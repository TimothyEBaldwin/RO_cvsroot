head	1.20;
access;
symbols
	Browse-2_16:1.20
	Browse-2_15:1.20
	Browse-2_14:1.20
	Browse-2_13:1.20
	Browse-2_12:1.20
	Browse-2_11:1.19
	Browse-2_10:1.19
	Browse-2_09:1.19
	ahodgkin_208_i4_2:1.19
	ahodgkin_208_i4:1.17
	ahodgkin_208_i3:1.17
	ahodgkin_208_i2:1.17
	ahodgkin_208_i1:1.17
	ahodgkin_207release:1.16
	ahodgkin_206release:1.15
	ahodgkin_205release:1.14
	ahodgkin_204release:1.14
	ahodgkin_202release:1.14
	ahodgkin_201release:1.14
	ahodgkin_200release:1.14
	ahodgkin_133beta:1.14
	ahodgkin_132beta:1.14
	ahodgkin_131beta:1.14
	ahodgkin_130beta:1.13
	ahodgkin_129:1.13
	ahodgkin_128beta:1.12
	ahodgkin_128alpha:1.12
	ahodgkin_127beta2:1.11
	ahodgkin_127beta:1.11
	ahodgkin_126beta:1.10
	ahodgkin_AW97patch:1.9
	ahodgkin_AW97:1.7;
locks; strict;
comment	@# @;


1.20
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.14.08.45.07;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.31.15.58.42;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	99.03.30.15.51.55;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	98.09.23.13.18.13;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	98.07.09.10.27.17;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	98.01.31.10.55.26;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.12.12.11.17.55;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.12.02.16.13.55;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.11.19.10.29.05;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.10.30.17.11.08;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.10.24.14.09.18;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.10.22.13.15.56;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.10.16.13.23.15;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.10.13.07.06.59;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.10.09.10.52.06;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.10.07.17.03.44;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.10.07.13.51.59;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.10.06.15.18.23;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.10.05.17.16.23;	author ahodgkin;	state Exp;
branches;
next	;


desc
@@


1.20
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Object.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Handling OBJECT, APPLET and EMBED.                */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 05-Oct-1997 (ADH): Created.                       */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>
#include <tboxlibs/flex.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>

#include "Global.h"
#include "FromROSLib.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "Fetch.h" /* (Which itself includes URLstat.h) */
#include "FetchHTML.h"
#include "Filetypes.h"
#include "Images.h"
#include "Memory.h"
#include "MimeMap.h"
#include "MiscDefs.h"
#include "PlugIn.h"
#include "Redraw.h"
#include "Reformat.h"
#include "TokenUtils.h"
#include "Toolbars.h"
#include "URLutils.h"
#include "URLveneer.h"
#include "Windows.h"

#include "Object.h"

/* Static function prototypes */

static int               object_get_token_object    (const browser_data * b, const HStream * restrict token);
static _kernel_oserror * object_get_object_size     (browser_data * b, int object, BBox * restrict size);
static _kernel_oserror * object_set_object_size     (browser_data * b, int object, BBox * size);
static int               object_get_object_position (const browser_data * b, const int object, int * restrict x, int * restrict y);
static _kernel_oserror * object_get_object_plugin   (const browser_data * b, const int object, unsigned int * restrict plugin_instance, unsigned int * restrict plugin_task);
static _kernel_oserror * object_set_object_plugin   (const browser_data * b, const int object, const unsigned int plugin_instance, const unsigned int plugin_task);

/**************************************************************/
/* object_retrieve_filetype()                                 */
/*                                                            */
/* Given a browser and token relative to an OBJECT, APPLET or */
/* EMBED, plus an optional mimetype or data (URL leaf) field, */
/* return an appropriate filetype from the mimetype or URL.   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the object;                                    */
/*                                                            */
/*             Pointer to an HStream struct relevant to the   */
/*             object;                                        */
/*                                                            */
/*             Pointer to the MIME type (if any) for the      */
/*             object;                                        */
/*                                                            */
/*             Pointer to the URL (if any) for the object,    */
/*             which may be relative rather than absolute.    */
/*                                                            */
/*             Pointer to a char * which will be updated, if  */
/*             possible, to point to an absolute form of the  */
/*             URL given (may be NULL, and may end up holding */
/*             NULL on exit). This is allocated by HTMLLib    */
/*             within the context of the HStream given above, */
/*             and so is freed whenever the stream is.        */
/**************************************************************/

int object_retrieve_filetype
    (
      const browser_data  * restrict b,
      const HStream       * restrict t,
      const char          * restrict type,
      const char          * restrict data,
      const char         ** restrict absolute
    )
{
  const char * current  = NULL;
  const char * newdata  = NULL;
  int          filetype = -1;

  dprintf(("Plug", "object_retrieve_filetype: For type '%s' / data '%s'\n", type ? type : "<NULL>", data ? data : "<NULL>"));

  if (absolute) *absolute = NULL;

  /* Must relativise the data URL... */

  if (data && *data)
  {
    current = browser_base_url(b);

    if (current)
    {
      newdata = HtmlRelativiseURL(current, data, t);
      if (absolute) *absolute = newdata;
    }
  }

  /* If we have a Mime type, use it */

  if (type && *type)
  {
    if (mimemap_mime_to_riscos(type, &filetype)) filetype = -1;
  }

  /* Otherwise, try to work it out from the filename extension */

  if (newdata)
  {
    url_description * d = urlutils_return_description(newdata);

    if (d && d->path)
    {
      const char * ext = strrchr(d->path, '.');

      if (ext)
      {
        if (mimemap_extension_to_riscos(ext, &filetype)) filetype = -1;
      }

      urlutils_free_description(d);
    }
  }

  dprintf(("Plug", "object_retrieve_filetype: Returning &%X\n", filetype));

  return filetype;
}

/**************************************************************/
/* object_new_object()                                        */
/*                                                            */
/* Adds a structure for a new Object to a browser's array of  */
/* Objects.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct to add to;    */
/*                                                            */
/*             Pointer to a token representing the Object     */
/*             (OBJECT, EMBED or APPLET tag).                 */
/**************************************************************/

_kernel_oserror * object_new_object(browser_data * b, HStream * t)
{
  const char * data;
  const char * type;

  /* If this isn't an Object token, do nothing (well, */
  /* complain about it in TRACE builds).              */

  if (!t || !ISOBJECT(t))
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Token %08x passed to object_new_object does not represent an OBJECT, APPLET or EMBED tag",
              (int) t);

      return &erb;

    #endif

    return NULL;
  }

  /* Allocate memory for the item */

  RetError(memory_set_chunk_size(b,
                                 NULL,
                                 CK_OBJB,
                                 (b->nobjects + 1) * sizeof(object_info)));

  /* Fill in the new item */

  b->odata[b->nobjects].plugin_instance_handle = 0;
  b->odata[b->nobjects].plugin_task_handle     = 0;
  b->odata[b->nobjects].token                  = t;

  /* Until this is seen by the user, open it off-screen to avoid */
  /* having to send out lots of reposition calls during the main */
  /* page reformat.                                              */

  b->odata[b->nobjects].x                      = -1;
  b->odata[b->nobjects].y                      = -1;

  /* Initially set invalid widths / heights so that it must be */
  /* worked out properly later.                                */

  b->odata[b->nobjects].w                      = -1;
  b->odata[b->nobjects].h                      = -1;

  /* Set up initial flags values */

  b->odata[b->nobjects].isimage                = 0;
  b->odata[b->nobjects].isplugin               = 0;
  b->odata[b->nobjects].broadcast_sent         = 0;

  /* Finally, increment the objects counter */

  b->nobjects++;

  /* First, deal with object types we can handle inline, such */
  /* as images.                                               */

  data = HtmlOBJECTdata(t);
  type = HtmlOBJECTtype(t);

  if (data && *data)
  {
    const char * absolute;
    int          filetype = object_retrieve_filetype(b, t, type, data, &absolute);

    /* Is it an image we can handle? */

    if (
         filetype == FileType_PNG  ||
         filetype == FileType_GIF  ||
         filetype == FileType_JPEG ||
         filetype == FileType_TIFF ||
         filetype == FileType_XBM  ||
         filetype == FileType_DRAW ||
         filetype == FileType_BMP
       )
    {
      if (absolute)
      {
        /* If we've managed all that, call image_new_image */

        RetError(image_new_image(b,
                                 absolute,
                                 t,
                                 0,
                                 NULL));

        b->odata[b->nobjects - 1].isimage = 1;

        return NULL;
      }
    }
  }

  /* Deal with external objects */

  else data = HtmlOBJECTclassid(t);

  /* Since we've modified the 'data' source (i.e. where we're expecting */
  /* the URL to come from), we need to work the filetype out again.     */

  if (data && *data)
  {
    int cannot_handle = 0;

    /* Well OK, this looks like a Plug-In. But can we handle it? */
    /* First, check for Active-X.                                */

    if (!strncmp(data, "clsid:", 6)) cannot_handle = 1;

    /* Otherwise, check a Plug-In exists to handle the data type */

    else
    {
      int filetype = object_retrieve_filetype(b, t, type, data, NULL);

      if (filetype != -1)
      {
        char             var[32];
        _kernel_swi_regs r;

        /* Final check is to see if there's an Alias$@@PlugInType_xxx variable */

        sprintf(var, "Alias$@@PlugInType_%03X", filetype);

        r.r[0] = (int) var;
        r.r[1] = (int) NULL;
        r.r[2] = -1;
        r.r[3] = 0;
        r.r[4] = 0;

        /* *Not* _swix, we want the R2 value of 0 for 'unset'... */

        _kernel_swi(OS_ReadVarVal, &r, &r);

        if (!r.r[2]) cannot_handle = 1;
      }
      else cannot_handle = 1;
    }

    /* If we can handle it, flag this as a Plug-In */

    if (!cannot_handle) b->odata[b->nobjects - 1].isplugin = 1;

    /* Otherwise, use the alternative HTML stream here */

    else
    {
      int           depth, line, chunk;
       token_path * path = NULL;

      // For now - security blanket...

      /* Can't do anything if the next token has been preprocessed [somehow] */

      if (t->next && t->next->flags == HFlags_DealtWithToken)
      {
        #ifdef TRACE

          erb.errnum = Utils_Error_Custom_Normal;

          StrNCpy0(erb.errmess,
                   "Can't replace this object tag as later tokens have already been preprocessed, in object_new_object");

          show_error_ret(&erb);

        #else

          t = t;

        #endif
      }
      else
      {
        /* What line was the token in? */

        depth = tokenutils_line_range(b,
                                      t,
                                      &line,
                                      &chunk,
                                      NULL,
                                      NULL,
                                      &path);

        if (line >= 0)
        {
          /* If the line was found and we have a depth, the line */
          /* is in a table - find the base parent line of the    */
          /* table, so we can reformat it.                       */

          if (depth) line = path[depth - 1].line;
        }

        if (path) free(path);

        /* Right, only have to reformat if the token was in the */
        /* line list.                                           */

        if (line >= 0) reformat_format_from(b, line - 1, 0, -1);

        /* We now know that the object is no longer in any line */
        /* list, so it's safe to preprocess the alternate HTML  */
        /* stream and place that under the token.               */

        t->flags |= HFlags_IgnoreObject;

        /* Discard the new object */

        b->nobjects --;

        memory_set_chunk_size(b,
                              NULL,
                              CK_OBJB,
                              (b->nobjects + 1) * sizeof(object_info));

        if (HtmlOBJECTstream(t))
        {

// Eeek! Recursive calls back to this routine!
//
//            HStream * alt = HtmlOBJECTstream(t);
//
//            /* Preprocess the stream */
//
//            // Of course, this probably breaks forms if extra form fields
//            // are present as part of an ongoing FORM tag.
//
//            while (alt)
//            {
//              fetch_preprocess_token(b, alt);
//
//              alt = alt->next;
//            }
//
          /* Move it into the main token list */

          HtmlReplaceOBJECT(t);

          /* That's it; any subsequent reformatting takes care of the rest */

          return NULL;
        }
      }
    }
  }

  /* If this is a Plug-In, and we're supposed to launch them */
  /* as soon as possible, then launch it now.                */

  if (
       b->odata[b->nobjects - 1].isplugin &&
       choices.support_object             &&
       choices.plugin_control == Choices_PlugIns_ASAP
     )
  {
    BBox position;

    RetError(object_get_object_size(b, b->nobjects - 1, &position));

    /* Object position is currently invalid, so hide the Plug-In */
    /* by moving it off the top of the work area.                */

    position.xmax = (position.xmax - position.xmin);
    position.xmin = 0;
    position.ymax = (position.ymax - position.ymin) + 0x1000; /* 0x1000 to be (very) safe */
    position.ymin = 0x1000;

    b->odata[b->nobjects - 1].broadcast_sent = 1; /* Don't try over and over if the first gives an error */

    RetError(plugin_add_queue_item(b, t, &position));
  }

  return NULL;
}

/**************************************************************/
/* object_discard()                                           */
/*                                                            */
/* Discards all Objects held by a given browser.              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Objects.                                   */
/**************************************************************/

_kernel_oserror * object_discard(browser_data * b)
{
  _kernel_oserror * e = NULL;
  _kernel_oserror * local;
  int               i;

  /* Close down any Plug-Ins */

  for (i = 0; i < b->nobjects; i++)
  {
    if (
         b->odata[i].isplugin       &&
         b->odata[i].broadcast_sent &&
         b->odata[i].plugin_task_handle
       )
    {
      unsigned int   instance;
      browser_data * browser;

      e = plugin_obtain_instance(b, b->odata[i].token, &instance);

      if (!e)
      {
        /* Close down any fetches */

        browser = last_browser;

        while (browser)
        {
          if (
               browser->pstream                                      &&
               browser->pstream->browser_instance_handle == instance
             )
             windows_close_browser(browser);

          browser = browser->previous;
        }

        /* Close the plug-in itself */

        e = plugin_send_close(instance,
                              b->odata[i].plugin_task_handle,
                              b->odata[i].plugin_instance_handle);
      }
    }
  }

  plugin_flush_instance_entries(b);

  /* Only set 'e' from the queue flush if the above call didn't */
  /* generate an error.                                         */

  local = plugin_flush_queue(b, 1);
  if (!e) e = local;

  /* Remove the Objects themselves. */

  b->nobjects = 0;

  memory_set_chunk_size(b, NULL, CK_OBJB, 0);

  return e;
}

/**************************************************************/
/* object_get_token_object()                                  */
/*                                                            */
/* Return the number of the Object represented in the given   */
/* browser by the given token.                                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Pointer to a token representing the Object     */
/*             (OBJECT, EMBED or APPLET tag).                 */
/*                                                            */
/* Returns:    Number of the Object from 0 to number of       */
/*             Objects minus 1, or -1 if the Object cannot be */
/*             found.                                         */
/**************************************************************/

static int object_get_token_object
           (
             const browser_data *          b,
             const HStream      * restrict token
           )
{
  int found = -1;
  int i;

  /* If this isn't an Object token, do nothing (well, */
  /* complain about it in TRACE builds).              */

  if (!token || !ISOBJECT(token))
  {
    #ifdef TRACE

      if (!ISOBJECT(token))
      {
        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Token %08x passed to object_get_token_object does not represent an OBJECT, APPLET or EMBED tag",
                (int) token);

        show_error_ret(&erb);
      }

    #endif

    return -1;
  }

  /* Otherwise, try to find the item */

  for (i = 0; i < b->nobjects; i++)
  {
    if (b->odata[i].token == token)
    {
      found = i;
      break;
    }
  }

  return found;
}

/**************************************************************/
/* object_get_object_size()                                   */
/*                                                            */
/* Returns the size of a given Object.                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct to add to;    */
/*                                                            */
/*             Number of the Object, from 0 to number of      */
/*             Objects minus 1;                               */
/*                                                            */
/*             Pointer to a BBox, in which the size of the    */
/*             Object will be written.                        */
/**************************************************************/

static _kernel_oserror * object_get_object_size
                         (
                           browser_data *          b,
                           int                     object,
                           BBox         * restrict size
                         )
{
  HStream * tp;

  /* Can't do anything without a bounding box! */

  if (!size)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess, "Null bounding box pointer passed to object_get_object_size");
      return &erb;

    #endif

    return NULL;
  }

  /* Fill in zeros to start with */

  size->xmin = size->ymin = 0;
  size->xmax = size->ymax = 0;

  /* Is this a valid object number? */

  if (object < 0 || object >= b->nobjects)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid object number %d for passed to object_get_object_size (browser %08x, nobjects = %d)",
              object,
              (int) b,
              b->nobjects);

      return &erb;

    #endif

    return NULL;
  }

  /* If this is an image, return through the image sizing routines */

  if (b->odata[object].isimage)
  {
    return image_get_token_image_size(b,
                                      b->odata[object].token,
                                      size);
  }

  /* Find its size */

  tp = b->odata[object].token;

  /* If we haven't already, work this out */

  if (b->odata[object].w < 0 || b->odata[object].h < 0)
  {
    int w, h;
    int available_w = redraw_display_width (b, b->cell);
    int available_h = redraw_display_height(b, b->cell);

    /* Deal with % specifiers as well as pixels */

    if (OBJECT_HAS_WIDTH(tp))
    {
      switch (OBJECT_WIDTH_UNITS(tp))
      {
        default:
        case UNITS_PIXELS:  w = OBJECT_WIDTH(tp) * 2; break;
        case UNITS_PERCENT: w = available_w * OBJECT_WIDTH(tp) / 100; break;
      }
    }
    else w = 0;

    if (OBJECT_HAS_HEIGHT(tp))
    {
      switch (OBJECT_HEIGHT_UNITS(tp))
      {
        default:
        case UNITS_PIXELS:  h = OBJECT_HEIGHT(tp) * 2; break;
        case UNITS_PERCENT: h = available_h * OBJECT_HEIGHT(tp) / 100; break;
      }
    }
    else h = 0;

    size->xmax = w;
    size->ymax = h;

    b->odata[object].w = w;
    b->odata[object].h = h;
  }

  /* Otherwise, get the prestored value */

  else
  {
    size->xmax = b->odata[object].w;
    size->ymax = b->odata[object].h;
  }

  /* Don't allow zero in any direction */

  if (size->xmax == 0 || size->ymax == 0)
  {
    const char * text = HtmlOBJECTstandby(b->odata[object].token);

    reformat_get_placeholder_size(b, b->odata[object].token, text, size);

    b->odata[object].w = size->xmax - size->xmin;
    b->odata[object].h = size->ymax - size->ymin;
  }

  return NULL;
}

/**************************************************************/
/* object_get_token_object_size()                             */
/*                                                            */
/* Returns the size of a given Object.                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Pointer to a token representing the Object     */
/*             (OBJECT, EMBED or APPLET tag);                 */
/*                                                            */
/*             Pointer to a BBox, in which the size of the    */
/*             Object will be written.                        */
/**************************************************************/

_kernel_oserror * object_get_token_object_size
                  (
                    browser_data  * restrict b,
                    const HStream * restrict t,
                    BBox          * restrict size
                  )
{
  return object_get_object_size(b, object_get_token_object(b, t), size);
}

/**************************************************************/
/* object_set_object_size()                                   */
/*                                                            */
/* Sets the size of a given Object.                           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Number of the Object, from 0 to number of      */
/*             Objects minus 1;                               */
/*                                                            */
/*             Pointer to a BBox, from which the xmax - xmin  */
/*             and ymax - ymin values are used to set the     */
/*             size.                                          */
/**************************************************************/

static _kernel_oserror * object_set_object_size(browser_data * b, int object, BBox * size)
{
  int width, height;

  /* Can't do anything without a bounding box! */

  if (!size)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess, "Null bounding box pointer passed to object_get_object_size");
      return &erb;

    #endif

    return NULL;
  }

  /* Work out the width and height */

  width  = size->xmax - size->xmin;
  height = size->ymax - size->ymin;

  /* Is this a valid object number? */

  if (object < 0 || object >= b->nobjects)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid object number %d for passed to object_get_object_size (browser %08x, nobjects = %d)",
              object,
              (int) b,
              b->nobjects);

      return &erb;

    #endif

    return NULL;
  }

  /* If this is an image, need to set the image's size */

  if (b->odata[object].isimage) RetError(image_set_token_image_size(b,
                                                                    b->odata[object].token,
                                                                    size));

  /* Set also the width and height values for the Object */

  b->odata[object].w = width;
  b->odata[object].h = height;

  return NULL;
}

/**************************************************************/
/* object_set_token_object_size()                             */
/*                                                            */
/* Sets the size of a given Object.                           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Pointer to a token representing the Object     */
/*             (OBJECT, EMBED or APPLET tag);                 */
/*                                                            */
/*             Pointer to a BBox, from which the xmax - xmin  */
/*             and ymax - ymin values are used to set the     */
/*             size.                                          */
/**************************************************************/

_kernel_oserror * object_set_token_object_size(browser_data * b, HStream * t, BBox * size)
{
  return object_set_object_size(b, object_get_token_object(b, t), size);
}

/**************************************************************/
/* object_get_object_position()                               */
/*                                                            */
/* Returns the x and y fields of the object_info structure    */
/* for a given Object.                                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Number of the Object;                          */
/*                                                            */
/*             Pointer to an int, in which the X coordinate   */
/*             is returned;                                   */
/*                                                            */
/*             Pointer to an int, in which the Y coordinate   */
/*             is returned.                                   */
/*                                                            */
/* Returns:    1 if the object number is invalid or 0 for     */
/*             success.                                       */
/*                                                            */
/* Assumes:    Neither pointer is NULL.                       */
/**************************************************************/

static int object_get_object_position
           (
             const browser_data *          b,
             const int                     object,
             int                * restrict x,
             int                * restrict y
           )
{
  if (object < 0 || object >= b->nobjects) return 1;

  *x = b->odata[object].x;
  *y = b->odata[object].y;

  return 0;
}

/**************************************************************/
/* object_get_token_object_position()                         */
/*                                                            */
/* Returns the x and y fields of the object_info structure    */
/* for a given Object.                                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Pointer to the token representing the Object;  */
/*                                                            */
/*             Pointer to an int, in which the X coordinate   */
/*             is returned;                                   */
/*                                                            */
/*             Pointer to an int, in which the Y coordinate   */
/*             is returned.                                   */
/*                                                            */
/* Returns:    1 if the object could not be found from the    */
/*             given token, or 0 for success.                 */
/*                                                            */
/* Assumes:    Neither pointer is NULL.                       */
/**************************************************************/

int object_get_token_object_position
    (
      const browser_data * restrict b,
      const HStream      * restrict t,
      int                * restrict x,
      int                * restrict y
    )
{
  int object = object_get_token_object(b, t);

  return object_get_object_position(b, object, x, y);
}

/**************************************************************/
/* object_set_token_object_position()                         */
/*                                                            */
/* Sets the x and y fields of the object_info structure for a */
/* given Object, so that it may be [partially] plotted during */
/* a fetch.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the object;                                    */
/*                                                            */
/*             Pointer to the token representing the Object;  */
/*                                                            */
/*             X coordinate (window coords);                  */
/*                                                            */
/*             Y coordinate (window coords).                  */
/*                                                            */
/* Returns:    Number of the Object that was changed, or -1   */
/*             if none could be found for the given token.    */
/**************************************************************/

int object_set_token_object_position
    (
      browser_data  *          b,
      const HStream * restrict t,
      int                      x,
      int                      y
    )
{
  int object = object_get_token_object(b, t);

  #ifdef TRACE
    {
      char debugbuf[1024];
      sprintf(debugbuf,"object_set_token_object_position: Called for %p, %p at %d, %d",b,t,x,y);
      dprintf(("Plug", "%s\n",debugbuf));
    }
  #endif

  /* If an object was found, set the x and y coordinates */

  if (object >= 0)
  {
    int oldx, oldy;

    oldx = b->odata[object].x;
    oldy = b->odata[object].y;

    /* *Don't* invalidate x and y positions for Objects; this causes */
    /* too many reshape messages for some PlugIns and can lead to    */
    /* items left with out-of-date position information.             */
    /*                                                               */
    /* Objects are initialised to be in an invalidated position, of  */
    /* course, so still need to check for that later in the code.    */

    if (x != -1 && y != -1)
    {
      b->odata[object].x = x;
      b->odata[object].y = y;
    }

    /* If this is is acting as an image, need to update */
    /* the image structure too.                         */

    if (b->odata[object].isimage) image_set_token_image_position(b, t, x, y);

    /* If this item is a Plug-In, this could be the first time we've */
    /* known for sure what position the item should be plotted at;   */
    /* pr we may want to tell the Plug-In to move to a new position. */

    if (b->odata[object].isplugin)
    {
      BBox position;

      dprintf(("Plug", "object_set_token_object_position: Is Plug-In\n"));

      show_error_ret(object_get_object_size(b, object, &position));

      /* If this is the first time we've tried to set a position for */
      /* the Object and a broadcast to start up an associated        */
      /* Plug-In has not yet been sent, add the Plug-In to the       */
      /* 'ready to launch' queue.                                    */

      if (!b->odata[object].broadcast_sent)
      {
        int start_now = 0;

        /* Only do this for valid Object positions */

        if (x >= 0)
        {
          /* Object position is valid, we can place it in the right position initially */

          position.xmin += x;
          position.ymin += y;
          position.xmax += x;
          position.ymax += y;

          if (choices.plugin_control != Choices_PlugIns_Never && choices.support_object) start_now = 1;
        }

        if (start_now)
        {
          b->odata[object].broadcast_sent = 1; /* Don't try over and over if the first gives an error */

          dprintf(("Plug", "object_set_token_object_position: Starting Plug-In\n"));

          show_error_ret(plugin_add_queue_item(b, t, &position));
        }

        #ifdef TRACE

          else dprintf(("Plug", "object_set_token_object_position: Choices say not to start Plug-In yet\n"));

        #endif
      }

      /* If the Plug-In has been started, and the position of the Object */
      /* has changed, tell the Plug-In to move.                          */

      else if (
                (
                  oldx != x ||
                  oldy != y
                )
                && b->odata[object].plugin_task_handle
              )
      {
        unsigned int instance;

        if (x < 0)
        {
          /* Object position is invalid */

          position.xmax = (position.xmax - position.xmin);
          position.xmin = 0;
          position.ymax = (position.ymax - position.ymin) + 0x1000; /* 0x1000 to be (very) safe */
          position.ymax = 0x1000;
        }
        else
        {
          /* Object position has been updated */

          position.xmin += x;
          position.ymin += y;
          position.xmax += x;
          position.ymax += y;
        }

        /* Send the reshape message */

        dprintf(("Plug", "object_set_token_object_position: Moving Plug-In\n"));

        if (!plugin_obtain_instance(b, b->odata[object].token, &instance))
        {
          show_error_ret(plugin_send_original_reshape(instance,
                                                      b->odata[object].plugin_task_handle,
                                                      b->odata[object].plugin_instance_handle,
                                                      &position));
        }
      }
    }
  }

  dprintf(("Plug", "object_set_token_object_position: Successful, returning Object number %d\n",object));

  return object;
}

/**************************************************************/
/* object_return_info()                                       */
/*                                                            */
/* Return information on an Object identified by a Plug-In    */
/* instance handle.                                           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct holding the   */
/*             Objects to search;                             */
/*                                                            */
/*             Plug-In instance handle;                       */
/*                                                            */
/*             Pointer to an HStream *, in which the token    */
/*             the Object is represen- ting is written;       */
/*                                                            */
/*             Pointer to an int, in which the Plug-In task   */
/*             handle for this Object is written.             */
/*                                                            */
/* Returns:    Returns 1 if the item was found, else 0. If 0, */
/*             the contents of the given pointers are not     */
/*             changed.                                       */
/*                                                            */
/* Assumes:    Either of the last two pointers may be NULL.   */
/**************************************************************/

int object_return_info(browser_data * b, unsigned int plugin_instance_handle, HStream ** token, unsigned int * plugin_task)
{
  int i;

  for (i = 0; i < b->nobjects; i++)
  {
    if (b->odata[i].plugin_instance_handle == plugin_instance_handle)
    {
      /* Found it */

      if (token)       *token       = b->odata[i].token;
      if (plugin_task) *plugin_task = b->odata[i].plugin_task_handle;

      return 1;
    }
  }

  /* Found nothing */

  return 0;
}

/**************************************************************/
/* object_get_token_object_box()                              */
/*                                                            */
/* Returns a bounding box filled in with parent window work   */
/* area coordinates for a given Object.                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object - font handle data may be updated;  */
/*                                                            */
/*             Pointer to the token representing the Object;  */
/*                                                            */
/*             Pointer to a BBox to return the work area      */
/*             coordinates describing the Object's size.      */
/*                                                            */
/* Returns:    1 for failure, 0 for success.                  */
/**************************************************************/

int object_get_token_object_box
    (
      browser_data  * restrict b,
      const HStream * restrict t,
      BBox          * restrict box
    )
{
  int object = object_get_token_object(b, t);
  int x, y;

  if (object < 0 || object >= b->nobjects || !box) return 1;

  /* Get the Object bounding box */

  if (object_get_object_size(b, object, box)) return 1;

  /* Get the Object position */

  if (object_get_object_position(b, object, &x, &y)) return 1;

  /* Return if the Object position is invalidated at the moment */

  if (x < 0) return 1;

  /* Otherwise add the coordinates */

  box->xmin += x;
  box->ymin += y;
  box->xmax += x;
  box->ymax += y;

  return 0;
}

/**************************************************************/
/* object_get_object_plugin()                                 */
/*                                                            */
/* Returns details of any Plug-In associated with a given     */
/* Object (referenced by number).                             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Number of the Object;                          */
/*                                                            */
/*             Pointer to an int, in which the Plug-In        */
/*             instance handle will be written;               */
/*                                                            */
/*             Pointer to an int, in which the Plug-In task   */
/*             handle will be written, or 0 if the Object     */
/*             does not have an associated Plug-In or can't   */
/*             be found.                                      */
/*                                                            */
/* Assumes:    Either pointer may be NULL.                    */
/**************************************************************/

static _kernel_oserror * object_get_object_plugin
                         (
                           const browser_data *          b,
                           const int                     object,
                           unsigned int       * restrict plugin_instance,
                           unsigned int       * restrict plugin_task
                         )
{
  /* Fill in zeros to start with */

  if (plugin_instance) *plugin_instance = 0;
  if (plugin_task)     *plugin_task     = 0;

  /* Is this a valid object number? */

  if (object < 0 || object >= b->nobjects)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid object number %d passed to object_get_token_object_plugin (browser %08x, nobjects = %d)",
              object,
              (int) b,
              b->nobjects);

      return &erb;

    #endif

    return NULL;
  }

  /* If not associated with a Plug-In, exit */

  if (!b->odata[object].isplugin) return NULL;

  /* Otherwise, return the details */

  if (plugin_instance) *plugin_instance = b->odata[object].plugin_instance_handle;
  if (plugin_task)     *plugin_task     = b->odata[object].plugin_task_handle;

  /* Finished */

  return NULL;
}

/**************************************************************/
/* object_get_token_object_plugin()                           */
/*                                                            */
/* Returns details of any Plug-In associated with a given     */
/* Object (referenced by token).                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Pointer to the token representing the Object;  */
/*                                                            */
/*             Pointer to an int, in which the Plug-In        */
/*             instance handle will be written;               */
/*                                                            */
/*             Pointer to an int, in which the Plug-In task   */
/*             handle will be written, or 0 if the Object     */
/*             does not have an associated Plug-In or can't   */
/*             be found.                                      */
/*                                                            */
/* Assumes:    Either pointer may be NULL.                    */
/**************************************************************/

_kernel_oserror * object_get_token_object_plugin
                  (
                    const browser_data * restrict b,
                    const HStream      * restrict t,
                    unsigned int       * restrict plugin_instance,
                    unsigned int       * restrict plugin_task
                  )
{
  return object_get_object_plugin(b,
                                  object_get_token_object(b, t),
                                  plugin_instance,
                                  plugin_task);
}

/**************************************************************/
/* object_set_object_plugin()                                 */
/*                                                            */
/* Sets details of any Plug-In associated with a given Object */
/* (referenced by number).                                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Number of the Object;                          */
/*                                                            */
/*             Plug-In instance handle to set;                */
/*                                                            */
/*             Plug-In task handle to set.                    */
/*                                                            */
/* Assumes:    Either pointer may be NULL.                    */
/**************************************************************/

static _kernel_oserror * object_set_object_plugin
                         (
                           const browser_data * b,
                           const int            object,
                           const unsigned int   plugin_instance,
                           const unsigned int   plugin_task
                         )
{
  /* Is this a valid object number? */

  if (object < 0 || object >= b->nobjects)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid object number %d for passed to object_set_token_object_plugin (browser %08x, nobjects = %d)",
              object,
              (int) b,
              b->nobjects);

      return &erb;

    #endif

    return NULL;
  }

  /* If not associated with a Plug-In, exit */

  if (!b->odata[object].isplugin) return NULL;

  /* Otherwise, set the details */

  b->odata[object].plugin_instance_handle = plugin_instance;
  b->odata[object].plugin_task_handle     = plugin_task;

  /* Finished */

  return NULL;
}

/**************************************************************/
/* object_set_token_object_plugin()                           */
/*                                                            */
/* Sets details of any Plug-In associated with a given Object */
/* (referenced by token).                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Pointer to the token representing the Object   */
/*             (usually have to remember this when the        */
/*             initial Message_PlugIn_Open is sent);          */
/*                                                            */
/*             Plug-In instance handle to set;                */
/*                                                            */
/*             Plug-In task handle to set.                    */
/*                                                            */
/* Assumes:    Either pointer may be NULL.                    */
/**************************************************************/

_kernel_oserror * object_set_token_object_plugin
                  (
                    const browser_data * restrict b,
                    const HStream      * restrict t,
                    const unsigned int            plugin_instance,
                    const unsigned int            plugin_task
                  )
{
  return object_set_object_plugin(b,
                                  object_get_token_object(b, t),
                                  plugin_instance,
                                  plugin_task);
}

/**************************************************************/
/* object_redraw()                                            */
/*                                                            */
/* Does a high level redraw of an Object, using an outline to */
/* show where the Object should be if it isn't plotted by     */
/* some other method.                                         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             Address of the token representing the OBJECT,  */
/*             APPLET or EMBED tag;                           */
/*                                                            */
/*             The X offset in window coords (so OS units) of */
/*             the left hand edge of the Object;              */
/*                                                            */
/*             The Y offset in window coords (so OS units) of */
/*             the bottom edge of the Object;                 */
/*                                                            */
/*             Pointer to a BBox conventionally initialised   */
/*             to describe the current graphics window or     */
/*             redraw area in OS units (e.g. from the         */
/*             'redraw_area' field of a Wimp redraw block).   */
/**************************************************************/

_kernel_oserror * object_redraw
                  (
                    browser_data  *          b,
                    const HStream * restrict token,
                    int                      x,
                    int                      y,
                    const BBox    * restrict gfxwin
                  )
{
  _kernel_oserror * e       = NULL;
  int               object  = object_get_token_object(b, token);
  int               plotted = 0;

  if (b->odata[object].isimage)
  {
    e = image_redraw(b,
                     token,
                     x,
                     y,
                     gfxwin);

    if (e == NULL) plotted = 1;
  }

  if (plotted == 0)
  {
    /* Plot a placeholder */

    BBox box;

    object_get_object_size(b, object, &box);

    box.xmin += x;
    box.ymin += y;
    box.xmax += x - box.xmin;
    box.ymax += y - box.ymin;

    box.xmin &= ~(wimpt_dx() - 1);
    box.ymin &= ~(wimpt_dy() - 1);

    redraw_draw_placeholder(b,
                            gfxwin,
                            &box,
                            token,
                            HtmlOBJECTstandby((HStream *) token));
  }

  return e;
}

/**************************************************************/
/* object_token_is_image()                                    */
/*                                                            */
/* Finds out whether an Object is acting as an an inline      */
/* image or not.                                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the object;                                    */
/*                                                            */
/*             Pointer to the token representing the Object.  */
/*                                                            */
/* Returns:    1 if the Object is acting as an inline image,  */
/*             else 0.                                        */
/**************************************************************/

int object_token_is_image
    (
      const browser_data *          b,
      const HStream      * restrict token
    )
{
  int object = object_get_token_object(b, token);

  if (object < 0 || object >= b->nobjects) return 0;
  else                                     return !!b->odata[object].isimage;
}
@


1.19
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d70 2
a71 2
static int               object_get_token_object    (browser_data * b, HStream * t);
static _kernel_oserror * object_get_object_size     (browser_data * b, int object, BBox * size);
d73 3
a75 3
static int               object_get_object_position (browser_data * b, int object, int * x, int * y);
static _kernel_oserror * object_get_object_plugin   (browser_data * b, int object, unsigned int * plugin_instance, unsigned int * plugin_task);
static _kernel_oserror * object_set_object_plugin   (browser_data * b, int object, unsigned int plugin_instance, unsigned int plugin_task);
d104 8
a111 1
int object_retrieve_filetype(browser_data * b, HStream * t, const char * type, const char * data, const char ** absolute)
d332 2
a333 2
      int          depth, line, chunk;
      token_path * path = NULL;
d549 5
a553 1
static int object_get_token_object(browser_data * b, HStream * t)
d561 1
a561 1
  if (!t || !ISOBJECT(t))
d565 1
a565 1
      if (!ISOBJECT(t))
d571 1
a571 1
                (int) t);
d585 1
a585 1
    if (b->odata[i].token == t)
d609 6
a614 1
static _kernel_oserror * object_get_object_size(browser_data * b, int object, BBox * size)
d749 6
a754 1
_kernel_oserror * object_get_token_object_size(browser_data * b, HStream * t, BBox * size)
d878 7
a884 1
static int object_get_object_position(browser_data * b, int object, int * x, int * y)
d917 7
a923 1
int object_get_token_object_position(browser_data * b, HStream * t, int * x, int * y)
d950 7
a956 1
int object_set_token_object_position(browser_data * b, HStream * t, int x, int y)
d1151 1
a1151 1
/*             the Object;                                    */
d1161 6
a1166 1
int object_get_token_object_box(browser_data * b, HStream * t, BBox * box)
d1217 7
a1223 1
static _kernel_oserror * object_get_object_plugin(browser_data * b, int object, unsigned int * plugin_instance, unsigned int * plugin_task)
d1287 7
a1293 1
_kernel_oserror * object_get_token_object_plugin(browser_data * b, HStream * t, unsigned int * plugin_instance, unsigned int * plugin_task)
d1319 7
a1325 1
static _kernel_oserror * object_set_object_plugin(browser_data * b, int object, unsigned int plugin_instance, unsigned int plugin_task)
d1382 7
a1388 1
_kernel_oserror * object_set_token_object_plugin(browser_data * b, HStream * t, unsigned int plugin_instance, unsigned int plugin_task)
a1405 4
/*             Pointer to a RedrawWindowBlock struct which    */
/*             holds information about the current redraw     */
/*             session;                                       */
/*                                                            */
d1413 16
a1428 4
/*             the bottom edge of the Object.                 */
/**************************************************************/

_kernel_oserror * object_redraw(browser_data * b, WimpRedrawWindowBlock * r, HStream * token, int x, int y)
d1436 7
a1442 2
    e = image_redraw(b, r, token, x, y);
    if (!e) plotted = 1;
d1445 1
a1445 1
  if (!plotted)
d1462 1
a1462 1
                            r,
d1465 1
a1465 1
                            HtmlOBJECTstandby(token));
d1486 5
a1490 1
int object_token_is_image(browser_data * b, HStream * t)
d1492 1
a1492 1
  int object = object_get_token_object(b, t);
@


1.18
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a43 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d110 1
a110 3
  #ifdef TRACE
    if (tl & (1u<<30)) Printf("object_retrieve_filetype: For type '%s' / data '%s'\n", type ? type : "<NULL>", data ? data : "<NULL>"); 
  #endif
d114 13
d136 1
a136 1
  else if (data && *data)
d138 1
a138 3
    /* Must relativise the data URL... */

    current = browser_base_url(b);
d140 1
a140 1
    if (current)
d142 1
a142 2
      newdata = HtmlRelativiseURL(current, data, t);
      if (absolute) *absolute = newdata;
d144 1
a144 1
      if (newdata)
d146 2
a147 10
        url_description * d = urlutils_return_description(newdata);

        if (d && d->path)
        {
          const char * ext = strrchr(d->path, '.');

          if (ext)
          {
            if (mimemap_extension_to_riscos(ext, &filetype)) filetype = -1;
          }
d149 1
a149 3
          urlutils_free_description(d);
        }
      }
d153 1
a153 3
  #ifdef TRACE
    if (tl & (1u<<30)) Printf("object_retrieve_filetype: Returning &%X\n", filetype);
  #endif
a921 1
    if (tl & (1u<<30))
d925 1
a925 1
      Printf("%s\n",debugbuf);
d964 1
a964 3
      #ifdef TRACE
        if (tl & (1u<<30)) Printf("object_set_token_object_position: Is Plug-In\n");
      #endif
d995 1
a995 3
          #ifdef TRACE
            if (tl & (1u<<30)) Printf("object_set_token_object_position: Starting Plug-In\n");
          #endif
d1002 1
a1002 1
          else if (tl & (1u<<30)) Printf("object_set_token_object_position: Choices say not to start Plug-In yet\n");
d1041 1
a1041 3
        #ifdef TRACE
          if (tl & (1u<<30)) Printf("object_set_token_object_position: Moving Plug-In\n");
        #endif
d1054 1
a1054 3
  #ifdef TRACE
    if (tl & (1u<<30)) Printf("object_set_token_object_position: Successful, returning Object number %d\n",object);
  #endif
@


1.17
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d15 12
a26 9
/***************************************************/
/* File   : Object.c                               */
/*                                                 */
/* Purpose: Handling OBJECT, APPLET and EMBED.     */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 05-Oct-97: Created.                    */
/***************************************************/
d32 16
a47 2
#include "swis.h"
#include "flex.h"
a48 9
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "toolbox.h"

#include "svcprint.h"
d67 1
d82 96
a177 13
/*************************************************/
/* object_new_object()                           */
/*                                               */
/* Adds a structure for a new Object to a        */
/* browser's array of Objects.                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             to add to;                        */
/*                                               */
/*             Pointer to a token representing   */
/*             the Object (OBJECT, EMBED or      */
/*             APPLET tag).                      */
/*************************************************/
d240 2
a241 1
  /* Now deal with data types we can handle inline */
d248 2
a249 23
    int filetype;

    /* If we have a Mime type, use it */

    if (type && *type)
    {
      if (mimemap_mime_to_riscos(type, &filetype)) filetype = FileType_DATA;
    }

    /* Otherwise, try to work it out from the filename extension */

    else
    {
      const char * ext;

      ext = strrchr(data, '.');

      if (ext)
      {
        if (mimemap_extension_to_riscos(ext, &filetype)) filetype = FileType_DATA;
      }
      else filetype = FileType_DATA;
    }
d263 1
a263 9
      const char * current;
      const char * newdata;

      /* Must relativise the data URL... */

      current = browser_fetch_url(b);
      if (!current) current = browser_current_url(b);

      if (current)
d265 1
a265 1
        newdata = HtmlRelativiseURL(current, data, t);
d267 5
a271 9
        if (newdata)
        {
          /* If we've managed all that, call image_new_image */

          RetError(image_new_image(b,
                                   newdata,
                                   t,
                                   0,
                                   NULL));
d273 1
a273 1
          b->odata[b->nobjects - 1].isimage = 1;
d275 1
a275 2
          return NULL;
        }
d284 3
d300 1
a300 2
      const char * type = HtmlOBJECTcodetype(t);
      const char * ext  = strrchr(data, '.');
d302 1
a302 4
      /* Can't handle it if there's no extension or code type */

      if (!ext && (!type || (type && !*type))) cannot_handle = 1;
      else
d304 2
a305 1
        int filetype;
d307 1
a307 1
        /* Can't handle it if we don't have a Mime map entry for it */
d309 1
a309 15
        if (type)
        {
          if (mimemap_mime_to_riscos(type, &filetype)) cannot_handle = 1;
        }
        else
        {
          if (mimemap_extension_to_riscos(ext, &filetype)) cannot_handle = 1;
        }

        if (!cannot_handle)
        {
          char             var[32];
          _kernel_swi_regs r;

          /* Final check is to see if there's an Alias$@@PlugInType_xxx variable */
d311 5
a315 1
          sprintf(var, "Alias$@@PlugInType_%03X", filetype);
d317 1
a317 5
          r.r[0] = (int) var;
          r.r[1] = (int) NULL;
          r.r[2] = -1;
          r.r[3] = 0;
          r.r[4] = 0;
d319 1
a319 1
          /* *Not* _swix, we want the R2 value of 0 for 'unset'... */
d321 1
a321 4
          _kernel_swi(OS_ReadVarVal, &r, &r);

          if (!r.r[2]) cannot_handle = 1;
        }
d323 1
d461 8
a468 8
/*************************************************/
/* object_discard()                              */
/*                                               */
/* Discards all Objects held by a given browser. */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Objects.          */
/*************************************************/
d534 16
a549 17
/*************************************************/
/* object_get_token_object()                     */
/*                                               */
/* Return the number of the Object represented   */
/* in the given browser by the given token.      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to a token representing   */
/*             the Object (OBJECT, EMBED or      */
/*             APPLET tag).                      */
/*                                               */
/* Returns:    Number of the Object from 0 to    */
/*             number of Objects minus 1, or -1  */
/*             if the Object cannot be found.    */
/*************************************************/
d593 13
a605 15
/*************************************************/
/* object_get_object_size()                      */
/*                                               */
/* Returns the size of a given Object.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             to add to;                        */
/*                                               */
/*             Number of the Object, from 0 to   */
/*             number of Objects minus 1;        */
/*                                               */
/*             Pointer to a BBox, in which the   */
/*             size of the Object will be        */
/*             written.                          */
/*************************************************/
d727 14
a740 16
/*************************************************/
/* object_get_token_object_size()                */
/*                                               */
/* Returns the size of a given Object.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to a token representing   */
/*             the Object (OBJECT, EMBED or      */
/*             APPLET tag);                      */
/*                                               */
/*             Pointer to a BBox, in which the   */
/*             size of the Object will be        */
/*             written.                          */
/*************************************************/
d747 15
a761 15
/*************************************************/
/* object_set_object_size()                      */
/*                                               */
/* Sets the size of a given Object.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Number of the Object, from 0 to   */
/*             number of Objects minus 1;        */
/*                                               */
/*             Pointer to a BBox, from which the */
/*             xmax - xmin and ymax - ymin       */
/*             values are used to set the size.  */
/*************************************************/
d822 15
a836 16
/*************************************************/
/* object_set_token_object_size()                */
/*                                               */
/* Sets the size of a given Object.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to a token representing   */
/*             the Object (OBJECT, EMBED or      */
/*             APPLET tag);                      */
/*                                               */
/*             Pointer to a BBox, from which the */
/*             xmax - xmin and ymax - ymin       */
/*             values are used to set the size.  */
/*************************************************/
d843 22
a864 22
/*************************************************/
/* object_get_object_position()                  */
/*                                               */
/* Returns the x and y fields of the object_info */
/* structure for a given Object.                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Number of the Object;             */
/*                                               */
/*             Pointer to an int, in which the   */
/*             X coordinate is returned;         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Y coordinate is returned.         */
/*                                               */
/* Returns:    1 if the object number is invalid */
/*             or 0 for success.                 */
/*                                               */
/* Assumes:    Neither pointer is NULL.          */
/*************************************************/
d876 22
a897 24
/*************************************************/
/* object_get_token_object_position()            */
/*                                               */
/* Returns the x and y fields of the object_info */
/* structure for a given Object.                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object;                       */
/*                                               */
/*             Pointer to an int, in which the   */
/*             X coordinate is returned;         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Y coordinate is returned.         */
/*                                               */
/* Returns:    1 if the object could not be      */
/*             found from the given token, or 0  */
/*             for success.                      */
/*                                               */
/* Assumes:    Neither pointer is NULL.          */
/*************************************************/
d906 19
a924 21
/*************************************************/
/* object_set_token_object_position()            */
/*                                               */
/* Sets the x and y fields of the object_info    */
/* structure for a given Object, so that it may  */
/* be [partially] plotted during a fetch.        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object;                       */
/*                                               */
/*             X coordinate (window coords);     */
/*                                               */
/*             Y coordinate (window coords).     */
/*                                               */
/* Returns:    Number of the Object that was     */
/*             changed, or -1 if none could be   */
/*             found for the given token.        */
/*************************************************/
d934 1
a934 1
      sprintf(debugbuf,"object_set_token_object_positon: Called for %p, %p at %d, %d",b,t,x,y);
d975 1
a975 1
        if (tl & (1u<<30)) Printf("object_set_token_object_positon: Is Plug-In\n");
d1008 1
a1008 1
            if (tl & (1u<<30)) Printf("object_set_token_object_positon: Starting Plug-In\n");
d1056 1
a1056 1
          if (tl & (1u<<30)) Printf("object_set_token_object_positon: Moving Plug-In\n");
d1071 1
a1071 1
    if (tl & (1u<<30)) Printf("object_set_token_object_positon: Successful, returning Object number %d\n",object);
d1077 23
a1099 26
/*************************************************/
/* object_return_info()                          */
/*                                               */
/* Return information on an Object identified by */
/* a Plug-In instance handle.                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             holding the Objects to search;    */
/*                                               */
/*             Plug-In instance handle;          */
/*                                               */
/*             Pointer to an HStream *, in which */
/*             the token the Object is represen- */
/*             ting is written;                  */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Plug-In task handle for this      */
/*             Object is written.                */
/*                                               */
/* Returns:    Returns 1 if the item was found,  */
/*             else 0. If 0, the contents of the */
/*             given pointers are not changed.   */
/*                                               */
/* Assumes:    Either of the last two pointers   */
/*             may be NULL.                      */
/*************************************************/
d1123 16
a1138 19
/*************************************************/
/* object_get_token_object_box()                 */
/*                                               */
/* Returns a bounding box filled in with parent  */
/* window work area coordinates for a given      */
/* Object.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object;                       */
/*                                               */
/*             Pointer to a BBox to return the   */
/*             work area coordinates describing  */
/*             the Object's size.                */
/*                                               */
/* Returns:    1 for failure, 0 for success.     */
/*************************************************/
d1169 21
a1189 23
/*************************************************/
/* object_get_object_plugin()                    */
/*                                               */
/* Returns details of any Plug-In associated     */
/* with a given Object (referenced by number).   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Number of the Object;             */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Plug-In instance handle will be   */
/*             written;                          */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Plug-In task handle will be       */
/*             written, or 0 if the Object       */
/*             does not have an associated       */
/*             Plug-In or can't be found.        */
/*                                               */
/* Assumes:    Either pointer may be NULL.       */
/*************************************************/
d1233 21
a1253 24
/*************************************************/
/* object_get_token_object_plugin()              */
/*                                               */
/* Returns details of any Plug-In associated     */
/* with a given Object (referenced by token).    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object;                       */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Plug-In instance handle will be   */
/*             written;                          */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Plug-In task handle will be       */
/*             written, or 0 if the Object       */
/*             does not have an associated       */
/*             Plug-In or can't be found.        */
/*                                               */
/* Assumes:    Either pointer may be NULL.       */
/*************************************************/
d1263 17
a1279 17
/*************************************************/
/* object_set_object_plugin()                    */
/*                                               */
/* Sets details of any Plug-In associated with   */
/* a given Object (referenced by number).        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Number of the Object;             */
/*                                               */
/*             Plug-In instance handle to set;   */
/*                                               */
/*             Plug-In task handle to set.       */
/*                                               */
/* Assumes:    Either pointer may be NULL.       */
/*************************************************/
d1318 19
a1336 20
/*************************************************/
/* object_set_token_object_plugin()              */
/*                                               */
/* Sets details of any Plug-In associated with   */
/* a given Object (referenced by token).         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object (usually have to       */
/*             remember this when the initial    */
/*             Message_PlugIn_Open is sent);     */
/*                                               */
/*             Plug-In instance handle to set;   */
/*                                               */
/*             Plug-In task handle to set.       */
/*                                               */
/* Assumes:    Either pointer may be NULL.       */
/*************************************************/
d1346 23
a1368 25
/*************************************************/
/* object_redraw()                               */
/*                                               */
/* Does a high level redraw of an Object, using  */
/* an outline to show where the Object should be */
/* if it isn't plotted by some other method.     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to a RedrawWindowBlock    */
/*             struct which holds information    */
/*             about the current redraw session; */
/*                                               */
/*             Address of the token representing */
/*             the OBJECT, APPLET or EMBED tag;  */
/*                                               */
/*             The X offset in window coords (so */
/*             OS units) of the left hand edge   */
/*             of the Object;                    */
/*                                               */
/*             The Y offset in window coords (so */
/*             OS units) of the bottom edge of   */
/*             the Object.                       */
/*************************************************/
d1408 14
a1421 15
/*************************************************/
/* object_token_is_image()                       */
/*                                               */
/* Finds out whether an Object is acting as an   */
/* an inline image or not.                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object.                       */
/*                                               */
/* Returns:    1 if the Object is acting as an   */
/*             inline image, else 0.             */
/*************************************************/
@


1.16
log
@Another intermediate check-in, resources may not be up to date; items
most likely to be buildable are PhoenixJ and BrowseD. Done because I'm
about to make some rather dodgy changes to code otherwise unchanged
since the Customer browser and I may well have to back them out...

In Handlers.c now set the HFlags_HasBeenVisited bit of a token at the point
it is first clicked on. Means the link returns to a "visited" colour after
the highlight flash immediately. This will persist for as long as the browser
window is kept open on that page, though if the URL doesn't end up making it
into the history for whatever reason it would "unhighlight" on reload; fair
enough, really. The highlight is window-local, so there are no redraw worries
for other open windows with links to the same URL (though other same-URL
links on the same page aren't updated either).

All forms submissions force a reload (principally for eudoramail.com, but
many other sites have similar requirements).

!MkClean and !MkClnAll didn't correctly call the utility to strip Makefile
dependencies. Fixed.

On fetch closedown, fetchpage_preprocess_token could be called on a token
which had already been run through the preprocessor. Now checks the flags
word before proceeding.

Image RAM cache and garbage collection system implemented - see new Choices
file entries CollectAfter, FreeRAMLimit and UnusedImageLimit to get an
overview. This contains groundwork for JavaScript image array support.

More JavaScript support improvements. Any one window object will know its
parent, top, this, etc.; frames array working except for a frameset created
via. multiple documents; opener for something created with window.open is
currently not set and don't know why (property is being created, pointer to
valid object is held, but JS engine returns 'null'. Ho hum) - JSChain won't
work yet, then.
@
text
@d187 1
@


1.15
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d209 2
a210 1
                                   0));
@


1.14
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d60 1
d170 1
a170 1
      ext = data + strlen(data) - 1;
d172 1
a172 3
      while (ext >= data && *ext != '.') ext--;

      if (*ext == '.')
d392 1
a392 1
       choices.support_object    &&
d441 2
a442 1
      unsigned int instance;
d448 17
@


1.13
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d595 6
a600 3
  if (b->odata[object].isimage) return image_get_token_image_size(b,
                                                                  b->odata[object].token,
                                                                  size);
@


1.12
log
@Implemented Message_PlugIn_ReshapeRequest, Message_PlugIn_Status and
Message_PlugIn_Busy. Plug-in code more robust when given invalid
browser instance handles by the plug-in.

Line spacing is now calculated on the basis of the normal style base serif
font, with all other fonts being forced into that line height. This does
mean that an unusually tall (say) sans serif font may get clipped. It
appears to be the only way to get around wildly different baseline
depths returned from the font metrics - you can't work out line spacing
based on each different font style; the line spacing will vary.

Table heighting (as opposed to widthing...) improved considerably; rowspan
can no longer cause very tall cells in odd places. Having trouble getting
rid of the single pixel breaks between vertically adjacent cells, though
I've not tried too hard. Widthing, though, seems fairly badly broken at
present... :-/

Set/clear of page_is_text flag made more robust (it looked as though there
was the potential for this to get stuck in a set state, though I've never
see the front-end behave in a manner which indicates this is the case).
The reformatter will now decrease leading if this flag is set (plain text
pages look daft with a line spacing that is OK for 'rich' text pages).
No reformatting is done if the page width changes by dragging on the
resize icon, though toggle size / full screen will still reformat even
if the contents are only text (browser needs to sort out various width
flags at this point).

Cut down on excessive redrawing when reformatting due to a change in
window dimensions is not done. If display_width hasn't changed, then no
redraw is needed. If this causes redraw problems, then whatever is
changing display_width needs investigating. It shouldn't be kludged
(basically) by forcing a redraw instead of a reformat.

TT/PRE/etc. text can now have a non-100% aspect ratio. 80-90% looks
best (ArcWeb, for example, uses 86%). New option 'TTAspect' in
the Choices files.

Debug builds link to a non-debug Unicode library now; stops stderr
being dumped to the bottom left of the screen if you've not redirected
it in the Run file.

RISC OS 3.1 seems to need more initial WimpSlot than later OS versions.
The 64 deep nested table set gives a 'No stack for trap handler' error
(which it really means in this case!) without 800K, even though 3.71
is happy with just 640K. So, the !Run file checks if Boot$OSVersion
is exactly 300, 310 or 311, and sets the WimpSlot accordingly.

!Run[D] files now require latest fetcher module versions (URL 0.21,
File 0.31, HTTP 0.58).
@
text
@d88 2
a89 3
  _kernel_oserror * e;
  const char      * data;
  const char      * type;
d705 1
a705 2
  _kernel_oserror * e;
  int               width, height;
@


1.11
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d67 1
d132 6
d604 3
d638 11
d658 3
d689 98
d1022 49
@


1.10
log
@Removed 'The Onion' link from some Hotlist files. Time showed that the
site wasn't entirely Family Friendly (TM)... Removed Shift Control (it's
gone offline now), and corrected the Telegraph URL from ...the-telegraph...
to just ...telegraph...

StrongHelp manual generator now tries to work out the number of lines in
the table on the root page more intelligently.

Plug-in support extended to handle Shockwave. Quite a lot of underlying
work for this, including a pseudo cache system for temporary files.

Bug in redraw routines: they plotted background images within table
cells, when nothing should have been drawn. Oops. When background images
in cells are properly supported, this can get sorted out.

Tweaked vertical plot position of HRs (up to 4 OS units too high before due
to rounding).

Various Res file bits and pieces, Ursula build taken up to v1.26 beta
for release on the Browser site. *Note* not all resources are up to date!
This will be done after AW97.
@
text
@d120 3
a122 3
  b->odata[b->nobjects].plugin_instance_handle  = 0;
  b->odata[b->nobjects].plugin_task_handle      = 0;
  b->odata[b->nobjects].token                   = t;
d128 2
a129 2
  b->odata[b->nobjects].x                       = -1;
  b->odata[b->nobjects].y                       = -1;
d133 3
a135 3
  b->odata[b->nobjects].isimage                 = 0;
  b->odata[b->nobjects].isplugin                = 0;
  b->odata[b->nobjects].broadcast_sent          = 0;
d231 2
a232 1
      const char * ext = strrchr(data, '.');
d234 1
a234 1
      /* Can't handle it if there's no extension */
d236 1
a236 1
      if (!ext) cannot_handle = 1;
d243 4
a246 1
        if (mimemap_extension_to_riscos(ext, &filetype)) cannot_handle = 1;
d248 5
@


1.9
log
@Various fixes in the code required for Shockwave support (many invalid
assumptions about the OBJECT tag structure). Not finished yet though.

Played around with signal handling 'n' all that to try and get sensible
errors reported for aborts etc. using code by KBracey. Need a ROM patch
for _swix on RISC OS 3.7 upwards (or a local fixed copy of _swix),
otherwise should sort out most of the problems seen (mostly 'no stack
for trap handler' errors and a distinct lack of a register dump).

Plug-In view on redraw / ASAP choices now work as they should (ASAP
was previously broken).

Version numbers in Messages incremented to 1.25 (23 Oct 1997).

For Plug-In support, created new source file RMA.c/h to handle RMA
claims and releases, in an attempt to ensure leakage never happens.
As such, this source is *slightly* more advanced than that in the 1.25
AW '97 build, though functionally identical. Well, that is, at least
you can confirm zero RMA leakage with '-debug LMem' in TRACE builds now!

Intend to do a consistency check on comment syntax in all sources
shortly - I need to rebuild my StrongHelp manuals; can't keep track
of all of these new functions...
@
text
@d94 1
a94 1
  if (!t || t->tagno != TAG_OBJECT)
a211 4

    b->odata[b->nobjects - 1].isplugin = 1;

    return NULL;
d216 3
a218 1
  else
d220 70
a289 1
    data = HtmlOBJECTclassid(t);
d291 80
a370 1
    if (data && *data) b->odata[b->nobjects - 1].isplugin = 1;
d427 10
a436 3
      e = plugin_send_plugin_close(b,
                                   b->odata[i].plugin_instance_handle,
                                   b->odata[i].plugin_task_handle);
d440 2
d483 1
a483 1
  if (!t || t->tagno != TAG_OBJECT)
d487 1
a487 1
      if (t->tagno != TAG_OBJECT)
d848 2
d875 7
a881 4
        show_error_ret(plugin_send_original_reshape(b,
                                                    b->odata[object].plugin_instance_handle,
                                                    b->odata[object].plugin_task_handle,
                                                    &position));
d1103 1
a1103 4
/*             relevant to the Object - usually  */
/*             set as the browser instance       */
/*             handle for the Plug-In, so cast   */
/*             as an int;                        */
d1117 1
a1117 1
_kernel_oserror * object_set_token_object_plugin(unsigned int browser_instance, HStream * t, unsigned int plugin_instance, unsigned int plugin_task)
a1118 2
  browser_data * b = (browser_data *) browser_instance;

@


1.8
log
@fetch_get_raw_data will notice if up->fetching is zero and return a
'finished' status rather than trying to continue reading data for the
fetch. Fetches should never fall through that far but at least it
will cope if they do.

3D table borders are now supported. 2D borders are used if the
inter-cell spacing is too small to fit the borders in (display resolution
dependent) - the external table border is 2D if the internal borders are,
else 3D. For cellspacing of 0, internal table borders must plot over the
outer edge of pixels inside the cell; for all greater spacings, the
borders take up all or part of the gap between them. The external border
will always fit around the outside of the cells, including the
cellspacing value in the gap between the outer cells and the border.

Anti-alias colour for placeholder ALT text was incorrect. Fixed.

I'd changed 'point' to 'points' in some of the Font Choices dialogues;
now changed back to 'point'.

The routine to find out how large an otherwise unsized object or image
placeholder based on its ALT text has been centralised in Reformat.c,
so that the image and object routines can both access it without
code duplication (this means non-image objects will now have the correct
size if they contain ALT text, rather than assuming a standard default
size as before). ALT text in images that were also objects was never
plotted either, though the placeholder size would have been correct.
This has been fixed.
@
text
@d146 1
a146 1
  if (data && *data && type && *type)
d150 23
a172 1
    if (mimemap_mime_to_riscos(type, &filetype)) filetype = FileType_DATA;
d212 4
a222 1
    type = HtmlOBJECTcodetype(t);
d224 27
a250 1
    if (data && type) b->odata[b->nobjects - 1].isplugin = 1;
d380 2
d431 2
d434 3
a436 4
    int       w, h;
    int       available_w = redraw_display_width (b, b->cell);
    int       available_h = redraw_display_height(b, b->cell);
    HStream * tp          = b->odata[object].token;
d650 1
a650 9
        if (x < 0)
        {
          /* Object position is invalid, so hide the Plug-In by moving */
          /* it off the top of the work area.                          */

          position.xmax = (position.xmax - position.xmin);
          position.xmin = 0;
          position.ymax = (position.ymax - position.ymin) + 0x1000; /* 0x1000 to be (very) safe */
          position.ymin = 0x1000;
d652 1
a652 10
          /* This call will be done by the reformatter, as soon as it    */
          /* sees the Object item (the redraw routines set the position, */
          /* the reformatter invalidates it).                            */
          /*                                                             */
          /* So only start the Plug-In if Choices say to do so ASAP.     */

          if (choices.plugin_control == Choices_PlugIns_ASAP && choices.support_object) start_now = 1;

        }
        else
d718 4
a721 4
        show_error_ret(plugin_send_original_plugin_reshape(b,
                                                           b->odata[object].plugin_instance_handle,
                                                           b->odata[object].plugin_task_handle,
                                                           &position));
@


1.7
log
@Now handles PARAM tags. Sorted out Plug-In bug that was related to Java
setting a 0 by 0 graphics window before calling Wimp_Poll (fixed in Java).
Implemented queue for Plug-Ins so multiple broadcasts aren't sent for
several Objects in one data chunk.

Added Docs directory with some documentation in it. More things to keep
checking for stylistic consistency, horray ;-)

Corrected !Run[D] for Ursula build to need AcornURI but not TaskModule
(URI handler needed for !Mail to pick up mailto: links).

Added display_height field to browser_data, analogous to display_width,
to cope with % sized objects by width and height (see how HRs are
handled in Redraw.c for an example of how it was always fairly easy
with width, but not height until this addition). Though you do have
to reload to get a new size; reformat isn't enough. Must see to this
some time...

Fixed bug where basic typefaces were claimed *before* the Choices file
had been read. For unusual Choices settings, this could create some
'interesting' problems now and again. This was part of narrower scope
work in the Choices code to allow font changing without leaking font
handles (now done; fm_shutdown only ditches fonts, it keeps internal
structures - must then call  fm_lose_fonts for all browsers to get the
bitfields up to date, then rewrite the typeface definitions and reclaim
basic fonts). Noticed that fm_claim_basic_typefaces would claim multiple
instances of the same font if there were several cases of the same font
mapped to different typeface styles - fixed.

Implemented PlugInControl settings, but not SupportObject (fully).
@
text
@d150 1
a150 1
    RetError(mimemap_mime_to_riscos(type, &filetype));
d416 3
a418 2
    size->xmax = ImageDefaultOSSize_X;
    size->ymax = ImageDefaultOSSize_Y;
@


1.6
log
@More reformatter code bugs fixed; this one regarding width of items. Any
kerned string was overestimated (causing redraw bugs and caret position
problems in forms, apart from other minor bits elsewhere) and the default
size of a writable icon wasn't especially clever.

Crude Plug-In support; just about manages Java, but can't fetch on
behalf of Plug-In (for example). Had to change the default file access
URL construction to be 'file:/' instead of 'file://', or local file
fetches that reference Java applets won't work. This is in its very
early stages, and is being checked in mostly so that various Choices
issues can be worked on.
@
text
@d46 1
d58 1
d65 5
a69 4
static int               object_get_token_object  (browser_data * b, HStream * t);
static _kernel_oserror * object_get_object_size   (browser_data * b, int object, BBox * size);
static _kernel_oserror * object_get_object_plugin (browser_data * b, int object, unsigned int * plugin_instance, unsigned int * plugin_task);
static _kernel_oserror * object_set_object_plugin (browser_data * b, int object, unsigned int plugin_instance, unsigned int plugin_task);
a130 9
  /* Width and height initially come from the token, but if this */
  /* ends up leading to a Plug-In being called, that Plug-In     */
  /* could ask for the size to change; hence the 'width' and     */
  /* 'height' fields.                                            */

  b->odata[b->nobjects].units                   = UNITS_PIXELS;
  b->odata[b->nobjects].width                   = t->cols;
  b->odata[b->nobjects].height                  = t->rows;

d163 15
a177 4
      RetError(image_new_image(b,
                               data,
                               t,
                               0));
d179 4
a182 1
      b->odata[b->nobjects - 1].isimage = 1;
d184 5
a188 1
      return NULL;
d217 1
d236 7
a242 1
  /* Remove the Objects */
d281 3
a283 1
      erb.errnum = Utils_Error_Custom_Normal;
d285 3
a287 3
      sprintf(erb.errmess,
              "Token %08x passed to object_new_object does not represent an OBJECT, APPLET or EMBED tag",
              (int) t);
d289 2
a290 1
      show_error_ret(&erb);
a377 1
  if (b->odata[object].units == UNITS_PIXELS)
d379 31
a409 2
    size->xmax = b->odata[object].width  * 2; /* A 'web pixel' -> 2 OS units under RISC OS */
    size->ymax = b->odata[object].height * 2;
d446 33
d507 1
a507 6
  if (object < 0) return 1;

  *x = b->odata[object].x;
  *y = b->odata[object].y;

  return 0;
d536 9
d554 12
a565 2
    b->odata[object].x = x;
    b->odata[object].y = y;
d580 4
d588 2
a589 1
      /* Plug-In has not yet been sent, send it.                     */
d593 2
d597 2
a598 1
          /* Object position is invalid, so hide the Plug-In */
d600 12
a611 2
          position.xmin = -position.xmax - 16;
          position.xmax = -16;
a612 2
          position.ymin = position.ymax + 16;
          position.ymin = 16;
d622 2
d626 7
a632 1
        b->odata[object].broadcast_sent = 1; /* Don't try over and over if the first gives an error */
d634 8
a641 1
        show_error_ret(plugin_broadcast_plugin_open(b, t, &position));
d657 1
a657 1
          /* Object position has been invalidated, so hide the Plug-In */
d659 4
a662 5
          position.xmin = -position.xmax - 16;
          position.xmax = -16;

          position.ymin = position.ymax + 16;
          position.ymin = 16;
d676 4
d688 4
d693 49
@


1.5
log
@!Run[D] files updated for new fetchers and GopherFetcher; protocols list
in Controls updated for Gopher. Debug builds now require 2760K rather than
2560K. Font$... variables set if not already, in anticipation of font
Choices work.

Additional bits in Choices section of Res file tidied and some name
changes (e.g. Netscape -> Navigator(TM)). Frames support option added
to Choices.

Grouped 'support_frames' under the Fetch Controls section and added
support_object in Global.h; appropriate entries placed in the Choices
files, and are read at startup. At present, though, only the frames
support flag is implemented.

For some reason, Menu was the button to use on history popups if you
wanted to show URLs instead of descriptions (or vice versa, depending
on Choices settings). Now, Select and Menu will show the Choices
defined setting, and Adjust will show the opposite.

History menus are built backwards, so local histories have the most
recently visited pages at the top. Global history has still no real
order to it, but this may be arranged later.

Customer name changed to Customer by request.

Customer browser now gets its own resources (SYSTEM=Customer), but
otherwise is unchanged, with the Ursula build now giving the
'spinning acorn' with a Bookworm-style toolbar. This is used for the
Desktop !Browse build.

!Sprites[22] files updated to include GIF, JPEG and PNG sprites;
!Run[D] files and !Boot files set appropriate File$Type_xxx variables.
Sprites in all sprites files have been checked for unnecessary palettes,
which have been removed where present.
@
text
@d63 4
a66 2
static int               object_get_token_object (browser_data * b, HStream * t);
static _kernel_oserror * object_get_object_size  (browser_data * b, int object, BBox * size);
a116 1
  b->odata[b->nobjects].browser_instance_handle = 0;
d134 2
a135 2
  b->odata[b->nobjects].width                   = t->rows;
  b->odata[b->nobjects].height                  = t->cols;
d140 2
d182 1
a182 1
  if (!data)
d186 2
a189 5
//  if (data && *data && type && *type)
//  {
//    return plugin_broadcast_plugin_open(
//  }

d204 21
d227 3
a229 1
  return memory_set_chunk_size(b, NULL, CK_OBJB, 0);
d239 1
a239 1
/*             relevant to the Objects;          */
d379 1
a379 1
/*             to add to;                        */
d462 5
d474 81
d561 188
d802 5
a806 40
    if (box.xmax > 8 && box.ymax > 8)
    {
      /* xmin, ymin hold the bottom left hand corner coordinates, whilst */
      /* xmax, ymax hold the width and height. The adjustments are to    */
      /* account for the way the bbc_rectanglefill function works; e.g., */
      /* to get a width of 4 OS units, ask for 3 (as it adds this to the */
      /* x coordinate and treats it as an inclusive x coordinate max).   */
      /* There are corrections to plot 2 OS units inside of the real     */
      /* bounding box (looks better when images touch each other) and to */
      /* get the darker sides of the 'slabbed in' box overlapping the    */
      /* lighter sides by the right amount.                              */

      redraw_set_colour(Redraw_Colour_AlmostWhite);
      bbc_rectanglefill(box.xmin + 2,
                        box.ymin + 2,
                        box.xmax - 5,
                        3);
      bbc_rectanglefill(box.xmax + box.xmin - 6,
                        box.ymin + 2,
                        3,
                        box.ymax - 5);

      redraw_set_colour(Redraw_Colour_MidGrey);
      bbc_rectanglefill(box.xmin + 2,
                        box.ymax + box.ymin - 6,
                        box.xmax - 7,
                        3);
      bbc_rectanglefill(box.xmin + 2,
                        box.ymin + 4,
                        3,
                        box.ymax - 7);
    }
    else
    {
      if (box.xmax < 2) box.xmax = 2;
      if (box.ymax < 2) box.ymax = 2;

      redraw_set_colour(0);
      bbc_rectangle(box.xmin,box.ymin,box.xmax - 1,box.ymax - 1);
    }
@


1.4
log
@Added MimeMap module support. OBJECT routines now use this to determine
if the item is an inline image, and if so pass it to the image routines.
At present, support relies on a (correct) content type.
@
text
@d83 2
d146 4
a149 4
  if (
       HtmlOBJECTdata(t) &&
       HtmlOBJECTtype(t)
     )
d151 3
a153 2
    const char * data = HtmlOBJECTdata(t);
    const char * type = HtmlOBJECTtype(t);
d155 10
a164 1
    if (*data)
d166 4
a169 1
      int filetype;
d171 1
a171 1
      RetError(mimemap_mime_to_riscos(type, &filetype));
d173 3
a175 1
      /* Is it an image we can handle? */
d177 1
a177 13
      if (
           filetype == FileType_PNG  ||
           filetype == FileType_GIF  ||
           filetype == FileType_JPEG ||
           filetype == FileType_TIFF ||
           filetype == FileType_XBM  ||
           filetype == FileType_BMP
         )
      {
        RetError(image_new_image(b,
                                 data,
                                 t,
                                 0));
d179 4
a182 5
        b->odata[b->nobjects - 1].isimage = 1;

        return NULL;
      }
    }
d185 4
a188 1
  /* Finally deal with other objects */
@


1.3
log
@Res files had component 0x29fc in frame gadgets for Choices - that's
meant to be the 'fake page' display. Sorted that out.

Got rid of unnecessary #define in Choices.h; the gadget autodetect
for the colour choices took its place.

Unsized objects now default to the same dimensions as unsized images.
@
text
@d48 1
d51 1
d134 4
d142 41
d318 6
d434 5
d472 3
a474 2
  int object  = object_get_token_object(b, token);
  int plotted = 0;
d476 5
a480 6
  // Here would go some code to check if this is, say, an image,
  // and if so call the image redraw code instead. This would set
  // the 'plotted' flag as appropriate - may need to extend image
  // library API to say if it was about to draw a placeholder
  // itself, so that plotted stays unset (assuming it isn't possible
  // to easily generalise the image placeholder plotting).
d540 25
a564 1
  return NULL;
@


1.2
log
@Calling HtmlEndParse at the end of html_get_next_token and setting
up->context to NULL was wrong; fetch_fetcher would end up recalling
html_get_next_token later which would then call HtmlParse even though
the document parse had just finished! The HtmlEndParse call has now
been moved to fetch_stop.

Altered reformatter to claim fonts inside a browser, rather than
claiming them for nothing and losing them afterwards.

Got rid of TAG == TABLE and ISBODY tests, replacing with tagno == TAG_TABLE.
Removed all references to TD, TH, TR and TABLE in the style word.
@
text
@d116 7
d279 8
d313 74
d439 1
a439 1
Printf("%d, %d\n",box.xmax,box.ymax);
@


1.1
log
@Big steps forward in vertical white space handling as a result of
improvements in HTMLLib in this area ( -> all versions now 1.22 beta-2).
As a result, the 'last_space' field in browser_data struct has been
removed. Note that this relies quite heavily on setting of the PCDATA
bit in the 'style' field of an HStream and the automatic collapsing
of (for example) multiple P tags inside HTMLLib.

Trace.c improved to recognise various bits in the 'style' field of an
HStream structure.

Phoenix defaults altered to a more 'standard' set of choices; Trinity
as the serif font, with a slightly larger default font size. This is
because there's a good chance it might get released to a wider audience
than Acorn internal (though the animation and icon bar sprites will
have to change before then...).

MiscDefs updated for new SWI numbers in HTTP module; !Run[D] files thus
updated to require HTTP 0.42 or later. At this point, all earlier
modules are not backwards compatible in terms of direct calls to the
HTTP module, though this only affects cookies_process_cookie at present.
At the same time, checks for System$Path, InetDBase$Path, and setting
of Inet$MimeMappings if not already defined have been added to the Run
files along with RMEnsures of Resolver and MimeMap.

Object and PlugIn c/h pairs created to handle OBJECT, EMBED and APPLET,
and the RISC OS Plug-In interface respectively. Not part of the build
process yet. Addition of 'odata' field in browser_data struct and
definition of chunk CK_OBJB for memory_set_chunk_size() are in support
of this.
@
text
@d49 2
d58 337
@

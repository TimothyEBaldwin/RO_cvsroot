head	1.53;
access;
symbols
	Browse-2_16:1.53
	Browse-2_15:1.53
	Browse-2_14:1.53
	Browse-2_13:1.53
	Browse-2_12:1.53
	Browse-2_11:1.52
	Browse-2_10:1.52
	Browse-2_09:1.52
	ahodgkin_208_i4_2:1.51
	ahodgkin_208_i4:1.48
	ahodgkin_208_i3:1.48
	ahodgkin_208_i2:1.48
	ahodgkin_208_i1:1.48
	ahodgkin_207release:1.45
	ahodgkin_206release:1.40
	ahodgkin_205release:1.39
	ahodgkin_204release:1.39
	ahodgkin_202release:1.38
	ahodgkin_201release:1.37
	ahodgkin_200release:1.36
	ahodgkin_133beta:1.36
	ahodgkin_132beta:1.36
	ahodgkin_131beta:1.35
	ahodgkin_130beta:1.34
	ahodgkin_129:1.33
	ahodgkin_128beta:1.31
	ahodgkin_128alpha:1.31
	ahodgkin_127beta2:1.29
	ahodgkin_127beta:1.28
	ahodgkin_126beta:1.27
	ahodgkin_AW97patch:1.25
	ahodgkin_AW97:1.23;
locks; strict;
comment	@# @;


1.53
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.52;

1.52
date	2005.04.26.09.42.34;	author ahodgkin;	state Exp;
branches;
next	1.51;

1.51
date	2000.11.14.08.45.06;	author ahodgkin;	state Exp;
branches;
next	1.50;

1.50
date	2000.05.31.15.58.37;	author ahodgkin;	state Exp;
branches;
next	1.49;

1.49
date	2000.03.03.11.11.33;	author ahodgkin;	state Exp;
branches;
next	1.48;

1.48
date	99.09.02.13.10.21;	author ahodgkin;	state Exp;
branches;
next	1.47;

1.47
date	99.03.30.15.51.45;	author ahodgkin;	state Exp;
branches;
next	1.46;

1.46
date	98.10.14.15.21.56;	author ahodgkin;	state Exp;
branches;
next	1.45;

1.45
date	98.10.13.16.34.01;	author ahodgkin;	state Exp;
branches;
next	1.44;

1.44
date	98.10.06.09.28.52;	author ahodgkin;	state Exp;
branches;
next	1.43;

1.43
date	98.09.23.13.18.08;	author ahodgkin;	state Exp;
branches;
next	1.42;

1.42
date	98.09.07.11.46.50;	author ahodgkin;	state Exp;
branches;
next	1.41;

1.41
date	98.07.23.13.26.39;	author sbrodie;	state Exp;
branches;
next	1.40;

1.40
date	98.07.09.10.27.11;	author ahodgkin;	state Exp;
branches;
next	1.39;

1.39
date	98.04.16.08.14.14;	author ahodgkin;	state Exp;
branches;
next	1.38;

1.38
date	98.03.20.12.12.44;	author ahodgkin;	state Exp;
branches;
next	1.37;

1.37
date	98.02.23.12.06.12;	author ahodgkin;	state Exp;
branches;
next	1.36;

1.36
date	98.02.06.13.55.15;	author ahodgkin;	state Exp;
branches;
next	1.35;

1.35
date	98.01.31.10.55.22;	author ahodgkin;	state Exp;
branches;
next	1.34;

1.34
date	97.12.18.10.07.00;	author ahodgkin;	state Exp;
branches;
next	1.33;

1.33
date	97.12.12.17.12.26;	author ahodgkin;	state Exp;
branches;
next	1.32;

1.32
date	97.12.12.11.17.54;	author ahodgkin;	state Exp;
branches;
next	1.31;

1.31
date	97.12.02.16.13.51;	author ahodgkin;	state Exp;
branches;
next	1.30;

1.30
date	97.11.26.17.11.01;	author ahodgkin;	state Exp;
branches;
next	1.29;

1.29
date	97.11.21.16.08.53;	author ahodgkin;	state Exp;
branches;
next	1.28;

1.28
date	97.11.19.10.29.01;	author ahodgkin;	state Exp;
branches;
next	1.27;

1.27
date	97.10.30.17.11.04;	author ahodgkin;	state Exp;
branches;
next	1.26;

1.26
date	97.10.27.18.19.59;	author kbracey;	state Exp;
branches;
next	1.25;

1.25
date	97.10.22.13.15.54;	author ahodgkin;	state Exp;
branches;
next	1.24;

1.24
date	97.10.20.07.09.19;	author ahodgkin;	state Exp;
branches;
next	1.23;

1.23
date	97.10.16.13.23.14;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	97.10.16.09.25.21;	author kbracey;	state Exp;
branches;
next	1.21;

1.21
date	97.10.13.07.06.57;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	97.10.10.20.00.52;	author kbracey;	state Exp;
branches;
next	1.19;

1.19
date	97.10.07.17.03.42;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	97.09.26.12.36.02;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	97.09.24.11.14.18;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	97.09.22.11.51.10;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	97.09.22.07.43.17;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	97.09.18.08.58.59;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.09.12.17.19.25;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.09.09.14.13.16;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.08.28.16.08.01;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.08.18.17.09.54;	author kbracey;	state Exp;
branches;
next	1.9;

1.9
date	97.08.18.17.00.46;	author kbracey;	state Exp;
branches;
next	1.8;

1.8
date	97.08.18.16.15.40;	author kbracey;	state Exp;
branches;
next	1.7;

1.7
date	97.08.18.09.23.58;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.08.12.09.26.36;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.08.05.08.42.57;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.08.01.09.00.52;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.12.52.31;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.07.24.16.12.10;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.28.45;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.53
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Images.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Image related functions.                          */
/*                                                            */
/* Author:  A.D.Hodgkinson, including various functions from  */
/*          original Customer browser by Merlyn Kline.       */
/*                                                            */
/* History: 28-Nov-1996 (ADH): Created with dummy function    */
/*                             for temporary use in other     */
/*                             routines.                      */
/*          20-Jan-1997 (ADH): Filled in with most of the     */
/*                             functions present and          */
/*                             converted to the new data      */
/*                             structures where needed.       */
/*          15-Mar-1997 (ADH): Reorganised a bit, putting     */
/*                             functions in a more logical    */
/*                             order to aid legibility.       */
/*          17-Dec-1997 (ADH): Added support for saving as a  */
/*                             Draw file.                     */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include <kernel.h>
#include <swis.h>
#include <tboxlibs/flex.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>

#include "Global.h"
#include "FromROSLib.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Browser.h"
#include "Fetch.h" /* (Which itself includes URLstat.h) */
#include "FetchHTML.h"
#include "FetchPage.h"
#include "FontManage.h"
#include "ImgHistory.h"
#include "PrintStyle.h"
#include "Protocols.h"
#include "Redraw.h"
#include "Reformat.h"
#include "Save.h"
#include "SaveDraw.h"
#include "SavePDF.h"
#include "Scale.h"
#include "TokenUtils.h"
#include "Toolbars.h"
#include "URLutils.h"
#include "URLveneer.h"
#include "Windows.h"

#include "Images.h"

/* Statics */

static _kernel_oserror * image_load_chunk             (browser_data * b, int image, char * buffer, int bytes);
static void              image_remove_data            (browser_data * b, int image);
static void              image_remove_all_data        (int image);
static void              image_delay                  (browser_data * b, int image);
static void              image_abandon                (browser_data * b, int image);
static void              image_prepare                (browser_data * b, HStream * token, int image, int background);

static void              image_mark_as_deleted        (int i);
static void              image_mark_as_gcable         (int i);
static void              image_destroy                (int image);
static int               image_renumber               (int old, int new);
static int               image_purge_deleted_entries  (void);
static void              image_post_deletion_clearup  (void);
static int               image_gc_oldest              (browser_data * b);

static void              image_refetch                (browser_data * b, int image, int priority, int redraw);

static _kernel_oserror * image_update_area            (browser_data * b, int x, int y, BBox * ubox, int image, int redraw);
static _kernel_oserror * image_update_image           (browser_data * b, int image, BBox * box);

static _kernel_oserror * image_register_filler        (int xref);

static int               image_count_fetches          (browser_data * b);

static int               image_get_token_image_xref   (const browser_data * restrict b, const HStream * restrict token);
static int               image_get_token_image_actual (const browser_data * restrict b, const HStream * restrict token);

static void              image_lock_image_size        (browser_data * b, int image);
static void              image_unlock_image_size      (browser_data * b, int image);
static _kernel_oserror * image_get_image_size         (browser_data * restrict b, int image, BBox * restrict box, int ignore_stored);
static _kernel_oserror * image_set_image_size         (browser_data * b, int image, BBox * box);

static int               image_can_be_saved_as_sprite (browser_data * b, int i);

/* Locals */

static image_info   * idata       = NULL; /* Flex block for image_info structures (referenced as an array) */
static int            nimages     = 0;    /* Current number of image_info structures in idata array        */
static int            lastimage   = 0;    /* Used to work out what image_process_null should handle next   */
static int            animhandler = 0;    /* Flag so code knows when to (de)register GIF animation handler */
static unsigned int   unique_id   = 1;    /* IDs start at 1 and rise thereafter                            */
static char         * unique_name = NULL; /* Temporary pathname, nothing to do with unique_id!             */

/* For animated images, the filler function for the background of a   */
/* transparent image will get called only for the main image with the */
/* associated image data - not for any cross referenced images. These */
/* statics hold the browser and image being redrawn at any time, so   */
/* the filler function knows which cross referencing image is         */
/* actually being redrawn.                                            */

static int                  image_redrawing   = -1;
static const browser_data * browser_redrawing = NULL;

/* Local compilation options */

#undef  TRACE_FETCH_STORE
#define FAST_TOKEN_REFERENCE
#define FAST_TOKEN_REFERENCE_SHIFT 12
#undef  ALL_FAST

/**************************************************************/
/* image_load_chunk()                                         */
/*                                                            */
/* Tell the image library to deal with some of image data     */
/* we've fetched for a given image.                           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The image number, from 0 to nimages - 1;       */
/*                                                            */
/*             Pointer to a buffer containing the data, as a  */
/*             char *;                                        */
/*                                                            */
/*             The amount of data in that buffer.             */
/**************************************************************/

static _kernel_oserror * image_load_chunk(browser_data * b, int image, char * buffer, int bytes)
{
  BBox              box;
  _kernel_oserror * e = NULL;

  dprintf(("Imag", "image_load_chunk: Called for image %d\n",image));

  /* If the library has filled in the istore field, tell it to */
  /* get some of the data we've fetched.                       */

  if (idata[image].istore) e = idata[image].istore -> Load(idata[image].istore,
                                                           buffer,
                                                           bytes,
                                                           &box);

  dprintf(("Imag", "image_load_chunk: Exitting with error\n"));

  /* Return errors for STRICT_PARSER builds only */

  #ifdef STRICT_PARSER
    if (e) return e;
  #else
    if (e) return NULL;
  #endif

  /* Update the image on the page to reflect the new data */

  image_update_image(b, image, &box);

  dprintf(("Imag", "image_load_chunk: Successful\n"));

  return NULL;
}

/**************************************************************/
/* image_remove_data()                                        */
/*                                                            */
/* Discards the fetched image data associated with an image,  */
/* but leaves the URL information alone.                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The image number, from 0 to nimages - 1.       */
/**************************************************************/

static void image_remove_data(browser_data * b, int image)
{
  dprintf(("Imag", "image_remove_data: Called for image %d\n",image));

  if (idata[image].flex->fetchdata)
  {
    #ifdef TRACE
      flexcount -= flex_size(&idata[image].flex->fetchdata);
      dprintf(("CFle", "**   flexcount: %d\n",flexcount));
    #endif

    flex_free(&idata[image].flex->fetchdata);

    idata[image].flex->fetchdata = NULL;
  }

  dprintf(("Imag", "image_remove_data: Successful\n"));
}

/**************************************************************/
/* image_remove_all_data()                                    */
/*                                                            */
/* Discards the fetched image data associated with an image,  */
/* including URL information.                                 */
/*                                                            */
/* Parameters: The image number, from 0 to nimages - 1.       */
/**************************************************************/

static void image_remove_all_data(int image)
{
  dprintf(("Imag", "image_remove_all_data: Called for image %d\n",image));

  if (!idata[image].flex) return;

  if (idata[image].flex->urldata)
  {
    #ifdef TRACE
      flexcount -= flex_size((flex_ptr) &idata[image].flex->urldata);
      dprintf(("CFle", "**   flexcount: %d\n",flexcount));
    #endif

    flex_free((flex_ptr) &idata[image].flex->urldata);

    idata[image].flex->urldata = NULL;
  }

  if (idata[image].flex->fetchdata)
  {
    #ifdef TRACE
      flexcount -= flex_size(&idata[image].flex->fetchdata);
      dprintf(("CFle", "**   flexcount: %d\n",flexcount));
    #endif

    flex_free(&idata[image].flex->fetchdata);

    idata[image].flex->fetchdata = NULL;
  }

  free(idata[image].flex);
  idata[image].flex = NULL;

  dprintf(("Imag", "image_remove_all_data: Successful\n"));
}

/**************************************************************/
/* image_delay()                                              */
/*                                                            */
/* Stop fetching data for an image, even if it hasn't all     */
/* been fetched, but allow the fetch to continue later on.    */
/*                                                            */
/* Call with care. Keeping part of an image is dangerous -    */
/* ImageLib may object. Normally, this should only be called  */
/* for images which have not started to fetch. Stopping an    */
/* image mid-fetch is more safely done through image_abandon. */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The image number, from 0 to nimages - 1.       */
/**************************************************************/

static void image_delay(browser_data * b, int image)
{
  dprintf(("Imag", "image_delay: Called for image %d\n",image));

  /* Stop any fetching for the image */

  if (idata[image].handle) html_close(idata[image].handle);

  idata[image].handle  = 0;
  idata[image].delayed = 1;

  /* If this is a background, go back to the plain background */

  if (image == b->background_image) b->antialias_colour = redraw_backcol(b);

  if (idata[image].istore) image_update_image(b, image, NULL);

  /* There may be a new overall fetch status, so ensure the */
  /* status bar is up to date                               */

  toolbars_cancel_status(b, Toolbars_Status_GetPics);

  dprintf(("Imag", "image_delay: Successful\n"));
}

/**************************************************************/
/* image_delay_fetches()                                      */
/*                                                            */
/* Stops any images which have not started to fetch for a     */
/* given browser from fetching at all, by setting the image's */
/* 'delayed' flag.                                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images.                                    */
/**************************************************************/

void image_delay_fetches(browser_data * b)
{
  if (nimages)
  {
    int image;

    for (image = 0; image < nimages; image++)
    {
      /* Only interested in non-cross referencing images */
      /* owned by this browser which are not fetching.   */

      if (
           idata[image].owner == b &&
           idata[image].xref < 0   &&
           !idata[image].handle
         )
         image_delay(b, image);
    }
  }
}

/**************************************************************/
/* image_abandon()                                            */
/*                                                            */
/* Stop fetching data for an image, even if it hasn't all     */
/* been fetched.                                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The image number, from 0 to nimages - 1.       */
/**************************************************************/

static void image_abandon(browser_data * b, int image)
{
  BBox end;

  dprintf(("Imag", "image_abandon: Called for image %d\n",image));

  /* Stop any fetching for the image */

  if (idata[image].handle) html_close(idata[image].handle);

  idata[image].handle  = 0;
  idata[image].fetched = 1;

  /* If this is a background, go back to the plain background */

  if (image == b->background_image) b->antialias_colour = redraw_backcol(b);

  if (idata[image].istore)
  {
    /* Let this fail silently */

    idata[image].istore -> EndLoad(idata[image].istore, &end);

    /* Redraw the image */

    image_update_image(b, image, &end);
  }

  /* There may be a new overall fetch status, so ensure the */
  /* status bar is up to date                               */

  toolbars_cancel_status(b, Toolbars_Status_GetPics);

  dprintf(("Imag", "image_abandon: Successful\n"));
}

/**************************************************************/
/* image_abort_fetches()                                      */
/*                                                            */
/* Stop fetching data for all images belonging to a given     */
/* browser, discarding all data for those images. The fetches */
/* cannot be restarted after this!                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images.                                    */
/**************************************************************/

void image_abort_fetches(browser_data * b)
{
  int i;

  /* Loop through the images */

  for (i = 0; i < nimages; i++)
  {
    /* If owned by this browser... */

    if (idata[i].owner == b)
    {
      /* Mark the image as fetched (so pending images don't then */
      /* start to fetch after fetching images stop).             */

      idata[i].fetched = 1;

      /* Stop any images which are fetching */

      if (idata[i].handle)
      {
        html_close(idata[i].handle);
        idata[i].handle   = 0;
        idata[i].bytesgot = 0;

        /* If this is a background, go back to the plain background */

        if (i == b->background_image) b->antialias_colour = redraw_backcol(b);

        if (idata[i].istore)
        {
          #ifdef STRICT_PARSER

            /* Report any errors as Continue-only in strict parser mode */

            _kernel_oserror * e;

            e = idata[i].istore -> Delete(idata[i].istore);

            if (e)
            {
              e->errnum = Utils_Error_Custom_Message;
              show_error_ret(e);
            }

          #else

            /* If not in Strict mode, ignore any errors */

            idata[i].istore -> Delete(idata[i].istore);

          #endif

          idata[i].istore = NULL;

          /* Remove any fetched data (not URL information though) */

          image_remove_data(b, i);

          /* Redraw the item */

          if (idata[i].token) browser_update_token(b, idata[i].token, 0, 0);
        }
      }
    }
  }

  /* There may be a new overall fetch status, so ensure the */
  /* status bar is up to date                               */

  toolbars_cancel_status(b, Toolbars_Status_GetPics);
}

/**************************************************************/
/* image_prepare()                                            */
/*                                                            */
/* Ensure various flags in an image are set up as required by */
/* the token the image represents. Will update the token to   */
/* hold the image number if FAST_TOKEN_REFERENCE is defined.  */
/*                                                            */
/* Originally part of image_new_image; made into a new        */
/* function as it was needed more than once.                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to the token the image represents      */
/*             (NULL if none);                                */
/*                                                            */
/*             The image number;                              */
/*                                                            */
/*             1 if this is a background image (fast          */
/*             processing), else 0.                           */
/**************************************************************/

static void image_prepare(browser_data * b, HStream * token, int image, int background)
{
  /* If the image is not a background one, need to update the */
  /* width and height fields according to any details in the  */
  /* HTML source.                                             */

  if (!background)
  {
    /* Need to flag if the HTML gives us an absolute size */

    if (
         token                                      &&
         OBJECT_HAS_WIDTH   (token)                 &&
         OBJECT_HAS_HEIGHT  (token)                 &&
         OBJECT_WIDTH_UNITS (token) == UNITS_PIXELS &&
         OBJECT_HEIGHT_UNITS(token) == UNITS_PIXELS
       )
       idata[image].fixedsize = 1, idata[image].canredraw = 1;

    else
    {
      /* If reformats aren't immediate, image_update_image may ask for */
      /* one and then if canredraw is set, will start updating the     */
      /* image. This is invalid unless the reformat has definitely     */
      /* occurred (a full size image plots inside a default size       */
      /* placeholder...). However, if reformats happen straight away,  */
      /* we'll always be able to redraw.                               */

      if (!choices.refo_wait) idata[image].canredraw = 1;
      else                    idata[image].canredraw = 0;
    }

    idata[image].currw = idata[image].currh = -1;
  }

  /* Store the image number in the token */

  #ifdef FAST_TOKEN_REFERENCE

    if (token)
    {
      token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
      token->flags |= ((image + 1) << FAST_TOKEN_REFERENCE_SHIFT);
    }

  #endif
}

/**************************************************************/
/* image_new_image()                                          */
/*                                                            */
/* Starts fetching a new image. Creates a record in the idata */
/* flex block and increments the image counter. If an image   */
/* is already being fetched with the same URL then a cross    */
/* reference is set up to point to that, else a fetch is      */
/* initiated.                                                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image to fetch;                            */
/*                                                            */
/*             Pointer to the URL to fetch;                   */
/*                                                            */
/*             The address of the token that led to this      */
/*             function call, i.e. the token representing     */
/*             that image;                                    */
/*                                                            */
/*             1 if the image is for the background (it will  */
/*             be turned into a sprite for fast plotting),    */
/*             else 0; or if 2, the background_image field of */
/*             the browser_data structure is filled in with   */
/*             the relevant image number and the image will   */
/*             again be turned into a sprite for fast         */
/*             plotting;                                      */
/*                                                            */
/*             Pointer to an int, in which an opaque value by */
/*             which the image may be later referenced is     */
/*             returned - useful for garbage collection if    */
/*             you've no token to associate with this image   */
/*             (may be NULL).                                 */
/**************************************************************/

_kernel_oserror * image_new_image(browser_data * b, const char * url, HStream * token, int background, int * handle)
{
  int ok, ulen;
  int xref;
  int use_xref   = 0;
  int tried_once = 0;

  dprintf(("Imag", "image_new_image: Called\n"));

  /* Can't proceed without the URL to fetch! */

  if (!url) url = ""; /* Point to *something*, even if it is blank */
  xref = -1;

  /* Need to make sure we don't already have an image with this URL */
  /* if there are already some images present.                      */

  if (nimages)
  {
    int test = 1;

    #ifdef FAST_TOKEN_REFERENCE

      /* Must not try to have too many images... */

      if (nimages >= (((unsigned int) 0xffffffff) >> FAST_TOKEN_REFERENCE_SHIFT))
      {
        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 lookup_token("MaxImages:Too many images.",
                              0,
                              0));
        return &erb;
      }

    #endif

    /* If this is a File URL, check it's not scrap - don't allow cross */
    /* referencing if it is.                                           */

    if (!strncmp(url, FileMethod, sizeof(FileMethod) - 1))
    {
      char test_url[Limits_URL];

      /* Build the URL we'd be on for a scrap file fetch */

      StrNCpy0(test_url, Save_ScrapFile);

      urlutils_pathname_to_url(test_url, sizeof(test_url));

      /* If it's the same as the URL we've been given, don't */
      /* cross reference the image.                          */

      if (!strcmp(url, test_url)) test = 0;
    }

    if (test)
    {
      int i;

      for (i = 0; i < nimages; i++)
      {
        /* Can we simply create a cross reference to another image? */

        if (
             idata[i].flex->urldata                                  &&  /* The image has an associated URL                     */
             idata[i].xref < 0                                       &&  /* The image doesn't cross reference things itself     */
             idata[i].background == !!background                     &&  /* We're not trying to make a b/g an f/g or vice versa */
             !strcmp(url, idata[i].flex->urldata)                    &&  /* This holds a URL which matches that passed in       */
             (
               !background ||                                            /* This isn't a background image, or...                */
               (
                 background &&                                           /* If this is a background image, the background       */
                 redraw_backcol(idata[i].owner) == redraw_backcol(b)     /* colours match in the two owner browsers             */
               )
             )
           )
        {
          xref = i; /* If all of the above are satisfied, cross reference */
          break;    /* this image with the one it matches.                */
        }
      }
    }
  }

  /* Don't need to hold the URL for a cross referenced image */

  if   (xref >= 0) ulen = 0;
  else             ulen = strlen(url) + 1;

  /* Are we cross-referencing an image which is ready for garbage */
  /* collection? If so, we can just claim this one.               */

  if (xref >= 0)
  {
    if (!idata[xref].from_js && !idata[xref].token)
    {
      /* Set the token and owner */

      idata[xref].token     = token;
      idata[xref].owner     = b;
      idata[xref].last_used = time(NULL);

      /* Handle background images */

      if (background == 2) b->background_image = xref;

      /* Ensure any required flags are updated */

      image_prepare(b, token, xref, background);

      /* Flag to any of the code we're about to jump to that the */
      /* xref image number should be used, not 'nimages - 1'     */

      use_xref = 1;

      /* Jump past all the image setup and cross referencing */
      /* code to carry on with whatever remains for this     */
      /* image.                                              */

      goto image_new_image_reclaimed_image_jump_point;
    }
  }

  /* For each of the following allocations, try twice. If the first */
  /* attempt fails, garbage collect all images and try again.       */

  tried_once = 0;

  do
  {
    /* Allocate space for the image_info structure */

    if (idata)
    {
      int oldsize;

      oldsize = flex_size  ((flex_ptr) &idata);
      ok      = flex_extend((flex_ptr) &idata, oldsize + sizeof(image_info));
    }
    else ok   = flex_alloc ((flex_ptr) &idata, sizeof(image_info));

    if (!ok && !tried_once)
    {
      tried_once = 1;
      image_gc(NULL, 0, 0);
    }
    else break;
  }
  while (!ok);

  /* Throw back an error if out of memory */

  if (!ok)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("NoMemImg:There is not enough free memory for any new images (%0).",
                          0,
                          "1"));

    return &erb;
  }

  /* Initialise the new structure (*before* incrementing nimages for now) */

  memset(&idata[nimages], 0, sizeof(image_info));

  idata[nimages].owner      = b;
  idata[nimages].x          = -1;
  idata[nimages].y          = -1;

  idata[nimages].token      = token;
  idata[nimages].last_used  = time(NULL);
  idata[nimages].xref       = xref;

  idata[nimages].background = !!background;
  idata[nimages].hadfiller  = 0;

  /* Allocate space for the URL */

  if (ulen)
  {
    tried_once = 0;

    do
    {
      /* Allocate space for the image data */

      idata[nimages].flex = malloc(sizeof(image_flex));

      if (!idata[nimages].flex) ok = 0;
      else                      ok = 1;

      memset(idata[nimages].flex, 0, sizeof(image_flex));

      if (ok) ok = flex_alloc((flex_ptr) &idata[nimages].flex->urldata, ulen);

      if (!ok && !tried_once)
      {
        tried_once = 1;
        image_gc(NULL, 0, 0);
      }
      else break;
    }
    while (!ok);
  }

  /* Again, throw back an error if out of memory */

  if (!ok)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("NoMemImg:There is not enough free memory for any new images (%0).",
                          0,
                          "1"));

    return &erb;
  }

  #ifdef TRACE
    flexcount += ulen;
    dprintf(("CFle", "**   flexcount: %d\n",flexcount));
  #endif

  /* If there's data for a URL, copy it into the above allocated block */
  /* and inform ImageLib of the new image.                             */

  if (ulen)
  {
    strcpy(idata[nimages].flex->urldata, url);

    #ifdef ALL_FAST
      idata[nimages].istore = NewImage(NULL, IMAGE_FAST);
    #else
      idata[nimages].istore = NewImage(NULL, background ? IMAGE_FAST : 0);
    #endif
  }

  /* Set the 'delayed' flag if it's not a background image and */
  /* images are flagged as not being shown right now, or if it */
  /* is a background image and backgrounds are flagged to be   */
  /* plain only.                                               */

  if (background)
  {
    idata[nimages].delayed   = !b->show_background;
    idata[nimages].canredraw = 1;

    /* Set the background image number */

    if (background == 2) b->background_image = nimages;
  }
  else
  {
    idata[nimages].delayed = (!b->show_foreground && b->displayed != Display_External_Image);
  }

  /* May have the image source in an exclusion list though */

  if (
       !idata[nimages].delayed                    &&
       ulen                                       &&
       urlutils_match_by_token(url, "LONoImages")
     )
     idata[nimages].delayed = 1;

  /* Make sure width and height info etc. is correct according */
  /* to the given HStream.                                     */

  image_prepare(b, token, nimages, background);

  /* Unique ID is never decremented... */

  idata[nimages].unique_id = unique_id ++;
  if (handle) *handle = idata[nimages].unique_id;

  /* ...whereas nimages is, when images get discarded. */

  nimages++;

image_new_image_reclaimed_image_jump_point:

  if (!ulen)
  {
    /* Since we aren't starting a fetch for this image, must call image_update_image  */
    /* on it to make sure any required reformats etc. (e.g. because a width or height */
    /* but not both was specified in the HTML) are carried out.                       */

    image_update_image(b, use_xref ? xref : nimages - 1, NULL);
  }

  /* Reflect any change of status */

  toolbars_update_status(b, Toolbars_Status_GetPics);
  toolbars_set_button_states(b);

  /* Finished. */

  dprintf(("Imag", "image_new_image: Successful\n"));

  return NULL;
}

/**************************************************************/
/* image_process_null()                                       */
/*                                                            */
/* The main engine of the image loading system. Allows up to  */
/* choices.max_images images to be simultaneously fetched.    */
/* Handles redraw, memory allocation, out-of-memory fetch     */
/* stops, and so-forth.                                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images.                                    */
/**************************************************************/

_kernel_oserror * image_process_null(browser_data * b)
{
  _kernel_oserror * e;

  dprintf(("Imag", "image_process_null: Called\n"));

  /* If there are not max_images images being fetched and there are still */
  /* images which have not started fetching, then start a fetch for one.  */
  /* Then do a 'get next chunk' on the next image with a fetch going      */
  /* on. Cause a screen update as appropriate.                            */

  if (nimages && b->fetch_status != BS_DATAFETCH)
  {
    int image, fetches;

    fetches = image_count_fetches(b);

    if (lastimage < 0 || lastimage >= nimages) lastimage = nimages - 1;

    image = lastimage;

    /* For all images up to and including the last one dealt with in a */
    /* null event, initiate fetches if they haven't already started.   */

    do
    {
      image ++;
      if (image >= nimages) image = 0;

      if (
           !idata[image].handle         &&
           !idata[image].fetched        &&
           !idata[image].delayed        &&
           idata[image].xref < 0        &&
           fetches < choices.max_images
         )
      {
        const char * referer = browser_base_url(b);
        char       * url     = malloc(strlen(idata[image].flex->urldata) + 1);

        if (url)
        {
          strcpy(url, idata[image].flex->urldata);

          e = html_get(url,                          /* Document to fetch                */
                       NULL,                         /* Pointer to any extra data        */
                       (int *) &idata[image].handle, /* Place to return the fetch handle */
                       URL_Method_http_GET,          /* Fetch method                     */

                       #ifndef SINGLE_USER
                         user.name,                  /* User name for MailServ, if using */
                       #else                         /* a multiuser version              */
                         NULL,
                       #endif

                       0,                            /* 0 = Don't parse fetched data     */
                       !b->reloading,                /* 1 = Proxy can be used, 0 = can't */
                       referer);                     /* URL of referring page            */
          free(url);
        }
        else e = NULL;

        if (!url || e)
        {
          /* Don't report it; countless 'I've failed' reports for */
          /* the very beginning of a fetch are not very helpful.  */
          /* Particularly, 'file not found' for file fetches can  */
          /* be major pain!                                       */

          image_abandon(b, image);
          return NULL;
        }
        else
        {
          /* In case the image requires authorisation, store the related image token */
          /* in the lasttoken field of the fetch URLStat structure (if possible).    */

          urlstat * up = urlstat_find_entry(idata[image].handle);
          if (up != NULL) up->lasttoken = idata[image].token;
        }

        url = NULL;
      }
    }
    while (image != lastimage && !idata[image].handle);

    lastimage = image;

    /* If the image we're now on has a fetch handle... */

    if (idata[image].handle)
    {
      char buffer[10240];

      /* ...And a fetch has already started... */

      if (idata[image].started)
      {
        int done, bytes;

        /* ...Then get the next chunk of data. If the fetch */
        /* call gives an error, abandon the image fetch and */
        /* exit.                                            */

        e = fetch_get_raw_data(NULL,                /* The browser_data structure */
                               idata[image].handle, /* Fetch handle */
                               buffer,              /* Buffer for fetched data */
                               sizeof(buffer),      /* Buffer's size */
                               &done,               /* 'done' = 1 for fetch completed, else 0 */
                               &bytes);             /* Number of bytes put into buffer */

        if (e)
        {
          image_abandon(b, image);
          return e;
        }

        idata[image].bytesgot += bytes;

dprintf(("temp", "Bytes got for image %d = %d (+%d this time)\n",image,idata[image].bytesgot,bytes));


        /* If the fetch_get_raw_data call resulted in data being fetched, */
        /* send that to the image library and reflect the fetched data in */
        /* the status bar.                                                */

        if (bytes)
        {
          e = image_load_chunk(b, image, buffer, bytes);

          if (e)
          {
            image_abandon(b, image);
            return e;
          }

          toolbars_update_progress(b);
        }

        /* If the fetch has finished, update everything as appropriate */

        if (done)
        {
          BBox end;

          html_close(idata[image].handle);

          idata[image].handle  = 0;
          idata[image].fetched = 1;
          idata[image].success = 1;

          if (idata[image].istore)
          {
            e = idata[image].istore -> EndLoad(idata[image].istore, &end);

            /* Report any errors as Continue-only in strict parser mode */

            #ifdef STRICT_PARSER

              if (e)
              {
                e->errnum = Utils_Error_Custom_Message;
                show_error_ret(e);
              }

            #endif

            /* Log errors regardless of parser mode */

            if (e != NULL && choices.ev_events != 0)
            {
              if (strlen(idata[image].flex->urldata) < sizeof(tokens))
              {
                bool ok = true;

                strcpy(tokens, idata[image].flex->urldata);

                if (strlen(e->errmess) + 2 + strlen(tokens) < sizeof(tokens))
                {
                  strcat(tokens, ": ");
                  strcat(tokens, e->errmess);
                }
                else if (strlen(tokens) + 3 < sizeof(tokens))
                {
                  strcat(tokens, "...");
                }
                else ok = false;

                if (ok) eventlogs_log_message(b,
                                              eventlogs_significant_event,
                                              tokens);

                *tokens = '\0';
              }
            }
          }

          /* If the image is a background image and the library has */
          /* dealt with it (this is assumed to be the case if the   */
          /* library has assigned a width to the image) then get    */
          /* the background text colour from the library on the     */
          /* basis of the image's contents. Else, use the plain     */
          /* background colour.                                     */
          /*                                                        */
          /* Note that it is not until the call to BGCol that       */
          /* ImageLib actually turns the background image into a    */
          /* sprite in the current colour depth, so if this isn't   */
          /* called, the sprite will plot slowly resulting in       */
          /* (typically) painfully slow redraws.                    */

          if (image == b->background_image) // idata[image].owner->background_image)
          {
            b->antialias_colour = redraw_backcol(b);

            if (idata[image].istore->width > 0)
            {
              #ifdef STRICT_PARSER

                /* Report any errors as Continue-only in strict parser mode */

                e = idata[image].istore -> BGCol(idata[image].istore,
                                                 &b->antialias_colour,
                                                 b->background_colour != -1 && b->use_source_cols);

                if (e)
                {
                  e->errnum = Utils_Error_Custom_Message;
                  show_error_ret(e);
                }

              #else

                /* If not in Strict mode, ignore any errors */

                idata[image].istore -> BGCol(idata[image].istore,
                                             &b->antialias_colour,
                                             b->background_colour != -1 && b->use_source_cols);

              #endif
            }
          }

          image_update_image(b, image, &end);
        }
      }
      else
      {
        /* In this block of code, the current image has had a fetch */
        /* started for it, but hasn't fetched any data yet - so we  */
        /* haven't (for example) got a full header for the request. */

        int       remn, sofar, waiting;
        int       realsize;
        int       oldsize;
        HStream * tptr;
        void    * store;
        char    * url = malloc(strlen(idata[image].flex->urldata) + 1);

        if (url) strcpy(url, idata[image].flex->urldata);

        /* Go in with no store; only interested in new data, as  */
        /* anything fetched so far goes into the ddata block. */

        store = NULL;

        /* At this stage, must put the data fetched so far back into the  */
        /* store. This is because headers may come in over several        */
        /* passes through the fetcher - if we give the fetcher an empty   */
        /* block each time, it won't be able to see the whole header      */
        /* block and the fetch fails (well, the image library keeps       */
        /* waiting for something to happen). At the time of writing this  */
        /* is demonstrated by the images at http://www.debenhams.co.uk/.  */

        if (idata[image].flex->fetchdata)
        {
          int isize = flex_size(&idata[image].flex->fetchdata);

          /* Complain if the flex allocation fails, else copy the data across */

          if (!flex_alloc(&store, isize))
          {
            image_abandon(b, image);
            free(url);
            return NULL;
          }
          else
          {
            int budge = flex_set_budge(0);

            #ifdef TRACE
              flexcount += isize;
              dprintf(("CFle", "**   flexcount: %d\n",flexcount));
            #endif

            memcpy(store, idata[image].flex->fetchdata, isize);

            flex_set_budge(budge);
          }
        }

        #ifdef TRACE_FETCH_STORE

          if (store)
          {
            int  offset;
            int  size = flex_size(&store);
            char cha;
            int  nl   = 0;

            dprintf(("Imag", "Image %d pre-fetch store:\n\n",image));

            for (offset = 0; offset < size; offset ++)
            {
              cha = ((char *) store)[offset];

              if (cha > 31) dprintf(("Imag", "%c",cha));
              if (cha == 13 || cha == 10)
              {
                if (!nl)
                {
                  dprintf(("Imag", "\n"));
                  nl = 1;
                }
                else nl = 0;
              }
            }

            dprintf(("Imag", "\nEnd of store\n\n"));
          }

        #endif

        /* Call the fetch routine */

        if (url)
        {
          e = html_get_next_token(b,
                                  idata[image].handle,
                                  &remn,
                                  &sofar,
                                  &tptr,
                                  &waiting,
                                  &store,
                                  url,
                                  1);

          free(url);
        }
        else e = NULL; /* Suppress compiler warning */

        if (!url || e)
        {
          /* If there's an error, free the store and ditch the image */

          if (store)
          {
            #ifdef TRACE
              flexcount -= flex_size(&store);
              dprintf(("CFle", "**   flexcount: %d\n",flexcount));
            #endif

            flex_free(&store);
          }

          image_abandon(b, image);

          dprintf(("Imag", "image_process_null: Exitting with error\n"));

          /* Only return errors in STRICT_PARSER builds for similar reason to */
          /* suppression of any errors from html_get above. After all, errors */
          /* here can include things like "404 Not Found".                    */

          #ifdef STRICT_PARSER
            return e;
          #else
            return NULL;
          #endif
        }

        url = NULL;

        #ifdef TRACE_FETCH_STORE

          if (store)
          {
            int  offset;
            int  size = flex_size(&store);
            char cha;
            int  nl   = 0;

            dprintf(("Imag", "Image %d post-fetch store:\n\n",image));

            for (offset = 0; offset < size; offset ++)
            {
              cha = ((char *) store)[offset];

              if (cha > 31) dprintf(("Imag", "%c",cha));
              if (cha == 13 || cha == 10)
              {
                if (!nl)
                {
                  dprintf(("Imag", "\n"));
                  nl = 1;
                }
                else nl = 0;
              }
            }

            dprintf(("Imag", "\nEnd of store\n\n"));
          }

        #endif

        /* How much data was added? */

        oldsize  = idata[image].flex->fetchdata ? flex_size(&idata[image].flex->fetchdata) : 0;
        realsize = store                        ? flex_size(&store) - oldsize              : 0;

        /* If we've got data in the local store, copy it to the image store. */

        if (realsize > 0)
        {
          int ok;
          int amount = flex_size(&store);
          int budge;

          /* Make enough room for the extra data */

          if (idata[image].flex->fetchdata) ok = flex_extend(&idata[image].flex->fetchdata, amount);
          else                              ok = flex_alloc (&idata[image].flex->fetchdata, amount);

          if (!ok)
          {
            #ifdef TRACE
              flexcount -= flex_size(&store);
              dprintf(("CFle", "**   flexcount: %d\n",flexcount));
            #endif

            flex_free(&store);

            image_abandon(b,image);

            erb.errnum = Utils_Error_Custom_Message;

            StrNCpy0(erb.errmess,
                     lookup_token("NoMemImg:There is not enough free memory for any new images (%0).",
                                  0,
                                  "2"));
            return &erb;
          }

          #ifdef TRACE

          else
          {
            flexcount += realsize;
            dprintf(("CFle", "**   flexcount: %d\n",flexcount));
          }

          #endif

          /* Copy the added data from the temporary store into the image's store */

          budge = flex_set_budge(0);

          memcpy(((char *) idata[image].flex->fetchdata) + oldsize,
                 ((char *) store)                        + oldsize,
                 realsize);

          flex_set_budge(budge);
        }

        /* Free the temporary store, if it was used */

        if (store)
        {
          #ifdef TRACE
            flexcount -= flex_size(&store);
            dprintf(("CFle", "**   flexcount: %d\n",flexcount));
          #endif

          flex_free(&store);
        }

        /* Act according to the fetch status */

        switch (waiting)
        {
          case 1: break; /* Nothing happened yet, or the HTTP response header is still coming in */
          case 2: break; /* Redirected, we can ignore and wait for the fetcher to cope */

          case 0:        /* Not awaiting delivery (shouldn't happen in this context, but here 'just in case') */
          case 3:        /* We have some data */
          {
            int offset, remaining, this_block;

            /* Flag that a fetch is in progress (rather than headers still */
            /* arriving, waiting, or redirecting)                          */

            idata[image].started = 1;

            /* Increment the 'bytes so far' counter for the image */

            idata[image].bytesgot += realsize;

            /* Push the data into the library, in chunks defined by */
            /* the size of 'buffer' (allocated as a char[] above).  */
            /* We do this as we can't be sure the ImageLib Load     */
            /* function is flex-safe, so the recently fetched data  */
            /* is copiedied into a temporary, non-movable block.    */

            offset    = oldsize;
            remaining = realsize;

            while (remaining > 0)
            {
              this_block = remaining;

              if (this_block > sizeof(buffer)) this_block = sizeof(buffer);
              memcpy(buffer, ((char *) idata[image].flex->fetchdata) + offset, this_block);

              offset    += this_block;
              remaining -= this_block;

              e = image_load_chunk(b, image, buffer, this_block);

              if (e)
              {
                /* If there's an error, ditch the image */

                image_abandon(b, image);

                dprintf(("Imag", "image_process_null: Exitting with error\n"));

                return e;
              }
            }

            /* Get rid of any accumulated data and update the status bar */

            image_remove_data(b, image);
            toolbars_update_progress(b);
          }
          break;
        }

        /* Closure of long 'if' that deals with either continuing  */
        /* to fetch data for an image, or getting the first chunk  */
        /* of data for a fetch. (The code immediately above is for */
        /* getting the first chunk).                               */
      }
      /* Closure of long 'if' that sees if a fetch has started */
      /* for an image. (The code immediately above excutes if  */
      /* it has, else a fetch is started).                     */
    }

    /* Closure of long 'if' that checks to see if there are */
    /* images to be fetched, and that the fetch status is   */
    /* not BS_DATAFETCH (i.e. other fetch activity has      */
    /* ceased).                                             */
  }

  dprintf(("Imag", "image_process_null: Successful\n"));

  return NULL;
}

/**************************************************************/
/* image_mark_as_deleted()                                    */
/*                                                            */
/* Mark an image as deleted, but don't remove it from the     */
/* image array yet. When all images that are to be deleted    */
/* have been thus marked, call image_purge_deleted_entries    */
/* before continuing.                                         */
/*                                                            */
/* Does not free any memory at all, in the image array or any */
/* other blocks. Does not cancel fetches or sort out other    */
/* image references such as background_image fields in        */
/* browser_data structures either, because this may be called */
/* when images are renumbered rather than wholly removed. If  */
/* completely wiping an image, make sure you do all of that   */
/* *before* calling here.                                     */
/*                                                            */
/* Parameters: Number of the image to mark as deleted.        */
/**************************************************************/

static void image_mark_as_deleted(int i)
{
  /* Try to set the flags up so that if for some horrific */
  /* reason this image should end up being processed as a */
  /* "live" item, it'll do minimum damage!                */

  idata[i].handle    = 0;
  idata[i].istore    = NULL;

  idata[i].deleted   = 1;

  idata[i].fetched   = 1;
  idata[i].delayed   = 0;
  idata[i].success   = 1;

  idata[i].hadfirst  = 1;
  idata[i].reformat  = 0;
  idata[i].hadfiller = 0;
  idata[i].canredraw = 0;
  idata[i].priority  = 0;

  idata[i].token     = NULL;

  return;
}

/**************************************************************/
/* image_mark_as_gcable()                                     */
/*                                                            */
/* Mark an image as suitable for garbage collection. Such     */
/* images may exist in the image array for as long as         */
/* required and may be reclaimed as working items by calls to */
/* image_new_image.                                           */
/*                                                            */
/* Parameters: Number of the image to mark as suitable for    */
/*             garbage collection.                            */
/**************************************************************/

static void image_mark_as_gcable(int i)
{
  idata[i].token = NULL;

  /* Yup, that was all that needs doing for now */

  return;
}

/**************************************************************/
/* image_discard()                                            */
/*                                                            */
/* For a given browser, discard images:                       */
/*                                                            */
/* * Any images which are xrefed by another browser have      */
/* their ownership transferred to that other browser and the  */
/* xrefing item is removed instead                            */
/*                                                            */
/* * Any images owned by the given browser which just xref    */
/* other images are removed                                   */
/*                                                            */
/* * Any remaining images holding actual image data are       */
/* marked for garbage collection but not removed immediately. */
/*                                                            */
/* When an image is removed, all data, including fetches,     */
/* ImageLib info and external refs to the image number is     */
/* sorted out. Remaining items in the image_info array may    */
/* end up renumbered.                                         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images.                                    */
/**************************************************************/

_kernel_oserror * image_discard(browser_data * b)
{
  int i, xref;

  dprintf(("Imag", "\nimage_discard: Called for %p. There are %d images.\n\n", b, nimages));

  if (!nimages) return NULL;

  /* See if any images cross reference those in the browser */
  /* for which images will be discarded. If so, 'move' the  */
  /* cross referencee over to be owned by the cross         */
  /* referencer.                                            */

  _swix(Hourglass_Start, _IN(0), 1);

  /* Must go backwards because we may delete items from the array */
  /* during the loop itself                                       */

  for (i = nimages - 1; i >= 0; i--)
  {
    xref = idata[i].xref;

    if (idata[i].owner != b && xref >= 0 && idata[xref].owner == b)
    {
      /* Keep the xref image, since that holds the real data and */
      /* is doing all the fetching, etc. - it works out as less  */
      /* effort overall (especially in the second pass below) to */
      /* delete the cross referencing image. This may seem a bit */
      /* odd as though we've been called to delete the images    */
      /* owned by browser 'b', in the first pass we end up       */
      /* deleting structures owned by completely different       */
      /* browsers...                                             */

      dprintf(("Imag", "image_discard: Transferring cross referencer %d to cross referencee %d\n", i, xref));

      idata[xref].owner      = idata[i].owner;
      idata[xref].x          = idata[i].x;
      idata[xref].y          = idata[i].y;

      idata[xref].token      = idata[i].token;
      idata[xref].last_used  = idata[i].last_used;

      idata[xref].currw      = idata[i].currw;
      idata[xref].currh      = idata[i].currh;
      idata[xref].xref       = -1;

      idata[xref].delayed    = idata[i].delayed;

      idata[xref].fixedsize  = idata[i].fixedsize;
      idata[xref].background = idata[i].background;

      idata[xref].hadfirst   = idata[i].hadfirst;
      idata[xref].canredraw  = idata[i].canredraw;
      idata[xref].priority   = idata[i].priority;

      /* Ensure the token is up to date */

      #ifdef FAST_TOKEN_REFERENCE

        if (idata[xref].token)
        {
          idata[xref].token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
          idata[xref].token->flags |= ((xref + 1) << FAST_TOKEN_REFERENCE_SHIFT);
        }

      #endif

      /* Did the image we're transferring a new owner to have */
      /* RegisterFiller called for it, with the old owner?    */

      if (idata[xref].hadfiller)
      {
        /* If an image became a background, ImageLib may have withdrawn the */
        /* RegisterFiller function...                                       */

        if (!idata[xref].istore->RegisterFiller)
        {
          idata[xref].hadfiller = 0;
        }
        else
        {
          /* Recall the RegisterFiller function with the new owner details */

          show_error_ret(image_register_filler(xref));
        }
      }

      /* If this is a background image for the cross referencer... */

      if (i == idata[i].owner->background_image)
      {
        /* Update the browser_data 'background_image' field to point to the */
        /* new cross reference image number.                                */

        idata[i].owner->background_image = xref;
      }

      /* If the cross referencee was being fetched, may need to */
      /* claim fetch nulls in the cross referencer to finish    */
      /* the job.                                               */

      if (idata[xref].handle && !idata[i].owner->fetch_handler)
      {
        fetchpage_claim_nulls(idata[i].owner);
        toolbars_update_status(idata[i].owner, Toolbars_Status_GetPics);
      }

      /* Delete the cross referencer */

      dprintf(("Imag", "image_discard: Deleting entry owned by %p that cross references image %d\n\n", idata[i].owner, idata[i].xref));

      image_destroy(i);
    }

    /* OK, so this image isn't owned by another browser but cross referencing */
    /* one owned by ourselves. A simpler case is where we own an image that   */
    /* just cross references another - we can delete those straight away      */

    else if (idata[i].owner == b)
    {
      if (idata[i].xref >= 0)
      {
        dprintf(("Imag", "image_discard: Image %d is a simple cross-referencer, deleting it\n\n", i));

        image_destroy(i);
      }

      /* Next case; this is owned by us but holds real data. In this case, mark */
      /* it as suitable for garbage collection but not as deleted.              */

      else if (idata[i].bytesgot)
      {
        dprintf(("Imag", "image_discard: Image %d being marked for GC\n", i));

        image_mark_as_gcable(i);
      }

      /* Last case: Not a cross referencer, but has no data yet - get rid of it */

      else
      {
        dprintf(("Imag", "image_discard: Image does not cross reference but has no bytes fetched for it yet; so deleting it\n\n"));

        image_destroy(i);
      }
    }
  }

  _swix(Hourglass_Off, 0);

  dprintf(("Imag", "image_discard: Delete pass complete; there are %d images. Calling clearup function.\n\n", nimages));

  image_post_deletion_clearup();

  dprintf(("Imag", "\nimage_discard: Successful. Post-clearup, there are %d images.\n\n", nimages));

  return NULL;
}

/**************************************************************/
/* image_destroy()                                            */
/*                                                            */
/* Close down any fetch associated with an image, deal with   */
/* any references to it (e.g. the background_image field of a */
/* browser_data structure), and remove all data except for    */
/* the actual image_info array entry. The item is marked as   */
/* deleted.                                                   */
/*                                                            */
/* Callers should be aware of the need to call                */
/* image_post_deletion_clearup as soon as possible after a    */
/* round of image deletions.                                  */
/*                                                            */
/* Parameters: Number of the image to remove.                 */
/**************************************************************/

static void image_destroy(int image)
{
  dprintf(("Imag", "image_destroy: Called for image %d\n", image));

  /* If the image was being fetched, close that session */

  if (idata[image].handle)
  {
    html_close(idata[image].handle);
    idata[image].handle = 0;
  }

  if (idata[image].istore)
  {
    #ifdef STRICT_PARSER

      /* Report any errors as Continue-only in strict parser mode */

      _kernel_oserror * e;

      e = idata[image].istore -> Delete(idata[image].istore);

      if (e)
      {
        e->errnum = Utils_Error_Custom_Message;
        show_error_ret(e);
      }

    #else

      /* If not in Strict mode, ignore any errors */

      idata[image].istore -> Delete(idata[image].istore);

    #endif

    idata[image].istore = NULL;
  }

  /* Get rid of associated data except the image_info struct */

  image_remove_all_data(image);

  /* Clear the background image field of the owner if necessary */

  if (idata[image].owner->background_image == image)
  {
    idata[image].owner->background_image = -1;
  }

  /* Mark the image as deleted */

  image_mark_as_deleted(image);

  dprintf(("Imag", "image_destroy: Image %d deleted\n\n", image));
}

/**************************************************************/
/* image_renumber()                                           */
/*                                                            */
/* Move an image in the image array. Copies over the          */
/* structure from new position to old and marks the old as    */
/* deleted.                                                   */
/*                                                            */
/* Destination image number must be a deleted image!          */
/*                                                            */
/* Parameters: Image's current number;                        */
/*                                                            */
/*             Image's desired number.                        */
/*                                                            */
/* Returns:    1 if the item was renumbered, 0 if there was a */
/*             problem (e.g. parameters out of range,         */
/*             destination image not deleted, etc.).          */
/**************************************************************/

static int image_renumber(int old, int new)
{
  if (
       old < 0        ||
       new < 0        ||
       old >= nimages ||
       new >= nimages ||
       old == new
     )
     return 0;

  if (!idata[new].deleted)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "In image_renumber, %d can't be renumbered to %d as the latter has not been deleted!",
              old,
              new);

      show_error_ret(&erb);

    #endif

    return 0;
  }

  /* First off, repoint any images which xref this one, if this */
  /* image has image data (else it can't be xref'd)             */

  if (idata[old].istore)
  {
    int i;

    for (i = 0; i < nimages; i++)
    {
      if (idata[i].xref == old) idata[i].xref = new;
    }
  }

  /* Sort out background images */

  if (idata[old].owner->background_image == old) idata[old].owner->background_image = new;

  /* Copy the old structure into the new position */

  idata[new] = idata[old];

  /* Reregister filler functions, if necessary */

  if (idata[new].hadfiller)
  {
    /* If so, then provided the filler function is still available, */
    /* reregister with the new image number.                        */

    if (!idata[new].istore->RegisterFiller)
    {
      idata[new].hadfiller = 0;
    }
    else
    {
      show_error_ret(image_register_filler(new));
    }
  }

  /* Update the associated token */

  #ifdef FAST_TOKEN_REFERENCE

    if (idata[new].token)
    {
      idata[new].token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
      idata[new].token->flags |= ((new + 1) << FAST_TOKEN_REFERENCE_SHIFT);
    }

  #endif

  /* Mark the old item as deleted. */

  image_mark_as_deleted(old);

  /* Finished */

  return 1;
}

/**************************************************************/
/* image_purge_deleted_entries()                              */
/*                                                            */
/* Gets rid of items in the image array which are marked as   */
/* deleted by renumbering things to fill holes and then       */
/* shrinking the image array block.                           */
/*                                                            */
/* Assumes nimages is set up to include all of the image      */
/* array entries (i.e. it hasn't been decremented yet) and    */
/* decrements it before exitting.                             */
/*                                                            */
/* Images marked as deleted but still in the image array MUST */
/* ALWAYS BE REMOVED by this function before anything else    */
/* goes on after a round of deleting things. Deleted images   */
/* will cause significant problems if run through the rest of */
/* the image system...!                                       */
/*                                                            */
/* This function does not touch any allocation blocks other   */
/* than idata, holding the array of image_info structures.    */
/* The caller should clean up any other image related data    */
/* when going through images marking them as deleted.         */
/*                                                            */
/* Returns:    1 if any items were deleted (so nimages will   */
/*             have been decremented appropriately), else 0.  */
/**************************************************************/

static int image_purge_deleted_entries(void)
{
  int first_space = -1;
  int last_live   = -1;
  int finished    = 0;

  int i;
  int newsize;

  dprintf(("Imag", "image_purge_deleted_entries: Called\n"));

  /* Shuffle non-deleted items from higher in the image */
  /* array down into free places currently held by      */
  /* deleted items lower down. On the whole, we're      */
  /* likely to shuffle less data and renumber fewer     */
  /* images this way than by a dumb "shuffle data down  */
  /* over the deleted hole" approach.                   */

  do
  {
    /* Find the first deleted item in the array */

    for (
          i = first_space == -1 ? 0 : first_space;
          i < nimages;
          i++
        )
    {
      if (idata[i].deleted)
      {
        first_space = i;
        break;
      }
    }

    if (first_space == -1)
    {
      dprintf(("Imag", "image_purge_deleted_entries: No images are marked as deleted, exitting\n"));

      return 0;
    }

    /* Find the last non-deleted (live) item in the array */

    for (
          i = last_live == -1 ? (nimages - 1) : last_live;
          i >= 0;
          i--
        )
    {
      if (!idata[i].deleted)
      {
        last_live = i;
        break;
      }
    }

    /* If we can find a live image, proceed */

    if (last_live != -1)
    {
      if (first_space > last_live)
      {
        /* If the first space is above the last live item, we */
        /* can just shrink the array.                         */

        nimages = first_space; /* I.e. last_live + 1 */

        #ifdef TRACE

          if (first_space - last_live != 1)
          {
            erb.errnum = Utils_Error_Custom_Normal;

            StrNCpy0(erb.errmess,
                     "You're imagining this error from image_purge_deleted_entries, because it is impossible for it to occur.");

            show_error_ret(&erb);
          }

        #endif

        finished = 1;
      }
      else
      {
        /* If the first space is below the last live item, must start */
        /* moving things around. Ho hum.                              */

        dprintf(("Imag", "image_purge_deleted_entries: Renumbering %d to %d\n", last_live, first_space));

        image_renumber(last_live, first_space);
      }
    }

    /* If there are no live images, can exit the loop */

    else
    {
      dprintf(("Imag", "image_purge_deleted_entries: There are no images left\n"));

      nimages  = 0;
      finished = 1;
    }
  }
  while (!finished);

  /* Check lastimage is OK */

  if (lastimage >= nimages) lastimage = nimages - 1;

  /* Ensure the image_info data block matches the size of the images now present */

  newsize = nimages * sizeof(image_info);

  #ifdef TRACE
    {
      int oldsize;

      oldsize    = flex_size((flex_ptr) &idata);
      flexcount -= (oldsize - newsize);

      dprintf(("CFle", "**   flexcount: %d\n",flexcount));
    }
  #endif

  if (idata)
  {
    if (newsize) flex_extend ((flex_ptr) &idata, newsize);
    else         flex_free   ((flex_ptr) &idata);
  }

  dprintf(("Imag", "image_purge_deleted_entries: Successful, nimages now %d\n", nimages));

  return 1;
}

/**************************************************************/
/* image_post_deletion_clearup()                              */
/*                                                            */
/* After deleting a set of images or image_info structures    */
/* which had no associated data in ImageLib, call this to     */
/* tidy up - deregister the animation handler, resize the     */
/* idata flex block, etc.                                     */
/**************************************************************/

static void image_post_deletion_clearup(void)
{
  int i;

  dprintf(("Imag", "image_post_deletion_clearup: Called\n"));

  _swix(Hourglass_Start, _IN(0), 1);

  /* Compact the image_info array and shrink the idata flex block; */
  /* if the function returns 0 we've no work to do here            */

  if (image_purge_deleted_entries())
  {
    /* If there is an animation handler present, but no animated */
    /* images remain, remove that handler.                       */

    if (animhandler)
    {
      int found = 0;

      dprintf(("Imag", "image_post_deletion_clearup: There is an animation handler present; checking to see if it can be removed\n"));

      for (i = 0; i < nimages; i++)
      {
        if (idata[i].istore && idata[i].istore->animated)
        {
          found = 1;
          break;
        }
      }

      if (!found)
      {
        dprintf(("Imag", "image_post_deletion_clearup: Removing animation handler\n\n"));

        deregister_null_claimant(Wimp_ENull, (WimpEventHandler *) image_animate_images, NULL);
        animhandler = 0;
      }

      #ifdef TRACE

        else dprintf(("Imag", "image_post_deletion_clearup: The handler is still required\n\n"));

      #endif
    }
  }

  /* Trace build sanity check */

  #ifdef FAST_TOKEN_REFERENCE
    #ifdef TRACE

      {
        for (i = 0; i < nimages; i ++)
        {
          if (idata[i].token && (idata[i].token->flags >> FAST_TOKEN_REFERENCE_SHIFT) - 1 != i)
          {
            dprintf(("Imag", "image_post_deletion_clearup: \0211Image %d is referenced incorrectly by its token\0217 - correcting...\n", i));

            idata[i].token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
            idata[i].token->flags |= ((i + 1) << FAST_TOKEN_REFERENCE_SHIFT);
          }
        }
      }

    #endif
  #endif

  _swix(Hourglass_Off, 0);

  dprintf(("Imag", "image_post_deletion_clearup: Successful\n"));

  return;
}

/**************************************************************/
/* image_gc()                                                 */
/*                                                            */
/* Garbage collect unused images.                             */
/*                                                            */
/* If removing only one specific image (see parameters list), */
/* image_post_deletion_clearup is NOT called - it is assumed  */
/* that the caller of this function may want to remove        */
/* several images and it would be very inefficient to clear   */
/* up after each one. So, if a specific unique ID is given    */
/* for image removal, the caller must remember to invoke      */
/* image_post_deletion_clearup.                               */
/*                                                            */
/* It is assumed that for any images marked as suitable for   */
/* GC, the owner browser still exists. Consequently, this     */
/* function MUST be called for a given browser if that        */
/* browser is about to be shut down.                          */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images to collect or NULL to remove any    */
/*             images regardless of owner;                    */
/*                                                            */
/*             Unique ID of a specific image to remove - 0 to */
/*             remove all images regardless of ID;            */
/*                                                            */
/*             If removing images regardless of unique ID (0  */
/*             is passed above), images with the 'from_js'    */
/*             flag set are still not removed unless a        */
/*             non-zero value is passed here.                 */
/**************************************************************/

_kernel_oserror * image_gc(browser_data * b, unsigned int uid, int remove_js_too)
{
  int i;
  int clearup = 0;

  /* UID is zero; remove all pending images */

  if (uid == 0)
  {
    /* Count backwards as we may remove idata array items */
    /* during the loop's execution                        */

    for (i = nimages - 1; i >= 0; i --)
    {
      if (
           (!b || idata[i].owner == b)          &&
           (remove_js_too || !idata[i].from_js) &&
           !idata[i].token
         )
      {
        image_destroy(i);
        clearup = 1;
      }
    }
  }

  /* Find the given unique ID */

  else
  {
    int i;
    int found = -1;

    for (i = 0; i < nimages; i ++)
    {
      if (idata[i].unique_id == uid)
      {
        found = i;
        break;
      }
    }

    if (found >= 0)
    {
      /* Found it - check it's not in use still! */

      #ifdef TRACE

        if (idata[found].token)
        {
          erb.errnum = Utils_Error_Custom_Normal;

          StrNCpy0(erb.errmess, "Unique ID given to image_gc() refers to an image with a non-NULL token field!");

          return &erb;
        }

      #else

        if (idata[found].token) return NULL;

      #endif

      /* OK, get rid of the item */

      image_destroy(found);
      clearup = 1;
    }

    #ifdef TRACE

      else
      {
        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess, "Unique ID not recognised in image_gc()");

        return &erb;
      }

    #endif
  }

  if (clearup) image_post_deletion_clearup();

  return NULL;
}

/**************************************************************/
/* image_gc_js()                                              */
/*                                                            */
/* Garbage collect unused images with the 'from_js' flag set. */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images to collect or NULL to remove any    */
/*             images regardless of owner.                    */
/**************************************************************/

_kernel_oserror * image_gc_js(browser_data * b)
{
  // "Placeholder" function...

  return NULL;
}

/**************************************************************/
/* image_gc_oldest()                                          */
/*                                                            */
/* Remove the oldest image which is pending garbage           */
/* collection owned by a given browser.                       */
/*                                                            */
/* Calls image_gc with a specific image unique ID, therefore  */
/* image_post_deletion_clearup is not called - the caller of  */
/* this function must remember to do that.                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image to remove.                           */
/*                                                            */
/* Returns:    1 if an item was removed, else 0.              */
/**************************************************************/

static int image_gc_oldest(browser_data * b)
{
  int    i;
  int    found  = -1;
  time_t oldest = time(NULL);

  dprintf(("Imag", "image_gc_oldest: Called for %p\n",b));

  /* Look for the oldest item */

  for (i = 0; i < nimages; i ++)
  {
    if (
         idata[i].owner == b &&
         !idata[i].token     &&
         !idata[i].from_js
       )
    {
      if (difftime(idata[i].last_used, oldest) < 0)
      {
        oldest = idata[i].last_used;
        found  = i;
      }
    }
  }

  /* If we got one, remove it */

  #ifdef TRACE
    if (found >= 0) dprintf(("Imag", "image_gc_oldest: Oldest is %d\n", found));
    else            dprintf(("Imag", "image_gc_oldest: No appropriate image found\n"));
  #endif

  if (found >= 0) image_gc(b, idata[found].unique_id, 0);

  /* Say whether or not one was removed */

  dprintf(("Imag", "image_gc_oldest: Successful\n"));

  return found >= 0 ? 1 : 0;
}

/**************************************************************/
/* image_maybe_gc()                                           */
/*                                                            */
/* Possibly garbage collect unused images for the given       */
/* browser.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct who's images  */
/*             may be garbage collected.                      */
/**************************************************************/

_kernel_oserror * image_maybe_gc(browser_data * b)
{
  int gc;
  int any = 0;

  _swix(Hourglass_On, 0);

  /* Keep going until we don't need to GC anymore... */

  do
  {
    gc = 0;

    /* Deal with the free RAM constraint */

    if (choices.free_ram_limit > 0)
    {
      unsigned int free;

      if (
           !_swix(Wimp_SlotSize,
                  _INR(0,1) | _OUT(2),

                  -1,
                  -1,

                  &free)
         )
      {
        if (free < choices.free_ram_limit) gc = 1;
      }
    }

    /* Deal with the unused images constraint */

    if (choices.unused_image_limit > 0)
    {
      int i;
      int unused = 0;

      for (i = 0; i < nimages; i ++)
      {
        if (
             idata[i].owner == b &&
             !idata[i].token     &&
             !idata[i].from_js
           )
           unused ++;
      }

      if (unused > choices.unused_image_limit) gc = 1;
    }
    else if (choices.unused_image_limit == 0) gc = 1;

    /* If required, get rid of the oldest image */

    if (gc) any = 1, gc = image_gc_oldest(b);
  }
  while (gc);

  /* Clear up after deletions, if there were any */

  if (any) image_post_deletion_clearup();

  _swix(Hourglass_Off, 0);

  return NULL;
}

/**************************************************************/
/* image_refetch()                                            */
/*                                                            */
/* Reloads an image, redrawing as required and setting the    */
/* priority flag as asked.                                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images;                                    */
/*                                                            */
/*             The image number;                              */
/*                                                            */
/*             Value to set Priority flag to (so that if      */
/*             'show foreground images' is turned off, the    */
/*             image will override it);                       */
/*                                                            */
/*             1 to redraw the image, 0 to not bother (e.g.   */
/*             for many images, may want to redraw the whole  */
/*             window instead).                               */
/**************************************************************/

static void image_refetch(browser_data * b, int image, int priority, int redraw)
{
  int i;

  /* Sanity check */

  if (image < 0 || image >= nimages || !b) return;

  /* Use the cross referenced base image if necessary */

  if (idata[image].xref >= 0) image = idata[image].xref;

  if (
       (
         !idata[image].fetched &&  /* If the image isn't fetched...  */
         idata[image].delayed      /* ...and was flagged as delayed, */
       )
       ||
       (
         idata[image].fetched  &&  /* or has fetched but...       */
         !idata[image].success &&  /* ...not successfully, and... */
         !idata[image].istore      /* ...it has no ImageLib entry */
       )
     )
  {
    /* If the image says it isn't fetched, reset its 'bytesgot' counter */

    if (!idata[image].fetched) idata[image].bytesgot = 0;

    /* Set up the flags */

    idata[image].success  = 0;
    idata[image].delayed  = 0;
    idata[image].fetched  = 0;
    idata[image].priority = priority;

    /* If we deleted the ImageLib entry, need to recreate it */

    if (!idata[image].istore && idata[image].xref == -1)
    {
      #ifdef ALL_FAST
        idata[image].istore = NewImage(NULL, IMAGE_FAST);
      #else
        idata[image].istore = NewImage(NULL, image == b->background_image ? IMAGE_FAST : 0);
      #endif
    }

    /* Now handle the fetching */

    if (!b->fetch_handler)
    {
      fetchpage_claim_nulls(b);
      toolbars_update_status(b, Toolbars_Status_GetPics);
    }
  }
  else
  {
    /* If the image is already loaded, just redraw it */

    idata[image].priority = priority;
    idata[image].hadfirst = 0;

    if (redraw) image_update_image(b, image, NULL);
  }

  /* Deal with all cross referencers of the base image */

  for (i = 0; i < nimages; i++)
  {
    if (idata[i].xref == image)
    {
      idata[i].priority = priority;
      idata[i].hadfirst = 0;

      if (redraw) image_update_image(b, i, NULL);
    }
  }
}

/**************************************************************/
/* image_reload()                                             */
/*                                                            */
/* Reloads an image, redrawing as required and setting the    */
/* priority flag so that even if a browser has 'show          */
/* foreground images' turned off, the reloading image (and    */
/* all that cross reference it) will still be shown.          */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images;                                    */
/*                                                            */
/*             Address of the token representing the image.   */
/**************************************************************/

void image_reload(browser_data * b, HStream * token)
{
  int image = image_get_token_image_xref(b, token);

  if (image < 0) return;

  image_refetch(b, image, 1, 1);
}

/**************************************************************/
/* image_restart_fetches()                                    */
/*                                                            */
/* If image loading has been suspended for any reason, it can */
/* be resumed by calling this function. Any images already    */
/* loaded will be reshown. The priority flag for images is    */
/* not set, so the browser must be set to display foreground  */
/* images for anything to show up.                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images;                                    */
/*                                                            */
/*             1 to restart foreground fetches, else 0;       */
/*                                                            */
/*             1 to restart background fetches, else 0.       */
/**************************************************************/

void image_restart_fetches(browser_data * b, int foreground, int background)
{
  if (nimages)
  {
    int image;

    /* Loop round all the images */

    for (image = 0; image < nimages; image++)
    {
      /* If an image has not been fetched and is flagged as being */
      /* delayed, or an image has been fetched but has not been   */
      /* flagged as succesfully fetched and has not been dealt    */
      /* with by the image library (the istore field is NULL),    */
      /* then clear all the fetch flags for the image so that it  */
      /* will later be fetched.                                   */

      if (idata[image].owner == b)
      {
        /* Only fetch foreground or background images if asked to */

        if (
             (idata[image].background  && background) ||
             (!idata[image].background && foreground)
           )
           image_refetch(idata[image].owner, image, 0, 0);
      }
    }
  }
}

/**************************************************************/
/* image_update_area()                                        */
/*                                                            */
/* Updates (redraws) part of an image, which will reflect any */
/* new data fetched for it if the whole image hasn't been     */
/* fetched yet.                                               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The left hand X window coordinate in OS units  */
/*             for the image;                                 */
/*                                                            */
/*             The bottom Y window coordinate in OS units for */
/*             the image;                                     */
/*                                                            */
/*             A BBox defining a rectangle relative to X and  */
/*             Y which is the area to update;                 */
/*                                                            */
/*             The image number, from 0 to nimages - 1;       */
/*                                                            */
/*             1 to force a redraw (i.e. clear any previously */
/*             drawn data first), zero to not clear the       */
/*             region.                                        */
/**************************************************************/

static _kernel_oserror * image_update_area(browser_data * b, int x, int y, BBox * ubox,
                                           int image, int redraw)
{
  _kernel_oserror       * e;
  WimpRedrawWindowBlock   r;
  int                     more, sx, sy;
  int                     xref;

  dprintf(("Imag", "image_update_area: Called for image %d\n",image));

  /* Zero width/height images are invisible */

  if (ubox->xmax - ubox->xmin == 0 || ubox->ymax - ubox->ymin == 0)
  {
    dprintf(("Imag", "image_update_area: Image has 0 width or height, so don't need to redraw anything\n"));

    return NULL;
  }

  /* If the image cannot be redrawn yet, don't redraw it... */

  if (!idata[image].canredraw)
  {
    dprintf(("Imag", "image_update_area: Image %d can't be redrawn yet (canredraw = 0)\n",image));

    return NULL;
  }

  r.window_handle = b->window_handle;

  r.visible_area  = *ubox;

  r.visible_area.xmin += x;
  r.visible_area.ymin += y;
  r.visible_area.xmax += x;
  r.visible_area.ymax += (y + 4);

  /* Ensure that 'xref' holds the number of the given image, which may well */
  /* cross reference another, 'image', that has the actual render data.     */

  xref = image;
  if (idata[image].xref >= 0) image = idata[image].xref;

  /* If the image may acquire a mask during rendering, even if it is not    */
  /* initially transparent, need to force the area to redraw to clear first */

  if (
       idata[image].istore->mutable_mask ||
       redraw
     )
     wimp_force_redraw(r.window_handle,
                       r.visible_area.xmin,
                       r.visible_area.ymin,
                       r.visible_area.xmax,
                       r.visible_area.ymax);
  else
  {
    /* Otherwise, do a less flickery non-clearing update */

    wimp_update_window(&r, &more);

    sx = coords_x_toscreen(x, &r);
    sy = coords_y_toscreen(y, &r);

    while(more)
    {
      if (
           b->show_foreground                     ||
           b->displayed == Display_External_Image ||
           idata[xref].priority
         )
      {
        e = redrawcore_image(b,
                             xref,
                             scale_os_to_user(b, sx),
                             scale_os_to_user(b, sy),
                             scale_os_to_user(b, idata[xref].currw),
                             scale_os_to_user(b, idata[xref].currh));

        #ifdef STRICT_PARSER

          if (e)
          {
            e->errnum = Utils_Error_Custom_Message;
            show_error_ret(e);
          }

        #endif
      }

      #ifdef ANTI_TWITTER

        if (!printing) anti_twitter(&r);

      #endif

      wimp_get_rectangle(&r,&more);
    }
  }

  dprintf(("Imag", "image_update_area: Successful\n"));

  return NULL;
}

/**************************************************************/
/* image_update_image()                                       */
/*                                                            */
/* Update the specified image number on screen, including all */
/* which cross reference it. If the image has changed size on */
/* screen then start a reformat from the first occurrence     */
/* (i.e. smallest token number), otherwise just do an update  */
/* on the relevant rectangle for each occurrence.             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images;                                    */
/*                                                            */
/*             The image number, from 0 to nimages - 1;       */
/*                                                            */
/*             Pointer (which may be NULL) to a BBox into     */
/*             which the image's size will be returned.       */
/**************************************************************/

static _kernel_oserror * image_update_image(browser_data * b, int image, BBox * box)
{
  int  i, actual;
  int  istart, iend;
  BBox whole;

  dprintf(("Imag", "image_update_image: Called for image %d\n",image));

  /* If a BBox is passed in here, then the image will be redrawn in that */
  /* specific region. Otherwise, the region is derived from the image's  */
  /* size. The BBox 'whole' is used for the latter case, so by setting   */
  /* 'box' to the address of this if a BBox was *not* given, we can then */
  /* transparently use this elsewhere and update either the requested    */
  /* area or the whole image without needing other special case code.    */
  /*                                                                     */
  /* If the image's 'hadfirst' flag is clear, it hasn't been through     */
  /* this function yet. In that case, want to ensure that the whole      */
  /* image is redrawn to clear any placeholder that will be plotted in   */
  /* its place; otherwise, only the part of the placeholder that         */
  /* corresponds to the requested redraw box will be cleared.            */

  if (!box || !idata[image].hadfirst) box = &whole;

  /* Now ensure that 'image' is the image with the render information, as */
  /* the rest of the code has to deal with all xref images to this one    */
  /* anyway.                                                              */
  /*                                                                      */
  /* So 'actual' is now the image number given to image_update_image, and */
  /* 'image' is the number of the image with associated render data; this */
  /* may be the same as 'actual' or may be equal to the contents of its   */
  /* 'xref' field.                                                        */

  actual = image;
  if (idata[actual].xref >= 0) image = idata[actual].xref;

  /* If there appears to be no data for the image, or it is less than */
  /* one pixel wide (i.e. not displayable for whatever reason), exit. */

  if (!idata[image].istore || (idata[image].istore && idata[image].istore->width < 1)) return NULL;

  /* Check if the image has become animated */

  if (idata[image].istore->animated)
  {
    /* If the image is animated and we haven't got a null handler */
    /* for animations, install one now.                           */

    if (!animhandler)
    {
      register_null_claimant(Wimp_ENull, (WimpEventHandler *) image_animate_images, NULL);
      animhandler = 1;
    }
  }

  /* Register a per-image filler function if it hasn't already got one */

  if (idata[image].istore->RegisterFiller && !idata[image].hadfiller)
  {
    show_error_ret(image_register_filler(image));
  }

  /* A few things are only done for images with actual image data; */
  /* only if these change do we need to worry about xrefs.         */

  if (actual == image)
  {
    /* When the image library gets some data for an image it will fill */
    /* in the width_os and height_os fields of the istore structure    */
    /* that 'image' points to. If the HTML source didn't specify a     */
    /* size for this or cross referencing images and the size is not   */
    /* the same as stored in currw / currh, flag that a reformat is    */
    /* needed for this image.                                          */

    if (
         !idata[actual].hadfirst             &&
         idata[image].istore->width_os  >= 0 &&
         idata[image].istore->height_os >= 0
       )
    {
      for (i = 0; i < nimages; i++)
      {
        if (
             (
               idata[i].xref == image ||
               i == image
             )
             && !idata[i].fixedsize
           )
        {
          BBox size;

          /* Ignore any existing currw and currh values - find the image */
          /* size based entirely on the HTML and the image itself        */

          image_get_image_size(b,
                               i,
                               &size,
                               1);

          /* Does the returned value differ from the stored size? If so, */
          /* flag that we must do a reformat for this image. It is up to */
          /* the reformatter to call back to routines in this source     */
          /* file and update currw and currh once the image is           */
          /* incorporated into a line array.                             */

          if (
               size.xmax != idata[i].currw ||
               size.ymax != idata[i].currh
             )
             idata[i].reformat = 1;
        }
      }
    }

    /* If the image is for the background, just refresh the window contents */
    /* with browser_update_window (remembering to update those windows that */
    /* cross reference the same background image, too).                     */

    if (image == idata[image].owner->background_image)
    {
      for (i = 0; i < nimages; i++)
      {
        if ((i == image || idata[i].xref == image) && idata[image].fetched)
        {
          browser_update_bottom(idata[i].owner, NULL);
        }
      }

      return NULL;
    }
  }

  /* Look through images for cross references */

  whole.xmin = whole.ymin = 0;

  if (actual == image) istart = 0,      iend = nimages - 1;
  else                 istart = actual, iend = actual;

  for (i = istart; i <= iend; i++)
  {
    /* If we're on the current image, or on one which  */
    /* references it, then proceed.                    */

    if (i == image || idata[i].xref == image)
    {
      BBox partial;
      int  l;
      int  noplot = 0;

      /* Set the 'whole' BBox to the size of the base image in OS units */

      image_get_image_size(b, i, &whole, 0);

      /* Ensure the redraw box returned by the image Load call */
      /* (or the BBox 'whole' from above) is scaled to fit the */
      /* actual image's dimensions.                            */
      /*                                                       */
      /* We don't scale if box = &whole, as in that case the   */
      /* bbox is already scaled, or if for some reason the     */
      /* width or height fields in the ImageLib image struct   */
      /* seem to be invalid.                                   */

      if (
           box != &whole                      &&
           idata[image].istore->width_os  > 0 &&
           idata[image].istore->height_os > 0
         )
      {
        partial.xmin = (box->xmin * whole.xmax) / idata[image].istore->width_os;
        partial.ymin = (box->ymin * whole.ymax) / idata[image].istore->height_os;
        partial.xmax = (box->xmax * whole.xmax) / idata[image].istore->width_os;
        partial.ymax = (box->ymax * whole.ymax) / idata[image].istore->height_os;
      }
      else partial = *box;

      /* If the image doesn't have position information, can't plot it */

      if (idata[i].x == -1 && idata[i].y == -1) noplot = 1;

      /* Only continue if the line containing a chunk */
      /* relating to the token which relates to this  */
      /* image (!) can be found.                      */

      if (idata[i].token) l = tokenutils_find_ancestor_line(idata[i].owner, idata[i].token);
      else                l = -1;

      if (l < 0) noplot = 1;

      /* May not be redrawing the image, but might still want to */
      /* reformat the page here if the size has changed.         */

      if (noplot)
      {
        if (!idata[i].hadfirst && !idata[i].fixedsize)
        {
          /* This is the first time we've known how big the image is since it   */
          /* was encountered in the HTML; record it in the image history, then. */

          if (idata[i].istore)
          {
            /* Ignore errors, this isn't vital */

            imghistory_record((const char **) &idata[i].flex->urldata,
                              0,
                              idata[i].istore->width_os,
                              idata[i].istore->height_os);
          }

          /* Now do the reformat, if the size changed */

          idata[i].hadfirst = 1;

          if (idata[i].reformat)
          {
            idata[i].reformat = 0;

            if (l >= 0) reformat_format_from(idata[i].owner,
                                             l - 1,
                                             0,
                                             i);
          }

         /* If we don't need to reformat, we can (potentially!) redraw */

          else idata[i].canredraw = 1;
        }
      }
      else
      {
        int       x, y;
        BBox      ibox;
        HStream * tp;

        x  = idata[i].x;
        y  = idata[i].y;
        tp = idata[i].token;

        if (
             tp &&
             !reformat_get_image_size(idata[i].owner,
                                      tp,
                                      &ibox)
           )
        {
          /* If the image size was obtained without error, */
          /* correct its X and Y coordinates appropriately */

          if (!idata[i].hadfirst)
          {
            int do_redraw = 1;

            idata[i].hadfirst = 1;

            /* Is the image size fixed in the HTML? If not, may need to do a */
            /* reformat.                                                     */

            if (!idata[i].fixedsize)
            {
              /* As above, this is the first time we've known how big the image is */
              /* since it was encountered in the HTML, so record it in the image   */
              /* history.                                                          */

              if (idata[i].istore)
              {
                /* Ignore errors, this isn't vital */

                imghistory_record((const char **) &idata[i].flex->urldata,
                                  0,
                                  idata[i].istore->width_os,
                                  idata[i].istore->height_os);
              }

              /* If the size changed, do a reformat */

              if (idata[i].reformat)
              {
                idata[i].reformat = 0;
                do_redraw         = 0; /* Reformatting - no extra redraws needed */

                reformat_format_from(idata[i].owner, l - 1, 0, i);
              }

              /* If we don't need to reformat, we can redraw */

              else idata[i].canredraw = 1;
            }

            /* If no reformat was needed, just do a redraw (which clears the */
            /* background first; see the very large comment earlier on). NB, */
            /* we don't need to force a redraw if the image is animated as   */
            /* regardless of whether or not it has a mask, the composition   */
            /* through the filler function leads to an unmasked image plot   */
            /* at the end of the day.                                        */

            if (do_redraw)
            {
              int animated, ai;

              if (idata[i].xref >= 0) ai = idata[i].xref;
              else                    ai = 0;

              if (idata[ai].istore) animated = idata[ai].istore->animated;
              else                  animated = 0;

              image_update_area(idata[i].owner,
                                x,
                                y,
                                &partial,
                                i,
                                !animated);
            }
          }

          /* Work out what region to redraw (may only require */
          /* a partial area update)                           */

          else if (partial.ymax < partial.ymin)
          {
            BBox ubox = partial;

            /* If the y max coordinate is less than the y min coordinate, */
            /* redraw from ymin to the top of the image, and from ymax to */
            /* the bottom. That way can miss out a middle section.        */

            ubox.ymin = partial.ymin;
            ubox.ymax = whole.ymax;

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &ubox,
                              i,
                              0);

            ubox.ymax = partial.ymax;
            ubox.ymin = 0;

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &ubox,
                              i,
                              0);
          }
          else if (partial.xmax < partial.xmin)
          {
            BBox ubox = partial;

            /* Similarly, if xmax is less than xmin, draw from xmin to the */
            /* right hand side of the image and from xmax to the left, so  */
            /* a vertical strip in the middle may be untouched.            */

            ubox.xmin = partial.xmin;
            ubox.xmax = whole.xmax;

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &ubox,
                              i,
                              0);

            ubox.xmax = partial.xmax;
            ubox.xmin = 0;

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &ubox,
                              i,
                              0);
          }
          else
          {
            /* Otherwise, redraw the requested box */

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &partial,
                              i,
                              0);
          }

        /* Closure of 'if (tp && !reformat_get_image_size(...))' */
        }

      /* Closure of 'if (noplot)' - code immediately above is */
      /* executed in the 'else' section.                      */
      }

    /* Closure of 'if (i == image || idata[i].xref == image)' */
    }

  /* Closure of loop running round all the images */
  }

  dprintf(("Imag", "image_update_image: Successful\n"));

  return NULL;
}

/**************************************************************/
/* image_animate_images()                                     */
/*                                                            */
/* Checks all images to see if they need updating. Designed   */
/* to be called on null events.                               */
/*                                                            */
/* Parameters are as standard for a Wimp event handler.       */
/**************************************************************/

int image_animate_images(int eventcode, WimpPollBlock * block, IdBlock * idb, browser_data * handle)
{
  int i, image, redraw;

  /* Scan round all images */

  for (i = 0; i < nimages; i++)
  {
    /* Find the image with associated render data */

    if (idata[i].xref >= 0) image = idata[i].xref;
    else                    image = i;

    /* Skip this image if it as already been dealt with */

    if (image >= i)
    {
      /* If this image does have such data, is flagged as */
      /* animated, and has a pointer to a NeedRedraw      */
      /* function, proceed.                               */

      if (
           idata[image].istore             &&
           idata[image].istore->animated   &&
           idata[image].istore->NeedRedraw
         )
      {
        BBox extent;

        #ifdef STRICT_PARSER

          /* Report any errors as Continue-only in strict parser mode */

          _kernel_oserror * e;

          e = idata[image].istore -> NeedRedraw(idata[image].istore, &redraw, &extent);

          if (e)
          {
            e->errnum = Utils_Error_Custom_Message;
            show_error_ret(e);
          }

        #else

          /* If not in Strict mode, ignore any errors */

          idata[image].istore -> NeedRedraw(idata[image].istore, &redraw, &extent);

        #endif

        /* Redraw the image, if required */

        if (redraw) image_update_image(idata[i].owner, i, NULL);
      }
    }
  }

  return 0;
}

/**************************************************************/
/* image_register_filler()                                    */
/*                                                            */
/* Registers the given image and it's owning browser with     */
/* ImageLib. Must be called for cross referencing images      */
/* only.                                                      */
/*                                                            */
/* Parameters: The image number to register.                  */
/**************************************************************/

static _kernel_oserror * image_register_filler(int xref)
{
  #ifdef STRICT_PARSER

    {
      _kernel_oserror * e;

      /* Report any errors as Continue-only in strict parser mode */

      e = idata[xref].istore -> RegisterFiller(idata[xref].istore,
                                               (FillerFunction *) image_fill_background,
                                               idata[xref].owner,
                                               (int *) xref);

      if (e)
      {
        e->errnum = Utils_Error_Custom_Message;
        return e;
      }
    }

  #else

    /* If not in Strict mode, don't report errors */

    idata[xref].istore -> RegisterFiller(idata[xref].istore,
                                         (FillerFunction *) image_fill_background,
                                         idata[xref].owner,
                                         (int *) xref);
  #endif

  idata[xref].hadfiller = 1;

  return NULL;
}

/**************************************************************/
/* image_fill_background()                                    */
/*                                                            */
/* Called as a FillerFunction for ImageLib, this draws        */
/* whatever background is appropriate for the registered      */
/* image. Output should have been redirected by ImageLib at   */
/* this point.                                                */
/*                                                            */
/* The way the function is registered should leave void *     */
/* handle pointing to the browser owning the image with int * */
/* i actually being an int (not an int *) holding the image   */
/* number for which the function was registered in the first  */
/* place. The owner of this image is used for all general     */
/* information - the browser given in the first pointer is    */
/* just used to spot potential errors; if the browser given   */
/* as the owner is not actually the owner of the given image, */
/* the function will exit.                                    */
/**************************************************************/

_kernel_oserror * image_fill_background(void * handle, int * i)
{
  WimpGetWindowStateBlock   state;
  _kernel_oserror         * e        = NULL;
  const browser_data      * b;// TODO        = (browser_data *) handle;

  int                       image;
  int                       ximage   = (int) i;

  int                       noplot   = 0;
  int                       bimage   = -1;
  int                       bximage  = -1;
  int                       bgcolour = -1;

  int                       is_background_image;
  int                       x, y, xorigin, yorigin;
  int                       w, h;

  dprintf(("Imag", "image_fill_background: Called with %p, %d\n", handle, (int) i));

  b      = browser_redrawing;
  ximage = image = image_redrawing;

  if (idata[ximage].xref >= 0) ximage = idata[ximage].xref;

  if (image >= nimages || image < 0)
  {
    dprintf(("Imag", "image_fill_background: \0211Serious error!\0217 Invalid image number %d. Exitting.\n",image));

    return NULL;
  }

  if (!b)
  {
    dprintf(("Imag", "image_fill_background: \0211Serious error!\0217 Null browser_data pointer. Exitting.\n"));

    return NULL;
  }

  if (!is_known_browser(b))
  {
    dprintf(("Imag", "image_fill_background: \0211Serious error!\0217 Browser %p is not a known current browser. Exitting.\n",b));

    return NULL;
  }

//  if (idata[ximage].owner != b)
//  {
//    dprintf(("Imag", "image_fill_background: \0211Serious error!\0217 Actual owner of image %d = %p, given owner = %p. Exitting.\n",ximage,idata[ximage].owner,b));
//
//    return NULL;
//  }

  state.window_handle = b->window_handle;
  e = wimp_get_window_state(&state);
  if (e) return e;

//  /* Should never happen, but you never know... */
//
//  if (idata[ximage].xref >= 0) ximage = idata[ximage].xref;
//
//  /* See the top of the file for details on browser_redrawing */
//  /* and image_redrawing                                      */
//
//  if (browser_redrawing) b = browser_redrawing;
//
//  if (image_redrawing >= -1) image = image_redrawing;
//  else                       image = ximage;

  dprintf(("Imag", "image_fill_background: Decided to use %p, %d\n"
                   "image_fill_background: Image w, h = %d, %d\n",

                   b, image,
                   idata[image].currw, idata[image].currh));

  /* Can't plot a background image to fill this one if there's no */
  /* background to plot, or if *this* is the background image.    */

  if (b->background_image >= 0)
  {
    bimage = bximage = b->background_image;
    if (idata[bximage].xref >= 0) bximage = idata[bximage].xref;
  }
  else bimage = bximage = -1, noplot = 1;

  if (image == bimage) is_background_image = 1;
  else                 is_background_image = 0;

  #ifdef TRACE
    if (bimage >= 0) dprintf(("Imag", "image_fill_background: Background image = %d, is_background_image = %d\n", bimage, is_background_image));
    else             dprintf(("Imag", "image_fill_background: No background image\n"));
  #endif

  /* The image may exist in a table, and we should check what */
  /* background colour to draw if this is the case.           */

  if (!is_background_image && idata[image].token && b->use_source_cols)
  {
    int effective_bgcolour = tokenutils_background_colour(b, idata[image].token);
    if (effective_bgcolour > -1) bgcolour = effective_bgcolour, noplot = 1;
  }

  /* If bgcolor is -1 here, there's no table cell behind the image in */
  /* question blocking the page background. Thus we may have to do a  */
  /* few more checks to see if there's a background image we need to  */
  /* plot, and either way, get the page background colour.            */

  if (bgcolour == -1)
  {
    if (!is_background_image)
    {
      if (
           !noplot &&
           (
             !idata[bximage].fetched ||
             !idata[bximage].istore
           )
         )
         noplot = 1;

      if (
           !noplot               &&
           idata[bximage].istore &&
           (
             idata[bximage].istore->width_os  <= 0 ||
             idata[bximage].istore->height_os <= 0
           )
         )
         noplot = 1;
    }

    bgcolour = redraw_backcol(b);
  }

  xorigin = -idata[image].x;
  yorigin = -idata[image].y;

  /* Ensure dithered background colours have a dithering */
  /* (ECF) pattern that starts in the right place        */

  e = _swix(OS_SetECFOrigin,
            _INR(0,1),

            -xorigin,
            -yorigin);

  if (e) return e;

  /* We need to draw a plain colour background if we're filling the */
  /* background image, if we were asked not to plot a background    */
  /* image, or if we were but that image is itself transparent -    */
  /* that is, has a simple mask (alpha blended backgrounds will     */
  /* have their own filler function and we get called back when we  */
  /* invoke Render on the image further down). We also need to show */
  /* the plain background if background images are disabled for     */
  /* general display or for printing (and we're in a print loop).   */

  if (
       is_background_image                ||
       noplot                             ||
       idata[bximage].istore->transparent ||
       !b->show_background                ||
       (
         printing &&
         !printstyle_show_all()
       )
     )
  {
    BBox user_box;

    user_box.xmin = user_box.ymin = 0;

    scale_pair_os_to_user(b,
                          idata[ximage].istore -> width_os,
                          idata[ximage].istore -> height_os,
                          &user_box.xmax,
                          &user_box.ymax);

    RetError(redrawcore_rectangle(b,
                                  &user_box,
                                  bgcolour,
                                  0));
  }

  /* If there's no background image to plot, exit here */

  if (
       is_background_image ||
       !b->show_background ||
       noplot              ||
       (
         printing &&
         !printstyle_show_all()
       )
     )
  {
    dprintf(("Imag", "image_fill_background: No background image to plot, so successful (exitting)\n"));

    return NULL;
  }

  /* Find the scale for the background plotting; if the foreground */
  /* image is scaled, then plotting the background at 1:1 will     */
  /* make it look scaled by the same amount, and things won't      */
  /* match up. We could either prescale the foreground image and   */
  /* then plot into that prescaled image, but this takes a lot     */
  /* of memory, or we could try to stick with a post-scaled image. */
  /* In that case, the background can either be ignored or we can  */
  /* try to scale it down so though it will look blocky and low    */
  /* resolution, it will at least roughly line up with the things  */
  /* around the foreground. This code does the last of the three.  */
  /*                                                               */
  /* Note the faster, simpler routine for scalings of 1:1 - avoids */
  /* floating point.                                               */

  if (
       idata[image].currw != idata[ximage].istore->width_os  ||
       idata[image].currh != idata[ximage].istore->height_os
     )
  {
    BBox           redraw;
    float          scalex, scaley;
    float          tempx,  tempy;
    float          tempw,  temph;
    int            htop;
    int            user_w, user_h;

    dprintf(("Imag", "image_fill_background: Plotting scaled background\n"));

    tempx = (float) idata[ximage].istore->width_os, tempy = (float) idata[ximage].istore->height_os;
    tempw = (float) idata[image].currw,             temph = (float) idata[image].currh;

    scalex = tempx / tempw;
    scaley = tempy / temph;

    /* Round the background image's width and height down to pixel boundaries */

    tempw = idata[bximage].istore->width_os;
    temph = idata[bximage].istore->height_os;

    w = ((int) (tempw * scalex + (float) 0.5)) & ~(wimpt_dx() - 1);
    h = ((int) (temph * scaley + (float) 0.5)) & ~(wimpt_dy() - 1);

    /* Work out the coordinates over which to tile the image */

    tempx = - (float) (idata[image].x);

    if (!controls.swap_bars) htop = toolbars_button_height(b) + toolbars_url_height(b);
    else                     htop = toolbars_status_height(b);

    if (htop) htop += wimpt_dy();

    tempy = - (float) idata[image].y
            - (float) htop;

    xorigin = (int) (tempx * scalex + (float) 0.5) + 1;
    yorigin = (int) (tempy * scaley + (float) 0.5) + 1;

    /* Exit if the background size appears to be too small */

    if (w < 1 || h < 1) return NULL;

    redraw.xmin = -((-xorigin) % w);
    redraw.ymin = -h;
    redraw.xmax = idata[ximage].istore->width_os;
    redraw.ymax = idata[ximage].istore->height_os + (yorigin - idata[ximage].istore->height_os) % h - 1;

    idata[bximage].istore -> ModeChange(idata[bximage].istore);

    /* Render the image over the redraw region with a scaled plot */

    scale_pair_os_to_user(b, w, h, &user_w, &user_h);

    for (y = redraw.ymax - h + wimpt_dy(); y >= redraw.ymin; y -= h)
    {
      for (x = redraw.xmin; x <= redraw.xmax; x += w)
      {
        e = redrawcore_image(b,
                             bimage,
                             scale_os_to_user(b, x),
                             scale_os_to_user(b, y),
                             user_w,
                             user_h);

        if (e) break;
      }

      if (e) break;
    }

    idata[bximage].istore -> ModeChange(idata[bximage].istore);
  }
  else
  {
    BBox redraw;
    int  htop;
    int  w, h, user_w, user_h;

    dprintf(("Imag", "image_fill_background: Plotting unscaled background\n"));

    w = (idata[bximage].istore->width_os)  & ~(wimpt_dx() - 1);
    h = (idata[bximage].istore->height_os) & ~(wimpt_dy() - 1);

    xorigin = -idata[image].x;

    if (!controls.swap_bars) htop = toolbars_button_height(b) + toolbars_url_height(b);
    else                     htop = toolbars_status_height(b);

    if (htop) htop += wimpt_dy();

    yorigin = -idata[image].y - htop;

    /* Exit if the background size appears to be too small */

    if (w < 1 || h < 1) return NULL;

    redraw.xmin = -((-xorigin) % w);
    redraw.ymin = -h;
    redraw.xmax = idata[ximage].istore->width_os;
    redraw.ymax = idata[ximage].istore->height_os + (yorigin - idata[ximage].istore->height_os) % h - 1;

    idata[bximage].istore -> ModeChange(idata[bximage].istore);

    /* Render the image over the redraw region with an unscaled plot */

    scale_pair_os_to_user(b, w, h, &user_w, &user_h);

    for (y = redraw.ymax - h + wimpt_dy(); y >= redraw.ymin; y -= h)
    {
      for (x = redraw.xmin; x <= redraw.xmax; x += w)
      {
        e = redrawcore_image(b,
                             bimage,
                             scale_os_to_user(b, x),
                             scale_os_to_user(b, y),
                             user_w,
                             user_h);

        if (e) break;
      }

      if (e) break;
    }

    idata[bximage].istore -> ModeChange(idata[bximage].istore);
  }

  dprintf(("Imag", "image_fill_background: Successful\n"));

  return e;
}

/**************************************************************/
/* image_redraw_primitive()                                   */
/*                                                            */
/* Image rendering 'primitive' call.                          */
/*                                                            */
/* The supplied image number is checked, along with whether   */
/* or not that image has renderable data. The redrawing image */
/* number is stored in image_redrawing and the browser in     */
/* browser_redrawing for callback functions to check against. */
/* The old values are stacked before calling the image Render */
/* function, then restored afterwards.                        */
/*                                                            */
/* Parameters: Pointer to the browser_data struct relevant to */
/*             the image to be redrawn;                       */
/*                                                            */
/*             Number of the image (0 to nimages - 1);        */
/*                                                            */
/*             Bottom left X coordinate (screen coords);      */
/*                                                            */
/*             Bottom left Y coordinate (screen coords);      */
/*                                                            */
/*             Width at which to plot image (OS units);       */
/*                                                            */
/*             Height at which to plot image (OS units).      */
/**************************************************************/

_kernel_oserror * image_redraw_primitive
                  (
                    const browser_data * restrict b,
                    const unsigned int            image,
                    int                           x,
                    int                           y,
                    unsigned int                  width,
                    unsigned int                  height
                  )
{
  _kernel_oserror    * e;
  int                  parent;
  const browser_data * old_browser;
  int                  old_image;

  dprintf(("Imag", "image_redraw_primitive: Called for browser &%08X, image %u, (%d,%d), %u x %d\n", (int) b, image, x, y, width, height));

  if (image >= nimages)
  {
    dprintf(("Imag", "image_redraw_primitive: Image out of range, exiting\n"));
    return NULL;
  }

  /* Ensure that 'xref' holds the number of the given image, which may well */
  /* cross reference another, 'image', that has the actual render data.     */

  if (idata[image].xref >= 0) parent = idata[image].xref;
  else                        parent = image;

  if (
       idata[parent].istore         == NULL ||
       idata[parent].istore->Render == NULL
     )
  {
    dprintf(("Imag", "image_redraw_primitive: Image is not renderable, exiting\n"));
    return NULL;
  }

  /* Record the redrawing image number */

  old_browser       = browser_redrawing;
  old_image         = image_redrawing;
  browser_redrawing = b;
  image_redrawing   = image;

  /* Render the image */

  e = idata[parent].istore -> Render(idata[parent].istore,
                                     x,
                                     y,
                                     100, /* Scale factor - ignored when width and height are >= 0 */
                                     width,
                                     height);

  /* Clear the redrawing browser and image record */

  browser_redrawing = old_browser;
  image_redrawing   = old_image;

  /* Return the result of the render call */

  dprintf(("Imag", "image_redraw_primitive: Successful, returning Render call result &%08X\n", (int) e));

  return e;
}

/**************************************************************/
/* image_redraw()                                             */
/*                                                            */
/* Does a high level redraw of an image, with an outline to   */
/* show where the image should be if it isn't all plotted, or */
/* a slabbed box to display broken or unfetched images.       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Address of the token representing the image;   */
/*                                                            */
/*             The X offset in window coords (so OS units) of */
/*             the left hand edge of the image;               */
/*                                                            */
/*             The Y offset in window coords (so OS units) of */
/*             the bottom edge of the image;                  */
/*                                                            */
/*             Pointer to a BBox conventionally initialised   */
/*             to describe the current graphics window or     */
/*             redraw area in OS units (e.g. from the         */
/*             'redraw_area' field of a Wimp redraw block).   */
/**************************************************************/

_kernel_oserror * image_redraw
                  (
                    browser_data  * restrict b,
                    const HStream * restrict token,
                    int                      x,
                    int                      y,
                    const BBox    * restrict gfxwin
                  )
{
  int image, actual;
  int plotted = 0;

  dprintf(("Imag", "image_redraw: Called with token &%08X\n", (int) token));

  /* Get the image number for the given token; 'actual' holds the actual */
  /* image for the given token, which may cross reference 'image', which */
  /* holds the actual render data.                                       */

  image = actual = image_get_token_image_actual(b, token);

  if (image < 0) return NULL;

  if (idata[actual].xref >= 0) image = idata[actual].xref;

  /* If the image has a fetched width and height, */
  /* and the browser choices specify that images  */
  /* should be shown (or the image itself has a   */
  /* high priority show bit set), display part or */
  /* all of the image.                            */

  if (
       image  >= 0 &&
       actual >= 0 &&
       (
         b->show_foreground                     ||
         b->displayed == Display_External_Image ||
         idata[actual].priority
       )
       && idata[actual].canredraw
       && idata[image].istore             /* Must check istore here, as if width / height are <= 0, */
       && idata[image].istore->width  > 0 /* the image library has no data for the image and will   */
       && idata[image].istore->height > 0 /* not have filled in (e.g.) the Render field. So you'd   */
     )                                    /* get a rather nasty abort trying to call it!            */
  {
    _kernel_oserror * e = NULL;

    if (idata[actual].currw && idata[actual].currh)
    {
      e = redrawcore_image(b,
                           actual,
                           scale_os_to_user(b, x),
                           scale_os_to_user(b, y),
                           scale_os_to_user(b, idata[actual].currw),
                           scale_os_to_user(b, idata[actual].currh));

      #ifdef STRICT_PARSER

        if (e)
        {
          e->errnum = Utils_Error_Custom_Message;
          show_error_ret(e);
        }

      #endif
    }

    if (!e) plotted = 1;
  }

  if (!plotted)
  {
    /* If the image was not plotted, either due to error or because there's */
    /* no data yet, plot a placeholder and any present ALT text instead.    */

    BBox            box;
    const char    * text;
    const HStream * tp   = NULL;

    image_get_image_size(b, actual, &box, 0);

    box.xmin += x;
    box.ymin += y;
    box.xmax += x - box.xmin;
    box.ymax += y - box.ymin;

    box.xmin &= ~(wimpt_dx() - 1);
    box.ymin &= ~(wimpt_dy() - 1);

    /* If an image, the ALT text wants to be from the actual image, not one */
    /* that might be being cross referenced.                                */

    tp = (ISOBJECT(tp)) ? token : idata[actual].token;

    if (tp)
    {
      text = (ISOBJECT(tp)) ? HtmlOBJECTstandby((HStream *) tp) : tp->text;

      redraw_draw_placeholder(b,
                              gfxwin,
                              &box,
                              tp,
                              text);
    }
  }

  dprintf(("Imag", "image_redraw: Successful\n"));

  return NULL;
}

/*************************************************/
/* image_tile_window()                           */
/*                                               */
/* For a given redraw rectangle, tiles the       */
/* background image within that rectangle.       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the window and image; */
/*                                               */
/*             Pointer to a WimpRedrawWindow-    */
/*             Block structure defining the area */
/*             over which to tile the image;     */
/*                                               */
/*             The X and Y coordinates to take   */
/*             as the tile origin, in OS units.  */
/*                                               */
/* Returns:    1 for success, 0 for failure.     */
/*************************************************/

int image_tile_window
    (
      const browser_data          * restrict b,
      const WimpRedrawWindowBlock * restrict r,
      int                                    xorigin,
      int                                    yorigin
    )
{
  _kernel_oserror * e;
  int               x, y, w, h, user_w, user_h;
  int               xmin, ymax;
  int               image;

  dprintf(("Imag", "image_tile_window: Called, background_image = %d\n",b->background_image));

  /* Can only tile if there's a background image defined and fully fetched */

  if (b->background_image < 0) return 0;

  image = b->background_image;
  if (idata[image].xref >= 0) image = idata[image].xref;

  if (!idata[image].fetched || !idata[image].istore) return 0;

  /* Round the width and height to pixel boundaries */

  w = idata[image].istore->width_os  & ~(wimpt_dx() - 1);
  h = idata[image].istore->height_os & ~(wimpt_dy() - 1);

  if (w < 1 || h < 1) return 0;

  /* Work out the coordinates over which to tile the image */

  xmin = coords_x_toworkarea(r->redraw_area.xmin,r);
  ymax = coords_y_toworkarea(r->redraw_area.ymax,r);

  xmin -= ((xmin - xorigin) % w);
  ymax -= ((ymax - yorigin) % h) + 1;

  xmin = coords_x_toscreen(xmin, r);
  ymax = coords_y_toscreen(ymax, r);

  /* Do a blank rectangle if the image is transparent (has a mask) */

  if (idata[image].istore->transparent)
  {
    BBox user_box;

    scale_box_os_to_user(b, &r->redraw_area, &user_box);

    e = redrawcore_rectangle(b,
                             &user_box,
                             redraw_backcol(b),
                             0);

    /* Suppress errors unless in strict builds */

    #ifdef STRICT_PARSER

      if (e)
      {
        e->errnum = Utils_Error_Custom_Message;
        show_error_ret(e);

        return 0;
      }

    #endif
  }

  /* Render the image over the redraw region */

  scale_pair_os_to_user(b, w, h, &user_w, &user_h);

  for (y = ymax - h + wimpt_dy(); y >= r->redraw_area.ymin - h; y -= h)
  {
    for (x = xmin; x <= r->redraw_area.xmax; x += w)
    {
      e = redrawcore_image(b,
                           b->background_image,
                           scale_os_to_user(b, x),
                           scale_os_to_user(b, y),
                           user_w,
                           user_h);

      /* Suppress errors unless in strict builds */

      #ifdef STRICT_PARSER

        if (e)
        {
          e->errnum = Utils_Error_Custom_Message;
          show_error_ret(e);

          return 0;
        }

      #else

        if (e) return NULL;

      #endif
    }
  }

  dprintf(("Imag", "image_tile_window: Successful\n"));

  return 1;
}

/**************************************************************/
/* image_mark_as_redrawable()                                 */
/*                                                            */
/* Flags that an image may now be redrawn (this is generally  */
/* called because an unsized image has found its size, asked  */
/* for a reformat, and that reformat is about to take place). */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The image number.                              */
/**************************************************************/

void image_mark_as_redrawable(browser_data * b, int image)
{
  /* Mark the image as redrawable */

  if (idata[image].owner == b) idata[image].canredraw = 1;

  return;
}

/**************************************************************/
/* image_token_reformatted()                                  */
/*                                                            */
/* Called by a reformatter to signal an image is locked in a  */
/* line array. Sets the image's canredraw flag and locks the  */
/* image's size.                                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             image.                                         */
/**************************************************************/

void image_token_reformatted(browser_data * b, HStream * token)
{
  int  image;
  int  xref;

  /* Get the image number */

  image = image_get_token_image_actual(b, token);
  if (image < 0 || image >= nimages) return;

  if (idata[image].xref >= 0) xref = idata[image].xref;
  else                        xref = image;

  /* Lock the image size */

  image_lock_image_size(b, image);

  /* Exit if the image has no known real size yet - even if its size */
  /* is fixed in the HTML, there's no point marking it as redrawable */
  /* if there is no image data to redraw...!                         */

  if (
       !idata[xref].istore                ||
       idata[xref].istore->width_os  <= 0 ||
       idata[xref].istore->height_os <= 0
     )
     return;

  /* We do have some data and the reformatter has fixed the image in */
  /* the line array, so mark it as redrawable now.                   */

  image_mark_as_redrawable(b, image);

  return;
}

/**************************************************************/
/* image_mode_change()                                        */
/*                                                            */
/* Ensure images are up to date following a mode change.      */
/**************************************************************/

_kernel_oserror * image_mode_change(void)
{
  dprintf(("Imag", "image_mode_change: Called\n"));

  if (nimages)
  {
    int i;

    /* For each image, call the image library's mode change handling function */

    for (i = 0; i < nimages; i++)
    {
      if (idata[i].istore && idata[i].istore->width > 0 && idata[i].istore -> ModeChange)
      {
        #ifdef STRICT_PARSER

          /* Report any errors as Continue-only in strict parser mode */

          _kernel_oserror * e;

          e = idata[i].istore -> ModeChange(idata[i].istore);

          dprintf(("Imag", "image_mode_change: Exitting with error\n"));

          if (e) return e;

        #else

          /* If not in Strict mode, ignore any errors */

          idata[i].istore -> ModeChange(idata[i].istore);

        #endif
      }
    }
  }

  dprintf(("Imag", "image_mode_change: Successful\n"));

  return NULL;
}

/**************************************************************/
/* image_count_fetches()                                      */
/*                                                            */
/* Counts how many fetches are being performed for a given    */
/* web page.                                                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page and images being fetched.             */
/*                                                            */
/* Returns:    The number of image fetches that are currently */
/*             in progress (this may be zero, of course).     */
/**************************************************************/

static int image_count_fetches(browser_data * b)
{
  int i, c = 0;

  dprintf(("Imag", "image_count_fetches: Called\n"));

  /* there is a fetch handle in their image_info structs. */

  for (i = 0; i < nimages; i++) if (idata[i].handle && idata[i].owner == b) c++;

  dprintf(("Imag", "image_count_fetches: Exitting with %d\n",c));

  return c;
}

/**************************************************************/
/* image_parent()                                             */
/*                                                            */
/* A function that exposes a bit more of the internal         */
/* implementation than is ideal - given an image number,      */
/* return the parent - that is, the image number holding the  */
/* actual image data. The given number may be a cross-        */
/* referencing image. Originally written for the PDF output   */
/* routines.                                                  */
/*                                                            */
/* Parameters: Image number of interest.                      */
/*                                                            */
/* Returns:    Parent image (may be the same number as given  */
/*             as a parameter), or -1 if the given number     */
/*             appears to be invalid.                         */
/**************************************************************/

int image_parent(int image)
{
  if (image < 0 || image >= nimages) return -1;

  if (idata[image].xref >= 0) return idata[image].xref;

  return image;
}

/**************************************************************/
/* image_fetching()                                           */
/*                                                            */
/* Returns 1 if there are any image fetches going on at all,  */
/* else 0 (faster than using image_count_fetches above if you */
/* don't care how many fetches there are).                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the inquiry.                                   */
/*                                                            */
/* Returns:    1 if there are image fetches in progress, else */
/*             0.                                             */
/**************************************************************/

int image_fetching(browser_data * b)
{
  int i;

  dprintf(("Imag", "image_fetching: Called\n"));

  for (i = 0; i < nimages; i++)
  {
    if (idata[i].handle && idata[i].owner == b)
    {
      dprintf(("Imag", "image_fetching: Exitting, there is at least 1 fetch in progress\n"));

      return 1;
    }
  }

  dprintf(("Imag", "image_fetching: Exitting, no fetches in progress\n"));

  return 0;
}

/**************************************************************/
/* image_fetched()                                            */
/*                                                            */
/* Determines if an image has been completely fetched or not. */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The image number, from 0 to nimages - 1.       */
/*                                                            */
/* Returns:    1 if the image has been fetched completely,    */
/*             else 0.                                        */
/**************************************************************/

int image_fetched(browser_data * b, int image)
{
  dprintf(("Imag", "image_fetched: Called for image %d\n",image));

  if (image >= 0) return (idata[image].fetched);

  dprintf(("Imag", "image_fetched: Exitting with 0 (failed)\n"));

  return 0;
}

/**************************************************************/
/* image_token_fetched()                                      */
/*                                                            */
/* Determines if an image has been completely fetched or not, */
/* based on a token representing the image.                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to a token representing the image.     */
/*                                                            */
/* Returns:    1 if the image has been fetched completely,    */
/*             else 0.                                        */
/**************************************************************/

int image_token_fetched(browser_data * b, HStream * token)
{
  int image;

  dprintf(("Imag", "image_token_fetched: Called for token %p\n",token));

  image = image_get_token_image_xref(b, token);

  dprintf(("Imag", "image_token_fetched: Represents image %d\n"
                   "image_token_fetched: Exitting through image_fetched\n",

                   image));

  return image_fetched(b, image);
}

/**************************************************************/
/* image_total_bytes_fetched()                                */
/*                                                            */
/* Works out the total number of bytes fetched in images so   */
/* far.                                                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images.                                    */
/*                                                            */
/* Returns:    The number of bytes fetched in image data at   */
/*             the moment of calling the function.            */
/**************************************************************/

int image_total_bytes_fetched(browser_data * b)
{
  int count = 0;

  dprintf(("Imag", "image_total_bytes_fetched: Called\n"));

  /* Sum the fetched size of all images currently present, */
  /* if there are any to count.                            */

  if (nimages)
  {
    int image;

    for (image = 0; image < nimages; image++)
    {
      if (idata[image].owner == b && idata[image].token) count += idata[image].bytesgot;
    }
  }

  dprintf(("Imag", "image_total_bytes_fetched: Exitting with %d\n",count));

  return count;
}

/**************************************************************/
/* image_count_pending()                                      */
/*                                                            */
/* Counts how many images are waiting to be fetched, but have */
/* been delayed for whatever reason.                          */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images. Any images in child windows are    */
/*             also included in the count.                    */
/*                                                            */
/* Returns:    The number of images waiting to be fetched,    */
/*             counting any images in any child windows (if   */
/*             present)                                       */
/**************************************************************/

int image_count_pending(browser_data * b)
{
  int i, c = 0;

  dprintf(("Imag", "image_count_pending: Called for %p\n",b));

  if (b->nchildren)
  {
    for (i = 0; i < b->nchildren; i++)
    {
      c += image_count_pending(b->children[i]);
    }
  }
  else
  {
    for (i = 0; i < nimages; i++)
    {
      if (
           idata[i].xref < 0   &&
           idata[i].owner == b &&
           !idata[i].fetched   &&
           !idata[i].delayed
         )
         c++;
    }
  }

  dprintf(("Imag", "image_count_pending: Exitting with %d for %p\n",c,b));

  return c;
}

/**************************************************************/
/* image_count_specific_pending()                             */
/*                                                            */
/* Counts how many images are waiting to be fetched, but have */
/* been delayed for whatever reason, for just the specified   */
/* browser (not including any child windows).                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images.                                    */
/*                                                            */
/* Returns:    The number of images waiting to be fetched in  */
/*             the given browser.                             */
/**************************************************************/

int image_count_specific_pending(browser_data * b)
{
  int i, c = 0;

  dprintf(("Imag", "image_count_specific_pending: Called for %p\n",b));

  for (i = 0; i < nimages; i++)
  {
    if (
         idata[i].xref < 0   &&
         idata[i].owner == b &&
         !idata[i].fetched   &&
         !idata[i].delayed
       )
       c++;
  }

  dprintf(("Imag", "image_count_specific_pending: Exitting with %d for %p\n",c,b));

  return c;
}

/**************************************************************/
/* image_count_delayed()                                      */
/*                                                            */
/* Returns the number of images which have been delayed       */
/* (could be fetched, but have been set up to not fetch yet). */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the images.                                    */
/**************************************************************/

int image_count_delayed(browser_data * b)
{
  int count = 0;

  if (nimages)
  {
    int  i;

    for (i = 0; i < nimages; i++)
    {
      if (
           (
             !idata[i].fetched &&
             idata[i].delayed
           )
           ||
           (
             idata[i].fetched  &&
             !idata[i].success &&
             !idata[i].istore
           )
         )
         count++;
    }
  }

  return count;
}

/**************************************************************/
/* image_plot_started()                                       */
/*                                                            */
/* Returns 1 if a given image in a given browser has had some */
/* plotting done for it (so the placeholder box and possibly  */
/* ALT text will no longer be visible for it).                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The number of the image.                       */
/*                                                            */
/* Returns:    1 if the image has been partially or           */
/*             completely plotted, else 0.                    */
/**************************************************************/

int image_plot_started(browser_data * b, int image)
{
  if (image < 0) return 0;

  if (!idata[image].istore) return 0;

  if (!idata[image].canredraw) return 0;

  if (idata[image].istore->width > 0) return 1;
  else                                return 0;
}

/**************************************************************/
/* image_token_plot_started()                                 */
/*                                                            */
/* Returns 1 if a given image in a given browser has had some */
/* plotting done for it (so the placeholder box and possibly  */
/* ALT text will no longer be visible for it).                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to a token representing the image.     */
/*                                                            */
/* Returns:    1 if the image has been partially or           */
/*             completely plotted, else 0.                    */
/**************************************************************/

int image_token_plot_started(browser_data * b, HStream * token)
{
  int image;

  image = image_get_token_image_xref(b, token);

  return image_plot_started(b, image);
}

/**************************************************************/
/* image_get_token_image_xref()                               */
/*                                                            */
/* Finds the image number associated with a given token. The  */
/* number will be the image that actually has the associated  */
/* image data, not just one that cross references this data.  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The token address.                             */
/*                                                            */
/* Returns:    The image number which references that token,  */
/*             or -1 if none found.                           */
/**************************************************************/

static int image_get_token_image_xref
           (
             const browser_data * restrict b,
             const HStream      * restrict token
           )
{
  int found = -1;

  #ifndef FAST_TOKEN_REFERENCE
    int i;
  #endif

  dprintf(("Imag", "image_get_token_image_xref: Called\n"));

  #ifdef FAST_TOKEN_REFERENCE

    found = (token->flags >> FAST_TOKEN_REFERENCE_SHIFT) - 1;

    /* If an appropriate image was found, ensure it */
    /* is the one with render data attached, not    */
    /* just a cross reference image.                */

    if (found >= 0 && found < nimages)
    {
      if (idata[found].xref >= 0) found = idata[found].xref;
    }

  #else

    /* If there are any images to deal with... */

    if (nimages)
    {
      /* ...then look through them all, seeing if the */
      /* image is referred to by the given token.     */

      for (i = 0; i < nimages; i++)
      {

        if (idata[i].token == token && idata[i].owner == b)
        {
          found = i;
          break;
        }
      }

      /* If an appropriate image was found, ensure it */
      /* is the one with render data attached, not    */
      /* just a cross reference image.                */

      if (found >= 0)
      {
        if (idata[found].xref >= 0) found = idata[found].xref;
      }
    }

  #endif

  /* Return the image number, or -1 for failure */

  dprintf(("Imag", "image_get_token_image_xref: Exitting with %d\n", found));

  return found;
}

/**************************************************************/
/* image_get_token_image_actual()                             */
/*                                                            */
/* As image_get_token_image, but returns the exact image      */
/* number represented by the given token rather than the      */
/* cross referenced one with the pointers to the image data.  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The token address.                             */
/*                                                            */
/* Returns:    The image number which references that token,  */
/*             or -1 if none found.                           */
/**************************************************************/

static int image_get_token_image_actual
           (
             const browser_data * restrict b,
             const HStream      * restrict token
           )
{
  int found = -1;

  #ifndef FAST_TOKEN_REFERENCE
    int i;
  #endif

  dprintf(("Imag", "image_get_token_image_actual: Called\n"));

  #ifdef FAST_TOKEN_REFERENCE

    found = (token->flags >> FAST_TOKEN_REFERENCE_SHIFT) - 1;

  #else

    /* If there are any images to deal with... */

    if (nimages)
    {
      /* ...then look through them all, seeing if the */
      /* image is referred to by the given token.     */

      for (i = 0; i < nimages; i++)
      {

        if (idata[i].token == token && idata[i].owner == b)
        {
          found = i;
          break;
        }
      }
    }

  #endif

  /* Return the image number, or -1 for failure */

  dprintf(("Imag", "image_get_token_image_actual: Exitting with %d\n", found));

  return found;
}

/**************************************************************/
/* image_lock_image_size()                                    */
/*                                                            */
/* Ask image_get_image_size for the size of an image, making  */
/* sure currw and currh are -1 so that it works the size out  */
/* from first principles, then set that size jn currw and     */
/* currh for future reference.                                */
/*                                                            */
/* Designed to be called by the reformatter when it           */
/* encounters an image and stores it in a line array.         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Number of the image.                           */
/**************************************************************/

static void image_lock_image_size(browser_data * b, int image)
{
  BBox size;

  /* Rediscover the image size - so ignore any stored */
  /* values in currw and currh.                       */

  if (image_get_image_size(b, image, &size, 1)) return;

  /* Now lock the size by (re)storing it in currw and currh */

  idata[image].currw = size.xmax;
  idata[image].currh = size.ymax;

  return;
}

/**************************************************************/
/* image_lock_token_image_size()                              */
/*                                                            */
/* As image_lock_image_size, but takes a pointer to an        */
/* HStream rather than an image number.                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             image.                                         */
/**************************************************************/

void image_lock_token_image_size(browser_data * b, HStream * token)
{
  int  image = image_get_token_image_actual(b, token);

  if (image < 0) return;

  image_lock_image_size(b, image);

  return;
}

/**************************************************************/
/* image_unlock_image_size()                                  */
/*                                                            */
/* Set currw and currh for an image to -1, so that            */
/* image_get_image_size will start working the size out from  */
/* first principles rather than using any prestored value.    */
/*                                                            */
/* Designed to be called by the reformatter when it destroys  */
/* a line array with images in it.                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Number of the image.                           */
/**************************************************************/

static void image_unlock_image_size(browser_data * b, int image)
{
  idata[image].currw = -1;
  idata[image].currh = -1;

  return;
}

/**************************************************************/
/* image_unlock_token_image_size()                            */
/*                                                            */
/* As image_unlock_image_size, but takes a pointer to an      */
/* HStream rather than an image number.                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             image.                                         */
/**************************************************************/

void image_unlock_token_image_size(browser_data * b, HStream * token)
{
  int image = image_get_token_image_actual(b, token);

  if (image < 0) return;

  image_unlock_image_size(b, image);

  return;
}

/**************************************************************/
/* image_get_image_size()                                     */
/*                                                            */
/* Returns the size of an image in OS units.                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image - font handle data may be updated to */
/*             calculate e.g. placeholder size;               */
/*                                                            */
/*             The image number, from 0 to nimages - 1, which */
/*             may just be a cross referencing image (i.e.    */
/*             has no directly associated data);              */
/*                                                            */
/*             Pointer to a BBox into which the size          */
/*             information is placed (xmax and ymax fields    */
/*             filled with width and height currently - xmin  */
/*             and ymin always zero);                         */
/*                                                            */
/*             1 to ignore the image's currw and currh        */
/*             fields, else use those if they are present.    */
/*                                                            */
/* Assumes:    The BBox pointer is not NULL.                  */
/**************************************************************/

static _kernel_oserror * image_get_image_size
                         (
                           browser_data * restrict b,
                           int                     image,
                           BBox         * restrict box,
                           int                     ignore_stored
                         )
{
  int                      awidth      = 0; /* Available page / cell width */
  int                      aheight     = 0; /* Same, but height            */

  int                      real_width  = 0; /* The actual image dimensions (OS units) */
  int                      real_height = 0; /* from ImageLib                          */

  int                      width_os    = -1; /* The image size as it will appear on the page, taking  */
  int                      height_os   = -1; /* account of any WIDTH or HEIGHT attributes in the HTML */

  int                      actual;
  int                      subtract;
  const HStream * restrict tp          = idata[image].token;

  #ifdef TRACE

    dprintf(("Imag", "image_get_image_size: Called for image %d\n",image));

    if (!box)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess,"Null pointer to BBox given to image_get_image_size");
      return &erb;
    }

    if (image < 0)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,"Invalid image number %d passed to image_get_image_size (nimages = %d)", image, nimages);
      return &erb;
    }
    if (image >= nimages)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,"Out of range image number %d passed to image_get_image_size (nimages = %d)", image, nimages);
      return &erb;
    }

  #else

    if (!box || image < 0 || image >= nimages) return NULL;

  #endif

  /* Zero contents of the BBox */

  memset(box, 0, sizeof(BBox));

  /* Can we return a prestored size? */

  if (!ignore_stored && idata[image].currw >= 0 && idata[image].currh >= 0)
  {
    box->xmax = idata[image].currw;
    box->ymax = idata[image].currh;

    dprintf(("Imag", "image_get_image_size: Successful\n"));

    return NULL;
  }

  /* If this cross references another image, get its number */

  if (idata[image].xref >= 0) actual = idata[image].xref;
  else                        actual = image;

  /* Work out the available width / height */

  if (!tp || !tp->parent)
  {
    awidth  = redraw_display_width (b, NULL);
    aheight = redraw_display_height(b, NULL);

    if (tp)
    {
      subtract = redraw_left_gap (b, b->cell, tp) +
                 redraw_right_gap(b, b->cell, tp);
    }
    else
    {
      subtract = redraw_left_margin (b, b->cell) +
                 redraw_right_margin(b, b->cell);
    }
  }
  else
  {
    const reformat_cell * cell = tokenutils_token_cell(b, tp);

    if (!cell) cell = b->cell;

    if (
         TD_HAS_WIDTH  (tp->parent) &&
         TD_WIDTH_UNITS(tp->parent) == UNITS_PIXELS
       )
       awidth = TD_WIDTH(tp->parent) * 2; /* 1 'web pixel' = 2 OS units */

    if (
         TD_HAS_HEIGHT  (tp->parent) &&
         TD_HEIGHT_UNITS(tp->parent) == UNITS_PIXELS
       )
       aheight = TD_HEIGHT(tp->parent) * 2; /* 1 'web pixel' = 2 OS units */

    subtract = redraw_left_gap (b, cell, tp) +
               redraw_right_gap(b, cell, tp);
  }

  convert_to_os(subtract, &subtract);
  awidth -= subtract;
  if (awidth < 0) awidth = 0;

  /* Try to get the image size from the actual image data (i.e. ImageLib) */

  if (idata[actual].istore)
  {
    real_width  = idata[actual].istore->width_os;
    real_height = idata[actual].istore->height_os;
  }

  /* If we don't seem to have anything, try the image history */

  if (real_width <= 0 && real_height <= 0)
  {
    imghistory_return_size((const char **) &idata[actual].flex->urldata,
                           0,
                           &real_width,
                           &real_height);
  }

  /* The image may have a specific width and height given in */
  /* the HTML.                                               */

  if (tp && tp->tagno != TAG_INPUT)
  {
    /* The OBJECT macros work for IMGs as well as OBJECTs */

    if (OBJECT_HAS_WIDTH(tp))
    {
      switch (OBJECT_WIDTH_UNITS(tp))
      {
        default:
        case UNITS_PIXELS:  width_os = OBJECT_WIDTH(tp) * 2; break;
        case UNITS_PERCENT: width_os = awidth * OBJECT_WIDTH(tp) / 100; break;
      }
    }

    if (OBJECT_HAS_HEIGHT(tp))
    {
      switch (OBJECT_HEIGHT_UNITS(tp))
      {
        default:
        case UNITS_PIXELS:  height_os = OBJECT_HEIGHT(tp) * 2; break;
        case UNITS_PERCENT: height_os = aheight * OBJECT_HEIGHT(tp) / 100; break;
      }
    }
  }

  /* If width and height are both < zero, i.e. as yet unset, */
  /* try to find them out from the image data itself         */

  if (width_os < 0 && height_os < 0)
  {
    if (real_width > 0 && real_height > 0)
    {
      width_os  = real_width;
      height_os = real_height;
    }
  }

  /* If width and height are still both < zero, must go for a */
  /* default placeholder size instead.                        */

  if (width_os < 0 && height_os < 0) goto image_get_image_size_placeholder;

  /* We may have final values... */

  if (width_os >= 0 && height_os >= 0)
  {
    box->xmax = width_os;
    box->ymax = height_os;

    dprintf(("Imag", "image_get_image_size: Successful\n"));

    return NULL;
  }

  /* Otherwise, scale one from the other if possible - for this we must */
  /* have a real image size to get the proportions from                 */

  if (real_width <= 0 || real_height <= 0) goto image_get_image_size_placeholder;

  /* We know the true image size and can thus scale whichever dimension is */
  /* missing for the on-page size from the proportions of the real image.  */

  if (width_os < 0)
  {
    /* Work out width based on the height */

    width_os = (height_os * real_width) / real_height;
  }
  else
  {
    /* Work out height based on the width */

    height_os = (width_os * real_height) / real_width;
  }

  /* We should now have both values, but if not, drop through to the */
  /* placeholder size routine.                                       */

  if (width_os >= 0 && height_os >= 0)
  {
    box->xmax = width_os;
    box->ymax = height_os;

    dprintf(("Imag", "image_get_image_size: Successful\n"));

    return NULL;
  }

image_get_image_size_placeholder:

  {
    /* Don't have precise image dimensions, so work it out from */
    /* any ALT text present or go for a default value.          */

    HStream    * tp = NULL;
    const char * text;

    if (image >= 0) tp = idata[image].token;

    if (tp)
    {
      text = (ISOBJECT(tp)) ? HtmlOBJECTstandby(tp) : tp->text;
    }
    else
    {
      text = NULL;
    }

    reformat_get_placeholder_size(b, tp, text, box);
  }

  dprintf(("Imag", "image_get_image_size: Successful\n"));

  return NULL;
}

/**************************************************************/
/* image_get_token_image_size()                               */
/*                                                            */
/* As image_get_image_size above, but takes a token address   */
/* rather than an image number. The default 'unknown' image   */
/* size will be returned if no image could be associated with */
/* the token (no error will be raised).                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             A token address;                               */
/*                                                            */
/*             Pointer to a BBox into which the size          */
/*             information is placed.                         */
/*                                                            */
/* Assumes:    The BBox pointer is not NULL.                  */
/**************************************************************/

_kernel_oserror * image_get_token_image_size
                  (
                    browser_data  * restrict b,
                    const HStream * restrict token,
                    BBox          * restrict box
                  )
{
  int image;

  dprintf(("Imag", "image_get_token_image_size: Called\n"));

  image = image_get_token_image_actual(b, token);

  dprintf(("Imag", "image_get_token_image_size: Exitting through image_get_image_size\n"));

  return image_get_image_size(b, image, box, 0);
}

/**************************************************************/
/* image_set_image_size()                                     */
/*                                                            */
/* Sets the size of an image (currw, currh fields) in OS      */
/* units.                                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             The image number, from 0 to nimages - 1, which */
/*             may just be a cross referencing image (i.e.    */
/*             has no directly associated data);              */
/*                                                            */
/*             Pointer to a BBox from which the size          */
/*             information is read (xmax - xmin, ymax -       */
/*             ymin).                                         */
/*                                                            */
/* Assumes:    The BBox pointer is not NULL.                  */
/**************************************************************/

static _kernel_oserror * image_set_image_size(browser_data * b, int image, BBox * box)
{
  #ifdef TRACE

    dprintf(("Imag", "image_set_image_size: Called for image %d\n",image));

    if (!box)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess,"Null pointer to BBox given to image_set_image_size");
      return &erb;
    }

    if (image < 0)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,"Invalid image number %d passed to image_set_image_size (nimages = %d)", image, nimages);
      return &erb;
    }
    if (image >= nimages)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,"Out of range image number %d passed to image_set_image_size (nimages = %d)", image, nimages);
      return &erb;
    }

  #else

    if (image < 0 || image >= nimages) return NULL;

  #endif

  idata[image].currw = box->xmax - box->xmin;
  idata[image].currh = box->ymax - box->ymin;

  dprintf(("Imag", "image_set_image_size: Successful\n"));

  return NULL;
}

/**************************************************************/
/* image_set_token_image_size()                               */
/*                                                            */
/* As image_set_image_size above, but takes a token address   */
/* rather than an image number.                               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             A token address;                               */
/*                                                            */
/*             Pointer to a BBox from which the size          */
/*             information is read (xmax - xmin, ymax -       */
/*             ymin).                                         */
/*                                                            */
/* Assumes:    The BBox pointer is not NULL.                  */
/**************************************************************/

_kernel_oserror * image_set_token_image_size(browser_data * b, HStream * token, BBox * box)
{
  int image;

  dprintf(("Imag", "image_set_token_image_size: Called\n"));

  image = image_get_token_image_actual(b, token);

  dprintf(("Imag", "image_set_token_image_size: Exitting through image_set_image_size\n"));

  return image_set_image_size(b, image, box);
}

/**************************************************************/
/* image_get_token_actual_size()                              */
/*                                                            */
/* Returns the width and height of an image, in pixels, or 0  */
/* and 0 if it the size isn't known yet.                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             A token address;                               */
/*                                                            */
/*             Pointer to an int, in which the width is       */
/*             written;                                       */
/*                                                            */
/*             Pointer to an int, in which the height is      */
/*             written.                                       */
/*                                                            */
/* Assumes:    All pointers are non-NULL and valid.           */
/**************************************************************/

void image_get_token_actual_size(browser_data * b, HStream * token, int * w, int * h)
{
  int image;

  dprintf(("Imag", "image_get_token_actual_size: Called\n"));

  image = image_get_token_image_xref(b, token);

  if (idata[image].istore)
  {
    *w = idata[image].istore -> width_os  / 2;
    *h = idata[image].istore -> height_os / 2;
  }
  else
  {
    *w = 0;
    *h = 0;
  }

  dprintf(("Imag", "image_get_token_actual_size: Exitting with width %d, height %d\n", *w, *h));

  return;
}

/**************************************************************/
/* image_get_back_image_size()                                */
/*                                                            */
/* Finds out the size of the background image in OS units.    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the background image; Pointer to a BBox into   */
/*             which the size information is placed.          */
/*                                                            */
/* Assumes:    That neither pointer is NULL.                  */
/**************************************************************/

_kernel_oserror * image_get_back_image_size(browser_data * b, BBox * box)
{
  dprintf(("Imag", "image_get_back_image_size: Called, exitting through image_get_image_size\n"));

  return (image_get_image_size(b, b->background_image, box, 1));
}

/**************************************************************/
/* image_get_token_image_position()                           */
/*                                                            */
/* Returns the x and y fields of the image_info structure for */
/* a given image.                                             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to the token representing the image;   */
/*                                                            */
/*             Pointer to an int, in which the X coordinate   */
/*             is returned;                                   */
/*                                                            */
/*             Pointer to an int, in which the Y coordinate   */
/*             is returned.                                   */
/*                                                            */
/* Returns:    1 if the image could not be found from the     */
/*             given token, or 0 for success.                 */
/*                                                            */
/* Assumes:    Neither pointer is NULL.                       */
/**************************************************************/

int image_get_token_image_position
    (
      const browser_data * restrict b,
      const HStream      * restrict t,
      int                * restrict x,
      int                * restrict y
    )
{
  int image = image_get_token_image_actual(b, t);

  if (image < 0) return 1;

  *x = idata[image].x;
  *y = idata[image].y;

  return 0;
}

/**************************************************************/
/* image_set_token_image_position()                           */
/*                                                            */
/* Sets the x and y fields of the image_info structure for a  */
/* given image, so that it may be [partially] plotted during  */
/* a fetch.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to the token representing the image;   */
/*                                                            */
/*             X coordinate (window coords);                  */
/*                                                            */
/*             Y coordinate (window coords).                  */
/*                                                            */
/* Returns:    Number of the image that was changed, or -1 if */
/*             none could be found for the given token.       */
/**************************************************************/

int image_set_token_image_position
    (
      const browser_data * restrict b,
      const HStream      * restrict t,
      int                           x,
      int                           y
    )
{
  int image = image_get_token_image_actual(b, t);

  /* If an image was found, set the x and y coordinates */

  if (image >= 0)
  {
    idata[image].x = x;
    idata[image].y = y;
  }

  return image;
}

/**************************************************************/
/* image_get_background_image_url()                           */
/*                                                            */
/* Returns the URL of a browser's current background image.   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the background;                                */
/*                                                            */
/*             Pointer to a buffer to take the URL;           */
/*                                                            */
/*             Size of the buffer.                            */
/**************************************************************/

void image_get_background_image_url(browser_data * b, char * buffer, int size)
{
  int old_budge;
  int image = b ? b->background_image : -1;

  if (!buffer || size < 1) return;

  *buffer = 0;

  if (size < 2 || image < 0 || image >= nimages) return;

  /* Lock flex */

  old_budge = flex_set_budge(0);

  /* Copy the URL in, ensuring termination */

  strncpy(buffer, idata[image].flex->urldata, size);
  buffer[size - 1] = 0;

  /* Restore flex's previous budge state */

  flex_set_budge(old_budge);

  /* Finished */

  return;
}

/**************************************************************/
/* image_convert_to_pixels()                                  */
/*                                                            */
/* Converts a given OS unit X and Y size to pixel size, for a */
/* given image.                                               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to the token representing the image;   */
/*                                                            */
/*             Pointer to an int which already contains the X */
/*             size in OS units, which will have the pixel    */
/*             size returned into it;                         */
/*                                                            */
/*             A similar pointer for the Y size.              */
/*                                                            */
/* Assumes:    That no pointer is NULL.                       */
/**************************************************************/

void image_convert_to_pixels(browser_data * b, HStream * token, int * x, int * y)
{
  int image;

  dprintf(("Imag", "image_convert_to_pixels: Called\n"));

  image = image_get_token_image_xref(b, token);

  /* If the library has got enough information to fill in the */
  /* width of the image, proceed with the conversion          */

  if (image >= 0 && idata[image].istore && idata[image].istore->width > 0)
  {
    *x = *x * idata[image].istore->width  / idata[image].istore->width_os;
    *y = *y * idata[image].istore->height / idata[image].istore->height_os;
  }
  else
  {
    /* Can't find image - maybe it's not loaded... Assume 2 OS units per pixel. */

    *x = *x / 2;
    *y = *y / 2;
  }

  dprintf(("Imag", "image_convert_to_pixels: Successful\n"));
}

/**************************************************************/
/* image_return_click_offset()                                */
/*                                                            */
/* Calculate the coordinates of a click on an image in pixels */
/* from the top left corner, as required by image maps and    */
/* image input fields.                                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to a token representing the image;     */
/*                                                            */
/*             A WimpGetPointerInfo block pointer describing  */
/*             the mouse pointer's position;                  */
/*                                                            */
/*             Pointer to an int, in which the x offset is    */
/*             returned;                                      */
/*                                                            */
/*             Pointer to an int, in which the y offset is    */
/*             returned.                                      */
/*                                                            */
/* Assumes:    That the int pointers are not NULL.            */
/**************************************************************/

_kernel_oserror * image_return_click_offset(browser_data * b, HStream * t, WimpGetPointerInfoBlock * i, int * x, int * y)
{
  _kernel_oserror         * e;
  WimpGetWindowStateBlock   s;
  BBox                      box;

  /* Get the image's size and position on screen */

  s.window_handle = b->window_handle;

  e = wimp_get_window_state(&s);
  if (e) return e;

  e = image_get_token_image_size(b, t, &box);
  if (e) return e;

  if (image_get_token_image_position(b, t, x, y)) return NULL;

  *x = coords_x_toscreen(*x, (WimpRedrawWindowBlock *) &s);
  *y = coords_y_toscreen(*y, (WimpRedrawWindowBlock *) &s);

  /* Get the offset of the pointer position from the top left */
  /* of the image in ox and oy                                */

  *x = i->x - *x;
  *y = *y + (box.ymax - box.ymin) - i->y;

  image_convert_to_pixels(b, t, x, y);

  /* Check for daft values due to rounding etc. */

  if (*x < 0) *x = 0;
  if (*y < 0) *y = 0;

  return NULL;
}

/**************************************************************/
/* image_can_be_saved_as_sprite                               */
/*                                                            */
/* Returns 1 if a given image has data and can be saved (the  */
/* DumpSprite function is present), else 0.                   */
/*                                                            */
/* The image may cross reference another with the actual      */
/* data. If so, the return value will be referring to that    */
/* cross referenced image.                                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct owning the    */
/*             image;                                         */
/*                                                            */
/*             Number of the image.                           */
/*                                                            */
/* Returns:    1 if the image can be saved as a sprite, else  */
/*             0.                                             */
/**************************************************************/

static int image_can_be_saved_as_sprite(browser_data * b, int i)
{
  if (
       idata[i].istore                &&
       idata[i].istore->DumpSprite    &&
       idata[i].istore->width_os > 0  &&
       idata[i].istore->height_os > 0
     )
     return 1;

  return 0;
}

/**************************************************************/
/* image_token_can_be_saved_as_sprite                         */
/*                                                            */
/* Returns 1 if a given image has data and can be saved (the  */
/* DumpSprite function is present), else 0.                   */
/*                                                            */
/* The image may cross reference another with the actual      */
/* data. If so, the return value will be referring to that    */
/* cross referenced image.                                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct owning the    */
/*             image;                                         */
/*                                                            */
/*             Pointer to the token representing the image,   */
/*             or NULL for the page's background image.       */
/*                                                            */
/* Returns:    1 if the image can be saved as a sprite, else  */
/*             0.                                             */
/**************************************************************/

int image_token_can_be_saved_as_sprite(browser_data * b, HStream * image)
{
  int i;

  /* Find the image number */

  if (!image) i = b->background_image;
  else        i = image_get_token_image_xref(b, image);

  /* Complain if we can't in TRACE builds */

  if (i < 0)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "In image_token_can_be_saved_as_sprite, can't find an image that is represented by the token %p for the browser %p.",
              image,
              b);

      show_error_ret(&erb);

    #endif

    return 0;
  }

  /* Can it be saved? */

  return image_can_be_saved_as_sprite(b, i);
}

/**************************************************************/
/* image_export_sprite()                                      */
/*                                                            */
/* Saves an image represented by the given token as a sprite  */
/* at the given path.                                         */
/*                                                            */
/* Parameters: Pointer to the path to save to;                */
/*                                                            */
/*             Pointer to a browser_data struct that owns the */
/*             image;                                         */
/*                                                            */
/*             Pointer to the token representing the image,   */
/*             or NULL for the page's background image.       */
/**************************************************************/

_kernel_oserror * image_export_sprite(char * path, browser_data * b, HStream * image)
{
  int               im, i;
  _kernel_oserror * e;

  if (!path || !*path) return NULL;

  save_record_path(path);

  /* Find the image number */

  if (!image) im = b->background_image;
  else        im = image_get_token_image_actual(b, image);

  if (idata[im].xref >= 0) i = idata[im].xref;
  else                     i = im;

  /* Must have image data... */

  if (!image_can_be_saved_as_sprite(b, i))
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "There is no data for this image in image_export_sprite.");

      return &erb;

    #endif

    return NULL;
  }

  /* Export the image */

  browser_redrawing = b;
  image_redrawing   = im;

  e = idata[i].istore -> DumpSprite(idata[i].istore,
                                    path,
                                    -1);

  browser_redrawing = NULL;
  image_redrawing   = -1;

  return e;
}

/**************************************************************/
/* image_sprite_size()                                        */
/*                                                            */
/* Returns the size that the given image would be as a sprite */
/* on disc.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct that owns the */
/*             image;                                         */
/*                                                            */
/*             Pointer to the token representing the image,   */
/*             or NULL for the page's background image.       */
/*                                                            */
/* Returns:    The size the image would be as a sprite file   */
/*             saved to disc, in bytes (a guess only).        */
/**************************************************************/

int image_sprite_size(browser_data * b, HStream * image)
{
  /* ...And for now, we don't know. */

  return 4096;
}

/**************************************************************/
/* image_export_original()                                    */
/*                                                            */
/* Saves an image represented by the given token in its       */
/* original format to the given path.                         */
/*                                                            */
/* Parameters: Pointer to the path to save to;                */
/*                                                            */
/*             Pointer to a browser_data struct that owns the */
/*             image;                                         */
/*                                                            */
/*             Pointer to the token representing the image,   */
/*             or NULL for the page's background image.       */
/**************************************************************/

_kernel_oserror * image_export_original(char * path, browser_data * b, HStream * image)
{
  char url[Limits_URL];
  int  i;

  if (!path || !*path) return NULL;

  save_record_path(path);

  /* Find the image number */

  if (!image) i = b->background_image;
  else        i = image_get_token_image_xref(b, image);

  /* Must have image data... */

  if (!idata[i].flex->urldata)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "There is no URL for this image in image_export_original.");

      return &erb;

    #endif

    return NULL;
  }

  /* Start a fetch for this URL */

  strncpy(url, idata[i].flex->urldata, sizeof(url));
  url[sizeof(url) - 1] = 0;

  RetError(windows_create_browser(url,
                                  NULL,
                                  NULL,
                                  NULL,
                                  Windows_CreateBrowser_SaveToFile));

  /* Set the title to the save pathname */

  {
    char title[Limits_Title];

    StrNCpy0(title, path);

    /* Don't treat any errors here as fatal */

    show_error_ret(window_set_title(0, last_browser->self_id, title));
  }

  /* Open the file */

  last_browser->save_file = fopen(path, "wb");

  if (!last_browser->save_file)
  {
    StrLastE;

    fetch_stop(last_browser, 0);

    return &erb;
  }
  else
  {
    int bytes;

    /* Set the filetype to DEADDEAD, to represent an incomplete */
    /* file (particularly good on later Filers, which display   */
    /* a special sprite for this).                              */

    _swix(OS_File,
          _INR(0,2),

          2, /* Set load address */
          path,
          0xdeaddead);

    _swix(OS_File,
          _INR(0,1) | _IN(3),

          3, /* Set exec address */
          path,
          0xdeaddead);

    if (last_browser->source)
    {
      int old_budge;

      /* Any data in the source store represents already */
      /* fetched bits of the file. Must lock flex down   */
      /* over the save to make sure the heap doesn't     */
      /* shift over the call to fwrite.                  */

      old_budge = flex_set_budge(0);

      bytes = fwrite(last_browser->source,
                     1,
                     flex_size((flex_ptr) &last_browser->source),
                     last_browser->save_file);

      flex_set_budge(old_budge);

      /* If we didn't transfer as much as we expected, complain */

      if (bytes != flex_size((flex_ptr) &last_browser->source))
      {
        /* Report any errors */

        StrLastE;

        fetch_stop(last_browser, 0);

        return &erb;
      }
      else
      {
        /* Otherwise, get rid of the data in the source store */
        /* as it's been written to the file.                  */

        flex_free((flex_ptr) &last_browser->source);
        last_browser->source = NULL;
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* image_to_draw_file()                                       */
/*                                                            */
/* Export an image to a Draw file in sprite format. The Draw  */
/* file sprite header information should be in place so that  */
/* the sprite data may be written at the current file pointer */
/* without creating an invalid Draw file.                     */
/*                                                            */
/* Note that no padding to round output size to a multiple of */
/* any particular number of bytes is carried out - the caller */
/* must do this if it is required.                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Pointer to a FILE * through which to write;    */
/*                                                            */
/*             Image number;                                  */
/*                                                            */
/*             Width to scale to in user-points;              */
/*                                                            */
/*             Height to scale to in user-points;             */
/*                                                            */
/*             Pointer to a size_t, which if non-NULL will be */
/*             updated with the amount of data that *would*   */
/*             be written without writing anything, else if   */
/*             NULL produces normal output to a file.         */
/**************************************************************/

_kernel_oserror * image_to_draw_file
                  (
                    const browser_data * restrict b,
                    FILE               * restrict f,
                    int                           image,
                    unsigned int                  width,
                    unsigned int                  height,
                    size_t             * restrict r_size
                  )
{
  _kernel_oserror * e;
  int               actual;

  dprintf(("Imag", "image_to_draw_file: Called for image %d\n", image));

  if (r_size == NULL && f == NULL)
  {
    dprintf(("Imag", "image_to_draw_file: Failed - NULL file pointer!\n"));
    return NULL;
  }

  /* Get 'actual' to hold the actual image, which may cross-reference */
  /* 'image', with 'image' holding the renderable data.               */

  actual = image;
  if (actual >= 0 && idata[actual].xref >= 0) image = idata[actual].xref;

  /* If the image has a fetched width and height, */
  /* and the browser choices specify that images  */
  /* should be shown (or the image itself has a   */
  /* high priority show bit set), display part or */
  /* all of the image.                            */

  if (
          actual >= 0
       && idata[actual].canredraw
       && idata[image].istore
       && idata[image].istore->width  > 0
       && idata[image].istore->height > 0
       && idata[image].istore->StartExport
       && idata[image].istore->Export
       && idata[image].istore->EndExport
       && idata[image].istore->DumpSprite
     )

// TODO: Redirection should give an excellent opportunity for
//       producing a very good likeness of the page, but in
//       practice it either blows up (GIFs in particular), on
//       occasion produces "Object sizes are inconsistent with
//       file sizes", and when it works (JPEG, PNG) the filler
//       function doesn't seem to be called anyway so images
//       are composited onto a black background. Doh.
//
//  {
//    size_t         size;
//    int            pixw, pixh;
//    int            old_budge;
//    unsigned int   r0, r1, r2, r3;
//    unsigned int   redirected  = 0;
//    int          * sprite_area = NULL;
//    int          * save_area   = NULL;
//    const char   * sprite_name = "web_image"; /* Not much point internationalising this largely hidden string */
//
//    /* ImageLib's Export routine(s) would be great except they  */
//    /* don't always exist (GIF has no routine written) and some */
//    /* use a temporary file (e.g JPEG). PNG output seems to do  */
//    /* compositing to black; that's the base colour in the      */
//    /* internal store which Export dumps. So that's no use. We  */
//    /* could use the DumpSprite routine but this always uses a  */
//    /* temporary file. Compositing works better but it's not    */
//    /* ideal. Again some types don't support dumping to sprites */
//    /* anyway, e.g. Draw.                                       */
//    /*                                                          */
//    /* Therefore: The Hard Way. The ImageLib routines mostly    */
//    /* allocate large RAM blocks and make complete image copies */
//    /* internally anyway, so that's what we'll do here. Big,    */
//    /* big memory overhead, but faster and composites.          */
//    /*                                                          */
//    /* We'll create a 90 DPI square pixel 16M colour sprite for */
//    /* the output redirection.                                  */
//
//    scale_pair_user_to_os(b, width, height, &pixw, &pixh);
//
//    pixw /= 2; if (pixw < 1) pixw = 1;
//    pixh /= 2; if (pixh < 1) pixh = 1;
//
//    size  = 16 + 44 + /* 16 = full sprite area header, 44 = sprite header */
//            (pixw * pixh * 4);
//
//    /* Is that all we need to do? */
//
//    if (r_size != NULL)
//    {
//      *r_size = size - 16; /* -16 to skip unwanted header */
//      return NULL;
//    }
//
//    if (!flex_alloc((flex_ptr) &sprite_area, size)) return make_no_memory_error(48);
//
//    /* From here on Flex must NOT move */
//
//    old_budge = flex_set_budge(0);
//
//    /* Initialise the sprite area */
//
//    sprite_area[0] = size;
//    sprite_area[1] = 0;
//    sprite_area[2] = 16;
//    sprite_area[3] = 16;
//
//    e = _swix(OS_SpriteOp,
//              _INR(0,1),
//
//              0x109, /* Initialise area */
//              sprite_area);
//
//    /* Create the sprite */
//
//    if (e == NULL)
//    {
//      e = _swix(OS_SpriteOp,
//                _INR(0,6),
//
//                0x10F,        /* Create sprite */
//                sprite_area,
//                sprite_name,
//                0,            /* No palette */
//                pixw,
//                pixh,
//                (6u  << 27) | /* Sprite type 6 = 24bpp                 */
//                (90u << 1)  | /* 90 DPI horizontal                     */
//                (90u << 14) | /* 90 DPI vertical                       */
//                (1u  << 0));  /* Distinguish this from a mode selector */
//    }
//
//    /* Find the save area size ready for redirection, */
//    /* and allocate the required amount               */
//
//    if (e == NULL)
//    {
//      size_t sasize;
//
//      e = _swix(OS_SpriteOp,
//                _INR(0,2) | _OUT(3),
//
//                0x13E, /* Read save area size */
//                sprite_area,
//                sprite_name,
//
//                &sasize);
//
//      if (e == NULL)
//      {
//        save_area = malloc(sasize);
//
//        if (save_area == 0)
//        {
//          e = make_no_memory_error(48);
//        }
//        else
//        {
//          save_area[0] = 0;
//        }
//      }
//    }
//
//    /* Now redirect output */
//
//    if (e == NULL)
//    {
//      e = _swix(OS_SpriteOp,
//                _INR(0,3) | _OUTR(0,3),
//
//                0x13C, /* Redirect to sprite */
//                sprite_area,
//                sprite_name,
//                save_area,
//
//                &r0,
//                &r1,
//                &r2,
//                &r3);
//    }
//
//    if (e == NULL)
//    {
//      redirected = 1;
//      image_mode_change();
//
//      e = image_redraw_primitive(b,
//                                 actual,
//                                 0,
//                                 0,
//                                 pixw * 2,
//                                 pixh * 2);
//    }
//
//    /* Restore output if it was redirected, regardless of */
//    /* any outstanding error conditions.                  */
//
//    if (redirected)
//    {
//      _swix(OS_SpriteOp, _INR(0,3), r0, r1, r2, r3);
//      image_mode_change();
//    }
//
//    /* Free the save area and see if there are any errors */
//    /* that need returning.                               */
//
//    free(save_area); /* Works fine if save_area is NULL */
//
//    if (e != NULL)
//    {
//      flex_set_budge(old_budge); /* Restore previous flex behaviour */
//      if (sprite_area != NULL) flex_free((flex_ptr) &sprite_area);
//      return e;
//    }
//
//    /* Dump the sprite data to the output file */
//
//    if (
//         fwrite(sprite_area + 4, /* Pointer arithmetic - +4 ints = +16 bytes */
//                1,
//                size - 16,
//                f)
//
//         != size - 16
//       )
//    {
//      StrLastE;
//      e = &erb;
//    }
//
//    /* Free the temporary sprite */
//
//    flex_set_budge(old_budge); /* Restore previous flex behaviour */
//    if (sprite_area != NULL) flex_free((flex_ptr) &sprite_area);
//
//    /* Return any pending error conditions */
//
//    return e;
//  }

  {
    char         data[16384];
    size_t       len;
    size_t       size  = 0;
//    unsigned int first = 1;

    browser_redrawing = b;
    image_redrawing   = actual;

// TODO: Standard Export produces poor results (composition to
//       black rather than white for example) and is not supported
//       for all types (particularly GIF) even though an Export
//       function is still offered in those cases.
//
// BUT:  It'd be nice if ImageLib worked, wouldn't it. Images that
//       are processed for backgrounds don't give the correct size
//       in Export calls (it's just *slightly* out). So these calls
//       are too inconsistently broken to be of any use at all.
//
//      /* Since normal export doesn't work yet (see above) we might */
//      /* at least save some time for "get the file size" calls...  */
//
//      if (r_size != NULL)
//      {
//        RetError(idata[image].istore -> StartExport(idata[image].istore,
//                                                    (int *) &size));
//
//        (void) idata[image].istore -> EndExport(idata[image].istore);
//
//        /* Don't count the sprite file's sprite area header */
//
//        if (size < 12) size  = 0;
//        else           size -= 12;
//
//        if (size != 0)
//        {
//          dprintf(("Imag", "image_to_draw_file: Returning size %u from Export()\n", size));
//
//          *r_size = size;
//          return NULL;
//        }
//      }

//    /* Get the required size */
//
//    RetError(idata[image].istore -> StartExport(idata[image].istore,
//                                                (int *) &size));
//
//    /* Don't count the sprite file's sprite area header */
//
//    if (size < 12) size  = 0;
//    else           size -= 12;
//
//    /* Sizes of zero indicate that the image library cannot export */
//    /* this item. For example, it has trouble with GIF images.     */
//
//    if (size == 0)
    {
      FILE * input = NULL;
      int    got;

//      /* Cancel the export */
//
//      (void) idata[image].istore -> EndExport(idata[image].istore);

      /* Make a unique filename and dump the image as a sprite to it */

      if (unique_name) /* Was one left over accidentally? */
      {
        remove(unique_name);
        free(unique_name);
        unique_name = NULL;
      }

      unique_name = malloc(Limits_OS_Pathname);

      if (!unique_name)
      {
        browser_redrawing = NULL;
        image_redrawing   = -1;

        return make_no_memory_error(48);
      }

      protocols_util_make_unique_name(unique_name, Limits_OS_Pathname);

      /* Output the sprite, skipping the first 12 bytes of sprite area header */

      e = idata[image].istore -> DumpSprite(idata[image].istore,
                                            unique_name,
                                            -1);
      if (e)
      {
        remove(unique_name);
        free(unique_name);

        unique_name       = NULL;
        browser_redrawing = NULL;
        image_redrawing   = -1;

        return e;
      }

      /* Open the sprite file */

      input = fopen(unique_name, "rb");

      if (!input)
      {
        remove(unique_name);
        free(unique_name);

        unique_name       = NULL;
        browser_redrawing = NULL;
        image_redrawing   = -1;

        RetLastE;
      }

      /* Find the size; deduct 12 for the sprite area header */

      fseek(input, 0, SEEK_END); /* We'll seek back later */
      size = (size_t) ftell(input);

      if (size < 12) size  = 0;
      else           size -= 12;

      /* Return the size if need be */

      if (r_size != NULL)
      {
        fclose(input);
        remove(unique_name);
        free(unique_name);

        unique_name       = NULL;
        browser_redrawing = NULL;
        image_redrawing   = -1;

        dprintf(("Imag", "image_to_draw_file: Returning size %u from DumpSprite()\n", size));

        *r_size = (size_t) size;
        return NULL;
      }

      /* Copy the dumped sprite to the output file */

      fseek(input, 12, SEEK_SET);

      while (size != 0) /* This is just to create an 'if' block that we can 'break' out of */
      {
        if (size < sizeof(data)) len = size;
        else                     len = sizeof(data);

        /* Read some data */

        got = fread(data, sizeof(*data), len, input);

        /* Write it back */

        if (got > 0 && fwrite(data, sizeof(*data), got, f) != got)
        {
          fclose(input);
          remove(unique_name);
          free(unique_name);

          unique_name       = NULL;
          browser_redrawing = NULL;
          image_redrawing   = -1;

          dprintf(("Imag", "image_to_draw_file: Failed (error from fwrite())\n"));
          RetLastE;
        }

        /* Exit if we got less than we requested, indicating reading */
        /* to the end of the file.                                   */

        if (got < len) break;
      }

      /* All done */

      fclose(input);
      remove(unique_name);
      free(unique_name);

      unique_name       = NULL;
      browser_redrawing = NULL;
      image_redrawing   = -1;

      return NULL;
    }
//    else
//    {
//      if (r_size != NULL)
//      {
//        browser_redrawing = NULL;
//        image_redrawing   = -1;
//
//        dprintf(("Imag", "image_to_draw_file: Returning size %u\n", size));
//
//        *r_size = (size_t) size;
//        return idata[image].istore -> EndExport(idata[image].istore);
//      }
//
//      /* Start writing data */
//
//      while (size != 0) /* This is just to create an 'if' block that we can 'break' out of */
//      {
//        if (size < sizeof(data)) len = size;
//        else                     len = sizeof(data);
//
//        e = idata[image].istore -> Export(idata[image].istore,
//                                          data,
//                                          (int *) &len);
//
//        if (e != NULL)
//        {
//          browser_redrawing = NULL;
//          image_redrawing   = -1;
//
//          (void) idata[image].istore -> EndExport(idata[image].istore);
//          dprintf(("Imag", "image_to_draw_file: Failed (error from Export call)\n"));
//          return e;
//        }
//
//        /* 'len' is updated to say how many bytes were actually transferred; */
//        /* have to skip the first 12 bytes on the first calls to avoid the   */
//        /* sprite area header and just get the sprite data.                  */
//
//        if (len == 0) break;
//
//        if (
//             fwrite((data + (first ? 12 : 0)),
//                    sizeof(*data),
//                    len - (first ? 12 : 0),
//                    f)
//
//             != len - (first ? 12 : 0)
//           )
//        {
//          browser_redrawing = NULL;
//          image_redrawing   = -1;
//
//          (void) idata[image].istore -> EndExport(idata[image].istore);
//          dprintf(("Imag", "image_to_draw_file: Failed (error from fwrite())\n"));
//          RetLastE;
//        }
//
//        first = 0;
//      }
//
//      e = idata[image].istore -> EndExport(idata[image].istore);
//
//      browser_redrawing = NULL;
//      image_redrawing   = -1;
//
//      return e;
//    }
  }

  if (r_size != NULL) *r_size = 0;

  dprintf(("Imag", "image_to_draw_file: Successful\n"));

  return NULL;
}

/**************************************************************/
/* image_draw_to_pdf()                                        */
/*                                                            */
/* If the given image is a non-background Draw image and it   */
/* can be dumped in original format, do so and call back to   */
/* SavePDF to convert it to inline drawing data. Otherwise,   */
/* do nothing except report the failure through a supplied    */
/* integer. PDF export is assumed to be in progress. Designed */
/* to be called from a RedrawCore image plot function.        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Image number;                                  */
/*                                                            */
/*             X coordinate, user-points;                     */
/*                                                            */
/*             Y coordinate, user-points;                     */
/*                                                            */
/*             Width, user-points;                            */
/*                                                            */
/*             Height, user-points;                           */
/*                                                            */
/*             Pointer to an integer, updated on exit when no */
/*             error is generated with zero if the image was  */
/*             not drawn, or non-zero if the image was sent   */
/*             to the PDF file successfully;                  */
/*                                                            */
/*             Pointer to a size_t, which if non-NULL will be */
/*             updated with the amount of data that *would*   */
/*             be written without writing anything, else if   */
/*             NULL produces normal output to a file.         */
/*             (NOT YET IMPLEMENTED).                         */
/**************************************************************/

_kernel_oserror * image_draw_to_pdf
                  (
                    const browser_data * restrict b,
                    const unsigned int            image,
                    int                           x,
                    int                           y,
                    unsigned int                  width,
                    unsigned int                  height,
                    int                * restrict ok,

                    size_t             * restrict r_size
                  )
{
  _kernel_oserror * e;
  int               actual;
  int               use_original = 0;

  *ok    = 0;
  actual = image_parent(image);

  if (
          idata[actual].canredraw
       && idata[actual].background == 0
       && idata[actual].istore
       && idata[actual].istore->width  > 0
       && idata[actual].istore->height > 0
       && idata[actual].istore->is_drawfile
       && idata[actual].istore->DumpToCache
     )
  {
    /* Get a unique filename without tmpnam()'s limitations */

    if (unique_name) /* Was one left over accidentally? */
    {
      remove(unique_name);
      free(unique_name);
      unique_name = NULL;
    }

    unique_name = malloc(Limits_OS_Pathname);
    if (!unique_name) return make_no_memory_error(48);

    protocols_util_make_unique_name(unique_name, Limits_OS_Pathname);

    /* Dump the Draw file to this location */

    e = idata[actual].istore -> DumpToCache(idata[actual].istore,
                                            unique_name,
                                            &use_original);

    if (e == NULL && use_original == 0)
    {
      e = savepdf_draw_file_to_pdf(b,
                                   unique_name,
                                   x,
                                   y,
                                   width,
                                   height,

                                   r_size);

      /* If no error, indicate that conversion was successful. */
      /* Otherwise, drop through. Callers may attempt another  */
      /* kind of conversion; the file pointer will have been   */
      /* rewound to before we made the first attempt.          */

      if (e == NULL) *ok = 1;
    }

    /* Tidy up the output file and exit early */

    remove(unique_name);

    free(unique_name);
    unique_name = NULL;
  }

  /* Ignore errors (see above) - if there was a problem the 'ok' */
  /* flag will still be clear.                                   */

  return NULL;
}

/**************************************************************/
/* image_send_to_pdf()                                        */
/*                                                            */
/* Dump the given image to a sprite and call SavePDF.c to get */
/* it written to the currently open PDF file.                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             Image number;                                  */
/*                                                            */
/*             Pointer to a size_t, which if non-NULL will be */
/*             updated with the amount of data that *would*   */
/*             be written without writing anything, else if   */
/*             NULL produces normal output to a file.         */
/*             (NOT YET IMPLEMENTED).                         */
/**************************************************************/

_kernel_oserror * image_send_to_pdf
                  (
                    const browser_data * restrict b,
                    int                           image,
                    size_t             * restrict r_size
                  )
{
  _kernel_oserror * e;

  if (r_size != NULL)
  {
    *r_size = 0; // NOT YET IMPLEMENTED
    return NULL;
  }

  /* Flicker LEDs */

  _swix(Hourglass_LEDs,
        _INR(0,1),

        1 + (image % 2),
        1 + (image % 2));

  /* We'll dump images to a temporary file - get a filename */

  if (unique_name) /* Was one left over accidentally? */
  {
    remove(unique_name);
    free(unique_name);
    unique_name = NULL;
  }

  unique_name = malloc(Limits_OS_Pathname);
  if (!unique_name) return make_no_memory_error(48);

  protocols_util_make_unique_name(unique_name, Limits_OS_Pathname);

  if (
          idata[image].xref < 0 /* This is parent image, holding 'real' data */
       && idata[image].canredraw
       && idata[image].istore
       && idata[image].istore->width  > 0
       && idata[image].istore->height > 0
       && idata[image].istore->DumpSprite
     )
  {
    FILE * test;

    /* Try to dump the image to a sprite */

    browser_redrawing = b;
    image_redrawing   = image;

    e = idata[image].istore -> DumpSprite(idata[image].istore,
                                          unique_name,

                                          -1);

    browser_redrawing = NULL;
    image_redrawing   = -1;

    /* Only proceed if we can actually open the file */

    if ((test = fopen(unique_name, "rb")) != NULL)
    {
      fclose(test);

      if (e == NULL)
      {
        /* Get it converted for the PDF file */

        e = savepdf_sprite_file_to_pdf(b,
                                       unique_name,
                                       image,
                                       NULL);

        remove(unique_name);

        free(unique_name);
        unique_name = NULL;

        return e;
      }
    }
  }

  /* If the image seems to be inappropriate or the DumpSprite call  */
  /* produced no/unopenable output, use a 'huh?' sprite instead...! */

  return savepdf_sprite_name_to_pdf(b,
                                    (void *) sprite_block,
                                    "ptr_dts", /* "Hand" icon - could mean "Stop" - saves having to add some new sprite to each build, since this should hardly ever / never actually be used */
                                    NULL);
}
@


1.52
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d74 2
a107 1
//static int               image_data_offset            (int image);
d110 2
a111 2
static int               image_get_token_image_xref   (browser_data * b, HStream * token);
static int               image_get_token_image_actual (browser_data * b, HStream * token);
d115 1
a115 1
static _kernel_oserror * image_get_image_size         (browser_data * b, int image, BBox * box, int ignore_stored);
d136 2
a137 2
static int            image_redrawing   = -1;
static browser_data * browser_redrawing = NULL;
a145 220
// Presently unused... TBD...

#define ImageGranularity 8

// Unimplemented functions:

// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
// static _kernel_oserror * image_savesprite_start_save1(image_info * ip,int * isize)
// {
//   int        size;
//
//   * isize=-1;
//   if(ip && ip->istore && ip->istore->width>0)
//   {
//     ERROUT((_kernel_oserror*)ip->istore->StartExport(ip->istore,&size));
//     size-=12; /* subtract the size of the sprite area header */
//   }
//   else
//   {
//     sprite_header * p;
//     sprite_area   * sa;
//     sprite_id     sid;
//
//     image_get_broken_sprite(&sa,&sid);
//     p=(sprite_header*)sid.s.addr;
//     size=WORDALIGN(p->next);
//   }
//   * isize=size;
//   return(NULL);
// }
//
// /* ----------------------------------------------------------------------*/
// _kernel_oserror * image_savesprite_start_save(browser_data * b,int token,int * isize)
// {
//   image_info * ip;
//
//   ip=image_get_token_image_xref(b,token);
//   return(image_savesprite_start_save1(ip,isize));
// }
//
//
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
// static int image_savesprite_save_image1(image_info * ip)
// {
//   sprite_header * p;
//   sprite_area   * sa;
//   sprite_id     sid;
//
//   if(ip && ip->istore && ip->istore->width>0)
//   {
//     int  len;
//     char buffer[2048];
//     int  skip=12; /* skip first 12 bytes (sprite area header) */
//
//     do
//     {
//       len=sizeof(buffer);
//       if(wimpt_complain((_kernel_oserror*)ip->istore->Export(ip->istore,buffer,&len))) return(0);
//       if(len-skip>0 && !save_write_bytes(buffer+skip,len-skip)) return(0);
//       skip-=len;
//       if(skip<0) skip=0;
//     } while(len);
//     return(1);
//   }
//   image_get_broken_sprite(&sa,&sid);
//   p=(sprite_header*)sid.s.addr;
//   return(save_write_bytes((void*)p,WORDALIGN(p->next)));
// }
//
// /* ----------------------------------------------------------------------*/
// int image_savesprite_save_image(browser_data * b,int token)
// {
//   image_info    * ip;
//
//   ip=image_get_token_image_xref(b,token);
//   return(image_savesprite_save_image1(ip));
// }
//
// /* ----------------------------------------------------------------------*/
// void image_savesprite_end_save(browser_data * b,int token)
// {
//   image_info * ip;
//
//   ip=image_get_token_image_xref(b,token);
//   if(ip && ip->istore && ip->istore->width>0) ip->istore->EndExport(ip->istore);
// }
//
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
// static int image_picture_saver(void * handle,char * pathname)
// {
//   browser       * b;
//   int           * si,token;
//   image_info    * ip;
//
//   pathname=pathname;
//   si=(int*)handle;
//   b=(browser*)si[0];
//   token=si[1];
//   ip=NULL;
//   if(token>0) ip=image_get_token_image_xref(b,token);
//   else if(b->background_image>0) ip=image_info_addr(b,b->background_image);
//   if(ip && ip->istore && ip->istore->width>0)
//   {
//     int  len;
//     char buffer[2048];
//
//     do
//     {
//       len=sizeof(buffer);
//       if(wimpt_complain((_kernel_oserror*)ip->istore->Export(ip->istore,buffer,&len))) return(0);
//       if(len && !save_write_bytes(buffer,len)) return(0);
//     } while(len);
//   }
//   else
//   {
//     sprite_area   area,* sa;
//     sprite_id     sid;
//     sprite_header * p;
//
//     image_get_broken_sprite(&sa,&sid);
//     p=(sprite_header*)sid.s.addr;
//     area.size=sizeof(sprite_area)+p->next;
//     area.number=1;
//     area.sproff=sizeof(sprite_area);
//     area.freeoff=area.size;
//     if(!save_write_bytes((void*)(&area.number),sizeof(area)-4)) return(0);
//     return(save_write_bytes((void*)p,p->next));
//   }
//   return(1);
// }
//
// /* ----------------------------------------------------------------------*/
// _kernel_oserror * image_save_picture(browser_data * b,int token)
// {
//   int        size,saveinfo[2];
//   char       pathname[256];
//   image_info * ip;
//
//   ip=NULL;
//   if(token && fetch_token_address(b,token)->style&IMG) ip=image_get_token_image_xref(b,token);
//   if(!ip && b->background_image>0)
//   {
//     ip=image_info_addr(b,b->background_image);
//     token=0;
//   }
//   if(ip && ip->istore && ip->istore->width>0) ip->istore->StartExport(ip->istore,&size);
//   else
//   {
//     sprite_area   * sa;
//     sprite_id     sid;
//     sprite_header * p;
//
//     image_get_broken_sprite(&sa,&sid);
//     p=(sprite_header*)sid.s.addr;
//     size=sizeof(sprite_area)+p->next-4;
//   }
//   saveinfo[0]=(int)b;
//   saveinfo[1]=token;
//   strcpy(pathname,msgs_lookup("sprfile:SpriteFile"));
//   save_saveas(FILETYPE_SPRITE,pathname,size,image_picture_saver,NULL,(void*)saveinfo);
//   if(ip && ip->istore && ip->istore->width>0) ip->istore->EndExport(ip->istore);
//   return(NULL);
// }

// /* ----------------------------------------------------------------------*/
// _kernel_oserror * image_saveback_start_save(browser_data * b,int * isize)
// {
//   image_info * ip;
//
//   ip=image_info_addr(b,b->background_image);
//   return(image_savesprite_start_save1(ip,isize));
// }
//
// /* ----------------------------------------------------------------------*/
// int image_saveback_save_image(browser_data * b)
// {
//   image_info    * ip;
//
//   ip=image_info_addr(b,b->background_image);
//   return(image_savesprite_save_image1(ip));
// }
//
// /* ----------------------------------------------------------------------*/
// void image_saveback_end_save(browser_data * b)
// {
//   image_info * ip;
//
//   ip=image_info_addr(b,b->background_image);
//   if(ip && idata[i].istore && idata[i].istore->width>0) idata[i].istore->EndExport(idata[i].istore);
// }

// **** static const char * image_get_url(HStream * t)
// **** {
// ****   if ISBODY(t)
// ****   {
// ****     if (t->tagno == TAG_TABLE) return NULL;
// ****     else if (t->style & IMG)   return t->src;
// ****     else if ISOBJECT(t)        return NULL; // Eeek
// ****     else if (t->style & FORM)
// ****     {
// ****       if (t->tagno == TAG_INPUT)
// ****       {
// ****         switch (HtmlINPUTtype(t))
// ****         {
// ****           case inputtype_IMAGE: return HtmlINPUTsrc(t);
// ****           default:              return NULL;
// ****         }
// ****       }
// ****       else return NULL;
// ****     }
// ****   }
// ****   else if ISFRAMESET(t) return NULL;
// ****   else if ISHEAD(t)
// ****   {
// ****     if (t->tag == BODY) return HtmlBODYbackground(t);
// ****   }
// ****
// ****   return NULL;
// **** }

d661 2
a662 2
          xref = i;       /* If all of the above are satisfied, cross reference */
          i    = nimages; /* this image with the one it matches.                */
d718 1
a718 1
      int oldsize;//, size;
d2685 6
a2690 12
        browser_redrawing = b;
        image_redrawing   = xref;

        e = idata[image].istore -> Render(idata[image].istore,
                                          sx,
                                          sy,
                                          100,
                                          idata[xref].currw,
                                          idata[xref].currh);

        browser_redrawing = NULL;
        image_redrawing   = -1;
d3175 1
a3175 1
        BBox extent; // Not actually used yet...!
d3278 1
a3278 1
  browser_data            * b        = (browser_data *) handle;
d3442 1
a3442 1
    redraw_set_colour(bgcolour);
d3444 12
a3455 4
    bbc_rectanglefill(0,
                      0,
                      idata[ximage].istore -> width_os,
                      idata[ximage].istore -> height_os);
d3499 1
a3499 3

    int            oimage;
    browser_data * obrowser;
d3545 2
d3551 6
a3556 17
        /* Re-entrancy - if the background image is transparent we get */
        /* called again, so need to stack image_redrawing etc. first   */

        oimage            = image_redrawing;
        obrowser          = browser_redrawing;
        image_redrawing   = bimage;
        browser_redrawing = idata[bimage].owner;

        e = (idata[bximage].istore -> Render(idata[bximage].istore,
                                             x,
                                             y,
                                             100,
                                             w,
                                             h));

        image_redrawing   = oimage;
        browser_redrawing = obrowser;
d3568 3
a3570 5
    BBox           redraw;
    int            htop;

    int            oimage;
    browser_data * obrowser;
d3599 2
d3605 6
a3610 13
        oimage            = image_redrawing;
        obrowser          = browser_redrawing;
        image_redrawing   = bimage;
        browser_redrawing = idata[bimage].owner;

        e = (idata[bximage].istore -> Render(idata[bximage].istore,
                                             x,
                                             y,
                                             100,
                                             -1,
                                             -1));
        image_redrawing   = oimage;
        browser_redrawing = obrowser;
d3627 92
a3727 4
/*             Pointer to a RedrawWindowBlock struct which    */
/*             holds information about the current redraw     */
/*             session;                                       */
/*                                                            */
d3734 6
a3739 1
/*             the bottom edge of the image.                  */
d3742 8
a3749 1
_kernel_oserror * image_redraw(browser_data * b, WimpRedrawWindowBlock * r, HStream * token, int x, int y)
d3790 6
a3795 12
      browser_redrawing = b;
      image_redrawing   = actual;

      e = idata[image].istore -> Render(idata[image].istore,
                                        x,
                                        y,
                                        100,
                                        idata[actual].currw,
                                        idata[actual].currh);

      browser_redrawing = NULL;
      image_redrawing   = -1;
d3816 3
a3818 3
    BBox         box;
    const char * text;
    HStream    * tp   = NULL;
d3837 1
a3837 1
      text = (ISOBJECT(tp)) ? HtmlOBJECTstandby(tp) : tp->text;
d3840 1
a3840 1
                              r,
d3852 26
a3877 20
/**************************************************************/
/* image_tile_window()                                        */
/*                                                            */
/* For a given redraw rectangle, tiles the background image   */
/* within that rectangle.                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the window and image;                          */
/*                                                            */
/*             Pointer to a WimpRedrawWindow- Block structure */
/*             defining the area over which to tile the       */
/*             image;                                         */
/*                                                            */
/*             The X and Y coordinates to take as the tile    */
/*             origin, in OS units.                           */
/*                                                            */
/* Returns:    1 for success, 0 for failure.                  */
/**************************************************************/

int image_tile_window(browser_data * b, WimpRedrawWindowBlock * r, int xorigin, int yorigin)
d3880 1
a3880 1
  int               x, y, w, h;
d3917 1
a3917 1
    redraw_set_colour(redraw_backcol(b));
d3919 20
a3938 4
    bbc_rectanglefill(r->redraw_area.xmin,
                      r->redraw_area.ymin,
                      r->redraw_area.xmax - r->redraw_area.xmin,
                      r->redraw_area.ymax - r->redraw_area.ymin);
d3943 2
d3949 6
a3954 2
      browser_redrawing = b;
      image_redrawing   = b->background_image;
d3956 1
a3956 9
      e = idata[image].istore -> Render(idata[image].istore,
                                        x,
                                        y,
                                        100,
                                        w,
                                        h);

      browser_redrawing = NULL;
      image_redrawing   = -1;
d3970 1
a3970 1
        if (e) return 0;
d4130 26
d4474 5
a4478 1
static int image_get_token_image_xref(browser_data * b, HStream * token)
d4555 5
a4559 1
static int image_get_token_image_actual(browser_data * b, HStream * token)
d4714 2
a4715 1
/*             the image;                                     */
d4732 20
a4751 14
static _kernel_oserror * image_get_image_size(browser_data * b, int image, BBox * box, int ignore_stored)
{
  int       awidth      = 0; /* Available page / cell width */
  int       aheight     = 0; /* Same, but height            */

  int       real_width  = 0; /* The actual image dimensions (OS units) */
  int       real_height = 0; /* from ImageLib                          */

  int       width_os    = -1; /* The image size as it will appear on the page, taking  */
  int       height_os   = -1; /* account of any WIDTH or HEIGHT attributes in the HTML */

  int       actual;
  int       subtract;
  HStream * tp          = idata[image].token;
d4824 1
a4824 1
    reformat_cell * cell = tokenutils_token_cell(b, tp);
d5004 6
a5009 1
_kernel_oserror * image_get_token_image_size(browser_data * b, HStream * token, BBox * box)
d5199 7
a5205 1
int image_get_token_image_position(browser_data * b, HStream * t, int * x, int * y)
d5237 7
a5243 1
int image_set_token_image_position(browser_data * b, HStream * t, int x, int y)
a5730 23
/* image_original_size()                                      */
/*                                                            */
/* Returns the size of a given image in its original format.  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct that owns the */
/*             image;                                         */
/*                                                            */
/*             Pointer to the token representing the image,   */
/*             or NULL for the page's background image.       */
/*                                                            */
/* Returns:    The size of the original image, in bytes (a    */
/*             guess only).                                   */
/**************************************************************/

int image_original_size(browser_data * b, HStream * image)
{
  int size = image_draw_file_size(b, image, 0);

  if (size <= 0) return 0;
  else           return size + 12;
}

/**************************************************************/
d5733 8
a5740 4
/* As image_redraw, but will output a sprite to the Draw file */
/* being output by SaveDraw.c (which must be active at the    */
/* time this is called). Assumes that the appropriate Draw    */
/* file object header has already been written.               */
d5745 1
a5745 5
/*             Pointer to a RedrawWindowBlock struct which    */
/*             holds information about the current redraw     */
/*             session;                                       */
/*                                                            */
/*             Address of the token representing the image;   */
d5747 1
a5747 2
/*             The X offset in window coords (so OS units) of */
/*             the left hand edge of the image;               */
d5749 1
a5749 2
/*             The Y offset in window coords (so OS units) of */
/*             the bottom edge of the image;                  */
d5751 1
a5751 3
/*             1 to assume the image is already present as a  */
/*             sprite in 'unique_name' else create the image  */
/*             first.                                         */
d5753 4
a5756 3
/* Returns:    0 if failed, 1 if successful; if failed,       */
/*             caller should try some alternative             */
/*             representation (e.g. write out a placeholder). */
d5759 9
a5767 1
int image_to_draw_file(browser_data * b, WimpRedrawWindowBlock * r, HStream * token, int x, int y, int dont_create)
d5769 2
a5770 2
  int image, actual;
  int plotted = 0;
d5772 1
a5772 1
  dprintf(("Imag", "image_to_draw_file: Called with token &%08X\n", (int) token));
d5774 5
a5778 5
  /* Get the image number for the given token; 'actual' holds the actual */
  /* image for the given token, which may cross reference 'image', which */
  /* holds the actual render data.                                       */

  image = image_get_token_image_actual(b, token);
d5780 2
a5781 1
  if (image < 0) return NULL;
d5784 1
a5784 1
  if (idata[actual].xref >= 0) image = idata[actual].xref;
d5793 1
a5793 7
       image  >= 0 &&
       actual >= 0 &&
       (
         b->show_foreground                     ||
         b->displayed == Display_External_Image ||
         idata[actual].priority
       )
d5795 206
a6000 5
       && idata[image].istore             /* Must check istore here, as if width / height are <= 0, */
       && idata[image].istore->width  > 0 /* the image library has no data for the image and will   */
       && idata[image].istore->height > 0 /* not have filled in (e.g.) the Render field. So you'd   */
       && idata[image].istore->DumpSprite /* get a rather nasty abort trying to call it!            */
       && image_can_be_saved_as_sprite(b, image)
a6001 4
//       && idata[image].istore->StartExport
//       && idata[image].istore->Export
//       && idata[image].istore->EndExport
     )
d6003 4
a6006 2
    FILE            * input = NULL;
    _kernel_oserror * e     = NULL;
d6008 2
a6009 2
    int               written, ok;
    char              buffer[10240];
d6011 33
a6043 1
//    int               image_size = 0;
d6045 14
a6058 1
    if (!dont_create || !unique_name)
d6060 16
d6078 1
a6078 1
      if (unique_name)
d6080 2
a6081 1
        protocols_util_make_unique_name(unique_name, Limits_OS_Pathname);
d6083 4
a6086 1
        /* Output the sprite, skipping the first 12 bytes of sprite area header */
d6088 1
a6088 2
        browser_redrawing = b;
        image_redrawing   = actual;
d6090 7
a6096 3
        e = idata[image].istore -> DumpSprite(idata[image].istore,
                                              unique_name,
                                              -1);
d6098 1
d6101 2
a6103 1
    }
d6105 1
a6105 4
    if (e || !unique_name) ok = 0;
    else
    {
      ok = 1;
d6109 33
a6141 2
      if (!input || !input->__file) ok = 0;
    }
d6143 3
a6145 4
    if (ok)
    {
      e = _swix(OS_Args,
                _INR(0,2),
d6147 1
a6147 3
                1,
                input->__file,
                12);
d6149 1
a6149 2
      if (e) ok = 0;
    }
d6151 1
a6151 3
    if (ok)
    {
      do
d6153 18
a6170 2
        e = _swix(OS_GBPB,
                  _INR(0,3) | _OUT(3),
d6172 3
a6174 4
                  4,
                  input->__file,
                  buffer,
                  sizeof(buffer),
d6176 2
a6177 1
                  &written);
d6179 1
a6179 2
        if (!e && written < sizeof(buffer)) ok = savedraw_write_bytes(buffer, sizeof(buffer) - written);
        else                                ok = e ? 0 : 1;
a6180 2
      while (!e && written < sizeof(buffer));
    }
d6182 2
a6183 2
    if (input)
    {
d6185 2
d6188 3
a6190 1
      if (unique_name) remove(unique_name);
d6192 1
a6192 2
      free(unique_name);
      unique_name = NULL;
d6194 59
a6252 6

//    browser_redrawing = b;
//    image_redrawing   = actual;
//
//    e       = idata[image].istore -> StartExport(idata[image].istore, &image_size);
//    ok      = 1;
d6254 1
a6254 2
//    written = 12;
//    e       = idata[image].istore -> Export(idata[image].istore, buffer, &written);
d6256 2
a6257 5
//    while (!e && ok && written)
//    {
//      written = sizeof(buffer);
//
//      e = idata[image].istore -> Export(idata[image].istore, buffer, &written);
d6259 1
a6259 2
//      if (!e) ok = savedraw_write_bytes(buffer, written);
//      else    ok = 0;
d6261 1
a6261 5
//
//    e = idata[image].istore -> EndExport(idata[image].istore);
//
//    browser_redrawing = NULL;
//    image_redrawing   = -1;
d6263 1
a6263 1
    /* Flag if we succeeded */
d6265 1
a6265 2
    if (!e && ok) plotted = 1;
  }
d6267 1
a6267 3
  dprintf(("Imag", "image_to_draw_file: Exitting with %d\n", plotted));

  return plotted;
d6271 1
a6271 1
/* image_draw_file_size()                                     */
d6273 6
a6278 2
/* Returns the amount of data that image_to_draw_file would   */
/* write to the output file.                                  */
d6283 9
a6291 1
/*             Address of the token representing the image;   */
d6293 4
a6296 2
/*             1 to not delete the scrap file in              */
/*             'unique_name' that this writes, else 0.        */
d6298 5
a6302 3
/* Returns:    0 if failed, else the amount of data that      */
/*             image_to-draw_file would write to the output   */
/*             file.                                          */
d6305 12
a6316 1
int image_draw_file_size(browser_data * b, HStream * token, int dont_delete)
d6318 3
a6320 1
  int image, actual;
d6322 2
a6323 16
  /* Get the image number for the given token; 'actual' holds the actual */
  /* image for the given token, which may cross reference 'image', which */
  /* holds the actual render data.                                       */

  image = image_get_token_image_actual(b, token);

  if (image < 0) return NULL;

  actual = image;
  if (idata[actual].xref >= 0) image = idata[actual].xref;

  /* If the image has a fetched width and height, */
  /* and the browser choices specify that images  */
  /* should be shown (or the image itself has a   */
  /* high priority show bit set), display part or */
  /* all of the image.                            */
d6326 7
a6332 17
       image  >= 0 &&
       actual >= 0 &&
       (
         b->show_foreground                     ||
         b->displayed == Display_External_Image ||
         idata[actual].priority
       )
       && idata[actual].canredraw
       && idata[image].istore             /* Must check istore here, as if width / height are <= 0, */
       && idata[image].istore->width  > 0 /* the image library has no data for the image and will   */
       && idata[image].istore->height > 0 /* not have filled in (e.g.) the Render field. So you'd   */
       && idata[image].istore->DumpSprite /* get a rather nasty abort trying to call it!            */
       && image_can_be_saved_as_sprite(b, image)

//       && idata[image].istore->StartExport
//       && idata[image].istore->Export
//       && idata[image].istore->EndExport
d6335 1
a6335 2
    _kernel_oserror * e          = NULL;
    int               image_size = 0;
d6337 1
a6337 1
    if (unique_name)
a6339 1

d6345 1
d6347 1
a6347 3
    if (unique_name)
    {
      protocols_util_make_unique_name(unique_name, Limits_OS_Pathname);
d6349 1
a6349 2
      browser_redrawing = b;
      image_redrawing   = actual;
d6351 1
a6351 1
      e = idata[image].istore -> DumpSprite(idata[image].istore,
d6353 1
a6353 1
                                            -1);
d6355 1
a6355 5
      browser_redrawing = NULL;
      image_redrawing   = -1;
    }

    if (!e && unique_name)
d6357 6
a6362 5
      e = _swix(OS_File,
                _INR(0,1) | _OUT(4),

                17,
                unique_name,
d6364 1
a6364 1
                &image_size);
d6366 4
a6369 3
      if (!dont_delete)
      {
        remove(unique_name);
d6371 1
a6371 3
        free(unique_name);
        unique_name = NULL;
      }
d6374 1
a6374 3
//    e = idata[image].istore -> StartExport(idata[image].istore, &image_size);
//
//    if (!e) idata[image].istore -> EndExport(idata[image].istore);
d6376 1
a6376 2
    /* Remember, we'd skip the first 12 bytes of sprite area header */
    /* in the output Draw file.                                     */
d6378 2
a6379 1
    if (!e && image_size > 12) return image_size - 12;
d6382 4
a6385 1
  return 0;
d6389 1
a6389 1
/* image_tile_to_draw()                                       */
d6391 2
a6392 2
/* For a given redraw rectangle, tiles the background image   */
/* within that rectangle to a Draw file.                      */
d6395 1
a6395 5
/*             the window and image;                          */
/*                                                            */
/*             Pointer to a WimpRedrawWindow- Block structure */
/*             defining the area over which to tile the       */
/*             image;                                         */
d6397 1
a6397 2
/*             The X and Y coordinates to take as the tile    */
/*             origin, in OS units;                           */
d6399 5
a6403 7
/*             Pointer to an int if wanting to know the size  */
/*             of the item only, else NULL (NB the int        */
/*             contents are not updated - the pointer is      */
/*             acting like a flag, basically).                */
/*                                                            */
/* Returns:    0 if failed, else the amount of data that was  */
/*             output.                                        */
d6406 6
a6411 1
int image_tile_to_draw(browser_data * b, WimpRedrawWindowBlock * r, int xorigin, int yorigin, int * size)
a6412 1
  char              name[Limits_OS_Pathname];
a6413 14
  FILE            * input = NULL;
  void            * block = NULL;
  int               image;
  int               tsize = 0;
  int               x, y, w, h;
  int               xmin, ymax;
  int               image_size;

  /* Can only tile if there's a background image defined and fully fetched */

  if (b->background_image < 0) return 0;

  image = b->background_image;
  if (idata[image].xref >= 0) image = idata[image].xref;
d6415 1
a6415 23
  if (!idata[image].fetched || !idata[image].istore) return 0;

  /* Round the width and height to pixel boundaries */

  w = idata[image].istore->width_os  & ~1;
  h = idata[image].istore->height_os & ~1;

  if (w < 1 || h < 1) return 0;

  /* Work out the coordinates over which to tile the image */

  xmin = coords_x_toworkarea(r->redraw_area.xmin, r);
  ymax = coords_y_toworkarea(r->redraw_area.ymax, r);

  xmin -= ((xmin - xorigin) % w);
  ymax -= ((ymax - yorigin) % h) + 1;

  xmin = coords_x_toscreen(xmin, r);
  ymax = coords_y_toscreen(ymax, r);

  /* Do a blank rectangle if the image is transparent (has a mask) */

  if (idata[image].istore->transparent)
d6417 2
a6418 12
    redraw_set_colour(redraw_backcol(b));

    tsize += DSIZE_FRECT;

    if (!size)
    {
      if (!savedraw_rectangle_fill(OTD(r->redraw_area.xmin),
                                   OTD(r->redraw_area.ymin),
                                   OTD(r->redraw_area.xmax - r->redraw_area.xmin),
                                   OTD(r->redraw_area.ymax - r->redraw_area.ymin),
                                   redraw_backcol(b))) return 0;
    }
d6421 1
a6421 1
  /* How big is each image going to be? */
d6423 2
a6424 1
  protocols_util_make_unique_name(name, sizeof(name));
d6426 2
a6427 2
  browser_redrawing = b;
  image_redrawing   = b->background_image;
d6429 1
a6429 6
  e = idata[image].istore -> DumpSprite(idata[image].istore,
                                        name,
                                        -1);

  browser_redrawing = NULL;
  image_redrawing   = -1;
d6431 1
a6431 1
  if (!e)
d6433 3
a6435 7
    e = _swix(OS_File,
              _INR(0,1) | _OUT(4),

              17,
              name,

              &image_size);
d6438 2
a6439 1
  if (e || image_size <= 12) return 0;
d6441 1
a6441 1
  /* Subtract the sprite file header size */
d6443 8
a6450 6
  image_size -= 12;

  input = fopen(name, "rb");
  block = malloc(image_size);

  if (block && input && input->__file)
d6452 1
a6452 1
    /* Load the image */
d6454 1
a6454 2
    e = _swix(OS_Args,
              _INR(0,2),
d6456 2
a6457 3
              1,
              input->__file,
              12);
d6459 2
a6460 1
    if (e) goto image_tile_to_draw_exit;
d6462 1
a6462 2
    e = _swix(OS_GBPB,
              _INR(0,3),
d6464 2
a6465 4
              4,
              input->__file,
              block,
              image_size);
d6467 1
a6467 1
    if (e) goto image_tile_to_draw_exit;
d6469 3
a6471 2
    fclose(input);
    input = NULL;
d6473 1
a6473 5
    /* Render the image over the redraw region */

    for (y = ymax - h + 4; y >= r->redraw_area.ymin - h; y -= h)
    {
      for (x = xmin; x <= r->redraw_area.xmax; x += w)
d6475 1
a6475 4
        if (!size)
        {
          draw_spristrhdr hdr;
          int             ok;
d6477 4
a6480 1
          /* Write the item header */
d6482 1
a6482 2
          hdr.tag  = draw_OBJSPRITE;
          hdr.size = image_size + sizeof(hdr);
d6484 2
a6485 4
          hdr.bbox.xmin = OTD(x);
          hdr.bbox.ymin = OTD(y);
          hdr.bbox.xmax = OTD(x + w);
          hdr.bbox.ymax = OTD(y + h);
d6487 1
a6487 25
          if (!savedraw_write_bytes((char *) &hdr, sizeof(hdr))) goto image_tile_to_draw_exit;

          /* Write out the image */

          ok = savedraw_write_bytes(block, image_size);
          if (!ok) goto image_tile_to_draw_exit;

          #ifdef STRICT_PARSER

            if (e)
            {
              e->errnum = Utils_Error_Custom_Message;
              show_error_ret(e);

              goto image_tile_to_draw_exit;
            }

          #else

            if (e) goto image_tile_to_draw_exit;

          #endif
        }

        tsize += image_size + sizeof(draw_spristrhdr);
d6492 2
a6493 8
  /* Successful exit */

  if (input) fclose(input);
  if (block) free(block);

  remove(name);

  return tsize;
d6495 4
a6498 10
  /* Error condition exit */

image_tile_to_draw_exit:

  if (input) fclose(input);
  if (block) free(block);

  remove(name);

  return 0;
a6499 29

// /**************************************************************/
// /* image_gflex()                                              */
// /*                                                            */
// /* Allocate / extend a flex block with granularity, to try    */
// /* and avoid too much flex shifting.                          */
// /*                                                            */
// /* Parameters: Flex anchor for the block;                     */
// /*                                                            */
// /*             Minimum size of the block.                     */
// /*                                                            */
// /* Returns:    1 for OK, 0 for failure.                       */
// /**************************************************************/
//
// static int image_gflex(flex_ptr ptr, int size)
// {
//   ///// Presently unused... TBD...
//
//   int oldsize;
//
//   size = ((size >> ImageGranularity) + 1) << ImageGranularity;
//
//   if (*ptr == NULL) return flex_alloc(ptr, size);
//
//   oldsize = ((flex_size(ptr) >> ImageGranularity) + 1) << ImageGranularity;
//
//   if (oldsize != size) return flex_extend(ptr, size);
//   else                 return 1;
// }
@


1.51
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d145 4
d937 1
a937 1
      int oldsize;
d1290 1
a1290 1
            if (e)
d1312 2
d3524 1
a3524 1
  if (image >= nimages || image <=0)
d4146 1
a4146 1
  if (image < 0 || image > nimages) return;
d4850 1
a4850 1
    if (image > nimages)
d5136 1
a5136 1
    if (image > nimages)
d6340 29
@


1.50
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a56 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d383 1
a383 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_load_chunk: Called for image %d\n",image);
  #endif
d393 1
a393 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_load_chunk: Exitting with error\n");
  #endif
d407 1
a407 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_load_chunk: Successful\n");
  #endif
d426 1
a426 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_remove_data: Called for image %d\n",image);
  #endif
d432 1
a432 1
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d440 1
a440 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_remove_data: Successful\n");
  #endif
d454 1
a454 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_remove_all_data: Called for image %d\n",image);
  #endif
d462 1
a462 1
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d474 1
a474 1
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d485 1
a485 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_remove_all_data: Successful\n");
  #endif
d507 1
a507 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_delay: Called for image %d\n",image);
  #endif
d527 1
a527 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_delay: Successful\n");
  #endif
d578 1
a578 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_abandon: Called for image %d\n",image);
  #endif
d607 1
a607 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_abandon: Successful\n");
  #endif
d804 1
a804 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_new_image: Called\n");
  #endif
a808 1

d1023 1
a1023 1
    if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d1100 1
a1100 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_new_image: Successful\n");
  #endif
d1121 1
a1121 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_process_null: Called\n");
  #endif
d1177 1
a1177 1
        else e = NULL; /* Suppress compiler warning */
d1236 3
d1270 1
a1270 1
            #ifdef STRICT_PARSER
d1272 1
a1272 1
              /* Report any errors as Continue-only in strict parser mode */
d1274 1
a1274 1
              e = idata[image].istore -> EndLoad(idata[image].istore, &end);
d1282 9
a1290 1
            #else
d1292 1
a1292 1
              /* If not in Strict mode, ignore any errors */
d1294 10
a1303 1
              idata[image].istore -> EndLoad(idata[image].istore, &end);
d1305 5
a1309 1
            #endif
d1406 1
a1406 1
              if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d1424 1
a1424 1
            Printf("Image %d pre-fetch store:\n\n",image);
d1430 1
a1430 1
              if (cha > 31) Printf("%c",cha);
d1435 1
a1435 1
                  Printf("\n");
d1442 1
a1442 1
            Printf("\nEnd of store\n\n");
d1473 1
a1473 1
              if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d1481 1
a1481 3
          #ifdef TRACE
            if (tl & (1u<<15)) Printf("image_process_null: Exitting with error\n");
          #endif
d1505 1
a1505 1
            Printf("Image %d post-fetch store:\n\n",image);
d1511 1
a1511 1
              if (cha > 31) Printf("%c",cha);
d1516 1
a1516 1
                  Printf("\n");
d1523 1
a1523 1
            Printf("\nEnd of store\n\n");
d1550 1
a1550 1
              if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d1571 1
a1571 1
            if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d1593 1
a1593 1
            if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d1647 1
a1647 3
                #ifdef TRACE
                  if (tl & (1u<<15)) Printf("image_process_null: Exitting with error\n");
                #endif
d1677 1
a1677 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_process_null: Successful\n");
  #endif
d1776 1
a1776 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("\nimage_discard: Called for %p. There are %d images.\n\n", b, nimages);
  #endif
d1805 1
a1805 3
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_discard: Transferring cross referencer %d to cross referencee %d\n", i, xref);
      #endif
d1881 1
a1881 3
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_discard: Deleting entry owned by %p that cross references image %d\n\n", idata[i].owner, idata[i].xref);
      #endif
d1894 1
a1894 3
        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_discard: Image %d is a simple cross-referencer, deleting it\n\n", i);
        #endif
d1904 1
a1904 3
        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_discard: Image %d being marked for GC\n", i);
        #endif
d1913 1
a1913 3
        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_discard: Image does not cross reference but has no bytes fetched for it yet; so deleting it\n\n", i);
        #endif
d1922 1
a1922 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_discard: Delete pass complete; there are %d images. Calling clearup function.\n\n", nimages);
  #endif
d1926 1
a1926 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("\nimage_discard: Successful. Post-clearup, there are %d images.\n\n", nimages);
  #endif
d1949 1
a1949 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_destroy: Called for image %d\n", image);
  #endif
d2001 1
a2001 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_destroy: Image %d deleted\n\n", image);
  #endif
d2145 1
a2145 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_purge_deleted_entries: Called\n");
  #endif
d2173 1
a2173 3
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_purge_deleted_entries: No images are marked as deleted, exitting\n");
      #endif
d2225 1
a2225 3
        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_purge_deleted_entries: Renumbering %d to %d\n", last_live, first_space);
        #endif
d2235 1
a2235 3
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_purge_deleted_entries: There are no images left\n");
      #endif
d2258 1
a2258 1
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d2268 1
a2268 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_purge_deleted_entries: Successful, nimages now %d\n", nimages);
  #endif
d2286 1
a2286 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_post_deletion_clearup: Called\n");
  #endif
d2302 1
a2302 3
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_post_deletion_clearup: There is an animation handler present; checking to see if it can be removed\n");
      #endif
d2315 1
a2315 3
        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_post_deletion_clearup: Removing animation handler\n\n");
        #endif
d2323 1
a2323 4
        else
        {
          if (tl & (1u<<15)) Printf("image_post_deletion_clearup: The handler is still required\n\n");
        }
d2339 1
a2339 1
            Printf("image_post_deletion_clearup: \0211Image %d is referenced incorrectly by its token\0217 - correcting...\n", i);
d2352 1
a2352 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_post_deletion_clearup: Successful\n");
  #endif
d2515 1
a2515 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_gc_oldest: Called for %p\n",b);
  #endif
d2538 2
a2539 5
    if (tl & (1u<<15))
    {
      if (found >= 0) Printf("image_gc_oldest: Oldest is %d\n", found);
      else            Printf("image_gc_oldest: No appropriate image found\n");
    }
d2546 1
a2546 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_gc_oldest: Successful\n");
  #endif
d2834 1
a2834 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_update_area: Called for image %d\n",image);
  #endif
d2840 1
a2840 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_update_area: Image has 0 width or height, so don't need to redraw anything\n");
    #endif
d2849 1
a2849 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_update_area: Image %d can't be redrawn yet (canredraw = 0)\n",image);
    #endif
d2932 1
a2932 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_update_area: Successful\n");
  #endif
d2961 1
a2961 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_update_image: Called for image %d\n",image);
  #endif
d3353 1
a3353 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_update_image: Successful\n");
  #endif
d3511 1
a3511 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fill_background: Called with %p, %d\n", handle, i);
  #endif
d3520 1
a3520 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: \0211Serious error!\0217 Invalid image number %d. Exitting.\n",image);
    #endif
d3527 1
a3527 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: \0211Serious error!\0217 Null browser_data pointer. Exitting.\n");
    #endif
d3534 1
a3534 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: \0211Serious error!\0217 Browser %p is not a known current browser. Exitting.\n",b);
    #endif
d3541 1
a3541 3
//    #ifdef TRACE
//      if (tl & (1u<<15)) Printf("image_fill_background: \0211Serious error!\0217 Actual owner of image %d = %p, given owner = %p. Exitting.\n",ximage,idata[ximage].owner,b);
//    #endif
d3562 5
a3566 7
  #ifdef TRACE
    if (tl & (1u<<15))
    {
      Printf("image_fill_background: Decided to use %p, %d\n", b, image);
      Printf("image_fill_background: Image w, h = %d, %d\n",idata[image].currw,idata[image].currh);
    }
  #endif
d3582 2
a3583 5
    if (tl & (1u<<15))
    {
      if (bimage >= 0) Printf("image_fill_background: Background image = %d, is_background_image = %d\n", bimage, is_background_image);
      else             Printf("image_fill_background: No background image\n");
    }
d3681 1
a3681 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: No background image to plot, so successful (exitting)\n");
    #endif
d3714 1
a3714 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: Plotting scaled background\n");
    #endif
d3796 1
a3796 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: Plotting unscaled background\n");
    #endif
d3850 1
a3850 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fill_background: Successful\n");
  #endif
d3883 1
a3883 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_redraw: Called with token %d\n", token);
  #endif
d3982 1
a3982 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_redraw: Successful\n");
  #endif
d4013 1
a4013 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_tile_window: Called, background_image = %d\n",b->background_image);
  #endif
d4091 1
a4091 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_tile_window: Successful\n");
  #endif
d4176 1
a4176 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_mode_change: Called\n");
  #endif
d4196 1
a4196 3
          #ifdef TRACE
            if (tl & (1u<<15)) Printf("image_mode_change: Exitting with error\n");
          #endif
d4211 1
a4211 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_mode_change: Successful\n");
  #endif
d4233 1
a4233 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_fetches: Called\n");
  #endif
d4239 1
a4239 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_fetches: Exitting with %d\n",c);
  #endif
d4262 1
a4262 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fetching: Called\n");
  #endif
d4268 1
a4268 3
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_fetching: Exitting, there is at least 1 fetch in progress\n");
      #endif
d4274 1
a4274 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fetching: Exitting, no fetches in progress\n");
  #endif
d4295 1
a4295 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fetched: Called for image %d\n",image);
  #endif
d4299 1
a4299 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fetched: Exitting with 0 (failed)\n");
  #endif
d4323 1
a4323 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_token_fetched: Called for token %p\n",token);
  #endif
d4327 4
a4330 7
  #ifdef TRACE
    if (tl & (1u<<15))
    {
      Printf("image_token_fetched: Represents image %d\n",image);
      Printf("image_token_fetched: Exitting through image_fetched\n");
    }
  #endif
d4352 1
a4352 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_total_bytes_fetched: Called\n");
  #endif
d4367 1
a4367 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_total_bytes_fetched: Exitting with %d\n",count);
  #endif
d4391 1
a4391 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_pending: Called for %p\n",b);
  #endif
d4414 1
a4414 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_pending: Exitting with %d for %p\n",c,b);
  #endif
d4437 1
a4437 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_specific_pending: Called for %p\n",b);
  #endif
d4450 1
a4450 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_specific_pending: Exitting with %d for %p\n",c,b);
  #endif
d4571 1
a4571 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_xref: Called\n");
  #endif
d4619 1
a4619 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_xref: Exitting with %d\n", found);
  #endif
d4648 1
a4648 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_actual: Called\n");
  #endif
d4678 1
a4678 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_actual: Exitting with %d\n", found);
  #endif
d4829 1
a4829 1
    if (tl & (1u<<15)) Printf("image_get_image_size: Called for image %d\n",image);
d4868 1
a4868 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_get_image_size: Successful\n");
    #endif
d4992 1
a4992 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_get_image_size: Successful\n");
    #endif
d5026 1
a5026 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_get_image_size: Successful\n");
    #endif
d5054 1
a5054 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_image_size: Successful\n");
  #endif
d5082 1
a5082 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_size: Called\n");
  #endif
d5086 1
a5086 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_size: Exitting through image_get_image_size\n");
  #endif
d5115 1
a5115 1
    if (tl & (1u<<15)) Printf("image_set_image_size: Called for image %d\n",image);
d5146 1
a5146 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_set_image_size: Successful\n");
  #endif
d5173 1
a5173 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_set_token_image_size: Called\n");
  #endif
d5177 1
a5177 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_set_token_image_size: Exitting through image_set_image_size\n");
  #endif
d5206 1
a5206 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_actual_size: Called\n");
  #endif
d5221 1
a5221 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_actual_size: Exitting with width %d, height %d\n", *w, *h);
  #endif
d5240 1
a5240 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_back_image_size: Called, exitting through image_get_image_size\n");
  #endif
d5381 1
a5381 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_convert_to_pixels: Called\n");
  #endif
d5401 1
a5401 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_convert_to_pixels: Successful\n");
  #endif
d5847 1
a5847 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_to_draw_file: Called with token %d\n", token);
  #endif
d5997 1
a5997 3
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_to_draw_file: Exitting with %d\n", plotted);
  #endif
@


1.49
log
@
Authorisation works for image fetches. Previously authorise_authorise
assumed any check was for a browser page. Now looks at the dialogue box
client handle, which is 0 for the page or a fetch handle for an image.
The urlstat structure this relates to now has lasttoken filled in for
the token the image represents, which gives the URL to which the
user name and password relate.
@
text
@d15 24
a38 21
/***************************************************/
/* File   : Images.c                               */
/*                                                 */
/* Purpose: Image related functions.               */
/*                                                 */
/* Author : Merlyn Kline for Customer browser     */
/*          This source adapted by A.D.Hodgkinson  */
/*                                                 */
/* History: 28-Nov-96: Created with dummy function */
/*                     for temporary use in other  */
/*                     routines.                   */
/*          20-Jan-97: Filled in with most of the  */
/*                     functions present and       */
/*                     converted to the new data   */
/*                     structures where needed.    */
/*          15-Mar-97: Reorganised a bit, putting  */
/*                     functions in a more logical */
/*                     order to aid legibility.    */
/*          17-Dec-97: Added support for saving as */
/*                     a Draw file.                */
/***************************************************/
d45 16
a60 2
#include "swis.h"
#include "flex.h"
a61 9
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "toolbox.h"

#include "svcprint.h"
d366 16
a381 18
/*************************************************/
/* image_load_chunk()                            */
/*                                               */
/* Tell the image library to deal with some of   */
/* image data we've fetched for a given image.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1;                      */
/*                                               */
/*             Pointer to a buffer containing    */
/*             the data, as a char *;            */
/*                                               */
/*             The amount of data in that        */
/*             buffer.                           */
/*************************************************/
d423 11
a433 13
/*************************************************/
/* image_remove_data()                           */
/*                                               */
/* Discards the fetched image data associated    */
/* with an image, but leaves the URL information */
/* alone.                                        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1.                      */
/*************************************************/
d458 8
a465 9
/*************************************************/
/* image_remove_all_data()                       */
/*                                               */
/* Discards the fetched image data associated    */
/* with an image, including URL information.     */
/*                                               */
/* Parameters: The image number, from 0 to       */
/*             nimages - 1.                      */
/*************************************************/
d507 16
a522 20
/*************************************************/
/* image_delay()                                 */
/*                                               */
/* Stop fetching data for an image, even if it   */
/* hasn't all been fetched, but allow the fetch  */
/* to continue later on.                         */
/*                                               */
/* Call with care. Keeping part of an image is   */
/* dangerous - ImageLib may object. Normally,    */
/* this should only be called for images which   */
/* have not started to fetch. Stopping an image  */
/* mid-fetch is more safely done through         */
/* image_abandon.                                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1.                      */
/*************************************************/
d553 10
a562 10
/*************************************************/
/* image_delay_fetches()                         */
/*                                               */
/* Stops any images which have not started to    */
/* fetch for a given browser from fetching at    */
/* all, by setting the image's 'delayed' flag.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/
d585 11
a595 12
/*************************************************/
/* image_abandon()                               */
/*                                               */
/* Stop fetching data for an image, even if it   */
/* hasn't all been fetched.                      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1.                      */
/*************************************************/
d637 10
a646 11
/*************************************************/
/* image_abort_fetches()                         */
/*                                               */
/* Stop fetching data for all images belonging   */
/* to a given browser, discarding all data for   */
/* those images. The fetches cannot be restarted */
/* after this!                                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/
d721 21
a741 24
/*************************************************/
/* image_prepare()                               */
/*                                               */
/* Ensure various flags in an image are set up   */
/* as required by the token the image            */
/* represents. Will update the token to hold     */
/* the image number if FAST_TOKEN_REFERENCE is   */
/* defined.                                      */
/*                                               */
/* Originally part of image_new_image; made into */
/* a new function as it was needed more than     */
/* once.                                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to the token the image    */
/*             represents (NULL if none);        */
/*                                               */
/*             The image number;                 */
/*                                               */
/*             1 if this is a background image   */
/*             (fast processing), else 0.        */
/*************************************************/
d791 32
a822 38
/*************************************************/
/* image_new_image()                             */
/*                                               */
/* Starts fetching a new image. Creates a record */
/* in the idata flex block and increments the    */
/* image counter. If an image is already being   */
/* fetched with the same URL then a cross        */
/* reference is set up to point to that, else a  */
/* fetch is initiated.                           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image to fetch;   */
/*                                               */
/*             Pointer to the URL to fetch;      */
/*                                               */
/*             The address of the token that led */
/*             to this function call, i.e. the   */
/*             token representing that image;    */
/*                                               */
/*             1 if the image is for the         */
/*             background (it will be turned     */
/*             into a sprite for fast plotting), */
/*             else 0; or if 2, the              */
/*             background_image field of the     */
/*             browser_data structure is filled  */
/*             in with the relevant image number */
/*             and the image will again be       */
/*             turned into a sprite for fast     */
/*             plotting;                         */
/*                                               */
/*             Pointer to an int, in which an    */
/*             opaque value by which the image   */
/*             may be later referenced is        */
/*             returned - useful for garbage     */
/*             collection if you've no token     */
/*             to associate with this image (may */
/*             be NULL).                         */
/*************************************************/
d1137 11
a1147 12
/*************************************************/
/* image_process_null()                          */
/*                                               */
/* The main engine of the image loading system.  */
/* Allows up to choices.max_images images to be  */
/* simultaneously fetched. Handles redraw,       */
/* memory allocation, out-of-memory fetch stops, */
/* and so-forth.                                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/
d1698 18
a1715 22
/*************************************************/
/* image_mark_as_deleted()                       */
/*                                               */
/* Mark an image as deleted, but don't remove it */
/* from the image array yet. When all images     */
/* that are to be deleted have been thus marked, */
/* call image_purge_deleted_entries before       */
/* continuing.                                   */
/*                                               */
/* Does not free any memory at all, in the image */
/* array or any other blocks. Does not cancel    */
/* fetches or sort out other image references    */
/* such as background_image fields in            */
/* browser_data structures either, because this  */
/* may be called when images are renumbered      */
/* rather than wholly removed. If completely     */
/* wiping an image, make sure you do all of that */
/* *before* calling here.                        */
/*                                               */
/* Parameters: Number of the image to mark as    */
/*             deleted.                          */
/*************************************************/
d1743 11
a1753 12
/*************************************************/
/* image_mark_as_gcable()                        */
/*                                               */
/* Mark an image as suitable for garbage         */
/* collection. Such images may exist in the      */
/* image array for as long as required and may   */
/* be reclaimed as working items by calls to     */
/* image_new_image.                              */
/*                                               */
/* Parameters: Number of the image to mark as    */
/*             suitable for garbage collection.  */
/*************************************************/
d1764 23
a1786 26
/*************************************************/
/* image_discard()                               */
/*                                               */
/* For a given browser, discard images:          */
/*                                               */
/* * Any images which are xrefed by another      */
/*   browser have their ownership transferred    */
/*   to that other browser and the xrefing item  */
/*   is removed instead                          */
/*                                               */
/* * Any images owned by the given browser which */
/*   just xref other images are removed          */
/*                                               */
/* * Any remaining images holding actual image   */
/*   data are marked for garbage collection but  */
/*   not removed immediately.                    */
/*                                               */
/* When an image is removed, all data, including */
/* fetches, ImageLib info and external refs to   */
/* the image number is sorted out. Remaining     */
/* items in the image_info array may end up      */
/* renumbered.                                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/
d1963 15
a1977 16
/*************************************************/
/* image_destroy()                               */
/*                                               */
/* Close down any fetch associated with an       */
/* image, deal with any references to it (e.g.   */
/* the background_image field of a browser_data  */
/* structure), and remove all data except for    */
/* the actual image_info array entry. The item   */
/* is marked as deleted.                         */
/*                                               */
/* Callers should be aware of the need to call   */
/* image_post_deletion_clearup as soon as        */
/* possible after a round of image deletions.    */
/*                                               */
/* Parameters: Number of the image to remove.    */
/*************************************************/
d2040 17
a2056 20
/*************************************************/
/* image_renumber()                              */
/*                                               */
/* Move an image in the image array. Copies      */
/* over the structure from new position to old   */
/* and marks the old as deleted.                 */
/*                                               */
/* Destination image number must be a deleted    */
/* image!                                        */
/*                                               */
/* Parameters: Image's current number;           */
/*                                               */
/*             Image's desired number.           */
/*                                               */
/* Returns:    1 if the item was renumbered, 0   */
/*             if there was a problem (e.g.      */
/*             parameters out of range,          */
/*             destination image not deleted,    */
/*             etc.).                            */
/*************************************************/
d2146 25
a2170 31
/*************************************************/
/* image_purge_deleted_entries()                 */
/*                                               */
/* Gets rid of items in the image array which    */
/* are marked as deleted by renumbering things   */
/* to fill holes and then shrinking the image    */
/* array block.                                  */
/*                                               */
/* Assumes nimages is set up to include all of   */
/* the image array entries (i.e. it hasn't been  */
/* decremented yet) and decrements it before     */
/* exitting.                                     */
/*                                               */
/* Images marked as deleted but still in the     */
/* image array MUST ALWAYS BE REMOVED by this    */
/* function before anything else goes on after a */
/* round of deleting things. Deleted images will */
/* cause significant problems if run through the */
/* rest of the image system...!                  */
/*                                               */
/* This function does not touch any allocation   */
/* blocks other than idata, holding the array of */
/* image_info structures. The caller should      */
/* clean up any other image related data when    */
/* going through images marking them as deleted. */
/*                                               */
/* Returns:    1 if any items were deleted (so   */
/*             nimages will have been            */
/*             decremented appropriately), else  */
/*             0.                                */
/*************************************************/
d2319 8
a2326 9
/*************************************************/
/* image_post_deletion_clearup()                 */
/*                                               */
/* After deleting a set of images or image_info  */
/* structures which had no associated data in    */
/* ImageLib, call this to tidy up - deregister   */
/* the animation handler, resize the idata flex  */
/* block, etc.                                   */
/*************************************************/
d2414 30
a2443 36
/*************************************************/
/* image_gc()                                    */
/*                                               */
/* Garbage collect unused images.                */
/*                                               */
/* If removing only one specific image (see      */
/* parameters list), image_post_deletion_clearup */
/* is NOT called - it is assumed that the caller */
/* of this function may want to remove several   */
/* images and it would be very inefficient to    */
/* clear up after each one. So, if a specific    */
/* unique ID is given for image removal, the     */
/* caller must remember to invoke                */
/* image_post_deletion_clearup.                  */
/*                                               */
/* It is assumed that for any images marked as   */
/* suitable for GC, the owner browser still      */
/* exists. Consequently, this function MUST be   */
/* called for a given browser if that browser is */
/* about to be shut down.                        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images to collect */
/*             or NULL to remove any images      */
/*             regardless of owner;              */
/*                                               */
/*             Unique ID of a specific image to  */
/*             remove - 0 to remove all images   */
/*             regardless of ID;                 */
/*                                               */
/*             If removing images regardless of  */
/*             unique ID (0 is passed above),    */
/*             images with the 'from_js' flag    */
/*             set are still not removed unless  */
/*             a non-zero value is passed here.  */
/*************************************************/
d2533 9
a2541 11
/*************************************************/
/* image_gc_js()                                 */
/*                                               */
/* Garbage collect unused images with the        */
/* 'from_js' flag set.                           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images to collect */
/*             or NULL to remove any images      */
/*             regardless of owner.              */
/*************************************************/
d2550 15
a2564 16
/*************************************************/
/* image_gc_oldest()                             */
/*                                               */
/* Remove the oldest image which is pending      */
/* garbage collection owned by a given browser.  */
/*                                               */
/* Calls image_gc with a specific image unique   */
/* ID, therefore image_post_deletion_clearup is  */
/* not called - the caller of this function must */
/* remember to do that.                          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image to remove.  */
/*                                               */
/* Returns:    1 if an item was removed, else 0. */
/*************************************************/
d2615 9
a2623 10
/*************************************************/
/* image_maybe_gc()                              */
/*                                               */
/* Possibly garbage collect unused images for    */
/* the given browser.                            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             who's images may be garbage       */
/*             collected.                        */
/*************************************************/
d2694 19
a2712 21
/*************************************************/
/* image_refetch()                               */
/*                                               */
/* Reloads an image, redrawing as required and   */
/* setting the priority flag as asked.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images;           */
/*                                               */
/*             The image number;                 */
/*                                               */
/*             Value to set Priority flag to (so */
/*             that if 'show foreground images'  */
/*             is turned off, the image will     */
/*             override it);                     */
/*                                               */
/*             1 to redraw the image, 0 to not   */
/*             bother (e.g. for many images,     */
/*             may want to redraw the whole      */
/*             window instead).                  */
/*************************************************/
d2793 13
a2805 15
/*************************************************/
/* image_reload()                                */
/*                                               */
/* Reloads an image, redrawing as required and   */
/* setting the priority flag so that even if a   */
/* browser has 'show foreground images' turned   */
/* off, the reloading image (and all that cross  */
/* reference it) will still be shown.            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images;           */
/*                                               */
/*             Address of the token representing */
/*             the image.                        */
/*************************************************/
d2816 16
a2831 19
/*************************************************/
/* image_restart_fetches()                       */
/*                                               */
/* If image loading has been suspended for any   */
/* reason, it can be resumed by calling this     */
/* function. Any images already loaded will be   */
/* reshown. The priority flag for images is not  */
/* set, so the browser must be set to display    */
/* foreground images for anything to show up.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images;           */
/*                                               */
/*             1 to restart foreground fetches,  */
/*             else 0;                           */
/*                                               */
/*             1 to restart background fetches,  */
/*             else 0.                           */
/*************************************************/
d2864 25
a2888 27
/*************************************************/
/* image_update_area()                           */
/*                                               */
/* Updates (redraws) part of an image, which     */
/* will reflect any new data fetched for it if   */
/* the whole image hasn't been fetched yet.      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The left hand X window coordinate */
/*             in OS units for the image;        */
/*                                               */
/*             The bottom Y window coordinate in */
/*             OS units for the image;           */
/*                                               */
/*             A BBox defining a rectangle       */
/*             relative to X and Y which is the  */
/*             area to update;                   */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1;                      */
/*                                               */
/*             1 to force a redraw (i.e. clear   */
/*             any previously drawn data first), */
/*             zero to not clear the region.     */
/*************************************************/
d3009 17
a3025 21
/*************************************************/
/* image_update_image()                          */
/*                                               */
/* Update the specified image number on screen,  */
/* including all which cross reference it. If    */
/* the image has changed size on screen then     */
/* start a reformat from the first occurrence    */
/* (i.e. smallest token number), otherwise just  */
/* do an update on the relevant rectangle for    */
/* each occurrence.                              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images;           */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1;                      */
/*                                               */
/*             Pointer (which may be NULL) to a  */
/*             BBox into which the image's size  */
/*             will be returned.                 */
/*************************************************/
d3434 8
a3441 10
/*************************************************/
/* image_animate_images()                        */
/*                                               */
/* Checks all images to see if they need         */
/* updating. Designed to be called on null       */
/* events.                                       */
/*                                               */
/* Parameters are as standard for a Wimp event   */
/* handler.                                      */
/*************************************************/
d3504 9
a3512 9
/*************************************************/
/* image_register_filler()                       */
/*                                               */
/* Registers the given image and it's owning     */
/* browser with ImageLib. Must be called for     */
/* cross referencing images only.                */
/*                                               */
/* Parameters: The image number to register.     */
/*************************************************/
d3550 18
a3567 20
/*************************************************/
/* image_fill_background()                       */
/*                                               */
/* Called as a FillerFunction for ImageLib,      */
/* this draws whatever background is appropriate */
/* for the registered image. Output should have  */
/* been redirected by ImageLib at this point.    */
/*                                               */
/* The way the function is registered should     */
/* leave void * handle pointing to the browser   */
/* owning the image with int * i actually being  */
/* an int (not an int *) holding the image       */
/* number for which the function was registered  */
/* in the first place. The owner of this image   */
/* is used for all general information - the     */
/* browser given in the first pointer is just    */
/* used to spot potential errors; if the browser */
/* given as the owner is not actually the owner  */
/* of the given image, the function will exit.   */
/*************************************************/
d3954 22
a3975 26
/*************************************************/
/* image_redraw()                                */
/*                                               */
/* Does a high level redraw of an image, with    */
/* an outline to show where the image should be  */
/* if it isn't all plotted, or a slabbed box to  */
/* display broken or unfetched images.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a RedrawWindowBlock    */
/*             struct which holds information    */
/*             about the current redraw session; */
/*                                               */
/*             Address of the token representing */
/*             the image;                        */
/*                                               */
/*             The X offset in window coords (so */
/*             OS units) of the left hand edge   */
/*             of the image;                     */
/*                                               */
/*             The Y offset in window coords (so */
/*             OS units) of the bottom edge of   */
/*             the image.                        */
/*************************************************/
d4090 18
a4107 18
/*************************************************/
/* image_tile_window()                           */
/*                                               */
/* For a given redraw rectangle, tiles the       */
/* background image within that rectangle.       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the window and image; */
/*                                               */
/*             Pointer to a WimpRedrawWindow-    */
/*             Block structure defining the area */
/*             over which to tile the image;     */
/*                                               */
/*             The X and Y coordinates to take   */
/*             as the tile origin, in OS units.  */
/*                                               */
/* Returns:    1 for success, 0 for failure.     */
/*************************************************/
d4203 12
a4214 13
/*************************************************/
/* image_mark_as_redrawable()                    */
/*                                               */
/* Flags that an image may now be redrawn (this  */
/* is generally called because an unsized image  */
/* has found its size, asked for a reformat, and */
/* that reformat is about to take place).        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number.                 */
/*************************************************/
d4225 13
a4237 13
/*************************************************/
/* image_token_reformatted()                     */
/*                                               */
/* Called by a reformatter to signal an image is */
/* locked in a line array. Sets the image's      */
/* canredraw flag and locks the image's size.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the image.           */
/*************************************************/
d4275 5
a4279 6
/*************************************************/
/* image_mode_change()                           */
/*                                               */
/* Ensure images are up to date following a mode */
/* change.                                       */
/*************************************************/
d4329 12
a4340 14
/*************************************************/
/* image_count_fetches()                         */
/*                                               */
/* Counts how many fetches are being performed   */
/* for a given web page.                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the page and images   */
/*             being fetched.                    */
/*                                               */
/* Returns:    The number of image fetches that  */
/*             are currently in progress (this   */
/*             may be zero, of course).          */
/*************************************************/
d4361 13
a4373 14
/*************************************************/
/* image_fetching()                              */
/*                                               */
/* Returns 1 if there are any image fetches      */
/* going on at all, else 0 (faster than using    */
/* image_count_fetches above if you don't care   */
/* how many fetches there are).                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the inquiry.          */
/*                                               */
/* Returns:    1 if there are image fetches in   */
/*             progress, else 0.                 */
/*************************************************/
d4402 13
a4414 15
/*************************************************/
/* image_fetched()                               */
/*                                               */
/* Determines if an image has been completely    */
/* fetched or not.                               */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1.                      */
/*                                               */
/* Returns:    1 if the image has been fetched   */
/*             completely, else 0.               */
/*************************************************/
d4431 14
a4444 16
/*************************************************/
/* image_token_fetched()                         */
/*                                               */
/* Determines if an image has been completely    */
/* fetched or not, based on a token representing */
/* the image.                                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a token representing   */
/*             the image.                        */
/*                                               */
/* Returns:    1 if the image has been fetched   */
/*             completely, else 0.               */
/*************************************************/
d4467 12
a4478 13
/*************************************************/
/* image_total_bytes_fetched()                   */
/*                                               */
/* Works out the total number of bytes fetched   */
/* in images so far.                             */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*                                               */
/* Returns:    The number of bytes fetched in    */
/*             image data at the moment of       */
/*             calling the function.             */
/*************************************************/
d4508 14
a4521 16
/*************************************************/
/* image_count_pending()                         */
/*                                               */
/* Counts how many images are waiting to be      */
/* fetched, but have been delayed for whatever   */
/* reason.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images. Any       */
/*             images in child windows are also  */
/*             included in the count.            */
/*                                               */
/* Returns:    The number of images waiting to   */
/*             be fetched, counting any images   */
/*             in any child windows (if present) */
/*************************************************/
d4559 13
a4571 14
/*************************************************/
/* image_count_specific_pending()                */
/*                                               */
/* Counts how many images are waiting to be      */
/* fetched, but have been delayed for whatever   */
/* reason, for just the specified browser (not   */
/* including any child windows).                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*                                               */
/* Returns:    The number of images waiting to   */
/*             be fetched in the given browser.  */
/*************************************************/
d4599 9
a4607 10
/*************************************************/
/* image_count_delayed()                         */
/*                                               */
/* Returns the number of images which have been  */
/* delayed (could be fetched, but have been set  */
/* up to not fetch yet).                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/
d4638 15
a4652 16
/*************************************************/
/* image_plot_started()                          */
/*                                               */
/* Returns 1 if a given image in a given browser */
/* has had some plotting done for it (so the     */
/* placeholder box and possibly ALT text will no */
/* longer be visible for it).                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The number of the image.          */
/*                                               */
/* Returns:    1 if the image has been partially */
/*             or completely plotted, else 0.    */
/*************************************************/
d4666 15
a4680 17
/*************************************************/
/* image_token_plot_started()                    */
/*                                               */
/* Returns 1 if a given image in a given browser */
/* has had some plotting done for it (so the     */
/* placeholder box and possibly ALT text will no */
/* longer be visible for it).                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a token representing   */
/*             the image.                        */
/*                                               */
/* Returns:    1 if the image has been partially */
/*             or completely plotted, else 0.    */
/*************************************************/
d4691 15
a4705 16
/*************************************************/
/* image_get_token_image_xref()                  */
/*                                               */
/* Finds the image number associated with a      */
/* given token. The number will be the image     */
/* that actually has the associated image data,  */
/* not just one that cross references this data. */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The token address.                */
/*                                               */
/* Returns:    The image number which references */
/*             that token, or -1 if none found.  */
/*************************************************/
d4772 15
a4786 16
/*************************************************/
/* image_get_token_image_actual()                */
/*                                               */
/* As image_get_token_image, but returns the     */
/* exact image number represented by the given   */
/* token rather than the cross referenced one    */
/* with the pointers to the image data.          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The token address.                */
/*                                               */
/* Returns:    The image number which references */
/*             that token, or -1 if none found.  */
/*************************************************/
d4835 16
a4850 18
/*************************************************/
/* image_lock_image_size()                       */
/*                                               */
/* Ask image_get_image_size for the size of an   */
/* image, making sure currw and currh are -1 so  */
/* that it works the size out from first         */
/* principles, then set that size jn currw and   */
/* currh for future reference.                   */
/*                                               */
/* Designed to be called by the reformatter when */
/* it encounters an image and stores it in a     */
/* line array.                                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Number of the image.              */
/*************************************************/
d4869 12
a4880 12
/*************************************************/
/* image_lock_token_image_size()                 */
/*                                               */
/* As image_lock_image_size, but takes a pointer */
/* to an HStream rather than an image number.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the image.           */
/*************************************************/
d4893 15
a4907 16
/*************************************************/
/* image_unlock_image_size()                     */
/*                                               */
/* Set currw and currh for an image to -1, so    */
/* that image_get_image_size will start working  */
/* the size out from first principles rather     */
/* than using any prestored value.               */
/*                                               */
/* Designed to be called by the reformatter when */
/* it destroys a line array with images in it.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Number of the image.              */
/*************************************************/
d4917 12
a4928 13
/*************************************************/
/* image_unlock_token_image_size()               */
/*                                               */
/* As image_unlock_image_size, but takes a       */
/* pointer to an HStream rather than an image    */
/* number.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the image.           */
/*************************************************/
d4941 22
a4962 25
/*************************************************/
/* image_get_image_size()                        */
/*                                               */
/* Returns the size of an image in OS units.     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1, which may just be a  */
/*             cross referencing image (i.e. has */
/*             no directly associated data);     */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             size information is placed (xmax  */
/*             and ymax fields filled with       */
/*             width and height currently - xmin */
/*             and ymin always zero);            */
/*                                               */
/*             1 to ignore the image's currw and */
/*             currh fields, else use those if   */
/*             they are present.                 */
/*                                               */
/* Assumes:    The BBox pointer is not NULL.     */
/*************************************************/
d5219 18
a5236 19
/*************************************************/
/* image_get_token_image_size()                  */
/*                                               */
/* As image_get_image_size above, but takes a    */
/* token address rather than an image number.    */
/* The default 'unknown' image size will be      */
/* returned if no image could be associated with */
/* the token (no error will be raised).          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             A token address;                  */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             size information is placed.       */
/*                                               */
/* Assumes:    The BBox pointer is not NULL.     */
/*************************************************/
d5255 19
a5273 20
/*************************************************/
/* image_set_image_size()                        */
/*                                               */
/* Sets the size of an image (currw, currh       */
/* fields) in OS units.                          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1, which may just be a  */
/*             cross referencing image (i.e. has */
/*             no directly associated data);     */
/*                                               */
/*             Pointer to a BBox from which the  */
/*             size information is read (xmax -  */
/*             xmin, ymax - ymin).               */
/*                                               */
/* Assumes:    The BBox pointer is not NULL.     */
/*************************************************/
d5317 17
a5333 17
/*************************************************/
/* image_set_token_image_size()                  */
/*                                               */
/* As image_set_image_size above, but takes a    */
/* token address rather than an image number.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             A token address;                  */
/*                                               */
/*             Pointer to a BBox from which the  */
/*             size information is read (xmax -  */
/*             xmin, ymax - ymin).               */
/*                                               */
/* Assumes:    The BBox pointer is not NULL.     */
/*************************************************/
d5352 19
a5370 21
/*************************************************/
/* image_get_token_actual_size()                 */
/*                                               */
/* Returns the width and height of an image, in  */
/* pixels, or 0 and 0 if it the size isn't known */
/* yet.                                          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             A token address;                  */
/*                                               */
/*             Pointer to an int, in which the   */
/*             width is written;                 */
/*                                               */
/*             Pointer to an int, in which the   */
/*             height is written.                */
/*                                               */
/* Assumes:    All pointers are non-NULL and     */
/*             valid.                            */
/*************************************************/
d5400 11
a5410 13
/*************************************************/
/* image_get_back_image_size()                   */
/*                                               */
/* Finds out the size of the background image in */
/* OS units.                                     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the background image; */
/*             Pointer to a BBox into which the  */
/*             size information is placed.       */
/*                                               */
/* Assumes:    That neither pointer is NULL.     */
/*************************************************/
d5421 22
a5442 24
/*************************************************/
/* image_get_token_image_position()              */
/*                                               */
/* Returns the x and y fields of the image_info  */
/* structure for a given image.                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to the token representing */
/*             the image;                        */
/*                                               */
/*             Pointer to an int, in which the   */
/*             X coordinate is returned;         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Y coordinate is returned.         */
/*                                               */
/* Returns:    1 if the image could not be found */
/*             from the given token, or 0 for    */
/*             success.                          */
/*                                               */
/* Assumes:    Neither pointer is NULL.          */
/*************************************************/
d5456 19
a5474 21
/*************************************************/
/* image_set_token_image_position()              */
/*                                               */
/* Sets the x and y fields of the image_info     */
/* structure for a given image, so that it may   */
/* be [partially] plotted during a fetch.        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to the token representing */
/*             the image;                        */
/*                                               */
/*             X coordinate (window coords);     */
/*                                               */
/*             Y coordinate (window coords).     */
/*                                               */
/* Returns:    Number of the image that was      */
/*             changed, or -1 if none could be   */
/*             found for the given token.        */
/*************************************************/
d5491 12
a5502 14
/*************************************************/
/* image_get_background_image_url()              */
/*                                               */
/* Returns the URL of a browser's current        */
/* background image.                             */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the background;       */
/*                                               */
/*             Pointer to a buffer to take the   */
/*             URL;                              */
/*                                               */
/*             Size of the buffer.               */
/*************************************************/
d5533 19
a5551 21
/*************************************************/
/* image_convert_to_pixels()                     */
/*                                               */
/* Converts a given OS unit X and Y size to      */
/* pixel size, for a given image.                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to the token representing */
/*             the image;                        */
/*                                               */
/*             Pointer to an int which already   */
/*             contains the X size in OS units,  */
/*             which will have the pixel size    */
/*             returned into it;                 */
/*                                               */
/*             A similar pointer for the Y size. */
/*                                               */
/* Assumes:    That no pointer is NULL.          */
/*************************************************/
d5584 23
a5606 27
/*************************************************/
/* image_return_click_offset()                   */
/*                                               */
/* Calculate the coordinates of a click on an    */
/* image in pixels from the top left corner, as  */
/* required by image maps and image input        */
/* fields.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a token representing   */
/*             the image;                        */
/*                                               */
/*             A WimpGetPointerInfo block        */
/*             pointer describing the mouse      */
/*             pointer's position;               */
/*                                               */
/*             Pointer to an int, in which the   */
/*             x offset is returned;             */
/*                                               */
/*             Pointer to an int, in which the   */
/*             y offset is returned.             */
/*                                               */
/* Assumes:    That the int pointers are not     */
/*             NULL.                             */
/*************************************************/
d5645 18
a5662 19
/*************************************************/
/* image_can_be_saved_as_sprite                  */
/*                                               */
/* Returns 1 if a given image has data and can   */
/* be saved (the DumpSprite function is          */
/* present), else 0.                             */
/*                                               */
/* The image may cross reference another with    */
/* the actual data. If so, the return value will */
/* be referring to that cross referenced image.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             owning the image;                 */
/*                                               */
/*             Number of the image.              */
/*                                               */
/* Returns:    1 if the image can be saved as a  */
/*             sprite, else 0.                   */
/*************************************************/
d5677 19
a5695 21
/*************************************************/
/* image_token_can_be_saved_as_sprite            */
/*                                               */
/* Returns 1 if a given image has data and can   */
/* be saved (the DumpSprite function is          */
/* present), else 0.                             */
/*                                               */
/* The image may cross reference another with    */
/* the actual data. If so, the return value will */
/* be referring to that cross referenced image.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             owning the image;                 */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*                                               */
/* Returns:    1 if the image can be saved as a  */
/*             sprite, else 0.                   */
/*************************************************/
d5731 14
a5744 15
/*************************************************/
/* image_export_sprite()                         */
/*                                               */
/* Saves an image represented by the given token */
/* as a sprite at the given path.                */
/*                                               */
/* Parameters: Pointer to the path to save to;   */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             that owns the image;              */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*************************************************/
d5796 15
a5810 17
/*************************************************/
/* image_sprite_size()                           */
/*                                               */
/* Returns the size that the given image would   */
/* be as a sprite on disc.                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             that owns the image;              */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*                                               */
/* Returns:    The size the image would be as a  */
/*             sprite file saved to disc, in     */
/*             bytes (a guess only).             */
/*************************************************/
d5819 14
a5832 15
/*************************************************/
/* image_export_original()                       */
/*                                               */
/* Saves an image represented by the given token */
/* in its original format to the given path.     */
/*                                               */
/* Parameters: Pointer to the path to save to;   */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             that owns the image;              */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*************************************************/
d5967 14
a5980 16
/*************************************************/
/* image_original_size()                         */
/*                                               */
/* Returns the size of a given image in its      */
/* original format.                              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             that owns the image;              */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*                                               */
/* Returns:    The size of the original image,   */
/*             in bytes (a guess only).          */
/*************************************************/
d5990 31
a6020 37
/*************************************************/
/* image_to_draw_file()                          */
/*                                               */
/* As image_redraw, but will output a sprite     */
/* to the Draw file being output by SaveDraw.c   */
/* (which must be active at the time this is     */
/* called). Assumes that the appropriate Draw    */
/* file object header has already been written.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a RedrawWindowBlock    */
/*             struct which holds information    */
/*             about the current redraw session; */
/*                                               */
/*             Address of the token representing */
/*             the image;                        */
/*                                               */
/*             The X offset in window coords (so */
/*             OS units) of the left hand edge   */
/*             of the image;                     */
/*                                               */
/*             The Y offset in window coords (so */
/*             OS units) of the bottom edge of   */
/*             the image;                        */
/*                                               */
/*             1 to assume the image is already  */
/*             present as a sprite in            */
/*             'unique_name' else create the     */
/*             image first.                      */
/*                                               */
/* Returns:    0 if failed, 1 if successful; if  */
/*             failed, caller should try some    */
/*             alternative representation (e.g.  */
/*             write out a placeholder).         */
/*************************************************/
d6186 18
a6203 21
/*************************************************/
/* image_draw_file_size()                        */
/*                                               */
/* Returns the amount of data that               */
/* image_to_draw_file would write to the output  */
/* file.                                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Address of the token representing */
/*             the image;                        */
/*                                               */
/*             1 to not delete the scrap file    */
/*             in 'unique_name' that this        */
/*             writes, else 0.                   */
/*                                               */
/* Returns:    0 if failed, else the amount of   */
/*             data that image_to-draw_file      */
/*             would write to the output file.   */
/*************************************************/
d6306 24
a6329 26
/*************************************************/
/* image_tile_to_draw()                          */
/*                                               */
/* For a given redraw rectangle, tiles the       */
/* background image within that rectangle to a   */
/* Draw file.                                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the window and image; */
/*                                               */
/*             Pointer to a WimpRedrawWindow-    */
/*             Block structure defining the area */
/*             over which to tile the image;     */
/*                                               */
/*             The X and Y coordinates to take   */
/*             as the tile origin, in OS units;  */
/*                                               */
/*             Pointer to an int if wanting to   */
/*             know the size of the item only,   */
/*             else NULL (NB the int contents    */
/*             are not updated - the pointer is  */
/*             acting like a flag, basically).   */
/*                                               */
/* Returns:    0 if failed, else the amount of   */
/*             data that was output.             */
/*************************************************/
@


1.48
log
@Long overdue check-in of intermediate browser build, from continued "out
of hours" work. Forgot to add a few files last time too.

List dialogue box handler complete, and exclusion lists implemented
within the main browser code. Full documentation in Choices file.
Save routine knows all about it but is now getting very slow - must
come up with a better scheme; for now, it puts the hourglass on...

StripExtensions option controls auto stripping of filename extensions.

More sensible ancestor / frame selection for keyboard shortcut items
and the save dialogues - having selected a frame won't lock you into
it for F3 and related shortcuts now (input focus in URL writable ->
get ancestor details, input focus in frame -> get frame details). F4
works in frames. F5 now generally present for 'view source' with a
corresponding menu entry in the File menu.

Odd thing in later Res files; there's no action set for Adjust clicks
on the main ToolAction items in the button bar. Very odd. Nothing
appears to be set in v2.07 either, yet adjust-click works. Even
stranger. Anyway, added in the relevant event details (same as for
Select click in all cases) and this fixes the problem.

Background colours in the TABLE tag ignored the "don't print any
backgrounds" Print Style setting. Fixed. Meanwhile, the "black
text with no backgrounds" option wasn't getting this right either;
fixed this also.

Event logging implemented; HTTP errors and script output via.
window.print extension. No internal error output yet.

Faith:Never behaviour extended. If ever a server sends something with
no content type or an unhandleable type, the browser will try and get a
filetype from the URL. If it gets text or HTML, it'll render the file.
Else it'll save it. Hacks around IIS 4's lack of a content type field
in the Marketeye login stuff, and similar other slightly broken sites.
@
text
@d1236 8
@


1.47
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d1068 14
d1101 1
a1101 6
  /* If there's data for a URL, copy it into the above allocated block */
  /* and inform ImageLib of the new image.                             */

  if (ulen)
  {
    strcpy(idata[nimages].flex->urldata, url);
d1103 6
a1108 6
    #ifdef ALL_FAST
      idata[nimages].istore = NewImage(NULL, IMAGE_FAST);
    #else
      idata[nimages].istore = NewImage(NULL, background ? IMAGE_FAST : 0);
    #endif
  }
d1501 2
a1502 1
          /* suppression of any errors from html_get above.                   */
a3075 6
  /* Update the specified image number on the screen, including all       */
  /* which xref to it. If the image has changed size on screen then start */
  /* a reformat from the first occurrence (ie the smallest token number), */
  /* otherwise just do an update of the relevant rectangle for each       */
  /* occurrence.                                                          */

d3078 1
a3078 1
  BBox whole, partial;
d3089 1
a3089 1
  /* area or the whole image without needing special case code.          */
d3130 2
d3137 2
a3138 9
  /* When the image library gets some data for an image it will fill */
  /* in the width_os and height_os fields of the istore structure    */
  /* that 'image' points to. If the HTML source didn't specify a     */
  /* size for this or cross referencing images and the size is not   */
  /* the same as stored in currw / currh, flag that a reformat is    */
  /* needed for this image.                                          */
  /*                                                                 */
  /* Since this is driven by ImageLib suppling data, we only need to */
  /* do this if the requested image to update holds the image data.  */
d3140 8
a3147 2
  if (
       actual == image                     &&
d3149 5
a3153 6
       !idata[actual].hadfirst             &&
       idata[image].istore->width_os  >= 0 &&
       idata[image].istore->height_os >= 0
     )
  {
    for (i = 0; i < nimages; i++)
d3155 1
a3155 7
      if (
           (
             idata[i].xref == image ||
             i == image
           )
           && !idata[i].fixedsize
         )
a3156 16
        BBox size;

        /* Ignore any existing currw and currh values - find the image */
        /* size based entirely on the HTML and the image itself        */

        image_get_image_size(b,
                             i,
                             &size,
                             1);

        /* Does the returned value differ from the stored size? If so, */
        /* flag that we must do a reformat for this image. It is up to */
        /* the reformatter to call back to routines in this source     */
        /* file and update currw and currh once the image is           */
        /* incorporated into a line array.                             */

d3158 5
a3162 2
             size.xmax != idata[i].currw ||
             size.ymax != idata[i].currh
d3164 2
a3165 4
           idata[i].reformat = 1;
      }
    }
  }
d3167 2
a3168 3
  /* If the image is for the background, just refresh the window contents */
  /* with browser_update_window (remembering to update those windows that */
  /* cross reference the same background image, too).                     */
d3170 4
a3173 3
  {
    int            isbackground = 0;
    browser_data * check        = last_browser;
d3175 5
a3179 2
    /* First check if the image is the background of this browser. If */
    /* not then check all browsers.                                   */
d3181 6
a3186 8
    if (actual == b->background_image || image == b->background_image) isbackground = 1;
    else
    {
      while (check && !isbackground)
      {
        if (actual == check->background_image || image == check->background_image) isbackground = 1;

        check = check->previous;
d3190 3
a3192 2
    /* If this is a background, update all instances of the image */
    /* and exit the update routine here.                          */
d3194 1
a3194 1
    if (isbackground)
d3196 1
a3196 4
      /* (Only update other browsers if the image we were asked to update is */
      /* holding the actual image data, so the appearance may have changed). */

      if (actual == image)
d3198 1
a3198 1
        for (i = 0; i < nimages; i++)
d3200 1
a3200 4
          if ((i == image || idata[i].xref == image) && idata[image].fetched)
          {
            browser_update_bottom(idata[i].owner, NULL);
          }
d3222 3
a3224 4
      int       l, x, y;
      int       noplot = 0;
      HStream * tp;
      BBox      ibox;
d3306 4
d4286 1
a4286 1
/* canredraw flag and locs the image's size.     */
@


1.46
log
@Corrected the Font Manager bug that never was - adjustment calculations
for line height in preformatted text were bogus. Fixed also daft use of
'&&' instead of '&' in trace build conditional debug output for
image_purge_deleted_entries.
@
text
@d819 1
a819 1
/*             else 0. If 2, then the            */
d1005 1
a1005 2
  /* Increment the image counter, zero the contents of the image_info structure */
  /* and fill in some of the fields where contents are known now.               */
d1007 1
a1007 1
  memset(&idata[nimages], 0, sizeof(image_info)); /* Precautionary catch-all */
d1070 1
a1070 1
  /* is a backgrond image and backgrounds are flagged to be    */
d3126 1
a3126 1
  if (idata[image].istore -> RegisterFiller && !idata[image].hadfiller)
d3621 3
a3623 3
/* this redraws the background image. Output     */
/* will probably have been redirected by         */
/* ImageLib at this point.                       */
d3627 9
a3635 4
/* who's background will be redrawn, with int *  */
/* i actually being an int (not an int *)        */
/* holding the image number for which the        */
/* function was registered in the first place.   */
d3649 1
d3652 1
d3660 41
d3705 11
a3715 1
  /* Should never happen, but you never know... */
d3717 7
a3723 1
  if (idata[ximage].xref >= 0) ximage = idata[ximage].xref;
d3725 2
a3726 2
  /* See the top of the file for details on browser_redrawing */
  /* and image_redrawing                                      */
d3728 6
a3733 1
  if (browser_redrawing) b = browser_redrawing;
d3735 2
a3736 2
  if (image_redrawing >= -1) image = image_redrawing;
  else                       image = ximage;
d3741 2
a3742 2
      Printf("image_fill_background: Decided to use %p, %d\n", b, image);
      Printf("image_fill_background: Image w, h = %d, %d\n",idata[image].currw,idata[image].currh);
d3749 1
a3749 1
  if (idata[image].token && b->use_source_cols)
d3755 4
a3758 2
  /* We may still have no defined background colour, in which */
  /* case check the main page background.                     */
d3762 1
a3762 4
    /* Can't plot a background image if there's no such image or */
    /* it's not fully fetched.                                   */

    if (b->background_image >= 0)
d3764 6
a3769 18
      bimage = b->background_image;
      if (idata[bimage].xref >= 0) bimage = idata[bimage].xref;
    }
    else bimage = -1, noplot = 1;

    #ifdef TRACE
      if (tl & (1u<<15))
      {
        if (bimage >= 0) Printf("image_fill_background: Background image = %d\n",bimage);
        else             Printf("image_fill_background: No background image\n");
      }
    #endif

    if (
         !noplot &&
         (
           !idata[bimage].fetched ||
           !idata[bimage].istore
d3771 1
a3771 2
       )
       noplot = 1;
d3773 7
a3779 6
    if (
         !noplot              &&
         idata[bimage].istore &&
         (
           idata[bimage].istore->width_os  <= 0 ||
           idata[bimage].istore->height_os <= 0
d3781 2
a3782 2
       )
       noplot = 1;
d3801 8
a3808 5
  /* Do a blank rectangle if the image is transparent (has a mask) */
  /* or the image itself can't be plotted, or the browser window   */
  /* set up not to plot background images, or we're printing and   */
  /* shouldn't plot backgrounds (we must plot something at this    */
  /* stage!).                                                      */
d3811 4
a3814 3
       noplot                            ||
       idata[bimage].istore->transparent ||
       !b->show_background               ||
d3829 1
a3829 1
  /* If there's no background image that can be plotted, exit here */
d3832 1
d3867 8
a3874 6
    BBox  redraw;
    float scalex, scaley;
    float tempx,  tempy;
    float tempw,  temph;
    int   htop;
    int   oimage;
d3888 2
a3889 2
    tempw = idata[bimage].istore->width_os;
    temph = idata[bimage].istore->height_os;
d3918 1
a3918 1
    idata[bimage].istore -> ModeChange(idata[bimage].istore);
d3920 1
a3920 1
    /* Render the image over the redraw region, with a scaled plot */
d3926 2
a3927 2
        oimage          = image_redrawing;
        image_redrawing = bimage;
d3929 11
a3939 6
        e = (idata[bimage].istore -> Render(idata[bimage].istore,
                                            x,
                                            y,
                                            100,
                                            w,
                                            h));
d3941 2
a3942 1
        image_redrawing = oimage;
d3950 1
a3950 1
    idata[bimage].istore -> ModeChange(idata[bimage].istore);
d3954 5
a3958 3
    BBox redraw;
    int  htop;
    int  oimage;
d3964 2
a3965 2
    w = (idata[bimage].istore->width_os)  & ~(wimpt_dx() - 1);
    h = (idata[bimage].istore->height_os) & ~(wimpt_dy() - 1);
d3985 1
a3985 1
    idata[bimage].istore -> ModeChange(idata[bimage].istore);
d3987 1
a3987 1
    /* Render the image over the redraw region, with an unscaled plot */
d3993 13
a4005 10
        oimage          = image_redrawing;
        image_redrawing = bimage;

        e = (idata[bimage].istore -> Render(idata[bimage].istore,
                                            x,
                                            y,
                                            100,
                                            -1,
                                            -1));
        image_redrawing = oimage;
d4013 1
a4013 1
    idata[bimage].istore -> ModeChange(idata[bimage].istore);
@


1.45
log
@Tweaks to export rules in Makefile - ResJ source for JavaScript builds,
all of User dir exported, resources rule exports About as well as User.

Handles images with a width or height of 0 specified in the HTML.
Previously went for a default size placeholder and changes to image
sizes and/or redraw problems could occur before/after subsequent
reformatting (involved trivial changes to image_get_image_size and
image_redraw_area only).

Default parameter HRs now plot properly in rectangular pixel modes.

Choices code updated to cope with the minimum font size, JS support,
watchdog on/off and timeout, Navigator object option added generally
(act even *more* like Navigator), image GC after fetch, and image
GC unused image / free RAM constraints.

Code in JSnavigator.c updated to obey new "act more like Navigator"
option (see above). Currently declares itself as version 3.0.

Resources for all builds are up to date. All links in default hotlist
verified and corrected where necessary, with several new links added.

This is Release v2.07. Not tested very much, sorry; YMMV.
@
text
@d2196 1
a2196 1
    if (tl && (1u<<15)) Printf("image_purge_deleted_entries: Called\n");
d2226 1
a2226 1
        if (tl && (1u<<15)) Printf("image_purge_deleted_entries: No images are marked as deleted, exitting\n");
d2280 1
a2280 1
          if (tl && (1u<<15)) Printf("image_purge_deleted_entries: Renumbering %d to %d\n", last_live, first_space);
d2292 1
a2292 1
        if (tl && (1u<<15)) Printf("image_purge_deleted_entries: There are no images left\n");
d2327 1
a2327 1
    if (tl && (1u<<15)) Printf("image_purge_deleted_entries: Successful, nimages now %d\n", nimages);
@


1.44
log
@Another intermediate version, rather more stable than the last I hope.

Lazy clearing of backgrounds - pages with the same background image or
colour won't be cleared to grey when going from one to the next anymore.

BODY element onLoad script attribute implemented properly (beyond the
Customer hackery).

Images use independent flex blocks for URL and transient fetch data;
greatly improved data throughput in image system as a result. Image
renumbering implemented - speeds up closing of pages / frames with
many images. Image xref is still rather slow though and images with
a 0 width or height specified in the HTML still cause an incorrectly
formatted page to appear.

Have, I think, fixed the "stops anti-aliasing" bug. Noticed that some
background images are not being processed as Fast (e.g. at the
Fibblesnork Lego Guide) - that old problem has reappeared, then.

Background images would cross reference when two pages had the same
background colour set in <body> elements but one was configured to use
document colours and one wasn't (so xref should not occur). Code was
looking at b->background_colour; corrected to call redraw_backcol(b).

Titles were added to the history according to the fetch URL not the
display URL, though the former is more likely to be in the history due
to the code execution order in the fetcher; changed to see whether this
improves upon the rather hit and miss addition of titles.

The 'about:' page now gets entered into the history (makes for much more
sensible behaviour if it is configured as a Home page, for example).
@
text
@d2936 11
d4016 1
a4016 1
    _kernel_oserror * e;
d4018 4
a4021 2
    browser_redrawing = b;
    image_redrawing   = actual;
d4023 6
a4028 6
    e = idata[image].istore -> Render(idata[image].istore,
                                      x,
                                      y,
                                      100,
                                      idata[actual].currw,
                                      idata[actual].currh);
d4030 2
a4031 2
    browser_redrawing = NULL;
    image_redrawing   = -1;
d4033 1
a4033 1
    #ifdef STRICT_PARSER
d4035 5
a4039 5
      if (e)
      {
        e->errnum = Utils_Error_Custom_Message;
        show_error_ret(e);
      }
d4041 2
a4042 1
    #endif
d4998 2
a4999 2
  int       width_os    = 0; /* The image size as it will appear on the page, taking  */
  int       height_os   = 0; /* account of any WIDTH or HEIGHT attributes in the HTML */
d5148 2
a5149 2
  /* If width and height are both <= zero, try to find them out */
  /* from the image data itself                                 */
d5151 1
a5151 1
  if (width_os <= 0 && height_os <= 0)
d5160 2
a5161 2
  /* If width and height are still both <= zero, must go for a */
  /* default placeholder size instead.                         */
d5163 1
a5163 1
  if (width_os <= 0 && height_os <= 0) goto image_get_image_size_placeholder;
d5167 1
a5167 1
  if (width_os > 0 && height_os > 0)
d5187 1
a5187 1
  if (width_os <= 0)
d5203 1
a5203 1
  if (width_os > 0 && height_os > 0)
@


1.43
log
@Another intermediate check-in, resources may not be up to date; items
most likely to be buildable are PhoenixJ and BrowseD. Done because I'm
about to make some rather dodgy changes to code otherwise unchanged
since the Customer browser and I may well have to back them out...

In Handlers.c now set the HFlags_HasBeenVisited bit of a token at the point
it is first clicked on. Means the link returns to a "visited" colour after
the highlight flash immediately. This will persist for as long as the browser
window is kept open on that page, though if the URL doesn't end up making it
into the history for whatever reason it would "unhighlight" on reload; fair
enough, really. The highlight is window-local, so there are no redraw worries
for other open windows with links to the same URL (though other same-URL
links on the same page aren't updated either).

All forms submissions force a reload (principally for eudoramail.com, but
many other sites have similar requirements).

!MkClean and !MkClnAll didn't correctly call the utility to strip Makefile
dependencies. Fixed.

On fetch closedown, fetchpage_preprocess_token could be called on a token
which had already been run through the preprocessor. Now checks the flags
word before proceeding.

Image RAM cache and garbage collection system implemented - see new Choices
file entries CollectAfter, FreeRAMLimit and UnusedImageLimit to get an
overview. This contains groundwork for JavaScript image array support.

More JavaScript support improvements. Any one window object will know its
parent, top, this, etc.; frames array working except for a frameset created
via. multiple documents; opener for something created with window.open is
currently not set and don't know why (property is being created, pointer to
valid object is held, but JS engine returns 'null'. Ho hum) - JSChain won't
work yet, then.
@
text
@d87 3
a89 1
static void              image_delete_image_entry     (int image);
d91 2
d95 1
d103 1
a103 1
static int               image_data_offset            (int image);
a118 1
static char         * ddata       = NULL; /* Flex block for in-transit fetch data, URLs, etc.              */
a432 2
  int p, oldsize, remove;

d437 1
a437 12
  /* Get the current data size */

  oldsize = flex_size((flex_ptr) &ddata);

  /* The alloc field holds the total amount of data associated */
  /* with the image, and the ualloc field holds the amount     */
  /* that the URL uses. So subtract ualloc from alloc to get   */
  /* the amount that must be removed.                          */

  remove = idata[image].alloc - idata[image].ualloc;

  if (remove)
a438 10
    /* Need to shuffle the rest of the flex block */
    /* down and shrink the block, if this isn't   */
    /* the last image (i.e. p != oldsize).        */

    p = image_data_offset(image) + idata[image].alloc;

    if (p != oldsize) memmove(ddata + p - remove, ddata + p, oldsize - p);

    flex_extend((flex_ptr) &ddata, oldsize - remove);

d440 1
a440 1
      flexcount -= remove;
a442 1
  }
d444 1
a444 3
  /* Subtract the amount removed from the alloc field */
  /* and set isize to zero, i.e. we're not storing    */
  /* any image data anymore.                          */
d446 2
a447 2
  idata[image].alloc -= remove;
  idata[image].isize  = 0;
a465 2
  int p, oldsize, remove;

d470 1
a470 1
  /* Get the current data size */
d472 6
a477 1
  oldsize = flex_size((flex_ptr) &ddata);
d479 1
a479 2
  /* The alloc field holds the total amount of data associated */
  /* with the image.                                           */
d481 2
a482 1
  remove = idata[image].alloc;
d484 1
a484 1
  if (remove)
a485 10
    /* Need to shuffle the rest of the flex block */
    /* down and shrink the block, if this isn't   */
    /* the last image                             */

    p = image_data_offset(image);

    if (oldsize - p - remove) memmove(ddata + p, ddata + p + remove, oldsize - p - remove);

    flex_extend((flex_ptr) &ddata, oldsize - remove);

d487 1
a487 1
      flexcount -= remove;
d490 4
d496 2
a497 6
  /* Subtract the amount removed from the alloc field */
  /* and set isize to zero, i.e. we're not storing    */
  /* any image data anymore.                          */

  idata[image].alloc = 0;
  idata[image].isize = 0;
d838 1
a838 1
  int size, ok, ulen;
d905 4
a908 4
             idata[i].alloc                                            &&  /* The image has data allocated for it                 */
             idata[i].xref < 0                                         &&  /* The image doesn't cross reference things itself     */
             idata[i].background == !!background                       &&  /* We're not trying to make a b/g an f/g or vice versa */
             !strcmp(url, ddata + image_data_offset(i))                &&  /* This holds a URL which matches that passed in       */
d910 1
a910 1
               !background ||                                              /* This isn't a background image, or...                */
d912 2
a913 2
                 background &&                                             /* If this is a background image, the background       */
                 idata[i].owner->background_colour == b->background_colour /* colours match in the two owner browsers             */
d925 1
a925 6
  if (xref >= 0) ulen = 0; /* Don't need any extra data for a cross referenced image. */
  else
  {
    ulen = (strlen(url) + 1);
    ulen = (int) WordAlign(ulen);
  }
d927 2
a928 1
  size = ulen;
d991 33
a1023 1
  if (ok)
d1031 4
a1034 3
      if (ddata)
      {
        int oldsize;
d1036 1
a1036 4
        #ifdef TRACE
          flexcount += sizeof(image_info);
          if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
        #endif
d1038 1
a1038 4
        oldsize = flex_size  ((flex_ptr) &ddata);
        ok      = flex_extend((flex_ptr) &ddata, oldsize + size);
      }
      else ok   = flex_alloc ((flex_ptr) &ddata, size);
d1050 1
a1050 1
  /* Throw back an error if out of memory */
d1065 1
a1065 1
    flexcount += size;
a1068 20
  /* Increment the image counter, zero the contents of the image_info structure */
  /* and fill in some of the fields where contents are known now.               */

  memset(&idata[nimages], 0, sizeof(image_info)); /* Precautionary catch-all */

  idata[nimages].owner      = b;
  idata[nimages].x          = -1;
  idata[nimages].y          = -1;

  idata[nimages].alloc      = size;
  idata[nimages].ualloc     = ulen;
  idata[nimages].isize      = 0;

  idata[nimages].token      = token;
  idata[nimages].last_used  = time(NULL);
  idata[nimages].xref       = xref;

  idata[nimages].background = !!background;
  idata[nimages].hadfiller  = 0;

d1089 1
a1089 1
  /* and ImageLib about the new image.                                 */
d1093 1
a1093 1
    strcpy(ddata + image_data_offset(nimages), url);
d1193 2
a1194 1
        const char * referer = browser_current_url(b);
d1196 3
a1198 14
        e = html_get(ddata + image_data_offset(image),   /* Document to fetch                */
                     NULL,                               /* Pointer to any extra data        */
                     (int *) &idata[image].handle,       /* Place to return the fetch handle */
                     URL_Method_http_GET,                /* Fetch method                     */

                     #ifndef SINGLE_USER
                       user.name,                        /* User name for MailServ, if using */
                     #else                               /* a multiuser version              */
                       NULL,
                     #endif

                     0,                                  /* 0 = Don't parse fetched data     */
                     !b->reloading,                      /* 1 = Proxy can be used, 0 = can't */
                     referer);                           /* URL of referring page            */
d1200 19
a1218 1
        if (e)
d1222 2
a1223 2
          /* Particularly, 'file not found' for file fetches, can */
          /* be major pain.                                       */
d1226 1
d1228 2
d1332 1
a1332 1
          if (image == idata[image].owner->background_image)
d1375 1
d1378 3
d1393 1
a1393 1
        /* is demonstrated by the images at http://www.debenhams.co.uk/'. */
d1395 1
a1395 1
        if (idata[image].isize)
d1397 1
a1397 1
          int p = image_data_offset(image) + idata[image].ualloc;
d1401 1
a1401 1
          if (!flex_alloc(&store, idata[image].isize))
d1404 1
a1404 1

d1409 2
d1412 1
a1412 1
              flexcount += idata[image].isize;
d1416 3
a1418 1
            memcpy(store, ddata + p, idata[image].isize);
d1456 15
a1470 9
        e = html_get_next_token(b,
                                idata[image].handle,
                                &remn,
                                &sofar,
                                &tptr,
                                &waiting,
                                &store,
                                ddata + image_data_offset(image),
                                1);
d1472 1
a1472 1
        if (e)
d1492 8
a1499 1
          return e;
d1502 2
d1538 2
a1539 2
        if (store) realsize = flex_size(&store) - idata[image].isize; /* We already had 'isize' bytes before the fetcher was entered */
        else       realsize = 0;
d1543 1
a1543 1
        if (realsize >= 0)
d1545 3
a1547 3
          int p, oldsize;

          /* oldsize holds the whole image data block size (for all images) */
d1549 1
a1549 1
          oldsize = flex_size((flex_ptr) &ddata);
d1551 2
a1552 2
          /* Allocate 'size' extra bytes, doing the relevant error handling */
          /* code if the allocation fails                                   */
d1554 1
a1554 1
          if (!flex_extend((flex_ptr) &ddata, oldsize + realsize))
d1584 1
a1584 1
          /* p points to the first byte after the data used by this image */
d1586 1
a1586 1
          p = image_data_offset(image) + idata[image].alloc;
d1588 3
a1590 5
          /* Move all data from p up to the end of the block (as was, hence */
          /* oldsize) along the block by size bytes, effectively creating   */
          /* a gap of that many bytes just after this image's data. If p    */
          /* = oldsize, this was the last image in the block and there's    */
          /* no data above it to move (so don't do the memmove).            */
d1592 2
a1593 1
          if (p != oldsize) memmove(ddata + p + realsize, ddata + p, oldsize - p);
d1595 1
a1595 1
          /* Copy the new data into that gap */
d1597 6
a1602 1
          memcpy(ddata + p, ((char *) store) + idata[image].isize, realsize);
d1604 1
a1604 4
          /* Update the image's image data and total data pointers */

          idata[image].alloc += realsize;
          idata[image].isize += realsize;
d1613 3
a1615 2
          case 0: /* Not awaiting delivery (shouldn't happen in this context, but here 'just in case') */
          case 3: /* We have some data */
d1617 1
a1617 1
            int i, n, n1;
d1619 2
a1620 1
            /* Flag that a fetch has started to happen */
a1623 5
            /* Set 'n' to the size of data that was fetched */

            if (store) n = flex_size(&store);
            else       n = 0;

d1626 1
a1626 1
            idata[image].bytesgot += n;
d1630 3
d1634 2
a1635 1
            i = 0;
d1637 1
a1637 1
            while (n)
d1639 1
a1639 1
              n1 = n;
d1641 2
a1642 2
              if (n1 > sizeof(buffer)) n1 = sizeof(buffer);
              memcpy(buffer, (char *) store + i, n1);
d1644 2
a1645 2
              i += n1;
              n -= n1;
d1647 1
a1647 1
              e = image_load_chunk(b, image, buffer, n1);
d1651 1
a1651 11
                /* If there's an error, free the store and ditch the image */

                if (store)
                {
                  #ifdef TRACE
                    flexcount -= flex_size(&store);
                    if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
                  #endif

                  flex_free(&store);
                }
a1670 12
        /* Free the temporary store, if it was used */

        if (store)
        {
          #ifdef TRACE
            flexcount -= flex_size(&store);
            if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
          #endif

          flex_free(&store);
        }

d1695 1
a1695 1
/* image_delete_image_entry()                    */
d1697 48
a1744 4
/* Deletes an image_info structure from the      */
/* array of structures. The cross reference      */
/* image numbers of subsequent images are        */
/* adjusted appropriately.                       */
d1746 5
a1750 5
/* The idata flex block is not shrunk; this is   */
/* expected to be ,one externally, to avoid      */
/* possibly freeing many small blocks            */
/* consecutively (which can be slow with flex).  */
/* E.g. see image_post_deletion_clearup.         */
d1752 2
a1753 7
/* NOTE. Since this removes items from the idata */
/* array, if you're calling during a for() loop  */
/* scanning that array, count *backwards* from   */
/* nimages - 1 to 0. Otherwise, clearly, things  */
/* will go horribly wrong.                       */
/*                                               */
/* Parameters: Image number to remove.           */
d1756 1
a1756 1
static void image_delete_image_entry(int image)
d1758 1
a1758 2
  browser_data * b;
  int            i;
d1760 1
a1760 1
  nimages--;
d1762 1
a1762 62
  if (lastimage == image) lastimage--;
  if (lastimage >= nimages) lastimage = nimages - 1;

  /* Only need to alter xref numbers or move flex data */
  /* around if this wasn't the last image in the block */

  if (image < nimages) /* (Not 'nimages - 1' as nimages has been decremented by this point) */
  {
    memmove(&idata[image], &idata[image + 1], sizeof(image_info) * (nimages - image));

    for (i = image; i < nimages; i++)
    {
      #ifdef TRACE
        if (idata[i].xref == image) Printf("JUST DELETED IMAGE %d WHICH WAS XREF'D AND SHOULDN'T HAVE BEEN\n", i);
      #endif

      /* Did this cross reference an image which will have changed number? */

      if (idata[i].xref > image) idata[i].xref--;

      /* Update the associated token */

      #ifdef FAST_TOKEN_REFERENCE

        if (idata[i].token)
        {
          idata[i].token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
          idata[i].token->flags |= ((i + 1) << FAST_TOKEN_REFERENCE_SHIFT);
        }

      #endif

      /* Did this have a filler function registered for it? */

      if (idata[i].hadfiller)
      {
        /* If so, then provided the filler function is still available, */
        /* reregister with the new image number.                        */

        if (!idata[i].istore->RegisterFiller)
        {
          idata[i].hadfiller = 0;
        }
        else
        {
          show_error_ret(image_register_filler(i));
        }
      }
    }
  }

  /* Need to also alter browser_data structures' background image */
  /* number fields.                                               */

  b = last_browser;

  while (b)
  {
    if (b->background_image > image) b->background_image--;

    b = b->previous;
  }
d1768 19
a1786 3
/* Discards all images for a given browser       */
/* window, freeing the memory and shutting down  */
/* any active fetches.                           */
d1797 1
a1797 1
    if (tl & (1u<<15)) Printf("\nimage_discard: Called for %p\n\n", b);
d1809 1
a1809 9
  #ifdef TRACE
    if (tl & (1u<<15))
    {
      Printf("image_discard: First pass, checking for cross referencees owned by %p\n", b);
      Printf("               There are %d images before this pass.\n\n", nimages);
    }
  #endif

  /* Must go backwards because we can delete items from the array */
d1906 1
a1906 1
        if (tl & (1u<<15)) Printf("image_discard: Deleting entry owned by %p that cross references image %d\n", idata[i].owner, idata[i].xref);
d1909 1
a1909 5
      image_remove_all_data(i);

      /* Safe because we're counting through the array backwards */

      image_delete_image_entry(i);
a1910 1
  }
d1912 3
a1914 7
  #ifdef TRACE
    if (tl & (1u<<15))
    {
      Printf("\nimage_discard: First pass complete, there are now %d images\n", nimages);
      Printf("               Second pass, removing remaining images owned by %p\n\n", b);
    }
  #endif
d1916 1
a1916 7
  /* Now delete any remaining images owned by the given browser */
  /* - count backwards as we might remove items from the idata  */
  /* array during the loop.                                     */

  for (i = nimages - 1; i >= 0; i--)
  {
    if (idata[i].owner == b)
d1918 1
a1918 1
      if (idata[i].istore)
d1920 6
a1925 1
        /* Mark the image as suitable for garbage collection */
d1927 2
a1928 1
        idata[i].token = NULL;
d1930 2
d1933 1
a1933 1
          if (tl & (1u<<15)) Printf("\nimage_discard: Image %d marked for GC but not deleted\n", i);
d1935 2
d1938 3
a1942 3
        image_remove_all_data(i);
        image_delete_image_entry(i);

d1944 1
a1944 1
          if (tl & (1u<<15)) Printf("\nimage_discard: Image %d deleted\n", i);
d1946 2
d1955 1
a1955 1
    if (tl & (1u<<15)) Printf("\nimage_discard: Second pass complete, there are now %d images\n\n", nimages);
d1961 1
a1961 1
    if (tl & (1u<<15)) Printf("image_discard: Successful\n\n");
d1970 10
a1979 27
/* image_discard gets rid of cross referencing   */
/* images and transfers ownership of items that  */
/* are owned by the given browser but cross      */
/* referenced by another to that other. It does  */
/* not delete actual, non-cross-referencing      */
/* images owned by the given browser though, but */
/* instead marks them as suitable for later      */
/* garbage collection.                           */
/*                                               */
/* image_delete_image_entry is used to remove an */
/* item from the idata array but does not deal   */
/* with ImageLib data or ongoing fetches.        */
/*                                               */
/* To actually kill an image off completely, use */
/* this function. It's called by the garbage     */
/* collector image_gc and used to be part of     */
/* image_discard before the image garbage        */
/* collection system existed.                    */
/*                                               */
/* Be careful what you delete (!) and remember   */
/* to call image_post_deletion_clearup when all  */
/* the images you want to get rid of have been   */
/* removed by this function.                     */
/*                                               */
/* NB - this calls image_delete_image_entry, so  */
/* the same restrictions on scanning through     */
/* the idata array as for that function apply.   */
d1986 4
d2021 2
d2025 2
d2028 11
a2038 1
  image_delete_image_entry(image);
d2041 1
a2041 1
    if (tl & (1u<<15)) Printf("\nimage_destroy: Image %d deleted\n", image);
d2046 12
a2057 1
/* image_post_deletion_clearup()                 */
d2059 5
a2063 5
/* After deleting a set of images or image_info  */
/* structures which had no associated data in    */
/* ImageLib, call this to tidy up - deregister   */
/* the animation handler, resize the idata flex  */
/* block, etc.                                   */
d2066 1
a2066 1
static void image_post_deletion_clearup(void)
d2068 12
a2079 1
  int newsize, i;
d2081 1
a2081 1
  _swix(Hourglass_Start, _IN(0), 1);
d2083 4
a2086 2
  /* If there is an animation handler present, but no animated */
  /* images remain, remove that handler.                       */
d2088 1
a2088 3
  if (animhandler)
  {
    int found = 0;
a2089 2
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_post_deletion_clearup: There is an animation handler present; checking to see if it can be removed\n");
d2092 10
d2104 113
a2216 1
      if (idata[i].istore && idata[i].istore->animated)
d2218 1
a2218 1
        found = 1;
d2223 1
a2223 1
    if (!found)
d2226 1
a2226 1
        if (tl & (1u<<15)) Printf("image_post_deletion_clearup: Removing animation handler\n\n");
d2229 16
a2244 2
      deregister_null_claimant(Wimp_ENull, (WimpEventHandler *) image_animate_images, NULL);
      animhandler = 0;
d2247 24
a2270 1
    #ifdef TRACE
d2272 2
d2276 8
a2283 1
        if (tl & (1u<<15)) Printf("image_post_deletion_clearup: The handler is still required\n\n");
d2285 3
d2289 9
a2297 1
    #endif
d2299 5
d2322 2
a2323 2
    if (newsize) flex_extend((flex_ptr) &idata, newsize);
    else         flex_free((flex_ptr) &idata);
d2326 75
d2422 4
d2444 6
a2489 2

    if (clearup) image_post_deletion_clearup();
d2549 2
d3291 2
a3292 2
            imghistory_record((const char **) &ddata,
                              image_data_offset(i),
d3351 2
a3352 2
                imghistory_record((const char **) &ddata,
                                  image_data_offset(i),
d3670 1
a3670 1
  if (idata[image].token && idata[image].token->parent)
d3672 2
a3673 15
    table_headdata * head  = idata[image].token->parent;
    table_row      * row   = NULL;
    table_stream   * table = NULL;

    if (head) row   = head->parent;
    if (row)  table = row->parent;

    if (table)
    {
      if (TABLE_HAS_BGCOL(table)) bgcolour = TABLE_BGCOL(table), noplot = 1;

      /* Individual cells can override the table */

      if (TD_HAS_BGCOL(head))     bgcolour = TD_BGCOL(head),     noplot = 1;
    }
d3801 1
d3853 3
d3862 3
d3877 1
d3912 3
d3921 2
d3979 1
a3979 1
  image = image_get_token_image_actual(b, token);
a3982 1
  actual = image;
d4152 1
a4152 1
      image_redrawing   = image;
a4317 32
/* image_data_offset()                           */
/*                                               */
/* Returns the offset into the ddata block of    */
/* the data associated with a given image.       */
/*                                               */
/* Parameters: An image number, from 0 to        */
/*             nimages - 1.                      */
/*                                               */
/* Returns:    Pointer to the data associated    */
/*             with that image (as a char *).    */
/*************************************************/

static int image_data_offset(int image)
{
  int i, count = 0;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_data_offset: Called for image %d\n",image);
  #endif

  if (image <= 0) return 0; /* Image 0's data offset will be zero... */

  for (i = 0; i < image; count += idata[i].alloc, i++);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_data_offset: Successful\n");
  #endif

  return count;
}

/*************************************************/
d4493 1
a4493 1
      if (idata[image].owner == b) count += idata[image].bytesgot;
d4731 1
a4731 1
    if (found >= 0)
d5100 2
a5101 2
    imghistory_return_size((const char **) &ddata,
                           image_data_offset(actual),
a5529 1
  int offset;
a5538 4
  /* Find the offset of the URL in the 'ddata' block */

  offset = image_data_offset(image);

d5545 1
a5545 1
  strncpy(buffer, ddata + offset, size);
d5592 1
a5592 1
  if (image >= 0 && idata[image].istore->width > 0)
d5782 2
a5783 1
  int i;
d5791 5
a5795 2
  if (!image) i = b->background_image;
  else        i = image_get_token_image_xref(b, image);
d5817 11
a5827 3
  return idata[i].istore -> DumpSprite(idata[i].istore,
                                       path,
                                       -1);
d5874 1
a5874 1
  int  i, offset;
d5887 1
a5887 3
  offset = image_data_offset(i);

  if (!ddata[offset])
d5905 1
a5905 1
  strncpy(url, ddata + offset, sizeof(url));
a6120 3
    browser_redrawing = b;
    image_redrawing   = actual;

d6131 3
d6137 3
d6195 3
d6215 3
a6220 3
    browser_redrawing = NULL;
    image_redrawing   = -1;

d6311 3
d6317 3
d6411 2
a6412 2
  xmin = coords_x_toworkarea(r->redraw_area.xmin,r);
  ymax = coords_y_toworkarea(r->redraw_area.ymax,r);
d6442 3
d6449 3
a6522 3
          browser_redrawing = b;
          image_redrawing   = image;

a6523 4

          browser_redrawing = NULL;
          image_redrawing   = -1;

@


1.42
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d83 1
a83 1
static void              image_remove_all_data        (browser_data * b, int image);
d86 1
d88 3
d98 1
a98 1
static int               image_data_offset            (browser_data * b, int image);
d113 7
a119 7
static image_info * idata       = NULL;
static char       * ddata       = NULL;
static int          nimages     = 0;
static int          lastimage   = 0;
static int          animhandler = 0;

static char       * unique_name = NULL;
d136 1
d452 1
a452 1
    p = image_data_offset(b,image) + idata[image].alloc;
d482 1
a482 4
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
d486 1
a486 1
static void image_remove_all_data(browser_data * b, int image)
d509 1
a509 1
    p = image_data_offset(b, image);
d741 1
a741 1
          browser_update_token(b, idata[i].token, 0, 0);
d754 73
d854 17
a870 7
/*             plotting.                         */
/*************************************************/

_kernel_oserror * image_new_image(browser_data * b, const char * url, HStream * token, int background)
{
  int       size, ok, ulen, xref;
  HStream * tp;
a880 1
  tp   = token;
d937 1
a937 1
             !strcmp(url, ddata + image_data_offset(b,i))              &&  /* This holds a URL which matches that passed in       */
d963 2
a964 1
  /* Allocate space for the image_info structure */
d966 1
a966 1
  if (idata)
d968 9
a976 1
    int oldsize;
d978 17
a994 2
    oldsize = flex_size  ((flex_ptr) &idata);
    ok      = flex_extend((flex_ptr) &idata, oldsize + sizeof(image_info));
a995 1
  else ok   = flex_alloc ((flex_ptr) &idata, sizeof(image_info));
d997 26
a1022 1
  /* Allocate space for the image data */
d1026 3
a1028 1
    if (ddata)
d1030 10
a1039 1
      int oldsize;
d1041 4
a1044 4
      #ifdef TRACE
        flexcount += sizeof(image_info);
        if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
      #endif
d1046 6
a1051 2
      oldsize = flex_size  ((flex_ptr) &ddata);
      ok      = flex_extend((flex_ptr) &ddata, oldsize + size);
d1053 1
a1053 1
    else ok   = flex_alloc ((flex_ptr) &ddata, size);
d1088 2
a1089 1
  idata[nimages].token      = tp;
d1119 1
a1119 1
    strcpy(ddata + image_data_offset(b, nimages), url);
d1121 5
a1125 1
    idata[nimages].istore = NewImage(NULL, background ? IMAGE_FAST : 0);
d1128 2
a1129 15
  // This works, but you've then got to alter the dataoffset fields
  // of higher images whenever you remove any data from one lower in
  // the flex block. That's not implemented yet, and the speed penalty
  // of this may offset the gains in image_data_offset.
  //
  // if (!nimages) idata[nimages].dataoffset = 0;
  // else idata[nimages].dataoffset = idata[nimages - 1].dataoffset + idata[nimages - 1].alloc;

  /* If the image is not a background one, need to update the */
  /* width and height fields according to any details in the  */
  /* HTML source.                                             */

  if (!background)
  {
    /* Need to flag if the HTML gives us an absolute size */
d1131 1
a1131 7
    if (
         OBJECT_HAS_WIDTH   (token)                 &&
         OBJECT_HAS_HEIGHT  (token)                 &&
         OBJECT_WIDTH_UNITS (token) == UNITS_PIXELS &&
         OBJECT_HEIGHT_UNITS(token) == UNITS_PIXELS
       )
       idata[nimages].fixedsize = 1, idata[nimages].canredraw = 1;
d1133 1
a1133 8
    else
    {
      /* If reformats aren't immediate, image_update_image may ask for */
      /* one and then if canredraw is set, will start updating the     */
      /* image. This is invalid unless the reformat has definitely     */
      /* occurred (a full size image plots inside a default size       */
      /* placeholder...). However, if reformats happen straight away,  */
      /* we'll always be able to redraw.                               */
d1135 2
a1136 3
      if (!choices.refo_wait) idata[nimages].canredraw = 1;
      else                    idata[nimages].canredraw = 0;
    }
d1138 1
a1138 2
    idata[nimages].currw = idata[nimages].currh = -1;
  }
d1142 1
a1142 8
  /* Store the image number */

  #ifdef FAST_TOKEN_REFERENCE

    token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
    token->flags |= (nimages << FAST_TOKEN_REFERENCE_SHIFT);

  #endif
d1150 1
a1150 1
    image_update_image(b, nimages - 1, NULL);
d1221 1
a1221 1
        e = html_get(ddata + image_data_offset(b,image), /* Document to fetch                */
d1408 1
a1408 1
          int p = image_data_offset(b, image) + idata[image].ualloc;
d1470 1
a1470 1
                                ddata + image_data_offset(b, image),
d1578 1
a1578 1
          p = image_data_offset(b, image) + idata[image].alloc;
d1715 1
a1715 1
/* expected to be done externally, to avoid      */
d1718 7
d1749 1
a1749 1
        if (idata[i].xref == image) Printf("JUST DELETED IMAGE %d WHICH WAS XREF'D AND SHOULDN'T HAVE BEEN\n");
d1760 5
a1764 2
        idata[i].token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
        idata[i].token->flags |= ((i + 1) << FAST_TOKEN_REFERENCE_SHIFT);
d1813 1
a1813 1
  int newsize, i, xref;
d1836 4
a1839 1
  for (i = nimages - 1; i >= 0; i--) /* Going backwards helps out flex */
d1863 1
d1882 5
a1886 2
        idata[xref].token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
        idata[xref].token->flags |= ((xref + 1) << FAST_TOKEN_REFERENCE_SHIFT);
d1936 4
a1939 1
      image_remove_all_data(idata[i].owner, i);
d1953 2
d1956 1
a1956 1
  for (i = nimages - 1; i >= 0; i--) /* Going backwards helps out flex */
d1960 5
a1964 1
      /* If the image was being fetched, close that session */
d1966 5
a1970 1
      if (idata[i].handle)
d1972 6
a1977 2
        html_close(idata[i].handle);
        idata[i].handle = 0;
d1979 14
d1994 2
a1995 3
      if (idata[i].istore)
      {
        #ifdef STRICT_PARSER
d1997 33
a2029 1
          /* Report any errors as Continue-only in strict parser mode */
d2031 3
a2033 1
          _kernel_oserror * e;
d2035 5
a2039 1
          e = idata[i].istore -> Delete(idata[i].istore);
d2041 3
a2043 5
          if (e)
          {
            e->errnum = Utils_Error_Custom_Message;
            show_error_ret(e);
          }
d2045 1
a2045 1
        #else
d2047 1
a2047 1
          /* If not in Strict mode, ignore any errors */
d2049 1
a2049 1
          idata[i].istore -> Delete(idata[i].istore);
d2051 4
a2054 1
        #endif
d2057 7
a2063 3
      image_remove_all_data(b, i);
      image_delete_image_entry(i);
    }
d2066 3
d2070 1
a2070 1
    if (tl & (1u<<15)) Printf("\nimage_discard: Second pass complete, there are now %d images\n\n", nimages);
d2072 17
d2098 1
a2098 1
      if (tl & (1u<<15)) Printf("image_discard: There is an animation handler present; checking to see if it can be removed\n");
d2113 1
a2113 1
        if (tl & (1u<<15)) Printf("image_discard: Removing animation handler\n\n");
d2124 1
a2124 1
        if (tl & (1u<<15)) Printf("image_discard: The handler is still required\n\n");
a2150 2
  _swix(Hourglass_Off, 0);

d2157 1
a2157 1
          if ((idata[i].token->flags >> FAST_TOKEN_REFERENCE_SHIFT) - 1 != i)
d2159 1
a2159 1
            Printf("image_discard: \0211Image %d is referenced incorrectly by its token\0217 - correcting...\n", i);
d2170 166
d2337 37
a2373 1
    if (tl & (1u<<15)) Printf("image_discard: Successful\n\n");
d2376 80
d2521 5
a2525 1
      idata[image].istore = NewImage(NULL, image == b->background_image ? IMAGE_FAST : 0);
d3012 3
a3014 1
      l = tokenutils_find_ancestor_line(idata[i].owner, idata[i].token);
d3032 1
a3032 1
                              image_data_offset(idata[i].owner, i),
d3063 1
d3092 1
a3092 1
                                  image_data_offset(idata[i].owner, i),
d3209 1
a3209 1
        /* Closure of 'if (!reformat_get_image_size(...))' */
d3410 1
a3410 1
  if (idata[image].token->parent)
d3796 1
a3796 2
    tp   = (ISOBJECT(tp)) ? token                 : idata[actual].token;
    text = (ISOBJECT(tp)) ? HtmlOBJECTstandby(tp) : tp->text;
d3798 10
a3807 5
    redraw_draw_placeholder(b,
                            r,
                            &box,
                            tp,
                            text);
d4064 1
a4064 5
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image in          */
/*             question;                         */
/*                                               */
/*             An image number, from 0 to        */
d4071 1
a4071 1
static int image_data_offset(browser_data * b, int image)
d4076 1
a4076 1
    if (tl & (1u<<15)) Printf("image_data_offset: Called for image %d, and exitting\n",image);
d4083 4
d4819 1
a4819 1
  if (!tp->parent)
d4824 10
a4833 2
    subtract = redraw_left_gap (b, b->cell, tp) +
               redraw_right_gap(b, b->cell, tp);
d4874 1
a4874 1
                           image_data_offset(idata[actual].owner, actual),
d4882 1
a4882 1
  if (tp->tagno != TAG_INPUT)
d4985 8
a4992 1
    text = (ISOBJECT(tp)) ? HtmlOBJECTstandby(tp) : tp->text;
d5315 1
a5315 1
  offset = image_data_offset(b, image);
d5653 1
a5653 1
  offset = image_data_offset(b, i);
@


1.41
log
@Added capability to send Referer headers, together with new options to
allow this to be sent: a) Always, b) Never, c) when the URL referred to
is an http URL.  Default is c.  There is no frontend editing capability
for this option.  This addition means that various counters and sites
that rely on referer to indicate a resource upon which an operation is
to be carried out will now work (eg. rating a web site on Geocities).
@
text
@d1102 1
a1102 1
        const char *referer = browser_current_url(b);
d1117 1
a1117 1
                     referer);                           /* Referring page                   */
d5197 1
a5197 11
        /* Any data in the source store represents already */
        /* fetched bits of the file. Must lock flex down   */
        /* over the save to make sure the heap doesn't     */
        /* shift over the call to fwrite.                  */

        flex_set_budge(0);

        bytes = fwrite(last_browser->source,
                       1,
                       flex_size((flex_ptr) &last_browser->source),
                       last_browser->save_file);
d5199 13
a5211 1
        flex_set_budge(1);
@


1.40
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d1102 2
d1116 2
a1117 1
                     !b->reloading);                     /* 1 = Proxy can be used, 0 = can't */
@


1.39
log
@All !Run[D], Choices, Messages, Controls and Res files are up to date.

RefoKeep and RefoHold options added to, respectively, try and maintain
the line at the top of the visible area when reformatting, and not shrink
the vertical extent at the start of a reformat to try and avoid flicker
to the top of the page and back down again when RefoKeep is on. Choices
front-end implemented, which also allows RefoWait and RefoTime to be set.
Unfortunately for various reasons this doesn't help the page jumping when
unsized images come in (but RefoHold can improve matters...) - roll on
the image history.

DragToScroll and NoScrollBars options added for frames; included new
pointer type, Mouse_Shape_DTS, so relevant Controls file entries done
and Sprites[22] files updated as required. Noticed some builds have
a low-res ptr_link with a mask - mask removed.

Named anchor following fixed up somewhat - anchors near the bottom of
the page shouldn't be displayed, and then pulled down when the fetcher
releases null polls and ensures the y extent is correct (this through
implementing the min_height field in the browser_data structure).

RefoHang was never implemented and there seems little point to it now,
so the entry for it has been removed from the global choices structure
and all Choices files.

Markers menus should work properly now (in last check-in they would not
update correctly if Adjust was used on the entries).

URI handler usage now a lot more sensible, with configuration of how the
browser uses the module from both a Utils menu submenu (sic) and the
Choices dialogue.

Slightly dodgy 'hang around waiting for user input' stuff for the Cookies
dialogue box: All fetches are suspended; the fetcher remembers some info
about its state at the time the cookie came in, and restores it later; it
will only do this for one fetch at a time. It's necessary to single-thread
the fetcher at this point anyway, since other fetches may have a
dependency on the cookie that is hanging in mid-air at that point. As part
of this, some of the fetcher code has been split out into separate
functions (to try and 'black box' the code a bit). Anyway, Cookie Query
dialogue box now implemented with appropriate Choices file entry and
UI work in the Choices dialogue box.

Phoenix build Choices rearranged. Can now choose when the image history
is saved from the front end. Added also MSIE 4-style table option menu
for JPEG support (OS only, OS if it can handle it, internal only).

Should be a bit faster at loading the history - though 95% of the time
is spent in SWI URL_ParseURL. URL descriptions are stored more
efficiently as part of this - one malloc block instead of several
small blocks. The minimum block size for malloc blocks typically leads
to a significantly smaller startup wimpslot depending on the visit
history size.

Nasty bug in image system fixed. If an image size came in and a reformat
was to take place, the line the image lies in is found and the reformat
progresses from there. Unforunately, this didn't check to see if the
token can't be found in the line list, so it'd reformat from the top
of the page...! This would happen if, for example, an image halfway down
the page came in whilst a reformat for an image higher up had just begun.

In Choices.c, made choices_set_timetype_field, choices_set_uri_field,
choices_set_plugin_field, choices_set_cookie_field, and
choices_set_jpeg_field static (so they're not declared in Choices.h now).

Two memory leaks plugged in URL comparison routines in URLutils.c
(calling free() url_description instead of urlutils_free_descripton()).

Client pull reload handler was setting the reload flag if reloading
the same page, but forgetting to turn on reload_lock so
fetchpage_postprocessed was clearing the reload state... Similarly,
Ctrl+Shift+SELECT-Click on a link when the Controls file 'UseSmall'
entry is 'no' would not have reloaded as it should. Both fixed.

Frames shouldn't be so keen on acquiring horizontal scroll bars and never
letting them go when their width is decreased now. Frames set up for
'scrolling="yes"' will not start with no scroll bars and then gain them
shortly afterwards, causing flicker and two reformats - they'll start
with, and continue to hold, both scroll bars.

Pointer shouldn't flicker when over a frame border whilst other fetches
are progressing now.
@
text
@d129 3
a131 1
#undef TRACE_FETCH_STORE
d345 1
a345 1
// **** 
d441 5
a445 3
  /* Need to shuffle the rest of the flex block */
  /* down and shrink the block, if this isn't   */
  /* the last image (i.e. p != oldsize).        */
d447 1
a447 1
  p = image_data_offset(b,image) + idata[image].alloc;
d449 1
a449 1
  if (p != oldsize) memmove(ddata + p - remove, ddata + p, oldsize - p);
d451 1
a451 1
  flex_extend((flex_ptr) &ddata, oldsize - remove);
d453 5
a457 4
  #ifdef TRACE
    flexcount -= remove;
    if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
  #endif
d505 1
a505 1
    /* the last image (i.e. p != oldsize).        */
d509 1
a509 1
    if (p != oldsize) memmove(ddata + p, ddata + p + remove, oldsize - p - remove);
d805 17
a850 1
             !strcmp(url, ddata + image_data_offset(b,i))              &&  /* This holds a URL which matches that passed in       */
d853 1
d892 1
a892 1
  if (ok && ddata)
d894 3
a896 1
    int oldsize;
d898 4
a901 4
    #ifdef TRACE
      flexcount += sizeof(image_info);
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
    #endif
d903 4
a906 2
    oldsize = flex_size  ((flex_ptr) &ddata);
    ok      = flex_extend((flex_ptr) &ddata, oldsize + size);
a907 1
  else ok   = flex_alloc ((flex_ptr) &ddata, size);
d982 1
a982 1
  // else idata[nimages].dataoffset = idata[nimages - 1].dataoffset + alloc;
d1018 9
d1629 9
d1744 9
d1923 19
d2289 1
d2321 1
a2321 1
  if (idata[image].xref >= 0) image = idata[image].xref;
d2353 3
d2358 2
d2427 4
a2430 1
      for (i = 0; i < nimages; i++)
d2432 1
a2432 1
        if ((i == image || idata[i].xref == image) && idata[image].fetched)
d2434 4
a2437 1
          browser_update_bottom(idata[i].owner, NULL);
d2445 1
a2445 1
  /* Look through all images for cross references */
d2449 4
a2452 1
  for (i = 0; i < nimages; i++)
d2595 6
a2600 2
            /* If no reformat was needed, just do a redraw (which clears the  */
            /* background first; see the very large comment earlier on).      */
d2604 8
d2617 1
a2617 1
                                1);
d3084 1
a3084 1
    for (y = redraw.ymax - h + 4; y >= redraw.ymin; y -= h)
d3136 1
a3136 1
    for (y = redraw.ymax - h + 4; y >= redraw.ymin; y -= h)
d3367 1
a3367 1
  for (y = ymax - h + 4; y >= r->redraw_area.ymin - h; y -= h)
d3793 2
d3796 1
a3796 3
           !idata[i].delayed   &&
           idata[i].xref < 0   &&
           idata[i].owner == b
d3835 2
d3838 1
a3838 3
         !idata[i].delayed   &&
         idata[i].xref < 0   &&
         idata[i].owner == b
d3869 1
a3869 1
    for(i = 0; i < nimages; i++)
d3965 5
a3969 1
  int i, found = -1;
d3975 1
a3975 1
  /* If there are any images to deal with... */
d3977 1
a3977 14
  if (nimages)
  {
    /* ...then look through them all, seeing if the */
    /* image is referred to by the given token.     */

    for (i = 0; i < nimages; i++)
    {

      if (idata[i].token == token && idata[i].owner == b)
      {
        found = i;
        break;
      }
    }
d3987 31
a4017 1
  }
d4047 5
a4051 1
  int i, found = -1;
d4057 3
a4059 1
  /* If there are any images to deal with... */
d4061 3
a4063 4
  if (nimages)
  {
    /* ...then look through them all, seeing if the */
    /* image is referred to by the given token.     */
d4065 1
a4065 1
    for (i = 0; i < nimages; i++)
d4067 2
d4070 1
a4070 1
      if (idata[i].token == token && idata[i].owner == b)
d4072 6
a4077 2
        found = i;
        break;
d4080 2
a4081 1
  }
d4909 5
d5164 2
d5167 2
a5168 1
    RetLastE;
d5214 2
d5217 2
a5218 1
        RetLastE;
@


1.38
log
@Programming warehouse link removed from all hotlists - the page has gone.

Some compile-time hacks in place to use MemLib, a dynamic area based
malloc replacement which shrinks its heap when possible. All builds
have these switched off at the moment. Seemed to work with just Browse,
though there would be problems with message blocks stored in dynamic
areas because of the Wimp's '&3800000' check - however, it failed when
HTMLLib was made to use it, too. Don't know why yet.

ItemInfo.[c/h] source added, with Res file additions for testbed Browse
and Phoenix.

Small fetch windows now work properly regardless of toolbar settings
in the Choices.

Reload now reloads all images too, rather than only reloading them for
as long as the main page was being fetched.

Added a simple 'Find' facility.

Realised that event handlers in eventlib are called in reverse order
of registration, so the miscellaneous event handler is now registered
first rather than last.

Multiuser code added (most only active if SINGLE_USER is undefined). As
part of this, hotlist code now knows about read-only items (done for the
Customer-style 'Resources' file, but works generally anyway).
handle_add_hotlist doesn't try to save the hotlist itself anymore (the
hotlist_add function does all that through hotlist_modified anyway).

Customer build Choices and Controls updated slightly (e.g. ClaimHelp
off, hotlist to save on quit only).

Customer build now uses Phoenix-style buttons. Sprites files which
worked at the time (but will probably be out of date now) and included
most of the original Customer-style sprites are in
'Utils.Icons.Customer'.

Choices, Messages and Res files for all builds now stripped down to only
single user items or single plus multiuser for Customer build and testbed
build. Before, all contained a few multiuser bits in at least the Choices
file if not more.

Grammatical error ("Fetching frames contents" (sic.)) corrected in
default message, Toolbars.c, and all of the Messages files.

Customer build brought back to a servicable level (including
implementation of the Find dialogue box with animation and fixing
up authorisation and 'Stop' state in the tristate). Quite a few
missing #ifndef REMOTE_HOTLIST bits from hotlist code added...

Customer build will not use <Choices$Write> or Boot:Choices for any
file finding now. UseProxy defaults to 'yes', MaxImages to 2. Res
file includes Proxy Address setting (save_save_choices() now writes
the ProxyAddress line).
@
text
@d1020 1
a1020 1
/* Allows up to choices.maximages images to be   */
d1037 1
a1037 1
  /* If there are not maximages images being fetched and there are still  */
d1061 5
a1065 5
           !idata[image].handle        &&
           !idata[image].fetched       &&
           !idata[image].delayed       &&
           idata[image].xref < 0       &&
           fetches < choices.maximages
d2443 4
a2446 1
            reformat_format_from(idata[i].owner, l - 1, 0, i);
@


1.37
log
@The '3F6C0' abort fixed; reformat_left_margin didn't cope with a NULL
cell pointer. This only happened if the image library tried to deal with
an image in a table cell which wasn't properly dealt with by the table
systems yet, for whatever reason. Rare, but persistent once it started
happening because it depended on the value of the FIQ vector!

Put function header comments in SaveFile.c, at last.

Messages files now read version 2.01, 23 Feb 1998.
@
text
@d318 29
d4467 50
@


1.36
log
@*Don't* try to load FilterManager 0.18 in !Run[D] files. Requires
WindowManager 3.98. Sets URI handler environment variables for
http, ftp and gopher.

Fixed 'doesn't reformat for unsized images' bug - only happens when the
deferred reformatter is enabled, hadn't remembered to check this in my
debug build where this is turned off. Oops.

Caret position in forms could get left behind despite attempts to rectify
this in v1.31 - now fixed (and faster, fortunately).

Hourglass + percentage displayed for History and Image History when
loading - it can take a while for very big histories, though in
practice you only see the visit history loading (has to do a lot
more work, and is thus quite a bit slower than the image history).

POST forms worked when targetted to frames, but were broken when
not targetted! (Forms data inherited from one browser to the same
browser; ended up freeing the flex block...). Fixed.

Now support 303 response code (redirect to GET). Treated as 301, i.e.
not support if STRICT_PARSER is defined, otherwise drops through to
the 302 handling code.

Pointer shouldn't get stuck in odd shapes when going to a new page now;
it gets reset to a standard shape every time the null handler that
checks the position is called, though (whether or not the handler thinks
the pointer is over a different token, if that token is NULL, it sets
the standard shape). A possible work around would be for a browser to
remember the pointer shape too; that's for the future, though.

Early stage table formatting functions could blow themselves apart if
tables_count_table decided there were no rows, columns or both. A
net table size of zero cells is now dealt with; slow, partial table
fetches in multiple windows with image loading turned on will now
*hopefully* be stable, where v1.31 would have bombed out repeatedly.

A nested frameset within one document will now inherit the border
width (frame spacing) and border colour of its parent. This is done
by copying the maxlen and indent fields of the parent token over
the child, and note it's done in the browser (fetch_preprocess_token),
not HTMLLib.

Border colour on a FRAMESET now used, with the first colour on any
FRAME within it overriding, as in NN 4 and MSIE 4.

<LI> bullets really do stick to the text next to them now (I'd done
that in an experimental piece of code and forgotten to merge it back
before the last check-in).

Browse$HotlistURL/URIFile and Browse$HomeURL/URIFile now work from
_TaskName in the Messages file, and are thus of the generic form
<App>$HotlistURL etc. - Docs.Notes and Docs.User updated appropriately.

Event 0x11d00 through to 0x11d7f will make the browser look up Controls
file entries 'JumpTo00' through to 'JumpTo7f' and read a URL from them.
This will be fetched in the ancestor window of the source of the event,
or a new window if such an ancestor can't be found [for Daytona demo].

NB: Nasty frames-related crash at http://www.teledanmark.dk/menu/start.htm
is *not* fixed in this source. NOBR is not supported.
@
text
@d4147 2
@


1.35
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d100 3
a102 1
static _kernel_oserror * image_get_image_size         (browser_data * b, int image, BBox * box);
a935 9
    BBox size;

    /* Have a guess at the image size to start with */

    image_get_image_size(b, nimages, &size);

    idata[nimages].currw = size.xmax;
    idata[nimages].currh = size.ymax;

d944 16
a959 1
       idata[nimages].fixedsize = 1;
a961 2
//  if (!choices.refo_wait) idata[nimages].canredraw = 1; /* If not waiting, reformats are immediate so canredraw is always true */

a972 23
// This cross referencing trick to help unknown image sizes
// looks to be deprecated in the face of the image history,
// and may cause problems when one and only one dimension for
// a particular image is specified in the HTML source.
//
//  else
//  {
//    /* If this is a cross-referencing image, and it hasn't got  */
//    /* its fixedsize flag set, then it has no size info yet.    */
//    /* In that case, get it from the image it cross references. */
//
//    if (!idata[nimages - 1].fixedsize && !idata[nimages - 1].currw && !idata[nimages - 1].currh)
//    {
//      int xref = idata[nimages - 1].xref;
//
//      if (xref >= 0 && idata[xref].istore)
//      {
//        idata[nimages - 1].currw = idata[xref].istore->width_os;
//        idata[nimages - 1].currh = idata[xref].istore->height_os;
//      }
//    }
//  }

d2249 3
a2251 2
  /* size for this or cross referencing images, fill in currw /      */
  /* currh with the new values.                                      */
d2271 3
d2276 2
a2277 1
                             &size);
d2279 11
a2289 6
        if (size.xmax != idata[i].currw || size.ymax != idata[i].currh)
        {
          idata[i].reformat = 1;
          idata[i].currw    = size.xmax;
          idata[i].currh    = size.ymax;
        }
d2351 1
a2351 2
      whole.xmax = idata[i].currw;
      whole.ymax = idata[i].currh;
d2368 4
a2371 4
        partial.xmin = (box->xmin * idata[i].currw) / idata[image].istore->width_os;
        partial.ymin = (box->ymin * idata[i].currh) / idata[image].istore->height_os;
        partial.xmax = (box->xmax * idata[i].currw) / idata[image].istore->width_os;
        partial.ymax = (box->ymax * idata[i].currh) / idata[image].istore->height_os;
d2416 4
d2471 4
d2503 1
a2503 1
            ubox.ymax = idata[i].currh;
d2531 1
a2531 1
            ubox.xmax = idata[i].currw;
d3136 1
a3136 1
    image_get_image_size(b, actual, &box);
d3303 1
a3303 1
/* image_token_check_redrawable()                */
d3305 3
a3307 3
/* Checks to see if an image has a known width   */
/* and height, and if so, marks it as            */
/* redrawable. Used for delayed reformatting.    */
d3316 1
a3316 1
void image_token_check_redrawable(browser_data * b, HStream * token)
d3319 1
a3319 1
  BBox size;
d3324 4
d3329 3
a3331 1
  if (image < 0 || image > nimages) return;
d3333 3
a3335 1
  image_get_image_size(b, image, &size);
d3337 6
a3342 2
  idata[image].currw = size.xmax;
  idata[image].currh = size.ymax;
d3344 2
a3345 5
//  /* Exit if the image has no known size yet */
//
//  if (idata[image].currw <= 0 || idata[image].currh <= 0) return;
//
  /* Mark it as redrawable */
d3930 110
d4053 8
a4060 1
/*             size information is placed.       */
d4065 1
a4065 1
static _kernel_oserror * image_get_image_size(browser_data * b, int image, BBox * box)
d4106 1
a4106 1
    if (image < 0 || image >= nimages) return NULL;
d4110 18
d4167 1
a4167 5
  /* Zero contents of the BBox */

  memset(box, 0, sizeof(BBox));

  /* Get the real image dimensions if possible */
d4337 1
a4337 1
  return image_get_image_size(b, image, box);
d4458 1
a4458 1
  return (image_get_image_size(b, b->background_image, box));
@


1.34
log
@Not all resources are up to date in this check-in, and documentation
both within source and stuff in 'Docs' is out of date or missing - I
was very pushed for time on this one... Hopefully will do another
'tidy up' check-in before close on Friday; until then, beware of
anything other than the Ursula (Desktop browser) build. Anyway...

Export As Draw done. As part of this, FONT SIZE and SUP / SUB adjustment
of font size is done in fm_token_font_info rather than fm_find_token_font.

Bullets and switches are plotted as indirected sprite items, rather than
indirected text + sprite items - this relied on being in a redraw loop to
pick the sprites up from the local pool (failed during printing).

URI files now have a LF line ending rather than CR... '*' recognised
as an empty field when loading via. RAM transfer now (only worked for
loading from disc before).

Gave placeholder bounding boxes 4 OS units more minimum extra gap
vertically and reduced horizontal addition to this value * 1.5, rather
than * 2 (see reformat_get_placeholder_size).

Background image tiling starts at ymax - h + 4, rather than ymax, so
there isn't the bottom line of pixels from the top tile always present
at the top of the window. The '+4' is for caution's sake.

Can now save a frame's HTML source, that of its parent or its ancestor,
and the same for the URI pointing to those documents - see Menus.h for
the relevant component IDs that should lead to the SaveFile dialogue.

Have hopefully fixed timeout = 0 values (i.e. 'forever') on things
like LinkTo; before, image fetches could override the state (so you'd
only ever see brief flickers of a given URL as the pointer went over
a link).

Save File dialogue will remember the state of option or radio buttons
for a given parent component origin and restore that state when the
dialogue is next opened from the same place (stops turning on saving
as a URL file also turning on 'save background images' for Draw file
export, etc.).

Use of a META tag to reload the *same* page now sets the 'reloading'
flag in the browser so that it doesn't go through a proxy - otherwise
pages which are meant to update periodically through client pull
don't work, as they keep coming out of the cache.

Can now handle images specifying just a width or height in the HTML
(other dimension is scaled accordingly, but note that the placeholder
size must still be 'dumb' until the image data comes in). An image
will now override an image history size entry for the same entry
with a different size.
@
text
@d910 10
d934 1
a934 21
    int w           = 0;
    int h           = 0;
    int available_w = redraw_display_width (b, b->cell);
    int available_h = redraw_display_height(b, b->cell);

    /* Form INPUT type buttons can't have sizes specified, so we have to */
    /* rely on the image history for them.                               */

    if (tp->tagno != TAG_INPUT)
    {
      /* The OBJECT macros work for IMGs as well as OBJECTs */

      if (OBJECT_HAS_WIDTH(tp))
      {
        switch (OBJECT_WIDTH_UNITS(tp))
        {
          default:
          case UNITS_PIXELS:  w = OBJECT_WIDTH(tp) * 2; break;
          case UNITS_PERCENT: w = available_w * OBJECT_WIDTH(tp) / 100; break;
        }
      }
d936 1
a936 10
      if (OBJECT_HAS_HEIGHT(tp))
      {
        switch (OBJECT_HEIGHT_UNITS(tp))
        {
          default:
          case UNITS_PIXELS:  h = OBJECT_HEIGHT(tp) * 2; break;
          case UNITS_PERCENT: h = available_h * OBJECT_HEIGHT(tp) / 100; break;
        }
      }
    }
d938 1
a938 1
    /* If we haven't got anything, try the image history */
d940 2
a941 3
    if (!w && !h)
    {
      int ih_w, ih_h;
d943 1
a943 1
      imghistory_return_size(&url, 0, &ih_w, &ih_h);
d945 7
a951 12
      if (ih_w > 0 && ih_h > 0) w = ih_w, h = ih_h, idata[nimages].fromhistory = 1;
    }

    /* Record the image's size, if we have it */

    if (w) idata[nimages].currw = w;
    if (h) idata[nimages].currh = h;

    /* If we knew the sizes, flag that the image size should not alter */
    /* from here on and it can be redrawn immediately.                 */

    if (!idata[nimages].fromhistory && w > 0 && h > 0) idata[nimages].fixedsize = 1, idata[nimages].canredraw = 1;
d954 1
a954 1
  if (!choices.refo_wait) idata[nimages].canredraw = 1; /* If not waiting, reformats are immediate so canredraw is always true */
d958 1
a958 12
  /* If there's data for a URL, need to tell the image handling library */
  /* about the new image.                                               */

  if (ulen)
  {
    idata[nimages - 1].istore = NewImage(NULL, background ? IMAGE_FAST : 0);

    /* Fill in the URL */

    strcpy(ddata + image_data_offset(b, nimages - 1), url);
  }
  else
d2285 1
a2285 16
        /* Had neither a width nor a height, or the image size came */
        /* from the image history originally.                       */

        if ((!idata[i].currw && !idata[i].currh) || idata[i].fromhistory)
        {
          idata[i].fromhistory = 0;

          if (
               idata[i].currw != idata[image].istore->width_os ||
               idata[i].currh != idata[image].istore->height_os
             )
             idata[i].reformat = 1;

          idata[i].currw = idata[image].istore->width_os;
          idata[i].currh = idata[image].istore->height_os;
        }
d2287 3
a2289 1
        /* Had a height but no width - scale by the height */
d2291 1
a2291 1
        else if (!idata[i].currw)
d2293 3
a2295 12
          if (idata[i].currw != idata[image].istore->width_os) idata[i].reformat = 1;

          idata[i].currw = (idata[image].istore->width_os * idata[i].currh) / idata[image].istore->height_os;
        }

        /* Had a width but no height - scale by the width */

        else
        {
          if (idata[i].currh != idata[image].istore->height_os) idata[i].reformat = 1;

          idata[i].currh = (idata[image].istore->height_os * idata[i].currw) / idata[image].istore->width_os;
d2428 2
a2429 5
        x = idata[i].x;
        y = idata[i].y;

        /* Get the address of the token representing the image */

d2432 5
a2436 1
        if (!reformat_get_image_size(idata[i].owner, tp, &ibox))
d2562 1
a2562 1
        /* Closure of 'if (!reformat_get_image_size(idata[i].owner, tp, &ibox))' */
d2719 3
a2721 4
  _kernel_oserror         * e      = NULL;
  browser_data            * b      = (browser_data *) handle;
  int                       ximage = (int) i;
  int                       noplot = 0;
d2723 6
a2728 1
  int                       bimage;
d2760 2
a2761 2
  /* Can't plot a background image if there's no such image or */
  /* it's not fully fetched.                                   */
d2763 1
a2763 1
  if (b->background_image >= 0)
d2765 15
a2779 2
    bimage = b->background_image;
    if (idata[bimage].xref >= 0) bimage = idata[bimage].xref;
a2780 1
  else bimage = -1, noplot = 1;
d2782 9
a2790 2
  #ifdef TRACE
    if (tl & (1u<<15))
d2792 2
a2793 2
      if (bimage >= 0) Printf("image_fill_background: Background image = %d\n",bimage);
      else             Printf("image_fill_background: No background image\n");
d2795 9
a2803 1
  #endif
d2805 6
a2810 5
  if (
       !noplot &&
       (
         !idata[bimage].fetched ||
         !idata[bimage].istore
d2812 1
a2812 2
     )
     noplot = 1;
d2814 7
a2820 6
  if (
       !noplot              &&
       idata[bimage].istore &&
       (
         idata[bimage].istore->width_os  <= 0 ||
         idata[bimage].istore->height_os <= 0
d2822 4
a2825 2
     )
     noplot = 1;
d2857 1
a2857 1
    redraw_set_colour(redraw_backcol(b));
a3132 1
    HStream    * tp = NULL;
d3134 1
d3318 2
a3319 1
  int image;
d3327 1
a3327 1
  /* Exit if the image has no known size yet */
d3329 2
a3330 1
  if (idata[image].currw <= 0 || idata[image].currh <= 0) return;
d3332 5
a3336 1
  /* Otherwise mark it as redrawable */
d3941 13
d3984 39
d4027 7
a4033 4
  /* Find the image width/height in pixels. For images which can't be   */
  /* redrawn yet, ensure that the default size is returned, even if the */
  /* real size is known - this is so that ALT text placeholder redraws  */
  /* and (for example) keyboard navigation won't fail.                  */
d4035 106
a4140 2
  box->xmax = idata[image].canredraw ? idata[image].currw & ~(wimpt_dx() - 1) : -1;
  box->ymax = idata[image].canredraw ? idata[image].currh & ~(wimpt_dy() - 1) : -1;
a4141 1
  if (box->xmax < 1 || box->ymax < 1)
d5210 2
a5211 1
/* background image within that rectangle.       */
d5256 2
a5257 2
  w = idata[image].istore->width_os  & ~(wimpt_dx() - 1);
  h = idata[image].istore->height_os & ~(wimpt_dy() - 1);
@


1.33
log
@Note that the 'Docs' documentation (possibly contrary to previous
log messages) still hasn't been updated with the new SaveFile
stuff, and function header comments have yet to be written for
SaveFile.c.

Fixed urlutils_pathname_to_url - OS_GSTrans doesn't like the same
input buffer as output buffer (fairly obvious, but I was living in
the hope of not having to duplicate the input path string).

Image history will not cache scrap file images anymore. Browser's
image handling library won't cross reference them either.

When dragging a single item from the hotlist to a Filer window, the
code now checks Ctrl - if held down, a URL file is written, else a
URI file. The state of any option buttons or radios in the last
Save File dialogue that was opened is no longer relevant...!

history_save_as_html could write out broken files when titles
for items in the History were not present. Fixed.

Hourglass switched on for hotlist and history saving as HTML;
hotlist_save_entries no longer closes the output file on error
(it should be done by the caller, since the caller is responsible
for opening the file and passing the FILE * pointer to
hotlist_save_entries).
@
text
@d33 2
d66 1
d70 1
d113 2
d965 1
a965 1
      if (ih_w > 0 && ih_h > 0) w = ih_w, h = ih_h;
d976 1
a976 1
    if (w > 0 && h > 0) idata[nimages].fixedsize = 1, idata[nimages].canredraw = 1;
d996 3
a998 3
    /* If this is a cross-referencing image, and it hasn't got  */
    /* its fixedsize flag set, then it has no size info yet.    */
    /* In that case, get it from the image it cross references. */
d1000 2
a1001 3
    if (!idata[nimages - 1].fixedsize)
    {
      int xref = idata[nimages - 1].xref;
d1003 22
a1024 7
      if (xref >= 0 && idata[xref].istore)
      {
        idata[nimages - 1].currw = idata[xref].istore->width_os;
        idata[nimages - 1].currh = idata[xref].istore->height_os;
      }
    }
  }
d1117 1
a1117 1
    while (image != lastimage && idata[image].handle == 0);
a1557 1

d2306 1
a2306 1
       !idata[image].hadfirst              &&
d2321 34
a2354 2
        idata[i].currw = idata[image].istore->width_os;
        idata[i].currh = idata[image].istore->height_os;
d2472 1
a2472 1
          /* Now do the reformat */
d2475 7
a2481 1
          reformat_format_from(idata[i].owner, l - 1, 0, i);
d2500 2
d2504 2
a2505 11
            /* If the image size was specified in the HTML, just do a redraw  */
            /* (which clears the background first, see the very large comment */
            /* earlier on). Otherwise, the image size has changed so do a     */
            /* reformat here.                                                 */

            if (idata[i].fixedsize) image_update_area(idata[i].owner,
                                                      x,
                                                      y,
                                                      &partial,
                                                      i,
                                                      1);
d2507 1
a2507 1
            else
d2523 13
a2535 1
              /* Now do the reformat */
d2537 8
a2544 1
              reformat_format_from(idata[i].owner, l - 1, 0, i);
d2548 2
a2549 2
          /* Otherwise, work out what region to redraw (may only require */
          /* a partial area update)                                      */
d2977 1
a2977 1
    for (y = redraw.ymax; y >= redraw.ymin; y -= h)
d3029 1
a3029 1
    for (y = redraw.ymax; y >= redraw.ymin; y -= h)
d3260 1
a3260 1
  for (y = ymax; y >= r->redraw_area.ymin - h; y -= h)
d4000 1
a4000 1
  if (box->xmax < 1)
d4746 227
a4972 1
  /* ...And for now, we don't know this either! */
d4974 304
a5277 1
  return 4096;
@


1.32
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d69 1
d761 1
a761 1
    int i;
d763 20
a782 1
    for (i = 0; i < nimages; i++)
d784 5
a788 1
      /* Can we simply create a cross reference to another image? */
d790 5
a794 7
      if (
           idata[i].alloc                                            &&  /* The image has data allocated for it                 */
           !strcmp(url, ddata + image_data_offset(b,i))              &&  /* This holds a URL which matches that passed in       */
           idata[i].xref < 0                                         &&  /* The image doesn't cross reference things itself     */
           idata[i].background == !!background                       &&  /* We're not trying to make a b/g an f/g or vice versa */
           (
             !background ||                                              /* This isn't a background image, or...                */
d796 5
a800 2
               background &&                                             /* If this is a background image, the background       */
               idata[i].owner->background_colour == b->background_colour /* colours match in the two owner browsers             */
d803 4
a806 4
         )
      {
        xref = i;       /* If all of the above are satisfied, cross reference */
        i    = nimages; /* this image with the one it matches.                */
@


1.31
log
@Implemented Message_PlugIn_ReshapeRequest, Message_PlugIn_Status and
Message_PlugIn_Busy. Plug-in code more robust when given invalid
browser instance handles by the plug-in.

Line spacing is now calculated on the basis of the normal style base serif
font, with all other fonts being forced into that line height. This does
mean that an unusually tall (say) sans serif font may get clipped. It
appears to be the only way to get around wildly different baseline
depths returned from the font metrics - you can't work out line spacing
based on each different font style; the line spacing will vary.

Table heighting (as opposed to widthing...) improved considerably; rowspan
can no longer cause very tall cells in odd places. Having trouble getting
rid of the single pixel breaks between vertically adjacent cells, though
I've not tried too hard. Widthing, though, seems fairly badly broken at
present... :-/

Set/clear of page_is_text flag made more robust (it looked as though there
was the potential for this to get stuck in a set state, though I've never
see the front-end behave in a manner which indicates this is the case).
The reformatter will now decrease leading if this flag is set (plain text
pages look daft with a line spacing that is OK for 'rich' text pages).
No reformatting is done if the page width changes by dragging on the
resize icon, though toggle size / full screen will still reformat even
if the contents are only text (browser needs to sort out various width
flags at this point).

Cut down on excessive redrawing when reformatting due to a change in
window dimensions is not done. If display_width hasn't changed, then no
redraw is needed. If this causes redraw problems, then whatever is
changing display_width needs investigating. It shouldn't be kludged
(basically) by forcing a redraw instead of a reformat.

TT/PRE/etc. text can now have a non-100% aspect ratio. 80-90% looks
best (ArcWeb, for example, uses 86%). New option 'TTAspect' in
the Choices files.

Debug builds link to a non-debug Unicode library now; stops stderr
being dumped to the bottom left of the screen if you've not redirected
it in the Run file.

RISC OS 3.1 seems to need more initial WimpSlot than later OS versions.
The 64 deep nested table set gives a 'No stack for trap handler' error
(which it really means in this case!) without 800K, even though 3.71
is happy with just 640K. So, the !Run file checks if Boot$OSVersion
is exactly 300, 310 or 311, and sets the WimpSlot accordingly.

!Run[D] files now require latest fetcher module versions (URL 0.21,
File 0.31, HTTP 0.58).
@
text
@d70 1
d4161 49
d4449 1
a4449 1
              "There is no data for this image in image_export_foreground_sprite.");
d4480 1
a4480 1
/*             bytes.                            */
d4490 166
@


1.30
log
@Image history - sizes of images are remembered for future reference (if
the sizes aren't specified in the HTML, they can be looked for in the
image history instead to minimise reformatting requirements). Choices
file options ImageHistoryPath, ImageExpiryAge, ImageMaxSize and
SaveImageHistory added to support this (all have a direct analogy to
the global History items of the same name after removing 'Image').

Text area items are now the correct height for the number of rows
specified in the HTML, don't scroll a line too early, and have the
caret placed at the start of the text when moved into from above
or at the end when moved into from below (rather than always at
the end, which was behaviour inherited from single line writables,
where this is desirable). The top of the text area is aligned to
the top of any line of text on the same line, with the text area
dropping below the text, rather than the bottom of the area matching
the text baseline and extending upwards.

Filename extensions for download files are only stripped if an
attempt to convert to a RISC OS filetype through the Mime Mapper module
does not return an error or Data (0xffd) filetype. '.cgi' is a special
case which is always stripped.

Altered heading styles - all are bold, none are italic, H3 is as big
as H2 was, H2 is a little larger, and others scale down to H6 being
the size as normal text (but, as I say, bold).

Sorted out tables and forms. We can just look for tagno=TAG_FORM, and
get rid of the wobbly form_flag; also discarded the redundant
reprocess_table flag in fetch_preprocess_token. Two separate forms
in consecutive table cells (for example) which used to fail - they
were submitted as one single form - will now work correctly.

Fixed nasty bug in FontManage.c where font size 7 would intermittently
fail. The stupid font sizes that it could ask the Font Manager for may
be responsible for the occasional Font Manager crashes that have been
noticed. Array for font sizes was declared as [Limits_FontSizes], but
indices 1 to Limits_FontSizes are actually used - so needed a '+ 1'
in the declaration... :-/

Replaced the case insensitive string comparison functions in Utils.c
with more efficient versions by S.Brodie.

MAXLENGTH specifier in INPUT tags is now supported. If unspecified or
specifically zero, the browser overrides and allows any length.
@
text
@d95 1
d2332 4
a2335 5
      int          l, x, y;
      int          chunk, depth, noplot = 0;
      token_path * path = NULL;
      HStream    * tp;
      BBox         ibox;
d2372 1
a2372 1
      depth = tokenutils_line_range(idata[i].owner, idata[i].token, &l, &chunk, NULL, NULL, &path);
a2373 10
      else
      {
        /* If a line was found and depth is non-zero, the line was inside */
        /* a table - want to find the parent line of the table, so that   */
        /* if a reformat is needed it will resize the table as required.  */

        if (depth) l = path[depth - 1].line;
        if (l < 0) noplot = 1;
      }
      if (path) free(path);
d3962 98
@


1.29
log
@All hotlist_find_match calls wrapped in '#ifndef REMOTE_HOTLIST' compile
time option, for Customer builds.

Cross referencing of images when the background colour is different - should
not do it for backgrounds, for e.g. alpha transparent PNGs would then fail.
This was implemented, but it turns out it affects *all* cross referencing!
Fixed for just background images.

As described in Docs.TagNames, the tag name "ahodgkin_127beta2" associated
with this checkin applies to everything *except* Choices.c. v1.27 beta 2
was build with the Choices file tagged "ahodgkin_127beta". The confusion
arises because Choices.c got independently updated and checked back in
before I checked in the v1.27 beta 2 changes myself.
@
text
@d62 1
a306 52
// Deprecated functions:

// /*************************************************/
// /* image_info_addr                               */
// /*                                               */
// /* Returns the address of the image_info struct  */
// /* for a given image number.                     */
// /*                                               */
// /* This function is deprecated. Use a direct     */
// /* array reference (i.e. idata[image]) in        */
// /* preference, as this is robust with respect to */
// /* flex block movements (see Assumes below).     */
// /*                                               */
// /* Parameters: Pointer to a browser_data struct  */
// /*             relevant to the image in          */
// /*             question;                         */
// /*                                               */
// /*             An image number, from 0 to        */
// /*             nimages - 1.                      */
// /*                                               */
// /* Returns:    Pointer to the image_info struct  */
// /*             for that image.                   */
// /*                                               */
// /* Assumes:    The pointer is in a flex block,   */
// /*             so it will be invalidated if the  */
// /*             block should move;                */
// /*                                               */
// /*             No limit checking is performed on */
// /*             the image number.                 */
// /*************************************************/
//
// static image_info * image_info_addr(browser_data * b, int image)
// {
//   #ifdef TRACE
//     if (tl & (1u<<15)) Printf("image_info_addr: Called for image %d, and exitting\n",image);
//   #endif
//
//   return &idata[image];
// }

// Deprecated fragments:

// No such thing as The Broken Sprite anymore...
//
// static void image_get_broken_sprite(sprite_area * * sa,sprite_id * sid)
// {
//   * sa=resspr_area();
//   sid->tag=sprite_id_name;
//   sid->s.name="missing";
//   plotspr_locate_sprite(* sa,sid);
// }

a838 16
//  if (idata)
//  {
//    char * p;
//    int    olddatasize;
//
//    olddatasize = flex_size((flex_ptr) &idata);
//    size += olddatasize;
//    ok = flex_extend((flex_ptr) &idata,size);
//    p = (char*) idata;
//    p+=nimages* sizeof(image_info);
//    memmove(p+sizeof(image_info),p,olddatasize-nimages* sizeof(image_info));
//  }
//  else ok=mflex_alloc(&idata,size);
//
//  if(!ok) return(errorgen(2));

d889 1
a889 1
  if (!background && tp->tagno != TAG_INPUT)
d891 2
a892 1
    int w, h;
d896 2
a897 1
    /* The OBJECT macros work for images as well as OBJECTs */
d899 1
a899 1
    if (OBJECT_HAS_WIDTH(tp))
d901 13
a913 1
      switch (OBJECT_WIDTH_UNITS(tp))
d915 6
a920 3
        default:
        case UNITS_PIXELS:  w = OBJECT_WIDTH(tp) * 2; break;
        case UNITS_PERCENT: w = available_w * OBJECT_WIDTH(tp) / 100; break;
a922 1
    else w = 0;
d924 3
a926 1
    if (OBJECT_HAS_HEIGHT(tp))
d928 5
a932 6
      switch (OBJECT_HEIGHT_UNITS(tp))
      {
        default:
        case UNITS_PIXELS:  h = OBJECT_HEIGHT(tp) * 2; break;
        case UNITS_PERCENT: h = available_h * OBJECT_HEIGHT(tp) / 100; break;
      }
d934 2
a935 1
    else h = 0;
d940 3
d2392 15
d2441 20
a2460 1
            else reformat_format_from(idata[i].owner, l - 1, 0, i);
@


1.28
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d813 2
d816 11
a826 5
           idata[i].alloc                                            && /* The image has data allocated for it                 */
           !strcmp(url, ddata + image_data_offset(b,i))              && /* This holds a URL which matches that passed in       */
           idata[i].xref < 0                                         && /* The image doesn't cross reference things itself     */
           idata[i].background == !!background                       && /* We're not trying to make a b/g an f/g or vice versa */
           idata[i].owner->background_colour == b->background_colour    /* Background colours match in the two owner browsers  */
@


1.27
log
@Removed 'The Onion' link from some Hotlist files. Time showed that the
site wasn't entirely Family Friendly (TM)... Removed Shift Control (it's
gone offline now), and corrected the Telegraph URL from ...the-telegraph...
to just ...telegraph...

StrongHelp manual generator now tries to work out the number of lines in
the table on the root page more intelligently.

Plug-in support extended to handle Shockwave. Quite a lot of underlying
work for this, including a pseudo cache system for temporary files.

Bug in redraw routines: they plotted background images within table
cells, when nothing should have been drawn. Oops. When background images
in cells are properly supported, this can get sorted out.

Tweaked vertical plot position of HRs (up to 4 OS units too high before due
to rounding).

Various Res file bits and pieces, Ursula build taken up to v1.26 beta
for release on the Browser site. *Note* not all resources are up to date!
This will be done after AW97.
@
text
@d65 1
d85 2
d814 5
a818 4
           idata[i].alloc                               && /* The image has data allocated for it                 */
           !strcmp(url, ddata + image_data_offset(b,i)) && /* This holds a URL which matches that passed in       */
           idata[i].xref < 0                            && /* The image doesn't cross reference things itself     */
           idata[i].background == !!background             /* We're not trying to make a b/g an f/g or vice versa */
d915 1
d1607 2
d1610 17
d1717 19
a1735 2
      /* If this is a background image for the cross referencer, */
      /* must update the browser_data 'background_image' field.  */
d1737 9
a1745 1
      if (i == idata[i].owner->background_image) idata[i].owner->background_image = xref;
d2286 1
a2286 1
  if (idata[image].istore->RegisterFiller)
d2288 1
a2288 28
    #ifdef STRICT_PARSER

      {
        _kernel_oserror * e;

        /* Report any errors as Continue-only in strict parser mode */

        e = idata[image].istore -> RegisterFiller(idata[image].istore,
                                                  (FillerFunction *) image_fill_background,
                                                  b,
                                                  (int *) image);

        if (e)
        {
          e->errnum = Utils_Error_Custom_Message;
          show_error_ret(e);
        }
      }

    #else

      /* If not in Strict mode, ignore any errors */

      idata[image].istore -> RegisterFiller(idata[image].istore,
                                            (FillerFunction *) image_fill_background,
                                            b,
                                            (int *) image);
    #endif
d2370 1
a2370 1
      int          chunk, o, depth, noplot = 0;
a2447 8
          o = 0;

          if (ISOBJECT(tp))         o = HtmlOBJECTborder(tp);
          else if (tp->style & IMG) o = tp->maxlen * 2;

          x += o;
          y += ibox.ymin + o;

a2464 149

  // Haven't solved the cross referencing problem yet. What seems to happen
  // is that the function gets called when the actual image comes in, then
  // gets called separately with the cross references set up. So by that time,
  // the fact that the cross referenced images weren't sized either is not
  // known to the function and unless you've forced a reformat first time
  // round it'll go pear shaped later.

  //          {
  //            int width, old_h, old_y, old_b, top, bot;
  //
  //            /* Optimisation and complication... For images which lie alone on */
  //            /* a single line, don't have to reformat. Can just shift the page */
  //            /* below down, and redraw the line with the image in.             */
  //            /*                                                                */
  //            /* Later it should be possible to carry out a reformat between    */
  //            /* the image and the next line break point, but for now this at   */
  //            /* least gets rid of a few reformats.                             */
  //            /*                                                                */
  //            /* This is complicated somewhat by cross referencing. That is, if */
  //            /* several image tags refer to the same piece of data, normally   */
  //            /* the reformatter is called and so resizes them all in passing   */
  //            /* (see comments on the reformatter call below). This won't       */
  //            /* happen in the optimised case, so must to a scan right down the */
  //            /* line list until either all occurrences have been found or the  */
  //            /* reformatter gets called for some reason.                       */
  //
  //            if (b->ldata[l].n == 1)
  //            {
  //              Printf("Optimised page yshift for new, previously unsized image on line %d\n",l);
  //
  //              width  = ibox.xmax - ibox.xmin;
  //              convert_to_points(width, &width);
  //              b->cdata[chunk].w = width;
  //
  //              top = ibox.ymax;
  //              bot = ibox.ymin;
  //
  //              if (top & 3) top += 4 - (top & 3);
  //              if (bot & 3) bot += 4 - (bot & 3);
  //
  //              old_h = b->ldata[l].h;
  //              old_y = b->ldata[l].y;
  //              old_b = b->ldata[l].b;
  //
  //              /* lp->h - lp->b equates to the height of the line in OS units minus */
  //              /* the y offset of the font baseline from the bottom of the line. If */
  //              /* 'top' is greater than this the line needs to grow vertically.     */
  //
  //              if (top > (b->ldata[l].h - b->ldata[l].b))
  //              {
  //                int d;
  //
  //                d = top - (b->ldata[l].h - b->ldata[l].b);
  //                b->ldata[l].h += d;
  //                b->ldata[l].y -= d;
  //              }
  //
  //              /* Similarly, if bot is greater than the offset of the baseline from */
  //              /* the bottom of the line, account for the extra offset.             */
  //
  //              if (bot > b->ldata[l].b)
  //              {
  //                int d;
  //
  //                d = bot - b->ldata[l].b;
  //
  //                b->ldata[l].h += d;
  //                b->ldata[l].b += d; /* Was lp->b = bot; */
  //                b->ldata[l].y -= d;
  //              }
  //
  //              if (
  //                   b->ldata[l].h != old_h ||
  //                   b->ldata[l].y != old_y ||
  //                   b->ldata[l].b != old_b
  //                 )
  //              {
  //                int move;
  //
  //                move = b->ldata[l].h - old_h;
  //
  //                if (move)
  //                {
  //                  e = reformat_shift_vertically(b, l + 1, b->nlines + 1, -move);
  //                  if (e) return e;
  //                }
  //              }
  //
  //              /* If using complex backdrops, want to keep them in sync, so need */
  //              /* to refresh the whole area below the line just altered. Else,   */
  //              /* just redraw the line.                                          */
  //
  //              if (b->background_image != -1)
  //              {
  //                /* Redraw everything below the line */
  //
  //                int top;
  //
  //                if (b->ldata[l].y + b->ldata[l].h > old_y + old_h) top = b->ldata[l].y + b->ldata[l].h;
  //                else                                               top = old_y + old_h;
  //
  //                browser_update_bottom(b, top);
  //              }
  //              else
  //              {
  //                /* Redraw just the line that's changed */
  //
  //                WimpGetWindowStateBlock state;
  //                int                     top, bottom;
  //
  //                /* Work out the top and bottom points to redraw from, depending */
  //                /* on how the line moved and/or resized due to the above code.  */
  //
  //                if (b->ldata[l].y < old_y) bottom = b->ldata[l].y;
  //                else                       bottom = old_y;
  //
  //                if (b->ldata[l].y + b->ldata[l].h > old_y + old_h) top = b->ldata[l].y + b->ldata[l].h;
  //                else                                               top = old_y + old_h;
  //
  //                state.window_handle = b->window_handle;
  //                e = wimp_get_window_state(&state);
  //                if (e) return e;
  //
  //                coords_box_toworkarea(&state.visible_area, (WimpRedrawWindowBlock *) &state);
  //
  //                return wimp_force_redraw(state.window_handle,
  //                                         state.visible_area.xmin,
  //                                         bottom,
  //                                         state.visible_area.xmax,
  //                                         top);
  //              }
  //
  //              /* Closure of long 'if' checking if there was just one chunk on this */
  //              /* line - if so don't need to call the reformatter, can just shuffle */
  //              /* lines below (being very careful over the redraw...). The code     */
  //              /* above executes in this case. Else, reformat from this point.      */
  //            }
  //            else
  //            {
  //              /* Where several image tags in the document source refer to the same */
  //              /* actual piece of image data, this reformat call will ensure that   */
  //              /* they are all correctly sized and positioned. This is because it   */
  //              /* will always be called on the first of any such images and thus    */
  //              /* must go through all subsequent occurrences in passing.            */
  //
  //              return (reformat_format_from(b, l - 1, 0, i));
  //            }
  //          }
d2538 1
a2538 1
         /* Closure of 'if (!reformat_get_image_size(idata[i].owner, tp, &ibox))' */
d2631 46
d2683 7
d2704 4
d2724 8
d2742 8
d2817 7
a2823 1
     return NULL;
d2850 4
d2901 5
a2905 5
                                           x,
                                           y,
                                           100,
                                           w,
                                           h));
d2919 4
d2953 5
a2957 5
                                           x,
                                           y,
                                           100,
                                           -1,
                                           -1));
d2967 4
d4296 4
@


1.26
log
@Added support for getting aspect ratio right in filler function.
Added support for background alpha PNGs.
Passed support_object flag through to HTMLLib.
@
text
@d54 1
a1202 1

d2428 2
a2429 2
          if (tp->tagno == TAG_OBJECT) o = HtmlOBJECTborder(tp);
          else if (tp->style & IMG)    o = tp->maxlen * 2;
a3012 1

d3135 2
a3136 2
    tp   = token->tagno == TAG_OBJECT ? token                 : idata[actual].token;
    text = tp->tagno    == TAG_OBJECT ? HtmlOBJECTstandby(tp) : tp->text;
d3973 1
a3973 1
    text = tp->tagno == TAG_OBJECT ? HtmlOBJECTstandby(tp) : tp->text;
@


1.25
log
@fetch_get_raw_data will notice if up->fetching is zero and return a
'finished' status rather than trying to continue reading data for the
fetch. Fetches should never fall through that far but at least it
will cope if they do.

3D table borders are now supported. 2D borders are used if the
inter-cell spacing is too small to fit the borders in (display resolution
dependent) - the external table border is 2D if the internal borders are,
else 3D. For cellspacing of 0, internal table borders must plot over the
outer edge of pixels inside the cell; for all greater spacings, the
borders take up all or part of the gap between them. The external border
will always fit around the outside of the cells, including the
cellspacing value in the gap between the outer cells and the border.

Anti-alias colour for placeholder ALT text was incorrect. Fixed.

I'd changed 'point' to 'points' in some of the Font Choices dialogues;
now changed back to 'point'.

The routine to find out how large an otherwise unsized object or image
placeholder based on its ALT text has been centralised in Reformat.c,
so that the image and object routines can both access it without
code duplication (this means non-image objects will now have the correct
size if they contain ALT text, rather than assuming a standard default
size as before). ALT text in images that were also objects was never
plotted either, though the placeholder size would have been correct.
This has been fixed.
@
text
@d1202 1
d1205 2
d1214 2
a1215 1
                                                 &b->antialias_colour);
d1228 2
a1229 1
                                             &b->antialias_colour);
a1232 1
            else b->antialias_colour = redraw_backcol(b);
d2944 1
a2944 1
    /*idata[bimage].istore -> ModeChange(idata[bimage].istore);*/
d2964 1
a2964 1
    /*idata[bimage].istore -> ModeChange(idata[bimage].istore);*/
d2992 1
a2992 1
    /*idata[bimage].istore -> ModeChange(idata[bimage].istore);*/
d3012 1
a3012 1
    /*idata[bimage].istore -> ModeChange(idata[bimage].istore);*/
@


1.24
log
@Weird - the line registering the ENavigateToBeShown event disappeared from
Main.c, so the last log was incorrect; Navigate menu items wouldn't have
been greyed out. Probably a(nother?) CVS update screw up on my part; now
fixed. This sort of thing is happening far too often...

Font manager would crash in system font or if a font face was not found
in the previous release - that hacky business of returning weird font
handles when system font is to be used instead ensured a rather less than
valid array reference on behalf of fm_claim_basic_typefaces.

Added in a few more calls to the 'check the button bar' routines, to
ensure that things like Stop are greyed/ungreyed when needed.

Cellpadding code could lead to rmarg overlapping lmarg, or the sum
being greater than dwidth, or something like that (!) in the reformatter.
Anyway the results were unpleasant; this has been sorted out by range
checking right and left margins w.r.t. display width in the relevant
section of the code.

People who specify 'td width = 2000' in tables expecting to get something
sensible now do, though I was half inclined to leave it alone... I can
only assume that they don't know about % specification or it didn't
work in their browser at authorship time, and the huge width served as
an attempt to get the table to fill the available window width. Anyway,
the table reformatter spots when the maximum width a cell requires is
less than half of what it asks for, and ignores the width specifier if
this is the case.
@
text
@d3132 2
a3133 10
    if (tp->tagno != TAG_OBJECT)
    {
      tp   = idata[actual].token;
      text = tp ? tp->text : NULL;
    }
    else
    {
      tp   = token;
      text = HtmlOBJECTstandby(tp);
    }
d3962 2
a3963 2
    /* Don't have precise image dimensions, so work out the ALT text */
    /* requirements and use these instead, if there *is* ALT text!   */
d3965 2
a3966 1
    HStream * tp = NULL;
d3970 1
a3970 36
    if (
         !tp ||
         (
           tp->tagno == TAG_OBJECT &&
           (
             !HtmlOBJECTstandby(tp) ||
             !*HtmlOBJECTstandby(tp)
           )
           || !tp->text
           || !*tp->text
         )
       )
    {
      box->xmax = ImageDefaultOSSize_X;
      box->ymax = ImageDefaultOSSize_Y;
    }
    else
    {
      int    h, temp, size;
      BBox   fbox;
      char * text;

      text = tp->tagno == TAG_OBJECT ? (char *) HtmlOBJECTstandby(tp) : tp->text;

      /* Claim the font */

      size = (fm_size(tp->fontsize) * 80) / 100;

      h = fm_find_font(idata[image].owner,
                       "sans",
                       size,
                       size,
                       0,
                       0);

      /* Find the string width of the ALT text */
d3972 1
a3972 51
      fm_get_string_width(h,
                          text,
                          Reformat_AsWideAsPossible_MP,
                          strlen(text),
                          -1,
                          &temp,
                          &box->xmax);

      convert_to_os(box->xmax, &box->xmax);

      /* Find the font height */

      fm_font_box(h, &fbox);

      /* As well as subtracting ymin (the y minimum coordinate */
      /* of the font bbox) from ymax, need to also add some    */
      /* height to give a gap between the text and slabbed box */
      /* that's drawn to mark the image's position.            */

      box->ymax = fbox.ymax - fbox.ymin;

      convert_to_os(choices.font_size, &temp);

      if (temp < 16) temp = 16;

      box->ymax += temp;
      box->xmax += temp * 2;

      /* Don't want to force the page width up just because of */
      /* ALT text in images, especially in narrow items such   */
      /* as navigation frames, so limit check xmax.            */

      // Currently this is done by an absolute hard coded upper
      // limit, but ultimately it would ideally be limited e.g.
      // by cell width. Just as soon as I work out a nice way
      // of doing that... (Remember, you may not know the cell
      // width at times when this is being called to try and
      // determine it; yet you must return consistent and
      // appropriate values subsequently for redraw purposes).

      {
        int remain;

        convert_to_os(b->left_margin + b->right_margin, &remain);

        remain = b->display_width - remain;
        if (remain > 320) remain = 320;

        if (box->xmax > remain) box->xmax = remain;
      }
    }
@


1.23
log
@Now handles PARAM tags. Sorted out Plug-In bug that was related to Java
setting a 0 by 0 graphics window before calling Wimp_Poll (fixed in Java).
Implemented queue for Plug-Ins so multiple broadcasts aren't sent for
several Objects in one data chunk.

Added Docs directory with some documentation in it. More things to keep
checking for stylistic consistency, horray ;-)

Corrected !Run[D] for Ursula build to need AcornURI but not TaskModule
(URI handler needed for !Mail to pick up mailto: links).

Added display_height field to browser_data, analogous to display_width,
to cope with % sized objects by width and height (see how HRs are
handled in Redraw.c for an example of how it was always fairly easy
with width, but not height until this addition). Though you do have
to reload to get a new size; reformat isn't enough. Must see to this
some time...

Fixed bug where basic typefaces were claimed *before* the Choices file
had been read. For unusual Choices settings, this could create some
'interesting' problems now and again. This was part of narrower scope
work in the Choices code to allow font changing without leaking font
handles (now done; fm_shutdown only ditches fonts, it keeps internal
structures - must then call  fm_lose_fonts for all browsers to get the
bitfields up to date, then rewrite the typeface definitions and reclaim
basic fonts). Noticed that fm_claim_basic_typefaces would claim multiple
instances of the same font if there were several cases of the same font
mapped to different typeface styles - fixed.

Implemented PlugInControl settings, but not SupportObject (fully).
@
text
@d1093 5
a1097 1
          show_error_ret(e);
@


1.22
log
@Places where ModeChange should be called in image_fill_background marked,
but commented out (because of problems with flex moving when redirected
to a sprite).
A few more tags added to Trace.
@
text
@d944 3
a946 1
    /* Works for Objects as well as images */
d948 1
a948 2
    if (tp->cols > 0) idata[nimages].currw = tp->cols * 2;
    if (tp->rows > 0) idata[nimages].currh = tp->rows * 2;
d950 26
a975 1
    if (tp->cols > 0 && tp->rows > 0) idata[nimages].fixedsize = 1, idata[nimages].canredraw = 1;
d2420 2
a2421 2
          if (tp->tagno == TAG_OBJECT)              o = HtmlOBJECTborder(tp);
          else if (ISLINK(tp) && (tp->style & IMG)) o = tp->maxlen * 2;
@


1.21
log
@More reformatter code bugs fixed; this one regarding width of items. Any
kerned string was overestimated (causing redraw bugs and caret position
problems in forms, apart from other minor bits elsewhere) and the default
size of a writable icon wasn't especially clever.

Crude Plug-In support; just about manages Java, but can't fetch on
behalf of Plug-In (for example). Had to change the default file access
URL construction to be 'file:/' instead of 'file://', or local file
fetches that reference Java applets won't work. This is in its very
early stages, and is being checked in mostly so that various Choices
issues can be worked on.
@
text
@d2910 2
d2929 2
d2958 2
d2977 3
@


1.20
log
@Added support for PNGs with alpha. image_fill_background optimised.
@
text
@a2200 1

d2203 1
a2203 1
  if (idata[image].istore -> RegisterFiller)
d2906 1
a2906 1
    redraw.ymin = -h /*-idata[ximage].istore->height_os */;
d2950 1
a2950 1
    redraw.ymin = -h /*-idata[ximage].istore->height_os */;
d3076 3
a3078 1
    BBox box;
d3090 4
a3093 1
    if (box.xmax > 8 && box.ymax > 8)
d3095 2
a3096 29
      /* xmin, ymin hold the bottom left hand corner coordinates, whilst */
      /* xmax, ymax hold the width and height. The adjustments are to    */
      /* account for the way the bbc_rectanglefill function works; e.g., */
      /* to get a width of 4 OS units, ask for 3 (as it adds this to the */
      /* x coordinate and treats it as an inclusive x coordinate max).   */
      /* There are corrections to plot 2 OS units inside of the real     */
      /* bounding box (looks better when images touch each other) and to */
      /* get the darker sides of the 'slabbed in' box overlapping the    */
      /* lighter sides by the right amount.                              */

      redraw_set_colour(Redraw_Colour_AlmostWhite);
      bbc_rectanglefill(box.xmin + 2,
                        box.ymin + 2,
                        box.xmax - 5,
                        3);
      bbc_rectanglefill(box.xmax + box.xmin - 6,
                        box.ymin + 2,
                        3,
                        box.ymax - 5);

      redraw_set_colour(Redraw_Colour_MidGrey);
      bbc_rectanglefill(box.xmin + 2,
                        box.ymax + box.ymin - 6,
                        box.xmax - 7,
                        3);
      bbc_rectanglefill(box.xmin + 2,
                        box.ymin + 4,
                        3,
                        box.ymax - 7);
d3100 2
a3101 5
      if (box.xmax < 2) box.xmax = 2;
      if (box.ymax < 2) box.ymax = 2;

      redraw_set_colour(0);
      bbc_rectangle(box.xmin,box.ymin,box.xmax - 1,box.ymax - 1);
d3104 5
a3108 121
    /* Plot any ALT text that there might be, if we have a */
    /* rational image number.                              */

    if (image >= 0)
    {
      HStream * tp;

      tp = idata[actual].token;

      if (tp && tp->tagno != TAG_OBJECT && tp->text && *tp->text)
      {
        /* Have got some ALT text. First find out the bounding box */
        /* needed to contain that text.                            */

        int    h, xpos, vcent, stringwidth, stringheight, size, dummy;
        BBox   fbox;
        BBox * ibox = NULL;

        fbox.xmin = fbox.ymin = 0;

        /* Claim the font */

        size = (fm_size(tp->fontsize) * 80) / 100;

        h = fm_find_font(b,
                         "sans",
                         size,
                         size,
                         0,
                         0);

        /* Find the string width of the ALT text */

        fm_get_string_width(h,
                            tp->text,
                            Reformat_AsWideAsPossible_MP,
                            strlen(tp->text),
                            -1,
                            &dummy,
                            &stringwidth);

        convert_to_os(stringwidth, &stringwidth);

        /* Find the font height */

        fm_font_box(h, &fbox);

        stringheight = fbox.ymax - fbox.ymin;

        /* Set xpos to the horizontal offset to plot at. */
        /* Remember that 'box' contains the bottom       */
        /* left coordinates of the image, then the width */
        /* and height in OS units in xmax and ymax.      */

        /* Similarly, centre vertically */

        vcent = (box.ymax - stringheight) / 2 - fbox.ymin;
        if (vcent <= 0) vcent = 10;
        vcent += box.ymin;

        xpos = (box.xmax - stringwidth) / 2;
        if (xpos <= 0) xpos = 10;
        xpos += box.xmin;

        /* Now set the graphics window to the image bounding box,    */
        /* taking account of the slabbed border already drawn above. */
        /* Need to set this to the intersection of the current       */
        /* graphics window though, or could end up scribbling over   */
        /* things that aren't meant to be touched.                   */

        fbox.xmin = box.xmin + 8;
        fbox.xmax = box.xmin + box.xmax - 9;
        fbox.ymin = box.ymin + 8;
        fbox.ymax = box.ymin + box.ymax - 9;

        /* If the max coordinates are less than the min, the image BBox */
        /* is too small to fit anything in. Don't proceed, as the       */
        /* attempt to set the graphics rectangle would fail, default to */
        /* the whole screen, and then random bits of ALT text would get */
        /* scribbled all over the place...                              */

        if (fbox.xmin < fbox.xmax && fbox.ymin < fbox.ymax)
        {
          /* Need to ensure a graphics window is set up for the plot, as  */
          /* text may be clipped, but this needs to take the current      */
          /* redraw rectangle into account too - hence the function call. */

          ibox = set_graphics_intersection(&fbox, &r->redraw_area);

          if (ibox)
          {
            int colour;

            colour = redraw_token_colour(b, tp);

            fm_set_font_colour(h,
                               colour,
                               redraw_backcol(b));
            fm_puts(h,
                    xpos,
                    vcent,
                    tp->text,
                    1,
                    b->background_image >= 0 && b->show_background);

            /* Underline text if it's a link and the browser is set to underline links */

            if (b->underline_links && ISLINK(tp))
            {
              redraw_set_colour(colour);
              bbc_move(xpos, vcent - 7);
              bbc_draw(xpos + stringwidth, vcent - 7);
            }

            /* Put the old graphics window back again. */

            restore_graphics_intersection(&r->redraw_area);
          }
        }
      }
    }
d3938 12
a3949 1
    if (!tp || tp->tagno == TAG_OBJECT || !tp->text || *tp->text == 0)
d3956 5
a3960 2
      int  h, temp, size;
      BBox fbox;
d3976 1
a3976 1
                          tp->text,
d3978 1
a3978 1
                          strlen(tp->text),
@


1.19
log
@Added MimeMap module support. OBJECT routines now use this to determine
if the item is an inline image, and if so pass it to the image routines.
At present, support relies on a (correct) content type.
@
text
@d2202 4
d2906 2
a2907 2
    redraw.xmin = xorigin;
    redraw.ymin = -idata[ximage].istore->height_os;
d2909 1
a2909 1
    redraw.ymax = yorigin;
d2911 1
a2911 1
    /* Render the image over the redraw region, with an unscaled plot */
d2913 1
a2913 1
    for (y = redraw.ymax; y >= redraw.ymin - h; y -= h)
d2915 1
a2915 1
      for (x = redraw.xmin; x <= redraw.xmax + w; x += w)
d2950 2
a2951 2
    redraw.xmin = xorigin;
    redraw.ymin = -idata[ximage].istore->height_os;
d2953 1
a2953 1
    redraw.ymax = yorigin;
d2957 1
a2957 1
    for (y = redraw.ymax; y >= redraw.ymin - h; y -= h)
d2959 1
a2959 1
      for (x = redraw.xmin; x <= redraw.xmax + w; x += w)
@


1.18
log
@Added support for HTMLLib HttpEndParse call.

Text items with no VALUE specified in the HTML were not cleared on
hitting a Reset button as the text field of the token is NULL; fixed.
SELECT lists with no default selection item were not being changed
on hitting a Reset button; fixed. In radio groups with no default
selection specified, no item will be selected. This goes against
the HTML 2 spec but allows broken Navigator-esque forms behaviour.
In consequence, radios can be deselected by clicking on the same
one twice. I'd fixed the flickering experienced when doing this
recently, but that, now, is irrelevant, since the state of a radio
must always change.

Reformatter's new 'find width of a SELECT field' didn't account for
the width of <none> and <many> items, and now does (particularly
important for broken items with no OPTION contents).

Under certain circumstances, illegally named targets would open in the
ancestor rather than a new window - a deliberate decision in the code,
but now reversed due to a test suite failure; they'll open in a new
window instead.

Altered the left hand indent handling for lists so that headings and
body text follow the Navigator 48 pixel indent and the bullet point
items drop to the left of the left hand margin, rather than sitting
on the margin with the text indented to the right.

Tightened up the hotlist_load_directory checking of URLs, so that
only those with '://' in - i.e. look fully specified - are accepted.
HTML files are loaded into a new directory now.

Items without a descriptive title in hotlist_new_url will have the URL
substituted in instead. White space before and after descriptions and
after URLs is stripped. Directories with zero length names or null
strings (after white space is stripped) will still be created, with a
generic name (see Messages, token 'HotlistUntitled').
@
text
@d944 2
d2390 4
a2393 1
          if (ISLINK(tp) && (tp->style & IMG)) o = tp->maxlen * 2;
d3135 1
a3135 1
      if (tp && tp->text && *tp->text)
d4076 1
a4076 1
    if (!tp || !tp->text || *tp->text == 0)
@


1.17
log
@Tidied up Hotlist source a bit more, mostly so PSI can use the automatic
StrongHelp generator on it. Revealed a spurious toolbox_hide_object call
that would always fault and never do anything, and a few heinous uses
of show_error which have all been removed.

When dragging hotlist items, directories will now be highlighted whenever
the item would be added to them, rather than just over the sprite. In
practice this only changes if the item is open and has contents...

Drag box selections had broken in the hotlist; fixed (uninitialised
variable in hotlist_select_box). Adjust-drags now close the window on
completion. Minor problem with Shift+Drag (copy) reversing order of items
sorted out. Added hotlist_add_html_file and implemented loading of HTML.
DO NOT add broken HTML files, this has not been coded for and URLs of the
form http:///this/that (no host name) will hang the machine (bug in the
cookie code of the HTTP module up to at least version 0.39).

Made SELECT list items only as wide as the widest entry actually appears
(using fm_get_string_width), rather than as wide as the widest character
BBox in the font multiplied by the string length of the longest entry.

Updated !Run[D] files to require HTTP 0.39, FTP 0.12 and File 0.23.
@
text
@d78 1
a78 1
static void              image_refetch                (browser_data * b, int image, int priority);
d1823 6
a1828 1
/*             override it).                     */
d1831 1
a1831 1
static void image_refetch(browser_data * b, int image, int priority)
d1888 2
a1889 1
    image_update_image(b, image, NULL);
d1900 2
a1901 1
      image_update_image(b, i, NULL);
d1928 1
a1928 1
  image_refetch(b, image, 1);
d1936 4
a1939 1
/* function.                                     */
d1976 1
a1976 1
           image_refetch(idata[image].owner, image, 0);
@


1.16
log
@Choices and Controls files are now loaded into malloc space (use chf and
cof to address them). Previously only in Main.c, task_dir is now globally
visible.

Choices updated to allow 16ths of a point in the font size specification
and the System font face has been removed - it isn't used. The use of
serif and sans serif fonts has been rationalised across builds (e.g. Desktop
builds use what they say, but the Customer build uses Homerton as the
default body (serif, so to speak) font as it matches the box's look and
feel better).

Font loading altered a bit to work properly! Font library defines some
standard startup fonts without using Choices, which Choices can then
override.
@
text
@d3146 1
a3146 1
                            0x1000000,
d3150 1
a3150 2
                            &stringwidth
                            );
d4086 1
a4086 1
                          0x1000000,
@


1.15
log
@Now working on source merged with Kevin Bracey's internationalisation
support. UNIFONT is undefined in the Make File for now. All Res and
Choices files updated appropriately.

Having sorted out the old Choices and Messages to form Choices, Controls
and Messages, this build has had the same cleaning up done internally.
This includes greater consistency in naming schemes and the removal of
the inconsitent choices items - e.g. Choices file entries saying 'delay
images' and 'plain backgrounds' where internally all the flags say 'show
images' and 'show backgrounds'. ChoiceDefs.h and CtrlDefs.h added to
clarify the meaning of some fields, though usage of these is not 100%
in the source (there are cases where parameters are passed through to
functions as ints, and those functions still check these against hard
coded values rather than the #define stuff).

Fetcher status return bits (connected, sent request, etc.) now reflected
in status bar. Progress during fetchs to files are reported by %, where
the size of the object is known. Exceeding 100% drops back to a byte
counter, in case the estimated size was wrong. The progress counter
may be updated after specific delays, rather than 'as often as possible',
to reduce flicker (as requested by D.Brown some time ago).

I've done a small rewrite of the fetch prioritisation scheme in FetchPage.c;
how well this performs in general use across different processor speeds
remains to be tested, but certainly it has some advantages. For each small
fetch window before the rewrite, a 4cs tight loop was entered - this gave a
noticable and substantial drain to the Desktop performance if more than one
was opened. Now, several can be up at once with little hit. The actual file
fetch is on half the priority it was before, with all others taken back
just a bit - e.g. from 20cs per poll to 15cs per poll for flat out
reformatting. You don't seem to lose much time on the format in practice,
and the Desktop feels quite a bit lighter at the same time. There's the
potential for smoother frameset loading in this scheme, too.

When Shift+Clicking on a link meant you still fetched inside the main
browser window, several fetches could occur in a frameset - one per frame.
However, now that you can only do this by clicking on a link that leads to
non-displayable data - or by turning off the small fetch windows by
setting UseSmall to 'no' in Choices - a bug where fetchpage_preprocessed
would stop such fetches as new ones were started was revealed.
The API to frames_abort_fetching has now been extended to include a
'stop file spooling too' flag, allowing a fix to be made by having
fetchpage_preprocess's calls not set this (and it doesn't check the
savelink flag is unset before proceeding, since frames_abort_fetching
does that implicitly now).

Had left the RAM transfer buffer at 16 bytes (from testing) accidentally...
Oops. Upped it to 4K. In addition, when loading data by RAM transfer,
the browser didn't notice if a RAMFetch bounced during the transfer. It
would be treated as a 'first' RAMFetch bounce, basically, and try to go to
file transfer - oops. Fixed.
@
text
@d3133 1
a3133 1
        size = fm_size(tp->fontsize);
d4074 1
a4074 1
      size = fm_size(tp->fontsize);
@


1.14
log
@Support for ANT URL broadcast message added.

Image deletion routines rewritten; nasty animated GIF bug now gone
(it kept trying to update the cross-referenced image in the browser that
no longer existed, and I've no idea how animated GIFs ever managed to *not*
blow up if a cross referencing browser was shut down; and I've tested
this...). There are now as many image structures as there are total images
in the visible browsers, and no more; cross referenced images in the
to-be-deleted browser have their ownership moved to the cross
referencer before the cross referencee is wiped, with any required fetches
being transferred with them.

Reformatter sped up a bit by getting rid of strlen on the main text field
of tokens in all places bar one, where it is called extremely rarely. This
means direct app-to-app transfer of, say, a 359K text file to the browser
won't run like a drain as it tries to do strlen on a 359K string over and
over again! Most of the time the performance benefits won't really be
noticable, but on the above text file, formatting time went down from
290 seconds before the change to just under 7 seconds, a 41 fold speed
increase or thereabouts (SA110 228MHz).

MakeFile changed to force function name compilation on for debug builds
(-fn in the DD...FLAGS); useful for certain functions such as
register_null_handler, which can now output the name of the function
being registered.

...Which helped show up some nasties in the animation handler and animation
drift handler registration/deregistration process, which have been fixed
(callers of fetchpage_release_nulls were unaware that the drift handler
could be installed, and fragments of old code checking choices.anim_drift
had a value other than 1 or 0 were still hanging around - bit tricky for
a single bit item).

Added support for VALIGN in table cells. Spotted a bug or two in the
'what token is the pointer over' routines as a result, and fixed them - the
worst was in browser_line_at_y, which checked the y coordinate was below
the given one [the mouse], but didn't check the line height to see if the
given y coordinate was *within* the line, rather than just above it. Never
used to matter pre-tables, but a definite concern once multiple line
arrays can exist on one page.
@
text
@d78 1
d211 1
a211 1
//   else if(b->backimage>0) ip=image_info_addr(b,b->backimage);
d251 1
a251 1
//   if(!ip && b->backimage>0)
d253 1
a253 1
//     ip=image_info_addr(b,b->backimage);
d280 1
a280 1
//   ip=image_info_addr(b,b->backimage);
d289 1
a289 1
//   ip=image_info_addr(b,b->backimage);
d298 1
a298 1
//   ip=image_info_addr(b,b->backimage);
d540 7
d569 1
a569 1
  if (image == b->backimage) b->aacol = redraw_backcol(b);
d584 32
d645 1
a645 1
  if (image == b->backimage) b->aacol = redraw_backcol(b);
d707 1
a707 1
        if (i == b->backimage) b->aacol = redraw_backcol(b);
d775 7
a781 6
/*             else 0. If 2, then the backimage  */
/*             field of the browser_data         */
/*             structure is filled in with the   */
/*             relevant image number and the     */
/*             image will again be turned into a */
/*             sprite for fast plotting.         */
d918 1
a918 1
    idata[nimages].delayed   = b->plainback;
d923 5
a927 1
    if (background == 2) b->backimage = nimages;
a928 1
  else idata[nimages].delayed = !b->displayimages && b->displayed != Display_External_Image;
d950 1
a950 1
  if (!choices.refowait) idata[nimages].canredraw = 1; /* If not waiting, reformats are immediate so canredraw is always true */
d1170 1
a1170 1
          if (image == idata[image].owner->backimage)
d1179 1
a1179 1
                                                 &b->aacol);
d1192 1
a1192 1
                                             &b->aacol);
d1196 1
a1196 1
            else b->aacol = redraw_backcol(b);
d1577 1
a1577 1
    if (b->backimage > image) b->backimage--;
d1658 1
a1658 1
      /* must update the browser_data 'backimage' field.         */
d1660 1
a1660 1
      if (i == idata[i].owner->backimage) idata[i].owner->backimage = xref;
d1810 1
a1810 1
/* image_reload()                                */
d1813 1
a1813 4
/* setting the priority flag so that even if a   */
/* browser has 'show foreground images' turned   */
/* off, the reloading image (and all that cross  */
/* reference it) will still be shown.            */
d1818 6
a1823 2
/*             Address of the token representing */
/*             the image.                        */
d1826 1
a1826 1
void image_reload(browser_data * b, HStream * token)
d1828 1
a1828 3
  if (nimages)
  {
    int i, image;
d1830 1
a1830 2
    /* First, start a fetch on the base image if necessary, */
    /* otherwise just set the priority flag and redraw it.  */
d1832 1
a1832 1
    image = image_get_token_image_xref(b, token);
d1834 1
a1834 1
    if (image < 0) return;
d1836 12
a1847 11
    if (
         (
           !idata[image].fetched &&
           idata[image].delayed
         )
         ||
         (
           idata[image].fetched  &&
           !idata[image].success &&
           !idata[image].istore
         )
d1849 3
a1851 2
    {
      if (!idata[image].fetched) idata[image].bytesgot = 0;
d1853 1
a1853 4
      idata[image].success  = 0;
      idata[image].delayed  = 0;
      idata[image].fetched  = 0;
      idata[image].priority = 1;
d1855 1
a1855 1
      /* If we deleted the ImageLib entry, need to recreate it */
d1857 4
a1860 4
      if (!idata[image].istore && idata[image].xref == -1)
      {
        idata[image].istore = NewImage(NULL, image == b->backimage ? IMAGE_FAST : 0);
      }
d1862 1
a1862 1
      /* Now handle the fetching */
d1864 3
a1866 5
      if (!b->fetch_handler)
      {
        fetchpage_claim_nulls(b);
        toolbars_update_status(b, Toolbars_Status_GetPics);
      }
d1868 4
a1871 1
    else
d1873 2
a1874 3
      idata[image].priority = 1;
      idata[image].hadfirst = 0;
      image_update_image(b, image, NULL);
d1876 9
d1886 1
a1886 2
    /* Now set the priority flag on all images that cross */
    /* reference the base image.                          */
d1888 3
a1890 1
    for (i = 0; i < nimages; i++)
d1892 3
a1894 6
      if (idata[i].xref == image)
      {
        idata[i].priority = 1;
        idata[i].hadfirst = 0;
        image_update_image(b, i, NULL);
      }
d1900 1
a1900 1
/* image_delay_fetches()                         */
d1902 5
a1906 1
/* Suspends image loading temporarily.           */
d1909 4
a1912 1
/*             relevant to the images.           */
d1915 1
a1915 1
void image_delay_fetches(browser_data * b)
d1917 3
a1919 3
  if (nimages)
  {
    int image;
d1921 1
a1921 5
    for (image = 0; image < nimages; image++)
    {
      if (!idata[image].handle) image_delay(b, image);
    }
  }
d1945 1
a1945 3
    int            image;
//    int            xref;
//    browser_data * xref_b;
d1958 1
a1958 15
      if (
           idata[image].owner == b &&
           (
             (
               !idata[image].fetched &&
               idata[image].delayed
             )
             ||
             (
               idata[image].fetched  &&
               !idata[image].success &&
               !idata[image].istore
             )
           )
         )
d1966 1
a1966 52
        {
          image_reload(idata[image].owner, idata[image].token);

//          idata[image].success = 0;
//          idata[image].delayed = 0;
//          idata[image].fetched = 0;
//
//          /* If we deleted the ImageLib entry, need to recreate it and */
//          /* restart fetching                                          */
//
//          if (!idata[image].istore && idata[image].xref == -1) idata[image].istore = NewImage(NULL, image == b->backimage ? IMAGE_FAST : 0);
//
//          /* Start the fetch */
//
//          if (!b->fetch_handler)
//          {
//            fetchpage_claim_nulls(b);
//            toolbars_update_status(b, Toolbars_Status_GetPics);
//          }
//
//          /* Deal with cross referenced images. If this browser cross */
//          /* references another image, and that image isn't owned by  */
//          /* this browser, then clear its fetching flags also and     */
//          /* make sure that this other browser will fetch the data.   */
//
//          xref = idata[image].xref;
//
//          if (xref >= 0 && idata[xref].owner != b)
//          {
//            idata[xref].success = 0;
//            idata[xref].delayed = 0;
//            idata[xref].fetched = 0;
//
//            xref_b = idata[xref].owner;
//
//            /* If we deleted the ImageLib entry, need to recreate it and */
//            /* restart fetching                                          */
//
//            if (!idata[xref].istore && idata[xref].xref == -1) idata[xref].istore = NewImage(NULL, image == xref_b->backimage ? IMAGE_FAST : 0);
//
//            /* Start the fetch */
//
//            if (!xref_b->fetch_handler)
//            {
//              fetchpage_claim_nulls(xref_b);
//              toolbars_update_status(xref_b, Toolbars_Status_GetPics);
//            }
//          }

        /* Closure of 'if' checking whether to restart fetches for */
        /* foreground or background images                         */
        }
a1967 2

    /* Closure of 'for' loop going through all of the images */
a1968 2

  /* Closure of 'if (nimages)' */
d2062 1
a2062 1
           b->displayimages                       ||
d2259 1
a2259 1
    if (actual == b->backimage || image == b->backimage) isbackground = 1;
d2264 1
a2264 1
        if (actual == check->backimage || image == check->backimage) isbackground = 1;
d2492 1
a2492 1
  //              if (b->backimage != -1)
d2753 1
a2753 1
  if (b->backimage >= 0)
d2755 1
a2755 1
    bimage = b->backimage;
d2802 1
a2802 1
       b->plainback                      ||
d2820 2
a2821 2
       b->plainback ||
       noplot       ||
d2872 2
a2873 2
    if (!fixed.swapbars) htop = toolbars_button_height(b) + toolbars_url_height(b);
    else                 htop = toolbars_status_height(b);
d2920 2
a2921 2
    if (!fixed.swapbars) htop = toolbars_button_height(b) + toolbars_url_height(b);
    else                 htop = toolbars_status_height(b);
d3015 1
a3015 1
         b->displayimages                       ||
d3215 1
a3215 1
                    b->backimage >= 0 && !b->plainback);
d3219 1
a3219 1
            if (b->underlinelks && ISLINK(tp))
d3269 1
a3269 1
    if (tl & (1u<<15)) Printf("image_tile_window: Called, backimage = %d\n",b->backimage);
d3274 1
a3274 1
  if (b->backimage < 0) return 0;
d3276 1
a3276 1
  image = b->backimage;
d4106 1
a4106 1
      convert_to_os(choices.fontsize, &temp);
d4128 1
a4128 1
        convert_to_os(b->leftmargin + b->rightmargin, &remain);
d4202 1
a4202 1
  return (image_get_image_size(b, b->backimage, box));
d4453 1
a4453 1
  if (!image) i = b->backimage;
d4503 1
a4503 1
  if (!image) i = b->backimage;
@


1.13
log
@As warned in the last log, pretty much all event codes and component IDs
have now changed along with many of the names, to provide a consistent
name and numberspace for events and components. This also minimises
number clashes (e.g. as was, the Save File origin when opened from a
Hotlist menu with an already-used component ID). To get full details on
this, please carefully read through TBEvents.h.

Res files, Sprites files and Messages files have been updated again both
due to the above, and routine additions (e.g. message support for a few
Hotlist bits and pieces). !Run[D] files updated for FTP 0.11 and
HTTP 0.36.

In the Makefile, the Customer objects list was missing Save - must have
moved something when I should've copied it, when adding in SaveFile or
SaveObject in all probability. Now fixed. Couple of other bits and bobs
fixed in the build environment (e.g. stuff saying !Argo instead of
!Customer). Oh, and I've altered the MakeFile copy options again to the
best compromise I can come up with. Newer is turned on for everything
except !Run[D] and !RunImage, since both of those change between debug
builds - otherwise if you'd built debug and non-debug versions, it was
not possible to switch between them - one version would have the newer
timestamp and thus never get overwritten.

The default hotlist has had a few items added - that'll be about the end
of it, I think; there's more than enough stuff in there now.

Saving of the hotlist from the document menu and of URI files,
directories and selections from the hotlist menu tree is now implemented
- this new save system rocks... Oh, and you can save all images and
backgrounds as sprites.

Saving of items with Shift+Click to other applications directly now
works, and is robust. Unique Scrap filenames are used, with data load
bounces (e.g. if some pra - er, person quits the app they're sending
to) working correctly - that is, give an error, keep the file, rename
it to something safe, and open the directory it lies in. As opposed
to normal app-to-app bounces, where the scrap file is deleted (see
PRM 3-254). This means you can now look at README files in FTP
sites, say, without using a disc intermediate. Or you can send pictures
straight to ChangeFSI, fetch HTML links into editors, and so-on, and
so-on - it's all very funky. Known problems include the ambiguous
'invalid component ID' instead of 'file open' for *normal* (straight to
disc) shift+click saves, and I think I'll introduce a unique name
guarantee of some sort to stop 'file open' in the first place. Odd
that the really tricky part (app-to-app) should be least likely to
suffer from this!
@
text
@d609 2
a610 18
//    #ifdef STRICT_PARSER
//
//      /* Report any errors as Continue-only in strict parser mode */
//
//      _kernel_oserror * e;
//
//      e = idata[image].istore -> EndLoad(idata[image].istore);
//
//      if (e)
//      {
//        e->errnum = Utils_Error_Custom_Message;
//        show_error_ret(e);
//      }
//
//    #else
//
//      /* If not in Strict mode, ignore any errors */
//
d612 2
a613 2
//
//    #endif
d662 2
a663 1
        idata[i].handle = 0;
d695 6
d1552 1
a1552 1
  int newsize, i;
d1560 4
a1563 2
  /* Discard all the images in this view, free the memory */
  /* and close the URL handles if still open.             */
d1565 1
a1565 4
  i = nimages - 1;

  /* First, get rid of any images owned by this browser which cross */
  /* reference others that point to the actual image data.          */
d1568 5
a1572 1
    if (tl & (1u<<15)) Printf("image_discard: Have %d images before first pass.\n\n",nimages);
d1575 1
a1575 3
  _swix(Hourglass_Start, _IN(0), 1);

  while (i >= 0)
d1577 1
a1577 3
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_discard: First pass, check image %d\n", i);
    #endif
d1579 10
a1588 1
    _swix(Hourglass_Percentage, _IN(0), (100 * (nimages - i)) / nimages);
a1589 2
    if (idata[i].xref >= 0 && idata[i].owner == b)
    {
d1591 1
a1591 1
        if (tl & (1u<<15)) Printf("image_discard: Deleting entry owned by %p that cross references image %d\n", b, idata[i].xref);
d1594 3
a1596 14
      image_remove_all_data(b, i);
      image_delete_image_entry(i);
    }

    i--;
  }

  #ifdef TRACE
    if (tl & (1u<<15))
    {
      Printf("image_discard: First pass complete.\n\n");
      Printf("image_discard: Have %d images before second pass.\n\n",nimages);
    }
  #endif
d1598 1
a1598 6
  /* Now check all images that point to data and see if they're */
  /* cross referenced by anything. If so, they can't be deleted */
  /* yet. If not, and they're owned by the browser that is      */
  /* discarding images, they can all go. If they're not owned   */
  /* by the browser, check if they're owned by any other        */
  /* current browser; if not, then they can again be discarded. */
d1600 3
a1602 1
  i = nimages - 1;
d1604 1
a1604 5
  while (i >= 0)
  {
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_discard: Second pass, check image %d\n", i);
    #endif
d1606 2
a1607 1
    _swix(Hourglass_Percentage, _IN(0), (100 * (nimages - i)) / nimages);
d1609 3
a1611 1
    /* Proceed if the image does not cross reference anything itself. */
d1613 2
a1614 3
    if (idata[i].xref < 0)
    {
      int i2, xref = -1;
d1616 1
a1616 3
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_discard: This is a non-xref image\n");
      #endif
d1618 3
a1620 2
      /* Scan all images, looking for at least one reference to the current */
      /* image. Remember that image's number in xref, if there is one.      */
d1622 1
a1622 1
      for (i2 = 0; i2 < nimages; i2++)
d1624 2
a1625 5
        if (idata[i2].xref == i)
        {
          xref = i2;
          break;
        }
d1628 2
d1631 1
a1631 5
        if (tl & (1u<<15))
        {
          if (xref >= 0) Printf("image_discard: %d cross references this\n",xref);
          else           Printf("image_discard: Nothing cross references this\n");
        }
d1634 4
a1637 3
      if (xref < 0)
      {
        int deleteit = 0;
d1639 7
a1645 4
        if (idata[i].owner == b)
        {
          /* Delete the current image, as nothing cross references it and */
          /* it is owned by the browser that is discarding images.        */
d1647 1
a1647 3
          #ifdef TRACE
            if (tl & (1u<<15)) Printf("image_discard: The current browser %p owns this, so it can be deleted.\n",b);
          #endif
d1649 5
a1653 6
          deleteit = 1;
        }
        else
        {
          browser_data * check;
          int            found = 0;
d1655 5
a1659 5
          /* Nothing cross references the image, but it isn't owned by this  */
          /* browser. So we can't delete it, as it may be used by another    */
          /* window... Unless, of course, there is no browser_data structure */
          /* in the list of browsers that claims to own it. In that case,    */
          /* all windows using the image *must* be gone by now.              */
d1661 3
a1663 5
          #ifdef TRACE
            if (tl & (1u<<15)) Printf("image_discard: The current browser %p does not own this...\n", b);
          #endif

          check = last_browser;
d1665 1
a1665 7
          while (check)
          {
            if (idata[i].owner == check)
            {
              found = 1;
              break;
            }
d1667 1
a1667 2
            check = check->previous;
          }
d1669 1
a1669 1
          /* If found is zero, no current browser owns the image, so it can go */
d1671 1
a1671 1
          if (!found)
d1673 2
a1674 5
            deleteit = 1;

            #ifdef TRACE
              if (tl & (1u<<15)) Printf("image_discard: ...and no current browser does either, so it can be deleted.\n");
            #endif
a1675 7
          else
          {
            #ifdef TRACE
              if (tl & (1u<<15)) Printf("image_discard: ...but another browser does, so it must not be deleted.\n");
            #endif
          }
        }
d1677 1
a1677 5
        if (deleteit)
        {
          #ifdef TRACE
            if (tl & (1u<<15)) Printf("image_discard: Deleting entry %d\n", i);
          #endif
d1679 1
a1679 1
          /* If the image was being fetched, close that session */
d1681 1
a1681 5
          if (idata[i].handle)
          {
            html_close(idata[i].handle);
            idata[i].handle = 0;
          }
d1683 2
a1684 3
          if (idata[i].istore)
          {
            #ifdef STRICT_PARSER
d1686 2
a1687 25
              /* Report any errors as Continue-only in strict parser mode */

              _kernel_oserror * e;

              e = idata[i].istore -> Delete(idata[i].istore);

              if (e)
              {
                e->errnum = Utils_Error_Custom_Message;
                show_error_ret(e);
              }

            #else

              /* If not in Strict mode, ignore any errors */

              idata[i].istore -> Delete(idata[i].istore);

            #endif
          }

          image_remove_all_data(idata[i].owner, i);
          image_delete_image_entry(i);
        }
      }
a1688 2

    i--;
d1692 1
a1692 5
    if (tl & (1u<<15))
    {
      Printf("image_discard: Second pass complete.\n\n");
      Printf("image_discard: Have %d images left.\n\n", nimages);
    }
d1702 4
d1717 4
d1724 9
d1768 5
a1772 3
/* Reloads an image - well, in fact it just      */
/* redraws an existing image at present or will  */
/* start a fetch if the image was delayed.       */
d1807 2
d1814 14
a1827 2
      if (!b->fetch_handler) fetchpage_claim_nulls(b);
      toolbars_update_status(b, Toolbars_Status_GetPics);
d1832 1
d1844 1
d1895 2
a1896 2
    int            xref;
    browser_data * xref_b;
d1932 1
a1932 8
          idata[image].success = 0;
          idata[image].delayed = 0;
          idata[image].fetched = 0;

          /* Deal with cross referenced images. If this browser cross */
          /* references another image, and that image isn't owned by  */
          /* this browser, then clear its fetching flags also and     */
          /* make sure that this other browser will fetch the data.   */
d1934 45
a1978 9
          xref = idata[image].xref;

          if (xref >= 0 && idata[xref].owner != b)
          {
            idata[xref].success = 0;
            idata[xref].delayed = 0;
            idata[xref].fetched = 0;

            xref_b = idata[xref].owner;
d1980 2
a1981 3
            if (!xref_b->fetch_handler) fetchpage_claim_nulls(xref_b);
            toolbars_update_status(xref_b, Toolbars_Status_GetPics);
          }
d1984 2
d1988 1
a1988 4
    /* Finally, make sure fetching is started for the given browser */

    if (!b->fetch_handler) fetchpage_claim_nulls(b);
    toolbars_update_status(b, Toolbars_Status_GetPics);
@


1.12
log
@First a minor warning - the various Res files are out of sync in this build.
Only the Browse resources are currently valid.

Added Utils.Icons - has a few archives inside containing the resources
(well, some of them) used to build various UI sprites for various builds.
Archived because these are unlikely to change much, and putting them on
CVS was a move to, well, archive the stuff...

SaveDBox objects vanquished and requirements in !Run[D] files removed. The
data save code fits much more neatly in amongst the data load protocol
stuff now (with the slight exception of having to split the SaveObject
source into SaveObject and SaveFile - the former handles multiple persistent
dialogues for Shift+Click on links and the like, the latter handles 'one at
a time' transient dialogues for save source and similar). Export Link is now
supported, too, and writes a 'proper' version URI file. You'll find that
double-clicking on old URI files will work as the URI handler picks them up,
whilst new version ones don't; however, dragging onto the browser will only
work with new version files. Note that support for saving and loading URL
files (ANT suite stuff) is present too, so old URI files can be typed as URL
files if you want to keep them working without modification - the URI
handler itself will hopefully support the defined URI file format soon;
double-clicking on old URI files will stop working at that point. Note
there are *lots* of changes in every Res file to support all this. This may
all seem a bit pointless to some, but the changes do in fact make it very
easy to add new save dialogues all over the place. Certainly much easier
than with the previous system, anyway. In fact, post script, image
'save as sprite' took about half an hour, which I hope proves the worth
of the new system.

Merged in newer hotlist code with support for drag cancelling with Escape
(all relevant Res files appropriately updated) and cancelling scrolling
when you've reached the window scroll limit. Had to move some of the
Wimp message handling stuff to the central Protocols source, as clashes
were occuring, and also the hotlist routines were using independent saving
code - a lot of duplicated effort. This was fair enough as at the time the
Hotlist code was written, the Save code couldn't be used in the way it is
now.

New Save Source and Print buttons on the toolbar of some builds.

Phoenix Sprites file made more efficient - the Acorn base section has been
split from the animated upper region. Browse build has a new grey fade
sprite at the back, which is less grainy than the previous one and only
uses 16 colours (with a 16 greyscale palette).

Not really a bug, bug the routine to start an image fetch for INPUT
TYPE=IMAGE forms items only did so if the src field (or equivalent, for
this tag type) was non-NULL. In fact, you should always call image_new_image
and let that handle the rest, otherwise other sections of the code will fail
as they try to obtain an image number for a given HStream and get -1 back.
This problem only generally manifested itself when loading an HTML file to
the browser straight from an application, as many src fields become NULL
when the relativisation routines find nothing to relativise to...

Authentication got broken somewhere along the line - this has been fixed
(in HTMLLib and the browser).

Ctrl+Click on a cross referenced image updates *all* copies, not just the
one with the image data attached.

Next big step: Rip up TBEvents.h and rebuild that whole approach somewhat.
To all those working on the code, my apologies but this means all Res files
will receive a very large number of alterations and there will be extensive
code changes too (mostly naming convention stuff), in more or less all
source files. I am endeavouring to ensure that the new numberspace
convention does not clash with the work being done by Kevin on
internationalisation.
@
text
@d90 2
d3473 1
a3473 1
      if (idata[i].istore && idata[i].istore->width > 0)
d4432 14
a4445 1
/* image_export_sprite()                         */
d4447 19
a4465 2
/* Saves an image represented by the given token */
/* as a sprite at the given path.                */
d4467 7
a4473 1
/* Parameters: Pointer to the path to save to;   */
d4475 2
a4476 2
/*             Pointer to a browser_data struct  */
/*             that owns the image;              */
d4481 3
d4486 1
a4486 1
_kernel_oserror * image_export_sprite(char * path, browser_data * b, HStream * image)
d4504 1
a4504 1
              "In image_export_foreground_sprite, can't find an image that is represented by the token %p for the browser %p.",
d4508 1
a4508 1
      return &erb;
d4512 1
a4512 1
    return NULL;
d4515 4
a4518 1
  /* Must have image data...! */
d4520 28
a4547 1
  if (!idata[i].istore || !idata[i].istore->DumpSprite)
d4592 1
a4592 1
  return -1;
d4594 1
@


1.11
log
@Very long log entry alert - but hey, beats 'Bug fixed' (sorry, Richard) ;-)

Open URL implementation more or less complete, though may undergo UI
revision at a later date to allow named frames to be targetted. Hope to use
the ideas in this code as the foundation for other general dialogues.

In token stream dump for TRACE builds, table head items were not indented
as far as they should have been - this is fixed; and manual toolbar redraw
routines have been removed. They never worked, were commented out, and
would never be used in that form anyway.

DragBox source added, but it isn't at all complete and won't work - this is
an 'in spare time' thing. We need custom drag boxes constrained to windows
for the hotlist, and unconstrained for frame border resizing... Hey ho.

Ancestor window extents match visible areas if there are frames (no more
scrolling framesets...!). Frame resizing works whilst new documents fetch
without pulling the extent down now. However, frame horizontal extents
never shrink until a reload which is nasty, and this is all due for a
rewrite. Frames border redrawing routine moved out of Redraw.c and into
Frames.c. Bug regarding the mouse rectangle and frame border widths
(rectangle was too large, so you could squash the edges) for edge-drag
frame resizes fixed.

Window width change reformat tolerance fixed; you could creep the window
width down or up forever without any reformat, and centred objects would
move but not be redrawn (thereby giving rise to subsequent redraw errors).

Filetype on objects saved through Shift+Click correct. Save Source dialogue
recognises if that source is plain text, rather than assuming HTML. A
browser that fetches a file remembers the old store size it had before the
save, so even though the data is now ditched, it reports the same amount of
data fetched afterwards (looked awful when this could, for example,
suddenly say '0' after a file save). Progress indicator is now fully aware
of one or many file saves inside a frameset and reports the number of
saves, a colon, and the cumulative saved data count, instead of reporting
the sum total of fetched data in all frames, including non-file save stuff
(note that for just 1 save, '1:' is not shown as a special case for the
most common condition). A bug related to this, where you could in fact only
do one fetch per frame*set*, has been corrected (only one fetch allowed per
frame still, this is unlikely to ever change).

Hotlist support added (D.Brown's source), with various bits of integration
and modification still in progress there. Note additions to the Messages
files. On the subject of Messages, the whole mucky business about what
goes in Messages or Choices (and a few bugs where lookup_choice was used
instead of lookup_token or vice versa) has been sorted out. Messages
contains, more or less, just that. Choices contains user configurable
stuff which generally can't mess things up too badly. A new file, Controls,
is a Messages file holding the non-user configurable choices, which can
generally make things go badly wrong if misused. A lot of these are tied
to the Res file. StrongED users can get these to automatically fold out
the various sections (EMail me for details). Sorry, but at the time of
writing, Zap doesn't do folding... =8*P

Two bugs with images. Asking for images to be shown in browser B when
browser A uses the same ones and was loaded first didn't work correctly,
and now does (a bit weird - browser A does the fetch and browser B does the
display...). Second one occurred when the background image was also used on
the page as a foreground image. This has been fixed by flagging background
images in the image_info structure, and checking this before cross
referencing. This bit also allowed the image_restart_fetches API to be
extended, so that just background or foreground images may be fetched if
they weren't already and the user asked the browser to show them. Before,
the whole lot had to be fetched together (so turning on 'display
backgrounds' will now kick off an image fetch if required, you don't
need to reload the page anymore).

Makefile copy options tweaked to be 'newer' (so if you're testing with some
temporary Choices file or something, it won't write over it at the end of
every export), and REMOTE_HOTLIST flag added for Customer builds - means
the Hotlist.c functions aren't needed; the old, hotlist-by-file method is
used. Added support for Customer build (see later), though there were very
few additions needed in practice.

Table printing fixed - in many ways it wasn't broken, it was image printing
causing the oddities ever since the global image pool was introduced (this
is, again, fixed). The 'reformat to fit page' option didn't work as coded
any more; tables store cell addresses in the HStreams, so you can't then do
a background reformat in a different browser. Hence, it now has to reformat
to the page width, print, then put the page back again, all in the actual
displayed browser. This doesn't feel as slow in use as it perhaps should,
considering what is going on... Note that a line of a defined fraction (see
Print.h) of page height will now split over page boundaries, so tall images
or tall tables don't cause problems now (aside from the obvious problem of
having the line split over a page at all!). There was a bug in the routine
to print from a given start point until 'n' pages had been filled, in that
it always filled 'n + 1' - now fixed. Finally, as part of the printing
tweaks, a new dialogue exists - PrintStyle - with a similarly named source
file added to deal with it.

Global history auto save / load done, but only to the Choices file path -
the whole browser is still strictly single user at present, with all the
extra work for a multiuser Customer environment yet to be done. This has
shown up a global history corruption problem which I haven't fixed yet.

Rationalising TBEvents.h - things are migrating out of it, and into more
appropriate sources (e.g. definitions relating to the Open URL dialogue are
going into OpenURL.h, etc.). Event codes were at one stage deliberately
diverged in numberspace from the component IDs of typical gadgets raising
the events, to avoid anyone getting confused and thinking the IDs and event
codes must match. However, this is in fact unlikely and it is much easier
to remember the fewer numbers that result from tying the two together where
possible. This has resulted in changes to event codes raised in the
following objects of all Res files: Authorise, Find, OpenURL, and
PrintStyle.

And finally - !Run[D] files for all variants updated to require the latest
toolbox and fetcher modules. All Res files updated for hotlists etc. and
sprites files updated appropriately. All Messages, Choices and Controls
files brought in sync., and an Customer build has been added (based on the
Desktop build binary with different resources).

That's all for now...
@
text
@d588 2
d625 1
a625 1
    idata[image].istore -> EndLoad(idata[image].istore);
d629 1
a629 1
    image_update_image(b, image, NULL);
d761 1
a761 1
  if (!url) return NULL;
d862 1
a862 1
  memset(&idata[nimages], 0, sizeof(image_info)); /* Precautionary catchall */
d1024 1
a1024 1
                     !b->reloading);                    /* 1 = Proxy can be used, 0 = can't */
d1053 6
a1058 6
        e =  fetch_get_raw_data(NULL,                   /* The browser_data structure */
                                idata[image].handle,    /* Fetch handle */
                                buffer,                 /* Buffer for fetched data */
                                sizeof(buffer),         /* Buffer's size */
                                &done,                  /* 'done' = 1 for fetch completed, else 0 */
                                &bytes);                /* Number of bytes put into buffer */
d1089 2
d1103 1
a1103 1
              e = idata[image].istore -> EndLoad(idata[image].istore);
d1115 1
a1115 1
              idata[image].istore -> EndLoad(idata[image].istore);
d1162 1
a1162 1
          image_update_image(b, image, NULL);
d1845 4
a1848 1
    int image;
d1880 12
d2343 2
a2344 2
      whole.xmax = idata[image].currw + 1;
      whole.ymax = idata[image].currh + 1;
d2349 5
d2355 12
a2366 4
      partial.xmin = (box->xmin  * idata[i].currw) / idata[image].currw;
      partial.ymin = (box->ymin  * idata[i].currh) / idata[image].currh;
      partial.xmax = ((box->xmax * idata[i].currw) / idata[image].currw) + 1;
      partial.ymax = ((box->ymax * idata[i].currh) / idata[image].currh) + 1;
d4427 95
@


1.10
log
@Really removed Font SWIs this time.
@
text
@a53 1
#include "TBEvents.h"
d61 1
d72 1
a72 1
static void              image_load_chunk             (browser_data * b, int image, char * buffer, int bytes);
d370 1
a370 1
static void image_load_chunk(browser_data * b, int image, char * buffer, int bytes)
d387 5
a391 1
  /* Report any errors as Continue-only in strict parser mode */
d394 3
a396 5
    if (e)
    {
      e->errnum = Utils_Error_Custom_Message;
      show_error_ret(e);
    }
d406 2
d774 4
a777 3
           idata[i].alloc                               && /* The image has data allocated for it.             */
           !strcmp(url, ddata + image_data_offset(b,i)) && /* This holds a URL which matches that passed in.   */
           idata[i].xref < 0                               /* The image doesn't cross reference things itself. */
d862 10
a871 7
  idata[nimages].owner   = b;
  idata[nimages].x       = -1;
  idata[nimages].y       = -1;

  idata[nimages].alloc   = size;
  idata[nimages].ualloc  = ulen;
  idata[nimages].isize   = 0;
d873 1
a873 2
  idata[nimages].token   = tp;
  idata[nimages].xref    = xref;
d973 2
d1010 19
a1028 18
        if (
             html_get(
                       ddata + image_data_offset(b,image), /* Document to fetch                */
                       NULL,                               /* Pointer to any extra data        */
                       (int *) &idata[image].handle,       /* Place to return the fetch handle */
                       URL_Method_http_GET,                /* Fetch method                     */

                       #ifndef SINGLE_USER
                         user.name,                        /* User name for MailServ, if using */
                       #else                               /* a multiuser version              */
                         NULL,
                       #endif

                       0,                                  /* 0 = Don't parse fetched data     */
                       !b->reloading                       /* 1 = Proxy can be used, 0 = can't */
                     )
           )
           image_abandon(b, image);
d1051 8
a1058 10
        if (
             fetch_get_raw_data(
                                 NULL,                   /* The browser_data structure */
                                 idata[image].handle,    /* Fetch handle */
                                 buffer,                 /* Buffer for fetched data */
                                 sizeof(buffer),         /* Buffer's size */
                                 &done,                  /* 'done' = 1 for fetch completed, else 0 */
                                 &bytes                  /* Number of bytes put into buffer */
                               )
           )
d1060 2
a1061 2
          image_abandon(b,image);
          return NULL;
d1072 8
a1079 1
          image_load_chunk(b, image, buffer, bytes);
a1098 2
              _kernel_oserror * e;

a1136 2
                _kernel_oserror * e;

d1242 11
a1252 13
        if (
             html_get_next_token(
                                  b,
                                  idata[image].handle,
                                  &remn,
                                  &sofar,
                                  &tptr,
                                  &waiting,
                                  &store,
                                  ddata + image_data_offset(b, image),
                                  1
                                )
           )
d1265 1
d1268 5
a1272 1
          return NULL;
d1416 24
a1439 1
              image_load_chunk(b, image, buffer, n1);
d1906 7
a1912 1
/*             relevant to the images.           */
d1915 1
a1915 1
void image_restart_fetches(browser_data * b)
d1919 3
a1921 1
    int image;
d1935 1
d1937 10
a1946 8
             !idata[image].fetched &&
             idata[image].delayed
           )
           ||
           (
             idata[image].fetched  &&
             !idata[image].success &&
             !idata[image].istore
d1950 30
a1979 3
        idata[image].success = 0;
        idata[image].delayed = 0;
        idata[image].fetched = 0;
d1983 2
d2099 1
d2105 1
a2732 1
  int                       bimage, image;
d2734 2
d2800 3
a2802 1
  /* set up not to plot background images.                         */
d2804 9
a2812 1
  if (noplot || idata[bimage].istore->transparent || b->plainback)
d2824 9
a2832 1
  if (b->plainback || noplot) return NULL;
d3046 1
d3052 1
d4074 1
a4074 1
      int h, temp, size;
d4096 1
a4096 2
                          &box->xmax
                         );
@


1.9
log
@Stopped Images.c using Font SWIs instead of fm functions
@
text
@d3975 1
d3990 8
a3997 12
      _swix(Font_SetFont, _IN(0), h);

      _swix(Font_StringWidth,
            _INR(1,5) | _OUT(2),

            tp->text,
            0x1000000,
            0x1000000,
            -1,
            strlen(tp->text),

            &box->xmax);
d4003 1
a4003 7
      _swix(Font_ReadInfo,
            _IN(0) | _OUT(2) | _OUT(4),

            h,

            &temp,
            &box->ymax);
d4005 1
a4005 1
      /* As well as subtracting temp (the y minimum coordinate */
d4010 1
a4010 1
      box->ymax -= temp;
@


1.8
log
@Modified to cope with withdrawal of #defines SELECT, INPUT etc.
Added right-align support.
@
text
@d3030 1
a3030 1
        int    h, ymin, xpos, vcent, stringwidth, stringheight, size;
d3049 8
a3056 12
        _swix(Font_SetFont, _IN(0), h);

        _swix(Font_StringWidth,
              _INR(1,5) | _OUT(2),

              tp->text,
              0x1000000,
              0x1000000,
              -1,
              strlen(tp->text),

              &stringwidth);
d3062 1
a3062 7
        _swix(Font_ReadInfo,
              _IN(0) | _OUT(2) | _OUT(4),

              h,

              &ymin,           /* Font BBox ymin */
              &stringheight);  /* Font BBox ymax */
d3064 1
a3064 1
        stringheight -= ymin;  /* So height = ymax - ymin */
d3073 1
a3073 1
        vcent = (box.ymax - stringheight) / 2 - ymin;
@


1.7
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@d896 1
a896 1
  if (!background && !(tp->style & INPUT))
@


1.6
log
@Quite a few general source changes throughout many files to sort out swapped
toolbars. There will be more work on this shortly. svcprint.c has been
modified to allow it to output to a file in PipeFS, so TML-less machines
can still use the standard browser debug routines (albeit in a less than
elegant fashion). Comments in that source file give more details. Plus a
few more bug fixes.
@
text
@d17 3
a19 1
/* Purpose: Image related functions                */
d22 1
d58 2
a59 1
#include "Fetch.h"
d66 1
d315 1
d325 1
d1042 8
a1049 8
             html_get_next_chunk(
                                  NULL,                   /* The browser_data structure */
                                  idata[image].handle,    /* Fetch handle */
                                  buffer,                 /* Buffer for fetched data */
                                  sizeof(buffer),         /* Buffer's size */
                                  &done,                  /* 'done' = 1 for fetch completed, else 0 */
                                  &bytes                  /* Number of bytes put into buffer */
                                )
d1058 3
a1060 3
        /* If the html_get_next_chunk() call resulted in data being fetched, */
        /* send that to the image library and reflect the fetched data in    */
        /* the status bar.                                                   */
d3392 1
d3454 1
a3454 1
/* image_count_fetches() above if you don't care */
d3499 1
d3531 1
d3553 1
a3553 1
      Printf("image_token_fetched: Exitting through image_fetched()\n");
d3802 1
d4212 1
d4215 1
d4220 1
a4315 2

/*************************************************/
@


1.5
log
@Fixed problems with unsourced images in tables and a couple of other bugs
here and there - nothing earth shattering... Just wanted to keep the CVS
source up to date.
@
text
@d1011 1
a1011 1
           idata[image].handle = 0;
d2752 1
d2772 5
d2778 1
a2778 3
            - (float) toolbars_button_height(b)
            - (float) toolbars_url_height(b)
            - (float) wimpt_dy();
d2813 1
d2819 7
a2825 1
    yorigin = -idata[image].y - toolbars_button_height(b) - toolbars_url_height(b) - wimpt_dy();
@


1.4
log
@Made INPUT type=image work
@
text
@d3007 1
a3007 1
      if (tp && tp->text)
d3905 1
d3927 1
d3929 1
d3931 1
d4020 8
d4034 1
d4059 1
d4061 1
d4230 60
@


1.3
log
@Supported client pull, through a generalised handing of the META tag.
@
text
@d889 1
a889 1
  if (!background)
d2297 1
a2297 1
          if (ISLINK(tp)) o = tp->maxlen * 2;
@


1.2
log
@Updated code to extract attributes from BODY tag, including event info.
@
text
@d103 4
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d733 1
a733 1
_kernel_oserror * image_new_image(browser_data * b, char * url, HStream * token, int background)
@

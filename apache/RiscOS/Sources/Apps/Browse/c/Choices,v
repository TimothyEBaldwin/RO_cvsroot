head	1.42;
access;
symbols
	Browse-2_16:1.42
	Browse-2_15:1.42
	Browse-2_14:1.42
	Browse-2_13:1.42
	Browse-2_12:1.42
	Browse-2_11:1.41
	Browse-2_10:1.41
	Browse-2_09:1.41
	ahodgkin_208_i4_2:1.41
	ahodgkin_208_i4:1.39
	ahodgkin_208_i3:1.39
	ahodgkin_208_i2:1.39
	ahodgkin_208_i1:1.38
	ahodgkin_207release:1.36
	ahodgkin_206release:1.34
	ahodgkin_205release:1.34
	ahodgkin_204release:1.33
	ahodgkin_202release:1.32
	ahodgkin_201release:1.31
	ahodgkin_200release:1.31
	ahodgkin_133beta:1.31
	ahodgkin_132beta:1.31
	ahodgkin_131beta:1.31
	ahodgkin_130beta:1.28
	ahodgkin_129:1.28
	ahodgkin_128beta:1.26
	ahodgkin_128alpha:1.24
	ahodgkin_127beta2:1.23
	ahodgkin_127beta:1.20
	ahodgkin_126beta:1.16
	ahodgkin_AW97patch:1.16
	ahodgkin_AW97:1.14;
locks; strict;
comment	@# @;


1.42
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.41;

1.41
date	2000.11.14.08.45.05;	author ahodgkin;	state Exp;
branches;
next	1.40;

1.40
date	2000.05.31.15.58.28;	author ahodgkin;	state Exp;
branches;
next	1.39;

1.39
date	2000.02.25.17.08.51;	author ahodgkin;	state Exp;
branches;
next	1.38;

1.38
date	99.09.02.13.10.14;	author ahodgkin;	state Exp;
branches;
next	1.37;

1.37
date	99.03.30.15.51.38;	author ahodgkin;	state Exp;
branches;
next	1.36;

1.36
date	98.10.13.16.33.59;	author ahodgkin;	state Exp;
branches;
next	1.35;

1.35
date	98.09.07.11.46.39;	author ahodgkin;	state Exp;
branches;
next	1.34;

1.34
date	98.04.21.10.38.12;	author ahodgkin;	state Exp;
branches;
next	1.33;

1.33
date	98.04.16.08.14.06;	author ahodgkin;	state Exp;
branches;
next	1.32;

1.32
date	98.03.20.12.12.25;	author ahodgkin;	state Exp;
branches;
next	1.31;

1.31
date	98.01.15.11.27.21;	author dbrown;	state Exp;
branches;
next	1.30;

1.30
date	98.01.06.11.18.27;	author dbrown;	state Exp;
branches;
next	1.29;

1.29
date	98.01.06.09.28.54;	author dbrown;	state Exp;
branches;
next	1.28;

1.28
date	97.12.12.15.12.29;	author dbrown;	state Exp;
branches;
next	1.27;

1.27
date	97.12.12.11.17.43;	author ahodgkin;	state Exp;
branches;
next	1.26;

1.26
date	97.12.03.11.11.12;	author dbrown;	state Exp;
branches;
next	1.25;

1.25
date	97.12.03.10.39.16;	author dbrown;	state Exp;
branches;
next	1.24;

1.24
date	97.12.01.12.01.48;	author dbrown;	state Exp;
branches;
next	1.23;

1.23
date	97.11.21.15.17.11;	author dbrown;	state Exp;
branches;
next	1.22;

1.22
date	97.11.21.14.43.27;	author dbrown;	state Exp;
branches;
next	1.21;

1.21
date	97.11.21.13.10.47;	author dbrown;	state Exp;
branches;
next	1.20;

1.20
date	97.11.20.16.04.27;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	97.11.20.10.22.42;	author dbrown;	state Exp;
branches;
next	1.18;

1.18
date	97.11.19.10.28.46;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	97.11.05.15.25.51;	author kbracey;	state Exp;
branches;
next	1.16;

1.16
date	97.10.17.14.15.51;	author dbrown;	state Exp;
branches;
next	1.15;

1.15
date	97.10.17.11.08.14;	author dbrown;	state Exp;
branches;
next	1.14;

1.14
date	97.10.16.13.23.06;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.10.15.15.09.06;	author dbrown;	state Exp;
branches;
next	1.12;

1.12
date	97.10.13.12.55.13;	author dbrown;	state Exp;
branches;
next	1.11;

1.11
date	97.10.08.13.56.10;	author dbrown;	state Exp;
branches;
next	1.10;

1.10
date	97.10.08.11.42.28;	author dbrown;	state Exp;
branches;
next	1.9;

1.9
date	97.10.07.16.22.49;	author dbrown;	state Exp;
branches;
next	1.8;

1.8
date	97.10.07.13.18.29;	author dbrown;	state Exp;
branches;
next	1.7;

1.7
date	97.10.07.12.14.27;	author dbrown;	state Exp;
branches;
next	1.6;

1.6
date	97.10.07.10.41.18;	author dbrown;	state Exp;
branches;
next	1.5;

1.5
date	97.10.03.09.18.59;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.10.02.14.18.03;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.10.01.17.17.54;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.10.01.09.13.19;	author dbrown;	state Exp;
branches;
next	1.1;

1.1
date	97.09.29.11.24.10;	author dbrown;	state Exp;
branches;
next	;


desc
@@


1.42
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Choices.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Functions related to the Chices dialogue box and  */
/*          associated sub-windows.                           */
/*                                                            */
/* Author:  D.T.A.Brown.                                      */
/*                                                            */
/* History: 23-Sep-1997 (DTAB): Created.                      */
/*          18-Apr-1998 (ADH): choices_find_component will    */
/*                             complain if the same thing is  */
/*                             found more than once in TRACE  */
/*                             builds.                        */
/*          25-May-2000 (ADH): 64-wide comments adopted.      */
/*          17-Feb-2006 (ADH): New internal function order.   */
/**************************************************************/

#include <stdlib.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>
#include <tboxlibs/menu.h>
#include <tboxlibs/colourdbox.h>
#include <tboxlibs/fontmenu.h>

#include "ToolAction.h" /* Local copy that doesn't use OSLib */

#include <ImageLib/imagetrans.h>

#include "Global.h"
#include "FromROSLib.h"
#include "Utils.h"

#include "ChoiceDefs.h"
#include "Encoding.h"
#include "FetchPage.h"
#include "FontManage.h"
#include "History.h"
#include "Menus.h"
#include "NestWimp.h"
#include "Redraw.h"
#include "Reformat.h"
#include "Save.h"
#include "URLutils.h"
#include "Windows.h"

#include "Choices.h"

/* Local compile-time options */

#define CREATE_ONLY_ONCE

/* Local variables */

static char          consonant     []        = "bcdfghjklmnpqrstvwxyz";
static char          vowel         []        = "aeiou";
static int           rubbish_seed;

/* Used to prevent rounding errors when converting to/from font 16ths of a point to decimal */

static unsigned char todecimal     []        = {0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9};
static unsigned char fromdecimal   []        = {0, 2, 4, 5, 7, 8, 10, 12, 13, 15};

static ObjectId *    subwindows              = NULL;
static int           current_subwindow       = 0;
static ObjectId      colourdbox_id           = 0;

static ComponentId   save_ticked             = NULL_ComponentId;
static ComponentId   disp_ticked             = NULL_ComponentId;
static ComponentId   pbrk_ticked             = NULL_ComponentId;
static ComponentId   urih_ticked             = NULL_ComponentId;
static ComponentId   cook_ticked             = NULL_ComponentId;
static ComponentId   refe_ticked             = NULL_ComponentId;
static ComponentId   jpeg_ticked             = NULL_ComponentId;
static ComponentId   bord_ticked             = NULL_ComponentId;
static ComponentId   plug_ticked             = NULL_ComponentId;
static ComponentId   time_ticked             = NULL_ComponentId;

#ifdef JAVASCRIPT
  static ComponentId wino_ticked             = NULL_ComponentId;
  static ComponentId winc_ticked             = NULL_ComponentId;
#endif

static int           history_radio           = 0; /* 0 - page history, 1 - image history */

static int           expiry_age_greyed       = 0;
static int           max_size_greyed         = 0;
static int           image_expiry_age_greyed = 0;
static int           image_max_size_greyed   = 0;

static int           choices_modechanged     = 0;

static fm_typeface * new_typefaces           = NULL;

#ifdef CREATE_ONLY_ONCE
  static int         objects_created         = 0;
#endif

/* Enumeration describing known units of time */

typedef enum choices_time
{
  choices_time_NONE    = -1,
  choices_time_MINUTES = 0,
  choices_time_HOURS   = 1,
  choices_time_DAYS    = 2,
  choices_time_WEEKS   = 3,
  choices_time_MONTHS  = 4,
}
choices_time_e;

/* Records of units chosen for various menus */

static choices_time_e image_expiry_units   = choices_time_NONE;
static choices_time_e history_expiry_units = choices_time_NONE;

/* Type used to hold a mapping between a menu entry component ID */
/* and the value of a Choices item.                              */

typedef struct choices_map
{
  ComponentId id;
  int         value;
}
choices_map_t;

/* Map for the hotlist display type menu */

static choices_map_t map_hldisplay[] =
       {
         { CD_DispDesc,            Choices_HotlistType_Descriptions  },
         { CD_DispURL,             Choices_HotlistType_URLs          },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the history display type menu */

static choices_map_t map_hidisplay[] =
       {
         { CD_DispDesc,            0                                 },
         { CD_DispURL,             1                                 },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the hotlist save frequency menu */

static choices_map_t map_hlsave[] =
       {
         { CD_SaveNever,           Choices_SaveHotlist_Never         },
         { CD_SaveOnExit,          Choices_SaveHotlist_Once          },
         { CD_SaveAlways,          Choices_SaveHotlist_Always        },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the history save frequency menu */

static choices_map_t map_hisave[] =
       {
         { CD_SaveNever,           Choices_SaveHistory_Never         },
         { CD_SaveOnExit,          Choices_SaveHistory_Once          },
         { CD_SaveAlways,          Choices_SaveHistory_Always        },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the image history save frequency menu */

static choices_map_t map_hiimsave[] =
       {
         { CD_SaveNever,           Choices_SaveImageHistory_Never    },
         { CD_SaveOnExit,          Choices_SaveImageHistory_Once     },
         { CD_SaveAlways,          Choices_SaveImageHistory_Always   },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the page break menu */

static choices_map_t map_pagebreak[] =
       {
         { CD_PBreakNever,         0                                 },
         { CD_PBreakH1,            1                                 },
         { CD_PBreakH2,            2                                 },
         { CD_PBreakH3,            3                                 },
         { CD_PBreakH4,            4                                 },
         { CD_PBreakH5,            5                                 },
         { CD_PBreakH6,            6                                 },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the URI handler menu */

static choices_map_t map_uri[] =
       {
         { CD_URINever,            Choices_URI_Never                 },
         { CD_URIProcOnly,         Choices_URI_RequestsOnly          },
         { CD_URIBroadUk,          Choices_URI_BroadcastUnknowns     },
         { CD_URIProcAndBroad,     Choices_URI_UnknownsAndRequests   },
         { CD_URIProcAndEvery,     Choices_URI_EverythingAndRequests },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the cookie menu */

static choices_map_t map_cookie[] =
       {
         { CD_CookieReject,        Choices_Cookies_Reject            },
         { CD_CookiePrompt,        Choices_Cookies_Prompt            },
         { CD_CookieAccept,        Choices_Cookies_Accept            },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the referer menu */

static choices_map_t map_referer[] =
       {
         { CD_RefererNever,        Choices_SendReferer_Never         },
         { CD_RefererAlways,       Choices_SendReferer_Always        },
         { CD_RefererWhenHTTP,     Choices_SendReferer_WhenHTTP      },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the JPEG menu */

static choices_map_t map_jpeg[] =
       {
         { CD_JPEGOS,              Choices_SupportPJPEG_OS           },
         { CD_JPEGBoth,            Choices_SupportPJPEG_Both         },
         { CD_JPEGInternal,        Choices_SupportPJPEG_Internal     },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the outer table border menu */

static choices_map_t map_table_inner[] =
       {
         { CD_TableBorderNone,     Choices_TableOuter_Never          },
         { CD_TableBorder2D,       Choices_TableOuter_Always2D       },
         { CD_TableBorder3D,       Choices_TableOuter_Always3D       },
         { CD_TableBorderAuto,     Choices_TableOuter_Auto           },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the inner table border menu */

static choices_map_t map_table_outer[] =
       {
         { CD_TableBorderNone,     Choices_TableInner_Never          },
         { CD_TableBorder2D,       Choices_TableInner_Always2D       },
         { CD_TableBorder3D,       Choices_TableInner_Always3D       },
         { CD_TableBorderAuto,     Choices_TableInner_Auto           },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the plug-in launch menu */

static choices_map_t map_plugin[] =
       {
         { CD_PlugDont,            Choices_PlugIns_Never             },
         { CD_PlugRedraw,          Choices_PlugIns_Viewed            },
         { CD_PlugASAP,            Choices_PlugIns_ASAP              },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the time type (units) menu */

static choices_map_t map_timetype[] =
       {
         { CD_TimeMinutes,         (int) choices_time_MINUTES        },
         { CD_TimeHours,           (int) choices_time_HOURS          },
         { CD_TimeDays,            (int) choices_time_DAYS           },
         { CD_TimeWeeks,           (int) choices_time_WEEKS          },
         { CD_TimeMonths,          (int) choices_time_MONTHS         },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the header/footer special text menu (actually forming */
/* indices into the text insertion array below, with additional  */
/* offsets from the special text sub-menu).                      */

static choices_map_t map_hfspecial[] =
       {
         { CD_HFTextPageNumber,    0                                 },
         { CD_HFTextTotalPages,    5                                 },
         { CD_HFTextURL,           10                                },
         { CD_HFTextTitleBlank,    11                                },
         { CD_HFTextTitleURL,      12                                },
         { CD_HFTextDate,          13                                },
         { CD_HFTextHeadings,      14                                },
         { CD_HFTextExclaimation,  15                                },
         { NULL_ComponentId,       0                                 }
       };

/* Map for the header/footer special text sub-menu (actually */
/* additions to indices in the map_hfspecial array above).   */

static choices_map_t map_hfspecsub[] =
       {
         { CD_HFSub123,            0                                 },
         { CD_HFSubiii,            1                                 },
         { CD_HFSubIII,            2                                 },
         { CD_HFSubaaa,            3                                 },
         { CD_HFSUbAAA,            4                                 },
         { NULL_ComponentId,       0                                 }
       };

/* A similar map to the special text menus above, this time for */
/* date format strings.                                         */

static choices_map_t map_hfdate[] =
       {
         { CD_HFDate24Hour,        0                                 },
         { CD_HFDate12Hour,        1                                 },
         { CD_HFDateAMPM,          2                                 },
         { CD_HFDateMinutes,       3                                 },
         { CD_HFDateSeconds,       4                                 },
         { CD_HFDateCentiseconds,  5                                 },
         { CD_HFDateFullWeekday,   6                                 },
         { CD_HFDateShortWeekday,  7                                 },
         { CD_HFDateNumWeekday,    8                                 },
         { CD_HFDateDayOfMonth,    9                                 },
         { CD_HFDateOrdinalPS,     10                                },
         { CD_HFDateFullMonth,     11                                },
         { CD_HFDateShortMonth,    12                                },
         { CD_HFDateNumMonth,      13                                },
         { CD_HFDateCentury,       14                                },
         { CD_HFDateYear,          15                                },
         { CD_HFDateWeekOfYear,    16                                },
         { CD_HFDateDayOfYear,     17                                },
         { CD_HFDateTimezone,      18                                },
         { CD_HFDateExclaimation,  19                                },
         { CD_HFDatePercent,       20                                },
         { NULL_ComponentId,       0                                 }
       };

#ifdef JAVASCRIPT

  /* Map for the JS 'window.open' menu */

  static choices_map_t map_win_open[] =
         {
           { CD_WinOpenAllow,      Choices_JSWindowOpen_Allow        },
           { CD_WinOpenReplace,    Choices_JSWindowOpen_Replace      },
           { CD_WinOpenQuery,      Choices_JSWindowOpen_Query        },
           { CD_WinOpenSuppress,   Choices_JSWindowOpen_Suppress     },
           { NULL_ComponentId,     0                                 }
         };

  /* Map for the JS 'window.close' menu */

  static choices_map_t map_win_close[] =
         {
           { CD_WinCloseAlways,    Choices_JSWindowClose_Always      },
           { CD_WinCloseSometimes, Choices_JSWindowClose_Sometimes   },
           { CD_WinCloseQuery,     Choices_JSWindowClose_Query       },
           { CD_WinCloseSuppress,  Choices_JSWindowClose_Suppress    },
           { NULL_ComponentId,     0                                 }
         };

#endif

/* Array of items inserted by the special text menu plus offsets */
/* from the special text sub-menu.                               */

const char * restrict special_text[] = {
                                         "!p1",
                                         "!pi",
                                         "!pI",
                                         "!pa",
                                         "!pA",

                                         "!P1",
                                         "!Pi",
                                         "!PI",
                                         "!Pa",
                                         "!PA",

                                         "!u",
                                         "!tk",
                                         "!ta",
                                         "!dp",
                                         "!dm",
                                         "!s",
                                         "!!"
                                       };

const char * restrict special_date[] = {
                                         "!24",
                                         "!12",
                                         "!am",
                                         "!mi",
                                         "!se",
                                         "!cs",
                                         "!we",
                                         "!w3",
                                         "!wn",
                                         "!dy",
                                         "!st",
                                         "!mo",
                                         "!m3",
                                         "!mn",
                                         "!ce",
                                         "!yr",
                                         "!wk",
                                         "!dn",
                                         "!tz",
                                         "!!",
                                         "!%"
                                       };

/* Lifecycle support */

static void              choices_internal_shutdown              (void);
static _kernel_oserror * choices_show_subwindow                 (ObjectId choices_window, int subwindow);
static void              choices_delete_subwindows              (void);

static int               choices_open_choice_window             (int eventcode, WimpPollBlock * event, IdBlock * id_block, void * handle);

static _kernel_oserror * choices_set_contents                   (void);
static _kernel_oserror * choices_get_contents                   (void);

/* Main dialogue box button handlers */

static int               choices_set_button_handler             (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_cancel_button_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_save_button_handler            (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Colour choices 'fake page' routines */

static int               choices_redraw_fakepage_handler        (int eventcode, WimpPollBlock * event, IdBlock * id_block, void * handle);
static _kernel_oserror * choices_write_rubbish                  (fm_face h,                int xpos, int ypos, int maxxish,   int forecolour, int backcolour, int * newxpos, int seed);
static _kernel_oserror * choices_draw_string                    (fm_face h, char * string, int xpos, int ypos, int underline, int forecolour, int backcolour, int * newxpos);

/* Radio group handlers */

static int               choices_radio_click_handler            (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_history_radio_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_printing_layout_radio_change   (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_printing_h_or_f_radio_change   (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);

/* Option button handlers */

static int               choices_option_state_handler           (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Menu handling support */

static ComponentId       choices_map_choice_to_entry
                         (
                           int                            choices_value,
                           const choices_map_t * restrict map
                         );

static int               choices_map_entry_to_choice
                         (
                           ComponentId                    menu_entry,
                           const choices_map_t * restrict map
                         );

static _kernel_oserror * choices_menu_open_by_popup
                         (
                           ObjectId               pane,
                           ComponentId            button,
                           const char  * restrict menu_name,
                           ObjectId    *          menu_object
                         );

static _kernel_oserror * choices_menu_popup_handler
                         (
                           ObjectId                       pane,
                           ComponentId                    button,
                           const char          * restrict menu_name,
                           int                            choices_value,
                           ComponentId         * restrict ticked_entry,
                           const choices_map_t * restrict map
                         );

static _kernel_oserror * choices_menu_selection_handler
                         (
                           ObjectId                       menu_object,
                           ComponentId                    selected_entry,
                           const char          * restrict menu_name,
                           int                 * restrict choices_value,
                           ComponentId         * restrict ticked_entry,
                           ComponentId                    associated_display_field,
                           const choices_map_t * restrict map
                         );

static _kernel_oserror * choices_update_popup_menu_display_field
                         (
                           ComponentId            display_field,
                           ComponentId            menu_entry,
                           const char  * restrict menu_name
                         );

/* Menu pop-up button handlers */

static int               choices_display_popup_handler          (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_save_popup_handler             (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_pagebreak_popup_handler        (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_uri_popup_handler              (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_cookie_popup_handler           (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_referer_popup_handler          (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_jpeg_popup_handler             (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_table_border_popup_handler     (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_plugin_popup_handler           (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_timetype_popup_handler         (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);

#ifdef JAVASCRIPT
  static int             choices_win_open_popup_handler         (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
  static int             choices_win_close_popup_handler        (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
#endif

static int               choices_font_button_handler            (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_encoding_button_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_button_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Simple menu selection handlers */

static int               choices_display_selection_handler      (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_save_selection_handler         (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_pagebreak_selection_handler    (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_uri_selection_handler          (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_cookie_selection_handler       (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_referer_selection_handler      (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_jpeg_selection_handler         (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_table_border_selection_handler (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_plugin_selection_handler       (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_timetype_selection_handler     (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_hfspecial_selection_handler    (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_hfspecsub_selection_handler    (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
static int               choices_hfdate_selection_handler       (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);

#ifdef JAVASCRIPT
  static int             choices_win_open_selection_handler     (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
  static int             choices_win_close_selection_handler    (const int eventcode, const ToolboxEvent * restrict event, const IdBlock * restrict idb, const void * restrict handle);
#endif

static int               choices_font_selected_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_selected_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Menu closed handlers */

static int               choices_font_closed_handler            (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_closed_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/* Menu-related display field and number range updating */

static _kernel_oserror * choices_set_display_field              (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_save_field                 (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_pagebreak_field            (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_uri_field                  (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_cookie_field               (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_referer_field              (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_jpeg_field                 (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_table_border_field         (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_plugin_field               (ComponentId display_field, int choices_value);
static _kernel_oserror * choices_set_timetype_field             (ComponentId display_field, int choices_value);

#ifdef JAVASCRIPT
  static _kernel_oserror * choices_set_win_open_field           (ComponentId display_field, int choices_value);
  static _kernel_oserror * choices_set_win_close_field          (ComponentId display_field, int choices_value);
#endif

/* Time menu utilities */

static choices_time_e    choices_return_appropriate_timetype    (int seconds);
static int               choices_seconds_to_typed_time          (int secs, choices_time_e timetype);
static int               choices_typed_time_to_seconds          (int time, choices_time_e timetype);
static int               choices_get_range_of_typed_time        (choices_time_e timetype);

/* Greying/ungreying items, with related actions */

static _kernel_oserror * choices_batch_gadget_state             (const ComponentId * restrict array, int state);

static void              choices_set_tables_greyed              (int state);
static _kernel_oserror * choices_set_printing_greyed            (void);
static void              choices_set_frame_related_greyed       (ObjectId window, int state);
static void              choices_set_fonts_greyed               (int state);

static void              choices_set_expiry_age                 (ObjectId window);
static void              choices_set_expiry_age_greyed          (int state);
static void              choices_set_im_expiry_age              (ObjectId window);
static void              choices_set_im_expiry_age_greyed       (int state);
static void              choices_set_max_size                   (ObjectId window);
static void              choices_set_max_size_greyed            (ObjectId window, int state);
static void              choices_set_im_max_size                (ObjectId window);
static void              choices_set_im_max_size_greyed         (ObjectId window, int state);

#ifdef JAVASCRIPT
  static void            choices_set_js_watchdog_greyed         (int state);
  static void            choices_set_js_all_greyed              (int state);
#endif

/* Finding gadgets */

static ObjectId          choices_find_component                 (ComponentId component);

/* Setting gadget parameters */

static _kernel_oserror * choices_displayfield_set_value         (const unsigned int flags, const ObjectId window, const ComponentId writable, const char * restrict text);
static _kernel_oserror * choices_writablefield_set_value        (const unsigned int flags, const ObjectId window, const ComponentId writable, const char * restrict text);
static _kernel_oserror * choices_writablefield_add_text         (const unsigned int flags, const ObjectId window, const ComponentId writable, const char * restrict text);
static _kernel_oserror * choices_button_set_validation          (const unsigned int flags, const ObjectId window, const ComponentId writable, const char * restrict text);
static _kernel_oserror * choices_numberrange_set_value          (const unsigned int flags, const ObjectId window, const ComponentId writable, const int value);
static _kernel_oserror * choices_colour_set_component           (ObjectId window, ComponentId component, int colour);

/* Reading gadget parameters */

static _kernel_oserror * choices_get_menu_entry_text            (const char * restrict menuname, ComponentId compid, char ** tempstring);
static _kernel_oserror * choices_retrieve_text_item             (ComponentId writable_field, char ** choice_to_update);

/* Miscellaneous utility functions */

static void              choices_modified_font                  (char * orig, char * mod, char * buffer);
int                      choices_clip_to_min_max                (int value, int min, int max);

/**************************************************************/
/* choices_to_be_shown()                                      */
/*                                                            */
/* Called when the ECDToBeShown event is generated.           */
/*                                                            */
/* Creates all the subwindow dialogues and fills them in with */
/* appropriate values. Registers all additional event         */
/* handlers used while the choices dialogue is visible.       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int choices_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror       *e;
  ObjectId              window;
  int                   subwindow_tobeshown;

  dprintf(("Choi", "choices_to_be_shown: Called\n"));

  /* In multiuser builds, need to be logged in - otherwise, close */
  /* the dialogue!                                                */

  #ifndef SINGLE_USER

    if (!logged_in)
    {
      toolbox_hide_object(0, idb->self_id);
      return 1;
    }

  #endif

  if (choices_windowid != NULL_ObjectId) return 1;

  _swix(OS_ReadMonotonicTime, _OUT(0), &rubbish_seed);

  choices_windowid = idb->self_id;

  /* Allocate block for holding subwindows ObjectIds */

  if (!subwindows)
  {
    subwindows = malloc(sizeof(ObjectId)*CDNoSubwindows);

    /* If hide object doesn't work, things are really screwed */

    if (!subwindows)
    {
      ChkError(toolbox_hide_object(0, idb->self_id));
      return 1;
    }
  }

  if (!new_choices)
  {
    new_choices = malloc(sizeof(global_choices));

    if (!new_choices)
    {
      ChkError(toolbox_hide_object(0, idb->self_id));
      return 1;
    }
    else
    {
      memcpy(new_choices, &choices, sizeof(global_choices));
    }
  }

  if (!new_typefaces)
  {
    new_typefaces = calloc(sizeof(fm_typeface), 3);

    if (!new_typefaces)
    {
      free(new_choices);
      new_choices = NULL;
      free(subwindows);
      subwindows  = NULL;
    }
    else
    {
      fm_typeface * tfptr;

      tfptr = fm_find_typeface("serif");
      memcpy(&new_typefaces[0], tfptr, sizeof(fm_typeface));
      tfptr = fm_find_typeface("sans");
      memcpy(&new_typefaces[1], tfptr, sizeof(fm_typeface));
      tfptr = fm_find_typeface("fixed");
      memcpy(&new_typefaces[2], tfptr, sizeof(fm_typeface));
    }
  }

  /* Create all choices subwindows.  Set their ObjectIds to NULL if they cannot be created */

  /* Might be worth changing this to a loop in the future */

  #ifdef CREATE_ONLY_ONCE
  if (!objects_created)
  {
  #endif
    e = toolbox_create_object(0, "ChSub0", &subwindows[0]);  if (e) subwindows[0]  = NULL;
    e = toolbox_create_object(0, "ChSub1", &subwindows[1]);  if (e) subwindows[1]  = NULL;
    e = toolbox_create_object(0, "ChSub2", &subwindows[2]);  if (e) subwindows[2]  = NULL;
    e = toolbox_create_object(0, "ChSub3", &subwindows[3]);  if (e) subwindows[3]  = NULL;
    e = toolbox_create_object(0, "ChSub4", &subwindows[4]);  if (e) subwindows[4]  = NULL;
    e = toolbox_create_object(0, "ChSub5", &subwindows[5]);  if (e) subwindows[5]  = NULL;
    e = toolbox_create_object(0, "ChSub6", &subwindows[6]);  if (e) subwindows[6]  = NULL;
    e = toolbox_create_object(0, "ChSub7", &subwindows[7]);  if (e) subwindows[7]  = NULL;
    e = toolbox_create_object(0, "ChSub8", &subwindows[8]);  if (e) subwindows[8]  = NULL;
    e = toolbox_create_object(0, "ChSub9", &subwindows[9]);  if (e) subwindows[9]  = NULL;
    e = toolbox_create_object(0, "ChSubA", &subwindows[10]); if (e) subwindows[10] = NULL;
  #ifdef CREATE_ONLY_ONCE
  }
  #endif

  subwindow_tobeshown = current_subwindow;
  current_subwindow   = CDSubNone;

  ChkError(choices_show_subwindow(idb->self_id, subwindow_tobeshown));

  ChkError(radiobutton_set_state(0, idb->self_id, CDFirstSubRadio + subwindow_tobeshown, 1));

  ChkError(choices_set_contents());

  /* Register choices event handlers. Make sure any additions here */
  /* are matched by deregistration in choices_internal_shutdown,   */
  /* just underneath this function.                                */

  #ifdef CREATE_ONLY_ONCE
  e = NULL;

  if (!objects_created)
  {
  #endif
    e         = event_register_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,            NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDSet,                     choices_set_button_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,            NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,        NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_LayoutRadios,          (ToolboxEventHandler *)
                                                                              choices_printing_layout_radio_change,   NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HFRadios,              (ToolboxEventHandler *)
                                                                              choices_printing_h_or_f_radio_change,   NULL);

    if (!e) e = event_register_toolbox_handler(-1, ECD_HlDispBt,              (ToolboxEventHandler *)
                                                                              choices_display_popup_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiDispBt,              (ToolboxEventHandler *)
                                                                              choices_display_popup_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HlSaveBt,              (ToolboxEventHandler *)
                                                                              choices_save_popup_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiSaveBt,              (ToolboxEventHandler *)
                                                                              choices_save_popup_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiImSaveBt,            (ToolboxEventHandler *)
                                                                              choices_save_popup_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_PageBreakBt,           (ToolboxEventHandler *)
                                                                              choices_pagebreak_popup_handler,        NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_URIHandlerBt,          (ToolboxEventHandler *)
                                                                              choices_uri_popup_handler,              NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_CookieBt,              (ToolboxEventHandler *)
                                                                              choices_cookie_popup_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_RefererBt,             (ToolboxEventHandler *)
                                                                              choices_referer_popup_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_JPEGBt,                (ToolboxEventHandler *)
                                                                              choices_jpeg_popup_handler,             NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_TabInnerBordBt,        (ToolboxEventHandler *)
                                                                              choices_table_border_popup_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_TabOuterBordBt,        (ToolboxEventHandler *)
                                                                              choices_table_border_popup_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_ObjPlugBt,             (ToolboxEventHandler *)
                                                                              choices_plugin_popup_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiAgeTypeBt,           (ToolboxEventHandler *)
                                                                              choices_timetype_popup_handler,         NULL);

    #ifdef JAVASCRIPT
      if (!e) e = event_register_toolbox_handler(-1, ECD_WinOpenBt,           (ToolboxEventHandler *)
                                                                              choices_win_open_popup_handler,         NULL);
      if (!e) e = event_register_toolbox_handler(-1, ECD_WinCloseBt,          (ToolboxEventHandler *)
                                                                              choices_win_close_popup_handler,        NULL);
    #endif


    if (!e) e = event_register_toolbox_handler(-1, ECDDispMenuClick,          (ToolboxEventHandler *)
                                                                              choices_display_selection_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDSaveMenuClick,          (ToolboxEventHandler *)
                                                                              choices_save_selection_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDPageBreakMenuClick,     (ToolboxEventHandler *)
                                                                              choices_pagebreak_selection_handler,    NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDURIMenuClick,           (ToolboxEventHandler *)
                                                                              choices_uri_selection_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDCookieMenuClick,        (ToolboxEventHandler *)
                                                                              choices_cookie_selection_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDRefererMenuClick,       (ToolboxEventHandler *)
                                                                              choices_referer_selection_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDJPEGMenuClick,          (ToolboxEventHandler *)
                                                                              choices_jpeg_selection_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDBordMenuClick,          (ToolboxEventHandler *)
                                                                              choices_table_border_selection_handler, NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDPlugMenuClick,          (ToolboxEventHandler *)
                                                                              choices_plugin_selection_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDTimeMenuClick,          (ToolboxEventHandler *)
                                                                              choices_timetype_selection_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDHFSpecialMenuClick,     (ToolboxEventHandler *)
                                                                              choices_hfspecial_selection_handler,    NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDHFSpecSubMenuClick,     (ToolboxEventHandler *)
                                                                              choices_hfspecsub_selection_handler,    NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDHFDateMenuClick,        (ToolboxEventHandler *)
                                                                              choices_hfdate_selection_handler,       NULL);

    #ifdef JAVASCRIPT
      if (!e) e = event_register_toolbox_handler(-1, ECDWinOpenMenuClick,     (ToolboxEventHandler *)
                                                                              choices_win_open_selection_handler,     NULL);
      if (!e) e = event_register_toolbox_handler(-1, ECDWinCloseMenuClick,    (ToolboxEventHandler *)
                                                                              choices_win_close_selection_handler,    NULL);
    #endif


    if (!e) e = event_register_toolbox_handler(-1, ECDHiRadioClick,           choices_history_radio_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,            NULL);

    if ((window = choices_find_component(CD_FakePage)) != 0)
    {
      if (!e) e = event_register_wimp_handler(window, Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
    }
    if (!e) e = event_register_wimp_handler(idb->self_id, Wimp_EOpenWindow, choices_open_choice_window, NULL);
  #ifdef CREATE_ONLY_ONCE
  }
  #endif

  /* Deal with errors */

  if (e)
  {
    choices_internal_shutdown();
    ChkError(e);
  }

  #ifdef CREATE_ONLY_ONCE
  objects_created = 1;
  #endif

  return 1;
}

/**************************************************************/
/* choices_internal_shutdown()                                */
/*                                                            */
/* Shut down the Choices system. Should be called if an error */
/* occurs when setting up or if CREATE_ONLY_ONCE is undefined */
/* and the window is closing. If CREATE_ONLY_ONCE is defined, */
/* the objects_created flag is cleared to endeavour to ensure */
/* internal consistency.                                      */
/**************************************************************/

static void choices_internal_shutdown(void)
{
  ObjectId window;

  /* Clear the "created" flag if relevant */

  #ifdef CREATE_ONLY_ONCE
    objects_created = 0;
  #endif

  /* Delete all subwindow objects */

  choices_delete_subwindows();

  free(new_choices);
  new_choices = NULL;
  free(new_typefaces);
  new_typefaces = NULL;

  /* Deregister choices event handlers */
  event_deregister_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,            NULL);
  event_deregister_toolbox_handler(-1, CDSet,                     choices_set_button_handler,             NULL);
  event_deregister_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,          NULL);
  event_deregister_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,            NULL);
  event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,        NULL);
  event_deregister_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECD_LayoutRadios,          (ToolboxEventHandler *)
                                                                  choices_printing_layout_radio_change,   NULL);
  event_deregister_toolbox_handler(-1, ECD_HFRadios,              (ToolboxEventHandler *)
                                                                  choices_printing_h_or_f_radio_change,   NULL);

  event_deregister_toolbox_handler(-1, ECD_HlDispBt,              (ToolboxEventHandler *)
                                                                  choices_display_popup_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECD_HiDispBt,              (ToolboxEventHandler *)
                                                                  choices_display_popup_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECD_HlSaveBt,              (ToolboxEventHandler *)
                                                                  choices_save_popup_handler,             NULL);
  event_deregister_toolbox_handler(-1, ECD_HiSaveBt,              (ToolboxEventHandler *)
                                                                  choices_save_popup_handler,             NULL);
  event_deregister_toolbox_handler(-1, ECD_HiImSaveBt,            (ToolboxEventHandler *)
                                                                  choices_save_popup_handler,             NULL);
  event_deregister_toolbox_handler(-1, ECD_PageBreakBt,           (ToolboxEventHandler *)
                                                                  choices_pagebreak_popup_handler,        NULL);
  event_deregister_toolbox_handler(-1, ECD_URIHandlerBt,          (ToolboxEventHandler *)
                                                                  choices_uri_popup_handler,              NULL);
  event_deregister_toolbox_handler(-1, ECD_CookieBt,              (ToolboxEventHandler *)
                                                                  choices_cookie_popup_handler,           NULL);
  event_deregister_toolbox_handler(-1, ECD_RefererBt,             (ToolboxEventHandler *)
                                                                  choices_referer_popup_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECD_JPEGBt,                (ToolboxEventHandler *)
                                                                  choices_jpeg_popup_handler,             NULL);
  event_deregister_toolbox_handler(-1, ECD_TabInnerBordBt,        (ToolboxEventHandler *)
                                                                  choices_table_border_popup_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECD_TabOuterBordBt,        (ToolboxEventHandler *)
                                                                  choices_table_border_popup_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECD_ObjPlugBt,             (ToolboxEventHandler *)
                                                                  choices_plugin_popup_handler,           NULL);
  event_deregister_toolbox_handler(-1, ECD_HiAgeTypeBt,           (ToolboxEventHandler *)
                                                                  choices_timetype_popup_handler,         NULL);

  #ifdef JAVASCRIPT
    event_deregister_toolbox_handler(-1, ECD_WinOpenBt,           (ToolboxEventHandler *)
                                                                  choices_win_open_popup_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECD_WinCloseBt,          (ToolboxEventHandler *)
                                                                  choices_win_close_popup_handler,        NULL);
  #endif


  event_deregister_toolbox_handler(-1, ECDDispMenuClick,          (ToolboxEventHandler *)
                                                                  choices_display_selection_handler,      NULL);
  event_deregister_toolbox_handler(-1, ECDSaveMenuClick,          (ToolboxEventHandler *)
                                                                  choices_save_selection_handler,         NULL);
  event_deregister_toolbox_handler(-1, ECDPageBreakMenuClick,     (ToolboxEventHandler *)
                                                                  choices_pagebreak_selection_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDURIMenuClick,           (ToolboxEventHandler *)
                                                                  choices_uri_selection_handler,          NULL);
  event_deregister_toolbox_handler(-1, ECDCookieMenuClick,        (ToolboxEventHandler *)
                                                                  choices_cookie_selection_handler,       NULL);
  event_deregister_toolbox_handler(-1, ECDRefererMenuClick,       (ToolboxEventHandler *)
                                                                  choices_referer_selection_handler,      NULL);
  event_deregister_toolbox_handler(-1, ECDJPEGMenuClick,          (ToolboxEventHandler *)
                                                                  choices_jpeg_selection_handler,         NULL);
  event_deregister_toolbox_handler(-1, ECDBordMenuClick,          (ToolboxEventHandler *)
                                                                  choices_table_border_selection_handler, NULL);
  event_deregister_toolbox_handler(-1, ECDPlugMenuClick,          (ToolboxEventHandler *)
                                                                  choices_plugin_selection_handler,       NULL);
  event_deregister_toolbox_handler(-1, ECDTimeMenuClick,          (ToolboxEventHandler *)
                                                                  choices_timetype_selection_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECDHFSpecialMenuClick,     (ToolboxEventHandler *)
                                                                  choices_hfspecial_selection_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDHFSpecSubMenuClick,     (ToolboxEventHandler *)
                                                                  choices_hfspecsub_selection_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDHFDateMenuClick,        (ToolboxEventHandler *)
                                                                  choices_hfdate_selection_handler,       NULL);

  #ifdef JAVASCRIPT
    event_deregister_toolbox_handler(-1, ECDWinOpenMenuClick,     (ToolboxEventHandler *)
                                                                  choices_win_open_selection_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDWinCloseMenuClick,    (ToolboxEventHandler *)
                                                                  choices_win_close_selection_handler,    NULL);
  #endif


  event_deregister_toolbox_handler(-1, ECDHiRadioClick,           choices_history_radio_handler,          NULL);
  event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,           NULL);
  event_deregister_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,            NULL);

  if ((window = choices_find_component(CD_FakePage)) != 0)
  {
    event_deregister_wimp_handler(window, Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
  }

  if (choices_windowid != NULL_ObjectId)
  {
    event_deregister_wimp_handler(choices_windowid,
                                  Wimp_EOpenWindow,
                                  choices_open_choice_window,
                                  NULL);
  }
}

/**************************************************************/
/* choices_show_subwindow()                                   */
/*                                                            */
/* Shows a choice subwindow in the main choices window.      */
/*                                                            */
/* Parameters: the ObjectId of the main choices window        */
/*                                                            */
/*             the number of the subwindow to show. Defined   */
/*             in choices.h Use CDSubNone to remove the       */
/*             current subwindow.                             */
/*                                                            */
/* Returns:    pointer to _kernel_oserror                     */
/**************************************************************/

static _kernel_oserror * choices_show_subwindow(ObjectId choices_window, int subwindow)
{
  _kernel_oserror           * e;
  WindowShowObjectBlock       show_block;
  WimpGetWindowStateBlock     state;
  WimpGetWindowOutlineBlock   outline;
  int                         window_handle;
  int                         vwidth, hheight;

  if (current_subwindow != CDSubNone && current_subwindow != subwindow)
  {
    /* remove the current subwindow */

    RetError(toolbox_hide_object(0, subwindows[current_subwindow]));
    current_subwindow = CDSubNone;
  }

  if (subwindow == CDSubNone || !(subwindows[subwindow]))
  {
    /* Have not been asked to open a new subwindow */

    return NULL;
  }

  RetError(window_get_wimp_handle(0, choices_window, &window_handle));
  state.window_handle = window_handle;
  RetError(wimp_get_window_state(&state));
  RetError(gadget_get_bbox(0, choices_window, CDPlaceHolder, &show_block.visible_area));
  windows_return_tool_sizes(NULL, &hheight, &vwidth);

  show_block.visible_area.xmin = coords_x_toscreen(show_block.visible_area.xmin, (WimpRedrawWindowBlock *) &state);
  show_block.visible_area.xmax = coords_x_toscreen(show_block.visible_area.xmax, (WimpRedrawWindowBlock *) &state);
  show_block.visible_area.ymin = coords_y_toscreen(show_block.visible_area.ymin, (WimpRedrawWindowBlock *) &state);
  show_block.visible_area.ymax = coords_y_toscreen(show_block.visible_area.ymax, (WimpRedrawWindowBlock *) &state);

  /* Adjustments for different types of window */

  dprintf(("Choi", "choices_show_subwindow: Wimp flags = %x\n", state.flags));

  RetError(window_get_wimp_handle(0, subwindows[subwindow], &state.window_handle));
  RetError(wimp_get_window_state(&state));

  if (state.flags & WimpWindow_VScroll) show_block.visible_area.xmax -= vwidth;
  else vwidth  = 0;

  if (state.flags & WimpWindow_HScroll) show_block.visible_area.ymin += hheight;
  else hheight = 0;

  show_block.xscroll = 0;
  show_block.yscroll = 0;
  show_block.behind  = -1;

  show_block.window_flags    = 0;
  show_block.alignment_flags = 0;

  /* Requires wimp handle just to be awkward */

  show_block.parent_window_handle = window_handle;

  RetError(toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                               subwindows[subwindow],
                               Toolbox_ShowObject_FullSpec,
                               &show_block,
                               choices_window,
                               -1));

  outline.window_handle = state.window_handle;
  wimp_get_window_outline(&outline);

  if (outline.outline.xmin < show_block.visible_area.xmin)
  {
    show_block.visible_area.xmin += (show_block.visible_area.xmin - outline.outline.xmin);
  }
  if (outline.outline.ymin < (show_block.visible_area.ymin - hheight))
  {
    show_block.visible_area.ymin += (show_block.visible_area.ymin - outline.outline.ymin);
  }
  if (outline.outline.xmax > (show_block.visible_area.xmax + vwidth))
  {
    show_block.visible_area.xmax -= (outline.outline.xmax - show_block.visible_area.xmax);
  }
  if (outline.outline.ymax > show_block.visible_area.ymax)
  {
    show_block.visible_area.ymax -= (outline.outline.ymax - show_block.visible_area.ymax);
  }

  e = toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                          subwindows[subwindow],
                          Toolbox_ShowObject_FullSpec,
                          &show_block,
                          choices_window,
                          -1);

  if (!e) current_subwindow = subwindow;

  return e;
}

/**************************************************************/
/* choices_delete_subwindows()                                */
/*                                                            */
/* Deletes all subwindows, reports any and all errors         */
/* occuring while deleting them. Frees the structure holding  */
/* the subwindows. Only call if CREATE_ONLY_ONCE is undefined */
/* or you're going to tidy up events etc. and make sure the   */
/* objects_created flag setting is appropriate.               */
/**************************************************************/

static void choices_delete_subwindows(void)
{
  _kernel_oserror *e;
  int count;

  for(count = 0; count < CDNoSubwindows; count++)
  {
    if (subwindows[count])
    {
      e = toolbox_delete_object(0, subwindows[count]);
      if (e) show_error_ret(e);
      subwindows[count] = 0;
    }
  }
  free(subwindows);
  subwindows = NULL;
}

/**************************************************************/
/* choices_hidden()                                           */
/*                                                            */
/* Called when the ECDHidden event is generated. Deletes all  */
/* the subwindow dialogues. Deregisters all additional event  */
/* handlers used while the choices dialogue is visible.       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int choices_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror * e;
  int               temp;

  temp = current_subwindow;

  /* Close subwindow */

  e = choices_show_subwindow(idb->self_id, CDSubNone);
  if (e) show_error_ret(e);

  #ifndef CREATE_ONLY_ONCE
    choices_internal_shutdown();
  #endif

  choices_windowid  = NULL_ObjectId;
  current_subwindow = temp;

  return 1;
}

/**************************************************************/
/* choices_close()                                            */
/*                                                            */
/* Close the Choices dialogue as if the 'Cancel' button had   */
/* been activated with Select.                                */
/**************************************************************/

_kernel_oserror * choices_close(void)
{
  if (new_choices) memcpy(new_choices, &choices, sizeof(global_choices));

  if (choices_windowid) return toolbox_hide_object(0, choices_windowid);
  else                  return NULL;
}

/**************************************************************/
/* choices_mode_change()                                      */
/*                                                            */
/* Called on every mode change event. Records that a mode     */
/* change has taken place for use with the                    */
/* choices_open_choice_window function.                       */
/**************************************************************/

_kernel_oserror * choices_mode_change(void)
{
  choices_modechanged = 1;

  return NULL;
}

/**************************************************************/
/* choices_open_choice_window()                               */
/*                                                            */
/* Called whenever the choices window needs to be moved and   */
/* specifically on mode changes so the current sub window can */
/* be positioned correctly dealing with rounding errors       */
/* between modes of different aspect ratio.                   */
/**************************************************************/

static int choices_open_choice_window(int eventcode, WimpPollBlock * event, IdBlock * idb, void * handle)
{
  toolbox_show_object(0, idb->self_id, Toolbox_ShowObject_FullSpec, &(event->open_window_request.visible_area), idb->parent_id, idb->parent_component);

  if (choices_modechanged)
  {
    /* Reshow the subwindow at possibly new location */

    choices_show_subwindow(idb->self_id, current_subwindow);
    choices_modechanged = 0;
  }

  return 1;
}

/**************************************************************/
/* choices_set_contents()                                     */
/*                                                            */
/* Sets the contents of all choices subwindows to reflect the */
/* current state of the global choices.                       */
/*                                                            */
/* Returns:    pointer to _kernel_oserror.                    */
/**************************************************************/

static _kernel_oserror * choices_set_contents(void)
{
  ObjectId          window;
  unsigned int      temp, frac;

  /* No error handling here, as we want to allow items to be missing */

  /* Networking - URI handling, cookies, referer header */

  if ((window = choices_find_component(CD_Homepage))          != 0) choices_writablefield_set_value (0, window, CD_Homepage,          new_choices->home_page);
  if ((window = choices_find_component(CD_NetLaunchProxy))    != 0) optionbutton_set_state          (0, window, CD_NetLaunchProxy,    new_choices->start_proxy);
  if ((window = choices_find_component(CD_ClientPull))        != 0) optionbutton_set_state          (0, window, CD_ClientPull,        new_choices->client_pull);
  if ((window = choices_find_component(CD_NetscapeEmu))       != 0) optionbutton_set_state          (0, window, CD_NetscapeEmu,       new_choices->clone);
  if ((window = choices_find_component(CD_StripExtensions))   != 0) optionbutton_set_state          (0, window, CD_StripExtensions,   new_choices->strip_extensions);
  if ((window = choices_find_component(CD_NetUseProxy))       != 0) optionbutton_set_state          (0, window, CD_NetUseProxy,       new_choices->use_proxy);
  if ((window = choices_find_component(CD_NetProxyAddr))      != 0)
  {
    set_gadget_state(window, CD_NetProxyAddr, !new_choices->use_proxy);
    set_gadget_state(window, CD_NetProxyLabl, !new_choices->use_proxy);
    choices_writablefield_set_value(0, window, CD_NetProxyAddr, new_choices->proxy_address);
  }

  (void) choices_set_uri_field     (CD_URIHandlerDisp, new_choices->uri_usage);
  (void) choices_set_cookie_field  (CD_CookieDisp,     new_choices->cookies);
  (void) choices_set_referer_field (CD_RefererDisp,    new_choices->send_referer);

  /* Colours */

  if ((window = choices_find_component(CD_UseDocColours))     != 0) optionbutton_set_state          (0, window, CD_UseDocColours,     new_choices->use_source_cols);

  if ((window = choices_find_component(CD_BackColour))        != 0) choices_colour_set_component       (window, CD_BackColour,        new_choices->background_colour);
  if ((window = choices_find_component(CD_TextColour))        != 0) choices_colour_set_component       (window, CD_TextColour,        new_choices->text_colour);
  if ((window = choices_find_component(CD_LinkColour))        != 0) choices_colour_set_component       (window, CD_LinkColour,        new_choices->link_colour);
  if ((window = choices_find_component(CD_UsedColour))        != 0) choices_colour_set_component       (window, CD_UsedColour,        new_choices->used_colour);
  if ((window = choices_find_component(CD_FolwColour))        != 0) choices_colour_set_component       (window, CD_FolwColour,        new_choices->followed_colour);
  if ((window = choices_find_component(CD_SlctColour))        != 0) choices_colour_set_component       (window, CD_SlctColour,        new_choices->selected_colour);

  /* Fonts */

  if ((window = choices_find_component(CD_FontsSystem))       != 0)
  {
    optionbutton_set_state(0, window, CD_FontsSystem, new_choices->system_font);
    choices_set_fonts_greyed(new_choices->system_font);

    /*set_gadget_state(window, CD_FontsGroup1,  new_choices->system_font);*/
  }

  if ((window = choices_find_component(CD_FontsTF1Disp))      != 0) choices_displayfield_set_value  (0, window, CD_FontsTF1Disp,      new_typefaces[0].fontnames[0]);
  if ((window = choices_find_component(CD_FontsTF2Disp))      != 0) choices_displayfield_set_value  (0, window, CD_FontsTF2Disp,      new_typefaces[1].fontnames[0]);
  if ((window = choices_find_component(CD_FontsTF3Disp))      != 0) choices_displayfield_set_value  (0, window, CD_FontsTF3Disp,      new_typefaces[2].fontnames[0]);

  temp = new_choices->font_size;
  frac = (temp & 0xf);
  temp = ((temp >> 4) * 10) + todecimal[frac];

  if ((window = choices_find_component(CD_FontsSize))         != 0) choices_numberrange_set_value   (0, window, CD_FontsSize,         temp);
  if ((window = choices_find_component(CD_FontsAspect))       != 0) choices_numberrange_set_value   (0, window, CD_FontsAspect,       new_choices->tt_aspect);
  if ((window = choices_find_component(CD_FontsMinSize))      != 0) choices_numberrange_set_value   (0, window, CD_FontsMinSize,      new_choices->minimum_font_size);
  if ((window = choices_find_component(CD_UnderlineLinks))    != 0) optionbutton_set_state          (0, window, CD_UnderlineLinks,    new_choices->underline_links);

  /* Encoding */

  choices_set_encoding_field();

  /* Images */

  if ((window = choices_find_component(CD_ShowForeground))    != 0) optionbutton_set_state          (0, window, CD_ShowForeground,    new_choices->show_foreground);
  if ((window = choices_find_component(CD_ShowBackground))    != 0) optionbutton_set_state          (0, window, CD_ShowBackground,    new_choices->show_background);
  if ((window = choices_find_component(CD_NetMaxImageFetch))  != 0) choices_numberrange_set_value   (0, window, CD_NetMaxImageFetch,  new_choices->max_images);

  (void) choices_set_jpeg_field(CD_JPEGDisp, new_choices->support_pjpeg);

  /* Image RAM cache */

  if ((window = choices_find_component(CD_GCAfterNewFetch))   != 0) optionbutton_set_state          (0, window, CD_GCAfterNewFetch,   new_choices->collect_after);
  if ((window = choices_find_component(CD_GCUnusedLimitDisp)) != 0) choices_numberrange_set_value   (0, window, CD_GCUnusedLimitDisp, new_choices->unused_image_limit);
  if ((window = choices_find_component(CD_GCFreeLimitDisp))   != 0) choices_numberrange_set_value   (0, window, CD_GCFreeLimitDisp,   new_choices->free_ram_limit);

  /* Image history */

  if ((window = choices_find_component(CD_HiImExpiryAge))     != 0) choices_set_im_expiry_age (window);
  if ((window = choices_find_component(CD_HiImMaxSize))       != 0) choices_set_im_max_size   (window);

  (void) choices_set_save_field    (CD_HiImSaveDisp, new_choices->save_image_history);

  if (history_radio)
  {
    if ((window = choices_find_component(CD_HiRadImage)) != 0)
    radiobutton_set_state(0, window, CD_HiRadImage, 1);
  }
  else
  {
    if ((window = choices_find_component(CD_HiRadPage)) != 0)
    radiobutton_set_state(0, window, CD_HiRadPage, 1);
  }

  /* View */

  if ((window = choices_find_component(CD_URLBar))            != 0) optionbutton_set_state          (0, window, CD_URLBar,            new_choices->url_bar);
  if ((window = choices_find_component(CD_StatusBar))         != 0) optionbutton_set_state          (0, window, CD_StatusBar,         new_choices->status_bar);
  if ((window = choices_find_component(CD_ButtonBar))         != 0) optionbutton_set_state          (0, window, CD_ButtonBar ,        new_choices->button_bar);
  if ((window = choices_find_component(CD_FullScreen))        != 0) optionbutton_set_state          (0, window, CD_FullScreen,        new_choices->full_screen);
  if ((window = choices_find_component(CD_PreserveWidth))     != 0) optionbutton_set_state          (0, window, CD_PreserveWidth,     new_choices->toggle_on_y_only);

  /* Reformatting */

  if ((window = choices_find_component(CD_RefoKeep))          != 0) optionbutton_set_state          (0, window, CD_RefoKeep,          new_choices->refo_keep);
  if ((window = choices_find_component(CD_RefoHold))          != 0) optionbutton_set_state          (0, window, CD_RefoHold,          new_choices->refo_hold);
  if ((window = choices_find_component(CD_RefoWait))          != 0)
  {
    optionbutton_set_state(0, window, CD_RefoWait, new_choices->refo_wait);

    set_gadget_state(window, CD_RefoTimeLabl,  !new_choices->refo_wait);
    set_gadget_state(window, CD_RefoTimeDisp,  !new_choices->refo_wait);
    set_gadget_state(window, CD_RefoTimeLabl2, !new_choices->refo_wait);
  }
  if ((window = choices_find_component(CD_RefoTimeDisp))      != 0) choices_numberrange_set_value   (0, window, CD_RefoTimeDisp,      new_choices->refo_time);

  /* Printing */

  (void) choices_set_pagebreak_field (CD_PageBreakDisp,  new_choices->print_page_break_hx);

  if (new_choices->print_headers_from == 0)
  {
    if ((window = choices_find_component(CD_HeadersOff))      != 0) radiobutton_set_state           (0, window, CD_HeadersOff,        1);
    if ((window = choices_find_component(CD_HeadersFrom))     != 0) radiobutton_set_state           (0, window, CD_HeadersFrom,       0);
    if ((window = choices_find_component(CD_HeadersDisp))     != 0) choices_numberrange_set_value   (0, window, CD_HeadersDisp,       1);
  }
  else
  {
    if ((window = choices_find_component(CD_HeadersOff))      != 0) radiobutton_set_state           (0, window, CD_HeadersOff,        0);
    if ((window = choices_find_component(CD_HeadersFrom))     != 0) radiobutton_set_state           (0, window, CD_HeadersFrom,       1);
    if ((window = choices_find_component(CD_HeadersDisp))     != 0) choices_numberrange_set_value   (0, window, CD_HeadersDisp,       new_choices->print_headers_from);
  }

  if (new_choices->print_footers_from == 0)
  {
    if ((window = choices_find_component(CD_FootersOff))      != 0) radiobutton_set_state           (0, window, CD_FootersOff,        1);
    if ((window = choices_find_component(CD_FootersFrom))     != 0) radiobutton_set_state           (0, window, CD_FootersFrom,       0);
    if ((window = choices_find_component(CD_FootersDisp))     != 0) choices_numberrange_set_value   (0, window, CD_FootersDisp,       1);
  }
  else
  {
    if ((window = choices_find_component(CD_FootersOff))      != 0) radiobutton_set_state           (0, window, CD_FootersOff,        0);
    if ((window = choices_find_component(CD_FootersFrom))     != 0) radiobutton_set_state           (0, window, CD_FootersFrom,       1);
    if ((window = choices_find_component(CD_FootersDisp))     != 0) choices_numberrange_set_value   (0, window, CD_FootersDisp,       new_choices->print_footers_from);
  }

  if ((window = choices_find_component(CD_HeaderLeft))        != 0) choices_writablefield_set_value (0, window, CD_HeaderLeft,        new_choices->print_header_left);
  if ((window = choices_find_component(CD_HeaderMiddle))      != 0) choices_writablefield_set_value (0, window, CD_HeaderMiddle,      new_choices->print_header_mid);
  if ((window = choices_find_component(CD_HeaderRight))       != 0) choices_writablefield_set_value (0, window, CD_HeaderRight,       new_choices->print_header_right);
  if ((window = choices_find_component(CD_FooterLeft))        != 0) choices_writablefield_set_value (0, window, CD_FooterLeft,        new_choices->print_footer_left);
  if ((window = choices_find_component(CD_FooterMiddle))      != 0) choices_writablefield_set_value (0, window, CD_FooterMiddle,      new_choices->print_footer_mid);
  if ((window = choices_find_component(CD_FooterRight))       != 0) choices_writablefield_set_value (0, window, CD_FooterRight,       new_choices->print_footer_right);
  if ((window = choices_find_component(CD_DateFormat))        != 0) choices_writablefield_set_value (0, window, CD_DateFormat,        new_choices->print_date_format);

  if (new_choices->print_facing_pages == Choices_PrintFacingPages_No)
  {
    if ((window = choices_find_component(CD_NormalHFRadio))   != 0) radiobutton_set_state           (0, window, CD_NormalHFRadio,     1);
    if ((window = choices_find_component(CD_BookHFRadio))     != 0) radiobutton_set_state           (0, window, CD_BookHFRadio,       0);
    if ((window = choices_find_component(CD_SpreadHFRadio))   != 0) radiobutton_set_state           (0, window, CD_SpreadHFRadio,     0);
  }
  else if (new_choices->print_facing_pages == Choices_PrintFacingPages_Page)
  {
    if ((window = choices_find_component(CD_NormalHFRadio))   != 0) radiobutton_set_state           (0, window, CD_NormalHFRadio,     0);
    if ((window = choices_find_component(CD_BookHFRadio))     != 0) radiobutton_set_state           (0, window, CD_BookHFRadio,       1);
    if ((window = choices_find_component(CD_SpreadHFRadio))   != 0) radiobutton_set_state           (0, window, CD_SpreadHFRadio,     0);
  }
  else
  {
    if ((window = choices_find_component(CD_NormalHFRadio))   != 0) radiobutton_set_state           (0, window, CD_NormalHFRadio,     0);
    if ((window = choices_find_component(CD_BookHFRadio))     != 0) radiobutton_set_state           (0, window, CD_BookHFRadio,       0);
    if ((window = choices_find_component(CD_SpreadHFRadio))   != 0) radiobutton_set_state           (0, window, CD_SpreadHFRadio,     1);
  }

  if ((window = choices_find_component(CD_BoldHF))            != 0) optionbutton_set_state          (0, window, CD_BoldHF,            new_choices->print_hf_bold);
  if ((window = choices_find_component(CD_ItalicHF))          != 0) optionbutton_set_state          (0, window, CD_ItalicHF,          new_choices->print_hf_italic);
  if ((window = choices_find_component(CD_SizeHFDisp))        != 0) choices_numberrange_set_value   (0, window, CD_SizeHFDisp,        new_choices->print_hf_scale);

  (void) choices_set_printing_greyed();

  /* JavaScript */

  #ifdef JAVASCRIPT
    if ((window = choices_find_component(CD_SupportJS))       != 0) optionbutton_set_state          (0, window, CD_SupportJS,         new_choices->support_js);
    if ((window = choices_find_component(CD_JSWatchdog))      != 0) optionbutton_set_state          (0, window, CD_JSWatchdog,        new_choices->js_watchdog);
    if ((window = choices_find_component(CD_JSTimeoutDisp))   != 0) choices_numberrange_set_value   (0, window, CD_JSTimeoutDisp,     new_choices->js_timeout);
    if ((window = choices_find_component(CD_JSNavAsNav))      != 0) optionbutton_set_state          (0, window, CD_JSNavAsNav,        new_choices->js_nav_as_nav);
    if ((window = choices_find_component(CD_JSErrorBoxes))    != 0) optionbutton_set_state          (0, window, CD_JSErrorBoxes,      new_choices->js_error_boxes);

    (void) choices_set_win_open_field  (CD_JSWinOpenDisp,  new_choices->js_window_open);
    (void) choices_set_win_close_field (CD_JSWinCloseDisp, new_choices->js_window_close);

    choices_set_js_all_greyed(!new_choices->support_js);
  #endif

  /* Visit history */

  if ((window = choices_find_component(CD_HiExpiryAge))       != 0) choices_set_expiry_age (window);
  if ((window = choices_find_component(CD_HiMaxSize))         != 0) choices_set_max_size   (window);

  (void) choices_set_display_field (CD_HiDispDisp, new_choices->show_urls);
  (void) choices_set_save_field    (CD_HiSaveDisp, new_choices->save_history);

  /* Hotlist */

  if ((window = choices_find_component(CD_HlAutoOpen))        != 0) choices_numberrange_set_value   (0,  window, CD_HlAutoOpen,       new_choices->auto_open_delay);
  if ((window = choices_find_component(CD_HlAutoScroll))      != 0) choices_numberrange_set_value   (0,  window, CD_HlAutoScroll,     new_choices->auto_scroll_delay);

  (void) choices_set_display_field (CD_HlDispDisp, new_choices->hotlist_show);
  (void) choices_set_save_field    (CD_HlSaveDisp, new_choices->save_hotlist);

  /* Tables */

  if ((window = choices_find_component(CD_MSIE4StyleTables))  != 0) optionbutton_set_state          (0, window, CD_MSIE4StyleTables,  new_choices->msie4_style_tables);
  if ((window = choices_find_component(CD_TabSupport))        != 0)
  {
    optionbutton_set_state(0, window, CD_TabSupport, new_choices->support_tables);
    choices_set_tables_greyed(!new_choices->support_tables);
  }

  (void) choices_set_table_border_field(CD_TabInnerBordDisp, new_choices->table_inner);
  (void) choices_set_table_border_field(CD_TabOuterBordDisp, new_choices->table_outer);

  /* Frames */

  if ((window = choices_find_component(CD_DragToScroll))      != 0) optionbutton_set_state          (0, window, CD_DragToScroll,      new_choices->drag_to_scroll);
  if ((window = choices_find_component(CD_NoScrollBars))      != 0) optionbutton_set_state          (0, window, CD_NoScrollBars,      new_choices->no_scroll_bars);
  if ((window = choices_find_component(CD_ShowMayScroll))     != 0) optionbutton_set_state          (0, window, CD_ShowMayScroll,     new_choices->show_may_scroll);
  if ((window = choices_find_component(CD_FramesSupport))     != 0) optionbutton_set_state          (0, window, CD_FramesSupport,     new_choices->support_frames);

  choices_set_frame_related_greyed(window, !new_choices->support_frames);
  if (new_choices->support_frames) set_gadget_state(window, CD_ShowMayScroll, !new_choices->no_scroll_bars);

  /* Plug-ins */

  if ((window = choices_find_component(CD_ObjHandle))         != 0) optionbutton_set_state          (0,  window, CD_ObjHandle,        new_choices->support_object);
  if ((window = choices_find_component(CD_ObjPlugDisp))       != 0)
  {
    set_gadget_state(window, CD_ObjPlugLabl, !new_choices->support_object);
    set_gadget_state(window, CD_ObjPlugBt,   !new_choices->support_object);
    set_gadget_state(window, CD_ObjPlugDisp, !new_choices->support_object);

    (void) choices_set_plugin_field(CD_ObjPlugDisp, new_choices->plugin_control);
  }

  return NULL;
}

/**************************************************************/
/* choices_get_contents()                                     */
/*                                                            */
/* Sets the state of the global choices to reflect the        */
/* contents of all the choices subwindows. Many items are     */
/* maintained as they get changed, but some must be read back */
/* explicitly.                                                */
/**************************************************************/

static _kernel_oserror * choices_get_contents(void)
{
  WimpGetWindowStateBlock   s;
  browser_data            * b;
  fm_typeface             * tfptr;
  ObjectId                  window;

  int                       serif_changed      = 0;
  int                       sans_changed       = 0;
  int                       fixed_changed      = 0;
  int                       tablestyle_changed = 0;
  int                       needs_redraw       = 0;
  int                       colours_changed    = 0;

  int                       old_font_size,          old_system_font;
  int                       old_msie4_style_tables, old_minimum_font_size;
  int                       frac,                   temp;

  /* Get the Home page address */

  RetError(choices_retrieve_text_item(CD_Homepage, &new_choices->home_page));

  /* The lack of error checking is to allow */
  /* items to be missing from the dialogue. */

  if ((window = choices_find_component(CD_HlAutoOpen))        != 0) numberrange_get_value (0, window, CD_HlAutoOpen,        &new_choices->auto_open_delay);
  if ((window = choices_find_component(CD_HlAutoScroll))      != 0) numberrange_get_value (0, window, CD_HlAutoScroll,      &new_choices->auto_scroll_delay);
  if ((window = choices_find_component(CD_RefoTimeDisp))      != 0) numberrange_get_value (0, window, CD_RefoTimeDisp,      &new_choices->refo_time);
  if ((window = choices_find_component(CD_GCUnusedLimitDisp)) != 0) numberrange_get_value (0, window, CD_GCUnusedLimitDisp, &new_choices->unused_image_limit);
  if ((window = choices_find_component(CD_GCFreeLimitDisp))   != 0) numberrange_get_value (0, window, CD_GCFreeLimitDisp,   &new_choices->free_ram_limit);

  #ifdef JAVASCRIPT
    if ((window = choices_find_component(CD_JSTimeoutDisp))   != 0) numberrange_get_value (0, window, CD_JSTimeoutDisp,     (int *) &new_choices->js_timeout);
  #endif

  if (expiry_age_greyed)
  {
    if (history_radio) new_choices->image_expiry_age = 0;
    else               new_choices->expiry_age       = 0;
  }
  else
  {
    if ((window = choices_find_component(CD_HiExpiryAge)) != 0)
    {
      numberrange_get_value(0, window, CD_HiExpiryAge, &temp);

      if (history_radio) new_choices->image_expiry_age = choices_typed_time_to_seconds(temp, history_expiry_units);
      else               new_choices->expiry_age       = choices_typed_time_to_seconds(temp, history_expiry_units);
    }
  }

  if (max_size_greyed)
  {
    if (history_radio) new_choices->image_max_size = 0;
    else               new_choices->max_size       = 0;
  }
  else
  {
    if ((window = choices_find_component(CD_HiMaxSize)) != 0)
    {
      RetError(numberrange_get_value(0, window, CD_HiMaxSize, &temp));

      if (history_radio) new_choices->image_max_size = temp * 1024;
      else               new_choices->max_size       = temp * 1024;
    }
  }

  if (image_expiry_age_greyed)
  {
    new_choices->image_expiry_age = 0;
  }
  else
  {
    if ((window = choices_find_component(CD_HiImExpiryAge)) != 0)
    {
      RetError(numberrange_get_value(0, window, CD_HiImExpiryAge, &temp));
      new_choices->image_expiry_age = choices_typed_time_to_seconds(temp, image_expiry_units);
    }
  }

  if (image_max_size_greyed)
  {
    new_choices->image_max_size = 0;
  }
  else
  {
    if ((window = choices_find_component(CD_HiImMaxSize)) != 0)
    {
      RetError(numberrange_get_value(0, window, CD_HiImMaxSize, &temp));
      new_choices->image_max_size = temp * 1024;
    }
  }

  /* Read the proxy address */

  RetError(choices_retrieve_text_item(CD_NetProxyAddr, &new_choices->proxy_address));

  if ((window = choices_find_component(CD_NetMaxImageFetch)) != 0)
  {
    RetError(numberrange_get_value(0, window, CD_NetMaxImageFetch,  &temp));
    new_choices->max_images = temp;
  }

  /* Grab various printing options */

  RetError(choices_retrieve_text_item(CD_HeaderLeft,   &new_choices->print_header_left));
  RetError(choices_retrieve_text_item(CD_HeaderMiddle, &new_choices->print_header_mid));
  RetError(choices_retrieve_text_item(CD_HeaderRight,  &new_choices->print_header_right));
  RetError(choices_retrieve_text_item(CD_FooterLeft,   &new_choices->print_footer_left));
  RetError(choices_retrieve_text_item(CD_FooterMiddle, &new_choices->print_footer_mid));
  RetError(choices_retrieve_text_item(CD_FooterRight,  &new_choices->print_footer_right));
  RetError(choices_retrieve_text_item(CD_DateFormat,   &new_choices->print_date_format));

  if ((window = choices_find_component(CD_SizeHFDisp)) != 0) numberrange_get_value(0, window, CD_SizeHFDisp, &new_choices->print_hf_scale);

  if (new_choices->print_headers_from != 0)
  {
    if ((window = choices_find_component(CD_HeadersDisp)) != 0)
    {
      ChkError(numberrange_get_value(0,
                                     window,
                                     CD_HeadersDisp,
                                     &new_choices->print_headers_from));
    }
    else new_choices->print_headers_from = 1;
  }

  if (new_choices->print_footers_from != 0)
  {
    if ((window = choices_find_component(CD_FootersDisp)) != 0)
    {
      ChkError(numberrange_get_value(0,
                                     window,
                                     CD_FootersDisp,
                                     &new_choices->print_footers_from));
    }
    else new_choices->print_footers_from = 1;
  }

  /* Remember some of the old values */

  old_font_size          = choices.font_size;
  old_minimum_font_size  = choices.minimum_font_size;
  old_system_font        = choices.system_font;
  old_msie4_style_tables = choices.msie4_style_tables;

  if ((window = choices_find_component(CD_FontsSize)) != 0)
  {
    numberrange_get_value(0, window, CD_FontsSize, &new_choices->font_size);
    frac = new_choices->font_size % 10;
    new_choices->font_size = ((new_choices->font_size / 10)<<4) + fromdecimal[frac];
  }

  if ((window = choices_find_component(CD_FontsAspect)) != 0)
  {
    numberrange_get_value(0, window, CD_FontsAspect, &new_choices->tt_aspect);
    if (choices.tt_aspect != new_choices->tt_aspect) fixed_changed = 1;
  }

  if ((window = choices_find_component(CD_FontsMinSize)) != 0)
  {
    numberrange_get_value(0, window, CD_FontsMinSize, &temp);
    if (temp < 1) temp = 1;
    if (temp > 7) temp = 7;
    new_choices->minimum_font_size = temp;
    if (choices.minimum_font_size != new_choices->minimum_font_size) serif_changed = sans_changed = fixed_changed = 1;
  }

  /* Have the default document colours changed? */

  if (
      choices.background_colour != new_choices->background_colour ||
      choices.text_colour       != new_choices->text_colour       ||
      choices.link_colour       != new_choices->link_colour       ||
      choices.used_colour       != new_choices->used_colour       ||
      choices.followed_colour   != new_choices->followed_colour   ||
      choices.selected_colour   != new_choices->selected_colour
     )
  {
    colours_changed = 1;
  }

  /* Do we need to redraw because certain special items have changed? */
  /* (As opposed to reformat, and/or ditch and reclaim fonts).        */

  if (
       choices.table_inner  != new_choices->table_inner ||
       choices.table_outer  != new_choices->table_outer
     )
     needs_redraw = 1;

  /* Now start using the dialogue's new settings */

  memcpy(&choices, new_choices, sizeof(global_choices));

  /* Before we change fonts, we need to forget the basic */
  /* typeface definitions. First find out which have     */
  /* changed, if any.                                    */

  tfptr = fm_find_typeface("serif");

  if (tfptr)
  {
    if (memcmp(tfptr, &new_typefaces[0], sizeof(fm_typeface))) serif_changed = 1;
  }

  tfptr = fm_find_typeface("sans");

  if (tfptr)
  {
    if (memcmp(tfptr, &new_typefaces[1], sizeof(fm_typeface))) sans_changed = 1;
  }

  tfptr = fm_find_typeface("fixed");

  if (tfptr)
  {
    if (memcmp(tfptr, &new_typefaces[2], sizeof(fm_typeface))) fixed_changed = 1;
  }

  if (choices.system_font) choices.font_size = FM_Standard_Size;

  /* Other ways that font styles can change */

  if (
       choices.font_size         != old_font_size         ||
       choices.minimum_font_size != old_minimum_font_size ||
       choices.system_font       != old_system_font
     )
  {
    serif_changed = 1;
    sans_changed  = 1;
    fixed_changed = 1;
    fm_set_system_font(choices.system_font);
    fm_init_sizes(choices.font_size);
  }

  /* Has the table reformat style changed? */

  if (choices.msie4_style_tables != old_msie4_style_tables) tablestyle_changed = 1;

  /* If fonts have changed, get ready to update them */

  if (serif_changed || sans_changed || fixed_changed)
  {
    /* Dump *all* current fonts */

    fm_shutdown();

    /* Write the new typeface details into the existing structures */

    tfptr = fm_find_typeface("serif");
    if (tfptr) memcpy(tfptr, &new_typefaces[0], sizeof(fm_typeface));

    tfptr = fm_find_typeface("sans");
    if (tfptr) memcpy(tfptr, &new_typefaces[1], sizeof(fm_typeface));

    tfptr = fm_find_typeface("fixed");
    if (tfptr) memcpy(tfptr, &new_typefaces[2], sizeof(fm_typeface));
  }

  /* Tell ImageLib how to handle JPEGs based on the dialogue box settings */

  ImageLib_SetInternalJPEG(choices.support_pjpeg);

  /* Update browsers - *must* call fm_lose_fonts for all */
  /* browsers if the above code called fm_shutdown.      */

  b = last_browser;

  while (b)
  {
    if (
         tablestyle_changed ||
         serif_changed      ||
         sans_changed       ||
         fixed_changed
       )
    {
      /* Get rid of the currently used fonts for this browser */

      fm_lose_fonts(b);

      /* Only reformat page if it has no children */

      if (!b->children) reformat_format_from(b, -1, 1, -1);
    }
    else
    {
      if (b->background_colour == -1)
      {
        b->antialias_colour = redraw_backcol(b);
      }

      /* The Choices are only used directly for browsers which are */
      /* set to override document colours. Otherwise defaults will */
      /* have been read locally and possibly overridden by HTML,   */
      /* and a reload will be needed to reflect the changes.       */
      /*                                                           */
      /* Alternatively, it may be the case that all browsers need  */
      /* redrawing (e.g. if the table border types change).        */

      if (
           needs_redraw ||
           (
             colours_changed &&
             (
               !b->use_source_cols
               ||
               (
                 b->background_colour == -1 &&
                 b->background_image  == -1
               )
             )
           )
         )
      {
        s.window_handle = b->window_handle;
        RetError(wimp_get_window_state(&s));

        coords_box_toworkarea(&s.visible_area, (WimpRedrawWindowBlock *) &s);

        RetError(wimp_force_redraw(b->window_handle,
                                   s.visible_area.xmin,
                                   s.visible_area.ymin,
                                   s.visible_area.xmax,
                                   s.visible_area.ymax));
      }
    }

    b = b->previous;
  }

  if (serif_changed || sans_changed || fixed_changed)
  {
    /* Reclaim basic typefaces - remember to claim at the *new* */
    /* font Choices size.                                       */

    fm_claim_basic_typefaces(choices.font_size);
  }

  return NULL;
}

/**************************************************************/
/* choices_set_button_handler()                               */
/*                                                            */
/* Called when the set button in the main choices dialogue is */
/* clicked. Uses choices_get_contents to set the global       */
/* choices to reflect the choices set in the choices          */
/* subwindows                                                 */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int choices_set_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e = NULL;
  int             buttons;

  ChkError(window_get_pointer_info(0, NULL, NULL, &buttons, NULL, NULL));

  e = choices_get_contents();
  if (e) show_error_ret(e);

  if (buttons != 1)
  {
    ChkError(toolbox_hide_object(0, choices_windowid));
  }

  return 1;
}

/**************************************************************/
/* choices_cancel_button_handler()                            */
/*                                                            */
/* Called when the cancel button in the main choices dialogue */
/* is clicked. Uses choices_set_contents to restore the       */
/* subwindows to their previous state.                        */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int choices_cancel_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ObjectId        window;
  int             update_fake;
  fm_typeface   * tfptr;
  int             buttons;

  ChkError(window_get_pointer_info(0, NULL, NULL, &buttons, NULL, NULL));

  if (buttons == 1)
  {
    if ((choices.background_colour != new_choices->background_colour) ||
        (choices.text_colour       != new_choices->text_colour)       ||
        (choices.link_colour       != new_choices->link_colour)       ||
        (choices.used_colour       != new_choices->used_colour)       ||
        (choices.followed_colour   != new_choices->followed_colour)   ||
        (choices.selected_colour   != new_choices->selected_colour)   ||
        (choices.underline_links   != new_choices->underline_links))
    {
      update_fake = 1;
    }
    else
    {
      update_fake = 0;
    }

    memcpy(new_choices, &choices, sizeof(global_choices));

    tfptr = fm_find_typeface("serif");
    memcpy(&new_typefaces[0], tfptr, sizeof(fm_typeface));
    tfptr = fm_find_typeface("sans");
    memcpy(&new_typefaces[1], tfptr, sizeof(fm_typeface));
    tfptr = fm_find_typeface("fixed");
    memcpy(&new_typefaces[2], tfptr, sizeof(fm_typeface));

    choices_set_contents();

    /* Attempt to redraw fake page display */

    if (update_fake && (window = choices_find_component(CD_FakePage)) != 0) button_set_flags(0, window, CD_FakePage, 0, 0);
  }
  else
  {
    memcpy(new_choices, &choices, sizeof(global_choices));
    ChkError(toolbox_hide_object(0, choices_windowid));
  }

  return 1;
}

/**************************************************************/
/* choices_save_button_handler()                              */
/*                                                            */
/* Called when the set button in the main choices dialogue is */
/* clicked. Uses choices_get_contents to set the global       */
/* choices to reflect the choices set in the choices          */
/* subwindows and then saves the choices file.                */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int choices_save_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e = NULL;
  ObjectId        window;
  int             buttons;

  ChkError(window_get_pointer_info(0, NULL, NULL, &buttons, NULL, NULL));

  e = choices_get_contents();
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  /* Attempt to redraw fake page display */

  if ((window = choices_find_component(CD_FakePage)) != 0) button_set_flags(0, window, CD_FakePage, 0, 0);

  e = save_save_choices(NULL);
  if (e) show_error_ret(e);

  if (buttons != 1)
  {
    ChkError(toolbox_hide_object(0, choices_windowid));
  }

  return 1;
}

/**************************************************************/
/* choices_redraw_fakepage_handler()                          */
/*                                                            */
/* Redraws the fake page in the colour selection dbox.        */
/**************************************************************/

static int choices_redraw_fakepage_handler(int eventcode, WimpPollBlock * event, IdBlock * idb, void * handle)
{
  _kernel_oserror       * e = NULL;
  WimpRedrawWindowBlock   block;
  WimpGetWindowStateBlock state;
  int                     more, ypos, xtarget, ptsize, gadsize, xstart, nolines;
  int                     fontheight = 0;
  int                     gotfont    = 0;
  BBox                    icon_coords, fbox;
  fm_face                 h = 0;
  char                    display_this[4];

  block.window_handle = event->redraw_window_request.window_handle;
  state.window_handle = event->redraw_window_request.window_handle;

  e = wimp_get_window_state(&state);
  show_error_ret(e);
  if (!e) e = gadget_get_bbox(0, idb->self_id, CD_FakePage, &icon_coords);

  gadsize = icon_coords.ymax - icon_coords.ymin;

  xstart = gadsize / 8;

  if (e)
  {
    /* Gadget doesn't exist or something strange happened trying */
    /* to get window state so just do a simple redraw loop to    */
    /* keep the wimp happy.                                      */

    ChkError(wimp_redraw_window(&block, &more));
    while (more && !e) e = wimp_get_rectangle(&block, &more);
    return 1;
  }

  coords_box_toscreen(&icon_coords, (WimpRedrawWindowBlock *) &state);

  /* Find out which lines to draw */

  for(nolines = 0; nolines < sizeof(display_this); nolines++) display_this[nolines] = 0;

  nolines = 1; /* Start with one line (half at top, half at bottom) */

  if (choices_find_component(CD_LinkColourBt))
  {
    nolines ++;
    display_this[0] = 1;
  }
  if (choices_find_component(CD_UsedColourBt))
  {
    nolines ++;
    display_this[1] = 1;
  }
  if (choices_find_component(CD_FolwColourBt))
  {
    nolines ++;
    display_this[2] = 1;
  }
  if (choices_find_component(CD_SlctColourBt))
  {
    nolines ++;
    display_this[3] = 1;
  }

  /* Start the redraw loop */

  ChkError(wimp_redraw_window(&block, &more));

  while (more && !e)
  {
    /* Clip the redraw area to only take in the gadget */

    if (utils_set_graphics_window(&icon_coords, &block.redraw_area, NULL))
    {
      /* Only claim the font if it is required */

      if (!gotfont)
      {
        /* Find default browser font, the font manager will return system */
        /* font if it is configured.                                      */

        /* Find a 1000 subpoint (big) version of default browser font to scale against */

        h = fm_find_font(NULL, "serif", 1000, 1000, 0, 0);
        e = fm_font_box(h, &fbox);
        fm_lose_font(NULL, h);
        if (e) show_error_cont(e);
        fontheight = fbox.ymax - fbox.ymin;

        /* Find a version of the default browser font with a */
        /* point size which will allow an appropriate number */
        /* of lines in the fake page display.                */

        ptsize = ((gadsize * 1000 / nolines) / fontheight);

        h = fm_find_font(NULL, "serif", ptsize, ptsize, 0, 0);
        ChkError(fm_font_box(h, &fbox));
        fontheight = fbox.ymax - fbox.ymin;
        gotfont = 1;
      }

      /* Fake browser drawing code is here */

      /* Fill background with background colour */

      redraw_set_colour(new_choices->background_colour);
      ChkError(bbc_rectanglefill(icon_coords.xmin, icon_coords.ymin, icon_coords.xmax - icon_coords.xmin, icon_coords.ymax - icon_coords.ymin));

      xtarget = icon_coords.xmin - 32;
      ypos = icon_coords.ymax - fontheight / 3;

      /* Display the top line of the fake page display */

      ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 1));

      ypos -= fontheight;
      xtarget = icon_coords.xmin - 32;

      /* Display the new link line of the fake page display */

      if (display_this[0])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 2));
        ChkError(choices_draw_string(h, "new", xtarget, ypos, new_choices->underline_links, new_choices->link_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 3));

        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }

      /* Display the new followed line of the fake page display */

      if (display_this[1])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 4));
        ChkError(choices_draw_string(h, "followed", xtarget, ypos, new_choices->underline_links, new_choices->used_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 5));

        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }

      /* Display the highlighted link line of the fake page display */

      if (display_this[2])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 6));
        ChkError(choices_draw_string(h, "highlighted", xtarget, ypos, new_choices->underline_links, new_choices->followed_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 7));

        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }

      /* Display the selected link line of the fake page display */

      if (display_this[3])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 8));
        ChkError(choices_draw_string(h, "selected", xtarget, ypos, new_choices->underline_links, new_choices->selected_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 9));

        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }

      /* Display the bottom line of the fake page display */

      ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 10));
    }

    utils_restore_graphics_window(&block.redraw_area);

    /* Get the next redraw rectangle */

    if (!e) e = wimp_get_rectangle(&block, &more);
  }

  if (gotfont) fm_lose_font(NULL, h);

  return 1;
}

/**************************************************************/
/* choices_write_rubbish()                                    */
/*                                                            */
/* Writes a string of readable rubbish on the screen using    */
/* the passed font handle. It also returns the position to    */
/* paint the next string following this one.                  */
/*                                                            */
/* Parameters: Font handle;                                   */
/*                                                            */
/*             X position on screen (OS coords);              */
/*                                                            */
/*             Y position on screen (OS coords);              */
/*                                                            */
/*             Approximate x position to stop printing at (OS */
/*             coords);                                       */
/*                                                            */
/*             Foreground colour;                             */
/*                                                            */
/*             Background colour;                             */
/*                                                            */
/*             Pointer to int to return x position in;        */
/*                                                            */
/*             Random seed for string to print (if you pass   */
/*             the same seed the string should be the same).  */
/**************************************************************/

static _kernel_oserror * choices_write_rubbish
                         (
                           fm_face   h,
                           int       xpos,
                           int       ypos,
                           int       maxxish,
                           int       forecolour,
                           int       backcolour,
                           int     * newxpos,
                           int       seed
                         )
{
  char ministring[5];
  int chars = 0;
  int spcwidth, width, nochars;

  fm_set_font_colour(h, forecolour, backcolour);

  srand(seed);

  fm_get_string_width(h, " ", 0x1000000, 1, -1, &nochars, &width);
  convert_to_os(width, &spcwidth);
  xpos += spcwidth;

  while(xpos < maxxish)
  {
    ministring[0] = consonant[rand()%(sizeof(consonant)-1)];
    ministring[1] = vowel[rand()%(sizeof(vowel)-1)];

    if (rand()%2)
    {
      ministring[2] = consonant[rand()%(sizeof(consonant)-1)];
      ministring[3] = vowel[rand()%(sizeof(vowel)-1)];
      ministring[4] = 0;
    }
    else
    {
      ministring[2] = 0;
    }

    fm_puts(h, xpos, ypos, ministring, 1, 0);
    fm_get_string_width(h, ministring, 0x1000000, strlen(ministring), -1, &nochars, &width);
    convert_to_os(width, &width);
    xpos += width;

    chars++;
    if (chars > rand()%2 || xpos >= maxxish)
    {
      chars = 0;
      xpos += spcwidth;
    }
  }

  *newxpos = xpos;
  return NULL;
}

/**************************************************************/
/* choices_draw_string()                                      */
/*                                                            */
/* Writes a string on the screen using the passed font        */
/* handle, it underlines the text if required. It also        */
/* returns the position to paint the next string following    */
/* this one.                                                  */
/*                                                            */
/* Parameters: Font handle;                                   */
/*                                                            */
/*             String to print;                               */
/*                                                            */
/*             X position on screen (OS coords);              */
/*                                                            */
/*             Y position on screen (OS coords);              */
/*                                                            */
/*             0 - don't underline, non-0 - underline;        */
/*                                                            */
/*             Foreground colour;                             */
/*                                                            */
/*             Background colour;                             */
/*                                                            */
/*             Pointer to int to return x position in.        */
/**************************************************************/

static _kernel_oserror * choices_draw_string
                         (
                           fm_face   h,
                           char    * string,
                           int       xpos,
                           int       ypos,
                           int       underline,
                           int       forecolour,
                           int       backcolour,
                           int     * newxpos
                         )
{
  int width, nochars;

  fm_set_font_colour(h, forecolour, backcolour);
  fm_get_string_width(h, string, 0x1000000, strlen(string), -1, &nochars, &width);
  convert_to_os(width, &width);

  /* The next string must be plotted straight after this string */

  *newxpos = xpos + width;

  fm_puts(h, xpos, ypos, string, 1, 0);

  if (underline)
  {
    redraw_set_colour(forecolour);
    bbc_move(xpos, ypos - 7);
    bbc_draw(*newxpos, ypos - 7);
  }
  return NULL;
}

/**************************************************************/
/* choices_radio_click_handler()                              */
/*                                                            */
/* Shows the appropriate subwindow when a radio button in the */
/* choices dialogue is clicked on                             */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int choices_radio_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int window, state;

  radiobutton_get_state(0, idb->self_id, idb->self_component, &state, NULL);

  /* Is this a radiobutton selected event? */

  if (state)
  {
    window = idb->self_component - CDFirstSubRadio;
    if (window > CDNoSubwindows) window = CDSubNone;
    choices_show_subwindow(idb->self_id, window);
  }

  return 1;
}

/**************************************************************/
/* choices_history_radio_handler()                            */
/*                                                            */
/* Handles radio button state changes. Swaps between page and */
/* image history settings.                                    */
/**************************************************************/

static int choices_history_radio_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int state, temp;
  ObjectId window;

  radiobutton_get_state(0, idb->self_id, idb->self_component, &state, NULL);

  /* Is this a radiobutton selected event? */

  if (state)
  {
    if (expiry_age_greyed)
    {
      if (history_radio) new_choices->image_expiry_age = 0;
      else               new_choices->expiry_age = 0;
    }
    else
    {
      if ((window = choices_find_component(CD_HiExpiryAge))    != 0)
      {
        numberrange_get_value(0, window, CD_HiExpiryAge,  &temp);
        if (history_radio) new_choices->image_expiry_age = choices_typed_time_to_seconds(temp, history_expiry_units);
        else               new_choices->expiry_age = choices_typed_time_to_seconds(temp, history_expiry_units);
      }
    }

    if (max_size_greyed)
    {
      if (history_radio) new_choices->image_max_size = 0;
      else               new_choices->max_size = 0;
    }
    else
    {
      if ((window = choices_find_component(CD_HiMaxSize))      != 0)
      {
        numberrange_get_value(0, window, CD_HiMaxSize,    &temp);
        if (history_radio) new_choices->image_max_size = temp * 1024;
        else               new_choices->max_size = temp * 1024;
      }
    }

    switch(idb->self_component)
    {
      case CD_HiRadPage:
      history_radio = 0;
      if ((window = choices_find_component(CD_HiExpiryAge))    != 0) choices_set_expiry_age(window);
      if ((window = choices_find_component(CD_HiMaxSize))      != 0) choices_set_max_size(window);
      break;

      case CD_HiRadImage:
      history_radio = 1;
      if ((window = choices_find_component(CD_HiExpiryAge))    != 0) choices_set_expiry_age(window);
      if ((window = choices_find_component(CD_HiMaxSize))      != 0) choices_set_max_size(window);
      break;
    }
  }

  return 1;
}

/**************************************************************/
/* choices_printing_layout_radio_change()                     */
/*                                                            */
/* Handles printing layout radio button selections, updating  */
/* new_choices as required.                                   */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_printing_layout_radio_change
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  switch (idb->self_component)
  {
    case CD_NormalHFBt:      radiobutton_set_state(0, idb->self_id, CD_NormalHFRadio, 1); /* ...and drop through */
    case CD_NormalHFRadio:   new_choices->print_facing_pages = Choices_PrintFacingPages_No;     break;
    case CD_BookHFBt:        radiobutton_set_state(0, idb->self_id, CD_BookHFRadio  , 1); /* ...and drop through */
    case CD_BookHFRadio:     new_choices->print_facing_pages = Choices_PrintFacingPages_Page;   break;
    case CD_SpreadHFBt:      radiobutton_set_state(0, idb->self_id, CD_SpreadHFRadio, 1); /* ...and drop through */
    case CD_SpreadHFRadio:   new_choices->print_facing_pages = Choices_PrintFacingPages_Spread; break;
  }

  return 1;
}

/**************************************************************/
/* choices_printing_h_or_f_radio_change()                     */
/*                                                            */
/* Handles header or footer on/off radio button selections,   */
/* updating new_choices and gadget greyed/ungreyed states as  */
/* required.                                                  */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_printing_h_or_f_radio_change
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  ObjectId window;

  switch (idb->self_component)
  {
    /* If headers are off, set this in Choices. If headers are on,  */
    /* try to read the starting page; if the relevant gadget cannot */
    /* be found, assume we start on page 1.                         */

    case CD_HeadersOff:  new_choices->print_headers_from = 0; break;
    case CD_HeadersFrom:
    {
      if ((window = choices_find_component(CD_HeadersDisp)) != 0)
      {
        ChkError(numberrange_get_value(0,
                                       window,
                                       CD_HeadersDisp,
                                       &new_choices->print_headers_from));
      }
      else new_choices->print_headers_from = 1;
    }
    break;

    /* If footers are off, set this in Choices. If footers are on,  */
    /* try to read the starting page; if the relevant gadget cannot */
    /* be found, assume we start on page 1.                         */

    case CD_FootersOff:  new_choices->print_footers_from = 0; break;
    case CD_FootersFrom:
    {
      if ((window = choices_find_component(CD_FootersDisp)) != 0)
      {
        ChkError(numberrange_get_value(0,
                                       window,
                                       CD_FootersDisp,
                                       &new_choices->print_footers_from));
      }
      else new_choices->print_footers_from = 1;
    }
    break;
  }

  /* Set greyed/ungreyed states according to these new settings */

  ChkError(choices_set_printing_greyed());

  return 1;
}

/**************************************************************/
/* choices_option_state_handler()                             */
/*                                                            */
/* Called when an option button has its state changed by      */
/* being clicked on. Sets or unsets the relevant flag in      */
/* new_choices and causes redraws where necessary.            */
/**************************************************************/

static int choices_option_state_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int               state;
  ObjectId          window;

  ChkError(optionbutton_get_state(0, idb->self_id, idb->self_component, &state));

  switch(idb->self_component)
  {
    case CD_UnderlineLinks:
    {
      new_choices->underline_links = !!state;

      /* Attempt to redraw fake page display */

      if ((window = choices_find_component(CD_FakePage)) != 0) button_set_flags(0, window, CD_FakePage, 0, 0);
      break;
    }

    case CD_UseDocColours:  new_choices->use_source_cols = !!state; break;
    case CD_ShowForeground: new_choices->show_foreground = !!state; break;
    case CD_ShowBackground: new_choices->show_background = !!state; break;

    case CD_URLBar:         new_choices->url_bar         = !!state; break;
    case CD_StatusBar:      new_choices->status_bar      = !!state; break;
    case CD_ButtonBar:      new_choices->button_bar      = !!state; break;
    case CD_FullScreen:     new_choices->full_screen     = !!state; break;

    case CD_ClientPull:     new_choices->client_pull     = !!state; break;
    case CD_NetscapeEmu:    new_choices->clone           = !!state; break;

    case CD_FramesSupport:
    {
      new_choices->support_frames = !!state;
      choices_set_frame_related_greyed(idb->self_id, !state);
      if (new_choices->support_frames) set_gadget_state(idb->self_id, CD_ShowMayScroll, !new_choices->no_scroll_bars);
    }
    break;

    case CD_RefoKeep:       new_choices->refo_keep       = !!state; break;
    case CD_RefoHold:       new_choices->refo_hold       = !!state; break;
    case CD_RefoWait:
    {
      new_choices->refo_wait = !!state;

      if ((window = choices_find_component(CD_RefoTimeLabl)) != 0)
      {
        set_gadget_state(window, CD_RefoTimeLabl,  !state);
        set_gadget_state(window, CD_RefoTimeDisp,  !state);
        set_gadget_state(window, CD_RefoTimeLabl2, !state);
      }
    }
    break;

    case CD_NoScrollBars:
    {
      new_choices->no_scroll_bars = !!state;
      set_gadget_state(idb->self_id, CD_ShowMayScroll, !new_choices->no_scroll_bars);
    }
    break;

    case CD_DragToScroll:   new_choices->drag_to_scroll  = !!state; break;
    case CD_ShowMayScroll:  new_choices->show_may_scroll = !!state; break;

    case CD_FontsSystem:
    {
      new_choices->system_font = !!state;
      if ((window = choices_find_component(CD_FontsTF1Labl)) != 0)
      {
        choices_set_fonts_greyed(new_choices->system_font);
        /*set_gadget_state(window, CD_FontsGroup1,  new_choices->system_font);*/
        if ((window = choices_find_component(CD_FontsSize)) != 0)
        {
          if (new_choices->system_font)
          {
            int frac, temp;
            numberrange_get_value(0, window, CD_FontsSize, &new_choices->font_size);
            frac = new_choices->font_size % 10;
            new_choices->font_size = ((new_choices->font_size / 10)<<4) + fromdecimal[frac];
            temp = FM_Standard_Size;
            frac = (temp & 0xf);
            temp = ((temp >> 4) * 10) + todecimal[frac];
            choices_numberrange_set_value(0, window, CD_FontsSize, temp);
            choices_numberrange_set_value(0, window, CD_FontsAspect, 100);
          }
          else
          {
            int temp, frac;
            temp = new_choices->font_size;
            frac = (temp & 0xf);
            temp = ((temp >> 4) * 10) + todecimal[frac];
            choices_numberrange_set_value(0, window, CD_FontsSize, temp);
            choices_numberrange_set_value(0, window, CD_FontsAspect, new_choices->tt_aspect);
          }
        }
      }
    }
    break;

    case CD_ObjHandle:
    {
      new_choices->support_object = !!state;

      if ((window = choices_find_component(CD_ObjPlugDisp)) != 0)
      {
        set_gadget_state(window, CD_ObjPlugLabl, !new_choices->support_object);
        set_gadget_state(window, CD_ObjPlugBt,   !new_choices->support_object);
        set_gadget_state(window, CD_ObjPlugDisp, !new_choices->support_object);
      }
    }
    break;

    case CD_NetUseProxy:
    {
      new_choices->use_proxy = !!state;
      if ((window = choices_find_component(CD_NetProxyAddr))    != 0)
      {
        set_gadget_state(window, CD_NetProxyAddr, !new_choices->use_proxy);
        set_gadget_state(window, CD_NetProxyLabl, !new_choices->use_proxy);
      }
    }
    break;

    case CD_NetLaunchProxy: new_choices->start_proxy = !!state; break;

    case CD_HiDontAge:
    {
      choices_set_expiry_age_greyed(!state);
      expiry_age_greyed = !state;
    }
    break;

    case CD_HiDontSize:
    {
      choices_set_max_size_greyed(idb->self_id, !state);
      max_size_greyed = !state;
    }
    break;

    case CD_HiImDontAge:
    {
      choices_set_im_expiry_age_greyed(!state);
      image_expiry_age_greyed = !state;
    }
    break;

    case CD_HiImDontSize:
    {
      choices_set_im_max_size_greyed(idb->self_id, !state);
      image_max_size_greyed = !state;
    }
    break;

    case CD_MSIE4StyleTables: new_choices->msie4_style_tables = !!state; break;

    case CD_TabSupport:
    {
      new_choices->support_tables = !!state;
      choices_set_tables_greyed(!state);
    }
    break;

    #ifdef JAVASCRIPT

      case CD_SupportJS:
      {
        new_choices->support_js = !!state;
        choices_set_js_all_greyed(!state);
      }
      break;

      case CD_JSWatchdog:
      {
        new_choices->js_watchdog = !!state;
        choices_set_js_watchdog_greyed(!state);
      }
      break;

      case CD_JSNavAsNav:   new_choices->js_nav_as_nav  = !!state; break;
      case CD_JSErrorBoxes: new_choices->js_error_boxes = !!state; break;

    #endif

    case CD_GCAfterNewFetch: new_choices->collect_after    = !!state; break;
    case CD_PreserveWidth:   new_choices->toggle_on_y_only = !!state; break;
    case CD_StripExtensions: new_choices->strip_extensions = !!state; break;

    case CD_BoldHF:   new_choices->print_hf_bold   = !!state; break;
    case CD_ItalicHF: new_choices->print_hf_italic = !!state; break;

    /* Haven't recognised this option button event so pass it on */

    default: return 0;
  }

  return 1;
}

/**************************************************************/
/* choices_map_choice_to_entry()                              */
/*                                                            */
/* Map a Choices setting to a menu entry component ID using   */
/* the given map array.                                       */
/*                                                            */
/* Parameters: Choices value;                                 */
/*                                                            */
/*             Pointer to a choices_map_t array terminated    */
/*             with an entry with an ID of NULL_ComponentId.  */
/*                                                            */
/* Returns:    Equivalent component ID or the first map entry */
/*             ID as a default if no mapping is found.        */
/**************************************************************/

static ComponentId choices_map_choice_to_entry
                   (
                     int                            choices_value,
                     const choices_map_t * restrict map
                   )
{
  int entry = 0;

  /* Simple linear search through a potentially unsorted array */
  /* - arrays are expected to be very short and the routine is */
  /* not called during speed critical sections.                */

  while (map[entry].id != NULL_ComponentId)
  {
    if (map[entry].value == choices_value) return map[entry].id;
    entry ++;
  }

  return map[0].id;
}

/**************************************************************/
/* choices_map_entry_to_choice()                              */
/*                                                            */
/* Map a menu entry component ID to a Choices setting using   */
/* the given map array.                                       */
/*                                                            */
/* Parameters: Menu entry component ID;                       */
/*                                                            */
/*             Pointer to a choices_map_t array terminated    */
/*             with an entry with an ID of NULL_ComponentId.  */
/*                                                            */
/* Returns:    Equivalent Choices setting value or the first  */
/*             map entry value as a default if no mapping is  */
/*             found.                                         */
/**************************************************************/

static int choices_map_entry_to_choice
           (
             ComponentId                    menu_entry,
             const choices_map_t * restrict map
           )
{
  int entry = 0;

  /* Simple linear search through a potentially unsorted array */
  /* - arrays are expected to be very short and the routine is */
  /* not called during speed critical sections.                */

  while (map[entry].id != NULL_ComponentId)
  {
    if (map[entry].id == menu_entry) return map[entry].value;
    entry ++;
  }

  return map[0].value;
}

/**************************************************************/
/* choices_menu_open_by_popup()                               */
/*                                                            */
/* Open a menu positioned next to a pop-up button. The menu   */
/* will not appear on screen until the next Wimp_Poll, so     */
/* subsequent alterations to its contents beforehand will not */
/* be seen by the user.                                       */
/*                                                            */
/* Parameters: Object ID of object holding pop-up button;     */
/*                                                            */
/*             Component ID of pop-up button;                 */
/*                                                            */
/*             Name of template in Res file for menu to open; */
/*                                                            */
/*             Pointer to an ObjectId, updated on successful  */
/*             exit with the object ID of the opened menu.    */
/**************************************************************/

static _kernel_oserror * choices_menu_open_by_popup
                         (
                           ObjectId               pane,
                           ComponentId            button,
                           const char  * restrict menu_name,
                           ObjectId    *          menu_object
                         )
{
  WimpGetWindowStateBlock state;
  BBox                    box;
  int                     position[2];

  /* Set open coordinates of menu to top left of display button */

  RetError(gadget_get_bbox(0, pane, button, &box));
  RetError(window_get_wimp_handle(0, pane, &state.window_handle));
  RetError(wimp_get_window_state(&state));

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock *) &state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock *) &state);

  /* (Re-)Create the menu */

  RetError(toolbox_create_object(0, (void *) menu_name, menu_object));

  /* Show the menu */

  return toolbox_show_object(Toolbox_ShowObject_AsMenu,
                             *menu_object,
                             Toolbox_ShowObject_TopLeft,
                             position,
                             pane,
                             button);
}

/**************************************************************/
/* choices_menu_popup_handler()                               */
/*                                                            */
/* Generic handler for activations of pop-up buttons designed */
/* to open menus representing a Choices item, with entries    */
/* that map to values for that item, so that at any given     */
/* time exactly one entry will be ticked in accordance with   */
/* the current value of the associated Choices item.          */
/*                                                            */
/* Parameters: Object ID of object holding pop-up button;     */
/*                                                            */
/*             Component ID of pop-up button;                 */
/*                                                            */
/*             Name of template in Res file for menu to open; */
/*                                                            */
/*             Current value of the associated Choices item;  */
/*                                                            */
/*             Pointer to a component ID, updated on          */
/*             successful exit with the component ID of the   */
/*             menu entry that got ticked based on the given  */
/*             Choices value;                                 */
/*                                                            */
/*             Pointer to a choices_map_t array giving the    */
/*             mappings between menu entries and Choices      */
/*             values terminated by an entry with a component */
/*             ID of NULL_ComponentId.                        */
/**************************************************************/

static _kernel_oserror * choices_menu_popup_handler
                         (
                           ObjectId                       pane,
                           ComponentId                    button,
                           const char          * restrict menu_name,
                           int                            choices_value,
                           ComponentId         * restrict ticked_entry,
                           const choices_map_t * restrict map
                         )
{
  ObjectId                menu;

  RetError(choices_menu_open_by_popup(pane,
                                      button,
                                      menu_name,
                                      &menu));

  /* If an entry was previously ticked, untick it */

  if (*ticked_entry != NULL_ComponentId)
  {
    RetError(menu_set_tick(0, menu, *ticked_entry, 0));
  }

  /* Set the new ticked entry value using the supplied mapping function */

  *ticked_entry = choices_map_choice_to_entry(choices_value, map);
  return menu_set_tick(0, menu, *ticked_entry, 1);
}

/**************************************************************/
/* choices_menu_selection_handler()                           */
/*                                                            */
/* Generic handler for selections in pop-up menus supporting  */
/* single ticked item selections, each entry corresponding to */
/* a value of a particular Choices item.                      */
/*                                                            */
/* Parameters: Object ID of menu;                             */
/*                                                            */
/*             Component ID of selected entry;                */
/*                                                            */
/*             Name of related menu template in Res file;     */
/*                                                            */
/*             Pointer to an int, updated on successful exit  */
/*             with the new Choices item value corresponding  */
/*             to the selected menu entry;                    */
/*                                                            */
/*             Pointer to a component ID, containing on entry */
/*             the component ID of the currently ticked menu  */
/*             entry, updated on successful exit with the     */
/*             component ID of the new ticked menu entry      */
/*                                                            */
/*             Component ID of an associated display field to */
/*             be updated with the text of the selected menu  */
/*             entry, or NULL_ComponentId if there is no such */
/*             display field;                                 */
/*                                                            */
/*             Pointer to a choices_map_t array giving the    */
/*             mappings between menu entries and Choices      */
/*             values terminated by an entry with a component */
/*             ID of NULL_ComponentId.                        */
/**************************************************************/

static _kernel_oserror * choices_menu_selection_handler
                         (
                           ObjectId                       menu_object,
                           ComponentId                    selected_entry,
                           const char          * restrict menu_name,
                           int                 * restrict choices_value,
                           ComponentId         * restrict ticked_entry,
                           ComponentId                    associated_display_field,
                           const choices_map_t * restrict map
                         )
{
  /* Was there a change in ticked entry? */

  if (
       menu_object   != NULL_ObjectId &&
       *ticked_entry != selected_entry
     )
  {
    /* Untick the current ticked item if there is one */

    if (*ticked_entry != NULL_ComponentId)
    {
      RetError(menu_set_tick(0, menu_object, *ticked_entry, 0));
    }

    /* Set the new tick and record the ticked entry */

    RetError(menu_set_tick(0, menu_object, selected_entry, 1));
    *ticked_entry = selected_entry;
  }

  /* Map the selected entry to a choices value even if the    */
  /* ticked entry appears to be the same as the new selection */

  *choices_value = choices_map_entry_to_choice(selected_entry, map);

  /* Is there an associated display field to update? If so do */
  /* it, even if the tick hasn't moved - the redraw will make */
  /* the menu re-selection seem less "dead" to the user.      */

  if (associated_display_field != NULL_ComponentId)
  {
    return choices_update_popup_menu_display_field(associated_display_field,
                                                   selected_entry,
                                                   menu_name);
  }
  else
  {
    return NULL;
  }
}

/**************************************************************/
/* choices_update_popup_menu_display_field()                  */
/*                                                            */
/* Update a display field associated with a pop-up menu using */
/* the text from one of the menu's entries.                   */
/*                                                            */
/* Parameters: Component ID of the display field - if this is */
/*             not found in the Choices panes the function    */
/*             exits with no error;                           */
/*                                                            */
/*             Component ID of the menu entry - if this is a  */
/*             NULL ID the function exits with no error;      */
/*                                                            */
/*             Name of related menu template in Res file.     */
/**************************************************************/

static _kernel_oserror * choices_update_popup_menu_display_field
                         (
                           ComponentId            display_field,
                           ComponentId            menu_entry,
                           const char  * restrict menu_name
                         )
{
  _kernel_oserror * e;
  char            * text;
  ObjectId          container;

  /* If the menu entry is NULL bail out straight away. */

  if (menu_entry == NULL_ComponentId) return NULL;

  /* Find the object holding the given display field, bailing */
  /* out if not located.                                      */

  container = choices_find_component(display_field);
  if (container == NULL_ObjectId) return NULL;

  /* Get the menu text for the given menu name associated with */
  /* the selected menu entry.                                  */

  RetError(choices_get_menu_entry_text(menu_name,
                                       menu_entry,
                                       &text));

  /* Set this in the display field, recording the error but */
  /* not returning it until the text buffer is freed.       */

  e = choices_displayfield_set_value(0,
                                     container,
                                     display_field,
                                     text);

  free(text);

  return e;
}

/**************************************************************/
/* choices_display_popup_handler()                            */
/*                                                            */
/* Opens the display menu with a value appropriate to either  */
/* the hotlist or history.                                    */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_display_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             value = 0;
  choices_map_t * map   = NULL;

  /* This menu is used for both hotlist and history display */

  switch(idb->self_component)
  {
    default:
    case CD_HlDispBt: value = new_choices->hotlist_show; map = map_hldisplay; break;
    case CD_HiDispBt: value = new_choices->show_urls;    map = map_hidisplay; break;
  }

  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChDisplay",
                                            value,
                                            &disp_ticked,
                                            map));
  return 1;
}

/**************************************************************/
/* choices_save_popup_handler()                               */
/*                                                            */
/* Opens the save menu with a value appropriate to either the */
/* hotlist or visit/image history.                            */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_save_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             value = 0;
  choices_map_t * map   = NULL;

  /* This menu is used for both hotlist and history display */

  switch(idb->self_component)
  {
    default:
    case CD_HlSaveBt:   value = new_choices->save_hotlist;       map = map_hlsave;   break;
    case CD_HiSaveBt:   value = new_choices->save_history;       map = map_hisave;   break;
    case CD_HiImSaveBt: value = new_choices->save_image_history; map = map_hiimsave; break;
  }

  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChSave",
                                            value,
                                            &save_ticked,
                                            map));
  return 1;
}

/**************************************************************/
/* choices_pagebreak_popup_handler()                          */
/*                                                            */
/* Handles page break menu pop-up button activations.         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_pagebreak_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChPBreakAt",
                                            new_choices->print_page_break_hx,
                                            &pbrk_ticked,
                                            map_pagebreak));
  return 1;
}

/**************************************************************/
/* choices_uri_popup_handler()                                */
/*                                                            */
/* Handles URI handler menu pop-up button activations.        */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_uri_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChURI",
                                            new_choices->uri_usage,
                                            &urih_ticked,
                                            map_uri));
  return 1;
}

/**************************************************************/
/* choices_cookie_popup_handler()                             */
/*                                                            */
/* Handles cookie menu pop-up button activations.             */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_cookie_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChCookies",
                                            new_choices->cookies,
                                            &cook_ticked,
                                            map_cookie));
  return 1;
}

/**************************************************************/
/* choices_referer_popup_handler()                            */
/*                                                            */
/* Handles referer menu pop-up button activations.            */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_referer_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChReferer",
                                            new_choices->send_referer,
                                            &refe_ticked,
                                            map_referer));
  return 1;
}

/**************************************************************/
/* choices_jpeg_popup_handler()                               */
/*                                                            */
/* Handles JPEG menu pop-up button activations.               */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_jpeg_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChJPEG",
                                            new_choices->support_pjpeg,
                                            &jpeg_ticked,
                                            map_jpeg));
  return 1;
}

/**************************************************************/
/* choices_table_border_popup_handler()                       */
/*                                                            */
/* Opens the table border menu with a value appropriate to    */
/* either the inner or outer borders.                         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_table_border_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             value = 0;
  choices_map_t * map   = NULL;

  /* This menu is used for both hotlist and history display */

  switch(idb->self_component)
  {
    default:
    case CD_TabInnerBordBt: value = new_choices->table_inner; map = map_table_inner; break;
    case CD_TabOuterBordBt: value = new_choices->table_outer; map = map_table_outer; break;
  }

  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChTabBord",
                                            value,
                                            &bord_ticked,
                                            map));
  return 1;
}

/**************************************************************/
/* choices_plugin_popup_handler()                             */
/*                                                            */
/* Handles plug-in launch menu pop-up button activations.     */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_plugin_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChPlugin",
                                            new_choices->plugin_control,
                                            &plug_ticked,
                                            map_plugin));
  return 1;
}

/**************************************************************/
/* choices_timetype_popup_handler()                           */
/*                                                            */
/* Displays the time units menu when the appropriate          */
/* toolaction button is pressed.                              */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_timetype_popup_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  choices_time_e value;

  /* This menu is used for both image and visit histories */

  switch(idb->self_component)
  {
    default:
    case CD_HiAgeTypeBt:   value = history_expiry_units; break;
    case CD_HiImAgeTypeBt: value = image_expiry_units;   break;
  }

  show_error_ret(choices_menu_popup_handler(idb->self_id,
                                            idb->self_component,
                                            "ChTime",
                                            (int) value,
                                            &time_ticked,
                                            map_timetype));
  return 1;
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* choices_win_open_popup_handler()                           */
  /*                                                            */
  /* Handles JS 'window.open' menu pop-up button activations.   */
  /*                                                            */
  /* Parameters: As standard for a Toolbox event handler.       */
  /**************************************************************/

  static int choices_win_open_popup_handler
             (
               const int                     eventcode,
               const ToolboxEvent * restrict event,
               const IdBlock      * restrict idb,
               const void         * restrict handle
             )
  {
    show_error_ret(choices_menu_popup_handler(idb->self_id,
                                              idb->self_component,
                                              "ChWinOpen",
                                              new_choices->js_window_open,
                                              &wino_ticked,
                                              map_win_open));
    return 1;
  }

  /**************************************************************/
  /* choices_win_close_popup_handler()                          */
  /*                                                            */
  /* Handles JS 'window.close' menu pop-up button activations.  */
  /*                                                            */
  /* Parameters: As standard for a Toolbox event handler.       */
  /**************************************************************/

  static int choices_win_close_popup_handler
             (
               const int                     eventcode,
               const ToolboxEvent * restrict event,
               const IdBlock      * restrict idb,
               const void         * restrict handle
             )
  {
    show_error_ret(choices_menu_popup_handler(idb->self_id,
                                              idb->self_component,
                                              "ChWinClose",
                                              new_choices->js_window_close,
                                              &winc_ticked,
                                              map_win_close));
    return 1;
  }

#endif

/**************************************************************/
/* choices_font_button_handler()                              */
/*                                                            */
/* Opens a font menu box with appropriate settings for the    */
/* current font.                                              */
/**************************************************************/

static int choices_font_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  WimpGetWindowStateBlock   state;
  BBox                      box;
  int                       position[2];
  ObjectId                  fontmenu_id;
  char                    * fontname = NULL;

  /* Ensure we know why we're being opened */

  switch(idb->self_component)
  {
    case CD_FontsTF1Bt: break;
    case CD_FontsTF2Bt: break;
    case CD_FontsTF3Bt: break;

    default: return 1;
  }

  /* Set open coordinates of menu to top left of display idb->self_component */

  ChkError(gadget_get_bbox(0, idb->self_id, idb->self_component, &box));
  ChkError(window_get_wimp_handle(0, idb->self_id, &state.window_handle));
  ChkError(wimp_get_window_state(&state));

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock *) &state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock *) &state);

  /* Create the menu */

  ChkError(toolbox_create_object(0, "FontMenu", &fontmenu_id));

  /* Set the selected (ticked) font. Irritatingly this has to be done */
  /* before the menu is opened or fontmenu_set_font appears to do     */
  /* nothing - presumably a Toolbox bug - so we can't use the generic */
  /* "open menu at popup" routine.                                    */

  switch(idb->self_component)
  {
    case CD_FontsTF1Bt: fontname = new_typefaces[0].fontnames[0]; break;
    case CD_FontsTF2Bt: fontname = new_typefaces[1].fontnames[0]; break;
    case CD_FontsTF3Bt: fontname = new_typefaces[2].fontnames[0]; break;
  }

  ChkError(fontmenu_set_font(0, fontmenu_id, fontname));

  /* Show the menu */

  ChkError(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                               fontmenu_id,
                               Toolbox_ShowObject_TopLeft,
                               position,
                               idb->self_id,
                               idb->self_component));

  /* Register event handlers and return */

  ChkError(event_register_toolbox_handler(fontmenu_id, FontMenu_HasBeenHidden, choices_font_closed_handler,   NULL));
  ChkError(event_register_toolbox_handler(fontmenu_id, FontMenu_Selection,     choices_font_selected_handler, NULL));

  return 1;
}

/**************************************************************/
/* choices_encoding_button_handler()                          */
/*                                                            */
/* Opens the encoding window with appropriate values for the  */
/* choices dialogue.                                          */
/**************************************************************/

static int choices_encoding_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;

  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  /* Set open coordinates of encoding menu to top left of encoding button */

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     encoding_get_menuid(),
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     choices_windowid,
                                     NULL));

  return 1;
}

/**************************************************************/
/* choices_colour_button_handler()                            */
/*                                                            */
/* Opens a colour dialogue box with appropriate settings for  */
/* the current colour.                                        */
/**************************************************************/

static int choices_colour_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;
  int colour[2];

  /* Is the ColourDbox module in RMA? */

  e = _swix(OS_Module, _INR(0,1), 18, "ColourDbox");

  /* No, well try and load it from system */

  if (e)
  {
    e = _swix(OS_Module, _INR(0,1), 1, "System:Modules.Toolbox.ColourDbox");
  }

  /* That didn't work so try reinitialising it */

  if (e)
  {
    e = _swix(OS_Module, _INR(0,1), 3, "ColourDbox");
  }

  /* That didn't work either!  So it's tough you can't change the colours */

  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  switch(idb->self_component)
  {
    case CD_BackColourBt: colour[0] = new_choices->background_colour; break;
    case CD_TextColourBt: colour[0] = new_choices->text_colour;       break;
    case CD_LinkColourBt: colour[0] = new_choices->link_colour;       break;
    case CD_UsedColourBt: colour[0] = new_choices->used_colour;       break;
    case CD_FolwColourBt: colour[0] = new_choices->followed_colour;   break;
    case CD_SlctColourBt: colour[0] = new_choices->selected_colour;   break;
    default:
    return 1;
    break;
  }

  colour[1] = 0;

  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  /* Set open coordinates of encoding menu to top left of encoding button */

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

  e = toolbox_create_object(0, "ColourDbox", &colourdbox_id);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = colourdbox_set_colour(0, colourdbox_id, colour);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     colourdbox_id,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));

  e = event_register_toolbox_handler(colourdbox_id, ColourDbox_DialogueCompleted, choices_colour_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = event_register_toolbox_handler(colourdbox_id, ColourDbox_ColourSelected, choices_colour_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  return 1;
}

/**************************************************************/
/* choices_display_selection_handler()                        */
/*                                                            */
/* Called when there is a selection in the display menu. Sets */
/* the selected menu item to be ticked, unticks the           */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the associated display field.                  */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_display_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             new_value     = 0;
  ComponentId     display_field = NULL_ComponentId;
  choices_map_t * map           = NULL;

  /* This menu is used for both hotlist and history display */

  switch (idb->parent_component)
  {
    case CD_HlDispBt: display_field = CD_HlDispDisp; map = map_hldisplay; break;
    case CD_HiDispBt: display_field = CD_HiDispDisp; map = map_hidisplay; break;
  }

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChDisplay",
                                                &new_value,
                                                &disp_ticked,
                                                display_field,
                                                map));

  switch(idb->parent_component)
  {
    case CD_HlDispBt: new_choices->hotlist_show = new_value; break;
    case CD_HiDispBt: new_choices->show_urls    = new_value; break;
  }

  return 1;
}

/**************************************************************/
/* choices_save_selection_handler()                           */
/*                                                            */
/* Called when there is a selection in the save menu. Sets    */
/* the selected menu item to be ticked, unticks the           */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the associated display field.                  */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_save_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             new_value     = 0;
  ComponentId     display_field = NULL_ComponentId;
  choices_map_t * map           = NULL;

  /* This menu is used for both hotlist and history display */

  switch (idb->parent_component)
  {
    case CD_HlSaveBt:   display_field = CD_HlSaveDisp;   map = map_hlsave;   break;
    case CD_HiSaveBt:   display_field = CD_HiSaveDisp;   map = map_hisave;   break;
    case CD_HiImSaveBt: display_field = CD_HiImSaveDisp; map = map_hiimsave; break;
  }

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChSave",
                                                &new_value,
                                                &save_ticked,
                                                display_field,
                                                map));

  switch(idb->parent_component)
  {
    case CD_HlSaveBt:   new_choices->save_hotlist       = new_value; break;
    case CD_HiSaveBt:   new_choices->save_history       = new_value; break;
    case CD_HiImSaveBt: new_choices->save_image_history = new_value; break;
  }

  return 1;
}

/**************************************************************/
/* choices_pagebreak_selection_handler()                      */
/*                                                            */
/* Handle page break menu selections.                         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_pagebreak_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChPBreakAt",
                                                &new_value,
                                                &pbrk_ticked,
                                                CD_PageBreakDisp,
                                                map_pagebreak));

  new_choices->print_page_break_hx = new_value;
  return 1;
}

/**************************************************************/
/* choices_uri_selection_handler()                            */
/*                                                            */
/* Handle URI handler menu selections.                        */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_uri_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChURI",
                                                &new_value,
                                                &urih_ticked,
                                                CD_URIHandlerDisp,
                                                map_uri));
  new_choices->uri_usage = new_value;
  return 1;
}

/**************************************************************/
/* choices_cookie_selection_handler()                         */
/*                                                            */
/* Handle cookie menu selections.                             */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_cookie_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChCookies",
                                                &new_value,
                                                &cook_ticked,
                                                CD_CookieDisp,
                                                map_cookie));
  new_choices->cookies = new_value;
  return 1;
}

/**************************************************************/
/* choices_referer_selection_handler()                        */
/*                                                            */
/* Handle referer menu selections.                            */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_referer_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChReferer",
                                                &new_value,
                                                &refe_ticked,
                                                CD_RefererDisp,
                                                map_referer));
  new_choices->send_referer = new_value;
  return 1;
}

/**************************************************************/
/* choices_jpeg_selection_handler()                           */
/*                                                            */
/* Handle JPEG menu selections.                               */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_jpeg_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChJPEG",
                                                &new_value,
                                                &jpeg_ticked,
                                                CD_JPEGDisp,
                                                map_jpeg));
  new_choices->support_pjpeg = new_value;
  return 1;
}

/**************************************************************/
/* choices_table_border_selection_handler()                   */
/*                                                            */
/* Called when there is a selection in the table border menu. */
/* Sets the selected menu item to be ticked, unticks the      */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the associated display field.                  */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_table_border_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int             new_value     = 0;
  ComponentId     display_field = NULL_ComponentId;
  choices_map_t * map           = NULL;

  /* This menu is used for both inner and outer border styles */

  switch (idb->parent_component)
  {
    case CD_TabInnerBordBt: display_field = CD_TabInnerBordDisp; map = map_table_inner; break;
    case CD_TabOuterBordBt: display_field = CD_TabOuterBordDisp; map = map_table_outer; break;
  }

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChTabBord",
                                                &new_value,
                                                &bord_ticked,
                                                display_field,
                                                map));

  switch(idb->parent_component)
  {
    case CD_TabInnerBordBt: new_choices->table_inner = new_value; break;
    case CD_TabOuterBordBt: new_choices->table_outer = new_value; break;
  }

  return 1;
}

/**************************************************************/
/* choices_plugin_selection_handler()                         */
/*                                                            */
/* Handle plug-in launch menu selections.                     */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_plugin_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int new_value;

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChPlugin",
                                                &new_value,
                                                &plug_ticked,
                                                CD_ObjPlugDisp,
                                                map_plugin));
  new_choices->plugin_control = new_value;
  return 1;
}

/**************************************************************/
/* choices_timetype_selection_handler()                       */
/*                                                            */
/* Called when there is a selection in the time units menu.   */
/* Sets the selected menu item to be ticked, unticks the      */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the associated display and numerical fields.   */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_timetype_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  choices_time_e old_units, new_units;
  ComponentId    numbers, display;
  ObjectId       window;

  /* This menu is used for both image and visit histories */

  switch (idb->parent_component)
  {
    default:

    case CD_HiAgeTypeBt:   numbers = CD_HiExpiryAge;   display = CD_HiAgeTypeDisp;   break;
    case CD_HiImAgeTypeBt: numbers = CD_HiImExpiryAge; display = CD_HiImAgeTypeDisp; break;
  }

  show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                idb->self_component,
                                                "ChTime",
                                                (int *) &new_units,
                                                &time_ticked,
                                                display,
                                                map_timetype));

  /* This menu is used for both image and visit histories */

  switch (idb->parent_component)
  {
    default:

    case CD_HiAgeTypeBt:   old_units = history_expiry_units; history_expiry_units = new_units; break;
    case CD_HiImAgeTypeBt: old_units = image_expiry_units;   image_expiry_units   = new_units; break;
  }

  /* Sort out the number range gadget */

  window = choices_find_component(numbers);

  if (window != NULL_ObjectId)
  {
    int temptime;

    /* What was the existing time converted to seconds using the old units? */

    show_error_ret(numberrange_get_value(0, window, numbers, &temptime));

    temptime = choices_typed_time_to_seconds(temptime, old_units);

    /* Set this time in the new units, then bound the number range to make */
    /* sure the figure is pulled into range.                               */

    show_error_ret(numberrange_set_value(0,
                                         window,
                                         numbers,
                                         choices_seconds_to_typed_time(temptime,
                                                                       new_units)));

    show_error_ret(numberrange_set_bounds(NumberRange_LowerBound |
                                          NumberRange_UpperBound |
                                          NumberRange_StepSize   |
                                          NumberRange_Precision,

                                          window,
                                          numbers,
                      /* Lower bound */   1,
                      /* Upper bound */   choices_get_range_of_typed_time(new_units),
                      /* Step size   */   1,
                      /* Precision   */   0));
  }

  return 1;
}

/**************************************************************/
/* choices_hfspecial_selection_handler()                      */
/*                                                            */
/* Handle header/footer special text menu selections.         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_hfspecial_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int         index = choices_map_entry_to_choice(idb->self_component, map_hfspecial);
  ObjectId    window;
  ComponentId writable;

  /* Find the writable field related to the parent pop-up button */

  switch (idb->parent_component)
  {
    default:

    case CD_HeaderLeftBt:   writable = CD_HeaderLeft;   break;
    case CD_HeaderMiddleBt: writable = CD_HeaderMiddle; break;
    case CD_HeaderRightBt:  writable = CD_HeaderRight;  break;
    case CD_FooterLeftBt:   writable = CD_FooterLeft;   break;
    case CD_FooterMiddleBt: writable = CD_FooterMiddle; break;
    case CD_FooterRightBt:  writable = CD_FooterRight;  break;
  }

  /* Insert text based on the selection */

  window = choices_find_component(writable);

  if (
       window != NULL_ObjectId &&
       index  >= 0             &&
       index  <  sizeof(special_text) / sizeof(*special_text)
     )
  {
    show_error_ret(choices_writablefield_add_text(0,
                                                  window,
                                                  writable,
                                                  special_text[index]));
  }

  return 1;
}

/**************************************************************/
/* choices_hfspecsub_selection_handler()                      */
/*                                                            */
/* Handle header/footer special text sub-menu selections.     */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_hfspecsub_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  ObjectId    window,   original_object;
  ComponentId writable, original_component;

  int         index    = choices_map_entry_to_choice(idb->parent_component, map_hfspecial);
  int         subindex = choices_map_entry_to_choice(idb->self_component,   map_hfspecsub);

  /* Find the writable field related to the original pop-up button - */
  /* this is our parent's parent (*not* the ancestor).               */

  ChkError(toolbox_get_parent(0,
                              idb->parent_id,
                              &original_object,
                              &original_component));

  switch (original_component)
  {
    default:

    case CD_HeaderLeftBt:   writable = CD_HeaderLeft;   break;
    case CD_HeaderMiddleBt: writable = CD_HeaderMiddle; break;
    case CD_HeaderRightBt:  writable = CD_HeaderRight;  break;
    case CD_FooterLeftBt:   writable = CD_FooterLeft;   break;
    case CD_FooterMiddleBt: writable = CD_FooterMiddle; break;
    case CD_FooterRightBt:  writable = CD_FooterRight;  break;
  }

  /* Insert text based on the selection */

  window  = choices_find_component(writable);
  index  += subindex;

  if (
       window != NULL_ObjectId &&
       index  >= 0             &&
       index  <  sizeof(special_text) / sizeof(*special_text)
     )
  {
    show_error_ret(choices_writablefield_add_text(0,
                                                  window,
                                                  writable,
                                                  special_text[index]));
  }

  return 1;
}

/**************************************************************/
/* choices_hfdate_selection_handler()                         */
/*                                                            */
/* Handle header/footer special text menu selections.         */
/*                                                            */
/* Parameters: As standard for a Toolbox event handler.       */
/**************************************************************/

static int choices_hfdate_selection_handler
           (
             const int                     eventcode,
             const ToolboxEvent * restrict event,
             const IdBlock      * restrict idb,
             const void         * restrict handle
           )
{
  int      index = choices_map_entry_to_choice(idb->self_component, map_hfdate);
  ObjectId window;

  /* Insert text based on the selection */

  window = choices_find_component(CD_DateFormat);

  if (
       window != NULL_ObjectId &&
       index  >= 0             &&
       index  <  sizeof(special_date) / sizeof(*special_date)
     )
  {
    show_error_ret(choices_writablefield_add_text(0,
                                                  window,
                                                  CD_DateFormat,
                                                  special_date[index]));
  }

  return 1;
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* choices_win_open_selection_handler()                       */
  /*                                                            */
  /* Handle JS 'window.open' menu selections.                   */
  /*                                                            */
  /* Parameters: As standard for a Toolbox event handler.       */
  /**************************************************************/

  static int choices_win_open_selection_handler
             (
               const int                     eventcode,
               const ToolboxEvent * restrict event,
               const IdBlock      * restrict idb,
               const void         * restrict handle
             )
  {
    int new_value;

    show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                  idb->self_component,
                                                  "ChWinOpen",
                                                  &new_value,
                                                  &wino_ticked,
                                                  CD_JSWinOpenDisp,
                                                  map_win_open));
    new_choices->js_window_open = new_value;
    return 1;
  }

  /**************************************************************/
  /* choices_win_close_selection_handler()                      */
  /*                                                            */
  /* Handle JS 'window.close' menu selections.                  */
  /*                                                            */
  /* Parameters: As standard for a Toolbox event handler.       */
  /**************************************************************/

  static int choices_win_close_selection_handler
             (
               const int                     eventcode,
               const ToolboxEvent * restrict event,
               const IdBlock      * restrict idb,
               const void         * restrict handle
             )
  {
    int new_value;

    show_error_ret(choices_menu_selection_handler(idb->self_id,
                                                  idb->self_component,
                                                  "ChWinClose",
                                                  &new_value,
                                                  &winc_ticked,
                                                  CD_JSWinCloseDisp,
                                                  map_win_close));
    new_choices->js_window_close = new_value;
    return 1;
  }

#endif

/**************************************************************/
/* choices_font_selected_handler()                            */
/*                                                            */
/* Called when the a font is selected in the font menu.       */
/**************************************************************/

static int choices_font_selected_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  char font[4] [Limits_FontName], *p, *p2;
  int found;
  fm_typeface * target;

  dprintf(("Choi", "choices_font_selected_handler: called\n"
                   "choices_font_selected_handler: Selected font = %s\n",

                   ((FontMenuSelectionEvent *) event)->font_id));

  p2 = font[0];

  /* Assume that the F field will be found because the font menu */
  /* returns the font in the correct format.                     */

  ChkError(_swix(Font_FindField, _INR(1,2)|_OUTR(1,2), ((FontMenuSelectionEvent*)event)->font_id, 'F', &p, &found));

  /* Extract the font name */

  while (*p > 32 && *p != '\\') *p2++ = *p++;
  *p2 = '\0';

  choices_modified_font(font[0], getenv("Font$Italic"), font[1]); /* Get italic variant of base font */
  choices_modified_font(font[0], getenv("Font$Bold"),   font[2]); /* Get bold version of base font   */
  choices_modified_font(font[2], getenv("Font$Italic"), font[3]); /* Get italic version of bold font */

  dprintf(("Choi", "Base font           = %s\n"
                   "Italic version      = %s\n"
                   "Bold version        = %s\n"
                   "Bold-Italic version = %s\n",

                   font[0],
                   font[1],
                   font[2],
                   font[3]));

  /* Set display field to name of new font */
  /* Ignore error as the display isn't     */
  /* required.                             */

  choices_displayfield_set_value(0, idb->parent_id, idb->parent_component - 1, font[0]);

  switch(idb->parent_component)
  {
    case CD_FontsTF1Bt: target = &new_typefaces[0]; break;
    case CD_FontsTF2Bt: target = &new_typefaces[1]; break;
    case CD_FontsTF3Bt: target = &new_typefaces[2]; break;

    default:
    return 1;
    break;
  }

  strcpy(target->fontnames[0], font[0]);
  strcpy(target->fontnames[1], font[1]);
  strcpy(target->fontnames[2], font[2]);
  strcpy(target->fontnames[3], font[3]);

  return 1;
}

/**************************************************************/
/* choices_colour_selected_handler()                          */
/*                                                            */
/* Called when the a colour is selected in the colour         */
/* dialogue box. Sets appropriate fields in the new_choices   */
/* structure and updates the window to reflect the new colour */
/* chosen.                                                    */
/**************************************************************/

static int choices_colour_selected_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ColourDboxColourSelectedEvent *cevent = (ColourDboxColourSelectedEvent*)event;

  switch(idb->parent_component)
  {
    case CD_BackColourBt: new_choices->background_colour = cevent->colour_block[0]; break;
    case CD_TextColourBt: new_choices->text_colour       = cevent->colour_block[0]; break;
    case CD_LinkColourBt: new_choices->link_colour       = cevent->colour_block[0]; break;
    case CD_UsedColourBt: new_choices->used_colour       = cevent->colour_block[0]; break;
    case CD_FolwColourBt: new_choices->followed_colour   = cevent->colour_block[0]; break;
    case CD_SlctColourBt: new_choices->selected_colour   = cevent->colour_block[0]; break;
    default:
    return 1;
    break;
  }

  /* Don't bother with errors as colour display field might not exist */

  choices_colour_set_component(idb->parent_id, idb->parent_component-1, cevent->colour_block[0]);

  /* Don't bother with errors as fake page display might not exist */

  button_set_flags(0, idb->parent_id, CD_FakePage, 0, 0);

  return 1;
}

/**************************************************************/
/* choices_font_closed_handler()                              */
/*                                                            */
/* Called when the font menu is closed deregisters all events */
/* attached to it and deletes the menu object.                */
/**************************************************************/

static int choices_font_closed_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;

  e = event_register_toolbox_handler(idb->self_id, FontMenu_HasBeenHidden, choices_font_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = event_register_toolbox_handler(idb->self_id, FontMenu_Selection, choices_font_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = toolbox_delete_object(0, idb->self_id);
  if (e) {show_error_ret(e); return 1;}

  dprintf(("Choi", "choices_font_closed_handler: FontMenu deleted\n"));

  return 1;
}

/**************************************************************/
/* choices_colour_closed_handler()                            */
/*                                                            */
/* Called when the colour dialogue box is closed deregisters  */
/* all events attached to it and deletes the dbox object.     */
/**************************************************************/

static int choices_colour_closed_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;

  e = event_deregister_toolbox_handler(idb->self_id, ColourDbox_DialogueCompleted, choices_colour_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = event_deregister_toolbox_handler(colourdbox_id, ColourDbox_ColourSelected, choices_colour_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = toolbox_delete_object(0, idb->self_id);
  if (e) {show_error_ret(e); return 1;}

  dprintf(("Choi", "choices_colour_closed_handler: Colour DBox deleted\n"));

  return 1;
}

/**************************************************************/
/* choices_set_encoding_field()                               */
/*                                                            */
/* Sets the encoding display field appropriately to reflect   */
/* the current state of new_choices->encoding                 */
/**************************************************************/

_kernel_oserror * choices_set_encoding_field(void)
{
  _kernel_oserror * e;
  ObjectId          objid, destwind;
  ComponentId       compid;
  char            * textptr;
  int               sizereqd;

  /* Find which window the encoding display is in */

  destwind = choices_find_component(CD_EncodingDisply);
  if (!destwind) return NULL;

  /* Find menu item which contains encoding name */

  if (encoding_get_encoding_item(new_choices->encoding, &objid, &compid))
  {
    RetError(menu_get_entry_text(0, objid, compid, NULL, 0, &sizereqd));

    /* Add 1 to the buffer size just incase the sizereqd field is returned as string */
    /* length rather than the buffer size required.  Typical paranoid precautions    */
    /* when using the toolbox.                                                       */

    textptr = malloc(sizereqd+1);

    if (textptr)
    {
      e = menu_get_entry_text(0, objid, compid, textptr, sizereqd+1, NULL);
      if (e)
      {
        free(textptr);
        return e;
      }

      e = choices_displayfield_set_value(0, destwind, CD_EncodingDisply, textptr);

      free(textptr);
      return e;
    }
    else
    {
      RetError(make_no_memory_error(18));
    }
  }
  else
  {
    /* The encoding name could not be found in the menu structure */

    RetError(choices_displayfield_set_value(0,
                                            destwind,
                                            CD_EncodingDisply,
                                            lookup_token("NoEncoding:Unknown encoding", 0, 0)));
  }

  return NULL;
}

/**************************************************************/
/* choices_set_display_field()                                */
/*                                                            */
/* Sets the passed display menu display field appropriately   */
/* to reflect the passed state.                               */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_display_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  ComponentId menu_entry = NULL_ComponentId;

  dprintf(("Choi", "choices_set_display_field: Called\n"));

  /* This menu is used for both hotlist and history display */

  switch (display_field)
  {
    case CD_HlDispDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_hldisplay); break;
    case CD_HiDispDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_hidisplay); break;
  }

  /* Safe even if menu_entry still holds a NULL ID */

  return choices_update_popup_menu_display_field(display_field,
                                                 menu_entry,
                                                 "ChDisplay");
}

/**************************************************************/
/* choices_set_save_field()                                   */
/*                                                            */
/* Sets the passed save display field appropriately to        */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_save_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  ComponentId menu_entry = NULL_ComponentId;

  dprintf(("Choi", "choices_set_save_field: Called\n"));

  /* This menu is used in several different places */

  switch (display_field)
  {
    case CD_HlSaveDisp:   menu_entry = choices_map_choice_to_entry(choices_value, map_hlsave);   break;
    case CD_HiSaveDisp:   menu_entry = choices_map_choice_to_entry(choices_value, map_hisave);   break;
    case CD_HiImSaveDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_hiimsave); break;
  }

  /* Safe even if menu_entry still holds a NULL ID */

  return choices_update_popup_menu_display_field(display_field,
                                                 menu_entry,
                                                 "ChSave");
}

/**************************************************************/
/* choices_set_pagebreak_field()                              */
/*                                                            */
/* Sets the passed page break display field appropriately to  */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_pagebreak_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_pagebreak_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_pagebreak),
                                                 "ChPBreakAt");
}

/**************************************************************/
/* choices_set_uri_field()                                    */
/*                                                            */
/* Sets the passed URI handler display field appropriately to */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_uri_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_uri_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_uri),
                                                 "ChURI");
}

/**************************************************************/
/* choices_set_cookie_field()                                 */
/*                                                            */
/* Sets the passed cookie display field appropriately to      */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_cookie_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_cookie_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_cookie),
                                                 "ChCookies");
}

/**************************************************************/
/* choices_set_referer_field()                                */
/*                                                            */
/* Sets the passed referer display field appropriately to     */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_referer_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_referer_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_referer),
                                                 "ChReferer");
}

/**************************************************************/
/* choices_set_jpeg_field()                                   */
/*                                                            */
/* Sets the passed JPEG display field appropriately to        */
/* reflect the passed state.                                  */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_jpeg_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_jpeg_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_jpeg),
                                                 "ChJPEG");
}

/**************************************************************/
/* choices_set_table_border_field()                           */
/*                                                            */
/* Sets the passed table border display field appropriately   */
/* to reflect the passed state.                               */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_table_border_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  ComponentId menu_entry = NULL_ComponentId;

  dprintf(("Choi", "choices_set_table_border_field: Called\n"));

  /* This menu is used for both hotlist and history display */

  switch (display_field)
  {
    case CD_TabInnerBordDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_table_inner); break;
    case CD_TabOuterBordDisp: menu_entry = choices_map_choice_to_entry(choices_value, map_table_outer); break;
  }

  /* Safe even if menu_entry still holds a NULL ID */

  return choices_update_popup_menu_display_field(display_field,
                                                 menu_entry,
                                                 "ChTabBord");
}

/**************************************************************/
/* choices_set_plugin_field()                                 */
/*                                                            */
/* Sets the passed plug-in launch display field appropriately */
/* to reflect the passed state.                               */
/*                                                            */
/* Parameters: Component ID of the display field;             */
/*                                                            */
/*             State (a Choices item value).                  */
/**************************************************************/

static _kernel_oserror * choices_set_plugin_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_plugin_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_plugin),
                                                 "ChPlugin");
}

/**************************************************************/
/* choices_set_timetype_field()                               */
/*                                                            */
/* Sets the time field appropriately to reflect the passed    */
/* state.                                                     */
/*                                                            */
/* Parameters: timetype - see defined values in choices.h     */
/**************************************************************/

static _kernel_oserror * choices_set_timetype_field
                         (
                           ComponentId display_field,
                           int         choices_value
                         )
{
  dprintf(("Choi", "choices_set_timetype_field: Called\n"));

  return choices_update_popup_menu_display_field(display_field,
                                                 choices_map_choice_to_entry(choices_value,
                                                                             map_timetype),
                                                 "ChTime");
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* choices_set_win_open_field()                               */
  /*                                                            */
  /* Sets the passed window.open display field appropriately to */
  /* reflect the passed state.                                  */
  /*                                                            */
  /* Parameters: Component ID of the display field;             */
  /*                                                            */
  /*             State (a Choices item value).                  */
  /**************************************************************/

  static _kernel_oserror * choices_set_win_open_field
                           (
                             ComponentId display_field,
                             int         choices_value
                           )
  {
    dprintf(("Choi", "choices_set_win_open_field: Called\n"));

    return choices_update_popup_menu_display_field(display_field,
                                                   choices_map_choice_to_entry(choices_value,
                                                                               map_win_open),
                                                   "ChWinOpen");
  }

  /**************************************************************/
  /* choices_set_win_close_field()                              */
  /*                                                            */
  /* Sets the passed window.close display field appropriately   */
  /* to reflect the passed state.                               */
  /*                                                            */
  /* Parameters: Component ID of the display field;             */
  /*                                                            */
  /*             State (a Choices item value).                  */
  /**************************************************************/

  static _kernel_oserror * choices_set_win_close_field
                           (
                             ComponentId display_field,
                             int         choices_value
                           )
  {
    dprintf(("Choi", "choices_set_win_close_field: Called\n"));

    return choices_update_popup_menu_display_field(display_field,
                                                   choices_map_choice_to_entry(choices_value,
                                                                               map_win_close),
                                                   "ChWinClose");
  }

#endif

/**************************************************************/
/* choices_return_appropriate_timetype()                      */
/*                                                            */
/* Given a time in seconds returns the most appropriate set   */
/* of units to display that time in.                          */
/*                                                            */
/* Parameters: Time in seconds.                               */
/*                                                            */
/* Returns:    The type of the appropriate units.             */
/**************************************************************/

static choices_time_e choices_return_appropriate_timetype(int seconds)
{
  if (seconds <= 60*60)        return choices_time_MINUTES;
  if (seconds <= 60*60*24)     return choices_time_HOURS;
  if (seconds <= 60*60*24*7)   return choices_time_DAYS;
  if (seconds <= 60*60*24*7*4) return choices_time_WEEKS;

  return choices_time_MONTHS;
}

/**************************************************************/
/* choices_seconds_to_typed_time()                            */
/*                                                            */
/* Converts a time in seconds to a time in the passed units.  */
/*                                                            */
/* Parameters: Time in seconds;                               */
/*                                                            */
/*             The units in which to return the time.         */
/*                                                            */
/* Returns:    The time in the passed units.                  */
/**************************************************************/

static int choices_seconds_to_typed_time(int secs, choices_time_e timetype)
{
  switch (timetype)
  {
    case choices_time_MINUTES: return choices_clip_to_min_max(secs/(60),           1, 60);
    case choices_time_HOURS:   return choices_clip_to_min_max(secs/(60*60),        1, 24);
    case choices_time_DAYS:    return choices_clip_to_min_max(secs/(60*60*24),     1, 7);
    case choices_time_WEEKS:   return choices_clip_to_min_max(secs/(60*60*24*7),   1, 4);
    case choices_time_MONTHS:  return choices_clip_to_min_max(secs/(60*60*24*7*4), 1, 12);
    default:                   return 1;
  }
}

/**************************************************************/
/* choices_typed_time_to_seconds()                            */
/*                                                            */
/* Converts a time in the passed units to seconds.            */
/*                                                            */
/* Parameters: Time in passed units;                          */
/*                                                            */
/*             Units which the time was passed.               */
/*                                                            */
/* Returns:    Time in seconds.                               */
/**************************************************************/

static int choices_typed_time_to_seconds(int time, choices_time_e timetype)
{
  switch (timetype)
  {
    case choices_time_MINUTES: return time * 60;
    case choices_time_HOURS:   return time * 60*60;
    case choices_time_DAYS:    return time * 60*60*24;
    case choices_time_WEEKS:   return time * 60*60*24*7;
    case choices_time_MONTHS:  return time * 60*60*24*7*4;
    default:                   return 0;
  }
}

/**************************************************************/
/* choices_get_range_of_typed_time()                          */
/*                                                            */
/* Returns the max acceptable value of the passed time units  */
/* type.                                                      */
/*                                                            */
/* Parameters: The type of time units.                        */
/*                                                            */
/* Returns:    The maximum acceptable value.                  */
/**************************************************************/

static int choices_get_range_of_typed_time(choices_time_e timetype)
{
  switch (timetype)
  {
    case choices_time_MINUTES: return 60;
    case choices_time_HOURS:   return 24;
    case choices_time_DAYS:    return 7;
    case choices_time_WEEKS:   return 4;
    case choices_time_MONTHS:  return 12;
    default:                   return 0;
  }
}

/**************************************************************/
/* choices_batch_gadget_state()                               */
/*                                                            */
/* Set a batch of gadgets grey or ungrey in a way that will   */
/* minimise flicker.                                          */
/*                                                            */
/* Parameters: Pointer to an array of component IDs for all   */
/*             gadgets to be modified, terminated by an entry */
/*             of NULL_ComponentId;                           */
/*                                                            */
/*             1 to grey the gadgets, 0 to ungrey them.       */
/**************************************************************/

static _kernel_oserror * choices_batch_gadget_state
                         (
                           const ComponentId * restrict array,
                           int                          state
                         )
{
  int         entry = 0;
  ComponentId window;

  while (array[entry] != NULL_ComponentId)
  {
    window = choices_find_component(array[entry]);

    if (window != NULL_ObjectId)
    {
      RetError(set_gadget_state(window, array[entry], state));
    }

    entry++;
  }

  return NULL;
}

/**************************************************************/
/* choices_set_tables_greyed()                                */
/*                                                            */
/* Sets the table border gadgets to greyed or ungreyed.       */
/*                                                            */
/* Parameters: 0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_tables_greyed(int state)
{
  ComponentId array[] = {
                          CD_TabInnerBordLabl, CD_TabInnerBordDisp, CD_TabInnerBordBt,
                          CD_TabOuterBordLabl, CD_TabOuterBordDisp, CD_TabOuterBordBt,
                          CD_MSIE4StyleTables,
                          NULL_ComponentId
                        };

  (void) choices_batch_gadget_state(array, state);
}

/**************************************************************/
/* choices_set_printing_greyed()                              */
/*                                                            */
/* Update the greyed/ungreyed state of printing items in the  */
/* Choices dialogue box panes according to the new_choices    */
/* contents. Set the layout sprites to indicate header and    */
/* footer activation condition.                               */
/**************************************************************/

static _kernel_oserror * choices_set_printing_greyed(void)
{
  int           state;
  ComponentId   window;
  const char  * spr1 = NULL;
  const char  * spr2 = NULL;
  const char  * spr3 = NULL;

  /* Sort out the header/footer layout indicator sprites. It looks */
  /* better if this is done before the grey/ungrey operations as a */
  /* sprite ungreying, then changing, is more obvious than a one   */
  /* which changes whilst still greyed out.                        */

  if (new_choices->print_headers_from != 0 && new_choices->print_footers_from != 0)
  {
    /* Headers and footers both on */

    spr1 = "phf_normal";
    spr2 = "phf_book";
    spr3 = "phf_spread";
  }
  else if (new_choices->print_headers_from == 0 && new_choices->print_footers_from != 0)
  {
    /* Headers off */

    spr1 = "phf_normal_f";
    spr2 = "phf_book_f";
    spr3 = "phf_spread_f";
  }
  else if (new_choices->print_footers_from == 0 && new_choices->print_headers_from != 0)
  {
    /* Footers off */

    spr1 = "phf_normal_h";
    spr2 = "phf_book_h";
    spr3 = "phf_spread_h";
  }

  /* Update the sprites? */

  if (spr1 != NULL)
  {
    if ((window = choices_find_component(CD_NormalHFBt)) != NULL_ObjectId)
    {
      RetError(_swix(Toolbox_ObjectMiscOp,
                     _INR(0,4),

                     toolaction_SET_IDENT_OFF,
                     window,
                     ToolAction_SetIdent,
                     CD_NormalHFBt,
                     spr1));
    }

    if ((window = choices_find_component(CD_BookHFBt)) != NULL_ObjectId)
    {
      RetError(_swix(Toolbox_ObjectMiscOp,
                     _INR(0,4),

                     toolaction_SET_IDENT_OFF,
                     window,
                     ToolAction_SetIdent,
                     CD_BookHFBt,
                     spr2));
    }

    if ((window = choices_find_component(CD_SpreadHFBt)) != NULL_ObjectId)
    {
      RetError(_swix(Toolbox_ObjectMiscOp,
                     _INR(0,4),

                     toolaction_SET_IDENT_OFF,
                     window,
                     ToolAction_SetIdent,
                     CD_SpreadHFBt,
                     spr3));
    }
  }

  /* Grey/ungrey items immediately related to headers on/off */

  if (new_choices->print_headers_from == 0) state = 1;
  else                                      state = 0;

  /* C99 mid-block declaration */

  ComponentId array1[] = {
                           CD_HeadersDisp,
                           CD_HeaderLabl,
                           CD_HeaderLeft,   CD_HeaderLeftBt,
                           CD_HeaderMiddle, CD_HeaderMiddleBt,
                           CD_HeaderRight,  CD_HeaderRightBt,
                           NULL_ComponentId
                         };

  RetError(choices_batch_gadget_state(array1, state));

  /* Grey/ungrey items immediately related to footers on/off */

  if (new_choices->print_footers_from == 0) state = 1;
  else                                      state = 0;

  /* C99 mid-block declaration */

  ComponentId array2[] = {
                           CD_FootersDisp,
                           CD_FooterLabl,
                           CD_FooterLeft,   CD_FooterLeftBt,
                           CD_FooterMiddle, CD_FooterMiddleBt,
                           CD_FooterRight,  CD_FooterRightBt,
                           NULL_ComponentId
                         };

  RetError(choices_batch_gadget_state(array2, state));

  /* Grey/ungrey items only affected if both headers and footers are on/off */

  if (new_choices->print_headers_from == 0 && new_choices->print_footers_from == 0) state = 1;
  else                                                                              state = 0;

  /* C99 mid-block declaration */

  ComponentId array3[] = {
                           CD_HFLeftLabl,     CD_HFMiddleLabl,  CD_HFRightLabl,
                           CD_DateFormatLabl, CD_DateFormat,    CD_DateFormatBt,
                           CD_NormalHFLabl,   CD_NormalHFRadio, CD_NormalHFBt,
                           CD_BookHFLabl,     CD_BookHFRadio,   CD_BookHFBt,
                           CD_SpreadHFLabl,   CD_SpreadHFRadio, CD_SpreadHFBt,
                           CD_BoldHF,         CD_ItalicHF,
                           CD_SizeHFLabl,     CD_SizeHFDisp,    CD_PercentageHFLabl,
                           NULL_ComponentId
                         };

  RetError(choices_batch_gadget_state(array3, state));

  /* Finished */

  return NULL;
}

/**************************************************************/
/* choices_set_frame_related_greyed()                         */
/*                                                            */
/* Sets frame related gadgets, except "Support Frames", to    */
/* greyed or ungreyed.                                        */
/*                                                            */
/* CD_ShowMayScroll is greyed with everything else, but only  */
/* ungreyed if new_choices->no_scroll_bars is set, so make    */
/* sure this is set appropriately before calling to ungrey    */
/* stuff.                                                     */
/*                                                            */
/* Parameters: Object ID of the window which contains the     */
/*             icons;                                         */
/*                                                            */
/*             0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_frame_related_greyed(ObjectId window, int state)
{
  set_gadget_state(window, CD_NoScrollBars,  !!state);
  set_gadget_state(window, CD_ShowMayScroll, state ? 1 : !new_choices->no_scroll_bars);
}

/**************************************************************/
/* choices_set_fonts_greyed()                                 */
/*                                                            */
/* Sets the font name and font size gadgets to                */
/* greyed/ungreyed.                                           */
/*                                                            */
/* Parameters: 0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_fonts_greyed(int state)
{
  ComponentId array[] = {
                          CD_FontsTF1Labl, CD_FontsTF1Disp,     CD_FontsTF1Bt,
                          CD_FontsTF2Labl, CD_FontsTF2Disp,     CD_FontsTF2Bt,
                          CD_FontsTF3Labl, CD_FontsTF3Disp,     CD_FontsTF3Bt,
                          CD_FontsSize,    CD_FontsSzLabl1,     CD_FontsSzLabl2,
                          CD_FontsAspect,  CD_FontsAspectLabl1, CD_FontsAspectLabl2,
                          NULL_ComponentId
                        };

  (void) choices_batch_gadget_state(array, state);
}

/**************************************************************/
/* choices_set_expiry_age()                                   */
/*                                                            */
/* Sets up the expiry age fields and greys/ungreys them as    */
/* appropriate.                                               */
/*                                                            */
/* Parameters: ObjectId of the window containing the gadgets. */
/**************************************************************/

static void choices_set_expiry_age(ObjectId window)
{
  int            temp;
  int            rangetop;
  choices_time_e time_scale;
  int            age;

  age = history_radio ? new_choices->image_expiry_age : new_choices->expiry_age;

  if (age == 0)
  {
    time_scale = choices_time_DAYS;
    temp       = 1;
    rangetop   = 7;
  }
  else
  {
    time_scale = choices_return_appropriate_timetype(age);
    temp       = choices_seconds_to_typed_time(age, time_scale);
    rangetop   = choices_get_range_of_typed_time(time_scale);
  }

  expiry_age_greyed = !age;
  choices_set_expiry_age_greyed(!age);
  optionbutton_set_state(0, window, CD_HiDontAge, !!age);

  choices_numberrange_set_value(0, window, CD_HiExpiryAge, temp);
  choices_set_timetype_field(CD_HiAgeTypeDisp, time_scale);

  history_expiry_units = time_scale;

  numberrange_set_bounds(15, window, CD_HiExpiryAge, 1, rangetop, 1, 0);
}

/**************************************************************/
/* choices_set_expiry_age_greyed()                            */
/*                                                            */
/* Sets the expiry age gadgets to greyed/ ungreyed.           */
/*                                                            */
/* Parameters: 0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_expiry_age_greyed(int state)
{
  ComponentId array[] = {
                          CD_HiExpiryAgeLabl,
                          CD_HiExpiryAge,
                          CD_HiAgeTypeDisp,
                          CD_HiAgeTypeBt,
                          NULL_ComponentId
                        };

  (void) choices_batch_gadget_state(array, state);
}

/**************************************************************/
/* choices_set_im_expiry_age()                                */
/*                                                            */
/* Sets up the image expiry age fields and greys/ungreys      */
/* them as appropriate.                                       */
/*                                                            */
/* Parameters: ObjectId of the window containing the gadgets. */
/**************************************************************/

static void choices_set_im_expiry_age(ObjectId window)
{
  int            temp;
  int            rangetop;
  choices_time_e time_scale;

  if (new_choices->image_expiry_age == 0)
  {
    time_scale = choices_time_DAYS;
    temp       = 1;
    rangetop   = 7;
  }
  else
  {
    time_scale = choices_return_appropriate_timetype(new_choices->image_expiry_age);
    temp       = choices_seconds_to_typed_time(new_choices->image_expiry_age, time_scale);
    rangetop   = choices_get_range_of_typed_time(time_scale);
  }

  image_expiry_age_greyed = !new_choices->image_expiry_age;
  choices_set_im_expiry_age_greyed(!new_choices->image_expiry_age);
  optionbutton_set_state(0, window, CD_HiImDontAge, !!new_choices->image_expiry_age);

  choices_numberrange_set_value(0, window, CD_HiImExpiryAge, temp);
  choices_set_timetype_field(CD_HiImAgeTypeDisp, time_scale);

  image_expiry_units = time_scale;

  numberrange_set_bounds(15, window, CD_HiImExpiryAge, 1, rangetop, 1, 0);
}

/**************************************************************/
/* choices_set_im_expiry_age_greyed()                         */
/*                                                            */
/* Sets the image expiry age gadgets to greyed/ ungreyed.     */
/*                                                            */
/* Parameters: 0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_im_expiry_age_greyed(int state)
{
  ComponentId array[] = {
                          CD_HiImExpiryAgeLabl,
                          CD_HiImExpiryAge,
                          CD_HiImAgeTypeDisp,
                          CD_HiImAgeTypeBt,
                          NULL_ComponentId
                        };

  (void) choices_batch_gadget_state(array, state);
}

/**************************************************************/
/* choices_set_max_size()                                     */
/*                                                            */
/* Sets up the max size field and greys or ungreys it as      */
/* appropriate.                                               */
/*                                                            */
/* Parameters: The ObjectId of the window which contains the  */
/*             gadgets.                                       */
/**************************************************************/

static void choices_set_max_size(ObjectId window)
{
  int size;

  size = history_radio ? new_choices->image_max_size : new_choices->max_size;

  optionbutton_set_state(0, window, CD_HiDontSize, !!size);
  max_size_greyed = !size;
  choices_set_max_size_greyed(window, max_size_greyed);

  choices_numberrange_set_value(0,
                                window,
                                CD_HiMaxSize,
                                !size ? 32 : size/1024);
}

/**************************************************************/
/* choices_set_max_size_greyed()                              */
/*                                                            */
/* Sets the max size gadgets to greyed/ungreyed.              */
/*                                                            */
/* Parameters: ObjectId of the window which contains the      */
/*             icons.                                         */
/*                                                            */
/*             0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_max_size_greyed(ObjectId window, int state)
{
  set_gadget_state(window, CD_HiMaxSizeLabl1, !!state);
  set_gadget_state(window, CD_HiMaxSizeLabl2, !!state);
  set_gadget_state(window, CD_HiMaxSize,      !!state);
}

/**************************************************************/
/* choices_set_im_max_size()                                  */
/*                                                            */
/* Sets up the image max size field and greys or ungreys it   */
/* as appropriate.                                            */
/*                                                            */
/* Parameters: The ObjectId of the window which contains the  */
/*             gadgets.                                       */
/**************************************************************/

static void choices_set_im_max_size(ObjectId window)
{
  optionbutton_set_state(0, window, CD_HiImDontSize, !!new_choices->image_max_size);
  image_max_size_greyed = !new_choices->image_max_size;
  choices_set_im_max_size_greyed(window, image_max_size_greyed);

  choices_numberrange_set_value(0,
                                window,
                                CD_HiImMaxSize,
                                !new_choices->image_max_size ? 32 : new_choices->image_max_size/1024);
}

/**************************************************************/
/* choices_set_im_max_size_greyed()                           */
/*                                                            */
/* Sets the image max size gadgets to greyed/ ungreyed.       */
/*                                                            */
/* Parameters: ObjectId of the window which contains the      */
/*             icons.                                         */
/*                                                            */
/*             0 to ungrey, any other value to to grey.       */
/**************************************************************/

static void choices_set_im_max_size_greyed(ObjectId window, int state)
{
  set_gadget_state(window, CD_HiImMaxSizeLabl1, !!state);
  set_gadget_state(window, CD_HiImMaxSizeLabl2, !!state);
  set_gadget_state(window, CD_HiImMaxSize,      !!state);
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* choices_set_js_watchdog_greyed()                           */
  /*                                                            */
  /* Sets the JS watchdog timeout gadgets to greyed or          */
  /* ungreyed.                                                  */
  /*                                                            */
  /* Parameters: 0 to ungrey, any other value to to grey.       */
  /**************************************************************/

  static void choices_set_js_watchdog_greyed(int state)
  {
    ComponentId array[] = {
                            CD_JSTimeoutLabl,
                            CD_JSTimeoutDisp,
                            CD_JSTimeoutLabl2,

                            NULL_ComponentId
                          };

    (void) choices_batch_gadget_state(array, state);
  }

  /**************************************************************/
  /* choices_set_js_all_greyed()                                */
  /*                                                            */
  /* Sets all JS related gadgets, except "Support JavaScript",  */
  /* to greyed or ungreyed. Watchdog related stuff is set       */
  /* according to the value of new_choices->js_watchdog, so     */
  /* make sure this is valid before calling the function. This  */
  /* is handled as follows; if you ask for items to be greyed,  */
  /* the watchdog stuff will always be greyed too; if you ask   */
  /* for items to be ungreyed, the watchdog stuff will be only  */
  /* if new_choices->js_watchdog is set.                        */
  /*                                                            */
  /* Parameters: 0 to ungrey, any other value to to grey        */
  /*             (except for watchdog items, see details        */
  /*             above).                                        */
  /**************************************************************/

  static void choices_set_js_all_greyed(int state)
  {
    ComponentId array[] = {
                            CD_JSWatchdog,
                            CD_JSNavAsNav,
                            CD_JSErrorBoxes,

                            CD_JSOpenCloseLabl,

                            CD_JSWinOpenLabl,
                            CD_JSWinOpenDisp,
                            CD_JSWinOpenBt,

                            CD_JSWinCloseLabl,
                            CD_JSWinCloseDisp,
                            CD_JSWinCloseBt,

                            NULL_ComponentId
                          };

    (void) choices_batch_gadget_state(array, state);
    choices_set_js_watchdog_greyed(state ? 1 : !new_choices->js_watchdog);
  }

#endif

/**************************************************************/
/* choices_find_component()                                   */
/*                                                            */
/* Scans all the choices subwindows for the requested         */
/* component and returns the id of the first window in which  */
/* it was seen.                                               */
/*                                                            */
/* Parameters: The component to find.                         */
/*                                                            */
/* Returns:    Where to return the object id to. 0 if the     */
/*             component was not found                        */
/**************************************************************/

static ObjectId choices_find_component(ComponentId component)
{
  int          findwindow;
  unsigned int flags;

  #ifndef TRACE

    /* Uses lazy evaluation to not call gadget_get_flags unless */
    /* subwindows[findwindow] contains an objectid.             */

    for (findwindow = 0; findwindow < CDNoSubwindows; findwindow++)
    {
      if (
           subwindows[findwindow] &&
           !gadget_get_flags(0,
                             subwindows[findwindow],
                             component,
                             &flags)
         )
         return subwindows[findwindow];
    }

  #else

    /* TRACE builds will check for multiple same component IDs,   */
    /* and complain. Would have saved at least one time consuming */
    /* error in Phoenix if I'd thought to do this a week earlier! */

    {
      ObjectId found = NULL_ObjectId;
      int      pane  = 0;

      for (findwindow = 0; findwindow < CDNoSubwindows; findwindow++)
      {
        if (
             subwindows[findwindow] &&
             !gadget_get_flags(0,
                               subwindows[findwindow],
                               component,
                               &flags)
           )
        {
          if (found == NULL_ObjectId)
          {
            found = subwindows[findwindow];
            pane  = findwindow;
          }
          else
          {
            erb.errnum = Utils_Error_Custom_Normal;

            sprintf(erb.errmess,
                    "Duplicate component ID 0x%x in Choices dialogue box panes %d and %d.",
                    component,
                    pane,
                    findwindow);

            show_error_ret(&erb);

            found = subwindows[findwindow];
          }

        /* Closure of 'if' with code above running if the gadget is found */
        }

      /* Closure of 'for' loop */
      }

      if (found != NULL_ObjectId) return found;
    }

  #endif

  return 0;
}

/**************************************************************/
/* choices_displayfield_set_value()                           */
/*                                                            */
/* Does as displayfield_set_value but will only update it if  */
/* the text is different to that currently in the display     */
/* field.                                                     */
/*                                                            */
/* Parameters: Same as displayfield_set_value.                */
/**************************************************************/

static _kernel_oserror * choices_displayfield_set_value
                         (
                           const unsigned int   flags,
                           const ObjectId       window,
                           const ComponentId    writable,
                           const char         * restrict text
                         )
{
  int               reqdsize;
  char            * oldtext;
  _kernel_oserror * e = NULL;

  RetError(displayfield_get_value(0, window, writable, NULL, 0, &reqdsize));

  oldtext = malloc(reqdsize+1);
  if (!oldtext) return make_no_memory_error(20);

  displayfield_get_value(0, window, writable, oldtext, reqdsize, NULL);

  if (strcmp(text, oldtext))
  {
    e = displayfield_set_value(flags, window, writable, (char *) text);
  }

  free(oldtext);

  return e;
}

/**************************************************************/
/* choices_writablefield_set_value()                          */
/*                                                            */
/* Does as writablefield_set_value but will only update it if */
/* the text is different to that currently in the display     */
/* field.                                                     */
/*                                                            */
/* Parameters: Same as writablefield_set_value.               */
/**************************************************************/

static _kernel_oserror * choices_writablefield_set_value
                         (
                           const unsigned int   flags,
                           const ObjectId       window,
                           const ComponentId    writable,
                           const char         * restrict text
                         )
{
  int               reqdsize;
  char            * oldtext;
  _kernel_oserror * e = NULL;

  RetError(writablefield_get_value(0, window, writable, NULL, 0, &reqdsize));

  oldtext = malloc(reqdsize+1);
  if (!oldtext) return make_no_memory_error(20);

  writablefield_get_value(0, window, writable, oldtext, reqdsize, NULL);

  if (strcmp(text, oldtext))
  {
    e = writablefield_set_value(flags, window, writable, (char *) text);
  }

  free(oldtext);

  return e;
}

/**************************************************************/
/* choices_writablefield_add_text()                           */
/*                                                            */
/* Adds the specified text either at the caret position if    */
/* the caret is in the given writable field, or at the end of */
/* the field if the caret position is elsewhere or cannot be  */
/* determined.                                                */
/*                                                            */
/* Parameters: Flags to pass to writablefield_set_value;      */
/*                                                            */
/*             Object ID to pass to writablefield_set_value;  */
/*                                                            */
/*             Component ID to pass to                        */
/*             writablefield_set_value;                       */
/*                                                            */
/*             Pointer to NUL-terminated piece of text to     */
/*             insert into or append to existing gadget text. */
/**************************************************************/

static _kernel_oserror * choices_writablefield_add_text
                         (
                           const unsigned int   flags,
                           const ObjectId       window,
                           const ComponentId    writable,
                           const char         * restrict text
                         )
{
  WimpGetCaretPositionBlock            caret;
  int                                  window_handle;
  int                                  icon_handle;
  int                                  reqdsize;
  char                      * restrict oldtext;
  size_t                               newlen, oldlen;
  _kernel_oserror           *          e = NULL;

  newlen = strlen(text);

  /* A writable field should consist of just the one icon */

  RetError(gadget_get_icon_list(0,
                                window,
                                writable,
                                &icon_handle,
                                sizeof(icon_handle),
                                NULL));

  /* Read the current caret position and window's Wimp handle */

  RetError(wimp_get_caret_position(&caret));
  RetError(window_get_wimp_handle(0, window, &window_handle));

  /* Allocate room for the existing text plus new text plus NUL */

  RetError(writablefield_get_value(0, window, writable, NULL, 0, &reqdsize));

  oldtext = malloc(reqdsize + newlen + 1);
  if (oldtext == NULL) return make_no_memory_error(20);

  /* Read the current value */

  e = writablefield_get_value(0, window, writable, oldtext, reqdsize, NULL);

  if (e != NULL)
  {
    free(oldtext);
    return e;
  }

  oldlen = strlen(oldtext);

  /* Do we insert or append the text? */

  if (
       caret.window_handle == window_handle &&
       caret.icon_handle   == icon_handle   &&
       caret.index         >= 0             &&
       caret.index         <  oldlen
     )
  {
    /* Insert the new text */

    memmove(oldtext + caret.index + newlen,
            oldtext + caret.index,
            oldlen  - caret.index + 1); /* + 1 moves NUL too */

    memcpy (oldtext + caret.index,
            text,
            newlen);

    e = writablefield_set_value(0, window, writable, oldtext);

    if (e == NULL)
    {
      /* Move the caret to just after the new text */

      (void) wimp_set_caret_position(caret.window_handle,
                                     caret.icon_handle,
                                     caret.xoffset,
                                     caret.yoffset,
                                     caret.height,
                                     caret.index + newlen);
    }
  }
  else
  {
    /* Append the new text */

    strcat(oldtext, text);

    e = writablefield_set_value(0, window, writable, oldtext);

    /* If that worked, put the caret at the end of this writable   */
    /* field's new text. Otherwise, appended data can get scrolled */
    /* out of view depending upon the field's alignment settings.  */

    if (e == NULL)
    {
      (void) wimp_set_caret_position(window_handle,
                                     icon_handle,
                                     0,
                                     0,
                                     -1,
                                     oldlen + newlen);
    }
  }

  free(oldtext);
  return e;
}

/**************************************************************/
/* choices_button_set_validation()                            */
/*                                                            */
/* Does as button_set_validation but will only update it if   */
/* the text is different to that currently in the button.     */
/*                                                            */
/* Parameters: Same as button_set_validation.                 */
/**************************************************************/

static _kernel_oserror * choices_button_set_validation
                         (
                           const unsigned int   flags,
                           const ObjectId       window,
                           const ComponentId    writable,
                           const char         * restrict text
                         )
{
  int               reqdsize;
  char            * oldtext;
  _kernel_oserror * e = NULL;

  RetError(button_get_validation(0, window, writable, NULL, 0, &reqdsize));

  oldtext = malloc(reqdsize+1);
  if (!oldtext) return make_no_memory_error(20);

  button_get_validation(0, window, writable, oldtext, reqdsize, NULL);

  if (strcmp(text, oldtext))
  {
    e = button_set_validation(flags, window, writable, (char *) text);
  }

  free(oldtext);

  return e;
}

/**************************************************************/
/* choices_numberrange_set_value()                            */
/*                                                            */
/* Does as numberrange_set_value but will only update it if   */
/* the number is different to that currently in the display.  */
/*                                                            */
/* Parameters: Same as numberrange_set_value.                 */
/**************************************************************/

static _kernel_oserror * choices_numberrange_set_value
                         (
                           const unsigned int flags,
                           const ObjectId     window,
                           const ComponentId  writable,
                           const int          value
                         )
{
  int               oldvalue;
  _kernel_oserror * e = NULL;

  RetError(numberrange_get_value(0, window, writable, &oldvalue));

  if (oldvalue != value)
  {
    e = numberrange_set_value(flags, window, writable, value);
  }

  return e;
}

/**************************************************************/
/* choices_colour_set_component()                             */
/*                                                            */
/* Sets the validation string of a button to be slabbed in    */
/* and have the background colour specified.                  */
/*                                                            */
/* Parameters: Window ObjectId;                               */
/*                                                            */
/*             Button ComponentId;                            */
/*                                                            */
/*             Colour.                                        */
/**************************************************************/

static _kernel_oserror * choices_colour_set_component(ObjectId window, ComponentId component, int colour)
{
  char            newvalidation[32];
  unsigned char * newcol;

  newcol = (unsigned char*)&colour;

  sprintf(newvalidation, "R2;C/%02.2x%02.2x%02.2x", *(newcol + 3), *(newcol + 2), *(newcol + 1));

  return choices_button_set_validation(0, window, component, newvalidation);
}

/**************************************************************/
/* choices_get_menu_entry_text()                              */
/*                                                            */
/* Gets a pointer to a piece of text acquired from a menu.    */
/* The pointer is to a malloc block and so must be freed      */
/* after use.                                                 */
/*                                                            */
/* Parameters: pointer to the menu name                       */
/*                                                            */
/*             menu componentid                               */
/*                                                            */
/*             pointer to char* to use for the malloc block   */
/*                                                            */
/* Assumes:    the menu is a shared object.                   */
/**************************************************************/

static _kernel_oserror * choices_get_menu_entry_text
                         (
                           const char   * restrict menuname,
                           ComponentId             compid,
                           char        **          tempstring
                         )
{
  ObjectId menu_id;
  int      reqdsize;

  RetError(toolbox_create_object(0, (void *) menuname, &menu_id));

  RetError(menu_get_entry_text(0, menu_id, compid, NULL, 0, &reqdsize));

  *tempstring = malloc(reqdsize+1);
  if (!*tempstring) return make_no_memory_error(20);

  RetError(menu_get_entry_text(0, menu_id, compid, *tempstring, reqdsize+1, NULL));

  return NULL;
}

/**************************************************************/
/* choices_retrieve_text_item()                               */
/*                                                            */
/* Read a writable field's contents into a Choices item.      */
/*                                                            */
/* Parameters: Component ID of the writable field to read;    */
/*                                                            */
/*             Pointer to a char *, assumed to contain NULL   */
/*             or a malloc'd string that is free-able, which  */
/*             will be updated on exit with a pointer to the  */
/*             new string read from the writable field,       */
/*             itself malloc'd, the old string free'd.        */
/**************************************************************/

static _kernel_oserror * choices_retrieve_text_item
                         (
                           ComponentId    writable_field,
                           char        ** choice_to_update
                         )
{
  ObjectId   container;
  char     * tempstring;
  int        reqsize;

  /* Find the component */

  container = choices_find_component(writable_field);
  if (container == NULL_ObjectId) return NULL;

  /* Find out how much space is needed for the value */

  RetError(writablefield_get_value(0,
                                   container,
                                   writable_field,
                                   NULL,
                                   0,
                                   &reqsize));

  /* Allocate space for the value */

  tempstring = malloc(reqsize + 1);
  if (tempstring == NULL) return make_no_memory_error(17);

  RetError(writablefield_get_value(0,
                                   container,
                                   writable_field,
                                   tempstring,
                                   reqsize,
                                   NULL));

  /* Delete the old choices item and replace it */

  free(*choice_to_update);
  *choice_to_update = tempstring;

  /* Finished */

  return NULL;
}

/**************************************************************/
/* choices_modified_font()                                    */
/*                                                            */
/* Finds a version of a font with a specified modification    */
/* eg. bold or italic.                                        */
/*                                                            */
/* Parameters: pointer to the original font name              */
/*                                                            */
/*             pointer to a space separated and null          */
/*             terminated list of modifications in order of   */
/*             preference                                     */
/*                                                            */
/*             pointer to a buffer to contain the name of the */
/*             new font.                                      */
/**************************************************************/

static void choices_modified_font(char * orig, char * mod, char * buffer)
{
  _kernel_oserror * e = NULL;
  char              origname[Limits_FontName];
  int               f=-1;
  char            * p, * p2;
  char            * lastdot;
  BOOL              found;

  /* Find the fontname field */

  _swix(Font_FindField, _INR(1,2)|_OUTR(1,2), orig, 'F', &p, &found);

  /* If the field could not be found assume that the entire */
  /* string is the font name.                               */

  if (!found) p = orig;

  p2 = origname;

  /* Extract the font name.                                       */
  /* Copys the string pointed to by p to p2 until either a \ or a */
  /* character with an ascii value less than 32 is encountered.   */

  while (*p > 32 && *p != '\\') *p2++ = *p++;

  /* NULL terminate the new string */

  *p2 = '\0';

  lastdot = strrchr(origname, '.');

  /* Get first of possibly several possible modifications */

  p = strtok(mod, " ");

  while (p)
  {
    sprintf(buffer, "%s.%s", origname, p);
    e=_swix(Font_FindFont, _INR(1,5)|_OUT(0), buffer, 12*16, 12*16, 90, 90, &f);

    /* If there was no error then the font must have been found */

    if (!e) break;

    if (lastdot)
    {
      *lastdot = '\0';
      sprintf(buffer, "%s.%s", origname, p);
      *lastdot = '.';
      e=_swix(Font_FindFont, _INR(1,5)|_OUT(0), buffer, 12*16, 12*16, 90, 90, &f);
      if (e==NULL) break;
    }

    /* Get the next modification */

    p=strtok(NULL, " ");
  }

  /* If a font has been 'found' we need to lose it again */

  if (f >= 0) _swix(Font_LoseFont, _IN(0), f);

  /* If an error was encountered the best we can do is */
  /* to return the original font.                      */

  if (e) strcpy(buffer, orig);
}

/**************************************************************/
/* choices_clip_to_min_max()                                  */
/*                                                            */
/* Clips a number to a minimum and maximum value              */
/*                                                            */
/* Parameters: initial value;                                 */
/*                                                            */
/*             minimum;                                       */
/*                                                            */
/*             maximum.                                       */
/*                                                            */
/* Returns:    clipped value.                                 */
/**************************************************************/

int choices_clip_to_min_max(int value, int min, int max)
{
  return value > max ? max : (value < min ? min : value);
}
@


1.41
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d31 1
d52 2
d79 1
a79 1
/* Locals */
d81 3
a83 3
static char consonant[]                = "bcdfghjklmnpqrstvwxyz";
static char vowel[]                    = "aeiou";
static int  rubbish_seed;
d87 2
a88 2
static unsigned char todecimal  [] = {0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9};
static unsigned char fromdecimal[] = {0, 2, 4, 5, 7, 8, 10, 12, 13, 15};
d94 3
a96 5
static int           save_ticked             = -1;
static int           disp_ticked             = -1;
static int           plug_ticked             = -1;
static int           time_ticked             = -1;
static int           bord_ticked             = -1;
d99 1
d101 3
a103 1
static ComponentId   refe_ticked             = NULL_ComponentId;
a116 3
static int           image_expiry_units      = -1;
static int           history_expiry_units    = -1;

a121 1

a122 1

d125 1
a125 1
/* Static function prototypes */
d127 232
a358 7
static _kernel_oserror * choices_show_subwindow              (ObjectId choices_window, int subwindow);
static _kernel_oserror * choices_set_contents                (void);
static _kernel_oserror * choices_get_contents                (void);
static void              choices_set_expiry_age              (ObjectId window);
static void              choices_set_expiry_age_greyed       (ObjectId window, int state);
static void              choices_set_tables_greyed           (ObjectId window, int state);
static _kernel_oserror * choices_set_table_border_field      (ObjectId obj, ComponentId comp, int state);
a360 3
  static void            choices_set_js_watchdog_greyed      (ObjectId window, int state);
  static void            choices_set_js_all_greyed           (ObjectId window, int state);
#endif
d362 21
a382 17
static void              choices_set_frame_related_greyed    (ObjectId window, int state);
static void              choices_set_fonts_greyed            (ObjectId window, int state);
static void              choices_set_max_size                (ObjectId window);
static void              choices_set_max_size_greyed         (ObjectId window, int state);
static void              choices_set_im_max_size             (ObjectId window);
static void              choices_set_im_max_size_greyed      (ObjectId window, int state);
int                      choices_clip_to_min_max             (int value, int min, int max);
static void              choices_set_im_expiry_age           (ObjectId window);
static void              choices_set_im_expiry_age_greyed    (ObjectId window, int state);
_kernel_oserror        * choices_set_timetype_tick           (int timetype);

static _kernel_oserror * choices_set_timetype_field          (int timetype, ComponentId comp);
static _kernel_oserror * choices_set_plugin_field            (void);
static _kernel_oserror * choices_set_uri_field               (void);
static _kernel_oserror * choices_set_cookie_field            (void);
static _kernel_oserror * choices_set_jpeg_field              (void);
static _kernel_oserror * choices_set_referer_field           (void);
a383 3
#ifdef JAVASCRIPT
  static _kernel_oserror * choices_set_win_open_field        (void);
  static _kernel_oserror * choices_set_win_close_field       (void);
d386 2
a387 1
static void              choices_modified_font               (char * orig, char * mod, char * buffer);
d389 142
a530 33
static int               choices_radio_click_handler         (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_set_button_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_cancel_button_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_save_button_handler         (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_encoding_button_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_button_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_closed_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_selected_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_display_m_button_handler    (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_save_m_button_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_display_m_click_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_save_m_click_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_option_state_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_font_button_handler         (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_font_closed_handler         (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_font_selected_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_redraw_fakepage_handler     (int eventcode, WimpPollBlock * event, IdBlock * id_block, void * handle);
static int               choices_open_choice_window          (int eventcode, WimpPollBlock * event, IdBlock * id_block, void * handle);
static int               choices_plug_m_button_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_plug_m_click_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_timetype_m_button_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_timetype_m_click_handler    (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_bord_m_button_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_bord_m_click_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_history_radio_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_uri_m_button_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_uri_m_click_handler         (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_cookie_m_button_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_cookie_m_click_handler      (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_jpeg_m_button_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_jpeg_m_click_handler        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_referer_m_button_handler    (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_referer_m_click_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
d533 2
a534 4
  static int             choices_win_open_m_button_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
  static int             choices_win_open_m_click_handler    (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
  static int             choices_win_close_m_button_handler  (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
  static int             choices_win_close_m_click_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
d537 19
a555 15
static _kernel_oserror * choices_colour_set_component        (ObjectId window, ComponentId component, int colour);
static _kernel_oserror * choices_set_save_field              (ObjectId obj, ComponentId comp, int state);
static _kernel_oserror * choices_set_display_field           (ObjectId obj, ComponentId comp, int state);
static ObjectId          choices_find_component              (ComponentId component);
_kernel_oserror        * choices_get_menu_entry_text         (char * menuname, ComponentId compid, char ** tempstring);

static _kernel_oserror * choices_displayfield_set_value      (unsigned int flags, ObjectId window, ComponentId writable, char *text);
static _kernel_oserror * choices_writablefield_set_value     (unsigned int flags, ObjectId window, ComponentId writable, char *text);
static _kernel_oserror * choices_button_set_validation       (unsigned int flags, ObjectId window, ComponentId writable, char *text);
static _kernel_oserror * choices_numberrange_set_value       (unsigned int flags, ObjectId window, ComponentId writable, int value);

static int               choices_return_appropriate_timetype (int seconds);
static int               choices_seconds_to_typed_time       (int secs, int timetype);
static int               choices_typed_time_to_seconds       (int time, int timetype);
static int               choices_get_range_of_typed_time     (int time);
d557 4
a560 22
/**************************************************************/
/* choices_show_subwindow()                                   */
/*                                                            */
/* Shows a choice subwindow in the main choices window.      */
/*                                                            */
/* Parameters: the ObjectId of the main choices window        */
/*                                                            */
/*             the number of the subwindow to show. Defined   */
/*             in choices.h Use CDSubNone to remove the       */
/*             current subwindow.                             */
/*                                                            */
/* Returns:    pointer to _kernel_oserror                     */
/**************************************************************/

static _kernel_oserror * choices_show_subwindow(ObjectId choices_window, int subwindow)
{
  _kernel_oserror           * e;
  WindowShowObjectBlock       show_block;
  WimpGetWindowStateBlock     state;
  WimpGetWindowOutlineBlock   outline;
  int                         window_handle;
  int                         vwidth, hheight;
d562 2
a563 3
  if (current_subwindow != CDSubNone && current_subwindow != subwindow)
  {
    /* remove the current subwindow */
d565 1
a565 3
    RetError(toolbox_hide_object(0, subwindows[current_subwindow]));
    current_subwindow = CDSubNone;
  }
d567 2
a568 3
  if (subwindow == CDSubNone || !(subwindows[subwindow]))
  {
    /* Have not been asked to open a new subwindow */
d570 12
a581 2
    return NULL;
  }
d583 4
a586 10
  RetError(window_get_wimp_handle(0, choices_window, &window_handle));
  state.window_handle = window_handle;
  RetError(wimp_get_window_state(&state));
  RetError(gadget_get_bbox(0, choices_window, CDPlaceHolder, &show_block.visible_area));
  windows_return_tool_sizes(NULL, &hheight, &vwidth);

  show_block.visible_area.xmin = coords_x_toscreen(show_block.visible_area.xmin, (WimpRedrawWindowBlock *) &state);
  show_block.visible_area.xmax = coords_x_toscreen(show_block.visible_area.xmax, (WimpRedrawWindowBlock *) &state);
  show_block.visible_area.ymin = coords_y_toscreen(show_block.visible_area.ymin, (WimpRedrawWindowBlock *) &state);
  show_block.visible_area.ymax = coords_y_toscreen(show_block.visible_area.ymax, (WimpRedrawWindowBlock *) &state);
d588 1
a588 1
  /* Adjustments for different types of window */
d590 22
a611 1
  dprintf(("Choi", "choices_show_subwindow: Wimp flags = %x\n", state.flags));
d613 4
a616 15
  RetError(window_get_wimp_handle(0, subwindows[subwindow], &state.window_handle));
  RetError(wimp_get_window_state(&state));

  if (state.flags & WimpWindow_VScroll) show_block.visible_area.xmax -= vwidth;
  else vwidth  = 0;

  if (state.flags & WimpWindow_HScroll) show_block.visible_area.ymin += hheight;
  else hheight = 0;

  show_block.xscroll = 0;
  show_block.yscroll = 0;
  show_block.behind  = -1;

  show_block.window_flags    = 0;
  show_block.alignment_flags = 0;
d618 1
a618 1
  /* Requires wimp handle just to be awkward */
d620 1
a620 1
  show_block.parent_window_handle = window_handle;
d622 1
a622 6
  RetError(toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                               subwindows[subwindow],
                               Toolbox_ShowObject_FullSpec,
                               &show_block,
                               choices_window,
                               -1));
d624 6
a629 2
  outline.window_handle = state.window_handle;
  wimp_get_window_outline(&outline);
d631 1
a631 16
  if (outline.outline.xmin < show_block.visible_area.xmin)
  {
    show_block.visible_area.xmin += (show_block.visible_area.xmin - outline.outline.xmin);
  }
  if (outline.outline.ymin < (show_block.visible_area.ymin - hheight))
  {
    show_block.visible_area.ymin += (show_block.visible_area.ymin - outline.outline.ymin);
  }
  if (outline.outline.xmax > (show_block.visible_area.xmax + vwidth))
  {
    show_block.visible_area.xmax -= (outline.outline.xmax - show_block.visible_area.xmax);
  }
  if (outline.outline.ymax > show_block.visible_area.ymax)
  {
    show_block.visible_area.ymax -= (outline.outline.ymax - show_block.visible_area.ymax);
  }
d633 2
a634 6
  e = toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                          subwindows[subwindow],
                          Toolbox_ShowObject_FullSpec,
                          &show_block,
                          choices_window,
                          -1);
d636 1
a636 1
  if (!e) current_subwindow = subwindow;
d638 2
a639 2
  return e;
}
d674 1
a674 1
  if (choices_windowid) return 1;
d742 11
a752 10
    e = toolbox_create_object(0, "ChSub0", &subwindows[0]); if (e) subwindows[0] = NULL;
    e = toolbox_create_object(0, "ChSub1", &subwindows[1]); if (e) subwindows[1] = NULL;
    e = toolbox_create_object(0, "ChSub2", &subwindows[2]); if (e) subwindows[2] = NULL;
    e = toolbox_create_object(0, "ChSub3", &subwindows[3]); if (e) subwindows[3] = NULL;
    e = toolbox_create_object(0, "ChSub4", &subwindows[4]); if (e) subwindows[4] = NULL;
    e = toolbox_create_object(0, "ChSub5", &subwindows[5]); if (e) subwindows[5] = NULL;
    e = toolbox_create_object(0, "ChSub6", &subwindows[6]); if (e) subwindows[6] = NULL;
    e = toolbox_create_object(0, "ChSub7", &subwindows[7]); if (e) subwindows[7] = NULL;
    e = toolbox_create_object(0, "ChSub8", &subwindows[8]); if (e) subwindows[8] = NULL;
    e = toolbox_create_object(0, "ChSub9", &subwindows[9]); if (e) subwindows[9] = NULL;
d767 3
a769 2
  /* are matched in the deregistration section below, and add to   */
  /* choices_hidden.                                               */
d776 39
a814 31
    e         = event_register_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDSet,                     choices_set_button_handler,            NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiImSaveBt,            choices_save_m_button_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDHiRadioClick,           choices_history_radio_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiAgeTypeBt,           choices_timetype_m_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDTimeMenuClick,          choices_timetype_m_click_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_TabInnerBordBt,        choices_bord_m_button_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_TabOuterBordBt,        choices_bord_m_button_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDBordMenuClick,          choices_bord_m_click_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_URIHandlerBt,          choices_uri_m_button_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDURIMenuClick,           choices_uri_m_click_handler,           NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_CookieBt,              choices_cookie_m_button_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDCookieMenuClick,        choices_cookie_m_click_handler,        NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_JPEGBt,                choices_jpeg_m_button_handler,         NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDJPEGMenuClick,          choices_jpeg_m_click_handler,          NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_RefererBt,             choices_referer_m_button_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDRefererMenuClick,       choices_referer_m_click_handler,       NULL);
d817 4
a820 4
      if (!e) e = event_register_toolbox_handler(-1, ECD_WinOpenBt,           choices_win_open_m_button_handler,     NULL);
      if (!e) e = event_register_toolbox_handler(-1, ECDWinOpenMenuClick,     choices_win_open_m_click_handler,      NULL);
      if (!e) e = event_register_toolbox_handler(-1, ECD_WinCloseBt,          choices_win_close_m_button_handler,    NULL);
      if (!e) e = event_register_toolbox_handler(-1, ECDWinCloseMenuClick,    choices_win_close_m_click_handler,     NULL);
d823 40
d876 1
a876 44
    event_deregister_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,           NULL);
    event_deregister_toolbox_handler(-1, CDSet,                     choices_set_button_handler,            NULL);
    event_deregister_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,         NULL);
    event_deregister_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,           NULL);
    event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,       NULL);
    event_deregister_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECD_HiImSaveBt,            choices_save_m_button_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,          NULL);
    event_deregister_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,       NULL);
    event_deregister_toolbox_handler(-1, ECDHiRadioClick,           choices_history_radio_handler,         NULL);
    event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,          NULL);
    event_deregister_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,           NULL);
    event_deregister_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,          NULL);
    event_deregister_toolbox_handler(-1, ECD_HiAgeTypeBt,           choices_timetype_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDTimeMenuClick,          choices_timetype_m_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_TabInnerBordBt,        choices_bord_m_button_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECD_TabOuterBordBt,        choices_bord_m_button_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECDBordMenuClick,          choices_bord_m_click_handler,          NULL);
    event_deregister_toolbox_handler(-1, ECD_URIHandlerBt,          choices_uri_m_button_handler,          NULL);
    event_deregister_toolbox_handler(-1, ECDURIMenuClick,           choices_uri_m_click_handler,           NULL);
    event_deregister_toolbox_handler(-1, ECD_CookieBt,              choices_cookie_m_button_handler,       NULL);
    event_deregister_toolbox_handler(-1, ECDCookieMenuClick,        choices_cookie_m_click_handler,        NULL);
    event_deregister_toolbox_handler(-1, ECD_JPEGBt,                choices_jpeg_m_button_handler,         NULL);
    event_deregister_toolbox_handler(-1, ECDJPEGMenuClick,          choices_jpeg_m_click_handler,          NULL);
    event_deregister_toolbox_handler(-1, ECD_RefererBt,             choices_referer_m_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECDRefererMenuClick,       choices_referer_m_click_handler,       NULL);

    #ifdef JAVASCRIPT
      event_deregister_toolbox_handler(-1, ECD_WinOpenBt,           choices_win_open_m_button_handler,     NULL);
      event_deregister_toolbox_handler(-1, ECD_WinCloseBt,          choices_win_close_m_button_handler,    NULL);
    #endif

    if ((window = choices_find_component(CD_FakePage)) != 0)
    {
      event_deregister_wimp_handler(window, Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
    }

    event_deregister_wimp_handler(idb->self_id, Wimp_EOpenWindow, choices_open_choice_window, NULL);

a886 29
#ifndef CREATE_ONLY_ONCE

  /**************************************************************/
  /* choices_delete_subwindows()                                */
  /*                                                            */
  /* Deletes all subwindows, reports any and all errors         */
  /* occuring while deleting them. Frees the structure holding  */
  /* the subwindows.                                            */
  /**************************************************************/

  static void choices_delete_subwindows(void)
  {
    _kernel_oserror *e;
    int count;

    for(count = 0; count < CDNoSubwindows; count++)
    {
      if (subwindows[count])
      {
        e = toolbox_delete_object(0, subwindows[count]);
        if (e) show_error_ret(e);
        subwindows[count] = 0;
      }
    }
    free(subwindows);
    subwindows = NULL;
  }
#endif

d888 1
a888 5
/* choices_hidden()                                           */
/*                                                            */
/* Called when the ECDHidden event is generated. Deletes all  */
/* the subwindow dialogues. Deregisters all additional event  */
/* handlers used while the choices dialogue is visible.       */
d890 5
a894 1
/* Parameters are as standard for a Toolbox event handler.    */
d897 1
a897 1
int choices_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d899 1
a899 5
  _kernel_oserror * e;
  #ifndef CREATE_ONLY_ONCE
    ObjectId          window;
  #endif
  int               temp;
d901 1
a901 1
  temp = current_subwindow;
d903 3
a905 4
  /* Close subwindow */

  e = choices_show_subwindow(idb->self_id, CDSubNone);
  if (e) show_error_ret(e);
d907 1
a907 2
  #ifndef CREATE_ONLY_ONCE
    /* Delete all subwindow objects */
d909 1
a909 1
    choices_delete_subwindows();
d911 45
a955 33
    free(new_choices);
    new_choices = NULL;
    free(new_typefaces);
    new_typefaces = NULL;

    /* Deregister choices event handlers */
    event_deregister_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,       NULL);
    event_deregister_toolbox_handler(-1, CDSet,                     choices_set_button_handler,        NULL);
    event_deregister_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,       NULL);
    event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,   NULL);
    event_deregister_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_HiImSaveBt,            choices_save_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,   NULL);
    event_deregister_toolbox_handler(-1, ECDHiRadioClick,          choices_history_radio_handler,     NULL);
    event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,       NULL);
    event_deregister_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_HiAgeTypeBt,           choices_timetype_m_button_handler, NULL);
    event_deregister_toolbox_handler(-1, ECDTimeMenuClick,          choices_timetype_m_click_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECD_TabInnerBordBt,        choices_bord_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_TabOuterBordBt,        choices_bord_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDBordMenuClick,          choices_bord_m_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_URIHandlerBt,          choices_uri_m_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECDURIMenuClick,           choices_uri_m_click_handler,       NULL);
    event_deregister_toolbox_handler(-1, ECD_JPEGBt,                choices_jpeg_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDJPEGMenuClick,          choices_jpeg_m_click_handler,      NULL);
d957 5
a961 5
    if ((window = choices_find_component(CD_FakePage)) != 0)
    {
      event_deregister_wimp_handler(window, Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
    }
    event_deregister_wimp_handler(idb->self_id, Wimp_EOpenWindow, choices_open_choice_window, NULL);
a963 2
  choices_windowid = 0;
  current_subwindow = temp;
d965 26
a990 2
  return 1;
}
d992 6
a997 8
/**************************************************************/
/* choices_radio_click_handler()                              */
/*                                                            */
/* Shows the appropriate subwindow when a radio button in the */
/* choices dialogue is clicked on                             */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/
a998 3
static int choices_radio_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int window, state;
d1000 3
a1002 1
  radiobutton_get_state(0, idb->self_id, idb->self_component, &state, NULL);
d1004 4
a1007 1
  /* Is this a radiobutton selected event? */
d1009 1
a1009 1
  if (state)
d1011 4
a1014 3
    window = idb->self_component - CDFirstSubRadio;
    if (window > CDNoSubwindows) window = CDSubNone;
    choices_show_subwindow(idb->self_id, window);
a1015 2

  return 1;
d1019 5
a1023 1
/* choices_set_contents()                                     */
d1025 3
a1027 2
/* Sets the contents of all choices subwindows to reflect the */
/* current state of the global choices.                       */
d1029 1
a1029 1
/* Returns:    pointer to _kernel_oserror.                    */
d1032 1
a1032 1
static _kernel_oserror * choices_set_contents(void)
d1034 6
a1039 2
  ObjectId          window;
  unsigned int      temp, frac;
d1041 3
a1043 1
  /* No error handling here, as we want to allow items to be missing */
d1045 3
a1047 5
  if ((window = choices_find_component(CD_Homepage))       != 0) choices_writablefield_set_value(0, window, CD_Homepage,       new_choices->home_page);
  if ((window = choices_find_component(CD_UnderlineLinks)) != 0) optionbutton_set_state(0,  window, CD_UnderlineLinks, new_choices->underline_links);
  if ((window = choices_find_component(CD_UseDocColours))  != 0) optionbutton_set_state(0,  window, CD_UseDocColours,  new_choices->use_source_cols);
  if ((window = choices_find_component(CD_ShowForeground)) != 0) optionbutton_set_state(0,  window, CD_ShowForeground, new_choices->show_foreground);
  if ((window = choices_find_component(CD_ShowBackground)) != 0) optionbutton_set_state(0,  window, CD_ShowBackground, new_choices->show_background);
d1049 3
a1051 2
  /* Get encoding name */
  choices_set_encoding_field();
d1053 1
a1053 34
  if ((window = choices_find_component(CD_URLBar))         != 0) optionbutton_set_state(0, window, CD_URLBar,     new_choices->url_bar);
  if ((window = choices_find_component(CD_StatusBar))      != 0) optionbutton_set_state(0, window, CD_StatusBar,  new_choices->status_bar);
  if ((window = choices_find_component(CD_ButtonBar))      != 0) optionbutton_set_state(0, window, CD_ButtonBar , new_choices->button_bar);
  if ((window = choices_find_component(CD_FullScreen))     != 0) optionbutton_set_state(0, window, CD_FullScreen, new_choices->full_screen);

  if ((window = choices_find_component(CD_BackColour))     != 0) choices_colour_set_component(window, CD_BackColour, new_choices->background_colour);
  if ((window = choices_find_component(CD_TextColour))     != 0) choices_colour_set_component(window, CD_TextColour, new_choices->text_colour);
  if ((window = choices_find_component(CD_LinkColour))     != 0) choices_colour_set_component(window, CD_LinkColour, new_choices->link_colour);
  if ((window = choices_find_component(CD_UsedColour))     != 0) choices_colour_set_component(window, CD_UsedColour, new_choices->used_colour);
  if ((window = choices_find_component(CD_FolwColour))     != 0) choices_colour_set_component(window, CD_FolwColour, new_choices->followed_colour);
  if ((window = choices_find_component(CD_SlctColour))     != 0) choices_colour_set_component(window, CD_SlctColour, new_choices->selected_colour);

  if ((window = choices_find_component(CD_HlAutoOpen))     != 0) choices_numberrange_set_value(0,  window, CD_HlAutoOpen,   new_choices->auto_open_delay);
  if ((window = choices_find_component(CD_HlAutoScroll))   != 0) choices_numberrange_set_value(0,  window, CD_HlAutoScroll, new_choices->auto_scroll_delay);
  if ((window = choices_find_component(CD_HlDispDisp))     != 0) choices_set_display_field(window, CD_HlDispDisp,   new_choices->hotlist_show);
  if ((window = choices_find_component(CD_HlSaveDisp))     != 0) choices_set_save_field(   window, CD_HlSaveDisp,   new_choices->save_hotlist);

  if ((window = choices_find_component(CD_HiExpiryAge))    != 0) choices_set_expiry_age(window);
  if ((window = choices_find_component(CD_HiMaxSize))      != 0) choices_set_max_size(window);
  if ((window = choices_find_component(CD_HiDispDisp))     != 0) choices_set_display_field(window, CD_HiDispDisp, new_choices->show_urls);
  if ((window = choices_find_component(CD_HiSaveDisp))     != 0) choices_set_save_field(window, CD_HiSaveDisp, new_choices->save_history);
  if ((window = choices_find_component(CD_HiImExpiryAge))  != 0) choices_set_im_expiry_age(window);
  if ((window = choices_find_component(CD_HiImMaxSize))    != 0) choices_set_im_max_size(window);
  if ((window = choices_find_component(CD_HiImSaveDisp))   != 0) choices_set_save_field(window, CD_HiImSaveDisp, new_choices->save_image_history);

  if (history_radio)
  {
    if ((window = choices_find_component(CD_HiRadImage))   != 0)
    radiobutton_set_state(0, window, CD_HiRadImage, 1);
  }
  else
  {
    if ((window = choices_find_component(CD_HiRadPage))    != 0)
    radiobutton_set_state(0, window, CD_HiRadPage, 1);
d1056 5
a1060 2
  if ((window = choices_find_component(CD_ClientPull))     != 0) optionbutton_set_state(0, window, CD_ClientPull,    new_choices->client_pull);
  if ((window = choices_find_component(CD_NetscapeEmu))    != 0) optionbutton_set_state(0, window, CD_NetscapeEmu,   new_choices->clone);
d1062 4
a1065 4
  if ((window = choices_find_component(CD_DragToScroll))   != 0) optionbutton_set_state(0, window, CD_DragToScroll,  new_choices->drag_to_scroll);
  if ((window = choices_find_component(CD_NoScrollBars))   != 0) optionbutton_set_state(0, window, CD_NoScrollBars,  new_choices->no_scroll_bars);
  if ((window = choices_find_component(CD_ShowMayScroll))  != 0) optionbutton_set_state(0, window, CD_ShowMayScroll, new_choices->show_may_scroll);
  if ((window = choices_find_component(CD_FramesSupport))  != 0) optionbutton_set_state(0, window, CD_FramesSupport, new_choices->support_frames);
d1067 1
a1067 2
  choices_set_frame_related_greyed(window, !new_choices->support_frames);
  if (new_choices->support_frames) set_gadget_state(window, CD_ShowMayScroll, !new_choices->no_scroll_bars);
d1069 1
a1069 5
  if ((window = choices_find_component(CD_RefoKeep))       != 0) optionbutton_set_state(0, window, CD_RefoKeep,      new_choices->refo_keep);
  if ((window = choices_find_component(CD_RefoHold))       != 0) optionbutton_set_state(0, window, CD_RefoHold,      new_choices->refo_hold);
  if ((window = choices_find_component(CD_RefoWait))       != 0)
  {
    optionbutton_set_state(0, window, CD_RefoWait, new_choices->refo_wait);
d1071 2
a1072 5
    set_gadget_state(window, CD_RefoTimeLabl,  !new_choices->refo_wait);
    set_gadget_state(window, CD_RefoTimeDisp,  !new_choices->refo_wait);
    set_gadget_state(window, CD_RefoTimeLabl2, !new_choices->refo_wait);
  }
  if ((window = choices_find_component(CD_RefoTimeDisp))   != 0) choices_numberrange_set_value(0,  window, CD_RefoTimeDisp, new_choices->refo_time);
d1074 219
a1292 1
  if ((window = choices_find_component(CD_FontsSystem))    != 0)
d1295 1
a1295 1
    choices_set_fonts_greyed(window, new_choices->system_font);
d1299 4
a1302 3
  if ((window = choices_find_component(CD_FontsTF1Disp))   != 0) choices_displayfield_set_value(0, window, CD_FontsTF1Disp, new_typefaces[0].fontnames[0]);
  if ((window = choices_find_component(CD_FontsTF2Disp))   != 0) choices_displayfield_set_value(0, window, CD_FontsTF2Disp, new_typefaces[1].fontnames[0]);
  if ((window = choices_find_component(CD_FontsTF3Disp))   != 0) choices_displayfield_set_value(0, window, CD_FontsTF3Disp, new_typefaces[2].fontnames[0]);
d1308 27
a1334 3
  if ((window = choices_find_component(CD_FontsSize))      != 0) choices_numberrange_set_value(0,  window, CD_FontsSize,    temp);
  if ((window = choices_find_component(CD_FontsAspect))    != 0) choices_numberrange_set_value(0,  window, CD_FontsAspect,  new_choices->tt_aspect);
  if ((window = choices_find_component(CD_FontsMinSize))   != 0) choices_numberrange_set_value(0,  window, CD_FontsMinSize, new_choices->minimum_font_size);
d1336 3
a1338 2
  if ((window = choices_find_component(CD_ObjHandle))      != 0) optionbutton_set_state(0,  window, CD_ObjHandle, new_choices->support_object);
  if ((window = choices_find_component(CD_ObjPlugDisp))    != 0)
d1340 2
a1341 4
    set_gadget_state(window, CD_ObjPlugLabl, !new_choices->support_object);
    set_gadget_state(window, CD_ObjPlugBt,   !new_choices->support_object);
    set_gadget_state(window, CD_ObjPlugDisp, !new_choices->support_object);
    choices_set_plugin_field();
d1343 1
a1343 2

  if ((window = choices_find_component(CD_URIHandlerDisp)) != 0)
d1345 2
a1346 1
    choices_set_uri_field();
d1349 13
a1361 1
  if ((window = choices_find_component(CD_CookieDisp)) != 0)
d1363 5
a1367 1
    choices_set_cookie_field();
d1369 3
d1373 3
a1375 1
  if ((window = choices_find_component(CD_JPEGDisp)) != 0)
d1377 3
a1379 1
    choices_set_jpeg_field();
d1381 1
a1381 2

  if ((window = choices_find_component(CD_RefererDisp)) != 0)
d1383 3
a1385 1
    choices_set_referer_field();
d1388 1
a1388 2
  if ((window = choices_find_component(CD_MSIE4StyleTables)) != 0) optionbutton_set_state(0, window, CD_MSIE4StyleTables, new_choices->msie4_style_tables);
  if ((window = choices_find_component(CD_TabSupport))       != 0)
d1390 3
a1392 2
    optionbutton_set_state(0, window, CD_TabSupport, new_choices->support_tables);
    choices_set_tables_greyed(window, !new_choices->support_tables);
d1394 1
a1394 2

  if ((window = choices_find_component(CD_TabInnerBordDisp)) != 0)
d1396 24
a1419 1
    choices_set_table_border_field(window, CD_TabInnerBordDisp, new_choices->table_inner);
d1421 1
a1421 2

  if ((window = choices_find_component(CD_TabOuterBordDisp)) != 0)
d1423 3
a1425 1
    choices_set_table_border_field(window, CD_TabOuterBordDisp, new_choices->table_outer);
d1428 41
a1468 2
  if ((window = choices_find_component(CD_NetUseProxy))     != 0) optionbutton_set_state(0,  window, CD_NetUseProxy, new_choices->use_proxy);
  if ((window = choices_find_component(CD_NetProxyAddr))    != 0)
d1470 2
a1471 3
    set_gadget_state(window, CD_NetProxyAddr, !new_choices->use_proxy);
    set_gadget_state(window, CD_NetProxyLabl, !new_choices->use_proxy);
    choices_writablefield_set_value(0, window, CD_NetProxyAddr, new_choices->proxy_address);
a1472 2
  if ((window = choices_find_component(CD_NetLaunchProxy))   != 0) optionbutton_set_state(0,  window, CD_NetLaunchProxy, new_choices->start_proxy);
  if ((window = choices_find_component(CD_NetMaxImageFetch)) != 0) choices_numberrange_set_value(0, window, CD_NetMaxImageFetch, new_choices->max_images);
d1474 4
a1477 4
  #ifdef JAVASCRIPT
    if ((window = choices_find_component(CD_JSWatchdog))      != 0) optionbutton_set_state        (0, window, CD_JSWatchdog,    new_choices->js_watchdog);
    if ((window = choices_find_component(CD_JSNavAsNav))      != 0) optionbutton_set_state        (0, window, CD_JSNavAsNav,    new_choices->js_nav_as_nav);
    if ((window = choices_find_component(CD_JSErrorBoxes))    != 0) optionbutton_set_state        (0, window, CD_JSErrorBoxes,  new_choices->js_error_boxes);
d1479 4
a1482 2
    if ((window = choices_find_component(CD_SupportJS))       != 0) optionbutton_set_state        (0, window, CD_SupportJS,     new_choices->support_js);
    if ((window = choices_find_component(CD_JSTimeoutDisp))   != 0) choices_numberrange_set_value (0, window, CD_JSTimeoutDisp, new_choices->js_timeout);
d1484 2
a1485 4
    if ((window = choices_find_component(CD_JSWinOpenDisp)) != 0)
    {
      choices_set_win_open_field();
    }
d1487 1
a1487 4
    if ((window = choices_find_component(CD_JSWinCloseDisp)) != 0)
    {
      choices_set_win_close_field();
    }
d1489 6
a1494 2
    choices_set_js_all_greyed(window, !new_choices->support_js);
  #endif
d1496 2
a1497 5
  if ((window = choices_find_component(CD_GCAfterNewFetch))   != 0) optionbutton_set_state        (0, window, CD_GCAfterNewFetch,   new_choices->collect_after);
  if ((window = choices_find_component(CD_GCUnusedLimitDisp)) != 0) choices_numberrange_set_value (0, window, CD_GCUnusedLimitDisp, new_choices->unused_image_limit);
  if ((window = choices_find_component(CD_GCFreeLimitDisp))   != 0) choices_numberrange_set_value (0, window, CD_GCFreeLimitDisp,   new_choices->free_ram_limit);
  if ((window = choices_find_component(CD_PreserveWidth))     != 0) optionbutton_set_state        (0, window, CD_PreserveWidth,     new_choices->toggle_on_y_only);
  if ((window = choices_find_component(CD_StripExtensions))   != 0) optionbutton_set_state        (0, window, CD_StripExtensions,   new_choices->strip_extensions);
d1506 3
a1508 1
/* contents of all the choices subwindows.                    */
a1513 1
  _kernel_oserror         * e;
a1514 1
  char                    * tempstring;
a1516 1
  int                       reqsize;
d1529 4
d1536 5
a1540 37
  if ((window = choices_find_component(CD_Homepage)) != 0)
  {
    e = writablefield_get_value(0, window, CD_Homepage, NULL, 0, &reqsize);

    if (!e)
    {
      tempstring = malloc(reqsize + 1);

      if (tempstring)
      {
        e = writablefield_get_value(0, window, CD_Homepage, tempstring, reqsize, NULL);

        if (!e)
        {
          if (!strcmp(tempstring, new_choices->home_page))
          {
            free(tempstring);
          }
          else
          {
            free(new_choices->home_page);
            new_choices->home_page = tempstring;
          }
        }
      }
      else
      {
        show_error_ret(make_no_memory_error(17));
      }
    }
  }

  if ((window = choices_find_component(CD_HlAutoOpen))        != 0) numberrange_get_value (0, window, CD_HlAutoOpen,        &new_choices->auto_open_delay);
  if ((window = choices_find_component(CD_HlAutoScroll))      != 0) numberrange_get_value (0, window, CD_HlAutoScroll,      &new_choices->auto_scroll_delay);
  if ((window = choices_find_component(CD_RefoTimeDisp))      != 0) numberrange_get_value (0, window, CD_RefoTimeDisp,      &new_choices->refo_time);
  if ((window = choices_find_component(CD_GCUnusedLimitDisp)) != 0) numberrange_get_value (0, window, CD_GCUnusedLimitDisp, &new_choices->unused_image_limit);
  if ((window = choices_find_component(CD_GCFreeLimitDisp))   != 0) numberrange_get_value (0, window, CD_GCFreeLimitDisp,   &new_choices->free_ram_limit);
d1571 1
a1571 1
      numberrange_get_value(0, window, CD_HiMaxSize, &temp);
d1586 1
a1586 2
      numberrange_get_value(0, window, CD_HiImExpiryAge, &temp);

d1599 1
a1599 2
      numberrange_get_value(0, window, CD_HiImMaxSize, &temp);

d1604 5
a1608 1
  if ((window = choices_find_component(CD_NetProxyAddr)) != 0)
d1610 5
a1614 1
    e = writablefield_get_value(0, window, CD_NetProxyAddr, NULL, 0, &reqsize);
d1616 7
a1622 3
    if (!e)
    {
      tempstring = malloc(reqsize + 1);
d1624 1
a1624 3
      if (tempstring)
      {
        e = writablefield_get_value(0, window, CD_NetProxyAddr, tempstring, reqsize, NULL);
d1626 8
a1633 17
        if (!e)
        {
          if (!strcmp(tempstring, new_choices->proxy_address))
          {
            free(tempstring);
          }
          else
          {
            free(new_choices->proxy_address);
            new_choices->proxy_address = tempstring;
          }
        }
      }
      else
      {
        show_error_ret(make_no_memory_error(17));
      }
d1635 1
d1638 1
a1638 1
  if ((window = choices_find_component(CD_NetMaxImageFetch)) != 0)
d1640 8
a1647 2
    numberrange_get_value(0, window, CD_NetMaxImageFetch,  &temp);
    new_choices->max_images = temp;
a1944 15
/* choices_close()                                            */
/*                                                            */
/* Close the Choices dialogue as if the 'Cancel' button had   */
/* been activated with Select.                                */
/**************************************************************/

_kernel_oserror * choices_close(void)
{
  if (new_choices) memcpy(new_choices, &choices, sizeof(global_choices));

  if (choices_windowid) return toolbox_hide_object(0, choices_windowid);
  else                  return NULL;
}

/**************************************************************/
d1986 1
a1986 1
/* choices_set_encoding_field()                               */
d1988 1
a1988 2
/* Sets the encoding display field appropriately to reflect   */
/* the current state of new_choices->encoding                 */
d1991 1
a1991 1
_kernel_oserror * choices_set_encoding_field(void)
d1993 12
a2004 5
  _kernel_oserror * e;
  ObjectId          objid, destwind;
  ComponentId       compid;
  char            * textptr;
  int               sizereqd;
d2006 3
a2008 1
  /* Find which window the encoding display is in */
d2010 1
a2010 2
  destwind = choices_find_component(CD_EncodingDisply);
  if (!destwind) return NULL;
d2012 1
a2012 1
  /* Find menu item which contains encoding name */
d2014 1
a2014 1
  if (encoding_get_encoding_item(new_choices->encoding, &objid, &compid))
d2016 8
a2023 1
    RetError(menu_get_entry_text(0, objid, compid, NULL, 0, &sizereqd));
d2025 1
a2025 3
    /* Add 1 to the buffer size just incase the sizereqd field is returned as string */
    /* length rather than the buffer size required.  Typical paranoid precautions    */
    /* when using the toolbox.                                                       */
d2027 1
a2027 1
    textptr = malloc(sizereqd+1);
d2029 1
a2029 8
    if (textptr)
    {
      e = menu_get_entry_text(0, objid, compid, textptr, sizereqd+1, NULL);
      if (e)
      {
        free(textptr);
        return e;
      }
d2031 1
a2031 1
      e = choices_displayfield_set_value(0, destwind, CD_EncodingDisply, textptr);
d2033 4
a2036 7
      free(textptr);
      return e;
    }
    else
    {
      RetError(make_no_memory_error(18));
    }
d2038 1
a2038 1
  else
d2040 2
a2041 3
    /* The encoding name could not be found in the menu structure */

    RetError(choices_displayfield_set_value(0, destwind, CD_EncodingDisply, "Unknown encoding")); //
d2043 1
a2043 20

  return NULL;
}

/**************************************************************/
/* choices_encoding_button_handler()                          */
/*                                                            */
/* Opens the encoding window with appropriate values for the  */
/* choices dialogue.                                          */
/**************************************************************/

static int choices_encoding_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;

  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
d2045 2
a2046 2
    show_error_ret(e);
    return 1;
d2048 1
a2048 3

  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
d2050 2
a2051 2
    show_error_ret(e);
    return 1;
d2054 5
a2058 2
  e = wimp_get_window_state(&state);
  if (e)
d2060 5
a2064 3
    show_error_ret(e);
    return 1;
  }
d2066 4
a2069 1
  /* Set open coordinates of encoding menu to top left of encoding button */
d2071 1
a2071 2
  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);
d2073 5
a2077 6
  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     encoding_get_menuid(),
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     choices_windowid,
                                     NULL));
d2079 3
a2081 2
  return 1;
}
d2083 1
a2083 6
/**************************************************************/
/* choices_colour_button_handler()                            */
/*                                                            */
/* Opens a colour dialogue box with appropriate settings for  */
/* the current colour.                                        */
/**************************************************************/
d2085 5
a2089 7
static int choices_colour_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;
  int colour[2];
d2091 1
a2091 1
  /* Is the ColourDbox module in RMA? */
d2093 1
a2093 1
  e = _swix(OS_Module, _INR(0,1), 18, "ColourDbox");
d2095 2
a2096 1
  /* No, well try and load it from system */
d2098 2
a2099 4
  if (e)
  {
    e = _swix(OS_Module, _INR(0,1), 1, "System:Modules.Toolbox.ColourDbox");
  }
d2101 1
a2101 1
  /* That didn't work so try reinitialising it */
d2103 1
a2103 4
  if (e)
  {
    e = _swix(OS_Module, _INR(0,1), 3, "ColourDbox");
  }
d2105 2
a2106 1
  /* That didn't work either!  So it's tough you can't change the colours */
d2108 1
a2108 5
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2110 5
a2114 12
  switch(idb->self_component)
  {
    case CD_BackColourBt: colour[0] = new_choices->background_colour; break;
    case CD_TextColourBt: colour[0] = new_choices->text_colour;       break;
    case CD_LinkColourBt: colour[0] = new_choices->link_colour;       break;
    case CD_UsedColourBt: colour[0] = new_choices->used_colour;       break;
    case CD_FolwColourBt: colour[0] = new_choices->followed_colour;   break;
    case CD_SlctColourBt: colour[0] = new_choices->selected_colour;   break;
    default:
    return 1;
    break;
  }
d2116 3
a2118 1
  colour[1] = 0;
d2120 1
a2120 6
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2122 5
a2126 6
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2128 3
a2130 6
  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2132 1
a2132 1
  /* Set open coordinates of encoding menu to top left of encoding button */
d2134 5
a2138 2
  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);
d2140 3
a2142 6
  e = toolbox_create_object(0, "ColourDbox", &colourdbox_id);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2144 1
a2144 6
  e = colourdbox_set_colour(0, colourdbox_id, colour);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2146 5
a2150 6
  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     colourdbox_id,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));
d2152 3
a2154 2
  e = event_register_toolbox_handler(colourdbox_id, ColourDbox_DialogueCompleted, choices_colour_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
d2156 1
a2156 2
  e = event_register_toolbox_handler(colourdbox_id, ColourDbox_ColourSelected, choices_colour_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
d2158 2
a2159 2
  return 1;
}
d2161 1
a2161 6
/**************************************************************/
/* choices_colour_closed_handler()                            */
/*                                                            */
/* Called when the colour dialogue box is closed deregisters  */
/* all events attached to it and deletes the dbox object.     */
/**************************************************************/
d2163 1
a2163 3
static int choices_colour_closed_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  _kernel_oserror *e;
d2165 2
a2166 2
  e = event_deregister_toolbox_handler(idb->self_id, ColourDbox_DialogueCompleted, choices_colour_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
d2168 1
a2168 7
  e = event_deregister_toolbox_handler(colourdbox_id, ColourDbox_ColourSelected, choices_colour_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = toolbox_delete_object(0, idb->self_id);
  if (e) {show_error_ret(e); return 1;}

  dprintf(("Choi", "choices_colour_closed_handler: Colour DBox deleted\n"));
d2174 20
a2193 1
/* choices_colour_selected_handler()                          */
d2195 2
a2196 4
/* Called when the a colour is selected in the colour         */
/* dialogue box. Sets appropriate fields in the new_choices   */
/* structure and updates the window to reflect the new colour */
/* chosen.                                                    */
d2199 11
a2209 1
static int choices_colour_selected_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d2211 11
a2221 1
  ColourDboxColourSelectedEvent *cevent = (ColourDboxColourSelectedEvent*)event;
d2223 1
a2223 1
  switch(idb->parent_component)
d2225 2
a2226 10
    case CD_BackColourBt: new_choices->background_colour = cevent->colour_block[0]; break;
    case CD_TextColourBt: new_choices->text_colour       = cevent->colour_block[0]; break;
    case CD_LinkColourBt: new_choices->link_colour       = cevent->colour_block[0]; break;
    case CD_UsedColourBt: new_choices->used_colour       = cevent->colour_block[0]; break;
    case CD_FolwColourBt: new_choices->followed_colour   = cevent->colour_block[0]; break;
    case CD_SlctColourBt: new_choices->selected_colour   = cevent->colour_block[0]; break;
    default:
    return 1;
    break;
  }
d2228 10
a2237 1
  /* Don't bother with errors as colour display field might not exist */
d2239 4
a2242 1
  choices_colour_set_component(idb->parent_id, idb->parent_component-1, cevent->colour_block[0]);
d2244 7
a2250 1
  /* Don't bother with errors as fake page display might not exist */
d2252 2
a2253 3
  button_set_flags(0, idb->parent_id, CD_FakePage, 0, 0);

  return 1;
d2257 14
a2270 1
/* choices_colour_set_component()                             */
d2272 1
a2272 2
/* Sets the validation string of a button to be slabbed in    */
/* and have the background colour specified.                  */
d2274 1
a2274 1
/* Parameters: Window ObjectId;                               */
d2276 1
a2276 1
/*             Button ComponentId;                            */
d2278 1
a2278 1
/*             Colour.                                        */
d2281 11
a2291 1
static _kernel_oserror *choices_colour_set_component(ObjectId window, ComponentId component, int colour)
d2293 7
a2299 2
  char            newvalidation[32];
  unsigned char * newcol;
d2301 1
a2301 1
  newcol = (unsigned char*)&colour;
d2303 1
a2303 1
  sprintf(newvalidation, "R2;C/%02.2x%02.2x%02.2x", *(newcol + 3), *(newcol + 2), *(newcol + 1));
d2305 7
a2311 1
  return choices_button_set_validation(0, window, component, newvalidation);
d2315 4
a2318 1
/* choices_display_button_handler()                           */
d2320 1
a2320 2
/* Opens the display menu with a value appropriate to either  */
/* the hotlist or history.                                    */
d2323 1
a2323 1
static int choices_display_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d2325 1
a2325 6
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;
  ObjectId display;
  int new_tick;
d2327 1
a2327 6
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2329 1
a2329 6
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2331 1
a2331 2
  e = wimp_get_window_state(&state);
  if (e)
d2333 3
a2335 28
    show_error_ret(e);
    return 1;
  }

  /* Set open coordinates of display menu to top left of display button */

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

  e = toolbox_create_object(0, "ChDisplay", &display);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  switch(idb->self_component)
  {
    case CD_HlDispBt: new_tick = new_choices->hotlist_show; break;
    case CD_HiDispBt: new_tick = new_choices->show_urls;    break;
    default: new_tick = 0; break;
  }

  if (disp_ticked != new_tick)
  {
    if (disp_ticked != -1) menu_set_tick(0, display, disp_ticked, 0);
    menu_set_tick(0, display, new_tick, 1);
    disp_ticked = new_tick;
a2337 7
  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     display,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));

d2342 1
a2342 1
/* choices_save_m_button_handler()                            */
d2344 2
a2345 2
/* Opens the save menu with a value appropriate to either the */
/* hotlist or visit/image history.                            */
d2348 1
a2348 1
static int choices_save_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d2350 2
a2351 6
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;
  ObjectId display;
  int new_tick;
d2353 1
a2353 6
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2355 1
a2355 6
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d2357 1
a2357 2
  e = wimp_get_window_state(&state);
  if (e)
d2359 14
a2372 3
    show_error_ret(e);
    return 1;
  }
d2374 14
a2387 1
  /* Set open coordinates of display menu to top left of display button */
d2389 7
a2395 2
  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);
d2397 6
a2402 20
  e = toolbox_create_object(0, "ChSave", &display);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  switch(idb->self_component)
  {
    case CD_HlSaveBt:   new_tick = new_choices->save_hotlist; break;
    case CD_HiSaveBt:   new_tick = new_choices->save_history; break;
    case CD_HiImSaveBt: new_tick = new_choices->save_image_history; break;
    default: new_tick = 0; break;
  }

  if (save_ticked != new_tick)
  {
    if (save_ticked != -1) menu_set_tick(0, display, save_ticked, 0);
    menu_set_tick(0, display, new_tick, 1);
    save_ticked = new_tick;
a2404 7
  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     display,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));

d2409 1
a2409 24
/* choices_set_save_field()                                   */
/*                                                            */
/* Sets the passed save display field appropriately to        */
/* reflect the passed state.                                  */
/**************************************************************/

static _kernel_oserror * choices_set_save_field(ObjectId obj, ComponentId comp, int state)
{
  _kernel_oserror *e;
  char *tempstring;

  dprintf(("Choi", "choices_set_display_field: Called\n"));

  RetError(choices_get_menu_entry_text("ChSave", state, &tempstring));

  e = choices_displayfield_set_value(0, obj, comp, tempstring);

  free(tempstring);

  return e;
}

/**************************************************************/
/* choices_set_display_field()                                */
d2411 2
a2412 22
/* Sets the passed display display field appropriately to     */
/* reflect the passed state.                                  */
/**************************************************************/

static _kernel_oserror * choices_set_display_field(ObjectId obj, ComponentId comp, int state)
{
  _kernel_oserror *e;
  char *tempstring;

  dprintf(("Choi", "choices_set_display_field: Called\n"));

  RetError(choices_get_menu_entry_text("ChDisplay", state, &tempstring));

  e = choices_displayfield_set_value(0, obj, comp, tempstring);

  free(tempstring);

  return e;
}

/**************************************************************/
/* choices_display_m_click_handler()                          */
d2414 1
a2414 5
/* Called when there is a selection in the display menu. Sets */
/* the selected menu item to be ticked, unticks the           */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the display field of the component with        */
/* component number 1 less than the menus parent.             */
d2417 7
a2423 1
static int choices_display_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d2425 1
a2425 8
  if (disp_ticked != idb->self_component)
  {
    if (disp_ticked != -1) menu_set_tick(0, idb->self_id, disp_ticked, 0);
    menu_set_tick(0, idb->self_id, idb->self_component, 1);
    disp_ticked = idb->self_component;
  }

  switch(idb->parent_component)
d2427 6
a2432 6
    case CD_HlDispBt:
    new_choices->hotlist_show = idb->self_component;
    break;
    case CD_HiDispBt:
    new_choices->show_urls    = idb->self_component;
    break;
a2434 2
  choices_set_display_field(idb->parent_id, idb->parent_component - 1, idb->self_component);

d2439 1
a2439 1
/* choices_save_m_click_handler()                             */
d2441 5
a2445 5
/* Called when there is a selection in the save menu. Sets    */
/* the selected menu item to be ticked, unticks the           */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the display field of the component with        */
/* component number 1 less than the menus parent.             */
d2448 7
a2454 1
static int choices_save_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d2456 3
a2458 1
  if (save_ticked != idb->self_component)
d2460 3
a2462 4
    if (save_ticked != -1) menu_set_tick(0, idb->self_id, save_ticked, 0);
    menu_set_tick(0, idb->self_id, idb->self_component, 1);
    save_ticked = idb->self_component;
  }
d2464 12
a2475 4
  switch(idb->parent_component)
  {
    case CD_HlSaveBt:
    new_choices->save_hotlist = idb->self_component;
d2477 17
a2493 5
    case CD_HiSaveBt:
    new_choices->save_history = idb->self_component;
    break;
    case CD_HiImSaveBt:
    new_choices->save_image_history = idb->self_component;
d2497 3
a2499 1
  choices_set_save_field(idb->parent_id, idb->parent_component - 1, idb->self_component);
d2505 1
a2505 1
/* choices_draw_string()                                      */
d2507 3
a2509 20
/* Writes a string on the screen using the passed font        */
/* handle, it underlines the text if required. It also        */
/* returns the position to paint the next string following    */
/* this one.                                                  */
/*                                                            */
/* Parameters: Font handle;                                   */
/*                                                            */
/*             String to print;                               */
/*                                                            */
/*             X position on screen (OS coords);              */
/*                                                            */
/*             Y position on screen (OS coords);              */
/*                                                            */
/*             0 - don't underline, non-0 - underline;        */
/*                                                            */
/*             Foreground colour;                             */
/*                                                            */
/*             Background colour;                             */
/*                                                            */
/*             Pointer to int to return x position in.        */
d2512 1
a2512 2
static _kernel_oserror * choices_draw_string(fm_face h, char * string, int xpos, int ypos,
                                             int underline, int forecolour, int backcolour, int * newxpos)
d2514 2
a2515 1
  int width, nochars;
d2517 1
a2517 3
  fm_set_font_colour(h, forecolour, backcolour);
  fm_get_string_width(h, string, 0x1000000, strlen(string), -1, &nochars, &width);
  convert_to_os(width, &width);
d2519 5
a2523 1
  /* The next string must be plotted straight after this string */
d2525 1
a2525 1
  *newxpos = xpos + width;
d2527 439
a2965 1
  fm_puts(h, xpos, ypos, string, 1, 0);
d2967 7
a2973 1
  if (underline)
d2975 1
a2975 3
    redraw_set_colour(forecolour);
    bbc_move(xpos, ypos - 7);
    bbc_draw(*newxpos, ypos - 7);
a2976 1
  return NULL;
d2980 1
a2980 1
/* choices_write_rubbish()                                    */
d2982 2
a2983 3
/* Writes a string of readable rubbish on the screen using    */
/* the passed font handle. It also returns the position to    */
/* paint the next string following this one.                  */
d2985 3
a2987 1
/* Parameters: Font handle;                                   */
d2989 2
a2990 1
/*             X position on screen (OS coords);              */
d2992 46
a3037 1
/*             Y position on screen (OS coords);              */
d3039 2
a3040 8
/*             Approximate x position to stop printing at (OS */
/*             coords);                                       */
/*                                                            */
/*             Foreground colour;                             */
/*                                                            */
/*             Background colour;                             */
/*                                                            */
/*             Pointer to int to return x position in;        */
d3042 1
a3042 2
/*             Random seed for string to print (if you pass   */
/*             the same seed the string should be the same).  */
d3045 7
a3051 2
static _kernel_oserror * choices_write_rubbish(fm_face h, int xpos, int ypos, int maxxish,
                                               int forecolour, int backcolour, int * newxpos, int seed)
d3053 2
a3054 3
  char ministring[5];
  int chars = 0;
  int spcwidth, width, nochars;
d3056 1
a3056 1
  fm_set_font_colour(h, forecolour, backcolour);
d3058 6
a3063 1
  srand(seed);
d3065 8
a3072 3
  fm_get_string_width(h, " ", 0x1000000, 1, -1, &nochars, &width);
  convert_to_os(width, &spcwidth);
  xpos += spcwidth;
d3074 8
a3081 4
  while(xpos < maxxish)
  {
    ministring[0] = consonant[rand()%(sizeof(consonant)-1)];
    ministring[1] = vowel[rand()%(sizeof(vowel)-1)];
d3083 10
a3092 10
    if (rand()%2)
    {
      ministring[2] = consonant[rand()%(sizeof(consonant)-1)];
      ministring[3] = vowel[rand()%(sizeof(vowel)-1)];
      ministring[4] = 0;
    }
    else
    {
      ministring[2] = 0;
    }
d3094 1
a3094 4
    fm_puts(h, xpos, ypos, ministring, 1, 0);
    fm_get_string_width(h, ministring, 0x1000000, strlen(ministring), -1, &nochars, &width);
    convert_to_os(width, &width);
    xpos += width;
d3096 6
a3101 6
    chars++;
    if (chars > rand()%2 || xpos >= maxxish)
    {
      chars = 0;
      xpos += spcwidth;
    }
d3104 7
a3110 2
  *newxpos = xpos;
  return NULL;
d3114 3
a3116 1
/* choices_redraw_fakepage_handler()                          */
d3118 1
a3118 1
/* Redraws the fake page in the colour selection dbox.        */
d3121 7
a3127 1
static int choices_redraw_fakepage_handler(int eventcode, WimpPollBlock * event, IdBlock * idb, void * handle)
d3129 16
a3144 9
  _kernel_oserror       * e = NULL;
  WimpRedrawWindowBlock   block;
  WimpGetWindowStateBlock state;
  int                     more, ypos, xtarget, ptsize, gadsize, xstart, nolines;
  int                     fontheight = 0;
  int                     gotfont    = 0;
  BBox                    icon_coords, fbox;
  fm_face                 h = 0;
  char                    display_this[4];
d3146 16
a3161 2
  block.window_handle = event->redraw_window_request.window_handle;
  state.window_handle = event->redraw_window_request.window_handle;
d3163 7
a3169 3
  e = wimp_get_window_state(&state);
  show_error_ret(e);
  if (!e) e = gadget_get_bbox(0, idb->self_id, CD_FakePage, &icon_coords);
d3171 16
a3186 1
  gadsize = icon_coords.ymax - icon_coords.ymin;
d3188 7
a3194 1
  xstart = gadsize / 8;
d3196 16
a3211 5
  if (e)
  {
    /* Gadget doesn't exist or something strange happened trying */
    /* to get window state so just do a simple redraw loop to    */
    /* keep the wimp happy.                                      */
d3213 7
a3219 4
    ChkError(wimp_redraw_window(&block, &more));
    while (more && !e) e = wimp_get_rectangle(&block, &more);
    return 1;
  }
d3221 16
a3236 1
  coords_box_toscreen(&icon_coords, (WimpRedrawWindowBlock *) &state);
d3238 8
a3245 1
  /* Find out which lines to draw */
d3247 10
a3256 1
  for(nolines = 0; nolines < sizeof(display_this); nolines++) display_this[nolines] = 0;
d3258 1
a3258 1
  nolines = 1; /* Start with one line (half at top, half at bottom) */
d3260 1
a3260 1
  if (choices_find_component(CD_LinkColourBt))
d3262 3
a3264 17
    nolines ++;
    display_this[0] = 1;
  }
  if (choices_find_component(CD_UsedColourBt))
  {
    nolines ++;
    display_this[1] = 1;
  }
  if (choices_find_component(CD_FolwColourBt))
  {
    nolines ++;
    display_this[2] = 1;
  }
  if (choices_find_component(CD_SlctColourBt))
  {
    nolines ++;
    display_this[3] = 1;
d3267 8
a3274 1
  /* Start the redraw loop */
d3276 7
a3282 1
  ChkError(wimp_redraw_window(&block, &more));
d3284 16
a3299 3
  while (more && !e)
  {
    /* Clip the redraw area to only take in the gadget */
d3301 8
a3308 3
    if (set_graphics_intersection(&icon_coords, &block.redraw_area))
    {
      /* Only claim the font if it is required */
d3310 9
a3318 4
      if (!gotfont)
      {
        /* Find default browser font, the font manager will return system */
        /* font if it is configured.                                      */
d3320 1
a3320 1
        /* Find a 1000 subpoint (big) version of default browser font to scale against */
d3322 6
a3327 5
        h = fm_find_font(NULL, "serif", 1000, 1000, 0, 0);
        e = fm_font_box(h, &fbox);
        fm_lose_font(NULL, h);
        if (e) show_error_cont(e);
        fontheight = fbox.ymax - fbox.ymin;
d3329 8
a3336 3
        /* Find a version of the default browser font with a */
        /* point size which will allow an appropriate number */
        /* of lines in the fake page display.                */
d3338 1
a3338 1
        ptsize = ((gadsize * 1000 / nolines) / fontheight);
d3340 7
a3346 12
        h = fm_find_font(NULL, "serif", ptsize, ptsize, 0, 0);
        ChkError(fm_font_box(h, &fbox));
        fontheight = fbox.ymax - fbox.ymin;
        gotfont = 1;
      }

      /* Fake browser drawing code is here */

      /* Fill background with background colour */

      redraw_set_colour(new_choices->background_colour);
      ChkError(bbc_rectanglefill(icon_coords.xmin, icon_coords.ymin, icon_coords.xmax - icon_coords.xmin, icon_coords.ymax - icon_coords.ymin));
d3348 16
a3363 2
      xtarget = icon_coords.xmin - 32;
      ypos = icon_coords.ymax - fontheight / 3;
d3365 7
a3371 1
      /* Display the top line of the fake page display */
d3373 16
a3388 1
      ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 1));
d3390 1
a3390 2
      ypos -= fontheight;
      xtarget = icon_coords.xmin - 32;
d3392 6
a3397 1
      /* Display the new link line of the fake page display */
d3399 7
a3405 5
      if (display_this[0])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 2));
        ChkError(choices_draw_string(h, "new", xtarget, ypos, new_choices->underline_links, new_choices->link_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 3));
d3407 1
a3407 3
        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }
d3409 5
a3413 1
      /* Display the new followed line of the fake page display */
d3415 2
a3416 9
      if (display_this[1])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 4));
        ChkError(choices_draw_string(h, "followed", xtarget, ypos, new_choices->underline_links, new_choices->used_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 5));

        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }
d3418 1
a3418 1
      /* Display the highlighted link line of the fake page display */
d3420 3
a3422 5
      if (display_this[2])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 6));
        ChkError(choices_draw_string(h, "highlighted", xtarget, ypos, new_choices->underline_links, new_choices->followed_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 7));
d3424 2
a3425 3
        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }
d3427 1
a3427 1
      /* Display the selected link line of the fake page display */
d3429 1
a3429 5
      if (display_this[3])
      {
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 8));
        ChkError(choices_draw_string(h, "selected", xtarget, ypos, new_choices->underline_links, new_choices->selected_colour, new_choices->background_colour, &xtarget));
        ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 9));
d3431 4
a3434 3
        ypos -= fontheight;
        xtarget = icon_coords.xmin - 32;
      }
d3436 6
a3441 1
      /* Display the bottom line of the fake page display */
d3443 1
a3443 2
      ChkError(choices_write_rubbish(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, rubbish_seed + 10));
    }
d3445 1
a3445 1
    restore_graphics_intersection(&block.redraw_area);
d3447 6
a3452 1
    /* Get the next redraw rectangle */
d3454 1
a3454 2
    if (!e) e = wimp_get_rectangle(&block, &more);
  }
d3456 2
a3457 1
  if (gotfont) fm_lose_font(NULL, h);
d3463 1
a3463 1
/* choices_option_state_handler()                             */
d3465 2
a3466 3
/* Called when an option button has its state changed by      */
/* being clicked on. Sets or unsets the relevant flag in      */
/* new_choices and causes redraws where necessary.            */
d3469 1
a3469 1
static int choices_option_state_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d3471 4
a3474 2
  int               state;
  ObjectId          window;
d3476 6
a3481 1
  ChkError(optionbutton_get_state(0, idb->self_id, idb->self_component, &state));
d3483 2
a3484 1
  switch(idb->self_component)
d3486 3
a3488 3
    case CD_UnderlineLinks:
    {
      new_choices->underline_links = !!state;
d3490 6
a3495 1
      /* Attempt to redraw fake page display */
d3497 1
a3497 3
      if ((window = choices_find_component(CD_FakePage)) != 0) button_set_flags(0, window, CD_FakePage, 0, 0);
      break;
    }
d3499 2
a3500 3
    case CD_UseDocColours:  new_choices->use_source_cols = !!state; break;
    case CD_ShowForeground: new_choices->show_foreground = !!state; break;
    case CD_ShowBackground: new_choices->show_background = !!state; break;
d3502 6
a3507 4
    case CD_URLBar:         new_choices->url_bar         = !!state; break;
    case CD_StatusBar:      new_choices->status_bar      = !!state; break;
    case CD_ButtonBar:      new_choices->button_bar      = !!state; break;
    case CD_FullScreen:     new_choices->full_screen     = !!state; break;
d3509 2
a3510 2
    case CD_ClientPull:     new_choices->client_pull     = !!state; break;
    case CD_NetscapeEmu:    new_choices->clone           = !!state; break;
d3512 6
a3517 7
    case CD_FramesSupport:
    {
      new_choices->support_frames = !!state;
      choices_set_frame_related_greyed(idb->self_id, !state);
      if (new_choices->support_frames) set_gadget_state(idb->self_id, CD_ShowMayScroll, !new_choices->no_scroll_bars);
    }
    break;
d3519 7
a3525 5
    case CD_RefoKeep:       new_choices->refo_keep       = !!state; break;
    case CD_RefoHold:       new_choices->refo_hold       = !!state; break;
    case CD_RefoWait:
    {
      new_choices->refo_wait = !!state;
d3527 1
a3527 8
      if ((window = choices_find_component(CD_RefoTimeLabl)) != 0)
      {
        set_gadget_state(window, CD_RefoTimeLabl,  !state);
        set_gadget_state(window, CD_RefoTimeDisp,  !state);
        set_gadget_state(window, CD_RefoTimeLabl2, !state);
      }
    }
    break;
d3529 1
a3529 6
    case CD_NoScrollBars:
    {
      new_choices->no_scroll_bars = !!state;
      set_gadget_state(idb->self_id, CD_ShowMayScroll, !new_choices->no_scroll_bars);
    }
    break;
d3531 1
a3531 2
    case CD_DragToScroll:   new_choices->drag_to_scroll  = !!state; break;
    case CD_ShowMayScroll:  new_choices->show_may_scroll = !!state; break;
d3533 4
a3536 34
    case CD_FontsSystem:
    {
      new_choices->system_font = !!state;
      if ((window = choices_find_component(CD_FontsTF1Labl)) != 0)
      {
        choices_set_fonts_greyed(window, new_choices->system_font);
        /*set_gadget_state(window, CD_FontsGroup1,  new_choices->system_font);*/
        if ((window = choices_find_component(CD_FontsSize)) != 0)
        {
          if (new_choices->system_font)
          {
            int frac, temp;
            numberrange_get_value(0, window, CD_FontsSize, &new_choices->font_size);
            frac = new_choices->font_size % 10;
            new_choices->font_size = ((new_choices->font_size / 10)<<4) + fromdecimal[frac];
            temp = FM_Standard_Size;
            frac = (temp & 0xf);
            temp = ((temp >> 4) * 10) + todecimal[frac];
            choices_numberrange_set_value(0, window, CD_FontsSize, temp);
            choices_numberrange_set_value(0, window, CD_FontsAspect, 100);
          }
          else
          {
            int temp, frac;
            temp = new_choices->font_size;
            frac = (temp & 0xf);
            temp = ((temp >> 4) * 10) + todecimal[frac];
            choices_numberrange_set_value(0, window, CD_FontsSize, temp);
            choices_numberrange_set_value(0, window, CD_FontsAspect, new_choices->tt_aspect);
          }
        }
      }
    }
    break;
d3538 1
a3538 3
    case CD_ObjHandle:
    {
      new_choices->support_object = !!state;
d3540 4
a3543 20
      if ((window = choices_find_component(CD_ObjPlugDisp)) != 0)
      {
        set_gadget_state(window, CD_ObjPlugLabl, !new_choices->support_object);
        set_gadget_state(window, CD_ObjPlugBt,   !new_choices->support_object);
        set_gadget_state(window, CD_ObjPlugDisp, !new_choices->support_object);
        choices_set_plugin_field();
      }
    }
    break;

    case CD_NetUseProxy:
    {
      new_choices->use_proxy = !!state;
      if ((window = choices_find_component(CD_NetProxyAddr))    != 0)
      {
        set_gadget_state(window, CD_NetProxyAddr, !new_choices->use_proxy);
        set_gadget_state(window, CD_NetProxyLabl, !new_choices->use_proxy);
      }
    }
    break;
d3545 1
a3545 1
    case CD_NetLaunchProxy: new_choices->start_proxy = !!state; break;
d3547 5
a3551 6
    case CD_HiDontAge:
    {
      choices_set_expiry_age_greyed(idb->self_id, !state);
      expiry_age_greyed = !state;
    }
    break;
d3553 10
a3562 5
    case CD_HiDontSize:
    {
      choices_set_max_size_greyed(idb->self_id, !state);
      max_size_greyed = !state;
    }
d3564 1
d3566 1
a3566 6
    case CD_HiImDontAge:
    {
      choices_set_im_expiry_age_greyed(idb->self_id, !state);
      image_expiry_age_greyed = !state;
    }
    break;
d3568 6
a3573 6
    case CD_HiImDontSize:
    {
      choices_set_im_max_size_greyed(idb->self_id, !state);
      image_max_size_greyed = !state;
    }
    break;
d3575 6
a3580 1
    case CD_MSIE4StyleTables: new_choices->msie4_style_tables = !!state; break;
d3582 6
a3587 6
    case CD_TabSupport:
    {
      new_choices->support_tables = !!state;
      choices_set_tables_greyed(idb->self_id, !state);
    }
    break;
d3589 1
a3589 1
    #ifdef JAVASCRIPT
d3591 2
a3592 6
      case CD_SupportJS:
      {
        new_choices->support_js = !!state;
        choices_set_js_all_greyed(idb->self_id, !state);
      }
      break;
d3594 6
a3599 6
      case CD_JSWatchdog:
      {
        new_choices->js_watchdog = !!state;
        choices_set_js_watchdog_greyed(idb->self_id, !state);
      }
      break;
d3601 6
a3606 2
      case CD_JSNavAsNav:   new_choices->js_nav_as_nav  = !!state; break;
      case CD_JSErrorBoxes: new_choices->js_error_boxes = !!state; break;
d3608 6
a3613 1
    #endif
d3615 2
a3616 3
    case CD_GCAfterNewFetch: new_choices->collect_after    = !!state; break;
    case CD_PreserveWidth:   new_choices->toggle_on_y_only = !!state; break;
    case CD_StripExtensions: new_choices->strip_extensions = !!state; break;
d3618 2
a3619 4
    /* Haven't recognised this option button event so pass it on */

    default: return 0;
  }
d3625 6
a3630 1
/* choices_mode_change()                                      */
d3632 1
a3632 3
/* Called on every mode change event. Records that a mode     */
/* change has taken place for use with the                    */
/* choices_open_choice_window function.                       */
d3635 7
a3641 1
_kernel_oserror * choices_mode_change(void)
d3643 25
a3667 1
  choices_modechanged = 1;
d3669 1
a3669 1
  return NULL;
d3673 6
a3678 1
/* choices_open_choice_window()                               */
d3680 1
a3680 4
/* Called whenever the choices window needs to be moved and   */
/* specifically on mode changes so the current sub window can */
/* be positioned correctly dealing with rounding errors       */
/* between modes of different aspect ratio.                   */
d3683 7
a3689 1
static int choices_open_choice_window(int eventcode, WimpPollBlock * event, IdBlock * idb, void * handle)
d3691 20
a3710 1
  toolbox_show_object(0, idb->self_id, Toolbox_ShowObject_FullSpec, &(event->open_window_request.visible_area), idb->parent_id, idb->parent_component);
d3712 1
a3712 1
  if (choices_modechanged)
d3714 3
a3716 4
    /* Reshow the subwindow at possibly new location */

    choices_show_subwindow(idb->self_id, current_subwindow);
    choices_modechanged = 0;
d3723 1
a3723 5
/* choices_find_component()                                   */
/*                                                            */
/* Scans all the choices subwindows for the requested         */
/* component and returns the id of the first window in which  */
/* it was seen.                                               */
d3725 1
a3725 1
/* Parameters: The component to find.                         */
d3727 1
a3727 2
/* Returns:    Where to return the object id to. 0 if the     */
/*             component was not found                        */
d3730 7
a3736 1
static ObjectId choices_find_component(ComponentId component)
d3738 1
a3738 4
  int          findwindow;
  unsigned int flags;

  #ifndef TRACE
d3740 7
a3746 2
    /* Uses lazy evaluation to not call gadget_get_flags unless */
    /* subwindows[findwindow] contains an objectid.             */
d3748 2
a3749 64
    for (findwindow = 0; findwindow < CDNoSubwindows; findwindow++)
    {
      if (
           subwindows[findwindow] &&
           !gadget_get_flags(0,
                             subwindows[findwindow],
                             component,
                             &flags)
         )
         return subwindows[findwindow];
    }

  #else

    /* TRACE builds will check for multiple same component IDs,   */
    /* and complain. Would have saved at least one time consuming */
    /* error in Phoenix if I'd thought to do this a week earlier! */

    {
      ObjectId found = NULL_ObjectId;
      int      pane  = 0;

      for (findwindow = 0; findwindow < CDNoSubwindows; findwindow++)
      {
        if (
             subwindows[findwindow] &&
             !gadget_get_flags(0,
                               subwindows[findwindow],
                               component,
                               &flags)
           )
        {
          if (found == NULL_ObjectId)
          {
            found = subwindows[findwindow];
            pane  = findwindow;
          }
          else
          {
            erb.errnum = Utils_Error_Custom_Normal;

            sprintf(erb.errmess,
                    "Duplicate component ID 0x%x in Choices dialogue box panes %d and %d.",
                    component,
                    pane,
                    findwindow);

            show_error_ret(&erb);

            found = subwindows[findwindow];
          }

        /* Closure of 'if' with code above running if the gadget is found */
        }

      /* Closure of 'for' loop */
      }

      if (found != NULL_ObjectId) return found;
    }

  #endif

  return 0;
d3753 3
a3755 1
/* choices_writablefield_set_value()                          */
d3757 1
a3757 3
/* Does as writablefield_set_value but will only update it if */
/* the text is different to that currently in the display     */
/* field.                                                     */
d3760 7
a3766 1
static _kernel_oserror *choices_writablefield_set_value(unsigned int flags, ObjectId window, ComponentId writable, char *text)
d3768 1
a3768 15
  int               reqdsize;
  char            * oldtext;
  _kernel_oserror * e = NULL;

  RetError(writablefield_get_value(0, window, writable, NULL, 0, &reqdsize));

  oldtext = malloc(reqdsize+1);
  if (!oldtext) return make_no_memory_error(100);

  writablefield_get_value(0, window, writable, oldtext, reqdsize, NULL);

  if (strcmp(text, oldtext))
  {
    e = writablefield_set_value(flags, window, writable, text);
  }
d3770 9
a3778 3
  free(oldtext);

  return e;
d3782 3
a3784 1
/* choices_displayfield_set_value()                           */
d3786 1
a3786 3
/* Does as displayfield_set_value but will only update it if  */
/* the text is different to that currently in the display     */
/* field.                                                     */
d3789 7
a3795 1
static _kernel_oserror *choices_displayfield_set_value(unsigned int flags, ObjectId window, ComponentId writable, char *text)
d3797 12
a3808 3
  int               reqdsize;
  char            * oldtext;
  _kernel_oserror * e = NULL;
d3810 7
a3816 1
  RetError(displayfield_get_value(0, window, writable, NULL, 0, &reqdsize));
d3818 9
a3826 2
  oldtext = malloc(reqdsize+1);
  if (!oldtext) return make_no_memory_error(100);
d3828 10
a3837 1
  displayfield_get_value(0, window, writable, oldtext, reqdsize, NULL);
d3839 7
a3845 4
  if (strcmp(text, oldtext))
  {
    e = displayfield_set_value(flags, window, writable, text);
  }
d3847 9
a3855 1
  free(oldtext);
d3857 9
a3865 1
  return e;
d3869 6
a3874 1
/* choices_button_set_validation()                            */
d3876 1
a3876 2
/* Does as button_set_validation but will only update it if   */
/* the text is different to that currently in the button.     */
d3879 7
a3885 1
static _kernel_oserror *choices_button_set_validation(unsigned int flags, ObjectId window, ComponentId writable, char *text)
d3887 3
a3889 3
  int               reqdsize;
  char            * oldtext;
  _kernel_oserror * e = NULL;
d3891 1
a3891 1
  RetError(button_get_validation(0, window, writable, NULL, 0, &reqdsize));
d3893 5
a3897 2
  oldtext = malloc(reqdsize+1);
  if (!oldtext) return make_no_memory_error(100);
d3899 7
a3905 1
  button_get_validation(0, window, writable, oldtext, reqdsize, NULL);
d3907 1
a3907 1
  if (strcmp(text, oldtext))
d3909 2
a3910 1
    e = button_set_validation(flags, window, writable, text);
d3913 1
a3913 3
  free(oldtext);

  return e;
d3917 3
a3919 1
/* choices_numberrange_set_value()                            */
d3921 1
a3921 2
/* Does as numberrange_set_value but will only update it if   */
/* the number is different to that currently in the display.  */
d3924 7
a3930 1
static _kernel_oserror *choices_numberrange_set_value(unsigned int flags, ObjectId window, ComponentId writable, int value)
d3932 1
a3932 2
  int               oldvalue;
  _kernel_oserror * e = NULL;
d3934 9
a3942 8
  RetError(numberrange_get_value(0, window, writable, &oldvalue));

  if (oldvalue != value)
  {
    e = numberrange_set_value(flags, window, writable, value);
  }

  return e;
d3946 1
a3946 1
/* choices_modified_font()                                    */
d3948 4
a3951 8
/* Finds a version of a font with a specified modification    */
/* eg. bold or italic.                                        */
/*                                                            */
/* Parameters: pointer to the original font name              */
/*                                                            */
/*             pointer to a space separated and null          */
/*             terminated list of modifications in order of   */
/*             preference                                     */
d3953 1
a3953 2
/*             pointer to a buffer to contain the name of the */
/*             new font.                                      */
d3956 7
a3962 1
static void choices_modified_font(char * orig, char * mod, char * buffer)
d3964 3
a3966 6
  _kernel_oserror * e = NULL;
  char              origname[Limits_FontName];
  int               f=-1;
  char            * p, * p2;
  char            * lastdot;
  BOOL              found;
d3968 1
a3968 1
  /* Find the fontname field */
d3970 3
a3972 1
  _swix(Font_FindField, _INR(1,2)|_OUTR(1,2), orig, 'F', &p, &found);
d3974 3
a3976 2
  /* If the field could not be found assume that the entire */
  /* string is the font name.                               */
d3978 7
a3984 1
  if (!found) p = orig;
d3986 1
a3986 1
  p2 = origname;
d3988 3
a3990 3
  /* Extract the font name.                                       */
  /* Copys the string pointed to by p to p2 until either a \ or a */
  /* character with an ascii value less than 32 is encountered.   */
d3992 3
a3994 1
  while (*p > 32 && *p != '\\') *p2++ = *p++;
d3996 1
a3996 1
  /* NULL terminate the new string */
d3998 1
a3998 1
  *p2 = '\0';
d4000 3
a4002 3
  lastdot = strrchr(origname, '.');

  /* Get first of possibly several possible modifications */
d4004 1
a4004 1
  p = strtok(mod, " ");
d4006 1
a4006 4
  while (p)
  {
    sprintf(buffer, "%s.%s", origname, p);
    e=_swix(Font_FindFont, _INR(1,5)|_OUT(0), buffer, 12*16, 12*16, 90, 90, &f);
d4008 1
a4008 1
    /* If there was no error then the font must have been found */
d4010 2
a4011 1
    if (!e) break;
d4013 5
a4017 8
    if (lastdot)
    {
      *lastdot = '\0';
      sprintf(buffer, "%s.%s", origname, p);
      *lastdot = '.';
      e=_swix(Font_FindFont, _INR(1,5)|_OUT(0), buffer, 12*16, 12*16, 90, 90, &f);
      if (e==NULL) break;
    }
d4019 4
a4022 1
    /* Get the next modification */
d4024 6
a4029 1
    p=strtok(NULL, " ");
d4032 1
a4032 8
  /* If a font has been 'found' we need to lose it again */

  if (f >= 0) _swix(Font_LoseFont, _IN(0), f);

  /* If an error was encountered the best we can do is */
  /* to return the original font.                      */

  if (e) strcpy(buffer, orig);
d4036 3
a4038 1
/* choices_font_button_handler()                              */
d4040 1
a4040 2
/* Opens a font menu box with appropriate settings for the    */
/* current font.                                              */
d4043 7
a4049 1
static int choices_font_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4051 5
a4055 7
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;
  ObjectId                fontmenu_id;
  int colour[2];
  char * fontname;
d4057 1
a4057 1
  switch(idb->self_component)
d4059 1
a4059 3
    case CD_FontsTF1Bt: break;
    case CD_FontsTF2Bt: break;
    case CD_FontsTF3Bt: break;
d4061 6
a4066 3
    default:
    return 1;
    break;
d4069 3
a4071 1
  colour[1] = 0;
d4073 5
a4077 2
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
d4079 4
a4082 2
    show_error_ret(e);
    return 1;
d4085 21
a4105 6
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4107 2
a4108 6
  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4110 2
a4111 1
  /* Set open coordinates of encoding menu to top left of encoding button */
d4113 4
a4116 2
  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);
d4118 1
a4118 2
  e = toolbox_create_object(0, "FontMenu", &fontmenu_id);
  if (e)
d4120 1
a4120 3
    show_error_ret(e);
    return 1;
  }
d4122 6
a4127 6
  switch(idb->self_component)
  {
    case CD_FontsTF1Bt: fontname = new_typefaces[0].fontnames[0]; break;
    case CD_FontsTF2Bt: fontname = new_typefaces[1].fontnames[0]; break;
    case CD_FontsTF3Bt: fontname = new_typefaces[2].fontnames[0]; break;
    default: fontname = ""; break;
d4130 1
a4130 1
  fontmenu_set_font(0, fontmenu_id, fontname);
d4132 2
a4133 6
  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     fontmenu_id,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));
d4135 11
a4145 5
  e = event_register_toolbox_handler(fontmenu_id, FontMenu_HasBeenHidden, choices_font_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}

  e = event_register_toolbox_handler(fontmenu_id, FontMenu_Selection, choices_font_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
d4151 3
a4153 1
/* choices_font_closed_handler()                              */
d4155 1
a4155 2
/* Called when the font menu is closed deregisters all events */
/* attached to it and deletes the menu object.                */
d4158 7
a4164 1
static int choices_font_closed_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4166 41
a4206 1
  _kernel_oserror *e;
d4208 10
a4217 2
  e = event_register_toolbox_handler(idb->self_id, FontMenu_HasBeenHidden, choices_font_closed_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
d4219 7
a4225 2
  e = event_register_toolbox_handler(idb->self_id, FontMenu_Selection, choices_font_selected_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
d4227 9
a4235 2
  e = toolbox_delete_object(0, idb->self_id);
  if (e) {show_error_ret(e); return 1;}
d4237 10
a4246 1
  dprintf(("Choi", "choices_font_closed_handler: FontMenu deleted\n"));
d4248 1
a4248 2
  return 1;
}
d4269 2
a4270 2
  /* Assume that the F field will be found because the fontmenu */
  /* returns the font in the correct format.                    */
d4319 1
a4319 1
/* choices_set_fonts_greyed()                                 */
d4321 4
a4324 7
/* Sets the font name and font size gadgets to                */
/* greyed/ungreyed.                                           */
/*                                                            */
/* Parameters: ObjectId of the window which contains the      */
/*             icons.                                         */
/*                                                            */
/*             0 to ungrey, any other value to to grey.       */
d4327 1
a4327 1
static void choices_set_fonts_greyed(ObjectId window, int state)
d4329 1
a4329 16
  set_gadget_state(window, CD_FontsTF1Labl,     !!state);
  set_gadget_state(window, CD_FontsTF1Disp,     !!state);
  set_gadget_state(window, CD_FontsTF1Bt,       !!state);
  set_gadget_state(window, CD_FontsTF2Labl,     !!state);
  set_gadget_state(window, CD_FontsTF2Disp,     !!state);
  set_gadget_state(window, CD_FontsTF2Bt,       !!state);
  set_gadget_state(window, CD_FontsTF3Labl,     !!state);
  set_gadget_state(window, CD_FontsTF3Disp,     !!state);
  set_gadget_state(window, CD_FontsTF3Bt,       !!state);
  set_gadget_state(window, CD_FontsSize,        !!state);
  set_gadget_state(window, CD_FontsSzLabl1,     !!state);
  set_gadget_state(window, CD_FontsSzLabl2,     !!state);
  set_gadget_state(window, CD_FontsAspect,      !!state);
  set_gadget_state(window, CD_FontsAspectLabl1, !!state);
  set_gadget_state(window, CD_FontsAspectLabl2, !!state);
}
d4331 12
a4342 6
/**************************************************************/
/* choices_set_plugin_field()                                 */
/*                                                            */
/* Sets the plugin field appropriately to reflect the current */
/* state of new_choices->plugin_control                       */
/**************************************************************/
d4344 1
a4344 5
static _kernel_oserror * choices_set_plugin_field(void)
{
  _kernel_oserror * e;
  ObjectId          destwind;
  char            * tempstring;
d4346 1
a4346 1
  dprintf(("Choi", "choices_set_plugin_field: Called\n"));
d4348 1
a4348 1
  /* Find which window the plugin display is in */
d4350 1
a4350 34
  destwind = choices_find_component(CD_ObjPlugDisp);
  if (!destwind) return NULL;

  RetError(choices_get_menu_entry_text("ChPlugin", new_choices->plugin_control, &tempstring));

  e = choices_displayfield_set_value(0, destwind, CD_ObjPlugDisp, tempstring);

  free(tempstring);

  return NULL;
}

/**************************************************************/
/* choices_plug_m_click_handler()                             */
/*                                                            */
/* Called when there is a selection in the plugin menu. Sets  */
/* the selected menu item to be ticked, unticks the           */
/* previously ticked entry sets appropriate new_choices field */
/* and updates the display field of the component with        */
/* component number 1 less than the menus parent.             */
/**************************************************************/

static int choices_plug_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  if (plug_ticked != idb->self_component)
  {
    if (plug_ticked != -1) menu_set_tick(0, idb->self_id, plug_ticked, 0);
    menu_set_tick(0, idb->self_id, idb->self_component, 1);
    plug_ticked = idb->self_component;
  }

  new_choices->plugin_control = idb->self_component;

  choices_set_plugin_field();
d4356 1
a4356 1
/* choices_plug_m_button_handler()                            */
d4358 2
a4359 2
/* Opens the save menu with a value appropriate to either the */
/* hotlist or history.                                        */
d4362 1
a4362 1
static int choices_plug_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4364 1
a4364 6
  _kernel_oserror         * e;
  int                       position[2];
  BBox                      box;
  WimpGetWindowStateBlock   state;
  ObjectId                  display;
  int                       new_tick;
d4366 2
a4367 6
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4369 2
a4370 6
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4372 2
a4373 6
  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4375 1
a4375 27
  /* Set open coordinates of display menu to top left of display button */

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

  e = toolbox_create_object(0, "ChPlugin", &display);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  new_tick = new_choices->plugin_control;

  if (plug_ticked != new_tick)
  {
    if (plug_ticked != -1) menu_set_tick(0, display, plug_ticked, 0);
    menu_set_tick(0, display, new_tick, 1);
    plug_ticked = new_tick;
  }

  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     display,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));
d4381 1
a4381 1
/* choices_history_radio_handler()                            */
d4383 2
a4384 2
/* Handles radio button state changes. Swaps between page and */
/* image history settings.                                    */
d4387 1
a4387 1
static int choices_history_radio_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4389 1
a4389 2
  int state, temp;
  ObjectId window;
d4391 2
a4392 1
  radiobutton_get_state(0, idb->self_id, idb->self_component, &state, NULL);
d4394 2
a4395 1
  /* Is this a radiobutton selected event? */
d4397 2
a4398 16
  if (state)
  {
    if (expiry_age_greyed)
    {
      if (history_radio) new_choices->image_expiry_age = 0;
      else               new_choices->expiry_age = 0;
    }
    else
    {
      if ((window = choices_find_component(CD_HiExpiryAge))    != 0)
      {
        numberrange_get_value(0, window, CD_HiExpiryAge,  &temp);
        if (history_radio) new_choices->image_expiry_age = choices_typed_time_to_seconds(temp, history_expiry_units);
        else               new_choices->expiry_age = choices_typed_time_to_seconds(temp, history_expiry_units);
      }
    }
d4400 1
a4400 30
    if (max_size_greyed)
    {
      if (history_radio) new_choices->image_max_size = 0;
      else               new_choices->max_size = 0;
    }
    else
    {
      if ((window = choices_find_component(CD_HiMaxSize))      != 0)
      {
        numberrange_get_value(0, window, CD_HiMaxSize,    &temp);
        if (history_radio) new_choices->image_max_size = temp * 1024;
        else               new_choices->max_size = temp * 1024;
      }
    }

    switch(idb->self_component)
    {
      case CD_HiRadPage:
      history_radio = 0;
      if ((window = choices_find_component(CD_HiExpiryAge))    != 0) choices_set_expiry_age(window);
      if ((window = choices_find_component(CD_HiMaxSize))      != 0) choices_set_max_size(window);
      break;

      case CD_HiRadImage:
      history_radio = 1;
      if ((window = choices_find_component(CD_HiExpiryAge))    != 0) choices_set_expiry_age(window);
      if ((window = choices_find_component(CD_HiMaxSize))      != 0) choices_set_max_size(window);
      break;
    }
  }
d4406 1
a4406 1
/* choices_uri_m_button_handler()                             */
d4408 2
a4409 1
/* Handles clicks on the URI Handler menu button.             */
d4412 1
a4412 1
static int choices_uri_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4414 5
a4418 5
  WimpGetWindowStateBlock   state;
  _kernel_oserror         * e;
  BBox                      box;
  int                       position[2];
  ObjectId                  display;
d4420 1
a4420 6
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4422 2
a4423 49
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  /* Set open coordinates of display menu to top left of display button */

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

  e = toolbox_create_object(0, "ChURI", &display);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  if (urih_ticked != NULL_ComponentId) menu_set_tick(0, display, urih_ticked, 0);

  switch(new_choices->uri_usage)
  {
    case Choices_URI_Never:                 urih_ticked = CD_URINever;        break;
    case Choices_URI_RequestsOnly:          urih_ticked = CD_URIProcOnly;     break;
    case Choices_URI_BroadcastUnknowns:     urih_ticked = CD_URIBroadUk;      break;
    case Choices_URI_UnknownsAndRequests:   urih_ticked = CD_URIProcAndBroad; break;
    case Choices_URI_EverythingAndRequests: urih_ticked = CD_URIProcAndEvery; break;
    default:                                urih_ticked = CD_URIProcAndBroad; break;
  }

  menu_set_tick(0, display, urih_ticked, 1);

  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     display,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));

  return 1;
}
d4425 1
a4425 6
/**************************************************************/
/* choices_set_uri_field()                                    */
/*                                                            */
/* Sets the URI Handler field appropriately to reflect the    */
/* current state of 'new_choices->uri_usage'.                 */
/**************************************************************/
d4427 3
a4429 5
static _kernel_oserror * choices_set_uri_field(void)
{
  _kernel_oserror * e;
  ObjectId          destwind;
  char            * tempstring;
d4431 3
a4433 1
  dprintf(("Choi", "choices_set_uri_field: Called\n"));
d4435 1
a4435 1
  /* Find which window the URI display is in */
d4437 8
a4444 2
  destwind = choices_find_component(CD_URIHandlerDisp);
  if (!destwind) return NULL;
d4446 1
a4446 1
  RetError(choices_get_menu_entry_text("ChURI", new_choices->uri_usage, &tempstring));
d4448 11
a4458 1
  e = choices_displayfield_set_value(0, destwind, CD_URIHandlerDisp, tempstring);
d4460 5
a4464 1
  free(tempstring);
d4466 1
a4466 1
  return e;
d4470 1
a4470 1
/* choices_uri_m_click_handler()                              */
d4472 6
a4477 1
/* Handles clicks on URI Handler menu entries.                */
d4480 5
a4484 1
static int choices_uri_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4486 5
a4490 6
  if (urih_ticked != idb->self_component)
  {
    if (urih_ticked != NULL_ComponentId) menu_set_tick(0, idb->self_id, urih_ticked, 0);
    menu_set_tick(0, idb->self_id, idb->self_component, 1);
    urih_ticked = idb->self_component;
  }
d4492 1
a4492 1
  switch (urih_ticked)
d4494 2
a4495 5
    case CD_URINever:        new_choices->uri_usage = Choices_URI_Never;                 break;
    case CD_URIProcOnly:     new_choices->uri_usage = Choices_URI_RequestsOnly;          break;
    case CD_URIBroadUk:      new_choices->uri_usage = Choices_URI_BroadcastUnknowns;     break;
    case CD_URIProcAndBroad: new_choices->uri_usage = Choices_URI_UnknownsAndRequests;   break;
    case CD_URIProcAndEvery: new_choices->uri_usage = Choices_URI_EverythingAndRequests; break;
d4498 1
a4498 1
  choices_set_uri_field();
d4500 3
a4502 1
  return 1;
d4506 4
a4509 1
/* choices_cookie_m_button_handler()                          */
d4511 3
a4513 1
/* Handles clicks on the Cookie menu button.                  */
d4516 5
a4520 1
static int choices_cookie_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4522 1
a4522 5
  WimpGetWindowStateBlock   state;
  _kernel_oserror         * e;
  BBox                      box;
  int                       position[2];
  ObjectId                  display;
d4524 1
a4524 6
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4526 1
a4526 6
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4528 1
a4528 2
  e = wimp_get_window_state(&state);
  if (e)
d4530 3
a4532 2
    show_error_ret(e);
    return 1;
d4535 1
a4535 1
  /* Set open coordinates of display menu to top left of display button */
d4537 4
a4540 2
  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);
d4542 10
a4551 6
  e = toolbox_create_object(0, "ChCookies", &display);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4553 7
a4559 1
  if (cook_ticked != NULL_ComponentId) menu_set_tick(0, display, cook_ticked, 0);
d4561 5
a4565 7
  switch(new_choices->cookies)
  {
    case Choices_Cookies_Reject: cook_ticked = CD_CookieReject; break;
    case Choices_Cookies_Prompt: cook_ticked = CD_CookiePrompt; break;
    case Choices_Cookies_Accept: cook_ticked = CD_CookieAccept; break;
    default:                     cook_ticked = CD_CookieAccept; break;
  }
d4567 10
a4576 1
  menu_set_tick(0, display, cook_ticked, 1);
d4578 7
a4584 6
  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     display,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));
d4586 4
a4589 1
  return 1;
d4595 6
a4600 2
/* Sets the Cookie field appropriately to reflect the current */
/* state of 'new_choices->cookies'.                           */
d4603 5
a4607 1
static _kernel_oserror * choices_set_cookie_field(void)
a4608 4
  _kernel_oserror * e;
  ObjectId          destwind;
  char            * tempstring;

d4611 5
a4615 1
  /* Find which window the cookie display is in */
d4617 10
a4626 2
  destwind = choices_find_component(CD_CookieDisp);
  if (!destwind) return NULL;
d4628 7
a4634 3
  RetError(choices_get_menu_entry_text("ChCookies", new_choices->cookies, &tempstring));

  e = choices_displayfield_set_value(0, destwind, CD_CookieDisp, tempstring);
d4636 4
a4639 3
  free(tempstring);

  return e;
d4643 6
a4648 1
/* choices_cookie_m_click_handler()                           */
d4650 1
a4650 1
/* Handles clicks on Cookie menu entries.                     */
d4653 5
a4657 1
static int choices_cookie_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4659 1
a4659 13
  if (cook_ticked != idb->self_component)
  {
    if (cook_ticked != NULL_ComponentId) menu_set_tick(0, idb->self_id, cook_ticked, 0);
    menu_set_tick(0, idb->self_id, idb->self_component, 1);
    cook_ticked = idb->self_component;
  }

  switch (cook_ticked)
  {
    case CD_CookieReject: new_choices->cookies = Choices_Cookies_Reject; break;
    case CD_CookiePrompt: new_choices->cookies = Choices_Cookies_Prompt; break;
    case CD_CookieAccept: new_choices->cookies = Choices_Cookies_Accept; break;
  }
d4661 4
a4664 3
  choices_set_cookie_field();

  return 1;
d4668 4
a4671 1
/* choices_jpeg_m_button_handler()                            */
d4673 3
a4675 1
/* Handles clicks on the JPEG menu button.                    */
d4678 5
a4682 1
static int choices_jpeg_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4684 1
a4684 5
  WimpGetWindowStateBlock   state;
  _kernel_oserror         * e;
  BBox                      box;
  int                       position[2];
  ObjectId                  display;
d4686 1
a4686 6
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4688 1
a4688 6
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4690 1
a4690 2
  e = wimp_get_window_state(&state);
  if (e)
d4692 2
a4693 2
    show_error_ret(e);
    return 1;
d4696 1
a4696 1
  /* Set open coordinates of display menu to top left of display button */
d4698 4
a4701 2
  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);
d4703 10
a4712 6
  e = toolbox_create_object(0, "ChJPEG", &display);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d4714 7
a4720 18
  if (jpeg_ticked != NULL_ComponentId) menu_set_tick(0, display, jpeg_ticked, 0);

  switch(new_choices->support_pjpeg)
  {
    case Choices_SupportPJPEG_OS:       jpeg_ticked = CD_JPEGOS;       break;
    case Choices_SupportPJPEG_Both:     jpeg_ticked = CD_JPEGBoth;     break;
    case Choices_SupportPJPEG_Internal: jpeg_ticked = CD_JPEGInternal; break;
    default:                            jpeg_ticked = CD_JPEGBoth;     break;
  }

  menu_set_tick(0, display, jpeg_ticked, 1);

  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     display,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));
d4722 4
a4725 1
  return 1;
d4729 4
a4732 1
/* choices_set_jpeg_field()                                   */
d4734 1
a4734 2
/* Sets the JPEG field appropriately to reflect current state */
/* of 'new_choices->support_pjpeg'.                           */
d4737 5
a4741 1
static _kernel_oserror * choices_set_jpeg_field(void)
d4743 9
a4751 3
  _kernel_oserror * e;
  ObjectId          destwind;
  char            * tempstring;
d4753 10
a4762 1
  dprintf(("Choi", "choices_set_jpeg_field: Called\n"));
d4764 7
a4770 1
  /* Find which window the JPEG display is in */
d4772 5
a4776 2
  destwind = choices_find_component(CD_JPEGDisp);
  if (!destwind) return NULL;
d4778 10
a4787 1
  RetError(choices_get_menu_entry_text("ChJPEG", new_choices->support_pjpeg, &tempstring));
d4789 7
a4795 1
  e = choices_displayfield_set_value(0, destwind, CD_JPEGDisp, tempstring);
d4797 5
a4801 1
  free(tempstring);
d4803 1
a4803 2
  return e;
}
d4806 4
a4809 1
/* choices_jpeg_m_click_handler()                             */
d4811 3
a4813 1
/* Handles clicks on JPEG menu entries.                       */
d4816 1
a4816 1
static int choices_jpeg_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4818 4
a4821 13
  if (jpeg_ticked != idb->self_component)
  {
    if (jpeg_ticked != NULL_ComponentId) menu_set_tick(0, idb->self_id, jpeg_ticked, 0);
    menu_set_tick(0, idb->self_id, idb->self_component, 1);
    jpeg_ticked = idb->self_component;
  }

  switch (jpeg_ticked)
  {
    case CD_JPEGOS:       new_choices->support_pjpeg = Choices_SupportPJPEG_OS;       break;
    case CD_JPEGBoth:     new_choices->support_pjpeg = Choices_SupportPJPEG_Both;     break;
    case CD_JPEGInternal: new_choices->support_pjpeg = Choices_SupportPJPEG_Internal; break;
  }
d4823 1
a4823 3
  choices_set_jpeg_field();

  return 1;
d4827 5
a4831 1
/* choices_referer_m_button_handler()                         */
d4833 3
a4835 1
/* Handles clicks on the Referer menu button.                 */
d4838 1
a4838 1
static int choices_referer_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4840 1
a4840 22
  WimpGetWindowStateBlock   state;
  _kernel_oserror         * e;
  BBox                      box;
  int                       position[2];
  ObjectId                  display;

  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }

  e = wimp_get_window_state(&state);
  if (e)
d4842 6
a4847 2
    show_error_ret(e);
    return 1;
d4849 1
d4851 11
a4861 1
  /* Set open coordinates of display menu to top left of display button */
d4863 3
a4865 5
  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

  e = toolbox_create_object(0, "ChReferer", &display);
  if (e)
d4867 6
a4872 2
    show_error_ret(e);
    return 1;
d4874 1
d4876 10
a4885 1
  if (refe_ticked != NULL_ComponentId) menu_set_tick(0, display, refe_ticked, 0);
d4887 3
a4889 1
  switch(new_choices->send_referer)
d4891 6
a4896 4
    case Choices_SendReferer_Never:    refe_ticked = CD_RefererNever;     break;
    case Choices_SendReferer_Always:   refe_ticked = CD_RefererAlways;   break;
    case Choices_SendReferer_WhenHTTP: refe_ticked = CD_RefererWhenHTTP; break;
    default:                           refe_ticked = CD_RefererWhenHTTP; break;
a4897 11

  menu_set_tick(0, display, refe_ticked, 1);

  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     display,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));

  return 1;
d4901 8
a4908 1
/* choices_set_referer_field()                                */
d4910 1
a4910 2
/* Sets the Referer field appropriately to reflect current    */
/* state of 'new_choices->send_referer'.                      */
d4913 5
a4917 1
static _kernel_oserror * choices_set_referer_field(void)
d4919 2
a4920 10
  _kernel_oserror * e;
  ObjectId          destwind;
  char            * tempstring;

  dprintf(("Choi", "choices_set_referer_field: Called\n"));

  /* Find which window the referer display is in */

  destwind = choices_find_component(CD_RefererDisp);
  if (!destwind) return NULL;
d4922 1
a4922 19
  RetError(choices_get_menu_entry_text("ChReferer", new_choices->send_referer, &tempstring));

  e = choices_displayfield_set_value(0, destwind, CD_RefererDisp, tempstring);

  free(tempstring);

  return e;
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* choices_win_open_m_button_handler()                        */
  /*                                                            */
  /* Handles clicks on the Window Open menu button (control of  */
  /* scripts opening windows).                                  */
  /**************************************************************/

  static int choices_win_open_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4924 1
a4924 5
    WimpGetWindowStateBlock   state;
    _kernel_oserror         * e;
    BBox                      box;
    int                       position[2];
    ObjectId                  display;
d4926 1
a4926 2
    e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
    if (e)
d4928 1
a4928 2
      show_error_ret(e);
      return 1;
d4931 2
a4932 6
    e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
    if (e)
    {
      show_error_ret(e);
      return 1;
    }
d4934 2
a4935 6
    e = wimp_get_window_state(&state);
    if (e)
    {
      show_error_ret(e);
      return 1;
    }
d4937 7
a4943 1
    /* Set open coordinates of display menu to top left of display button */
d4945 8
a4952 2
    position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
    position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);
d4954 2
a4955 6
    e = toolbox_create_object(0, "ChWinOpen", &display);
    if (e)
    {
      show_error_ret(e);
      return 1;
    }
d4957 8
a4964 1
    if (wino_ticked != NULL_ComponentId) menu_set_tick(0, display, wino_ticked, 0);
d4966 7
a4972 7
    switch(new_choices->js_window_open)
    {
      case Choices_JSWindowOpen_Replace:  wino_ticked = CD_WinOpenReplace;  break;
      case Choices_JSWindowOpen_Query:    wino_ticked = CD_WinOpenQuery;    break;
      case Choices_JSWindowOpen_Suppress: wino_ticked = CD_WinOpenSuppress; break;
      default:                            wino_ticked = CD_WinOpenAllow;    break;
    }
d4974 4
a4977 1
    menu_set_tick(0, display, wino_ticked, 1);
d4979 3
a4981 6
    show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                       display,
                                       Toolbox_ShowObject_TopLeft,
                                       position,
                                       idb->self_id,
                                       idb->self_component));
d4983 3
a4985 1
    return 1;
d4987 1
a4987 9

  /**************************************************************/
  /* choices_win_open_m_click_handler()                         */
  /*                                                            */
  /* Handles clicks on Open (control of scripts opening         */
  /* windows) menu entries.                                     */
  /**************************************************************/

  static int choices_win_open_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d4989 1
a4989 6
    if (wino_ticked != idb->self_component)
    {
      if (wino_ticked != NULL_ComponentId) menu_set_tick(0, idb->self_id, wino_ticked, 0);
      menu_set_tick(0, idb->self_id, idb->self_component, 1);
      wino_ticked = idb->self_component;
    }
d4991 3
a4993 11
    switch (refe_ticked)
    {
      case CD_WinOpenAllow:    new_choices->js_window_open = Choices_JSWindowOpen_Allow;    break;
      case CD_WinOpenReplace:  new_choices->js_window_open = Choices_JSWindowOpen_Replace;  break;
      case CD_WinOpenQuery:    new_choices->js_window_open = Choices_JSWindowOpen_Query;    break;
      case CD_WinOpenSuppress: new_choices->js_window_open = Choices_JSWindowOpen_Suppress; break;
    }

    choices_set_win_open_field();

    return 1;
d4995 1
a4995 9

  /**************************************************************/
  /* choices_set_win_open_field()                               */
  /*                                                            */
  /* Sets the Open field appropriately to reflect current state */
  /* of 'new_choices->js_window_open'.                          */
  /**************************************************************/

  static _kernel_oserror * choices_set_win_open_field(void)
d4997 1
a4997 12
    _kernel_oserror * e;
    ObjectId          destwind;
    char            * tempstring;

    dprintf(("Choi", "choices_set_win_open_field: Called\n"));

    /* Find which window the win_open display is in */

    destwind = choices_find_component(CD_JSWinOpenDisp);
    if (!destwind) return NULL;

    RetError(choices_get_menu_entry_text("ChWinOpen", new_choices->js_window_open, &tempstring));
d4999 3
a5001 5
    e = choices_displayfield_set_value(0, destwind, CD_JSWinOpenDisp, tempstring);

    free(tempstring);

    return e;
d5004 1
a5004 6
  /**************************************************************/
  /* choices_win_close_m_button_handler()                       */
  /*                                                            */
  /* Handles clicks on the Window Close menu button (control of */
  /* scripts closing windows).                                  */
  /**************************************************************/
d5006 1
a5006 1
  static int choices_win_close_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d5008 4
a5011 5
    WimpGetWindowStateBlock   state;
    _kernel_oserror         * e;
    BBox                      box;
    int                       position[2];
    ObjectId                  display;
d5013 5
a5017 5
    e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
    if (e)
    {
      show_error_ret(e);
      return 1;
d5020 1
a5020 2
    e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
    if (e)
d5022 2
a5023 3
      show_error_ret(e);
      return 1;
    }
d5025 5
a5029 5
    e = wimp_get_window_state(&state);
    if (e)
    {
      show_error_ret(e);
      return 1;
d5032 1
a5032 7
    /* Set close coordinates of display menu to top left of display button */

    position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
    position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

    e = toolbox_create_object(0, "ChWinClose", &display);
    if (e)
d5034 2
a5035 5
      show_error_ret(e);
      return 1;
    }

    if (winc_ticked != NULL_ComponentId) menu_set_tick(0, display, winc_ticked, 0);
d5037 5
a5041 6
    switch(new_choices->js_window_close)
    {
      case Choices_JSWindowClose_Always:   winc_ticked = CD_WinCloseAlways;    break;
      case Choices_JSWindowClose_Query:    winc_ticked = CD_WinCloseQuery;     break;
      case Choices_JSWindowClose_Suppress: winc_ticked = CD_WinCloseSuppress;  break;
      default:                             winc_ticked = CD_WinCloseSometimes; break;
d5043 1
d5045 1
a5045 1
    menu_set_tick(0, display, winc_ticked, 1);
d5047 2
a5048 6
    show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                       display,
                                       Toolbox_ShowObject_TopLeft,
                                       position,
                                       idb->self_id,
                                       idb->self_component));
d5050 1
a5050 9
    return 1;
  }

  /**************************************************************/
  /* choices_win_close_m_click_handler()                        */
  /*                                                            */
  /* Handles clicks on Close (control of scripts closing        */
  /* windows) menu entries.                                     */
  /**************************************************************/
d5052 8
a5059 8
  static int choices_win_close_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
  {
    if (winc_ticked != idb->self_component)
    {
      if (winc_ticked != NULL_ComponentId) menu_set_tick(0, idb->self_id, winc_ticked, 0);
      menu_set_tick(0, idb->self_id, idb->self_component, 1);
      winc_ticked = idb->self_component;
    }
d5061 1
a5061 7
    switch (refe_ticked)
    {
      case CD_WinCloseAlways:    new_choices->js_window_close = Choices_JSWindowClose_Always;    break;
      case CD_WinCloseSometimes: new_choices->js_window_close = Choices_JSWindowClose_Sometimes; break;
      case CD_WinCloseQuery:     new_choices->js_window_close = Choices_JSWindowClose_Query;     break;
      case CD_WinCloseSuppress:  new_choices->js_window_close = Choices_JSWindowClose_Suppress;  break;
    }
d5063 1
a5063 1
    choices_set_win_close_field();
d5065 2
a5066 2
    return 1;
  }
d5068 1
a5068 6
  /**************************************************************/
  /* choices_set_win_close_field()                              */
  /*                                                            */
  /* Sets the Close field appropriately to reflect current      */
  /* state of 'new_choices->js_window_close'.                   */
  /**************************************************************/
d5070 8
a5077 5
  static _kernel_oserror * choices_set_win_close_field(void)
  {
    _kernel_oserror * e;
    ObjectId          destwind;
    char            * tempstring;
d5079 1
a5079 1
    dprintf(("Choi", "choices_set_win_close_field: Called\n"));
d5081 1
a5081 1
    /* Find which window the win_close display is in */
d5083 2
a5084 2
    destwind = choices_find_component(CD_JSWinCloseDisp);
    if (!destwind) return NULL;
d5086 1
a5086 1
    RetError(choices_get_menu_entry_text("ChWinClose", new_choices->js_window_close, &tempstring));
d5088 10
a5097 1
    e = choices_displayfield_set_value(0, destwind, CD_JSWinCloseDisp, tempstring);
d5099 1
a5099 1
    free(tempstring);
d5101 1
a5101 2
    return e;
  }
d5103 2
a5104 1
#endif
d5107 4
a5110 1
/* choices_refer_m_click_handler()                            */
d5112 9
a5120 1
/* Handles clicks on Referer menu entries.                    */
d5123 1
a5123 1
static int choices_referer_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d5125 3
a5127 6
  if (refe_ticked != idb->self_component)
  {
    if (refe_ticked != NULL_ComponentId) menu_set_tick(0, idb->self_id, refe_ticked, 0);
    menu_set_tick(0, idb->self_id, idb->self_component, 1);
    refe_ticked = idb->self_component;
  }
d5129 8
a5136 6
  switch (refe_ticked)
  {
    case CD_RefererNever:    new_choices->send_referer = Choices_SendReferer_Never;    break;
    case CD_RefererAlways:   new_choices->send_referer = Choices_SendReferer_Always;   break;
    case CD_RefererWhenHTTP: new_choices->send_referer = Choices_SendReferer_WhenHTTP; break;
  }
d5138 10
a5147 1
  choices_set_referer_field();
d5149 1
a5149 1
  return 1;
d5155 1
a5155 1
/* Sets up the expiry age fields and greys/ ungreys them as   */
d5163 4
a5166 4
  int temp;
  int rangetop;
  int time_scale;
  int age;
d5172 1
d5174 1
a5174 2
    time_scale = CD_TimeDays;
    rangetop  = 7;
d5184 1
a5184 1
  choices_set_expiry_age_greyed(window, !age);
d5188 1
a5188 1
  choices_set_timetype_field(time_scale, CD_HiAgeTypeDisp);
d5200 1
a5200 4
/* Parameters: ObjectId of the window which contains the      */
/*             icons.                                         */
/*                                                            */
/*             0 to ungrey, any other value to to grey.       */
d5203 1
a5203 1
static void choices_set_expiry_age_greyed(ObjectId window, int state)
d5205 9
a5213 4
  set_gadget_state(window, CD_HiExpiryAgeLabl, !!state);
  set_gadget_state(window, CD_HiExpiryAge,     !!state);
  set_gadget_state(window, CD_HiAgeTypeDisp,   !!state);
  set_gadget_state(window, CD_HiAgeTypeBt,     !!state);
d5219 1
a5219 1
/* Sets up the image expiry age fields and greys /ungreys     */
d5227 3
a5229 3
  int temp;
  int rangetop;
  int time_scale;
d5233 1
d5235 1
a5235 2
    time_scale = CD_TimeDays;
    rangetop  = 7;
d5245 1
a5245 1
  choices_set_im_expiry_age_greyed(window, !new_choices->image_expiry_age);
d5247 1
d5249 1
a5249 1
  choices_set_timetype_field(time_scale, CD_HiImAgeTypeDisp);
d5261 1
a5261 4
/* Parameters: ObjectId of the window which contains the      */
/*             icons.                                         */
/*                                                            */
/*             0 to ungrey, any other value to to grey.       */
d5264 1
a5264 1
static void choices_set_im_expiry_age_greyed(ObjectId window, int state)
d5266 9
a5274 4
  set_gadget_state(window, CD_HiImExpiryAgeLabl, !!state);
  set_gadget_state(window, CD_HiImExpiryAge,     !!state);
  set_gadget_state(window, CD_HiImAgeTypeDisp,   !!state);
  set_gadget_state(window, CD_HiImAgeTypeBt,     !!state);
d5344 86
a5429 1
/* choices_set_im_max_size_greyed()                           */
d5431 3
a5433 1
/* Sets the image max size gadgets to greyed/ ungreyed.       */
d5435 1
a5435 2
/* Parameters: ObjectId of the window which contains the      */
/*             icons.                                         */
d5437 2
a5438 1
/*             0 to ungrey, any other value to to grey.       */
d5441 1
a5441 1
static void choices_set_im_max_size_greyed(ObjectId window, int state)
d5443 21
a5463 4
  set_gadget_state(window, CD_HiImMaxSizeLabl1, !!state);
  set_gadget_state(window, CD_HiImMaxSizeLabl2, !!state);
  set_gadget_state(window, CD_HiImMaxSize,      !!state);
}
d5465 3
a5467 8
/**************************************************************/
/* choices_set_timetype_field()                               */
/*                                                            */
/* Sets the time field appropriately to reflect the passed    */
/* state. Also ticks the appropriate item in the menu.        */
/*                                                            */
/* Parameters: timetype - see defined values in choices.h     */
/**************************************************************/
d5469 3
a5471 6
static _kernel_oserror * choices_set_timetype_field(int timetype, ComponentId comp)
{
  _kernel_oserror * e;
  ObjectId          destwind;
  ObjectId          menu_id;
  char            * tempstring;
d5473 18
a5490 1
  dprintf(("Choi", "choices_set_timetype_field: Called\n"));
d5492 5
a5496 1
  /* Find which window the time display is in */
d5498 1
a5498 2
  destwind = choices_find_component(comp);
  if (!destwind) return NULL;
d5500 2
a5501 1
  RetError(toolbox_create_object(0, "ChTime", &menu_id));
d5503 2
a5504 1
  RetError(choices_get_menu_entry_text("ChTime", timetype, &tempstring));
d5506 2
a5507 1
  RetError(choices_set_timetype_tick(timetype));
d5509 2
a5510 1
  e = choices_displayfield_set_value(0, destwind, comp, tempstring);
d5512 1
a5512 1
  free(tempstring);
d5514 1
a5514 1
  return NULL;
d5518 1
a5518 1
/* choices_set_timetype_tick()                                */
d5520 3
a5522 1
/* Ticks the appropriate item in the ChTime menu              */
d5524 1
a5524 1
/* Parameters: timetype - see defined values in choices.h     */
d5527 7
a5533 1
_kernel_oserror * choices_set_timetype_tick(int timetype)
d5535 8
a5542 1
  ObjectId menu_id;
d5544 1
a5544 1
  RetError(toolbox_create_object(0, "ChTime", &menu_id));
d5546 1
a5546 1
  if (time_ticked != -1)
d5548 1
a5548 1
    RetError(menu_set_tick(0, menu_id, time_ticked, 0));
d5551 1
a5551 1
  RetError(menu_set_tick(0, menu_id, timetype, 1));
d5553 1
a5553 3
  time_ticked = timetype;

  return NULL;
d5557 5
a5561 1
/* choices_timetype_m_button_handler()                        */
d5563 1
a5563 2
/* Displays the time units menu when the appropriate          */
/* toolaction button is pressed.                              */
d5566 7
a5572 1
static int choices_timetype_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d5574 3
a5576 5
  _kernel_oserror         * e;
  int                       position[2];
  BBox                      box;
  WimpGetWindowStateBlock   state;
  ObjectId                  display;
d5578 1
a5578 6
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d5580 2
a5581 6
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d5583 1
a5583 6
  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d5585 1
a5585 6
  /* Set open coordinates of display menu to top left of display button */

  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);

  switch(idb->self_component)
d5587 1
a5587 7
    case CD_HiAgeTypeBt:
    choices_set_timetype_tick(history_expiry_units);
    break;

    case CD_HiImAgeTypeBt:
    choices_set_timetype_tick(image_expiry_units);
    break;
d5590 1
a5590 6
  e = toolbox_create_object(0, "ChTime", &display);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d5592 1
a5592 8
  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     display,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));

  return 1;
d5596 6
a5601 1
/* choices_timetype_m_click_handler()                         */
d5603 9
a5611 3
/* Handles clicks in the time units menu. Translates the      */
/* current expiry time to the new units and places the name   */
/* of the units in the appropriate display field.             */
d5614 7
a5620 1
static int choices_timetype_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d5622 32
a5653 2
  ObjectId window;
  int temptime;
d5655 1
a5655 1
  window = idb->parent_id;
d5657 1
a5657 1
  switch(idb->parent_component)
d5659 5
a5663 3
    case CD_HiAgeTypeBt:
    {
      numberrange_get_value(0, window, CD_HiExpiryAge, &temptime);
d5665 1
a5665 1
      temptime = choices_typed_time_to_seconds(temptime, history_expiry_units);
d5667 8
a5674 1
      choices_set_timetype_field(idb->self_component, CD_HiAgeTypeDisp);
d5676 3
a5678 1
      history_expiry_units = idb->self_component;
d5680 3
a5682 2
      numberrange_set_value(0, window, CD_HiExpiryAge, choices_seconds_to_typed_time(temptime, history_expiry_units));
      numberrange_set_bounds(15, window, CD_HiExpiryAge, 1, choices_get_range_of_typed_time(history_expiry_units), 1, 0);
d5684 1
a5684 2
      break;
    }
d5686 1
a5686 1
    case CD_HiImAgeTypeBt:
d5688 1
a5688 1
      numberrange_get_value(0, window, CD_HiImExpiryAge, &temptime);
d5690 11
a5700 1
      temptime = choices_typed_time_to_seconds(temptime, image_expiry_units);
d5702 1
a5702 1
      choices_set_timetype_field(idb->self_component, CD_HiImAgeTypeDisp);
d5704 1
a5704 1
      image_expiry_units = idb->self_component;
d5706 3
a5708 2
      numberrange_set_value(0, window, CD_HiImExpiryAge, choices_seconds_to_typed_time(temptime, image_expiry_units));
      numberrange_set_bounds(15, window, CD_HiImExpiryAge, 1, choices_get_range_of_typed_time(image_expiry_units), 1, 0);
d5710 8
a5717 1
      break;
d5721 2
a5722 1
  return 1;
d5726 1
a5726 1
/* choices_typed_time_to_seconds()                            */
d5728 2
a5729 6
/* Converts a time in the passed units to seconds.            */
/*                                                            */
/* Parameters: Time in passed units;                          */
/*                                                            */
/*             units which the time was passed as (defined in */
/*             choices.h);                                    */
d5731 1
a5731 1
/* Returns:    time in seconds.                               */
d5734 7
a5740 1
static int choices_typed_time_to_seconds(int time, int timetype)
d5742 3
a5744 10
  switch(timetype)
  {
    case CD_TimeMinutes: return time * 60;
    case CD_TimeHours:   return time * 60*60;
    case CD_TimeDays:    return time * 60*60*24;
    case CD_TimeWeeks:   return time * 60*60*24*7;
    case CD_TimeMonths:  return time * 60*60*24*7*4;
    default:             return 0;
  }
}
d5746 1
a5746 13
/**************************************************************/
/* choices_clip_to_min_max()                                  */
/*                                                            */
/* Clips a number to a minimum and maximum value              */
/*                                                            */
/* Parameters: initial value;                                 */
/*                                                            */
/*             minimum;                                       */
/*                                                            */
/*             maximum.                                       */
/*                                                            */
/* Returns:    clipped value.                                 */
/**************************************************************/
d5748 2
a5749 4
int choices_clip_to_min_max(int value, int min, int max)
{
  return value > max ? max : (value < min ? min : value);
}
d5751 1
a5751 12
/**************************************************************/
/* choices_seconds_to_typed_time()                            */
/*                                                            */
/* Converts a time in seconds to a time in the passed units.  */
/*                                                            */
/* Parameters: time in seconds;                               */
/*                                                            */
/*             the units to return time in as defined in      */
/*             choices.h;                                     */
/*                                                            */
/* Returns:    the time in the passed units.                  */
/**************************************************************/
d5753 1
a5753 3
static int choices_seconds_to_typed_time(int secs, int timetype)
{
  switch(timetype)
d5755 1
a5755 6
    case CD_TimeMinutes: return choices_clip_to_min_max(secs/(60),           1, 60);
    case CD_TimeHours:   return choices_clip_to_min_max(secs/(60*60),        1, 24);
    case CD_TimeDays:    return choices_clip_to_min_max(secs/(60*60*24),     1, 7);
    case CD_TimeWeeks:   return choices_clip_to_min_max(secs/(60*60*24*7),   1, 4);
    case CD_TimeMonths:  return choices_clip_to_min_max(secs/(60*60*24*7*4), 1, 12);
    default:             return 1;
a5756 13
}

/**************************************************************/
/* choices_return_appropriate_timetype()                      */
/*                                                            */
/* Given a time in seconds returns the most appropriate set   */
/* of units to display that time in.                          */
/*                                                            */
/* Parameters: time in seconds.                               */
/*                                                            */
/* Returns:    the type of the appropriate units as defined   */
/*             in choices.h                                   */
/**************************************************************/
d5758 1
a5758 6
static int choices_return_appropriate_timetype(int seconds)
{
  if (seconds <= 60*60)        return CD_TimeMinutes;
  if (seconds <= 60*60*24)     return CD_TimeHours;
  if (seconds <= 60*60*24*7)   return CD_TimeDays;
  if (seconds <= 60*60*24*7*4) return CD_TimeWeeks;
d5760 1
a5760 1
  return CD_TimeMonths;
d5764 1
a5764 1
/* choices_get_range_of_typed_time()                          */
d5766 2
a5767 4
/* Returns the max acceptable value of the passed time units  */
/* type.                                                      */
/*                                                            */
/* Parameters: the type of time units. (defined in choices.h) */
d5769 1
a5769 1
/* Returns:    the maximum acceptable value.                  */
d5772 7
a5778 1
static int choices_get_range_of_typed_time(int timetype)
d5780 6
a5785 1
  switch(timetype)
d5787 1
a5787 6
    case CD_TimeMinutes: return 60;
    case CD_TimeHours:   return 24;
    case CD_TimeDays:    return 7;
    case CD_TimeWeeks:   return 4;
    case CD_TimeMonths:  return 12;
    default:             return 0;
d5789 2
d5794 4
a5797 1
/* choices_set_tables_greyed()                                */
d5799 1
a5799 1
/* Sets the table border gadgets to greyed or ungreyed.       */
d5801 1
a5801 2
/* Parameters: Object ID of the window which contains the     */
/*             icons;                                         */
d5803 1
a5803 1
/*             0 to ungrey, any other value to to grey.       */
d5806 1
a5806 1
static void choices_set_tables_greyed(ObjectId window, int state)
d5808 8
a5815 7
  set_gadget_state(window, CD_TabInnerBordLabl, !!state);
  set_gadget_state(window, CD_TabInnerBordDisp, !!state);
  set_gadget_state(window, CD_TabInnerBordBt,   !!state);
  set_gadget_state(window, CD_TabOuterBordLabl, !!state);
  set_gadget_state(window, CD_TabOuterBordDisp, !!state);
  set_gadget_state(window, CD_TabOuterBordBt,   !!state);
  set_gadget_state(window, CD_MSIE4StyleTables, !!state);
d5819 11
a5829 1
/* choices_set_table_border_field()                           */
d5831 1
a5831 2
/* Sets the passed display display field appropriately to     */
/* reflect the passed state.                                  */
d5834 6
a5839 1
static _kernel_oserror * choices_set_table_border_field(ObjectId obj, ComponentId comp, int state)
d5841 2
a5842 2
  _kernel_oserror *e;
  char *tempstring;
d5844 1
a5844 1
  dprintf(("Choi", "choices_set_table_border_field: Called\n"));
d5846 1
a5846 1
  RetError(choices_get_menu_entry_text("ChTabBord", state, &tempstring));
d5848 2
a5849 1
  e = choices_displayfield_set_value(0, obj, comp, tempstring);
d5851 1
a5851 1
  free(tempstring);
d5853 1
a5853 1
  return e;
d5856 28
a5883 1
#ifdef JAVASCRIPT
d5885 1
a5885 11
  /**************************************************************/
  /* choices_set_js_watchdog_greyed()                           */
  /*                                                            */
  /* Sets the JS watchdog timeout gadgets to greyed or          */
  /* ungreyed.                                                  */
  /*                                                            */
  /* Parameters: Object ID of the window which contains the     */
  /*             icons;                                         */
  /*                                                            */
  /*             0 to ungrey, any other value to to grey.       */
  /**************************************************************/
d5887 6
a5892 6
  static void choices_set_js_watchdog_greyed(ObjectId window, int state)
  {
    set_gadget_state(window, CD_JSTimeoutLabl,  !!state);
    set_gadget_state(window, CD_JSTimeoutDisp,  !!state);
    set_gadget_state(window, CD_JSTimeoutLabl2, !!state);
  }
d5894 1
a5894 19
  /**************************************************************/
  /* choices_set_js_all_greyed()                                */
  /*                                                            */
  /* Sets all JS related gadgets, except "Support JavaScript",  */
  /* to greyed or ungreyed. Watchdog related stuff is set       */
  /* according to the value of new_choices->js_watchdog, so     */
  /* make sure this is valid before calling the function. This  */
  /* is handled as follows; if you ask for items to be greyed,  */
  /* the watchdog stuff will always be greyed too; if you ask   */
  /* for items to be ungreyed, the watchdog stuff will be only  */
  /* if new_choices->js_watchdog is set.                        */
  /*                                                            */
  /* Parameters: Object ID of the window which contains the     */
  /*             icons;                                         */
  /*                                                            */
  /*             0 to ungrey, any other value to to grey        */
  /*             (except for watchdog items, see details        */
  /*             above).                                        */
  /**************************************************************/
d5896 2
a5897 5
  static void choices_set_js_all_greyed(ObjectId window, int state)
  {
    set_gadget_state(window, CD_JSWatchdog,      !!state);
    set_gadget_state(window, CD_JSNavAsNav,      !!state);
    set_gadget_state(window, CD_JSErrorBoxes,    !!state);
d5899 6
a5904 1
    set_gadget_state(window, CD_JSOpenCloseLabl, !!state);
d5906 1
a5906 3
    set_gadget_state(window, CD_JSWinOpenLabl,   !!state);
    set_gadget_state(window, CD_JSWinOpenDisp,   !!state);
    set_gadget_state(window, CD_JSWinOpenBt,     !!state);
d5908 2
a5909 3
    set_gadget_state(window, CD_JSWinCloseLabl,  !!state);
    set_gadget_state(window, CD_JSWinCloseDisp,  !!state);
    set_gadget_state(window, CD_JSWinCloseBt,    !!state);
d5911 1
a5911 2
    choices_set_js_watchdog_greyed (window, state ? 1 : !new_choices->js_watchdog);
  }
d5913 2
a5914 1
#endif
d5917 1
a5917 1
/* choices_set_frame_related_greyed()                         */
d5919 2
a5920 2
/* Sets frame related gadgets, except "Support Frames", to    */
/* greyed or ungreyed.                                        */
d5922 1
a5922 4
/* CD_ShowMayScroll is greyed with everything else, but only  */
/* ungreyed if new_choices->no_scroll_bars is set, so make    */
/* sure this is set appropriately before calling to ungrey    */
/* stuff.                                                     */
d5924 3
a5926 2
/* Parameters: Object ID of the window which contains the     */
/*             icons;                                         */
d5928 2
a5929 1
/*             0 to ungrey, any other value to to grey.       */
d5932 1
a5932 1
static void choices_set_frame_related_greyed(ObjectId window, int state)
d5934 15
a5948 3
  set_gadget_state(window, CD_NoScrollBars,  !!state);
  set_gadget_state(window, CD_ShowMayScroll, state ? 1 : !new_choices->no_scroll_bars);
}
d5950 1
a5950 6
/**************************************************************/
/* choices_bord_m_button_handler()                            */
/*                                                            */
/* Opens the bord menu with a value appropriate to either the */
/* inner or outer table border.                               */
/**************************************************************/
d5952 3
a5954 8
static int choices_bord_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  WimpGetWindowStateBlock   state;
  _kernel_oserror         * e;
  BBox                      box;
  int                       position[2];
  int                       new_tick;
  ObjectId                  display;
d5956 1
a5956 6
  e = gadget_get_bbox(0, idb->self_id, idb->self_component, &box);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d5958 1
a5958 6
  e = window_get_wimp_handle(0, idb->self_id, &state.window_handle);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d5960 1
a5960 6
  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d5962 1
a5962 1
  /* Set open coordinates of display menu to top left of display button */
d5964 1
a5964 2
  position[0] = coords_x_toscreen(box.xmax, (WimpRedrawWindowBlock*)&state);
  position[1] = coords_y_toscreen(box.ymax, (WimpRedrawWindowBlock*)&state);
d5966 1
a5966 6
  e = toolbox_create_object(0, "ChTabBord", &display);
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
d5968 1
a5968 1
  switch(idb->self_component)
d5970 2
a5971 4
    case CD_TabInnerBordBt: new_tick = new_choices->table_inner; break;
    case CD_TabOuterBordBt: new_tick = new_choices->table_outer; break;
    default: new_tick = 0; break;
  }
d5973 1
a5973 6
  if (bord_ticked != new_tick)
  {
    if (bord_ticked != -1) menu_set_tick(0, display, bord_ticked, 0);
    menu_set_tick(0, display, new_tick, 1);
    bord_ticked = new_tick;
  }
d5975 1
a5975 6
  show_error_ret(toolbox_show_object(Toolbox_ShowObject_AsMenu,
                                     display,
                                     Toolbox_ShowObject_TopLeft,
                                     position,
                                     idb->self_id,
                                     idb->self_component));
d5977 8
a5984 2
  return 1;
}
d5986 1
a5986 7
/**************************************************************/
/* choices_bord_m_click_handler()                             */
/*                                                            */
/* Handles clicks in the border type menu. Sets the           */
/* associated display field and field in the new_choices      */
/* structure.                                                 */
/**************************************************************/
d5988 1
a5988 7
static int choices_bord_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  if (bord_ticked != idb->self_component)
  {
    if (bord_ticked != -1) menu_set_tick(0, idb->self_id, bord_ticked, 0);
    menu_set_tick(0, idb->self_id, idb->self_component, 1);
    bord_ticked = idb->self_component;
d5991 3
a5993 9
  switch(idb->parent_component)
  {
    case CD_TabInnerBordBt:
    new_choices->table_inner = idb->self_component;
    break;
    case CD_TabOuterBordBt:
    new_choices->table_outer = idb->self_component;
    break;
  }
d5995 2
a5996 1
  choices_set_table_border_field(idb->parent_id, idb->parent_component - 1, idb->self_component);
d5998 1
a5998 1
  return 1;
d6002 1
a6002 1
/* choices_get_menu_entry_text()                              */
d6004 1
a6004 3
/* Gets a pointer to a piece of text acquired from a menu.    */
/* The pointer is to a malloc block and so must be freed      */
/* after use.                                                 */
d6006 1
a6006 1
/* Parameters: pointer to the menu name                       */
d6008 1
a6008 1
/*             menu componentid                               */
d6010 1
a6010 1
/*             pointer to char* to use for the malloc block   */
d6012 1
a6012 1
/* Assumes:    the menu is a shared object.                   */
d6015 1
a6015 1
_kernel_oserror * choices_get_menu_entry_text(char * menuname, ComponentId compid, char ** tempstring)
d6017 1
a6017 13
  ObjectId menu_id;
  int      reqdsize;

  RetError(toolbox_create_object(0, menuname, &menu_id));

  RetError(menu_get_entry_text(0, menu_id, compid, NULL, 0, &reqdsize));

  *tempstring = malloc(reqdsize+1);
  if (!*tempstring) return make_no_memory_error(20);

  RetError(menu_get_entry_text(0, menu_id, compid, *tempstring, reqdsize+1, NULL));

  return NULL;
@


1.40
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a52 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

a61 1
#include "Limits.h"
d274 1
a274 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_show_subwindow: Wimp flags = %x\n", state.flags);
  #endif
d353 1
a353 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_to_be_shown: Called\n");
  #endif
d1660 1
a1660 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_colour_closed_handler: Colour DBox deleted\n");
  #endif
d1886 1
a1886 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_set_display_field: Called\n");
  #endif
d1909 1
a1909 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_set_display_field: Called\n");
  #endif
d2942 1
a2942 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_font_closed_handler: FontMenu deleted\n");
  #endif
d2959 4
a2962 7
  #ifdef TRACE
    if (tl & (1u<<29))
    {
      Printf("choices_font_selected_handler: called\n");
      Printf("Selected font = %s\n", ((FontMenuSelectionEvent*)event)->font_id);
    }
  #endif
d2980 9
a2988 9
  #ifdef TRACE
    if (tl & (1u<<29))
    {
      Printf("Base font           = %s\n", font[0]);
      Printf("Italic version      = %s\n", font[1]);
      Printf("Bold version        = %s\n", font[2]);
      Printf("Bold-Italic version = %s\n", font[3]);
    }
  #endif
d3059 1
a3059 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_set_plugin_field: Called\n");
  #endif
d3320 1
a3320 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_set_uri_field: Called\n");
  #endif
d3447 1
a3447 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_set_cookie_field: Called\n");
  #endif
d3572 1
a3572 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_set_jpeg_field: Called\n");
  #endif
d3697 1
a3697 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_set_referer_field: Called\n");
  #endif
d3827 1
a3827 3
    #ifdef TRACE
      if (tl & (1u<<29)) Printf("choices_set_win_open_field: Called\n");
    #endif
d3955 1
a3955 3
    #ifdef TRACE
      if (tl & (1u<<29)) Printf("choices_set_win_close_field: Called\n");
    #endif
d4220 1
a4220 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_set_timetype_field: Called\n");
  #endif
d4539 1
a4539 3
  #ifdef TRACE
    if (tl & (1u<<29)) Printf("choices_set_table_border_field: Called\n");
  #endif
@


1.39
log
@Misecllaneous tweaks and fixes. Major addition is full header and footer
support in the printing system - see the Phoenix Choices file for more
information.

Only the Phoenix resources are up to date currently.
@
text
@d15 17
a31 15
/***************************************************/
/* File   : Choices.c                              */
/*                                                 */
/* Purpose: Functions relating to the choices      */
/*          dialogue box and associated sub        */
/*          windows                                */
/*                                                 */
/* Author : D.T.A.Brown                            */
/*                                                 */
/* History: 23-Sep-97: Created.                    */
/*          18-Apr-98: choices_find_component will */
/*                     complain if the same thing  */
/*                     is found more than once in  */
/*                     TRACE builds (ADH).         */
/***************************************************/
d36 2
a37 1
#include "swis.h"
d39 1
a39 1
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */
d41 3
a43 3
#include "wimp.h"
#include "wimplib.h"
#include "event.h"
d45 12
a56 5
#include "toolbox.h"
#include "window.h"
#include "menu.h"
#include "ColourDbox.h"
#include "FontMenu.h"
a57 1
#include "svcprint.h"
d229 13
a241 16
/*************************************************/
/* choices_show_subwindow()                      */
/*                                               */
/* Shows a choice subwindow in the main choices  */
/* window.                                      */
/*                                               */
/* Parameters: the ObjectId of the main choices  */
/*             window                            */
/*                                               */
/*             the number of the subwindow to    */
/*             show.  Defined in choices.h       */
/*             Use CDSubNone to remove           */
/*             the current subwindow.            */
/*                                               */
/* Returns:    pointer to _kernel_oserror        */
/*************************************************/
d343 11
a353 14
/*************************************************/
/* choices_to_be_shown()                         */
/*                                               */
/* Called when the ECDToBeShown event is         */
/* generated.                                    */
/*                                               */
/* Creates all the subwindow dialogues and fills */
/* them in with appropriate values.              */
/* Registers all additional event handlers used  */
/* while the choices dialogue is visible.        */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d585 8
a592 7
  /*************************************************/
  /* choices_delete_subwindows()                   */
  /*                                               */
  /* Deletes all subwindows, reports any and all   */
  /* errors occuring while deleting them.          */
  /* Frees the structure holding the subwindows.   */
  /*************************************************/
d613 9
a621 11
/*************************************************/
/* choices_hidden()                              */
/*                                               */
/* Called when the ECDHidden event is generated. */
/* Deletes all the subwindow dialogues.          */
/* Deregisters all additional event handlers     */
/* used while the choices dialogue is visible.   */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d690 8
a697 9
/*************************************************/
/* choices_radio_click_handler()                 */
/*                                               */
/* Shows the appropriate subwindow when a radio  */
/* button in the choices dialogue is clicked on  */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d717 8
a724 9
/*************************************************/
/* choices_set_contents()                        */
/*                                               */
/* Sets the contents of all choices subwindows   */
/* to reflect the current state of the global    */
/* choices.                                      */
/*                                               */
/* Returns:    pointer to _kernel_oserror.       */
/*************************************************/
d906 6
a911 7
/*************************************************/
/* choices_get_contents()                        */
/*                                               */
/* Sets the state of the global choices to       */
/* reflect the contents of all the choices       */
/* subwindows.                                   */
/*************************************************/
d1282 10
a1291 12
/*************************************************/
/* choices_set_button_handler()                  */
/*                                               */
/* Called when the set button in the main        */
/* choices dialogue is clicked.                  */
/* Uses choices_get_contents to set the global   */
/* choices to reflect the choices set in the     */
/* choices subwindows                            */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d1311 9
a1319 11
/*************************************************/
/* choices_cancel_button_handler()               */
/*                                               */
/* Called when the cancel button in the main     */
/* choices dialogue is clicked.                  */
/* Uses choices_set_contents to restore the      */
/* subwindows to their previous state.           */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d1371 6
a1376 6
/*************************************************/
/* choices_close()                               */
/*                                               */
/* Close the Choices dialogue as if the 'Cancel' */
/* button had been activated with Select.        */
/*************************************************/
d1386 10
a1395 13
/*************************************************/
/* choices_save_button_handler()                 */
/*                                               */
/* Called when the set button in the main        */
/* choices dialogue is clicked.                  */
/* Uses choices_get_contents to set the global   */
/* choices to reflect the choices set in the     */
/* choices subwindows and then saves the choices */
/* file.                                         */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d1427 6
a1432 7
/*************************************************/
/* choices_set_encoding_field()                  */
/*                                               */
/* Sets the encoding display field appropriately */
/* to reflect the current state of               */
/* new_choices->encoding                         */
/*************************************************/
d1488 6
a1493 6
/*************************************************/
/* choices_encoding_button_handler()             */
/*                                               */
/* Opens the encoding window with appropriate    */
/* values for the choices dialogue.              */
/*************************************************/
d1538 6
a1543 6
/*************************************************/
/* choices_colour_button_handler()               */
/*                                               */
/* Opens a colour dialogue box with appropriate  */
/* settings for the current colour.              */
/*************************************************/
d1650 6
a1655 7
/*************************************************/
/* choices_colour_closed_handler()               */
/*                                               */
/* Called when the colour dialogue box is closed */
/* deregisters all events attached to it and     */
/* deletes the dbox object.                      */
/*************************************************/
d1677 8
a1684 9
/*************************************************/
/* choices_colour_selected_handler()             */
/*                                               */
/* Called when the a colour is selected in the   */
/* colour dialogue box.                          */
/* Sets appropriate fields in the new_choices    */
/* structure and updates the window to reflect   */
/* the new colour chosen.                        */
/*************************************************/
d1714 12
a1725 13
/*************************************************/
/* choices_colour_set_component()                */
/*                                               */
/* Sets the validation string of a button to be  */
/* slabbed in and have the background colour     */
/* specified.                                    */
/*                                               */
/* Parameters: window ObjectId                   */
/*                                               */
/*             button ComponentId                */
/*                                               */
/*             colour                            */
/*************************************************/
d1739 6
a1744 6
/*************************************************/
/* choices_display_button_handler()              */
/*                                               */
/* Opens the display menu with a value           */
/* appropriate to either the hotlist or history. */
/*************************************************/
d1812 6
a1817 6
/*************************************************/
/* choices_save_m_button_handler()               */
/*                                               */
/* Opens the save menu with a value appropriate  */
/* to either the hotlist or visit/image history. */
/*************************************************/
d1886 6
a1891 6
/*************************************************/
/* choices_set_save_field()                      */
/*                                               */
/* Sets the passed save display field            */
/* appropriately to reflect the passed state.    */
/*************************************************/
d1911 6
a1916 6
/*************************************************/
/* choices_set_display_field()                   */
/*                                               */
/* Sets the passed display display field         */
/* appropriately to reflect the passed state.    */
/*************************************************/
d1936 9
a1944 11
/*************************************************/
/* choices_display_m_click_handler()             */
/*                                               */
/* Called when there is a selection in the       */
/* display menu.  Sets the selected menu item to */
/* be ticked, unticks the previously ticked      */
/* entry sets appropriate new_choices field and  */
/* updates the display field of the component    */
/* with component number 1 less than the menus   */
/* parent.                                       */
/*************************************************/
d1970 9
a1978 11
/*************************************************/
/* choices_save_m_click_handler()                */
/*                                               */
/* Called when there is a selection in the save  */
/* menu.  Sets the selected menu item to be      */
/* ticked, unticks the previously ticked entry   */
/* sets appropriate new_choices field and        */
/* updates the display field of the component    */
/* with component number 1 less than the menus   */
/* parent.                                       */
/*************************************************/
d2007 27
a2033 35
/*************************************************/
/* choices_draw_string()                         */
/*                                               */
/* Writes a string on the screen using the       */
/* passed font handle, it underlines the text if */
/* required.  It also returns the position to    */
/* paint the next string following this one.     */
/*                                               */
/* Parameters: font handle                       */
/*                                               */
/*             string to print                   */
/*                                               */
/*             xposition on screen (os coords)   */
/*                                               */
/*             yposition on screen (os coords)   */
/*                                               */
/*             0     - don't underline           */
/*             non 0 - underline                 */
/*                                               */
/*             foreground colour                 */
/*                                               */
/*             background colour                 */
/*                                               */
/*             pointer to int to return x        */
/*             position in                       */
/*************************************************/

static _kernel_oserror * choices_draw_string(fm_face h,
                                             char *string,
                                             int xpos,
                                             int ypos,
                                             int underline,
                                             int forecolour,
                                             int backcolour,
                                             int *newxpos)
d2036 1
d2056 28
a2083 37
/*************************************************/
/* choices_write_rubbish()                       */
/*                                               */
/* Writes a string of readable rubbish on the    */
/* screen using the passed font handle.  It also */
/* returns the position to paint the next string */
/* following this one.                           */
/*                                               */
/* Parameters: font handle                       */
/*                                               */
/*             xposition on screen (os coords)   */
/*                                               */
/*             yposition on screen (os coords)   */
/*                                               */
/*             Approximate x position to stop    */
/*             printing at (os coords)           */
/*                                               */
/*             foreground colour                 */
/*                                               */
/*             background colour                 */
/*                                               */
/*             pointer to int to return x        */
/*             position in                       */
/*                                               */
/*             Random seed for string to print   */
/*             (If you pass the same seed the    */
/*             string should be the same)        */
/*************************************************/

static _kernel_oserror * choices_write_rubbish(fm_face h,
                                            int xpos,
                                            int ypos,
                                            int maxxish,
                                            int forecolour,
                                            int backcolour,
                                            int *newxpos,
                                            int seed)
d2130 5
a2134 6
/*************************************************/
/* choices_redraw_fakepage_handler()             */
/*                                               */
/* Redraws the fake page in the colour selection */
/* dbox.                                         */
/*************************************************/
d2318 7
a2324 8
/*************************************************/
/* choices_option_state_handler()                */
/*                                               */
/* Called when an option button has its state    */
/* changed by being clicked on.  Sets or unsets  */
/* the relevant flag in new_choices and causes   */
/* redraws where necessary.                      */
/*************************************************/
d2522 7
a2528 7
/*************************************************/
/* choices_mode_change()                         */
/*                                               */
/* Called on every mode change event.  Records   */
/* that a mode change has taken place for use    */
/* with the choices_open_choice_window function. */
/*************************************************/
d2537 8
a2544 9
/*************************************************/
/* choices_open_choice_window()                  */
/*                                               */
/* Called whenever the choices window needs to   */
/* be moved and specifically on mode changes so  */
/* the current sub window can be positioned      */
/* correctly dealing with rounding errors        */
/* between modes of different aspect ratio.      */
/*************************************************/
d2561 12
a2572 12
/*************************************************/
/* choices_find_component()                      */
/*                                               */
/* Scans all the choices subwindows for the      */
/* requested component and returns the id of the */
/* first window in which it was seen.            */
/*                                               */
/* Parameters: The component to find.            */
/*                                               */
/* Returns:    Where to return the object id to. */
/*             0 if the component was not found  */
/*************************************************/
d2650 7
a2656 7
/*************************************************/
/* choices_writablefield_set_value()             */
/*                                               */
/* Does as writablefield_set_value but will only */
/* update it if the text is different to that    */
/* currently in the display field.               */
/*************************************************/
d2681 7
a2687 7
/*************************************************/
/* choices_displayfield_set_value()              */
/*                                               */
/* Does as displayfield_set_value but will only  */
/* update it if the text is different to that    */
/* currently in the display field.               */
/*************************************************/
d2712 6
a2717 7
/*************************************************/
/* choices_button_set_validation()               */
/*                                               */
/* Does as button_set_validation but will only   */
/* update it if the text is different to that    */
/* currently in the button.                      */
/*************************************************/
d2742 6
a2747 7
/*************************************************/
/* choices_numberrange_set_value()               */
/*                                               */
/* Does as numberrange_set_value but will only   */
/* update it if the number is different to that  */
/* currently in the display.                     */
/*************************************************/
d2764 15
a2778 16
/*************************************************/
/* choices_modified_font()                       */
/*                                               */
/* Finds a version of a font with a specified    */
/* modification eg. bold or italic.              */
/*                                               */
/* Parameters: pointer to the original font name */
/*                                               */
/*             pointer to a space separated and  */
/*             null terminated list of           */
/*             modifications in order of         */
/*             preference                        */
/*                                               */
/*             pointer to a buffer to contain    */
/*             the name of the new font.         */
/*************************************************/
d2849 6
a2854 6
/*************************************************/
/* choices_font_button_handler()                 */
/*                                               */
/* Opens a font menu box with appropriate        */
/* settings for the current font.                */
/*************************************************/
d2938 6
a2943 7
/*************************************************/
/* choices_font_closed_handler()                 */
/*                                               */
/* Called when the font menu is closed           */
/* deregisters all events attached to it and     */
/* deletes the menu object.                      */
/*************************************************/
d2965 5
a2969 6
/*************************************************/
/* choices_font_selected_handler()               */
/*                                               */
/* Called when the a font is selected in the     */
/* font menu.                                    */
/*************************************************/
d3036 11
a3046 12
/*************************************************/
/* choices_set_fonts_greyed()                    */
/*                                               */
/* Sets the font name and font size gadgets to   */
/* greyed/ungreyed.                              */
/*                                               */
/* Parameters: ObjectId of the window which      */
/*             contains the icons.               */
/*                                               */
/*             0 to ungrey, any other value to   */
/*             to grey.                          */
/*************************************************/
d3067 6
a3072 7
/*************************************************/
/* choices_set_plugin_field()                    */
/*                                               */
/* Sets the plugin field appropriately to        */
/* reflect the current state of                  */
/* new_choices->plugin_control                   */
/*************************************************/
d3098 9
a3106 11
/*************************************************/
/* choices_plug_m_click_handler()                */
/*                                               */
/* Called when there is a selection in the       */
/* plugin menu.  Sets the selected menu item to  */
/* be ticked, unticks the previously ticked      */
/* entry sets appropriate new_choices field and  */
/* updates the display field of the component    */
/* with component number 1 less than the menus   */
/* parent.                                       */
/*************************************************/
d3124 6
a3129 6
/*************************************************/
/* choices_plug_m_button_handler()               */
/*                                               */
/* Opens the save menu with a value appropriate  */
/* to either the hotlist or history.             */
/*************************************************/
d3192 6
a3197 6
/*************************************************/
/* choices_history_radio_handler()               */
/*                                               */
/* Handles radio button state changes.  Swaps    */
/* between page and image history settings.      */
/*************************************************/
d3259 5
a3263 6
/*************************************************/
/* choices_uri_m_button_handler()                */
/*                                               */
/* Handles clicks on the URI Handler menu        */
/* button.                                       */
/*************************************************/
d3330 6
a3335 7
/*************************************************/
/* choices_set_uri_field()                       */
/*                                               */
/* Sets the URI Handler field appropriately to   */
/* reflect the current state of                  */
/* 'new_choices->uri_usage'.                     */
/*************************************************/
d3361 5
a3365 5
/*************************************************/
/* choices_uri_m_click_handler()                 */
/*                                               */
/* Handles clicks on URI Handler menu entries.   */
/*************************************************/
d3390 5
a3394 5
/*************************************************/
/* choices_cookie_m_button_handler()             */
/*                                               */
/* Handles clicks on the Cookie menu button.     */
/*************************************************/
d3459 6
a3464 7
/*************************************************/
/* choices_set_cookie_field()                    */
/*                                               */
/* Sets the Cookie field appropriately to        */
/* reflect the current state of                  */
/* 'new_choices->cookies'.                       */
/*************************************************/
d3490 5
a3494 5
/*************************************************/
/* choices_cookie_m_click_handler()              */
/*                                               */
/* Handles clicks on Cookie menu entries.        */
/*************************************************/
d3517 5
a3521 5
/*************************************************/
/* choices_jpeg_m_button_handler()               */
/*                                               */
/* Handles clicks on the JPEG menu button.       */
/*************************************************/
d3586 6
a3591 7
/*************************************************/
/* choices_set_jpeg_field()                      */
/*                                               */
/* Sets the JPEG field appropriately to reflect  */
/* current state of                              */
/* 'new_choices->support_pjpeg'.                 */
/*************************************************/
d3617 5
a3621 5
/*************************************************/
/* choices_jpeg_m_click_handler()                */
/*                                               */
/* Handles clicks on JPEG menu entries.          */
/*************************************************/
d3644 5
a3648 5
/*************************************************/
/* choices_referer_m_button_handler()            */
/*                                               */
/* Handles clicks on the Referer menu button.    */
/*************************************************/
d3713 6
a3718 7
/*************************************************/
/* choices_set_referer_field()                   */
/*                                               */
/* Sets the Referer field appropriately to       */
/* reflect current state of                      */
/* 'new_choices->send_referer'.                  */
/*************************************************/
d3746 6
a3751 6
  /*************************************************/
  /* choices_win_open_m_button_handler()           */
  /*                                               */
  /* Handles clicks on the Window Open menu        */
  /* button (control of scripts opening windows).  */
  /*************************************************/
d3816 6
a3821 6
  /*************************************************/
  /* choices_win_open_m_click_handler()            */
  /*                                               */
  /* Handles clicks on Open (control of scripts    */
  /* opening windows) menu entries.                */
  /*************************************************/
d3845 6
a3850 7
  /*************************************************/
  /* choices_set_win_open_field()                  */
  /*                                               */
  /* Sets the Open field appropriately to          */
  /* reflect current state of                      */
  /* 'new_choices->js_window_open'.                */
  /*************************************************/
d3876 6
a3881 6
  /*************************************************/
  /* choices_win_close_m_button_handler()          */
  /*                                               */
  /* Handles clicks on the Window Close menu       */
  /* button (control of scripts closing windows).  */
  /*************************************************/
d3946 6
a3951 6
  /*************************************************/
  /* choices_win_close_m_click_handler()           */
  /*                                               */
  /* Handles clicks on Close (control of scripts   */
  /* closing windows) menu entries.                */
  /*************************************************/
d3975 6
a3980 7
  /*************************************************/
  /* choices_set_win_close_field()                 */
  /*                                               */
  /* Sets the Close field appropriately to         */
  /* reflect current state of                      */
  /* 'new_choices->js_window_close'.               */
  /*************************************************/
d4008 5
a4012 5
/*************************************************/
/* choices_refer_m_click_handler()               */
/*                                               */
/* Handles clicks on Referer menu entries.       */
/*************************************************/
d4035 8
a4042 9
/*************************************************/
/* choices_set_expiry_age()                      */
/*                                               */
/* Sets up the expiry age fields and greys/      */
/* ungreys them as appropriate.                  */
/*                                               */
/* Parameters: ObjectId of the window containing */
/*             the gadgets.                      */
/*************************************************/
d4078 10
a4087 12
/*************************************************/
/* choices_set_expiry_age_greyed()               */
/*                                               */
/* Sets the expiry age gadgets to greyed/        */
/* ungreyed.                                     */
/*                                               */
/* Parameters: ObjectId of the window which      */
/*             contains the icons.               */
/*                                               */
/*             0 to ungrey, any other value to   */
/*             to grey.                          */
/*************************************************/
d4097 8
a4104 9
/*************************************************/
/* choices_set_im_expiry_age()                   */
/*                                               */
/* Sets up the image expiry age fields and greys */
/* /ungreys them as appropriate.                 */
/*                                               */
/* Parameters: ObjectId of the window containing */
/*             the gadgets.                      */
/*************************************************/
d4136 10
a4145 12
/*************************************************/
/* choices_set_im_expiry_age_greyed()            */
/*                                               */
/* Sets the image expiry age gadgets to greyed/  */
/* ungreyed.                                     */
/*                                               */
/* Parameters: ObjectId of the window which      */
/*             contains the icons.               */
/*                                               */
/*             0 to ungrey, any other value to   */
/*             to grey.                          */
/*************************************************/
d4155 9
a4163 9
/*************************************************/
/* choices_set_max_size()                        */
/*                                               */
/* Sets up the max size field and greys or       */
/* ungreys it as appropriate.                    */
/*                                               */
/* Parameters: The ObjectId of the window which  */
/*             contains the gadgets.             */
/*************************************************/
d4181 10
a4190 11
/*************************************************/
/* choices_set_max_size_greyed()                 */
/*                                               */
/* Sets the max size gadgets to greyed/ungreyed. */
/*                                               */
/* Parameters: ObjectId of the window which      */
/*             contains the icons.               */
/*                                               */
/*             0 to ungrey, any other value to   */
/*             to grey.                          */
/*************************************************/
d4199 9
a4207 9
/*************************************************/
/* choices_set_im_max_size()                     */
/*                                               */
/* Sets up the image max size field and greys or */
/* ungreys it as appropriate.                    */
/*                                               */
/* Parameters: The ObjectId of the window which  */
/*             contains the gadgets.             */
/*************************************************/
d4221 10
a4230 12
/*************************************************/
/* choices_set_im_max_size_greyed()              */
/*                                               */
/* Sets the image max size gadgets to greyed/    */
/* ungreyed.                                     */
/*                                               */
/* Parameters: ObjectId of the window which      */
/*             contains the icons.               */
/*                                               */
/*             0 to ungrey, any other value to   */
/*             to grey.                          */
/*************************************************/
d4239 8
a4246 10
/*************************************************/
/* choices_set_timetype_field()                  */
/*                                               */
/* Sets the time field appropriately to reflect  */
/* the passed state.  Also ticks the appropriate */
/* item in the menu.                             */
/*                                               */
/* Parameters: timetype - see defined values in  */
/*                        choices.h              */
/*************************************************/
d4277 7
a4283 8
/*************************************************/
/* choices_set_timetype_tick()                   */
/*                                               */
/* Ticks the appropriate item in the ChTime menu */
/*                                               */
/* Parameters: timetype - see defined values in  */
/*                        choices.h              */
/*************************************************/
d4303 6
a4308 6
/*************************************************/
/* choices_timetype_m_button_handler()           */
/*                                               */
/* Displays the time units menu when the         */
/* appropriate toolaction button is pressed.     */
/*************************************************/
d4372 7
a4378 8
/*************************************************/
/* choices_timetype_m_click_handler()            */
/*                                               */
/* Handles clicks in the time units menu.        */
/* Translates the current expiry time to the new */
/* units and places the name of the units in the */
/* appropriate display field.                    */
/*************************************************/
d4425 12
a4436 13
/*************************************************/
/* choices_typed_time_to_seconds()               */
/*                                               */
/* Converts a time in the passed units to        */
/* seconds.                                      */
/*                                               */
/* Parameters: Time in passed units;             */
/*                                               */
/*             units which the time was passed   */
/*             as (defined in choices.h);        */
/*                                               */
/* Returns:    time in seconds.                  */
/*************************************************/
d4451 13
a4463 13
/*************************************************/
/* choices_clip_to_min_max()                     */
/*                                               */
/* Clips a number to a minimum and maximum value */
/*                                               */
/* Parameters: initial value;                    */
/*                                               */
/*             minimum;                          */
/*                                               */
/*             maximum.                          */
/*                                               */
/* Returns:    clipped value.                    */
/*************************************************/
d4470 12
a4481 13
/*************************************************/
/* choices_seconds_to_typed_time()               */
/*                                               */
/* Converts a time in seconds to a time in the   */
/* passed units.                                 */
/*                                               */
/* Parameters: time in seconds;                  */
/*                                               */
/*             the units to return time in as    */
/*             defined in choices.h;             */
/*                                               */
/* Returns:    the time in the passed units.     */
/*************************************************/
d4496 11
a4506 12
/*************************************************/
/* choices_return_appropriate_timetype()         */
/*                                               */
/* Given a time in seconds returns the most      */
/* appropriate set of units to display that time */
/* in.                                           */
/*                                               */
/* Parameters: time in seconds.                  */
/*                                               */
/* Returns:    the type of the appropriate units */
/*             as defined in choices.h           */
/*************************************************/
d4518 10
a4527 11
/*************************************************/
/* choices_get_range_of_typed_time()             */
/*                                               */
/* Returns the max acceptable value of the       */
/* passed time units type.                       */
/*                                               */
/* Parameters: the type of time units. (defined  */
/*             in choices.h)                     */
/*                                               */
/* Returns:    the maximum acceptable value.     */
/*************************************************/
d4542 10
a4551 12
/*************************************************/
/* choices_set_tables_greyed()                   */
/*                                               */
/* Sets the table border gadgets to greyed or    */
/* ungreyed.                                     */
/*                                               */
/* Parameters: Object ID of the window which     */
/*             contains the icons;               */
/*                                               */
/*             0 to ungrey, any other value to   */
/*             to grey.                          */
/*************************************************/
d4564 6
a4569 6
/*************************************************/
/* choices_set_table_border_field()              */
/*                                               */
/* Sets the passed display display field         */
/* appropriately to reflect the passed state.    */
/*************************************************/
d4591 11
a4601 12
  /*************************************************/
  /* choices_set_js_watchdog_greyed()              */
  /*                                               */
  /* Sets the JS watchdog timeout gadgets to       */
  /* greyed or ungreyed.                           */
  /*                                               */
  /* Parameters: Object ID of the window which     */
  /*             contains the icons;               */
  /*                                               */
  /*             0 to ungrey, any other value to   */
  /*             to grey.                          */
  /*************************************************/
d4610 19
a4628 21
  /*************************************************/
  /* choices_set_js_all_greyed()                   */
  /*                                               */
  /* Sets all JS related gadgets, except "Support  */
  /* JavaScript", to greyed or ungreyed. Watchdog  */
  /* related stuff is set according to the value   */
  /* of new_choices->js_watchdog, so make sure     */
  /* this is valid before calling the function.    */
  /* This is handled as follows; if you ask for    */
  /* items to be greyed, the watchdog stuff will   */
  /* always be greyed too; if you ask for items to */
  /* be ungreyed, the watchdog stuff will be only  */
  /* if new_choices->js_watchdog is set.           */
  /*                                               */
  /* Parameters: Object ID of the window which     */
  /*             contains the icons;               */
  /*                                               */
  /*             0 to ungrey, any other value to   */
  /*             to grey (except for watchdog      */
  /*             items, see details above).        */
  /*************************************************/
d4651 16
a4666 18
/*************************************************/
/* choices_set_frame_related_greyed()            */
/*                                               */
/* Sets frame related gadgets, except "Support   */
/* Frames", to greyed or ungreyed.               */
/*                                               */
/* CD_ShowMayScroll is greyed with everything    */
/* else, but only ungreyed if                    */
/* new_choices->no_scroll_bars is set, so make   */
/* sure this is set appropriately before calling */
/* to ungrey stuff.                              */
/*                                               */
/* Parameters: Object ID of the window which     */
/*             contains the icons;               */
/*                                               */
/*             0 to ungrey, any other value to   */
/*             to grey.                          */
/*************************************************/
d4674 6
a4679 6
/*************************************************/
/* choices_bord_m_button_handler()               */
/*                                               */
/* Opens the bord menu with a value appropriate  */
/* to either the inner or outer table border.    */
/*************************************************/
d4747 7
a4753 7
/*************************************************/
/* choices_bord_m_click_handler()                */
/*                                               */
/* Handles clicks in the border type menu.  Sets */
/* the associated display field and field in the */
/* new_choices structure.                        */
/*************************************************/
d4779 15
a4793 16
/*************************************************/
/* choices_get_menu_entry_text()                 */
/*                                               */
/* Gets a pointer to a piece of text acquired    */
/* from a menu.  The pointer is to a malloc      */
/* block and so must be freed after use.         */
/*                                               */
/* Parameters: pointer to the menu name          */
/*                                               */
/*             menu componentid                  */
/*                                               */
/*             pointer to char* to use for       */
/*             the malloc block                  */
/*                                               */
/* Assumes:    the menu is a shared object.      */
/*************************************************/
@


1.38
log
@Long overdue check-in of intermediate browser build, from continued "out
of hours" work. Forgot to add a few files last time too.

List dialogue box handler complete, and exclusion lists implemented
within the main browser code. Full documentation in Choices file.
Save routine knows all about it but is now getting very slow - must
come up with a better scheme; for now, it puts the hourglass on...

StripExtensions option controls auto stripping of filename extensions.

More sensible ancestor / frame selection for keyboard shortcut items
and the save dialogues - having selected a frame won't lock you into
it for F3 and related shortcuts now (input focus in URL writable ->
get ancestor details, input focus in frame -> get frame details). F4
works in frames. F5 now generally present for 'view source' with a
corresponding menu entry in the File menu.

Odd thing in later Res files; there's no action set for Adjust clicks
on the main ToolAction items in the button bar. Very odd. Nothing
appears to be set in v2.07 either, yet adjust-click works. Even
stranger. Anyway, added in the relevant event details (same as for
Select click in all cases) and this fixes the problem.

Background colours in the TABLE tag ignored the "don't print any
backgrounds" Print Style setting. Fixed. Meanwhile, the "black
text with no backgrounds" option wasn't getting this right either;
fixed this also.

Event logging implemented; HTTP errors and script output via.
window.print extension. No internal error output yet.

Faith:Never behaviour extended. If ever a server sends something with
no content type or an unhandleable type, the browser will try and get a
filetype from the URL. If it gets text or HTML, it'll render the file.
Else it'll save it. Hacks around IIS 4's lack of a content type field
in the Marketeye login stuff, and similar other slightly broken sites.
@
text
@d98 5
d156 5
d197 7
d475 39
a513 31
    e         = event_register_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDSet,                     choices_set_button_handler,        NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,   NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler,  NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler,  NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiImSaveBt,            choices_save_m_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,   NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDHiRadioClick,           choices_history_radio_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_HiAgeTypeBt,           choices_timetype_m_button_handler, NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDTimeMenuClick,          choices_timetype_m_click_handler,  NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_TabInnerBordBt,        choices_bord_m_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_TabOuterBordBt,        choices_bord_m_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDBordMenuClick,          choices_bord_m_click_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_URIHandlerBt,          choices_uri_m_button_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDURIMenuClick,           choices_uri_m_click_handler,       NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_CookieBt,              choices_cookie_m_button_handler,   NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDCookieMenuClick,        choices_cookie_m_click_handler,    NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_JPEGBt,                choices_jpeg_m_button_handler,     NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDJPEGMenuClick,          choices_jpeg_m_click_handler,      NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECD_RefererBt,             choices_referer_m_button_handler,  NULL);
    if (!e) e = event_register_toolbox_handler(-1, ECDRefererMenuClick,       choices_referer_m_click_handler,   NULL);
d527 36
a562 31
    event_deregister_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,       NULL);
    event_deregister_toolbox_handler(-1, CDSet,                     choices_set_button_handler,        NULL);
    event_deregister_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,       NULL);
    event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,   NULL);
    event_deregister_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_HiImSaveBt,            choices_save_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,   NULL);
    event_deregister_toolbox_handler(-1, ECDHiRadioClick,           choices_history_radio_handler,     NULL);
    event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,       NULL);
    event_deregister_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_HiAgeTypeBt,           choices_timetype_m_button_handler, NULL);
    event_deregister_toolbox_handler(-1, ECDTimeMenuClick,          choices_timetype_m_click_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECD_TabInnerBordBt,        choices_bord_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_TabOuterBordBt,        choices_bord_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDBordMenuClick,          choices_bord_m_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_URIHandlerBt,          choices_uri_m_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECDURIMenuClick,           choices_uri_m_click_handler,       NULL);
    event_deregister_toolbox_handler(-1, ECD_CookieBt,              choices_cookie_m_button_handler,   NULL);
    event_deregister_toolbox_handler(-1, ECDCookieMenuClick,        choices_cookie_m_click_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECD_JPEGBt,                choices_jpeg_m_button_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDJPEGMenuClick,          choices_jpeg_m_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_RefererBt,             choices_referer_m_button_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECDRefererMenuClick,       choices_referer_m_click_handler,   NULL);
d879 1
d884 10
d2539 2
a2540 1
      case CD_JSNavAsNav: new_choices->js_nav_as_nav = !!state; break;
d3793 266
d4705 13
a4717 2
    set_gadget_state(window, CD_JSWatchdog, !!state);
    set_gadget_state(window, CD_JSNavAsNav, !!state);
d4719 1
a4719 1
    choices_set_js_watchdog_greyed(window, state ? 1 : !new_choices->js_watchdog);
@


1.37
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d860 1
d2504 1
@


1.36
log
@Tweaks to export rules in Makefile - ResJ source for JavaScript builds,
all of User dir exported, resources rule exports About as well as User.

Handles images with a width or height of 0 specified in the HTML.
Previously went for a default size placeholder and changes to image
sizes and/or redraw problems could occur before/after subsequent
reformatting (involved trivial changes to image_get_image_size and
image_redraw_area only).

Default parameter HRs now plot properly in rectangular pixel modes.

Choices code updated to cope with the minimum font size, JS support,
watchdog on/off and timeout, Navigator object option added generally
(act even *more* like Navigator), image GC after fetch, and image
GC unused image / free RAM constraints.

Code in JSnavigator.c updated to obey new "act more like Navigator"
option (see above). Currently declares itself as version 3.0.

Resources for all builds are up to date. All links in default hotlist
verified and corrected where necessary, with several new links added.

This is Release v2.07. Not tested very much, sorry; YMMV.
@
text
@d435 1
@


1.35
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d125 1
a125 1
static void              choices_set_tables_greyed           (int state, ObjectId window);
d127 7
d749 4
d755 3
a767 5

  if ((window = choices_find_component(CD_NoScrollBars))   != 0) optionbutton_set_state(0, window, CD_NoScrollBars,  new_choices->no_scroll_bars);
  if ((window = choices_find_component(CD_DragToScroll))   != 0) optionbutton_set_state(0, window, CD_DragToScroll,  new_choices->drag_to_scroll);
  if ((window = choices_find_component(CD_ShowMayScroll))  != 0) optionbutton_set_state(0, window, CD_ShowMayScroll, new_choices->show_may_scroll);

d774 1
d822 1
a822 1
    choices_set_tables_greyed(!new_choices->support_tables,window);
d845 15
d873 1
a874 1
  WimpGetWindowStateBlock   s;
d876 2
a878 1
  char                    * tempstring;
d880 1
a880 1
  fm_typeface             * tfptr;
d887 4
a890 2
  int                       old_font_size, old_system_font, old_msie4_style_tables;
  int                       frac,          temp;
d927 5
a931 2
  if ((window = choices_find_component(CD_HlAutoOpen))     != 0) numberrange_get_value(0, window, CD_HlAutoOpen,   &new_choices->auto_open_delay);
  if ((window = choices_find_component(CD_HlAutoScroll))   != 0) numberrange_get_value(0, window, CD_HlAutoScroll, &new_choices->auto_scroll_delay);
d933 3
a935 1
  if ((window = choices_find_component(CD_RefoTimeDisp))   != 0) numberrange_get_value(0, window, CD_RefoTimeDisp, &new_choices->refo_time);
d940 1
a940 1
    else               new_choices->expiry_age = 0;
d944 1
a944 1
    if ((window = choices_find_component(CD_HiExpiryAge))    != 0)
d946 2
a947 1
      numberrange_get_value(0, window, CD_HiExpiryAge,  &temp);
d949 1
a949 1
      else               new_choices->expiry_age = choices_typed_time_to_seconds(temp, history_expiry_units);
d956 1
a956 1
    else               new_choices->max_size = 0;
d960 1
a960 1
    if ((window = choices_find_component(CD_HiMaxSize))      != 0)
d962 2
a963 1
      numberrange_get_value(0, window, CD_HiMaxSize,    &temp);
d965 1
a965 1
      else               new_choices->max_size = temp * 1024;
d975 1
a975 1
    if ((window = choices_find_component(CD_HiImExpiryAge))    != 0)
d977 2
a978 1
      numberrange_get_value(0, window, CD_HiImExpiryAge,  &temp);
d989 1
a989 1
    if ((window = choices_find_component(CD_HiImMaxSize))      != 0)
d991 2
a992 1
      numberrange_get_value(0, window, CD_HiImMaxSize,    &temp);
a996 1

d1038 1
d1079 1
d1082 2
a1083 2
       choices.table_inner != new_choices->table_inner ||
       choices.table_outer != new_choices->table_outer
d1118 7
a1124 1
  if (choices.font_size != old_font_size || choices.system_font != old_system_font)
d1201 1
a1201 3
             (!b->use_source_cols &&
              colours_changed
             ) ||
d1203 6
a1208 2
               b->background_colour == -1 &&
               b->background_image  == -1
a1222 5

        if (b->background_colour == -1)
        {
          b->antialias_colour = choices.background_colour;
        }
d2280 1
d2347 8
a2354 1
    case CD_FramesSupport:  new_choices->support_frames  = !!state; break;
d2359 11
a2369 1
    new_choices->refo_wait = !!state;
d2371 1
a2371 1
    if ((window = choices_find_component(CD_RefoTimeLabl)) != 0)
d2373 2
a2374 3
      set_gadget_state(window, CD_RefoTimeLabl,  !state);
      set_gadget_state(window, CD_RefoTimeDisp,  !state);
      set_gadget_state(window, CD_RefoTimeLabl2, !state);
a2377 1
    case CD_NoScrollBars:   new_choices->no_scroll_bars  = !!state; break;
a2381 2
    new_choices->system_font = !!state;
    if ((window = choices_find_component(CD_FontsTF1Labl)) != 0)
d2383 2
a2384 3
      choices_set_fonts_greyed(window, new_choices->system_font);
      /*set_gadget_state(window, CD_FontsGroup1,  new_choices->system_font);*/
      if ((window = choices_find_component(CD_FontsSize)) != 0)
d2386 3
a2388 1
        if (new_choices->system_font)
d2390 21
a2410 18
          int frac, temp;
          numberrange_get_value(0, window, CD_FontsSize, &new_choices->font_size);
          frac = new_choices->font_size % 10;
          new_choices->font_size = ((new_choices->font_size / 10)<<4) + fromdecimal[frac];
          temp = FM_Standard_Size;
          frac = (temp & 0xf);
          temp = ((temp >> 4) * 10) + todecimal[frac];
          choices_numberrange_set_value(0, window, CD_FontsSize, temp);
          choices_numberrange_set_value(0, window, CD_FontsAspect, 100);
        }
        else
        {
          int temp, frac;
          temp = new_choices->font_size;
          frac = (temp & 0xf);
          temp = ((temp >> 4) * 10) + todecimal[frac];
          choices_numberrange_set_value(0, window, CD_FontsSize, temp);
          choices_numberrange_set_value(0, window, CD_FontsAspect, new_choices->tt_aspect);
d2417 2
a2418 1
    new_choices->support_object = !!state;
d2420 7
a2426 6
    if ((window = choices_find_component(CD_ObjPlugDisp)) != 0)
    {
      set_gadget_state(window, CD_ObjPlugLabl, !new_choices->support_object);
      set_gadget_state(window, CD_ObjPlugBt,   !new_choices->support_object);
      set_gadget_state(window, CD_ObjPlugDisp, !new_choices->support_object);
      choices_set_plugin_field();
a2430 2
    new_choices->use_proxy = !!state;
    if ((window = choices_find_component(CD_NetProxyAddr))    != 0)
d2432 6
a2437 2
      set_gadget_state(window, CD_NetProxyAddr, !new_choices->use_proxy);
      set_gadget_state(window, CD_NetProxyLabl, !new_choices->use_proxy);
d2444 4
a2447 2
    choices_set_expiry_age_greyed(idb->self_id, !state);
    expiry_age_greyed = !state;
d2451 4
a2454 2
    choices_set_max_size_greyed(idb->self_id, !state);
    max_size_greyed = !state;
d2458 4
a2461 2
    choices_set_im_expiry_age_greyed(idb->self_id, !state);
    image_expiry_age_greyed = !state;
d2465 4
a2468 2
    choices_set_im_max_size_greyed(idb->self_id, !state);
    image_max_size_greyed = !state;
d2474 4
a2477 2
    new_choices->support_tables = !!state;
    choices_set_tables_greyed(!new_choices->support_tables,idb->self_id);
d2480 23
d4302 1
a4302 1
/* Sets the table border gadgets to greyed/      */
d4305 2
a4306 2
/* Parameters: ObjectId of the window which      */
/*             contains the icons.               */
d4312 1
a4312 1
static void choices_set_tables_greyed(int state, ObjectId window)
d4346 79
@


1.34
log
@Updated Hotlists - USNA HTML resources and 6025 TV room pages had moved,
MIDI themes is unreachable, Hensa has been restructured.

For table cells where the line or chunk data totals less than Flex_256_Point
bytes (see top of Memory.c, current value is 8192) there would be an over-
allocation of 1 byte per cell due to a (now fixed) bug in the granular
allocator.This would translate into 4 bytes wastage of course, and may
represent a small speed penalty depending on how flex works out block
word alignment.

Several entries in the Choices file were missing from save_save_choices in
its new form (see last check-in). Added back in. Ursula and Phoenix Res
files contained an incorrect component ID in pane 3 that was stopping the
'no scroll bars' option in pane 7 working correctly (duplicate component
ID). Res files corrected; TRACE builds will now spot such errors and give
a warning when they occur (in choices_find_component).

Table widthing code fixes:

 * Very wide table cell specifiers (e.g. TD WIDTH="2000") were ignored,
   but this isn't what Navigator / MSIE 4 do. This code was present
   because of other bugs in the widther, long since fixed. The code has
   been commented out - if the problem reappears the use of the code can
   be re-investigated, but as far as I can tell it isn't needed.

 * If two pixel specified cells appear one above the other, the first
   would always have been taken for use in the final width calculation
   even if it specified a smaller width than the second. The check was
   made to ensure that pixel specifiers were chosen in preference to
   other cells, which is OK, but it didn't notice if the current cell
   was also a pixel specifier! Fixed; you now get the widest.

 * The TRACE build 'Colspan cell xxx would have been width yyy, below
   minimum width of zzz' error should no longer happen. In a manner similar
   to the bug mentioned above, two cells above each other spanning the
   same columns with the lower cell narrower than the upper would end up
   with the narrower width. The code that trapped and corrected the error
   was not compiled out of release builds, even though the error message
   generation was, because the rendering would fail otherwise. The widther
   has now been fixed not to make this mistake and the final check is now
   strictly TRACE build only, thereby speeding up table widthing for
   non-TRACE builds.

 * Another use of MSIE4StyleTables option, for cellspacing; it's based
   on the actual used cells, rather than the maximum cell width caused
   by COLSPAN etc. So if you've a cell with a big COLSPAN but as a
   heading but the rest of the table only uses, say, 4 columns, you won't
   get a gap to the right which adds up to the spacing for all of the
   cells that the COLSPAN attribute in the heading implied. The option
   was actually intended as 'bad things when switched on', and though in
   this case it makes for a better rendering, it does hide an error in
   the HTML. Note Navigator 4 acts as Browse with MSIE4StyleTables off
   in this particular case. Oh, it works in both ways of course, so
   the table height routine had to be updated too. A new function,
   tables_find_actual_size, exists to support the feature in general.

Messages files updated to v2.05 (21-Apr-98). Help menu items renamed a
bit in Ursula, Phoenix and Customer Res files, but entries still point
to the same URLs. Phoenix button bar markers have been brought closer
together to stop them being visible when only the URL bar is meant to
be present.
@
text
@d96 1
d142 1
d177 2
d479 2
d523 2
d775 3
a777 2
  if ((window = choices_find_component(CD_FontsSize))      != 0) choices_numberrange_set_value(0,  window, CD_FontsSize, temp);
  if ((window = choices_find_component(CD_FontsAspect))    != 0) choices_numberrange_set_value(0,  window, CD_FontsAspect, new_choices->tt_aspect);
d803 5
d1018 9
d2985 1
a2985 1
  /* Find which window the encoding display is in */
d3252 1
a3252 1
  /* Find which window the encoding display is in */
d3382 1
a3382 1
  /* Find which window the encoding display is in */
d3510 1
a3510 1
  /* Find which window the encoding display is in */
d3552 128
d3911 1
a3911 1
    if (tl & (1u<<29)) Printf("choices_set_plugin_field: Called\n");
d3914 1
a3914 1
  /* Find which window the encoding display is in */
@


1.33
log
@All !Run[D], Choices, Messages, Controls and Res files are up to date.

RefoKeep and RefoHold options added to, respectively, try and maintain
the line at the top of the visible area when reformatting, and not shrink
the vertical extent at the start of a reformat to try and avoid flicker
to the top of the page and back down again when RefoKeep is on. Choices
front-end implemented, which also allows RefoWait and RefoTime to be set.
Unfortunately for various reasons this doesn't help the page jumping when
unsized images come in (but RefoHold can improve matters...) - roll on
the image history.

DragToScroll and NoScrollBars options added for frames; included new
pointer type, Mouse_Shape_DTS, so relevant Controls file entries done
and Sprites[22] files updated as required. Noticed some builds have
a low-res ptr_link with a mask - mask removed.

Named anchor following fixed up somewhat - anchors near the bottom of
the page shouldn't be displayed, and then pulled down when the fetcher
releases null polls and ensures the y extent is correct (this through
implementing the min_height field in the browser_data structure).

RefoHang was never implemented and there seems little point to it now,
so the entry for it has been removed from the global choices structure
and all Choices files.

Markers menus should work properly now (in last check-in they would not
update correctly if Adjust was used on the entries).

URI handler usage now a lot more sensible, with configuration of how the
browser uses the module from both a Utils menu submenu (sic) and the
Choices dialogue.

Slightly dodgy 'hang around waiting for user input' stuff for the Cookies
dialogue box: All fetches are suspended; the fetcher remembers some info
about its state at the time the cookie came in, and restores it later; it
will only do this for one fetch at a time. It's necessary to single-thread
the fetcher at this point anyway, since other fetches may have a
dependency on the cookie that is hanging in mid-air at that point. As part
of this, some of the fetcher code has been split out into separate
functions (to try and 'black box' the code a bit). Anyway, Cookie Query
dialogue box now implemented with appropriate Choices file entry and
UI work in the Choices dialogue box.

Phoenix build Choices rearranged. Can now choose when the image history
is saved from the front end. Added also MSIE 4-style table option menu
for JPEG support (OS only, OS if it can handle it, internal only).

Should be a bit faster at loading the history - though 95% of the time
is spent in SWI URL_ParseURL. URL descriptions are stored more
efficiently as part of this - one malloc block instead of several
small blocks. The minimum block size for malloc blocks typically leads
to a significantly smaller startup wimpslot depending on the visit
history size.

Nasty bug in image system fixed. If an image size came in and a reformat
was to take place, the line the image lies in is found and the reformat
progresses from there. Unforunately, this didn't check to see if the
token can't be found in the line list, so it'd reformat from the top
of the page...! This would happen if, for example, an image halfway down
the page came in whilst a reformat for an image higher up had just begun.

In Choices.c, made choices_set_timetype_field, choices_set_uri_field,
choices_set_plugin_field, choices_set_cookie_field, and
choices_set_jpeg_field static (so they're not declared in Choices.h now).

Two memory leaks plugged in URL comparison routines in URLutils.c
(calling free() url_description instead of urlutils_free_descripton()).

Client pull reload handler was setting the reload flag if reloading
the same page, but forgetting to turn on reload_lock so
fetchpage_postprocessed was clearing the reload state... Similarly,
Ctrl+Shift+SELECT-Click on a link when the Controls file 'UseSmall'
entry is 'no' would not have reloaded as it should. Both fixed.

Frames shouldn't be so keen on acquiring horizontal scroll bars and never
letting them go when their width is decreased now. Frames set up for
'scrolling="yes"' will not start with no scroll bars and then gain them
shortly afterwards, causing flicker and two reformats - they'll start
with, and continue to hold, both scroll bars.

Pointer shouldn't flicker when over a frame border whilst other fetches
are progressing now.
@
text
@d25 4
d2450 1
a2450 2
  /* Uses lazy evaluation to not call gadget_get_flags unless */
  /* subwindows[findwindow] contains an objectid.             */
d2452 65
a2516 2
  for(findwindow = 0; findwindow < CDNoSubwindows; findwindow++)
    if (subwindows[findwindow] && !gadget_get_flags(0, subwindows[findwindow], component, &flags)) return subwindows[findwindow];
@


1.32
log
@Programming warehouse link removed from all hotlists - the page has gone.

Some compile-time hacks in place to use MemLib, a dynamic area based
malloc replacement which shrinks its heap when possible. All builds
have these switched off at the moment. Seemed to work with just Browse,
though there would be problems with message blocks stored in dynamic
areas because of the Wimp's '&3800000' check - however, it failed when
HTMLLib was made to use it, too. Don't know why yet.

ItemInfo.[c/h] source added, with Res file additions for testbed Browse
and Phoenix.

Small fetch windows now work properly regardless of toolbar settings
in the Choices.

Reload now reloads all images too, rather than only reloading them for
as long as the main page was being fetched.

Added a simple 'Find' facility.

Realised that event handlers in eventlib are called in reverse order
of registration, so the miscellaneous event handler is now registered
first rather than last.

Multiuser code added (most only active if SINGLE_USER is undefined). As
part of this, hotlist code now knows about read-only items (done for the
Customer-style 'Resources' file, but works generally anyway).
handle_add_hotlist doesn't try to save the hotlist itself anymore (the
hotlist_add function does all that through hotlist_modified anyway).

Customer build Choices and Controls updated slightly (e.g. ClaimHelp
off, hotlist to save on quit only).

Customer build now uses Phoenix-style buttons. Sprites files which
worked at the time (but will probably be out of date now) and included
most of the original Customer-style sprites are in
'Utils.Icons.Customer'.

Choices, Messages and Res files for all builds now stripped down to only
single user items or single plus multiuser for Customer build and testbed
build. Before, all contained a few multiuser bits in at least the Choices
file if not more.

Grammatical error ("Fetching frames contents" (sic.)) corrected in
default message, Toolbars.c, and all of the Messages files.

Customer build brought back to a servicable level (including
implementation of the Find dialogue box with animation and fixing
up authorisation and 'Stop' state in the tristate). Quite a few
missing #ifndef REMOTE_HOTLIST bits from hotlist code added...

Customer build will not use <Choices$Write> or Boot:Choices for any
file finding now. UseProxy defaults to 'yes', MaxImages to 2. Res
file includes Proxy Address setting (save_save_choices() now writes
the ProxyAddress line).
@
text
@d49 1
d89 3
d132 5
a136 1
_kernel_oserror        * choices_set_timetype_field          (int timetype, ComponentId comp);
d165 6
d452 1
d465 6
d484 13
a496 12
    event_deregister_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, CDSet,                     choices_set_button_handler,       NULL);
    event_deregister_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler, NULL);
    event_deregister_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler, NULL);
    event_deregister_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,  NULL);
d498 4
a501 4
    event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,     NULL);
d507 6
d607 1
d620 4
d712 1
a712 1
  if ((window = choices_find_component(CD_HiSaveDisp))     != 0) choices_set_save_field(   window, CD_HiSaveDisp, new_choices->save_history);
d715 1
d719 1
a719 1
    if ((window = choices_find_component(CD_HiRadImage))    != 0)
d732 17
d775 1
a775 1
  if ((window = choices_find_component(CD_TabSupport))     != 0)
d777 17
a793 1
    optionbutton_set_state(0,  window, CD_TabSupport, new_choices->support_tables);
d815 1
a815 1
  if ((window = choices_find_component(CD_NetMaxImageFetch)) != 0) choices_numberrange_set_value(0, window, CD_NetMaxImageFetch, new_choices->maximages);
d837 8
a844 7
  int                       serif_changed   = 0;
  int                       sans_changed    = 0;
  int                       fixed_changed   = 0;
  int                       needs_redraw    = 0;
  int                       colours_changed = 0;
  int                       old_font_size, old_system_font, frac;
  int                       temp;
d884 2
d978 1
a978 1
    new_choices->maximages = temp;
d981 6
a986 2
  old_font_size = choices.font_size;
  old_system_font = choices.system_font;
d1062 4
d1086 4
d1097 6
a1102 1
    if (serif_changed || sans_changed || fixed_changed)
d1717 1
a1717 1
/* to either the hotlist or history.             */
d1764 3
a1766 2
    case CD_HlSaveBt: new_tick = new_choices->save_hotlist; break;
    case CD_HiSaveBt: new_tick = new_choices->save_history; break;
d1902 3
d2280 17
d2336 1
a2336 1
      set_gadget_state(window, CD_ObjPlugBt, !new_choices->support_object);
d2373 2
d2886 1
a2886 1
_kernel_oserror * choices_set_plugin_field(void)
d3074 389
d3686 1
a3686 1
_kernel_oserror * choices_set_timetype_field(int timetype, ComponentId comp)
d4007 1
d4044 6
a4049 6
  _kernel_oserror *e;
  int  position[2];
  BBox box;
  WimpGetWindowStateBlock state;
  ObjectId display;
  int new_tick;
@


1.31
log
@Browsers with use default colours set only get redrawn by choices when the
default colours have actually been changed.
@
text
@d76 1
a76 1
static unsigned char todecimal[]   = {0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9};
d79 9
a87 9
static ObjectId *    subwindows          = NULL;
static int           current_subwindow   = 0;
static ObjectId      colourdbox_id       = 0;

static int           save_ticked         = -1;
static int           disp_ticked         = -1;
static int           plug_ticked         = -1;
static int           time_ticked         = -1;
static int           bord_ticked         = -1;
d89 1
a89 1
static int           history_radio       = 0; /* 0 - page history, 1 - image history */
d96 2
a97 2
static int           image_expiry_units   = -1;
static int           history_expiry_units = -1;
d99 1
a99 1
static int           choices_modechanged = 0;
d101 1
a101 2
global_choices  *    new_choices         = NULL;
ObjectId             choices_windowid    = 0;
d103 3
a105 1
static fm_typeface * new_typefaces       = NULL;
a106 2
#ifdef CREATE_ONLY_ONCE
  static int         objects_created     = 0;
d111 62
a172 65
static _kernel_oserror * choices_show_subwindow          (ObjectId choices_window, int subwindow);
static _kernel_oserror * choices_set_contents            (void);
static _kernel_oserror * choices_get_contents            (void);
_kernel_oserror        * choices_set_encoding_field      (void);
_kernel_oserror        * choices_set_plugin_field        (void);
static void              choices_set_expiry_age          (ObjectId window);
static void              choices_set_expiry_age_greyed   (ObjectId window, int state);
static void              choices_set_tables_greyed       (int state, ObjectId window);
static _kernel_oserror * choices_set_table_border_field  (ObjectId obj, ComponentId comp, int state);
static void              choices_set_fonts_greyed        (ObjectId window, int state);
static void              choices_set_max_size            (ObjectId window);
static void              choices_set_max_size_greyed     (ObjectId window, int state);
static void              choices_set_im_max_size         (ObjectId window);
static void              choices_set_im_max_size_greyed  (ObjectId window, int state);
int                      choices_clip_to_min_max         (int value, int min, int max);
static void              choices_set_im_expiry_age       (ObjectId window);
static void              choices_set_im_expiry_age_greyed(ObjectId window, int state);
_kernel_oserror        * choices_set_timetype_tick       (int timetype);

_kernel_oserror        * choices_set_timetype_field      (int timetype, ComponentId comp);

static void              choices_modified_font           (char * orig, char * mod, char * buffer);

static int               choices_radio_click_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_set_button_handler      (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_cancel_button_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_save_button_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_encoding_button_handler (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_button_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_closed_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_colour_selected_handler (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_display_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_save_m_button_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_display_m_click_handler (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_save_m_click_handler    (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_option_state_handler    (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_font_button_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_font_closed_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_font_selected_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_redraw_fakepage_handler (int eventcode, WimpPollBlock * event, IdBlock * id_block, void * handle);
static int               choices_open_choice_window      (int eventcode, WimpPollBlock * event, IdBlock * id_block, void * handle);
static int               choices_plug_m_button_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_plug_m_click_handler    (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_timetype_m_button_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_timetype_m_click_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_bord_m_button_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_bord_m_click_handler    (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               choices_history_radio_handler   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static _kernel_oserror * choices_colour_set_component    (ObjectId window, ComponentId component, int colour);
static _kernel_oserror * choices_set_save_field          (ObjectId obj, ComponentId comp, int state);
static _kernel_oserror * choices_set_display_field       (ObjectId obj, ComponentId comp, int state);
static ObjectId          choices_find_component          (ComponentId component);
_kernel_oserror        * choices_get_menu_entry_text     (char * menuname, ComponentId compid, char ** tempstring);

static _kernel_oserror * choices_displayfield_set_value  (unsigned int flags, ObjectId window, ComponentId writable, char *text);
static _kernel_oserror * choices_writablefield_set_value (unsigned int flags, ObjectId window, ComponentId writable, char *text);
static _kernel_oserror * choices_button_set_validation   (unsigned int flags, ObjectId window, ComponentId writable, char *text);
static _kernel_oserror * choices_numberrange_set_value   (unsigned int flags, ObjectId window, ComponentId writable, int value);

static int               choices_return_appropriate_timetype(int seconds);
static int               choices_seconds_to_typed_time   (int secs, int timetype);
static int               choices_typed_time_to_seconds   (int time, int timetype);
static int               choices_get_range_of_typed_time (int time);

d249 1
d296 1
d316 13
d1179 15
d1247 5
a1251 5
  _kernel_oserror *e;
  ObjectId    objid, destwind;
  ComponentId compid;
  char *textptr;
  int sizereqd;
@


1.30
log
@Added max image fetches choice.
@
text
@d759 5
a763 4
  int                       serif_changed = 0;
  int                       sans_changed  = 0;
  int                       fixed_changed = 0;
  int                       needs_redraw  = 0;
d915 14
d1032 3
a1034 1
             !b->use_source_cols ||
@


1.29
log
@Fixed REALLY stupid cancel not working type bug in choices.
@
text
@d736 2
a737 1
  if ((window = choices_find_component(CD_NetLaunchProxy))  != 0) optionbutton_set_state(0,  window, CD_NetLaunchProxy, new_choices->start_proxy);
d891 6
@


1.28
log
@Implemented Launch Proxy option.
@
text
@d1136 1
@


1.27
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d736 1
d2191 2
@


1.26
log
@Made TT aspect choice work with system font.
@
text
@a26 2
#define CREATE_ONLY_ONCE

d64 4
d75 1
d107 1
a107 1
static int           objects_created     = 0;
a3172 1
  _kernel_oserror * e;
d3605 2
a3606 3
  _kernel_oserror * e;
  ObjectId          menu_id;
  int               reqdsize;
@


1.25
log
@Implemented TT aspect ratio choice.
@
text
@d2152 1
d2161 1
d2694 15
a2708 12
  set_gadget_state(window, CD_FontsTF1Labl, !!state);
  set_gadget_state(window, CD_FontsTF1Disp, !!state);
  set_gadget_state(window, CD_FontsTF1Bt,   !!state);
  set_gadget_state(window, CD_FontsTF2Labl, !!state);
  set_gadget_state(window, CD_FontsTF2Disp, !!state);
  set_gadget_state(window, CD_FontsTF2Bt,   !!state);
  set_gadget_state(window, CD_FontsTF3Labl, !!state);
  set_gadget_state(window, CD_FontsTF3Disp, !!state);
  set_gadget_state(window, CD_FontsTF3Bt,   !!state);
  set_gadget_state(window, CD_FontsSize,    !!state);
  set_gadget_state(window, CD_FontsSzLabl1, !!state);
  set_gadget_state(window, CD_FontsSzLabl2, !!state);
@


1.24
log
@Implemented size and age expiry of image history.  There are two ways of
achieving this.

i)  There can be two sets of gadgets, one set for page history and another set
    for image history.

ii) There can be one set of gadgets for both settings and two radio buttons to
    select between them.

Only one of these may be present at the same time.  Currently the radio button
version is the one that is in place.  To change to the other version delete the
radio buttons and copy the gadgets from the ChoicesTMP window into the
appropriate window.
@
text
@d699 1
d897 6
a2943 1

@


1.23
log
@Choices dialogue only gets created the first time it is opened (ie. it is not
deleted every time it is closed anymore).  Can be controlled by a #define
@
text
@d86 9
a94 2
static int           expiry_age_greyed   = 0;
static int           max_size_greyed     = 0;
a113 1
static void              choices_set_max_size            (ObjectId window);
d119 1
d121 2
d124 3
d128 1
a128 1
_kernel_oserror        * choices_set_timetype_field      (int timetype);
d156 1
d426 1
d461 1
d555 22
a576 21
    event_deregister_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, CDSet,                     choices_set_button_handler,       NULL);
    event_deregister_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler, NULL);
    event_deregister_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler, NULL);
    event_deregister_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,  NULL);
    event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECD_HiAgeTypeBt,           choices_timetype_m_button_handler,NULL);
    event_deregister_toolbox_handler(-1, ECDTimeMenuClick,          choices_timetype_m_click_handler, NULL);
    event_deregister_toolbox_handler(-1, ECD_TabInnerBordBt,        choices_bord_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECD_TabOuterBordBt,        choices_bord_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECDBordMenuClick,          choices_bord_m_click_handler,     NULL);
d666 13
d797 1
d800 2
a801 1
    new_choices->expiry_age = 0;
d808 2
a809 1
      new_choices->expiry_age = choices_typed_time_to_seconds(temp, time_ticked);
d815 2
a816 1
    new_choices->max_size = 0;
d823 15
a837 1
      new_choices->max_size = temp * 1024;
d841 14
d2185 1
a2185 3
    set_gadget_state(idb->self_id, CD_HiMaxSizeLabl1, !state);
    set_gadget_state(idb->self_id, CD_HiMaxSize, !state);
    set_gadget_state(idb->self_id, CD_HiMaxSizeLabl2, !state);
d2189 10
d2828 67
d2909 3
d2913 1
a2913 1
  if (new_choices->expiry_age == 0)
d2921 2
a2922 2
    time_scale = choices_return_appropriate_timetype(new_choices->expiry_age);
    temp       = choices_seconds_to_typed_time(new_choices->expiry_age, time_scale);
d2926 3
a2928 3
  expiry_age_greyed = !new_choices->expiry_age;
  choices_set_expiry_age_greyed(window, !new_choices->expiry_age);
  optionbutton_set_state(0, window, CD_HiDontAge, !!new_choices->expiry_age);
d2931 4
a2934 1
  choices_set_timetype_field(time_scale);
d2938 1
d2961 61
d3033 6
a3038 2
  optionbutton_set_state(0, window, CD_HiDontSize, !!new_choices->max_size);
  max_size_greyed = !new_choices->max_size;
d3044 1
a3044 1
                                !new_choices->max_size ? 32 : new_choices->max_size/1024);
d3067 42
d3119 1
a3119 1
_kernel_oserror * choices_set_timetype_field(int timetype)
d3132 1
a3132 1
  destwind = choices_find_component(CD_HiAgeTypeDisp);
d3139 25
a3172 4
  e = choices_displayfield_set_value(0, destwind, CD_HiAgeTypeDisp, tempstring);

  free(tempstring);

d3217 11
d3259 9
a3267 1
  window = choices_find_component(CD_HiExpiryAge);
d3269 1
a3269 1
  numberrange_get_value(0, window, CD_HiExpiryAge, &temptime);
d3271 1
a3271 1
  temptime = choices_typed_time_to_seconds(temptime, time_ticked);
d3273 9
a3281 1
  choices_set_timetype_field(idb->self_component);
d3283 1
a3283 1
  numberrange_set_value(0, window, CD_HiExpiryAge, choices_seconds_to_typed_time(temptime, time_ticked));
d3285 10
a3294 1
  numberrange_set_bounds(15, window, CD_HiExpiryAge, 1, choices_get_range_of_typed_time(time_ticked), 1, 0);
@


1.22
log
@More tidying.  Made choices_seconds_to_typed_time a LOT smaller.  Made
choices_return_appropriate_timetype do what it says it does (thankfully not
a problem for the bete released version).
@
text
@d27 2
d96 4
d366 16
a381 9
  e = toolbox_create_object(0, "ChSub0", &subwindows[0]); if (e) subwindows[0] = NULL;
  e = toolbox_create_object(0, "ChSub1", &subwindows[1]); if (e) subwindows[1] = NULL;
  e = toolbox_create_object(0, "ChSub2", &subwindows[2]); if (e) subwindows[2] = NULL;
  e = toolbox_create_object(0, "ChSub3", &subwindows[3]); if (e) subwindows[3] = NULL;
  e = toolbox_create_object(0, "ChSub4", &subwindows[4]); if (e) subwindows[4] = NULL;
  e = toolbox_create_object(0, "ChSub5", &subwindows[5]); if (e) subwindows[5] = NULL;
  e = toolbox_create_object(0, "ChSub6", &subwindows[6]); if (e) subwindows[6] = NULL;
  e = toolbox_create_object(0, "ChSub7", &subwindows[7]); if (e) subwindows[7] = NULL;
  e = toolbox_create_object(0, "ChSub8", &subwindows[8]); if (e) subwindows[8] = NULL;
d395 2
d398 1
a398 23
  e         = event_register_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,       NULL);
  if (!e) e = event_register_toolbox_handler(-1, CDSet,                     choices_set_button_handler,        NULL);
  if (!e) e = event_register_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,       NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,   NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler,  NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler,  NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,      NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,   NULL);
  if (!e) e = event_register_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,      NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,       NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,      NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HiAgeTypeBt,           choices_timetype_m_button_handler, NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDTimeMenuClick,          choices_timetype_m_click_handler,  NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_TabInnerBordBt,        choices_bord_m_button_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_TabOuterBordBt,        choices_bord_m_button_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDBordMenuClick,          choices_bord_m_click_handler,      NULL);

  if ((window = choices_find_component(CD_FakePage)) != 0)
d400 28
a427 1
    if (!e) e = event_register_wimp_handler(window, Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
d429 1
a429 2

  if (!e) e = event_register_wimp_handler(idb->self_id, Wimp_EOpenWindow, choices_open_choice_window, NULL);
d467 4
d474 8
a481 12
/*************************************************/
/* choices_delete_subwindows()                   */
/*                                               */
/* Deletes all subwindows, reports any and all   */
/* errors occuring while deleting them.          */
/* Frees the structure holding the subwindows.   */
/*************************************************/

static void choices_delete_subwindows(void)
{
  _kernel_oserror *e;
  int count;
d483 1
a483 1
  for(count = 0; count < CDNoSubwindows; count++)
d485 4
a488 1
    if (subwindows[count])
d490 6
a495 3
      e = toolbox_delete_object(0, subwindows[count]);
      if (e) show_error_ret(e);
      subwindows[count] = 0;
d497 2
d500 1
a500 3
  free(subwindows);
  subwindows = NULL;
}
d517 3
a519 1
  ObjectId          window;
d529 4
a532 1
  /* Delete all subwindow objects */
d534 4
a537 1
  choices_delete_subwindows();
d539 22
a560 28
  free(new_choices);
  new_choices = NULL;
  free(new_typefaces);
  new_typefaces = NULL;

  /* Deregister choices event handlers */

  event_deregister_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,      NULL);
  event_deregister_toolbox_handler(-1, CDSet,                     choices_set_button_handler,       NULL);
  event_deregister_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,      NULL);
  event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,  NULL);
  event_deregister_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler, NULL);
  event_deregister_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler, NULL);
  event_deregister_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,  NULL);
  event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,      NULL);
  event_deregister_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECD_HiAgeTypeBt,           choices_timetype_m_button_handler,NULL);
  event_deregister_toolbox_handler(-1, ECDTimeMenuClick,          choices_timetype_m_click_handler, NULL);
  event_deregister_toolbox_handler(-1, ECD_TabInnerBordBt,        choices_bord_m_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECD_TabOuterBordBt,        choices_bord_m_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDBordMenuClick,          choices_bord_m_click_handler,     NULL);
d562 6
a567 5
  if ((window = choices_find_component(CD_FakePage)) != 0)
  {
    event_deregister_wimp_handler(window, Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
  }
  event_deregister_wimp_handler(idb->self_id, Wimp_EOpenWindow, choices_open_choice_window, NULL);
@


1.21
log
@Added comments to the beginning of all functions.  Cleaned up some of the
workings.
@
text
@d107 2
d2801 21
a2821 19
  int temp;
  if (new_choices->max_size == 0)
  {
    set_gadget_state(window, CD_HiMaxSizeLabl1, 1);
    set_gadget_state(window, CD_HiMaxSizeLabl2, 1);
    set_gadget_state(window, CD_HiMaxSize, 1);
    optionbutton_set_state(0, window, CD_HiDontSize, 0);
    max_size_greyed = 1;
    temp = 32;
  }
  else
  {
    set_gadget_state(window, CD_HiMaxSizeLabl1, 0);
    set_gadget_state(window, CD_HiMaxSizeLabl2, 0);
    set_gadget_state(window, CD_HiMaxSize, 0);
    optionbutton_set_state(0, window, CD_HiDontSize, 1);
    max_size_greyed = 0;
    temp = new_choices->max_size/1024;
  }
d2823 5
a2827 1
  choices_numberrange_set_value(0, window, CD_HiMaxSize, temp);
d2982 6
a2987 10
    case CD_TimeMinutes:
    return time * 60;
    case CD_TimeHours:
    return time * 60*60;
    case CD_TimeDays:
    return time * 60*60*24;
    case CD_TimeWeeks:
    return time * 60*60*24*7;
    case CD_TimeMonths:
    return time * 60*60*24*7*4;
d2989 19
a3007 1
  return 0;
a3025 1
  int temp;
d3028 6
a3033 41
    case CD_TimeMinutes:
    {
      temp = secs/60;
      if (temp > 60) temp = 60;
      if (temp < 1)  temp = 1;
      break;
    }

    case CD_TimeHours:
    {
      temp = secs/(60*60);
      if (temp > 24) temp = 24;
      if (temp < 1)  temp = 1;
      break;
    }
    case CD_TimeDays:
    {
      temp = secs/(60*60*24);
      if (temp > 7) temp = 7;
      if (temp < 1)  temp = 1;
      break;
    }
    case CD_TimeWeeks:
    {
      temp = secs/(60*60*24*7);
      if (temp > 4) temp = 4;
      if (temp < 1)  temp = 1;
      break;
    }
    case CD_TimeMonths:
    {
      temp = secs/(60*60*24*7*8*4);
      if (temp > 12) temp = 12;
      if (temp < 1)  temp = 1;
      break;
    }
    default:
    {
      temp = 1;
      break;
    }
a3034 1
  return temp;
d3052 5
a3056 4
  if (new_choices->expiry_age <= 60*60)    return CD_TimeMinutes;
  if (new_choices->expiry_age <= 60*60*24) return CD_TimeHours;
  if (new_choices->expiry_age <= 60*60*24*7) return CD_TimeDays;
  if (new_choices->expiry_age <= 60*60*24*7*4) return CD_TimeWeeks;
d3076 6
a3081 10
    case CD_TimeMinutes:
    return 60;
    case CD_TimeHours:
    return 24;
    case CD_TimeDays:
    return 7;
    case CD_TimeWeeks:
    return 4;
    case CD_TimeMonths:
    return 12;
a3082 1
  return 0;
@


1.20
log
@Following the last check-in - all build resources brought up to date.

Adjust-click on forwards/backwards buttons did not work in the intermediate
build, and now does.

Adjust-click on form submission buttons where the submit method is POST
will now work correctly, as the new view inherits the extradata block
of the old. Failure of this is signalled through
make_no_fetch_memory_error, code 16 (see updated Errors file in Docs).
Note the name change of extradata in this context; more details below.

The passing of forms POST data and extra headers for sending in an
HTTP request via. the URL module was all done through pointers into
flex blocks, and was therefore very unsafe. All relevant functions now
use pointers to pointers to the data.

To remove confusion on the umpteen uses of the word 'extradata', the field
in browser_data has been renamed to 'post_data'. The 'extradata' parameters
used within FetchPage.c were all disconnected from the extra header info /
form POST data stuff that extradata is usually associated with, and have
thus also been renamed, in this case to 'appnddata' (Append Data).

As well as X-NoProxy, the browser sends the 'proper' HTTP headers
Pragma:no-cache and Cache-Control:no-cache.

A redirection from a POST request was not handled correctly; despite
what HTTP specs say, you're supposed to use GET for the new URL. The
browser was, but when it chopped off the redundant header data in the
request didn't terminate it and left Content-Type in anyway...! Fixed.

Ctrl+Tab implemented - URL completion. Comes from the hotlist URLs,
hotlist titles, history hosts, paths, full URLs and lastly titles.
See code comments for more (history_find_match, hotlist_find_match).

TableSupport option added to Choices; it is read, can be set by the
front-end, but doesn't actually do anything else yet.

Reversed Choices' semantics on 'don't expire by...' for History. Added
'needs_redraw' flag to choices_get_contents so that, for example, if the
table border types change, browsers get redrawn.
@
text
@d103 1
a103 1
static void              choices_set_expiry_age_greyed   (int greyed, ObjectId window);
d106 1
d141 1
d628 1
a628 12
    set_gadget_state(window, CD_FontsTF1Labl, new_choices->system_font);
    set_gadget_state(window, CD_FontsTF1Disp, new_choices->system_font);
    set_gadget_state(window, CD_FontsTF1Bt,   new_choices->system_font);
    set_gadget_state(window, CD_FontsTF2Labl, new_choices->system_font);
    set_gadget_state(window, CD_FontsTF2Disp, new_choices->system_font);
    set_gadget_state(window, CD_FontsTF2Bt,   new_choices->system_font);
    set_gadget_state(window, CD_FontsTF3Labl, new_choices->system_font);
    set_gadget_state(window, CD_FontsTF3Disp, new_choices->system_font);
    set_gadget_state(window, CD_FontsTF3Bt,   new_choices->system_font);
    set_gadget_state(window, CD_FontsSize,    new_choices->system_font);
    set_gadget_state(window, CD_FontsSzLabl1, new_choices->system_font);
    set_gadget_state(window, CD_FontsSzLabl2, new_choices->system_font);
a1555 2
  ObjectId menu_id;
  int reqdsize;
d1562 1
a1562 8
  RetError(toolbox_create_object(0, "ChSave", &menu_id));

  RetError(menu_get_entry_text(0, menu_id, state, NULL, 0, &reqdsize));

  tempstring = malloc(reqdsize + 1);
  if (!tempstring) return make_no_memory_error(19);

  RetError(menu_get_entry_text(0, menu_id, state, tempstring, reqdsize+1, NULL));
a1580 2
  ObjectId menu_id;
  int reqdsize;
d1587 1
a1587 8
  RetError(toolbox_create_object(0, "ChDisplay", &menu_id));

  RetError(menu_get_entry_text(0, menu_id, state, NULL, 0, &reqdsize));

  tempstring = malloc(reqdsize+1);
  if (!tempstring) return make_no_memory_error(20);

  RetError(menu_get_entry_text(0, menu_id, state, tempstring, reqdsize+1, NULL));
d2040 1
a2040 12
      set_gadget_state(window, CD_FontsTF1Labl, new_choices->system_font);
      set_gadget_state(window, CD_FontsTF1Disp, new_choices->system_font);
      set_gadget_state(window, CD_FontsTF1Bt,   new_choices->system_font);
      set_gadget_state(window, CD_FontsTF2Labl, new_choices->system_font);
      set_gadget_state(window, CD_FontsTF2Disp, new_choices->system_font);
      set_gadget_state(window, CD_FontsTF2Bt,   new_choices->system_font);
      set_gadget_state(window, CD_FontsTF3Labl, new_choices->system_font);
      set_gadget_state(window, CD_FontsTF3Disp, new_choices->system_font);
      set_gadget_state(window, CD_FontsTF3Bt,   new_choices->system_font);
      set_gadget_state(window, CD_FontsSize,    new_choices->system_font);
      set_gadget_state(window, CD_FontsSzLabl1, new_choices->system_font);
      set_gadget_state(window, CD_FontsSzLabl2, new_choices->system_font);
d2089 1
a2089 1
    choices_set_expiry_age_greyed(!state, idb->self_id);
d2572 29
a2611 2
  ObjectId          menu_id;
  int               reqdsize;
d2623 1
a2623 8
  RetError(toolbox_create_object(0, "ChPlugin", &menu_id));

  RetError(menu_get_entry_text(0, menu_id, new_choices->plugin_control, NULL, 0, &reqdsize));

  tempstring = malloc(reqdsize + 1);
  if (!tempstring) return make_no_memory_error(19);

  RetError(menu_get_entry_text(0, menu_id, new_choices->plugin_control, tempstring, reqdsize+1, NULL));
d2730 6
a2745 2
    choices_set_expiry_age_greyed(1, window);
    optionbutton_set_state(0, window, CD_HiDontAge, 0);
a2748 1
    expiry_age_greyed = 1;
a2754 3
    choices_set_expiry_age_greyed(0, window);
    optionbutton_set_state(0, window, CD_HiDontAge, 1);
    expiry_age_greyed = 0;
d2756 5
d2768 9
d2779 1
a2779 1
static void choices_set_expiry_age_greyed(int greyed, ObjectId window)
d2781 4
a2784 14
  if (greyed)
  {
    set_gadget_state(window, CD_HiExpiryAgeLabl, 1);
    set_gadget_state(window, CD_HiExpiryAge, 1);
    set_gadget_state(window, CD_HiAgeTypeDisp, 1);
    set_gadget_state(window, CD_HiAgeTypeBt, 1);
  }
  else
  {
    set_gadget_state(window, CD_HiExpiryAgeLabl, 0);
    set_gadget_state(window, CD_HiExpiryAge, 0);
    set_gadget_state(window, CD_HiAgeTypeDisp, 0);
    set_gadget_state(window, CD_HiAgeTypeBt, 0);
  }
d2789 6
a2837 1
  int               reqdsize;
d2851 1
a2851 1
  RetError(menu_get_entry_text(0, menu_id, timetype, NULL, 0, &reqdsize));
a2861 5
  tempstring = malloc(reqdsize + 1);
  if (!tempstring) return make_no_memory_error(19);

  RetError(menu_get_entry_text(0, menu_id, timetype, tempstring, reqdsize+1, NULL));

d2871 3
d2929 5
d2958 10
d2990 10
d3054 9
d3076 8
d3106 9
d3119 6
a3124 6
  set_gadget_state(window, CD_TabInnerBordLabl, state);
  set_gadget_state(window, CD_TabInnerBordDisp, state);
  set_gadget_state(window, CD_TabInnerBordBt,   state);
  set_gadget_state(window, CD_TabOuterBordLabl, state);
  set_gadget_state(window, CD_TabOuterBordDisp, state);
  set_gadget_state(window, CD_TabOuterBordBt,   state);
a3136 2
  ObjectId menu_id;
  int reqdsize;
d3143 1
a3143 8
  RetError(toolbox_create_object(0, "ChTabBord", &menu_id));

  RetError(menu_get_entry_text(0, menu_id, state, NULL, 0, &reqdsize));

  tempstring = malloc(reqdsize+1);
  if (!tempstring) return make_no_memory_error(20);

  RetError(menu_get_entry_text(0, menu_id, state, tempstring, reqdsize+1, NULL));
d3227 4
d3255 35
@


1.19
log
@Implemented history expiry and table border choices.
@
text
@d706 1
d814 10
d910 14
a923 2

      if (!b->use_source_cols || (b->background_colour == -1 && b->background_image == -1))
d2127 2
a2128 2
    choices_set_expiry_age_greyed(!!state, idb->self_id);
    expiry_age_greyed = !!state;
d2132 4
a2135 4
    set_gadget_state(idb->self_id, CD_HiMaxSizeLabl1, !!state);
    set_gadget_state(idb->self_id, CD_HiMaxSize, !!state);
    set_gadget_state(idb->self_id, CD_HiMaxSizeLabl2, !!state);
    max_size_greyed = !!state;
d2759 1
a2759 1
    optionbutton_set_state(0, window, CD_HiDontAge, 1);
d2771 1
a2771 1
    optionbutton_set_state(0, window, CD_HiDontAge, 0);
d2813 1
a2813 1
    optionbutton_set_state(0, window, CD_HiDontSize, 1);
d2822 1
a2822 1
    optionbutton_set_state(0, window, CD_HiDontSize, 0);
@


1.18
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d81 5
d101 7
d131 4
d146 6
d306 5
a310 1
    if (!subwindows) ChkError(toolbox_hide_object(0, idb->self_id));
d379 21
a399 16
  e         = event_register_toolbox_handler(-1, ECDRG2,                    choices_radio_click_handler,      NULL);
  if (!e) e = event_register_toolbox_handler(-1, CDSet,                     choices_set_button_handler,       NULL);
  if (!e) e = event_register_toolbox_handler(-1, CDCancel,                  choices_cancel_button_handler,    NULL);
  if (!e) e = event_register_toolbox_handler(-1, CDSaveButton,              choices_save_button_handler,      NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_EncodingMenuBt,        choices_encoding_button_handler,  NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_ColourButton,          choices_colour_button_handler,    NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HlDispBt,              choices_display_m_button_handler, NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HiDispBt,              choices_display_m_button_handler, NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HlSaveBt,              choices_save_m_button_handler,    NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HiSaveBt,              choices_save_m_button_handler,    NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDSaveMenuClick,          choices_save_m_click_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDDispMenuClick,          choices_display_m_click_handler,  NULL);
  if (!e) e = event_register_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_FontButton,            choices_font_button_handler,      NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_ObjPlugBt,             choices_plug_m_button_handler,    NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDPlugMenuClick,          choices_plug_m_click_handler,     NULL);
d428 5
d525 5
d614 2
a615 2
  if ((window = choices_find_component(CD_HiLines))        != 0) choices_numberrange_set_value(0,  window, CD_HiLines,    new_choices->expiry_age);
  if ((window = choices_find_component(CD_HiMaxSize))      != 0) choices_numberrange_set_value(0,  window, CD_HiMaxSize,  new_choices->max_size);
d659 16
d707 1
d746 25
a770 2
  if ((window = choices_find_component(CD_HiLines))        != 0) numberrange_get_value(0, window, CD_HiLines,      &new_choices->expiry_age);
  if ((window = choices_find_component(CD_HiMaxSize))      != 0) numberrange_get_value(0, window, CD_HiMaxSize,    &new_choices->max_size);
d950 4
d957 5
d982 3
d986 1
a986 7
  if ((choices.background_colour != new_choices->background_colour) ||
      (choices.text_colour       != new_choices->text_colour)       ||
      (choices.link_colour       != new_choices->link_colour)       ||
      (choices.used_colour       != new_choices->used_colour)       ||
      (choices.followed_colour   != new_choices->followed_colour)   ||
      (choices.selected_colour   != new_choices->selected_colour)   ||
      (choices.underline_links   != new_choices->underline_links))
d988 14
a1001 6
    update_fake = 1;
  }
  else
  {
    update_fake = 0;
  }
d1003 1
a1003 1
  memcpy(new_choices, &choices, sizeof(global_choices));
d1005 6
a1010 6
  tfptr = fm_find_typeface("serif");
  memcpy(&new_typefaces[0], tfptr, sizeof(fm_typeface));
  tfptr = fm_find_typeface("sans");
  memcpy(&new_typefaces[1], tfptr, sizeof(fm_typeface));
  tfptr = fm_find_typeface("fixed");
  memcpy(&new_typefaces[2], tfptr, sizeof(fm_typeface));
d1012 1
a1012 1
  choices_set_contents();
d1014 1
a1014 1
  /* Attempt to redraw fake page display */
d1016 6
a1021 1
  if (update_fake && (window = choices_find_component(CD_FakePage)) != 0) button_set_flags(0, window, CD_FakePage, 0, 0);
d1044 3
d1062 5
d1780 2
a1781 2
    ministring[0] = consonant[rand()%sizeof(consonant)];
    ministring[1] = vowel[rand()%sizeof(vowel)];
d1785 2
a1786 2
      ministring[2] = consonant[rand()%sizeof(consonant)];
      ministring[3] = vowel[rand()%sizeof(vowel)];
d2103 17
d2155 1
a2155 1
  toolbox_show_object(0, idb->self_id, Toolbox_ShowObject_FullSpec, &(event->open_window_request.visible_area), 0, -1);
d2719 476
@


1.17
log
@Added system font option to choices.
Stopped UNIFONT forcing system font use and added calls to Font_WideFormat.
Made sure the system font option is read before fm_init is called!

User agent string now set if Netscape faking is disabled (format used is
"Acorn Browse/1.26 (RISC OS 3.71)".
@
text
@d573 2
a574 2
  if ((window = choices_find_component(CD_HiLines))        != 0) choices_numberrange_set_value(0,  window, CD_HiLines,    new_choices->v_hist_size);
  if ((window = choices_find_component(CD_HiMaxSize))      != 0) choices_numberrange_set_value(0,  window, CD_HiMaxSize,  new_choices->g_hist_size);
d688 2
a689 2
  if ((window = choices_find_component(CD_HiLines))        != 0) numberrange_get_value(0, window, CD_HiLines,      &new_choices->v_hist_size);
  if ((window = choices_find_component(CD_HiMaxSize))      != 0) numberrange_get_value(0, window, CD_HiMaxSize,    &new_choices->g_hist_size);
@


1.16
log
@Implemented proxy choices.
@
text
@d543 1
a543 2
  _kernel_oserror * e;
  unsigned int      flags, temp, frac;
d582 17
d605 2
a606 2
  temp = ((temp >> 4) * 10) + todecimal[frac]
  ;
d612 4
a615 21
    e = gadget_get_flags(0, window, CD_ObjPlugLabl, &flags);
    if (!e)
    {
      if (new_choices->support_object) flags &= ~(1u<<31); else flags |= (1u<<31);
      gadget_set_flags(0, window, CD_ObjPlugLabl, flags);
    }

    e = gadget_get_flags(0, window, CD_ObjPlugBt, &flags);
    if (!e)
    {
      if (new_choices->support_object) flags &= ~(1u<<31); else flags |= (1u<<31);
      gadget_set_flags(0, window, CD_ObjPlugBt, flags);
    }

    e = gadget_get_flags(0, window, CD_ObjPlugDisp, &flags);
    if (!e)
    {
      if (new_choices->support_object) flags &= ~(1u<<31); else flags |= (1u<<31);
      gadget_set_flags(0, window, CD_ObjPlugDisp, flags);
      choices_set_plugin_field();
    }
d621 3
a623 13
    e = gadget_get_flags(0, window, CD_NetProxyAddr, &flags);
    if (!e)
    {
      if (new_choices->use_proxy) flags &= ~(1u<<31); else flags |= (1u<<31);
      gadget_set_flags(0, window, CD_NetProxyAddr, flags);
    }

    e = gadget_get_flags(0, window, CD_NetProxyLabl, &flags);
    if (!e)
    {
      if (new_choices->use_proxy) flags &= ~(1u<<31); else flags |= (1u<<31);
      gadget_set_flags(0, window, CD_NetProxyLabl, flags);
    }
a624 1
  if ((window = choices_find_component(CD_NetProxyAddr))       != 0) choices_writablefield_set_value(0, window, CD_NetProxyAddr, new_choices->proxy_address);
d649 1
a649 1
  int                       old_font_size, frac;
d724 2
a725 1
  if ((window = choices_find_component(CD_FontsSize))      != 0)
d759 3
a761 1
  if (choices.font_size != old_font_size)
d766 1
a1903 2
  _kernel_oserror * e;
  unsigned int      flags;
d1932 3
a1934 4
    case CD_ObjHandle:
    new_choices->support_object = !!state;

    if ((window = choices_find_component(CD_ObjPlugDisp))    != 0)
d1936 14
a1949 2
      e = gadget_get_flags(0, window, CD_ObjPlugLabl, &flags);
      if (!e)
d1951 19
a1969 2
        if (new_choices->support_object) flags &= ~(1u<<31); else flags |= (1u<<31);
        gadget_set_flags(0, window, CD_ObjPlugLabl, flags);
d1971 2
d1974 2
a1975 6
      e = gadget_get_flags(0, window, CD_ObjPlugBt, &flags);
      if (!e)
      {
        if (new_choices->support_object) flags &= ~(1u<<31); else flags |= (1u<<31);
        gadget_set_flags(0, window, CD_ObjPlugBt, flags);
      }
d1977 6
a1982 7
      e = gadget_get_flags(0, window, CD_ObjPlugDisp, &flags);
      if (!e)
      {
        if (new_choices->support_object) flags &= ~(1u<<31); else flags |= (1u<<31);
        gadget_set_flags(0, window, CD_ObjPlugDisp, flags);
        choices_set_plugin_field();
      }
d1990 2
a1991 13
      e = gadget_get_flags(0, window, CD_NetProxyAddr, &flags);
      if (!e)
      {
        if (new_choices->use_proxy) flags &= ~(1u<<31); else flags |= (1u<<31);
        gadget_set_flags(0, window, CD_NetProxyAddr, flags);
      }

      e = gadget_get_flags(0, window, CD_NetProxyLabl, &flags);
      if (!e)
      {
        if (new_choices->use_proxy) flags &= ~(1u<<31); else flags |= (1u<<31);
        gadget_set_flags(0, window, CD_NetProxyLabl, flags);
      }
d2275 2
a2276 2
/* Opens a colour dialogue box with appropriate  */
/* settings for the current colour.              */
@


1.15
log
@Fixed bug with font size clipping in main.c.
Implemented font size choices.
@
text
@d66 3
a68 2
static char *consonant                = "bcdfghjklmnpqrstvwxyz";
static char *vowel                    = "aeiou";
d272 2
d619 19
d703 32
d736 6
a741 3
  if ((window = choices_find_component(CD_FontsSize))      != 0) numberrange_get_value(0, window, CD_FontsSize,    &new_choices->font_size);
  frac = new_choices->font_size % 10;
  new_choices->font_size = ((new_choices->font_size / 10)<<4) + fromdecimal[frac];
d1629 1
a1629 1
/* choices_write_crap()                          */
d1657 1
a1657 1
static _kernel_oserror * choices_write_crap(fm_face h,
d1830 1
a1830 1
      ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, 1));
d1839 1
a1839 1
        ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, 2));
d1841 1
a1841 1
        ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, 3));
d1851 1
a1851 1
        ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, 4));
d1853 1
a1853 1
        ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, 5));
d1863 1
a1863 1
        ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, 6));
d1865 1
a1865 1
        ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, 7));
d1874 1
a1874 1
        ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, 12));
d1876 1
a1876 1
        ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, 9));
d1884 1
a1884 1
      ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, 10));
d1943 2
a1946 2
      new_choices->support_object = !!state;

d1967 20
@


1.14
log
@Now handles PARAM tags. Sorted out Plug-In bug that was related to Java
setting a 0 by 0 graphics window before calling Wimp_Poll (fixed in Java).
Implemented queue for Plug-Ins so multiple broadcasts aren't sent for
several Objects in one data chunk.

Added Docs directory with some documentation in it. More things to keep
checking for stylistic consistency, horray ;-)

Corrected !Run[D] for Ursula build to need AcornURI but not TaskModule
(URI handler needed for !Mail to pick up mailto: links).

Added display_height field to browser_data, analogous to display_width,
to cope with % sized objects by width and height (see how HRs are
handled in Redraw.c for an example of how it was always fairly easy
with width, but not height until this addition). Though you do have
to reload to get a new size; reformat isn't enough. Must see to this
some time...

Fixed bug where basic typefaces were claimed *before* the Choices file
had been read. For unusual Choices settings, this could create some
'interesting' problems now and again. This was part of narrower scope
work in the Choices code to allow font changing without leaking font
handles (now done; fm_shutdown only ditches fonts, it keeps internal
structures - must then call  fm_lose_fonts for all browsers to get the
bitfields up to date, then rewrite the typeface definitions and reclaim
basic fonts). Noticed that fm_claim_basic_typefaces would claim multiple
instances of the same font if there were several cases of the same font
mapped to different typeface styles - fixed.

Implemented PlugInControl settings, but not SupportObject (fully).
@
text
@d69 4
d541 1
a541 1
  unsigned int      flags;
d584 6
d639 1
d681 5
d711 8
@


1.13
log
@Font choices added (currently doesn't free old browser fonts).
@
text
@d369 1
d576 4
a580 1

a605 4
  if ((window = choices_find_component(CD_FontsTF1Disp))   != 0) choices_displayfield_set_value(0, window, CD_FontsTF1Disp, new_typefaces[0].fontnames[0]);
  if ((window = choices_find_component(CD_FontsTF2Disp))   != 0) choices_displayfield_set_value(0, window, CD_FontsTF2Disp, new_typefaces[1].fontnames[0]);
  if ((window = choices_find_component(CD_FontsTF3Disp))   != 0) choices_displayfield_set_value(0, window, CD_FontsTF3Disp, new_typefaces[2].fontnames[0]);

d626 3
a628 1
  int                       changed;
d672 3
a674 1
  changed = 0;
d677 1
d680 1
a680 2
    if (memcmp(tfptr, &new_typefaces[0], sizeof(fm_typeface))) changed = 1;
    memcpy(tfptr, &new_typefaces[0], sizeof(fm_typeface));
d682 1
d684 1
d687 1
a687 2
    if (memcmp(tfptr, &new_typefaces[1], sizeof(fm_typeface))) changed = 1;
    memcpy(tfptr, &new_typefaces[1], sizeof(fm_typeface));
d689 1
d691 1
d694 1
a694 2
    if (memcmp(tfptr, &new_typefaces[2], sizeof(fm_typeface))) changed = 1;
    memcpy(tfptr, &new_typefaces[2], sizeof(fm_typeface));
d697 22
a718 1
  /* Update browsers */
d724 1
a724 1
    if (changed)
d726 3
a728 1
      // NEEDS TO GET BROWSERS TO GET RID OF THEIR FONT HANDLES
d769 8
d1720 1
a1720 1
        ChkError(fm_font_box(h, &fbox));
d1722 1
@


1.12
log
@Minimal support for font choices added, fixed problem with colour changing with
browsers with no background colour specified.  Options for Objects implemented.
@
text
@d57 1
d69 3
a71 7
static ObjectId * subwindows          = NULL;
static int        current_subwindow   = 0;
static ObjectId   colourdbox_id       = 0;

static int        save_ticked         = -1;
static int        disp_ticked         = -1;
static int        plug_ticked         = -1;
d73 3
a75 1
static int        choices_modechanged = 0;
d77 6
a82 2
global_choices  * new_choices         = NULL;
ObjectId          choices_windowid    = 0;
d287 1
d295 24
d458 5
d602 4
d625 2
d670 21
d697 1
a697 1
    if (b->background_colour == -1)
d699 5
a703 1
      b->antialias_colour = redraw_backcol(b);
d705 6
d712 4
a715 4
    /* The Choices are only used directly for browsers which are */
    /* set to override document colours. Otherwise defaults will */
    /* have been read locally and possibly overridden by HTML,   */
    /* and a reload will be needed to reflect the changes.       */
d717 4
a720 4
    if (!b->use_source_cols || (b->background_colour == -1 && b->background_image == -1))
    {
      s.window_handle = b->window_handle;
      RetError(wimp_get_window_state(&s));
d722 1
a722 1
      coords_box_toworkarea(&s.visible_area, (WimpRedrawWindowBlock *) &s);
d724 5
a728 5
      RetError(wimp_force_redraw(b->window_handle,
                                 s.visible_area.xmin,
                                 s.visible_area.ymin,
                                 s.visible_area.xmax,
                                 s.visible_area.ymax));
d730 4
a733 3
      if (b->background_colour == -1)
      {
        b->antialias_colour = choices.background_colour;
d781 1
d800 7
d2144 1
d2192 10
d2255 1
a2255 1
  char font[4] [128], *p, *p2;
d2257 1
d2301 3
a2303 3
    case CD_FontsTF1Bt: break;
    case CD_FontsTF2Bt: break;
    case CD_FontsTF3Bt: break;
d2310 5
d2388 1
a2388 1
/* choices_save_m_button_handler()               */
@


1.11
log
@Stopped various displays being redrawn unnecessarily when cancel is pressed
in main choices dialogue.
@
text
@d42 1
d53 1
d69 1
a69 1
static int        current_subwindow   = CDSubNone;
d74 1
d86 4
d104 3
d109 2
d256 1
d305 4
a308 1
  ChkError(choices_show_subwindow(idb->self_id, 0));
d310 1
a310 1
  ChkError(radiobutton_set_state(0, idb->self_id, CDFirstSubRadio + 0, 1));
d318 16
a333 13
  e         = event_register_toolbox_handler(-1, ECDRG2,             choices_radio_click_handler,      NULL);
  if (!e) e = event_register_toolbox_handler(-1, CDSet,              choices_set_button_handler,       NULL);
  if (!e) e = event_register_toolbox_handler(-1, CDCancel,           choices_cancel_button_handler,    NULL);
  if (!e) e = event_register_toolbox_handler(-1, CDSaveButton,       choices_save_button_handler,      NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_EncodingMenuBt, choices_encoding_button_handler,  NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_ColourButton,   choices_colour_button_handler,    NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HlDispBt,       choices_display_m_button_handler, NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HiDispBt,       choices_display_m_button_handler, NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HlSaveBt,       choices_save_m_button_handler,    NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECD_HiSaveBt,       choices_save_m_button_handler,    NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDSaveMenuClick,   choices_save_m_click_handler,     NULL);
  if (!e) e = event_register_toolbox_handler(-1, ECDDispMenuClick,   choices_display_m_click_handler,  NULL);
  if (!e) e = event_register_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler, NULL);
d345 16
a360 13
    event_deregister_toolbox_handler(-1, ECDRG2,             choices_radio_click_handler,      NULL);
    event_deregister_toolbox_handler(-1, CDSet,              choices_set_button_handler,       NULL);
    event_deregister_toolbox_handler(-1, CDCancel,           choices_cancel_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, CDSaveButton,       choices_save_button_handler,      NULL);
    event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt, choices_encoding_button_handler,  NULL);
    event_deregister_toolbox_handler(-1, ECD_ColourButton,   choices_colour_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECD_HlDispBt,       choices_display_m_button_handler, NULL);
    event_deregister_toolbox_handler(-1, ECD_HiDispBt,       choices_display_m_button_handler, NULL);
    event_deregister_toolbox_handler(-1, ECD_HlSaveBt,       choices_save_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECD_HiSaveBt,       choices_save_m_button_handler,    NULL);
    event_deregister_toolbox_handler(-1, ECDSaveMenuClick,   choices_save_m_click_handler,     NULL);
    event_deregister_toolbox_handler(-1, ECDDispMenuClick,   choices_display_m_click_handler,  NULL);
    event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler, NULL);
d417 3
d432 16
a447 13
  event_deregister_toolbox_handler(-1, ECDRG2,             choices_radio_click_handler,      NULL);
  event_deregister_toolbox_handler(-1, CDSet,              choices_set_button_handler,       NULL);
  event_deregister_toolbox_handler(-1, CDCancel,           choices_cancel_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, CDSaveButton,       choices_save_button_handler,      NULL);
  event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt, choices_encoding_button_handler,  NULL);
  event_deregister_toolbox_handler(-1, ECD_ColourButton,   choices_colour_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECD_HlDispBt,       choices_display_m_button_handler, NULL);
  event_deregister_toolbox_handler(-1, ECD_HiDispBt,       choices_display_m_button_handler, NULL);
  event_deregister_toolbox_handler(-1, ECD_HlSaveBt,       choices_save_m_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECD_HiSaveBt,       choices_save_m_button_handler,    NULL);
  event_deregister_toolbox_handler(-1, ECDSaveMenuClick,   choices_save_m_click_handler,     NULL);
  event_deregister_toolbox_handler(-1, ECDDispMenuClick,   choices_display_m_click_handler,  NULL);
  event_deregister_toolbox_handler(-1, OptionButton_StateChanged, choices_option_state_handler, NULL);
d456 1
d501 4
a504 1
  ObjectId window;
d542 27
d589 2
a590 2
  /* The lack of error chechking is to allow */
  /* items to be missing from the dialogue.  */
d637 5
d647 1
a647 1
    if (!b->use_source_cols)
d659 5
d1712 5
a1716 2
  int      state;
  ObjectId window;
d1744 29
d1860 1
a1860 1
  _kernel_oserror * e;
d1891 1
a1891 1
  _kernel_oserror * e;
d1922 1
a1922 1
  _kernel_oserror * e;
d1952 1
a1952 1
  _kernel_oserror * e;
d1962 395
@


1.10
log
@Added Client pull, 'Netscape compatiblility' and frames support options.
@
text
@d105 5
d475 1
a475 1
  if ((window = choices_find_component(CD_Homepage))       != 0) writablefield_set_value(0, window, CD_Homepage,       new_choices->home_page);
d482 1
a482 1
  choices_set_encoding_field(); //
d496 2
a497 2
  if ((window = choices_find_component(CD_HlAutoOpen))     != 0) numberrange_set_value(0,  window, CD_HlAutoOpen,   new_choices->auto_open_delay);
  if ((window = choices_find_component(CD_HlAutoScroll))   != 0) numberrange_set_value(0,  window, CD_HlAutoScroll, new_choices->auto_scroll_delay);
d501 2
a502 2
  if ((window = choices_find_component(CD_HiLines))        != 0) numberrange_set_value(0,  window, CD_HiLines,    new_choices->v_hist_size);
  if ((window = choices_find_component(CD_HiMaxSize))      != 0) numberrange_set_value(0,  window, CD_HiMaxSize,  new_choices->g_hist_size);
a638 1
  _kernel_oserror *e = NULL;
d640 16
d663 1
a663 3
  if ((window = choices_find_component(CD_FakePage)) != 0) button_set_flags(0, window, CD_FakePage, 0, 0);

  if (e) show_error_ret(e);
d745 2
a746 1
      e = displayfield_set_value(0, destwind, CD_EncodingDisply, textptr);
d749 1
a749 4
      if (e)
      {
        return e;
      }
d760 1
a760 1
    RetError(displayfield_set_value(0, destwind, CD_EncodingDisply, "Unknown encoding")); //
d1017 1
a1017 1
  return button_set_validation(0, window, component, newvalidation);
d1193 1
a1193 1
  e = displayfield_set_value(0, obj, comp, tempstring);
d1227 1
a1227 1
  e = displayfield_set_value(0, obj, comp, tempstring);
d1711 2
d1738 3
d1742 27
d1770 88
a1857 4
    if (subwindows[findwindow])
    {
      if (!gadget_get_flags(0, subwindows[findwindow], component, &flags)) return subwindows[findwindow];
    }
d1860 1
a1860 1
  return 0;
@


1.9
log
@Choices now allows gadgets to be in any subwindow with some limitations which
are addressed in the header file.  Also there is no longer a concept of named
subwindows.
@
text
@d470 5
a474 5
  if ((window = choices_find_component(CD_Homepage))       != 0) writablefield_set_value(0, window, CD_Homepage, new_choices->home_page);
  if ((window = choices_find_component(CD_UnderlineLinks)) != 0) optionbutton_set_state(0, window, CD_UnderlineLinks, new_choices->underline_links);
  if ((window = choices_find_component(CD_UseDocColours))  != 0) optionbutton_set_state(0, window, CD_UseDocColours,  new_choices->use_source_cols);
  if ((window = choices_find_component(CD_ShowForeground)) != 0) optionbutton_set_state(0, window, CD_ShowForeground, new_choices->show_foreground);
  if ((window = choices_find_component(CD_ShowBackground)) != 0) optionbutton_set_state(0, window, CD_ShowBackground, new_choices->show_background);
d491 4
a494 4
  if ((window = choices_find_component(CD_HlAutoOpen))     != 0) numberrange_set_value(0, window, CD_HlAutoOpen, new_choices->auto_open_delay);
  if ((window = choices_find_component(CD_HlAutoScroll))   != 0) numberrange_set_value(0, window, CD_HlAutoScroll, new_choices->auto_scroll_delay);
  if ((window = choices_find_component(CD_HlDispDisp))     != 0) choices_set_display_field(window, CD_HlDispDisp, new_choices->hotlist_show);
  if ((window = choices_find_component(CD_HlSaveDisp))     != 0) choices_set_save_field(window, CD_HlSaveDisp, new_choices->save_hotlist);
d496 2
a497 2
  if ((window = choices_find_component(CD_HiLines))        != 0) numberrange_set_value(0, window, CD_HiLines,   new_choices->v_hist_size);
  if ((window = choices_find_component(CD_HiMaxSize))      != 0) numberrange_set_value(0, window, CD_HiMaxSize, new_choices->g_hist_size);
d499 5
a503 1
  if ((window = choices_find_component(CD_HiSaveDisp))     != 0) choices_set_save_field(window, CD_HiSaveDisp, new_choices->save_history);
d562 2
a563 3

  if ((window = choices_find_component(CD_HiLines))        != 0) numberrange_get_value(0, window, CD_HiLines,   &new_choices->v_hist_size);
  if ((window = choices_find_component(CD_HiMaxSize))      != 0) numberrange_get_value(0, window, CD_HiMaxSize, &new_choices->g_hist_size);
d1651 4
@


1.8
log
@Added runtime detection of editable colours for fake page display.
@
text
@d63 2
a64 2
char *consonant = "bcdfghjklmnpqrstvwxyz";
char *vowel = "aeiou";
d66 3
a68 3
static int      * subwindows        = NULL;
static ObjectId   current_subwindow = CDSubNone;
static ObjectId   colourdbox_id     = 0;
d70 2
a71 2
static int        save_ticked = -1;
static int        disp_ticked = -1;
d75 2
a76 2
global_choices  * new_choices       = NULL;
ObjectId          choices_windowid  = 0;
d99 1
d103 1
d238 1
d275 11
a285 9
  e = toolbox_create_object(0, "ChSub0", subwindows + CDSubBrowseDefaults); if (e) subwindows[CDSubBrowseDefaults] = NULL;
  e = toolbox_create_object(0, "ChSub1", subwindows + CDSubWindows);        if (e) subwindows[CDSubWindows]        = NULL;
  e = toolbox_create_object(0, "ChSub2", subwindows + CDSubColours);        if (e) subwindows[CDSubColours]        = NULL;
  e = toolbox_create_object(0, "ChSub3", subwindows + CDSubFonts);          if (e) subwindows[CDSubFonts]          = NULL;
  e = toolbox_create_object(0, "ChSub4", subwindows + CDSubHotlist);        if (e) subwindows[CDSubHotlist]        = NULL;
  e = toolbox_create_object(0, "ChSub5", subwindows + CDSubHistory);        if (e) subwindows[CDSubHistory]        = NULL;
  e = toolbox_create_object(0, "ChSub6", subwindows + CDSubSub6);           if (e) subwindows[CDSubSub6]           = NULL;
  e = toolbox_create_object(0, "ChSub7", subwindows + CDSubSub7);           if (e) subwindows[CDSubSub7]           = NULL;
  e = toolbox_create_object(0, "ChSub8", subwindows + CDSubSub8);           if (e) subwindows[CDSubSub8]           = NULL;
d287 1
a287 1
  ChkError(choices_show_subwindow(idb->self_id, CDSubBrowseDefaults));
d289 1
a289 1
  ChkError(radiobutton_set_state(0, idb->self_id, CDBrowseDefaults, 1));
d309 6
a314 1
  if (!e) e = event_register_toolbox_handler(subwindows[CDSubBrowseDefaults], OptionButton_StateChanged, choices_option_state_handler, NULL);
a315 1
  if (!e) e = event_register_wimp_handler(*(subwindows + CDSubColours), Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
d333 6
a338 1
    event_deregister_toolbox_handler(subwindows[CDSubBrowseDefaults], OptionButton_StateChanged, choices_option_state_handler, NULL);
a339 1
    event_deregister_wimp_handler(*(subwindows + CDSubColours), Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
d389 1
d414 1
a414 1
  event_deregister_toolbox_handler(subwindows[CDSubBrowseDefaults], OptionButton_StateChanged, choices_option_state_handler, NULL);
d416 4
a419 1
  event_deregister_wimp_handler(*(subwindows + CDSubColours), Wimp_ERedrawWindow, choices_redraw_fakepage_handler, NULL);
d439 5
a443 1
  ObjectId window;
d445 1
a445 1
  switch(idb->self_component)
d447 3
a449 11
    case CDBrowseDefaults: window = CDSubBrowseDefaults; break;
    case CDWindows:        window = CDSubWindows;        break;
    case CDColours:        window = CDSubColours;        break;
    case CDFonts:          window = CDSubFonts;          break;
    case CDHotlist:        window = CDSubHotlist;        break;
    case CDHistory:        window = CDSubHistory;        break;
    case CDSub6:           window = CDSubSub6;           break;
    case CDSub7:           window = CDSubSub7;           break;
    case CDSub8:           window = CDSubSub8;           break;

    default:               window = CDNoSubwindows;      break;
a451 2
  choices_show_subwindow(idb->self_id, window);

d467 1
d470 30
a499 51
  if (subwindows[CDSubBrowseDefaults])
  {
    writablefield_set_value(0, subwindows[CDSubBrowseDefaults], CD_Homepage, new_choices->home_page);

    optionbutton_set_state(0, subwindows[CDSubBrowseDefaults], CD_UnderlineLinks, new_choices->underline_links);
    optionbutton_set_state(0, subwindows[CDSubBrowseDefaults], CD_UseDocColours,  new_choices->use_source_cols);
    optionbutton_set_state(0, subwindows[CDSubBrowseDefaults], CD_ShowForeground, new_choices->show_foreground);
    optionbutton_set_state(0, subwindows[CDSubBrowseDefaults], CD_ShowBackground, new_choices->show_background);

    /* Get encoding name */

    choices_set_encoding_field();
  }

  if (subwindows[CDSubWindows])
  {
    optionbutton_set_state(0, subwindows[CDSubWindows], CD_URLBar,     new_choices->url_bar);
    optionbutton_set_state(0, subwindows[CDSubWindows], CD_StatusBar,  new_choices->status_bar);
    optionbutton_set_state(0, subwindows[CDSubWindows], CD_ButtonBar,  new_choices->button_bar);
    optionbutton_set_state(0, subwindows[CDSubWindows], CD_FullScreen, new_choices->full_screen);
  }

  if (subwindows[CDSubColours])
  {
    choices_colour_set_component(subwindows[CDSubColours], CD_BackColour, new_choices->background_colour);
    choices_colour_set_component(subwindows[CDSubColours], CD_TextColour, new_choices->text_colour);
    choices_colour_set_component(subwindows[CDSubColours], CD_LinkColour, new_choices->link_colour);
    choices_colour_set_component(subwindows[CDSubColours], CD_UsedColour, new_choices->used_colour);
    choices_colour_set_component(subwindows[CDSubColours], CD_FolwColour, new_choices->followed_colour);
    choices_colour_set_component(subwindows[CDSubColours], CD_SlctColour, new_choices->selected_colour);
  }

  if (subwindows[CDSubHotlist])
  {
    numberrange_set_value(0, subwindows[CDSubHotlist], CD_HlAutoOpen,   new_choices->auto_open_delay);
    numberrange_set_value(0, subwindows[CDSubHotlist], CD_HlAutoScroll, new_choices->auto_scroll_delay);

    choices_set_display_field(subwindows[CDSubHotlist], CD_HlDispDisp, new_choices->hotlist_show);

    choices_set_save_field(subwindows[CDSubHotlist], CD_HlSaveDisp, new_choices->save_hotlist);
  }

  if (subwindows[CDSubHistory])
  {
    numberrange_set_value(0, subwindows[CDSubHistory], CD_HiLines,   new_choices->v_hist_size);
    numberrange_set_value(0, subwindows[CDSubHistory], CD_HiMaxSize, new_choices->g_hist_size);

    choices_set_display_field(subwindows[CDSubHistory], CD_HiDispDisp, new_choices->show_urls);

    choices_set_save_field(subwindows[CDSubHistory], CD_HiSaveDisp, new_choices->save_history);
  }
d517 1
a518 1
  int                       state;
d524 1
a524 1
  if (subwindows[CDSubBrowseDefaults])
d526 1
a526 1
    e = writablefield_get_value(0, subwindows[CDSubBrowseDefaults], CD_Homepage, NULL, 0, &reqsize);
d534 1
a534 1
        e = writablefield_get_value(0, subwindows[CDSubBrowseDefaults], CD_Homepage, tempstring, reqsize, NULL);
d556 2
a557 4
  if (subwindows[CDSubWindows])
  {
    e = optionbutton_get_state(0, subwindows[CDSubWindows], CD_URLBar,     &state);
    if (!e) new_choices->url_bar     = !!state;
d559 2
a560 21
    e = optionbutton_get_state(0, subwindows[CDSubWindows], CD_StatusBar,  &state);
    if (!e) new_choices->status_bar  = !!state;

    e = optionbutton_get_state(0, subwindows[CDSubWindows], CD_ButtonBar,  &state);
    if (!e) new_choices->button_bar  = !!state;

    e = optionbutton_get_state(0, subwindows[CDSubWindows], CD_FullScreen, &state);
    if (!e) new_choices->full_screen = !!state;
  }

  if (subwindows[CDSubHotlist])
  {
    numberrange_get_value(0, subwindows[CDSubHotlist], CD_HlAutoOpen,   &new_choices->auto_open_delay);
    numberrange_get_value(0, subwindows[CDSubHotlist], CD_HlAutoScroll, &new_choices->auto_scroll_delay);
  }

  if (subwindows[CDSubHistory])
  {
    numberrange_get_value(0, subwindows[CDSubHistory], CD_HiLines,   &new_choices->v_hist_size);
    numberrange_get_value(0, subwindows[CDSubHistory], CD_HiMaxSize, &new_choices->g_hist_size);
  }
d632 1
d637 5
d664 2
d673 4
d694 1
a694 1
  ObjectId    objid;
d699 5
d724 1
a724 1
      e = displayfield_set_value(0, subwindows[CDSubBrowseDefaults], CD_EncodingDisply, textptr);
d741 1
a741 1
    RetError(displayfield_set_value(0, subwindows[CDSubBrowseDefaults], CD_EncodingDisply, "Unknown encoding")); //
a1438 1
  unsigned int            flags;
d1475 1
a1475 1
  if (!gadget_get_flags(0, idb->self_id, CD_LinkColourBt, &flags))
d1480 1
a1480 1
  if (!gadget_get_flags(0, idb->self_id, CD_UsedColourBt, &flags))
d1485 1
a1485 1
  if (!gadget_get_flags(0, idb->self_id, CD_FolwColourBt, &flags))
d1490 1
a1490 1
  if (!gadget_get_flags(0, idb->self_id, CD_SlctColourBt, &flags))
d1624 2
a1625 1
  int state;
d1634 1
a1634 1
      /* Don't bother with errors as fake page display might not exist */
d1636 1
a1636 4
      if (subwindows[CDSubColours])
      {
        button_set_flags(0, subwindows[CDSubColours], CD_FakePage, 0, 0);
      }
d1643 9
d1693 29
@


1.7
log
@Accidently left vowels in the consonant list for making fake text!
@
text
@d1451 2
a1452 1
  int                     more, ypos, xtarget, ptsize, gadsize, xstart;
d1457 1
d1483 27
d1538 1
a1538 5
        #ifdef ChoiceUseSelected
          ptsize = ((gadsize * 1000 / 5) / fontheight);
        #else
          ptsize = ((gadsize * 1000 / 4) / fontheight);
        #endif
d1565 5
a1569 3
      ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, 2));
      ChkError(choices_draw_string(h, "new", xtarget, ypos, new_choices->underline_links, new_choices->link_colour, new_choices->background_colour, &xtarget));
      ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, 3));
d1571 3
a1573 2
      ypos -= fontheight;
      xtarget = icon_coords.xmin - 32;
d1577 5
a1581 3
      ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, 4));
      ChkError(choices_draw_string(h, "followed", xtarget, ypos, new_choices->underline_links, new_choices->used_colour, new_choices->background_colour, &xtarget));
      ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, 5));
d1583 3
a1585 2
      ypos -= fontheight;
      xtarget = icon_coords.xmin - 32;
d1589 5
a1593 3
      ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmin+xstart, new_choices->text_colour, new_choices->background_colour, &xtarget, 6));
      ChkError(choices_draw_string(h, "highlighted", xtarget, ypos, new_choices->underline_links, new_choices->followed_colour, new_choices->background_colour, &xtarget));
      ChkError(choices_write_crap(h, xtarget, ypos, icon_coords.xmax, new_choices->text_colour, new_choices->background_colour, &xtarget, 7));
d1595 3
a1597 2
      ypos -= fontheight;
      xtarget = icon_coords.xmin - 32;
d1600 2
a1601 1
      #ifdef ChoiceUseSelected
d1608 1
a1608 1
      #endif
@


1.6
log
@Choices 'fakepage' display added.
@
text
@d63 1
a63 1
char *consonant = "bcdfghijklmnopqrstuvwxyz";
@


1.5
log
@Version in Messages taken to 1.22 (03 Oct).

Updated Res files in appropriate builds to hold various (similar) Choices
designs.

Choices related menus were flagged as Shared, but none of the dialogues
(including ColourDBox) were - potential future problems, though shouldn't
cause any leaks at present. This has been sorted out anyway.

Encoding function encoding_init no longer returns an error from
toolbox_create_object, so the Encoding menu and all those attached
to it do not have to be present (e.g. the Customer build).

SUB, SUP, STRIKE and U supported. U underlines the baseline of the body text
font, whilst STRIKE will go through roughly the middle of the lower case
chars even if the font is SUP or SUB. Note that Navigator appears to shift
the underline point for SUB and SUP; it may be necessary to copy this
behaviour, but testing on real sites must proceed before that. There could
also be a problem with the automatic lowering of font size, which Navigator
doesn't do, so any FONT SIZE = -n commands could make it too small. Again,
this needs testing on real sites.

'http://' is added to URLs with no protocol specified, unless they start with
'ftp.', in which case the new behaviour is to add 'ftp://'.

Choices code altered to do less error checking on components! They should be
able to be missing without raising errors. Referencing of the subwindow
array changed from *(subwindows + number) to subwindows[number].

Made trace_tag_name code look pretty...

reformat_useless_token now checks tagno is non-zero.

User Agent string setting now done through URL_GetURL, on a per-session
basis.

Ellipsis character removed from all Messages files, replaced with '...'.
There's little difference between the two in an outline font, and in System
font the latter looks much better. Smart quotes left in, as they look
better in all cases.
@
text
@d50 1
d54 1
d63 3
d73 2
d96 3
a98 1

d129 1
a129 1
  if (current_subwindow != CDSubNone)
d134 1
d137 1
a137 1
  if (subwindow == CDSubNone || !(subwindows[subwindow]) || subwindow == current_subwindow)
a140 1
    current_subwindow = CDSubNone;
d241 2
d304 1
d306 2
d324 4
d400 6
a562 12

    e = optionbutton_get_state(0, subwindows[CDSubBrowseDefaults], CD_UnderlineLinks, &state);
    if (!e) new_choices->underline_links = !!state;

    e = optionbutton_get_state(0, subwindows[CDSubBrowseDefaults], CD_UseDocColours,  &state);
    if (!e) new_choices->use_source_cols = !!state;

    e = optionbutton_get_state(0, subwindows[CDSubBrowseDefaults], CD_ShowForeground, &state);
    if (!e) new_choices->show_foreground = !!state;

    e = optionbutton_get_state(0, subwindows[CDSubBrowseDefaults], CD_ShowBackground, &state);
    if (!e) new_choices->show_background = !!state;
d951 1
a951 1
/* choices_colour_closed_handler()               */
d977 7
a983 1
  show_error_ret(choices_colour_set_component(idb->parent_id, idb->parent_component-1, cevent->colour_block[0]));
d989 1
a989 1
/* choices_colour_closed_handler()               */
d1231 7
d1267 7
d1296 367
@


1.4
log
@Didn't redraw browsers which would be immediately affected by a change to
the Choices when 'Set' was used. Appropriate redraw calls added. Reversed
decision to toe in the pane window by 8 OS units relative to the placeholder
icon sides.
@
text
@d59 1
a59 3
static int            * subwindows        = NULL;
static ObjectId         current_subwindow = CDSubNone;
static ObjectId         colourdbox_id     = 0;
d61 3
a63 2
static int              save_ticked = -1;
static int              disp_ticked = -1;
d65 7
a71 2
global_choices        * new_choices       = NULL;
ObjectId                choices_windowid  = 0;
d124 1
a124 1
    RetError(toolbox_hide_object(0, *(subwindows + current_subwindow)));
d127 1
a127 1
  if (subwindow == CDSubNone || !(*(subwindows + subwindow)) || subwindow == current_subwindow)
d152 1
a152 1
  RetError(window_get_wimp_handle(0, *(subwindows + subwindow), &state.window_handle));
d172 1
a172 1
                               *(subwindows + subwindow),
d182 1
d184 1
d186 1
d188 1
d190 1
d192 1
d194 1
d196 1
d199 1
a199 1
                          *(subwindows + subwindow),
d261 9
a269 9
  e = toolbox_create_object(0, "ChSub0", subwindows + CDSubBrowseDefaults); if (e) *(subwindows + CDSubBrowseDefaults) = NULL;
  e = toolbox_create_object(0, "ChSub1", subwindows + CDSubWindows);        if (e) *(subwindows + CDSubWindows)        = NULL;
  e = toolbox_create_object(0, "ChSub2", subwindows + CDSubColours);        if (e) *(subwindows + CDSubColours)        = NULL;
  e = toolbox_create_object(0, "ChSub3", subwindows + CDSubFonts);          if (e) *(subwindows + CDSubFonts)          = NULL;
  e = toolbox_create_object(0, "ChSub4", subwindows + CDSubHotlist);        if (e) *(subwindows + CDSubHotlist)        = NULL;
  e = toolbox_create_object(0, "ChSub5", subwindows + CDSubHistory);        if (e) *(subwindows + CDSubHistory)        = NULL;
  e = toolbox_create_object(0, "ChSub6", subwindows + CDSubSub6);           if (e) *(subwindows + CDSubSub6)           = NULL;
  e = toolbox_create_object(0, "ChSub7", subwindows + CDSubSub7);           if (e) *(subwindows + CDSubSub7)           = NULL;
  e = toolbox_create_object(0, "ChSub8", subwindows + CDSubSub8);           if (e) *(subwindows + CDSubSub8)           = NULL;
d332 1
a332 1
    if (*(subwindows + count))
d334 1
a334 1
      e = toolbox_delete_object(0, *(subwindows + count));
d336 1
a336 1
      *(subwindows + count) = 0;
d432 1
a432 3
  _kernel_oserror * e;

  /* Check that the BrowseDefaults subwindow exists */
d434 1
a434 1
  if (*(subwindows + CDSubBrowseDefaults))
d436 1
a436 1
    RetError(writablefield_set_value(0, *(subwindows + CDSubBrowseDefaults), CD_Homepage, new_choices->home_page));
d438 4
a441 4
    RetError(optionbutton_set_state(0, *(subwindows + CDSubBrowseDefaults), CD_UnderlineLinks, new_choices->underline_links));
    RetError(optionbutton_set_state(0, *(subwindows + CDSubBrowseDefaults), CD_UseDocColours,  new_choices->use_source_cols));
    RetError(optionbutton_set_state(0, *(subwindows + CDSubBrowseDefaults), CD_ShowForeground, new_choices->show_foreground));
    RetError(optionbutton_set_state(0, *(subwindows + CDSubBrowseDefaults), CD_ShowBackground, new_choices->show_background));
d445 1
a445 1
    RetError(choices_set_encoding_field());
d448 1
a448 4
  /* Check that the various subwindows exist before reading */
  /* their contents.                                        */

  if (*(subwindows + CDSubWindows))
d450 4
a453 4
    RetError(optionbutton_set_state(0, *(subwindows + CDSubWindows), CD_URLBar,     new_choices->url_bar));
    RetError(optionbutton_set_state(0, *(subwindows + CDSubWindows), CD_StatusBar,  new_choices->status_bar));
    RetError(optionbutton_set_state(0, *(subwindows + CDSubWindows), CD_ButtonBar,  new_choices->button_bar));
    RetError(optionbutton_set_state(0, *(subwindows + CDSubWindows), CD_FullScreen, new_choices->full_screen));
d456 1
a456 1
  if (*(subwindows + CDSubColours))
d458 6
a463 6
    RetError(choices_colour_set_component(*(subwindows + CDSubColours), CD_BackColour, new_choices->background_colour));
    RetError(choices_colour_set_component(*(subwindows + CDSubColours), CD_TextColour, new_choices->text_colour));
    RetError(choices_colour_set_component(*(subwindows + CDSubColours), CD_LinkColour, new_choices->link_colour));
    RetError(choices_colour_set_component(*(subwindows + CDSubColours), CD_UsedColour, new_choices->used_colour));
    RetError(choices_colour_set_component(*(subwindows + CDSubColours), CD_FolwColour, new_choices->followed_colour));
    RetError(choices_colour_set_component(*(subwindows + CDSubColours), CD_SlctColour, new_choices->selected_colour));
d466 1
a466 1
  if (*(subwindows + CDSubHotlist))
d468 2
a469 2
    RetError(numberrange_set_value(0, *(subwindows + CDSubHotlist), CD_HlAutoOpen,   new_choices->auto_open_delay));
    RetError(numberrange_set_value(0, *(subwindows + CDSubHotlist), CD_HlAutoScroll, new_choices->auto_scroll_delay));
d471 1
a471 1
    RetError(choices_set_display_field(*(subwindows + CDSubHotlist), CD_HlDispDisp, new_choices->hotlist_show));
d473 1
a473 1
    RetError(choices_set_save_field(*(subwindows + CDSubHotlist), CD_HlSaveDisp, new_choices->save_hotlist));
d476 1
a476 1
  if (*(subwindows + CDSubHistory))
d478 2
a479 2
    RetError(numberrange_set_value(0, *(subwindows + CDSubHistory), CD_HiLines,   new_choices->v_hist_size));
    RetError(numberrange_set_value(0, *(subwindows + CDSubHistory), CD_HiMaxSize, new_choices->g_hist_size));
d481 1
a481 1
    RetError(choices_set_display_field(*(subwindows + CDSubHistory), CD_HiDispDisp, new_choices->show_urls));
d483 1
a483 1
    RetError(choices_set_save_field(*(subwindows + CDSubHistory), CD_HiSaveDisp, new_choices->save_history));
d485 1
a494 2
/*                                               */
/* Returns:    pointer to _kernel_oserror        */
d506 2
a507 1
  /* Check that the BrowseDefaults subwindow exists */
d509 1
a509 1
  if (*(subwindows + CDSubBrowseDefaults))
d511 1
a511 1
    RetError(writablefield_get_value(0, *(subwindows + CDSubBrowseDefaults), CD_Homepage, NULL, 0, &reqsize));
d513 3
a515 1
    tempstring = malloc(reqsize + 1);
d517 1
a517 4
    if (tempstring)
    {
      RetError(writablefield_get_value(0, *(subwindows + CDSubBrowseDefaults), CD_Homepage, tempstring, reqsize, NULL));
      if (!strcmp(tempstring, new_choices->home_page))
d519 14
a532 1
        free(tempstring);
d536 1
a536 2
        free(new_choices->home_page);
        new_choices->home_page = tempstring;
a538 4
    else
    {
      show_error_ret(make_no_memory_error(17));
    }
d540 11
a550 8
    RetError(optionbutton_get_state(0, *(subwindows + CDSubBrowseDefaults), CD_UnderlineLinks, &state));
    new_choices->underline_links = !!state;
    RetError(optionbutton_get_state(0, *(subwindows + CDSubBrowseDefaults), CD_UseDocColours,  &state));
    new_choices->use_source_cols = !!state;
    RetError(optionbutton_get_state(0, *(subwindows + CDSubBrowseDefaults), CD_ShowForeground, &state));
    new_choices->show_foreground = !!state;
    RetError(optionbutton_get_state(0, *(subwindows + CDSubBrowseDefaults), CD_ShowBackground, &state));
    new_choices->show_background = !!state;
d553 7
a559 1
  /* Check that the Windows subwindow exists */
d561 5
a565 10
  if (*(subwindows + CDSubWindows))
  {
    RetError(optionbutton_get_state(0, *(subwindows + CDSubWindows), CD_URLBar,     &state));
    new_choices->url_bar     = !!state;
    RetError(optionbutton_get_state(0, *(subwindows + CDSubWindows), CD_StatusBar,  &state));
    new_choices->status_bar  = !!state;
    RetError(optionbutton_get_state(0, *(subwindows + CDSubWindows), CD_ButtonBar,  &state));
    new_choices->button_bar  = !!state;
    RetError(optionbutton_get_state(0, *(subwindows + CDSubWindows), CD_FullScreen, &state));
    new_choices->full_screen = !!state;
d568 1
a568 1
  if (*(subwindows + CDSubHotlist))
d570 2
a571 2
    RetError(numberrange_get_value(0, *(subwindows + CDSubHotlist), CD_HlAutoOpen,   &new_choices->auto_open_delay));
    RetError(numberrange_get_value(0, *(subwindows + CDSubHotlist), CD_HlAutoScroll, &new_choices->auto_scroll_delay));
d574 1
a574 1
  if (*(subwindows + CDSubHistory))
d576 2
a577 2
    RetError(numberrange_get_value(0, *(subwindows + CDSubHistory), CD_HiLines,   &new_choices->v_hist_size));
    RetError(numberrange_get_value(0, *(subwindows + CDSubHistory), CD_HiMaxSize, &new_choices->g_hist_size));
d725 1
a725 1
      e = displayfield_set_value(0, *(subwindows + CDSubBrowseDefaults), CD_EncodingDisply, textptr);
d742 1
a742 1
    RetError(displayfield_set_value(0, *(subwindows + CDSubBrowseDefaults), CD_EncodingDisply, "Unknown encoding")); //
d986 3
a988 2
  char newvalidation[32];
  unsigned char *newcol;
d991 1
a991 1
  sprintf(newvalidation, "R2;C/%02.2x%02.2x%02.2x", *(newcol+3), *(newcol+2), *(newcol+1));
@


1.3
log
@Changed some error handling in Choices, a little bit of reformatting,
removed unnecessary tempstring in Main, and played about with the
choices Res file objects.
@
text
@a141 7
  /* Toe it in for the borders */

  show_block.visible_area.xmin += 8;
  show_block.visible_area.ymin += 8;
  show_block.visible_area.xmax -= 8;
  show_block.visible_area.ymax -= 8;

d418 1
a418 1
static _kernel_oserror *choices_set_contents(void)
d420 1
a420 1
  _kernel_oserror *e;
d438 2
a439 1
  /* Check that the Windows subwindow exists */
d463 1
d465 1
d473 1
d475 1
a477 1

d493 6
a498 4
  _kernel_oserror *e;
  int state;
  char *tempstring;
  int reqsize;
d563 28
@


1.2
log
@Added run time RMEnsuring type behaviour for ColourDbox to save RMA space on
start up of the browser.
Also added additional deregistering of events which I forgot to do last time :(
@
text
@d107 1
a107 1
static _kernel_oserror *choices_show_subwindow(ObjectId choices_window, int subwindow)
d109 7
a115 7
  _kernel_oserror         *e;
  int                     window_handle;
  WindowShowObjectBlock   show_block;
  WimpGetWindowStateBlock state;
  WimpGetWindowOutlineBlock outline;
  int                     vwidth, hheight;
  
d119 2
a120 1
    toolbox_hide_object(0, *(subwindows + current_subwindow));
d122 1
a122 1
  
d126 1
a126 1
    
d130 1
a130 1
  
d136 13
a148 6
  
  show_block.visible_area.xmin = coords_x_toscreen(show_block.visible_area.xmin, (WimpRedrawWindowBlock*)&state);
  show_block.visible_area.xmax = coords_x_toscreen(show_block.visible_area.xmax, (WimpRedrawWindowBlock*)&state);
  show_block.visible_area.ymin = coords_y_toscreen(show_block.visible_area.ymin, (WimpRedrawWindowBlock*)&state);
  show_block.visible_area.ymax = coords_y_toscreen(show_block.visible_area.ymax, (WimpRedrawWindowBlock*)&state);
  
d150 1
a150 1
  
d152 1
a152 1
    Printf("wimp flags : %x\n", state.flags);
d154 1
a154 1
  
d157 1
a157 1
  
d160 1
a160 1
  
d163 1
a163 1
  
d167 1
a167 1
  
d170 1
a170 1
  
d173 1
a173 1
  
a179 1
  
d183 2
a184 2
  
  if (outline.outline.xmin < show_block.visible_area.xmin) 
d186 1
a186 1
  if (outline.outline.ymin < (show_block.visible_area.ymin - hheight)) 
d188 1
a188 1
  if (outline.outline.xmax > (show_block.visible_area.xmax + vwidth)) 
d190 1
a190 1
  if (outline.outline.ymax > show_block.visible_area.ymax) 
d222 1
a222 1
  
d224 1
a224 1
    Printf("called: choices_to_be_shown\n");
d226 1
a226 1
  
d228 1
a228 1
  
d230 1
d234 4
a237 11
    if (!subwindows)
    {
      /* If hide object doesn't work, things are really screwed */
      
      e = toolbox_hide_object(0, idb->self_id);
      show_error_ret(e);
      
      e = make_no_memory_error(100); //
      show_error_ret(e);
      return 1;
    }
d239 1
a239 1
  
d243 1
d246 1
a246 8
      /* If hide object doesn't work, things are really screwed */
      
      e = toolbox_hide_object(0, idb->self_id);
      show_error_ret(e);
      
      e = make_no_memory_error(100); //
      show_error_ret(e);
      return 1;
d255 36
a290 21
  
  e = toolbox_create_object(0, "ChSub0", subwindows + CDSubBrowseDefaults);
  if (e) *(subwindows + CDSubBrowseDefaults) = NULL;
  e = toolbox_create_object(0, "ChSub1", subwindows + CDSubWindows);
  if (e) *(subwindows + CDSubWindows) = NULL;
  e = toolbox_create_object(0, "ChSub2", subwindows + CDSubColours);
  if (e) *(subwindows + CDSubColours) = NULL;
  e = toolbox_create_object(0, "ChSub3", subwindows + CDSubFonts);
  if (e) *(subwindows + CDSubFonts) = NULL;
  e = toolbox_create_object(0, "ChSub4", subwindows + CDSubHotlist);
  if (e) *(subwindows + CDSubHotlist) = NULL;
  e = toolbox_create_object(0, "ChSub5", subwindows + CDSubHistory);
  if (e) *(subwindows + CDSubHistory) = NULL;
  e = toolbox_create_object(0, "ChSub6", subwindows + CDSubSub6);
  if (e) *(subwindows + CDSubSub6) = NULL;
  e = toolbox_create_object(0, "ChSub7", subwindows + CDSubSub7);
  if (e) *(subwindows + CDSubSub7) = NULL;
  e = toolbox_create_object(0, "ChSub8", subwindows + CDSubSub8);
  if (e) *(subwindows + CDSubSub8) = NULL;
  
  e = choices_show_subwindow(idb->self_id, CDSubBrowseDefaults);
d293 14
a306 2
    show_error_ret(e);
    return 1;
d308 1
a308 43
  
  e = radiobutton_set_state(0, idb->self_id, CDBrowseDefaults, 1);
  
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
  
  e = choices_set_contents();
  if (e)
  {
    show_error_ret(e);
    return 1;
  }
  
  /* Register choices event handlers */
  
  e = event_register_toolbox_handler(-1, ECDRG2, choices_radio_click_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, CDSet, choices_set_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, CDCancel, choices_cancel_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, CDSaveButton, choices_save_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, ECD_EncodingMenuBt, choices_encoding_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, ECD_ColourButton, choices_colour_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, ECD_HlDispBt, choices_display_m_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, ECD_HiDispBt, choices_display_m_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, ECD_HlSaveBt, choices_save_m_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, ECD_HiSaveBt, choices_save_m_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, ECDSaveMenuClick, choices_save_m_click_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_register_toolbox_handler(-1, ECDDispMenuClick, choices_display_m_click_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  
d319 1
d324 1
a324 1
  
d352 2
a353 2
  _kernel_oserror *e;
  
d355 1
a355 1
  
d358 1
a358 1
  
d360 1
a360 1
  
d362 1
a362 1
  
d364 14
a377 26
  
  e = event_deregister_toolbox_handler(-1, ECDRG2, choices_radio_click_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, CDSet, choices_set_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, CDCancel, choices_cancel_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, CDSaveButton, choices_save_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, ECD_EncodingMenuBt, choices_encoding_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, ECD_ColourButton, choices_colour_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, ECD_HlDispBt, choices_display_m_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, ECD_HiDispBt, choices_display_m_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, ECD_HlSaveBt, choices_save_m_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, ECD_HiSaveBt, choices_save_m_button_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, ECDSaveMenuClick, choices_save_m_click_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  e = event_deregister_toolbox_handler(-1, ECDDispMenuClick, choices_display_m_click_handler, NULL);
  if (e) {show_error_ret(e); return 1;}
  
d394 1
a394 1
  
d397 11
a407 11
    case CDBrowseDefaults : window = CDSubBrowseDefaults; break;
    case CDWindows        : window = CDSubWindows;        break;
    case CDColours        : window = CDSubColours;        break;
    case CDFonts          : window = CDSubFonts;          break;
    case CDHotlist        : window = CDSubHotlist;        break;
    case CDHistory        : window = CDSubHistory;        break;
    case CDSub6           : window = CDSubSub6;           break;
    case CDSub7           : window = CDSubSub7;           break;
    case CDSub8           : window = CDSubSub8;           break;
    
    default               : window = CDNoSubwindows;      break;
d409 1
a409 1
  
d411 1
a411 1
  
d428 1
a428 1
  
d430 1
a430 1
  
d434 1
a434 1
    
d439 1
a439 1
    
d441 1
a441 1
    
d444 1
a444 1
  
d446 1
a446 1
  
d454 1
a454 1
  
d464 1
a464 1
  
d472 1
a472 1
  
d480 1
a480 1
  
d494 1
a494 1
static _kernel_oserror *choices_get_contents(void)
d506 3
a508 1
    tempstring = malloc(reqsize+1);
d524 1
a524 1
      show_error_ret(make_no_memory_error(100)); //
d526 1
a526 1
    
d550 1
a550 1
  
d556 1
a556 1
  
d562 1
a562 1
  
d564 1
a564 1
  
d586 1
a586 1
  
d605 1
a605 1
  
d607 1
a607 1
  
d610 1
a610 1
  
d637 1
a637 1
  
d640 1
a640 1
  
d656 1
a656 1
  ComponentId compid;  
d659 1
a659 1
  
d661 1
a661 1
  
d665 1
a665 1
    
d669 1
a669 1
    
d681 1
a681 1
      
d690 1
a690 1
      RetError(make_no_memory_error(101)); //
d696 1
a696 1
    
d699 1
a699 1
  
d716 1
a716 1
  
d723 1
a723 1
  
d730 1
a730 1
  
d737 1
a737 1
  
d739 1
a739 1
  
d742 1
a742 1
  
d767 1
a767 1
  
d769 1
a769 1
  
d771 1
a771 1
  
d773 1
a773 1
  
d787 1
a787 1
  
d793 1
a793 1
  
d806 1
a806 1
  
d808 1
a808 1
  
d815 1
a815 1
  
d822 1
a822 1
  
d829 1
a829 1
  
d831 1
a831 1
  
d834 1
a834 1
  
d841 1
a841 1
  
d848 1
a848 1
  
d858 1
a858 1
  
d876 1
a876 1
  
d885 1
a885 1
  
d887 1
a887 1
  Printf("Colour dbox deleted\n");
d889 1
a889 1
  
d906 1
a906 1
  
d919 1
a919 1
  
d921 1
a921 1
  
d944 1
a944 1
  
d965 1
a965 1
  
d972 1
a972 1
  
d979 1
a979 1
  
d986 1
a986 1
  
d988 1
a988 1
  
d991 1
a991 1
  
d998 1
a998 1
  
d1005 1
a1005 1
  
d1012 1
a1012 1
  
d1038 1
a1038 1
  
d1045 1
a1045 1
  
d1052 1
a1052 1
  
d1059 1
a1059 1
  
d1061 1
a1061 1
  
d1064 1
a1064 1
  
d1071 1
a1071 1
  
d1078 1
a1078 1
  
d1085 1
a1085 1
  
d1109 1
a1109 1
  
d1111 1
a1111 1
    Printf("called: choices_set_display_field\n");
d1113 1
a1113 1
  
d1117 4
a1120 4
  
  tempstring = malloc(reqdsize+1);
  if (!tempstring) return make_no_memory_error(100); //
  
d1122 1
a1122 1
  
d1124 1
a1124 1
  
d1143 1
a1143 1
  
d1145 1
a1145 1
    Printf("called: choices_set_display_field\n");
d1147 1
a1147 1
  
d1151 1
a1151 1
  
d1153 2
a1154 2
  if (!tempstring) return make_no_memory_error(100); //
  
d1156 1
a1156 1
  
d1158 1
a1158 1
  
d1177 1
a1177 1
  
d1187 1
a1187 1
  
d1189 1
a1189 1
  
d1206 1
a1206 1
  
d1216 1
a1216 1
  
d1218 1
a1218 1
  
@


1.1
log
@Implemented dialogue based choices.
@
text
@d396 12
d797 26
d1053 1
a1053 1
/* choices_save_button_handler()                 */
@

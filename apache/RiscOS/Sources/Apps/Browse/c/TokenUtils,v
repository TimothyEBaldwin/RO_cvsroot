head	1.17;
access;
symbols
	Browse-2_16:1.17
	Browse-2_15:1.17
	Browse-2_14:1.17
	Browse-2_13:1.17
	Browse-2_12:1.17
	Browse-2_11:1.16
	Browse-2_10:1.16
	Browse-2_09:1.16
	ahodgkin_208_i4_2:1.15
	ahodgkin_208_i4:1.13
	ahodgkin_208_i3:1.13
	ahodgkin_208_i2:1.13
	ahodgkin_208_i1:1.13
	ahodgkin_207release:1.11
	ahodgkin_206release:1.10
	ahodgkin_205release:1.10
	ahodgkin_204release:1.10
	ahodgkin_202release:1.10
	ahodgkin_201release:1.10
	ahodgkin_200release:1.10
	ahodgkin_133beta:1.10
	ahodgkin_132beta:1.10
	ahodgkin_131beta:1.9
	ahodgkin_130beta:1.8
	ahodgkin_129:1.8
	ahodgkin_128beta:1.8
	ahodgkin_128alpha:1.8
	ahodgkin_127beta2:1.7
	ahodgkin_127beta:1.7
	ahodgkin_126beta:1.7
	ahodgkin_AW97patch:1.7
	ahodgkin_AW97:1.7;
locks; strict;
comment	@# @;


1.17
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.26.09.42.35;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.14.08.45.08;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.31.15.58.49;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	99.09.02.13.10.35;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	99.03.30.15.52.05;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	98.10.06.09.28.57;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	98.02.06.13.55.29;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	98.01.31.10.55.37;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.12.02.16.14.04;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.15.18.26;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.08.31.18.38.23;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.08.18.09.24.06;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.07.31.14.50.15;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.07.30.12.39.11;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.07.25.12.52.33;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.29.04;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.17
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    TokenUtils.c                                      */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Utility functions for finding out information     */
/*          about tokens.                                     */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 09-Apr-1997 (ADH): Created.                       */
/*          23-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/event.h>

#include "Global.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Redraw.h"

#include "TokenUtils.h"

/* Locals */

static unsigned int tokenutils_npaths = 0;

/* Static function prototypes */

static int tokenutils_line_range_r
           (
             const int                      toplevel,
             const browser_data  * restrict b,
             const reformat_cell *          d,
             const HStream       * restrict token,
             int                 * restrict fline,
             int                 * restrict fchunk,
             int                 * restrict lline,
             int                 * restrict lchunk,
             token_path         ** restrict path
           );

/**************************************************************/
/* tokenutils_anchor_range()                                  */
/*                                                            */
/* Will return the first (inclusive) and last (inclusive)     */
/* tokens that consecutively point to the same thing as       */
/* anchors. This is useful as some links may be made of       */
/* several tokens, as style changes to mark the result of a   */
/* web search (for example) or whatever may be used in what   */
/* is meant to be the same link. If this link is to be        */
/* highlighted or selected, need to know which tokens are     */
/* involved.                                                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the tokens;                                    */
/*                                                            */
/*             Pointer to one of the tokens in the collection */
/*             for this anchor;                               */
/*                                                            */
/*             Pointer to an HStream pointer, into which the  */
/*             address of the first token involved in the     */
/*             link is placed;                                */
/*                                                            */
/*             Pointer to an HStream pointer, into which the  */
/*             address of the last token involved in the link */
/*             is placed.                                     */
/*                                                            */
/* Assumes:    Either of the last two pointers may be NULL.   */
/*             The token pointer given at the start should    */
/*             point to a link. If not, the returned          */
/*             addresses will be undefined...                 */
/**************************************************************/

void tokenutils_anchor_range
     (
       const browser_data  * restrict b,
       const HStream       *          token,
       HStream            ** restrict first,
       HStream            ** restrict last
     )
{
  const HStream * restrict top   = NULL;
  const HStream * restrict end   = NULL;
  const HStream * restrict store = NULL;

  if (first) *first = NULL;
  if (last)  *last  = NULL;

  if (!b || !token) return;

  /* Can only proceed if the given token represents a link */

  if (token && (token->style & A) && token->anchor)
  {
    store = top = token;

    /* Move up the token list for as long as the token given matches */
    /* the details of the token being looked at.                     */

    while (
            top                                  &&
            (top->style & A)                     &&
            top->anchor                          &&
            !strcmp(top->anchor, token->anchor)
          )
          store = top, top = top->prev;

    /* Make sure we haven't overshot the first item */

    if (!top) top = store;

    if (
         top && !(
                   (top->style & A)                    &&
                   top->anchor                         &&
                   !strcmp(top->anchor, token->anchor)
                 )
       )
       top = top->next;

    store = end = token;

    /* Similary, move down the token list to find the first token after */
    /* all those involved in the link.                                  */

    while (
            end                                  &&
            (end->flags & HFlags_DealtWithToken) &&
            (end->style & A)                     &&
            end->anchor                          &&
            !strcmp(end->anchor, token->anchor)
          )
          store = end, end = end->next;

    /* Ensure we haven't overshot */

    if (!end) end = store;

    if (
         end && !(
                   (end->flags & HFlags_DealtWithToken) &&
                   (end->style & A)                     &&
                   end->anchor                          &&
                   !strcmp(end->anchor, token->anchor)
                 )
       )
       end = end->prev;
  }
  else top = end = token;

  /* Return the found values */

  if (first) *first = (HStream *) top;
  if (last)  *last  = (HStream *) end;

  return;
}

/**************************************************************/
/* tokenutils_line_range()                                    */
/*                                                            */
/* Returns the first chunk and line number to use a given     */
/* token, and the last line and chunk number to use that      */
/* token.                                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             Pointer to the token;                          */
/*                                                            */
/*             Pointer to an int, into which the first line   */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to an int, into which the first chunk  */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to an int, into which the last line    */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to an int, into which the last chunk   */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to a token_path pointer, which will be */
/*             filled in with the address of a malloced array */
/*             of reformat_cell structures for tokens within  */
/*             tables, or NULL if this shouldn't be built.    */
/*                                                            */
/* Returns:    See parameters list, and note that '-1' will   */
/*             be returned in all four fields should be token */
/*             not be found in a line to start with;          */
/*                                                            */
/*             The number of entries in the associated        */
/*             token_path structure for table-based tokens.   */
/*                                                            */
/* Assumes:    Any of the pointers may be NULL.               */
/**************************************************************/

int tokenutils_line_range
    (
      const browser_data * restrict b,
      const HStream      * restrict token,
      int                * restrict fline,
      int                * restrict fchunk,
      int                * restrict lline,
      int                * restrict lchunk,
      token_path        ** restrict path
    )
{
  tokenutils_npaths = 0;
  if (path) *path = NULL;

  return tokenutils_line_range_r(1,
                                 b,
                                 b->cell,
                                 token,
                                 fline,
                                 fchunk,
                                 lline,
                                 lchunk,
                                 path);
}

/**************************************************************/
/* tokenutils_line_range_r()                                  */
/*                                                            */
/* Recursive back-end to tokenutils_line_range.               */
/*                                                            */
/* Parameters: 1 for a top level call, else 0 if being called */
/*             recursively;                                   */
/*                                                            */
/*             Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             Pointer to a reformat_cell struct containing   */
/*             the token or a table which holds the token;    */
/*                                                            */
/*             Pointer to the token;                          */
/*                                                            */
/*             Pointer to an int, into which the first line   */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to an int, into which the first chunk  */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to an int, into which the last line    */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to an int, into which the last chunk   */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to a token_path pointer, which will be */
/*             filled in with the address of a malloced array */
/*             of token_path structures for tokens within     */
/*             tables, or NULL if this shouldn't be built.    */
/*                                                            */
/* Returns:    As for tokenutils_line_range.                  */
/*                                                            */
/* Assumes:    As for tokenutils_line_range.                  */
/**************************************************************/

static int tokenutils_line_range_r
           (
             const int                      toplevel,
             const browser_data  * restrict b,
             const reformat_cell *          d,
             const HStream       * restrict token,
             int                 * restrict fline,
             int                 * restrict fchunk,
             int                 * restrict lline,
             int                 * restrict lchunk,
             token_path         ** restrict path
           )
{
  int fl = -1, fc = -1, ll = -1, lc = -1; /* First Line, First Chunk, Last Line, Last Chunk */

  /* Start with all values at -1; saves having to fill them */
  /* in at any given failure point.                         */

  if (fline)  *fline  = fl;
  if (fchunk) *fchunk = fc;
  if (lline)  *lline  = ll;
  if (lchunk) *lchunk = lc;

  /* Can only try to find the token if the browser_data */
  /* and token pointers were not NULL.                  */

  if (b && d && token && d->nlines)
  {
    int cl, cc  = -1, mc; /* Current Line, Current Chunk, Maximum Chunk */
    int found   = 0;

    /* Must find the first line / chunk even if not asked for it */

    cl = 0;

    /* Loop through all lines */

    while (cl < d->nlines && !found)
    {
      cc = d->ldata[cl].chunks;
      mc = cc + d->ldata[cl].n;

      /* Go through this line's chunks looking for the token */

      while (cc < mc && !found)
      {
        if (toplevel) tokenutils_npaths = 0;

        if (d->cdata[cc].t == token) found = 1;
        else
        {
          /* Must recursively scan token lists for tables */

          if (d->cdata[cc].t->tagno == TAG_TABLE)
          {
            const table_stream   * restrict table     = (table_stream *) d->cdata[cc].t;
            const table_row      * restrict row       = NULL;
            const table_headdata * restrict head      = NULL;
            const reformat_cell  *          cellarray = table->cells;
            const reformat_cell  *          cell;
            int                             found     = 0;
            int                             cellindex;
            int                             cellcount = 0;
            int                             cellmax   = table->ColSpan * table->RowSpan;

            /* Naming convention: [Pointer] Table First/Last Line/Chunk */

            int              tfl = -1, tfc = -1, tll = -1, tlc = -1;
            int            * ptfl, * ptfc, * ptll, * ptlc;

            if (cellarray)
            {
              /* For recursive scanning of line lists, keep efficiency */
              /* as high as possible by only asking for the same       */
              /* values as originally passed to the function (e.g.     */
              /* don't want to look at last lines or chunks during     */
              /* the recursive scan unless they are needed at the top  */
              /* level too).                                           */

              if (fline)  ptfl = &tfl;
              else        ptfl = NULL;

              if (fchunk) ptfc = &tfc;
              else        ptfc = NULL;

              if (lline)  ptll = &tll;
              else        ptll = NULL;

              if (lchunk) ptlc = &tlc;
              else        ptlc = NULL;

              /* Scan the table */

              row = table->List;

              while (row && !found && cellcount < cellmax)
              {
                head = row->List;

                while (head && !found && cellcount < cellmax)
                {
                  switch (head->Tag)
                  {
                    case TagTableData:
                    case TagTableHead:
                    {
                      cellindex = table->ColSpan * head->RowOffs + head->ColOffs;

                      if (cellindex < cellmax)
                      {
                        cell = &cellarray[cellindex];

                        /* If a cell corresponding to this headdata item can be */
                        /* found and it has lines to scan, call this function   */
                        /* recursively on its contents.                         */

                        if (cell && cell->nlines)
                        {
                          /* Move flex anchors into the temporary browser_data struct */

                          tokenutils_line_range_r(0,
                                                  b,
                                                  cell,
                                                  token,
                                                  ptfl,
                                                  ptfc,
                                                  ptll,
                                                  ptlc,
                                                  path);

                          /* Check if the token was found */

                          if (tfl != -1 || tfc != -1 || tll != -1 || tlc != -1) found = 1;
                        }
                      }
                    }
                    break;
                  }

                  if (!found)
                  {
                    cellcount++;

                    head = head->Next;
                  }
                }

                if (!found) row = row->Next;
              }

              if (found)
              {
                if (path)
                {
                  token_path * temp;

                  /* Increment the tokenutils_npaths counter and allocate memory for a */
                  /* new token_path structure.                                         */

                  tokenutils_npaths++;

                  /* Note 'tokenutils_npaths + 1' - an extra structure for marking the */
                  /* end of the array.                                                 */

                  if (*path) temp = realloc(*path, (tokenutils_npaths + 1) * sizeof(token_path));
                  else       temp =         malloc((tokenutils_npaths + 1) * sizeof(token_path));

                  /* Complain and bail out if the allocation failed */

                  if (!temp)
                  {
                    if (*path)
                    {
                      free(*path);
                      *path = NULL;
                    }

                    show_error_ret(make_no_memory_error(1));

                    return 0;
                  }
                  else *path = temp;

                  /* Fill in the new token_path structure */

                  (*path)[tokenutils_npaths - 1].line  = cl;
                  (*path)[tokenutils_npaths - 1].chunk = cc;
                  (*path)[tokenutils_npaths - 1].head  = head;

                  /* Fill in the terminating structure */

                  (*path)[tokenutils_npaths].line  = -1;
                  (*path)[tokenutils_npaths].chunk = -1;
                  (*path)[tokenutils_npaths].head  = NULL;
                }

                /* Since we've found the token within a table inside this line, */
                /* and the token_path is filled in, want to exit now.           */

                if (fline)  *fline  = tfl;
                if (fchunk) *fchunk = tfc;
                if (lline)  *lline  = tll;
                if (lchunk) *lchunk = tlc;

                return tokenutils_npaths;
              }

            /* Closure of 'if (cellarray)' */
            }

          /* Closure of 'if (d->cdata[cc].t->tagno == TAG_TABLE)' */
          }

          cc++;

        /* Closure of 'else' section to 'if (d->cdata[cc].t == token)' */
        }

      /* Closure of 'while' loop going through all the chunks */
      }

      /* If we haven't found a chunk yet, go to the next line */

      if (!found) cl ++;
    }

    if (found)
    {
      if (cl >= d->nlines) cl = d->nlines - 1;
      fl = cl, fc = cc;

      /* If a line and chunk have been found, record them in fl and fc */

      if (cl >= 0 && cc >= 0)
      {
        /* Only try to find the last line / chunk if asked for them */

        if (lline || lchunk)
        {
          /* Start at the next line and if this starts with the given */
          /* token, keep moving on until a line which doesn't start   */
          /* with the token is found.                                 */

          cl++;
          while (cl < d->nlines && d->cdata[d->ldata[cl].chunks].t == token) cl++;

          /* Coming out of the above loop either we'll be at cl = d->nlines, */
          /* or cl will be the first line that doesn't start with the given  */
          /* token. In either case, must decrement cl by one to get back to  */
          /* a line which does include the token.                            */

          cl--;

          if (lchunk)
          {
            /* Now search the chunks for the token, starting at the last chunk */

            cc = d->ldata[cl].chunks + d->ldata[cl].n - 1;

            while (cc >= d->ldata[cl].chunks && d->cdata[cc].t != token) cc--;

            /* If cc is still in range, a token was found on this line (it */
            /* should always be, but something might go wrong above and    */
            /* this check is worth doing for robustness). So copy the last */
            /* line and chunk details to ll and lc.                        */

            if (cc >= d->ldata[cl].chunks) ll = cl, lc = cc;
          }
          else ll = cl;
        }
      }
    }
  }

  /* Fill in any requested values */

  if (fline)  *fline  = fl;
  if (fchunk) *fchunk = fc;
  if (lline)  *lline  = ll;
  if (lchunk) *lchunk = lc;

  return tokenutils_npaths;
}

/**************************************************************/
/* tokenutils_find_ancestor_line()                            */
/*                                                            */
/* Returns the line in a given browser's main line list in    */
/* which a given token lies, or -1 if the token can't be      */
/* found.                                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token and lines;                           */
/*                                                            */
/*             Pointer to the HStream struct to find.         */
/*                                                            */
/* Returns:    Line number that the token lies in, in the     */
/*             main line list - so the token could well lie   */
/*             inside a table within that line. -1 is         */
/*             returned if the token is not found in the line */
/*             list at all.                                   */
/**************************************************************/

int tokenutils_find_ancestor_line
    (
      const browser_data * restrict b,
      const HStream      * restrict t
    )
{
  const table_headdata * restrict head;
  const table_row      * restrict row;
  const table_stream   * restrict table;

  int              l;

  if (!b || !t) return NULL;

  table = (table_stream *) t;

  while (table->parent)
  {
    /* Find the table the token lies in */

    head = table->parent;
    if (!head) return -1;

    row = head->parent;
    if (!row) return -1;

    table = row->parent;
    if (!table) return -1;
  }

  tokenutils_line_range(b, (HStream *) table, &l, NULL, NULL, NULL, NULL);

  return l;




//  int          l;
//  int          chunk, depth, noline = 0;
//  token_path * path = NULL;
//
//  depth = tokenutils_line_range(b, t, &l, &chunk, NULL, NULL, &path);
//
//  if (l < 0) noline = 1;
//  else
//  {
//    /* If a line was found and depth is non-zero, the line was inside */
//    /* a table - want to find the parent line of the table            */
//
//    if (depth) l = path[depth - 1].line;
//    if (l < 0) noline = 1;
//  }
//
//  if (path) free(path);
//
//  if (noline) return -1;
//
//  return l;
}

/**************************************************************/
/* tokenutils_find_token                                      */
/*                                                            */
/* For a given token in a given reformat_cell, returns the    */
/* line and chunk number that the token spans.                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             Pointer to a reformat_cell struct containing   */
/*             the token or a table which holds the token;    */
/*                                                            */
/*             Pointer to the token;                          */
/*                                                            */
/*             Pointer to an int, into which the first line   */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to an int, into which the first chunk  */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to an int, into which the last line    */
/*             number is placed;                              */
/*                                                            */
/*             Pointer to an int, into which the last chunk   */
/*             number is placed;                              */
/*                                                            */
/* Returns:    See parameters list, and note that '-1' will   */
/*             be returned in all four fields should be token */
/*             not be found in a line to start with;          */
/*                                                            */
/* Assumes:    Any of the pointers may be NULL.               */
/**************************************************************/

void tokenutils_find_token
     (
       const browser_data  * restrict b,
       const reformat_cell *          d,
       const HStream       * restrict token,
       int                 * restrict fline,
       int                 * restrict fchunk,
       int                 * restrict lline,
       int                 * restrict lchunk
     )
{
  int fl = -1, fc = -1, ll = -1, lc = -1; /* First Line, First Chunk, Last Line, Last Chunk */

  /* Start with all values at -1; saves having to fill them */
  /* in at any given failure point.                         */

  if (fline)  *fline  = fl;
  if (fchunk) *fchunk = fc;
  if (lline)  *lline  = ll;
  if (lchunk) *lchunk = lc;

  /* Can only try to find the token if the browser_data */
  /* and token pointers were not NULL.                  */

  if (b && d && token && d->nlines)
  {
    int cl, cc  = -1, mc; /* Current Line, Current Chunk, Maximum Chunk */
    int found   = 0;

    /* Must find the first line / chunk even if not asked for it */

    cl = 0;

    /* Loop through all lines */

    while (cl < d->nlines && !found)
    {
      cc = d->ldata[cl].chunks;
      mc = cc + d->ldata[cl].n;

      /* Go through this line's chunks looking for the token */

      while (cc < mc && !found)
      {
        if (d->cdata[cc].t == token) found = 1;

        /* If not found, go to the next chunk */

        else cc++;
      }

      /* If we haven't found a chunk yet, go to the next line */

      if (!found) cl ++;
    }

    if (found)
    {
      if (cl >= d->nlines) cl = d->nlines - 1;
      fl = cl, fc = cc;

      /* If a line and chunk have been found, record them in fl and fc */

      if (cl >= 0 && cc >= 0)
      {
        /* Only try to find the last line / chunk if asked for them */

        if (lline || lchunk)
        {
          /* Start at the next line and if this starts with the given */
          /* token, keep moving on until a line which doesn't start   */
          /* with the token is found.                                 */

          cl++;
          while (cl < d->nlines && d->cdata[d->ldata[cl].chunks].t == token) cl++;

          /* Coming out of the above loop either we'll be at cl = d->nlines, */
          /* or cl will be the first line that doesn't start with the given  */
          /* token. In either case, must decrement cl by one to get back to  */
          /* a line which does include the token.                            */

          cl--;

          if (lchunk)
          {
            /* Now search the chunks for the token, starting at the last chunk */

            cc = d->ldata[cl].chunks + d->ldata[cl].n - 1;

            while (cc >= d->ldata[cl].chunks && d->cdata[cc].t != token) cc--;

            /* If cc is still in range, a token was found on this line (it */
            /* should always be, but something might go wrong above and    */
            /* this check is worth doing for robustness). So copy the last */
            /* line and chunk details to ll and lc.                        */

            if (cc >= d->ldata[cl].chunks) ll = cl, lc = cc;
          }
          else ll = cl;
        }
      }
    }
  }

  /* Fill in any requested values */

  if (fline)  *fline  = fl;
  if (fchunk) *fchunk = fc;
  if (lline)  *lline  = ll;
  if (lchunk) *lchunk = lc;

  /* Finished */

  return;
}

/**************************************************************/
/* tokenutils_find_cell()                                     */
/*                                                            */
/* Examines a token_path array and returns the address of the */
/* reformat_cell structure that corresponds to the last       */
/* entry.                                                     */
/*                                                            */
/* Parameters: Pointer to the reformat_cell that the          */
/*             token_path array refers to in the first entry  */
/*             (e.g. the 'cell' field of the parent           */
/*             browser_data structure);                       */
/*                                                            */
/*             Number of entries in the array;                */
/*                                                            */
/*             Pointer to the first entry.                    */
/*                                                            */
/* Returns:    Pointer to the reformat_cell structure         */
/*             corresponding to the last entry, or NULL if    */
/*             none may be found.                             */
/**************************************************************/

const reformat_cell * tokenutils_find_cell
                      (
                        const reformat_cell *          cell,
                        const int                      depth,
                        token_path          * restrict path
                      )
{
  if (depth && path && path[0].line >= 0 && path[depth - 1].line >= 0)
  {
    const table_stream   * restrict table;
    const table_headdata * restrict head;
    const reformat_cell  *          cellarray    = NULL;
    const reformat_cell  *          c            = NULL;
    int                             index        = depth - 1;
    int                             line, chunk;

    /* Start looking at the token_path array. The last */
    /* entry refers to the main line array, so get to  */
    /* the appropriate reformat_cell structure through */
    /* the main line list.                             */

    line  = path[index].line;
    chunk = path[index].chunk;
    head  = path[index].head;

    table     = (table_stream *) cell->cdata[chunk].t;
    cellarray = table->cells;

    if (cellarray) c = &cellarray[table->ColSpan * head->RowOffs + head->ColOffs];

    index--;

    /* Need to look at subsequent cell line arrays for any */
    /* nested tables.                                      */

    while (index >= 0 && c)
    {
      line  = path[index].line;
      chunk = path[index].chunk;
      head  = path[index].head;

      table     = (table_stream *) c->cdata[chunk].t;
      cellarray = table->cells;

      if (cellarray) c = &cellarray[table->ColSpan * head->RowOffs + head->ColOffs];

      index--;
    }

    return c;
  }

  return NULL;
}

/**************************************************************/
/* tokenutils_token_cell()                                    */
/*                                                            */
/* Returns the reformat_cell that a given token lies in. This */
/* may be NULL.                                               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             Pointer to the token.                          */
/**************************************************************/

const reformat_cell * tokenutils_token_cell
                      (
                        const browser_data * restrict b,
                        const HStream      * restrict token
                      )
{
  table_headdata * restrict head;
  table_row      * restrict row;
  table_stream   * restrict table;

  reformat_cell  *          cellarray;
  int                       cellnumber;

  if (!b || !token) return NULL;

  /* Find the table the token lies in */

  head = token->parent;
  if (!head) return NULL;

  row = head->parent;
  if (!row) return NULL;

  table = row->parent;
  if (!table) return NULL;

  cellarray = table->cells;
  if (!cellarray) return NULL;

  /* Work out what number this cell is in the cell array */

  cellnumber = head->ColOffs + table->ColSpan * head->RowOffs;

  if (cellnumber > table->ncells) return NULL;
  else                            return &cellarray[cellnumber];
}

/**************************************************************/
/* tokenutils_token_cell_offset()                             */
/*                                                            */
/* When a token has been found to lie in a table              */
/* (tokenutils_line_range has filled in an array of           */
/* token_path structures) this call can be used to quickly    */
/* find the x and y offset from the top left of the main page */
/* that the line list the token was in is positioned at (i.e. */
/* for tables, the offset of the table cell the token lies    */
/* in). This can be used as an origin shift for any           */
/* subsequent redraws (say).                                  */
/*                                                            */
/* External callers trying to then find the token x and y     */
/* position should remember to work this out for the correct  */
/* line array, which will be indicated by the first entry in  */
/* the token_path array.                                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token_path array;                          */
/*                                                            */
/*             Pointer to the token_path array;               */
/*                                                            */
/*             Pointer to an int, in which the x offset will  */
/*             be written;                                    */
/*                                                            */
/*             Pointer to an int, in which the y offset will  */
/*             be written.                                    */
/*                                                            */
/* Assumes:    Any pointer may be NULL. If the token_path     */
/*             array is NULL, then an offset of 0,0 is given. */
/**************************************************************/

void tokenutils_token_offset
     (
       const browser_data * restrict b,
       token_path         * restrict path,
       int                * restrict offset_x,
       int                * restrict offset_y
     )
{
  int             actx = 0, acty = 0;
  reformat_cell * cell = b->cell;

  /* Only start working things out if there's a token_path array */

  if (path && tokenutils_npaths)
  {
    int                             index = tokenutils_npaths - 1;
    int                             line, chunk;
    const table_stream   * restrict table;
    const table_headdata * restrict head;
    const reformat_cell  *          cellarray = NULL;
    const reformat_cell  *          c         = NULL;

    /* Find the line, chunk, headdata structure, table structure and */
    /* cell array for the last item in the token_path array.         */

    line      = path[index].line;
    chunk     = path[index].chunk;
    head      = path[index].head;
    table     = (table_stream *) cell->cdata[chunk].t;
    cellarray = table->cells;

    /* Increment by the offset of the top left of the table. */
    /* Since the last item in the array corresponds to the   */
    /* browser_data structure's cell array itself, here we   */
    /* use b->cell (stored in 'cell' above) rather than a    */
    /* table-derived cell.                                   */

    actx += redraw_start_x(b, cell, cell->cdata[chunk].t, line);
    acty += cell->ldata[line].y + cell->ldata[line].h;

    /* If there's a cell array, find the cell the current headdata */
    /* item is represented by.                                     */

    if (cellarray) c = &cellarray[table->ColSpan * head->RowOffs + head->ColOffs];

    /* If there's a cell, offset actx and acty by the top left */
    /* hand offset of that cell.                               */

    if (c)
    {
      int incx, incy;

      convert_pair_to_os(c->x, c->y, &incx, &incy);

      actx += incx, acty += incy;
    }

    /* Now do much the same for the remaining items in the token_path array */

    index--;

    while (index >= 0 && c && c->ldata && c->cdata)
    {
      line      = path[index].line;
      chunk     = path[index].chunk;
      head      = path[index].head;
      table     = (table_stream *) c->cdata[chunk].t;
      cellarray = table->cells;

      actx += redraw_start_x(b, c, c->cdata[chunk].t, line);
      acty += c->ldata[line].y + c->ldata[line].h;

      if (cellarray) c = &cellarray[table->ColSpan * head->RowOffs + head->ColOffs];

      if (c)
      {
        int incx, incy;

        convert_pair_to_os(c->x, c->y, &incx, &incy);

        actx += incx, acty += incy;
      }

      index--;
    }
  }

  /* actx and acty will either have been calculated from the token_path */
  /* array or will still be at 0 if no array was given.                 */

  if (offset_x) *offset_x = actx;
  if (offset_y) *offset_y = acty;

  return;
}

/**************************************************************/
/* tokenutils_within_distance()                               */
/*                                                            */
/* Returns 1 if a given token is within a given distance of   */
/* another, vertically.                                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the tokens;                                    */
/*                                                            */
/*             Pointer to the first token;                    */
/*                                                            */
/*             Pointer to the second token;                   */
/*                                                            */
/*             Distance that the tokens must be within.       */
/*                                                            */
/* Returns:    1 if the tokens are within the given distance  */
/*             of each other, else 0.                         */
/*                                                            */
/* Assumes:    If either HStream pointer is NULL the function */
/*             return 1.                                      */
/**************************************************************/

int tokenutils_within_distance
    (
      const browser_data * restrict b,
      const HStream      * restrict t1,
      const HStream      * restrict t2,
      int                           distance
    )
{
  int             lfir1, llas1, lfir2, llas2;
  int             check;
  reformat_cell * cell = b->cell;

  if (!t1 || !t2) return 1;

  /* Ensure distance is a positive number and find the */
  /* lines that the tokens span.                       */

  if (distance < 0) distance = -distance;

  tokenutils_line_range(b, t1, &lfir1, NULL, &llas1, NULL, NULL);
  tokenutils_line_range(b, t2, &lfir2, NULL, &llas2, NULL, NULL);

  /* Special case, tokens must be at zero distance effectively */

  if (lfir1 == lfir2 || llas1 == llas2) return 1;

  /* Want to ensure that the maximum distance between the tokens */
  /* is taken for the check. E.g. if t1 is above t2 (i.e. lfir1  */
  /* is less than lfir2) then want to check the distance between */
  /* the top line of t1 to the bottom line of t2.                */

  if (lfir1 < lfir2) check = cell->ldata[lfir1].y + cell->ldata[lfir1].h - cell->ldata[lfir2].y;
  else               check = cell->ldata[lfir2].y + cell->ldata[lfir2].h - cell->ldata[lfir1].y;

  return (check <= distance);
}

/**************************************************************/
/* tokenutils_background_colour()                             */
/*                                                            */
/* See what background colour should be used for a body text  */
/* token; deals with tables, going down through the structure */
/* until something with a background colour is found (just    */
/* checking the immediate local table or cell is not good     */
/* enough as a background colour from an outer level table as */
/* part of a nested set of cells may be what is showing       */
/* through).                                                  */
/*                                                            */
/* If there's no table-based colour, -1 is returned (use      */
/* redraw_backcol, say, in this case). If the browser is      */
/* configured to not use document colours, this'll still      */
/* return a colour if it finds one specified in the table     */
/* structure (so if the display configuration matters to the  */
/* caller, the caller must deal with this itself).            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             Pointer to the HStream struct who's background */
/*             colour should be returned.                     */
/*                                                            */
/* Returns:    Background colour as BBGGRR00, or -1 if none   */
/*             was found (so you should use redraw_backcol()  */
/*             or any page background image).                 */
/**************************************************************/

int tokenutils_background_colour
    (
      const browser_data * restrict b,
      const HStream      * restrict t
    )
{
  while (t && t->parent)
  {
    table_headdata * head  = t->parent;
    table_row      * row   = NULL;
    table_stream   * table = NULL;

    if (head) row   = head->parent;
    if (row)  table = row->parent;

    if (table)
    {
      if (TD_HAS_BGCOL(head))     return TD_BGCOL(head);
      if (TABLE_HAS_BGCOL(table)) return TABLE_BGCOL(table);
    }

    t = (HStream *) table;
  }

  return -1;
}
@


1.16
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d59 12
a70 1
static int tokenutils_line_range_r(int toplevel, browser_data * b, reformat_cell * d, HStream * token, int * fline, int * fchunk, int * lline, int * lchunk, token_path ** path);
d104 7
a110 1
void tokenutils_anchor_range(browser_data * b, HStream * token, HStream ** first, HStream ** last)
d112 3
a114 3
  HStream * top   = NULL;
  HStream * end   = NULL;
  HStream * store = NULL;
d183 2
a184 2
  if (first) *first = top;
  if (last)  *last  = end;
d228 10
a237 2
int tokenutils_line_range(browser_data * b, HStream * token,
                          int * fline, int * fchunk, int * lline, int * lchunk, token_path ** path)
d242 9
a250 1
  return tokenutils_line_range_r(1, b, b->cell, token, fline, fchunk, lline, lchunk, path);
d291 12
a302 2
static int tokenutils_line_range_r(int toplevel, browser_data * b, reformat_cell * d, HStream * token,
                                   int * fline, int * fchunk, int * lline, int * lchunk, token_path ** path)
d346 9
a354 9
            table_stream   * table     = (table_stream *) d->cdata[cc].t;
            table_row      * row       = NULL;
            table_headdata * head      = NULL;
            reformat_cell  * cellarray = table->cells;
            reformat_cell  * cell;
            int              found     = 0;
            int              cellindex;
            int              cellcount = 0;
            int              cellmax   = table->ColSpan * table->RowSpan;
d594 5
a598 1
int tokenutils_find_ancestor_line(browser_data * b, HStream * t)
d600 3
a602 3
  table_headdata * head;
  table_row      * row;
  table_stream   * table;
d687 10
a696 1
void tokenutils_find_token(browser_data * b, reformat_cell * d, HStream * token, int * fline, int * fchunk, int * lline, int * lchunk)
d804 125
d960 7
a966 1
void tokenutils_token_offset(browser_data * b, token_path * path, int * offset_x, int * offset_y)
d975 6
a980 6
    int              index = tokenutils_npaths - 1;
    int              line, chunk;
    table_stream   * table;
    table_headdata * head;
    reformat_cell  * cellarray = NULL;
    reformat_cell  * c         = NULL;
a1056 116
/* tokenutils_find_cell()                                     */
/*                                                            */
/* Examines a token_path array and returns the address of the */
/* reformat_cell structure that corresponds to the last       */
/* entry.                                                     */
/*                                                            */
/* Parameters: Pointer to the reformat_cell that the          */
/*             token_path array refers to in the first entry  */
/*             (e.g. the 'cell' field of the parent           */
/*             browser_data structure);                       */
/*                                                            */
/*             Number of entries in the array;                */
/*                                                            */
/*             Pointer to the first entry.                    */
/*                                                            */
/* Returns:    Pointer to the reformat_cell structure         */
/*             corresponding to the last entry, or NULL if    */
/*             none may be found.                             */
/**************************************************************/

reformat_cell * tokenutils_find_cell(reformat_cell * cell, int depth, token_path * path)
{
  if (depth && path && path[0].line >= 0 && path[depth - 1].line >= 0)
  {
    table_stream   * table;
    table_headdata * head;
    reformat_cell  * cellarray    = NULL;
    reformat_cell  * c            = NULL;
    int              index        = depth - 1;
    int              line, chunk;

    /* Start looking at the token_path array. The last */
    /* entry refers to the main line array, so get to  */
    /* the appropriate reformat_cell structure through */
    /* the main line list.                             */

    line  = path[index].line;
    chunk = path[index].chunk;
    head  = path[index].head;

    table     = (table_stream *) cell->cdata[chunk].t;
    cellarray = table->cells;

    if (cellarray) c = &cellarray[table->ColSpan * head->RowOffs + head->ColOffs];

    index--;

    /* Need to look at subsequent cell line arrays for any */
    /* nested tables.                                      */

    while (index >= 0 && c)
    {
      line  = path[index].line;
      chunk = path[index].chunk;
      head  = path[index].head;

      table     = (table_stream *) c->cdata[chunk].t;
      cellarray = table->cells;

      if (cellarray) c = &cellarray[table->ColSpan * head->RowOffs + head->ColOffs];

      index--;
    }

    return c;
  }

  return NULL;
}

/**************************************************************/
/* tokenutils_token_cell()                                    */
/*                                                            */
/* Returns the reformat_cell that a given token lies in. This */
/* may be NULL.                                               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             Pointer to the token.                          */
/**************************************************************/

reformat_cell * tokenutils_token_cell(browser_data * b, HStream * token)
{
  table_headdata * head;
  table_row      * row;
  table_stream   * table;

  reformat_cell  * cellarray;
  int              cellnumber;

  if (!b || !token) return NULL;

  /* Find the table the token lies in */

  head = token->parent;
  if (!head) return NULL;

  row = head->parent;
  if (!row) return NULL;

  table = row->parent;
  if (!table) return NULL;

  cellarray = table->cells;
  if (!cellarray) return NULL;

  /* Work out what number this cell is in the cell array */

  cellnumber = head->ColOffs + table->ColSpan * head->RowOffs;

  if (cellnumber > table->ncells) return NULL;
  else                            return &cellarray[cellnumber];
}

/**************************************************************/
d1078 7
a1084 1
int tokenutils_within_distance(browser_data * b, HStream * t1, HStream * t2, int distance)
d1144 5
a1148 1
int tokenutils_background_colour(browser_data * b, HStream * t)
@


1.15
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d55 1
a55 1
static tokenutils_npaths = 0;
@


1.14
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a44 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

@


1.13
log
@Long overdue check-in of intermediate browser build, from continued "out
of hours" work. Forgot to add a few files last time too.

List dialogue box handler complete, and exclusion lists implemented
within the main browser code. Full documentation in Choices file.
Save routine knows all about it but is now getting very slow - must
come up with a better scheme; for now, it puts the hourglass on...

StripExtensions option controls auto stripping of filename extensions.

More sensible ancestor / frame selection for keyboard shortcut items
and the save dialogues - having selected a frame won't lock you into
it for F3 and related shortcuts now (input focus in URL writable ->
get ancestor details, input focus in frame -> get frame details). F4
works in frames. F5 now generally present for 'view source' with a
corresponding menu entry in the File menu.

Odd thing in later Res files; there's no action set for Adjust clicks
on the main ToolAction items in the button bar. Very odd. Nothing
appears to be set in v2.07 either, yet adjust-click works. Even
stranger. Anyway, added in the relevant event details (same as for
Select click in all cases) and this fixes the problem.

Background colours in the TABLE tag ignored the "don't print any
backgrounds" Print Style setting. Fixed. Meanwhile, the "black
text with no backgrounds" option wasn't getting this right either;
fixed this also.

Event logging implemented; HTTP errors and script output via.
window.print extension. No internal error output yet.

Faith:Never behaviour extended. If ever a server sends something with
no content type or an unhandleable type, the browser will try and get a
filetype from the URL. If it gets text or HTML, it'll render the file.
Else it'll save it. Hacks around IIS 4's lack of a content type field
in the Marketeye login stuff, and similar other slightly broken sites.
@
text
@d15 13
a27 10
/***************************************************/
/* File   : TokenUtils.c                           */
/*                                                 */
/* Purpose: Utility functions for finding out      */
/*          information about tokens.              */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 09-Apr-97: Created.                    */
/***************************************************/
d33 1
a33 1
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */
d35 14
a48 3
#include "wimp.h"
#include "wimplib.h"
#include "event.h"
a49 7
#include "swis.h"
#include "kernel.h"

#include "toolbox.h"
#include "event.h"

#include "svcprint.h"
d66 31
a96 35
/*************************************************/
/* tokenutils_anchor_range()                     */
/*                                               */
/* Will return the first (inclusive) and last    */
/* (inclusive) tokens that consecutively point   */
/* to the same thing as anchors. This is useful  */
/* as some links may be made of several tokens,  */
/* as style changes to mark the result of a web  */
/* search (for example) or whatever may be used  */
/* in what is meant to be the same link. If this */
/* link is to be highlighted or selected, need   */
/* to know which tokens are involved.            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the tokens;           */
/*                                               */
/*             Pointer to one of the tokens in   */
/*             the collection for this anchor;   */
/*                                               */
/*             Pointer to an HStream pointer,    */
/*             into which the address of the     */
/*             first token involved in the link  */
/*             is placed;                        */
/*                                               */
/*             Pointer to an HStream pointer,    */
/*             into which the address of the     */
/*             last token involved in the link   */
/*             is placed.                        */
/*                                               */
/* Assumes:    Either of the last two pointers   */
/*             may be NULL. The token pointer    */
/*             given at the start should point   */
/*             to a link. If not, the returned   */
/*             addresses will be undefined...    */
/*************************************************/
d177 38
a214 42
/*************************************************/
/* tokenutils_line_range()                       */
/*                                               */
/* Returns the first chunk and line number to    */
/* use a given token, and the last line and      */
/* chunk number to use that token.               */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token;            */
/*                                               */
/*             Pointer to the token;             */
/*                                               */
/*             Pointer to an int, into which the */
/*             first line number is placed;      */
/*                                               */
/*             Pointer to an int, into which the */
/*             first chunk number is placed;     */
/*                                               */
/*             Pointer to an int, into which the */
/*             last line number is placed;       */
/*                                               */
/*             Pointer to an int, into which the */
/*             last chunk number is placed;      */
/*                                               */
/*             Pointer to a token_path pointer,  */
/*             which will be filled in with the  */
/*             address of a malloced array of    */
/*             reformat_cell structures for      */
/*             tokens within tables, or NULL if  */
/*             this shouldn't be built.          */
/*                                               */
/* Returns:    See parameters list, and note     */
/*             that '-1' will be returned in all */
/*             four fields should be token not   */
/*             be found in a line to start with; */
/*                                               */
/*             The number of entries in the      */
/*             associated token_path structure   */
/*             for table-based tokens.           */
/*                                               */
/* Assumes:    Any of the pointers may be NULL.  */
/*************************************************/
d225 37
a261 40
/*************************************************/
/* tokenutils_line_range_r()                     */
/*                                               */
/* Recursive back-end to tokenutils_line_range.  */
/*                                               */
/* Parameters: 1 for a top level call, else 0 if */
/*             being called recursively;         */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             relevant to the token;            */
/*                                               */
/*             Pointer to a reformat_cell struct */
/*             containing the token or a table   */
/*             which holds the token;            */
/*                                               */
/*             Pointer to the token;             */
/*                                               */
/*             Pointer to an int, into which the */
/*             first line number is placed;      */
/*                                               */
/*             Pointer to an int, into which the */
/*             first chunk number is placed;     */
/*                                               */
/*             Pointer to an int, into which the */
/*             last line number is placed;       */
/*                                               */
/*             Pointer to an int, into which the */
/*             last chunk number is placed;      */
/*                                               */
/*             Pointer to a token_path pointer,  */
/*             which will be filled in with the  */
/*             address of a malloced array of    */
/*             token_path structures for tokens  */
/*             within tables, or NULL if this    */
/*             shouldn't be built.               */
/*                                               */
/* Returns:    As for tokenutils_line_range.     */
/*                                               */
/* Assumes:    As for tokenutils_line_range.     */
/*************************************************/
d537 18
a554 20
/*************************************************/
/* tokenutils_find_ancestor_line()               */
/*                                               */
/* Returns the line in a given browser's main    */
/* line list in which a given token lies, or -1  */
/* if the token can't be found.                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token and lines;  */
/*                                               */
/*             Pointer to the HStream struct to  */
/*             find.                             */
/*                                               */
/* Returns:    Line number that the token lies   */
/*             in, in the main line list - so    */
/*             the token could well lie inside   */
/*             a table within that line. -1 is   */
/*             returned if the token is not      */
/*             found in the line list at all.    */
/*************************************************/
d612 32
a643 35
/*************************************************/
/* tokenutils_find_token                         */
/*                                               */
/* For a given token in a given reformat_cell,   */
/* returns the line and chunk number that the    */
/* token spans.                                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token;            */
/*                                               */
/*             Pointer to a reformat_cell struct */
/*             containing the token or a table   */
/*             which holds the token;            */
/*                                               */
/*             Pointer to the token;             */
/*                                               */
/*             Pointer to an int, into which the */
/*             first line number is placed;      */
/*                                               */
/*             Pointer to an int, into which the */
/*             first chunk number is placed;     */
/*                                               */
/*             Pointer to an int, into which the */
/*             last line number is placed;       */
/*                                               */
/*             Pointer to an int, into which the */
/*             last chunk number is placed;      */
/*                                               */
/* Returns:    See parameters list, and note     */
/*             that '-1' will be returned in all */
/*             four fields should be token not   */
/*             be found in a line to start with; */
/*                                               */
/* Assumes:    Any of the pointers may be NULL.  */
/*************************************************/
d752 31
a782 35
/*************************************************/
/* tokenutils_token_cell_offset()                */
/*                                               */
/* When a token has been found to lie in a table */
/* (tokenutils_line_range has filled in an       */
/* array of token_path structures) this call     */
/* can be used to quickly find the x and y       */
/* offset from the top left of the main page     */
/* that the line list the token was in is        */
/* positioned at (i.e. for tables, the offset of */
/* the table cell the token lies in). This can   */
/* be used as an origin shift for any subsequent */
/* redraws (say).                                */
/*                                               */
/* External callers trying to then find the      */
/* token x and y position should remember to     */
/* work this out for the correct line array,     */
/* which will be indicated by the first entry    */
/* in the token_path array.                      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token_path array; */
/*                                               */
/*             Pointer to the token_path array;  */
/*                                               */
/*             Pointer to an int, in which the   */
/*             x offset will be written;         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             y offset will be written.         */
/*                                               */
/* Assumes:    Any pointer may be NULL. If the   */
/*             token_path array is NULL, then    */
/*             an offset of 0,0 is given.        */
/*************************************************/
d874 20
a893 22
/*************************************************/
/* tokenutils_find_cell()                        */
/*                                               */
/* Examines a token_path array and returns the   */
/* address of the reformat_cell structure that   */
/* corresponds to the last entry.                */
/*                                               */
/* Parameters: Pointer to the reformat_cell that */
/*             the token_path array refers to in */
/*             the first entry (e.g. the 'cell'  */
/*             field of the parent browser_data  */
/*             structure);                       */
/*                                               */
/*             Number of entries in the array;   */
/*                                               */
/*             Pointer to the first entry.       */
/*                                               */
/* Returns:    Pointer to the reformat_cell      */
/*             structure corresponding to the    */
/*             last entry, or NULL if none may   */
/*             be found.                         */
/*************************************************/
d945 11
a955 11
/*************************************************/
/* tokenutils_token_cell()                       */
/*                                               */
/* Returns the reformat_cell that a given token  */
/* lies in. This may be NULL.                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token;            */
/*                                               */
/*             Pointer to the token.             */
/*************************************************/
d990 21
a1010 23
/*************************************************/
/* tokenutils_within_distance()                  */
/*                                               */
/* Returns 1 if a given token is within a given  */
/* distance of another, vertically.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the tokens;           */
/*                                               */
/*             Pointer to the first token;       */
/*                                               */
/*             Pointer to the second token;      */
/*                                               */
/*             Distance that the tokens must be  */
/*             within.                           */
/*                                               */
/* Returns:    1 if the tokens are within the    */
/*             given distance of each other,     */
/*             else 0.                           */
/*                                               */
/* Assumes:    If either HStream pointer is NULL */
/*             the function return 1.            */
/*************************************************/
d1043 28
a1070 33
/*************************************************/
/* tokenutils_background_colour()                */
/*                                               */
/* See what background colour should be used for */
/* a body text token; deals with tables, going   */
/* down through the structure until something    */
/* with a background colour is found (just       */
/* checking the immediate local table or cell is */
/* not good enough as a background colour from   */
/* an outer level table as part of a nested set  */
/* of cells may be what is showing through).     */
/*                                               */
/* If there's no table-based colour, -1 is       */
/* returned (use redraw_backcol, say, in this    */
/* case). If the browser is configured to not    */
/* use document colours, this'll still return a  */
/* colour if it finds one specified in the table */
/* structure (so if the display configuration    */
/* matters to the caller, the caller must deal   */
/* with this itself).                            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token;            */
/*                                               */
/*             Pointer to the HStream struct     */
/*             who's background colour should be */
/*             returned.                         */
/*                                               */
/* Returns:    Background colour as BBGGRR00,    */
/*             or -1 if none was found (so you   */
/*             should use redraw_backcol() or    */
/*             any page background image).       */
/*************************************************/
@


1.12
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d564 3
a566 3
  int          l;
  int          chunk, depth, noline = 0;
  token_path * path = NULL;
d568 1
a568 1
  depth = tokenutils_line_range(b, t, &l, &chunk, NULL, NULL, &path);
d570 5
a574 2
  if (l < 0) noline = 1;
  else
d576 4
a579 2
    /* If a line was found and depth is non-zero, the line was inside */
    /* a table - want to find the parent line of the table            */
d581 5
a585 2
    if (depth) l = path[depth - 1].line;
    if (l < 0) noline = 1;
d588 1
a588 1
  if (path) free(path);
d590 1
a590 1
  if (noline) return -1;
d592 24
a615 1
  return l;
@


1.11
log
@Another intermediate version, rather more stable than the last I hope.

Lazy clearing of backgrounds - pages with the same background image or
colour won't be cleared to grey when going from one to the next anymore.

BODY element onLoad script attribute implemented properly (beyond the
Customer hackery).

Images use independent flex blocks for URL and transient fetch data;
greatly improved data throughput in image system as a result. Image
renumbering implemented - speeds up closing of pages / frames with
many images. Image xref is still rather slow though and images with
a 0 width or height specified in the HTML still cause an incorrectly
formatted page to appear.

Have, I think, fixed the "stops anti-aliasing" bug. Noticed that some
background images are not being processed as Fast (e.g. at the
Fibblesnork Lego Guide) - that old problem has reappeared, then.

Background images would cross reference when two pages had the same
background colour set in <body> elements but one was configured to use
document colours and one wasn't (so xref should not occur). Code was
looking at b->background_colour; corrected to call redraw_backcol(b).

Titles were added to the history according to the fetch URL not the
display URL, though the former is more likely to be in the history due
to the code execution order in the fetcher; changed to see whether this
improves upon the rather hit and miss addition of titles.

The 'about:' page now gets entered into the history (makes for much more
sensible behaviour if it is configured as a Home page, for example).
@
text
@d1041 9
@


1.10
log
@*Don't* try to load FilterManager 0.18 in !Run[D] files. Requires
WindowManager 3.98. Sets URI handler environment variables for
http, ftp and gopher.

Fixed 'doesn't reformat for unsized images' bug - only happens when the
deferred reformatter is enabled, hadn't remembered to check this in my
debug build where this is turned off. Oops.

Caret position in forms could get left behind despite attempts to rectify
this in v1.31 - now fixed (and faster, fortunately).

Hourglass + percentage displayed for History and Image History when
loading - it can take a while for very big histories, though in
practice you only see the visit history loading (has to do a lot
more work, and is thus quite a bit slower than the image history).

POST forms worked when targetted to frames, but were broken when
not targetted! (Forms data inherited from one browser to the same
browser; ended up freeing the flex block...). Fixed.

Now support 303 response code (redirect to GET). Treated as 301, i.e.
not support if STRICT_PARSER is defined, otherwise drops through to
the 302 handling code.

Pointer shouldn't get stuck in odd shapes when going to a new page now;
it gets reset to a standard shape every time the null handler that
checks the position is called, though (whether or not the handler thinks
the pointer is over a different token, if that token is NULL, it sets
the standard shape). A possible work around would be for a browser to
remember the pointer shape too; that's for the future, though.

Early stage table formatting functions could blow themselves apart if
tables_count_table decided there were no rows, columns or both. A
net table size of zero cells is now dealt with; slow, partial table
fetches in multiple windows with image loading turned on will now
*hopefully* be stable, where v1.31 would have bombed out repeatedly.

A nested frameset within one document will now inherit the border
width (frame spacing) and border colour of its parent. This is done
by copying the maxlen and indent fields of the parent token over
the child, and note it's done in the browser (fetch_preprocess_token),
not HTMLLib.

Border colour on a FRAMESET now used, with the first colour on any
FRAME within it overriding, as in NN 4 and MSIE 4.

<LI> bullets really do stick to the text next to them now (I'd done
that in an experimental piece of code and forgotten to merge it back
before the last check-in).

Browse$HotlistURL/URIFile and Browse$HomeURL/URIFile now work from
_TaskName in the Messages file, and are thus of the generic form
<App>$HotlistURL etc. - Docs.Notes and Docs.User updated appropriately.

Event 0x11d00 through to 0x11d7f will make the browser look up Controls
file entries 'JumpTo00' through to 'JumpTo7f' and read a URL from them.
This will be fetched in the ancestor window of the source of the event,
or a new window if such an ancestor can't be found [for Daytona demo].

NB: Nasty frames-related crash at http://www.teledanmark.dk/menu/start.htm
is *not* fixed in this source. NOBR is not supported.
@
text
@d1028 48
@


1.9
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d944 1
d957 4
a960 1
  table = head->parent ? head->parent->parent : NULL;
@


1.8
log
@Implemented Message_PlugIn_ReshapeRequest, Message_PlugIn_Status and
Message_PlugIn_Busy. Plug-in code more robust when given invalid
browser instance handles by the plug-in.

Line spacing is now calculated on the basis of the normal style base serif
font, with all other fonts being forced into that line height. This does
mean that an unusually tall (say) sans serif font may get clipped. It
appears to be the only way to get around wildly different baseline
depths returned from the font metrics - you can't work out line spacing
based on each different font style; the line spacing will vary.

Table heighting (as opposed to widthing...) improved considerably; rowspan
can no longer cause very tall cells in odd places. Having trouble getting
rid of the single pixel breaks between vertically adjacent cells, though
I've not tried too hard. Widthing, though, seems fairly badly broken at
present... :-/

Set/clear of page_is_text flag made more robust (it looked as though there
was the potential for this to get stuck in a set state, though I've never
see the front-end behave in a manner which indicates this is the case).
The reformatter will now decrease leading if this flag is set (plain text
pages look daft with a line spacing that is OK for 'rich' text pages).
No reformatting is done if the page width changes by dragging on the
resize icon, though toggle size / full screen will still reformat even
if the contents are only text (browser needs to sort out various width
flags at this point).

Cut down on excessive redrawing when reformatting due to a change in
window dimensions is not done. If display_width hasn't changed, then no
redraw is needed. If this causes redraw problems, then whatever is
changing display_width needs investigating. It shouldn't be kludged
(basically) by forcing a redraw instead of a reformat.

TT/PRE/etc. text can now have a non-100% aspect ratio. 80-90% looks
best (ArcWeb, for example, uses 86%). New option 'TTAspect' in
the Choices files.

Debug builds link to a non-debug Unicode library now; stops stderr
being dumped to the bottom left of the screen if you've not redirected
it in the Run file.

RISC OS 3.1 seems to need more initial WimpSlot than later OS versions.
The 64 deep nested table set gives a 'No stack for trap handler' error
(which it really means in this case!) without 800K, even though 3.71
is happy with just 640K. So, the !Run file checks if Boot$OSVersion
is exactly 300, 310 or 311, and sets the WimpSlot accordingly.

!Run[D] files now require latest fetcher module versions (URL 0.21,
File 0.31, HTTP 0.58).
@
text
@d201 3
a203 3
/*             token_path structures for tokens  */
/*             within tables, or NULL if this    */
/*             shouldn't be built.               */
d748 1
a748 2
/* in the token_path array - preferably, use the */
/* tokenutils_coord_range function.              */
d930 41
d978 1
d980 1
d982 1
@


1.7
log
@Calling HtmlEndParse at the end of html_get_next_token and setting
up->context to NULL was wrong; fetch_fetcher would end up recalling
html_get_next_token later which would then call HtmlParse even though
the document parse had just finished! The HtmlEndParse call has now
been moved to fetch_stop.

Altered reformatter to claim fonts inside a browser, rather than
claiming them for nothing and losing them afterwards.

Got rid of TAG == TABLE and ISBODY tests, replacing with tagno == TAG_TABLE.
Removed all references to TD, TH, TR and TABLE in the style word.
@
text
@d542 46
@


1.6
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d310 1
a310 1
          if (d->cdata[cc].t->tag == TABLE && ISBODY(d->cdata[cc].t))
d467 1
a467 1
          /* Closure of 'if (d->cdata[cc].t->tag == TABLE && ISBODY(d->cdata[cc].t))' */
@


1.5
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@d434 2
a435 2
                    make_no_memory_error(1);
                    show_error_ret(&erb);
@


1.4
log
@Customer work complete, and this version just shipped. Had to comment out
the code in Main.c that sets the user agent string to fake Netscape, as the
persistent problems with forms in tables showed up much more on a modem
link - net result was that the customer's log in page didn't work. Not
faking Netscape gives an authorisation dialogue instead, allowing access
to the site even if not by the most elegant of methods.
@
text
@d15 10
a24 7
/*************************************************/
/* File   : TokenUtils.c                         */
/* Purpose: Utility functions for finding        */
/*          out information about tokens.        */
/* Author : A.D.Hodgkinson                       */
/* History: 09-Apr-97: Created                   */
/*************************************************/
d74 1
d77 1
d82 1
a718 2
/*                                               */
/* Returns:    See parameters list.              */
a934 2

/*************************************************/
@


1.3
log
@In the middle of customer support work.
@
text
@d98 2
d104 1
a104 1
    top = token;
d128 1
a128 1
       top = top->next ? top->next : NULL;
d130 1
a130 1
    end = token;
d156 1
a156 1
       end = end->prev ? end->prev : NULL;
@


1.2
log
@Supported client pull, through a generalised handing of the META tag.
@
text
@d95 3
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d123 1
a123 1
       top = top->next;
d151 1
a151 1
       end = end->prev;
@

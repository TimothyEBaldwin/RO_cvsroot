head	1.8;
access;
symbols
	Browse-2_16:1.8
	Browse-2_15:1.8
	Browse-2_14:1.8
	Browse-2_13:1.8
	Browse-2_12:1.8
	Browse-2_11:1.8
	Browse-2_10:1.8
	Browse-2_09:1.8
	ahodgkin_208_i4_2:1.8
	ahodgkin_208_i4:1.6
	ahodgkin_208_i3:1.6
	ahodgkin_208_i2:1.6
	ahodgkin_208_i1:1.5
	ahodgkin_207release:1.4
	ahodgkin_206release:1.1;
locks; strict;
comment	@# @;


1.8
date	2000.11.14.08.45.06;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.31.15.58.39;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.25.17.08.52;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	99.09.02.13.10.23;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	98.10.06.09.28.54;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	98.09.23.13.18.09;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	98.09.07.11.46.53;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	98.07.09.10.27.13;	author ahodgkin;	state Exp;
branches;
next	;


desc
@@


1.8
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    JSwindow.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: JavaScript support - Window objects. Based in     */
/*          part on source in libmocha from the Mozilla       */
/*          browser sources.                                  */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 06-May-1998 (ADH): Created.                       */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include "Global.h"
#include "FromROSLib.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "EventLogs.h"
#include "Fetch.h"
#include "FetchPage.h"
#include "Filetypes.h"
#include "Frames.h"
#include "Handlers.h"
#include "History.h"
#include "JavaScript.h"
#include "Memory.h"
#include "Toolbars.h"
#include "URLutils.h"
#include "Windows.h"

#ifdef JAVASCRIPT

  #include "JSconsts.h"
  #include "JSdocument.h"
  #include "JSnavigtr.h"
  #include "JSscreen.h"
  #include "JSURL.h"

  #include "JSwindow.h"

  /* Local compilation options: Minimum window width and */
  /* height, in pixels, for window.open().               */

  #define JSWindow_Minimum_Width  100
  #define JSWindow_Minimum_Height 100

  /* Static function prototypes */

  PR_STATIC_CALLBACK(JSBool) jswindow_get_property    (JSContext * cx, JSObject * obj, jsval id, jsval * vp);
  PR_STATIC_CALLBACK(JSBool) jswindow_set_property    (JSContext * cx, JSObject * obj, jsval id, jsval * vp);
  PR_STATIC_CALLBACK(JSBool) jswindow_list_properties (JSContext * cx, JSObject * obj);
  PR_STATIC_CALLBACK(JSBool) jswindow_resolve_name    (JSContext * cx, JSObject * obj, jsval id);
  PR_STATIC_CALLBACK(void)   jswindow_finalise        (JSContext * cx, JSObject * obj);

  PR_STATIC_CALLBACK(JSBool) jswindow_alert           (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_confirm         (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_home            (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_stop            (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_forward         (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_back            (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_blur            (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_focus           (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_open            (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_close           (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(JSBool) jswindow_print           (JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * rval);

  static int                 jswindow_has_option      (char * options, const char * name);
  static int                 jswindow_option_set      (char * options, const char * name);

  static void                jswindow_make_outer_bbox (BBox * size);
  static void                jswindow_make_inner_bbox (BBox * size);
  static void                jswindow_move_bbox       (BBox * size, int x, int y);
  static void                jswindow_convert_to_area (BBox * size);

  /* Window object property IDs */

  enum window_slot
  {
    WIN_LENGTH              = -1,
    WIN_FRAMES              = -2,
    WIN_PARENT              = -3,
    WIN_TOP                 = -4,
    WIN_SELF                = -5,
    WIN_NAME                = -6,
    WIN_STATUS              = -7,
    WIN_DEFAULT_STATUS      = -8,
    WIN_OPENER              = -9,
    WIN_CLOSED              = -10,
    WIN_WIDTH               = -11,
    WIN_HEIGHT              = -12,
    WIN_OUTWIDTH            = -13,
    WIN_OUTHEIGHT           = -14,
    WIN_XPOS                = -15,
    WIN_YPOS                = -16,
    WIN_XOFFSET             = -17,
    WIN_YOFFSET             = -18,
    WIN_SECURE              = -19,
    WIN_LOADING             = -20,
    WIN_FRAMERATE           = -21,
    WIN_OFFSCREEN_BUFFERING = -22
  };

  #define IS_INSECURE_SLOT(s) (WIN_LOADING <= (s) && (s) <= WIN_CLOSED)

  /* Window object property definitions */

  static JSPropertySpec jswindow_properties[] =
  {
    { "length",             WIN_LENGTH,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "frames",             WIN_FRAMES,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "parent",             WIN_PARENT,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "top",                WIN_TOP,                 JSPROP_ENUMERATE | JSPROP_READONLY },
    { "self",               WIN_SELF,                JSPROP_ENUMERATE | JSPROP_READONLY },
    { "window",             WIN_SELF,                JSPROP_READONLY                    },
    { "name",               WIN_NAME,                JSPROP_ENUMERATE                   },
    { "status",             WIN_STATUS,              JSPROP_ENUMERATE                   },
    { "defaultStatus",      WIN_DEFAULT_STATUS,      JSPROP_ENUMERATE                   },
    { lm_opener_str,        WIN_OPENER,              JSPROP_ENUMERATE                   },
    { lm_closed_str,        WIN_CLOSED,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "innerWidth",         WIN_WIDTH,               JSPROP_ENUMERATE                   },
    { "innerHeight",        WIN_HEIGHT,              JSPROP_ENUMERATE                   },
    { "outerWidth",         WIN_OUTWIDTH,            JSPROP_ENUMERATE                   },
    { "outerHeight",        WIN_OUTHEIGHT,           JSPROP_ENUMERATE                   },
    { "screenX",            WIN_XPOS,                JSPROP_ENUMERATE                   },
    { "screenY",            WIN_YPOS,                JSPROP_ENUMERATE                   },
    { "pageXOffset",        WIN_XOFFSET,             JSPROP_ENUMERATE | JSPROP_READONLY },
    { "pageYOffset",        WIN_YOFFSET,             JSPROP_ENUMERATE | JSPROP_READONLY },
    { "secure",             WIN_SECURE,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "frameRate",          WIN_FRAMERATE,           JSPROP_ENUMERATE                   },
    { "offscreenBuffering", WIN_OFFSCREEN_BUFFERING, JSPROP_ENUMERATE                   },
    { 0 }
  };

  /* Method table for Window object */

  static JSFunctionSpec jswindow_methods[] =
  {
    { "alert",                  jswindow_alert,                    1 },
//  { "clearTimeout",           jswindow_clear_timeout,            1 },
//  { "clearInterval",          jswindow_clear_timeout,            1 },
    { "close",                  jswindow_close,                    0 },
    { "confirm",                jswindow_confirm,                  1 },
    { "open",                   jswindow_open,                     1 },
//  { "setZOptions",            jswindow_set_zoptions,             1 },
//  { "setHotkeys",             jswindow_set_hotkeys,              1 },
//  { "setResizable",           jswindow_set_resizable,            1 },
//  { "prompt",                 jswindow_prompt,                   2 },
//  { setTimeout_str,           jswindow_set_timeout,              2 },
//  { setInterval_str,          jswindow_set_interval,             2 },
//  { "delay",                  jswindow_delay,                    0 },
//  { "escape",                 jswindow_escape,                   2 },
//  { "unescape",               jswindow_unescape,                 1 },
    { lm_blur_str,              jswindow_blur,                     0 },
    { lm_focus_str,             jswindow_focus,                    0 },
//  { lm_scroll_str,            jswindow_scroll_to,                2 },
//  { "scrollTo",               jswindow_scroll_to,                2 },
//  { "scrollBy",               jswindow_scroll_by,                2 },
//  { "moveTo",                 jswindow_move_to,                  2 },
//  { "moveBy",                 jswindow_move_by,                  2 },
//  { "resizeTo",               jswindow_resize_to,                2 },
//  { "resizeBy",               jswindow_resize_by,                2 },
//  { "captureEvents",          jswindow_capture_events,           1 },
//  { "releaseEvents",          jswindow_release_events,           1 },
//  { "enableExternalCapture",  jswindow_enable_external_capture,  0 },
//  { "disableExternalCapture", jswindow_disable_external_capture, 0 },
//  { "compromisePrincipals",   jswindow_compromise_principals,    0 },
//  { "downgradePrincipals",    jswindow_downgrade_principals,     0 },
    { "back",                   jswindow_back,                     0 },
    { "forward",                jswindow_forward,                  0 },
    { "home",                   jswindow_home,                     0 },
//  { "find",                   jswindow_find,                     0 },
//  { "print",                  jswindow_print,                    0 },
//  { "openFile",               jswindow_open_file,                0 },
    { "stop",                   jswindow_stop,                     0 },
//  { "atob",                   jswindow_atob,                     1 },
//  { "btoa",                   jswindow_btoa,                     1 },
//  { "taint",                  jswindow_taint_stub,               1 },
//  { "untaint",                jswindow_taint_stub,               1 },
    { "print",                  jswindow_print,                    1 },
    { 0 }
  };

  /* Class description for Window object */

  JSClass jswindow_class =
  {
    "Window", JSCLASS_HAS_PRIVATE,
    JS_PropertyStub,          JS_PropertyStub,        jswindow_get_property, jswindow_set_property,
    jswindow_list_properties, jswindow_resolve_name,  JS_ConvertStub,        jswindow_finalise
  };

  /**************************************************************/
  /* jswindow_new_window()                                      */
  /*                                                            */
  /* Create a new Window object for a given browser. Bring up   */
  /* related objects too.                                       */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct for which the */
  /*             object is to be created.                       */
  /*                                                            */
  /* Returns:    Pointer to the new object, or NULL for an      */
  /*             error.                                         */
  /**************************************************************/

  JSObject * jswindow_new_window(browser_data * b)
  {
    JSContext * cx;
    JSObject  * obj;

    dprintf(("JScr", "jswindow_new_window: Called for %p\n",b));

    cx  = b->bcx;

    if (!cx)
    {
      dprintf(("JScr", "jswindow_new_window: \0211Browser has no JSI context!\0217\n"));

      return JS_FALSE;
    }

    /* Create the object */

    obj = JS_NewObject(cx,
                       &jswindow_class,
                       NULL,
                       NULL);

    if (!obj)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not create Window object in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    b->window_object = obj;

    /* Add a GC root in case GC runs soon */

    if (
         !JS_AddNamedRoot(cx,
                          &b->window_object,
                          "window_object")
       )
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not add GC roots for Window object in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* Set the browser_data structure pointer as private data */

    if (!JS_SetPrivate(cx, obj, b))
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not set private data for Window object in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* Initialise standard classes in the Window object */

    if (!JS_InitStandardClasses(cx, obj))
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not initialise standard classes in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* Define the properties of the Window object */

    if (!JS_DefineProperties(cx, obj, jswindow_properties))
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not define Window object properties in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* Define the functions of the Window object */

    if (
         !JS_DefineFunctions(cx,
                             obj,
                             jswindow_methods)
       )
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not define Window object functions in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* The 'opener' object is created when window.open is used in a parent */
    /* to open a new window - it points back to that parent.               */

    if (b->opener)
    {
      if (
           !JS_DefinePropertyWithTinyId(cx,
                                        obj,
                                        lm_opener_str,
                                        WIN_OPENER,
                                        OBJECT_TO_JSVAL(b->opener),
                                        NULL,
                                        NULL,
                                        JSPROP_ENUMERATE)
         )
         return JS_FALSE;
    }

    /* Bring up all of the window property classes */

    jsdocument_initialise_class(b);
    jsdocument_define_document(b);
    jsurl_define_location(b);

//    JSObject *obj;
//
//    obj = decoder->window_object;
//    return (JSBool)(JS_DefineFunctions(cx, obj, lm_window_methods) &&
//           lm_InitEventClasses(decoder) &&
//           lm_InitDocumentClass(decoder) &&
//           lm_DefineDocument(decoder, LO_DOCUMENT_LAYER_ID) &&
//           lm_DefineHistory(decoder) &&
//           lm_DefineLocation(decoder) &&
//           lm_DefineCrypto(decoder) &&
//           lm_DefineBarClasses(decoder) &&
//           lm_InitLayerClass(decoder) &&
//           lm_InitRectClass(decoder) &&
//           lm_InitImageClass(decoder) &&
//           lm_InitAnchorClass(decoder) &&
//           lm_InitInputClasses(decoder) &&
//           lm_DefinePkcs11(decoder));

//   Round about line 3300 of lm_win.c...
//
//   What about JS_SetPrototype(cx, obj, decoder->event_capturer_prototype); ?

    /* Set up the relevant GC roots */

    #define HOLD(obj) if (!JS_AddNamedRoot(cx, &(obj), #obj)) return NULL

    HOLD(b->anchor_prototype);
    HOLD(b->bar_prototype);
    HOLD(b->document_prototype);
    HOLD(b->event_prototype);
    HOLD(b->event_capturer_prototype);
    HOLD(b->event_receiver_prototype);
    HOLD(b->form_prototype);
    HOLD(b->image_prototype);
    HOLD(b->input_prototype);
    HOLD(b->layer_prototype);
    HOLD(b->option_prototype);
    HOLD(b->rect_prototype);
    HOLD(b->url_prototype);

    HOLD(b->document);
    HOLD(b->history);
    HOLD(b->location);
    HOLD(b->navigator);
    HOLD(b->components);
    HOLD(b->crypto);
    HOLD(b->screen);
    HOLD(b->hardware);
    HOLD(b->pkcs11);

    HOLD(b->event_receiver);
    HOLD(b->opener);

    #undef HOLD

    return obj;
  }

  /**************************************************************/
  /* jswindow_destroy_window()                                  */
  /*                                                            */
  /* Destroy a given browser's Window and related objects.      */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct for which the */
  /*             object is to be created.                       */
  /**************************************************************/

  void jswindow_destroy_window(browser_data * b)
  {
    JSContext * cx  = b->bcx;
    JSObject  * obj = b->window_object;

    /* Do we have a JavaScript context? */

    if (!cx)
    {
      dprintf(("JScr", "jswindow_new_window: \0211Browser has no JSI context!\0217\n"));

      return;
    }

    /* In libmocha, it clears references before removing the GC */
    /* roots just by setting the pointers to NULL.              */

    /* Clear all object prototype refs. */

    b->anchor_prototype         = NULL;
    b->bar_prototype            = NULL;
    b->document_prototype       = NULL;
    b->event_prototype          = NULL;
    b->event_capturer_prototype = NULL;
    b->event_receiver_prototype = NULL;
    b->form_prototype           = NULL;
    b->image_prototype          = NULL;
    b->input_prototype          = NULL;
    b->layer_prototype          = NULL;
    b->option_prototype         = NULL;
    b->rect_prototype           = NULL;
    b->url_prototype            = NULL;

    /* Clear window sub-object refs. */

    if (b->document && obj)
    {
      JSDocument * doc = JS_GetPrivate(cx, b->document); /* (JSDocument defined in JSconsts.h) */

      if (doc)
      {
        doc->forms              = NULL;
        doc->links              = NULL;
        doc->anchors            = NULL;
        doc->applets            = NULL;
        doc->embeds             = NULL;
        doc->images             = NULL;
        doc->layers             = NULL;
      }
    }

    b->document                 = NULL;
    b->history                  = NULL;
    b->location                 = NULL;
    b->navigator                = NULL;
    b->components               = NULL;
    b->crypto                   = NULL;
    b->screen                   = NULL;
    b->hardware                 = NULL;
    b->pkcs11                   = NULL;

    /* Drop ad-hoc GC roots, but not opener -- it survives unloads. */

    b->event_receiver           = NULL;

    /* Deal with the Window object specially */

    if (obj)
    {
//    JS_ClearWatchPointsForObject (cx, obj);
      JS_ClearScope                (cx, obj);
    }

    // This is where you'd do a lm_closed_str property with tiny ID?
    // (void) JS_DefinePropertyWithTinyId(cx, obj, lm_closed_str, WIN_CLOSED,
    //                                            JSVAL_FALSE, NULL, NULL,
    //                                            JSPROP_ENUMERATE|JSPROP_READONLY);

    /* Remove GC roots */

    #define DROP(obj) JS_RemoveRoot(cx, &(obj))

    /* Drop all object prototype refs. */

    DROP(b->anchor_prototype);
    DROP(b->bar_prototype);
    DROP(b->document_prototype);
    DROP(b->event_prototype);
    DROP(b->event_capturer_prototype);
    DROP(b->event_receiver_prototype);
    DROP(b->form_prototype);
    DROP(b->image_prototype);
    DROP(b->input_prototype);
    DROP(b->layer_prototype);
    DROP(b->option_prototype);
    DROP(b->rect_prototype);
    DROP(b->url_prototype);

    /* Drop window sub-object refs. */

    DROP(b->document);
    DROP(b->history);
    DROP(b->location);
    DROP(b->navigator);
    DROP(b->components);
    DROP(b->crypto);
    DROP(b->screen);
    DROP(b->hardware);
    DROP(b->pkcs11);

    /* Drop ad-hoc GC roots. */

    DROP(b->event_receiver);
    DROP(b->opener);

    /* Remove the root that holds up the whole window in the decoder world */

    DROP(b->window_object);

    #undef DROP

    // Call JS_DestroyContext here?

    return;
  }

  /**************************************************************/
  /* jswindow_get_property()                                    */
  /*                                                            */
  /* Called when the interpreter is getting the value of a      */
  /* property in a Window object.                               */
  /*                                                            */
  /* Parameters as standard for an interpreter handler          */
  /* (callback) function.                                       */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_get_property(JSContext * cx, JSObject * obj, jsval id, jsval * vp)
  {
    browser_data * decoder;
    jsint          slot;
    JSString     * str;

    /* Get the decoder (browser) */

//    while (!(decoder = JS_GetInstancePrivate(cx, obj, &jswindow_class, NULL)))
//    {
//      obj = JS_GetPrototype(cx, obj);
//      if (!obj) return JS_TRUE;
//    }

    do
    {
      decoder = JS_GetInstancePrivate(cx,
                                      obj,
                                      &jswindow_class,
                                      NULL);

      if (!decoder)
      {
        obj = JS_GetPrototype(cx, obj);

        if (!obj) return JS_TRUE;
      }
    }
    while (!decoder);

    /* Allow anyone who can address this window to refer to its "window" and  */
    /* "self" properties, because they refer to the window already in hand by */
    /* the accessing script. Useful for layer scripts that 'import window.*'. */

    if (JSVAL_IS_INT(id) && JSVAL_TO_INT(id) == WIN_SELF)
    {
      *vp = OBJECT_TO_JSVAL(decoder->window_object);

      return JS_TRUE;
    }

    slot = JSVAL_IS_INT(id) ? JSVAL_TO_INT(id) : 0;

    // Now do stuff about WIN_CLOSED?

    if (!JSVAL_IS_INT(id)) return JS_TRUE;

    /* Deal with the various properties */

    switch (slot)
    {
      case WIN_LENGTH:
      {
        int length = 0;

        while (frames_find_browser_from_index(decoder, length)) length ++;

        *vp = INT_TO_JSVAL((int) (length - 1));
      }
      break;

      case WIN_FRAMES:
      {
        *vp = OBJECT_TO_JSVAL(decoder->window_object);
      }
      break;

      /* Return either the current Window object, or if we can find */
      /* one, the Window object for the parent.                     */
      /*                                                            */
      /* See utils_flat_parent for more information.                */

      case WIN_PARENT:
      {
        browser_data * parent;

        /* Find a suitable parent */

        parent = utils_flat_parent(decoder);

        *vp = OBJECT_TO_JSVAL(parent->window_object);
      }
      break;

      case WIN_TOP:
      {
        browser_data * ancestor = utils_ancestor(decoder);

        if (ancestor) *vp = OBJECT_TO_JSVAL(ancestor->window_object);
        else          *vp = OBJECT_TO_JSVAL(decoder->window_object);
      }
      break;

      case WIN_NAME:
      {
        if (decoder->window_name) str = JS_NewString(cx, decoder->window_name, strlen(decoder->window_name));
        else                      str = JS_NewString(cx, "", 0);

        if (!str) return JS_FALSE;

        *vp = STRING_TO_JSVAL(str);
      }
      break;

      case WIN_STATUS:
      {
        return JS_TRUE; /* From LibMocha: 'XXX can't get yet, return last known' */
      }
      break;

      case WIN_DEFAULT_STATUS:
      {
        // To be done

        return JS_TRUE;
      }
      break;

      case WIN_OPENER:
      {
        if (
             !JSVAL_IS_OBJECT(*vp) &&
             !JS_ConvertValue(cx, *vp, JSTYPE_OBJECT, vp)
           )
           return JS_FALSE;
      }
      break;

      case WIN_CLOSED:
      {
        *vp = JSVAL_FALSE;
      }
      break;

      case WIN_WIDTH:
      {
        WimpGetWindowStateBlock   state;
        _kernel_oserror         * e;

        /* Window inner width (visible area), pixels; assume */
        /* 2 OS units to 1 pixel in both directions to mimic */
        /* the perceptual units you see with Navigator under */
        /* Windows.                                          */

        state.window_handle = decoder->window_handle;

        e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) ((state.visible_area.xmax - state.visible_area.xmin) / 2));
      }
      break;

      case WIN_HEIGHT:
      {
        WimpGetWindowStateBlock   state;
        _kernel_oserror         * e;

        /* Window inner height (visible area), pixels; assume */
        /* 2 OS units to 1 pixel in both directions to mimic  */
        /* the perceptual units you see with Navigator under  */
        /* Windows.                                           */

        state.window_handle = decoder->window_handle;

        e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) ((state.visible_area.ymax - state.visible_area.ymin) / 2));
      }
      break;

      case WIN_OUTWIDTH:
      {
        WimpGetWindowOutlineBlock   outline;
        _kernel_oserror           * e;

        /* Window outer width (window outline), pixels; assume */
        /* 2 OS units to 1 pixel in both directions to mimic   */
        /* the perceptual units you see with Navigator under   */
        /* Windows.                                            */

        outline.window_handle = decoder->window_handle;

        e = wimp_get_window_outline(&outline);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) ((outline.outline.xmax - outline.outline.xmin) / 2));
      }
      break;

      case WIN_OUTHEIGHT:
      {
        WimpGetWindowOutlineBlock   outline;
        _kernel_oserror           * e;

        /* Window outer height (window outline), pixels; assume */
        /* 2 OS units to 1 pixel in both directions to mimic    */
        /* the perceptual units you see with Navigator under    */
        /* Windows.                                             */

        outline.window_handle = decoder->window_handle;

        e = wimp_get_window_outline(&outline);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) ((outline.outline.ymax - outline.outline.ymin) / 2));
      }
      break;

      case WIN_XPOS:
      {
        WimpGetWindowOutlineBlock   outline;
        _kernel_oserror           * e;

        /* Window outline top left X,Y coordinates required here, */
        /* again in pixels. TRHC is meant to be 0,0.              */

        outline.window_handle = decoder->window_handle;

        e = wimp_get_window_outline(&outline);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) (outline.outline.xmin / 2));
      }
      break;

      case WIN_YPOS:
      {
        WimpGetWindowOutlineBlock   outline;
        int                         wf, wl;
        _kernel_oserror           * e;

        /* Window outline top left X,Y coordinates - TRHC is 0,0. */
        /* RISC OS has 0,0 in the *bottom* left so we need to     */
        /* find the screen height out.                            */

        outline.window_handle = decoder->window_handle;

        e = wimp_get_window_outline(&outline);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        wf = bbc_modevar(-1, BBC_YEigFactor);
        wl = bbc_modevar(-1, BBC_YWindLimit);

        wl = (wl + 1) << wf;

        *vp = INT_TO_JSVAL((int) ((wl - outline.outline.ymax) / 2));
      }
      break;

      case WIN_XOFFSET:
      {
        WimpGetWindowStateBlock   state;
        _kernel_oserror         * e;

        /* X scroll offset, in pixels. 0 is fully left. */

        state.window_handle = decoder->window_handle;

        e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) (state.xscroll / 2));
      }
      break;

      case WIN_YOFFSET:
      {
        WimpGetWindowStateBlock   state;
        _kernel_oserror         * e;

        /* Y scroll offset, in pixels. 0 is scrolled to the top. */
        /* Other values are positive downwards.                  */

        state.window_handle = decoder->window_handle;

        e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) (-state.yscroll / 2));
      }
      break;

      case WIN_SECURE:
      {
        // To be done

        *vp = JSVAL_FALSE;
      }
      break;

      case WIN_LOADING:
      {
        if (fetch_fetching(decoder)) *vp = JSVAL_TRUE;
        else                         *vp = JSVAL_FALSE;
      }
      break;

      case WIN_FRAMERATE:
      {
        // To be done

        *vp = INT_TO_JSVAL(50);
      }
      break;

      case WIN_OFFSCREEN_BUFFERING:
      {
        *vp = JSVAL_FALSE;
      }
      break;

      default:
      {
        browser_data * frame;

        /* Don't mess with user-defined or method properties */

        if (slot < 0) return JS_TRUE;

        frame = frames_find_browser_from_index(decoder, slot);

        if (frame)
        {
          if (frame->window_object) *vp = OBJECT_TO_JSVAL(frame->window_object);
          else                      *vp = JSVAL_NULL;
        }
      }
      break;
    }

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_set_property()                                    */
  /*                                                            */
  /* Called when the interpreter is setting the value of a      */
  /* property in a Window object.                               */
  /*                                                            */
  /* Parameters as standard for an interpreter handler          */
  /* (callback) function.                                       */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_set_property(JSContext * cx, JSObject * obj, jsval id, jsval * vp)
  {
    browser_data * decoder;
    jsint          slot;
    jsdouble       size;
    char         * name;

    /* Get the decoder (browser) */

    do
    {
      decoder = JS_GetInstancePrivate(cx,
                                      obj,
                                      &jswindow_class,
                                      NULL);

      if (!decoder)
      {
        obj = JS_GetPrototype(cx, obj);

        if (!obj) return JS_TRUE;
      }
    }
    while (!decoder);

    if (!JSVAL_IS_INT(id))
    {
//        /* Due to the wonderful world of threads we need to know ahead of time if
//         * someone is setting an onMouseMove event handler here or in document so
//         * that we don't lose messages.*/
//        if (JS_TypeOfValue(cx, *vp) == JSTYPE_FUNCTION) {
//            if (JSVAL_IS_STRING(id)) {
//                prop_name = JS_GetStringBytes(JSVAL_TO_STRING(id));
//                /* XXX use lm_onMouseMove_str etc.*/
//                if (XP_STRCMP(prop_name, "onmousemove") == 0 ||
//                    XP_STRCMP(prop_name, "onMouseMove") == 0) {
//                    decoder->window_context->js_drag_enabled = TRUE;
//                }
//            }
//        }
      return JS_TRUE;
    }

    slot = JSVAL_TO_INT(id);

    /* For items which take a string, do the type */
    /* checking and conversion first              */

    switch (slot)
    {
      case WIN_NAME:
      case WIN_STATUS:
      case WIN_DEFAULT_STATUS:
      {
        if (
             !JSVAL_IS_STRING(*vp) &&
             !JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp)
           )
           return JS_FALSE;
      }
      break;
    }

    /* Now handle the actual property setting */

    switch (slot)
    {
      case WIN_NAME:
      {
        _kernel_oserror * e;

        name = JS_GetStringBytes(JSVAL_TO_STRING(*vp));

        if (!name) return JS_FALSE;

        /* Do we already have a name? */

        if (decoder->window_name)
        {
          browser_data * parent = utils_flat_parent(decoder);

          /* If the decoder is a frame, change its name in */
          /* its parent's scope.                           */

          if (parent)
          {
            JS_DeleteProperty(cx,
                              parent->window_object,
                              decoder->window_name);
          }
        }

        /* Set the new name for the current decoder */

        e = memory_set_chunk_size(decoder, NULL, CK_NAME, strlen(name) + 1);
        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        strcpy(decoder->window_name, name);
      }
      break;

      case WIN_XPOS:
      case WIN_YPOS:
      {
        WimpGetWindowStateBlock     state;
        WimpGetWindowOutlineBlock   outline;
        BBox                        screen;
        _kernel_oserror           * e;
        int                         new_x, new_y, wout, hout, lmarg, tmarg;
        ObjectId                    parent_o;
        ComponentId                 parent_c;

        /* Move the window, but keep it fully within the visible area */

        outline.window_handle = decoder->window_handle;
        state.window_handle   = decoder->window_handle;

        e = wimp_get_window_outline(&outline);
        if (!e) e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        /* Having got the window details, also find the screen size */

        screen.xmin = bbc_modevar(-1, BBC_XEigFactor);
        screen.ymin = bbc_modevar(-1, BBC_YEigFactor);
        screen.xmax = bbc_modevar(-1, BBC_XWindLimit);
        screen.ymax = bbc_modevar(-1, BBC_YWindLimit);

        screen.xmax = (screen.xmax + 1) << screen.xmin;
        screen.ymax = (screen.ymax + 1) << screen.ymin;

        /* Work out where to move to */

        if (!JS_ValueToNumber(cx, *vp, &size)) return JS_FALSE;

        if (slot == WIN_XPOS)
        {
          new_x = ((int) size) * 2;
          new_y = outline.outline.ymax;
        }
        else if (slot == WIN_YPOS)
        {
          /* 0,0 is *top* left in JavaScript, but bottom left in RISC OS */

          new_y = screen.ymax - (((int) size) * 2);
          new_x = outline.outline.xmin;
        }
        else
        {
          new_x = outline.outline.xmin;
          new_y = outline.outline.ymax;
        }

        /* Get the new outline bounding box */

        wout = outline.outline.xmax - outline.outline.xmin;
        hout = outline.outline.ymax - outline.outline.ymin;

        lmarg = state.visible_area.xmin - outline.outline.xmin;
        tmarg = outline.outline.ymax - state.visible_area.ymax;

        outline.outline.xmin = new_x;
        outline.outline.xmax = new_x + wout;
        outline.outline.ymin = new_y - hout;
        outline.outline.ymax = new_y;

        /* Make sure it is wholly inside the screen display. The ordering */
        /* of tests here makes sure that if the window is simply too big  */
        /* to fit, then the top left hand part will be visible.           */

        if (outline.outline.ymin < 0) outline.outline.ymax -= outline.outline.ymin, outline.outline.ymin = 0;

        if (outline.outline.xmax >= screen.xmax)
        {
          int diff = outline.outline.xmax - screen.xmax;

          outline.outline.xmin -= diff;
          outline.outline.xmax -= diff;
        }

        if (outline.outline.xmin < 0) outline.outline.xmax -= outline.outline.xmin, outline.outline.xmin = 0;

        if (outline.outline.ymax >= screen.ymax)
        {
          int diff = outline.outline.ymax - screen.ymax;

          outline.outline.ymin -= diff;
          outline.outline.ymax -= diff;
        }

        /* From the margins calculated earlier, work out the visible */
        /* area coordinates.                                         */

        state.visible_area.xmin = outline.outline.xmin + lmarg;
        state.visible_area.xmax = outline.outline.xmax + lmarg;

        state.visible_area.ymin = outline.outline.ymin - tmarg;
        state.visible_area.ymax = outline.outline.ymax - tmarg;

        /* Open the window in the new position */

        e = toolbox_get_parent(0, decoder->self_id, &parent_o, &parent_c);

        if (!e) e = toolbox_show_object(0,
                                        decoder->self_id,
                                        Toolbox_ShowObject_FullSpec,
                                        &state.visible_area,
                                        parent_o,
                                        parent_c);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }
      }
      break;

      case WIN_OPENER:
      {
        if (
             decoder->opener       &&
             !JSVAL_TO_OBJECT(*vp)
           )
           decoder->opener = NULL;
      }
      break;

    }

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_list_properties()                                 */
  /*                                                            */
  /* Help JavaScript list the properties of a Window object.    */
  /*                                                            */
  /* Parameters are as standard for a JavaScript property       */
  /* enumeration callback function.                             */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_list_properties(JSContext * cx, JSObject * obj)
  {
    browser_data * decoder;
    int            length = 0;
    int            slot;

    decoder = JS_GetPrivate(cx, obj);
    if (!decoder) return JS_TRUE;

    while (frames_find_browser_from_index(decoder, length)) length ++;

    if (length > 1)
    {
      for (slot = 0; slot < length; slot ++)
      {
        browser_data * frame = frames_find_browser_from_index(decoder, slot);

        if (
             !frame ||
             !JS_DefineProperty(cx,
                                decoder->window_object,
                                frame->window_name,
                                JSVAL_NULL,
                                NULL,
                                NULL,
                                JSPROP_ENUMERATE | JSPROP_READONLY)
           )
           return JS_FALSE;
      }
    }

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_resolve_name()                                    */
  /*                                                            */
  /* Help JavaScript work out what property a script is         */
  /* actually referring to in Window objects.                   */
  /*                                                            */
  /* Parameters are as standard for a JavaScript interpreter    */
  /* name resolver callback function.                           */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_resolve_name(JSContext * cx, JSObject * obj, jsval id)
  {
    char         * name = NULL;
    browser_data * decoder;
    browser_data * frame;
    jsint          slot;
    JSObject     * window_obj;

    /* Don't resolve any of names if id is on the left side of an = op. */

    if (JS_IsAssigning(cx))   return JS_TRUE;

    /* Can only resolve names (i.e. must have a string) */

    if (!JSVAL_IS_STRING(id)) return JS_TRUE;

    /* Get the associated browser_data structure and find the name */

    decoder = JS_GetPrivate(cx, obj);
    if (!decoder) return JS_TRUE;

    name = JS_GetStringBytes(JSVAL_TO_STRING(id));
    if (!name) return JS_TRUE;

    /* Get the Window object */

    window_obj = decoder->window_object;

    /* Have we got a frame with this name? */

    frame = frames_find_named_visible_same_index(decoder, name, &slot);

    if (frame)
    {
      /* We found a frame with that name.                */
      /*                                                 */
      /* Add the name as a property of the Window object */
      /* and alias it to Window.                         */

      if (
           !JS_DefinePropertyWithTinyId(cx,
                                        window_obj,
                                        frame->window_name,
                                        (int8) slot,
                                        JSVAL_NULL,
                                        NULL,
                                        NULL,
                                        JSPROP_ENUMERATE | JSPROP_READONLY)
         )
         return JS_FALSE;

      if (
           !JS_AliasElement(cx,
                            window_obj,
                            frame->window_name,
                            slot)
         )
         return JS_FALSE;

      return JS_TRUE;
    }

    /* Didn't find an appropriately named frame; */
    /* try generic Window properties instead.    */

    return jswindow_resolve_window_properties(decoder, obj, id);
  }

  /**************************************************************/
  /* jswindow_resolve_window_properties()                       */
  /*                                                            */
  /* If a property name isn't a frame name, for example, it may */
  /* refer to other specific object types. Deal with them here. */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct relevant to   */
  /*             the context;                                   */
  /*                                                            */
  /*             Pointer to the Window object in question;      */
  /*                                                            */
  /*             A jsval encoding the property ID.              */
  /*                                                            */
  /* Returns:    JS_TRUE if successful, JS_FALSE if there is an */
  /*             error.                                         */
  /**************************************************************/

  JSBool jswindow_resolve_window_properties(browser_data * decoder, JSObject * obj, jsval id)
  {
    const char * name;
    JSContext  * cx;

    cx = decoder->bcx;

    if (!cx)                  return JS_FALSE;
    if (!JSVAL_IS_STRING(id)) return JS_TRUE;

    name = JS_GetStringBytes(JSVAL_TO_STRING(id));

    if (!strcmp(name, "screen"))
    {
      return ((JSBool) (jsscreen_define_screen(decoder, obj) != NULL));
    }

    if (!strcmp(name, "hardware"))
    {
      // No hardware object yet
      //
      // return ((JSBool) (lm_DefineHardware(decoder, obj) != NULL));

      return JS_TRUE;
    }

    if (!strcmp(name, "loading"))
    {
      return JS_DefinePropertyWithTinyId(cx,
                                         obj,
                                         name,
                                         WIN_LOADING,
                                         JSVAL_VOID,
                                         NULL,
                                         NULL,
                                         JSPROP_ENUMERATE);
    }

    /* Is this the Navigator object? */

    if (!strcmp(name, lm_navigator_str))
    {
      /* See if there is a global navigator object yet */

      if (!decoder->navigator) // ...Should be lm_crippled_decoder throughout this function?
      {
        // lm_DefinePluginClasses(lm_crippled_decoder);

        decoder->navigator = jsnavigator_define_navigator(decoder);
        if (!decoder->navigator) return JS_FALSE;

        if (!JS_AddRoot(cx, &decoder->navigator)) return JS_FALSE;
      }

//      /* use the global navigator */
//      decoder->navigator = lm_crippled_decoder->navigator;
//      if (!JS_DefineProperty(cx, obj, lm_navigator_str,
//                             OBJECT_TO_JSVAL(decoder->navigator),
//                             NULL, NULL,
//                             JSPROP_ENUMERATE | JSPROP_READONLY)) {
//          return JS_FALSE;
//      }

      return JS_TRUE;
    }

    /* Is this the Components object? */

    if (!strcmp(name, lm_components_str))
    {
      /* see if there is a global components object yet */

// Another crippled decoder! Yikes.
//
//      if (!lm_crippled_decoder->components) {
//          lm_crippled_decoder->components =
//              lm_DefineComponents(lm_crippled_decoder);
//          if (!lm_crippled_decoder->components)
//              return JS_FALSE;
//          if (!JS_AddRoot(cx, &lm_crippled_decoder->components))
//              return JS_FALSE;
//      }
//
//      /* use the global navigator */
//      decoder->components = lm_crippled_decoder->components;
//      if (!JS_DefineProperty(cx, obj, lm_components_str,
//                             OBJECT_TO_JSVAL(decoder->components),
//                             NULL, NULL,
//                             JSPROP_ENUMERATE | JSPROP_READONLY)) {
//          return JS_FALSE;
//      }

      return JS_TRUE;
    }

// Toolbar, navigation bar, etc. stuff here
//
//    return lm_ResolveBar(cx, decoder, name);

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_finalise()                                        */
  /*                                                            */
  /* Get rid of a Window object.                                */
  /*                                                            */
  /* Parameters are as standard for an interpreter object       */
  /* finalisation callback function.                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(void) jswindow_finalise(JSContext * cx, JSObject * obj)
  {
    browser_data * win;

    dprintf(("JScr", "jswindow_finalise: Called\n"));

    win = JS_GetPrivate(cx, obj);

    if (!win)
    {
      dprintf(("JScr", "jswindow_finalise: Can't get URL structure; exitting\n"));

      return;
    }

    win = JS_GetPrivate(cx, obj);
    if (!win) return;
    else win->window_object = NULL;

    dprintf(("JScr", "jswindow_finalise: Successful\n"));

    return;
  }

  /**************************************************************/
  /* jswindow_alert()                                           */
  /*                                                            */
  /* Implementation of the Window object alert() method.        */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_alert(JSContext * cx, JSObject * obj,
                                            uintN argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    char         * message;
    JSString     * str;

    dprintf(("JScr", "jswindow_alert: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      dprintf(("JScr", "jswindow_alert: Can't get valid browser_data address (received 0x%08x)\n", (int) b));

      return JS_FALSE;
    }

    /* Get the string we're to display */

    str = JS_ValueToString(cx, argv[0]);

    if (!str)
    {
      dprintf(("JScr", "jswindow_alert: Can't get alert message string\n"));

      return JS_FALSE;
    }

    /* Convert JSString to pointer to char array */

    message = JS_GetStringBytes(str);

    if (!message || !*message)
    {
      dprintf(("JScr", "jswindow_alert: Can't convert message string to char *\n"));

      return JS_FALSE;
    }

    /* Report the message */

    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess, message);

    show_error_ret(&erb);

    /* Finished */

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_confirm()                                         */
  /*                                                            */
  /* Implementation of the Window object confirm() method.      */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_confirm(JSContext * cx, JSObject * obj,
                                             uintN argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    char         * message;
    JSString     * str;
    JSBool         result;

    dprintf(("JScr", "jswindow_confirm: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      dprintf(("JScr", "jswindow_confirm: Can't get valid browser_data address (received 0x%08x)\n", (int) b));

      return JS_FALSE;
    }

    /* Get the string we're to display */

    str = JS_ValueToString(cx, argv[0]);

    if (!str)
    {
      dprintf(("JScr", "jswindow_confirm: Can't get confirm message string\n"));

      return JS_FALSE;
    }

    /* Convert JSString to pointer to char array */

    message = JS_GetStringBytes(str);

    if (!message || !*message)
    {
      dprintf(("JScr", "jswindow_confirm: Can't convert message string to char *\n"));

      return JS_FALSE;
    }

    /* Report the message */

    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess, message);

    if (
         show_error_ask(&erb,
                        "JSErr3:OK,Cancel")
         != 3
       )
       result = JS_FALSE;

    else result = JS_TRUE;

    /* Return the result */

    *rval = BOOLEAN_TO_JSVAL(result);

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_home()                                            */
  /*                                                            */
  /* Implementation of the Window object home() method.         */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_home(JSContext * cx, JSObject * obj,
                                           uintN argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    IdBlock        id;

    dprintf(("JScr", "jswindow_home: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      dprintf(("JScr", "jswindow_home: Can't get valid browser_data address (received 0x%08x)\n", (int) b));

      return JS_FALSE;
    }

    /* Build an ID block to make it look like an event */
    /* came from this window                           */

    id.ancestor_id        = b->self_id;
    id.ancestor_component = NULL_ComponentId;
    id.parent_id          = NULL_ObjectId;
    id.parent_component   = NULL_ComponentId;
    id.self_id            = toolbars_get_upper(b);
    id.self_component     = ButtonBarHome;

    handle_home(0, NULL, &id, NULL);

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_stop()                                            */
  /*                                                            */
  /* Implementation of the Window object stop() method.         */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_stop(JSContext * cx, JSObject * obj,
                                           uintN argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    IdBlock        id;

    dprintf(("JScr", "jswindow_stop: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      dprintf(("JScr", "jswindow_stop: Can't get valid browser_data address (received 0x%08x)\n", (int) b));

      return JS_FALSE;
    }

    /* Build an ID block to make it look like an event */
    /* came from this window                           */

    id.ancestor_id        = b->self_id;
    id.ancestor_component = NULL_ComponentId;
    id.parent_id          = NULL_ObjectId;
    id.parent_component   = NULL_ComponentId;
    id.self_id            = toolbars_get_upper(b);
    id.self_component     = ButtonBarHome;

    handle_stop(0, NULL, &id, NULL);

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_forward()                                         */
  /*                                                            */
  /* Implementation of the Window object forward() method.      */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_forward(JSContext * cx, JSObject * obj,
                                              uintN argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    IdBlock        id;

    dprintf(("JScr", "jswindow_forward: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      dprintf(("JScr", "jswindow_forward: Can't get valid browser_data address (received 0x%08x)\n", (int) b));

      return JS_FALSE;
    }

    /* Build an ID block to make it look like an event */
    /* came from this window                           */

    id.ancestor_id        = b->self_id;
    id.ancestor_component = NULL_ComponentId;
    id.parent_id          = NULL_ObjectId;
    id.parent_component   = NULL_ComponentId;
    id.self_id            = toolbars_get_upper(b);
    id.self_component     = ButtonBarHome;

    handle_forwards(0, NULL, &id, NULL);

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_back()                                            */
  /*                                                            */
  /* Implementation of the Window object back() method.         */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_back(JSContext * cx, JSObject * obj,
                                           uintN argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    IdBlock        id;

    dprintf(("JScr", "jswindow_back: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      dprintf(("JScr", "jswindow_back: Can't get valid browser_data address (received 0x%08x)\n", (int) b));

      return JS_FALSE;
    }

    /* Build an ID block to make it look like an event */
    /* came from this window                           */

    id.ancestor_id        = b->self_id;
    id.ancestor_component = NULL_ComponentId;
    id.parent_id          = NULL_ObjectId;
    id.parent_component   = NULL_ComponentId;
    id.self_id            = toolbars_get_upper(b);
    id.self_component     = ButtonBarHome;

    handle_back(0, NULL, &id, NULL);

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_blur()                                            */
  /*                                                            */
  /* Implementation of the Window object blur() method.         */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_blur(JSContext * cx, JSObject * obj,
                                           uintN argc, jsval * argv, jsval * rval)
  {
    dprintf(("JScr", "jswindow_blur: Called\n"));

    /* Currently very simple; just lose focus completely. */

    wimp_set_caret_position(-1, -1, 0, 0, -1, -1);

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_focus()                                           */
  /*                                                            */
  /* Implementation of the Window object focus() method.        */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_focus(JSContext * cx, JSObject * obj,
                                            uintN argc, jsval * argv, jsval * rval)
  {
    browser_data * b;

    dprintf(("JScr", "jswindow_focus: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      dprintf(("JScr", "jswindow_focus: Can't get valid browser_data address (received 0x%08x)\n", (int) b));

      return JS_FALSE;
    }

    /* Give the window input focus */

    browser_give_general_focus(b);

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_open()                                            */
  /*                                                            */
  /* Implementation of the Window object open() method.         */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_open(JSContext * cx, JSObject * obj,
                                           uintN argc, jsval * argv, jsval * rval)
  {
    _kernel_oserror * e;
    browser_data    * decoder;
    browser_data    * new_decoder;
    url_description * url_struct;
    char            * url_string   = "";
    char            * url_relative = "";
    JSString        * str;
    JSString        * window_name_str;
    char            * window_name;
    char            * options;
    BBox              size;
    int               x, y;
    int               size_set     = 0;
    int               free_it      = 0;
    browser_data    * found;

    dprintf(("JScr", "jswindow_open: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    decoder = JS_GetInstancePrivate(cx,
                                    obj,
                                    &jswindow_class,
                                    argv);

    if (!is_known_browser(decoder))
    {
      dprintf(("JScr", "jswindow_open: Can't get valid browser_data address (received 0x%08x)\n", (int) decoder));

      *rval = JSVAL_NULL;
      return JS_TRUE;
    }

    /* Make url_string absolute based on current document's base URL. */

    if (argc > 0)
    {
      const char * base;

      str = JS_ValueToString(cx, argv[0]);

      if (!str)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }

      url_string = JS_GetStringBytes(str);

      if (!url_string)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }

      /* Find the document base URL */

      base = browser_base_url(decoder);
      if (!base) base = url_string;

      /* Return a descriptor for the given URL, thereby ensuring */
      /* it is well formed.                                      */

      url_struct = urlutils_return_description(url_string);

      if (!url_struct)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }
      else
      {
        urlutils_free_description(url_struct);
      }

      /* Relativise the URL to the document base location */

      if (decoder->stream) url_relative = urlutils_relativise_url(base, url_string), free_it = 1;

      if (!url_relative)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }
    }

    /* Set this to null so we can goto fail from here onward. */

    new_decoder = NULL;

    /* Sanity-check the optional window_name argument. */

    if (argc > 1)
    {
      window_name_str = JS_ValueToString(cx, argv[1]);

      if (!window_name_str)                     goto fail;
      if (!JS_LockGCThing(cx, window_name_str)) goto fail;

      window_name = JS_GetStringBytes(window_name_str);
    }
    else
    {
      window_name_str = NULL;
      window_name     = NULL;
    }

    /* There are some things we have to find out from the options */
    /* list before we open the window.                            */

    if (argc > 2)
    {
      str = JS_ValueToString(cx, argv[2]);

      if (!str) goto fail;

      options = JS_GetStringBytes(str);
    }
    else options = "";

    /* Read various options before the window opens */

    if (argc > 2)
    {
      /* Deal with size specifiers. Here, we must have both a */
      /* width and height for the inner or outer size for     */
      /* anything to change.                                  */

      if (
           (
             jswindow_option_set(options, "innerWidth") ||
             jswindow_option_set(options, "width")
           )
           &&
           (
             jswindow_option_set(options, "innerHeight") ||
             jswindow_option_set(options, "height")
           )
         )
      {
        size.xmin = jswindow_has_option(options, "innerWidth") |
                    jswindow_has_option(options, "width");

        size.ymin = jswindow_has_option(options, "innerHeight") |
                    jswindow_has_option(options, "height");

        jswindow_make_inner_bbox(&size);

        size_set = 1;
      }

      /* Since there's no analogue to the Navigator window where the  */
      /* outer width is set independently of the inner - you just get */
      /* huge resize borders around the edge - under RISC OS we have  */
      /* the problem of which should override. Since the inner width  */
      /* is critical to the page layout, we'll let inner width come   */
      /* before outer. Hence the outer width case is in the 'else',   */
      /* rather than the other way around.                            */

      else
      {
        if (
             jswindow_option_set(options, "outerWidth") &&
             jswindow_option_set(options, "outerHeight")
           )
        {
          size.xmin = jswindow_has_option(options, "outerWidth");
          size.ymin = jswindow_has_option(options, "outerHeight");

          jswindow_make_outer_bbox(&size);

          size_set = 1;
        }
      }

      /* If either an X or Y coordinate is set, move the window. The */
      /* other defaults to 0 if not specified.                       */

      if (
           jswindow_option_set(options, "screenX") ||
           jswindow_option_set(options, "screenY")
         )
      {
        x = jswindow_has_option(options, "screenX");
        y = jswindow_has_option(options, "screenY");

        /* We may not have specified a size */

        if (!size_set)
        {
          size.xmin = choices.width  / 2;
          size.ymin = choices.height / 2;

          jswindow_make_inner_bbox(&size);

          size_set = 1;
        }

        jswindow_move_bbox(&size, x, y);
      }
    }

    /* If we've set the window size and/or position, */
    /* make sure the bounding box is converted from  */
    /* outline to visible area coordinates.          */

    if (size_set) jswindow_convert_to_area(&size);

    /* Is there a window of the same name already? */

    found = last_browser;

    while (found)
    {
      if (
           !found->ancestor                         &&
           window_name                              &&
           found->window_name                       &&
           !strcmp(window_name, found->window_name)
         )
         break;

      found = found->previous;
    }

    /* If we found a window, close it (and recreate it in passing) */

    if (found)
    {
      /* Try to preserve the top left hand X and Y coordinates */
      /* if they were not specified in the options string      */

      if (
           !jswindow_option_set(options, "screenX") &&
           !jswindow_option_set(options, "screenY")
         )
      {
        WimpGetWindowOutlineBlock outline;
        int                       th, hh, vw;
        int                       w, h;

        windows_return_tool_sizes(&th, &hh, &vw);

        w = size.xmax - size.xmin;
        h = size.ymax - size.ymin;

        outline.window_handle = found->window_handle;

        if (!wimp_get_window_outline(&outline))
        {
          size.xmin = outline.outline.xmin + wimpt_dx();
          size.xmax = size.xmin + w;
          size.ymax = outline.outline.ymax - th;
          size.ymin = size.ymax - h;
        }
      }

      handle_close_browser(0, NULL, NULL, found);
    }

    /* We're finally ready to create the window - but should we...? */

    if      (choices.js_window_open == Choices_JSWindowOpen_Suppress) return JS_TRUE;
    else if (choices.js_window_open == Choices_JSWindowOpen_Query)
    {
      erb.errnum = Utils_Error_Custom_Message;

      StrNCpy0(erb.errmess,
               lookup_token("JSOpen:A script wants to open a window. Allow or prevent it?",
                            0,
                            NULL));


      if (
           show_error_ask(&erb,
                          "JSCue2:Allow,Prevent")
           != 3
         )
         return JS_TRUE;
    }
    else if (choices.js_window_open == Choices_JSWindowOpen_Replace)
    {
      javascript_set_pending_fetch(decoder,
                                   url_relative,
                                   1,
                                   0);

      return JS_TRUE;
    }

    /* Create the window */

    e = windows_create_browser(url_relative,
                               decoder,
                               ((size_set) ? &size : NULL),
                               window_name,
                               Windows_CreateBrowser_AsJSChild);

    if (free_it)
    {
      free(url_relative);
      url_relative = NULL;
    }

    if (e)
    {
      show_error_ret(e);

      *rval = JSVAL_NULL;
      return JS_TRUE;
    }
    else
    {
      new_decoder = last_browser;
    }

    /* Deal with specific options on the window that */
    /* are useful after the window has been created  */

    if (argc > 2)
    {
      /* Toolbar options */

      new_decoder->button_bar = !!jswindow_has_option(options, "toolbar");
      new_decoder->url_bar    = !!jswindow_has_option(options, "location");
      new_decoder->status_bar = !!jswindow_has_option(options, "status");

      // directories, personalbar, menubar have no equivalent in Browse yet

      toolbars_set_presence(new_decoder, InternalTopLeft);
      toolbars_set_presence(new_decoder, InternalBottomLeft);

//      chrome->show_scrollbar         = win_has_option(options, "scrollbars");
//      chrome->allow_resize           = win_has_option(options, "resizable");
//      chrome->allow_close            = TRUE;
//      chrome->dependent              = win_has_option(options, "dependent");
//      chrome->copy_history           = FALSE; /* XXX need strong trust */
//      chrome->topmost         = win_has_option(options, "alwaysRaised");
//      chrome->bottommost              = win_has_option(options, "alwaysLowered");
//      chrome->z_lock          = win_has_option(options, "z-lock");
//      chrome->is_modal            = win_has_option(options, "modal");
//      chrome->hide_title_bar  = !(win_has_option(options, "titlebar"));
//
//      /* Allow disabling of commands only if there is no menubar */
//      if (!chrome->show_menu) {
//          chrome->disable_commands = !win_has_option(options, "hotkeys");
//          if (XP_STRCASESTR(options,"hotkeys")==NULL)
//              chrome->disable_commands = FALSE;
//      }
//      /* If titlebar condition not specified, default to shown */
//      if (XP_STRCASESTR(options,"titlebar")==0)
//          chrome->hide_title_bar=FALSE;
//
//      if (chrome->topmost || chrome->bottommost ||
//          chrome->z_lock || chrome->is_modal ||
//          chrome->hide_title_bar || chrome->disable_commands) {
//          if (!lm_CanAccessTarget(cx, JSTARGET_UNIVERSAL_BROWSER_WRITE)) {
//              chrome->topmost = chrome->bottommost =
//              chrome->z_lock = chrome->is_modal =
//              chrome->hide_title_bar = chrome->disable_commands = 0;
//          }
//      }
//
//      /* In order to not start Java for every single window open we
//       * have to first check if we need to check, and then check.
//       * Start by getting width and height to use for positioning
//       * calculations. Defaults to 100 if neither are specified.
//       * Then get screen size.
//       */
//
//      win_width = chrome->w_hint ? chrome->w_hint :
//          (chrome->outw_hint ? chrome->outw_hint : 100);
//      win_height = chrome->h_hint ? chrome->h_hint :
//          (chrome->outh_hint ? chrome->outh_hint : 100);
//      ET_PostGetScreenSize(decoder->window_context, &width, &height);
//      if ((chrome->w_hint && chrome->w_hint < 100) ||
//          (chrome->h_hint && chrome->h_hint < 100) ||
//          (chrome->outw_hint && chrome->outw_hint < 100) ||
//          (chrome->outh_hint && chrome->outh_hint < 100) ||
//          (width < chrome->l_hint + win_width) ||
//          (chrome->l_hint < 0) ||
//          (height < chrome->t_hint + win_height) ||
//          (chrome->t_hint < 0)) {
//          /* The window is trying to put a window offscreen or make it too
//           * small.  We have to check the security permissions
//           */
//          if (!lm_CanAccessTarget(cx, JSTARGET_UNIVERSAL_BROWSER_WRITE)) {
//              /* Make sure windows are at least 100 by 100 pixels. */
//              if (chrome->w_hint && chrome->w_hint < 100) {
//          chrome->w_hint = 100;
//          win_width = 100;
//      }
//              if (chrome->h_hint && chrome->h_hint < 100) {
//          chrome->h_hint = 100;
//          win_height = 100;
//      }
//              if (chrome->outw_hint && chrome->outw_hint < 100) {
//          chrome->outw_hint = 100;
//          win_width = 100;
//      }
//              if (chrome->outh_hint && chrome->outh_hint < 100) {
//          chrome->outh_hint = 100;
//          win_height = 100;
//      }
//              /* Windows must be positioned on screen without security */
//              chrome->l_hint = (width < chrome->l_hint + win_width) ?
//                                  width - win_width : chrome->l_hint;
//              chrome->l_hint = (chrome->l_hint < 0) ? 0 : chrome->l_hint;
//              chrome->t_hint = (height < chrome->t_hint + win_height) ?
//                                  height - win_height : chrome->t_hint;
//              chrome->t_hint = (chrome->t_hint < 0) ? 0 : chrome->t_hint;
//          }
//      }
//
//      /* Make sure they always at least 10 x 10 regardless of security. 1 x 1
//       * windows are really hard to spot */
//      if (chrome->w_hint && chrome->w_hint < 10) chrome->w_hint = 10;
//      if (chrome->h_hint && chrome->h_hint < 10) chrome->h_hint = 10;
//      if (chrome->outw_hint && chrome->outw_hint < 10) chrome->outw_hint = 10;
//      if (chrome->outh_hint && chrome->outh_hint < 10) chrome->outh_hint = 10;
//
//      /* You must specify both width and height to get either */
//      if (chrome->w_hint == 0 || chrome->h_hint == 0)
//          chrome->w_hint = chrome->h_hint = 0;
//      if (chrome->outw_hint == 0 || chrome->outh_hint == 0)
//          chrome->outw_hint = chrome->outh_hint = 0;
//
//      /* Needed to allow positioning of windows at 0,0 */
//      if ((XP_STRCASESTR(options,"top") || XP_STRCASESTR(options,"left") ||
//                  XP_STRCASESTR(options,"screenX") || XP_STRCASESTR(options,"screenY")) != 0)
//          chrome->location_is_chrome=TRUE;
//
//      options = 0;
    }
//    else
//    {
//      /* Make a fully chromed window, but don't copy history. */
//      chrome->show_button_bar         = TRUE;
//      chrome->show_url_bar            = TRUE;
//      chrome->show_directory_buttons  = TRUE;
//      chrome->show_bottom_status_bar  = TRUE;
//      chrome->show_menu               = TRUE;
//      chrome->show_security_bar       = FALSE;
//      chrome->w_hint = chrome->h_hint = 0;
//      chrome->is_modal                = FALSE;
//      chrome->show_scrollbar          = TRUE;
//      chrome->allow_resize            = TRUE;
//      chrome->allow_close             = TRUE;
//      chrome->copy_history            = FALSE; /* XXX need strong trust */
//    }
//
//    /* Windows created by JS cannot be randomly used by Mail/News */
//    chrome->restricted_target = TRUE;
//
//    old_context = decoder->window_context;
//    if (!old_context) goto fail;
//
//    if (window_name)
//        context = XP_FindNamedContextInList(old_context, (char*)window_name);
//    else
//        context = NULL;
//
//    if (context) {
//        new_decoder = LM_GetMochaDecoder(context);
//        if (!new_decoder)
//            goto fail;
//        if (url_struct && !lm_GetURL(cx, new_decoder, url_struct)) {
//            url_struct = 0;
//            goto fail;
//        }
//        /* lm_GetURL() stashed a url_struct pointer, and owns it now. */
//        url_struct = 0;
//
//    /* If specific options are specified we will update the named
//     * window to match those options.  If not, we won't change them */
//    if (argc > 2)
//        ET_PostUpdateChrome(context, chrome);
//    } else {
//        if (lm_window_count >= lm_window_limit)
//            goto fail;
//        context = ET_PostNewWindow(old_context, url_struct,
//                                   (char*)window_name,
//                                   chrome);
//        if (!context)
//            goto fail;
//        /* ET_PostNewWindow() stashed a url_struct pointer, and owns it now. */
//        url_struct = 0;
//        new_decoder = LM_GetMochaDecoder(context);
//        if (!new_decoder) {
//            (void) ET_PostDestroyWindow(context);
//            goto fail;
//        }
//    }
//
    /* Set up the given object as the opener */

    new_decoder->opener = obj;

    if (
         !JS_DefinePropertyWithTinyId(cx,
                                      new_decoder->window_object,
                                      lm_opener_str,
                                      WIN_OPENER,
                                      OBJECT_TO_JSVAL(obj),
                                      NULL,
                                      NULL,
                                      JSPROP_ENUMERATE)
       )
       goto fail;

    JS_UnlockGCThing(cx, window_name_str);

//    new_decoder->in_window_quota = JS_TRUE;
//
//    lm_window_count++;
//    LM_PutMochaDecoder(new_decoder);

    *rval = OBJECT_TO_JSVAL(new_decoder->window_object);

//    XP_FREE(chrome);
//    XP_FREEIF(window_name);

    return JS_TRUE;

fail:

    if (window_name_str) JS_UnlockGCThing(cx, window_name_str);
    if (new_decoder)     handle_close_browser(0, NULL, NULL, new_decoder);

    *rval = JSVAL_NULL;

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_close()                                           */
  /*                                                            */
  /* Implementation of the Window object close() method. Will   */
  /* close the window without question if the window was        */
  /* created via. JavaScript (it has an inherited execution     */
  /* context), or ask first if not.                             */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_close(JSContext * cx, JSObject * obj,
                                            uintN argc, jsval * argv, jsval * rval)
  {
    browser_data * b;

    dprintf(("JScr", "jswindow_close: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      dprintf(("JScr", "jswindow_close: Can't get valid browser_data address (received 0x%08x)\n", (int) b));

      return JS_FALSE;
    }

    /* A JS sourced window? */

    if (is_known_browser(b->bcx_inherited))
    {
      /* Just close the window. */

      show_error_cont(javascript_register_post_exec_action(b, JavaScript_PostExec_Close));
    }
    else
    {
      int response;

      /* Security - should we close? */

      erb.errnum = Utils_Error_Custom_Message;

      StrNCpy0(erb.errmess,
               lookup_token("JSClos:Close this window?",
                            0,
                            0));

      response = show_error_ask(&erb, "JSQue1:Keep,Close");

      /* '4' means the second button of 2 -> Close */

      if (response == 4)
      {
        show_error_cont(javascript_register_post_exec_action(b, JavaScript_PostExec_Close));
      }
      else return JS_FALSE;
    }

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_print()                                           */
  /*                                                            */
  /* Implementation of the Window object print() method, an     */
  /* extension to allow console output.                         */
  /*                                                            */
  /* Parameters are as standard for a JavaScript method         */
  /* implementation.                                            */
  /**************************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_print(JSContext * cx, JSObject * obj,
                                            uintN argc, jsval * argv, jsval * rval)
  {
    browser_data * decoder;
    char         * string = "";
    JSString     * str;

    dprintf(("JScr", "jswindow_print: Called\n"));

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    decoder = JS_GetInstancePrivate(cx,
                                    obj,
                                    &jswindow_class,
                                    argv);

    if (!is_known_browser(decoder))
    {
      dprintf(("JScr", "jswindow_print: Can't get valid browser_data address (received 0x%08x)\n", (int) decoder));

      *rval = JSVAL_NULL;
      return JS_TRUE;
    }

    if (argc > 0)
    {
      str = JS_ValueToString(cx, argv[0]);

      if (!str)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }

      string = JS_GetStringBytes(str);

      if (!string)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }
    }

    eventlogs_log_message(decoder, eventlogs_script_information, string);

    return JS_TRUE;
  }

  /**************************************************************/
  /* jswindow_has_option()                                      */
  /*                                                            */
  /* In a string as would be passed to for example the          */
  /* JavaScript window.open() method, return the value          */
  /* associated with the given named entry in the given option  */
  /* string.                                                    */
  /*                                                            */
  /* Parameters: Pointer to the options string, which will be   */
  /*             written to during the operation of the         */
  /*             function though it'll be overall unchanged     */
  /*             when the function exits;                       */
  /*                                                            */
  /*             Pointer to the name to find the associated     */
  /*             value of.                                      */
  /*                                                            */
  /* Returns:    Value (or '1' for 'yes'), with '0' returned if */
  /*             the item is not found, its associated value is */
  /*             malformed for 'atoi()', or its associated      */
  /*             value is actually 0!                           */
  /**************************************************************/

  static int jswindow_has_option(char * options, const char * name)
  {
    char * comma;
    char * equal;
    int    found = 0;

    for (;;)
    {
      /* Find a name or value separator and force a terminator */
      /* there for string comparison purposes.                 */

      comma = strchr(options, ',');
      if (comma) *comma = '\0';

      equal = strchr(options, '=');
      if (equal) *equal = '\0';

      /* Do we have a match for the name? */

      if (utils_strcasecmp(options, name) == 0)
      {
        /* Yes. If the option says 'yes' return 1, else try to */
        /* termine the value of the argument associated with   */
        /* the name.                                           */

        if (!equal || utils_strcasecmp(equal + 1, "yes") == 0) found = 1;
        else                                                   found = atoi(equal + 1);
      }

      /* Put back any characters we wrote over */

      if (equal) *equal = '=';
      if (comma) *comma = ',';

      /* If we found something or have run out of items, exit */

      if (found || !comma) break;

      /* Otherwise, try the next item */

      options = comma + 1;
    }

    return found;
  }

  /**************************************************************/
  /* jswindow_option_set()                                      */
  /*                                                            */
  /* In a string as would be passed to for example the          */
  /* JavaScript window.open() method, return 1 if a given       */
  /* option is present, else 0.                                 */
  /*                                                            */
  /* Parameters: Pointer to the options string, which will be   */
  /*             written to during the operation of the         */
  /*             function though it'll be overall unchanged     */
  /*             when the function exits;                       */
  /*                                                            */
  /*             Pointer to the name to find the associated     */
  /*             value of.                                      */
  /*                                                            */
  /* Returns:    1 if option is found, else 0.                  */
  /**************************************************************/

  static int jswindow_option_set(char * options, const char * name)
  {
    char * comma;
    char * equal;
    int    found = 0;

    for (;;)
    {
      /* Find a name or value separator and force a terminator */
      /* there for string comparison purposes.                 */

      comma = strchr(options, ',');
      if (comma) *comma = '\0';

      equal = strchr(options, '=');
      if (equal) *equal = '\0';

      /* Do we have a match for the name? */

      if (utils_strcasecmp(options, name) == 0)
      {
        found =  1;
      }

      /* Put back any characters we wrote over */

      if (equal) *equal = '=';
      if (comma) *comma = ',';

      /* If we found something or have run out of items, exit */

      if (found || !comma) break;

      /* Otherwise, try the next item */

      options = comma + 1;
    }

    return found;
  }

  /**************************************************************/
  /* jswindow_make_outer_bbox()                                 */
  /*                                                            */
  /* Based on a width and height, construct a bounding box      */
  /* describing a window outline based on the assumption that   */
  /* the given values were pixel sizes for the intended outer   */
  /* window width and height. The window will be centred on     */
  /* screen.                                                    */
  /*                                                            */
  /* If you want to pass this bounding box on to something like */
  /* windows_create_browser, run it through                     */
  /* jswindow_convert_to_area.                                  */
  /*                                                            */
  /* The width and height are not allowed to drop below         */
  /* JSWindow_Minimum_Width and JSWindow_Minimum_Height (see    */
  /* top of file).                                              */
  /*                                                            */
  /* Parameters: Pointer to a BBox with the xmin and ymin       */
  /*             fields filled in with the pixel width and      */
  /*             height respectively - a 1 pixel to 2 OS unit   */
  /*             mapping is assumed in both directions.         */
  /**************************************************************/

  static void jswindow_make_outer_bbox(BBox * size)
  {
    BBox screen;
    int  w, h;

    if (size->xmin < 100) size->xmin = JSWindow_Minimum_Width;
    if (size->ymin < 100) size->ymin = JSWindow_Minimum_Height;

    /* Get the available screen X and Y size */

    screen.xmin = bbc_modevar(-1, BBC_XEigFactor);
    screen.ymin = bbc_modevar(-1, BBC_YEigFactor);
    screen.xmax = bbc_modevar(-1, BBC_XWindLimit);
    screen.ymax = bbc_modevar(-1, BBC_YWindLimit);

    screen.xmax = (screen.xmax + 1) << screen.xmin;
    screen.ymax = (screen.ymax + 1) << screen.ymin;

    /* Convert the given values to OS units */

    size->xmin *= 2;
    size->ymin *= 2;

    w = size->xmin;
    h = size->ymin;

    /* Work out the final BBox */

    size->xmin = (screen.xmax - w) / 2;
    size->ymin = (screen.ymax - h) / 2;
    size->xmax = size->xmin + w;
    size->ymax = size->ymin + h;

    return;
  }

  /**************************************************************/
  /* jswindow_make_inner_bbox()                                 */
  /*                                                            */
  /* Based on a width and height, construct a bounding box      */
  /* describing a window outline based on the assumption that   */
  /* the given values were pixel sizes for the intended inner   */
  /* window width and height. The window will be centred on     */
  /* screen.                                                    */
  /*                                                            */
  /* If you want to pass this bounding box on to something like */
  /* windows_create_browser, run it through                     */
  /* jswindow_convert_to_area.                                  */
  /*                                                            */
  /* The width and height are not allowed to drop below         */
  /* JSWindow_Minimum_Width and JSWindow_Minimum_Height (see    */
  /* top of file).                                              */
  /*                                                            */
  /* Parameters: Pointer to a BBox with the xmin and ymin       */
  /*             fields filled in with the pixel width and      */
  /*             height respectively - a 1 pixel to 2 OS unit   */
  /*             mapping is assumed in both directions.         */
  /**************************************************************/

  static void jswindow_make_inner_bbox(BBox * size)
  {
    int th, hh, vw;

    /* Work out the final BBox as if it were the outer edge */

    jswindow_make_outer_bbox(size);

    /* Account for the left hand window edge */

    size->xmin -= wimpt_dx();

    /* Account for the title, lower and right hand scroll bars */

    windows_return_tool_sizes(&th, &hh, &vw);

    size->xmax += vw;
    size->ymax += th;
    size->ymin -= hh;

    return;
  }

  /**************************************************************/
  /* jswindow_move_bbox()                                       */
  /*                                                            */
  /* Given a bounding box and X and Y absolute coordinates in   */
  /* pixels, move the box assuming it describes the outer       */
  /* outline of a window. Don't allow any window edge           */
  /* off-screen.                                                */
  /*                                                            */
  /* Parameters: Pointer to a BBox filled in with the           */
  /*             coordinates describing a window outline;       */
  /*                                                            */
  /*             X coordinate to move to in pixels - a 1 pixel  */
  /*             to 2 OS unit mapping is assumed (0 places the  */
  /*             left hand window edge at the far left of the   */
  /*             screen);                                       */
  /*                                                            */
  /*             Y coordinate to move to in pixels - again, a 1 */
  /*             pixel to 2 OS unit mapping is assumed (0       */
  /*             places the upper window edge at the top of the */
  /*             screen).                                       */
  /**************************************************************/

  static void jswindow_move_bbox(BBox * size, int x, int y)
  {
    BBox screen;
    int  w, h;

    /* Get the available screen X and Y size */

    screen.xmin = bbc_modevar(-1, BBC_XEigFactor);
    screen.ymin = bbc_modevar(-1, BBC_YEigFactor);
    screen.xmax = bbc_modevar(-1, BBC_XWindLimit);
    screen.ymax = bbc_modevar(-1, BBC_YWindLimit);

    screen.xmax = (screen.xmax + 1) << screen.xmin;
    screen.ymax = (screen.ymax + 1) << screen.ymin;

    /* Convert the given values to OS units; */
    /* get the window width and height.      */

    x *= 2;

    w = size->xmax - size->xmin;
    h = size->ymax - size->ymin;

    y = screen.ymax - y * 2;

    /* First check to see if we'd end up hanging off the right */
    /* hand edge of the screen and shift left if so            */

    if (x + w > screen.xmax) size->xmax = screen.xmax, size->xmin = size->xmax - w;
    else                     size->xmax = x + w,       size->xmin = x;

    /* We may have ended up too far left (if the window is wider */
    /* that the screen). If so, push back again so the left hand */
    /* window edge abuts the left hand screen edge.              */

    if (size->xmin < 0) size->xmin = 0, size->xmax = w;

    /* In a similar manner to the X coordinate, we want to end up */
    /* with the top of the window visible if it is taller than    */
    /* the screen.                                                */

    if (y > screen.xmax) size->ymax = screen.ymax, size->ymin = size->ymax - h;
    else                 size->ymax = y,           size->ymin = y - h;

    if (size->xmin < 0) size->xmin = 0, size->xmax = w;

    return;
  }

  /**************************************************************/
  /* jswindow_convert_to_area()                                 */
  /*                                                            */
  /* Convert a window outline bounding box to a window visible  */
  /* area bounding box, so it can e.g. be passed on to          */
  /* windows_create_browser.                                    */
  /*                                                            */
  /* Parameters: Pointer to the BBox to convert.                */
  /**************************************************************/

  static void jswindow_convert_to_area(BBox * size)
  {
    int th, hh, vw;

    /* Account for the left hand window edge */

    size->xmin += wimpt_dx();

    /* Account for the title, lower and right hand scroll bars */

    windows_return_tool_sizes(&th, &hh, &vw);

    size->xmax -= vw;
    size->ymax -= th;
    size->ymin += hh;

    return;
  }

#endif
@


1.7
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a43 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d243 1
a243 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_new_window: Called for %p\n",b);
    #endif
d249 1
a249 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_new_window: \0211Browser has no JSI context!\0217\n");
      #endif
d477 1
a477 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_new_window: \0211Browser has no JSI context!\0217\n");
      #endif
d1484 1
a1484 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_finalise: Called\n");
    #endif
d1490 1
a1490 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_finalise: Can't get URL structure; exitting\n");
      #endif
d1499 1
a1499 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_finalise: Successful\n");
    #endif
d1520 1
a1520 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_alert: Called\n");
    #endif
d1532 1
a1532 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_alert: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif
d1543 1
a1543 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_alert: Can't get alert message string\n");
      #endif
d1554 1
a1554 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_alert: Can't convert message string to char *\n");
      #endif
d1589 1
a1589 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_confirm: Called\n");
    #endif
d1601 1
a1601 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_confirm: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif
d1612 1
a1612 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_confirm: Can't get confirm message string\n");
      #endif
d1623 1
a1623 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_confirm: Can't convert message string to char *\n");
      #endif
d1665 1
a1665 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_home: Called\n");
    #endif
d1677 1
a1677 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_home: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif
d1712 1
a1712 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_stop: Called\n");
    #endif
d1724 1
a1724 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_stop: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif
d1759 1
a1759 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_forward: Called\n");
    #endif
d1771 1
a1771 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_forward: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif
d1806 1
a1806 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_back: Called\n");
    #endif
d1818 1
a1818 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_back: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif
d1850 1
a1850 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_blur: Called\n");
    #endif
d1873 1
a1873 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_focus: Called\n");
    #endif
d1885 1
a1885 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_focus: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif
d1925 1
a1925 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_open: Called\n");
    #endif
d1937 1
a1937 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_open: Can't get valid browser_data address (received 0x%08x)\n", (int) decoder);
      #endif
d2461 1
a2461 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_close: Called\n");
    #endif
d2473 1
a2473 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_close: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif
d2530 1
a2530 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_print: Called\n");
    #endif
d2542 1
a2542 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_print: Can't get valid browser_data address (received 0x%08x)\n", (int) decoder);
      #endif
@


1.6
log
@Misecllaneous tweaks and fixes. Major addition is full header and footer
support in the printing system - see the Phoenix Choices file for more
information.

Only the Phoenix resources are up to date currently.
@
text
@d15 14
a28 11
/***************************************************/
/* File   : JSwindow.c                             */
/*                                                 */
/* Purpose: JavaScript support - Window objects.   */
/*          Based in part on source in libmocha    */
/*          from the Mozilla browser sources.      */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 06-May-98: Created.                    */
/***************************************************/
d35 2
a36 1
#include "swis.h"
d38 1
a38 1
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */
d40 8
a47 3
#include "wimp.h"
#include "wimplib.h"
#include "event.h"
a48 1
#include "svcprint.h"
d87 2
a88 2
  PR_STATIC_CALLBACK(PRBool) jswindow_get_property    (JSContext * cx, JSObject * obj, jsval id, jsval * vp);
  PR_STATIC_CALLBACK(PRBool) jswindow_set_property    (JSContext * cx, JSObject * obj, jsval id, jsval * vp);
d93 11
a103 11
  PR_STATIC_CALLBACK(PRBool) jswindow_alert           (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_confirm         (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_home            (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_stop            (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_forward         (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_back            (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_blur            (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_focus           (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_open            (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_close           (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_print           (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
d230 12
a241 13
  /*************************************************/
  /* jswindow_new_window()                         */
  /*                                               */
  /* Create a new Window object for a given        */
  /* browser. Bring up related objects too.        */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             for which the object is to be     */
  /*             created.                          */
  /*                                               */
  /* Returns:    Pointer to the new object, or     */
  /*             NULL for an error.                */
  /*************************************************/
d468 8
a475 10
  /*************************************************/
  /* jswindow_destroy_window()                     */
  /*                                               */
  /* Destroy a given browser's Window and related  */
  /* objects.                                      */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             for which the object is to be     */
  /*             created.                          */
  /*************************************************/
d605 9
a613 9
  /*************************************************/
  /* jswindow_get_property()                       */
  /*                                               */
  /* Called when the interpreter is getting the    */
  /* value of a property in a Window object.       */
  /*                                               */
  /* Parameters as standard for an interpreter     */
  /* handler (callback) function.                  */
  /*************************************************/
d615 1
a615 1
  PR_STATIC_CALLBACK(PRBool) jswindow_get_property(JSContext * cx, JSObject * obj, jsval id, jsval * vp)
d990 9
a998 9
  /*************************************************/
  /* jswindow_set_property()                       */
  /*                                               */
  /* Called when the interpreter is setting the    */
  /* value of a property in a Window object.       */
  /*                                               */
  /* Parameters as standard for an interpreter     */
  /* handler (callback) function.                  */
  /*************************************************/
d1000 1
a1000 1
  PR_STATIC_CALLBACK(PRBool) jswindow_set_property(JSContext * cx, JSObject * obj, jsval id, jsval * vp)
d1242 8
a1249 9
  /*************************************************/
  /* jswindow_list_properties()                    */
  /*                                               */
  /* Help JavaScript list the properties of a      */
  /* Window object.                                */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* property enumeration callback function.       */
  /*************************************************/
d1285 9
a1293 10
  /*************************************************/
  /* jswindow_resolve_name()                       */
  /*                                               */
  /* Help JavaScript work out what property a      */
  /* script is actually referring to in Window     */
  /* objects.                                      */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* interpreter name resolver callback function.  */
  /*************************************************/
d1363 16
a1378 18
  /*************************************************/
  /* jswindow_resolve_window_properties()          */
  /*                                               */
  /* If a property name isn't a frame name, for    */
  /* example, it may refer to other specific       */
  /* object types. Deal with them here.            */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             relevant to the context;          */
  /*                                               */
  /*             Pointer to the Window object in   */
  /*             question;                         */
  /*                                               */
  /*             A jsval encoding the property ID. */
  /*                                               */
  /* Returns:    JS_TRUE if successful, JS_FALSE   */
  /*             if there is an error.             */
  /*************************************************/
d1482 8
a1489 8
  /*************************************************/
  /* jswindow_finalise()                           */
  /*                                               */
  /* Get rid of a Window object.                   */
  /*                                               */
  /* Parameters are as standard for an interpreter */
  /* object finalisation callback function.        */
  /*************************************************/
d1521 8
a1528 9
  /*************************************************/
  /* jswindow_alert()                              */
  /*                                               */
  /* Implementation of the Window object alert()   */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d1530 2
a1531 2
  PR_STATIC_CALLBACK(PRBool) jswindow_alert(JSContext * cx, JSObject * obj,
                                            uint argc, jsval * argv, jsval * rval)
d1597 8
a1604 9
  /*************************************************/
  /* jswindow_confirm()                            */
  /*                                               */
  /* Implementation of the Window object confirm() */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d1606 2
a1607 2
  PR_STATIC_CALLBACK(PRBool) jswindow_confirm(JSContext * cx, JSObject * obj,
                                             uint argc, jsval * argv, jsval * rval)
d1683 8
a1690 9
  /*************************************************/
  /* jswindow_home()                               */
  /*                                               */
  /* Implementation of the Window object home()    */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d1692 2
a1693 2
  PR_STATIC_CALLBACK(PRBool) jswindow_home(JSContext * cx, JSObject * obj,
                                           uint argc, jsval * argv, jsval * rval)
d1734 8
a1741 9
  /*************************************************/
  /* jswindow_stop()                               */
  /*                                               */
  /* Implementation of the Window object stop()    */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d1743 2
a1744 2
  PR_STATIC_CALLBACK(PRBool) jswindow_stop(JSContext * cx, JSObject * obj,
                                           uint argc, jsval * argv, jsval * rval)
d1785 8
a1792 9
  /*************************************************/
  /* jswindow_forward()                            */
  /*                                               */
  /* Implementation of the Window object forward() */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d1794 2
a1795 2
  PR_STATIC_CALLBACK(PRBool) jswindow_forward(JSContext * cx, JSObject * obj,
                                              uint argc, jsval * argv, jsval * rval)
d1836 8
a1843 9
  /*************************************************/
  /* jswindow_back()                               */
  /*                                               */
  /* Implementation of the Window object back()    */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d1845 2
a1846 2
  PR_STATIC_CALLBACK(PRBool) jswindow_back(JSContext * cx, JSObject * obj,
                                           uint argc, jsval * argv, jsval * rval)
d1887 8
a1894 9
  /*************************************************/
  /* jswindow_blur()                               */
  /*                                               */
  /* Implementation of the Window object blur()    */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d1896 2
a1897 2
  PR_STATIC_CALLBACK(PRBool) jswindow_blur(JSContext * cx, JSObject * obj,
                                           uint argc, jsval * argv, jsval * rval)
d1910 8
a1917 9
  /*************************************************/
  /* jswindow_focus()                              */
  /*                                               */
  /* Implementation of the Window object focus()   */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d1919 2
a1920 2
  PR_STATIC_CALLBACK(PRBool) jswindow_focus(JSContext * cx, JSObject * obj,
                                            uint argc, jsval * argv, jsval * rval)
d1952 8
a1959 9
  /*************************************************/
  /* jswindow_open()                               */
  /*                                               */
  /* Implementation of the Window object open()    */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d1961 2
a1962 2
  PR_STATIC_CALLBACK(PRBool) jswindow_open(JSContext * cx, JSObject * obj,
                                           uint argc, jsval * argv, jsval * rval)
d2503 11
a2513 12
  /*************************************************/
  /* jswindow_close()                              */
  /*                                               */
  /* Implementation of the Window object close()   */
  /* method. Will close the window without         */
  /* question if the window was created via.       */
  /* JavaScript (it has an inherited execution     */
  /* context), or ask first if not.                */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d2515 2
a2516 2
  PR_STATIC_CALLBACK(PRBool) jswindow_close(JSContext * cx, JSObject * obj,
                                            uint argc, jsval * argv, jsval * rval)
d2576 9
a2584 9
  /*************************************************/
  /* jswindow_print()                              */
  /*                                               */
  /* Implementation of the Window object print()   */
  /* method, an extension to allow console output. */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/
d2586 2
a2587 2
  PR_STATIC_CALLBACK(PRBool) jswindow_print(JSContext * cx, JSObject * obj,
                                            uint argc, jsval * argv, jsval * rval)
d2639 21
a2659 23
  /*************************************************/
  /* jswindow_has_option()                         */
  /*                                               */
  /* In a string as would be passed to for example */
  /* the JavaScript window.open() method, return   */
  /* the value associated with the given named     */
  /* entry in the given option string.             */
  /*                                               */
  /* Parameters: Pointer to the options string,    */
  /*             which will be written to during   */
  /*             the operation of the function     */
  /*             though it'll be overall unchanged */
  /*             when the function exits;          */
  /*                                               */
  /*             Pointer to the name to find the   */
  /*             associated value of.              */
  /*                                               */
  /* Returns:    Value (or '1' for 'yes'), with    */
  /*             '0' returned if the item is not   */
  /*             found, its associated value is    */
  /*             malformed for 'atoi()', or its    */
  /*             associated value is actually 0!   */
  /*************************************************/
d2707 17
a2723 18
  /*************************************************/
  /* jswindow_option_set()                         */
  /*                                               */
  /* In a string as would be passed to for example */
  /* the JavaScript window.open() method, return   */
  /* 1 if a given option is present, else 0.       */
  /*                                               */
  /* Parameters: Pointer to the options string,    */
  /*             which will be written to during   */
  /*             the operation of the function     */
  /*             though it'll be overall unchanged */
  /*             when the function exits;          */
  /*                                               */
  /*             Pointer to the name to find the   */
  /*             associated value of.              */
  /*                                               */
  /* Returns:    1 if option is found, else 0.     */
  /*************************************************/
d2766 22
a2787 25
  /*************************************************/
  /* jswindow_make_outer_bbox()                    */
  /*                                               */
  /* Based on a width and height, construct a      */
  /* bounding box describing a window outline      */
  /* based on the assumption that the given        */
  /* values were pixel sizes for the intended      */
  /* outer window width and height. The window     */
  /* will be centred on screen.                    */
  /*                                               */
  /* If you want to pass this bounding box on to   */
  /* something like windows_create_browser, run it */
  /* through jswindow_convert_to_area.             */
  /*                                               */
  /* The width and height are not allowed to drop  */
  /* below JSWindow_Minimum_Width and              */
  /* JSWindow_Minimum_Height (see top of file).    */
  /*                                               */
  /* Parameters: Pointer to a BBox with the xmin   */
  /*             and ymin fields filled in with    */
  /*             the pixel width and height        */
  /*             respectively - a 1 pixel to 2 OS  */
  /*             unit mapping is assumed in both   */
  /*             directions.                       */
  /*************************************************/
d2825 22
a2846 25
  /*************************************************/
  /* jswindow_make_inner_bbox()                    */
  /*                                               */
  /* Based on a width and height, construct a      */
  /* bounding box describing a window outline      */
  /* based on the assumption that the given        */
  /* values were pixel sizes for the intended      */
  /* inner window width and height. The window     */
  /* will be centred on screen.                    */
  /*                                               */
  /* If you want to pass this bounding box on to   */
  /* something like windows_create_browser, run it */
  /* through jswindow_convert_to_area.             */
  /*                                               */
  /* The width and height are not allowed to drop  */
  /* below JSWindow_Minimum_Width and              */
  /* JSWindow_Minimum_Height (see top of file).    */
  /*                                               */
  /* Parameters: Pointer to a BBox with the xmin   */
  /*             and ymin fields filled in with    */
  /*             the pixel width and height        */
  /*             respectively - a 1 pixel to 2 OS  */
  /*             unit mapping is assumed in both   */
  /*             directions.                       */
  /*************************************************/
d2871 21
a2891 24
  /*************************************************/
  /* jswindow_move_bbox()                          */
  /*                                               */
  /* Given a bounding box and X and Y absolute     */
  /* coordinates in pixels, move the box assuming  */
  /* it describes the outer outline of a window.   */
  /* Don't allow any window edge off-screen.       */
  /*                                               */
  /* Parameters: Pointer to a BBox filled in with  */
  /*             the coordinates describing a      */
  /*             window outline;                   */
  /*                                               */
  /*             X coordinate to move to in pixels */
  /*             - a 1 pixel to 2 OS unit mapping  */
  /*             is assumed (0 places the left     */
  /*             hand window edge at the far left  */
  /*             of the screen);                   */
  /*                                               */
  /*             Y coordinate to move to in pixels */
  /*             - again, a 1 pixel to 2 OS unit   */
  /*             mapping is assumed (0 places the  */
  /*             upper window edge at the top of   */
  /*             the screen).                      */
  /*************************************************/
d2942 9
a2950 9
  /*************************************************/
  /* jswindow_convert_to_area()                    */
  /*                                               */
  /* Convert a window outline bounding box to a    */
  /* window visible area bounding box, so it can   */
  /* e.g. be passed on to windows_create_browser.  */
  /*                                               */
  /* Parameters: Pointer to the BBox to convert.   */
  /*************************************************/
@


1.5
log
@Long overdue check-in of intermediate browser build, from continued "out
of hours" work. Forgot to add a few files last time too.

List dialogue box handler complete, and exclusion lists implemented
within the main browser code. Full documentation in Choices file.
Save routine knows all about it but is now getting very slow - must
come up with a better scheme; for now, it puts the hourglass on...

StripExtensions option controls auto stripping of filename extensions.

More sensible ancestor / frame selection for keyboard shortcut items
and the save dialogues - having selected a frame won't lock you into
it for F3 and related shortcuts now (input focus in URL writable ->
get ancestor details, input focus in frame -> get frame details). F4
works in frames. F5 now generally present for 'view source' with a
corresponding menu entry in the File menu.

Odd thing in later Res files; there's no action set for Adjust clicks
on the main ToolAction items in the button bar. Very odd. Nothing
appears to be set in v2.07 either, yet adjust-click works. Even
stranger. Anyway, added in the relevant event details (same as for
Select click in all cases) and this fixes the problem.

Background colours in the TABLE tag ignored the "don't print any
backgrounds" Print Style setting. Fixed. Meanwhile, the "black
text with no backgrounds" option wasn't getting this right either;
fixed this also.

Event logging implemented; HTTP errors and script output via.
window.print extension. No internal error output yet.

Faith:Never behaviour extended. If ever a server sends something with
no content type or an unhandleable type, the browser will try and get a
filetype from the URL. If it gets text or HTML, it'll render the file.
Else it'll save it. Hacks around IIS 4's lack of a content type field
in the Marketeye login stuff, and similar other slightly broken sites.
@
text
@d47 1
d2235 30
@


1.4
log
@Another intermediate version, rather more stable than the last I hope.

Lazy clearing of backgrounds - pages with the same background image or
colour won't be cleared to grey when going from one to the next anymore.

BODY element onLoad script attribute implemented properly (beyond the
Customer hackery).

Images use independent flex blocks for URL and transient fetch data;
greatly improved data throughput in image system as a result. Image
renumbering implemented - speeds up closing of pages / frames with
many images. Image xref is still rather slow though and images with
a 0 width or height specified in the HTML still cause an incorrectly
formatted page to appear.

Have, I think, fixed the "stops anti-aliasing" bug. Noticed that some
background images are not being processed as Fast (e.g. at the
Fibblesnork Lego Guide) - that old problem has reappeared, then.

Background images would cross reference when two pages had the same
background colour set in <body> elements but one was configured to use
document colours and one wasn't (so xref should not occur). Code was
looking at b->background_colour; corrected to call redraw_backcol(b).

Titles were added to the history according to the fetch URL not the
display URL, though the former is more likely to be in the history due
to the code execution order in the fetcher; changed to see whether this
improves upon the rather hit and miss addition of titles.

The 'about:' page now gets entered into the history (makes for much more
sensible behaviour if it is configured as a Home page, for example).
@
text
@d47 1
d90 2
d93 2
d170 1
a170 1
//  { "close",                  jswindow_close,                    0 },
d182 2
a183 2
//  { lm_blur_str,              jswindow_blur,                     0 },
//  { lm_focus_str,             jswindow_focus,                    0 },
d208 1
d1892 67
d2476 137
@


1.3
log
@Another intermediate check-in, resources may not be up to date; items
most likely to be buildable are PhoenixJ and BrowseD. Done because I'm
about to make some rather dodgy changes to code otherwise unchanged
since the Customer browser and I may well have to back them out...

In Handlers.c now set the HFlags_HasBeenVisited bit of a token at the point
it is first clicked on. Means the link returns to a "visited" colour after
the highlight flash immediately. This will persist for as long as the browser
window is kept open on that page, though if the URL doesn't end up making it
into the history for whatever reason it would "unhighlight" on reload; fair
enough, really. The highlight is window-local, so there are no redraw worries
for other open windows with links to the same URL (though other same-URL
links on the same page aren't updated either).

All forms submissions force a reload (principally for eudoramail.com, but
many other sites have similar requirements).

!MkClean and !MkClnAll didn't correctly call the utility to strip Makefile
dependencies. Fixed.

On fetch closedown, fetchpage_preprocess_token could be called on a token
which had already been run through the preprocessor. Now checks the flags
word before proceeding.

Image RAM cache and garbage collection system implemented - see new Choices
file entries CollectAfter, FreeRAMLimit and UnusedImageLimit to get an
overview. This contains groundwork for JavaScript image array support.

More JavaScript support improvements. Any one window object will know its
parent, top, this, etc.; frames array working except for a frameset created
via. multiple documents; opener for something created with window.open is
currently not set and don't know why (property is being created, pointer to
valid object is held, but JS engine returns 'null'. Ho hum) - JSChain won't
work yet, then.
@
text
@a393 1

d1217 5
a1221 1
        if (decoder->opener && !JSVAL_TO_OBJECT(*vp)) decoder->opener = NULL;
@


1.2
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d1900 1
a1900 1
    const char      * url_relative = "";
d1908 1
d1977 2
a1978 1
      url_relative = HtmlRelativiseURL(base, url_string, decoder->stream);
d2167 6
@


1.1
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d63 3
d392 5
d505 1
a505 1
      JSDocument * doc = JS_GetPrivate(cx, obj); /* (JSDocument defined in JSconsts.h) */
d674 1
a674 9
      /* Navigator only allows a frame to reference a parent that   */
      /* generated it via FRAMESET tags, if that parent generated   */
      /* the whole thing. If the parent loaded a page which itself  */
      /* had a FRAMESET, then that page would be the parent of the  */
      /* frames it loads.                                           */
      /*                                                            */
      /* The way that the internal structures work in this browser  */
      /* means we need to follow 'parent' pointers until we run out */
      /* to correctly copy the Navigator behaviour.                 */
d680 1
a680 1
        /* See if we can find a suitable parent */
d682 1
a682 3
        if (decoder->parent)
        {
          parent = utils_flat_parent(decoder);
d684 1
a684 8
          *vp = OBJECT_TO_JSVAL(parent->window_object);
        }
        else
        {
          /* The parent of the ancestor Window object is itself */

          *vp = OBJECT_TO_JSVAL(decoder->window_object);
        }
d1068 2
d1073 1
a1073 1
          if (decoder->parent)
a1074 2
            browser_data * parent = utils_parent(decoder);

d1383 1
a1383 5
      // No screen object yet
      //
      // return ((JSBool) (lm_DefineScreen(decoder, obj) != NULL));

      return JS_TRUE;
d1413 10
a1422 11
// Argh! Crippled decoder alert!
//
//      if (!lm_crippled_decoder->navigator) {
//          lm_DefinePluginClasses(lm_crippled_decoder);
//          lm_crippled_decoder->navigator = lm_DefineNavigator(lm_crippled_decoder);
//          if (!lm_crippled_decoder->navigator)
//              return JS_FALSE;
//          if (!JS_AddRoot(cx, &lm_crippled_decoder->navigator))
//              return JS_FALSE;
//      }
//
d1441 1
a1441 1
// Double argh! Another crippled decoder alert!
@

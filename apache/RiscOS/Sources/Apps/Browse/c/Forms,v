head	1.31;
access;
symbols
	Browse-2_16:1.31
	Browse-2_15:1.31
	Browse-2_14:1.31
	Browse-2_13:1.31
	Browse-2_12:1.31
	Browse-2_11:1.30
	Browse-2_10:1.30
	Browse-2_09:1.30
	ahodgkin_208_i4_2:1.29
	ahodgkin_208_i4:1.27
	ahodgkin_208_i3:1.27
	ahodgkin_208_i2:1.27
	ahodgkin_208_i1:1.27
	ahodgkin_207release:1.27
	ahodgkin_206release:1.25
	ahodgkin_205release:1.24
	ahodgkin_204release:1.24
	ahodgkin_202release:1.23
	ahodgkin_201release:1.22
	ahodgkin_200release:1.22
	ahodgkin_133beta:1.22
	ahodgkin_132beta:1.22
	ahodgkin_131beta:1.21
	ahodgkin_130beta:1.20
	ahodgkin_129:1.19
	ahodgkin_128beta:1.19
	ahodgkin_128alpha:1.19
	ahodgkin_127beta2:1.17
	ahodgkin_127beta:1.17
	ahodgkin_126beta:1.15
	ahodgkin_AW97patch:1.15
	ahodgkin_AW97:1.15;
locks; strict;
comment	@# @;


1.31
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.26.09.42.34;	author ahodgkin;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.14.08.45.06;	author ahodgkin;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.31.15.58.32;	author ahodgkin;	state Exp;
branches;
next	1.27;

1.27
date	98.09.23.13.18.04;	author ahodgkin;	state Exp;
branches;
next	1.26;

1.26
date	98.09.07.11.46.44;	author ahodgkin;	state Exp;
branches;
next	1.25;

1.25
date	98.07.09.10.27.05;	author ahodgkin;	state Exp;
branches;
next	1.24;

1.24
date	98.03.26.14.21.04;	author ahodgkin;	state Exp;
branches;
next	1.23;

1.23
date	98.03.20.12.12.34;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	98.02.06.13.55.04;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	98.01.31.10.55.16;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	97.12.18.10.06.57;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	97.12.02.16.13.46;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	97.11.26.17.10.55;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	97.11.20.16.04.32;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	97.11.19.10.28.52;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	97.10.09.10.52.02;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	97.09.26.12.35.58;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.09.24.11.14.15;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.09.22.07.43.12;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.09.09.14.13.12;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.08.31.18.38.14;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.08.28.16.07.54;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.08.18.16.15.37;	author kbracey;	state Exp;
branches;
next	1.7;

1.7
date	97.08.18.09.23.53;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.08.12.09.26.33;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.16.38.49;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.08.01.09.00.49;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.30.12.39.01;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.07.30.12.08.01;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.28.31;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.31
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Forms.c                                           */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Functions to manage HTML forms.                   */
/*                                                            */
/* Author:  A.D.Hodgkinson, including various functions from  */
/*          original Customer browser by Merlyn Kline.       */
/*                                                            */
/* History: 20-Jan-1997 (ADH): Created.                       */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>
#include <tboxlibs/flex.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include "Global.h"
#include "FromROSLib.h"
#include "Utils.h"

#include "Browser.h"
#include "FetchPage.h"
#include "FontManage.h"
#include "Images.h"
#include "JavaScript.h"
#include "Memory.h"
#include "Redraw.h"
#include "Scale.h"
#include "TokenUtils.h"
#include "Toolbars.h"

#include "Forms.h"

#include "trace.h"

/* Local memory allocation granularity control */

#define F_BLOCKSIZE 1024

/* Characters used in temporary local encoding of form data */

#define ENCODE_DATASEP         1 /* Usually becomes '?' */
#define ENCODE_FIELDSEP        2 /* Usually becomes '&' */
#define ENCODE_VALUESEP        3 /* Usually becomes '=' */

#define FORM_AUTOSCROLL_MARGIN 128

#define FORM_SELECTED(p)       (!!((*(p)) & 1))
#define FORM_SELCHAR           'Y'
#define FORM_UNSELCHAR         'N'

/* Miscellaneous local definitions */

#define Forms_Menu_Separator     "---"
#define Forms_Menu_Separator_Len 3

/* Local compilation options */

#undef ARROWS_MOVE_OUT

/* Local structures */

typedef struct form_header
{
  HStream * token;  /* Token defining this form      */
  int       fields; /* Number of fields on this form */

} form_header;

typedef struct form_field_header
{
  form_fieldtype   type;
  HStream        * token; /* Defining token           */
  int              size;  /* Number of words occupied */

} form_field_header;

typedef struct form_field
{
  form_field_header header;
  form_field_value  value;

} form_field;

/* Statics */

static browser_data * fe_browser    = 0;    /* Browser containing current edit, 0 = no edits */
static HStream      * fe_token      = NULL; /* Currently edited token, NULL = none           */
static int            fe_index      = 0;    /* Index of caret into text area when editing    */
static int            fe_xscroll    = 0;    /* Scroll offset of edited field (OS coords)     */
static int            fe_yscroll    = 0;    /* Scroll offset of edited field (lines)         */
static int            fe_single     = 1;    /* Edited field is single line field             */
static int            fe_password   = 0;    /* Edited field is a password field              */

static wimp_menustr * fe_menu       = NULL; /* The current form menu for SELECTs      */
static browser_data * fe_mbrowser   = NULL; /* Browser we clicked menu on for SELECTs */
static HStream      * fe_mtoken     = NULL; /* Token we clicked menu on for SELECTs   */
static int            fe_lastkey    = 0;    /* Last key run through form_process_key  */

/* Static function prototypes */

static _kernel_oserror * form_ensure_free         (browser_data * b, int free);

static void            * form_find_record         (const browser_data * b, const HStream * restrict token, int header);

static _kernel_oserror * form_validate_select     (browser_data * b, HStream * tp, int deflt);
static _kernel_oserror * form_validate_radio      (browser_data * b, HStream * token);

static _kernel_oserror * form_set_field_space     (browser_data * b, HStream * token, int space);
static void              form_build_selection     (const int * value, char * selection);
static char            * form_select_text         (const browser_data * restrict b, const HStream * restrict token, const char * restrict selection);
static _kernel_oserror * form_reset_form          (browser_data * b, HStream * token);

static void              form_textarea_find_caret (const char * p, int fh, int * index, int x, int y);
static void              form_textarea_caretpos   (const char * p, int fh, int index, int * x, int * y);
static int               form_input_box
                         (
                           browser_data  * restrict b,
                           const HStream * restrict tp,
                           BBox          * restrict box,
                           int           * restrict lh,
                           int           * restrict lb,
                           int           * restrict fhand
                         );

static _kernel_oserror * form_create_menu         (browser_data * restrict b, const HStream * restrict tp);
static _kernel_oserror * form_start_select_edit   (browser_data * b, HStream * token);

static _kernel_oserror * form_autoscroll          (browser_data * b);
static _kernel_oserror * form_start_textarea_edit (browser_data * b, HStream * tp, int mode);
static void              form_check_scroll_field  (browser_data * b, BBox * box, int x, int y, int lh);

static int               form_extend_flex         (void ** data, int size);
static int               form_encode_flex_data    (void ** data, const char * enctype, int start_at);
static int               form_field_data_size     (browser_data * b, form_field * fp, HStream * tp, unsigned int x, unsigned int y);
static _kernel_oserror * form_build_data          (browser_data * b, HStream * token, int x, int y, char ** data);
static _kernel_oserror * form_submit_form         (browser_data * b, HStream * token, int x, int y);

static int               form_cursor_editable     (form_fieldtype type);
static _kernel_oserror * form_next_field          (int auto_submit, int * used);
static _kernel_oserror * form_previous_field      (int * used);
static _kernel_oserror * form_cursor_right        (int * used);
static _kernel_oserror * form_cursor_bottom       (void);
static _kernel_oserror * form_cursor_eol          (void);
static _kernel_oserror * form_cursor_bol          (void);
static _kernel_oserror * form_cursor_left         (int * used);
static _kernel_oserror * form_cursor_top          (void);
static _kernel_oserror * form_cursor_y            (int dir, int * used);

static _kernel_oserror * form_insert_character    (int key, int * used);
static _kernel_oserror * form_delete_character    (int right);
static _kernel_oserror * form_delete_from_caret   (void);
static _kernel_oserror * form_delete_line         (void);

// /*************************************************/
// /* form_show_edit_token()                        */
// /*                                               */
// /* Ensures that the currently editing item, if   */
// /* there is one, is visible in the browser       */
// /* window that the form lies in.                 */
// /*************************************************/
//
// static void form_show_edit_token(void)
// {
//   /* If there is a currently editing browser and token, */
//   /* and that token is not fully visible, reshow the    */
//   /* item.                                              */
//
//   if (
//        fe_browser                                &&
//        fe_token                                  &&
//        !form_token_visible(fe_browser, fe_token)
//      )
//
//      browser_show_token(fe_browser, fe_token, 0, 0);
// }
//
// /*************************************************/
// /* form_token_visible()                          */
// /*                                               */
// /* Checks if a given forms item, indentified by  */
// /* an HStream structure, is visible in the       */
// /* browser window holding that form.             */
// /*                                               */
// /* The forms item should be one which will       */
// /* return sensible information when run through  */
// /* form_input_box (e.g. a writable field, text   */
// /* area, etc.).                                  */
// /*                                               */
// /* Parameters: Pointer to a browser_data struct  */
// /*             relevant to the form;             */
// /*                                               */
// /*             Pointer to an HStream struct      */
// /*             representing the field.           */
// /*                                               */
// /* Returns:    1 if the field is fully visible,  */
// /*             else 0.                           */
// /*************************************************/
//
// static int form_token_visible(browser_data * b, HStream * token)
// {
//   WimpGetWindowStateBlock state;
//   int                     ymin, ymax, lh, lb, fh, htop, hbot;
//   BBox                    box;
//
//   /* Get the window state */
//
//   state.window_handle = b->window_handle;
//
//   if (wimp_get_window_state(&state)) return 0;
//
//   /* Work out the page coordinates at the top and bottom */
//   /* of the visible area                                 */
//
//   if (!controls.swap_bars)
//   {
//     htop = toolbars_button_height(b) + toolbars_url_height(b);
//     hbot = toolbars_status_height(b);
//   }
//   else
//   {
//     htop = toolbars_status_height(b);
//     hbot = toolbars_button_height(b) + toolbars_url_height(b);
//   }
//
//   if (htop) htop += wimpt_dy();
//   if (hbot) hbot += wimpt_dy();
//
//   ymax = coords_y_toworkarea(state.visible_area.ymax - htop;
//                              (WimpRedrawWindowBlock *) &state);
//
//   ymin = coords_y_toworkarea(state.visible_area.ymin + hbot;
//                              (WimpRedrawWindowBlock *) &state);
//
//   /* Get the position of the forms item */
//
//   if (!form_input_box(b, token, &box, &lh, &lb, &fh)) return 0;
//
//   /* Work ouf if it is visible */
//
//   if (box.ymin > ymin && box.ymax < ymax) return 1;
//   if (box.ymax < ymin || box.ymin > ymin) return 0;
//
//   if (box.ymax - box.ymin > ymax - ymin) return 1;
//
//   return 0;
// }

/**************************************************************/
/* form_ensure_free()                                         */
/*                                                            */
/* Ensures that a given amount of free space is present in    */
/* the form store. This may not mean that the block extends   */
/* due to granularity of allocation considerations.           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form store;                                */
/*                                                            */
/*             Space to ensure is present.                    */
/*                                                            */
/* Assumes:    The space may be 0, in which case the block is */
/*             freed, and there may or may not be allocated   */
/*             store on entry. I.e., this copes with just     */
/*             about everything.                              */
/**************************************************************/

static _kernel_oserror * form_ensure_free(browser_data * b, int free)
{
  int ok = 1, oldsize, alloc;

  /* Work out how much extra space needs allocating to */
  /* give the requested free.                          */

  if (b->fdata)
  {
    int used;

    alloc   = 0;
    used    = *(int *)b->fdata; /* Amount of the block that's actually in use */
    oldsize = b->fdata_size;

    if (oldsize - used < free) alloc = free - (oldsize - used);
  }
  else
  {
    oldsize = 0;
    alloc   = free;
  }

  /* Proceed if that amount is not zero */

  if (alloc > 0)
  {
    /* Granularise the amount */

    alloc = alloc / F_BLOCKSIZE;
    alloc = (alloc + 1) * F_BLOCKSIZE;

    /* Allocate a new block or extent the existing one */

    if (!oldsize)
    {
      void * fdata = malloc(alloc);

      if (!fdata) ok = 0;
      else b->fdata = fdata, b->fdata_size = alloc;
    }
    else
    {
      void * fdata = realloc(b->fdata, alloc + oldsize);

      if (!fdata) ok = 0;
      else b->fdata = fdata, b->fdata_size = alloc + oldsize;
    }

    /* Report if the claim fails */

    if (!ok) return make_no_cont_memory_error(2);

    #ifdef TRACE
      malloccount += alloc;
      dprintf(("CMal", "**   malloccount: %d\n",malloccount));
    #endif

    /* If the block was not allocated before, then this */
    /* function itself has just used 4 bytes of it - in */
    /* storing the used space counter. So set this up   */
    /* to hold the right amount.                        */

    if (!oldsize) *(int *) b->fdata = 4;
  }

  return NULL;
}

/**************************************************************/
/* form_new_form()                                            */
/*                                                            */
/* Create a new form associated with the given token.         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form and token;                            */
/*                                                            */
/*             The token's address.                           */
/**************************************************************/

_kernel_oserror * form_new_form(browser_data * b, HStream * token)
{
  _kernel_oserror * e;
  form_header     * p;

  /* Claim memory for the form_header structure */

  e = form_ensure_free(b, sizeof(form_header));
  if (e) return e;

  /* The first word of the fdata data block that holds  */
  /* forms information says how many bytes in the       */
  /* block are actually used - including that first     */
  /* word. So the form_header needs to be placed at     */
  /* an address past this used space.                   */
  /*                                                    */
  /* It is up to users of the block to increase the     */
  /* used size counter, so form_ensure_free will not    */
  /* have incremented this yet.                         */

  p = (form_header *) (((int) b->fdata) + *(int *) b->fdata);

  /* Increment the used space counter */

  *(int *) b->fdata += sizeof(form_header);

  /* Fill in the structure and increment the forms counter */

  p->token  = token;
  p->fields = 0;

  b->nforms++;

  return NULL;
}

/**************************************************************/
/* form_discard()                                             */
/*                                                            */
/* Discards all the forms in a given view, freeing associated */
/* memory.                                                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the view.                                      */
/**************************************************************/

_kernel_oserror * form_discard(browser_data * b)
{
  form_cancel_edit(b);

  b->nforms = 0;

  if (b->fdata)
  {
    #ifdef TRACE
      malloccount -= b->fdata_size;
      dprintf(("CMal", "**   malloccount: %d\n",malloccount));
    #endif

    free(b->fdata);

    b->fdata      = NULL;
    b->fdata_size = 0;
  }

  return NULL;
}

/**************************************************************/
/* form_find_record()                                         */
/*                                                            */
/* Locates the form record governing the given token or       */
/* return NULL.                                               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             The token address;                             */
/*                                                            */
/*             1 to locate the header record for the form,    */
/*             else the field record will be located.         */
/*                                                            */
/* Returns:    Pointer to record, as a void *.                */
/**************************************************************/

static void * form_find_record
              (
                const browser_data *          b,
                const HStream      * restrict token,
                int                           header
              )
{
  form_header * hp;
  form_field  * fp;
  int           i, j, o, used;

  /* If there's no block, can't do anything */

  if (!b->fdata) return NULL;

  /* Set i to point past the first word, which holds the */
  /* used space counter (set 'used' to the value of that */
  /* counter, too).                                      */

  i    = 4;
  used = *(int *) b->fdata;

  /* Loop round as long as the offset counter i is inside */
  /* the amount of used data.                             */

  while (i < used)
  {
    /* All forms start with a form_header structure, so */
    /* set the header pointer hp to point to this.      */

    hp = (form_header *) (((int) b->fdata) + i);

    /* If the header's representing token matches the one */
    /* given to the function, then return 1) the pointer  */
    /* to it, if the header item was requested in the     */
    /* function's parameters, or 2) NULL, if the header   */
    /* item was not requested - if we've found the token  */
    /* in a header it can't possibly exist in a form      */
    /* field record too.                                  */

    if (hp->token == token) return (header ? hp : NULL);

    /* Set 'o' so that i + o gives an offset into the flex */
    /* block of the next form field record.                */

    o = sizeof(form_header);

    for (j = 0; j < hp->fields; j++)
    {
      /* As for the form header, find the form field record */

      fp = (form_field *) (((int) b->fdata) + i + o);

      /* And again, if the token matches that given to the */
      /* function, return the pointer to the header or the */
      /* pointer to the form record as indicated by the    */
      /* 'header' flag passed to the function.             */

      if (fp->header.token == token) return (header ? (void *) hp : (void *) fp);

      /* The 'size' field of the form field header in */
      /* the form field record holds the size of that */
      /* field in words; so increase the offset 'o'   */
      /* by this multiplied by 4 to get to the next   */
      /* form field.                                  */

      o += fp->header.size * 4;
    }

    /* Skip 'i' onto the next form header item */

    i += o;
  }

  return NULL;
}

/**************************************************************/
/* form_validate_select()                                     */
/*                                                            */
/* Deals with clicks on selection lists (aka. pop-up menus in */
/* forms) - either to select an item for the first time in an */
/* unselected group of menu items, or to ensure that the      */
/* selection which has been made is valid. Consequently, if   */
/* more than one item in the array is selected and the field  */
/* should only allow one at a time, everything but the first  */
/* selected item in the array will be deselected.             */
/*                                                            */
/* This function initiates appropriate redraws.               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             The token address for the list;                */
/*                                                            */
/*             The item number selected in the menu.          */
/**************************************************************/

static _kernel_oserror * form_validate_select(browser_data * b, HStream * tp, int deflt)
{
  int          changed;
  int          n;
  form_field * fp;
  char       * p;

  /* If the SELECT item can take multiple selections, there's */
  /* no work to do, so exit.                                  */

  if (HtmlSELECTmultiple(tp)) return NULL;

  /* Otherwise, find the form field record */

  fp = form_find_record(b, tp, 0);

  /* If not a SELECT field or the record couldn't be found, */
  /* exit.                                                  */

  if (!fp || fp->header.type != form_select) return NULL;

  changed = 0;

  /* Point to the 'selection' char array for the item */
  /* (see Forms.h).                                   */

  p = fp->value.select.selection;
  n = 0;

  /* Go through the array character by character, */
  /* representing items in the select list.       */

  while (*p)
  {
    /* n gets incremented when a selected item is */
    /* encountered. So the first time a selected  */
    /* item is hit, the following test fails.     */

    if (*p == FORM_SELCHAR && n)
    {
      /* However, the next time one is hit, this */
      /* will succeed; in that case, since we    */
      /* can only have one item selected at a    */
      /* time, deselect the item.                */

      changed = 1;
      *p      = FORM_UNSELCHAR;
    }

    /* (Mark the first occurrence of a selected item in 'n' */

    if (*p == FORM_SELCHAR) n++;

    p++;
  }

  /* If n is zero, no items were selected. In this case, can */
  /* simply select the item given in the function call and   */
  /* flag the change in 'changed'.                           */

  if (!n)
  {
    changed = 1;
    fp->value.select.selection[deflt] = FORM_SELCHAR;
  }

  /* If the item selected in the menu has now changed, */
  /* redraw the field to reflect the new selection.    */

  if (changed) browser_update_token(b, tp, 0, 0);

  return NULL;
}

/**************************************************************/
/* form_validate_radio()                                      */
/*                                                            */
/* Validate radio icons including the indicated token; i.e.   */
/* ensure that only one is selected.                          */
/*                                                            */
/* If more than one is selected, all but the last are         */
/* deselected (unless the passed token is selected). If none  */
/* are selected, that's allowed (Netscape Navigator - hmph).  */
/*                                                            */
/* This behaviour is important when loading forms as it       */
/* ensures that the correct default selection is applied (if  */
/* the fourth button is selected by default, when the first   */
/* is added it will be alone and deselected so it will get    */
/* selected - this must be overridden when the fourth button  */
/* is added to the page). It also ensures sensible behaviour  */
/* when the user clicks on the selected button.               */
/*                                                            */
/* This function initiates appropriate redraws.               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             The token address for the radio.               */
/**************************************************************/

static _kernel_oserror * form_validate_radio(browser_data * b, HStream * token)
{
  form_field  * fp;
  form_header * hp;
  HStream     * tp;
  const char  * name;
  int           selectthis;
  int           foundone;
  int           i;

  /* Find the record associated with the given token, */
  /* and exit if it can't be found or doesn't         */
  /* represent a radio group.                         */

  fp = form_find_record(b, token, 0);

  if (!fp || fp->header.type != form_radio) return NULL;

  /* Set 'selectthis' if the radio is selected, and set */
  /* 'name' to the radio's name.                        */

  selectthis = fp->value.checked;
  name       = HtmlINPUTname(token);

  /* Find the form header and first record of the form that */
  /* the given token lies in.                               */

  hp = form_find_record(b, token, 1);
  if (!hp) return NULL;

  fp = (form_field *) (((int) hp) + sizeof(form_header));

  /* Loop round all the fields in this group */

  foundone = 0;

  for (i = 0; i < hp->fields; i++)
  {
    /* Proceed if this field is a radio button */

    if (fp->header.type == form_radio)
    {
      tp = fp->header.token;

      /* See if the name of the token representing this radio */
      /* matches the name of the token given to the function  */

      if (name && HtmlINPUTname(tp) && !strcmp(name, HtmlINPUTname(tp)))
      {
        /* If so, it's in the same group of radio buttons. */

        if (
             fp->value.checked &&          /* So if the item is selected, */
             (
               foundone ||                 /* a selected one has been found before, or */
               (
                 selectthis &&             /* the given token was selected, */
                 fp->header.token != token /* and this field does not use the same token... */
               )
             )
           )
        {
          /* ...Then deselect this item and redraw it */

          fp->value.checked = 0;
          browser_update_token(b, fp->header.token, 0, 0);
        }

        /* Otherwise, this is the first item in the group that has been */
        /* found selected, so set foundone to flag this.                */

        if (fp->value.checked) foundone = 1;
      }
    }

    /* Point to the next form field record */

    fp = (form_field *) (((int) fp) + fp->header.size * 4);
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* form_set_field_space()                                     */
/*                                                            */
/* Set the space in bytes occupied by a field, *not*          */
/* including the header.                                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to the token representing the field;   */
/*                                                            */
/*             Space to set for the field, not including the  */
/*             header, in bytes.                              */
/**************************************************************/

static _kernel_oserror * form_set_field_space(browser_data * b, HStream * token, int space)
{
  _kernel_oserror * e;
  form_field      * fp;
  int               oldspace, offset;

  /* Find the form field record */

  fp = form_find_record(b, token, 0);
  if (!fp) return NULL;

  /* Get the offset of that record in the data block   */
  /* and determine the amount of space it already uses */

  offset   = ((int) fp) - ((int) b->fdata);
  oldspace = fp->header.size * 4;

  /* Add the size of the form header to the requested */
  /* form field space and word align it               */

  space += sizeof(form_field_header);
  space  = (int) WordAlign(space);

  /* If asking for more space, try to claim that memory */
  /* (if asking for less, leave the data block at its   */
  /* old size).                                         */

  if (space > oldspace)
  {
    e = form_ensure_free(b, space - oldspace);
    if (e) return e;
  }

  /* If the amount of space required is different from */
  /* the space already used, move data around in the   */
  /* data block as appropriate                         */

  if (space != oldspace)
  {
    /* Shuffle data above the field up or down so that the  */
    /* field now has the new amount of space (be it more or */
    /* less than before) free.                              */

    memmove((char *) (((int) b->fdata) + offset + space),
            (char *) (((int) b->fdata) + offset + oldspace),
            *((int *) b->fdata) - offset - oldspace);

    /* Update the data block's used space counter */

    *(int *) b->fdata += space - oldspace;

    /* Refind the field record (it may have moved) */

    fp = form_find_record(b, token, 0);
    if (!fp) return NULL;

    /* Update the field record's used words counter */

    fp->header.size = space / 4;
  }

  return NULL;
}

/**************************************************************/
/* form_put_field()                                           */
/*                                                            */
/* Sets the value in a field.                                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to the token representing this field;  */
/*                                                            */
/*             The value, as a char * - this is as for        */
/*             form_new_field below, except for SELECT        */
/*             fields, where it is treated as a pointer to a  */
/*             zero terminated list of bytes where            */
/*             FORM_UNSELCHAR indicates the item is not       */
/*             selected, and FORM_SELCHAR indicates it is     */
/*             selected;                                      */
/*                                                            */
/*             1 to update (redraw) the token, else 0.        */
/**************************************************************/

_kernel_oserror * form_put_field(browser_data * b, HStream * token, char * value, int update)
{
  _kernel_oserror * e;
  form_field      * fp;
  int               changed = 0;

  /* Find the field record */

  fp = form_find_record(b, token, 0);

  /* Only proceed if it can be found */

  if (fp)
  {
    switch (fp->header.type)
    {
      /* Writable items - text areas, normal single-line writables, */
      /* and single-line password writables.                        */

      case form_textarea: /* same as form_password: no break */
      case form_text    : /* same as form_password: no break */
      case form_password:
      {
        /* If a value for the field (i.e. a string for the writable field)  */
        /* has been given and it is different from the current field value, */
        /* ensure there is space for the new text, copy it in, and flag     */
        /* that there has been a change to the item with 'changed'.         */

        if (value && fp->value.text && strcmp(value, fp->value.text))
        {
          e = form_set_field_space(b, token, strlen(value) + 1);
          if (e) return e;

          fp = form_find_record(b, token, 0);
          if (!fp) return NULL;

          strcpy(fp->value.text, value);

          changed = 1;
        }
      }
      break;

      /* Checkbox (also known as an option button) */

      case form_checkbox:
      {
        /* If the 'value' parameter passed to the function is NULL, the */
        /* item will be deselected, else it will be selected.           */

        changed           = ((!value) != (!fp->value.checked));
        fp->value.checked = !!value;
      }
      break;

      /* Radio buttons */

      case form_radio:
      {
        /* Set the item's selected state as for option boxes above */

        changed           = ((!value) != (!fp->value.checked));
        fp->value.checked = !!value;

        /* For radios, need to make sure only one is selected */

        form_validate_radio(b, token);
      }
      break;

      /* Selection lists (pop-up menus) */

      case form_select:
      {
        char * o;

        /* If value is NULL, change it to be an empty string instead - */
        /* avoids having to keep checking for (value == NULL) later.   */

        value = value ? value : fp->value.select.selection;

        /* Try to find the first selected item in the field; */
        /* if not found, point to the first item.            */

        o = strchr(value, FORM_SELCHAR);
        if (!o) o = value;

        /* If the value passed to the function differs from that */
        /* already set for the field, change to the new value    */
        /* (which must be the same size - the number of items in */
        /* the field can't change) and flag the alteration in    */
        /* 'changed'.                                            */

        if (strcmp(value, fp->value.select.selection))
        {
          strcpy(fp->value.select.selection, value);
          changed = 1;
        }

        /* Ensure that this leaves a valid selection in the list */
        /* (some SELECT field types only allow one item to be    */
        /* selected at any one time).                            */

        form_validate_select(b, token, o - value);
      }
      break;
    }
  }

  /* Only update the token if it's changed, even if the   */
  /* 'update' parameter says the token should be redrawn. */
  /* This minimises flicker.                              */

  if (changed && update) browser_update_token(b, token, 0, 0);

  return NULL;
}

/**************************************************************/
/* form_build_selection()                                     */
/*                                                            */
/* Takes the value of a SELECT field - a list of items on a   */
/* menu - which will contain a series of FORM_SELCHAR and     */
/* FORM_UNSELCHAR characters, and fills in a given char array */
/* based on this value.                                       */
/*                                                            */
/* The first 4 bytes of the value field hold an int           */
/* describing the number of entries in the field. 8 bytes in  */
/* are the SEL or UNSEL chars, followed immediately by two    */
/* strings describing the menu entry (menu text and the field */
/* name for form submisson).                                  */
/*                                                            */
/* Parameters: Pointer to the value string;                   */
/*                                                            */
/*             Pointer to a char array big enough to hold the */
/*             selection array information (e.g. make it      */
/*             Limits_SelectItems + 1 in size to hold         */
/*             selections plus terminator).                   */
/**************************************************************/

static void form_build_selection(const int * value, char * selection)
{
  int    i, n;
  char * p;

  /* Find the number of entries and point to the first in 'p' */

  p  = (char *) (value + 2);
  n  = value[0];

  /* Can't go past the internal limit (see top of this file) */

  if (n > Limits_SelectItems) n = Limits_SelectItems;

  /* Loop through the entries */

  for (i = 0; i < n; i++)
  {
    /* FORM_SELECTED checks bit 0 of the character pointed */
    /* to by p, returning 1 if it is set.                  */

    selection[i] = FORM_SELECTED(p) ? FORM_SELCHAR : FORM_UNSELCHAR;

    /* Move past the selection character */

    p ++;

    /* Move past the menu entry text */

    p += strlen(p) + 1;

    /* Move past the menu entry name */

    p += strlen(p) + 1;
  }

  /* Terminate the list */

  selection[i] = 0;
}

/**************************************************************/
/* form_new_field()                                           */
/*                                                            */
/* Add a new field to the last form in the list (always the   */
/* right one due to the sequential nature of HTML forms). The */
/* value is initialised as passed in; for radios and          */
/* checkboxes this is taken to be NULL = not selected,        */
/* otherwise selected. For SELECT fields, this is taken as a  */
/* pointer to the value part of the token; this will be       */
/* converted to a zero terminated list of bytes where         */
/* FORM_UNSELCHAR = not selected, FORM_SELCHAR = selected.    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to a token describing the new item;    */
/*                                                            */
/*             The field type (see the form_fieldtype         */
/*             definition in Forms.h);                        */
/*                                                            */
/*             Value for the field (see comments above).      */
/**************************************************************/

_kernel_oserror * form_new_field(browser_data * b, HStream * token, form_fieldtype type, char * value)
{
  _kernel_oserror * e;
  int               space, c;
  form_field      * p;
  form_header     * head;
  char              select[Limits_SelectItems + 1];

  /* Did we hit a forms element with no FORM tag ever appearing */
  /* before it in the document?                                 */

  if (!b->fdata) RetError(form_new_form(b, NULL));

  /* Need space for the form header to start with */

  space = sizeof(form_field_header);

  /* Work out the space needed for the given form field type */

  switch (type)
  {
    case form_textarea: value = value ? value : ""; space += strlen(value) + 1; break;
    case form_text:     value = value ? value : ""; space += strlen(value) + 1; break;
    case form_password: value = value ? value : ""; space += strlen(value) + 1; break;

    case form_checkbox: space += 4; break;
    case form_radio:    space += 4; break;

    case form_select:
    {
      form_build_selection((int *) value, select);

      value  = select;
      space += strlen(value) + 1 + sizeof(fv_select) - 4;
    }
    break;

    /* Other types have no data storage and the value part of the */
    /* structure is overwritten by the next field entry.          */
  }

  /* Word align the required space and allocate it */

  space = (int) WordAlign(space);

  e = form_ensure_free(b, space);
  if (e) return e;

  /* *(int *) b->fdata holds the amount of used space in the data */
  /* block, so the following sets p to the first unused bit of    */
  /* space in that block.                                         */

  p = (form_field *) (((int) b->fdata) + *(int *) b->fdata);

  /* Update the used space counter */

  *(int *) b->fdata += space;

  /* Fill int the structure */

  p->header.type  = type;
  p->header.token = token;
  p->header.size  = space / 4; /* (Size in words) */

  /* Fill in the value */

  switch(type)
  {
    case form_textarea: /* same as password: no break */
    case form_text:     /* same as password: no break */

    case form_password: strcpy(p->value.text, value);
    break;

    case form_checkbox: /* same as radio: no break */

    case form_radio:    p->value.checked = !!value;
    break;

    case form_select:
    {
      p->value.select.scroll = 0;
      strcpy(p->value.select.selection, value);
    }
    break;

    /* Other types have no data storage and the value part of the */
    /* structure is overwritten by the next field entry.          */
  }

  head = (form_header *) (((int) b->fdata) + 4);
  c    = b->nforms;

  /* Find the header record for this form. */

  while ((--c) > 0)
  {
    int           n = head->fields;
    form_field * fp = (form_field *) (((int) head) + sizeof(form_header));

    while ((n--) > 0) fp = (form_field *) (((int) fp) + fp->header.size * 4);

    head = (form_header *) fp;
  }

  /* Increment the field counter for the form */

  head->fields++;

  /* For radio groups or selection lists, check that a */
  /* valid arrangement of selections has been made     */

  if (type == form_radio)  form_validate_radio (b, token);
  if (type == form_select) form_validate_select(b, token, 0);

  /* Start an image fetch for TYPE=IMAGE items */

  if (type == form_image)
  {
    e = image_new_image(b, HtmlINPUTsrc(token), token, 0, NULL);
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* form_get_field()                                           */
/*                                                            */
/* Returns the field value for a given forms item based on a  */
/* given token.                                               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             item for which the field value is required.    */
/*                                                            */
/* Returns:    The field value (see Forms.h)                  */
/**************************************************************/

form_field_value * form_get_field(browser_data * b, HStream * token)
{
  form_field * fp;

  fp = form_find_record(b, token, 0);

  return (fp ? &fp->value : NULL);
}

/**************************************************************/
/* form_select_text()                                         */
/*                                                            */
/* Returns a pointer to a string to use for the display       */
/* component of a SELECT field based on the what is selected  */
/* within it.                                                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             SELECT field;                                  */
/*                                                            */
/*             An array of chars describing the selection,    */
/*             e.g. as filled in by form_build_selection.     */
/*                                                            */
/* Returns:    Pointer to the text to use. This may be a text */
/*             item within the forms item itself or a general */
/*             response inside the Messages file lookup       */
/*             buffer - so if the caller wants to use         */
/*             lookup_token or any function which calls it    */
/*             but must retain the text across the call, that */
/*             caller must copy the text to a private buffer  */
/*             first.                                         */
/**************************************************************/

static char * form_select_text
              (
                const browser_data * restrict b,
                const HStream      * restrict token,
                const char         * restrict selection
              )
{
  int          i, n, s;
  const int  * pi;
  const char * p;
  char       * f;

  s  = 0;

  /* Find the number of entries in the list and skip to the first */
  /* one in 'p' and 'f'.                                          */

  pi = HtmlSELECToptions((HStream *) token);
  n  = pi[0];
  p  = (const char *) (pi + 2);
  f  = (char *) p;

  if (n > Limits_SelectItems) n = Limits_SelectItems;

  /* Loop through the entries */

  for (i = 0; i < n; i++)
  {
    /* If an item is selected, remember the pointer to it in 'f' */
    /* and count how many times this has happened in 's'.        */

    if (selection[i] == FORM_SELCHAR)
    {
      s++;

      f = (char *) p;
    }

    /* Move past the selected/unselected indicator char */

    p++;

    /* Move past the menu entry text */

    p += strlen(p) + 1;

    /* Move past the menu entry name */

    p += strlen(p) + 1;
  }

  /* If there were no selected items, return an appropriate message */

  if (!s)    return lookup_token("selNONE:<None>",0,0);

  /* If there were many selected items, return an appropriate message */

  if (s > 1) return lookup_token("selMANY:<Many>",0,0);

  /* Otherwise, return the entry text ('+ 1' gets past the */
  /* selected/unselected indicator char for the entry).    */

  return f + 1;
}

/**************************************************************/
/* form_get_field_text()                                      */
/*                                                            */
/* Returns the text associated with a given forms item        */
/* (identified by an HStream struct), taking care of the      */
/* different types of field.                                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             field.                                         */
/*                                                            */
/* Returns:    Pointer to the associated text.                */
/**************************************************************/

char * form_get_field_text
       (
         const browser_data * restrict b,
         const HStream      * restrict token
       )
{
  form_field * fp;

  /* Try to find the record, exit if this fails */

  fp = form_find_record(b, token, 0);
  if (!fp) return NULL;

  switch (fp->header.type)
  {
    case form_text:     /* Same as form_password */
    case form_textarea: /* Same as form_password */
    case form_password:
    {
      /* For these items, just a simple text string */

      return fp->value.text;
    }
    break;

    case form_checkbox:
    case form_radio:
    {
      /* Radios and checkboxes have no associated text */

      return NULL;
    }
    break;

    case form_select:
    {
      /* Select items need to return either the contents of a */
      /* selected menu item, or appropriate messages for many */
      /* or no selections.                                    */

      return form_select_text(b,
                              token,
                              fp->value.select.selection);
    }
    break;
  }

  return NULL;
}

/**************************************************************/
/* form_reset_form()                                          */
/*                                                            */
/* Returns a form to the state it was in when fetched,        */
/* discarding any changes within it.                          */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to an HStream struct that identifies   */
/*             the form to reset.                             */
/**************************************************************/

static _kernel_oserror * form_reset_form(browser_data * b, HStream * token)
{
  _kernel_oserror * e;
  form_header     * hp;

  /* Find the header record for the form */

  hp = form_find_record(b, token, 1);

  if (hp)
  {
    form_field * fp;
    int          i, j;
    char       * value;
    HStream    * tp;
    char         select[Limits_SelectItems + 1];

    /* Loop through all the form's fields */

    for (i = 0; i < hp->fields; i++)
    {
      /* Find the header again in case it has moved */

      hp = form_find_record(b, token, 1);

      /* Find the form field record - first, get the */
      /* first item based on the form_header pointer */

      fp = (form_field *) (((int) hp) + sizeof(form_header));

      /* Now skip along to the 'i'th entry, skipping along */
      /* by however many words each entry says it uses.    */

      for (j = 0; j < i; j++) fp = (form_field *) (((int) fp) + fp->header.size * 4);

      /* Get the associated HStream structure - all the */
      /* field values to write will come from this,     */
      /* thus restoring the initial form state.         */

      tp    = fp->header.token;
      value = NULL;

      switch(fp->header.type)
      {
        case form_text:     /* Same as form_password */
        case form_textarea: /* Same as form_password */
        case form_password:
        {
          /* Value is a simple text string for these types */

          value = tp->text ? tp->text : "";
        }
        break;

        case form_checkbox:
        case form_radio:
        {
          /* Value is NULL for unselected, non-NULL for selected */

          value = (char *) HtmlINPUTchecked(tp);
        }
        break;

        case form_select:
        {
          /* Value is the array of FORM_SELCHAR and FORM_UNSELCHAR characters */

          form_build_selection(HtmlSELECToptions(tp), select);
          value = select;
        }
        break;
      }

      /* Write the value for the field */

      e = form_put_field(b, tp, value, 1);
      if (e) return e;
    }
  }

  return NULL;
}

/**************************************************************/
/* form_get_linesize()                                        */
/*                                                            */
/* On the basis of a font bounding box, return a baseline     */
/* offset and line height for a text area.                    */
/*                                                            */
/* Parameters: Pointer to a BBox holding the minimum bounding */
/*             box needed to enclose any char in the font;    */
/*                                                            */
/*             Pointer to an int, into which the line's       */
/*             height is returned;                            */
/*                                                            */
/*             Pointer to an int, into which a font baseline  */
/*             offset is returned.                            */
/*                                                            */
/* Assumes:    That the pointers are not NULL.                */
/**************************************************************/

void form_get_linesize(BBox * fontbox, int * lh, int * lb)
{
  /* lb = font baseline offset from line bottom.    */

  *lb = 4 - fontbox->ymin;

  if (*lb < 0)   *lb  = 0;
  if ((*lb) & 3) *lb += 4 - ((*lb) & 3); /* (Rounding is done to ensure consistent spacing) */

  /* lh = line height */

  *lh = *lb + fontbox->ymax;

  if ((*lh) & 3) *lh += 4 - ((*lh) & 3);
}

/**************************************************************/
/* form_textarea_find_caret()                                 */
/*                                                            */
/* Locates the caret index in the string from the x position  */
/* (in OS units) and y position (in lines) relative to the    */
/* top left of a text area.                                   */
/*                                                            */
/* Parameters: Pointer to the string inside the text area;    */
/*                                                            */
/*             Font handle used by the area;                  */
/*                                                            */
/*             Pointer to an int, into which the index into   */
/*             the string is written;                         */
/*                                                            */
/*             X offset of caret from top left, in OS units;  */
/*                                                            */
/*             Y offset of caret from top left, in lines.     */
/*                                                            */
/* Assumes:    That the int pointer is not NULL.              */
/**************************************************************/

static void form_textarea_find_caret(const char * p, int fh, int * index, int x, int y)
{
  int    i, l, w;
  char   c;
  char * t;
  char   passcode[] = FE_PassCode;

  /* Locate the start of the line indicated by 'y' */

  i = 0;

  while (y > 0 && p[i])
  {
    if (p[i] == '\n') y--;
    i++;
  }

  p += i;

  /* Locate the end of the line */

  t = strchr(p, '\n');
  if (!t) t = strchr(p, 0);

  /* Force a terminator there, if there wasn't one already */

   c = *t;
  *t = 0;

  /* Get the index in this string from the font library */

  fm_get_string_width(fh,
                      fe_password ? passcode : p,
                      x * 400 + 6 * 400,
                      strlen(p),
                      -1,
                      &l,
                      &w);

  /* Restore the character overwritten by the terminator */

  *t = c;

  /* Write the caret index to the int given by 'index' */

  *index = l + i;

  return;
}

/**************************************************************/
/* form_textarea_caretpos()                                   */
/*                                                            */
/* Returns a horizontal offset in OS units and (for text      */
/* areas as opposed to single line writables) a vertical      */
/* offset in lines, at which the caret should be placed to be */
/* in a given index into a given string.                      */
/*                                                            */
/* Parameters: Pointer to the string;                         */
/*                                                            */
/*             The RISC OS Font Manager font handle for the   */
/*             font that the text is to be rendered in;       */
/*                                                            */
/*             Index into the string;                         */
/*                                                            */
/*             Pointer to an int, into which an offset from   */
/*             the left hand side of the text field, in OS    */
/*             units, is placed;                              */
/*                                                            */
/*             Pointer to an int, in which an offset in lines */
/*             from the top of the text field is placed.      */
/**************************************************************/

static void form_textarea_caretpos(const char * p, int fh, int index, int * x, int * y)
{
  int          ox, oy, i, li;
  const char * t;
  const char * l;
  char         passcode[] = FE_PassCode;

  i = li = oy = ox = 0;

  l = t = p;

  /* Whilst within the given index and still inside the given */
  /* string, search for new line characters. Increment the    */
  /* counter for the number of lines from the top for each.   */
  /* Other counters are updated so that the horizontal code   */
  /* below only works on the fragment of string that lies on  */
  /* the last line found here.                                */

  while (i < index && *t)
  {
    if (*t == '\n')
    {
      li = i + 1;
      l  = t + 1;

      oy++;
    }

    t++;
    i++;
  }

  /* For the x offset, work out the width of the string between */
  /* the start of the last line found above and the given index */
  /* position into the string.                                  */

  fm_get_string_width(fh,
                      fe_password ? passcode : l,
                      0x1000000,
                      index - li,
                      -1,
                      &i,
                      &ox);

  /* Convert to OS units */

  convert_to_os(ox, &ox);

  /* Return the values */

  if (x) *x = ox;
  if (y) *y = oy;
}

/**************************************************************/
/* form_input_box()                                           */
/*                                                            */
/* Returns information about a given input box (writable), if */
/* found.                                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             field;                                         */
/*                                                            */
/*             Pointer to a BBox which will be filled with    */
/*             the bounding box of the field;                 */
/*                                                            */
/*             Pointer to an int, into which the line height  */
/*             for the field is written;                      */
/*                                                            */
/*             Pointer to an int, into which the baseline     */
/*             offset for the field is written;               */
/*                                                            */
/*             Pointer to an int, into which the handle of    */
/*             the font used by the field is written.         */
/*                                                            */
/* Returns:    1 if the field was found, else 0.              */
/*                                                            */
/* Assumes:    None of the pointers may be NULL.              */
/**************************************************************/

static int form_input_box
           (
             browser_data  * restrict b,
             const HStream * restrict tp,
             BBox          * restrict box,
             int           * restrict lh,
             int           * restrict lb,
             int           * restrict fhand
           )
{
  int                   l, c, x, y, fh, t = 0;
  int                   orx,ory;
  int                   depth;
  token_path          * path;
  const reformat_cell * cell;

  /* Find the token */

  depth = tokenutils_line_range(b, tp, &l, &c, NULL, NULL, &path);
  if (l < 0) return 0;

  /* Find out the x and y offset of the cell the */
  /* token lies in.                              */

  tokenutils_token_offset(b, path, &orx, &ory);

  /* If there are valid entries in the token_path structure, */
  /* need to find out what line list browser_update_token_r  */
  /* should be called on. Otherwise, it's the main line      */
  /* list.                                                   */

  cell = tokenutils_find_cell(b->cell, depth, path);

  if (path) free (path);

  if (!cell) cell = b->cell, orx = 0, ory = 0;

  /* Get the position of this token and the font it uses */

  y  = ory + cell->ldata[l].y + cell->ldata[l].b;
  x  = orx + redraw_token_x(b, cell, tp, l);
  fh = fm_find_token_font(b, tp, 0);

  /* Return the font handle */

  *fhand = fh;

  /* Get the font bounding box and get line size details */

  fm_font_box(fh, box);
  form_get_linesize(box, lh, lb);

  /* For a text area, need to adjust the y coordinates of */
  /* the bounding box to account for the number of lines  */
  /* the area has.                                        */

  if (tp->tagno == TAG_TEXTAREA)
  {
    int r;

    r = tp->rows;
    if (r < 2) r = 2;

    box->ymin -= *lh * (r - 1);
  }

  /* Account for the border */

  box->ymin = box->ymin + y - 8;
  box->ymax = box->ymax + y + 8;

  /* Work out the x ranges */

  box->xmin = x + 4;

  convert_pair_to_os(cell->cdata[c].w, t, &x, &t);

  box->xmax = box->xmin + x - 4 - 4;

  return 1;
}

/**************************************************************/
/* form_abandon_menu()                                        */
/*                                                            */
/* Closes a form menu, so that there is no currently editing  */
/* form any more.                                             */
/**************************************************************/

void form_abandon_menu(void)
{
  /* Only proceed if there's a menu to abandon */

  if (fe_menu)
  {
    /* Close the menu, free memory associated with it, */
    /* and clear the status information associated     */
    /* with it.                                        */

    wimp_create_menu((wimp_menustr *) - 1, 0, 0);

    free (fe_menu);

    fe_menu     = NULL;
    fe_mbrowser = NULL;
    fe_mtoken   = NULL;

    menusrc = Menu_None;
  }
}

/**************************************************************/
/* form_end_edit()                                            */
/*                                                            */
/* Finishes editing a form, optionally discarding changes and */
/* moving the input focus to a general position in the        */
/* browser.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             1 to keep changes, else discard;               */
/*                                                            */
/*             1 to move the input focus, else leave it       */
/*             alone.                                         */
/*                                                            */
/* Assumes:    If not moving the input focus, the             */
/*             browser_data pointer may be NULL.              */
/**************************************************************/

_kernel_oserror * form_end_edit(browser_data * b, int keepchanges, int movefocus)
{
  _kernel_oserror * e = NULL;

  /* Proceed if something is being edited */

  if (
       (
         !b              ||
         b == fe_browser
       )
       && fe_browser
       && fe_token
     )
  {
    int u;

    /* u is set if scroll positions were non-zero for the field */

    u = fe_xscroll || fe_yscroll;

    fe_xscroll = fe_yscroll = fe_index = 0;

    /* Redraw the field if it was scrolled somewhere */

    if (u)
    {
      e = browser_update_token(fe_browser, fe_token, 1, 0);
      if (e) return e;
    }

    /* Discard the currently editing form details, so nothing */
    /* is being edited anymore.                               */

    fe_browser = NULL;
    fe_token   = NULL;

    /* Possibly move the focus back to a general position */

    if (movefocus) e = browser_give_general_focus(b);
  }

  /* Close any open menus and return */

  form_abandon_menu();

  return e;
}

/**************************************************************/
/* form_create_menu()                                         */
/*                                                            */
/* Builds and opens a menu for a SELECT field.                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             field.                                         */
/**************************************************************/

static _kernel_oserror * form_create_menu(browser_data * restrict b, const HStream * restrict tp)
{
  form_field              * fp;
  char                    * p, * o;
  const int               * pi;
  int                       w, i, n, size;
  WimpGetPointerInfoBlock   m;
  wimp_menuhdr            * mhp;
  wimp_menuitem           * mip;

  /* If there's an existing menu open and it isn't the one */
  /* we want to create, ensure it is closed first.         */

  if (b != fe_mbrowser || tp != fe_mtoken) form_abandon_menu();

  /* Find the form field record */

  fp = form_find_record(b, tp, 0);

  /* If the token doesn't represent a SELECT field, exit */

  if (!fp || fp->header.type != form_select) return NULL;

  /* Otherwise, point p to the value of the given token, */
  /* and thus get the number of items in 'n'.            */

  size = sizeof(wimp_menuhdr);
  pi   = HtmlSELECToptions(tp);
  n    = pi[0];

  /* Can't create a field if there are no items! */

  if (n < 1)
  {
    bbc_vdu(7);
    return NULL;
  }

  /* Limit check the number of items */

  if (n > Limits_SelectItems) n = Limits_SelectItems;

  /* Skip 'p' to the first item's selected/deselected char */

  p = (char *)&pi[2];

  /* Keep a running count of the width used so far in 'w'      */
  /* (for earlier OS versions which need this to be specified) */

  w = 8; /* Sensible starting width */

  /* Loop round the items, working out the data size they */
  /* will occupy in the menu.                             */

  for (i = 0; i < n; i++)
  {
    /* Skip past the selected/deselected char */

    p++;

    /* String length of the menu text, plus trailing space */
    /* (the "Stop Wimp thinking it's a keyboard shortcut"  */
    /* hack), plus terminator, plus the menu item          */
    /* structure itself.                                   */

    size += strlen(p) + 1 + 1 + sizeof(wimp_menuitem);

    /* If this item is wider than the highest recorded so */
    /* far, set 'w' to the width.                         */

    if (strlen(p) > w) w = strlen(p);

    /* Skip past the menu item text */

    p += strlen(p) + 1;

    /* Skip past the menu item name */

    p += strlen(p) + 1;
  }

  /* If fe_menu is already allocated, then the same menu has */
  /* already been opened - so don't need to change the block */
  /* size. Otherwise, try to claim memory for the menu.      */

  if (!fe_menu) fe_menu = malloc(size + 4);
  if (!fe_menu) return make_no_cont_memory_error(3);

  /* Zero the contents */

  memset(fe_menu, 0, size + 4);

  /* Set mhp to point to the menu header, and mip */
  /* to point to the first menu item.             */

  mhp = (wimp_menuhdr  *) fe_menu;
  mip = (wimp_menuitem *) (((int) mhp) + sizeof(wimp_menuhdr));

  /* Use the item name for a menu title */

  strncpy(mhp->title, HtmlSELECTname(tp), 12);

  /* If the title is now a NULL string or is a full */
  /* 12 chars long excluding terminator, replace it */
  /* with a standard title from the Messages file.  */

  if (!mhp->title[0] || mhp->title[11]) strcpy(mhp->title, lookup_token("selTITL:Select",0,0));

  /* Fill in the other header details */

  mhp->tit_fcol  = 7;
  mhp->tit_bcol  = 2;
  mhp->work_fcol = 7;
  mhp->work_bcol = 0;
  mhp->height    = 44;
  mhp->gap       = 0;

  /* Read the system font width and spacing for old Wimp versions */

  {
    int cwidth, cspacing;
    int vars[3] = {
                    BBC_GCharSizeX,
                    BBC_GCharSpaceX,
                    -1
                  };

    if (!bbc_vduvars(vars, vars))
    {
      cwidth   = vars[0];
      cspacing = vars[1];

      mhp->width = (w * cspacing + cwidth) * wimpt_dx(); /* I.e. ((w + 1) - 1) * cspacing + ... */
    }
    else
    {
      mhp->width = (w + 1) * 16;
    }
  }

  /* Point to the first item's selected/deselected char */

  p = (char *)(HtmlSELECToptions(tp) + 2);

  /* Point past the nth menu item structure (note the pointer */
  /* arithmetic...) - i.e. the limit of the menu item         */
  /* structures. This space is used for indirected item text. */

  o = (char *) (mip + n);

  /* Loop through all menu items */

  for (i = 0; i < n; i++)
  {
    /* Set the flags for the last menu item and give a */
    /* tick if the item is selected.                   */

    mip->flags = ((i == n - 1) ? wimp_MLAST : 0) |
                 ((fp->value.select.selection[i] == FORM_SELCHAR) ? wimp_MTICK : 0);

    /* There is no submenu */

    mip->submenu   = (wimp_menuptr) -1;

    /* Set the entry's icon flags */

    mip->iconflags = wimp_ITEXT              | /* A plain text item    */
                     wimp_IFILLED            | /* Background is filled */
                     wimp_INDIRECT           | /* Item is indirected   */
                     (wimp_BSELNOTIFY << 12) | /* 'Select' button type */
                     (7<<24);                  /* FG colour 7 (black)  */

    /* Buffer for the indirected text */

    mip->data.indirecttext.buffer      = o;

    /* No validation string */

    mip->data.indirecttext.validstring = NULL;
    mip->data.indirecttext.bufflen     = 0;

    /* Skip past the selected/deselected char */

    p++;

    /* Copy the item text into the buffer, with */
    /* trailing space                           */

    strcpy(o, p);
    strcat(o, " ");

    /* Skip past the menu item text */

    p += strlen(p) + 1;

    /* Skip past the menu item name */

    p += strlen(p) + 1;

    /* Increment the pointer to the indirected text buffer */
    /* past the menu item text just written in             */

    o += strlen(o) + 1;

// Hmph. Nice idea, but trouble is if you then select
// an item in the menu below a separator it'll be the
// wrong one - item 3 in the menu is item 4 in the list
// of menu options if there's a separator at item 2
// of that list, say.
//
// Get round to sorting this out eventually though as
// a load of hyphens in an anti-aliased proportional font
// do *not* look good as a separator!
//
//    /* If not on the last item, look ahead to see if a separator is present */
//
//    if (i != n - 1)
//    {
//      char * check = p;
//
//      check++;
//
//      /* If the string starts with a separator, assume it is meant to be */
//      /* an item separator... Add the flag to the current item to put a  */
//      /* real separator under it, skip p past this entry, and increment  */
//      /* the item counter to skip the separator entry. If the current    */
//      /* entry has now become the last one, set the 'last' flag.         */
//
//      if (!strncmp(check, Forms_Menu_Separator, Forms_Menu_Separator_Len))
//      {
//        p++;
//        p += strlen(p) + 1;
//        p += strlen(p) + 1;
//
//        mip->flags |= wimp_MSEPARATE;
//
//        i++;
//        if (i == n - 1) mip->flags |= wimp_MLAST;
//      }
//    }

    /* Advance to the next item (note pointer arithmetic) */

    mip++;
  }

  /* Find the position of the pointer, and record that a */
  /* menu from a form is opened (or about to be!) in the */
  /* menusrc global.                                     */

  wimp_get_pointer_info(&m);
  menusrc = Menu_Form;

  /* Work out where to open the menu */

  {
    int                       depth, line, chunk;
    int                       width, height;
    int                       x, y, orx, ory, x_add;
    BBox                      box;
    fm_face                   fh;
    token_path              * path = NULL;
    const reformat_cell     * cell;
    WimpGetWindowStateBlock   s;
    _kernel_oserror         * e;

    /* Find the line the token is in */

    depth = tokenutils_line_range(b, tp, &line, &chunk, NULL, NULL, &path);

    /* Find out the x and y offset of the cell the */
    /* token lies in.                              */

    tokenutils_token_offset(b, path, &orx, &ory);

    /* If there are valid entries in the token_path structure, */
    /* need to find out what line list to use.                 */

    cell = tokenutils_find_cell(b->cell, depth, path);

    if (path) free (path);

    if (!cell) cell = b->cell, orx = 0, ory = 0;

    /* Find the field's x and y offsets */

    x = orx + redraw_chunk_x(b, cell, chunk, line);
    y = ory + cell->ldata[line].y;

    convert_to_os(cell->cdata[chunk].w, &x_add);
    x += x_add;

    /* Get the window state to convert x and y to screen coords */

    s.window_handle = b->window_handle;
    e = wimp_get_window_state(&s);
    if (e) return e;

    x = coords_x_toscreen(x, (WimpRedrawWindowBlock *) &s);
    y = coords_y_toscreen(y, (WimpRedrawWindowBlock *) &s);

    /* Find out the size of the menu icon */

    utils_read_sprite_size("fgright", &width, &height);

    /* Find out the height of the display region */

    fh = fm_find_token_font(b, tp, 0);
    fm_font_box(fh, &box);

    /* Adjust y appropriately */

    y += cell->ldata[line].b + (box.ymin + height + box.ymax) / 2;

    return wimp_create_menu(fe_menu, x - 4, y);
  }
}

/**************************************************************/
/* form_start_select_edit()                                   */
/*                                                            */
/* Sets up a form SELECT field as the currently editing item  */
/* within that field, creating and opening the associated     */
/* menu.                                                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             SELECT field.                                  */
/**************************************************************/

static _kernel_oserror * form_start_select_edit(browser_data * b, HStream * token)
{
  _kernel_oserror * e = form_create_menu(b, token);

  if (e) return e;

  fe_mbrowser = b;
  fe_mtoken   = token;

  return NULL;
}

/**************************************************************/
/* form_autoscroll()                                          */
/*                                                            */
/* Scrolls a given browser window to ensure that the item the */
/* caret is in is fully visible.                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form.                                      */
/**************************************************************/

static _kernel_oserror * form_autoscroll(browser_data * b)
{
  WimpGetCaretPositionBlock c;

  wimp_get_caret_position(&c);

  /* Only proceed if the caret is inside the window, and visible */

  if (c.window_handle == b->window_handle && c.xoffset >= 0 && c.height > 0)
  {
    WimpGetWindowStateBlock   state;
    _kernel_oserror         * e;
    BBox                      box;
    int                       sc;
    int                       width, height, margin;
    int                       htop, hbot;

    state.window_handle = b->window_handle;
    e = wimp_get_window_state(&state);
    if (e) return e;

    /* Convert the visible area to window coordinates */

    box = state.visible_area;

    coords_box_toworkarea(&box, (WimpRedrawWindowBlock *) &state);

    /* Correct for the toolbars */

    if (!controls.swap_bars)
    {
      htop = toolbars_button_height(b) + toolbars_url_height(b);
      hbot = toolbars_status_height(b);
    }
    else
    {
      htop = toolbars_status_height(b);
      hbot = toolbars_button_height(b) + toolbars_url_height(b);
    }

    if (htop) htop += wimpt_dy();
    if (hbot) hbot += wimpt_dy();

    box.ymax -= htop;
    box.ymin += hbot;

    /* Find the visible area size */

    width  = box.xmax - box.xmin;
    height = box.ymax - box.ymin;

    /* Flag that scrolling isn't needed to start with */

    sc = 0;

    /* Vertical issues first */

    margin = FORM_AUTOSCROLL_MARGIN;
    if (height - c.height < margin * 2) margin = height / 4;

    /* The caret is scrolled off the top of the window */

    if (c.yoffset > box.ymax - c.height - margin)
    {
      state.yscroll += (c.yoffset - box.ymax + c.height + margin);
      sc = 1;
    }

    /* The caret is scrolled off the left of the window */

    if (c.yoffset < box.ymin + margin)
    {
      state.yscroll += (c.yoffset - box.ymin - margin);
      sc = 1;
    }

    /* Now the horizontal */

    margin = FORM_AUTOSCROLL_MARGIN;
    if (width < margin * 2) margin = width / 4;

    /* The caret is scrolled off the right of the window */

    if (c.xoffset > box.xmax - margin)
    {
      state.xscroll += (c.xoffset - box.xmax + margin);
      sc = 1;
    }

    /* The caret is scrolled off the left of the window */

    if (c.xoffset < box.xmin + margin)
    {
      state.xscroll += (c.xoffset - box.xmin - margin);
      sc = 1;
    }

    /* If the scroll position changed in the above code, reflect that new position */

    if (sc) wimp_open_window((WimpOpenWindowBlock *) &state);
  }

  return NULL;
}

/**************************************************************/
/* form_start_textarea_edit()                                 */
/*                                                            */
/* Starts an edit in a given text area (either a text area    */
/* object or a single line writable) placing the caret in a   */
/* specified position.                                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to a token representing the item to    */
/*             edit;                                          */
/*                                                            */
/*             Position mode for the caret: 0 = near mouse, 1 */
/*             = start of area for text area, end of line for */
/*             writable, 2 = end of line.                     */
/**************************************************************/

static _kernel_oserror * form_start_textarea_edit(browser_data * b, HStream * tp, int mode)
{
  BBox                      box;
  int                       lh, lb, fh, x, y;
  WimpGetPointerInfoBlock   m;
  WimpGetWindowStateBlock   state;
  _kernel_oserror         * e;

  if (fe_browser != b || fe_token != tp)
  {
    /* Cancel any existing edits and set library variables */
    /* to indicate the token and nature of token that is   */
    /* now being edited.                                   */

    e = form_end_edit(b, 1, 0);
    if (e) return e;

    fe_single   = tp->tagno != TAG_TEXTAREA;
    fe_password = tp->tagno == TAG_INPUT && HtmlINPUTtype(tp) == inputtype_PASSWORD;
    fe_browser  = b;
    fe_token    = tp;
  }

  switch (mode)
  {
    case 0: /* Place caret near the mouse pointer */
    {
      form_input_box(b, fe_token, &box, &lh, &lb, &fh);

      /* The above call accounts for the border with of the */
      /* item; strip that away.                             */

      box.xmin += 8;
      box.ymin += 8;
      box.xmax -= 8;
      box.ymax -= 8;

      /* Work out the where the pointer is in window coordinates */

      e = wimp_get_pointer_info(&m);
      if (e) return e;

      state.window_handle = b->window_handle;
      e = wimp_get_window_state(&state);
      if (e) return e;

      x = coords_x_toworkarea(m.x, (WimpRedrawWindowBlock *) &state);
      y = coords_y_toworkarea(m.y, (WimpRedrawWindowBlock *) &state);

      /* Get x as an OS unit offset from the left hand edge of the */
      /* forms item, and y as a line number.                       */

      x -= box.xmin;
      x += fe_xscroll;
      y  = fe_yscroll + (box.ymax - y) / lh;

      form_textarea_find_caret(form_get_field_text(b, fe_token), fh, &fe_index, x, y);
    }
    break;

    case 1: /* Place caret at start of line for text area, or end of line for single line writable */
    {
      if (fe_single) fe_index = strlen(form_get_field_text(b, fe_token));
      else           fe_index = 0;

      break;
    }

    case 2: fe_index = strlen(form_get_field_text(b, fe_token)); /* Place caret at end of line */
    break;

    default: fe_index = 0; /* Fallback position - caret at start of line */
    break;
  }

  form_give_focus(b);
  form_autoscroll(b);

  return NULL;
}

/**************************************************************/
/* form_check_scroll_field()                                  */
/*                                                            */
/* For a given text area or single line writable ensure that  */
/* the caret is shown at a given x and y position, when the   */
/* line height is lh, scrolling the field contents if         */
/* necessary.                                                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the text field;                                */
/*                                                            */
/*             Pointer to a BBox holding the window coord     */
/*             bounding box of the text field, *excluding*    */
/*             any borders;                                   */
/*                                                            */
/*             X offset into field, in OS units, for the      */
/*             caret;                                         */
/*                                                            */
/*             Number of lines below the first one for the    */
/*             caret.                                         */
/*                                                            */
/*             The line height in OS units.                   */
/**************************************************************/

static void form_check_scroll_field(browser_data * b, BBox * box, int x, int y, int lh)
{
  int dx, dy, t;

  dx = dy = 0;
  t  = box->xmax - box->xmin; /* Field's width in OS units */

  /* If the desired position is less than the current positon, scroll left */

  if (x - fe_xscroll < 0) dx = x - fe_xscroll;

  /* If the desired position is greater than the current position plus */
  /* the field width, scroll right                                     */

  if (x - fe_xscroll > t) dx = x - t - fe_xscroll;

  t = (box->ymax - box->ymin + 16) / lh; /* Field's height in lines; + 16 puts the borders back for this calculation */

  if (!fe_single) /* Only multi-line text areas can scroll vertically */
  {
    /* If the desired line is less than the current one, scroll down */

    if (y - fe_yscroll < 0) dy = y - fe_yscroll;

    /* If the desired line is greater than the current position plus the */
    /* height of the field (in lines), scroll up.                        */

    if (y - fe_yscroll >= t) dy = (y - t + 1) - fe_yscroll;
  }

  /* If dx or dy are non-zero, need to scroll */

  if (dx || dy)
  {
    BBox                      obox;
    WimpGetCaretPositionBlock c;

    /* Round the absolute value of x scroll up to a multiple of 4 */

    if (dx < 0)
    {
      if ((-dx) & 3) dx -= (4 - ((-dx) & 3));
    }
    else if (dx & 3) dx += 4 - (dx & 3);

    /* Find the caret */

    wimp_get_caret_position(&c);

    /* If the caret is not in a specific icon and is in the specified */
    /* browser window, hide it whilst things are scrolled to avoid    */
    /* redraw problems.                                               */

    if (
         c.icon_handle < 0                   &&
         c.window_handle == b->window_handle
       )
       wimp_set_caret_position(b->window_handle, -1, 0, 0, -1, -1);

    /* Increment the internal scroll positions */

    fe_xscroll += dx;
    fe_yscroll += dy;

    obox = *box;

    /* Work out the region to copy for the scroll, and block copy it */

    if (dx < 0) obox.xmax += dx;
    else        obox.xmin += dx;

    if (dy < 0) obox.ymin -= dy * lh;
    else        obox.ymax -= dy * lh;

    wimp_block_copy(b->window_handle,

                    obox.xmin,
                    obox.ymin,
                    obox.xmax,
                    obox.ymax,

                    obox.xmin - dx,
                    obox.ymin + dy * lh);

    /* Update any required regions for horizontal scrolling */

    if (dx)
    {
      WimpRedrawWindowBlock r;

      r.window_handle = b->window_handle;
      r.visible_area  = *box;

      if (dx < 0)
      {
        r.visible_area.xmax = r.visible_area.xmin - dx;
        if (r.visible_area.xmax > box->xmax) r.visible_area.xmax = box->xmax;
      }
      else
      {
        r.visible_area.xmin = r.visible_area.xmax - dx;
        if (r.visible_area.xmin < box->xmin) r.visible_area.xmin = box->xmin;
      }

      browser_update(b, &r, 1, 0);
    }

    /* Update any required regions for vertical scrolling */

    if (dy)
    {
      WimpRedrawWindowBlock r;

      r.window_handle = b->window_handle;
      r.visible_area  = *box;

      if (dy < 0)
      {
        r.visible_area.ymin = r.visible_area.ymax + dy * lh;
        if (r.visible_area.ymin < box->ymin) r.visible_area.ymin = box->ymin;
      }
      else
      {
        r.visible_area.ymax = r.visible_area.ymin + dy * lh;
        if (r.visible_area.ymax > box->ymax) r.visible_area.ymax = box->ymax;
      }

      browser_update(b, &r, 1, 0);
    }

    /* If the caret, when checked earlier, was not in a specific icon and */
    /* was in the specified browser window, put the caret back.           */

    if (
         c.icon_handle < 0                   &&
         c.window_handle == b->window_handle
       )
    {
      wimp_set_caret_position(c.window_handle,
                              c.icon_handle,
                              c.xoffset,
                              c.yoffset,
                              c.height,
                              c.index);
    }
  }
}

/**************************************************************/
/* form_give_focus()                                          */
/*                                                            */
/* If the library is editing some forms field, and this can   */
/* take an input focus, give the focus to the field and       */
/* return a success flag. (Editing is started with            */
/* form_click_field, for example, and ended with              */
/* form_end_edit).                                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the forms item that is to be given the caret.  */
/*                                                            */
/* Returns:    1 if the caret is placed in the item, else 0.  */
/**************************************************************/

int form_give_focus(browser_data * b)
{
  BBox box;
  int  lh, lb, fh, ox, oy;

  /* If not editing, no need to do anything */

  if (!b || b != fe_browser || !fe_token) return 0;

  /* Try to get the bounding box of the item */

  if (
       !form_input_box(b,
                       fe_token,
                       &box,
                       &lh,
                       &lb,
                       &fh)
     )
     return 0;

  /* The above call accounts for the item's border; */
  /* strip this away.                               */

  box.xmin += 8;
  box.ymin += 8;
  box.xmax -= 8;
  box.ymax -= 8;

  /* Get the x offset in OS units and y offset in lines */
  /* that the caret should be placed at.                */

  form_textarea_caretpos(form_get_field_text(b, fe_token),
                         fh,
                         fe_index,
                         &ox,
                         &oy);

  /* Ensure a multiple line item (i.e. text area) is */
  /* scrolled to show the line the caret will be     */
  /* moved to.                                       */

  form_check_scroll_field(b,
                          &box,
                          ox,
                          oy,
                          lh);

  /* Position the caret */

  if (
       wimp_set_caret_position(fe_browser->window_handle,
                               -1,
                               box.xmin + ox - fe_xscroll,
                               box.ymax - lh * (oy - fe_yscroll + 1) + 4,
                               lh - 2,
                               0)
     )
     return 0;

  return 1;
}

/**************************************************************/
/* form_extend_flex()                                         */
/*                                                            */
/* Extends a given flex block by a given amount, returning    */
/* the offset into the block of the new data or -1 to show    */
/* failure.                                                   */
/*                                                            */
/* Parameters: flex_ptr for the flex block; Amount to extend  */
/*             by.                                            */
/*                                                            */
/* Returns:    Offset into the block of the new data, or -1   */
/*             if the claim failed.                           */
/**************************************************************/

static int form_extend_flex(void ** data, int size)
{
  int o;

  /* If the block already exists, extend it; else, */
  /* create it.                                    */

  if (*data)
  {
    o = flex_size(data);
    if (!flex_extend(data, o + size)) return -1;
  }
  else
  {
    o = 0;
    if (!flex_alloc(data, size)) return -1;
  }

  #ifdef TRACE
    flexcount += size;
    dprintf(("CFle", "**   flexcount: %d\n",flexcount));
  #endif

  return o;
}

/**************************************************************/
/* form_encode_flex_data()                                    */
/*                                                            */
/* Encodes the given flex data ready for a form submission.   */
/*                                                            */
/* Spaces, ENCODE_DATASEP, ENCODE_FIELDSEP and                */
/* ENCODE_VALUESEP characters are replaced by special         */
/* alternatives ('+', '?', '&' and '=' respectively), whilst  */
/* all other non- alphanumeric characters are escaped ('%'    */
/* followed by the ASCII code in hex).                        */
/*                                                            */
/* Parameters: Pointer to the flex anchor pointing to the     */
/*             data;                                          */
/*                                                            */
/*             Encoding type [not implemented];               */
/*                                                            */
/*             Offset in block to start encoding at.          */
/*                                                            */
/* Returns:    1 if successful, 0 if failed (for example, ran */
/*             out of memory when extending flex block to     */
/*             hold escaped character sequences).             */
/**************************************************************/

static int form_encode_flex_data(void ** data, const char * enctype, int start_at)
{
  int    i, o;
  char * p;

  enctype = enctype; /* [Not implemented] Avoid compiler warning for now */

  o       = start_at;

  /* First, escape sequences */

  while (*(((char *) *data) + o))
  {
    p = ((char *) *data) + o;

    /* If not an alphanumeric character and not one of the */
    /* 'special' characters, escape it                     */

    if (
         !isalnum((int) *p)

         /* (As not escaped by e.g. Netscape Navigator (TM) */

         && *p != '_'
         && *p != '@@'
         && *p != '.'
         && *p != '-'
         && *p != '*'

         /* Specials - see code below */

         && *p != ' '
         && *p != ENCODE_DATASEP
         && *p != ENCODE_FIELDSEP
         && *p != ENCODE_VALUESEP
       )
    {
      char code[10];

      if (*p == '\n') strcpy (code, "%0A"); /* Was %0D%0A but this caused problems with e.g. Bugzilla under Unix; hopefully, having just %0A won't cause problems with Windows! */
      else            sprintf(code, "%%%02X", *p);

      if (!form_extend_flex(data, strlen(code) - 1)) return 0;

      memmove(((char *) *data) + o + strlen(code),
              ((char *) *data) + o + 1,
              flex_size(data) - o - strlen(code));

      strncpy(((char *) *data) + o,
              code,
              strlen(code));

      o += strlen(code) - 1;
    }
    o++;
  }

  /* Now do simple encodings */

  p = (char *) *data;
  o = flex_size(data);

  for (i = 0; i < o; i++, p++)
  {
    switch (*p)
    {
      case ' ':              *p = '+'; break;
      case ENCODE_DATASEP:   *p = '?'; break;
      case ENCODE_FIELDSEP:  *p = '&'; break;
      case ENCODE_VALUESEP:  *p = '='; break;
    }
  }

  return 1;
}

/**************************************************************/
/* form_field_data_size()                                     */
/*                                                            */
/* For a given field in a given browser, returns the total    */
/* size requirement including name and value, ready for       */
/* encoding a reply to the server (so this will consider what */
/* particular value sizes to count if something is selected   */
/* or unselected, etc.).                                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the field;                                     */
/*                                                            */
/*             Pointer to the form_field struct for the item; */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             item.                                          */
/*                                                            */
/* Returns:    Total required memory size needed to hold the  */
/*             item.                                          */
/**************************************************************/

static int form_field_data_size(browser_data * b, form_field * fp, HStream * tp, unsigned int x, unsigned int y)
{
  int size;

  size = 0;

  if (HtmlELEMENTname(tp))
  {
    size = strlen(HtmlELEMENTname(tp)) + 1; /* add one for the ' = ' sign */

    switch(fp->header.type)
    {
      case form_textarea: /* form_textarea same as form_password: no break */
      case form_text:     /* form_text same as form_password: no break */
      case form_password:
      {
        /* Size of the text string in the item */

        size += strlen(fp->value.text);
      }
      break;

      case form_checkbox: /* form_checkbox same as form_radio: no break */
      case form_radio:
      {
        /* If checked, return the size of the value string, if there */
        /* is one, or 0 if not checked.                              */

        if (fp->value.checked)
        {
          if (HtmlINPUTvalue(tp)) size += strlen(HtmlINPUTvalue(tp));
          else                    size += 2;
        }
        else size = 0;
      }
      break;

      case form_select:
      {
        int    i, n, s;
        char * p;
        char * q;

        /* For select fields, return the menu item name if one is */
        /* specified (*q is non-zero) or the menu item text if no */
        /* name is present (use p).                               */

        s = 0;
        n = HtmlSELECToptions(tp)[0];
        p = (char *)(HtmlSELECToptions(tp) + 2);

        for (i = 0; i < n; i++)
        {
          p++;

          q = p + strlen(p) + 1;

          if (
               fp->value.select.selection[i] == FORM_SELCHAR
             )
             s += size + strlen(q) + 1; /* Plus one for & separator */

          p = q + strlen(q) + 1 ;
        }

        if (s) s--; /* One of the & separators need not be included */

        size = s;
      }
      break;

      /* Image buttons send "name.x=123&name.y=123" */

      case form_image:
      {
        int  len;

        /* We've already added up length of "name=", this gives us */
        /* length of "name.x=&name.y="                             */

        size = (size + 2) * 2 + 1;

        /* Add in length of the two coordinates (note this is a */
        /* very slow function call)                             */

        len = utils_len_printf("%u%u", x, y);

        if (len >= 0) size += len;
        else          size += 64;  /* If len is < 0 there was an error, so play it safe */

        break;
      }

      /* The size of the submit button's text */

      case form_button:
      case form_submit:
      {
        size += strlen(form_button_text(tp));
      }
      break;

      /* The size of the item's value string */

      case form_hidden:
      {
        if (HtmlINPUTvalue(tp)) size += strlen(HtmlINPUTvalue(tp));
        else                    size  = 0;
      }
      break;
    }
  }

  return size;
}

/**************************************************************/
/* form_build_data()                                          */
/*                                                            */
/* Build the data structure for a form in the indicated flex  */
/* block. The token identifies the form and if it is a submit */
/* token it is included in the data structure; other submit   */
/* tokens are not. The flex block does not exist before       */
/* calling this routine. The form data are encoded according  */
/* to the specification.                                      */
/*                                                            */
/* If the form METHOD is GET, the URL is included as part of  */
/* this data.                                                 */
/*                                                            */
/* x and y are coords for forms submitted by INPUT TYPE =     */
/* IMAGE.                                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             form;                                          */
/*                                                            */
/*             X coord for INPUT TYPE = IMAGE submissions;    */
/*                                                            */
/*             Y coord for INPUT TYPE = IMAGE submissions;    */
/*                                                            */
/*             Pointer to the flex anchor for the flex block  */
/*             in which the data will be built.               */
/**************************************************************/

static _kernel_oserror * form_build_data(browser_data * b, HStream * token, int x, int y, char ** data)
{
  int           i, o, ho, fields, additions_start = 0;
  form_header * hp;
  form_field  * fp;
  HStream     * tp;
  int           first;

  #ifdef TRACE

    if (*data)
    {
      erb.errnum = Utils_Error_Custom_Normal;

      strcpy(erb.errmess,
             "Flex anchor is not NULL in form_build_data - flex error could have resulted had execution proceeded...");

      /* (Some routines may not echo this, and whilst we risk  */
      /* getting the error twice, returning an error is useful */
      /* as hopefully the errant caller will exit early rather */
      /* than dig itself in any deeper).                       */

      show_error_ret(&erb);

      return &erb;
    }

  #endif

  /* Claim 1 byte in the block for a terminator - should there */
  /* be no fields to add, the block will still hold valid data */

  if (form_extend_flex((void **) data, 1) < 0)
  {
    return make_no_cont_memory_error(4);
  }

  **data = 0;

  /* Find the field header and work out its offset in the data block */

  hp = form_find_record(b, token, 1);
  if (!hp) return NULL;

  ho = ((int) hp) - (int) b->fdata;

  tp = hp->token;

  if (HtmlFORMmethod(tp) == formmethod_GET && HtmlFORMaction(tp))
  {
    /* A GET form - put the URL in */

    int          i;
    int          len;
    const char * submit_url = HtmlFORMaction(tp);
    const char * query;

    /* Is there a query string already in the URL? */

    query = strchr(submit_url, '?');

    if (query) len = query - submit_url;
    else       len = strlen(submit_url);

    /* Only '+1' as whilst we need a field separator and a terminator */
    /* on top, we've already allocated 1 byte above.                  */

    i = form_extend_flex((void **) data, len + 1);
    if (i < 0) return make_no_cont_memory_error(5);

    if (query)
    {
      strncpy(*data, submit_url, len);
      (*data)[len] = '\0';
    }
    else
    {
      strcpy(*data, submit_url);
    }

    /* Set up the other data */

    additions_start      = len + 1;

    *((*data) + len)     = ENCODE_DATASEP;
    *((*data) + len + 1) = 0;
  }

  /* Get the number of fields, flag that this is the first time */
  /* around in 'first', and set the offset into the block of    */
  /* the first item after the header in 'o'.                    */

  fields = hp->fields;
  first  = 1;
  o      = sizeof(form_header);

  /* Loop through all fields */

  for (i = 0; i < fields; i++)
  {
    fp = (form_field *) (((int) b->fdata) + ho + o);
    tp = fp->header.token;

    /* Only proceed with encoding the contents if the item is named, */
    /* isn't a reset button, a submit button, or an image submit     */
    /* button. The exception for the latter two is if the token      */
    /* given to the function is that representing the button, in     */
    /* which case the item will be included in the encoded data.     */

    if (
         HtmlELEMENTname(tp)                                           &&
         fp->header.type != form_reset                                 &&
         (fp->header.type != form_submit || fp->header.token == token) &&
         (fp->header.type != form_image  || fp->header.token == token)
       )
    {
      int size;

      /* Find out how much space the encoded item will need */

      size = form_field_data_size(b, fp, tp, x, y);

      if (size)
      {
        int  offset;
        char *p;

        /* Try to claim enough memory to hold the item. If this is the first  */
        /* time round the loop add nothing, else add 1 for a field separator. */

        offset = form_extend_flex((void **) data, size + (first ? 0 : 1));

        if (offset < 0) return make_no_cont_memory_error(6);

        /* May have moved, so recalculate... */

        fp = (form_field  *) (((int) b->fdata) + ho + o);
        hp = (form_header *) (((int) b->fdata) + ho);
        tp = fp->header.token;

        p  = (*data) + offset - 1;

        /* If not the first time round, add in a field separator */

        if (!first) *p++ = ENCODE_FIELDSEP;

        /* Copy the item name to the block */

        *p = 0;

        strcpy(p, HtmlELEMENTname(tp));

        /* Put in a name/value separator */

         p   = strchr(p, 0);
        *p++ = ENCODE_VALUESEP;
        *p   = 0;

        switch(fp->header.type)
        {
          case form_textarea: /* form_textarea same as form_password: no break */
          case form_text:     /* form_text same as form_password: no break */
          case form_password:
          {
            /* Simple text string for these items */

            strcpy(p, fp->value.text);
          }
          break;

          case form_checkbox: /* form_checkbox same as form_radio: no break */
          case form_radio:
          {
            /* If the item has a value, use this. Otherwise use the default */
            /* string of 'on'.                                              */

            if (HtmlINPUTvalue(tp)) strcpy(p, HtmlINPUTvalue(tp));
            else                    strcpy(p, "on");
          }
          break;

          case form_select:
          {
            int    i, n, first;
            char * f;
            char * q;

            first = 1;
            n     = HtmlSELECToptions(tp)[0];
            f     = (char *)(HtmlSELECToptions(tp) + 2);

            for (i = 0; i < n; i++)
            {
              f++;

              /* q points to the menu item name (if it has one) */

              q = f + strlen(f) + 1;

              if (fp->value.select.selection[i] == FORM_SELCHAR)
              {
                if (!first)
                {
                  *p++ = ENCODE_FIELDSEP;

                  strcpy(p, HtmlSELECTname(tp));

                   p   = strchr(p, 0);
                  *p++ = ENCODE_VALUESEP;
                  *p   = 0;
                }

                /* Use the menu item name if there is one, else the item text */

                strcpy(p, q);

                p = strchr(p, 0);

                first = 0;
              }

              /* Move to the next item */

              f = q + strlen(q) + 1;
            }
          }
          break;

          case form_image:
          {
            /* Need to back up a bit */
            p += sprintf(p-1, ".x%c%u%c%s.y%c%u", ENCODE_VALUESEP, x, ENCODE_FIELDSEP, HtmlINPUTname(tp), ENCODE_VALUESEP, y) - 1;
          }
          break;

          case form_button:
          case form_submit:
          {
            /* Use the button text */

            strcpy(p, form_button_text(tp));
          }
          break;

          case form_hidden:
          {
            /* Use the item value */

            if (HtmlINPUTvalue(tp)) strcat(p, HtmlINPUTvalue(tp));
          }
          break;
        }

        first = 0;
      }
    }

    /* Skip to the next item */

    o += fp->header.size * 4;
  }

  /* Refind the header record and the token */
  /* representing it, to get the encoding   */
  /* type for the form.                     */

  hp = form_find_record(b, token, 1);
  tp = hp->token;

  /* Now encode the block according to the specified encoding type */

  if (!form_encode_flex_data((void **) data, HtmlFORMenctype(tp), additions_start))
  {
    return make_no_cont_memory_error(7);
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* form_submission_information()                              */
/*                                                            */
/* For a given token within a form, return the URL of         */
/* submission and a flag to say if the submission should be   */
/* done by POST.                                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to a token in the form;                */
/*                                                            */
/*             Pointer to an int, in which 1 is written if    */
/*             the submission method is POST, 0 is written if */
/*             it is GET, else the value is unchanged.        */
/*                                                            */
/* Returns:    Pointer to the URL to submit the form to, or   */
/*             NULL if unknown (also see the parameters       */
/*             list).                                         */
/*                                                            */
/* Assumes:    The int pointer may be NULL.                   */
/**************************************************************/

const char * form_submission_information(browser_data * b, HStream * token, int * post)
{
  HStream     * tp;
  form_header * hp;

  hp = form_find_record(b, token, 1);
  if (!hp) return NULL;

  tp = hp->token;
  if (!tp) return NULL;

  if (post)
  {
    if      (HtmlFORMmethod(tp) == formmethod_POST) *post = 1;
    else if (HtmlFORMmethod(tp) == formmethod_GET)  *post = 0;
  }

  return HtmlFORMaction(tp);
}

/**************************************************************/
/* form_could_load_text_at_pointer                            */
/*                                                            */
/* Can a text file be loaded into the forms element           */
/* represented by whatever HStream the pointer is over, if    */
/* this represents such an element? If so, try to do this.    */
/* Return 1 for success, 0 for failure.                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct for the       */
/*             browser window the pointer is over;            */
/*                                                            */
/*             Full pathname of the file.                     */
/*                                                            */
/* Returns:    1 if successful, else 0.                       */
/**************************************************************/

int form_could_load_text_at_pointer(browser_data * b, const char * pathname)
{
  WimpGetPointerInfoBlock p;

  if (!wimp_get_pointer_info(&p))
  {
    HStream * tptr = browser_get_pointer_token(b, &p, NULL, NULL);
    int       ctrl;

    /* Is Ctrl being pressed? We will overwrite the existing */
    /* value if so, otherwise append to it.                  */

    _swix(OS_Byte,
          _INR(0,1) | _OUT(1),

          121,
          129,

          &ctrl);

    if (
         tptr                                      &&
         ISBODY(tptr)                              &&
         (tptr->style & FORM)                      &&
         (
           tptr->tagno == TAG_TEXTAREA             ||
           (
             tptr->tagno == TAG_INPUT              &&
             HtmlINPUTtype(tptr) == inputtype_TEXT
           )
         )
       )
    {
      form_field * fp       = form_find_record(b, tptr, 0);
      FILE       * file     = fopen((char *) pathname, "rb");
      char       * filtered = NULL;
      char       * record   = NULL;
      int          len      = 0;
      int          end      = 0;
      int          max;
      int          c;

      if (tptr->tagno == TAG_TEXTAREA) max = 0;
      else
      {
        max = HtmlINPUTmaxlength(tptr);

        /* For single line writables, must make sure if appending */
        /* that we don't exceed the value specified in the MAXLEN */
        /* attribute of the defining INPUT element.               */

        if (
             !ctrl &&
             max   &&
             fp    &&
             (
               fp->header.type == form_textarea ||
               fp->header.type == form_text
             )
             && fp->value.text
           )
        {
          int elen = strlen(fp->value.text);

          /* If max ends up at 0, this will be misinterpreted as "unlimited" */
          /* so make sure we set '-1' in this case.                          */

          max -= elen;

          if (!max) max = -1;
        }
      }

      /* End any existing edit; we'll be moving the caret to the end of */
      /* this item in any case.                                         */

      if (fe_browser) form_end_edit(fe_browser, 1, 0);

      if (file)
      {
        /* Read the file into memory a byte at a time, screening */
        /* out control characters as required                    */

        while (!end)
        {
          c = fgetc(file);

          /* Allocate another byte of store */

          record   = filtered;
          filtered = memory_realloc((void *) filtered, len + 1);

          if (!filtered)
          {
            filtered = record;
            end      = 1;
          }

          if (!end)
          {
            int filterit = 1;

            /* Do we strip the character? */

            if (c == EOF || (max != 0 && len >= max))
            {
              end      = 1;
              c        = 0;
              filterit = 0;
            }
            else
            {
              if (tptr->tagno == TAG_TEXTAREA)
              {
                if (c == 13) c = 10;

                if ((c > 31 && c < 127) || c > 127 || c == 10) filterit = 0;
              }
              else
              {
                if ((c > 31 && c < 127) || c > 127) filterit = 0;
              }
            }

            /* If we should write it, do so */

            if (!filterit)
            {
              filtered[len] = (char) c;
              len ++;
            }
          }
          else
          {
            if (len) filtered[len - 1] = '\0';
          }
        }

        fclose(file);
        file = NULL;

        /* Do we have data? */

        if (filtered)
        {
          /* This is rather like form_put_field, but it allows appending */
          /* of data as well as replacement and doesn't try to compare   */
          /* the existing value at all.                                  */

          int changed = 0;

          if (
               fp &&
               (
                 fp->header.type == form_textarea ||
                 fp->header.type == form_text
               )
               && fp->value.text
             )
          {
            _kernel_oserror * e;

            if (!ctrl) e = form_set_field_space(b, tptr, strlen(fp->value.text) + len);
            else       e = form_set_field_space(b, tptr, len);

            if (!e)
            {
              /* Record may have moved... */

              fp = form_find_record(b, tptr, 0);

              /* Copy the string in */

              if (!ctrl) strcat(fp->value.text, filtered);
              else       strcpy(fp->value.text, filtered);

              changed = 1;
            }
          }

          /* Get rid of the stored data */

          memory_free(filtered);

          /* Redraw the item if changed */

          if (changed) browser_update_token(b, tptr, 0, 0);

          /* Move the caret to the end of the item, setting */
          /* it up as the currently editing element.        */

          form_start_textarea_edit(b, tptr, 2);
        }

        /* Whether or not we had data to replace, don't at this stage */
        /* allow any fetch to continue - flag success                 */

        return 1;
      }
    }
  }

  return 0;
}

/**************************************************************/
/* form_submit_form()                                         */
/*                                                            */
/* Submits the contents of a form to a URL specified by the   */
/* given token (usually, the token representing the Submit    */
/* button in the form).                                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to the token which had a front-end     */
/*             representation of itself activated to submit   */
/*             the form.                                      */
/**************************************************************/

static _kernel_oserror * form_submit_form(browser_data * b, HStream * token, int x, int y)
{
  char            * data = NULL;
  _kernel_oserror * e;
  form_header     * hp;
  HStream         * tp;
  int               adj;

  adj = controls.ignore_adjust ? 0 : adjust();

  /* Finish any current editing and find the header record for the form */

  e = form_finish_edit(b);
  if (e) return e;

  hp = form_find_record(b, token, 1);
  if (!hp) return NULL;

  tp = hp->token;

  /* For GET forms, we must have a URL to submit to in the 'anchor' field */

  if (HtmlFORMmethod(tp) == formmethod_GET && HtmlFORMaction(tp))
  {
    e = form_build_data(b, token, x, y, &data);

    if (!e)
    {
      /* Force a reload - return page is likely to be dynamically */
      /* generated and a great many sites these days return via.  */
      /* URLs which make it well-nigh impossible to know if you   */
      /* should cache objects or not.                             */

      b->reload_lock = 1;
      b->reloading   = 1;

      e = fetchpage_fetch_targetted(b,
                                    data,
                                    HtmlFORMtarget(tp),
                                    NULL,
                                    adj,
                                    0);
    }

    if (data)
    {
      #ifdef TRACE
        flexcount -= sizeof(&data);
        dprintf(("CFle", "**   flexcount: %d\n",flexcount));
      #endif

      flex_free((void **) &data);
    }
  }

  /* For POST types, must have a URL too, but use the 'post_data' block */
  /* of the browser_data structure so that fetcher routines know to     */
  /* encode the data in the header, rather than the URL                 */

  else if (HtmlFORMmethod(tp) == formmethod_POST && HtmlFORMaction(tp))
  {
    /* We may already have some data - should free it first if so! */

    if (b->post_data) flex_free(&b->post_data);

    /* Right, now construct the data block */

    e = form_build_data(b, token, x, y, (char **) &b->post_data);
    tp = hp->token;

    if (e)
    {
      if (b->post_data)
      {
        #ifdef TRACE
          flexcount -= sizeof(&b->post_data);
          dprintf(("CFle", "**   flexcount: %d\n",flexcount));
        #endif

        flex_free(&b->post_data);
      }
    }
    else
    {
      /* Force a reload (for more comments, see above) */

      b->reload_lock = 1;
      b->reloading   = 1;

      e = fetchpage_fetch_targetted(b,
                                    HtmlFORMaction(tp),
                                    HtmlFORMtarget(tp),
                                    NULL,
                                    adj,
                                    0);
    }
  }

  /* If the above fail, can't submit the form */

  else
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("CantSubmit:Can't find where to send the form to from this web page",
                          0,
                          0));

    e = &erb;
  }

  return e;
}

/**************************************************************/
/* form_click_field()                                         */
/*                                                            */
/* Processes a click on a form field.                         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form;                                      */
/*                                                            */
/*             Pointer to the token for the item that was     */
/*             clicked upon;                                  */
/*                                                            */
/*             Position mode for the caret: 0 = near mouse, 1 */
/*             = start of area for text area, end of line for */
/*             writable, 2 = end of line for writable, end of */
/*             all text for text area;                        */
/*                                                            */
/*             x-coordinate (if input image)                  */
/*                                                            */
/*             y-coordinate (if input image)                  */
/**************************************************************/

_kernel_oserror * form_click_field(browser_data * b, HStream * token, int mode, int x, int y)
{
  form_field      * fp;
  _kernel_oserror * e = NULL;

  /* If something is being edited that's not the given browser, end that edit */

  if (fe_browser && fe_browser != b)
  {
    e = form_end_edit(fe_browser, 1, 0);
    if (e) return e;
  }

  fp = form_find_record(b, token, 0);

  /* If it has a record in this module, edit it */

  if (fp)
  {
    switch (fp->header.type)
    {
      /* For text / password items, position the caret */

      case form_text:     /* same as form_password: no break */
      case form_textarea: /* same as form_password: no break */
      case form_password: e = form_start_textarea_edit(b, token, mode);
      break;

      /* For check (option) boxes and radios, toggle or values as appropriate */

      case form_checkbox: /* As for radios, so no 'break' */
      case form_radio:    e = form_put_field(b, token, (char *) !fp->value.checked, 1);
      break;

      /* For selection boxes (display fields with menus), open the menu */

      case form_select:   e = form_start_select_edit(b, token);
      break;

      /* For 'submit' buttons, slab the button in and out and submit the form */

      case form_image:
      case form_submit:
      {
        browser_flash_token(b, token);
        e = form_submit_form(b, token, x, y);
      }
      break;

      /* Don't submit BUTTON items */

      case form_button:
      {
        browser_flash_token(b, token);

        #ifdef JAVASCRIPT

          {
            const char * onclick = HtmlINPUTonclick(token);
            char       * data    = NULL;
            int          len1;
            int          len2;
            int          longest;

            if (onclick)
            {
              /* Construct a JavaScript URL with the onclick info */

              longest = len1 = sizeof(JavaScript_URL_Alternative1) - 1;
              len2           = sizeof(JavaScript_URL_Alternative2) - 1;

              if (len2 > len1) longest = len2;

              data = malloc(strlen(onclick) + longest + 1);

              if (!data) e = make_no_fetch_memory_error(20);
              else
              {
                strcpy(data, JavaScript_URL_Alternative1);
                strcat(data, onclick);

                e = fetchpage_fetch_targetted(b,
                                              data,
                                              HtmlFORMtarget(token),
                                              NULL,
                                              controls.ignore_adjust ? 0 : adjust(),
                                              0);

                free(data);
              }

              break;
            }
          }

        #endif

        /* Tell the user we can't do anything more with this... */

        erb.errnum = Utils_Error_Custom_Message;

        StrNCpy0(erb.errmess,
                 lookup_token("NoJavascript:Sorry, the browser does not support the JavaScript code required to make this button work.",
                              0,
                              0));

        show_error_ret(&erb);
      }
      break;

      /* For 'reset' buttons, slab the button in, reset the form and slab it out again */

      case form_reset:
      {
        browser_highlight_token(b, token);

        form_cancel_edit(b);
        e = form_reset_form(b, token);

        if (!e) browser_clear_highlight(b, 1);
      }
      break;
    }
  }

  return e;
}

/**************************************************************/
/* form_cancel_edit()                                         */
/*                                                            */
/* Terminates any editing in the specified browser, or all    */
/* browser forms, discarding any changes.                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form, or NULL to cancel any edits in any   */
/*             browsers.                                      */
/**************************************************************/

_kernel_oserror * form_cancel_edit(browser_data * b)
{
  return form_end_edit(b, 0, 1);
}

/**************************************************************/
/* form_finish_edit()                                         */
/*                                                            */
/* Terminates any editing in the specified browser, or all    */
/* browser forms, keeping any changes.                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the form, or NULL to cancel any edits in any   */
/*             browsers.                                      */
/**************************************************************/

_kernel_oserror * form_finish_edit(browser_data * b)
{
  return form_end_edit(b, 1, 1);
}

/**************************************************************/
/* form_button_text()                                         */
/*                                                            */
/* Returns a pointer to the text that should be placed in a   */
/* given button.                                              */
/*                                                            */
/* Parameters: Pointer to the token representing the button.  */
/*                                                            */
/* Returns:    Pointer to the text that should go in that     */
/*             button, according to whether it is a Submit,   */
/*             Reset, or unknown button type.                 */
/**************************************************************/

const char * form_button_text(HStream * tp)
{
  const char * p;

  p = HtmlINPUTvalue(tp);

       if (!p && HtmlINPUTtype(tp) == inputtype_SUBMIT) p = lookup_token("Submit:Submit",0,0);
  else if (!p && HtmlINPUTtype(tp) == inputtype_BUTTON) p = "";
  else if (!p && HtmlINPUTtype(tp) == inputtype_RESET)  p = lookup_token("Reset:Reset",  0,0);

  if (!p) p = lookup_token("Unknown:Action",0,0);

  return p;
}

/**************************************************************/
/* form_cursor_editable()                                     */
/*                                                            */
/* Returns 1 if the given field can be edited via. the        */
/* keyboard (i.e. it is a password field, a single line       */
/* writable, or a text area field).                           */
/*                                                            */
/* Parameters: The form_fieldtype of the field.               */
/*                                                            */
/* Returns:    1 if this can be edited via. the keyboard,     */
/*             else 0.                                        */
/**************************************************************/

static int form_cursor_editable(form_fieldtype type)
{
  return (type == form_password || type == form_text || type == form_textarea);
}

/**************************************************************/
/* form_token_cursor_editable()                               */
/*                                                            */
/* Finds out if a given token represents a cursor editable    */
/* forms element.                                             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the forms;                                     */
/*                                                            */
/*             Pointer to the token.                          */
/*                                                            */
/* Returns:    1 if the token represents a cursor editable    */
/*             forms element, else 0.                         */
/**************************************************************/

int form_token_cursor_editable(browser_data * b, HStream * token)
{
  form_header * hp;
  form_field  * fp;
  int           i = 0;

  /* Find the header item */

  hp = form_find_record(b, token, 1);

  if (!hp) return 0;

  /* Search for the field record */

  fp = (form_field *) (((int) hp) + sizeof(form_header));

  while (fp->header.token != token && i < hp->fields)
  {
    fp = (form_field *) (((int) fp) + fp->header.size * 4);
    i++;
  }

  /* Record not found */

  if (i == hp->fields) return 0;

  /* Record is found */

  return form_cursor_editable(fp->header.type);
}

/**************************************************************/
/* form_next_field()                                          */
/*                                                            */
/* Moves the editing position on to the next editable field   */
/* in the form. If there is no next field, optionally submit  */
/* the form.                                                  */
/*                                                            */
/* Parameters: 1 to automatically submit the form if there    */
/*             are no more editable fields, else 0;           */
/*                                                            */
/*             Pointer to an int, into which 0 may be written */
/*             if the keypress ends up in fact not being used */
/*             for some reason.                               */
/*                                                            */
/* Assumes:    The int pointer may be NULL.                   */
/**************************************************************/

static _kernel_oserror * form_next_field(int auto_submit, int * used)
{
  form_header * hp;
  form_field  * fp;
  int           i, found;
  HStream     * first;
  HStream     * next;

  found = 0;
  first = next = NULL;

  /* Find the details of the currently editing form */

  hp = form_find_record(fe_browser, fe_token, 1);
  fp = (form_field *) (((int) hp) + sizeof(form_header));

  /* Go through all the fields for the current form */

  for (i = 0; i < hp->fields; i++)
  {
    /* Can this field be edited from the keyboard? */

    if (form_cursor_editable(fp->header.type))
    {
      /* For the first editable field, set 'first' to point */
      /* to the token representing it. This may be used if  */
      /* there are no other editable fields to go to, but   */
      /* the auto submit flag is unset.                     */

      if (!first) first = fp->header.token;

      /* If 'next' is unset and the currently editing element */
      /* (represented by fe_token, see below) has been found, */
      /* then set 'next' to the current token - which must be */
      /* the first editable element available after fe_token. */

      if (!next && found) next = fp->header.token;
    }

    /* If this element is represented by the same token as   */
    /* the currently editing element, set 'found' to 1. Next */
    /* time around the loop, the code above may well then    */
    /* set 'next' to point to the next token that can be     */
    /* used for editing.                                     */

    if (fp->header.token == fe_token) found = 1;

    /* Move on to the next element. */

    fp = (form_field *) (((int) fp) + fp->header.size * 4);
  }

  /* If 'next' is NULL, either the currently editing element */
  /* was not found or there is no editable item after it.    */

  if (!next)
  {
    /* Either submit the form, or jump back up to the first editable */
    /* element.                                                      */

    if (auto_submit) return (form_submit_form(fe_browser, fe_token, 0, 0));
    else next = first;
  }

  /* If using keyboard control, want to try to find a generally */
  /* selectable token to move to (a wider search than the above */
  /* writable-only one). If this fails, go back to the token    */
  /* worked out above (this shouldn't really happen unless      */
  /* there was 2D movement possible at this stage - may not be  */
  /* able to find a selectable on the next line, but may have   */
  /* a writable forms field on the same one).                   */

  if (choices.keyboard_ctrl && fe_lastkey != akbd_TabK) /* Allow Tab to move between form elements only */
  {
    browser_data * b;
    browser_data * ancestor;
    browser_data * owner;
    HStream      * t;

    /* Remember the current editing details and cancel the existing edit, */
    /* ready for movement to a new token.                                 */

    b        = fe_browser;
    t        = fe_token;
    ancestor = utils_ancestor(b);

    owner = ancestor->selected_owner;

    form_end_edit(fe_browser, 1, 1); /* fe_browser etc. are now invalid, don't use again! */

    /* If the user has combined mouse and keyboard control, may have the */
    /* editing token different from the selected token. In this case,    */
    /* want to move from the caret, not wherever the selection may be.   */

    if (owner && ancestor->selected != t)
    {
      browser_clear_selection(owner, 0);

      browser_select_token(b, t, 0);

      owner = b;
    }

    /* Try moving the selection */

    if (!browser_move_selection(owner, fe_lastkey))
    {
      /* The selection failed, so try staying on the currently editing token */
      /* (with keyboard control, when you get to the bottom of the page you  */
      /* don't wrap to the top - so although the normal forms keyboard edit  */
      /* would go back up to the first writable item, if available, this     */
      /* shouldn't happen here if we are to be consistent).                  */
      /*                                                                     */
      /* Of course, we don't want to move back to the token if it's not      */
      /* visible at this moment; it can be very disconcerting to jump back   */
      /* up after using, say, page up / page down to move around.            */

      if (browser_check_visible(owner, NULL, t) && ancestor->selected != t)
      {
        browser_select_token(owner, t, 0);

        return form_click_field(owner, t, 1, 0, 0);
      }
      else
      {
        /* Not doing anything, so mark the keypress as unused */

        if (used) *used = 0;
      }
    }

    /* If the selection did move, may need to turn off the caret */

    else if (ancestor->selected != t && !form_token_cursor_editable(owner, ancestor->selected)) return wimp_set_caret_position(ancestor->window_handle, -1, 0, 0, -1, -1);
  }
  else
  {
    /* If there is indeed a next element, and it isn't the same as the */
    /* current one, move to it.                                        */

    if (next && next != fe_token)
    {
      if (choices.keyboard_ctrl) browser_select_token(fe_browser, next, 0); /* If moving by Tab, make sure the selection keeps up */
      return form_click_field(fe_browser, next, 1, 0, 0);
    }
  }

  return NULL;
}

/**************************************************************/
/* form_previous_field()                                      */
/*                                                            */
/* Moves the editing position up to the previous editable     */
/* field in the form.                                         */
/*                                                            */
/* Parameters: Pointer to an int, into which 0 may be written */
/*             if the keypress ends up in fact not being used */
/*             for some reason.                               */
/*                                                            */
/* Assumes:    The int pointer may be NULL.                   */
/**************************************************************/

static _kernel_oserror * form_previous_field(int * used)
{
  form_header * hp;
  form_field  * fp;
  int           i, found;
  HStream     * last;
  HStream     * previous;

  found = 0;
  previous = last = NULL;

  /* Find the details of the currently editing form */

  hp = form_find_record(fe_browser, fe_token, 1);
  fp = (form_field *) (((int) hp) + sizeof(form_header));

  /* Go through all the fields */

  for (i = 0; i < hp->fields; i++)
  {
    /* If we find the currently editing element, set 'found' to 1 */

    if (fp->header.token == fe_token) found = 1;

    /* Is the current element editable from the keyboard? */

    if (form_cursor_editable(fp->header.type))
    {
      /* If so, set 'last' to it. This may be used if there */
      /* are no previous elements to go to - by the end of  */
      /* the for loop, this will point to the last keyboard */
      /* editable element.                                  */

      last = fp->header.token;

      /* If 'found' isn't set, then remember the current */
      /* element in 'previous'. If 'found' is eventually */
      /* set by the above code, this will mean that      */
      /* 'previous' stays set on the keyboard editable   */
      /* field before the current one.                   */

      if (!found) previous = fp->header.token;
    }

    /* Move to the next field */

    fp = (form_field *) (((int) fp) + fp->header.size * 4);
  }

  /* If there is no previous item, wrap around to the last one */

  if (!previous) previous = last;

  /* If using keyboard control, want to try to find a generally */
  /* selectable token to move to (a wider search than the above */
  /* writable-only one). If this fails, go back to the token    */
  /* worked out above (this shouldn't really happen unless      */
  /* there was 2D movement possible at this stage - may not be  */
  /* able to find a selectable on a previous line, but may have */
  /* a writable forms field on the same one).                   */

  if (choices.keyboard_ctrl && fe_lastkey != akbd_TabK + akbd_Sh) /* Allow Tab to move between form elements only */
  {
    browser_data * b;
    browser_data * ancestor;
    browser_data * owner;
    HStream      * t;

    /* Remember the current editing details and cancel the existing edit, */
    /* ready for movement to a new token.                                 */

    b        = fe_browser;
    t        = fe_token;
    ancestor = utils_ancestor(b);

    owner = ancestor->selected_owner;

    form_end_edit(fe_browser, 1, 1); /* fe_browser etc. are now invalid, don't use again! */

    /* If the user has combined mouse and keyboard control, may have the */
    /* editing token different from the selected token. In this case,    */
    /* want to move from the caret, not wherever the selection may be.   */

    if (ancestor->selected != t)
    {
      browser_clear_selection(owner, 0);

      browser_select_token(b, t, 0);

      owner = b;
    }

    /* Try moving the selection */

    if (!browser_move_selection(owner, fe_lastkey))
    {
      /* The selection failed; proceed in the same manner as form_next_field */

      if (browser_check_visible(owner, NULL, t) && ancestor->selected != t)
      {
        browser_select_token(owner, t, 0);

        return form_click_field(owner, t, 2, 0, 0);
      }
      else
      {
        /* Not doing anything, so mark the keypress as unused */

        if (used) *used = 0;
      }
    }

    /* If the selection did move, may need to turn off the caret */

    else if (ancestor->selected != t && !form_token_cursor_editable(owner, ancestor->selected)) wimp_set_caret_position(ancestor->window_handle, -1, 0, 0, -1, -1);
  }
  else
  {
    /* If there is a previous item, and it's not the same as the */
    /* current one, move into it.                                */

    if (previous && previous != fe_token)
    {
      if (choices.keyboard_ctrl) browser_select_token(fe_browser, previous, 0); /* If moving by Tab, make sure the selection keeps up */
      return form_click_field(fe_browser, previous, 2, 0, 0);
    }
  }

  return NULL;
}

/**************************************************************/
/* form_cursor_right()                                        */
/*                                                            */
/* Handles moving the cursor (caret) right in a keyboard      */
/* editable form field.                                       */
/*                                                            */
/* Parameters: Pointer to an int, into which 0 may be written */
/*             if the keypress ends up in fact not being used */
/*             for some reason.                               */
/*                                                            */
/* Assumes:    The int pointer may be NULL.                   */
/**************************************************************/

static _kernel_oserror * form_cursor_right(int * used)
{
  /* Proceed only if there's something being edited */

  if (fe_token && fe_browser)
  {
    const char * p;

    p = form_get_field_text(fe_browser, fe_token);

    /* If we aren't on the terminator already, move forward */

    if (p[fe_index])
    {
      fe_index++;
      form_give_focus(fe_browser);

      return form_autoscroll(fe_browser);
    }
    else if (choices.keyboard_ctrl)
    {
      /* For keyboard control, jump to the next field */

      return form_next_field(0, used);
    }
  }

  /* Doing nothing, so mark the keypress as unused */

  else
  {
    if (used) *used = 0;
  }

  return NULL;
}

/**************************************************************/
/* form_cursor_bottom()                                       */
/*                                                            */
/* Moves the caret to the bottom right of a writable forms    */
/* item (text area or single line text fields).               */
/**************************************************************/

static _kernel_oserror * form_cursor_bottom(void)
{
  /* Can only proceed if something's being edited */

  if (fe_token && fe_browser)
  {
    const char * p;

    p = form_get_field_text(fe_browser, fe_token);

    /* Only move if not already on the last character */

    if (p[fe_index])
    {
      fe_index = strlen(p);
      form_give_focus(fe_browser);
      form_autoscroll(fe_browser);
    }
  }

  return NULL;
}

/**************************************************************/
/* form_cursor_eol()                                          */
/*                                                            */
/* Move the cursor to the end of the line in a writable forms */
/* element.                                                   */
/**************************************************************/

static _kernel_oserror * form_cursor_eol(void)
{
  if (fe_token && fe_browser)
  {
    const char * p;
    int          o;

    p = form_get_field_text(fe_browser, fe_token);
    o = fe_index;

    /* Keep going forward to a null or newline character */
    /* marking the end of the line                       */

    while (p[fe_index] && p[fe_index] != '\n') fe_index++;

    /* If the index has changed, do the appropriate */
    /* updates on the page.                         */

    if (o != fe_index)
    {
      form_give_focus(fe_browser);
      form_autoscroll(fe_browser);
    }
  }
  return NULL;
}

/**************************************************************/
/* form_cursor_bol()                                          */
/*                                                            */
/* Move the cursor to the start of the line in a writable     */
/* forms element.                                             */
/**************************************************************/

static _kernel_oserror * form_cursor_bol(void)
{
  if (fe_token && fe_browser && fe_index)
  {
    const char * p;
    int          o;

    p = form_get_field_text(fe_browser, fe_token);
    o = fe_index;

    /* Keep backing up until reaching the zero */
    /* index position, or for text areas, a    */
    /* newline character marking the end of a  */
    /* previous line.                          */

    do
    {
      fe_index--;
    }
    while (fe_index >= 0 && p[fe_index] != '\n');

    fe_index++;

    /* If the index has changed, do the appropriate */
    /* updates on the page.                         */

    if (o != fe_index)
    {
      form_give_focus(fe_browser);
      form_autoscroll(fe_browser);
    }
  }

  return NULL;
}

/**************************************************************/
/* form_cursor_left()                                         */
/*                                                            */
/* Handles moving the cursor (caret) left in a keyboard       */
/* editable form field.                                       */
/*                                                            */
/* Parameters: Pointer to an int, into which 0 may be written */
/*             if the keypress ends up in fact not being used */
/*             for some reason.                               */
/*                                                            */
/* Assumes:    The int pointer may be NULL.                   */
/**************************************************************/

static _kernel_oserror * form_cursor_left(int * used)
{
  /* Proceed only if there's something being edited */

  if (fe_token && fe_browser)
  {
    /* Can only go back if we aren't already at the start */

    if (fe_index)
    {
      fe_index--;
      form_give_focus(fe_browser);

      return form_autoscroll(fe_browser);
    }
    else if (choices.keyboard_ctrl)
    {
      /* For keyboard control, jump to the previous field */

      return form_previous_field(used);
    }
  }

  /* Doing nothing, so mark the keypress as unused */

  else
  {
    if (used) *used = 0;
  }

  return NULL;
}

/**************************************************************/
/* form_cursor_top()                                          */
/*                                                            */
/* Moves the caret to the top left of a writable forms item   */
/* (text area or single line item).                           */
/**************************************************************/

static _kernel_oserror * form_cursor_top(void)
{
  /* Proceed only if there's something being edited */
  /* and the caret isn't already at the start       */

  if (fe_token && fe_browser && fe_index)
  {
    fe_index = 0;
    form_give_focus(fe_browser);
    form_autoscroll(fe_browser);
  }

  return NULL;
}

/**************************************************************/
/* form_cursor_y()                                            */
/*                                                            */
/* Handles moving the caret up or down between editable form  */
/* elements. If overall keyboard control is enabled, this may */
/* jump out of the form and select objects on the page.       */
/*                                                            */
/* Parameters: Direction; negative for up, positive for down, */
/*             with the number of lines to move found based   */
/*             on the magnitude of the number. For single     */
/*             line items, only the sign is of interest; for  */
/*             multiple line items, 1 means '1 line', 2 means */
/*             'page up/down'.                                */
/*                                                            */
/*             Pointer to an int, into which 0 may be written */
/*             if the keypress ends up in fact not being used */
/*             for some reason.                               */
/*                                                            */
/* Assumes:    The int pointer may be NULL.                   */
/**************************************************************/

static _kernel_oserror * form_cursor_y(int dir, int * used)
{
  /* Can only move if we're editing some form, and a direction */
  /* has been given.                                           */

  if (fe_token && fe_browser && dir)
  {
    const char * p;
    int          o, x, y, fh;
    HStream    * tp;

    #ifndef ARROWS_MOVE_OUT

      if (choices.keyboard_ctrl)
      {

    #endif

        /* For single line items, just look at the relevant direction to move */

        if (fe_single && dir < 0) return form_previous_field(used);
        if (fe_single && dir > 0) return form_next_field(0, used);

    #ifndef ARROWS_MOVE_OUT

      }
      else
      {
        if (fe_single && dir != 0) return NULL;
      }

    #endif

    /* For multiline items (e.g. text areas), get need to move up or */
    /* down within the element.                                      */

    p  = form_get_field_text(fe_browser, fe_token);
    tp = fe_token;
    fh = fm_find_token_font(fe_browser, tp, 0);

    /* Get the caret position inside the element */

    form_textarea_caretpos(p, fh, fe_index, &x, &y);

    /* 'o' holds the index into the string for whatever */
    /* line of text the caret is currently in.          */

    o = fe_index;

    /* Work out where to move to */

    if (dir == 1 || dir == -1) y += dir;
    else if (dir)
    {
      int rows = tp->rows;

      if (rows < 2) rows = 2;

      if (dir == 2) y += rows;
      else          y -= rows;

      if (y < 0) y = 0;
    }

    #ifndef ARROWS_MOVE_OUT

      if (choices.keyboard_ctrl)
      {

    #endif

        /* If y < 0, we've dropped over the top of the element so move */
        /* up to the previous field.                                   */

        if (y < 0) return form_previous_field(used);

    #ifndef ARROWS_MOVE_OUT

      }
      else
      {
        if (y < 0) y = 0;
      }

      if (y < 0) y = 0;

    #endif

    /* If this really *is* a text area, then move the caret based on */
    /* the new 'y' coordinate. The call returns the new index into   */
    /* whatever text the caret is in, into fe_index.                 */

    if (tp->tagno == TAG_TEXTAREA) form_textarea_find_caret(p, fh, &fe_index, x, y);

    #ifndef ARROWS_MOVE_OUT

      if (choices.keyboard_ctrl)
      {

    #endif

        /* If the index into the string hasn't changed, then the caret */
        /* must have already been at the end of the text; in this      */
        /* case, move on to the next form element.                     */

        if (o == fe_index && dir > -2 && dir < 2) return form_next_field(0, used);

    #ifndef ARROWS_MOVE_OUT

      }

    #endif

    /* Otherwise, ensure the caret appearance and window scroll */
    /* positions are correct for the current caret position.    */

    form_give_focus(fe_browser);

    return form_autoscroll(fe_browser);
  }

  /* Doing nothing, so mark the keypress as unused */

  else
  {
    if (used) *used = 0;
  }

  return NULL;
}

/**************************************************************/
/* form_insert_character()                                    */
/*                                                            */
/* Inserts a character into the currently editing writable /  */
/* text area.                                                 */
/*                                                            */
/* Parameters: Key code, to give char to insert;              */
/*                                                            */
/*             Pointer to an int, in which 1 is written if    */
/*             the key press leads to an insertion, else 0 is */
/*             written.                                       */
/*                                                            */
/* Assumes:    The int pointer may not be NULL.               */
/**************************************************************/

static _kernel_oserror * form_insert_character(int key, int * used)
{
  char                  * p;
  HStream               * tp;
  _kernel_oserror       * e;
  WimpRedrawWindowBlock   r;
  int                     x, y, fh, lh, lb;

  /* Can we deal with the key? */

  if (
       (
         key < 32 &&
         key != 13
       )
       || key >  255
       || key == 127
       || !fe_token
       || !fe_browser
     )
  {
    /* No, so exit */

    *used = 0;
    return NULL;
  }

  /* Yes, so proceed */

  *used = 1;

  p     = form_get_field_text(fe_browser, fe_token);
  tp    = fe_token;

  /* If the key is 'return' and the writable has just */
  /* the one line, move to the next field.            */

  if (fe_single && key == 13) return form_next_field(1, NULL);

  /* Are we going to exceed the field maximum length? */

  if (HtmlINPUTmaxlength(fe_token) && strlen(p) >= HtmlINPUTmaxlength(fe_token)) return NULL;

  /* Otherwise, try to allocate space for the extra character */

  e = form_set_field_space(fe_browser, fe_token, strlen(p) + 2);
  if (e) return e;

  /* Make sure the field text and token pointers are up to date */

  p  = form_get_field_text(fe_browser, fe_token);
  tp = fe_token;

  /* Get details about the caret position for redraw later */

  form_input_box(fe_browser, fe_token, &r.visible_area, &lh, &lb, &fh);
  form_textarea_caretpos(p, fh, fe_index, &x, &y);

  /* Move the text above the caret position up and */
  /* insert the character (possibly modified)      */

  memmove(p + fe_index + 1, p + fe_index, strlen(p) - fe_index + 1);

  r.visible_area.ymax -= (y - fe_yscroll) * lh + 4;

  /* Alter code 13 to code 10 for internal consistency */

  if (key == 13) p[fe_index] = 10;
  else
  {
    p[fe_index] = key;
    r.visible_area.ymin  = r.visible_area.ymax - lh;
    r.visible_area.xmin += x - fe_xscroll;
  }

  /* Update the redraw area and exit through the routine */
  /* that updates the cursor position by moving it right */

  browser_update(fe_browser, &r, 1, 0);

  return form_cursor_right(NULL);
}

/**************************************************************/
/* form_delete_character()                                    */
/*                                                            */
/* Deletes a character from the currently editing writable /  */
/* text area, to the left or if required to the right.        */
/*                                                            */
/* Parameters: 0 to delete to the left, else delete right.    */
/**************************************************************/

static _kernel_oserror * form_delete_character(int right)
{
  _kernel_oserror       * e;
  char                  * p, c;
  int                     x, y, fh, lh, lb;
  WimpRedrawWindowBlock   r;

  /* If deleting left but already on the left of the field, exit */

  if (!right && !fe_index) return NULL;

  /* To simplify things, the rest of the routine handles deleting */
  /* right - so for left deletion, just move the cursor left on   */
  /* character first.                                             */

  if (!right) form_cursor_left(NULL);

  /* Get the field text, and exit if the cursor is on a */
  /* null character - i.e. can't delete right if at the */
  /* end of the string.                                 */

  p = form_get_field_text(fe_browser, fe_token);
  if (!p[fe_index]) return NULL;

  /* Remember the character that is about to be deleted */
  /* and get various details about the caret position   */

  c = p[fe_index];
  form_input_box(fe_browser, fe_token, &r.visible_area, &lh, &lb, &fh);
  form_textarea_caretpos(p, fh, fe_index, &x, &y);

  /* Delete the character */

  memmove(p + fe_index, p + fe_index + 1, strlen(p) - fe_index);
  e = form_set_field_space(fe_browser, fe_token, strlen(p) + 1);
  if (e) return e;

  /* From the value of the deleted character work out, for */
  /* text areas, what updates need to be done              */

  r.visible_area.ymax -= (y - fe_yscroll) * lh + 4;
  if(c != '\n')
  {
    r.visible_area.ymin = r.visible_area.ymax - lh;
    r.visible_area.xmin+= x - fe_xscroll;
  }

  /* Finally, exit by redraw the window as required */

  return browser_update(fe_browser, &r, 1, 0);
}

/**************************************************************/
/* form_delete_from_caret()                                   */
/*                                                            */
/* Deletes a chunk of the current line, from the caret        */
/* position to its end.                                       */
/*                                                            */
/* Assumes:    That there is a currently editing item, and    */
/*             it's a text area or single line writable.      */
/**************************************************************/

static _kernel_oserror * form_delete_from_caret(void)
{
  _kernel_oserror       * e;
  char                  * p;
  int                     x, y, fh, lh, lb;
  int                     end, len;
  WimpRedrawWindowBlock   r;

  p = form_get_field_text(fe_browser, fe_token);
  if (!p) return NULL;

  /* Find out where the current line (or whole piece of text, */
  /* for a single line writable) ends.                        */

  len = strlen(p);
  if (!len) return NULL;

  if (!p[fe_index] || p[fe_index] == '\n') return NULL;

  end = fe_index;

  while (end <= len && p[end] && p[end] != '\n') end++;

  /* Remove an appropriate chunk of the string */

  memmove(p + fe_index, p + end, len - end + 1);

  e = form_set_field_space(fe_browser, fe_token, strlen(p) + 1);
  if (e) return e;

  /* Work out redraw details and exit through the redraw routine */

  form_input_box(fe_browser, fe_token, &r.visible_area, &lh, &lb, &fh);
  form_textarea_caretpos(p, fh, fe_index, &x, &y);

  r.visible_area.ymax -= (y - fe_yscroll) * lh + 4;
  r.visible_area.ymin  = r.visible_area.ymax - lh;
  r.visible_area.xmin += x - fe_xscroll;

  return browser_update(fe_browser, &r, 1, 0);
}

/**************************************************************/
/* form_delete_line()                                         */
/*                                                            */
/* Clears the current line of the currently editing text      */
/* item.                                                      */
/*                                                            */
/* Assumes:    That there is a currently editing item, and    */
/*             it's a text area or single line writable.      */
/**************************************************************/

static _kernel_oserror * form_delete_line(void)
{
  _kernel_oserror       * e;
  char                  * p;
  int                     x, y, fh, lh, lb;
  int                     index, start, end, len;
  WimpRedrawWindowBlock   r;

  p = form_get_field_text(fe_browser, fe_token);
  if (!p) return NULL;

  /* Find out where the current line (or whole piece of text, */
  /* for a single line writable) starts and ends.             */

  len = strlen(p);
  if (!len) return NULL;

  /* If we're on the end of a line, step back one. If this */
  /* leaves fe_index pointing to an end of line character  */
  /* still, then the line was already empty so return.     */

  index = fe_index;

  if (!p[index] || p[index] == '\n') index--;
  if (index < 0) index = 0;
  if (!p[index] || p[index] == '\n') return NULL;

  /* Otherwise, look for end of line characters to either side */
  /* of the adjusted fe_index.                                 */

  start = end = index;

  while (start > 0  && p[start] && p[start] != '\n') start--;
  while (end <= len && p[end]   && p[end]   != '\n') end++;

  /* Set the new index and remove an appropriate chunk of the string */

  if (p[start] == '\n') fe_index = start + 1;
  else                  fe_index = start;

  memmove(p + fe_index, p + end, len - end + 1);

  e = form_set_field_space(fe_browser, fe_token, strlen(p) + 1);
  if (e) return e;

  /* Move the caret */

  form_give_focus(fe_browser);
  form_autoscroll(fe_browser);

  /* Work out redraw details and exit through the redraw routine */

  form_input_box(fe_browser, fe_token, &r.visible_area, &lh, &lb, &fh);
  form_textarea_caretpos(p, fh, fe_index, &x, &y);

  r.visible_area.ymax -= (y - fe_yscroll) * lh + 4;
  r.visible_area.ymin  = r.visible_area.ymax - lh;
  r.visible_area.xmin += x - fe_xscroll;

  return browser_update(fe_browser, &r, 1, 0);
}

/**************************************************************/
/* form_process_key()                                         */
/*                                                            */
/* Processes a given key stroke in the context of forms       */
/* handling.                                                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the forms;                                     */
/*                                                            */
/*             Pointer to an int in which the Wimp key code   */
/*             should be stored.                              */
/*                                                            */
/* Returns:    The key code will be set to zero if the key is */
/*             processed by the function (so that a caller    */
/*             can know if the keypress should be passed on   */
/*             further).                                      */
/**************************************************************/

_kernel_oserror * form_process_key(browser_data * b, int * key)
{
  _kernel_oserror * e    = NULL;
  int               used = 0;

  if (fe_browser && b == fe_browser && fe_token)
  {
    used = 1;

    fe_lastkey = *key;

    switch (*key)
    {
      case 8:   /* Ctrl+H */       e = form_delete_character(0);           break;
      case 21:  /* Ctrl+U */       e = form_delete_line();                 break;
      case 27:  /* Escape */       e = form_cancel_edit(b);                break;
      case 30:  /* Home */         e = form_cursor_top();                  break;
      case 127: /* Backspace */    e = form_delete_character(0);           break;
      case akbd_CopyK + akbd_Ctl:  e = form_delete_from_caret();           break;
      case akbd_RightK:            e = form_cursor_right(&used);           break;
      case akbd_RightK + akbd_Ctl: e = form_cursor_eol();                  break;
      case akbd_LeftK:             e = form_cursor_left(&used);            break;
      case akbd_LeftK + akbd_Ctl:  e = form_cursor_bol();                  break;
      case akbd_TabK:              e = form_next_field(0, &used);          break;
      case akbd_DownK:             e = form_cursor_y(1, &used);            break;
      case akbd_DownK + akbd_Sh:   e = form_cursor_y(2, &used);            break;
      case akbd_TabK + akbd_Sh:    e = form_previous_field(&used);         break;
      case akbd_UpK:               e = form_cursor_y(-1, &used);           break;
      case akbd_UpK + akbd_Sh:     e = form_cursor_y(-2, &used);           break;
      case akbd_CopyK:             e = form_delete_character(1);           break;
      case akbd_UpK + akbd_Ctl:    e = form_cursor_top();                  break;
      case akbd_DownK + akbd_Ctl:  e = form_cursor_bottom();               break;

      case 10:  /* Ctrl+J */       form_delete_line(); e = form_delete_character(1); break;

      default:                     e = form_insert_character(*key, &used); break;
    }
  }

  if (used)
  {
    /* Clear the keyboard buffer for anything other than actual */
    /* characters. Things can get slow in very large multi-line */
    /* writables now that you can drop big text files into them */

    if (*key < 32 || *key == 127 || *key > 255)
    {
      _swix(OS_Byte,
            _INR(0, 1),

            21,
            0);
    }

    *key = 0;
  }

  return e;
}

/**************************************************************/
/* form_textarea_redraw()                                     */
/*                                                            */
/* Redraws the text in a text area object.                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the text area;                                 */
/*                                                            */
/*             Pointer to the token representing the text     */
/*             area;                                          */
/*                                                            */
/*             Pointer to a BBox holding the bounding box of  */
/*             the text area, in screen coords (so OS units); */
/*                                                            */
/*             Pointer to a BBox holding the current graphics */
/*             window (usually from a call to the Wimp to     */
/*             redraw something - remember that this can't be */
/*             read during a printing routine as VDU          */
/*             variables may not be read during printing);    */
/*                                                            */
/*             A font handle for the font to use for the      */
/*             redraw;                                        */
/*                                                            */
/*             1 if the text area has multiple lines, 0 to    */
/*             render all text on one line only;              */
/*                                                            */
/*             1 if the text area represents a password       */
/*             object (show the text as a line of *s, instead */
/*             of the actual chars), else 0;                  */
/*                                                            */
/*             32-bit text foreground colour (&BBGGRRAA);     */
/*                                                            */
/*             32-bit text background colour (&BBGGRRAA).     */
/**************************************************************/

_kernel_oserror * form_textarea_redraw
                  (
                    const browser_data * restrict b,
                    const HStream      * restrict token,
                    const BBox         * restrict box,
                    const BBox         * gw,
                    fm_face              fh,
                    int                  multiline,
                    int                  password,
                    unsigned int         text_foreground,
                    unsigned int         text_background
                  )
{
  int    lh, lb, l;
  int    xs, ys, y;
  BBox   area, fontbox;
  char   c;
  char * p, *t;
  char   passcode[] = FE_PassCode;
  int    user_border;
  BBox   user_box, user_intersect, user_gfxwin;

  /* Get the various OS unit boxes in user-points */

  scale_box_os_to_user(b, box, &user_box);
  scale_box_os_to_user(b, gw,  &user_gfxwin);

  /* Shrink to account for a 4 OS unit border all */
  /* around (8 units top/bottom, left/right).     */

  user_border = scale_os_to_user(b, 8);

  user_box.xmin += user_border;
  user_box.ymin += user_border;
  user_box.xmax -= user_border;
  user_box.ymax -= user_border;

  /* Set 'area' to hold the bounding box in OS units */

  scale_box_user_to_os(b, &user_box, &area);

  /* Get nxmin, nxmax, nymin anx nymax to hold the coordinates of */
  /* a BBox formed by the intersection of the text area and the   */
  /* current graphics rectangle.                                  */

  if (utils_intersection(&user_box, &user_gfxwin, &user_intersect) == 0)
  {
    /* No intersection -> nothing to redraw */

    return NULL;
  }

  RetError(redrawcore_clipping(b, &user_intersect));

  /* Get the height of an individual line, based on the height of */
  /* the font to be used plus vertical spacing considerations.    */

  fm_font_box(fh, &fontbox);

  form_get_linesize(&fontbox, &lh, &lb);

  /* Get the text for the text area */

  p = form_get_field_text(b, token);

  /* Only proceed if there's text to draw */

  if (p)
  {
    int user_x;

    xs = ys = 0;

    /* If this is an element that the forms library is already handling */
    /* because it has the input focus, then use the scroll offset that  */
    /* is recorded for the object.                                      */

    if (b == fe_browser && token == fe_token)
    {
      xs = fe_xscroll;
      ys = fe_yscroll * lh;
    }

    y      = area.ymax + ys;
    user_x = scale_os_to_user(b, area.xmin - xs);

    do
    {
      /* The text may be terminated by newlines or null bytes; if */
      /* a newline, this implies a split point for a text area.   */

      t         = strchr(p, '\n');
      if (!t) t = strchr(p, 0);

      /* Ensure for C's purposes (sigh) that there is a zero terminator */
      /* at the end of the chunk to plot.                               */

       c = *t;
      *t = 0;

      l = strlen(p);

      /* If the line is in the visible region, plot it. Note the use of */
      /* the FE_PassCode line of asterisks - if a password is being     */
      /* entered, as many of these as there are characters in the       */
      /* real string will be displayed instead of that string.          */

      if (y - lh < area.ymax && l > 0)
      {
        RetError(redrawcore_text(b,
                                 fh,
                                 user_x,
                                 scale_os_to_user(b, y - lh + lb),
                                 password ? passcode : p,
                                 l,
                                 text_foreground,
                                 text_background,
                                 0));
      }

      y -= lh;

      /* Restore the character that was altered to a null byte earlier */

      *t = c;

      /* Advance the string pointer past the text just plotted */

      p += l;

      /* If we're on a newline, there must be another chunk of string to */
      /* plot, so move the pointer past it.                              */

      if (*p == '\n') p++;

      /* Keep looping whilst in the visible area and there's data left to   */
      /* plot, provided that this was flagged as a multiline object redraw. */
    }
    while (y>area.ymin && multiline && *p);
  }

  /* Restore the previous graphics rectangle */

  return redrawcore_clipping(b, &user_gfxwin);
}

/**************************************************************/
/* form_select_menu_event()                                   */
/*                                                            */
/* Handles menu selections in SELECT fields.                  */
/*                                                            */
/* Parameters: Pointer to a WimpPollBlock struct describing   */
/*             the selection event.                           */
/**************************************************************/

void form_select_menu_event(WimpPollBlock * e)
{
  /* Only proceed if this is definitely from a form-derived menu */

  if (menusrc == Menu_Form && fe_menu && fe_mbrowser && fe_mtoken)
  {
    int                       n, o;
    HStream                 * tp;
    form_field              * fp;
    WimpGetPointerInfoBlock   m;
    char                      select[Limits_SelectItems + 1];

    /* Find the form record, exit if it isn't a SELECT field */

    fp = form_find_record(fe_mbrowser, fe_mtoken, 0);
    if (fp->header.type != form_select) return;

    /* Check that the selected item is within the apparent range */
    /* of items that the menu should have                        */

    tp = fe_mtoken;
    n  = HtmlSELECToptions(tp)[0];
    o  = e->menu_selection[0];

    if (o >= n) return;

    /* After this, 'select' will hold an array of FORM_SELCHAR and */
    /* FORM_UNSELCHAR characters describing which menu items are   */
    /* selected or deselected.                                     */

    strcpy(select, fp->value.select.selection);

    /* For menus which can have multiple items selected, just invert */
    /* the selection type. Otherwise, need to make sure that any     */
    /* other selected item is cleared.                               */

    if (HtmlSELECTmultiple(tp))
    {
      select[o] = (select[o] == FORM_SELCHAR) ? FORM_UNSELCHAR : FORM_SELCHAR;
    }
    else
    {
      int i, c;

      for (i = 0; i < n; i++)
      {
        if (i == o) select[i] = (select[i] == FORM_SELCHAR) ? FORM_UNSELCHAR : FORM_SELCHAR;
        else select[i] = FORM_UNSELCHAR;
      }

      c = 0;

      for (i = 0; i < n; i++)
      {
        if (select[i] == FORM_SELCHAR) c++;
      }

      if (!c) select[o] = FORM_SELCHAR;
    }

    /* Update the browser with the new selection details */

    form_put_field(fe_mbrowser, fe_mtoken, select, 1);

    /* If Adjust was used, reopen the menu */

    wimp_get_pointer_info(&m);

    if (m.button_state & 3) form_create_menu(fe_mbrowser, fe_mtoken);
  }
}

/**************************************************************/
/* form_check_caret()                                         */
/*                                                            */
/* Ensure the caret is correctly located in a given browser   */
/* window.                                                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the window. This may be NULL to ensure it is   */
/*             correct in the currently editing form, else it */
/*             will check that the given browser holds the    */
/*             currently editing form and only check the      */
/*             caret if so.                                   */
/**************************************************************/

void form_check_caret(browser_data * b)
{
  /* Ensure we were given the browser holding the currently */
  /* editing form, or no browser at all, before trying to   */
  /* position the caret.                                    */

  if (
       (
         !b              ||
         b == fe_browser
       )
       && fe_browser
       && fe_token
     )
  {
    /* If the caret can't be placed, finish editing in this form */

    if (!form_give_focus(fe_browser)) form_finish_edit(fe_browser);
  }
}

/**************************************************************/
/* form_caret_may_need_moving()                               */
/*                                                            */
/* Whereas form_check_caret will finish editing in a window   */
/* if the caret can't be placed, this function will continue  */
/* to try placing it as long as the given browser matches the */
/* editing browser. This was designed for after the           */
/* reformatter had ben called, to try and keep the caret in   */
/* the window where possible.                                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the editing token. If there is no form edit    */
/*             going on in this window, the function will do  */
/*             nothing; otherwise, if there's an editing      */
/*             token too, it'll make sure the caret (if any)  */
/*             is correctly positioned.                       */
/**************************************************************/

void form_caret_may_need_moving(browser_data * b)
{
  if (
       fe_browser        &&
       fe_token          &&
       b == fe_browser
     )
     form_give_focus(b);
}
@


1.30
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d55 1
d131 1
a131 1
static void            * form_find_record         (browser_data * b, HStream * token, int header);
d138 1
a138 1
static char            * form_select_text         (browser_data * b, HStream * tp, char * selection);
d143 9
a151 1
static int               form_input_box           (browser_data * b, HStream * tp, BBox * box, int * lh, int * lb, int * fhand);
d153 1
a153 1
static _kernel_oserror * form_create_menu         (browser_data * b, HStream * tp);
d160 1
a160 1
static int               form_extend_flex         (void **data, int size);
d307 1
a307 1
    oldsize = flex_size(&b->fdata);
d330 4
a333 1
      if (!flex_alloc(&b->fdata, alloc)) ok = 0;
d337 4
a340 1
      if (!flex_extend(&b->fdata, alloc + oldsize)) ok = 0;
d348 2
a349 2
      flexcount += alloc;
      dprintf(("CFle", "**   flexcount: %d\n",flexcount));
d429 2
a430 2
      flexcount -= flex_size(&b->fdata);
      dprintf(("CFle", "**   flexcount: %d\n",flexcount));
d433 4
a436 2
    flex_free(&b->fdata);
    b->fdata = NULL;
d459 6
a464 1
static void * form_find_record(browser_data * b, HStream * token, int header)
d1223 6
a1228 1
static char * form_select_text(browser_data * b, HStream * tp, char * selection)
d1240 1
a1240 1
  pi = HtmlSELECToptions(tp);
d1304 5
a1308 1
char * form_get_field_text(browser_data * b, HStream * token)
d1661 9
a1669 1
static int form_input_box(browser_data * b, HStream * tp, BBox * box, int * lh, int * lb, int * fhand)
d1671 5
a1675 5
  int             l, c, x, y, fh, t = 0;
  int             orx,ory;
  int             depth;
  token_path    * path;
  reformat_cell * cell;
d1852 1
a1852 1
static _kernel_oserror * form_create_menu(browser_data * b, HStream * tp)
d2113 2
a2114 2
    token_path              * path  = NULL;
    reformat_cell           * cell;
d2155 1
a2155 1
    read_sprite_size("fgright", &width, &height);
d2674 1
a2674 1
static int form_extend_flex(void **data, int size)
d4991 5
a4995 1
/*             of the actual chars), else 0.                  */
d4998 12
a5009 2
void form_textarea_redraw(browser_data * b, HStream * token, BBox *box, BBox *gw, int fh,
                          int multiline, int password)
a5010 1
  int    nxmin, nymin, nxmax, nymax;
d5017 10
d5028 1
a5028 1
  /* Set 'area' to hold the bounding box of the text area */
d5030 4
a5033 1
  area = *box;
d5035 1
a5035 1
  /* Bring the coordinates in to account for the text area's border */
d5037 1
a5037 4
  area.xmin += 8;
  area.ymin += 8;
  area.xmax -= 8;
  area.ymax -= 8;
d5043 3
a5045 4
  nxmin = area.xmin > gw->xmin ? area.xmin : gw->xmin;
  nxmax = area.xmax < gw->xmax ? area.xmax : gw->xmax;
  nymin = area.ymin > gw->ymin ? area.ymin : gw->ymin;
  nymax = area.ymax < gw->ymax ? area.ymax : gw->ymax;
d5047 2
a5048 11
  /* Convert to pixels ready to set a graphics window */

  nxmin &= ~(wimpt_dx() - 1);
  nymin &= ~(wimpt_dy() - 1);
  nxmax &= ~(wimpt_dx() - 1);
  nymax &= ~(wimpt_dy() - 1);

  /* If the minimum coords are less than / equal to the maximums, */
  /* there is nothing to redraw.                                  */

  if (nxmin >= nxmax || nymin >= nymax) return;
d5050 1
a5050 3
  /* Otherwise, set the graphics rectangle. */

  bbc_gwindow(nxmin, nymin, nxmax - 1, nymax - 1);
d5067 2
d5081 2
a5082 1
    y = area.ymax + ys;
d5105 13
a5117 7
      if (y - lh < area.ymax) fm_putsl(fh,
                                       area.xmin - xs,
                                       y - lh + lb,
                                       password ? passcode : p,
                                       l,
                                       1,
                                       0);
d5141 1
a5141 1
  bbc_gwindow(gw->xmin, gw->ymin, gw->xmax - 1, gw->ymax - 1);
@


1.29
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d2723 1
a2723 1
      if (*p == '\n') strcpy (code, "%0D%0A");
d3527 2
a3528 1
                                    adj);
d3580 2
a3581 1
                                    adj);
d3708 2
a3709 1
                                              controls.ignore_adjust ? 0 : adjust());
@


1.28
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a43 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d334 1
a334 1
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d415 1
a415 1
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d2655 1
a2655 1
    if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d3534 1
a3534 1
        if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
d3562 1
a3562 1
          if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
@


1.27
log
@Another intermediate check-in, resources may not be up to date; items
most likely to be buildable are PhoenixJ and BrowseD. Done because I'm
about to make some rather dodgy changes to code otherwise unchanged
since the Customer browser and I may well have to back them out...

In Handlers.c now set the HFlags_HasBeenVisited bit of a token at the point
it is first clicked on. Means the link returns to a "visited" colour after
the highlight flash immediately. This will persist for as long as the browser
window is kept open on that page, though if the URL doesn't end up making it
into the history for whatever reason it would "unhighlight" on reload; fair
enough, really. The highlight is window-local, so there are no redraw worries
for other open windows with links to the same URL (though other same-URL
links on the same page aren't updated either).

All forms submissions force a reload (principally for eudoramail.com, but
many other sites have similar requirements).

!MkClean and !MkClnAll didn't correctly call the utility to strip Makefile
dependencies. Fixed.

On fetch closedown, fetchpage_preprocess_token could be called on a token
which had already been run through the preprocessor. Now checks the flags
word before proceeding.

Image RAM cache and garbage collection system implemented - see new Choices
file entries CollectAfter, FreeRAMLimit and UnusedImageLimit to get an
overview. This contains groundwork for JavaScript image array support.

More JavaScript support improvements. Any one window object will know its
parent, top, this, etc.; frames array working except for a frameset created
via. multiple documents; opener for something created with window.open is
currently not set and don't know why (property is being created, pointer to
valid object is held, but JS engine returns 'null'. Ho hum) - JSChain won't
work yet, then.
@
text
@d15 13
a27 10
/***************************************************/
/* File   : Forms.c                                */
/*                                                 */
/* Purpose: Functions to manage HTML forms.        */
/*                                                 */
/* Author : Merlyn Kline for Customer browser     */
/*          This source adapted by A.D.Hodgkinson  */
/*                                                 */
/* History: 28-Jan-97: Created.                    */
/***************************************************/
d34 14
a47 2
#include "swis.h"
#include "flex.h"
a48 7
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "svcprint.h"
d272 17
a288 19
/*************************************************/
/* form_ensure_free()                            */
/*                                               */
/* Ensures that a given amount of free space is  */
/* present in the form store. This may not mean  */
/* that the block extends due to granularity of  */
/* allocation considerations.                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form store;       */
/*                                               */
/*             Space to ensure is present.       */
/*                                               */
/* Assumes:    The space may be 0, in which case */
/*             the block is freed, and there may */
/*             or may not be allocated store on  */
/*             entry. I.e., this copes with just */
/*             about everything.                 */
/*************************************************/
d353 10
a362 11
/*************************************************/
/* form_new_form()                               */
/*                                               */
/* Create a new form associated with the given   */
/* token.                                        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form and token;   */
/*                                               */
/*             The token's address.              */
/*************************************************/
d400 9
a408 9
/*************************************************/
/* form_discard()                                */
/*                                               */
/* Discards all the forms in a given view,       */
/* freeing associated memory.                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the view.             */
/*************************************************/
d430 16
a445 17
/*************************************************/
/* form_find_record()                            */
/*                                               */
/* Locates the form record governing the given   */
/* token or return NULL.                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token;            */
/*                                               */
/*             The token address;                */
/*                                               */
/*             1 to locate the header record for */
/*             the form, else the field record   */
/*             will be located.                  */
/*                                               */
/* Returns:    Pointer to record, as a void *.   */
/*************************************************/
d519 20
a538 24
/*************************************************/
/* form_validate_select()                        */
/*                                               */
/* Deals with clicks on selection lists (aka.    */
/* pop-up menus in forms) - either to select an  */
/* item for the first time in an unselected      */
/* group of menu items, or to ensure that the    */
/* selection which has been made is valid.       */
/* Consequently, if more than one item in the    */
/* array is selected and the field should only   */
/* allow one at a time, everything but the first */
/* selected item in the array will be            */
/* deselected.                                   */
/*                                               */
/* This function initiates appropriate redraws.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token;            */
/*                                               */
/*             The token address for the list;   */
/*                                               */
/*             The item number selected in the   */
/*             menu.                             */
/*************************************************/
d614 25
a638 28
/*************************************************/
/* form_validate_radio()                         */
/*                                               */
/* Validate radio icons including the indicated  */
/* token; i.e. ensure that only one is selected. */
/*                                               */
/* If more than one is selected, all but the     */
/* last are deselected (unless the passed token  */
/* is selected). If none are selected, that's    */
/* allowed (Netscape Navigator - hmph).          */
/*                                               */
/* This behaviour is important when loading      */
/* forms as it ensures that the correct default  */
/* selection is applied (if the fourth button is */
/* selected by default, when the first is added  */
/* it will be alone and deselected so it will    */
/* get selected  - this must be overridden when  */
/* the fourth button is added to the page). It   */
/* also ensures sensible behaviour when the user */
/* clicks on the selected button.                */
/*                                               */
/* This function initiates appropriate redraws.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token;            */
/*                                               */
/*             The token address for the radio.  */
/*************************************************/
d725 14
a738 15
/*************************************************/
/* form_set_field_space()                        */
/*                                               */
/* Set the space in bytes occupied by a field,   */
/* *not* including the header.                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to the token representing */
/*             the field;                        */
/*                                               */
/*             Space to set for the field, not   */
/*             including the header, in bytes.   */
/*************************************************/
d804 20
a823 24
/*************************************************/
/* form_put_field()                              */
/*                                               */
/* Sets the value in a field.                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to the token representing */
/*             this field;                       */
/*                                               */
/*             The value, as a char * - this is  */
/*             as for form_new_field below,      */
/*             except for SELECT fields, where   */
/*             it is treated as a pointer to a   */
/*             zero terminated list of bytes     */
/*             where FORM_UNSELCHAR indicates    */
/*             the item is not selected, and     */
/*             FORM_SELCHAR indicates it is      */
/*             selected;                         */
/*                                               */
/*             1 to update (redraw) the token,   */
/*             else 0.                           */
/*************************************************/
d943 21
a963 24
/*************************************************/
/* form_build_selection()                        */
/*                                               */
/* Takes the value of a SELECT field - a list of */
/* items on a menu - which will contain a        */
/* series of FORM_SELCHAR and FORM_UNSELCHAR     */
/* characters, and fills in a given char array   */
/* based on this value.                          */
/*                                               */
/* The first 4 bytes of the value field hold an  */
/* int describing the number of entries in the   */
/* field. 8 bytes in are the SEL or UNSEL chars, */
/* followed immediately by two strings           */
/* describing the menu entry (menu text and the  */
/* field name for form submisson).               */
/*                                               */
/* Parameters: Pointer to the value string;      */
/*                                               */
/*             Pointer to a char array big       */
/*             enough to hold the selection      */
/*             array information (e.g. make it   */
/*             Limits_SelectItems + 1 in size to */
/*             hold selections plus terminator). */
/*************************************************/
d1006 22
a1027 28
/*************************************************/
/* form_new_field()                              */
/*                                               */
/* Add a new field to the last form in the list  */
/* (always the right one due to the sequential   */
/* nature of HTML forms). The value is           */
/* initialised as passed in; for radios and      */
/* checkboxes this is taken to be NULL = not     */
/* selected, otherwise selected. For SELECT      */
/* fields, this is taken as a pointer to the     */
/* value part of the token; this will be         */
/* converted to a zero terminated list of bytes  */
/* where FORM_UNSELCHAR = not selected,          */
/* FORM_SELCHAR = selected.                      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to a token describing the */
/*             new item;                         */
/*                                               */
/*             The field type (see the           */
/*             form_fieldtype definition in      */
/*             Forms.h);                         */
/*                                               */
/*             Value for the field (see          */
/*             comments above).                  */
/*************************************************/
d1156 14
a1169 15
/*************************************************/
/* form_get_field()                              */
/*                                               */
/* Returns the field value for a given forms     */
/* item based on a given token.                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the item for which   */
/*             the field value is required.      */
/*                                               */
/* Returns:    The field value (see Forms.h)     */
/*************************************************/
d1180 25
a1204 28
/*************************************************/
/* form_select_text()                            */
/*                                               */
/* Returns a pointer to a string to use for      */
/* the display component of a SELECT field based */
/* on the what is selected within it.            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the SELECT field;    */
/*                                               */
/*             An array of chars describing the  */
/*             selection, e.g. as filled in by   */
/*             form_build_selection.             */
/*                                               */
/* Returns:    Pointer to the text to use. This  */
/*             may be a text item within the     */
/*             forms item itself or a general    */
/*             response inside the Messages file */
/*             lookup buffer - so if the caller  */
/*             wants to use lookup_token or any  */
/*             function which calls it but must  */
/*             retain the text across the call,  */
/*             that caller must copy the text to */
/*             a private buffer first.           */
/*************************************************/
d1266 15
a1280 15
/*************************************************/
/* form_get_field_text()                         */
/*                                               */
/* Returns the text associated with a given      */
/* forms item (identified by an HStream struct), */
/* taking care of the different types of field.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the field.           */
/*                                               */
/* Returns:    Pointer to the associated text.   */
/*************************************************/
d1328 12
a1339 12
/*************************************************/
/* form_reset_form()                             */
/*                                               */
/* Returns a form to the state it was in when    */
/* fetched, discarding any changes within it.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to an HStream struct that */
/*             identifies the form to reset.     */
/*************************************************/
d1424 17
a1440 19
/*************************************************/
/* form_get_linesize()                           */
/*                                               */
/* On the basis of a font bounding box, return a */
/* baseline offset and line height for a text    */
/* area.                                         */
/*                                               */
/* Parameters: Pointer to a BBox holding the     */
/*             minimum bounding box needed to    */
/*             enclose any char in the font;     */
/*                                               */
/*             Pointer to an int, into which the */
/*             line's height is returned;        */
/*                                               */
/*             Pointer to an int, into which a   */
/*             font baseline offset is returned. */
/*                                               */
/* Assumes:    That the pointers are not NULL.   */
/*************************************************/
d1458 20
a1477 24
/*************************************************/
/* form_textarea_find_caret()                    */
/*                                               */
/* Locates the caret index in the string from    */
/* the x position (in OS units) and y position   */
/* (in lines) relative to the top left of a      */
/* text area.                                    */
/*                                               */
/* Parameters: Pointer to the string inside the  */
/*             text area;                        */
/*                                               */
/*             Font handle used by the area;     */
/*                                               */
/*             Pointer to an int, into which the */
/*             index into the string is written; */
/*                                               */
/*             X offset of caret from top left,  */
/*             in OS units;                      */
/*                                               */
/*             Y offset of caret from top left,  */
/*             in lines.                         */
/*                                               */
/* Assumes:    That the int pointer is not NULL. */
/*************************************************/
d1529 22
a1550 26
/*************************************************/
/* form_textarea_caretpos()                      */
/*                                               */
/* Returns a horizontal offset in OS units and   */
/* (for text areas as opposed to single line     */
/* writables) a vertical offset in lines, at     */
/* which the caret should be placed to be in a   */
/* given index into a given string.              */
/*                                               */
/* Parameters: Pointer to the string;            */
/*                                               */
/*             The RISC OS Font Manager font     */
/*             handle for the font that the text */
/*             is to be rendered in;             */
/*                                               */
/*             Index into the string;            */
/*                                               */
/*             Pointer to an int, into which     */
/*             an offset from the left hand side */
/*             of the text field, in OS units,   */
/*             is placed;                        */
/*                                               */
/*             Pointer to an int, in which an    */
/*             offset in lines from the top of   */
/*             the text field is placed.         */
/*************************************************/
d1606 28
a1633 32
/*************************************************/
/* form_input_box()                              */
/*                                               */
/* Returns information about a given input box   */
/* (writable), if found.                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the field;           */
/*                                               */
/*             Pointer to a BBox which will be   */
/*             filled with the bounding box of   */
/*             the field;                        */
/*                                               */
/*             Pointer to an int, into which the */
/*             line height for the field is      */
/*             written;                          */
/*                                               */
/*             Pointer to an int, into which the */
/*             baseline offset for the field is  */
/*             written;                          */
/*                                               */
/*             Pointer to an int, into which the */
/*             handle of the font used by the    */
/*             field is written.                 */
/*                                               */
/* Returns:    1 if the field was found, else 0. */
/*                                               */
/* Assumes:    None of the pointers may be NULL. */
/*************************************************/
d1709 6
a1714 6
/*************************************************/
/* form_abandon_menu()                           */
/*                                               */
/* Closes a form menu, so that there is no       */
/* currently editing form any more.              */
/*************************************************/
d1738 18
a1755 19
/*************************************************/
/* form_end_edit()                               */
/*                                               */
/* Finishes editing a form, optionally           */
/* discarding changes and moving the input focus */
/* to a general position in the browser.         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             1 to keep changes, else discard;  */
/*                                               */
/*             1 to move the input focus, else   */
/*             leave it alone.                   */
/*                                               */
/* Assumes:    If not moving the input focus,    */
/*             the browser_data pointer may be   */
/*             NULL.                             */
/*************************************************/
d1806 11
a1816 11
/*************************************************/
/* form_create_menu()                            */
/*                                               */
/* Builds and opens a menu for a SELECT field.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the field.           */
/*************************************************/
d2136 13
a2148 13
/*************************************************/
/* form_start_select_edit()                      */
/*                                               */
/* Sets up a form SELECT field as the currently  */
/* editing item within that field, creating and  */
/* opening the associated menu.                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the SELECT field.    */
/*************************************************/
d2162 9
a2170 9
/*************************************************/
/* form_autoscroll()                             */
/*                                               */
/* Scrolls a given browser window to ensure that */
/* the item the caret is in is fully visible.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form.             */
/*************************************************/
d2277 17
a2293 19
/*************************************************/
/* form_start_textarea_edit()                    */
/*                                               */
/* Starts an edit in a given text area (either   */
/* a text area object or a single line writable) */
/* placing the caret in a specified position.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to a token representing   */
/*             the item to edit;                 */
/*                                               */
/*             Position mode for the caret:      */
/*             0 = near mouse,                   */
/*             1 = start of area for text area,  */
/*                 end of line for writable,     */
/*             2 = end of line.                  */
/*************************************************/
d2376 23
a2398 24
/*************************************************/
/* form_check_scroll_field()                     */
/*                                               */
/* For a given text area or single line writable */
/* ensure that the caret is shown at a given x   */
/* and y position, when the line height is lh,   */
/* scrolling the field contents if necessary.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the text field;       */
/*                                               */
/*             Pointer to a BBox holding the     */
/*             window coord bounding box of the  */
/*             text field, *excluding* any       */
/*             borders;                          */
/*                                               */
/*             X offset into field, in OS units, */
/*             for the caret;                    */
/*                                               */
/*             Number of lines below the first   */
/*             one for the caret.                */
/*                                               */
/*             The line height in OS units.      */
/*************************************************/
d2548 14
a2561 16
/*************************************************/
/* form_give_focus()                             */
/*                                               */
/* If the library is editing some forms field,   */
/* and this can take an input focus, give the    */
/* focus to the field and return a success flag. */
/* (Editing is started with form_click_field,    */
/* for example, and ended with form_end_edit).   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the forms item that   */
/*             is to be given the caret.         */
/*                                               */
/* Returns:    1 if the caret is placed in the   */
/*             item, else 0.                     */
/*************************************************/
d2626 13
a2638 13
/*************************************************/
/* form_extend_flex()                            */
/*                                               */
/* Extends a given flex block by a given amount, */
/* returning the offset into the block of the    */
/* new data or -1 to show failure.               */
/*                                               */
/* Parameters: flex_ptr for the flex block;      */
/*             Amount to extend by.              */
/*                                               */
/* Returns:    Offset into the block of the new  */
/*             data, or -1 if the claim failed.  */
/*************************************************/
d2666 22
a2687 26
/*************************************************/
/* form_encode_flex_data()                       */
/*                                               */
/* Encodes the given flex data ready for a form  */
/* submission.                                   */
/*                                               */
/* Spaces, ENCODE_DATASEP, ENCODE_FIELDSEP and   */
/* ENCODE_VALUESEP characters are replaced by    */
/* special alternatives ('+', '?', '&' and '='   */
/* respectively), whilst all other non-          */
/* alphanumeric characters are escaped ('%'      */
/* followed by the ASCII code in hex).           */
/*                                               */
/* Parameters: Pointer to the flex anchor        */
/*             pointing to the data;             */
/*                                               */
/*             Encoding type [not implemented];  */
/*                                               */
/*             Offset in block to start encoding */
/*             at.                               */
/*                                               */
/* Returns:    1 if successful, 0 if failed (for */
/*             example, ran out of memory when   */
/*             extending flex block to hold      */
/*             escaped character sequences).     */
/*************************************************/
d2765 20
a2784 22
/*************************************************/
/* form_field_data_size()                        */
/*                                               */
/* For a given field in a given browser, returns */
/* the total size requirement including name     */
/* and value, ready for encoding a reply to the  */
/* server (so this will consider what particular */
/* value sizes to count if something is selected */
/* or unselected, etc.).                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the field;            */
/*                                               */
/*             Pointer to the form_field struct  */
/*             for the item;                     */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the item.            */
/*                                               */
/* Returns:    Total required memory size needed */
/*             to hold the item.                 */
/*************************************************/
d2902 29
a2930 33
/*************************************************/
/* form_build_data()                             */
/*                                               */
/* Build the data structure for a form in the    */
/* indicated flex block. The token identifies    */
/* the form and if it is a submit token it is    */
/* included in the data structure; other submit  */
/* tokens are not. The flex block does not exist */
/* before calling this routine. The form data    */
/* are encoded according to the specification.   */
/*                                               */
/* If the form METHOD is GET, the URL is         */
/* included as part of this data.                */
/*                                               */
/* x and y are coords for forms submitted by     */
/* INPUT TYPE = IMAGE.                           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the form;            */
/*                                               */
/*             X coord for INPUT TYPE = IMAGE    */
/*             submissions;                      */
/*                                               */
/*             Y coord for INPUT TYPE = IMAGE    */
/*             submissions;                      */
/*                                               */
/*             Pointer to the flex anchor for    */
/*             the flex block in which the data  */
/*             will be built.                    */
/*************************************************/
d3213 22
a3234 23
/*************************************************/
/* form_submission_information()                 */
/*                                               */
/* For a given token within a form, return the   */
/* URL of submission and a flag to say if the    */
/* submission should be done by POST.            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to a token in the form;   */
/*                                               */
/*             Pointer to an int, in which 1 is  */
/*             written if the submission method  */
/*             is POST, 0 is written if it is    */
/*             GET, else the value is unchanged. */
/*                                               */
/* Returns:    Pointer to the URL to submit the  */
/*             form to, or NULL if unknown (also */
/*             see the parameters list).         */
/*                                               */
/* Assumes:    The int pointer may be NULL.      */
/*************************************************/
d3256 15
a3270 17
/*************************************************/
/* form_could_load_text_at_pointer               */
/*                                               */
/* Can a text file be loaded into the forms      */
/* element represented by whatever HStream the   */
/* pointer is over, if this represents such an   */
/* element? If so, try to do this. Return 1 for  */
/* success, 0 for failure.                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             for the browser window the        */
/*             pointer is over;                  */
/*                                               */
/*             Full pathname of the file.        */
/*                                               */
/* Returns:    1 if successful, else 0.          */
/*************************************************/
d3477 14
a3490 16
/*************************************************/
/* form_submit_form()                            */
/*                                               */
/* Submits the contents of a form to a URL       */
/* specified by the given token (usually, the    */
/* token representing the Submit button in the   */
/* form).                                        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to the token which had a  */
/*             front-end representation of       */
/*             itself activated to submit the    */
/*             form.                             */
/*************************************************/
d3605 20
a3624 22
/*************************************************/
/* form_click_field()                            */
/*                                               */
/* Processes a click on a form field.            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form;             */
/*                                               */
/*             Pointer to the token for the item */
/*             that was clicked upon;            */
/*                                               */
/*             Position mode for the caret:      */
/*             0 = near mouse,                   */
/*             1 = start of area for text area,  */
/*                 end of line for writable,     */
/*             2 = end of line for writable, end */
/*                 of all text for text area;    */
/*                                               */
/*             x-coordinate (if input image)     */
/*                                               */
/*             y-coordinate (if input image)     */
/*************************************************/
d3753 10
a3762 11
/*************************************************/
/* form_cancel_edit()                            */
/*                                               */
/* Terminates any editing in the specified       */
/* browser, or all browser forms, discarding any */
/* changes.                                      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form, or NULL to  */
/*             cancel any edits in any browsers. */
/*************************************************/
d3769 10
a3778 11
/*************************************************/
/* form_finish_edit()                            */
/*                                               */
/* Terminates any editing in the specified       */
/* browser, or all browser forms, keeping any    */
/* changes.                                      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the form, or NULL to  */
/*             cancel any edits in any browsers. */
/*************************************************/
d3785 12
a3796 14
/*************************************************/
/* form_button_text()                            */
/*                                               */
/* Returns a pointer to the text that should be  */
/* placed in a given button.                     */
/*                                               */
/* Parameters: Pointer to the token representing */
/*             the button.                       */
/*                                               */
/* Returns:    Pointer to the text that should   */
/*             go in that button, according to   */
/*             whether it is a Submit, Reset, or */
/*             unknown button type.              */
/*************************************************/
d3813 12
a3824 13
/*************************************************/
/* form_cursor_editable()                        */
/*                                               */
/* Returns 1 if the given field can be edited    */
/* via. the keyboard (i.e. it is a password      */
/* field, a single line writable, or a text area */
/* field).                                       */
/*                                               */
/* Parameters: The form_fieldtype of the field.  */
/*                                               */
/* Returns:    1 if this can be edited via. the  */
/*             keyboard, else 0.                 */
/*************************************************/
d3831 14
a3844 15
/*************************************************/
/* form_token_cursor_editable()                  */
/*                                               */
/* Finds out if a given token represents a       */
/* cursor editable forms element.                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the forms;            */
/*                                               */
/*             Pointer to the token.             */
/*                                               */
/* Returns:    1 if the token represents a       */
/*             cursor editable forms element,    */
/*             else 0.                           */
/*************************************************/
d3877 16
a3892 18
/*************************************************/
/* form_next_field()                             */
/*                                               */
/* Moves the editing position on to the next     */
/* editable field in the form. If there is no    */
/* next field, optionally submit the form.       */
/*                                               */
/* Parameters: 1 to automatically submit the     */
/*             form if there are no more         */
/*             editable fields, else 0;          */
/*                                               */
/*             Pointer to an int, into which 0   */
/*             may be written if the keypress    */
/*             ends up in fact not being used    */
/*             for some reason.                  */
/*                                               */
/* Assumes:    The int pointer may be NULL.      */
/*************************************************/
d4044 12
a4055 13
/*************************************************/
/* form_previous_field()                         */
/*                                               */
/* Moves the editing position up to the previous */
/* editable field in the form.                   */
/*                                               */
/* Parameters: Pointer to an int, into which 0   */
/*             may be written if the keypress    */
/*             ends up in fact not being used    */
/*             for some reason.                  */
/*                                               */
/* Assumes:    The int pointer may be NULL.      */
/*************************************************/
d4188 12
a4199 13
/*************************************************/
/* form_cursor_right()                           */
/*                                               */
/* Handles moving the cursor (caret) right in a  */
/* keyboard editable form field.                 */
/*                                               */
/* Parameters: Pointer to an int, into which 0   */
/*             may be written if the keypress    */
/*             ends up in fact not being used    */
/*             for some reason.                  */
/*                                               */
/* Assumes:    The int pointer may be NULL.      */
/*************************************************/
d4238 6
a4243 7
/*************************************************/
/* form_cursor_bottom()                          */
/*                                               */
/* Moves the caret to the bottom right of a      */
/* writable forms item (text area or single line */
/* text fields).                                 */
/*************************************************/
d4268 6
a4273 6
/*************************************************/
/* form_cursor_eol()                             */
/*                                               */
/* Move the cursor to the end of the line in a   */
/* writable forms element.                       */
/*************************************************/
d4302 6
a4307 6
/*************************************************/
/* form_cursor_bol()                             */
/*                                               */
/* Move the cursor to the start of the line in a */
/* writable forms element.                       */
/*************************************************/
d4345 12
a4356 13
/*************************************************/
/* form_cursor_left()                            */
/*                                               */
/* Handles moving the cursor (caret) left in a   */
/* keyboard editable form field.                 */
/*                                               */
/* Parameters: Pointer to an int, into which 0   */
/*             may be written if the keypress    */
/*             ends up in fact not being used    */
/*             for some reason.                  */
/*                                               */
/* Assumes:    The int pointer may be NULL.      */
/*************************************************/
d4391 6
a4396 6
/*************************************************/
/* form_cursor_top()                             */
/*                                               */
/* Moves the caret to the top left of a writable */
/* forms item (text area or single line item).   */
/*************************************************/
d4413 20
a4432 24
/*************************************************/
/* form_cursor_y()                               */
/*                                               */
/* Handles moving the caret up or down between   */
/* editable form elements. If overall keyboard   */
/* control is enabled, this may jump out of the  */
/* form and select objects on the page.          */
/*                                               */
/* Parameters: Direction; negative for up,       */
/*             positive for down, with the       */
/*             number of lines to move found     */
/*             based on the magnitude of the     */
/*             number. For single line items,    */
/*             only the sign is of interest; for */
/*             multiple line items, 1 means '1   */
/*             line', 2 means 'page up/down'.    */
/*                                               */
/*             Pointer to an int, into which 0   */
/*             may be written if the keypress    */
/*             ends up in fact not being used    */
/*             for some reason.                  */
/*                                               */
/* Assumes:    The int pointer may be NULL.      */
/*************************************************/
d4565 14
a4578 14
/*************************************************/
/* form_insert_character()                       */
/*                                               */
/* Inserts a character into the currently        */
/* editing writable / text area.                 */
/*                                               */
/* Parameters: Key code, to give char to insert; */
/*                                               */
/*             Pointer to an int, in which 1 is  */
/*             written if the key press leads to */
/*             an insertion, else 0 is written.  */
/*                                               */
/* Assumes:    The int pointer may not be NULL.  */
/*************************************************/
d4663 8
a4670 10
/*************************************************/
/* form_delete_character()                       */
/*                                               */
/* Deletes a character from the currently        */
/* editing writable / text area, to the left or  */
/* if required to the right.                     */
/*                                               */
/* Parameters: 0 to delete to the left, else     */
/*             delete right.                     */
/*************************************************/
d4724 9
a4732 10
/*************************************************/
/* form_delete_from_caret()                      */
/*                                               */
/* Deletes a chunk of the current line, from the */
/* caret position to its end.                    */
/*                                               */
/* Assumes:    That there is a currently editing */
/*             item, and it's a text area or     */
/*             single line writable.             */
/*************************************************/
d4776 9
a4784 10
/*************************************************/
/* form_delete_line()                            */
/*                                               */
/* Clears the current line of the currently      */
/* editing text item.                            */
/*                                               */
/* Assumes:    That there is a currently editing */
/*             item, and it's a text area or     */
/*             single line writable.             */
/*************************************************/
d4848 17
a4864 18
/*************************************************/
/* form_process_key()                            */
/*                                               */
/* Processes a given key stroke in the context   */
/* of forms handling.                            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the forms;            */
/*                                               */
/*             Pointer to an int in which the    */
/*             Wimp key code should be stored.   */
/*                                               */
/* Returns:    The key code will be set to zero  */
/*             if the key is processed by the    */
/*             function (so that a caller can    */
/*             know if the keypress should be    */
/*             passed on further).               */
/*************************************************/
d4926 30
a4955 35
/*************************************************/
/* form_textarea_redraw()                        */
/*                                               */
/* Redraws the text in a text area object.       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the text area;        */
/*                                               */
/*             Pointer to the token representing */
/*             the text area;                    */
/*                                               */
/*             Pointer to a BBox holding the     */
/*             bounding box of the text area, in */
/*             screen coords (so OS units);      */
/*                                               */
/*             Pointer to a BBox holding the     */
/*             current graphics window (usually  */
/*             from a call to the Wimp to redraw */
/*             something - remember that this    */
/*             can't be read during a printing   */
/*             routine as VDU variables may not  */
/*             be read during printing);         */
/*                                               */
/*             A font handle for the font to use */
/*             for the redraw;                   */
/*                                               */
/*             1 if the text area has multiple   */
/*             lines, 0 to render all text on    */
/*             one line only;                    */
/*                                               */
/*             1 if the text area represents a   */
/*             password object (show the text as */
/*             a line of *s, instead of the      */
/*             actual chars), else 0.            */
/*************************************************/
d5087 8
a5094 8
/*************************************************/
/* form_select_menu_event()                      */
/*                                               */
/* Handles menu selections in SELECT fields.     */
/*                                               */
/* Parameters: Pointer to a WimpPollBlock struct */
/*             describing the selection event.   */
/*************************************************/
d5168 13
a5180 15
/*************************************************/
/* form_check_caret()                            */
/*                                               */
/* Ensure the caret is correctly located in a    */
/* given browser window.                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the window. This may  */
/*             be NULL to ensure it is correct   */
/*             in the currently editing form,    */
/*             else it will check that the given */
/*             browser holds the currently       */
/*             editing form and only check the   */
/*             caret if so.                      */
/*************************************************/
d5203 17
a5219 20
/*************************************************/
/* form_caret_may_need_moving()                  */
/*                                               */
/* Whereas form_check_caret will finish editing  */
/* in a window if the caret can't be placed,     */
/* this function will continue to try placing it */
/* as long as the given browser matches the      */
/* editing browser. This was designed for after  */
/* the reformatter had ben called, to try and    */
/* keep the caret in the window where possible.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the editing token.    */
/*             If there is no form edit going on */
/*             in this window, the function will */
/*             do nothing; otherwise, if there's */
/*             an editing token too, it'll make  */
/*             sure the caret (if any) is        */
/*             correctly positioned.             */
/*************************************************/
@


1.26
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d1165 1
a1165 1
    e = image_new_image(b, HtmlINPUTsrc(token), token, 0);
d3574 16
a3589 5
    if (!e) e = fetchpage_fetch_targetted(b,
                                          data,
                                          HtmlFORMtarget(tp),
                                          NULL,
                                          adj);
d3629 13
a3641 5
    else e = fetchpage_fetch_targetted(b,
                                       HtmlFORMaction(tp),
                                       HtmlFORMtarget(tp),
                                       NULL,
                                       adj);
@


1.25
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d3347 3
a3349 3
         tptr                                  &&
         ISBODY(tptr)                          &&
         (tptr->style & FORM)                  &&
d3351 1
a3351 1
           tptr->tagno == TAG_TEXTAREA ||
d3353 1
a3353 1
             tptr->tagno == TAG_INPUT &&
d3379 1
@


1.24
log
@This is NOT a 'final' version of anything in particular. I'm checking it
in as I'm about to start playing around with low level window handling
(as part of the thing mentioned at the bottom of this log) - this could
screw things up quite badly if it goes wrong! =8*P

Consequently, I advise you not to check this out over your working sources,
and preferably not to check this out at all.

Markers system - events defined in MiscEvents.h will make Browse remember
where it is on the page. This position can be jumped back to later.
Some builds will have defined keyboard shortcuts Ctrl+Shift+F5 through
F8 to set a marker, and Ctrl+F5 through F8 to jump to a marker.

The front-end for the above now has gadgets 0x80 upwards on the Toolbar or
a set of menus (see Menus.h). Noticed an omission in copy_toolaction_info()
(didn't copy the gadget state) in passing; fixed.

browser_top_line() now works properly, as part of the above, but it'll be
slower than before. If flagged to only find a complete line, it'll do just
that, but whereas before this would require any tables that it looked
inside to be wholly visible, tables can now be partially visible and have
lines inside that are fully visible. This should help the Find function
too. There is a new call, browser_top_line_offset, which works as
browser_top_line but also returns a vertical scroll offset in the found
line (used for more accurate marker position). browser_bottom_line[_r]
turn out to never be used, even by the keyboard control routines, so they
have been removed from Browser.c (rather than spend a lot of time and
effort fixing them).

browser_show_token erroneously subtracted 1 from a particular coordinate
when calculating the y scroll position, which could lead to single pixel
page creep using the markers system. Corrected.

The View Resources button (see Toolbars.h) has been finally implemented,
insofar as it fetches the resources file to the current browser page (or
to a new window if Adjust is used, Controls file settings permitting).

menus_toggle_bars did not take account of the toolbar lower window border
edge correctly. It does now.

The reformatter has a prototype system to keep the vertical page position
when reformatting. This was coded about 5 minutes ago, and is not likely
to be reliable...
@
text
@d49 2
d123 47
d1914 4
a1917 2
    /* String length of the menu text, plus terminator, */
    /* plus the menu item structure                     */
d1919 1
a1919 1
    size += strlen(p) + 1 + sizeof(wimp_menuitem);
a1967 1
  mhp->width     = w * 16;  // !! Need to read the font size properly, here.
d1971 23
d2039 2
a2040 1
    /* Copy the item text into the buffer */
d2043 1
d2532 10
a2541 2
      if (dx < 0) r.visible_area.xmax = r.visible_area.xmin - dx;
      else        r.visible_area.xmin = r.visible_area.xmax - dx;
d2555 10
a2564 2
      if (dy < 0) r.visible_area.ymin = r.visible_area.ymax + dy * lh;
      else        r.visible_area.ymax = r.visible_area.ymin + dy * lh;
d3033 1
a3033 1
    /* A GET form  - put the URL in */
d3035 11
a3045 2
    int i;
    int len = strlen(HtmlFORMaction(tp));
d3053 11
a3063 1
    strcpy(*data, HtmlFORMaction(tp));
d3265 1
a3265 1
/* form_submission_details()                     */
d3309 222
d3719 41
d4938 2
a4939 2
      case 8:   /* Ctl+H */        e = form_delete_character(0);           break;
      case 21:  /* Ctl+U */        e = form_delete_line();                 break;
d4958 2
d4964 17
a4980 1
  if (used) *key = 0;
d5052 1
a5052 1
  /* Conver to pixels ready to set a graphics window */
@


1.23
log
@Programming warehouse link removed from all hotlists - the page has gone.

Some compile-time hacks in place to use MemLib, a dynamic area based
malloc replacement which shrinks its heap when possible. All builds
have these switched off at the moment. Seemed to work with just Browse,
though there would be problems with message blocks stored in dynamic
areas because of the Wimp's '&3800000' check - however, it failed when
HTMLLib was made to use it, too. Don't know why yet.

ItemInfo.[c/h] source added, with Res file additions for testbed Browse
and Phoenix.

Small fetch windows now work properly regardless of toolbar settings
in the Choices.

Reload now reloads all images too, rather than only reloading them for
as long as the main page was being fetched.

Added a simple 'Find' facility.

Realised that event handlers in eventlib are called in reverse order
of registration, so the miscellaneous event handler is now registered
first rather than last.

Multiuser code added (most only active if SINGLE_USER is undefined). As
part of this, hotlist code now knows about read-only items (done for the
Customer-style 'Resources' file, but works generally anyway).
handle_add_hotlist doesn't try to save the hotlist itself anymore (the
hotlist_add function does all that through hotlist_modified anyway).

Customer build Choices and Controls updated slightly (e.g. ClaimHelp
off, hotlist to save on quit only).

Customer build now uses Phoenix-style buttons. Sprites files which
worked at the time (but will probably be out of date now) and included
most of the original Customer-style sprites are in
'Utils.Icons.Customer'.

Choices, Messages and Res files for all builds now stripped down to only
single user items or single plus multiuser for Customer build and testbed
build. Before, all contained a few multiuser bits in at least the Choices
file if not more.

Grammatical error ("Fetching frames contents" (sic.)) corrected in
default message, Toolbars.c, and all of the Messages files.

Customer build brought back to a servicable level (including
implementation of the Find dialogue box with animation and fixing
up authorisation and 'Stop' state in the tristate). Quite a few
missing #ifndef REMOTE_HOTLIST bits from hotlist code added...

Customer build will not use <Choices$Write> or Boot:Choices for any
file finding now. UseProxy defaults to 'yes', MaxImages to 2. Res
file includes Proxy Address setting (save_save_choices() now writes
the ProxyAddress line).
@
text
@d141 1
a141 1
//      browser_show_token(fe_browser, fe_token, 0);
@


1.22
log
@*Don't* try to load FilterManager 0.18 in !Run[D] files. Requires
WindowManager 3.98. Sets URI handler environment variables for
http, ftp and gopher.

Fixed 'doesn't reformat for unsized images' bug - only happens when the
deferred reformatter is enabled, hadn't remembered to check this in my
debug build where this is turned off. Oops.

Caret position in forms could get left behind despite attempts to rectify
this in v1.31 - now fixed (and faster, fortunately).

Hourglass + percentage displayed for History and Image History when
loading - it can take a while for very big histories, though in
practice you only see the visit history loading (has to do a lot
more work, and is thus quite a bit slower than the image history).

POST forms worked when targetted to frames, but were broken when
not targetted! (Forms data inherited from one browser to the same
browser; ended up freeing the flex block...). Fixed.

Now support 303 response code (redirect to GET). Treated as 301, i.e.
not support if STRICT_PARSER is defined, otherwise drops through to
the 302 handling code.

Pointer shouldn't get stuck in odd shapes when going to a new page now;
it gets reset to a standard shape every time the null handler that
checks the position is called, though (whether or not the handler thinks
the pointer is over a different token, if that token is NULL, it sets
the standard shape). A possible work around would be for a browser to
remember the pointer shape too; that's for the future, though.

Early stage table formatting functions could blow themselves apart if
tables_count_table decided there were no rows, columns or both. A
net table size of zero cells is now dealt with; slow, partial table
fetches in multiple windows with image loading turned on will now
*hopefully* be stable, where v1.31 would have bombed out repeatedly.

A nested frameset within one document will now inherit the border
width (frame spacing) and border colour of its parent. This is done
by copying the maxlen and indent fields of the parent token over
the child, and note it's done in the browser (fetch_preprocess_token),
not HTMLLib.

Border colour on a FRAMESET now used, with the first colour on any
FRAME within it overriding, as in NN 4 and MSIE 4.

<LI> bullets really do stick to the text next to them now (I'd done
that in an experimental piece of code and forgotten to merge it back
before the last check-in).

Browse$HotlistURL/URIFile and Browse$HomeURL/URIFile now work from
_TaskName in the Messages file, and are thus of the generic form
<App>$HotlistURL etc. - Docs.Notes and Docs.User updated appropriately.

Event 0x11d00 through to 0x11d7f will make the browser look up Controls
file entries 'JumpTo00' through to 'JumpTo7f' and read a URL from them.
This will be fetched in the ancestor window of the source of the event,
or a new window if such an ancestor can't be found [for Daytona demo].

NB: Nasty frames-related crash at http://www.teledanmark.dk/menu/start.htm
is *not* fixed in this source. NOBR is not supported.
@
text
@d3155 44
d3209 4
a3212 3
/*             Pointer to the token with its     */
/*             'anchor' field containing the URL */
/*             to submit the form to.            */
@


1.21
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d55 2
d4834 1
a4834 1
/* form_caret_may_be_moving()                    */
d4839 3
a4841 3
/* as long as the given browser and token match  */
/* the editing browser and token. This was       */
/* designed for the reformat loop, to try and    */
d4845 7
a4851 10
/*             relevant to the editing token;    */
/*                                               */
/*             Pointer to the HStream struct     */
/*             representing the form item being  */
/*             edited - if not such an item, no  */
/*             action will be taken, else if     */
/*             this and the browser match the    */
/*             editing browser and token, the    */
/*             function will try and (re)place   */
/*             the caret on the page.            */
d4854 1
a4854 1
void form_caret_may_be_moving(browser_data * b, HStream * token)
d4856 6
a4861 1
  if (fe_browser && fe_token && b == fe_browser && token == fe_token) form_give_focus(b);
@


1.20
log
@Not all resources are up to date in this check-in, and documentation
both within source and stuff in 'Docs' is out of date or missing - I
was very pushed for time on this one... Hopefully will do another
'tidy up' check-in before close on Friday; until then, beware of
anything other than the Ursula (Desktop browser) build. Anyway...

Export As Draw done. As part of this, FONT SIZE and SUP / SUB adjustment
of font size is done in fm_token_font_info rather than fm_find_token_font.

Bullets and switches are plotted as indirected sprite items, rather than
indirected text + sprite items - this relied on being in a redraw loop to
pick the sprites up from the local pool (failed during printing).

URI files now have a LF line ending rather than CR... '*' recognised
as an empty field when loading via. RAM transfer now (only worked for
loading from disc before).

Gave placeholder bounding boxes 4 OS units more minimum extra gap
vertically and reduced horizontal addition to this value * 1.5, rather
than * 2 (see reformat_get_placeholder_size).

Background image tiling starts at ymax - h + 4, rather than ymax, so
there isn't the bottom line of pixels from the top tile always present
at the top of the window. The '+4' is for caution's sake.

Can now save a frame's HTML source, that of its parent or its ancestor,
and the same for the URI pointing to those documents - see Menus.h for
the relevant component IDs that should lead to the SaveFile dialogue.

Have hopefully fixed timeout = 0 values (i.e. 'forever') on things
like LinkTo; before, image fetches could override the state (so you'd
only ever see brief flickers of a given URL as the pointer went over
a link).

Save File dialogue will remember the state of option or radio buttons
for a given parent component origin and restore that state when the
dialogue is next opened from the same place (stops turning on saving
as a URL file also turning on 'save background images' for Draw file
export, etc.).

Use of a META tag to reload the *same* page now sets the 'reloading'
flag in the browser so that it doesn't go through a proxy - otherwise
pages which are meant to update periodically through client pull
don't work, as they keep coming out of the cache.

Can now handle images specifying just a width or height in the HTML
(other dimension is scaled accordingly, but note that the placeholder
size must still be 'dumb' until the image data comes in). An image
will now override an image history size entry for the same entry
with a different size.
@
text
@d55 1
a55 1
/* Local memory allocaton granularity control */
d76 4
d1003 5
d1014 1
a1014 1
  switch(type)
d1460 1
d1487 1
a1487 1
                      fe_password ? FE_PassCode : p,
d1537 1
d1569 1
a1569 1
                      fe_password ? FE_PassCode : l,
d2251 1
a2251 1
/*             1 = start of line for text area,  */
d2264 5
a2268 3
  /* Cancel any existing edits and set library variables */
  /* to indicate the token and nature of token that is   */
  /* now being edited.                                   */
d2270 2
a2271 2
  e = form_end_edit(b, 1, 0);
  if (e) return e;
d2273 5
a2277 4
  fe_single   = tp->tagno != TAG_TEXTAREA;
  fe_password = tp->tagno == TAG_INPUT && HtmlINPUTtype(tp) == inputtype_PASSWORD;
  fe_browser  = b;
  fe_token    = tp;
d2309 2
a2310 1
      y  = (box.ymax - y) / lh;
d2662 10
a2672 1
         && *p != '_'
d2680 2
a2681 2
      if (*p == '\n') strcpy(code, "%0D%0A");
      else           sprintf(code, "%%%02X", *p);
d2749 1
d2800 1
a2800 1
             s += size + strlen(*q ? q : p) + 1; /* Plus one for & separator */
d2833 1
a2833 1
      /* The size of the button's text */
d2835 1
d2890 1
a2890 1
static _kernel_oserror * form_build_data(browser_data * b, HStream * token, int x, int y, void ** data)
d2898 20
a2917 1
  /* Try to extend the data block as required */
d2919 2
a2920 1
  *data = NULL;
d2922 1
a2922 1
  if (form_extend_flex(data, 1) < 0)
d2927 1
a2927 1
  *(char *) *data = 0;
d2942 2
a2943 2
    int    i;
    char * p;
d2945 2
a2946 1
    i = form_extend_flex(data, strlen(HtmlFORMaction(tp)) + 1);
d2948 1
d2951 1
a2951 1
    p = ((char *) *data) + i - 1;
d2953 1
a2953 1
    strcpy(p, HtmlFORMaction(tp));
d2955 2
a2956 4
    additions_start = ((int) p) - ((int) *data) + strlen(p) + 1;
    p               = strchr(p, 0);
    *p++            = ENCODE_DATASEP;
    *p              = 0;
d3001 1
a3001 1
        offset = form_extend_flex(data, size + (first ? 0 : 1));
d3010 2
a3011 1
        p  = ((char *) *data) + offset - 1;
d3085 1
a3085 1
                strcpy(p, *q ? q : f);
d3106 1
d3142 1
a3142 1
  if (!form_encode_flex_data(data, HtmlFORMenctype(tp), additions_start))
d3170 1
a3170 1
  void            * data;
d3207 1
a3207 1
      flex_free(&data);
d3217 7
a3223 1
    e = form_build_data(b, token, x, y, &b->post_data);
d3275 1
a3275 1
/*             1 = start of line for text area,  */
d3334 19
d3427 1
d3641 1
a3641 1
        return form_click_field(owner, t, 0, 0, 0);
d3663 1
a3663 1
      return form_click_field(fe_browser, next, 0, 0, 0);
d4053 6
a4058 4
/*             number of lines to move as the    */
/*             magnitude of the number. For      */
/*             single line items, only the       */
/*             sign is of interest;              */
d4079 1
a4079 1
    /* For single line items, just look at the relevant direction to move */
d4081 19
a4099 2
    if (fe_single && dir < 0) return form_previous_field(used);
    if (fe_single && dir > 0) return form_next_field(0, used);
d4119 14
a4132 1
    y += dir;
d4134 17
a4150 2
    /* If y < 0, we've dropped over the top of the element so move */
    /* up to the previous field.                                   */
d4152 3
a4154 1
    if (y < 0) return form_previous_field(used);
d4162 16
a4177 3
    /* If the index into the string hasn't changed, then the caret */
    /* must have already been at the end of the text; in this      */
    /* case, move on to the next form element.                     */
d4179 1
a4179 1
    if (o == fe_index) return form_next_field(0, used);
d4530 1
d4533 1
d4592 1
d4683 1
a4683 1
                                       password ? FE_PassCode : p,
d4829 29
@


1.19
log
@Implemented Message_PlugIn_ReshapeRequest, Message_PlugIn_Status and
Message_PlugIn_Busy. Plug-in code more robust when given invalid
browser instance handles by the plug-in.

Line spacing is now calculated on the basis of the normal style base serif
font, with all other fonts being forced into that line height. This does
mean that an unusually tall (say) sans serif font may get clipped. It
appears to be the only way to get around wildly different baseline
depths returned from the font metrics - you can't work out line spacing
based on each different font style; the line spacing will vary.

Table heighting (as opposed to widthing...) improved considerably; rowspan
can no longer cause very tall cells in odd places. Having trouble getting
rid of the single pixel breaks between vertically adjacent cells, though
I've not tried too hard. Widthing, though, seems fairly badly broken at
present... :-/

Set/clear of page_is_text flag made more robust (it looked as though there
was the potential for this to get stuck in a set state, though I've never
see the front-end behave in a manner which indicates this is the case).
The reformatter will now decrease leading if this flag is set (plain text
pages look daft with a line spacing that is OK for 'rich' text pages).
No reformatting is done if the page width changes by dragging on the
resize icon, though toggle size / full screen will still reformat even
if the contents are only text (browser needs to sort out various width
flags at this point).

Cut down on excessive redrawing when reformatting due to a change in
window dimensions is not done. If display_width hasn't changed, then no
redraw is needed. If this causes redraw problems, then whatever is
changing display_width needs investigating. It shouldn't be kludged
(basically) by forcing a redraw instead of a reformat.

TT/PRE/etc. text can now have a non-100% aspect ratio. 80-90% looks
best (ArcWeb, for example, uses 86%). New option 'TTAspect' in
the Choices files.

Debug builds link to a non-debug Unicode library now; stops stderr
being dumped to the bottom left of the screen if you've not redirected
it in the Run file.

RISC OS 3.1 seems to need more initial WimpSlot than later OS versions.
The 64 deep nested table set gives a 'No stack for trap handler' error
(which it really means in this case!) without 800K, even though 3.71
is happy with just 640K. So, the !Run file checks if Boot$OSVersion
is exactly 300, 310 or 311, and sets the WimpSlot accordingly.

!Run[D] files now require latest fetcher module versions (URL 0.21,
File 0.31, HTTP 0.58).
@
text
@a109 2
static char           fe_passcode[] = "****************************************";

d1477 1
a1477 1
                      fe_password ? fe_passcode : p,
d1558 1
a1558 1
                      fe_password ? fe_passcode : l,
d4537 1
a4537 1
      /* the fe_passcode line of asterisks - if a password is being     */
d4544 1
a4544 1
                                       password ? fe_passcode : p,
@


1.18
log
@Image history - sizes of images are remembered for future reference (if
the sizes aren't specified in the HTML, they can be looked for in the
image history instead to minimise reformatting requirements). Choices
file options ImageHistoryPath, ImageExpiryAge, ImageMaxSize and
SaveImageHistory added to support this (all have a direct analogy to
the global History items of the same name after removing 'Image').

Text area items are now the correct height for the number of rows
specified in the HTML, don't scroll a line too early, and have the
caret placed at the start of the text when moved into from above
or at the end when moved into from below (rather than always at
the end, which was behaviour inherited from single line writables,
where this is desirable). The top of the text area is aligned to
the top of any line of text on the same line, with the text area
dropping below the text, rather than the bottom of the area matching
the text baseline and extending upwards.

Filename extensions for download files are only stripped if an
attempt to convert to a RISC OS filetype through the Mime Mapper module
does not return an error or Data (0xffd) filetype. '.cgi' is a special
case which is always stripped.

Altered heading styles - all are bold, none are italic, H3 is as big
as H2 was, H2 is a little larger, and others scale down to H6 being
the size as normal text (but, as I say, bold).

Sorted out tables and forms. We can just look for tagno=TAG_FORM, and
get rid of the wobbly form_flag; also discarded the redundant
reprocess_table flag in fetch_preprocess_token. Two separate forms
in consecutive table cells (for example) which used to fail - they
were submitted as one single form - will now work correctly.

Fixed nasty bug in FontManage.c where font size 7 would intermittently
fail. The stupid font sizes that it could ask the Font Manager for may
be responsible for the occasional Font Manager crashes that have been
noticed. Array for font sizes was declared as [Limits_FontSizes], but
indices 1 to Limits_FontSizes are actually used - so needed a '+ 1'
in the declaration... :-/

Replaced the case insensitive string comparison functions in Utils.c
with more efficient versions by S.Brodie.

MAXLENGTH specifier in INPUT tags is now supported. If unspecified or
specifically zero, the browser overrides and allows any length.
@
text
@d1643 1
a1643 1
  fh = fm_find_token_font(b, tp);
d2075 1
a2075 1
    fh = fm_find_token_font(b, tp);
d4015 1
a4015 1
    fh = fm_find_token_font(fe_browser, tp);
@


1.17
log
@Following the last check-in - all build resources brought up to date.

Adjust-click on forwards/backwards buttons did not work in the intermediate
build, and now does.

Adjust-click on form submission buttons where the submit method is POST
will now work correctly, as the new view inherits the extradata block
of the old. Failure of this is signalled through
make_no_fetch_memory_error, code 16 (see updated Errors file in Docs).
Note the name change of extradata in this context; more details below.

The passing of forms POST data and extra headers for sending in an
HTTP request via. the URL module was all done through pointers into
flex blocks, and was therefore very unsafe. All relevant functions now
use pointers to pointers to the data.

To remove confusion on the umpteen uses of the word 'extradata', the field
in browser_data has been renamed to 'post_data'. The 'extradata' parameters
used within FetchPage.c were all disconnected from the extra header info /
form POST data stuff that extradata is usually associated with, and have
thus also been renamed, in this case to 'appnddata' (Append Data).

As well as X-NoProxy, the browser sends the 'proper' HTTP headers
Pragma:no-cache and Cache-Control:no-cache.

A redirection from a POST request was not handled correctly; despite
what HTTP specs say, you're supposed to use GET for the new URL. The
browser was, but when it chopped off the redundant header data in the
request didn't terminate it and left Content-Type in anyway...! Fixed.

Ctrl+Tab implemented - URL completion. Comes from the hotlist URLs,
hotlist titles, history hosts, paths, full URLs and lastly titles.
See code comments for more (history_find_match, hotlist_find_match).

TableSupport option added to Choices; it is read, can be set by the
front-end, but doesn't actually do anything else yet.

Reversed Choices' semantics on 'don't expire by...' for History. Added
'needs_redraw' flag to choices_get_contents so that, for example, if the
table border types change, browsers get redrawn.
@
text
@d356 1
a356 2
  b->nforms    = 0;
  b->form_flag = 0;
d1664 2
a1665 1
    box->ymax = (box->ymax - box->ymin + 4) * r + box->ymin;
d2337 2
a2338 1
/*             text field;                       */
d2365 1
a2365 1
  t = (box->ymax - box->ymin) / lh; /* Field's height in lines */
d3225 2
a3226 1
/*             2 = end of line.                  */
d3569 1
a3569 1
        return form_click_field(owner, t, 2, 0, 0);
d3591 1
a3591 1
      return form_click_field(fe_browser, next, 2, 0, 0);
d4118 4
@


1.16
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d3164 1
a3164 1
  /* For POST types, must have a URL too, but use the 'extradata' block */
d3170 1
a3170 1
    e = form_build_data(b, token, x, y, &b->extradata);
d3175 1
a3175 1
      if (b->extradata)
d3178 1
a3178 1
          flexcount -= sizeof(&b->extradata);
d3182 1
a3182 1
        flex_free(&b->extradata);
a3183 2

      b->extradata = NULL;
d3194 11
a3204 1
  else bbc_vdu(7);
@


1.15
log
@!Run[D] files updated for new fetchers and GopherFetcher; protocols list
in Controls updated for Gopher. Debug builds now require 2760K rather than
2560K. Font$... variables set if not already, in anticipation of font
Choices work.

Additional bits in Choices section of Res file tidied and some name
changes (e.g. Netscape -> Navigator(TM)). Frames support option added
to Choices.

Grouped 'support_frames' under the Fetch Controls section and added
support_object in Global.h; appropriate entries placed in the Choices
files, and are read at startup. At present, though, only the frames
support flag is implemented.

For some reason, Menu was the button to use on history popups if you
wanted to show URLs instead of descriptions (or vice versa, depending
on Choices settings). Now, Select and Menu will show the Choices
defined setting, and Adjust will show the opposite.

History menus are built backwards, so local histories have the most
recently visited pages at the top. Global history has still no real
order to it, but this may be arranged later.

Customer name changed to Customer by request.

Customer browser now gets its own resources (SYSTEM=Customer), but
otherwise is unchanged, with the Ursula build now giving the
'spinning acorn' with a Bookworm-style toolbar. This is used for the
Desktop !Browse build.

!Sprites[22] files updated to include GIF, JPEG and PNG sprites;
!Run[D] files and !Boot files set appropriate File$Type_xxx variables.
Sprites in all sprites files have been checked for unnecessary palettes,
which have been removed where present.
@
text
@d3127 3
d3146 6
a3151 1
    if (!e) e = fetchpage_new(b, data, 1, 1);
d3187 5
a3191 1
    else e = fetchpage_new(b, HtmlFORMaction(tp), 1, 1);
@


1.14
log
@Added support for HTMLLib HttpEndParse call.

Text items with no VALUE specified in the HTML were not cleared on
hitting a Reset button as the text field of the token is NULL; fixed.
SELECT lists with no default selection item were not being changed
on hitting a Reset button; fixed. In radio groups with no default
selection specified, no item will be selected. This goes against
the HTML 2 spec but allows broken Navigator-esque forms behaviour.
In consequence, radios can be deselected by clicking on the same
one twice. I'd fixed the flickering experienced when doing this
recently, but that, now, is irrelevant, since the state of a radio
must always change.

Reformatter's new 'find width of a SELECT field' didn't account for
the width of <none> and <many> items, and now does (particularly
important for broken items with no OPTION contents).

Under certain circumstances, illegally named targets would open in the
ancestor rather than a new window - a deliberate decision in the code,
but now reversed due to a test suite failure; they'll open in a new
window instead.

Altered the left hand indent handling for lists so that headings and
body text follow the Navigator 48 pixel indent and the bullet point
items drop to the left of the left hand margin, rather than sitting
on the margin with the text indented to the right.

Tightened up the hotlist_load_directory checking of URLs, so that
only those with '://' in - i.e. look fully specified - are accepted.
HTML files are loaded into a new directory now.

Items without a descriptive title in hotlist_new_url will have the URL
substituted in instead. White space before and after descriptions and
after URLs is stripped. Directories with zero length names or null
strings (after white space is stripped) will still be created, with a
generic name (see Messages, token 'HotlistUntitled').
@
text
@d2375 1
a2375 1
    if (y - fe_yscroll > t) dy = (y - t) - fe_yscroll;
@


1.13
log
@Tidied up Hotlist source a bit more, mostly so PSI can use the automatic
StrongHelp generator on it. Revealed a spurious toolbox_hide_object call
that would always fault and never do anything, and a few heinous uses
of show_error which have all been removed.

When dragging hotlist items, directories will now be highlighted whenever
the item would be added to them, rather than just over the sprite. In
practice this only changes if the item is open and has contents...

Drag box selections had broken in the hotlist; fixed (uninitialised
variable in hotlist_select_box). Adjust-drags now close the window on
completion. Minor problem with Shift+Drag (copy) reversing order of items
sorted out. Added hotlist_add_html_file and implemented loading of HTML.
DO NOT add broken HTML files, this has not been coded for and URLs of the
form http:///this/that (no host name) will hang the machine (bug in the
cookie code of the HTTP module up to at least version 0.39).

Made SELECT list items only as wide as the widest entry actually appears
(using fm_get_string_width), rather than as wide as the widest character
BBox in the font multiplied by the string length of the longest entry.

Updated !Run[D] files to require HTTP 0.39, FTP 0.12 and File 0.23.
@
text
@d570 2
a571 2
/* is selected). If none are selected, the       */
/* passed token is selected.                     */
a582 4
/* If the token passed in is selected, it will   */
/* stay selected. This ensures that clicking on  */
/* an already selected radio works.              */
/*                                               */
a670 13
  /* If no items were found selected, find the record for the token */
  /* given tothe function and selected it.                          */

  if (!foundone)
  {
    fp = form_find_record(b, token, 0);
    if (!fp) return NULL;

    fp->value.checked = 1;

    browser_update_token(b, fp->header.token, 0, 0);
  }

d831 1
a831 1
        changed           = ((!!value) != (fp->value.checked));
d842 1
a842 1
        changed           = ((!!value) != (fp->value.checked));
d860 1
a860 1
        value = value ? value : "";
d865 2
a866 2
        o = strchr(fp->value.select.selection, FORM_SELCHAR);
        if (!o) o = fp->value.select.selection;
d884 1
a884 1
        form_validate_select(b, token, o - fp->value.select.selection);
d970 9
a978 8
/* nature of HTML). The value is initialised as  */
/* passed in; for radio and checkbox this is     */
/* taken to be NULL = not selected, otherwise    */
/* selected. For SELECT fields, this is taken as */
/* a pointer to the value part of the token;     */
/* this will be converted to a zero terminated   */
/* list of bytes where FORM_UNSELCHAR = not      */
/* selected, FORM_SELCHAR = selected.            */
d1203 1
a1203 1
    /* Move past the selected/unselected inidicator char */
d1355 1
a1355 1
          value = tp->text;
d2649 1
d3239 1
a3239 1
      /* For check (option) boxes and radios, toggle values as appropriate */
d3241 1
a3241 1
      case form_checkbox: /* same as form_radio: no break */
@


1.12
log
@Now working on source merged with Kevin Bracey's internationalisation
support. UNIFONT is undefined in the Make File for now. All Res and
Choices files updated appropriately.

Having sorted out the old Choices and Messages to form Choices, Controls
and Messages, this build has had the same cleaning up done internally.
This includes greater consistency in naming schemes and the removal of
the inconsitent choices items - e.g. Choices file entries saying 'delay
images' and 'plain backgrounds' where internally all the flags say 'show
images' and 'show backgrounds'. ChoiceDefs.h and CtrlDefs.h added to
clarify the meaning of some fields, though usage of these is not 100%
in the source (there are cases where parameters are passed through to
functions as ints, and those functions still check these against hard
coded values rather than the #define stuff).

Fetcher status return bits (connected, sent request, etc.) now reflected
in status bar. Progress during fetchs to files are reported by %, where
the size of the object is known. Exceeding 100% drops back to a byte
counter, in case the estimated size was wrong. The progress counter
may be updated after specific delays, rather than 'as often as possible',
to reduce flicker (as requested by D.Brown some time ago).

I've done a small rewrite of the fetch prioritisation scheme in FetchPage.c;
how well this performs in general use across different processor speeds
remains to be tested, but certainly it has some advantages. For each small
fetch window before the rewrite, a 4cs tight loop was entered - this gave a
noticable and substantial drain to the Desktop performance if more than one
was opened. Now, several can be up at once with little hit. The actual file
fetch is on half the priority it was before, with all others taken back
just a bit - e.g. from 20cs per poll to 15cs per poll for flat out
reformatting. You don't seem to lose much time on the format in practice,
and the Desktop feels quite a bit lighter at the same time. There's the
potential for smoother frameset loading in this scheme, too.

When Shift+Clicking on a link meant you still fetched inside the main
browser window, several fetches could occur in a frameset - one per frame.
However, now that you can only do this by clicking on a link that leads to
non-displayable data - or by turning off the small fetch windows by
setting UseSmall to 'no' in Choices - a bug where fetchpage_preprocessed
would stop such fetches as new ones were started was revealed.
The API to frames_abort_fetching has now been extended to include a
'stop file spooling too' flag, allowing a fix to be made by having
fetchpage_preprocess's calls not set this (and it doesn't check the
savelink flag is unset before proceeding, since frames_abort_fetching
does that implicitly now).

Had left the RAM transfer buffer at 16 bytes (from testing) accidentally...
Oops. Upped it to 4K. In addition, when loading data by RAM transfer,
the browser didn't notice if a RAMFetch bounced during the transfer. It
would be treated as a 'first' RAMFetch bounce, basically, and try to go to
file transfer - oops. Fixed.
@
text
@d3801 1
a3801 1
    const char *p;
d3827 1
a3827 1
  if(fe_token && fe_browser)
d3829 2
a3830 2
    const char *p;
    int         o;
@


1.11
log
@First a minor warning - the various Res files are out of sync in this build.
Only the Browse resources are currently valid.

Added Utils.Icons - has a few archives inside containing the resources
(well, some of them) used to build various UI sprites for various builds.
Archived because these are unlikely to change much, and putting them on
CVS was a move to, well, archive the stuff...

SaveDBox objects vanquished and requirements in !Run[D] files removed. The
data save code fits much more neatly in amongst the data load protocol
stuff now (with the slight exception of having to split the SaveObject
source into SaveObject and SaveFile - the former handles multiple persistent
dialogues for Shift+Click on links and the like, the latter handles 'one at
a time' transient dialogues for save source and similar). Export Link is now
supported, too, and writes a 'proper' version URI file. You'll find that
double-clicking on old URI files will work as the URI handler picks them up,
whilst new version ones don't; however, dragging onto the browser will only
work with new version files. Note that support for saving and loading URL
files (ANT suite stuff) is present too, so old URI files can be typed as URL
files if you want to keep them working without modification - the URI
handler itself will hopefully support the defined URI file format soon;
double-clicking on old URI files will stop working at that point. Note
there are *lots* of changes in every Res file to support all this. This may
all seem a bit pointless to some, but the changes do in fact make it very
easy to add new save dialogues all over the place. Certainly much easier
than with the previous system, anyway. In fact, post script, image
'save as sprite' took about half an hour, which I hope proves the worth
of the new system.

Merged in newer hotlist code with support for drag cancelling with Escape
(all relevant Res files appropriately updated) and cancelling scrolling
when you've reached the window scroll limit. Had to move some of the
Wimp message handling stuff to the central Protocols source, as clashes
were occuring, and also the hotlist routines were using independent saving
code - a lot of duplicated effort. This was fair enough as at the time the
Hotlist code was written, the Save code couldn't be used in the way it is
now.

New Save Source and Print buttons on the toolbar of some builds.

Phoenix Sprites file made more efficient - the Acorn base section has been
split from the animated upper region. Browse build has a new grey fade
sprite at the back, which is less grainy than the previous one and only
uses 16 colours (with a 16 greyscale palette).

Not really a bug, bug the routine to start an image fetch for INPUT
TYPE=IMAGE forms items only did so if the src field (or equivalent, for
this tag type) was non-NULL. In fact, you should always call image_new_image
and let that handle the rest, otherwise other sections of the code will fail
as they try to obtain an image number for a given HStream and get -1 back.
This problem only generally manifested itself when loading an HTML file to
the browser straight from an application, as many src fields become NULL
when the relativisation routines find nothing to relativise to...

Authentication got broken somewhere along the line - this has been fixed
(in HTMLLib and the browser).

Ctrl+Click on a cross referenced image updates *all* copies, not just the
one with the image data attached.

Next big step: Rip up TBEvents.h and rebuild that whole approach somewhat.
To all those working on the code, my apologies but this means all Res files
will receive a very large number of alterations and there will be extensive
code changes too (mostly naming convention stuff), in more or less all
source files. I am endeavouring to ensure that the new numberspace
convention does not clash with the work being done by Kevin on
internationalisation.
@
text
@d177 1
a177 1
//   if (!fixed.swapbars)
d356 2
a357 2
  b->nforms   = 0;
  b->formflag = 0;
d2167 1
a2167 1
    if (!fixed.swapbars)
d3513 1
a3513 1
  if (choices.keyboardctl && fe_lastkey != akbd_TabK) /* Allow Tab to move between form elements only */
d3583 1
a3583 1
      if (choices.keyboardctl) browser_select_token(fe_browser, next, 0); /* If moving by Tab, make sure the selection keeps up */
d3666 1
a3666 1
  if (choices.keyboardctl && fe_lastkey != akbd_TabK + akbd_Sh) /* Allow Tab to move between form elements only */
d3728 1
a3728 1
      if (choices.keyboardctl) browser_select_token(fe_browser, previous, 0); /* If moving by Tab, make sure the selection keeps up */
d3769 1
a3769 1
    else if (choices.keyboardctl)
d3924 1
a3924 1
    else if (choices.keyboardctl)
@


1.10
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d1120 3
a1122 2
  /* Start an image fetch for these beauties... */
  if (type == form_image && HtmlINPUTsrc(token))
d1124 1
a1124 1
      e = image_new_image(b, HtmlINPUTsrc(token), token, 0);
@


1.9
log
@Very long log entry alert - but hey, beats 'Bug fixed' (sorry, Richard) ;-)

Open URL implementation more or less complete, though may undergo UI
revision at a later date to allow named frames to be targetted. Hope to use
the ideas in this code as the foundation for other general dialogues.

In token stream dump for TRACE builds, table head items were not indented
as far as they should have been - this is fixed; and manual toolbar redraw
routines have been removed. They never worked, were commented out, and
would never be used in that form anyway.

DragBox source added, but it isn't at all complete and won't work - this is
an 'in spare time' thing. We need custom drag boxes constrained to windows
for the hotlist, and unconstrained for frame border resizing... Hey ho.

Ancestor window extents match visible areas if there are frames (no more
scrolling framesets...!). Frame resizing works whilst new documents fetch
without pulling the extent down now. However, frame horizontal extents
never shrink until a reload which is nasty, and this is all due for a
rewrite. Frames border redrawing routine moved out of Redraw.c and into
Frames.c. Bug regarding the mouse rectangle and frame border widths
(rectangle was too large, so you could squash the edges) for edge-drag
frame resizes fixed.

Window width change reformat tolerance fixed; you could creep the window
width down or up forever without any reformat, and centred objects would
move but not be redrawn (thereby giving rise to subsequent redraw errors).

Filetype on objects saved through Shift+Click correct. Save Source dialogue
recognises if that source is plain text, rather than assuming HTML. A
browser that fetches a file remembers the old store size it had before the
save, so even though the data is now ditched, it reports the same amount of
data fetched afterwards (looked awful when this could, for example,
suddenly say '0' after a file save). Progress indicator is now fully aware
of one or many file saves inside a frameset and reports the number of
saves, a colon, and the cumulative saved data count, instead of reporting
the sum total of fetched data in all frames, including non-file save stuff
(note that for just 1 save, '1:' is not shown as a special case for the
most common condition). A bug related to this, where you could in fact only
do one fetch per frame*set*, has been corrected (only one fetch allowed per
frame still, this is unlikely to ever change).

Hotlist support added (D.Brown's source), with various bits of integration
and modification still in progress there. Note additions to the Messages
files. On the subject of Messages, the whole mucky business about what
goes in Messages or Choices (and a few bugs where lookup_choice was used
instead of lookup_token or vice versa) has been sorted out. Messages
contains, more or less, just that. Choices contains user configurable
stuff which generally can't mess things up too badly. A new file, Controls,
is a Messages file holding the non-user configurable choices, which can
generally make things go badly wrong if misused. A lot of these are tied
to the Res file. StrongED users can get these to automatically fold out
the various sections (EMail me for details). Sorry, but at the time of
writing, Zap doesn't do folding... =8*P

Two bugs with images. Asking for images to be shown in browser B when
browser A uses the same ones and was loaded first didn't work correctly,
and now does (a bit weird - browser A does the fetch and browser B does the
display...). Second one occurred when the background image was also used on
the page as a foreground image. This has been fixed by flagging background
images in the image_info structure, and checking this before cross
referencing. This bit also allowed the image_restart_fetches API to be
extended, so that just background or foreground images may be fetched if
they weren't already and the user asked the browser to show them. Before,
the whole lot had to be fetched together (so turning on 'display
backgrounds' will now kick off an image fetch if required, you don't
need to reload the page anymore).

Makefile copy options tweaked to be 'newer' (so if you're testing with some
temporary Choices file or something, it won't write over it at the end of
every export), and REMOTE_HOTLIST flag added for Customer builds - means
the Hotlist.c functions aren't needed; the old, hotlist-by-file method is
used. Added support for Customer build (see later), though there were very
few additions needed in practice.

Table printing fixed - in many ways it wasn't broken, it was image printing
causing the oddities ever since the global image pool was introduced (this
is, again, fixed). The 'reformat to fit page' option didn't work as coded
any more; tables store cell addresses in the HStreams, so you can't then do
a background reformat in a different browser. Hence, it now has to reformat
to the page width, print, then put the page back again, all in the actual
displayed browser. This doesn't feel as slow in use as it perhaps should,
considering what is going on... Note that a line of a defined fraction (see
Print.h) of page height will now split over page boundaries, so tall images
or tall tables don't cause problems now (aside from the obvious problem of
having the line split over a page at all!). There was a bug in the routine
to print from a given start point until 'n' pages had been filled, in that
it always filled 'n + 1' - now fixed. Finally, as part of the printing
tweaks, a new dialogue exists - PrintStyle - with a similarly named source
file added to deal with it.

Global history auto save / load done, but only to the Choices file path -
the whole browser is still strictly single user at present, with all the
extra work for a multiuser Customer environment yet to be done. This has
shown up a global history corruption problem which I haven't fixed yet.

Rationalising TBEvents.h - things are migrating out of it, and into more
appropriate sources (e.g. definitions relating to the Open URL dialogue are
going into OpenURL.h, etc.). Event codes were at one stage deliberately
diverged in numberspace from the component IDs of typical gadgets raising
the events, to avoid anyone getting confused and thinking the IDs and event
codes must match. However, this is in fact unlikely and it is much easier
to remember the fewer numbers that result from tying the two together where
possible. This has resulted in changes to event codes raised in the
following objects of all Res files: Authorise, Find, OpenURL, and
PrintStyle.

And finally - !Run[D] files for all variants updated to require the latest
toolbox and fetcher modules. All Res files updated for hotlists etc. and
sprites files updated appropriately. All Messages, Choices and Controls
files brought in sync., and an Customer build has been added (based on the
Desktop build binary with different resources).

That's all for now...
@
text
@d276 1
a276 5
    if (!ok)
    {
      make_no_cont_memory_error(2);
      return &erb;
    }
d1893 1
a1893 6

  if (!fe_menu)
  {
    make_no_cont_memory_error(3);
    return &erb;
  }
d2773 1
a2773 1
        /* For select fields,return the menu item name if one is */
d2893 1
a2893 2
    make_no_cont_memory_error(4);
    return &erb;
d2916 1
a2916 5
    if (i < 0)
    {
      make_no_cont_memory_error(5);
      return &erb;
    }
d2972 1
a2972 5
        if (offset < 0)
        {
          make_no_cont_memory_error(6);
          return &erb;
        }
d3111 1
a3111 2
    make_no_cont_memory_error(7);
    return &erb;
@


1.8
log
@Modified to cope with withdrawal of #defines SELECT, INPUT etc.
Added right-align support.
@
text
@d2814 1
a2814 1
        int len;
d2821 2
a2822 1
        /* Add in length of the two coordinates */
d3369 1
a3369 1
  if (!p) p = "Unknown:Action";
@


1.7
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@d1678 1
a1678 1
  if (tp->style & TEXTAREA)
d2286 2
a2287 2
  fe_single   = !(tp->style & TEXTAREA);
  fe_password = (tp->style & INPUT) && HtmlINPUTtype(tp) == inputtype_PASSWORD;
d4049 1
a4049 1
    if (tp->style & TEXTAREA) form_textarea_find_caret(p, fh, &fe_index, x, y);
@


1.6
log
@Quite a few general source changes throughout many files to sort out swapped
toolbars. There will be more work on this shortly. svcprint.c has been
modified to allow it to output to a file in PipeFS, so TML-less machines
can still use the standard browser debug routines (albeit in a less than
elegant fashion). Comments in that source file give more details. Plus a
few more bug fixes.
@
text
@d17 1
d19 1
d22 2
a23 1
/* History: 28-Jan-97: Created                     */
a64 2
#define MAXSELECTIONS          1024 /* Max entries in a SELECT field */

d71 1
a71 1
/* Miscellaneous definitions */
d112 4
a115 4
static wimp_menustr * fe_menu       = NULL; /* The current form menu for SELECTs       */
static browser_data * fe_mbrowser   = NULL; /* Browser we clicked menu on for SELECTs  */
static HStream      * fe_mtoken     = NULL; /* Token we clicked menu on for SELECTs    */
static int            fe_lastkey    = 0;    /* Last key run through form_process_key() */
d789 1
a789 1
/*             as for form_new_field() below,    */
d941 1
a941 1
/*             MAXSELECTIONS + 1 in size, to     */
d957 1
a957 1
  if (n > MAXSELECTIONS) n = MAXSELECTIONS;
d1020 1
a1020 1
  char              select[MAXSELECTIONS + 1];
d1206 1
a1206 1
  if (n > MAXSELECTIONS) n = MAXSELECTIONS;
d1339 1
a1339 1
    char         select[MAXSELECTIONS + 1];
a1423 2
/* Returns:    See parameters list.              */
/*                                               */
a1541 2
/*                                               */
/* Returns:    See parameters list.              */
d1853 1
a1853 1
  if (n > MAXSELECTIONS) n = MAXSELECTIONS;
d2264 1
a2264 1
/*             Position mode for the caret -     */
d2814 4
a2817 1
        char tempbuf[32];
d2819 1
a2819 3
         /* We've already added up length of "name=", this gives us */
         /* length of "name.x=&name.y="                             */
        size = (size+2) * 2 + 1;
d2822 6
a2827 1
        size += sprintf(tempbuf, "%u%u", x, y);
d3232 1
a3232 1
/*             Position mode for the caret -     */
d4238 3
a4240 3
/* Assumes: That there is a currently editing    */
/*          item, and it's a text area or single */
/*          line writable.                       */
d4291 3
a4293 3
/* Assumes: That there is a currently editing    */
/*          item, and it's a text area or single */
/*          line writable.                       */
d4601 1
a4601 1
    char                      select[MAXSELECTIONS + 1];
@


1.5
log
@Checking in mostly because its Friday... Quite a few little bug fixes
(adding up to a greater whole), which include removal of the dastardly
'invalid image number' errors that trace builds would raise from time to
time. Frame highlights are now better controlled (releaseably so).
Generally, this build represents the first genuinely promising version
of the browser for quite some time, despite the known library problems
with comment handling etc.
@
text
@d164 1
a164 1
//   int                     ymin, ymax, lh, lb, fh;
d176 15
a190 1
//   ymax = coords_y_toworkarea(state.visible_area.ymax - toolbars_button_height(b) - toolbars_url_height(b) - 4,
d193 1
a193 1
//   ymin = coords_y_toworkarea(state.visible_area.ymin + toolbars_status_height(b) + 4,
d2164 1
d2178 16
a2193 2
    box.ymax -= (toolbars_url_height(b) + toolbars_button_height(b));
    box.ymin += toolbars_status_height(b);
@


1.4
log
@Made INPUT type=image work
@
text
@d345 2
a346 1
  b->nforms = 0;
d3143 1
a3143 1
    if (!e) e = fetchpage_new(b, data, 1);
d3179 1
a3179 1
    else e = fetchpage_new(b, HtmlFORMaction(tp), 1);
d3508 3
a3510 5
    b = fe_browser;
    t = fe_token;

    ancestor = b->ancestor;
    if (!ancestor) ancestor = b;
d3661 3
a3663 5
    b = fe_browser;
    t = fe_token;

    ancestor = b->ancestor;
    if (!ancestor) ancestor = b;
@


1.3
log
@In the middle of customer support work.
@
text
@d45 1
d486 1
a486 1
  if (tp->type & TYPE_MULTIPLE) return NULL;
d588 1
a588 1
  char        * name;
d605 1
a605 1
  name       = token->name;
d630 1
a630 1
      if (name && tp->name && !strcmp(name, tp->name))
d929 1
a929 1
static void form_build_selection(char * value, char * selection)
d936 2
a937 3
  p  = value;
  n  = *(int *) p;
  p += 8;
d1023 1
a1023 1
      form_build_selection(value, select);
d1108 6
d1175 4
a1178 3
  int       i, n, s;
  char    * p;
  char    * f;
d1185 4
a1188 4
  p  = tp->value;
  n  = *(int *) p;
  p += 8;
  f  = p;
d1203 1
a1203 1
      f = p;
d1367 1
a1367 1
          value = (char *) (tp->type & TYPE_CHECKED);
d1375 1
a1375 1
          form_build_selection(tp->value, select);
d1454 1
a1454 1
static void form_textarea_find_caret(char * p, int fh, int * index, int x, int y)
d1532 1
a1532 1
static void form_textarea_caretpos(char * p, int fh, int index, int * x, int * y)
d1534 3
a1536 3
  int    ox, oy, i, li;
  char * t;
  char * l;
d1805 1
d1828 2
a1829 2
  p    = tp->value;
  n    = *(int *) p;
d1845 1
a1845 1
  p += 8;
d1904 1
a1904 1
  strncpy(mhp->title, tp->name, 12);
d1924 1
a1924 1
  p = tp->value + 8;
d2260 1
a2260 1
  fe_password = (tp->type & TYPE_RESET) == TYPE_PASSWORD;
d2624 1
a2624 1
static int form_encode_flex_data(void ** data, char * enctype, int start_at)
d2713 1
a2713 1
static int form_field_data_size(browser_data * b, form_field * fp, HStream * tp)
d2719 1
a2719 1
  if (tp->name)
d2721 1
a2721 1
    size = strlen(tp->name) + 1; /* add one for the ' = ' sign */
d2742 2
a2743 2
          if (tp->value) size += strlen(tp->value);
          else           size += 2;
d2760 2
a2761 2
        n = *(int *) tp->value;
        p = tp->value + 8;
d2783 1
a2783 1
      // Image button types not supported yet...
d2787 8
a2794 1
        size = 0;
d2810 2
a2811 2
        if (tp->value) size += strlen(tp->value);
        else           size  = 0;
d2835 1
a2835 1
/* INPUT TYPE = IMAGE [not implemented].         */
d2844 1
a2844 1
/*             submissions [not implemented];    */
d2847 1
a2847 1
/*             submissions [not implemented];    */
d2930 1
a2930 1
         tp->name                                                      &&
d2940 1
a2940 1
      size = form_field_data_size(b, fp, tp);
d2973 1
a2973 1
        strcpy(p, tp->name);
d2999 2
a3000 2
            if (tp->value) strcpy(p, tp->value);
            else           strcpy(p, "on");
d3011 2
a3012 2
            n     = *(int *) tp->value;
            f     = tp->value + 8;
d3028 1
a3028 1
                  strcpy(p, tp->name);
d3053 2
a3054 1
            // Not implemented yet
d3070 1
a3070 1
            if (tp->value) strcat(p, tp->value);
d3093 1
a3093 1
  if (!form_encode_flex_data(data, tp->enctype, additions_start))
d3120 1
a3120 1
static _kernel_oserror * form_submit_form(browser_data * b, HStream * token)
d3141 1
a3141 1
    e = form_build_data(b, token, 0, 0, &data); // 0, 0 need filling in for INPUT TYPE = IMAGE
d3161 1
a3161 1
    e = form_build_data(b, token, 0, 0, &b->extradata); // 0, 0 need filling in for INPUT TYPE = IMAGE
d3204 4
d3210 1
a3210 1
_kernel_oserror * form_click_field(browser_data * b, HStream * token, int mode)
a3248 4
      // Images not implemented yet

      case form_image:    break;

d3251 1
d3255 1
a3255 1
        e = form_submit_form(b, token);
d3326 1
a3326 1
char * form_button_text(HStream * tp)
d3328 1
a3328 1
  char * p;
d3330 1
a3330 1
  p = tp->value;
d3332 2
a3333 2
  if (!p && ((tp->type & TYPE_RESET) == TYPE_SUBMIT)) p = lookup_token("Submit:Submit",0,0);
  if (!p && ((tp->type & TYPE_RESET) == TYPE_RESET))  p = lookup_token("Reset:Reset",  0,0);
d3485 1
a3485 1
    if (auto_submit) return (form_submit_form(fe_browser, fe_token));
d3548 1
a3548 1
        return form_click_field(owner, t, 2);
d3570 1
a3570 1
      return form_click_field(fe_browser, next, 2);
d3695 1
a3695 1
        return form_click_field(owner, t, 2);
d3717 1
a3717 1
      return form_click_field(fe_browser, previous, 2);
d3744 1
a3744 1
    char * p;
d3789 1
a3789 1
    char *p;
d3817 2
a3818 2
    char *p;
    int  o;
d3851 2
a3852 2
    char * p;
    int    o;
d3982 3
a3984 3
    char    * p;
    int       o, x, y, fh;
    HStream * tp;
d4583 1
a4583 1
    n  = *(int *) tp->value;
d4598 1
a4598 1
    if (tp->type & TYPE_MULTIPLE)
@


1.2
log
@Changed FORM handling to process HTMLLib tokens using new interface.
@
text
@d2868 1
a2868 1
  if (HtmlFORMmethod(tp)==formmethod_GET && HtmlFORMaction(tp))
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d2868 1
a2868 1
  if ((tp->type & TYPE_GET) && tp->anchor)
d2875 1
a2875 1
    i = form_extend_flex(data, strlen(tp->anchor) + 1);
d2885 1
a2885 1
    strcpy(p, tp->anchor);
d3123 1
a3123 1
  if ((tp->type & TYPE_GET) && tp->anchor)
d3143 1
a3143 1
  else if ((tp->type & TYPE_POST) && tp->anchor)
d3162 1
a3162 1
    else e = fetchpage_new(b, tp->anchor, 1);
@

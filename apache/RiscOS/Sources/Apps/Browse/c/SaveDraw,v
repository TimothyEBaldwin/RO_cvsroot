head	1.8;
access;
symbols
	Browse-2_16:1.8
	Browse-2_15:1.8
	Browse-2_14:1.8
	Browse-2_13:1.8
	Browse-2_12:1.8
	Browse-2_11:1.7
	Browse-2_10:1.7
	Browse-2_09:1.7
	ahodgkin_208_i4_2:1.6
	ahodgkin_208_i4:1.4
	ahodgkin_208_i3:1.4
	ahodgkin_208_i2:1.4
	ahodgkin_208_i1:1.4
	ahodgkin_207release:1.3
	ahodgkin_206release:1.3
	ahodgkin_205release:1.2
	ahodgkin_204release:1.2
	ahodgkin_202release:1.2
	ahodgkin_201release:1.2
	ahodgkin_200release:1.2
	ahodgkin_133beta:1.2
	ahodgkin_132beta:1.2
	ahodgkin_131beta:1.2
	ahodgkin_130beta:1.1;
locks; strict;
comment	@# @;


1.8
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.26.09.42.34;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.14.08.45.08;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.31.15.58.46;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	99.03.30.15.52.02;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	98.07.09.10.27.24;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	98.01.31.10.55.32;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.12.18.10.07.08;	author ahodgkin;	state Exp;
branches;
next	;


desc
@@


1.8
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    SaveDraw.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Save a web page as a Draw file.                   */
/*                                                            */
/* Author:  A.D.Hodgkinson, including various functions from  */
/*          original Customer browser by Merlyn Kline.       */
/*                                                            */
/* History: 13-Nov-1997 (ADH): Created.                       */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>
#include <tboxlibs/flex.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include "Global.h"
#include "FromROSLib.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "CSIM.h"
#include "Fetch.h" /* (Which itself includes URLstat.h) */
#include "FileTypes.h"
#include "FontManage.h"
#include "Forms.h"
#include "Frames.h"
#include "Images.h"
#include "Object.h"
#include "Printing.h" /* Only for the PrintSplitFraction definition at present */
#include "PrintStyle.h"
#include "Redraw.h"
#include "RedrawCore.h"
#include "Reformat.h"
#include "Save.h"
#include "Scale.h"
#include "Tables.h"
#include "TokenUtils.h"
#include "Toolbars.h"

#ifdef UNIFONT
  #include <Unicode/iso10646.h>
  #include "Unifont.h"
#endif

#include "SaveDraw.h"

/* Local definitions */

#define DRAWMARGIN 0

/* Local statics */

static FILE * outfile = NULL;

/* Static function prototypes */

static _kernel_oserror * savedraw_rectangle_fill   (int x, int y, int w, int h, unsigned int c);
static _kernel_oserror * savedraw_triangle_fill    (int x1, int y1, int x2, int y2, int x3, int y3, unsigned int c);
static _kernel_oserror * savedraw_create           (browser_data * b, int bgimages, int * size);

/* Saved clipping rectangle information (in user-points, */
/* screen origin).                                       */

static const browser_data * clipping_browser = NULL;
static BBox                 clipping_rectangle;

/* Draw output redraw primitives */

static _kernel_oserror * savedraw_jmptbl_line
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict ends,
                           unsigned int                  colour,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savedraw_jmptbl_rectangle
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict rect,
                           unsigned int                  colour,
                           unsigned int                  border,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savedraw_jmptbl_triangle
                         (
                           const browser_data * restrict b,
                           int                           x1,
                           int                           y1,
                           int                           x2,
                           int                           y2,
                           int                           x3,
                           int                           y3,
                           unsigned int                  colour,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savedraw_jmptbl_text
                         (
                           const browser_data * restrict b,
                           fm_face                       handle,
                           int                           x,
                           int                           y,
                           const char         * restrict string,
                           unsigned int                  numbytes,
                           unsigned int                  fgcolour,
                           unsigned int                  bgcolour,
                           unsigned int                  blend,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savedraw_jmptbl_image
                         (
                           const browser_data * restrict b,
                           unsigned int                  image,
                           int                           x,
                           int                           y,
                           unsigned int                  width,
                           unsigned int                  height,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savedraw_jmptbl_sprite
                         (
                           const browser_data * restrict b,
                           const char         * restrict name,
                           int                           x,
                           int                           y,

                           size_t             * restrict r_size
                         );

static _kernel_oserror * savedraw_jmptbl_clipping
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict desired,

                           size_t             * restrict r_size
                         );

/* Draw output redraw table */

static redrawcore_function_table_t rtable_drawfile =
                                   {
                                     savedraw_jmptbl_line,
                                     savedraw_jmptbl_rectangle,
                                     savedraw_jmptbl_triangle,
                                     NULL, /* Don't need circles - used for debug only */

                                     savedraw_jmptbl_text,

                                     savedraw_jmptbl_image,
                                     savedraw_jmptbl_sprite,

                                     savedraw_jmptbl_clipping,

                                     NULL, /* Not interested in sections/anchors/links */
                                     NULL,
                                     NULL
                                   };

/**************************************************************/
/* savedraw_write_bytes()                                     */
/*                                                            */
/* Outputs a given number of bytes of a given string to the   */
/* FILE * set up in the global 'outfile', returning a success */
/* flag.                                                      */
/*                                                            */
/* Parameters: Pointer to an array of bytes;                  */
/*                                                            */
/*             Number of characters from the array to save.   */
/*                                                            */
/* Returns:    1 if successful, 0 if failed.                  */
/*                                                            */
/* Assumes:    An appropriately opened file is accessible     */
/*             through the global FILE * 'outfile'.           */
/**************************************************************/

_kernel_oserror * savedraw_write_bytes(const char * restrict s, size_t n)
{
  size_t written;

  if (!s || !outfile) return NULL;

  written = fwrite(s, sizeof(*s), n, outfile);

  if (written != n) return _kernel_last_oserror();
  else              return NULL;
}

/**************************************************************/
/* savedraw_rectangle_fill()                                  */
/*                                                            */
/* Output a filled rectangle.                                 */
/*                                                            */
/* Parameters: x position of the item in Draw coordinates;    */
/*                                                            */
/*             y position of the item in Draw coordinates;    */
/*                                                            */
/*             Item's width in Draw coordinates;              */
/*                                                            */
/*             Item's height in Draw coordinates;             */
/*                                                            */
/*             Colour of the rectangle.                       */
/**************************************************************/

static _kernel_oserror * savedraw_rectangle_fill(int x, int y, int w, int h, unsigned int c)
{
  draw_pathstrhdr * ph;
  int             * i;
  char              d[DSIZE_FRECT];

  if (w <= 0 || h <= 0)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      StrNCpy0(erb.errmess,
               "Rectangle width or height is zero in savedraw_rectangle_fill, so no object written out - if calculating file size, the value will be incorrect.");

      show_error_ret(&erb);

    #endif

    return NULL;
  }

  /* We'll compile the structure in 'd' */

  ph = (draw_pathstrhdr *) d;

  /* Fill in the header items */

  ph->tag                   = draw_OBJPATH;
  ph->size                  = DSIZE_FRECT;

  ph->bbox.xmin             = x;
  ph->bbox.xmax             = x + w;
  ph->bbox.ymin             = y;
  ph->bbox.ymax             = y + h;

  ph->fillcolour            = c;
  ph->pathcolour            = -1;
  ph->pathwidth             = 0;

  ph->pathstyle.joincapwind = 0;
  ph->pathstyle.reserved8   = 0;
  ph->pathstyle.tricapwid   = 0;
  ph->pathstyle.tricaphei   = 0;

  /* Now do the body */

  i = (int *) (d + sizeof(draw_pathstrhdr));

  *i++ = draw_PathMOVE;
  *i++ = x;
  *i++ = y;

  *i++ = draw_PathLINE;
  *i++ = x;
  *i++ = y + h - 1;

  *i++ = draw_PathLINE;
  *i++ = x + w - 1;
  *i++ = y + h - 1;

  *i++ = draw_PathLINE;
  *i++ = x + w - 1;
  *i++ = y;

  *i++ = draw_PathLINE;
  *i++ = x;
  *i++ = y;

  *i++ = draw_PathTERM;

  return savedraw_write_bytes(d, sizeof(d));
}

/**************************************************************/
/* savedraw_triangle_fill()                                   */
/*                                                            */
/* Output a filled triangle.                                  */
/*                                                            */
/* Parameters: x and y coordinates of the three vertices, in  */
/*             Draw coordinates;                              */
/*                                                            */
/*             Colour of the triangle.                        */
/**************************************************************/

static _kernel_oserror * savedraw_triangle_fill(int x1, int y1, int x2, int y2, int x3, int y3, unsigned int c)
{
  draw_pathstrhdr * ph;
  int             * i;
  char              d[DSIZE_FTRIA];

  /* We'll compile the structure in 'd' */

  ph = (draw_pathstrhdr *) d;

  /* Fill in the header items */

  ph->tag                   = draw_OBJPATH;
  ph->size                  = DSIZE_FTRIA;


  if (x1 < x2) ph->bbox.xmin = x1, ph->bbox.xmax = x2;
  else         ph->bbox.xmin = x2, ph->bbox.xmax = x1;
  if (y1 < y2) ph->bbox.ymin = y1, ph->bbox.ymax = y2;
  else         ph->bbox.ymin = y2, ph->bbox.ymax = y1;

  if (x3 < ph->bbox.xmin) ph->bbox.xmin = x3;
  if (y3 < ph->bbox.ymin) ph->bbox.ymin = y3;
  if (x3 > ph->bbox.xmax) ph->bbox.xmax = x3;
  if (y3 > ph->bbox.ymax) ph->bbox.ymax = y3;

  ph->fillcolour            = c;
  ph->pathcolour            = -1;
  ph->pathwidth             = 0;

  ph->pathstyle.joincapwind = 0;
  ph->pathstyle.reserved8   = 0;
  ph->pathstyle.tricapwid   = 0;
  ph->pathstyle.tricaphei   = 0;

  /* Now do the body */

  i = (int *) (d + sizeof(draw_pathstrhdr));

  *i++ = draw_PathMOVE;
  *i++ = x1;
  *i++ = y1;

  *i++ = draw_PathLINE;
  *i++ = x2;
  *i++ = y2;

  *i++ = draw_PathLINE;
  *i++ = x3;
  *i++ = y3;

  *i++ = draw_PathLINE;
  *i++ = x1;
  *i++ = y1;

  *i++ = draw_PathTERM;

  return savedraw_write_bytes(d, sizeof(d));
}

/**************************************************************/
/* savedraw_jmptbl_line()                                     */
/*                                                            */
/* Veneer function for the redraw table. Writes a Draw file   */
/* converting user-points to Draw units.                      */
/*                                                            */
/* Parameters: See redraw_line_fn_ptr_t, RedrawCore.h.        */
/*                                                            */
/* Returns:    See redraw_line_fn_ptr_t, RedrawCore.h.        */
/**************************************************************/

static _kernel_oserror * savedraw_jmptbl_line
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict ends,
                           unsigned int                  colour,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    BBox              draw;
    draw_pathstrhdr * ph;
    int             * i;
    char              d[DSIZE_FLINE];

    scale_box_user_to_draw(b, ends, &draw);

    /* We'll compile the structure in 'd' */

    ph = (draw_pathstrhdr *) d;

    /* Fill in the header items */

    ph->tag                   = draw_OBJPATH;
    ph->size                  = DSIZE_FLINE;

    if (draw.xmin < draw.xmax) ph->bbox.xmin = draw.xmin, ph->bbox.xmax = draw.xmax;
    else                       ph->bbox.xmax = draw.xmin, ph->bbox.xmin = draw.xmax;

    if (draw.ymin < draw.ymax) ph->bbox.ymin = draw.ymin, ph->bbox.ymax = draw.ymax;
    else                       ph->bbox.ymax = draw.ymin, ph->bbox.ymin = draw.ymax;

    ph->fillcolour            = -1;
    ph->pathcolour            = colour;
    ph->pathwidth             = scale_user_to_draw(b, scale_os_to_user(b, 1)); /* 2 OS units looks too think, so use 1 instead */

    ph->pathstyle.joincapwind = 0;
    ph->pathstyle.reserved8   = 0;
    ph->pathstyle.tricapwid   = 0;
    ph->pathstyle.tricaphei   = 0;

    /* Now do the body */

    i = (int *) (d + sizeof(draw_pathstrhdr));

    *i++ = draw_PathMOVE;
    *i++ = draw.xmin;
    *i++ = draw.ymin;

    *i++ = draw_PathLINE;
    *i++ = draw.xmax;
    *i++ = draw.ymax;

    *i++ = draw_PathTERM;

    return savedraw_write_bytes(d, sizeof(d));
  }
  else
  {
    *r_size = DSIZE_FLINE;
    return NULL;
  }
}

/**************************************************************/
/* savedraw_jmptbl_rectangle()                                */
/*                                                            */
/* Veneer function for the redraw table. Writes a Draw file   */
/* converting user-points to Draw units.                      */
/*                                                            */
/* Parameters: See redraw_rectangle_fn_ptr_t, RedrawCore.h.   */
/*                                                            */
/* Returns:    See redraw_rectangle_fn_ptr_t, RedrawCore.h.   */
/**************************************************************/

static _kernel_oserror * savedraw_jmptbl_rectangle
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict rect,
                           unsigned int         colour,
                           unsigned int         border,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    BBox         draw;
    unsigned int width, height;

    scale_box_user_to_draw(b, rect, &draw);

    width  = draw.xmax - draw.xmin;
    height = draw.ymax - draw.ymin;

    if (border != 0)
    {
      unsigned int thickness = scale_user_to_draw(b, border);

      if (thickness == 0) thickness = 1;

      RetError(savedraw_rectangle_fill(draw.xmin,             draw.ymin,             width,     thickness, colour));
      RetError(savedraw_rectangle_fill(draw.xmin,             draw.ymin,             thickness, height,    colour));
      RetError(savedraw_rectangle_fill(draw.xmin,             draw.ymax - thickness, width,     thickness, colour));
      return   savedraw_rectangle_fill(draw.xmax - thickness, draw.ymin,             thickness, height,    colour);
    }
    else
    {
      return   savedraw_rectangle_fill(draw.xmin, draw.ymin, width, height, colour);
    }
  }
  else
  {
    if (border != 0) *r_size = DSIZE_FRECT * 4;
    else             *r_size = DSIZE_FRECT;

    return NULL;
  }
}

/**************************************************************/
/* savedraw_jmptbl_triangle()                                 */
/*                                                            */
/* Veneer function for the redraw table. Writes a Draw file   */
/* converting user-points to Draw units.                      */
/*                                                            */
/* Parameters: See redraw_triangle_fn_ptr_t, RedrawCore.h.    */
/*                                                            */
/* Returns:    See redraw_triangle_fn_ptr_t, RedrawCore.h.    */
/**************************************************************/

static _kernel_oserror * savedraw_jmptbl_triangle
                         (
                           const browser_data * restrict b,
                           int                           x1,
                           int                           y1,
                           int                           x2,
                           int                           y2,
                           int                           x3,
                           int                           y3,
                           unsigned int                  colour,

                           size_t             * restrict r_size
                         )
{
  if (r_size == NULL)
  {
    int draw_x1, draw_y1;
    int draw_x2, draw_y2;
    int draw_x3, draw_y3;

    scale_pair_user_to_draw(b, x1, y1, &draw_x1, &draw_y1);
    scale_pair_user_to_draw(b, x2, y2, &draw_x2, &draw_y2);
    scale_pair_user_to_draw(b, x3, y3, &draw_x3, &draw_y3);

    return savedraw_triangle_fill(draw_x1,
                                  draw_y1,
                                  draw_x2,
                                  draw_y2,
                                  draw_x3,
                                  draw_y3,
                                  colour);
  }
  else
  {
    *r_size = DSIZE_FTRIA;
    return NULL;
  }
}

/**************************************************************/
/* savedraw_jmptbl_text()                                     */
/*                                                            */
/* Veneer function for the redraw table. Writes a Draw file   */
/* converting user-points to Draw units.                      */
/*                                                            */
/* Parameters: See redraw_text_fn_ptr_t, RedrawCore.h.        */
/*                                                            */
/* Returns:    See redraw_text_fn_ptr_t, RedrawCore.h.        */
/**************************************************************/

static _kernel_oserror * savedraw_jmptbl_text
                         (
                           const browser_data * restrict b,
                           fm_face                       handle,
                           int                           x,
                           int                           y,
                           const char         * restrict string,
                           unsigned int                  numbytes,
                           unsigned int                  fgcolour,
                           unsigned int                  bgcolour,
                           unsigned int                  blend,

                           size_t             * restrict r_size
                         )
{
  int  mp_width;
  int  user_height, user_width;
  int  user_leeway;

  /* Always work with length-limited output herein */

  if (numbytes == 0) numbytes = strlen(string);

  /* Clipping rectangles can be a small amount out and still look  */
  /* OK in Draw files, so give some leeway for text that might not */
  /* otherwise be output because it is deemed to spill beyond the  */
  /* clipping rectangle. This can happen because of rounding down  */
  /* in the scaling system meeting accurate height values below.   */

  user_leeway = scale_millipoints_to_user(b, scale_os_to_user(b, 2));

  /* Get the height as accurately as we can */

  if (fm_system_font())
  {
    BBox os_font;

    RetError(fm_font_box(handle, &os_font));
    user_height = scale_os_to_user(b, os_font.ymax - os_font.ymin);
  }
  else
  {
    struct
    {
      int x_spc_off;
      int y_spc_off;
      int x_ltr_off;
      int y_ltr_off;
      int split;
      int xmin;
      int ymin;
      int xmax;
      int ymax;
    }
    params;

    params.x_spc_off = 0;
    params.y_spc_off = 0;
    params.x_ltr_off = 0;
    params.y_ltr_off = 0;
    params.split     = -1;
    params.xmin      = 0;
    params.ymin      = 0;
    params.xmax      = 0;
    params.ymax      = 0;

    /* For outline fonts use a more accurate routine to find the */
    /* height of this *specific* string in millipoints.          */

    RetError(_swix(Font_ScanString,
                   _INR(0,7),

                   handle, string,
                   FM_GivenHandle | FM_Kern | (1u<<5) | (1u<<18), /* Bit 5 -> block given in R5; bit 18 -> return bounding box in R5 block */
                   Reformat_AsWideAsPossible_MP,
                   Reformat_AsWideAsPossible_MP,
                   &params, NULL,
                   numbytes));

    user_height = scale_millipoints_to_user(b, params.ymax - params.ymin);

    if (user_height <= 0)
    {
      BBox os_font;

      RetError(fm_font_box(handle, &os_font));
      user_height = scale_os_to_user(b, os_font.ymax - os_font.ymin);
    }
  }

  /* Now get the string width */

  RetError(fm_get_string_width(handle,
                               string,
                               Reformat_AsWideAsPossible_MP,
                               numbytes,
                               -1,
                               NULL,
                               &mp_width));

  user_width = scale_millipoints_to_user(b, mp_width);

  /* Do we have to worry about a clipping rectangle? */

  if (clipping_browser == b)
  {
    /* If the text won't fit in vertically, can't output anything - */
    /* Draw doesn't do clipping.                                    */
    /*                                                              */
    /* This output routine never expects to be asked to plot text   */
    /* with the left hand coordinate outside of the clipping area - */
    /* since it would take a lot of work to start moving along the  */
    /* input string, advancing the start coordinate with each       */
    /* character and seeing if we were in the clipping area yet, we */
    /* don't bother. It's not worth writing code that at the time   */
    /* of writing would never run.                                  */

    if (
         y               < clipping_rectangle.ymin - user_leeway ||
         y + user_height > clipping_rectangle.ymax + user_leeway ||
         x               < clipping_rectangle.xmin - user_leeway
       )
    {
      if (r_size != NULL) *r_size = 0;
      return NULL;
    }

    /* We may well get text that's too long to fit in the region,  */
    /* though. Keep chopping off characters until it fits if so... */

    while (
            x + user_width >= clipping_rectangle.xmax + user_leeway &&
            --numbytes > 0
          )
    {
      RetError(fm_get_string_width(handle,
                                   string,
                                   Reformat_AsWideAsPossible_MP,
                                   numbytes,
                                   -1,
                                   NULL,
                                   &mp_width));

      user_width = scale_millipoints_to_user(b, mp_width);
    }

    if (x + user_width > clipping_rectangle.xmax + user_leeway)
    {
      if (r_size != NULL) *r_size = 0;
      return NULL;
    }
  }

  /* The text should fit with 'numbytes' possibly adjusted now. */
  /* Make sure no trailing CR/LF is included.                   */

  while (numbytes > 0 && string[numbytes - 1] < ' ') numbytes--;

  if (numbytes == 0)
  {
    if (r_size != NULL) *r_size = 0;
    return NULL;
  }

  /* Allow for a terminating NUL byte */

  numbytes += 1;

  if (r_size == NULL)
  {
    draw_trfmtextstrhdr hdr;
    int                 draw_x, draw_y, draw_width, draw_height;
    int                 index, mp_sizex, mp_sizey;
    char                null = '\0';

    scale_pair_user_to_draw(b, x,          y,           &draw_x,     &draw_y);
    scale_pair_user_to_draw(b, user_width, user_height, &draw_width, &draw_height);

    if (fm_system_font())
    {
      index = 0;
    }
    else
    {
      index = fm_find_font_index_by_handle(handle, &mp_sizex, &mp_sizey);
      index++; /* Means returning -1 for problems -> 0 -> system font */
    }

    /* "62" is to convert 16ths of a point into millipoints (1000/16=62) */

    if (index == 0)
    {
      if (fm_system_font())
      {
        mp_sizex = FM_System_Size_X(handle) * 62;
        mp_sizey = FM_System_Size_Y(handle) * 62;
      }
      else
      {
        index    = 1;
        mp_sizex = choices.font_size * 62;
        mp_sizey = choices.font_size * 62;
      }
    }
    else
    {
      mp_sizex *= 62;
      mp_sizey *= 62;
    }

    /* Construct the header */

    hdr.tag                  = draw_OBJTEXTTRFM;
    hdr.size                 = sizeof(draw_trfmtextstrhdr) + (int) WordAlign(numbytes);
    hdr.bbox.xmin            = draw_x;
    hdr.bbox.xmax            = draw_x + draw_width;
    hdr.bbox.ymin            = draw_y;
    hdr.bbox.ymax            = draw_y + draw_height;
    hdr.matrix[0]            = 0x10000;
    hdr.matrix[1]            = 0;
    hdr.matrix[2]            = 0;
    hdr.matrix[3]            = 0x10000;
    hdr.matrix[4]            = 0;
    hdr.matrix[5]            = 0;
    hdr.fontflags            = SaveDraw_FontFlags_Kerned;
    hdr.textcolour           = fgcolour;
    hdr.background           = bgcolour;
    hdr.textstyle.fontref    = index;
    hdr.textstyle.reserved8  = 0;
    hdr.textstyle.reserved16 = 0;
    hdr.fsizex               = scale_user_to_draw(b, scale_millipoints_to_user(b, mp_sizex));
    hdr.fsizey               = scale_user_to_draw(b, scale_millipoints_to_user(b, mp_sizex));

    if (fm_system_font()) hdr.fsizex /= 2;

    hdr.coord.x              = draw_x;
    hdr.coord.y              = draw_y;

    /* Write the header */

    RetError(savedraw_write_bytes((char *) &hdr, sizeof(hdr)));

    /* Write the text itself */

    RetError(savedraw_write_bytes(string,  numbytes - 1));
    RetError(savedraw_write_bytes(&null, 1));

    if (numbytes != (int) WordAlign(numbytes))
    {
      RetError(savedraw_write_bytes("    ", (int) WordAlign(numbytes) - numbytes));
    }
  }
  else
  {
    *r_size = sizeof(draw_trfmtextstrhdr) + (int) WordAlign(numbytes);
  }

  return NULL;
}

/**************************************************************/
/* savedraw_jmptbl_image()                                    */
/*                                                            */
/* Veneer function for the redraw table. Writes a Draw file   */
/* converting user-points to Draw units.                      */
/*                                                            */
/* Parameters: See redraw_image_fn_ptr_t, RedrawCore.h.       */
/*                                                            */
/* Returns:    See redraw_image_fn_ptr_t, RedrawCore.h.       */
/**************************************************************/

static _kernel_oserror * savedraw_jmptbl_image
                         (
                           const browser_data * restrict b,
                           const unsigned int            image,
                           int                           x,
                           int                           y,
                           unsigned int                  width,
                           unsigned int                  height,

                           size_t             * restrict r_size
                         )
{
  draw_spristrhdr h;
  size_t          size;

  RetError(image_to_draw_file(b,
                              outfile,
                              image,
                              width,
                              height,
                              &size));

  /* Calculate total size */

  if (size != 0)
  {
    h.size = sizeof(h) + (int) WordAlign(size);

    if (r_size != NULL)
    {
      *r_size = h.size;
      return NULL;
    }
  }
  else
  {
    if (r_size != NULL) *r_size = 0;
    return NULL;
  }

  /* Output the image */

  h.tag       = draw_OBJSPRITE;
  h.bbox.xmin = x;
  h.bbox.ymin = y;
  h.bbox.xmax = x + width;
  h.bbox.ymax = y + height;

  scale_box_user_to_draw(b, &h.bbox, &h.bbox);

  if (size > 0)
  {
    RetError(savedraw_write_bytes((char *) &h, sizeof(h)));
    RetError(image_to_draw_file(b,
                                outfile,
                                image,
                                width,
                                height,
                                NULL));
  }

  /* Ensure 4-byte alignment after sprite data */

  if (size != (int) WordAlign(size))
  {
    RetError(savedraw_write_bytes("    ", (int) WordAlign(size) - size));
  }

  return NULL;
}

/**************************************************************/
/* savedraw_jmptbl_sprite()                                   */
/*                                                            */
/* Veneer function for the redraw table. Writes a Draw file   */
/* converting user-points to Draw units.                      */
/*                                                            */
/* Parameters: See redraw_sprite_fn_ptr_t, RedrawCore.h.      */
/*                                                            */
/* Returns:    See redraw_sprite_fn_ptr_t, RedrawCore.h.      */
/**************************************************************/

static _kernel_oserror * savedraw_jmptbl_sprite
                         (
                           const browser_data * restrict b,
                           const char         * restrict name,
                           int                           x,
                           int                           y,

                           size_t             * restrict r_size
                         )
{
  draw_spristrhdr   h;
  sprite_header   * sh;
  int               asize = 0;
  int               wid, hei;

  h.tag = draw_OBJSPRITE;

  /* Find the sprite block and its dimensions */

  RetError(_swix(OS_SpriteOp,
                 _INR(0,2) | _OUT(2),

                 280,
                 sprite_block,
                 name,

                 &sh));

  RetError(utils_read_sprite_size(name, &wid, &hei));

  asize  = sh->next + sizeof(h);
  h.size = (int) WordAlign(asize);

  if (r_size == NULL)
  {
    x = scale_user_to_draw(b, x);
    y = scale_user_to_draw(b, y);

    h.bbox.xmin = x;
    h.bbox.ymin = y;
    h.bbox.xmax = h.bbox.xmin + scale_user_to_draw(b, scale_os_to_user(b, wid));
    h.bbox.ymax = h.bbox.ymin + scale_user_to_draw(b, scale_os_to_user(b, hei));

    RetError(savedraw_write_bytes((char *) &h, sizeof(h)));
    RetError(savedraw_write_bytes((char *) sh, asize - sizeof(h)));

    /* Align to a 4-byte boundary using spaces */

    if (asize != h.size)
    {
      return savedraw_write_bytes("    ", h.size - asize);
    }
  }
  else *r_size = h.size;

  return NULL;
}

/**************************************************************/
/* savedraw_jmptbl_clipping()                                 */
/*                                                            */
/* Veneer function for the redraw table. Writes a Draw file   */
/* converting user-points to Draw units.                      */
/*                                                            */
/* Parameters: See redraw_clipping_fn_ptr_t, RedrawCore.h.    */
/*                                                            */
/* Returns:    See redraw_clipping_fn_ptr_t, RedrawCore.h.    */
/**************************************************************/

static _kernel_oserror * savedraw_jmptbl_clipping
                         (
                           const browser_data * restrict b,
                           const BBox         * restrict desired,

                           size_t             * restrict r_size
                         )
{
  /* Must record the clipping region whether or not we're */
  /* just calculating sizes as the amount of data output  */
  /* by, say, the text routine, depends on the clipping   */
  /* rectangle.                                           */

  clipping_browser   = b;
  clipping_rectangle = *desired;

  if (r_size != NULL) *r_size = 0;

  return NULL;
}

/**************************************************************/
/* savedraw_create()                                          */
/*                                                            */
/* Output a Draw file representing the contents of a given    */
/* browser, or find out how big the file would be. The static */
/* 'outfile' local to this file should hold a valid FILE * to */
/* output to in the first case.                               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct to represent  */
/*             in the Draw file;                              */
/*                                                            */
/*             1 to include any background image present on   */
/*             the browser's page, else 0;                    */
/*                                                            */
/*             Pointer to an int to take the file size if     */
/*             that's all you want, or NULL to actually       */
/*             output the file.                               */
/**************************************************************/

static _kernel_oserror * savedraw_create(browser_data * b, int bgimages, int * size)
{
  WimpRedrawWindowBlock   r;
  _kernel_oserror       * e;
  HStream               * selected;
  int                     tsize = 0; /* Total size */
  int                     height;
  draw_fileheader         h;

  /* Compile a pseudo-redraw block for the Draw file, */
  /* in screen coordinates.                           */

  height = reformat_return_extent(b, b->cell);
  if (height < b->display_height) height = b->display_height;

  r.visible_area.xmin = r.redraw_area.xmin = 0;
  r.visible_area.ymin = r.redraw_area.ymin = 0;
  r.visible_area.xmax = r.redraw_area.xmax = b->display_extent;
  r.visible_area.ymax = r.redraw_area.ymax = height;

  r.window_handle = b->window_handle;
  r.xscroll       = 0;
  r.yscroll       = 0;

  /* If required, write the Draw file header */

  tsize += DSIZE_FRECT; /* Background */

  if (size)
  {
    tsize = sizeof(h);
  }
  else
  {
    /* Draw file ID */

    strncpy(h.title, "Draw", sizeof(h.title));

    /* Draw file version */

    h.majorstamp = 201;
    h.minorstamp = 0;

    /* Program name - we do not rely on a field immediately */
    /* after 'progident' to take a string terminator here.  */

    strncpy(h.progident, program_name, sizeof(h.progident));

    if (strlen(program_name) < sizeof(h.progident))
    {
      int i = strlen(program_name);
      int j = sizeof(h.progident) - i;

      while (j) h.progident[i++] = ' ', j--;
    }

    /* Whole file's bounding box */

    h.bbox.xmin = DRAWMARGIN     + OTD(r.redraw_area.xmin);
    h.bbox.ymin = DRAWMARGIN     + OTD(r.redraw_area.ymin);
    h.bbox.xmax = DRAWMARGIN * 2 + OTD(r.redraw_area.xmax);
    h.bbox.ymax = DRAWMARGIN * 2 + OTD(r.redraw_area.ymax);

    RetError(savedraw_write_bytes((char *) &h, sizeof(h)));
  }

  /* Unless we're in system font, list the fonts used */

  if (!fm_system_font())
  {
    int  f, i, b, n;
    char fontname[Limits_FontName];
    int  fsize;

    fsize = 8;

    for (f = 0; f < 12; f++) /* 12 faces */
    {
      n = f / 4;        /* Internal font number     */
      i = (f % 4) & 1;  /* Italic flag, lsb (bit 0) */
      b = (f % 4) >> 1; /* Bold flag, bit 1         */

      e = fm_write_name(n, fontname, i, b);
      if (e) show_error_ret(e);

      fsize += strlen(fontname) + 2;
    }

    /* If required, write the header out */

    if (size)
    {
      tsize += (int) WordAlign(fsize);
    }
    else
    {
      *(int*) fontname       = draw_OBJFONTLIST;
      *(int*) (fontname + 4) = (int) WordAlign(fsize);

      RetError(savedraw_write_bytes(fontname, 8));

      for (f = 0; f < 12; f++) /* 12 faces */
      {
        n = f / 4;        /* Internal font number     */
        i = (f % 4) & 1;  /* Italic flag, lsb (bit 0) */
        b = (f % 4) >> 1; /* Bold flag, bit 1         */

        e = fm_write_name(n, fontname + 1, i, b);
        if (e) show_error_ret(e);

        fontname[0] = f + 1;

        RetError(savedraw_write_bytes(fontname, strlen(fontname + 1) + 2));
      }

      /* Word align the file contents */

      if (fsize != (int) WordAlign(fsize))
      {
        RetError(savedraw_write_bytes("    ", (int) WordAlign(fsize) - fsize));
      }
    }
  }

  /* Don't want the selection highlight appearing in the output */

  selected    = b->selected;
  b->selected = NULL;

  /* Set up the DrawFile redraw output table */

  redrawcore_replace_table(&rtable_drawfile);

  /* Count sizes only? */

  if (size != NULL)  redrawcore_count_sizes();

  /* Do the redraw */

  e = redraw_draw(b, &r, NULL, !bgimages, NULL);

  /* Get the size count (errors or otherwise)? */

  if (size != NULL) tsize += redrawcore_return_count();

  /* Restore the old table */

  redrawcore_default_table();

  /* Restore the selection highlight */

  b->selected = selected;

  /* Finished - return the size or any errors */

  if (e != NULL)
  {
    if (size) *size = 0;
    return e;
  }
  else
  {
    if (size) *size = tsize;
    return NULL;
  }
}

/**************************************************************/
/* savedraw_save_draw()                                       */
/*                                                            */
/* Save a given browser page as a Draw file.                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to save as a Draw file;               */
/*                                                            */
/*             Pointer to the pathname to save to;            */
/*                                                            */
/*             1 to include background image tiling if there  */
/*             is such an image, else 0 (0 recommended!).     */
/**************************************************************/

_kernel_oserror * savedraw_save_draw(browser_data * b, const char * pathname, int bgimages)
{
  /* If we seem to have left a file open, close it */

  if (outfile)
  {
    fclose(outfile);
    outfile = NULL;
  }

  /* Only proceed if we've got a pathname */

  if (pathname && *pathname)
  {
    _kernel_oserror * e;

    _swix(Hourglass_On, 0);

    save_record_path(pathname);

    /* Open the file */

    outfile = fopen(pathname, "wb");

    if (!outfile) RetLastE;

    /* Create the file */

    e = savedraw_create(b, bgimages, NULL);

    fclose(outfile);
    outfile = NULL;

    _swix(Hourglass_Off, 0);

    if (e != NULL) return e;

    /* Set the filetype */

    return _swix(OS_File,
                 _INR(0,2),

                 18,
                 pathname,
                 FileType_DRAW);
  }

  return NULL;
}

/**************************************************************/
/* savedraw_draw_size()                                       */
/*                                                            */
/* Returns the size of file that would be written by          */
/* savedraw_save_draw for the given browser.                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to save as a Draw file, for which the */
/*             file size is to be returned;                   */
/*                                                            */
/*             1 to include background image tiling in the    */
/*             count if there is such an image, else 0.       */
/*                                                            */
/* Returns:    Size of file that would be written by          */
/*             savedraw_save_draw for the given browser.      */
/**************************************************************/

unsigned int savedraw_draw_size(browser_data * b, int bgimages)
{
  /* This works but is very slow, almost doubling the time taken */
  /* to write the file. Images are particularly painful. Since   */
  /* the function is only used for messages returning sizes and  */
  /* nobody seems to care if the size is a default 4K, the code  */
  /* is commented out for now (when last tested, it worked OK).  */

//  int size;
//
//  _swix(Hourglass_On, 0);
//  savedraw_create(b, bgimages, &size);
//  _swix(Hourglass_Off, 0);
//
//  return size;

  return 4096;
}
@


1.7
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d20 1
a20 1
/* Purpose: Save a web page as text.                          */
d61 1
d64 1
d86 110
a195 11
static int  savedraw_triangle_fill    (int x1, int y1, int x2, int y2, int x3, int y3, unsigned int c);
static void savedraw_font_info        (HStream * t, int * number, int * size);
static int  savedraw_input_field      (browser_data * b, HStream * t, BBox * box, unsigned int colour, int menu, int * size);
static int  savedraw_button           (browser_data * b, HStream * t, BBox * box, int in, int * size);
static int  savedraw_switch           (int x, int y, char * spr, int * size);
static int  savedraw_texthdr          (browser_data * b, HStream * tp, int x, int y, int w, int h, int base, unsigned int length, unsigned int bgnd);
static int  savedraw_draw_placeholder (browser_data * b, WimpRedrawWindowBlock * r, BBox * holder, HStream * token, const char * text, int * size);
static int  savedraw_textarea_redraw  (browser_data * b, HStream * token, BBox *box, BBox *gw, int fh, int multiline, int password, int * size);

static int  savedraw_create           (browser_data * b, int bgimages, int * size);
static int  savedraw_create_r         (int toplevel, int xorg, int yorg, browser_data * b, reformat_cell * d, int noback, WimpRedrawWindowBlock * r, int bgimages, int * size, int * tsize);
d214 1
a214 1
int savedraw_write_bytes(const char * s, unsigned int n)
d216 1
a216 3
  _kernel_swi_regs r;

  if (!s || !outfile) return 0;
d218 1
a218 2
  /* Use _kernel_swi as it sets up */
  /* _kernel_last_oserror.         */
d220 1
a220 4
  r.r[0] = 2;
  r.r[1] = outfile->__file;
  r.r[2] = (int) s;
  r.r[3] = n;
d222 2
a223 3
  if (!r.r[1] || _kernel_swi(OS_GBPB, &r, &r)) return 0;

  return 1;
d242 1
a242 1
int savedraw_rectangle_fill(int x, int y, int w, int h, unsigned int c)
d261 1
a261 1
    return 1;
a263 6
  /* To ensure the lines are visible, should round x and y */
  /* to a multiple of 2 OS units.                          */

  x = x & ~(OTD(2) - 1);
  y = y & ~(OTD(2) - 1);

d310 1
d327 1
a327 1
static int savedraw_triangle_fill(int x1, int y1, int x2, int y2, int x3, int y3, unsigned int c)
d381 1
d388 1
a388 3
/* savedraw_font_info()                                       */
/*                                                            */
/* Find details of the font a token would use.                */
d390 2
a391 2
/* Parameters: Pointer to the HStream struct relevant to the  */
/*             enquiry;                                       */
d393 1
a393 3
/*             Pointer to an int, in which the number of the  */
/*             font (from the Draw file's font table) is      */
/*             returned;                                      */
d395 1
a395 4
/*             Pointer to an int, in which the font size in   */
/*             16ths pt. is written.                          */
/*                                                            */
/* Assumes:    Neither int pointer may be NULL.               */
d398 8
a405 1
static void savedraw_font_info(HStream * t, int * number, int * size)
d407 6
a412 3
  int f, i, b;

  /* Find details of the font in use */
d414 1
a414 1
  fm_token_font_info(t, &f, size, &i, &b);
d416 1
a416 2
  /* Convert the given face, italic and bold flags into a font number */
  /* for the Draw file                                                */
d418 1
a418 1
  *number = (f * 4 + (i ? 1 : 0) + (b ? 2 : 0) + 1);
d420 1
a420 1
  /* Finished */
d422 2
a423 2
  return;
}
d425 2
a426 28
/**************************************************************/
/* savedraw_input_field()                                     */
/*                                                            */
/* For forms, create an input field element.                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the element;                                   */
/*                                                            */
/*             Pointer to the token representing this         */
/*             element;                                       */
/*                                                            */
/*             BBox of the field, in window coords (and thus  */
/*             OS units);                                     */
/*                                                            */
/*             Border colour (as a palette entry, for more    */
/*             details see redraw_set_colour());              */
/*                                                            */
/*             1 if this is a display field, i.e. it has a    */
/*             menu icon, and the border colour is ignored,   */
/*             else 0;                                        */
/*                                                            */
/*             Pointer to an int if wanting to know the size  */
/*             of the item only, else NULL (NB the int        */
/*             contents are not updated - the pointer is      */
/*             acting like a flag, basically).                */
/*                                                            */
/* Returns:    Size of item written out, or 0 if it failed.   */
/**************************************************************/
d428 2
a429 4
static int savedraw_input_field(browser_data * b, HStream * t, BBox * box, unsigned int colour, int menu, int * size)
{
  int w, h;
  int tsize;
d431 3
a433 2
  w = box->xmax - box->xmin;
  h = box->ymax - box->ymin;
d435 4
a438 4
  if (menu)
  {
    int  sw;
    BBox shorter;
d440 1
a440 1
    shorter = *box;
d442 1
a442 1
    if (read_sprite_size("fgright", &sw, NULL)) sw = 44;
d444 3
a446 1
    shorter.xmax -= (sw + 8);
d448 3
a450 1
    if (shorter.xmax < shorter.xmin) shorter.xmax = shorter.xmin + sw;
d452 1
a452 1
    /* Redraw the display region as a slabbed button */
d454 1
a454 1
    return savedraw_button(b, t, &shorter, 2, size);
d458 2
a459 17
    /* Redraw the inside in white */

    tsize = DSIZE_FRECT;

    if (!savedraw_rectangle_fill(OTD(box->xmin), OTD(box->ymin), OTD(w), OTD(h), Redraw_Colour_White)) return 0;

    /* Redraw the border */

    tsize += DSIZE_FRECT * 4;

    if (!size)
    {
      if (!savedraw_rectangle_fill(OTD(box->xmin),     OTD(box->ymin),     OTD(4),     OTD(h), colour)) return 0;
      if (!savedraw_rectangle_fill(OTD(box->xmax - 4), OTD(box->ymin),     OTD(4),     OTD(h), colour)) return 0;
      if (!savedraw_rectangle_fill(OTD(box->xmin + 4), OTD(box->ymin),     OTD(w - 8), OTD(4), colour)) return 0;
      if (!savedraw_rectangle_fill(OTD(box->xmin + 4), OTD(box->ymax - 4), OTD(w - 8), OTD(4), colour)) return 0;
    }
a460 2

  return tsize;
d464 1
a464 9
/* savedraw_button()                                          */
/*                                                            */
/* For forms, redraws a button element.                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the element;                                   */
/*                                                            */
/*             Pointer to the token representing this         */
/*             element;                                       */
d466 2
a467 2
/*             BBox of the field, in window coords (and thus  */
/*             OS units);                                     */
d469 1
a469 3
/*             1 to be slabbed in, 2 to be slabbed in but     */
/*             with a light grey background rather than dark, */
/*             else 0;                                        */
d471 1
a471 6
/*             Pointer to an int if wanting to know the size  */
/*             of the item only, else NULL (NB the int        */
/*             contents are not updated - the pointer is      */
/*             acting like a flag, basically).                */
/*                                                            */
/* Returns:    Size of item written out, or 0 if it failed.   */
d474 9
a482 1
static int savedraw_button(browser_data * b, HStream * t, BBox * box, int in, int * size)
d484 4
a487 2
  int w, h, c;
  int tsize;
d489 1
a489 2
  w = box->xmax - box->xmin;
  h = box->ymax - box->ymin;
d491 2
a492 1
  c = (in == 1) ? Redraw_Colour_MidGrey : Redraw_Colour_BackGrey;
d494 3
a496 1
  tsize = DSIZE_FRECT;
d498 1
a498 1
  if (!size && !savedraw_rectangle_fill(OTD(box->xmin), OTD(box->ymin), OTD(w), OTD(h), c)) return 0;
d500 11
a510 5
  tsize += DSIZE_FRECT * 4;

  c = in ? Redraw_Colour_PlinthGrey : Redraw_Colour_AlmostWhite;

  if (!size)
d512 2
a513 9
    if (!savedraw_rectangle_fill(OTD(box->xmin),     OTD(box->ymin),     OTD(2),     OTD(h),     c)) return 0;
    if (!savedraw_rectangle_fill(OTD(box->xmin + 2), OTD(box->ymin + 2), OTD(2),     OTD(h - 2), c)) return 0;
    if (!savedraw_rectangle_fill(OTD(box->xmin + 4), OTD(box->ymax - 2), OTD(w - 4), OTD(2),     c)) return 0;
    if (!savedraw_rectangle_fill(OTD(box->xmin + 4), OTD(box->ymax - 4), OTD(w - 6), OTD(2),     c)) return 0;
  }

  tsize += DSIZE_FRECT * 4;

  c = in ? Redraw_Colour_AlmostWhite : Redraw_Colour_PlinthGrey;
d515 1
a515 6
  if (!size)
  {
    if (!savedraw_rectangle_fill(OTD(box->xmin + 2), OTD(box->ymin),     OTD(w - 2), OTD(2),     c)) return 0;
    if (!savedraw_rectangle_fill(OTD(box->xmin + 4), OTD(box->ymin + 2), OTD(w - 4), OTD(2),     c)) return 0;
    if (!savedraw_rectangle_fill(OTD(box->xmax - 4), OTD(box->ymin + 4), OTD(2),     OTD(h - 8), c)) return 0;
    if (!savedraw_rectangle_fill(OTD(box->xmax - 2), OTD(box->ymin + 4), OTD(2),     OTD(h - 6), c)) return 0;
a516 2

  return tsize;
d520 1
a520 5
/* savedraw_switch()                                          */
/*                                                            */
/* Output a switch (small sprite) at given coordinates.       */
/*                                                            */
/* Parameters: x position of the item in Draw coordinates;    */
d522 2
a523 1
/*             y position of the item in Draw coordinates;    */
d525 1
a525 1
/*             Pointer to the sprite's name;                  */
d527 1
a527 4
/*             Pointer to an int if wanting to know the size  */
/*             of the item only, else NULL (NB the int        */
/*             contents are not updated - the pointer is      */
/*             acting like a flag, basically).                */
d530 13
a542 1
static int savedraw_switch(int x, int y, char * spr, int * size)
d544 19
a562 32
  draw_spristrhdr    h;
  _kernel_swi_regs   r;
  sprite_header    * sh;
  int                asize = 0;
  int                wid, hei;

  h.tag = draw_OBJSPRITE;

  /* Find the sprite. Use _kernel_swi to set up */
  /* _kernel_last_oserror.                      */

  r.r[0] = 280;
  r.r[1] = (int) sprite_block;
  r.r[2] = (int) spr;

  if (_kernel_swi(OS_SpriteOp, &r, &r)) return 0;
  else sh = (sprite_header *) r.r[2];

  if (read_sprite_size(spr, &wid, &hei)) return 0;

  asize  = sh->next + sizeof(h);
  h.size = (int) WordAlign(asize);

  x = OTD(x);
  y = OTD(y);

  h.bbox.xmin = x;
  h.bbox.ymin = y;
  h.bbox.xmax = h.bbox.xmin + OTD(wid);
  h.bbox.ymax = h.bbox.ymin + OTD(hei);

  if (!size)
d564 2
a565 7
    if (!savedraw_write_bytes((char *) &h, sizeof(h)))         return 0;
    if (!savedraw_write_bytes((char *) sh, asize - sizeof(h))) return 0;

    if (asize != h.size)
    {
      if (!savedraw_write_bytes("    ", h.size - asize)) return 0;
    }
a566 2

  return h.size;
d570 1
a570 18
/* savedraw_texthdr()                                         */
/*                                                            */
/* Outputs a header for a text item.                          */
/*                                                            */
/* Parameters: Pointer to a browser_data struct for which the */
/*             item is to be output;                          */
/*                                                            */
/*             Pointer to an HStream struct from which the    */
/*             foreground colour and font to use is drawn     */
/*             (and nothing else);                            */
/*                                                            */
/*             x position of the item in Draw coordinates;    */
/*                                                            */
/*             y position of the item in Draw coordinates;    */
/*                                                            */
/*             Item's width in Draw coordinates;              */
/*                                                            */
/*             Item's height in Draw coordinates;             */
d572 2
a573 2
/*             Baseline offset for the text (added to the y   */
/*             coordinate);                                   */
d575 1
a575 2
/*             Length of the string that this header will be  */
/*             representing;                                  */
d577 1
a577 1
/*             Background colour to use.                      */
d580 14
a593 2
static int savedraw_texthdr(browser_data * b, HStream * tp, int x, int y,
                            int w, int h, int base, unsigned int length, unsigned int bgnd)
d595 3
a597 2
  draw_trfmtextstrhdr hdr;
  int                 number, size;
d599 3
a601 3
  if (w <= 0 || h <= 0)
  {
    #ifdef TRACE
d603 5
a607 1
      erb.errnum = Utils_Error_Custom_Normal;
d609 1
a609 2
      StrNCpy0(erb.errmess,
               "Width or height is zero in savedraw_texthdr, adjusting to 2 OS units to try and ensure output file is valid.");
d611 1
a611 1
      show_error_ret(&erb);
d613 3
a615 1
    #endif
d617 2
a618 2
    if (w <= 0) w = OTD(2);
    if (h <= 0) h = OTD(2);
d620 15
d636 22
a657 1
  /* Find info on the font */
d659 1
a659 1
  savedraw_font_info(tp, &number, &size);
d661 3
a663 24
  /* Fill in the header */

  hdr.tag                  = draw_OBJTEXTTRFM;
  hdr.size                 = sizeof(draw_trfmtextstrhdr) + (int) WordAlign(length + 1);
  hdr.bbox.xmin            = x;
  hdr.bbox.xmax            = x + w;
  hdr.bbox.ymin            = y;
  hdr.bbox.ymax            = y + h;
  hdr.matrix[0]            = 0x10000;
  hdr.matrix[1]            = 0;
  hdr.matrix[2]            = 0;
  hdr.matrix[3]            = 0x10000;
  hdr.matrix[4]            = 0;
  hdr.matrix[5]            = 0;
  hdr.fontflags            = SaveDraw_FontFlags_Kerned;
  hdr.textcolour           = redraw_token_colour(b, tp);
  hdr.background           = bgnd;
  hdr.textstyle.fontref    = fm_system_font() ? 0 : number;
  hdr.textstyle.reserved8  = 0;
  hdr.textstyle.reserved16 = 0;
  hdr.fsizey               = size * 40;

  if (number <= 8) hdr.fsizex = size * 40;
  else             hdr.fsizex = (size * 4 * choices.tt_aspect) / 10;
d665 4
a668 1
  if (fm_system_font()) hdr.fsizex /= 2;
d670 1
a670 2
  hdr.coord.x              = x;
  hdr.coord.y              = y + base;
d672 7
a678 36
  /* Exit through the save routines */

  return savedraw_write_bytes((char *) &hdr, sizeof(hdr));
}

/**************************************************************/
/* savedraw_draw_placeholder()                                */
/*                                                            */
/* Redraws a slabbed in place holder (unless the item is very */
/* small, in which case just at thin black border is plotted) */
/* for a given token, with optional text inside.              */
/*                                                            */
/* Parameters: A pointer to a browser_data structure relevant */
/*             to the redraw;                                 */
/*                                                            */
/*             A WimpRedrawWindowBlock pointer, with window   */
/*             area and redraw rectangle details filled in;   */
/*                                                            */
/*             Pointer to a BBox in which xmin and ymin hold  */
/*             the screen coords for the bottom left hand     */
/*             corner, and xmax and ymax hold the width and   */
/*             height of the placeholder in OS units;         */
/*                                                            */
/*             Pointer to the HStream struct the placeholder  */
/*             is to represent;                               */
/*                                                            */
/*             Pointer to a null-terminated piece of to plot  */
/*             inside, or NULL;                               */
/*                                                            */
/*             Pointer to an int if wanting to know the size  */
/*             of the item only, else NULL (NB the int        */
/*             contents are not updated - the pointer is      */
/*             acting like a flag, basically).                */
/*                                                            */
/* Returns:    Size of item written out, or 0 if it failed.   */
/**************************************************************/
d680 1
a680 4
static int savedraw_draw_placeholder(browser_data * b, WimpRedrawWindowBlock * r, BBox * holder, HStream * token, const char * text, int * size)
{
  int  tsize = 0;
  BBox ph    = *holder; // In case we want to adjust it later, e.g. for H/VSPACE
d682 1
a682 1
  /* A slabbed box if the size is great enough */
d684 1
a684 1
  if (ph.xmax > 8 && ph.ymax > 8)
d686 10
a695 1
    tsize += 4 * DSIZE_FRECT;
d697 5
a701 1
    if (!size)
d703 2
a704 4
      if (!savedraw_rectangle_fill(OTD(ph.xmin + 2),           OTD(ph.ymin + 2),           OTD(ph.xmax - 4), OTD(4),           Redraw_Colour_AlmostWhite)) return 0;
      if (!savedraw_rectangle_fill(OTD(ph.xmax + ph.xmin - 6), OTD(ph.ymin + 2),           OTD(4),           OTD(ph.ymax - 4), Redraw_Colour_AlmostWhite)) return 0;
      if (!savedraw_rectangle_fill(OTD(ph.xmin + 2),           OTD(ph.ymax + ph.ymin - 6), OTD(ph.xmax - 6), OTD(4),           Redraw_Colour_MidGrey))     return 0;
      if (!savedraw_rectangle_fill(OTD(ph.xmin + 2),           OTD(ph.ymin + 4),           OTD(4),           OTD(ph.ymax - 6), Redraw_Colour_MidGrey))     return 0;
a705 1
  }
d707 2
a708 1
  /* Otherwise a thin black frame */
d710 12
a721 4
  else
  {
    if (ph.xmax < 2) ph.xmax = 2;
    if (ph.ymax < 2) ph.ymax = 2;
d723 2
a724 1
    tsize += 4 * DSIZE_FRECT;
d726 1
a726 1
    if (!size)
d728 2
a729 4
      if (!savedraw_rectangle_fill(OTD(ph.xmin),               OTD(ph.ymin),               OTD(ph.xmax), OTD(2),       Redraw_Colour_Black)) return 0;
      if (!savedraw_rectangle_fill(OTD(ph.xmin),               OTD(ph.ymin),               OTD(2),       OTD(ph.ymax), Redraw_Colour_Black)) return 0;
      if (!savedraw_rectangle_fill(OTD(ph.xmin + ph.xmax - 2), OTD(ph.ymin),               OTD(2),       OTD(ph.ymax), Redraw_Colour_Black)) return 0;
      if (!savedraw_rectangle_fill(OTD(ph.xmin),               OTD(ph.ymin + ph.ymax - 2), OTD(ph.xmax), OTD(2),       Redraw_Colour_Black)) return 0;
d733 2
a734 1
  /* Output any text that there is */
d736 3
a738 1
  if (text && *text)
d740 3
a742 1
    /* Find out the bounding box needed to contain the text */
d744 1
a744 3
    int    h, xpos, vcent, stringwidth, stringheight, fsize;
    BBox   fbox;
    BBox * ibox = NULL;
d746 1
a746 1
    fbox.xmin = fbox.ymin = 0;
d748 6
a753 1
    /* Claim the font */
d755 2
a756 1
    fsize = (fm_size(token->fontsize) * 80) / 100;
d758 9
a766 6
    h = fm_find_font(b,
                     "sans",
                     fsize,
                     fsize,
                     0,
                     0);
d768 1
a768 1
    /* Find the string width of the ALT text */
d770 19
a788 13
    fm_get_string_width(h,
                        text,
                        Reformat_AsWideAsPossible_MP,
                        strlen(text),
                        -1,
                        NULL,
                        &stringwidth);

    convert_to_os(stringwidth, &stringwidth);

    /* Find the font height */

    fm_font_box(h, &fbox);
d790 1
a790 1
    stringheight = fbox.ymax - fbox.ymin;
d792 27
a818 4
    /* Set xpos to the horizontal offset to plot at. */
    /* Remember that 'box' contains the bottom       */
    /* left coordinates of the image, then the width */
    /* and height in OS units in xmax and ymax.      */
d820 1
a820 1
    /* Similarly, centre vertically */
d822 1
a822 3
    vcent = (ph.ymax - stringheight) / 2 - fbox.ymin;
    if (vcent <= 0) vcent = 10;
    vcent += ph.ymin;
d824 2
a825 3
    xpos = (ph.xmax - stringwidth) / 2;
    if (xpos <= 0) xpos = 10;
    xpos += ph.xmin;
d827 1
a827 13
    /* Now work out the bounding BBox from the placeholder BBox,  */
    /* allowing for a small edge gap before the text gets dropped */
    /* out completely (we can't clip in a Draw file, so must just */
    /* not output the text if it won't fit).                      */

    fbox.xmin = ph.xmin + 8;
    fbox.ymin = ph.ymin;// + 8;
    fbox.xmax = ph.xmin + ph.xmax - 8; /* Since ph.xmax = placeholder width) */
    fbox.ymax = ph.ymin + ph.ymax;// - 8; /* Since ph.ymax = placeholder height) */

    /* Can only proceed if there's a > 0 size bounding box */

    if (fbox.xmin < fbox.xmax && fbox.ymin < fbox.ymax)
d829 1
a829 73
      /* Find the intersection of the area of the image in which */
      /* we can plot ALT text and the 'redraw' rectangle         */

      ibox = intersection(&fbox, &r->redraw_area);

      /* If this box is smaller than that required for the ALT text, */
      /* don't proceed                                               */

      if (
           ibox                                    &&
           ibox->xmax - ibox->xmin >= stringwidth  &&
           ibox->ymax - ibox->ymin >= stringheight
         )
      {
        draw_trfmtextstrhdr hdr;
        int                 c      = redraw_token_colour(b, token);
        int                 length = strlen(text) + 1;
        char                null   = '\0';

        /* Construct the header */

        hdr.tag                  = draw_OBJTEXTTRFM;
        hdr.size                 = sizeof(draw_trfmtextstrhdr) + (int) WordAlign(length);
        hdr.bbox.xmin            = OTD(xpos);
        hdr.bbox.xmax            = OTD(xpos + stringwidth);
        hdr.bbox.ymin            = OTD(vcent);
        hdr.bbox.ymax            = OTD(vcent + stringheight);
        hdr.matrix[0]            = 0x10000;
        hdr.matrix[1]            = 0;
        hdr.matrix[2]            = 0;
        hdr.matrix[3]            = 0x10000;
        hdr.matrix[4]            = 0;
        hdr.matrix[5]            = 0;
        hdr.fontflags            = SaveDraw_FontFlags_Kerned;
        hdr.textcolour           = c;
        hdr.background           = redraw_background_colour(b, c);
        hdr.textstyle.fontref    = fm_system_font() ? 0 : 5;
        hdr.textstyle.reserved8  = 0;
        hdr.textstyle.reserved16 = 0;
        hdr.fsizex               = fsize * 40;
        hdr.fsizey               = fsize * 40;

        if (fm_system_font()) hdr.fsizex /= 2;

        hdr.coord.x              = OTD(xpos);
        hdr.coord.y              = OTD(vcent);

        tsize += sizeof(hdr) + (int) WordAlign(length);

        if (!size)
        {
          if (!savedraw_write_bytes((char *) &hdr, sizeof(hdr))) return 0;

          /* Write the text itself */

          if (!savedraw_write_bytes(text, length - 1)) return 0;
          if (!savedraw_write_bytes(&null, 1)) return 0;

          if (length != (int) WordAlign(length))
          {
            if (!savedraw_write_bytes("    ", (int) WordAlign(length) - length)) return 0;
          }
        }

        /* Underline text if it's a link and the browser is set to underline links */

        if (b->underline_links && ISLINK(token))
        {
          tsize += DSIZE_FRECT;

          if (!size && !savedraw_rectangle_fill(OTD(xpos), OTD(vcent - 7), OTD(stringwidth), OTD(2), c)) return 0;
        }
      }
d832 4
d837 1
a837 1
  return tsize;
d841 1
a841 21
/* savedraw_textarea_redraw()                                 */
/*                                                            */
/* Outputs the text in a text area object.                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the text area;                                 */
/*                                                            */
/*             Pointer to the token representing the text     */
/*             area;                                          */
/*                                                            */
/*             Pointer to a BBox holding the bounding box of  */
/*             the text area, in screen coords (so OS units); */
/*                                                            */
/*             Pointer to a BBox holding the current graphics */
/*             window (usually from a call to the Wimp to     */
/*             redraw something - remember that this can't be */
/*             read during a printing routine as VDU          */
/*             variables may not be read during printing);    */
/*                                                            */
/*             A font handle for the font to use for the      */
/*             redraw;                                        */
d843 2
a844 2
/*             1 if the text area has multiple lines, 0 to    */
/*             render all text on one line only;              */
d846 1
a846 3
/*             1 if the text area represents a password       */
/*             object (show the text as a line of *s, instead */
/*             of the actual chars), else 0;                  */
d848 1
a848 8
/*             Pointer to an int if wanting to know the size  */
/*             of the item only, else NULL (NB the int        */
/*             contents are not updated - the pointer is      */
/*             acting like a flag, basically).                */
/*                                                            */
/* Returns:    Size of item written out (which may be zero),  */
/*             or -1 for failure - note how this differs from */
/*             most other functions in this source!           */
d851 11
a861 2
static int savedraw_textarea_redraw(browser_data * b, HStream * token, BBox *box, BBox *gw, int fh,
                                    int multiline, int password, int * size)
d863 2
a864 7
  int    nxmin, nymin, nxmax, nymax;
  int    lh, lb, length, used;
  int    xs, ys, y;
  int    tsize = 0;
  BBox   area, fontbox;
  char   c;
  char * p, * t;
d866 6
a871 1
  /* Set 'area' to hold the bounding box of the text area */
d873 1
a873 1
  area = *box;
d875 3
a877 1
  /* Bring the coordinates in to account for the text area's border */
d879 11
a889 4
  area.xmin += 8;
  area.ymin += 8;
  area.xmax -= 8;
  area.ymax -= 8;
d891 1
a891 3
  /* Get nxmin, nxmax, nymin anx nymax to hold the coordinates of */
  /* a BBox formed by the intersection of the text area and the   */
  /* current graphics rectangle.                                  */
d893 5
a897 4
  nxmin = area.xmin > gw->xmin ? area.xmin : gw->xmin;
  nxmax = area.xmax < gw->xmax ? area.xmax : gw->xmax;
  nymin = area.ymin > gw->ymin ? area.ymin : gw->ymin;
  nymax = area.ymax < gw->ymax ? area.ymax : gw->ymax;
d899 1
a899 4
  nxmin &= ~1;
  nymin &= ~1;
  nxmax &= ~1;
  nymax &= ~1;
d901 10
a910 2
  /* If the minimum coords are less than / equal to the maximums, */
  /* there is nothing to redraw.                                  */
d912 1
a912 1
  if (nxmin >= nxmax || nymin >= nymax) return 0;
d914 4
a917 2
  /* Get the height of an individual line, based on the height of */
  /* the font to be used plus vertical spacing considerations.    */
d919 2
a920 1
  fm_font_box(fh, &fontbox);
d922 10
a931 1
  form_get_linesize(&fontbox, &lh, &lb);
d933 6
a938 1
  /* Get the text for the text area */
d940 7
a946 1
  p = form_get_field_text(b, token);
d948 1
a948 1
  /* Only proceed if there's text to draw */
d950 1
a950 6
  if (p)
  {
    /* Assume a zero scroll offset (so the output */
    /* Draw file reflects a 'dead' unedited page, */
    /* in the same way that the keyboard selected */
    /* item, if present, isn't shown highlighted) */
d952 2
a953 1
    xs = ys = 0;
d955 3
a957 1
    y = area.ymax + ys;
d959 1
a959 4
    do
    {
      /* The text may be terminated by newlines or null bytes; if */
      /* a newline, this implies a split point for a text area.   */
d961 1
a961 2
      t         = strchr(p, '\n');
      if (!t) t = strchr(p, 0);
d963 2
a964 2
      /* Ensure for C's purposes (sigh) that there is a zero terminator */
      /* at the end of the chunk to plot.                               */
d966 4
a969 2
       c = *t;
      *t = 0;
d971 4
a974 1
      length = used = strlen(p);
d976 2
a977 4
      /* If the line is in the visible region, plot it. Note the use of */
      /* the FE_PassCode line of asterisks - if a password is being     */
      /* entered, as many of these as there are characters in the       */
      /* real string will be displayed instead of that string.          */
d979 1
a979 4
      if (length && y - lh < area.ymax)
      {
        int  tw;
        char null = '\0';
d981 6
a986 1
        length ++; /* (Initial condition) */
d988 2
a989 49
        do
        {
          length --;

          if (fm_get_string_width(fh,
                                  password ? FE_PassCode : p,
                                  0x1000000,
                                  length,
                                  -1,
                                  NULL,
                                  &tw)) return -1;

          convert_to_os(tw, &tw);
        }
        while (length && tw > nxmax - nxmin);

        if (length)
        {
          /* Output the header */

          tsize += sizeof(draw_trfmtextstrhdr);

          if (!savedraw_texthdr(b,
                                token,
                                OTD(area.xmin - xs),
                                OTD(y - lh + lb),
                                OTD(tw),
                                OTD(lh),
                                0,
                                length,
                                (token->tagno == TAG_SELECT) ? Redraw_Colour_BackGrey : Redraw_Colour_White)) return -1;

          /* The count should include a terminator at this point */

          length++;

          /* Output the text ifself */

          tsize += (int) WordAlign(length);

          if (!savedraw_write_bytes(password ? FE_PassCode : p, length - 1)) return -1;
          if (!savedraw_write_bytes(&null, 1)) return -1;

          if (length != (int) WordAlign(length))
          {
            if (!savedraw_write_bytes("    ", (int) WordAlign(length) - length)) return -1;
          }
        }
      }
d991 10
a1000 1
      y -= lh;
d1002 4
a1005 1
      /* Restore the character that was altered to a null byte earlier */
d1007 7
a1013 1
      *t = c;
d1015 2
a1016 1
      /* Advance the string pointer past the text just plotted */
d1018 1
a1018 1
      p += used;
d1020 1
a1020 12
      /* If we're on a newline, there must be another chunk of string to */
      /* plot, so move the pointer past it.                              */

      if (*p == '\n') p++;

      /* Keep looping whilst in the visible area and there's data left to   */
      /* plot, provided that this was flagged as a multiline object redraw. */
    }
    while (y>area.ymin && multiline && *p);
  }

  return tsize;
d1042 1
a1042 1
static int savedraw_create(browser_data * b, int bgimages, int * size)
d1047 1
a1047 2
  int                     success;
  int                     tsize = 40; /* Draw file header */
d1049 1
d1070 4
a1073 1
  if (size) *size = 0;
a1075 2
    draw_fileheader h;

d1105 1
a1105 1
    if (!savedraw_write_bytes((char *) &h, sizeof(h))) return 0;
a1129 2
    tsize += (int) WordAlign(fsize);

d1132 5
a1136 1
    if (!size)
d1141 1
a1141 1
      if (!savedraw_write_bytes(fontname, 8)) return 0;
d1154 1
a1154 1
        if (!savedraw_write_bytes(fontname, strlen(fontname + 1) + 2)) return 0;
d1161 1
a1161 1
        if (!savedraw_write_bytes("    ", (int) WordAlign(fsize) - fsize)) return 0;
d1166 1
a1166 4
  /* Now draw the main page (recursively, for tables); */
  /* note that 'b->selected' is cleared to avoid       */
  /* highlighted tokens coming out as SeleColour in    */
  /* the draw output.                                  */
a1169 2
  success     = savedraw_create_r(1, 0, 0, b, b->cell, 0, &r, bgimages, size, &tsize);
  b->selected = selected;
d1171 1
a1171 1
  /* Finished */
d1173 1
a1173 43
  return success;
}

/**************************************************************/
/* savedraw_create_r()                                        */
/*                                                            */
/* Recursive back-end to savedraw_create. API is similar in   */
/* many ways to redraw_draw_r.                                */
/*                                                            */
/* Parameters: 1 if being called externally, or 0 if being    */
/*             called recursively;                            */
/*                                                            */
/*             x coord of offset from the top right to 'plot' */
/*             at (in milli- points);                         */
/*                                                            */
/*             y coord of offset from the top right to 'plot' */
/*             at (in milli- points);                         */
/*                                                            */
/*             Pointer to a browser_data struct to represent  */
/*             in the Draw file;                              */
/*                                                            */
/*             Pointer to the reformat_cell which is to be    */
/*             output;                                        */
/*                                                            */
/*             1 to draw no backgrounds, else 0;              */
/*                                                            */
/*             A WimpRedrawWindowBlock pointer containing     */
/*             details on the area of the page to output;     */
/*                                                            */
/*             1 to include any background image present on   */
/*             the browser's page, else 0;                    */
/*                                                            */
/*             Pointer to an int to take the file size if     */
/*             that's all you want, or NULL to actually       */
/*             output the file;                               */
/*                                                            */
/*             Pointer to an int in which the file size of    */
/*             the current chunk / cell (which may not be the */
/*             whole file) is written.                        */
/*                                                            */
/* Assumes:    Pointers must be valid and not NULL unless     */
/*             otherwise specified above.                     */
/**************************************************************/
d1175 1
a1175 9
static int savedraw_create_r(int toplevel, int xorg, int yorg,
                             browser_data * b, reformat_cell * d, int noback,
                             WimpRedrawWindowBlock * r, int bgimages,
                             int * size, int * tsize)
{
  BBox wbox, sbox, fbox;
  int  page_bottom, page_height;
  int  osxorg, osyorg;
  int  l = 0;
d1177 1
a1177 1
  /* Place the x and y origin in OS units into osxorg and osyorg */
d1179 1
a1179 1
  convert_pair_to_os(xorg, yorg, &osxorg, &osyorg);
d1181 1
a1181 1
  sbox = r->redraw_area; /* Set sbox to hold the redraw rectangle details */
d1183 1
a1183 1
  /* Convert the screen coord redraw rectangle into millipoints */
d1185 1
a1185 1
  convert_box_to_points(&sbox, &fbox);
d1187 1
a1187 2
  /* Convert the screen coord redraw region into work */
  /* area coords, putting the result in wbox.         */
d1189 1
a1189 2
  wbox = sbox;
  coords_box_toworkarea(&wbox, r);
d1191 1
a1191 6
  /* Now convert sbox to Draw coordinates. So, we have: */
  /*                                                    */
  /* sbox - The redraw area in Draw file coords;        */
  /* fbox - The redraw area in screen coords converted  */
  /*        to millipoints;                             */
  /* wbox - The redraw area in work area coords.        */
d1193 1
a1193 4
  sbox.xmin = DRAWMARGIN + OTD(sbox.xmin);
  sbox.ymin = DRAWMARGIN + OTD(sbox.ymin);
  sbox.xmax = DRAWMARGIN + OTD(sbox.xmax);
  sbox.ymax = DRAWMARGIN + OTD(sbox.ymax);
d1195 1
a1195 4
  /* Get the page bottom in work area coordinates, and the page height. */
  /* This is really a printing only concept, where the visible_area     */
  /* BBox will in fact hold the entire page bounding box. The variables */
  /* aren't used for anything else (at present, hence no 'if' wrapper). */
d1197 6
a1202 4
  page_bottom = coords_y_toworkarea(r->visible_area.ymin, r);
  page_height = r->visible_area.ymax - r->visible_area.ymin;

  if (!noback)
d1204 4
a1207 1
    int htop;
d1209 3
a1211 1282
    if (!controls.swap_bars) htop = toolbars_button_height(b) + toolbars_url_height(b);
    else                     htop = toolbars_status_height(b);

    if (htop) htop += wimpt_dy();

    /* If background images are not to be shown, or there's no image */
    /* to tile on the background, set the background to a uniform    */
    /* colour. The 'if' statement implicitly calls the background    */
    /* image tiler.                                                  */

    if (
         !b->show_background ||
         (
           !bgimages ||
           !image_tile_to_draw(b,
                               r,
                               0,
                               -htop,
                               size)
         )
       )
    {
      if (!toplevel || redraw_backcol(b) != Redraw_Colour_White)
      {
        if (
             !size &&
             !savedraw_rectangle_fill(sbox.xmin,
                                      sbox.ymin,
                                      sbox.xmax - sbox.xmin,
                                      sbox.ymax - sbox.ymin - (toplevel ? OTD(htop) : 0),
                                      redraw_backcol(b))
           )
           return 0;

        *tsize += DSIZE_FRECT;
      }
    }
  }

  for (l = 0; l < d->nlines; l++)
  {
    /* If there are line chunks for this line, and the bounding box y */
    /* coordinates lie within the redraw rectangle, process the line. */

    if (
         d->ldata[l].n                                      &&
         osyorg + d->ldata[l].y < wbox.ymax                 &&
         osyorg + d->ldata[l].y + d->ldata[l].h > wbox.ymin
       )
    {
      HStream * tp;            /* Token Pointer */
      fm_face   h;
      int       x, y;          /* Plotting origin */
      int       keepx, keepy;  /* Line's bottom left corner */
      int       base, i;
      char    * dp;            /* Data Pointer */
      int       cn;            /* Chunk Number */

      if (toplevel)
      {
        _swix(Hourglass_Percentage,
              _IN(0),

              (((wbox.ymax - osyorg - d->ldata[l].y) * 100) / (wbox.ymax - wbox.ymin)) - 1);
      }

//      if (printing == 1 && toplevel)
//      {
//        /* If printing = 1, it signals that we're not to split lines */
//        /* over the bottom of the page. So if this line will drop    */
//        /* off the bottom, we need to be careful. This gets a bit    */
//        /* hacky now...                                              */
//        /*                                                           */
//        /* To signal to the printing loop that a line was about to   */
//        /* be split but wasn't drawn, the top coord of the line is   */
//        /* returned in the xscroll field of the redraw block passed  */
//        /* to the function. The printing routines use this to work   */
//        /* out where to start the next redraw from.                  */
//        /*                                                           */
//        /* However, for large lines - e.g. very big images, tables,  */
//        /* or lines taller than the whole page - we either should,   */
//        /* or in the latter case must, split that line. So, if the   */
//        /* line is taller than 1/PrintSplitFraction of the page      */
//        /* height, will indeed be split over the page boundary.      */
//        /*                                                           */
//        /* If you add code here, remember that xscroll must be       */
//        /* filled in eventually or the printing loop will exit,      */
//        /* assuming there's no more page to draw.                    */
//
//        if (osyorg + d->ldata[l].y < page_bottom)
//        {
//          if (d->ldata[l].h <= page_height / PrintSplitFraction) /* (See Print.h) */
//          {
//            r->xscroll = osyorg + d->ldata[l].y + d->ldata[l].h;
//            return NULL;
//          }
//
//          /* The effective 'else' case here has to be handled at the end */
//          /* of printing, or you've just scrolled the page a long way to */
//          /* right...                                                    */
//        }
//      }
//
      /* Put the base address of the line's chunks into cp, */
      /* and point to its associated token in tp.           */

      cn = d->ldata[l].chunks;
      tp = d->cdata[cn].t;

      /* Get the x and y coordinates of the bottom left of the line in */
      /* millipoints into keepx and keepy                              */

      keepy = d->ldata[l].y;
      keepx = redraw_start_x(b, d, tp, l);

      convert_pair_to_points(keepx, keepy, &keepx, &keepy);

      x = coords_x_toscreen(0, r);
      y = coords_y_toscreen(0, r);

      convert_pair_to_points(x, y, &x, &y);

      /* Offset the line x and y coordinates by the origin passed into the */
      /* function, and thus get the actual screen coordinates, in milli-   */
      /* points, into x and y.                                             */

      keepx += xorg;
      keepy += yorg;

      x += keepx;
      y += keepy;

      /* Set 'base' to hold the baseline offset in millipoints */

      convert_to_points(d->ldata[l].b, &base);

      /* Loop round for all of the line chunks */

      for (
            i = 0;
            i < d->ldata[l].n && x < fbox.xmax;
            x += d->cdata[cn].w, i++, cn++
          )
      {
        if (x + d->cdata[cn].w > fbox.xmin)
        {
          /* Get the token address for this line chunk */

          tp = d->cdata[cn].t;

          /* Deal with table tags */

          if (tp->tagno == TAG_TABLE)
          {
            int oh;

            convert_to_points(d->ldata[l].h, &oh);

            /* Use of recursion for redraw... So need to keep this code block */
            /* as a code block, don't try to collapse it down a level and     */
            /* merge in 'oh' above, etc.                                      */

            {
              /* In this case there are table streams hung from d->cdata */

              table_stream   * table      = (table_stream *) tp;
              table_row      * row        = NULL;
              table_headdata * head       = NULL;
              reformat_cell  * cellarray  = table->cells;
              reformat_cell  * cell;

              int              oldback    = 0;
              int              oldaa      = 0;
              int              oldbgimage = -1;
              int              t_noback;

              BBox             rbox; /* Redraw box - i.e. the cell BBox in window coordintes */
              BBox           * ibox; /* Used for intersection between cell BBox and current graphics rectangle */
              BBox             tbox; /* Used to plot the table outer border */

              int              cellindex;
              int              cellcount;
              int              cellmax = table->ColSpan * table->RowSpan;

              int              swap;

              tbox.xmin = tbox.ymin = 0x1000000;
              tbox.xmax = tbox.ymax = 0;

              /* Only proceed if there are table cells to redraw */

              if (cellarray)
              {
                row       = table->List;
                cellcount = 0;

                while (row && cellcount < cellmax)
                {
                  head = row->List;

                  while (head && cellcount < cellmax)
                  {
                    switch (head->Tag)
                    {
                      case TagTableData:
                      case TagTableHead:
                      {
                        cellindex = head->RowOffs * table->ColSpan + head->ColOffs;

                        if (cellindex < cellmax)
                        {
                          int cx, cy, cw, ch;

                          cell = &cellarray[cellindex];

                          cx = x + cell->x;
                          cy = y + cell->y + oh - cell->cellheight;
                          cw = cell->cellwidth;
                          ch = cell->cellheight;

                          convert_pair_to_os(cx, cy, &cx, &cy);
                          convert_pair_to_os(cw, ch, &cw, &ch);

                          /* Update the table bounding box as required */

                          if (cx      < tbox.xmin) tbox.xmin = cx;
                          if (cy      < tbox.ymin) tbox.ymin = cy;
                          if (cx + cw > tbox.xmax) tbox.xmax = cx + cw;
                          if (cy + ch > tbox.ymax) tbox.ymax = cy + ch;

                        /* Closure of 'if (cellindex < cellmax)' */
                        }

                      /* Closure of specific 'case' item */
                      }
                      break;

                    /* Closure of 'switch (head->Tag)' */
                    }

                    cellcount ++;

                    head = head->Next;

                  /* Closure of 'while (head && ...)' */
                  }

                  row = row->Next;

                /* Closure of 'while (row && ...)' */
                }

                /* tbox doesn't take account of cell spacing yet - correct */
                /* for this now.                                           */

                tbox.xmin -= table->cellspacing * 2;
                tbox.ymin -= table->cellspacing * 2;
                tbox.xmax += table->cellspacing * 2;
                tbox.ymax += table->cellspacing * 2;

                /* If the table has a background colour, deal with this */

                if (TABLE_HAS_BGCOL(table))
                {
                  int tx, ty;
                  int tw, th;

                  /* Work out the x and y coordinates of the lower left hand pixel */
                  /* of the table border, and the width and height of the table    */
                  /* including the border.                                         */

                  tx = tbox.xmin;
                  ty = tbox.ymin;
                  tw = tbox.xmax - tbox.xmin;
                  th = tbox.ymax - tbox.ymin;

                  /* Output the background */

                  redraw_set_colour(TABLE_BGCOL(table));

                  if (!savedraw_rectangle_fill(OTD(tx), OTD(ty), OTD(tw), OTD(th), TABLE_BGCOL(table))) return 0;
                }

                /* Now output the table cells */

                row       = table->List;
                cellcount = 0;

                while (row && cellcount < cellmax)
                {
                  head = row->List;

                  while (head && cellcount < cellmax)
                  {
                    switch (head->Tag)
                    {
                      case TagTableData:
                      case TagTableHead:
                      {
                        cellindex = head->RowOffs * table->ColSpan + head->ColOffs;

                        if (cellindex < cellmax)
                        {
                          cell = &cellarray[cellindex];

                          if (TD_HAS_BGCOL(head))
                          {
                            oldback              = b->background_colour;
                            oldaa                = b->antialias_colour;
                            oldbgimage           = b->background_image;
                            b->background_colour = TD_BGCOL(head);
                            b->antialias_colour  = b->background_colour;
                            b->background_image  = -1; /* For now, no background images in table cells. */

                            t_noback = 0;
                          }
                          else t_noback = 1;

                          /* Set the graphics rectangle up for the redraw */

                          rbox.xmin = x + cell->x;
                          rbox.ymin = y + cell->y + oh - cell->cellheight;
                          rbox.xmax = rbox.xmin + cell->cellwidth;
                          rbox.ymax = rbox.ymin + cell->cellheight;

                          /* Convert to OS units */

                          convert_box_to_os(&rbox, &rbox);

                          /* If necessary, swap min and max coords */

                          if (rbox.xmax < rbox.xmin) swap = rbox.xmax, rbox.xmax = rbox.xmin, rbox.xmin = swap;
                          if (rbox.ymax < rbox.ymin) swap = rbox.ymax, rbox.ymax = rbox.ymin, rbox.ymin = swap;

                          /* See if the notional page redraw box intersects the overall redraw rectangle */

                          if (rbox.xmin == rbox.xmax || rbox.ymin == rbox.ymax) ibox = NULL;
                          else                                                  ibox = intersection(&rbox, &r->redraw_area);

                          if (ibox)
                          {
                            BBox oldrect;

                            oldrect        = r->redraw_area;
                            r->redraw_area = *ibox;

                            /* Recursive call to redraw the cell contents */

                            savedraw_create_r(0,
                                              keepx + cell->x,
                                              keepy + cell->y + oh,
                                              b,
                                              cell,
                                              t_noback,
                                              r,
                                              bgimages,
                                              size,
                                              tsize);

                            /* Restore the redraw rectangle */

                            r->redraw_area = oldrect;
                          }

                          /* Restore any data altered in b */

                          if (!t_noback)
                          {
                            b->background_colour = oldback;
                            b->antialias_colour  = oldaa;
                            b->background_image  = oldbgimage;
                          }

                          /* Draw the slabbed in cell border. */

                          if (TABLE_BORDER(table))
                          {
                            int dx = wimpt_dx();
                            int dy = wimpt_dy();

                            int max;

                            int cx, cy;
                            int cw, ch;

                            /* Get the cell x,y and w,h in OS units from the redraw box. We want to */
                            /* use this information rather than cell->x etc. as the redraw box is   */
                            /* the item that any internal redraws will have adhered to, including   */
                            /* plotting cell backgrounds (if present). Thus, we want any table      */
                            /* borders to be based on those same coordinates.                       */

                            cx = rbox.xmin;
                            cy = rbox.ymin;
                            cw = rbox.xmax - rbox.xmin;
                            ch = rbox.ymax - rbox.ymin;

                            /* Get the maximum horizontal OS to pixel scaling values, as this is */
                            /* used as a threshold for the 2D border / 3D border switching.      */

                            if (dy > dx) max = dy;
                            else         max = dx;

                            /* Don't do any actual drawing if the Choices don't say so. We have to */
                            /* do the calculation stuff above (well, most of it...!) so that the   */
                            /* outer border plotter code (below) will work, whether inner borders  */
                            /* are plotted or not.                                                 */

                            if (choices.table_inner != Choices_TableInner_Never)
                            {
                              /* For tables with a cell spacing greater than the OS unit */
                              /* to pixel scaling value, use a 3D border (depending on   */
                              /* what is specified in the Choices).                      */

                              *tsize += DSIZE_FRECT * 4;

                              if (
                                   choices.table_inner != Choices_TableInner_Always2D &&
                                   (
                                     table->cellspacing > max ||
                                     choices.table_inner == Choices_TableInner_Always3D
                                   )
                                 )
                              {
                                if (!savedraw_rectangle_fill(OTD(cx),      OTD(cy - 2),  OTD(cw),     OTD(2),      Redraw_Colour_AlmostWhite)) return 0;
                                if (!savedraw_rectangle_fill(OTD(cx + cw), OTD(cy - 2),  OTD(2),      OTD(ch + 2), Redraw_Colour_AlmostWhite)) return 0;
                                if (!savedraw_rectangle_fill(OTD(cx - 2),  OTD(cy - 2),  OTD(2),      OTD(ch + 4), Redraw_Colour_PlinthGrey))  return 0;
                                if (!savedraw_rectangle_fill(OTD(cx),      OTD(cy + ch), OTD(cw + 2), OTD(2),      Redraw_Colour_PlinthGrey))  return 0;
                              }

                              /* Otherwise use a black 2D border. If we've got half of the OS unit to */
                              /* pixel spacing available, then there'll be at least 1 pixel between   */
                              /* all cells so we can draw in that gap. Otherwise, we must plot over   */
                              /* the cell contents.                                                   */

                              else if (table->cellspacing >= (max >> 1))
                              {
                                if (!savedraw_rectangle_fill(OTD(cx - 2),  OTD(cy - 2),  OTD(cw + 2), OTD(2),      Redraw_Colour_Black)) return 0;
                                if (!savedraw_rectangle_fill(OTD(cx + cw), OTD(cy - 2),  OTD(2),      OTD(ch + 2), Redraw_Colour_Black)) return 0;
                                if (!savedraw_rectangle_fill(OTD(cx - 2),  OTD(cy),      OTD(2),      OTD(ch + 2), Redraw_Colour_Black)) return 0;
                                if (!savedraw_rectangle_fill(OTD(cx),      OTD(cy + ch), OTD(cw + 2), OTD(2),      Redraw_Colour_Black)) return 0;
                              }
                              else
                              {
                                if (!savedraw_rectangle_fill(OTD(cx),          OTD(cy),          OTD(cw), OTD(2),  Redraw_Colour_Black)) return 0;
                                if (!savedraw_rectangle_fill(OTD(cx + cw - 2), OTD(cy),          OTD(2),  OTD(ch), Redraw_Colour_Black)) return 0;
                                if (!savedraw_rectangle_fill(OTD(cx),          OTD(cy),          OTD(2),  OTD(ch), Redraw_Colour_Black)) return 0;
                                if (!savedraw_rectangle_fill(OTD(cx),          OTD(cy + ch - 2), OTD(cw), OTD(2),  Redraw_Colour_Black)) return 0;
                              }
                            }
                          }

                        /* Closure of 'if (cellindex < cellmax)' */
                        }

                      /* Closure of specific 'case' item */
                      }
                      break;

                    /* Closure of 'switch (head->Tag)' */
                    }

                    cellcount ++;

                    head = head->Next;

                  /* Closure of 'while (head && ...)' */
                  }

                  row = row->Next;

                /* Closure of 'while (row && ...)' */
                }

                /* Right, now redraw the slabbed out outer table border */

                if (TABLE_BORDER(table) && choices.table_outer != Choices_TableOuter_Never)
                {
                  int dx = wimpt_dx();
                  int dy = wimpt_dy();

                  int max;

                  int tx, ty;
                  int tw, th;
                  int tb;

                  tb = TABLE_BORDER(table) * 2; /* 1 'web pixel' = 2 OS */

                  /* Work out the x and y coordinates of the lower left hand pixel */
                  /* of the table border, and the width and height of the table    */
                  /* including the border.                                         */

                  tx = tbox.xmin - tb;
                  ty = tbox.ymin - tb;
                  tw = tbox.xmax - tbox.xmin + tb * 2;
                  th = tbox.ymax - tbox.ymin + tb * 2;

                  /* Get the maximum horizontal OS to pixel scaling values, as this is */
                  /* used as a threshold for the 2D border / 3D border switching.      */

                  if (dy > dx) max = dy;
                  else         max = dx;

                  /* Use the same threshold value on the border as for internal cell borders */

                  if (
                       choices.table_outer != Choices_TableOuter_Always2D &&
                       (
                         table->cellspacing > max ||
                         choices.table_outer == Choices_TableOuter_Always3D
                       )
                     )
                  {
                    int x[4], y[4];

                    /* There are 8 corners to a plinth,  6------4  */
                    /* we draw using 8 triangles. Work   |\    /|  */
                    /* these out first in the arrays     | 7--5 |  */
                    /* declared above to make the        | |  | |  */
                    /* plotting code tidier and avoid    | 1--3 |  */
                    /* unnecessary recalculation of      |/    \|  */
                    /* corner coordinates.               0------2  */
                    /*                                             */
                    /* Note how there are only 4 unique x or y     */
                    /* values, so that's all we need to work out.  */

                    x[0] = OTD(tx);
                    x[1] = OTD(tx + tb);
                    x[2] = OTD(tx + tw - tb);
                    x[3] = OTD(tx + tw);

                    y[0] = OTD(ty);
                    y[1] = OTD(ty + tb);
                    y[2] = OTD(ty + th - tb);
                    y[3] = OTD(ty + th);

                    /* OK, now do the drawing. We need to be careful about  */
                    /* the direction that the drawing occurs to ensure that */
                    /* adjacent diagonal lines meet up correctly. First,    */
                    /* the bottom edge.                                     */

                    if (!savedraw_triangle_fill(x[0], y[0], x[1], y[1], x[3], y[0], Redraw_Colour_PlinthGrey))  return 0; /* 0 -> 1 -> 2 */
                    if (!savedraw_triangle_fill(x[1], y[1], x[3], y[0], x[2], y[1], Redraw_Colour_PlinthGrey))  return 0; /* 1 -> 2 -> 3 */

                    /* Right hand edge */

                    if (!savedraw_triangle_fill(x[3], y[0], x[2], y[1], x[3], y[3], Redraw_Colour_PlinthGrey))  return 0; /* 2 -> 3 -> 4 */
                    if (!savedraw_triangle_fill(x[2], y[1], x[3], y[3], x[2], y[2], Redraw_Colour_PlinthGrey))  return 0; /* 3 -> 4 -> 5 */

                    /* Now the lighter section - the top edge first.*/

                    if (!savedraw_triangle_fill(x[3], y[3], x[2], y[2], x[0], y[3], Redraw_Colour_AlmostWhite)) return 0; /* 4 -> 5 -> 6 */
                    if (!savedraw_triangle_fill(x[2], y[2], x[0], y[3], x[1], y[2], Redraw_Colour_AlmostWhite)) return 0; /* 5 -> 6 -> 7 */

                    /* Finally, the left hand edge. */

                    if (!savedraw_triangle_fill(x[0], y[3], x[1], y[2], x[0], y[0], Redraw_Colour_AlmostWhite)) return 0; /* 6 -> 7 -> 0 */
                    if (!savedraw_triangle_fill(x[1], y[2], x[0], y[0], x[1], y[1], Redraw_Colour_AlmostWhite)) return 0; /* 7 -> 0 -> 1 */
                  }

                  /* Otherwise, use a 2D outer border. */

                  else
                  {
                    if (!savedraw_rectangle_fill(OTD(tx),           OTD(ty),           OTD(tw), OTD(tb), Redraw_Colour_Black)) return 0;
                    if (!savedraw_rectangle_fill(OTD(tx),           OTD(ty + th - tb), OTD(tw), OTD(tb), Redraw_Colour_Black)) return 0;
                    if (!savedraw_rectangle_fill(OTD(tx),           OTD(ty),           OTD(tb), OTD(th), Redraw_Colour_Black)) return 0;
                    if (!savedraw_rectangle_fill(OTD(tx + tw - tb), OTD(ty),           OTD(tb), OTD(th), Redraw_Colour_Black)) return 0;
                  }
                }

              /* Closure of 'if (cellarray)' */
              }

            /* Closure of unconditional code block dealing with redrawing */
            /* the body of a table.                                       */
            }
          }

          /* Deal with forms elements */

          else if (tp->tagno == TAG_INPUT || tp->tagno == TAG_TEXTAREA || tp->tagno == TAG_SELECT)
          {
            int asize;

            /* A text-based element */

            if (
                 tp->tagno == TAG_TEXTAREA               ||
                 tp->tagno == TAG_SELECT                 ||
                 HtmlINPUTtype(tp) == inputtype_TEXT     ||
                 HtmlINPUTtype(tp) == inputtype_PASSWORD
               )
            {
              BBox    box;
              int     ox, oy;
              fm_face fh;

              convert_pair_to_os(x, y + base, &ox, &oy);

              fh = fm_find_token_font(b, tp, 0);
              fm_font_box(fh, &box);

              /* Set up the bounding box for a text area, with a minimum of 2 rows */

              if (tp->tagno == TAG_TEXTAREA)
              {
                int r;
                int lh, lb;

                form_get_linesize(&box, &lh, &lb);

                r = tp->rows;
                if (r < 2) r = 2;

                box.ymin -= lh * (r - 1); /* ymin is already below the first line, so want to drop it by (rows - 1) more */
              }

              /* Account for the borders */

              box.ymin = box.ymin + oy - 8;
              box.ymax = box.ymax + oy + 8;
              box.xmin = ox + 4;

              convert_to_os(x + d->cdata[cn].w, &box.xmax);

              /* Account for a border */

              box.xmax -= 4;

              asize = savedraw_input_field(b,
                                           tp,
                                           &box,
                                           redraw_token_colour(b, tp),
                                           tp->tagno == TAG_SELECT,
                                           size);

              if (!asize) return 0;
              else *tsize += asize;

              /* Now the text inside the item */

              asize = savedraw_textarea_redraw(b,
                                               d->cdata[cn].t,
                                               &box,
                                               &r->redraw_area,
                                               fh,
                                               tp->tagno == TAG_TEXTAREA,
                                               tp->tagno == TAG_INPUT && HtmlINPUTtype(tp) == inputtype_PASSWORD,
                                               size);

              /* If the element is a SELECT field, it needs a menu icon too */

              if (tp->tagno == TAG_SELECT)
              {
                int  width, height, offset;
                BBox icon;

                /* Get the sprite size, work out a bounding box and plot */
                /* this as a virtual icon.                               */

                read_sprite_size("fgright", &width, &height);

                /* Work out the vertical offset */

                offset = (box.ymax - box.ymin - height) / 2;

                /* We've not adjusted width and height for the border for the */
                /* same reason as the '-2' below; in Redraw.c, this code will */
                /* give the icon itself a border and the icon contents are    */
                /* centred within the bounding box that takes account of this */
                /* - whereas here, we're just plotting the icon in a BBox     */
                /* which fits it closely at an absolute position.             */

                icon.xmin = box.xmax - width - 2;
                icon.ymin = box.ymin + offset;
                icon.xmax = icon.xmin + width;
                icon.ymax = icon.ymin + height;

                /* Output the icon */

                asize = savedraw_switch(icon.xmin, icon.ymin, "fgright", size);

                if (!asize) return 0;
                else *tsize += asize;

                /* If we're on a non-grey background, give it a border */

                if (redraw_backcol(b) != Redraw_Colour_BackGrey)
                {
                  *tsize += DSIZE_FRECT * 4;

                  if (!size)
                  {
                    int lw, lh;

                    lw = icon.xmax - icon.xmin;
                    lh = icon.ymax - icon.ymin;

                    if (!savedraw_rectangle_fill(OTD(icon.xmin - 2),  OTD(icon.ymin - 2),  OTD(lw + 4), OTD(2),      Redraw_Colour_Black)) return 0;
                    if (!savedraw_rectangle_fill(OTD(icon.xmin - 2),  OTD(icon.ymin - 2),  OTD(2),      OTD(lh + 4), Redraw_Colour_Black)) return 0;
                    if (!savedraw_rectangle_fill(OTD(icon.xmin + lw), OTD(icon.ymin - 2),  OTD(2),      OTD(lh + 4), Redraw_Colour_Black)) return 0;
                    if (!savedraw_rectangle_fill(OTD(icon.xmin - 2),  OTD(icon.ymin + lh), OTD(lw + 4), OTD(2),      Redraw_Colour_Black)) return 0;
                  }
                }
              }
            }
            else switch(HtmlINPUTtype(tp))
            {
              /* Graphics-based forms elements */

              case inputtype_CHECKBOX:
              {
                int ox, oy;

                convert_pair_to_os(x, y + base, &ox, &oy);

                asize = savedraw_switch(ox,
                                        oy - 8, /* See redraw_switch, which subtracts 8 from the Y value itself */
                                        form_get_field(b, d->cdata[cn].t) -> checked ? "fopton" : "foptoff",
                                        size);


                if (!asize) return 0;
                else *tsize += asize;
              }
              break;

              case inputtype_RADIO:
              {
                int ox, oy;

                convert_pair_to_os(x, y + base, &ox, &oy);

                asize = savedraw_switch(ox,
                                        oy - 8, /* See redraw_switch, which subtracts 8 from the Y value itself */
                                        form_get_field(b, d->cdata[cn].t) -> checked ? "fradioon" : "fradiooff",
                                        size);

                if (!asize) return 0;
                else *tsize += asize;
              }
              break;

              case inputtype_IMAGE: goto do_image; /* See a short distance below */

              case inputtype_HIDDEN: break;

              case inputtype_SUBMIT: /* SUBMIT same as RESET: no break */
              case inputtype_BUTTON: /* Again, no break                */
              case inputtype_RESET:
              {
                BBox         box;
                int          fh, ox, oy, colour, th, tw;
                const char * p;

                p = form_button_text(tp);

                convert_pair_to_os(x, y + base, &ox, &oy);

                fh = fm_find_token_font(b, tp, 0);

                fm_font_box(fh, &box);

                th = box.ymax - box.ymin;

                box.ymin = box.ymin + oy - 8;
                box.ymax = box.ymax + oy + 8;
                box.xmin = ox + 4;

                convert_to_os(x + d->cdata[cn].w,&box.xmax);

                /* Account for a border */

                box.xmax -= 4;

                /* Draw the button's plinth */

                colour = redraw_token_colour(b, tp);

                asize = savedraw_button(b, tp, &box, 0, size);

                if (!asize) return 0;
                else *tsize += asize;

                /* Plot the text (which will always fit in a button), centred horizontally */

                if (p && *p)
                {
                  int  length, end, offset;
                  char null = '\0';

                  length = strlen(p);
                  end    = 0;

                  while (end < length && p[end] != '\n') end++;

                  if (fm_get_string_width(fh,
                                          p,
                                          0x1000000,
                                          end - d->cdata[cn].o,
                                          -1,
                                          NULL,
                                          &tw)) return 0;

                  offset = (d->cdata[cn].w - tw) / 2 + 4;
                  if (offset < 0) offset = 0;

                  /* Output the header */

                  if (!savedraw_texthdr(b,
                                        tp,
                                        PTD(x + offset),
                                        PTD(y + base),
                                        PTD(tw),
                                        OTD(th),
                                        0,
                                        length,
                                        Redraw_Colour_BackGrey)) return 0;

                  else *tsize += sizeof(draw_trfmtextstrhdr);

                  /* (The count should include a terminator at this point) */

                  length++;

                  /* Output the text ifself */

                  *tsize += (int) WordAlign(length);

                  if (!savedraw_write_bytes(p, length - 1)) return 0;
                  if (!savedraw_write_bytes(&null, 1)) return 0;

                  if (length != (int) WordAlign(length))
                  {
                    if (!savedraw_write_bytes("    ", (int) WordAlign(length) - length)) return 0;
                  }
                }
              }
              break;
            }
          }

          /* Plot an imagem, OBJECT, EMBED or APPLET tag item */

          else if (ISOBJECT(tp) || (tp->style & IMG))
          {
            _kernel_oserror * e;
            BBox              box;
            int               ox, oy, o;
            int               ok;
            int               isobj;
            int               objim;

do_image: /* (This code is also used for form INPUT TYPE=IMAGE tags; see above) */

            if (ISOBJECT(tp)) isobj = 1, objim = object_token_is_image(b, tp);
            else              isobj = 0, objim = 0;

            convert_pair_to_os(x, y + base, &ox, &oy);

            e = isobj ? reformat_get_object_size(b, tp, &box) : reformat_get_image_size(b, tp, &box);

            if (!e)
            {
              draw_spristrhdr h;
              int             img_size = 0;

              if (!isobj || objim)
              {
                img_size = image_draw_file_size(b, tp, 1);

                h.tag    = draw_OBJSPRITE;
                h.size   = image_draw_file_size(b, tp, 1) + sizeof(h);
              }

              /* Correct the coordinates for plotting */

              ox -= box.xmin;

              box.xmin += ox;
              box.ymin += oy;
              box.xmax += ox;
              box.ymax += oy;

              /* Account for HSPACE / VSPACE; OBJECT calls work for IMGs too, */
              /* and the multpliers are for 1 'web pixel' = 2 OS units.       */

              box.xmin += HtmlOBJECThspace(tp) * 2;
              box.ymin += HtmlOBJECTvspace(tp) * 2;
              box.xmax -= HtmlOBJECThspace(tp) * 2;
              box.ymax -= HtmlOBJECTvspace(tp) * 2;

              /* Convert to the relevant coordinate space */

              h.bbox.xmin = OTD(box.xmin);
              h.bbox.ymin = OTD(box.ymin);
              h.bbox.xmax = OTD(box.xmax);
              h.bbox.ymax = OTD(box.ymax);

              /* Find the border width (if any) */

              if (isobj)                o = HtmlOBJECTborder(tp);
              else if (tp->style & IMG) o = tp->maxlen * 2;
              else                      o = 0;

              /* If we have an image to plot, output it */

              if (img_size)
              {
                if (!savedraw_write_bytes((char *) &h, sizeof(h))) return 0;

                /* Output the image itself - do this before the */
                /* image border (if any) so if there's some     */
                /* rounding when the Draw file is viewed scaled */
                /* down, the border doesn't get hidden.         */

                ok = image_to_draw_file(b, r, tp, o + box.xmin, o + box.ymin, 1);

                if (!ok) return 0;
              }

              /* Otherwise, output a placeholder */

              else
              {
                BBox         pbox = box;
                const char * text;
                int          asize;

                pbox.xmin += o;
                pbox.ymin += o;

                pbox.xmax -= pbox.xmin + o;
                pbox.ymax -= pbox.ymin + o;

                pbox.xmin &= ~1;
                pbox.ymin &= ~1;

                /* Work out what text to plot */

                text = objim ? HtmlOBJECTstandby(tp) : tp->text;

                /* Output the placeholder */

                asize = savedraw_draw_placeholder(b,
                                                  r,
                                                  &pbox,
                                                  tp,
                                                  text,
                                                  NULL);

                if (!asize) return 0;
                else *tsize += asize;
              }

              /* Draw a border of tp->maxlen * 2 OS units width around an image. */
              /* This comes from the image's BORDER attribute.                   */

              if (o)
              {
                unsigned int c = redraw_token_colour(b, tp);

                *tsize += 4 * DSIZE_FRECT;

                if (!size)
                {
                  if (!savedraw_rectangle_fill(OTD(box.xmin),     OTD(box.ymin),     OTD(box.xmax - box.xmin), OTD(o),                   c)) return 0;
                  if (!savedraw_rectangle_fill(OTD(box.xmin),     OTD(box.ymin),     OTD(o),                   OTD(box.ymax - box.ymin), c)) return 0;
                  if (!savedraw_rectangle_fill(OTD(box.xmin),     OTD(box.ymax - o), OTD(box.xmax - box.xmin), OTD(o),                   c)) return 0;
                  if (!savedraw_rectangle_fill(OTD(box.xmax - o), OTD(box.ymin),     OTD(o),                   OTD(box.ymax - box.ymin), c)) return 0;
                }
              }
            }
          }

          /* Plot a horizontal rule */

          else if (tp->style & HR)
          {
            int w, h, lmarg, ox, oy = 0;

            convert_to_os(y, &oy);

//            lmarg = redraw_left_gap(b, d, tp);
            lmarg = redraw_start_x(b, d, tp, l);

            convert_to_os(d->cdata[cn].w, &w);

            /* Round width to a multiple of 2 and limit check it. */
            /* Allow sizes greater than the available width, in   */
            /* which case align to the left and draw to whatever  */
            /* width was requested.                               */

            w = w &~ 1;
            if (w < 2) w = 2;

            /* Deal with a size (height) specifier */

            if (HR_HAS_SIZE(tp))
            {
              /* Currently only recognise pixels */

              switch (HR_SIZE_UNITS(tp))
              {
                case UNITS_PIXELS: h = HR_SIZE(tp) * 2; break;

                /* (IMPORTANT: If adding extra units, ensure h ends up a multiple of 2) */

                default: h = 4; break;
              }
            }
            else h = 4;

            /* Limit check the height */

            if (h < 2) h = 2;

            /* Sort out the horizontal and vertical plotting offsets; */
            /* centre vertically, and align horizontally as specified */
            /* in the token.                                          */

            oy += ((d->ldata[l].h - h) / 2) &~3 - 4;
            oy += 6;

            ox = (coords_x_toscreen(lmarg + osxorg, r) &~1);

            /* Change ox and oy to draw coordinates */

            ox = OTD(ox);
            oy = OTD(oy);

            /* Plot a black rule if NOSHADE is specified or the height */
            /* or width are less than 4 OS units, else plot a '3D'     */
            /* rule.                                                   */

            if (HR_NOSHADE(tp) || h < 4 || w < 4)
            {
              *tsize += DSIZE_FRECT; /* 1 rectangle */

              if (!savedraw_rectangle_fill(ox, oy, OTD(w), OTD(h), 0)) return 0;
            }
            else
            {
              if (h == 4)
              {
                /* Simple 'groove' rule */

                h = h / 2;

                w = OTD(w);
                h = OTD(h);

                *tsize += 2 * DSIZE_FRECT; /* 2 rectangles */

                if (!savedraw_rectangle_fill(ox, oy,     w, h, Redraw_Colour_MidGrey))     return 0;
                if (!savedraw_rectangle_fill(ox, oy - h, w, h, Redraw_Colour_AlmostWhite)) return 0;
              }
              else
              {
                /* 3D 'box' rule */

                w = OTD(w);
                h = OTD(h);

                *tsize += 4 * DSIZE_FRECT; /* 4 rectangles */

                if (!savedraw_rectangle_fill(ox,              oy,              w,      OTD(2), Redraw_Colour_AlmostWhite)) return 0;
                if (!savedraw_rectangle_fill(ox + w - OTD(2), oy,              OTD(2), h,      Redraw_Colour_AlmostWhite)) return 0;
                if (!savedraw_rectangle_fill(ox,              oy + h - OTD(2), w,      OTD(2), Redraw_Colour_MidGrey))     return 0;
                if (!savedraw_rectangle_fill(ox,              oy,              OTD(2), h,      Redraw_Colour_MidGrey))     return 0;
              }
            }
          }

          /* Plot a bullet point */

          else if (ISBULLET(tp))
          {
            int  ox, oy;
            int  asize;
            char spr[32];

            sprintf(spr, "b%d\0", (tp->indent + bullets - 1) % bullets);

            convert_pair_to_os(x, y + base, &ox, &oy);

            asize = savedraw_switch(ox, oy, spr, size);

            if (!asize) return 0;
            else *tsize += asize;
          }

          /* Plot some text */

          else
          {
            dp = tp->text;

            if (dp)
            {
              BBox   size;
              int    c, yofs, height;
              int    drax, dray;
              int    length;
              char   null = '\0';
              char * start;
              char * end;

              /* Find the font handle for the token, and its colour */

              h = fm_find_token_font(b, tp, 0);
              c = redraw_token_colour(b, tp);

              /* Find the text height in OS units */

              fm_font_box(h, &size);
              height = size.ymax - size.ymin;

              /* Work out the y offset to plot at */

              if (ISSUP(tp))
              {
                /* Shift baseline up for superscript text. The following */
                /* will be for the SUP size text, remember...            */

                convert_to_points(height, &yofs);

                /* SUP height = normht * 3 / 5, so to get normal  */
                /* height from SUP do height * 5 / 3. Then want   */
                /* to get the height remaining and use this as an */
                /* addition for the y positioning, so need to add */
                /* (normht - hormht * 3 / 5) = normht * 2 / 5.    */
                /* This all simplifies out to height * 2 / 3, but */
                /* this looks too high in practice, so it's taken */
                /* down a bit from that.                          */

                yofs = y + base + (yofs / 2);
              }
              else if (ISSUB(tp))
              {
                /* Shift the baseline down a bit for subscript text */

                yofs = y + (base * 4) / 5;
              }
              else yofs = y + base;

              /* Get the x and y coords in Draw coordinate units */

              drax = PTD(x);
              dray = PTD(yofs);

              length = d->cdata[cn].l + 1;

              /* Can't have control characters in the Draw file output */

              start = dp + d->cdata[cn].o;
              end   = start + length - 2;

              while (length > 1 && *start && *start < ' ') start ++, length --;
              while (length > 1 && *end   < ' ')           end   --, length --;

              if (length && d->cdata[cn].w && d->ldata[l].h)
              {
                /* Write the text item header */

                *tsize += sizeof(draw_trfmtextstrhdr);

                if (!savedraw_texthdr(b,
                                      tp,
                                      drax,
                                      dray,
                                      PTD(d->cdata[cn].w),
                                      OTD(d->ldata[l].h),
                                      0,
                                      length - 1,
                                      redraw_background_colour(b, c))) return 0;

                /* Write the text itself */

                *tsize += (int) WordAlign(length);

                if (!savedraw_write_bytes(start, length - 1)) return 0;
                if (!savedraw_write_bytes(&null, 1)) return 0;

                if (length != (int) WordAlign(length))
                {
                  if (!savedraw_write_bytes("    ", (int) WordAlign(length) - length)) return 0;
                }

                /* Deal with underlining. The position should not be affected */
                /* by SUB or SUP text.                                        */

                if (
                     (
                       (
                         ISLINK(tp) &&
                         b->underline_links
                       )
                       || ISUNDERLINE(tp)
                     )
                     && !(tp->tagno == TAG_TABLE)
                   )
                {
                  /* Underline the item - set the colour, and start at the item's x coordinate... */

                  int ox, oy, w, c;

                  /* Find the colour */

                  c = redraw_token_colour(b, tp);

                  /* Work out the coordinates (in OS units) */

                  convert_pair_to_os(x, y + base, &ox, &oy);
                  oy -= 7;

                  /* Draw the 'line' as a rectangle */

                  ox = OTD(ox);
                  oy = OTD(oy);

                  w = PTD(d->cdata[cn].w);

                  *tsize += DSIZE_FRECT;
                  if (!savedraw_rectangle_fill(ox, oy, w, OTD(2), c)) return 0;
                }

                /* Deal with STRIKE text. This needs to have the strikethrough */
                /* line through the text middle, as opposed to following the   */
                /* body text font baseline (so SUB and SUP *will* have an      */
                /* effect on the positioning).                                 */

                if (ISSTRIKE(tp) && !(tp->tagno == TAG_TABLE))
                {
                  int ox, oy, w, c;
                  int hs;

                  c = redraw_token_colour(b, tp);

                  convert_pair_to_os(x, yofs, &ox, &oy);
                  hs = height / 4;
                  oy += hs;

                  ox = OTD(ox);
                  oy = OTD(oy);

                  w = PTD(d->cdata[cn].w);

                  *tsize += DSIZE_FRECT;
                  if (!savedraw_rectangle_fill(ox, oy, w, OTD(2), c)) return 0;
                }
              }
            }
          }

        /* Closure of long 'if' checking if the current chunk */
        /* lies partially or entirely within the redraw area. */
        /* If it does, the code above executes.               */
        }

      /* Closure of 'for' looping round chunks on a given line */
      /* that lies partially or entirely within the redraw     */
      /* area.                                                 */
      }

    /* Closure of long 'if' checking if the current line lies */
    /* partially or entirely within the redraw area. The code */
    /* above executes if it does.                             */
    }

  /* Closure of 'for' looping for all lines in the document. */
  }

  if (size) *size = *tsize;

  return 1;
}

/**************************************************************/
/* savedraw_save_draw()                                       */
/*                                                            */
a1224 2
  int success = 0;

d1237 2
d1251 1
a1251 2
    success = savedraw_create(b, bgimages, NULL);
    StrLastE;
d1258 1
a1258 1
    if (!success) return &erb;
d1292 5
a1296 1
  int size;
d1298 3
d1302 3
a1304 1
size = 4096;
d1306 1
a1306 1
  return size;
@


1.6
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d84 1
a84 1
static int  savedraw_triangle_fill    (int x1, int y1, int x2, int y2, int x3, int y3, int c);
d86 1
a86 1
static int  savedraw_input_field      (browser_data * b, HStream * t, BBox * box, int colour, int menu, int * size);
d89 1
a89 1
static int  savedraw_texthdr          (browser_data * b, HStream * tp, int x, int y, int w, int h, int base, int length, int bgnd);
d148 1
a148 1
int savedraw_rectangle_fill(int x, int y, int w, int h, int c)
d238 1
a238 1
static int savedraw_triangle_fill(int x1, int y1, int x2, int y2, int x3, int y3, int c)
d362 1
a362 1
static int savedraw_input_field(browser_data * b, HStream * t, BBox * box, int colour, int menu, int * size)
d572 1
a572 1
                            int w, int h, int base, int length, int bgnd)
d2666 1
a2666 1
int savedraw_draw_size(browser_data * b, int bgimages)
@


1.5
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a42 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

@


1.4
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d15 13
a27 11
/***************************************************/
/* File   : SaveDraw.c                             */
/*                                                 */
/* Purpose: Save a web page as a Draw file.        */
/*                                                 */
/* Author : Merlyn Kline for Customer browser;    */
/*          This source adapted by A.D.Hodgkinson  */
/*          including bits from RISC_OSLib.        */
/*                                                 */
/* History: 13-Dec-97: Created.                    */
/***************************************************/
d33 9
a41 2
#include "swis.h"
#include "flex.h"
d43 4
a46 5
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"
a47 1
#include "svcprint.h"
d73 1
a73 1
  #include "Unicode/iso10646.h"
d101 16
a116 18
/*************************************************/
/* savedraw_write_bytes()                        */
/*                                               */
/* Outputs a given number of bytes of a given    */
/* string to the FILE * set up in the global     */
/* 'outfile', returning a success flag.          */
/*                                               */
/* Parameters: Pointer to an array of bytes;     */
/*                                               */
/*             Number of characters from the     */
/*             array to save.                    */
/*                                               */
/* Returns:    1 if successful, 0 if failed.     */
/*                                               */
/* Assumes:    An appropriately opened file is   */
/*             accessible through the global     */
/*             FILE * 'outfile'.                 */
/*************************************************/
d137 15
a151 18
/*************************************************/
/* savedraw_rectangle_fill()                     */
/*                                               */
/* Output a filled rectangle.                    */
/*                                               */
/* Parameters: x position of the item in Draw    */
/*             coordinates;                      */
/*                                               */
/*             y position of the item in Draw    */
/*             coordinates;                      */
/*                                               */
/*             Item's width in Draw coordinates; */
/*                                               */
/*             Item's height in Draw             */
/*             coordinates;                      */
/*                                               */
/*             Colour of the rectangle.          */
/*************************************************/
d232 10
a241 10
/*************************************************/
/* savedraw_triangle_fill()                      */
/*                                               */
/* Output a filled triangle.                     */
/*                                               */
/* Parameters: x and y coordinates of the three  */
/*             vertices, in Draw coordinates;    */
/*                                               */
/*             Colour of the triangle.           */
/*************************************************/
d302 17
a318 18
/*************************************************/
/* savedraw_font_info()                          */
/*                                               */
/* Find details of the font a token would use.   */
/*                                               */
/* Parameters: Pointer to the HStream struct     */
/*             relevant to the enquiry;          */
/*                                               */
/*             Pointer to an int, in which the   */
/*             number of the font (from the Draw */
/*             file's font table) is returned;   */
/*                                               */
/*             Pointer to an int, in which the   */
/*             font size in 16ths pt. is         */
/*             written.                          */
/*                                               */
/* Assumes:    Neither int pointer may be NULL.  */
/*************************************************/
d338 28
a365 31
/*************************************************/
/* savedraw_input_field()                        */
/*                                               */
/* For forms, create an input field element.     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the element;          */
/*                                               */
/*             Pointer to the token representing */
/*             this element;                     */
/*                                               */
/*             BBox of the field, in window      */
/*             coords (and thus OS units);       */
/*                                               */
/*             Border colour (as a palette       */
/*             entry, for more details see       */
/*             redraw_set_colour());             */
/*                                               */
/*             1 if this is a display field,     */
/*             i.e. it has a menu icon, and the  */
/*             border colour is ignored, else 0; */
/*                                               */
/*             Pointer to an int if wanting to   */
/*             know the size of the item only,   */
/*             else NULL (NB the int contents    */
/*             are not updated - the pointer is  */
/*             acting like a flag, basically).   */
/*                                               */
/* Returns:    Size of item written out, or 0 if */
/*             it failed.                        */
/*************************************************/
d416 25
a440 28
/*************************************************/
/* savedraw_button()                             */
/*                                               */
/* For forms, redraws a button element.          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the element;          */
/*                                               */
/*             Pointer to the token representing */
/*             this element;                     */
/*                                               */
/*             BBox of the field, in window      */
/*             coords (and thus OS units);       */
/*                                               */
/*             1 to be slabbed in, 2 to be       */
/*             slabbed in but with a light grey  */
/*             background rather than dark, else */
/*             0;                                */
/*                                               */
/*             Pointer to an int if wanting to   */
/*             know the size of the item only,   */
/*             else NULL (NB the int contents    */
/*             are not updated - the pointer is  */
/*             acting like a flag, basically).   */
/*                                               */
/* Returns:    Size of item written out, or 0 if */
/*             it failed.                        */
/*************************************************/
d483 16
a498 20
/*************************************************/
/* savedraw_switch()                             */
/*                                               */
/* Output a switch (small sprite) at given       */
/* coordinates.                                  */
/*                                               */
/* Parameters: x position of the item in Draw    */
/*             coordinates;                      */
/*                                               */
/*             y position of the item in Draw    */
/*             coordinates;                      */
/*                                               */
/*             Pointer to the sprite's name;     */
/*                                               */
/*             Pointer to an int if wanting to   */
/*             know the size of the item only,   */
/*             else NULL (NB the int contents    */
/*             are not updated - the pointer is  */
/*             acting like a flag, basically).   */
/*************************************************/
d547 28
a574 33
/*************************************************/
/* savedraw_texthdr()                            */
/*                                               */
/* Outputs a header for a text item.             */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             for which the item is to be       */
/*             output;                           */
/*                                               */
/*             Pointer to an HStream struct      */
/*             from which the foreground colour  */
/*             and font to use is drawn (and     */
/*             nothing else);                    */
/*                                               */
/*             x position of the item in Draw    */
/*             coordinates;                      */
/*                                               */
/*             y position of the item in Draw    */
/*             coordinates;                      */
/*                                               */
/*             Item's width in Draw coordinates; */
/*                                               */
/*             Item's height in Draw             */
/*             coordinates;                      */
/*                                               */
/*             Baseline offset for the text      */
/*             (added to the y coordinate);      */
/*                                               */
/*             Length of the string that this    */
/*             header will be representing;      */
/*                                               */
/*             Background colour to use.         */
/*************************************************/
d638 31
a668 37
/*************************************************/
/* savedraw_draw_placeholder()                   */
/*                                               */
/* Redraws a slabbed in place holder (unless the */
/* item is very small, in which case just at     */
/* thin black border is plotted) for a given     */
/* token, with optional text inside.             */
/*                                               */
/* Parameters: A pointer to a browser_data       */
/*             structure relevant to the redraw; */
/*                                               */
/*             A WimpRedrawWindowBlock pointer,  */
/*             with window area and redraw       */
/*             rectangle details filled in;      */
/*                                               */
/*             Pointer to a BBox in which xmin   */
/*             and ymin hold the screen coords   */
/*             for the bottom left hand corner,  */
/*             and xmax and ymax hold the width  */
/*             and height of the placeholder in  */
/*             OS units;                         */
/*                                               */
/*             Pointer to the HStream struct the */
/*             placeholder is to represent;      */
/*                                               */
/*             Pointer to a null-terminated      */
/*             piece of to plot inside, or NULL; */
/*                                               */
/*             Pointer to an int if wanting to   */
/*             know the size of the item only,   */
/*             else NULL (NB the int contents    */
/*             are not updated - the pointer is  */
/*             acting like a flag, basically).   */
/*                                               */
/* Returns:    Size of item written out, or 0 if */
/*             it failed.                        */
/*************************************************/
d857 39
a895 46
/*************************************************/
/* savedraw_textarea_redraw()                    */
/*                                               */
/* Outputs the text in a text area object.       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the text area;        */
/*                                               */
/*             Pointer to the token representing */
/*             the text area;                    */
/*                                               */
/*             Pointer to a BBox holding the     */
/*             bounding box of the text area, in */
/*             screen coords (so OS units);      */
/*                                               */
/*             Pointer to a BBox holding the     */
/*             current graphics window (usually  */
/*             from a call to the Wimp to redraw */
/*             something - remember that this    */
/*             can't be read during a printing   */
/*             routine as VDU variables may not  */
/*             be read during printing);         */
/*                                               */
/*             A font handle for the font to use */
/*             for the redraw;                   */
/*                                               */
/*             1 if the text area has multiple   */
/*             lines, 0 to render all text on    */
/*             one line only;                    */
/*                                               */
/*             1 if the text area represents a   */
/*             password object (show the text as */
/*             a line of *s, instead of the      */
/*             actual chars), else 0;            */
/*                                               */
/*             Pointer to an int if wanting to   */
/*             know the size of the item only,   */
/*             else NULL (NB the int contents    */
/*             are not updated - the pointer is  */
/*             acting like a flag, basically).   */
/*                                               */
/* Returns:    Size of item written out (which   */
/*             may be zero), or -1 for failure - */
/*             note how this differs from most   */
/*             other functions in this source!   */
/*************************************************/
d1064 18
a1081 21
/*************************************************/
/* savedraw_create()                             */
/*                                               */
/* Output a Draw file representing the contents  */
/* of a given browser, or find out how big the   */
/* file would be. The static 'outfile' local to  */
/* this file should hold a valid FILE * to       */
/* output to in the first case.                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             to represent in the Draw file;    */
/*                                               */
/*             1 to include any background       */
/*             image present on the browser's    */
/*             page, else 0;                     */
/*                                               */
/*             Pointer to an int to take the     */
/*             file size if that's all you want, */
/*             or NULL to actually output the    */
/*             file.                             */
/*************************************************/
d1219 40
a1258 47
/*************************************************/
/* savedraw_create_r()                           */
/*                                               */
/* Recursive back-end to savedraw_create. API is */
/* similar in many ways to redraw_draw_r.        */
/*                                               */
/* Parameters: 1 if being called externally, or  */
/*             0 if being called recursively;    */
/*                                               */
/*             x coord of offset from the top    */
/*             right to 'plot' at (in milli-     */
/*             points);                          */
/*                                               */
/*             y coord of offset from the top    */
/*             right to 'plot' at (in milli-     */
/*             points);                          */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             to represent in the Draw file;    */
/*                                               */
/*             Pointer to the reformat_cell      */
/*             which is to be output;            */
/*                                               */
/*             1 to draw no backgrounds, else 0; */
/*                                               */
/*             A WimpRedrawWindowBlock pointer   */
/*             containing details on the area    */
/*             of the page to output;            */
/*                                               */
/*             1 to include any background       */
/*             image present on the browser's    */
/*             page, else 0;                     */
/*                                               */
/*             Pointer to an int to take the     */
/*             file size if that's all you want, */
/*             or NULL to actually output the    */
/*             file;                             */
/*                                               */
/*             Pointer to an int in which the    */
/*             file size of the current chunk    */
/*             / cell (which may not be the      */
/*             whole file) is written.           */
/*                                               */
/* Assumes:    Pointers must be valid and not    */
/*             NULL unless otherwise specified   */
/*             above.                            */
/*************************************************/
d2589 13
a2601 16
/*************************************************/
/* savedraw_save_draw()                          */
/*                                               */
/* Save a given browser page as a Draw file.     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the page to save as   */
/*             a Draw file;                      */
/*                                               */
/*             Pointer to the pathname to save   */
/*             to;                               */
/*                                               */
/*             1 to include background image     */
/*             tiling if there is such an image, */
/*             else 0 (0 recommended!).          */
/*************************************************/
d2654 16
a2669 20
/*************************************************/
/* savedraw_draw_size()                          */
/*                                               */
/* Returns the size of file that would be        */
/* written by savedraw_save_draw for the given   */
/* browser.                                      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the page to save as   */
/*             a Draw file, for which the file   */
/*             size is to be returned;           */
/*                                               */
/*             1 to include background image     */
/*             tiling in the count if there is   */
/*             such an image, else 0.            */
/*                                               */
/* Returns:    Size of file that would be        */
/*             written by savedraw_save_draw for */
/*             the given browser.                */
/*************************************************/
@


1.3
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d2331 2
a2332 1
            lmarg = redraw_left_gap(b, d, tp);
d2684 1
a2684 1
                 _INR(0,2) | _INR(4,5),
@


1.2
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d2232 10
d2671 1
d2678 1
a2678 1
    if (!success) RetLastE;
@


1.1
log
@Not all resources are up to date in this check-in, and documentation
both within source and stuff in 'Docs' is out of date or missing - I
was very pushed for time on this one... Hopefully will do another
'tidy up' check-in before close on Friday; until then, beware of
anything other than the Ursula (Desktop browser) build. Anyway...

Export As Draw done. As part of this, FONT SIZE and SUP / SUB adjustment
of font size is done in fm_token_font_info rather than fm_find_token_font.

Bullets and switches are plotted as indirected sprite items, rather than
indirected text + sprite items - this relied on being in a redraw loop to
pick the sprites up from the local pool (failed during printing).

URI files now have a LF line ending rather than CR... '*' recognised
as an empty field when loading via. RAM transfer now (only worked for
loading from disc before).

Gave placeholder bounding boxes 4 OS units more minimum extra gap
vertically and reduced horizontal addition to this value * 1.5, rather
than * 2 (see reformat_get_placeholder_size).

Background image tiling starts at ymax - h + 4, rather than ymax, so
there isn't the bottom line of pixels from the top tile always present
at the top of the window. The '+4' is for caution's sake.

Can now save a frame's HTML source, that of its parent or its ancestor,
and the same for the URI pointing to those documents - see Menus.h for
the relevant component IDs that should lead to the SaveFile dialogue.

Have hopefully fixed timeout = 0 values (i.e. 'forever') on things
like LinkTo; before, image fetches could override the state (so you'd
only ever see brief flickers of a given URL as the pointer went over
a link).

Save File dialogue will remember the state of option or radio buttons
for a given parent component origin and restore that state when the
dialogue is next opened from the same place (stops turning on saving
as a URL file also turning on 'save background images' for Draw file
export, etc.).

Use of a META tag to reload the *same* page now sets the 'reloading'
flag in the browser so that it doesn't go through a proxy - otherwise
pages which are meant to update periodically through client pull
don't work, as they keep coming out of the cache.

Can now handle images specifying just a width or height in the HTML
(other dimension is scaled accordingly, but note that the placeholder
size must still be 'dumb' until the image data comes in). An image
will now override an image history size entry for the same entry
with a different size.
@
text
@d135 14
d233 6
d303 14
d491 16
d559 29
d593 2
a594 2
  draw_textstrhdr hdr;
  int             number, size;
d619 2
a620 2
  hdr.tag                  = draw_OBJTEXT;
  hdr.size                 = sizeof(draw_textstrhdr) + (int) WordAlign(length + 1);
d625 7
d812 4
a815 4
        draw_textstrhdr hdr;
        int             c      = redraw_token_colour(b, token);
        int             length = strlen(text) + 1;
        char            null   = '\0';
d819 2
a820 2
        hdr.tag                  = draw_OBJTEXT;
        hdr.size                 = sizeof(draw_textstrhdr) + (int) WordAlign(length);
d825 7
d1037 1
a1037 1
          tsize += sizeof(draw_textstrhdr);
d1094 17
d1252 43
d1528 2
a1529 2
              int              cellcount  = 0;
              int              cellmax    = table->ColSpan * table->RowSpan;
d1540 94
a1633 1
                row = table->List;
a1742 7
                            /* Update the table bounding box as required */

                            if (cx      < tbox.xmin) tbox.xmin = cx;
                            if (cy      < tbox.ymin) tbox.ymin = cy;
                            if (cx + cw > tbox.xmax) tbox.xmax = cx + cw;
                            if (cy + ch > tbox.ymax) tbox.ymax = cy + ch;

a1834 7
                  /* tbox doesn't take account of cell spacing */

                  tbox.xmin -= table->cellspacing * 2;
                  tbox.ymin -= table->cellspacing * 2;
                  tbox.xmax += table->cellspacing * 2;
                  tbox.ymax += table->cellspacing * 2;

d2096 1
d2167 1
a2167 1
                  else *tsize += sizeof(draw_textstrhdr);
d2317 1
a2317 1
            int w, h, available, ox, rmarg, lmarg, oy = 0;
d2321 1
a2321 3
            available = redraw_display_width(b, d);

            /* Work out margins */
d2323 1
a2323 34
            lmarg = redraw_margin(b, d, tp);

            if (tp->style & BLOCKQUOTE) rmarg = lmarg;
            else                        rmarg = redraw_right_margin(b, d);

            convert_pair_to_os(lmarg, rmarg, &lmarg, &rmarg);

            /* Left margin already takes account of cellpadding in tables, */
            /* but right margin doesn't; so we need to do that now.        */

            if (d->table) rmarg += d->table->cellpadding * 2; /* 1 'web pixel' = 2 OS units */

            /* In (for example) Netscape Navigator (TM), a 100% width HR */
            /* will only span between the left and right margins. So     */
            /* want to reduce apparent available space by this amount.   */

            available -= (lmarg + rmarg);
            if (available < 0) available = 0;

            /* Deal with a width specifier */

            if (HR_HAS_WIDTH(tp))
            {
              /* Currently recognise pixels and percentages */

              switch (HR_WIDTH_UNITS(tp))
              {
                case UNITS_PIXELS:  w = HR_WIDTH(tp) * 2;               break;
                case UNITS_PERCENT: w = available * HR_WIDTH(tp) / 100; break;

                default: w = available; break;
              }
            }
            else w = available;
d2361 1
a2361 3
            if (HR_ALIGN(tp) == ALIGN_LEFT || w > available) ox = lmarg;
            else if (HR_ALIGN(tp) == ALIGN_RIGHT)            ox = redraw_display_width(b, d) - rmarg - w;
            else                                             ox = ((redraw_display_width(b, d) - w) >> 1);
d2363 1
a2363 1
            ox = (coords_x_toscreen(ox + osxorg, r) &~1);
d2371 1
d2502 1
a2502 1
                *tsize += sizeof(draw_textstrhdr);
@

head	1.18;
access;
symbols
	Browse-2_16:1.18
	Browse-2_15:1.18
	Browse-2_14:1.18
	Browse-2_13:1.18
	Browse-2_12:1.18
	Browse-2_11:1.17
	Browse-2_10:1.17
	Browse-2_09:1.17
	ahodgkin_208_i4_2:1.16
	ahodgkin_208_i4:1.14
	ahodgkin_208_i3:1.14
	ahodgkin_208_i2:1.13
	ahodgkin_208_i1:1.12
	ahodgkin_207release:1.10
	ahodgkin_206release:1.7
	ahodgkin_205release:1.6
	ahodgkin_204release:1.6
	ahodgkin_202release:1.6
	ahodgkin_201release:1.6
	ahodgkin_200release:1.6
	ahodgkin_133beta:1.6
	ahodgkin_132beta:1.6
	ahodgkin_131beta:1.6
	ahodgkin_130beta:1.6
	ahodgkin_129:1.6
	ahodgkin_128beta:1.6
	ahodgkin_128alpha:1.6
	ahodgkin_127beta2:1.6
	ahodgkin_127beta:1.6
	ahodgkin_126beta:1.6
	ahodgkin_AW97patch:1.6
	ahodgkin_AW97:1.6;
locks; strict;
comment	@# @;


1.18
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.26.09.42.34;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.14.08.45.06;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.31.15.58.39;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.01.08.45.33;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.25.17.08.53;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	99.09.02.13.10.23;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	99.03.30.15.51.51;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	98.10.06.09.28.55;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	98.09.23.13.18.10;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	98.09.07.11.46.53;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	98.07.09.10.27.14;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.08.31.18.38.18;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.08.18.09.23.59;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.08.08.16.38.52;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.07.31.14.50.13;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.07.30.12.39.08;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.07.25.13.12.28;	author ahodgkin;	state Exp;
branches;
next	;


desc
@@


1.18
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    JavaScript.c                                      */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: JavaScript support.                               */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 24-Jul-1997 (ADH): Created.                       */
/*          25-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include "Global.h"
#include "Utils.h"

#include "Browser.h"
#include "EventLogs.h"
#include "FetchPage.h"
#include "Filetypes.h"
#include "Frames.h"
#include "Handlers.h"
#include "History.h"
#include "Main.h"
#include "Multiuser.h"
#include "Protocols.h"
#include "Save.h"
#include "Windows.h"
#include "URLutils.h"

#include "JavaScript.h"

#ifdef JAVASCRIPT

  #include "JSconsts.h"
  #include "JSwindow.h"

  /* Local compilation options */

  #define BRANCH_CALLBACK_GC_MASK  0
  #define BRANCH_CALLBACK_LED_MASK 63

  #undef  ATTEMPT_JS_POLL

  /* JavaScript post-execution action structure */

  struct javascript_postexec;

  typedef struct javascript_postexec
  {
    struct javascript_postexec * next;

    browser_data               * b;
    unsigned int                 type;

  } javascript_postexec;

  /* Static function prototypes */

  static JSBool PR_CALLBACK   javascript_watchdog                 (JSContext * cx, JSScript * script);
  static void                 javascript_error                    (JSContext * cx, const char * message, JSErrorReport * report);
  static void                 javascript_clear_post_exec_actions  (void);
  static _kernel_oserror    * javascript_handle_post_exec_actions (void);

  /* Other local statics */

  static unsigned int          watchdog_counter;
  static unsigned int          watchdog_start;
  static unsigned int          watchdog_leds;

  static browser_data        * script_browser = NULL;
  static javascript_source     script_source  = JavaScript_Source_Unknown;
  static char                * script_write_p = NULL;
  static int                   script_write_l = 0;

  static int                   source_set     = 0;
  static int                   doc_write_used = 0;
  static int                   proceed        = 0;

  static browser_data        * pending_b      = NULL;
  static char                * pending_url    = NULL;
  static int                   pending_record = 0;
  static int                   pending_stop   = 0;

  static javascript_postexec * postexec_head  = NULL;

#endif

/**************************************************************/
/* javascript_body_onload()                                   */
/*                                                            */
/* When a page has finished fetching the main page data, a    */
/* BODY tag may specify some JavaScript action. This functon  */
/* should be called to carry out that action.                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct with a filled */
/*             in 'onload' field describing the contents of   */
/*             the onLoad command in the HTML.                */
/**************************************************************/

_kernel_oserror * javascript_body_onload(browser_data * b)
{
  _kernel_oserror * e = NULL;

  dprintf(("JScr", "javascript_body_onload: Called\n"));

  if (!b->onload || !*b->onload) return NULL;

  #ifdef JAVASCRIPT

    javascript_set_source(JavaScript_Source_MiscEvent);
    e = javascript_process_script(b, b->onload);

  #endif

  /* Prevent multiple script executions... */

  b->onload = "";

  return e;
}

/**************************************************************/
/* javascript_href_onclick()                                  */
/*                                                            */
/* When something is clicked upon that has an onClick         */
/* attribute specified for it, this function is called with   */
/* the details of that attribute.                             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the item clicked on;                           */
/*                                                            */
/*             Pointer to the token representing that item;   */
/*                                                            */
/*             Pointer to an int, in which 1 is written if    */
/*             the contents of the HREF attribute in the link */
/*             that held the onClick should be ignored (else  */
/*             0 is written), the implication being that the  */
/*             onClick JavaScript code had a side effect; may */
/*             be NULL if not interested.                     */
/**************************************************************/

_kernel_oserror * javascript_href_onclick(browser_data * b, HStream * t, int * ignore)
{
  _kernel_oserror * e = NULL;

  dprintf(("JScr", "javascript_href_onclick: Called\n"));

  #ifdef JAVASCRIPT

    e = javascript_process_script(b, t->onclick);
    if (ignore) *ignore = 1;

  #else

    if (ignore) *ignore = 0;

  #endif

  return e;
}

/**************************************************************/
/* javascript_window_open()                                   */
/*                                                            */
/* Opens a given URL in a given target window.                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the window_open call;                          */
/*                                                            */
/*             1 if the specified target window must be found */
/*             to proceed, else 0 (if the target isn't found  */
/*             the URL is opened in the given browser         */
/*             instead);                                      */
/*                                                            */
/*             1 if the URL displayed in the target is to be  */
/*             recorded in the History before the new one is  */
/*             fetched, else 0;                               */
/*                                                            */
/*             Pointer to the URL to fetch;                   */
/*                                                            */
/*             Pointer to the target (or NULL / a null string */
/*             for the given browser).                        */
/**************************************************************/

_kernel_oserror * javascript_window_open(browser_data * b, int must_find, int record, char * url, char * target)
{
  _kernel_oserror * e;
  browser_data    * targetted = b;
  int               free_it   = 0;

  dprintf(("JScr", "javascript_window_open: Called for %p with '%s' and target '%s'\n",b,url,target));

  /* Exit if no URL or base browser is given */

  if (!b || !url || !*url) return NULL;

  /* If a target is specified, try and find it */

  if (target && *target)
  {
    browser_data * ancestor = utils_ancestor(b);

    dprintf(("JScr", "javascript_window_open: Proceeding with target '%s'\n",target));

    targetted = frames_find_named(ancestor, target);

    dprintf(("JScr", "javascript_window_open: targetted = %p\n",targetted));

    /* If the target can't be found and the parameters specify it must be, */
    /* then exit; else target the base browser instead.                    */

    if (!targetted)
    {
      if (must_find) return NULL;
      else targetted = b;
    }
  }

  /* Open the URL */

  dprintf(("JScr", "javascript_window_open: Opening to target %p\n",targetted));

  /* Relativise the URL if necessary */

  if (!strstr(url, HTTPmethod ProtocolSeparator)) /* (URLutils.h) */
  {
    browser_data * ancestor = utils_ancestor(targetted);
    char         * r_url;

    dprintf(("JScr", "javascript_window_open: Relativising URL\n"));

    /* Need to go down a sequence of options for which URL to relativise to! */

    r_url = browser_current_url(targetted);

    if (!r_url) r_url = browser_fetch_url(targetted);
    if (!r_url) r_url = browser_current_url(ancestor);
    if (!r_url) r_url = browser_fetch_url(ancestor);

    url = urlutils_relativise_url(r_url, url);

    dprintf(("JScr", "javascript_window_open: Relativised URL is '%s'\n",url));
  }

  e = fetchpage_new(targetted, url, record, 0, 1);

  if (free_it) free(url);

  return e;
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* javascript_url()                                           */
  /*                                                            */
  /* Find out if a URL is a JavaScript command.                 */
  /*                                                            */
  /* Parameters: Pointer to the URL string.                     */
  /*                                                            */
  /* Returns:    1 if the URL is a JavaScript URL, else 0.      */
  /**************************************************************/

  int javascript_url(const char * url)
  {
    if (!utils_strncasecmp(url, JavaScript_URL_Alternative1, sizeof(JavaScript_URL_Alternative1) - 1)) return 1;
    if (!utils_strncasecmp(url, JavaScript_URL_Alternative2, sizeof(JavaScript_URL_Alternative2) - 1)) return 1;

    return 0;
  }

  /**************************************************************/
  /* javascript_watchdog()                                      */
  /*                                                            */
  /* Periodically called by JavaScript interpreter - handles    */
  /* occasional garbage collection, watchdog timing, etc.       */
  /*                                                            */
  /* Assumes that the hourglass is turned on for the duration   */
  /* of the script - if not and the watchdog query comes up,    */
  /* it'll certainly turn the hourglass on afterwards if the    */
  /* user wants to continue script execution...!                */
  /*                                                            */
  /* Parameters are as standard for a JavaScript callback       */
  /* handler.                                                   */
  /**************************************************************/

  static JSBool PR_CALLBACK javascript_watchdog(JSContext * cx, JSScript * script)
  {
    unsigned int now;

    #ifndef ATTEMPT_JS_POLL
      int esc;
    #endif

    if (
         _swix(OS_ReadMonotonicTime,
               _OUT(0),

               &now)
       )
       return JS_FALSE;

    #ifndef ATTEMPT_JS_POLL

      /* Deal with hourglass LEDs */

      if (!((now - watchdog_start) & BRANCH_CALLBACK_LED_MASK))
      {
        _swix(Hourglass_LEDs,
              _INR(0,1),

              3,
              watchdog_leds);

        watchdog_leds ^= 3;
      }

    #else

      /* Polling. This doesn't really work properly - it is definitely */
      /* not suitable for release builds - but if there's a very heavy */
      /* JS processing task to do, rebuild with this switched on and   */
      /* you can at least let things progress in the background.       */

      #define BRANCH_CALLBACK_POLL_MASK 7

      if (!((now - watchdog_start) & BRANCH_CALLBACK_POLL_MASK))
      {
        WimpPollBlock block;
        IdBlock       id;
        int           reason;

        if (
             !wimp_poll(0x1003830,
                        &block,
                        NULL,
                        &reason)
           )
        {
          if (reason != Wimp_ENull)
          {
            id.self_id            = last_browser->self_id;
            id.self_component     = NULL_ComponentId;
            id.parent_id          = NULL_ObjectId;
            id.parent_component   = NULL_ComponentId;
            id.ancestor_id        = NULL_ObjectId;
            id.ancestor_component = NULL_ComponentId;
          }

          switch (reason)
          {
            case Wimp_ERedrawWindow:
            {
              windows_redraw_browser(Wimp_ERedrawWindow,
                                     &block,
                                     &id,
                                     last_browser);
            }
            break;

            case Wimp_EOpenWindow:
            {
              windows_open_browser(Wimp_EOpenWindow,
                                   &block,
                                   &id,
                                   last_browser);
            }
            break;

            case Wimp_EKeyPressed:
            {
              wimp_process_key(block.key_pressed.key_code);
            }
            break;

            case Wimp_EUserMessage:
            case Wimp_EUserMessageRecorded:
            {
              if (block.user_message.hdr.action_code == Wimp_MQuit)
              {
                multiuser_logout();
                exit(EXIT_SUCCESS);
              }
            }
            break;
          }
        }
      }

    #endif

    /* Handle periodic garbage collection */

    if (!(watchdog_counter & BRANCH_CALLBACK_GC_MASK))
    {
      JS_MaybeGC(cx);
    }

    #ifndef ATTEMPT_JS_POLL

      /* Check Escape */

      if (!_swix(OS_Byte,
                 _INR(0, 1) | _OUT(1),

                 121, /* Key scan reason code */
                 112, /* Key code for Escape  */

                 &esc))
      {
        if (esc != 255)
        {
          erb.errnum = Utils_Error_Custom_Message;

          StrNCpy0(erb.errmess,
                   lookup_token("JSEsc:Escape (script aborted)",
                                0,
                                0));

          show_error_cont(&erb);

          return JS_FALSE;
        }
      }

      if (choices.js_watchdog)
      {
        /* Watchdog - if the script has taken more than a certain */
        /* length of time, ask if we should stop it.              */

        if (now - watchdog_start > choices.js_timeout)
        {
          /* Build the query message */

          erb.errnum = Utils_Error_Custom_Message;

          StrNCpy0(erb.errmess,
                   lookup_token("JSLock:Lengthy JavaScript script is still running. Continue?",
                                0,
                                0));

          /* Turn off the hourglass */

          _swix(Hourglass_Off, 0);

          /* If the user didn't select 'Continue', */
          /* stop the script.                      */

          if (
               show_error_ask(&erb,
                              "JSErr1:Continue,Stop")
               != 3
             )
             return JS_FALSE;

          /* Turn the hourglass back on, since we're continuing */
          /* with the script.                                   */

          _swix(Hourglass_Start,
                _IN(0),

                1);

          _swix(Hourglass_LEDs,
                _INR(0,1),

                3,
                watchdog_leds);

          /* Don't forget to reset the counter :-) */

          watchdog_counter = 0;

          if (
               _swix(OS_ReadMonotonicTime,
                     _OUT(0),

                     &watchdog_start)
             )
             watchdog_start = now;
        }
      }

    #endif

    /* Increment the counter */

    watchdog_counter++;

    /* Carry on with the script */

    return JS_TRUE;
  }

  /**************************************************************/
  /* javascript_error()                                         */
  /*                                                            */
  /* Deal with errors from the JavaScript interpreter.          */
  /*                                                            */
  /* Parameters are as standard for a JavaScript error handling */
  /* function.                                                  */
  /**************************************************************/

  static void javascript_error(JSContext * cx, const char * message, JSErrorReport * report)
  {
    int response;

    dprintf(("JScr", "javascript_error: Called\n"));

    if (choices.ev_scripts)
    {
      eventlogs_log_message(script_browser,
                            eventlogs_script_information,
                            message);
    }

    if (choices.js_error_boxes != 0)
    {
      erb.errnum = Utils_Error_Custom_Message;

      StrNCpy0(erb.errmess,
               lookup_token("JSMisc:JavaScript error",
                            0,
                            0));

      if (strlen(message) + 3 < sizeof(erb.errmess))
      {
        strcat(erb.errmess, " - ");
        strcat(erb.errmess, message);
      }

      response = show_error_ask(&erb, "JSErr2:Continue,More info");
    }
    else response = 0;

    /* A response of 4 means 'more info' */

    if (response == 4)
    {
      FILE * f;
      int    i;

      f = fopen(Save_ScrapFile, "wb");

      if (!f)
      {
        erb = *_kernel_last_oserror();
        show_error_ret(&erb);

        return;
      }

      /* Write the introduction */

      fputs("// ", f);
      fputs(lookup_token("JSMisc:JavaScript error",0,0), f);
      fputs("\n// ", f);

      for (i = 0; i < strlen(tokens); i++) fputc('=', f);

      fputs("\n//\n", f);

      /* If we have a filename and/or line number, output them */

      if (report->filename) fprintf(f, "// %s, ", report->filename);
      if (report->lineno)   fprintf(f, "%u: ",    report->lineno);

      if (!report->filename && !report->lineno) fputs("// ", f);

      /* Output the basic error message */

      if (message[0])
      {
        fputc(toupper(message[0]), f);
        fputs(&message[1], f);
      }

      if (!report->linebuf)
      {
        /* If that's all we have, we're finished */

        putc('\n', f);
      }
      else
      {
        int j, k, n;

        /* Otherwise, print out the contents of the error report block's line buffer */

        fprintf(f, ":\n\n   %s\n\n// ", report->linebuf);

        n = report->tokenptr - report->linebuf;

        for (i = j = 0; i < n; i++)
        {
          if (report->linebuf[i] == '\t')
          {
            for (k = (j + 8) & ~7; j < k; j++) putc('-', f);

            continue;
          }

          putc('-', f);
          j++;
        }

        fputs("^", f);
      }

      /* Close the file */

      fclose(f);

      /* Set the filetype */

      ChkError(_swix(OS_File,
                     _INR(0,2),

                     18,
                     Save_ScrapFile,
                     FileType_JSS));

//      /* If the source was the URL writable, fetch the page */
//      /* in the browser. Otherwise, give it to an editor.   */
//
//      if (
//           script_source == JavaScript_Source_URLWritable &&
//           is_known_browser(script_browser)
//         )
//      {
//        fetchpage_new(script_browser,
//                      FileMethod ProtocolSepShort Save_ScrapFile,
//                      1,
//                      0);
//      }

      /* Send to an external editor */

      ChkError(protocols_atats_send_data_open(FileType_TEXT, Save_ScrapFile));
    }

    dprintf(("JScr", "javascript_error: Finished\n"));

    return;
  }

  /**************************************************************/
  /* javascript_configure_environment()                         */
  /*                                                            */
  /* Set up the browser environment for JavaScript.             */
  /**************************************************************/

  _kernel_oserror * javascript_configure_environment(void)
  {
    unsigned int mask;

    dprintf(("JScr", "javascript_configure_environment: Called\n"));

    /* Configure the floating point environment to act in a manner expected */
    /* by the JavaScript parser - turn off all exceptions.                  */

    set_fpsr(0, fpsr_trap_INX |
                fpsr_trap_UFL |
                fpsr_trap_OFL |
                fpsr_trap_DVZ |
                fpsr_trap_IVO);

    /* We must make sure our poll mask sets the bit that tells the Wimp */
    /* not to preserve floating point registers                         */

    RetError(event_get_mask(&mask));
    mask = (mask | Wimp_Poll_SaveFPRegs);
    RetError(event_set_mask(mask));

    dprintf(("JScr", "javascript_configure_environment: Successful\n"));

    return NULL;
  }

  /**************************************************************/
  /* javascript_startup()                                       */
  /*                                                            */
  /* Having made sure the environment is set up with            */
  /* javascript_configure_environment, call this function to    */
  /* bring up the interpreter.                                  */
  /**************************************************************/

  _kernel_oserror * javascript_startup(void)
  {
    if (choices.support_js)
    {
      jsr = JS_Init(JavaScript_HeapBeforeAutoGC /* See JavaScript.h */);

      dprintf(("JScr", "javascript_startup: Obtained run-time structure %p\n", jsr));

      if (!jsr)
      {
        erb.errnum = Utils_Error_Custom_Fatal;

        StrNCpy0(erb.errmess,
                 lookup_token("JSInit:JavaScript interpreter initialisation failed (not enough memory?)",
                              0,
                              0));

        return &erb;
      }
    }

    return NULL;
  }

  /**************************************************************/
  /* javascript_shutdown()                                      */
  /*                                                            */
  /* Shut down the JavaScript engine. Will throw an error if it */
  /* believes the engine is still in use...                     */
  /**************************************************************/

  _kernel_oserror * javascript_shutdown(void)
  {
    dprintf(("JScr", "javascript_shutdown: Called\n"));

    if (!jsr)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Fatal;

        StrNCpy0(erb.errmess,
                 "JavaScript engine is not active in javascript_shutdown()");

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    if (last_browser)
    {
      erb.errnum = Utils_Error_Custom_Fatal;

      StrNCpy0(erb.errmess,
               lookup_token("JSActv:JavaScript interpreter still in use",
                            0,
                            0));

      return &erb;
    }

    JS_Finish(jsr);

    jsr = NULL;

    dprintf(("JScr", "javascript_shutdown: Successful\n"));

    return NULL;
  }

  /**************************************************************/
  /* javascript_gain_context()                                  */
  /*                                                            */
  /* For a given browser, either create an new interpreter      */
  /* context and initialise the various JS client-side objects  */
  /* within it; or inherit the context from the given parent.   */
  /*                                                            */
  /* If a browser window already has a context, the function    */
  /* just exits.                                                */
  /*                                                            */
  /* Sets up also the branch callback (watchdog) and error      */
  /* reporting functions.                                       */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct to gain the   */
  /*             context;                                       */
  /*                                                            */
  /*             Pointer to a browser_data struct to inherit    */
  /*             from, or NULL for a new context.               */
  /**************************************************************/

  _kernel_oserror * javascript_gain_context(browser_data * b, browser_data * parent)
  {
    dprintf(("JScr", "javascript_gain_context: Called for browser %p, parent %p\n",b,parent));

    /* Does the browser already have a context? */

    if (!choices.support_js || b->bcx) return NULL;

    /* If we have a parent, inherit the context */

    if (parent)
    {
      /* Does the parent have a context? */

      if (!parent->bcx)
      {
        #ifdef TRACE

          erb.errnum = Utils_Error_Custom_Normal;

          sprintf(erb.errmess,
                  "Parent browser 0x%08x has no JSI context itself in javascript_gain_context()",
                  (int) parent);

          show_error_ret(&erb);

        #endif

        return NULL;
      }

      /* Copy the relevant details from the parent */

      b->bcx           = parent->bcx;
      b->bcx_inherited = parent;
    }

    /* If we don't have a parent, now there's some real work to do... */

    else
    {
      /* Get the context */

      b->bcx = JS_NewContext(jsr, JavaScript_Context_StackSize);

      if (!b->bcx)
      {
        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 lookup_token("JSCont:Cannot gain context in which to run JavaScript code (not enough memory?)",
                              0,
                              0));

        return &erb;
      }

    }

    /* Set up the client-side objects for this browser */

    if (!b->window_object) RetError(javascript_define_window(b));

    if (!parent)
    {
      /* Set up the watchdog and error functions for ancestors */

      JS_SetBranchCallback(b->bcx, javascript_watchdog);
      JS_SetErrorReporter (b->bcx, javascript_error);
    }

    dprintf(("JScr", "javascript_gain_context: Successful (context %p, Window object %p)\n", b->bcx, b->window_object));

    return NULL;
  }

  /**************************************************************/
  /* javascript_lose_context()                                  */
  /*                                                            */
  /* Get rid of a JavaScript interpreter context for a given    */
  /* browser. If the context was inherited, it is NOT           */
  /* destroyed, though any objects local to it are still thrown */
  /* away.                                                      */
  /*                                                            */
  /* Parameters: Pointer to a browser_Data struct with a valid  */
  /*             JSI context.                                   */
  /**************************************************************/

  _kernel_oserror * javascript_lose_context(browser_data * b)
  {
    dprintf(("JScr", "javascript_lose_context: Called\n"));

    if (!b->bcx)
    {
      dprintf(("JScr", "javascript_lose_context: Browser %p has no context anyway! Exitting\n", b));

      return NULL;
    }

    javascript_destroy_window(b);

    JS_GC(b->bcx);

    if (is_known_browser(b->bcx_inherited))
    {
      dprintf(("JScr", "javascript_lose_context: Browser %p has an inherited context; only destroying objects\n", b));
    }
    else
    {
      JS_DestroyContext(b->bcx);

      b->bcx           = NULL;
      b->bcx_inherited = NULL;
    }

    dprintf(("JScr", "javascript_lose_context: Successful\n"));

    return NULL;
  }

  /**************************************************************/
  /* javascript_define_window()                                 */
  /*                                                            */
  /* Define the top-level Window JavaScript object for the      */
  /* given browser (which must have a JSI context). Initialises */
  /* also related objects.                                      */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct with a valid  */
  /*             JSI context.                                   */
  /**************************************************************/

  _kernel_oserror * javascript_define_window(browser_data * b)
  {
    dprintf(("JScr", "javascript_define_window: Called for %p\n",b));

    if (!b->bcx)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser %p does not have an JSI context",
                b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    if (!jswindow_new_window(b))
    {
      erb.errnum = Utils_Error_Custom_Message;

      StrNCpy0(erb.errmess,
               lookup_token("JSGenE:Cannot start up JavaScript for this page (not enough memory?)",
                            0,
                            0));

      return &erb;
    }

    return NULL;
  }

  /**************************************************************/
  /* javascript_destroy_window()                                */
  /*                                                            */
  /* Get rid of the top-level Window JavaScript object for the  */
  /* given browser (which must have a JSI context). Gets rid    */
  /* also of related objects.                                   */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct with a valid  */
  /*             JSI context.                                   */
  /**************************************************************/

  _kernel_oserror * javascript_destroy_window(browser_data * b)
  {
    if (!b->bcx)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser %p does not have a JSI context",
                b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    jswindow_destroy_window(b);

    return NULL;
  }

  /**************************************************************/
  /* javascript_set_source()                                    */
  /*                                                            */
  /* Before processing a script, you should call this function  */
  /* to describe the way that the script source was             */
  /* encountered.                                               */
  /*                                                            */
  /* Parameters: javascript_source describing the way the       */
  /*             script was encountered (see JavaScript.h).     */
  /**************************************************************/

  void javascript_set_source(javascript_source s)
  {
    /* Remember the source and flag that we've done so */

    script_source = s;
    source_set    = 1;
  }

  /**************************************************************/
  /* javascript_process_script()                                */
  /*                                                            */
  /* Run the interpreter for a script. This may be a JavaScript */
  /* URL, or it may have a SCRIPT tag at the front of it.       */
  /*                                                            */
  /* It is strongly recommended that you call                   */
  /* javascript_set_source before calling this function.        */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct relevant to   */
  /*             the script;                                    */
  /*                                                            */
  /*             Pointer to the script as a null terminated     */
  /*             string.                                        */
  /**************************************************************/

  _kernel_oserror * javascript_process_script(browser_data * b, const char * script)
  {
    int          len = strlen(script);
    const char * si  = script;
    const char * url;
    JSScript   * jss;
    jsval        result;
    int          ok;
    int          jsu = 0;

    dprintf(("JScr", "javascript_process_script: Called\n"));

    /* Does the browser have a JavaScript context and Window object? */

    if (!b->bcx)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser 0x%08x has no JSI context in javascript_process_script()",
                (int) b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    if (!b->window_object)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser 0x%08x has no Window object in javascript_process_script()",
                (int) b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    /* Do we have a string to look at? */

    if (!si || !*si)
    {
      dprintf(("JScr", "javascript_process_script: Null script passed\n"));

      return NULL;
    }

    /* Check for a JavaScript URL prefix and point past it if it is there */

    if (
         !utils_strncasecmp(script,
                            JavaScript_URL_Alternative1,
                            sizeof(JavaScript_URL_Alternative1) - 1)
       )
       len -= (sizeof(JavaScript_URL_Alternative1) - 1),
       si  += (sizeof(JavaScript_URL_Alternative1) - 1),
       jsu = 1;

    else if (
              !utils_strncasecmp(script,
                                 JavaScript_URL_Alternative2,
                                 sizeof(JavaScript_URL_Alternative2) - 1)
            )
            len -= (sizeof(JavaScript_URL_Alternative2) - 1),
            si  += (sizeof(JavaScript_URL_Alternative2) - 1),
            jsu = 1;

    /* Do we still have a script to use? */

    if (len < 1)
    {
      dprintf(("JScr", "javascript_process_script: No script left after removing URL or SCRIPT tag prefix\n"));

      return NULL;
    }

    /* If javascript_set_source hasn't been called, the source_set */
    /* flag is clear - so we must state that the source of the     */
    /* script is unknown.                                          */

    if (!source_set) script_source = JavaScript_Source_Unknown;

    /* Remember the browser that the script is executing for */

    script_browser = b;

    /* Determine what the initial state of the doc_write_used flag should be */
    /* (which basically means 'do we reflect document.write output or raw    */
    /* interpreter output in the browser').                                  */

    if (script_source == JavaScript_Source_URLWritable) doc_write_used = 0;
    else                                                doc_write_used = 1;

    /* Ensure any post-execution actions are ditched before starting */

    javascript_clear_post_exec_actions();

    /* Compile the script */

    dprintf(("JScr", "javascript_process_script: Compiling script\n"));

    url           = browser_fetch_url(b);
    if (!url) url = browser_current_url(b);

    jss = JS_CompileScript(b->bcx,           /* Context                                */
                           b->window_object, /* Object with which script is associated */
                           si,               /* Pointer to script                      */
                           len,              /* Length of script                       */
                           url,              /* Name / URL for script (for errors)     */
                           0);               /* Line number (for errors)               */

    /* Ensure the source_set flag is cleared again ready for next time */

    source_set = 0;

    /* If JS_CompileScript failed, the error reporter function should */
    /* already have been called, so we exit silently now.             */

    if (!jss) ok = 0;
    else
    {
      /* Otherwise, go on to run the script. */

      dprintf(("JScr", "javascript_process_script: Script compiled. Now running it\n"));

      watchdog_counter = 0;
      watchdog_leds    = 1;

      RetError(_swix(OS_ReadMonotonicTime,
                     _OUT(0),

                     &watchdog_start));

      #ifndef ATTEMPT_JS_POLL
        _swix(Hourglass_On, 0);
      #endif

      ok = JS_ExecuteScript(b->bcx,
                            b->window_object,
                            jss,
                            &result);

      #ifndef ATTEMPT_JS_POLL
        _swix(Hourglass_Off, 0);
      #endif

      /* Throw away the bytecode */

      JS_DestroyScript(b->bcx, jss);
    }

    /* Try to allocate source in the browser source store */
    /* to report the results.                             */

    proceed = 1; /* Flag that the fetch should proceed until we know better */

//    if (b->source)
//    {
//      flex_free((flex_ptr) &b->source);
//      b->source = NULL;
//    }

    if (!ok)
    {
      /* There was an error - we shouldn't proceed with the fetch */

      proceed = 0;
    }
    else
    {
      /* If doc_write_used is clear, we want to turn the return result */
      /* from the script execution into some document source.          */

      if (!doc_write_used)
      {
        if (
             result == JSVAL_VOID     ||
             !JS_ConvertValue(b->bcx,
                              result,
                              JSTYPE_STRING,
                              &result)
           )
        {
          proceed = 0; // return javascript_empty_source_store(b);
        }
        else
        {
          int result_len = JS_GetStringLength(JSVAL_TO_STRING(result)); /* (Does not include terminator) */

          /* If this really was a JavaScript URL, record it in the history list now */
          /* (not really interested in errors, though; it's not critical...)        */

          if (jsu) history_record(b, script);

          /* Now copy the result across */

          if (b->source)
          {
            flex_free(&b->source);
            b->source = NULL;
          }

          if (flex_alloc((flex_ptr) &b->source, result_len))
          {
            /* The result is copied as plain text source - so there is no zero terminator to write */

            strncpy(b->source, JS_GetStringBytes(JSVAL_TO_STRING(result)), result_len);
          }
          else RetError(make_no_javascript_memory_error(3));
        }
      }

      // Would transer document.write accumulated store to here at this point.

      else
      {
        // Definitely *don't* touch the store if we've nothing to write.

        proceed = 0;
      }
    }

    /* Handle any post-execution actions - remember, after this, 'b' may be invalid */

    javascript_handle_post_exec_actions();

    /* TRACE builds will report how successful the execution was */

    #ifdef TRACE

      if (ok) dprintf(("JScr", "javascript_process_script: \0212Script ran OK\0217\n"));
      else    dprintf(("JScr", "javascript_process_script: \0211Script failed\0217\n"));

    #endif

    /* Finished */

    dprintf(("JScr", "javascript_process_script: Successful\n"));

    return NULL;
  }

  /**************************************************************/
  /* javascript_script_callback()                               */
  /*                                                            */
  /* Callback function for HTMLLib to handle a SCRIPT element.  */
  /*                                                            */
  /* Parameters: See HTMLLib "htmllib.h".                       */
  /*                                                            */
  /* Returns:    See HTMLLib "htmllib.h".                       */
  /**************************************************************/

  char * javascript_script_callback(void * stream, HStream * script_element, void * handle)
  {
    int            len;
    const char   * si;
    const char   * url;
    char         * ret;
    JSScript     * jss;
    jsval          result;
    int            ok;
    browser_data * b     = (browser_data *) handle;

    dprintf(("JScr", "javascript_script_callback: Called\n"));

    /* Is this JavaScript? */

    if (
         script_element->name &&
         utils_strncasecmp(script_element->name,
                           JavaScript_Language_Name,
                           sizeof(JavaScript_Language_Name) - 1)
       )
    {
      dprintf(("JScr", "javascript_script_callback: Unknown language '%s'\n", script_element->name));

      return NULL;
    }

    /* Get the script details */

    si = script_element->text;
    if (!si || !*si) return NULL;

    len = strlen(si);

//    /* Cope with a leading '<script>' if one is there */
//
//    if (!utils_strncasecmp(si, "<script>", sizeof("<script>") - 1)) si += sizeof("<script>") - 1;
//    len = strlen(si);
//    if (!len) return NULL;

    /* Does the browser have a JavaScript context and Window object? */

    if (!b->bcx)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser 0x%08x has no JSI context in javascript_script_callback()",
                (int) b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    if (!b->window_object)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser 0x%08x has no Window object in javascript_script_callback()",
                (int) b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    /* Set up initial information */

    javascript_free_document_write_block();

    script_source  = JavaScript_Source_ScriptInPage;
    script_browser = b;
    doc_write_used = 1;

    /* Ensure any post-execution actions are ditched before starting */

    javascript_clear_post_exec_actions();

    /* Compile the script */

    dprintf(("JScr", "javascript_script_callback: Compiling script\n"));

    url           = browser_fetch_url(b);
    if (!url) url = browser_current_url(b);

    jss = JS_CompileScript(b->bcx,           /* Context                                */
                           b->window_object, /* Object with which script is associated */
                           si,               /* Pointer to script                      */
                           len,              /* Length of script                       */
                           url,              /* Name / URL for script (for errors)     */
                           0);               /* Line number (for errors)               */

    /* Ensure the source_set flag is cleared again ready for next time */

    source_set = 0;

    /* If JS_CompileScript failed, the error reporter function should */
    /* already have been called, so we exit silently now.             */

    if (!jss) ok = 0;
    else
    {
      /* Otherwise, go on to run the script. */

      dprintf(("JScr", "javascript_script_callback: Script compiled. Now running it\n"));

      watchdog_counter = 0;
      watchdog_leds    = 1;

      _swi(OS_ReadMonotonicTime,
           _OUT(0),

           &watchdog_start);

      #ifndef ATTEMPT_JS_POLL
        _swix(Hourglass_On, 0);
      #endif

      ok = JS_ExecuteScript(b->bcx,
                            b->window_object,
                            jss,
                            &result);

      #ifndef ATTEMPT_JS_POLL
        _swix(Hourglass_Off, 0);
      #endif

      /* Throw away the bytecode */

      JS_DestroyScript(b->bcx, jss);
    }

    /* TRACE builds will report how successful the execution was */

    #ifdef TRACE

      if (ok) dprintf(("JScr", "javascript_script_callback: \0212Script ran OK\0217\n"));
      else    dprintf(("JScr", "javascript_script_callback: \0211Script failed\0217\n"));

    #endif

    /* Handle any post-execution actions - remember, after this, 'b' may be invalid */

    javascript_handle_post_exec_actions();

    /* Finished - copy the document.write() etc. data, or if there is */
    /* none or the script failed, return NULL.                        */

    if (ok && script_write_l)
    {
      int old_budge;

      /* The block has no terminator presently, so '+ 1' below leaves room for one*/

      ret = HtmlMalloc(script_write_l + 1, script_element);

      if (!ret)
      {
        dprintf(("JScr", "javascript_script_callback: Couldn't allocate memory for return data block, exitting\n"));

        return NULL;
      }

      /* Copy the existing data over, locking flex down Just In Case */

      old_budge = flex_set_budge(0);
      memcpy(ret, script_write_p, script_write_l);
      flex_set_budge(old_budge);

      /* Write the terminator */

      ret[script_write_l] = '\0';

      // If you think document.write is going wrong, this can help...
      //
      // #ifdef TRACE
      //
      //   {
      //     char   f[2048];
      //     FILE * o;
      //
      //     protocols_util_make_unique_name(f, sizeof(f));
      //
      //     o = fopen(f, "wb");
      //     if (o)
      //     {
      //       fwrite(ret, 1, script_write_l+1, o);
      //       fclose(o);
      //     }
      //   }
      //
      // #endif

      /* Free the temporary block */

      javascript_free_document_write_block();

      dprintf(("JScr", "javascript_script_callback: Successful (return block %p)\n", ret));

      return ret;
    }
    else
    {
      dprintf(("JScr", "javascript_script_callback: Successful with no return data, or script failed\n"));

      return NULL;
    }
  }

  /**************************************************************/
  /* javascript_allocate_document_write_block()                 */
  /*                                                            */
  /* Allocate a block of memory for a Document object (or       */
  /* similar) to write into. Repeated calls to this function    */
  /* will extend the single block and return a pointer to the   */
  /* start point where data should be written. If allocation    */
  /* fails, the entire block is discarded - there is no need to */
  /* remember your old pointer (as if calling realloc(), say,   */
  /* directly), since this function does it for you.            */
  /*                                                            */
  /* Parameters: Amount of data to allocate in bytes.           */
  /*                                                            */
  /* Returns:    Pointer to start of region where data should   */
  /*             be written - NULL terminators and the like     */
  /*             should NOT be included.                        */
  /**************************************************************/

  char ** javascript_allocate_document_write_block(int len, int * offset)
  {
    int success;
    int old_l;

    /* Allocate the new block */

    if (script_write_p) success = flex_extend((flex_ptr) &script_write_p, script_write_l + len);
    else                success = flex_alloc ((flex_ptr) &script_write_p, script_write_l + len);

    if (!success)
    {
      if (script_write_p)
      {
        flex_free((flex_ptr) &script_write_p);

        script_write_p = NULL;
        script_write_l = 0;
      }

      return NULL;
    }

    /* Remember the new length */

    old_l          = script_write_l;
    script_write_l = script_write_l + len;

    /* Give back the offset to write to */

    if (offset) *offset = old_l;

    return &script_write_p;
  }

  /**************************************************************/
  /* javascript_free_document_write_block()                     */
  /*                                                            */
  /* Free memory allocated through the                          */
  /* javascript_allocate_document_write_block() function.       */
  /**************************************************************/

  void javascript_free_document_write_block(void)
  {
    if (script_write_p)
    {
      flex_free((flex_ptr) &script_write_p);

      script_write_p = NULL;
      script_write_l = 0;
    }
  }

  /**************************************************************/
  /* javascript_set_doc_write_used()                            */
  /*                                                            */
  /* If a script does not use document_write but it came from   */
  /* the URL writable, the value returned by the parser should  */
  /* be used as a plain text document in the browser window.    */
  /* However, if the script comes from anywhere else or if it   */
  /* uses document.write(), only the document.write() generated */
  /* information should be displayed.                           */
  /*                                                            */
  /* So:                                                        */
  /*                                                            */
  /* If document.write() is called, this function should be     */
  /* invoked to flag the event.                                 */
  /**************************************************************/

  void javascript_set_doc_write_used(void)
  {
    doc_write_used = 1;
  }

  /**************************************************************/
  /* javascript_fetch_should_proceed()                          */
  /*                                                            */
  /* If a script has been processed because of a JavaScript     */
  /* URL, call this after javascript_script_callback to see if  */
  /* the fetch should be stopped or should continue.            */
  /*                                                            */
  /* Returns:    1 if the fetch should proceed, else 0.         */
  /**************************************************************/

  int javascript_fetch_should_proceed(void)
  {
    return proceed;
  }

  /**************************************************************/
  /* javascript_set_pending_fetch()                             */
  /*                                                            */
  /* If, say, in the middle of the script callback function, a  */
  /* URL needs to be visited (e.g. 'window.location.href="..."' */
  /* is done in a script), use this function instead of just    */
  /* calling fetchpage_new (which won't work due to fetcher     */
  /* threading issues). Later on, javascript_fetch_is_pending   */
  /* will be called to see if the fetch should be stopped and   */
  /* restarted at the recorded location.                        */
  /*                                                            */
  /* At the time of creation, this function's parameters list   */
  /* mirrors exactly those for fetchpage_new. To cancel a       */
  /* pending fetch, however, call with a NULL browser_data      */
  /* struct pointer.                                            */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct to which the  */
  /*             new URL refers;                                */
  /*                                                            */
  /*             Pointer to the new URL string (a copy is       */
  /*             taken, so any space allocated for this by the  */
  /*             caller may be safely disposed of afterwards);  */
  /*                                                            */
  /*             1 to record the previous URL in the history    */
  /*             list, else 0;                                  */
  /*                                                            */
  /*             1 to stop other page fetches in any other      */
  /*             frames related to this document, 0 to only     */
  /*             stop those in this frame.                      */
  /**************************************************************/

  void javascript_set_pending_fetch(browser_data * b, const char * url, int record, int stop)
  {
    if (!b || !url || !*url) return;

    pending_b      = b;
    pending_record = record;
    pending_stop   = stop;

    /* Need to take a copy of the URL */

    free(pending_url);
    pending_url = malloc(strlen(url) + 1);

    /* If allocation fails, cancel the pending fetch quietly */
    /* - otherwise, just copy the URL over.                  */

    if (!pending_url)
    {
      pending_b      = NULL;
      pending_record = 0;
      pending_stop   = 0;
    }
    else
    {
      strcpy(pending_url, url);
    }

    return;
  }

  /**************************************************************/
  /* javascript_fetch_is_pending()                              */
  /*                                                            */
  /* See if javascript_set_pending_fetch has been used to       */
  /* record a fetch that needs to be done as soon as possible.  */
  /*                                                            */
  /* Use javascript_do_pending_fetch to start the new fetch, if */
  /* this function says there is one waiting.                   */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct to check      */
  /*             against the one recorded for the pending       */
  /*             fetch.                                         */
  /*                                                            */
  /* Returns:    1 if a there is indeed a new fetch to start,   */
  /*             else 0.                                        */
  /**************************************************************/

  int javascript_fetch_is_pending(browser_data * b)
  {
    if (pending_b && pending_b == b) return 1;

    return 0;
  }

  /**************************************************************/
  /* javascript_do_pending_fetch()                              */
  /*                                                            */
  /* If javascript_fetch_is_pending says there is a fetch to be */
  /* done, use this function to start it.                       */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct to check      */
  /*             against the one recorded for the pending       */
  /*             fetch.                                         */
  /**************************************************************/

  _kernel_oserror * javascript_do_pending_fetch(browser_data * b)
  {
    _kernel_oserror * e;

    #ifdef TRACE

      if (!b || b != pending_b)
      {
        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser %p has no fetch pending in javascript_do_pending_fetch",
                b);

        return &erb;
      }

    #else

      if (!b || b != pending_b) return NULL;

    #endif

    e = fetchpage_new(pending_b,
                      pending_url,
                      pending_record,
                      pending_stop,
                      1);

    free(pending_url);

    pending_b      = 0;
    pending_record = 0;
    pending_stop   = 0;
    pending_url    = NULL;

    return e;
  }

  /**************************************************************/
  /* javascript_fix_invalid_date_format()                       */
  /*                                                            */
  /* Look for dates of the form:                                */
  /*                                                            */
  /*   FullDayName, dd-mmm-yy                                   */
  /*                                                            */
  /* and change them to:                                        */
  /*                                                            */
  /*   Day, dd mmm yy                                           */
  /*                                                            */
  /* to improve the changes of them being accepted by the Date  */
  /* object constructor. For example, "Wednesday, 18-Oct-97"    */
  /* will be changed to "Wed, 18 Oct 97".                       */
  /*                                                            */
  /* Originally created in a vague attempt to make              */
  /* Last-modified dates returned by Netscape Commerce server   */
  /* readable by 'new Date(...)'.                               */
  /*                                                            */
  /* Parameters: Pointer to the date string, which may be       */
  /*             modified; it will always end up the same       */
  /*             length or shorter than the string passed.      */
  /*                                                            */
  /* Returns:    1 if the string was modified, else 0.          */
  /**************************************************************/

  int javascript_fix_invalid_date_format(char * date)
  {
    int    modified = 0;
    char * p;

    if (!date) return 0;

    /* Monday -> Mon, Tuesday -> Tue, etc. */

    if (
         !strcmp(date, "Monday")    ||
         !strcmp(date, "Tuesday")   ||
         !strcmp(date, "Wednesday") ||
         !strcmp(date, "Thursday")  ||
         !strcmp(date, "Friday")    ||
         !strcmp(date, "Saturday")  ||
         !strcmp(date, "Sunday")
       )
    {
      char * end;
      char * space = strstr(date, " ");
      char * comma = strstr(date, ",");

      if (comma && space)
      {
        if (comma < space) end = comma;
        else               end = space;
      }
      else if (comma) end = comma;
      else if (space) end = space;
      else            end = NULL;

      if (end && end > (date + 3))
      {
        modified = 1;
        strcpy(end, date + 3);
      }
    }

    /* Any '-' changed to ' ' unless preceeded or followed by a ' ' */

    for (p = date; *p; p ++)
    {
      if (*p == '-')
      {
        if (
             p > date        &&
             *(p - 1) != ' ' &&
             *(p + 1) != ' '
           )
           *p = ' ', modified = 1;
      }
    }

    return modified;
  }

  /**************************************************************/
  /* javascript_reread_window_details()                         */
  /*                                                            */
  /* The screen X and Y positions, size etc. of the browser     */
  /* window in JavaScript are recorded to the accuracy of a     */
  /* JSDouble. JavaScript code may add 0.1 to the X position 10 */
  /* times and have the window move one pixel. So, just reading */
  /* the values from the Wimp each time we need to change or    */
  /* return something is not good enough - we have to keep a    */
  /* similarly accurate record.                                 */
  /*                                                            */
  /* Keeping such a record requires this function to be called  */
  /* whenever code moves, resizes or otherwise changes a        */
  /* browser window or frame. This will ensure that the         */
  /* JSDouble accuracy information is kept correctly updated.   */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct relevant to   */
  /*             the window for whom the updated information is */
  /*             to be recorded.                                */
  /**************************************************************/

  _kernel_oserror * javascript_reread_window_details(browser_data * b)
  {
//    WimpGetWindowStateBlock   state;
//    WimpGetWindowOutlineBlock outline;
//    int                       wf, wl;
//
//    state.window_handle   = b->window_handle;
//    outline.window_handle = b->window_handle;
//
//    RetError(wimp_get_window_state(&state));
//    RetError(wimp_get_window_outline(&outline));
//
//    wf = bbc_modevar(-1, BBC_YEigFactor);
//    wl = bbc_modevar(-1, BBC_YWindLimit);
//
//    wl = (wl + 1) << wf;
//
//    /* The read-from-the-window values should always be whole pixels, */
//    /* hence the cast to int first, then JSDouble for storage.        */
//
//    b->screen_x     = (JSDouble) ((int) (outline.outline.xmin / 2));
//    b->screen_y     = (JSDouble) ((int) ((wl - outline.outline.ymax) / 2));
//
//    b->inner_width  = (JSDouble) ((int) ((state.visible_area.xmax - state.visible_area.xmin) / 2));
//    b->inner_height = (JSDouble) ((int) ((state.visible_area.ymax - state.visible_area.ymin) / 2));
//
//    b->outer_width  = (JSDouble) ((int) ((outline.outline.xmax - outline.outline.xmin) / 2));
//    b->outer_height = (JSDouble) ((int) ((outline.outline.ymax - outline.outline.ymin) / 2));

    return NULL;
  }

  /**************************************************************/
  /* javascript_register_post_exec_action()                     */
  /*                                                            */
  /* Register an action to take place after a script has        */
  /* executed. Usually called by the script itself somewhere in */
  /* the native back end code.                                  */
  /*                                                            */
  /* Note: To register a requirement to visit a URL, use        */
  /* javascript_set_pending_fetch instead of this system        */
  /* (actions set here are executed too early for pending       */
  /* fetches to work).                                          */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct to which the  */
  /*             action is relevant;                            */
  /*                                                            */
  /*             Action type (see JavaScript.h).                */
  /**************************************************************/

  _kernel_oserror * javascript_register_post_exec_action(browser_data * b, unsigned int type)
  {
    javascript_postexec * exec = malloc(sizeof(javascript_postexec));

    if (!exec) return make_no_javascript_memory_error(4);

    exec->next = postexec_head;
    exec->b    = b;
    exec->type = type;

    postexec_head = exec;

    return NULL;
  }

  /**************************************************************/
  /* javascript_clear_post_exec_actions()                       */
  /*                                                            */
  /* Get rid of any pending post execution actions (e.g. ready  */
  /* for a new script to run).                                  */
  /**************************************************************/

  static void javascript_clear_post_exec_actions(void)
  {
    javascript_postexec * next;

    while (postexec_head)
    {
      next = postexec_head->next;
      free(postexec_head);
      postexec_head = next;
    }
  }

  /**************************************************************/
  /* javascript_handle_post_exec_actions()                      */
  /*                                                            */
  /* Some scripts do stuff that wants to actually happen after  */
  /* the script has exitted (e.g. close a window). This         */
  /* executes commands that the script has requested.           */
  /**************************************************************/

  static _kernel_oserror * javascript_handle_post_exec_actions(void)
  {
    int get_outa_here = 0;

    javascript_postexec * this;
    javascript_postexec * next;

    while (postexec_head)
    {
      this = postexec_head;
      next = this->next;

      /* Do whatever action this structure asks for */

      switch (this->type)
      {
        case 1:
        {
          if (is_known_browser(this->b))
          {
            /* If about to close a JS child and it has the input focus, give focus */
            /* back to the parent instead                                          */

            if (is_known_browser(this->b->bcx_inherited))
            {
              WimpGetCaretPositionBlock caret;

              wimp_get_caret_position(&caret);

              if (caret.window_handle == this->b->window_handle)
              {
                browser_give_general_focus(this->b->bcx_inherited);
              }
            }

            /* Close it */

            handle_close_browser(0, NULL, NULL, this->b);

            /* If we've just shut the executing browser, panic wildly. */

            if (this->b == script_browser) get_outa_here = 1;
          }
        }
        break;

        #ifdef TRACE

          default:
          {
            erb.errnum = Utils_Error_Custom_Normal;

            sprintf(erb.errmess,
                    "Unknown action type %d in javascript_handle_post_exec_actions",
                    this->type);

            show_error_ret(&erb);
          }
          break;

        #endif
      }

      /* Remove the structure */

      free(this), postexec_head = next;
    }

    // Erk. This is horrible. The alternative is to check to see
    // if 'b' is still valid after each and every call to these
    // JavaScript routines though, which doesn't bear thinking
    // about if only from a maintenance viewpoint.

    if (get_outa_here) longjmp(env, Main_FromJSHandler);

    return NULL;
  }

#endif
@


1.17
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@a51 1
#include "Customer.h"
a136 15
  #ifdef CUSTOMER_SPECIAL

    /* Only call customer_ functions if on the customer's site */

    if (strstr(browser_current_url(b), "www.customer.com"))
    {
      e = customer_body_onload(b);
    }

  #endif

  /* This is a bit unusual as the Customer hack existed before any real */
  /* JS support, hence the function itself being 'live' even in non JS  */
  /* builds.                                                            */

d166 3
a168 7
/*             0 is written) - this may be NULL if you're not */
/*             interested - in CUSTOMER_SPECIAL builds, or an */
/*             indication that the script function executed   */
/*             and returned, so any unknown anchor reference  */
/*             should be ignored (as an empty anchor is a     */
/*             common construct in links that only do a JS    */
/*             action) in non-CUSTOMER_SPECIAL script builds. */
d177 1
a177 3
  if (ignore) *ignore = 0;

  #ifdef CUSTOMER_SPECIAL
d179 2
a180 6
    /* Only call customer_ functions if on the customer's site */

    if (strstr(browser_current_url(b), "www.customer.com"))
    {
      e = customer_href_onclick(b, t, ignore);
    }
d184 1
a184 6
    #ifdef JAVASCRIPT

      e = javascript_process_script(b, t->onclick);
      if (ignore) *ignore = 1;

    #endif
@


1.16
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d183 6
a188 1
/*             interested.                                    */
d208 9
d305 1
a305 1
  e = fetchpage_new(targetted, url, record, 0);
d570 6
a575 3
    eventlogs_log_message(script_browser,
                          eventlogs_script_information,
                          message);
d1787 2
a1788 1
                      pending_stop);
@


1.15
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a41 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d134 1
a134 3
  #ifdef TRACE
    if (tl & (1u<<24)) Printf("javascript_body_onload: Called\n");
  #endif
d190 1
a190 3
  #ifdef TRACE
    if (tl & (1u<<24)) Printf("javascript_href_onclick: Called\n");
  #endif
d237 1
a237 3
  #ifdef TRACE
    if (tl & (1u<<24)) Printf("javascript_window_open: Called for %p with '%s' and target '%s'\n",b,url,target);
  #endif
d249 1
a249 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_window_open: Proceeding with target '%s'\n",target);
    #endif
d253 1
a253 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_window_open: targetted = %p\n",targetted);
    #endif
d267 1
a267 3
  #ifdef TRACE
    if (tl & (1u<<24)) Printf("javascript_window_open: Opening to target %p\n",targetted);
  #endif
d276 1
a276 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_window_open: Relativising URL\n");
    #endif
d288 1
a288 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_window_open: Relativised URL is '%s'\n",url);
    #endif
d554 1
a554 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_error: Called\n");
    #endif
d685 1
a685 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_error: Finished\n");
    #endif
d700 1
a700 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_configure_environment: Called\n");
    #endif
d718 1
a718 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_configure_environment: Successful\n");
    #endif
d737 1
a737 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_startup: Obtained run-time structure %p\n", jsr);
      #endif
d764 1
a764 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_shutdown: Called\n");
    #endif
d798 1
a798 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_shutdown: Successful\n");
    #endif
d825 1
a825 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_gain_context: Called for browser %p, parent %p\n",b,parent);
    #endif
d894 1
a894 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_gain_context: Successful (context %p, Window object %p)\n", b->bcx, b->window_object);
    #endif
d913 1
a913 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_lose_context: Called\n");
    #endif
d917 1
a917 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_lose_context: Browser %p has no context anyway! Exitting\n", b);
      #endif
d928 1
a928 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_lose_context: Browser %p has an inherited context; only destroying objects\n", b);
      #endif
d938 1
a938 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_lose_context: Successful\n");
    #endif
d956 1
a956 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_define_window: Called for %p\n",b);
    #endif
d1070 1
a1070 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_process_script: Called\n");
    #endif
d1112 1
a1112 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_process_script: Null script passed\n");
      #endif
d1141 1
a1141 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_process_script: No script left after removing URL or SCRIPT tag prefix\n");
      #endif
d1169 1
a1169 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_process_script: Compiling script\n");
    #endif
d1193 1
a1193 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_process_script: Script compiled. Now running it\n");
      #endif
d1300 2
a1301 5
      if (tl & (1u<<24))
      {
        if (ok) Printf("javascript_process_script: \0212Script ran OK\0217\n");
        else    Printf("javascript_process_script: \0211Script failed\0217\n");
      }
d1307 1
a1307 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_process_script: Successful\n");
    #endif
d1333 1
a1333 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_script_callback: Called\n");
    #endif
d1344 1
a1344 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_script_callback: Unknown language '%s'\n", script_element->name);
      #endif
d1412 1
a1412 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_script_callback: Compiling script\n");
    #endif
d1436 1
a1436 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_script_callback: Script compiled. Now running it\n");
      #endif
d1468 2
a1469 5
      if (tl & (1u<<24))
      {
        if (ok) Printf("javascript_script_callback: \0212Script ran OK\0217\n");
        else    Printf("javascript_script_callback: \0211Script failed\0217\n");
      }
d1490 1
a1490 3
        #ifdef TRACE
          if (tl & (1u<<24)) Printf("javascript_script_callback: Couldn't allocate memory for return data block, exitting\n");
        #endif
d1529 1
a1529 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_script_callback: Successful (return block %p)\n", ret);
      #endif
d1535 1
a1535 3
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_script_callback: Successful with no return data, or script failed\n");
      #endif
@


1.14
log
@Header and footer support working a lot better than in the previous
release. Could do with some code tidying, but little else to do.
Fixed a typo in JavaScript.c that stopped debug builds compiling,
and updated Trace.c to know about all current HStream flags bits.
@
text
@d15 12
a26 9
/***************************************************/
/* File   : JavaScript.c                           */
/*                                                 */
/* Purpose: JavaScript support.                    */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 24-Jul-97: Created.                    */
/***************************************************/
d33 2
a34 1
#include "swis.h"
d36 1
a36 1
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */
d38 8
a45 3
#include "wimp.h"
#include "wimplib.h"
#include "event.h"
a46 1
#include "svcprint.h"
d123 11
a133 13
/*************************************************/
/* javascript_body_onload()                      */
/*                                               */
/* When a page has finished fetching the main    */
/* page data, a BODY tag may specify some        */
/* JavaScript action. This functon should be     */
/* called to carry out that action.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             with a filled in 'onload' field   */
/*             describing the contents of the    */
/*             onLoad command in the HTML.       */
/*************************************************/
d174 18
a191 22
/*************************************************/
/* javascript_href_onclick()                     */
/*                                               */
/* When something is clicked upon that has an    */
/* onClick attribute specified for it, this      */
/* function is called with the details of that   */
/* attribute.                                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the item clicked on;  */
/*                                               */
/*             Pointer to the token representing */
/*             that item;                        */
/*                                               */
/*             Pointer to an int, in which 1 is  */
/*             written if the contents of the    */
/*             HREF attribute in the link that   */
/*             held the onClick should be        */
/*             ignored (else 0 is written) -     */
/*             this may be NULL if you're not    */
/*             interested.                       */
/*************************************************/
d217 22
a238 25
/*************************************************/
/* javascript_window_open()                      */
/*                                               */
/* Opens a given URL in a given target window.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the window_open call; */
/*                                               */
/*             1 if the specified target window  */
/*             must be found to proceed, else 0  */
/*             (if the target isn't found the    */
/*             URL is opened in the given        */
/*             browser instead);                 */
/*                                               */
/*             1 if the URL displayed in the     */
/*             target is to be recorded in the   */
/*             History before the new one is     */
/*             fetched, else 0;                  */
/*                                               */
/*             Pointer to the URL to fetch;      */
/*                                               */
/*             Pointer to the target (or NULL /  */
/*             a null string for the given       */
/*             browser).                         */
/*************************************************/
d321 9
a329 10
  /*************************************************/
  /* javascript_url()                              */
  /*                                               */
  /* Find out if a URL is a JavaScript command.    */
  /*                                               */
  /* Parameters: Pointer to the URL string.        */
  /*                                               */
  /* Returns:    1 if the URL is a JavaScript URL, */
  /*             else 0.                           */
  /*************************************************/
d339 14
a352 16
  /*************************************************/
  /* javascript_watchdog()                         */
  /*                                               */
  /* Periodically called by JavaScript interpreter */
  /* - handles occasional garbage collection,      */
  /* watchdog timing, etc.                         */
  /*                                               */
  /* Assumes that the hourglass is turned on for   */
  /* the duration of the script - if not and the   */
  /* watchdog query comes up, it'll certainly turn */
  /* the hourglass on afterwards if the user wants */
  /* to continue script execution...!              */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* callback handler.                             */
  /*************************************************/
d562 8
a569 9
  /*************************************************/
  /* javascript_error()                            */
  /*                                               */
  /* Deal with errors from the JavaScript          */
  /* interpreter.                                  */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* error handling function.                      */
  /*************************************************/
d715 5
a719 6
  /*************************************************/
  /* javascript_configure_environment()            */
  /*                                               */
  /* Set up the browser environment for            */
  /* JavaScript.                                   */
  /*************************************************/
d752 7
a758 7
  /*************************************************/
  /* javascript_startup()                          */
  /*                                               */
  /* Having made sure the environment is set up    */
  /* with javascript_configure_environment, call   */
  /* this function to bring up the interpreter.    */
  /*************************************************/
d786 6
a791 7
  /*************************************************/
  /* javascript_shutdown()                         */
  /*                                               */
  /* Shut down the JavaScript engine. Will throw   */
  /* an error if it believes the engine is still   */
  /* in use...                                     */
  /*************************************************/
d838 19
a856 21
  /*************************************************/
  /* javascript_gain_context()                     */
  /*                                               */
  /* For a given browser, either create an new     */
  /* interpreter context and initialise the        */
  /* various JS client-side objects within it; or  */
  /* inherit the context from the given parent.    */
  /*                                               */
  /* If a browser window already has a context,    */
  /* the function just exits.                      */
  /*                                               */
  /* Sets up also the branch callback (watchdog)   */
  /* and error reporting functions.                */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             to gain the context;              */
  /*                                               */
  /*             Pointer to a browser_data struct  */
  /*             to inherit from, or NULL for a    */
  /*             new context.                      */
  /*************************************************/
d938 11
a948 11
  /*************************************************/
  /* javascript_lose_context()                     */
  /*                                               */
  /* Get rid of a JavaScript interpreter context   */
  /* for a given browser. If the context was       */
  /* inherited, it is NOT destroyed, though any    */
  /* objects local to it are still thrown away.    */
  /*                                               */
  /* Parameters: Pointer to a browser_Data struct  */
  /*             with a valid JSI context.         */
  /*************************************************/
d990 10
a999 10
  /*************************************************/
  /* javascript_define_window()                    */
  /*                                               */
  /* Define the top-level Window JavaScript object */
  /* for the given browser (which must have a JSI  */
  /* context). Initialises also related objects.   */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             with a valid JSI context.         */
  /*************************************************/
d1039 10
a1048 11
  /*************************************************/
  /* javascript_destroy_window()                   */
  /*                                               */
  /* Get rid of the top-level Window JavaScript    */
  /* object for the given browser (which must have */
  /* a JSI context). Gets rid also of related      */
  /* objects.                                      */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             with a valid JSI context.         */
  /*************************************************/
d1074 10
a1083 11
  /*************************************************/
  /* javascript_set_source()                       */
  /*                                               */
  /* Before processing a script, you should call   */
  /* this function to describe the way that the    */
  /* script source was encountered.                */
  /*                                               */
  /* Parameters: javascript_source describing the  */
  /*             way the script was encountered    */
  /*             (see JavaScript.h).               */
  /*************************************************/
d1093 15
a1107 17
  /*************************************************/
  /* javascript_process_script()                   */
  /*                                               */
  /* Run the interpreter for a script. This may be */
  /* a JavaScript URL, or it may have a SCRIPT     */
  /* tag at the front of it.                       */
  /*                                               */
  /* It is strongly recommended that you call      */
  /* javascript_set_source before calling this     */
  /* function.                                     */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             relevant to the script;           */
  /*                                               */
  /*             Pointer to the script as a null   */
  /*             terminated string.                */
  /*************************************************/
d1376 9
a1384 10
  /*************************************************/
  /* javascript_script_callback()                  */
  /*                                               */
  /* Callback function for HTMLLib to handle a     */
  /* SCRIPT element.                               */
  /*                                               */
  /* Parameters: See HTMLLib "htmllib.h".          */
  /*                                               */
  /* Returns:    See HTMLLib "htmllib.h".          */
  /*************************************************/
d1622 17
a1638 21
  /*************************************************/
  /* javascript_allocate_document_write_block()    */
  /*                                               */
  /* Allocate a block of memory for a Document     */
  /* object (or similar) to write into. Repeated   */
  /* calls to this function will extend the single */
  /* block and return a pointer to the start point */
  /* where data should be written. If allocation   */
  /* fails, the entire block is discarded - there  */
  /* is no need to remember your old pointer (as   */
  /* if calling realloc(), say, directly), since   */
  /* this function does it for you.                */
  /*                                               */
  /* Parameters: Amount of data to allocate in     */
  /*             bytes.                            */
  /*                                               */
  /* Returns:    Pointer to start of region where  */
  /*             data should be written - NULL     */
  /*             terminators and the like should   */
  /*             NOT be included.                  */
  /*************************************************/
d1675 6
a1680 7
  /*************************************************/
  /* javascript_free_document_write_block()        */
  /*                                               */
  /* Free memory allocated through the             */
  /* javascript_allocate_document_write_block()    */
  /* function.                                     */
  /*************************************************/
d1693 15
a1707 17
  /*************************************************/
  /* javascript_set_doc_write_used()               */
  /*                                               */
  /* If a script does not use document_write but   */
  /* it came from the URL writable, the value      */
  /* returned by the parser should be used as a    */
  /* plain text document in the browser window.    */
  /* However, if the script comes from anywhere    */
  /* else or if it uses document.write(), only the */
  /* document.write() generated information should */
  /* be displayed.                                 */
  /*                                               */
  /* So:                                           */
  /*                                               */
  /* If document.write() is called, this function  */
  /* should be invoked to flag the event.          */
  /*************************************************/
d1714 9
a1722 11
  /*************************************************/
  /* javascript_fetch_should_proceed()             */
  /*                                               */
  /* If a script has been processed because of a   */
  /* JavaScript URL, call this after               */
  /* javascript_script_callback to see if the      */
  /* fetch should be stopped or should continue.   */
  /*                                               */
  /* Returns:    1 if the fetch should proceed,    */
  /*             else 0.                           */
  /*************************************************/
d1729 30
a1758 36
  /*************************************************/
  /* javascript_set_pending_fetch()                */
  /*                                               */
  /* If, say, in the middle of the script callback */
  /* function, a URL needs to be visited (e.g.     */
  /* 'window.location.href="..."' is done in a     */
  /* script), use this function instead of just    */
  /* calling fetchpage_new (which won't work due   */
  /* to fetcher threading issues). Later on,       */
  /* javascript_fetch_is_pending will be called to */
  /* see if the fetch should be stopped and        */
  /* restarted at the recorded location.           */
  /*                                               */
  /* At the time of creation, this function's      */
  /* parameters list mirrors exactly those for     */
  /* fetchpage_new. To cancel a pending fetch,     */
  /* however, call with a NULL browser_data        */
  /* struct pointer.                               */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             to which the new URL refers;      */
  /*                                               */
  /*             Pointer to the new URL string (a  */
  /*             copy is taken, so any space       */
  /*             allocated for this by the caller  */
  /*             may be safely disposed of         */
  /*             afterwards);                      */
  /*                                               */
  /*             1 to record the previous URL in   */
  /*             the history list, else 0;         */
  /*                                               */
  /*             1 to stop other page fetches in   */
  /*             any other frames related to this  */
  /*             document, 0 to only stop those in */
  /*             this frame.                       */
  /*************************************************/
d1790 16
a1805 18
  /*************************************************/
  /* javascript_fetch_is_pending()                 */
  /*                                               */
  /* See if javascript_set_pending_fetch has been  */
  /* used to record a fetch that needs to be done  */
  /* as soon as possible.                          */
  /*                                               */
  /* Use javascript_do_pending_fetch to start the  */
  /* new fetch, if this function says there is one */
  /* waiting.                                      */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             to check against the one          */
  /*             recorded for the pending fetch.   */
  /*                                               */
  /* Returns:    1 if a there is indeed a new      */
  /*             fetch to start, else 0.           */
  /*************************************************/
d1814 10
a1823 11
  /*************************************************/
  /* javascript_do_pending_fetch()                 */
  /*                                               */
  /* If javascript_fetch_is_pending says there is  */
  /* a fetch to be done, use this function to      */
  /* start it.                                     */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             to check against the one          */
  /*             recorded for the pending fetch.   */
  /*************************************************/
d1863 25
a1887 28
  /*************************************************/
  /* javascript_fix_invalid_date_format()          */
  /*                                               */
  /* Look for dates of the form:                   */
  /*                                               */
  /*   FullDayName, dd-mmm-yy                      */
  /*                                               */
  /* and change them to:                           */
  /*                                               */
  /*   Day, dd mmm yy                              */
  /*                                               */
  /* to improve the changes of them being accepted */
  /* by the Date object constructor. For example,  */
  /* "Wednesday, 18-Oct-97" will be changed to     */
  /* "Wed, 18 Oct 97".                             */
  /*                                               */
  /* Originally created in a vague attempt to make */
  /* Last-modified dates returned by Netscape      */
  /* Commerce server readable by 'new Date(...)'.  */
  /*                                               */
  /* Parameters: Pointer to the date string, which */
  /*             may be modified; it will always   */
  /*             end up the same length or shorter */
  /*             than the string passed.           */
  /*                                               */
  /* Returns:    1 if the string was modified,     */
  /*             else 0.                           */
  /*************************************************/
d1946 20
a1965 24
  /*************************************************/
  /* javascript_reread_window_details()            */
  /*                                               */
  /* The screen X and Y positions, size etc. of    */
  /* the browser window in JavaScript are recorded */
  /* to the accuracy of a JSDouble. JavaScript     */
  /* code may add 0.1 to the X position 10 times   */
  /* and have the window move one pixel. So, just  */
  /* reading the values from the Wimp each time we */
  /* need to change or return something is not     */
  /* good enough - we have to keep a similarly     */
  /* accurate record.                              */
  /*                                               */
  /* Keeping such a record requires this function  */
  /* to be called whenever code moves, resizes or  */
  /* otherwise changes a browser window or frame.  */
  /* This will ensure that the JSDouble accuracy   */
  /* information is kept correctly updated.        */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             relevant to the window for whom   */
  /*             the updated information is to be  */
  /*             recorded.                         */
  /*************************************************/
d1999 17
a2015 18
  /*************************************************/
  /* javascript_register_post_exec_action()        */
  /*                                               */
  /* Register an action to take place after a      */
  /* script has executed. Usually called by the    */
  /* script itself somewhere in the native back    */
  /* end code.                                     */
  /*                                               */
  /* Note: To register a requirement to visit a    */
  /* URL, use javascript_set_pending_fetch instead */
  /* of this system (actions set here are executed */
  /* too early for pending fetches to work).       */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             to which the action is relevant;  */
  /*                                               */
  /*             Action type (see JavaScript.h).   */
  /*************************************************/
d2032 6
a2037 6
  /*************************************************/
  /* javascript_clear_post_exec_actions()          */
  /*                                               */
  /* Get rid of any pending post execution actions */
  /* (e.g. ready for a new script to run).         */
  /*************************************************/
d2051 7
a2057 8
  /*************************************************/
  /* javascript_handle_post_exec_actions()         */
  /*                                               */
  /* Some scripts do stuff that wants to actually  */
  /* happen after the script has exitted (e.g.     */
  /* close a window). This executes commands that  */
  /* the script has requested.                     */
  /*************************************************/
@


1.13
log
@Misecllaneous tweaks and fixes. Major addition is full header and footer
support in the printing system - see the Phoenix Choices file for more
information.

Only the Phoenix resources are up to date currently.
@
text
@d2154 1
a2154 1
                    exec->type);
d2156 1
a2156 1
            show_error_ret(&erb)
@


1.12
log
@Long overdue check-in of intermediate browser build, from continued "out
of hours" work. Forgot to add a few files last time too.

List dialogue box handler complete, and exclusion lists implemented
within the main browser code. Full documentation in Choices file.
Save routine knows all about it but is now getting very slow - must
come up with a better scheme; for now, it puts the hourglass on...

StripExtensions option controls auto stripping of filename extensions.

More sensible ancestor / frame selection for keyboard shortcut items
and the save dialogues - having selected a frame won't lock you into
it for F3 and related shortcuts now (input focus in URL writable ->
get ancestor details, input focus in frame -> get frame details). F4
works in frames. F5 now generally present for 'view source' with a
corresponding menu entry in the File menu.

Odd thing in later Res files; there's no action set for Adjust clicks
on the main ToolAction items in the button bar. Very odd. Nothing
appears to be set in v2.07 either, yet adjust-click works. Even
stranger. Anyway, added in the relevant event details (same as for
Select click in all cases) and this fixes the problem.

Background colours in the TABLE tag ignored the "don't print any
backgrounds" Print Style setting. Fixed. Meanwhile, the "black
text with no backgrounds" option wasn't getting this right either;
fixed this also.

Event logging implemented; HTTP errors and script output via.
window.print extension. No internal error output yet.

Faith:Never behaviour extended. If ever a server sends something with
no content type or an unhandleable type, the browser will try and get a
filetype from the URL. If it gets text or HTML, it'll render the file.
Else it'll save it. Hacks around IIS 4's lack of a content type field
in the Marketeye login stuff, and similar other slightly broken sites.
@
text
@d584 3
a586 1
    erb.errnum = Utils_Error_Custom_Message;
d588 3
a590 4
    StrNCpy0(erb.errmess,
             lookup_token("JSMisc:JavaScript error",
                          0,
                          0));
d592 4
a595 5
    if (strlen(message) + 3 < sizeof(erb.errmess))
    {
      strcat(erb.errmess, " - ");
      strcat(erb.errmess, message);
    }
d597 5
a601 3
    eventlogs_log_message(script_browser,
                          eventlogs_script_information,
                          message);
d603 3
a605 1
    response = show_error_ask(&erb, "JSErr2:Continue,More info");
@


1.11
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d43 1
d47 1
d50 1
d71 13
d86 4
a89 2
  static JSBool PR_CALLBACK   javascript_watchdog           (JSContext * cx, JSScript * script);
  static void                 javascript_error              (JSContext * cx, const char * message, JSErrorReport * report);
d93 19
a111 17
  static unsigned int        watchdog_counter;
  static unsigned int        watchdog_start;
  static unsigned int        watchdog_leds;

  static browser_data      * script_browser = NULL;
  static javascript_source   script_source  = JavaScript_Source_Unknown;
  static char              * script_write_p = NULL;
  static int                 script_write_l = 0;

  static int                 source_set     = 0;
  static int                 doc_write_used = 0;
  static int                 proceed        = 0;

  static browser_data      * pending_b      = NULL;
  static char              * pending_url    = NULL;
  static int                 pending_record = 0;
  static int                 pending_stop   = 0;
d156 1
d597 4
d633 1
a633 1
      if (report->lineno)   fprintf(f, "%u: ", report->lineno);
d1227 4
d1360 4
d1484 4
d1558 4
d1762 1
a1762 1
  /* parameters list mirros exactly those for      */
d2030 140
@


1.10
log
@Another intermediate version, rather more stable than the last I hope.

Lazy clearing of backgrounds - pages with the same background image or
colour won't be cleared to grey when going from one to the next anymore.

BODY element onLoad script attribute implemented properly (beyond the
Customer hackery).

Images use independent flex blocks for URL and transient fetch data;
greatly improved data throughput in image system as a result. Image
renumbering implemented - speeds up closing of pages / frames with
many images. Image xref is still rather slow though and images with
a 0 width or height specified in the HTML still cause an incorrectly
formatted page to appear.

Have, I think, fixed the "stops anti-aliasing" bug. Noticed that some
background images are not being processed as Fast (e.g. at the
Fibblesnork Lego Guide) - that old problem has reappeared, then.

Background images would cross reference when two pages had the same
background colour set in <body> elements but one was configured to use
document colours and one wasn't (so xref should not occur). Code was
looking at b->background_colour; corrected to call redraw_backcol(b).

Titles were added to the history according to the fetch URL not the
display URL, though the former is more likely to be in the history due
to the code execution order in the fetcher; changed to see whether this
improves upon the rather hit and miss addition of titles.

The 'about:' page now gets entered into the history (makes for much more
sensible behaviour if it is configured as a Home page, for example).
@
text
@d739 3
a741 1
    jsr = JS_Init(JavaScript_HeapBeforeAutoGC /* See JavaScript.h */);
d743 3
a745 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_startup: Obtained run-time structure %p\n", jsr);
    #endif
d747 3
a749 3
    if (!jsr)
    {
      erb.errnum = Utils_Error_Custom_Fatal;
d751 4
a754 4
      StrNCpy0(erb.errmess,
               lookup_token("JSInit:JavaScript interpreter initialisation failed (not enough memory?)",
                            0,
                            0));
d756 2
a757 1
      return &erb;
d846 1
a846 1
    if (b->bcx) return NULL;
d1848 86
@


1.9
log
@Another intermediate check-in, resources may not be up to date; items
most likely to be buildable are PhoenixJ and BrowseD. Done because I'm
about to make some rather dodgy changes to code otherwise unchanged
since the Customer browser and I may well have to back them out...

In Handlers.c now set the HFlags_HasBeenVisited bit of a token at the point
it is first clicked on. Means the link returns to a "visited" colour after
the highlight flash immediately. This will persist for as long as the browser
window is kept open on that page, though if the URL doesn't end up making it
into the history for whatever reason it would "unhighlight" on reload; fair
enough, really. The highlight is window-local, so there are no redraw worries
for other open windows with links to the same URL (though other same-URL
links on the same page aren't updated either).

All forms submissions force a reload (principally for eudoramail.com, but
many other sites have similar requirements).

!MkClean and !MkClnAll didn't correctly call the utility to strip Makefile
dependencies. Fixed.

On fetch closedown, fetchpage_preprocess_token could be called on a token
which had already been run through the preprocessor. Now checks the flags
word before proceeding.

Image RAM cache and garbage collection system implemented - see new Choices
file entries CollectAfter, FreeRAMLimit and UnusedImageLimit to get an
overview. This contains groundwork for JavaScript image array support.

More JavaScript support improvements. Any one window object will know its
parent, top, this, etc.; frames array working except for a frameset created
via. multiple documents; opener for something created with window.open is
currently not set and don't know why (property is being created, pointer to
valid object is held, but JS engine returns 'null'. Ho hum) - JSChain won't
work yet, then.
@
text
@d117 2
d130 13
a142 1
  b->onload = NULL;
@


1.8
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d48 1
d51 1
d66 2
d78 1
d83 1
d88 5
d208 3
a210 1
  browser_data * targetted = b;
d271 1
a271 1
    url = HtmlRelativiseURL(r_url, url, targetted->stream);
d278 5
a282 1
  return fetchpage_new(targetted, url, record, 0);
d325 5
a329 2
    int now;
    int esc;
d339 21
a359 1
    /* Deal with hourglass LEDs */
d361 24
a384 4
    if (!((now - watchdog_start) & BRANCH_CALLBACK_LED_MASK))
    {
      _swix(Hourglass_LEDs,
            _INR(0,1),
d386 39
a424 2
            3,
            watchdog_leds);
d426 1
a426 2
      watchdog_leds ^= 3;
    }
d435 3
a437 1
    /* Check Escape */
d439 2
a440 2
    if (!_swix(OS_Byte,
               _INR(0, 1) | _OUT(1),
d442 2
a443 2
               121, /* Key scan reason code */
               112, /* Key code for Escape  */
d445 1
a445 3
               &esc))
    {
      if (esc != 255)
d447 3
a449 1
        erb.errnum = Utils_Error_Custom_Message;
d451 4
a454 4
        StrNCpy0(erb.errmess,
                 lookup_token("JSEsc:Escape (script aborted)",
                              0,
                              0));
d456 1
a456 1
        show_error_cont(&erb);
d458 2
a459 1
        return JS_FALSE;
a460 1
    }
d462 4
a465 4
    if (choices.js_watchdog)
    {
      /* Watchdog - if the script has taken more than a certain */
      /* length of time, ask if we should stop it.              */
d467 3
a469 3
      if (now - watchdog_start > choices.js_timeout)
      {
        /* Build the query message */
d471 1
a471 1
        erb.errnum = Utils_Error_Custom_Message;
d473 4
a476 4
        StrNCpy0(erb.errmess,
                 lookup_token("JSLock:Lengthy JavaScript script is still running. Continue?",
                              0,
                              0));
d478 1
a478 1
        /* Turn off the hourglass */
d480 1
a480 1
        _swix(Hourglass_Off, 0);
d482 2
a483 2
        /* If the user didn't select 'Continue', */
        /* stop the script.                      */
d485 6
a490 6
        if (
             show_error_ask(&erb,
                            "JSErr1:Continue,Stop")
             != 3
           )
           return JS_FALSE;
d492 2
a493 2
        /* Turn the hourglass back on, since we're continuing */
        /* with the script.                                   */
d495 2
a496 2
        _swix(Hourglass_Start,
              _IN(0),
d498 1
a498 1
              1);
d500 2
a501 2
        _swix(Hourglass_LEDs,
              _INR(0,1),
d503 2
a504 2
              3,
              watchdog_leds);
d506 1
a506 1
        /* Don't forget to reset the counter :-) */
d508 1
a508 1
        watchdog_counter = 0;
d510 3
a512 3
        if (
             _swix(OS_ReadMonotonicTime,
                   _OUT(0),
d514 4
a517 3
                   &watchdog_start)
           )
           watchdog_start = now;
d519 2
a520 1
    }
d708 6
a713 1
    /* Initialise the JavaScript system */
d715 10
d728 1
a728 1
      if (tl & (1u<<24)) Printf("javascript_configure_environment: Obtained run-time structure %p\n", jsr);
d743 13
d757 37
a793 1
      if (tl & (1u<<24)) Printf("javascript_configure_environment: Successful\n");
d807 3
a825 1
//Printf("JGC called for %p (Ancestor? %s)\n",b,!b->ancestor ? "yes" : "no"); // (Yes, '!b->ancestor' is correct)
d829 1
a829 16
    if (b->bcx)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser 0x%08x already has a JSI context in javascript_gain_context()",
                (int) b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }
d906 2
a907 1
  /* inherited, it is NOT destroyed.               */
d930 2
d935 1
a935 1
        if (tl & (1u<<24)) Printf("javascript_lose_context: Browser %p has an inherited context, which was not destroyed (exitting)\n", b);
d937 4
d942 2
a943 1
      return NULL;
a945 6
    JS_GC(b->bcx);
    JS_DestroyContext(b->bcx);

    b->bcx           = NULL;
    b->bcx_inherited = NULL;

d1023 1
a1023 1
                "Browser %p does not have an JSI context",
d1225 3
a1227 1
      _swix(Hourglass_On, 0);
d1234 3
a1236 1
      _swix(Hourglass_Off, 0);
d1361 16
d1474 3
a1476 1
      _swix(Hourglass_On, 0);
d1483 3
a1485 1
      _swix(Hourglass_Off, 0);
d1688 143
@


1.7
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d61 2
a62 4
  #define WATCHDOG
  #define BRANCH_CALLBACK_GC_MASK      0
  #define BRANCH_CALLBACK_LED_MASK     63
  #define BRANCH_CALLBACK_INTERRUPT_AT 1000
d76 2
d309 1
d339 1
a339 1
    #ifdef WATCHDOG
d341 25
d367 1
a367 1
      /* number of iterations, abort execution.                 */
d369 1
a369 1
      if (now - watchdog_start > BRANCH_CALLBACK_INTERRUPT_AT)
d411 8
a418 1
        watchdog_start   = now;
d420 1
a420 2

    #endif
d610 1
a610 1
    jsr = JS_Init(256 * 1024);
d613 1
a613 1
      if (tl & (1u<<24)) Printf("Global JavaScript run-time structure %p obtained in initialise_app()\n", jsr);
d763 4
d770 1
a770 1
        if (tl & (1u<<24)) Printf("Browser %p has no context anyway in javascript_lose_context\n", b);
d781 1
a781 1
        if (tl & (1u<<24)) Printf("Browser %p has an inherited context, which was not destroyed in javascript_lose_context\n", b);
d793 4
d845 1
a845 1
//Printf("%p ended up with OID %p\n",b,b->window_object);
d1131 5
a1135 2
          flex_free(&b->source);
          b->source = NULL;
d1194 1
a1197 1
    char         * block = NULL;
d1255 2
d1315 11
a1325 1
    /* Return the results (temporary hack) */
d1327 2
a1328 9
    if (
         !ok                        ||
         result == JSVAL_VOID       ||
         !JS_ConvertValue(b->bcx,
                          result,
                          JSTYPE_STRING,
                          &result)
       )
       ok = 0;
d1330 1
a1330 1
    if (ok)
d1332 5
a1336 1
      int result_len = JS_GetStringLength(JSVAL_TO_STRING(result)) + 1;
d1338 1
a1338 1
      if ((block = HtmlMalloc(result_len, script_element)) != NULL) /* This zero-fills the block to ensure correct termination */
d1340 3
a1342 5
        strncpy(block, JS_GetStringBytes(JSVAL_TO_STRING(result)), result_len);
      }
      else
      {
        show_error_ret(make_no_javascript_memory_error(3));
d1346 40
d1387 31
d1419 6
a1424 1
    /* TRACE builds will report how successful the execution was */
d1426 2
a1427 1
    #ifdef TRACE
d1429 3
a1431 1
      if (tl & (1u<<24))
d1433 4
a1436 2
        if (ok) Printf("javascript_script_callback: \0212Script ran OK\0217\n");
        else    Printf("javascript_script_callback: \0211Script failed or returned no result\0217\n");
d1439 14
a1452 1
    #endif
d1454 7
a1460 1
    /* Finished */
d1462 5
a1466 3
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_script_callback: Successful\n");
    #endif
d1468 3
a1470 1
    return block;
@


1.6
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d28 1
d44 1
d46 1
d48 2
d54 30
d267 1150
@


1.5
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@d45 1
d206 1
a206 1
  if (!strstr(url, "http://"))
@


1.4
log
@Checking in mostly because its Friday... Quite a few little bug fixes
(adding up to a greater whole), which include removal of the dastardly
'invalid image number' errors that trace builds would raise from time to
time. Frame highlights are now better controlled (releaseably so).
Generally, this build represents the first genuinely promising version
of the browser for quite some time, despite the known library problems
with comment handling etc.
@
text
@d17 3
a19 1
/* Purpose: JavaScript support                     */
d21 2
a22 1
/* History: 24-Jul-97: Created                     */
@


1.3
log
@Customer work complete, and this version just shipped. Had to comment out
the code in Main.c that sets the user agent string to fake Netscape, as the
persistent problems with forms in tables showed up much more on a modem
link - net result was that the customer's log in page didn't work. Not
faking Netscape gives an authorisation dialogue instead, allowing access
to the site even if not by the most elegant of methods.
@
text
@d172 1
a172 3
    browser_data * ancestor = b->ancestor;

    if (!ancestor) ancestor = b;
d204 1
a204 1
    browser_data * ancestor = targetted->ancestor;
a206 2
    if (!ancestor) ancestor = targetted;

d226 1
a226 1
  return fetchpage_new(targetted, url, record);
@


1.2
log
@In the middle of customer support work.
@
text
@d95 9
a103 1
/*             that item.                        */
d106 1
a106 1
_kernel_oserror * javascript_href_onclick(browser_data * b, HStream * t)
d114 2
d122 1
a122 1
      e = customer_href_onclick(b, t);
@


1.1
log
@Forgot to add the JavaScript, Customer and Meta source files at last
check in...! Put in a few utilities in a new Utils directory also, which
includes a TaskObey script that will take a backup of the Makefile, strip
out the dependencies list, and (assuming the CVS call doesn't crash),
restore the Makefile with dependencies intact from the backup.
@
text
@a26 1
#include "flex.h"
d38 3
d61 45
d108 6
a113 1
    return customer_body_onload(b);
d117 102
a218 2
  // Don't forget to set the onload field to NULL after use,
  // or this'll keep getting called as images fetch!
d220 1
a220 1
  return NULL;
@

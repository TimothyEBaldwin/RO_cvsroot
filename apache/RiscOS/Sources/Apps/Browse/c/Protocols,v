head	1.30;
access;
symbols
	Browse-2_16:1.30
	Browse-2_15:1.30
	Browse-2_14:1.30
	Browse-2_13:1.30
	Browse-2_12:1.30
	Browse-2_11:1.29
	Browse-2_10:1.29
	Browse-2_09:1.29
	ahodgkin_208_i4_2:1.28
	ahodgkin_208_i4:1.26
	ahodgkin_208_i3:1.26
	ahodgkin_208_i2:1.26
	ahodgkin_208_i1:1.26
	ahodgkin_207release:1.25
	ahodgkin_206release:1.24
	ahodgkin_205release:1.23
	ahodgkin_204release:1.23
	ahodgkin_202release:1.22
	ahodgkin_201release:1.21
	ahodgkin_200release:1.21
	ahodgkin_133beta:1.21
	ahodgkin_132beta:1.20
	ahodgkin_131beta:1.20
	ahodgkin_130beta:1.18
	ahodgkin_129:1.17
	ahodgkin_128beta:1.15
	ahodgkin_128alpha:1.15
	ahodgkin_127beta2:1.14
	ahodgkin_127beta:1.14
	ahodgkin_126beta:1.13
	ahodgkin_AW97patch:1.12
	ahodgkin_AW97:1.12;
locks; strict;
comment	@# @;


1.30
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.26.09.42.34;	author ahodgkin;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.14.08.45.07;	author ahodgkin;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.31.15.58.44;	author ahodgkin;	state Exp;
branches;
next	1.26;

1.26
date	99.09.02.13.10.28;	author ahodgkin;	state Exp;
branches;
next	1.25;

1.25
date	98.09.07.11.46.57;	author ahodgkin;	state Exp;
branches;
next	1.24;

1.24
date	98.07.09.10.27.20;	author ahodgkin;	state Exp;
branches;
next	1.23;

1.23
date	98.04.16.08.14.20;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	98.03.20.12.12.53;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	98.02.13.17.32.22;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	98.01.31.10.55.28;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	98.01.23.16.50.16;	author kbracey;	state Exp;
branches;
next	1.18;

1.18
date	97.12.18.10.07.03;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	97.12.12.17.12.28;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	97.12.12.11.18.01;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	97.11.27.17.50.04;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	97.11.19.10.29.08;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.10.30.17.11.11;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.10.13.07.07.00;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.10.09.10.52.07;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.09.24.11.14.21;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.09.22.07.43.22;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.09.18.08.59.01;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.09.15.12.41.31;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.09.14.19.18.16;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.09.12.17.19.30;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.09.09.14.13.19;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.09.03.12.36.10;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.09.02.15.46.02;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.08.31.18.38.21;	author ahodgkin;	state Exp;
branches;
next	;


desc
@@


1.30
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Protocols.h                                       */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Handle some common protocol stuff, such as        */
/*          inter-application data transfer.                  */
/*                                                            */
/*          Function naming convention is as usual a source   */
/*          leafname derived prefix, then a code based on the */
/*          protocol being dealt with:                        */
/*                                                            */
/*          _atats_  App To App Transfer, Save                */
/*          _atatl_  App To App Transfer, Load                */
/*          _pp_     Printer Protocol                         */
/*          _auh_    Acorn URI Handler                        */
/*          _ih_     Interactive Help                         */
/*          _aub_    ANT URL Broadcast                        */
/*          _multi_  Message is used in more than one message */
/*                   protocol scheme                          */
/*          _util_   A utility function not directly          */
/*                   connected with a specific protocol.      */
/*                                                            */
/*          This is followed by the direction, so to speak -  */
/*          i.e. '_got_' for got a message, '_send_' for      */
/*          sending a message. Alternatively, a prefix        */
/*          '_bounced' is used for messages which return as a */
/*          UserMessage_Acknowledge event.                    */
/*                                                            */
/*          Because the Plug-In message protocol is such a    */
/*          large and self-contained entity, this is kept     */
/*          separate, in PlugIn.h.                            */
/*                                                            */
/*          Do NOT use MemLib here, as you will hit the Wimp  */
/*          bug relating to message blocks stored at high     */
/*          addresses (given an old enough Wimp) if you do.   */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 29-Aug-1997 (ADH): Created.                       */
/*          06-Sep-1997 (ADH): Significant rewriting to stop  */
/*                             various clashes and increase   */
/*                             flexibility.                   */
/*          17-Apr-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <URI.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>

#include "Global.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "FetchPage.h"
#include "Filetypes.h"
#include "Forms.h"
#include "History.h"
#include "Hotlist.h"
#include "Images.h"
#include "JavaScript.h"
#include "MimeMap.h"
#include "OpenURL.h"
#include "Printing.h"
#include "Save.h"
#include "SaveDraw.h"
#include "SaveFile.h"
#include "SaveObject.h"
#include "SaveSHelp.h"
#include "SaveText.h"
#include "Toolbars.h"
#include "URLutils.h"
#include "Windows.h"

#include "Protocols.h"

/* Conditional includes */

#ifdef TRACE
  #include "Trace.h"
#endif

/* Local definitions */

#define RTB_Size 4096 /* RAM transfer buffer size, in bytes */

/* Local variables */

/* Need to retain information across function calls about the */
/* different processes going on. Since an object save could   */
/* be in progress whilst other saves go on above it, all of   */
/* the remembered items have to be independent. Consequently, */
/* a lot of separate statics are needed.                      */

/* View source - broadcast loading */

static int             data_open_reference                 = 0;

/* Saving the page source */

static int             save_source_reference               = 0;
static int             save_source_transmitted             = 0;
static browser_data  * save_source_browser                 = NULL;

/* Exporting the page as text */

static int             save_as_text_reference              = 0;
static browser_data  * save_as_text_browser                = NULL;
static int             save_as_text_embelishments          = 0;

/* Exporting the page as Draw */

static int             save_as_draw_reference              = 0;
static browser_data  * save_as_draw_browser                = NULL;
static int             save_as_draw_backgrounds            = 0;

/* Exporting the page as a StrongHelp manual */

static int             save_as_shelp_reference             = 0;
static browser_data  * save_as_shelp_browser               = NULL;

/* Printing the page to a PDF file */

static int             save_as_pdf_reference               = 0;
static browser_data  * save_as_pdf_browser                 = NULL;

/* Saving a link */

static int             save_link_reference                 = 0;
static int             save_link_transmitted               = 0;
static browser_data  * save_link_browser                   = NULL;
static HStream       * save_link_token                     = NULL;
static int             save_link_as_url                    = 0;

/* Saving the current location */

static int             save_location_reference             = 0;
static int             save_location_transmitted           = 0;
static browser_data  * save_location_browser               = NULL;
static int             save_location_as_url                = 0;

/* Exporting a log file */

static int             save_log_reference                  = 0;
static int             save_log_transmitted                = 0;
static eventlogs_log * save_log_log                        = NULL;
static int             save_log_selection                  = 0;

#ifndef REMOTE_HOTLIST

  /* Saving a hotlist item */

  static int            save_hotlist_entry_reference       = 0;
  static int            save_hotlist_entry_transmitted     = 0;
  static hotlist_item * save_hotlist_entry_item            = NULL;
  static int            save_hotlist_entry_as_url          = 0;

  /* Saving a hotlist selection */

  static int            save_hotlist_selection_reference   = 0;
  static int            save_hotlist_selection_transmitted = 0;

  /* Saving the entire hotlist */

  static int            save_entire_hotlist_reference      = 0;
  static int            save_entire_hotlist_transmitted    = 0;

#endif

/* Saving the History */

static int             save_history_reference              = 0;
static browser_data  * save_history_browser                = NULL;

/* Saving an object through the fetcher */

static int             save_object_reference               = 0;
static int             save_object_transmitted             = 0;
static browser_data  * save_object_browser                 = NULL;
static int             save_object_through_scrap           = 0;

/* Exporting an image as a sprite */

static int             save_image_reference                = 0;
static int             save_image_transmitted              = 0;
static browser_data  * save_image_browser                  = NULL;
static HStream       * save_image_token                    = NULL;
static int             save_image_as_original              = 0;

/* Loading data. For RAM transfer, buffers must be */
/* visible to all functions so they can be freed   */
/* in the event of a transfer failure.             */

static WimpMessage   * pending_data_save_ack               = NULL;
static char          * data_save_suggested_leafname        = NULL;

static void          * rtb                                 = NULL;
static int             ram_fetch_reference                 = 0;

static char          * ram_load_uri_buffer                 = NULL;
static int             ram_load_buffer_size                = 0;
static int             ram_load_started                    = 0;

/* Printing */

static int             print_save_reference                = 0;

/* Static function prototypes */

static _kernel_oserror * protocols_atats_got_data_save_ack (WimpMessage * m);
static _kernel_oserror * protocols_pp_got_data_save_ack    (WimpMessage * m);

static void              protocols_util_update_reference   (int old_ref, int new_ref);

/**************************************************************/
/* protocols_atats_send_data_open()                           */
/*                                                            */
/* Broadcasts a Message_DataOpen for the given filetype and   */
/* given pathname.                                            */
/*                                                            */
/* Parameters: The filetype to use;                           */
/*                                                            */
/*             Pointer to a null-terminated pathname to use.  */
/**************************************************************/

_kernel_oserror * protocols_atats_send_data_open(int filetype, char * pathname)
{
  WimpMessage dop;

  dprintf(("MsgP", "protocols_atats_send_data_open: Called\n"));

  /* Fill in the header */

  dop.hdr.your_ref    = 0;
  dop.hdr.action_code = Wimp_MDataOpen;

  /* Fill in the message body */

  dop.data.data_open.window_handle = 0;
  dop.data.data_open.x             = 0;
  dop.data.data_open.y             = 0;
  dop.data.data_open.file_type     = filetype;

  StrNCpy0(dop.data.data_open.path_name, pathname);

  dop.hdr.size = (int) WordAlign(strlen(dop.data.data_open.path_name) + 45); /* (44 for stuff up to the pathname, plus 1 for terminator) */

  /* Send the message */

  RetError(wimp_send_message(Wimp_EUserMessageRecorded, &dop, 0, 0, NULL));

  /* Record my_ref in case it bounces */

  data_open_reference = dop.hdr.my_ref;

  return NULL;
}

/**************************************************************/
/* protocols_atats_data_open_bounced()                        */
/*                                                            */
/* For a View Source function, the browser broadcasts a       */
/* Message_DataOpen. If this bounces, attempt to start an     */
/* editor instead, with the pathname specified in the         */
/* message.                                                   */
/*                                                            */
/* See PRM 3-265.                                             */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_atats_data_open_bounced(WimpMessage * m)
{
  dprintf(("MsgP", "protocols_atats_data_open_bounced: Called\n"));

  if (m->hdr.my_ref == data_open_reference)
  {
    _kernel_oserror * e;
    char            * combuf;
    char            * comstart = "If \"Alias$@@RunType_FFF\" <> \"\" Then @@RunType_FFF ";
    int               len;

    data_open_reference = 0;

    /* Want to run '@@RunType_FFF' with the given pathname as a parameter;  */
    /* need to assemble this command string. Work out how long it will be. */

    len = strlen(comstart) + strlen(m->data.data_open.path_name) + 1;

    /* Allocate space for it (complain if this fails). */

    combuf = malloc(len);

    if (!combuf) return make_no_memory_error(9);

    /* Assemble the string */

    strcpy(combuf, comstart);
    strcat(combuf, m->data.data_open.path_name);

    /* Execute the command */

    e = _swix(Wimp_StartTask,
              _IN(0),

              combuf);

    /* Free the command buffer and return the value the _swix call gave back */

    free(combuf);
    combuf = NULL;

    return e;
  }

  #ifdef TRACE

    else
    {
      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Message reference %x not recognised in protocols_atats_data_open_bounced",
              m->hdr.your_ref);

      return &erb;
    }

  #endif

  return NULL;
}

/**************************************************************/
/* protocols_atats_send_data_save()                           */
/*                                                            */
/* Send out a Message_DataSave to initiate saving of data to  */
/* another applicaion.                                        */
/*                                                            */
/* See PRM 3-250 to 3-252.                                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the save (or NULL);                            */
/*                                                            */
/*             Pointer to an item that will vary depending on */
/*             what is being saved - e.g. an HStream struct,  */
/*             a hotlist item, or NULL... full details by the */
/*             definition of the protocols_saving enumeration */
/*             in Protocols.h;                                */
/*                                                            */
/*             Pointer to a null terminated leafname to use;  */
/*                                                            */
/*             If possible, the estimated size of the data,   */
/*             else -1;                                       */
/*                                                            */
/*             Filetype to quote;                             */
/*                                                            */
/*             A protocols_saving value to say what is being  */
/*             saved (see Protocols.h);                       */
/*                                                            */
/*             A WimpGetPointerInfo block pointer, from which */
/*             the window and icon handle to send to, and x   */
/*             and y coords to send to, are read.             */
/**************************************************************/

_kernel_oserror * protocols_atats_send_data_save(browser_data * b, void * extra, char * leaf, int estimated_size, int filetype,
                                                 protocols_saving saving, WimpGetPointerInfoBlock * info)
{
  WimpMessage m;

  dprintf(("MsgP", "protocols_atats_send_data_save: Called\n"));

  /* Fill in the header */

  m.hdr.sender      = task_handle;
  m.hdr.your_ref    = 0;
  m.hdr.action_code = Wimp_MDataSave;

  /* Fill in the message body */

  m.data.data_save.destination_window = info->window_handle;
  m.data.data_save.destination_icon   = info->icon_handle;
  m.data.data_save.destination_x      = info->x;
  m.data.data_save.destination_y      = info->y;
  m.data.data_save.estimated_size     = estimated_size;
  m.data.data_save.file_type          = filetype;

  /* Copy in the leafname and work out the message size */

  StrNCpy0(m.data.data_save.leaf_name, leaf);

  m.hdr.size = (int) WordAlign(strlen(m.data.data_save.leaf_name) + 45);

  /* Send it */

  RetError(wimp_send_message(Wimp_EUserMessage,
                             &m,
                             info->window_handle,
                             info->icon_handle,
                             NULL));

  /* Remember various details */

  switch (saving)
  {
    /* Save the document source */

    case protocols_saving_document_source:
    {
      save_source_reference              = m.hdr.my_ref;
      save_source_transmitted            = 0;
      save_source_browser                = b;
    }
    break;

    /* Export the document as text */

    case protocols_saving_document_as_text:
    {
      save_as_text_reference             = m.hdr.my_ref;
      save_as_text_browser               = b;
      save_as_text_embelishments         = savefile_alternative_selected();
    }
    break;

    /* Export the document as a Draw file */

    case protocols_saving_document_as_draw:
    {
      save_as_draw_reference             = m.hdr.my_ref;
      save_as_draw_browser               = b;
      save_as_draw_backgrounds           = savefile_alternative_selected();
    }
    break;

    /* Export the document as a StrongHelp manual */

    case protocols_saving_document_as_shelp:
    {
      save_as_shelp_reference            = m.hdr.my_ref;
      save_as_shelp_browser              = b;
    }
    break;

    /* Print the document to a PDF file */

    case protocols_saving_document_as_pdf:
    {
      save_as_pdf_reference              = m.hdr.my_ref;
      save_as_pdf_browser                = b;
    }
    break;

    /* Save a link as a URI file */

    case protocols_saving_link:
    {
      save_link_reference                = m.hdr.my_ref;
      save_link_transmitted              = 0;
      save_link_browser                  = b;
      save_link_token                    = (HStream *) extra;
      save_link_as_url                   = savefile_alternative_selected();
    }
    break;

    /* Save the current location as a URI file */

    case protocols_saving_frame_location:
    {
      save_location_reference            = m.hdr.my_ref;
      save_location_transmitted          = 0;
      save_location_browser              = b;
      save_location_as_url               = savefile_alternative_selected();
    }
    break;

    /* Save a log file */

    case protocols_saving_log:
    {
      save_log_reference                 = m.hdr.my_ref;
      save_log_transmitted               = 0;
      save_log_log                       = (eventlogs_log *) extra;
      save_log_selection                 = savefile_alternative_selected();
    }
    break;

    #ifndef REMOTE_HOTLIST

      /* Save a hotlist item as a URI file */

      case protocols_saving_hotlist_entry:
      {
        save_hotlist_entry_reference       = m.hdr.my_ref;
        save_hotlist_entry_transmitted     = 0;
        save_hotlist_entry_item            = (hotlist_item *) extra;
        save_hotlist_entry_as_url          = filetype == FileType_URI ? 0 : 1;
      }
      break;

      /* Save a selection of hotlist items as an HTML file */

      case protocols_saving_hotlist_selection:
      {
        save_hotlist_selection_reference   = m.hdr.my_ref;
        save_hotlist_selection_transmitted = 0;
      }
      break;

      /* Save the entire hotlist as an HTML file */

      case protocols_saving_entire_hotlist:
      {
        save_entire_hotlist_reference      = m.hdr.my_ref;
        save_entire_hotlist_transmitted    = 0;
      }
      break;

    #endif

    /* Save an object through the fetcher */

    case protocols_saving_object:
    {
      save_object_reference              = m.hdr.my_ref;
      save_object_transmitted            = 0;
      save_object_browser                = b;
      save_object_through_scrap          = 0;
    }
    break;

    /* Save an image as a sprite */

    case protocols_saving_image_sprite:
    {
      save_image_reference               = m.hdr.my_ref;
      save_image_transmitted             = 0;
      save_image_browser                 = b;
      save_image_token                   = (HStream *) extra;
      save_image_as_original             = savefile_alternative_selected();
    }
    break;

    /* Saving the local or global history */

    case protocols_saving_local_history:
    {
      save_history_reference             = m.hdr.my_ref;
      save_history_browser               = b;
    }
    break;

    case protocols_saving_global_history:
    {
      save_history_reference             = m.hdr.my_ref;
      save_history_browser               = NULL;
    }
    break;
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* protocols_atats_data_save_bounced()                        */
/*                                                            */
/* Deals with a Message_DataSave bouncing.                    */
/*                                                            */
/* See PRM 3-252.                                             */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_atats_data_save_bounced(WimpMessage * m)
{
  dprintf(("MsgP", "protocols_atats_data_save_bounced: Called\n"));

  /* We have nothing to do here at present; this */
  /* is only here to be complete.                */

  return NULL;
}

/**************************************************************/
/* protocols_atats_got_ram_fetch()                            */
/*                                                            */
/* After the browser sends a Message_DataSave to an           */
/* application, it may reply with Message_RAMFetch rather     */
/* than Message_DataSaveAck if it can handle RAM transfer. In */
/* that case, we should see if we can do RAM transfer for     */
/* this filetype ourselves, and if so, transfer data.         */
/*                                                            */
/* See PRM 3-255 and 256.                                     */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             Message_RAMFetch. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_atats_got_ram_fetch(WimpMessage * m)
{
  dprintf(("MsgP", "protocols_atats_got_ram_fetch: Called\n"));

  /* Only the transfer methods by which RAM saving is currently */
  /* supported are listed in the switch. For others, we just do */
  /* nothing. The other application will see its message bounce */
  /* and should send Message_DataSaveAck to continue the save   */
  /* through a temporary file on disc. If not, no loss - from   */
  /* the user's perspective, nothing will have happened.        */
  /*                                                            */
  /* Note all the functions called in the switch statement call */
  /* Protocols.c back again with requests to send a reply of    */
  /* Message_RAMTransmit if they're successful.                 */
  /*                                                            */
  /* Stop press. C can't cope - you can't have a non-constant   */
  /* in a case statement. Good grief. So, this nice elegant     */
  /* case statement gets degraded into a grotty if...else       */
  /* ladder. Yuk, yuk, yuk, yuk, yuk. I *hate* this language.   */

  if (m->hdr.your_ref && m->hdr.your_ref == save_source_reference)
  {
    /* Save document source */

    if (
         is_known_browser(save_source_browser)
       )
       return save_transfer_source(save_source_browser,
                                   &save_source_transmitted,
                                   m);
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_link_reference)
  {
    if (is_known_browser(save_link_browser))
    {
      if (save_link_token)
      {
        /* Save a link as a URI file */

        return save_transfer_uri(save_link_token->anchor,
                                 NULL,
                                 save_link_as_url,
                                 &save_link_transmitted,
                                 m);
      }
      else
      {
        /* Save the current location as a URI file */

        char * url   = browser_current_url  (save_link_browser);
        char * title = browser_current_title(save_link_browser);

        if (!url) url = browser_fetch_url(save_link_browser);
        if (!url) url = " ";

        return save_transfer_uri(url,
                                 title,
                                 save_link_as_url,
                                 &save_link_transmitted,
                                 m);
      }
    }
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_location_reference)
  {
    /* Save the current location as a URI file */

    if (is_known_browser(save_location_browser))
    {
      char * title = browser_current_title(save_location_browser);
      char * url   = browser_current_url(save_location_browser);

      if (!url) url = browser_fetch_url(save_location_browser);
      if (!url) url = " ";

      return save_transfer_uri(url,
                               title,
                               save_location_as_url,
                               &save_location_transmitted,
                               m);
    }
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_log_reference)
  {
    /* Save log file */

    if (save_log_log) return save_transfer_log(save_log_log,
                                               save_log_selection,
                                               &save_log_transmitted,
                                               m);
  }

  #ifndef REMOTE_HOTLIST

    else if (m->hdr.your_ref && m->hdr.your_ref == save_hotlist_entry_reference)
    {
      /* Save a hotlist item as a URI file */

      if (
           save_hotlist_entry_item
         )
         return save_transfer_uri(save_hotlist_entry_item->data.url,
                                  save_hotlist_entry_item->name,
                                  save_hotlist_entry_as_url,
                                  &save_hotlist_entry_transmitted,
                                  m);
    }

  #endif

  return NULL;
}

/**************************************************************/
/* protocols_atats_send_ram_transmit()                        */
/*                                                            */
/* Send out a Message_RAMTransmit in response to a            */
/* Message_RAMFetch from another application, as part of an   */
/* ongoing dialogue for RAM transfer.                         */
/*                                                            */
/* See PRM 3-255 and 256.                                     */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             Message_RAMFetch. The contents will be         */
/*             modified and used in a reply;                  */
/*                                                            */
/*             The number of bytes written to the buffer      */
/*             given in the Message_RAMFetch;                 */
/*                                                            */
/*             1 if this is the last message in the transfer  */
/*             (so it won't be sent UserMessageRecorded and   */
/*             raise an error when it doesn't get             */
/*             acknowledged...).                              */
/**************************************************************/

_kernel_oserror * protocols_atats_send_ram_transmit(WimpMessage * m, int transmitted, int last)
{
  int old_ref = m->hdr.your_ref;

  dprintf(("MsgP", "protocols_atats_send_ram_transmit: Called\n"));

  /* Fill in the parts that need changing */

  m->hdr.your_ref             = m->hdr.my_ref;
  m->hdr.action_code          = Wimp_MRAMTransmit;

  m->data.ram_transmit.nbytes = transmitted;

  #ifdef TRACE

    /* Show the contents of the transmission buffer */

    if (tl & (1u<<28))
    {
      void * local = malloc(m->data.ram_transmit.nbytes);

      if (local)
      {
        if (
             !wimp_transfer_block(m->hdr.sender,
                                  m->data.ram_transmit.buffer,
                                  task_handle,
                                  local,
                                  m->data.ram_transmit.nbytes)
           )
        {
          trace_dump_buffer(m->data.ram_transmit.buffer,
                            m->data.ram_transmit.nbytes,
                            1);
        }
        else dprintf(("", "\n(Cannot dump transmission buffer - error from Wimp_TransferBlock)\n\n"));
      }
      else
      {
        dprintf(("", "\n(Cannot dump transmission buffer - not enough memory for local copy)\n\n"));
      }
    }

  #endif

  /* Send the reply */

  RetError(wimp_send_message(last ? Wimp_EUserMessage : Wimp_EUserMessageRecorded,
                             m,
                             m->hdr.sender,
                             0,
                             NULL));

  /* Update the records of my_ref for subsequent replies and bounces */

  protocols_util_update_reference(old_ref, m->hdr.my_ref);

  /* If this is the last item, may need to do some tidying up */
  /* (don't do this before sending the message, as here we    */
  /* close the menu tree - if the window we were sending to   */
  /* was in a menu... Well, things Go Wrong).                 */

  if (last)
  {
    #ifndef REMOTE_HOTLIST
      if (m->hdr.my_ref == save_hotlist_entry_reference) RetError(hotlist_clear_selection());
    #endif

    if (
         m->hdr.my_ref == save_source_reference        ||
         m->hdr.my_ref == save_link_reference          ||
         m->hdr.my_ref == save_location_reference      ||
         m->hdr.my_ref == save_log_reference

         #ifndef REMOTE_HOTLIST
           || m->hdr.my_ref == save_hotlist_entry_reference
         #endif
       )
    {
      _swix(Wimp_CreateMenu,
            _IN(1),

            -1);
    }
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* protocols_atats_ram_transmit_bounced()                     */
/*                                                            */
/* If a RAMTransmit is not acknowledged, we should abort file */
/* transfer and raise an error.                               */
/*                                                            */
/* See PRM 3-255 and 256.                                     */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_atats_ram_transmit_bounced(WimpMessage * m)
{
  dprintf(("MsgP", "protocols_atats_ram_transmit_bounced: Called\n"));

  /* There's no tidying up to do; just raise an error. */

  erb.errnum = Utils_Error_Custom_Message;

  StrNCpy0(erb.errmess,
           lookup_token("RecvDied:Data transfer failed - receiver died.",
                        0,
                        0));

  return &erb;
}

/**************************************************************/
/* protocols_atats_got_data_save_ack()                        */
/*                                                            */
/* Once we've sent out Message_DataSave we could get          */
/* Message_RAMFetch back and proceed with RAM transfer. Or    */
/* the other task could respond with a Message_DataSaveAck,   */
/* for transfer via a temporary file on disc. This can also   */
/* happen if the other application responds with a            */
/* Message_RAMFetch but we decide we can't do RAM transfer    */
/* for that particular object; the application sees its       */
/* Message_RAMFetch bounce and drops back to                  */
/* Message_DataSaveAck instead.                               */
/*                                                            */
/* See PRM 3-250, 251 and 253.                                */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

static _kernel_oserror * protocols_atats_got_data_save_ack(WimpMessage * m)
{
  _kernel_oserror * e    = NULL;
  int               ok   = 0; /* 0 = problem, 1 = OK, send DataLoad, 2 = OK, but don't send DataLoad */
  char            * path = m->data.data_save_ack.leaf_name; /* (Daft structure definition - it's a path, not a leaf...) */

  dprintf(("MsgP", "protocols_atats_got_data_save_ack: Called\n"));

  /* First, save the file. Yes, it's another nasty if...else ladder */
  /* because C can't handle it as a switch statement...             */

  if (m->hdr.your_ref)
  {
    if (m->hdr.your_ref == save_source_reference)
    {
      /* Save the document source */

      if (is_known_browser(save_source_browser))
      {
        e = save_save_source(path, save_source_browser);
        if (!e) ok = 1;
      }
    }
    else if (m->hdr.your_ref == save_as_text_reference)
    {
      /* Export the document as text */

      if (is_known_browser(save_as_text_browser))
      {
        e = savetext_save_text(save_as_text_browser, path, save_as_text_embelishments);
        if (!e) ok = 1;
      }
    }
    else if (m->hdr.your_ref == save_as_draw_reference)
    {
      /* Export the document as Draw */

      if (is_known_browser(save_as_draw_browser))
      {
        e = savedraw_save_draw(save_as_draw_browser, path, save_as_draw_backgrounds);
        if (!e) ok = 1;
      }
    }
    else if (m->hdr.your_ref == save_as_shelp_reference)
    {
      /* Export the document as a StrongHelp manual */

      if (is_known_browser(save_as_shelp_browser))
      {
        e = saveshelp_save_manual(save_as_shelp_browser, path);
        if (!e) ok = 1;
      }
    }
    else if (m->hdr.your_ref == save_as_pdf_reference)
    {
      /* Export the document as a PDF file */

      if (is_known_browser(save_as_pdf_browser))
      {
        e = print_print(path);

        /* If we get an error, clear it since it has already */
        /* been reported but leave the 'ok' flag clear so    */
        /* that the data save protocol stops here. Only set  */
        /* the 'ok' flag if there was no error.              */

        if (e) e = NULL;
        else   ok = 1;
      }
    }
    else if (m->hdr.your_ref == save_link_reference)
    {
      if (is_known_browser(save_link_browser))
      {
        if (save_link_token)
        {
          /* Save a link as a URI file */

          e = save_save_uri(path, save_link_token->anchor, NULL, save_link_as_url);
          if (!e) ok = 1;
        }
        else
        {
          char * url   = browser_current_url  (save_link_browser);
          char * title = browser_current_title(save_link_browser);

          /* Save the current location as a URI file */

          if (!url) url = browser_fetch_url(save_link_browser);
          if (!url) url = " ";

          e = save_save_uri(path, url, title, 0);
          if (!e) ok = 1;
        }
      }
    }
    else if (m->hdr.your_ref == save_location_reference)
    {
      /* Save the current location as a URI file */

      if (is_known_browser(save_location_browser))
      {
        char * title = browser_current_title(save_location_browser);
        char * url   = browser_current_url(save_location_browser);

        if (!url) url = browser_fetch_url(save_location_browser);
        if (!url) url = " ";

        e = save_save_uri(path,
                          url,
                          title,
                          save_location_as_url);

        if (!e) ok = 1;
      }
    }
    else if (m->hdr.your_ref == save_log_reference)
    {
      /* Save a log file */

      if (save_log_log)
      {
        e = save_save_log(path, save_log_log, save_log_selection);
        if (!e) ok = 1;
      }
    }

    #ifndef REMOTE_HOTLIST

      else if (m->hdr.your_ref == save_hotlist_entry_reference)
      {
        /* Save a hotlist item as a URI file */

        if (save_hotlist_entry_item)
        {
          e = save_save_uri(path, save_hotlist_entry_item->data.url, save_hotlist_entry_item->name, save_hotlist_entry_as_url);

          if (!e)
          {
            ok = 1;
            e = hotlist_clear_selection();
          }
        }
      }
      else if (m->hdr.your_ref == save_hotlist_selection_reference)
      {
        /* Save a hotlist selection as an HTML file */

        e = hotlist_save_hotlist(path, NULL, 1);

        if (!e)
        {
          ok = 1;
          e = hotlist_clear_selection();
        }
      }
      else if (m->hdr.your_ref == save_entire_hotlist_reference)
      {
        /* Save the whole hotlist */

        e = hotlist_save_hotlist(path, NULL, 0);
        if (!e) ok = 1;
      }

    #endif

    else if (m->hdr.your_ref == save_history_reference)
    {
      /* Save the local or global history */

      if (is_known_browser(save_history_browser))
      {
        e = history_save_as_html(path, save_history_browser);
        if (!e) ok = 1;
      }
      else
      {
        e = history_save_as_html(path, NULL);
        if (!e) ok = 1;
      }
    }
    else if (m->hdr.your_ref == save_object_reference)
    {
      if (is_known_browser(save_object_browser))
      {
        /* First, hide the Save Object dialogue */

        e = saveobject_close(save_object_browser);

        if (!e)
        {
          /* If this is through scrap, use a different filename */

          if (m->data.data_save_ack.estimated_size == -1)
          {
            /* Need to store the Message_DataLoad for later */

            save_object_browser->pending_data_load = malloc(sizeof(WimpMessage));
            if (!save_object_browser->pending_data_load) return make_no_memory_error(13);

            #ifdef TRACE
              malloccount += sizeof(WimpMessage);
              dprintf(("CMal", "** malloccount (protocols_atats_got_data_save_ack): \0211%d\0217\n",malloccount));
            #endif

            *save_object_browser->pending_data_load = *m;

            /* Change the filename to something unique and */
            /* update the message length                   */

            protocols_util_make_unique_name(save_object_browser->pending_data_load->data.data_load.leaf_name,
                                            sizeof(save_object_browser->pending_data_load->data.data_load.leaf_name));

            save_object_browser->pending_data_load->hdr.size = (int) WordAlign(strlen(save_object_browser->pending_data_load->data.data_load.leaf_name) + 45);

            /* Exit through the save routine */

            return save_save_object(save_object_browser->pending_data_load->data.data_load.leaf_name,
                                    save_object_browser);
          }

          /* Otherwise, save as normal */

          else
          {
            e = save_save_object(path, save_object_browser);
            if (!e) ok = 1;
          }
        }
      }
    }
    else if (m->hdr.your_ref == save_image_reference)
    {
      if (is_known_browser(save_image_browser))
      {
        if (!save_image_as_original)
        {
          /* Save as a sprite */

          e = image_export_sprite(path, save_image_browser, save_image_token);
          if (!e) ok = 1;
        }
        else
        {
          /* Save original image - similar to Save Object code. So, */
          /* if this is through scrap, use a different filename.    */

          if (m->data.data_save_ack.estimated_size == -1)
          {
            WimpMessage * pending;

            /* Need to store the Message_DataLoad for later */

            pending = malloc(sizeof(WimpMessage));
            if (!pending) return make_no_memory_error(13);

            #ifdef TRACE
              malloccount += sizeof(WimpMessage);
              dprintf(("CMal", "** malloccount (protocols_atats_got_data_save_ack): \0211%d\0217\n",malloccount));
            #endif

            *pending = *m;

            /* Change the filename to something unique and */
            /* update the message length                   */

            protocols_util_make_unique_name(pending->data.data_load.leaf_name,
                                            sizeof(pending->data.data_load.leaf_name));

            pending->hdr.size = (int) WordAlign(strlen(pending->data.data_load.leaf_name) + 45);

            /* Exit through the save routine */

            e = image_export_original(pending->data.data_load.leaf_name,
                                      save_image_browser,
                                      save_image_token);

            if (!e)
            {
              save_image_browser                    = last_browser;
              save_image_browser->pending_data_load = pending;
              ok                                    = 2;
            }
          }

          /* Otherwise, save as normal */

          else
          {
            e = image_export_original(path,
                                      save_image_browser,
                                      save_image_token);

            if (!e)
            {
              save_image_browser = last_browser;
              ok                 = 2;
            }
          }
        }
      }

    } /* Check for 'save_image_reference'         */
  }   /* Outer check for m->hdr.your_ref non-zero */

  /* If everything is OK, send out a Message_DataLoad in reply */

  if (ok && !e)
  {
    if (ok == 1) e = protocols_atats_send_data_load(m);

    /* Don't close the menu before sending the message, as if the item we are */
    /* sending to is within a menu tree, an Illegal Window Handle error may   */
    /* be raised.                                                             */

    _swix(Wimp_CreateMenu,
          _IN(1),

          -1);
  }

  /* Finished */

  return e;
}

/**************************************************************/
/* protocols_atats_send_data_load()                           */
/*                                                            */
/* Send out a Message_DataLoad in response to a               */
/* Message_DataSaveAck from another application, as part of   */
/* an ongoing dialogue for file transfer.                     */
/*                                                            */
/* See PRM 3-251 and 253.                                     */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             Message_DataSaveAck. The contents will be      */
/*             modified and used in the reply.                */
/**************************************************************/

_kernel_oserror * protocols_atats_send_data_load(WimpMessage * m)
{
  int old_ref = m->hdr.your_ref;
  int found   = 0;

  dprintf(("MsgP", "protocols_atats_send_data_load: Called\n"));

  /* Fill in the parts that need changing */

  m->hdr.your_ref    = m->hdr.my_ref;
  m->hdr.action_code = Wimp_MDataLoad;

  /* Find out the file size and type */

  RetError(_swix(OS_File,
                 _INR(0,1) | _OUT(0) | _OUT(4) | _OUT(6),

                 23, /* Read catalogue info for named, stamped object */
                 m->data.data_save_ack.leaf_name,

                 &found,
                 &m->data.data_load.estimated_size,
                 &m->data.data_load.file_type));

  if (found != 1 && found != 3)
  {
    /* Object not found - woo, weird (but it happens!) */

    #ifdef TRACE
      {
        erb.errnum = Utils_Error_Custom_Message;

        StrNCpy0(erb.errmess,
                 "Can't find the file I'm supposed to tell someone else to load in protocols_atats_send_data_load");

        show_error_ret(&erb);
      }
    #endif

    return NULL;
  }

  /* Send the reply */

  RetError(wimp_send_message(Wimp_EUserMessageRecorded,
                             m,
                             m->data.data_save_ack.destination_window,
                             m->data.data_save_ack.destination_icon,
                             NULL));

  /* Update the records of my_ref for subsequent replies and bounces */

  protocols_util_update_reference(old_ref, m->hdr.my_ref);

  /* Finished */

  return NULL;
}

/**************************************************************/
/* protocols_atats_data_load_bounced()                        */
/*                                                            */
/* Called if a Message_DataLoad bounces. Need to delete any   */
/* scrap files written and report an appropriate error.       */
/*                                                            */
/* See PRM 3-253, 254.                                        */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_atats_data_load_bounced(WimpMessage * m)
{
  int scrap_was_opened = 0;

  dprintf(("MsgP", "protocols_atats_data_load_bounced: Called\n"));

  /* Do we recognise this message? If so, deal with it, otherwise */
  /* ignore it (or raise a warning in TRACE builds).              */

  if (
       m->hdr.my_ref == save_source_reference              ||
       m->hdr.my_ref == save_as_text_reference             ||
       m->hdr.my_ref == save_as_draw_reference             ||
       m->hdr.my_ref == save_as_shelp_reference            ||
       m->hdr.my_ref == save_as_pdf_reference              ||
       m->hdr.my_ref == save_link_reference                ||
       m->hdr.my_ref == save_location_reference            ||
       m->hdr.my_ref == save_log_reference                 ||

       #ifndef REMOTE_HOTLIST

         m->hdr.my_ref == save_hotlist_entry_reference     ||
         m->hdr.my_ref == save_hotlist_selection_reference ||
         m->hdr.my_ref == save_entire_hotlist_reference    ||

       #endif

       m->hdr.my_ref == save_object_reference              ||
       m->hdr.my_ref == save_image_reference               ||
       m->hdr.my_ref == save_history_reference
     )
  {
    /* Not interested in any errors here - just get rid of scrap if we can */

    if (
         !strcmp(m->data.data_load.leaf_name,
                 Save_ScrapFile)
       )
    {
      /* Special case - if saving an object (Shift+Click on a link */
      /* or whatever) through scrap, so the send of a pending      */
      /* Message_DataLoad led to this bounce, don't delete the     */
      /* scrap file as it's the only copy of the data that we      */
      /* have. Instead, open the scrap directory. Otherwise, do as */
      /* PRM 3-254 and delete the scrap file.                      */

      if (!save_object_through_scrap) remove (m->data.data_load.leaf_name);
      else
      {
        char * combuf;
        int    comlen;
        char   new_name[Limits_OS_Pathname];

        save_object_through_scrap = 0;

        /* The first thing we need to do is change the filename away */
        /* from Scrap, or it could get overwritten when someone else */
        /* does a transfer.                                          */

        protocols_util_make_unique_name(new_name, sizeof(new_name));

        comlen = strlen("Rename ")                   +
                 strlen(m->data.data_load.leaf_name) +
                 1                                   + /* Space between the two names */
                 strlen(new_name)                    +
                 1;                                    /* Terminating byte */

        /* Allocate space for the Rename command; if it fails, fine */
        /* - just don't rename.                                     */

        combuf = malloc(comlen);

        if (combuf)
        {
          sprintf(combuf,
                  "%s%s%c%s",
                  "Rename ",
                  m->data.data_load.leaf_name,
                  ' ',
                  new_name);

          /* Execute the command */

          _swix(Wimp_StartTask,
                _IN(0),
                combuf);

          /* Free the buffer */

          free(combuf);
          combuf = NULL;
        }

        /* Try and allocate a buffer for the Filer_OpenDir command. */
        /* If this fails, let it do so silently.                    */

        comlen = strlen("Filer_OpenDir ") + strlen(Save_ScrapDir) + 1;
        combuf = malloc(comlen);

        if (combuf)
        {
          /* Copy in the command */

          strcpy(combuf, "Filer_OpenDir ");
          strcat(combuf, Save_ScrapDir);

          /* Execute it - if there was no error, flag that Scrap was opened */

          if (
               !_swix(Wimp_StartTask,
                      _IN(0),

                      combuf)
             )
             scrap_was_opened = 1;

          /* Free the temporary buffer */

          free(combuf);
        }
      }
    }

    /* Report an appropriate message */

    erb.errnum = Utils_Error_Custom_Message;


    if (!scrap_was_opened)
    {
      StrNCpy0(erb.errmess,
               lookup_token("RecvDied:Data transfer failed - receiver died.",
                            0,
                            0));
    }
    else
    {
      StrNCpy0(erb.errmess,
               lookup_token("RecvDiedKept:Data transfer failed - receiver died. The temporary file has been kept on disc so the fetched data can be recovered.",
                            0,
                            0));
    }

    return &erb;
  }

  #ifdef TRACE

    /* In TRACE builds, raise a warning if we don't recognise the message */

    else
    {
      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Message reference %x not recognised in protocols_atats_data_load_bounced",
              m->hdr.your_ref);

      return &erb;
    }

  #endif

  return NULL;
}

/**************************************************************/
/* protocols_atats_got_data_load_ack()                        */
/*                                                            */
/* Deals with a Message_DataLoadAck - completion of app to    */
/* app transfer from the browser.                             */
/*                                                            */
/* See PRM 3-250, 251, 254.                                   */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_atats_got_data_load_ack(WimpMessage * m)
{
  dprintf(("MsgP", "protocols_atats_got_data_load_ack: Called\n"));

  /* We have nothing to do here at present; this */
  /* is only here to be complete.                */

  return NULL;
}

/**************************************************************/
/* protocols_atats_send_any_pendings()                        */
/*                                                            */
/* Sends any pending messages related to the given browser,   */
/* in the context of application to application saving.       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the pending messages, if any.                  */
/**************************************************************/

_kernel_oserror * protocols_atats_send_any_pendings(browser_data * b)
{
  _kernel_oserror * e = NULL;

  if (!b || !is_known_browser(b)) return NULL;

  /* Pending Message_DataLoad - an object has been saved */
  /* through the fetcher to a temporary file.            */

  if (b->pending_data_load)
  {
    char * combuf;
    int    comlen;
    int    type;

    b->pending_data_load->hdr.my_ref = 0;

    /* Update the other state variables */

    save_object_reference     = b->pending_data_load->hdr.your_ref;
    save_object_transmitted   = 0;
    save_object_browser       = b;
    save_object_through_scrap = 1;

    /* Delete scrap if present, rename the file we've written to */
    /* ScrapFile, and alter the message back to using this       */
    /* filename.                                                 */

    remove(Save_ScrapFile);

    /* Does Scrap still exist? The above may have failed because */
    /* Save_ScrapFile was in use elsewhere. If so, then leave    */
    /* the filename as-is.                                       */

    type = 1;

    _swix(OS_File,
          _INR(0,1) | _OUT(0),

          17, /* Read catalogue info for object */
          Save_ScrapFile,

          &type);

    if (!type)
    {
      /* Allocate space for the buffer */

      comlen = strlen("Rename ")                                      +
               strlen(b->pending_data_load->data.data_load.leaf_name) +
               1                                                      + /* The space between the two names */
               strlen(Save_ScrapFile)                                 +
               1;                                                       /* Terminating byte */

      combuf = malloc(comlen);

      /* If we can't allocate space, as with the case of the scrap */
      /* file being undeletable, stick with the existing filename. */

      if (combuf)
      {
        /* We can allocate space, so build the command string. */

        sprintf(combuf,
                "%s%s%c%s",
                "Rename ",
                b->pending_data_load->data.data_load.leaf_name,
                ' ',
                Save_ScrapFile);

        /* Do it. If the command fails, use the original filename. */

        if (
             !_swix(Wimp_StartTask,
                    _IN(0),

                    combuf)
           )
        {
          /* The command worked, so change the message appropriately. */

          StrNCpy0(b->pending_data_load->data.data_load.leaf_name, Save_ScrapFile);

          b->pending_data_load->hdr.size = (int) WordAlign(strlen(Save_ScrapFile) + 45);
        }

        /* Free the command buffer */

        free(combuf);
      }
    }

    /* At last, send the message */

    e = protocols_atats_send_data_load(b->pending_data_load);

    /* We don't need the message block in the browser_data structure */
    /* any more, so free it.                                         */

    free(b->pending_data_load);
    b->pending_data_load = NULL;
  }

  return e;
}

/**************************************************************/
/* protocols_atatl_got_data_open()                            */
/*                                                            */
/* Handle reception of a Message_DataOpen - we may want to    */
/* load a given file. It is an application to application     */
/* related the consideration as we are transfering data from  */
/* the Filer, in a sense.                                     */
/*                                                            */
/* See PRM 3-265.                                             */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_atatl_got_data_open(WimpMessage * m)
{
  unsigned int type = m->data.data_open.file_type;

  dprintf(("MsgP", "protocols_atatl_got_data_open: Called\n"));

  /* Don't load it if we're the originator */

  if (m->hdr.sender == task_handle) return NULL;

  /* Don't want to load a text or data file from double-clicking, */
  /* only by dragging to a window or the icon bar icon. Similarly */
  /* ANT's URL files should only be loaded if dragged on, and the */
  /* same is true of URI files if we are using the URI handler.   */
  /* Since there is no native TIFF support, drop that out too. If */
  /* JavaScript is off, don't want to load those either...        */

  if (
       type == FileType_TEXT ||
       type == FileType_DATA ||
       type == FileType_DOS  || /* (Equivalent to FileType_DATA for PC files, so to speak) */
       type == FileType_TIFF ||
       type == FileType_URL  ||
       (
         type == FileType_URI &&
         uri_module_present
       )

       #ifndef JAVASCRIPT
         || type == FileType_JSS
       #endif
     )
     return NULL;

  /* Now treat as a DataLoad message to avoid duplicating load code. */

  m->data.data_load.destination_window = 0; /* Force a new window to open */
  m->data.data_load.destination_icon   = -1;
  m->data.data_load.estimated_size     = 0;

  dprintf(("MsgP", "protocols_atatl_got_data_open: Exitting through protocols_atatl_got_data_load\n"));

  return protocols_atatl_got_data_load(m);
}

/**************************************************************/
/* protocols_atatl_got_data_load()                            */
/*                                                            */
/* Deals with a Message_DataLoad - if we can handle the file, */
/* load it.                                                   */
/*                                                            */
/* See PRM 3-253.                                             */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_atatl_got_data_load(WimpMessage * m)
{
  ComponentId c;
  ObjectId    this;
  int         filetype = m->data.data_load.file_type;
  int         apptoapp = m->hdr.your_ref ? 1 : 0; /* your_ref is zero if from filer, else filled in for app to app */


  dprintf(("MsgP", "protocols_atatl_got_data_load: Called\n"));

  /* Was the URL writable targetted? In this case, if it was a text file, */
  /* assume it contained a URL - modify the Wimp Message block to contain */
  /* an ANT URL file filetype.                                            */

  RetError(window_wimp_to_toolbox(0,
                                  m->data.data_save.destination_window,
                                  m->data.data_save.destination_icon,
                                  &this,
                                  &c));

  if (c == URLBarWrit && filetype == FileType_TEXT) filetype = FileType_URL;

  /* If we've got a Data or DOS filetype, can we get anything */
  /* more from the filename?                                  */

  if (
       filetype == FileType_DATA ||
       filetype == FileType_DOS
     )
  {
    char * ext = strrchr(m->data.data_load.leaf_name, '/'); /* Since under RISC OS, filename extensions will start with '/' */

    if (ext)
    {
      ext++;

      if (mimemap_extension_to_riscos(ext, &filetype)) filetype = FileType_DATA;
    }
  }

  /* Proceed only if it's a filetype we can handle */

  if (
       filetype == FileType_HTML ||
       filetype == FileType_TEXT ||
       filetype == FileType_GIF  ||
       filetype == FileType_JPEG ||
       filetype == FileType_PNG  ||
       filetype == FileType_TIFF ||
       filetype == FileType_URL  ||
       filetype == FileType_URI

       #ifdef JAVASCRIPT
         || filetype == FileType_JSS
       #endif
     )
  {
    char url  [Limits_URL];
    char title[Limits_Title];
    int  handled = 0;

    dprintf(("MsgP", "protocols_atatl_got_data_load: Can handle this filetype (0x%03x)\n", filetype));

    /* Multiuser builds, if not logged in, just acknowledge */
    /* the message to stop (e.g.) another browser being     */
    /* launched by the Filer, then complain.                */

    #ifndef SINGLE_USER

      dprintf(("MsgP", "protocols_atatl_got_data_load: Not logged in\n"));

      if (!logged_in)
      {
        show_error_ret(protocols_atatl_send_data_load_ack(m));

        erb.errnum = Utils_Error_Custom_Message;

        StrNCpy0(erb.errmess,
                 lookup_token("MustLogIn:The browser cannot fetch Web pages until you log in.",
                              0,
                              0));

        show_error_ret(&erb);

        return NULL;
      }

    #endif

    /* Process the file */

    if (
         filetype != FileType_URI &&
         filetype != FileType_URL
       )
    {
      /* Not a URI or URL file, so text, HTML, image... */

      StrNCpy0(url, m->data.data_load.leaf_name);
      urlutils_pathname_to_url(url, sizeof(url));

      /* For text and HTML, we can use an internal URL scheme */
      /* to allow the fetcher to load the scrap file and then */
      /* remove it, as it should. For other types, the main   */
      /* fetcher modules must be used; so we can't get rid    */
      /* of the scrap file. If something else trashes it,     */
      /* tough.                                               */

      if (
           apptoapp &&
           (
             filetype == FileType_TEXT ||
             filetype == FileType_HTML

             #ifdef JAVASCRIPT
               || filetype == FileType_JSS
             #endif
           )
         )
      {
        StrNCpy0(url, Internal_URL ForScrapFile ":");

        /* Append the application suggested leafname */

        if (!data_save_suggested_leafname || !*data_save_suggested_leafname)
        {
          if (strlen(url) + 9 <= sizeof(url)) strcat(url, "HTMLfile");
        }
        else
        {
          if (strlen(url) + strlen(data_save_suggested_leafname) + 1 <= sizeof(url)) strcat(url, data_save_suggested_leafname);
        }

        /* Don't need a leafname record now */

        if (data_save_suggested_leafname)
        {
          free(data_save_suggested_leafname);
          data_save_suggested_leafname = NULL;
        }
      }
    }
    else
    {
      urlutils_load_uri_file(url,
                             sizeof(url),
                             title,
                             sizeof(title),
                             m->data.data_load.leaf_name);

      /* Delete scrap if used - we've finished with the */
      /* file now, certainly.                           */

      if (apptoapp) remove(m->data.data_load.leaf_name);
    }

    /* Take appropriate action */

    if (m->data.data_load.destination_window <= 0)
    {
      /* Load file to icon bar - i.e. open a new window. However, we */
      /* first do a quick check to see if this looks like a URL...   */
      /* If so, fetch the URL, not the file.                         */

      if (filetype == FileType_TEXT)
      {
        char   protocol[256];
        char * result;
        FILE * text = fopen(m->data.data_load.leaf_name, "rb");

        if (text)
        {
          /* fgets takes (str, n, stream) and reads n-1 bytes, so */
          /* pass 'sizeof(array)', not 'sizeof(array) - 1', as n. */

          result = fgets(protocol, sizeof(protocol), text);

          fclose(text);

          if (result && result == protocol) /* (After all, result *should* equal protocol, and it means we can use sizeof() in a moment) */
          {
            /* Just to be utterly paranoid about this... */

            protocol[sizeof(protocol) - 1] = '\0';

            /* Right, is there a protocol specifier at the very start */
            /* of this file which matches protocols we can handle?    */

            if (urlutils_check_protocols(protocol))
            {
              urlutils_load_uri_file(url,
                                     sizeof(url),
                                     title,
                                     sizeof(title),
                                     m->data.data_load.leaf_name);
            }
          }
        }
      }

      ChkError(windows_create_browser(url, NULL, NULL, NULL, Windows_CreateBrowser_Normal));

      handled = 1;
    }

    /* If we still haven't done anything with the file, see if the target */
    /* was the Open URL dialogue box.                                     */

    if (
         !handled      &&
         c == OpenWrit &&
         (
           filetype == FileType_URI  ||
           filetype == FileType_URL  ||
           filetype == FileType_TEXT
         )
       )
    {
      urlutils_load_uri_file(url,
                             sizeof(url),
                             title,
                             sizeof(title),
                             m->data.data_load.leaf_name);

      /* Ignore errors - most likely they'll be buffer overflow reports from the Toolbox */
      /* if the above URL is longer than can be fitted into the icon.                    */

      openurl_fill_in_url(url);

      handled = 1;
    }

    #ifndef REMOTE_HOTLIST

      if (!handled)
      {
        /* We allow two places for loading - a browser window (or bits of it), */
        /* and for URI / URL files, the hotlist window. Check the latter.      */

        if (
             filetype == FileType_URI ||
             filetype == FileType_URL
           )
        {
          /* If the target object ID  matches that of the hotlist, add the item. */

          if (this == hotlist_return_window_id())
          {
            char * leaf = NULL;

            /* If we have a title for the URL, use it, else try other methods... */

            if (!*title)
            {
              /* For the description, use the source leafname, unless this */
              /* is from another app (your_ref is non-zero), in which case */
              /* use the URL, as <Wimp$Scrap> isn't very friendly or       */
              /* unique.                                                   */

              if (!m->hdr.your_ref) leaf = strrchr(m->data.data_load.leaf_name, '.');

              if (!leaf) leaf = url;
              else       leaf ++;
            }

            ChkError(hotlist_add_position(m->data.data_load.destination_x,
                                          m->data.data_load.destination_y,
                                          *title ? title : leaf,
                                          url));

            handled = 1;
          }
        }

        /* We can also load HTML files, in a fashion, to the hotlist. */

        if (filetype == FileType_HTML)
        {
          ObjectId this;

          /* If we can get the window object ID... */

          if (
               !window_wimp_to_toolbox(0,
                                       m->data.data_load.destination_window,
                                       -1,
                                       &this,
                                       NULL)
             )
          {
            /* ...and it matches that of the hotlist, add the item. */

            if (this == hotlist_return_window_id())
            {
              char * path = m->data.data_load.leaf_name;

              ChkError(hotlist_add_html_file(m->data.data_load.destination_x,
                                             m->data.data_load.destination_y,
                                             path));

              handled = 1;
            }
          }
        }
      }

    #endif

    /* If still not handled yet, see if the target was a browser window */

    if (!handled)
    {
      browser_data * b = NULL;

      /* Otherwise, load file to a browser window. Need to find */
      /* its browser_data structure for this.                   */

      utils_browser_from_window(m->data.data_load.destination_window, &b);

      if (b && !b->small_fetch)
      {
        int dont_load_to_form = (filetype != FileType_TEXT);

        #ifdef JAVASCRIPT

          /* If this is a JavaScript URL, the script will end up    */
          /* being executed. Tell the JavaScript interface routines */
          /* that it came from the URL writable.                    */

          if (javascript_url(url))
          {
            dont_load_to_form = 1;
            javascript_set_source(JavaScript_Source_URLWritable);
          }

        #endif

        /* If flagged not to try, or trying to load the file into a */
        /* writeable forms item fails, do a conventional fetch.     */

        if (
             dont_load_to_form ||
             !form_could_load_text_at_pointer(b, m->data.data_load.leaf_name)
           )
        {
          ChkError(fetchpage_new(b, url, 1, 0, 0));
        }
        else
        {
          /* If the item was sent through Scrap, we should remove it */

          if (apptoapp) remove(m->data.data_load.leaf_name);
        }
      }
    }

    ChkError(protocols_atatl_send_data_load_ack(m));
  }

  return NULL;
}

/**************************************************************/
/* protocols_atatl_send_data_load_ack()                       */
/*                                                            */
/* In response to a Message_DataLoad, reply with a            */
/* Message_DataLoadAck.                                       */
/*                                                            */
/* See PRM 3-252 and 254.                                     */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_atatl_send_data_load_ack(WimpMessage * m)
{
  dprintf(("MsgP", "protocols_atatl_send_data_load_ack: Called\n"));

  m->hdr.your_ref    = m->hdr.my_ref;
  m->hdr.action_code = Wimp_MDataLoadAck;

  return wimp_send_message(Wimp_EUserMessage, m, m->hdr.sender, 0, NULL);
}

/**************************************************************/
/* protocols_atatl_got_data_save()                            */
/*                                                            */
/* Handle reception of a Message_DataSave - load data from    */
/* another application. Handles RAM transfer for some         */
/* filetypes.                                                 */
/*                                                            */
/* See PRM 3-252, 253, 255 and 256.                           */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_atatl_got_data_save(WimpMessage * m)
{
  _kernel_oserror * e        = NULL;
  int               filetype = m->data.data_save.file_type;
  int               ram      = 0;
  WimpMessage     * reply;
  ComponentId       c;

  dprintf(("MsgP", "protocols_atatl_got_data_save: Called\n"));

  /* Was the URL writable targetted? In this case, if it was a text file, */
  /* assume it contained a URL - modify the Wimp Message block to contain */
  /* an ANT URL file filetype. Do this for the Open URL dialogue box too. */

  RetError(window_wimp_to_toolbox(0,
                                  m->data.data_save.destination_window,
                                  m->data.data_save.destination_icon,
                                  NULL,
                                  &c));

  if ((c == URLBarWrit || c == OpenWrit) && filetype == FileType_TEXT) filetype = FileType_URL;

  /* Can we do RAM transfer for this file type? */

  if (
       filetype == FileType_URI ||
       filetype == FileType_URL
     )
     ram = 1;

  /* Can't do anything if <Wimp$Scrap> isn't defined and we want to */
  /* use it for file transfer. Note that the checking function will */
  /* raise an appropriate error in passing ('<Wimp$Scrap> not       */
  /* defined', for example).                                        */

  if (!ram && utils_check_scrap()) return NULL;

  /* Free any allocated data left over from previous calls */

  if (pending_data_save_ack)
  {
    dprintf(("MsgP", "protocols_atatl_got_data_save: Freeing old pending Acknowledge block\n"));

    free(pending_data_save_ack);
    pending_data_save_ack = NULL;
  }

  if (data_save_suggested_leafname)
  {
    dprintf(("MsgP", "protocols_atatl_got_data_save: Freeing old suggested leafname block\n"));

    free(data_save_suggested_leafname);
    data_save_suggested_leafname = NULL;
  }

  /* Record the leafname. Thus, when the Message_DataLoad comes along  */
  /* or the RAM transfer is finished, we can use this recorded leaf in */
  /* some meaningful place (such as the URL bar). Otherwise, we have   */
  /* no record (only e.g. '<Wimp$Scrap>' in a Message_DataLoad) and    */
  /* things get a bit more ugly at the front-end.                      */

  if (*m->data.data_save.leaf_name)
  {
    /* Allocate the block */

    data_save_suggested_leafname = malloc(strlen(m->data.data_save_ack.leaf_name) + 1);

    /* Do nothing if this should fail; assuming we managed  */
    /* to load the file, allow the load routines to default */
    /* down to a general alternative in the absence of this */
    /* record.                                              */

    if (data_save_suggested_leafname) strcpy(data_save_suggested_leafname, m->data.data_save_ack.leaf_name);
  }

  /* Deal with RAM transfer - send out a RAMFetch. If this */
  /* bounces, we'll need to drop back to scrap files.      */

  if (ram)
  {
    /* First, we may need to use file transfer so fill in */
    /* a pending DataSaveAck block for later use.         */

    pending_data_save_ack = malloc(sizeof(WimpMessage));

    if (!pending_data_save_ack) return make_no_memory_error(11);

    dprintf(("MsgP", "protocols_atatl_got_data_save: Allocated new pending Acknowledge block\n"));

    reply = pending_data_save_ack;
  }
  else
  {
    /* Otherwise, just point back to the existing message and modify */
    /* its contents for a reply in the normal fashion.               */

    reply = m;
  }

  /* Fill it in */

  *reply = *m;

  reply->hdr.your_ref    = m->hdr.my_ref;
  reply->hdr.action_code = Wimp_MDataSaveAck;

  reply->data.data_save_ack.estimated_size = -1;

  /* Write the filename for Scrap to the message block */
  /* and update the size field in the header.          */

  StrNCpy0(reply->data.data_save_ack.leaf_name, Save_ScrapFile);

  reply->hdr.size = (int) WordAlign(strlen(Save_ScrapFile) + 45); /* (44 for stuff up to the pathname, plus 1 for terminator) */

  /* For RAM transfer, send a Message_RAMFetch */

  if (ram)
  {
    WimpMessage * raf = m;

    /* Free any existing RAM transfer buffer and allocate a new one */

    if (rtb) free(rtb);
    rtb = malloc(RTB_Size);

    /* If the allocation fails, drop through to a scrap file method */

    if (rtb)
    {
      /* Fill in the message details */

      #ifdef TRACE
        malloccount += RTB_Size;
        dprintf(("CMal", "** malloccount (protocols_atatl_got_data_save): \0211%d\0217\n",malloccount));
      #endif

      raf->hdr.size                   = 28;
      raf->hdr.your_ref               = m->hdr.my_ref;
      raf->hdr.action_code            = Wimp_MRAMFetch;

      raf->data.ram_fetch.buffer      = rtb;
      raf->data.ram_fetch.buffer_size = RTB_Size;

      /* Send it */

      dprintf(("MsgP", "protocols_atatl_got_data_save: Sending Message_RAMFetch in response\n"));

      RetError(wimp_send_message(Wimp_EUserMessageRecorded,
                                 raf,
                                 m->hdr.sender,
                                 0,
                                 NULL));

      /* Remember my_ref in case it bounces */

      ram_fetch_reference = raf->hdr.my_ref;

      /* Flag that we've not started transfer of actual data yet */

      ram_load_started = 0;
    }
    else ram = 0; /* So that the Message_DataSaveAck goes out instead */
  }

  /* Otherwise send a Message_DataSaveAck reply */

  if (!ram) /* Must use this as the RAM transfer code will set 'ram' to 0 if it can't claim a transfer buffer */
  {
    RetError(wimp_send_message(Wimp_EUserMessage, /* Not interested in it bouncing */
                               reply,
                               m->hdr.sender,
                               0,
                               NULL));
  }

  return e;
}

/**************************************************************/
/* protocols_atatl_ram_fetch_bounced()                        */
/*                                                            */
/* Following getting a Message_DataSave,                      */
/* protocols_atatl_got_data_save may send out a               */
/* Message_RAMFetch. If this bounces, this function is        */
/* called. If the bounce is indeed due to the RAMFetch we     */
/* sent, then send out a Message_DataSaveAck instead, to try  */
/* and use scrap file transfer. This is stored in the         */
/* 'pending' block by the same function that sends the        */
/* Message_RAMFetch.                                          */
/*                                                            */
/* Alternatively, a Message_RAMFetch being sent in reply to a */
/* Message_RAMTransmit *during* RAM transfer could bounce,    */
/* and this function would be called. In that case, we should */
/* abort data transfer. The other end is meant to raise an    */
/* error (which is odd, since it seems likely that it will    */
/* have died - since it's sending, the changes of running out */
/* of memory at that end are slim).                           */
/*                                                            */
/* See PRM 3-255.                                             */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_atatl_ram_fetch_bounced(WimpMessage * m)
{
  dprintf(("MsgP", "protocols_atatl_ram_fetch_bounced: Called\n"));

  if (m->hdr.my_ref == ram_fetch_reference)
  {
    if (!ram_load_started && pending_data_save_ack)
    {
      /* The bounce is from the first Message_RAMFetch, so try using */
      /* scrap file transfer instead.                                */

      _kernel_oserror * e;

      dprintf(("MsgP", "protocols_atatl_ram_fetch_bounced: Recognised bounce for a new transfer - using Scrap instead\n"));

      /* Before doing this, make sure Scrap is present - the call */
      /* will raise an error if not, before returning here        */

      if (utils_check_scrap()) return NULL;

      /* Send the pending message */

      e = wimp_send_message(Wimp_EUserMessage,
                            pending_data_save_ack,
                            pending_data_save_ack->hdr.sender,
                            0,
                            NULL);

      /* Free the block and return any error that may have been generated */

      free(pending_data_save_ack);
      pending_data_save_ack = NULL;

      return e;
    }
    else
    {
      dprintf(("MsgP", "protocols_atatl_ram_fetch_bounced: Recognised bounce for an ongoing transfer - aborting\n"));

      /* The bounce is from an ongoing RAM transfer, so abort that */
      /* transfer - free any in-use buffers.                       */

      if (ram_load_uri_buffer)
      {
        free(ram_load_uri_buffer);
        ram_load_uri_buffer = NULL;

        #ifdef TRACE
          malloccount -= ram_load_buffer_size;
          dprintf(("CMal", "** malloccount (protocols_atatl_ram_fetch_bounced): \0212%d\0217\n",malloccount));
        #endif
      }

      ram_load_buffer_size = 0;

      if (rtb)
      {
        free(rtb);
        rtb = NULL;

        #ifdef TRACE
          malloccount -= RTB_Size;
          dprintf(("CMal", "** malloccount (protocols_atatl_ram_fetch_bounced): \0212%d\0217\n",malloccount));
        #endif
      }

      /* Free the pending Message_DataSaveAck block, if present */

      if (pending_data_save_ack)
      {
        free(pending_data_save_ack);
        pending_data_save_ack = 0;
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* protocols_atatl_got_ram_transmit()                         */
/*                                                            */
/* Deals with a Message_RAMTransmit - we have some data in    */
/* the 'rtb' buffer.                                          */
/*                                                            */
/* See PRM 3-255, 256.                                        */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_atatl_got_ram_transmit(WimpMessage * m)
{
  _kernel_oserror * e        = NULL;
  int               ok       = 1;
  int               finished = 0;

  dprintf(("MsgP", "protocols_atatl_got_ram_transmit: Called with %d bytes to receive\n", m->data.ram_transmit.nbytes));

  /* Flag that transfer is in progress */

  ram_load_started = 1;

  /* Flag if we've finished, too */

  if (m->data.ram_transmit.nbytes < RTB_Size) finished = 1;
  else if (m->data.ram_transmit.nbytes > RTB_Size) m->data.ram_transmit.nbytes = RTB_Size; /* You *never* know...! */

  /* We should know where the buffer is */

  #ifdef TRACE

    if (m->data.ram_transmit.buffer != rtb)
    {
      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Expected to get buffer %p but got %p instead, in protocols_atatl_got_ram_transmit",
              rtb,
              m->data.ram_transmit.buffer);

      e  = &erb;
      ok = 0;
    }

  #else

    if (m->data.ram_transmit.buffer != rtb) ok = 0;

  #endif

  /* The action here depends on the type of file being transferred; */
  /* we know from here on in that the 'rtb' buffer is the buffer    */
  /* that has been filled in (see above), so we can use this rather */
  /* than the more cumbersome 'm->data.ram_transmit.buffer'.        */

  if (ok && pending_data_save_ack)
  {
    ComponentId c;
    ObjectId    this;
    int         filetype = pending_data_save_ack->data.data_save_ack.file_type;

    /* Was this dragged to a URL writable, and thus should be */
    /* treated as an ANT URL file (if text)?                  */

    RetError(window_wimp_to_toolbox(0,
                                    pending_data_save_ack->data.data_save_ack.destination_window,
                                    pending_data_save_ack->data.data_save_ack.destination_icon,
                                    &this,
                                    &c));

    if ((c == URLBarWrit || c == OpenWrit) && filetype == FileType_TEXT) filetype = FileType_URL;

    switch (filetype)
    {
      /* For URI / URL files, copy data from the file transfer */
      /* buffer (which may deliver the file in several small   */
      /* chunks) to a cumulative file buffer, and then process */
      /* that whole thing when finished.                       */

      case FileType_URL: /* Same as for URI files, so no 'break' */
      case FileType_URI:
      {
        int first = 0;

        /* Only proceed with transfer if there are some bytes to get  */
        /* (otherwise, this was the last message with the final chunk */
        /* of data having exactly filled the buffer last time - so    */
        /* act upon the buffer contents now, without trying to        */
        /* transfer zero bytes first).                                */

        if (m->data.ram_transmit.nbytes)
        {
          /* Allocate or extend the local buffer to take in the URI file */

          if (!ram_load_uri_buffer)
          {
            /* Note we allocate 1 byte more than needed to allow a terminator to */
            /* be inserted after the URL string when the transfer has ended;     */
            /* this is because a URI file may end simply by EOF, it does not     */
            /* need a terminator (and in any case, that terminator may be a      */
            /* control char such as ASCII 10 or 13, which C would not treat as a */
            /* string terminator).                                               */

            ram_load_uri_buffer = malloc(m->data.ram_transmit.nbytes + 1);
            first               = 1;

            /* Complain if the allocation fails */

            if (!ram_load_uri_buffer)
            {
              e = make_no_memory_error(7);

              ok = 0;
            }

            #ifdef TRACE

              else
              {
                malloccount += m->data.ram_transmit.nbytes + 1;
                dprintf(("CMal", "** malloccount (protocols_atatl_got_ram_transmit): \0211%d\0217\n",malloccount));
              }

            #endif
          }
          else
          {
            void * local;

            /* realloc to a new size */

            local = realloc(ram_load_uri_buffer, ram_load_buffer_size + m->data.ram_transmit.nbytes);

            if (!local)
            {
              /* If the allocation fails, free the whole thing */

              free(ram_load_uri_buffer);
              ram_load_uri_buffer = NULL;

              #ifdef TRACE
                malloccount -= ram_load_buffer_size;
                dprintf(("CMal", "** malloccount (protocols_atatl_got_ram_transmit): \0212%d\0217\n",malloccount));
              #endif

              ram_load_buffer_size = 0;

              e = make_no_memory_error(7);

              ok = 0;
            }

            /* Otherwise record a possibly new buffer address */

            else
            {
              ram_load_uri_buffer = local;

              #ifdef TRACE
                malloccount += m->data.ram_transmit.nbytes;
                dprintf(("CMal", "** malloccount (protocols_atatl_got_ram_transmit): \0211%d\0217\n",malloccount));
              #endif
            }
          }

          if (ok)
          {
            /* Copy the data from the file transfer buffer into */
            /* the cumulative URI file buffer                   */

            memcpy(ram_load_uri_buffer + ram_load_buffer_size - !first,
                   rtb,
                   m->data.ram_transmit.nbytes);

            /* Increment the buffer size counter, remembering to add 1 if this */
            /* is the first time we've allocated data, to allow room for a     */
            /* string terminator when the transfer finishes.                   */

            ram_load_buffer_size += m->data.ram_transmit.nbytes + !!first;

            /* If tracing the process of the transfer, show the buffer contents */
            /* (but don't bother showing the uninitialised last byte).          */

            #ifdef TRACE
              if (tl & (1u<<28)) trace_dump_buffer(ram_load_uri_buffer,
                                                   ram_load_buffer_size - 1,
                                                   2);
            #endif
          }
        }

        /* If the transfer has finished, fetch the URL */

        if (finished)
        {
          int handled = 0;

          /* Remember we allocated 1 byte more than needed at the start, */
          /* so that this terminator could be inserted. This is required */
          /* for URL files, and won't hurt for URI files.                */

          ram_load_uri_buffer[ram_load_buffer_size - 1] = 0;

          /* This is capable of dealing with URI or URL files */

          urlutils_extract_uri(ram_load_uri_buffer, ram_load_buffer_size);

          if (pending_data_save_ack->data.data_save_ack.destination_window <= 0)
          {
            /* The original Message_DataSave was for no specific window */

            e = windows_create_browser(ram_load_uri_buffer, NULL, NULL, NULL, Windows_CreateBrowser_Normal);

            handled = 1;
          }

          /* Was this for the Open URL dialogue? */

          if (!handled && c == OpenWrit)
          {
            openurl_fill_in_url(ram_load_uri_buffer);
            handled = 1;
          }

          #ifndef REMOTE_HOTLIST

            if (!handled)
            {
              /* If the object ID of the window dragged to matches that of the hotlist, add the item. */

              if (this == hotlist_return_window_id())
              {
                /* Use the title, if we have one */

                if (*(ram_load_uri_buffer + strlen(ram_load_uri_buffer) + 1))
                {
                  ChkError(hotlist_add_position(pending_data_save_ack->data.data_save_ack.destination_x,
                                                pending_data_save_ack->data.data_save_ack.destination_y,
                                                ram_load_uri_buffer + strlen(ram_load_uri_buffer) + 1,
                                                ram_load_uri_buffer));
                }
                else
                {
                  ChkError(hotlist_add_position(pending_data_save_ack->data.data_save_ack.destination_x,
                                                pending_data_save_ack->data.data_save_ack.destination_y,
                                                ram_load_uri_buffer,
                                                ram_load_uri_buffer));
                }

                handled = 1;
              }
            }

          #endif

          /* Still not handled? Try a browser window. */

          if (!handled)
          {
            browser_data * b;

            /* The message was for a specific window, so find out which one */

            utils_browser_from_window(pending_data_save_ack->data.data_save_ack.destination_window, &b);

            if (b && !b->small_fetch)
            {
              #ifdef JAVASCRIPT

                /* If this is a JavaScript URL, the script will end up    */
                /* being executed. Tell the JavaScript interface routines */
                /* that it came from the URL writable.                    */

                if (javascript_url(ram_load_uri_buffer)) javascript_set_source(JavaScript_Source_URLWritable);

              #endif

              e = fetchpage_new(b, ram_load_uri_buffer, 1, 0, 0);
            }
          }

          free (ram_load_uri_buffer);
          ram_load_uri_buffer = NULL;

          #ifdef TRACE
            malloccount -= ram_load_buffer_size;
            dprintf(("CMal", "** malloccount (protocols_atatl_got_ram_transmit): \0212%d\0217\n",malloccount));
          #endif

          ram_load_buffer_size = 0;

          if (!e) ok = 0;
        }
      }
      break;

      default:
      {
        /* If we don't recognise the filetype, something is very wrong... */

        #ifdef TRACE

          erb.errnum = Utils_Error_Custom_Normal;
          sprintf(erb.errmess,
                  "Unrecognised filetype 0x%03x (%x) in protocols_atatl_got_ram_transmit",
                  pending_data_save_ack->data.data_save_ack.file_type,
                  pending_data_save_ack->data.data_save_ack.file_type);

          e  = &erb;
          ok = 0;

        #else

          ok = 0;

        #endif
      }
      break;
    }
  }

  if (ok && !finished)
  {
    /* If things are OK still, send a RAMFetch to get the  */
    /* next chunk, provided that there is more to get.     */
    /*                                                     */
    /* If things are not OK, no reply is given, thereby    */
    /* abandoning the transfer (PRM 3-256).                */

    WimpMessage * raf = m;

    raf->hdr.size        = 28;
    raf->hdr.your_ref    = m->hdr.my_ref;
    raf->hdr.action_code = Wimp_MRAMFetch;

    dprintf(("MsgP", "protocols_atatl_got_ram_transmit: Sending RAMFetch in reply\n"));

    e = wimp_send_message(Wimp_EUserMessageRecorded,
                          raf,
                          m->hdr.sender,
                          0,
                          NULL);

    ram_fetch_reference = m->hdr.my_ref;
  }

  /* Either we've finished or there was an error higher up */

  if (finished || !ok)
  {
    /* Free the RAM transfer buffer, if required. */

    if (rtb) free(rtb);
    rtb = NULL;

    #ifdef TRACE
      malloccount -= RTB_Size;
      dprintf(("CMal", "** malloccount (protocols_atatl_got_ram_transmit): \0212%d\0217\n",malloccount));
    #endif

    /* Free any pending Message_DataSaveAck */

    if (pending_data_save_ack)
    {
      dprintf(("MsgP", "protocols_atatl_got_ram_transmit: Freeing old pending Acknowledge block\n"));

      free(pending_data_save_ack);
      pending_data_save_ack = NULL;
    }
  }

  return e;
}

/**************************************************************/
/* protocols_pp_send_print_save()                             */
/*                                                            */
/* First stage of the Print Protocol - broadcast a            */
/* Message_PrintSave.                                         */
/*                                                            */
/* See PRM 3-259, 262.                                        */
/**************************************************************/

_kernel_oserror * protocols_pp_send_print_save(void)
{
  WimpMessage m;

  /* Fill in the header */

  m.hdr.your_ref    = 0;
  m.hdr.action_code = Browser_Message_PrintSave;

  /* Fill in the body */

  m.data.data_save.destination_window = 0;
  m.data.data_save.destination_icon   = 0;
  m.data.data_save.destination_x      = 0;
  m.data.data_save.destination_y      = 0;
  m.data.data_save.estimated_size     = 4096;
  m.data.data_save.file_type          = FileType_POUT;

  StrNCpy0(m.data.data_save.leaf_name,
           lookup_token("PrintName:WebPage",0,0));

  /* Work out the message size */

  m.hdr.size = (strlen(m.data.data_save.leaf_name) + 44);
  if (m.hdr.size & 3) m.hdr.size = (m.hdr.size & ~3) + 4;

  /* Send the message */

  RetError(wimp_send_message(Wimp_EUserMessageRecorded,
                             &m,
                             0,
                             0,
                             NULL));

  /* A Message_DataSaveAck returns, so to distinguish this from */
  /* any other Message_DataSaveAck, remember my_ref and check   */
  /* it against the returned your_ref in future.                */

  print_save_reference = m.hdr.my_ref;

  return NULL;
}

/**************************************************************/
/* protocols_pp_print_save_bounced()                          */
/*                                                            */
/* If a Message_PrintSave bounces, the browser tried to use   */
/* the printer protocol to do a print job but the printer     */
/* wasn't loaded. In that case, print directly to the         */
/* 'printer:' device.                                         */
/*                                                            */
/* See PRM 3-259 for details of where this fits into the      */
/* protocol, or 3-262 for the message structure.              */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_pp_print_save_bounced(WimpMessage * m)
{
  if (m->hdr.my_ref && m->hdr.my_ref == print_save_reference)
  {
    print_save_reference = 0;

    /* Go for it. */

    print_print(NULL);
  }

  #ifdef TRACE

    else
    {
      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Message reference %x not recognised in protocols_pp_print_save_bounced",
              m->hdr.your_ref);

      return &erb;
    }

  #endif

  return NULL;
}

/**************************************************************/
/* protocols_pp_got_print_error()                             */
/*                                                            */
/* Handle reception of a Message_PrintError - report an error */
/* from the printer driver.                                   */
/*                                                            */
/* See PRM 3-262.                                             */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_pp_got_print_error(WimpMessage * m)
{
  if (m->hdr.size == 20)
  {
    /* RISC OS 2 printer manager's PrintBusy response */

    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("PrintBusy:The printer is currently busy.",
                          0,
                          0));

    show_error_ret(&erb);
  }

  /* RISC OS 3 !Printers-generated specific error response */

  else show_error_ret((_kernel_oserror *) &m->data);

  return NULL;
}

/**************************************************************/
/* protocols_pp_got_data_save_ack()                           */
/*                                                            */
/* Handle reception of a Message_DataSaveAck where the        */
/* your_ref field shows that it has been sent in relation to  */
/* a print job. Only call in those circumstances...           */
/*                                                            */
/* See PRM 3-259 / 3-260 for details of where this fits into  */
/* the protocol, or PRM 3-253 for details on the message      */
/* structure.                                                 */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

static _kernel_oserror * protocols_pp_got_data_save_ack(WimpMessage * m)
{
  _kernel_oserror * e;
  WimpMessage     * dl = m;
  int               file_size;

  dprintf(("MsgP", "protocols_pp_got_data_save_ack: Called\n"));

  /* Print to a file in the !Printers-given file, then send */
  /* a DataLoad to the printer manager to tell it to put    */
  /* the file into the print queue.                         */

  print_save_reference = 0;

  print_print(m->data.data_save.leaf_name);

  e = _swix(OS_File,
        _INR(0,1) | _OUT(4),

        23, /* Read catalogue info */
        m->data.data_save.leaf_name,

        &file_size);

  if (e) return e;

  dl->hdr.size        = 64;
  dl->hdr.your_ref    = m->hdr.my_ref;
  dl->hdr.action_code = Wimp_MDataLoad;

  dl->data.data_load.estimated_size = file_size;
  dl->data.data_load.file_type      = FileType_POUT;

  e = _swix(OS_File,
            _INR(0,2),

            18, /* Set filetype of named object */
            m->data.data_save_ack.leaf_name,
            FileType_POUT);

  strcpy(dl->data.data_load.leaf_name, m->data.data_save_ack.leaf_name);

  /* Send the DataLoad - a UserMessage, not UserMessageRecorded, */
  /* so it can't bounce back.                                    */

  dprintf(("MsgP", "protocols_pp_got_data_save_ack: Sending Message_DataLoad in response\n"));

  return wimp_send_message(Wimp_EUserMessage,
                           dl,
                           m->hdr.sender,
                           0,
                           NULL);
}

/**************************************************************/
/* protocols_pp_got_print_type_odd()                          */
/*                                                            */
/* Handle reception of a Message_PrintTypeOdd.                */
/*                                                            */
/* If this is sent directly to the task, we can print         */
/* immediately to 'printer:'.                                 */
/*                                                            */
/* The use of an Alias$PrintType_FF4 system variable makes it */
/* unnecessary to deal with the case of a broadcast           */
/* PrintTypeOdd. This happens when a queued PrintOut file     */
/* that the browser has been asked to print rises to the top  */
/* of !Printers' queue. Bizarrely, !Printers doesn't          */
/* recognise the filetype and raises the message. We allow    */
/* this to fall back to the system variable, which copies the */
/* PrintOut file to the 'printer:' device.                    */
/*                                                            */
/* This is a hole in an otherwise workable, if cumbersome,    */
/* protocol.                                                  */
/*                                                            */
/* See PRM 3-263.                                             */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_pp_got_print_type_odd(WimpMessage * m)
{
  WimpMessage * ptk = m;

  if (m->hdr.your_ref && m->hdr.your_ref == print_save_reference)
  {
    /* The printer manager sent PrintTypeOdd as a reply to this */
    /* task (not a broadcast), so go ahead and print.           */

    print_save_reference = 0;

    /* Send PrintTypeKnown */

    ptk->hdr.size        = 20;
    ptk->hdr.your_ref    = m->hdr.my_ref;
    ptk->hdr.action_code = Browser_Message_PrintTypeKnown;

    RetError(wimp_send_message(Wimp_EUserMessage,
                               ptk,
                               m->hdr.sender,
                               0,
                               NULL));

    print_print(NULL);
  }

  #ifdef TRACE

    else if (m->hdr.your_ref)
    {
      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Message reference %x unrecognised in protocols_pp_got_print_type_odd",
              m->hdr.your_ref);

      return &erb;
    }

  #endif

// Commented out as the Alias$@@PrintType_FF4 system variable does this job
// anyway, and if we don't claim this message then anything else which may
// have a better idea of what to do at least gets a chance to try.
//
// This currently doesn't work, incidentally; the conditions on the 'if'
// are wrong (print_save_ref has probably been set to 0, but I never
// got the chance to properly debug this before removing it due to time
// constraints...).
//
//   else if (print_save_ref && m->data.data_save.file_type == FileType_POUT)
//   {
//     /* If the printer doesn't understand PrintOut files, then */
//     /* it may be broken (!) / PostScript. So reply, and copy  */
//     /* the file to the printer device directly.               */
//
//     print_save_ref = 0;
//
//     ptk->hdr.size        = 20;
//     ptk->hdr.your_ref    = m->hdr.my_ref;
//     ptk->hdr.action_code = Browser_Message_PrintTypeKnown;
//
//     ChkError(wimp_send_message(Wimp_EUserMessage, ptk, m->hdr.sender, 0, NULL));
//
//     _swix(OS_FSControl,
//           _INR(0,3),
//
//           26,
//           m->data.data_save.leaf_name,
//           "printer:",
//           2); /* Flags - 'Force' set, but no others. */
//   }

  return NULL;
}

/**************************************************************/
/* protocols_auh_got_started()                                */
/*                                                            */
/* Handle reception of a URI_MStarted - the URI handler has   */
/* starting up.                                               */
/*                                                            */
/* See 1307,260/FS.                                           */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_auh_got_started(WimpMessage * m)
{
  int version;

  /* Flag that the module is now available, provided the */
  /* version number is late enough.                      */

  if (uri_version(0, &version)) uri_module_present = 0;
  else if (version >= 5)        uri_module_present = 1;

  return NULL;
}

/**************************************************************/
/* protocols_auh_got_dying()                                  */
/*                                                            */
/* Handle reception of a URI_MDying - the URI handler is      */
/* closing down.                                              */
/*                                                            */
/* See 1307,260/FS.                                           */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_auh_got_dying(WimpMessage * m)
{
  /* If the URI handler is dying, don't try and use it anymore... */

  uri_module_present = 0;

  return NULL;
}

/**************************************************************/
/* protocols_auh_got_process()                                */
/*                                                            */
/* Handle reception of a URI_MProcess - process a URI from    */
/* the URI handler, replying if we can handle the URI.        */
/*                                                            */
/* See 1307,260/FS.                                           */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_auh_got_process(WimpMessage * m)
{
  URIProcessURIMessage * uri    = (URIProcessURIMessage *) &m->data;
  int                    ok;
  unsigned int           sender = m->hdr.sender;

  /* Should we deal with this message? */

  if (
       choices.uri_usage == Choices_URI_Never             ||
       choices.uri_usage == Choices_URI_BroadcastUnknowns
     )
     return NULL;

  /* Can we handle this URI? */

  ok = urlutils_check_protocols(uri->uri);

  dprintf(("URIH", "protocols_auh_got_process: URI_MProcess '%s', ok = %d\n",uri->uri,ok));

  /* If so, reply to the message and possibly start a fetch */

  if (ok)
  {
    #ifndef SINGLE_USER

      if (logged_in)
      {

    #endif

    /* Only fetch if the flags bits don't say we're to just */
    /* check the URI could be handled.                      */

    if (!uri->flags.bits.check)
    {
      uri_queue * entry = urlutils_find_queue_entry(uri->uri_handle);

      if (entry)
      {
        #ifdef JAVASCRIPT

          /* If this is a JavaScript URL, the script will end up    */
          /* being executed. Tell the JavaScript interface routines */
          /* that it came from the URL writable.                    */

          if (javascript_url(uri->uri)) javascript_set_source(JavaScript_Source_URLWritable);

        #endif

        RetError(fetchpage_postprocess_uri(entry->b,
                                           uri  ->uri,
                                           entry->flags & URIQueue_RecordInHistory ? 1 : 0));

        /* Don't remove it from the queue of uri_queue structures yet - */
        /* wait for the ReturnResult message for that.                  */
      }

      else RetError(windows_create_browser(uri->uri, NULL, NULL, NULL, Windows_CreateBrowser_Normal));
    }

    #ifndef SINGLE_USER

      }
      else
      {
        erb.errnum = Utils_Error_Custom_Message;

        StrNCpy0(erb.errmess,
                 lookup_token("MustLogIn:The browser cannot fetch Web pages until you log in.",
                              0,
                              0));

        show_error_ret(&erb);
      }

    #endif

    /* Now reply, saying that we've handled the message */

    m->hdr.sender      = task_handle;
    m->hdr.your_ref    = m->hdr.my_ref;
    m->hdr.action_code = URI_MProcessAck;

    RetError(wimp_send_message(Wimp_EUserMessage,
                               m,
                               sender,
                               0,
                               NULL));
  }

  return NULL;
}

/**************************************************************/
/* protocols_auh_got_return_result()                          */
/*                                                            */
/* Handle reception of a URI_MReturnResult - the URI handler  */
/* is reporting what happened to a URI we dispatched through  */
/* it.                                                        */
/*                                                            */
/* See 1307,260/FS.                                           */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_auh_got_return_result(WimpMessage * m)
{
  URIReturnResultMessage * uri = (URIReturnResultMessage *) &m->data;

  dprintf(("URIH", "protocols_auh_got_return_result: URI_MReturnResult, not_claimed = %d\n",uri->flags.bits.not_claimed));

  /* Remove the entry from the queue */

  RetError(urlutils_remove_from_queue(uri->uri_handle));

  /* If the URI was not claimed by anyone, give an appropriate error */

  if (uri->flags.bits.not_claimed)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("CannotFetch:The browser does not have a method of fetching the requested site.",
                          0,0));

    show_error_ret(&erb);
  }

  return NULL;
}

/**************************************************************/
/* protocols_ih_send_help_request()                           */
/*                                                            */
/* Sends out HelpRequest messages for the item the mouse      */
/* pointer is currently over, every 20 centiseconds or so.    */
/*                                                            */
/* Parameters are as standard for a Wimp NULL event handler.  */
/**************************************************************/

int protocols_ih_send_help_request(int eventcode, WimpPollBlock * block, IdBlock * idb, void * handle)
{
  int        time_now;
  static int last_time   = 0;
  static int last_window = 0;
  static int last_icon   = 0;

  /* Only proceed if the Controls say to do so */

  if (controls.claim_help)
  {
    /* Don't sent out requests too often */

    _swix(OS_ReadMonotonicTime, _OUT(0), &time_now);

    if (time_now - last_time > 20)
    {
      WimpGetPointerInfoBlock i;
      WimpMessage             m;

      last_time = time_now;

      ChkError(wimp_get_pointer_info(&i));

      /* Don't send a request if the pointer isn't over a */
      /* browser-owned window.                            */

      if (task_handle == utils_task_from_window(i.window_handle))
      {
        /* Don't send out multiple requests for the same window/icon. */

        if (i.icon_handle != last_icon || i.window_handle != last_window)
        {
          last_icon   = i.icon_handle;
          last_window = i.window_handle;
        }
        else return 0;

        /* Build the message block and send the request */

        m.hdr.size        = 40;
        m.hdr.sender      = task_handle;
        m.hdr.my_ref      = 0;
        m.hdr.your_ref    = 0;
        m.hdr.action_code = Wimp_MHelpRequest;

        m.data.help_request.mouse_x       = i.x;
        m.data.help_request.mouse_y       = i.y;
        m.data.help_request.buttons       = i.button_state;
        m.data.help_request.window_handle = i.window_handle;
        m.data.help_request.icon_handle   = i.icon_handle;

        ChkError(wimp_send_message(Wimp_EUserMessageRecorded,
                                   &m,
                                   i.window_handle,
                                   i.icon_handle,
                                   NULL));
      }
    }
  }

  return 0;
}

/**************************************************************/
/* protocols_ih_help_request_bounced()                        */
/*                                                            */
/* If a Message_HelpRequest comes in as a                     */
/* UserMessage_Acknowledge, then the browser tried to send    */
/* out such a message and it bounced - there is no help on    */
/* that item. In this case, if we're displaing help items in  */
/* the status bar, return to a non-help status string.        */
/*                                                            */
/* See PRM 3-244 for details of the message or                */
/* protocols_ih_send_help_request for the message origin.     */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_ih_help_request_bounced(WimpMessage * m)
{
  if (controls.claim_help)
  {
    WimpGetPointerInfoBlock   i;
    browser_data            * b = NULL;
    ObjectId                  o, a = -1;

    RetError(wimp_get_pointer_info(&i));
    RetError(window_wimp_to_toolbox(0, i.window_handle, i.icon_handle, &o, NULL));

    /* If we can get an ancestor, the pointer is over e.g. a toolbar */
    /* - otherwise, assume it is over a browser window.              */

    toolbox_get_ancestor(0, o, &a, NULL);

    if (a)
    {
      toolbox_get_client_handle(0, a, (void *) &b);
    }
    else toolbox_get_client_handle(0, o, (void *) &b);

    /* If we haven't got a valid client handle, exit */

    if (!is_known_browser(b)) return NULL;

    /* Update the status line */

    if (b->status_help != NULL)
    {
      b->status_help = NULL;
      RetError(toolbars_cancel_status(b, Toolbars_Status_Help));
    }
  }

  return NULL;
}

/**************************************************************/
/* protocols_ih_got_help_reply()                              */
/*                                                            */
/* On receiving a Message_HelpReply, we may want to display   */
/* the Help text in the status bar.                           */
/*                                                            */
/* See PRM 3-245.                                             */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_ih_got_help_reply(WimpMessage * m)
{
  static char last_help[Limits_StatusBarStatus];

  /* Don't do anything if the Controls say not to. */

  if (controls.claim_help)
  {
    WimpGetPointerInfoBlock   i;
    browser_data            * b = NULL;
    ObjectId                  o, a = 0;

    RetError(wimp_get_pointer_info(&i));
    RetError(window_wimp_to_toolbox(0, i.window_handle, i.icon_handle, &o, NULL));

    /* If we can get an ancestor, the pointer is over e.g. a toolbar */
    /* - otherwise, assume it is over a browser window.              */

    toolbox_get_ancestor(0, o, &a, NULL);

    if (a)
    {
      toolbox_get_client_handle(0, a, (void *) &b);
    }
    else toolbox_get_client_handle(0, o, (void *) &b);

    /* If we haven't got a valid client handle, exit. */

    if (!is_known_browser(b)) return NULL;

    /* If this is a small fetch window, don't display anything either */

    if (b->small_fetch) return NULL;

    /* If the text is empty, there was no help for that item, */
    /* so restore the old status display, if there was a      */
    /* help display already there.                            */

    if (!*m->data.help_reply.text)
    {
      if (b->status_help != NULL)
      {
        b->status_help = NULL;
        RetError(toolbars_cancel_status(b, Toolbars_Status_Help));
      }
    }
    else
    {
      /* Otherwise update the status bar with the help text, */
      /* if the text has changed.                            */

      if (
           !b->status_help ||
           (
             b->status_help                                  &&
             strcmp(b->status_help, m->data.help_reply.text)
           )
         )
      {
        StrNCpy0(last_help, m->data.help_reply.text);
        b->status_help = last_help;
        RetError(toolbars_update_status(b, Toolbars_Status_Help));
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* protocols_aub_got_open_url()                               */
/*                                                            */
/* Handle ANT Open URL broadcasts.                            */
/*                                                            */
/* See http://www.ant.co.uk/support/tech/ notes/url.html (15  */
/* Sep 1997).                                                 */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message. The contents will be         */
/*             modified and used in a reply.                  */
/**************************************************************/

_kernel_oserror * protocols_aub_got_open_url(WimpMessage * m)
{
  ant_open_url * open = (ant_open_url *) &m->data;
  int            ok   = 0;
  char         * url;
  char         * target;

  /* If 'tag' is non-NULL, the data is a URL string */

  if (open->tag) url = (char *) open, target = NULL;

  /* Otherwise, it's indirected */

  else
  {
    char * file;
    char * mimetype;

    /* Entries are either NULL, an offset into the  */
    /* message block (but we have to ensure that it */
    /* is a valid offset), or a pointer. This       */
    /* protocol sucks, big time.                    */

    if (!open->file.offset) file = NULL;
    else if (open->file.offset < 0x1800000)
    {
      if (open->file.offset >= sizeof(m->data.bytes)) file = NULL;
      else file = ((char *) open) + open->file.offset;
    }
    else file = open->file.ptr;

    if (!open->mimetype.offset) mimetype = NULL;
    else if (open->mimetype.offset < 0x1800000)
    {
      if (open->mimetype.offset >= sizeof(m->data.bytes)) mimetype = NULL;
      else mimetype = ((char *) open) + open->mimetype.offset;
    }
    else mimetype = open->mimetype.ptr;

    /* Can't handle file or mimetype requests */

    if (!file && !mimetype)
    {
      if (!open->url.offset) url = NULL;
      else if (open->url.offset < 0x1800000)
      {
        if (open->url.offset >= sizeof(m->data.bytes)) url = NULL;
        else url = ((char *) open) + open->url.offset;
      }
      else url = open->url.ptr;

      if (!open->target.offset) target = NULL;
      else if (open->target.offset < 0x1800000)
      {
        if (open->target.offset >= sizeof(m->data.bytes)) target = NULL;
        else target = ((char *) open) + open->target.offset;
      }
      else target = open->target.ptr;
    }
    else url = NULL, target = NULL;
  }

  /* Check the protocol - can we handle this? */

  if (url) ok = urlutils_check_protocols(url);

  /* If so, do so */

  if (ok)
  {
    /* Send out the URL */

    RetError(windows_create_browser(url,
                                    NULL,
                                    NULL,
                                    target,
                                    Windows_CreateBrowser_Normal));

    /* Acknowledge the message */

    m->hdr.your_ref = m->hdr.my_ref;

    return wimp_send_message(Wimp_EUserMessageAcknowledge,
                             m,
                             m->hdr.sender,
                             0,
                             NULL);
  }

  return NULL;
}

/**************************************************************/
/* protocols_multi_got_data_save_ack()                        */
/*                                                            */
/* Got a DataSaveAck - this could be part of the print        */
/* protocol, or standard file transfer between applications.  */
/*                                                            */
/* Parameters: Pointer to the WimpMessage struct for the      */
/*             received message.                              */
/**************************************************************/

_kernel_oserror * protocols_multi_got_data_save_ack(WimpMessage * m)
{
  if (m->hdr.your_ref && m->hdr.your_ref == print_save_reference) return protocols_pp_got_data_save_ack(m);
  else                                                            return protocols_atats_got_data_save_ack(m);
}

/**************************************************************/
/* protocols_util_update_reference()                          */
/*                                                            */
/* When a message is sent out as part of an ongoing           */
/* conversation, this function should be called after         */
/* Wimp_SendMessage to update the internal records of known   */
/* my_ref numbers.                                            */
/*                                                            */
/* Parameters: The value of the your_ref field in the         */
/*             *original* message, before a reply was         */
/*             generated (so you will need to remember this   */
/*             before setting your_ref to my_ref prior to     */
/*             replying);                                     */
/*                                                            */
/*             The value of the my_ref field filled in by the */
/*             Wimp after Wimp_SendMessage was called to send */
/*             the reply.                                     */
/**************************************************************/

static void protocols_util_update_reference(int old_ref, int new_ref)
{
  /* This would look really great as a switch statement. But hey, */
  /* I'm sure C is really an excellent language. Really.          */

  if      (old_ref == save_source_reference)              save_source_reference            = new_ref;
  else if (old_ref == save_as_text_reference)             save_as_text_reference           = new_ref;
  else if (old_ref == save_as_draw_reference)             save_as_draw_reference           = new_ref;
  else if (old_ref == save_as_shelp_reference)            save_as_shelp_reference          = new_ref;
  else if (old_ref == save_as_pdf_reference)              save_as_pdf_reference            = new_ref;
  else if (old_ref == save_link_reference)                save_link_reference              = new_ref;
  else if (old_ref == save_location_reference)            save_location_reference          = new_ref;
  else if (old_ref == save_log_reference)                 save_log_reference               = new_ref;

  #ifndef REMOTE_HOTLIST

    else if (old_ref == save_hotlist_entry_reference)     save_hotlist_entry_reference     = new_ref;
    else if (old_ref == save_hotlist_selection_reference) save_hotlist_selection_reference = new_ref;
    else if (old_ref == save_entire_hotlist_reference)    save_entire_hotlist_reference    = new_ref;

  #endif

  else if (old_ref == save_object_reference)              save_object_reference            = new_ref;
  else if (old_ref == save_image_reference)               save_image_reference             = new_ref;
  else if (old_ref == save_history_reference)             save_history_reference           = new_ref;
  else if (old_ref == print_save_reference)               print_save_reference             = new_ref;

  #ifdef TRACE

    else
    {
      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Old message reference %x not recognised in protocols_util_update_reference (has a new save method been created, but not added to this function?)",
              old_ref);

      show_error_ret(&erb);
    }

  #endif
}

/**************************************************************/
/* protocols_util_make_unique_name()                          */
/*                                                            */
/* Generates a browser-unique pathname in the given buffer,   */
/* based on Wimp$ScrapDir. This is hopefully system-unique as */
/* the function keeps going until it can't find a file under  */
/* the name it has constructed.                               */
/*                                                            */
/* Parameters: Pointer to the buffer;                         */
/*                                                            */
/*             Size of the buffer.                            */
/*                                                            */
/* Assumes:    Well it won't crash if you give it a NULL      */
/*             buffer pointer or a buffer size of less than 2 */
/*             bytes, but there's not exactly a huge amount   */
/*             of worth in calling the function under those   */
/*             conditions!                                    */
/**************************************************************/

void protocols_util_make_unique_name(char * buffer, int buffer_size)
{
  int    filecount = 0;
  int    type;
  char * leaf;

  if (!buffer || buffer_size < 2) return;

  /* Clear the buffer first */

  memset(buffer, 0, buffer_size);

  /* Write '<Wimp$ScrapDir>.' (or whatever is defined in Save.h) */
  /* to the buffer - +9 is 8 letters for the leafname (see code  */
  /* below) plus 1 for a terminator.                             */

  if (strlen(Save_ScrapPath) + 9 <= buffer_size) strcpy(buffer, Save_ScrapPath);
  else return;

  /* Append with a unique 8 letter leafname */

  leaf = buffer + strlen(buffer);

  do
  {
    sprintf(leaf, "BTF%05x", filecount++);

    /* Can we find the file? */

    type = 1;

    _swix(OS_File,
          _INR(0,1) | _OUT(0),

          17, /* Read catalogue info for object */
          buffer,

          &type);

    /* Keep going until we run out of files (!) or find an unused name */
  }
  while (type != 0 && filecount <= 0xfffff);

  /* Woo - did we run out? */

  if (filecount > 0xfffff)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      StrNCpy0(erb.errmess,
               "Blimey! Ran out of filenames in protocols_util_make_unique_name. Going to try to use Save_ScrapFile instead...");

      show_error_ret(&erb);

    #endif

    *buffer = 0;

    if (strlen(Save_ScrapFile) + 1 <= buffer_size) strcpy(buffer, Save_ScrapFile);

    return;
  }

  /* Finished */

  return;
}
@


1.29
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d149 5
d473 9
d916 1
a916 1
  if (m->hdr.your_ref && m->hdr.your_ref == save_source_reference)
d918 3
a920 1
    /* Save the document source */
d922 7
a928 1
    if (is_known_browser(save_source_browser))
d930 7
a936 2
      e = save_save_source(path, save_source_browser);
      if (!e) ok = 1;
d938 3
a940 4
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_as_text_reference)
  {
    /* Export the document as text */
d942 5
a946 4
    if (is_known_browser(save_as_text_browser))
    {
      e = savetext_save_text(save_as_text_browser, path, save_as_text_embelishments);
      if (!e) ok = 1;
d948 1
a948 6
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_as_draw_reference)
  {
    /* Export the document as Draw */

    if (is_known_browser(save_as_draw_browser))
d950 1
a950 7
      e = savedraw_save_draw(save_as_draw_browser, path, save_as_draw_backgrounds);
      if (!e) ok = 1;
    }
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_as_shelp_reference)
  {
    /* Export the document as a StrongHelp manual */
d952 5
a956 4
    if (is_known_browser(save_as_shelp_browser))
    {
      e = saveshelp_save_manual(save_as_shelp_browser, path);
      if (!e) ok = 1;
d958 1
a958 4
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_link_reference)
  {
    if (is_known_browser(save_link_browser))
d960 3
a962 1
      if (save_link_token)
d964 6
a969 1
        /* Save a link as a URI file */
d971 2
a972 2
        e = save_save_uri(path, save_link_token->anchor, NULL, save_link_as_url);
        if (!e) ok = 1;
d974 4
a977 1
      else
d979 11
a989 2
        char * url   = browser_current_url  (save_link_browser);
        char * title = browser_current_title(save_link_browser);
d991 1
a991 1
        /* Save the current location as a URI file */
d993 2
a994 2
        if (!url) url = browser_fetch_url(save_link_browser);
        if (!url) url = " ";
d996 3
a998 2
        e = save_save_uri(path, url, title, 0);
        if (!e) ok = 1;
d1001 3
a1003 4
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_location_reference)
  {
    /* Save the current location as a URI file */
d1005 4
a1008 4
    if (is_known_browser(save_location_browser))
    {
      char * title = browser_current_title(save_location_browser);
      char * url   = browser_current_url(save_location_browser);
d1010 2
a1011 2
      if (!url) url = browser_fetch_url(save_location_browser);
      if (!url) url = " ";
d1013 4
a1016 4
      e = save_save_uri(path,
                        url,
                        title,
                        save_location_as_url);
d1018 2
a1019 1
      if (!e) ok = 1;
d1021 3
a1023 4
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_log_reference)
  {
    /* Save a log file */
d1025 5
a1029 4
    if (save_log_log)
    {
      e = save_save_log(path, save_log_log, save_log_selection);
      if (!e) ok = 1;
a1030 1
  }
d1032 5
a1036 1
  #ifndef REMOTE_HOTLIST
d1038 3
a1040 3
    else if (m->hdr.your_ref && m->hdr.your_ref == save_hotlist_entry_reference)
    {
      /* Save a hotlist item as a URI file */
d1042 8
a1049 1
      if (save_hotlist_entry_item)
d1051 3
a1053 1
        e = save_save_uri(path, save_hotlist_entry_item->data.url, save_hotlist_entry_item->name, save_hotlist_entry_as_url);
d1061 3
a1063 4
    }
    else if (m->hdr.your_ref && m->hdr.your_ref == save_hotlist_selection_reference)
    {
      /* Save a hotlist selection as an HTML file */
d1065 2
a1066 6
      e = hotlist_save_hotlist(path, NULL, 1);

      if (!e)
      {
        ok = 1;
        e = hotlist_clear_selection();
a1067 4
    }
    else if (m->hdr.your_ref && m->hdr.your_ref == save_entire_hotlist_reference)
    {
      /* Save the whole hotlist */
d1069 1
a1069 3
      e = hotlist_save_hotlist(path, NULL, 0);
      if (!e) ok = 1;
    }
d1071 3
a1073 1
  #endif
d1075 10
a1084 8
  else if (m->hdr.your_ref && m->hdr.your_ref == save_history_reference)
  {
    /* Save the local or global history */

    if (is_known_browser(save_history_browser))
    {
      e = history_save_as_html(path, save_history_browser);
      if (!e) ok = 1;
d1086 1
a1086 1
    else
d1088 3
a1090 9
      e = history_save_as_html(path, NULL);
      if (!e) ok = 1;
    }
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_object_reference)
  {
    if (is_known_browser(save_object_browser))
    {
      /* First, hide the Save Object dialogue */
d1092 1
a1092 1
      e = saveobject_close(save_object_browser);
d1094 3
a1096 3
      if (!e)
      {
        /* If this is through scrap, use a different filename */
d1098 3
a1100 3
        if (m->data.data_save_ack.estimated_size == -1)
        {
          /* Need to store the Message_DataLoad for later */
d1102 2
a1103 2
          save_object_browser->pending_data_load = malloc(sizeof(WimpMessage));
          if (!save_object_browser->pending_data_load) return make_no_memory_error(13);
d1105 4
a1108 4
          #ifdef TRACE
            malloccount += sizeof(WimpMessage);
            dprintf(("CMal", "** malloccount (protocols_atats_got_data_save_ack): \0211%d\0217\n",malloccount));
          #endif
d1110 1
a1110 1
          *save_object_browser->pending_data_load = *m;
d1112 2
a1113 2
          /* Change the filename to something unique and */
          /* update the message length                   */
d1115 2
a1116 2
          protocols_util_make_unique_name(save_object_browser->pending_data_load->data.data_load.leaf_name,
                                          sizeof(save_object_browser->pending_data_load->data.data_load.leaf_name));
d1118 1
a1118 1
          save_object_browser->pending_data_load->hdr.size = (int) WordAlign(strlen(save_object_browser->pending_data_load->data.data_load.leaf_name) + 45);
d1120 1
a1120 1
          /* Exit through the save routine */
d1122 3
a1124 3
          return save_save_object(save_object_browser->pending_data_load->data.data_load.leaf_name,
                                  save_object_browser);
        }
d1126 1
a1126 1
        /* Otherwise, save as normal */
d1128 5
a1132 4
        else
        {
          e = save_save_object(path, save_object_browser);
          if (!e) ok = 1;
d1136 1
a1136 4
  }
  else if (m->hdr.your_ref && m->hdr.your_ref == save_image_reference)
  {
    if (is_known_browser(save_image_browser))
d1138 1
a1138 1
      if (!save_image_as_original)
d1140 3
a1142 1
        /* Save as a sprite */
d1144 7
a1150 7
        e = image_export_sprite(path, save_image_browser, save_image_token);
        if (!e) ok = 1;
      }
      else
      {
        /* Save original image - similar to Save Object code. So, */
        /* if this is through scrap, use a different filename.    */
d1152 3
a1154 3
        if (m->data.data_save_ack.estimated_size == -1)
        {
          WimpMessage * pending;
d1156 1
a1156 1
          /* Need to store the Message_DataLoad for later */
d1158 2
a1159 2
          pending = malloc(sizeof(WimpMessage));
          if (!pending) return make_no_memory_error(13);
d1161 4
a1164 4
          #ifdef TRACE
            malloccount += sizeof(WimpMessage);
            dprintf(("CMal", "** malloccount (protocols_atats_got_data_save_ack): \0211%d\0217\n",malloccount));
          #endif
d1166 1
a1166 1
          *pending = *m;
d1168 2
a1169 2
          /* Change the filename to something unique and */
          /* update the message length                   */
d1171 2
a1172 2
          protocols_util_make_unique_name(pending->data.data_load.leaf_name,
                                          sizeof(pending->data.data_load.leaf_name));
d1174 1
a1174 1
          pending->hdr.size = (int) WordAlign(strlen(pending->data.data_load.leaf_name) + 45);
d1176 1
a1176 1
          /* Exit through the save routine */
d1178 3
a1180 3
          e = image_export_original(pending->data.data_load.leaf_name,
                                    save_image_browser,
                                    save_image_token);
d1182 6
a1187 5
          if (!e)
          {
            save_image_browser                    = last_browser;
            save_image_browser->pending_data_load = pending;
            ok                                    = 2;
a1188 1
        }
d1190 1
a1190 1
        /* Otherwise, save as normal */
d1192 5
a1196 5
        else
        {
          e = image_export_original(path,
                                    save_image_browser,
                                    save_image_token);
d1198 5
a1202 4
          if (!e)
          {
            save_image_browser = last_browser;
            ok                 = 2;
d1206 3
a1208 2
    }
  }
d1330 1
d3607 1
@


1.28
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d1601 2
d1613 2
a1614 1
  /* Since there is no native TIFF support, drop that out too.    */
d1617 5
a1621 5
       m->data.data_open.file_type == FileType_TEXT ||
       m->data.data_open.file_type == FileType_DATA ||
       m->data.data_open.file_type == FileType_DOS  || /* (Equivalent to FileType_DATA for PC files, so to speak) */
       m->data.data_open.file_type == FileType_TIFF ||
       m->data.data_open.file_type == FileType_URL  ||
d1623 1
a1623 1
         m->data.data_open.file_type == FileType_URI &&
d1626 4
d1708 4
d1770 4
d2002 1
a2002 1
          ChkError(fetchpage_new(b, url, 1, 0));
d2620 1
a2620 1
              e = fetchpage_new(b, ram_load_uri_buffer, 1, 0);
@


1.27
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a75 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d252 1
a252 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_send_data_open: Called\n");
  #endif
d297 1
a297 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_data_open_bounced: Called\n");
  #endif
d394 1
a394 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_send_data_save: Called\n");
  #endif
d593 1
a593 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_data_save_bounced: Called\n");
  #endif
d619 1
a619 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_got_ram_fetch: Called\n");
  #endif
d756 1
a756 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_send_ram_transmit: Called\n");
  #endif
d787 1
a787 1
        else Printf("\n(Cannot dump transmission buffer - error from Wimp_TransferBlock)\n\n");
d791 1
a791 1
        Printf("\n(Cannot dump transmission buffer - not enough memory for local copy)\n\n");
d857 1
a857 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_ram_transmit_bounced: Called\n");
  #endif
d897 1
a897 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_got_data_save_ack: Called\n");
  #endif
d1074 1
a1074 1
            if (tl & (1u<<13)) Printf("** malloccount (protocols_atats_got_data_save_ack): \0211%d\0217\n",malloccount);
d1130 1
a1130 1
            if (tl & (1u<<13)) Printf("** malloccount (protocols_atats_got_data_save_ack): \0211%d\0217\n",malloccount);
d1215 1
a1215 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_send_data_load: Called\n");
  #endif
d1285 1
a1285 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_data_load_bounced: Called\n");
  #endif
d1460 1
a1460 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atats_got_data_load_ack: Called\n");
  #endif
d1601 1
a1601 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atatl_got_data_open: Called\n");
  #endif
d1632 1
a1632 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atatl_got_data_open: Exitting through protocols_atatl_got_data_load\n");
  #endif
d1658 1
a1658 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atatl_got_data_load: Called\n");
  #endif
d1707 1
a1707 3
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atatl_got_data_load: Can handle this filetype (0x%03x)\n", filetype);
    #endif
d1715 1
a1715 3
      #ifdef TRACE
        if (tl & (1u<<28)) Printf("protocols_atatl_got_data_load: Not logged in\n");
      #endif
d2019 1
a2019 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atatl_send_data_load_ack: Called\n");
  #endif
d2049 1
a2049 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atatl_got_data_save: Called\n");
  #endif
d2082 1
a2082 3
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atatl_got_data_save: Freeing old pending Acknowledge block\n");
    #endif
d2090 1
a2090 3
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atatl_got_data_save: Freeing old suggested leafname block\n");
    #endif
d2128 1
a2128 3
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atatl_got_data_save: Allocated new pending Acknowledge block\n");
    #endif
d2175 1
a2175 1
        if (tl & (1u<<13)) Printf("** malloccount (protocols_atatl_got_data_save): \0211%d\0217\n",malloccount);
d2187 1
a2187 3
      #ifdef TRACE
        if (tl & (1u<<28)) Printf("protocols_atatl_got_data_save: Sending Message_RAMFetch in response\n");
      #endif
d2248 1
a2248 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atatl_ram_fetch_bounced: Called\n");
  #endif
d2259 1
a2259 3
      #ifdef TRACE
        if (tl & (1u<<28)) Printf("protocols_atatl_ram_fetch_bounced: Recognised bounce for a new transfer - using Scrap instead\n");
      #endif
d2283 1
a2283 3
      #ifdef TRACE
        if (tl & (1u<<28)) Printf("protocols_atatl_ram_fetch_bounced: Recognised bounce for an ongoing transfer - aborting\n");
      #endif
d2295 1
a2295 1
          if (tl & (1u<<13)) Printf("** malloccount (protocols_atatl_ram_fetch_bounced): \0212%d\0217\n",malloccount);
d2308 1
a2308 1
          if (tl & (1u<<13)) Printf("** malloccount (protocols_atatl_ram_fetch_bounced): \0212%d\0217\n",malloccount);
d2344 1
a2344 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atatl_got_ram_transmit: Called with %d bytes to receive\n", m->data.ram_transmit.nbytes);
  #endif
d2448 1
a2448 1
                if (tl & (1u<<13)) Printf("** malloccount (protocols_atatl_got_ram_transmit): \0211%d\0217\n",malloccount);
d2470 1
a2470 1
                if (tl & (1u<<13)) Printf("** malloccount (protocols_atatl_got_ram_transmit): \0212%d\0217\n",malloccount);
d2488 1
a2488 1
                if (tl & (1u<<13)) Printf("** malloccount (protocols_atatl_got_ram_transmit): \0211%d\0217\n",malloccount);
d2614 1
a2614 1
            if (tl & (1u<<13)) Printf("** malloccount (protocols_atatl_got_ram_transmit): \0212%d\0217\n",malloccount);
d2663 1
a2663 3
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atatl_got_ram_transmit: Sending RAMFetch in reply\n");
    #endif
d2685 1
a2685 1
      if (tl & (1u<<13)) Printf("** malloccount (protocols_atatl_got_ram_transmit): \0212%d\0217\n",malloccount);
d2692 1
a2692 3
      #ifdef TRACE
        if (tl & (1u<<28)) Printf("protocols_atatl_got_ram_transmit: Freeing old pending Acknowledge block\n");
      #endif
d2855 1
a2855 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_pp_got_data_save_ack: Called\n");
  #endif
d2894 1
a2894 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_pp_got_data_save_ack: Sending Message_DataLoad in response\n");
  #endif
d3083 1
a3083 3
  #ifdef TRACE
    if (tl & (1u<<21)) Printf("protocols_auh_got_process: URI_MProcess '%s', ok = %d\n",uri->uri,ok);
  #endif
d3177 1
a3177 3
  #ifdef TRACE
    if (tl & (1u<<21)) Printf("protocols_auh_got_return_result: URI_MReturnResult, not_claimed = %d\n",uri->flags.bits.not_claimed);
  #endif
@


1.26
log
@Long overdue check-in of intermediate browser build, from continued "out
of hours" work. Forgot to add a few files last time too.

List dialogue box handler complete, and exclusion lists implemented
within the main browser code. Full documentation in Choices file.
Save routine knows all about it but is now getting very slow - must
come up with a better scheme; for now, it puts the hourglass on...

StripExtensions option controls auto stripping of filename extensions.

More sensible ancestor / frame selection for keyboard shortcut items
and the save dialogues - having selected a frame won't lock you into
it for F3 and related shortcuts now (input focus in URL writable ->
get ancestor details, input focus in frame -> get frame details). F4
works in frames. F5 now generally present for 'view source' with a
corresponding menu entry in the File menu.

Odd thing in later Res files; there's no action set for Adjust clicks
on the main ToolAction items in the button bar. Very odd. Nothing
appears to be set in v2.07 either, yet adjust-click works. Even
stranger. Anyway, added in the relevant event details (same as for
Select click in all cases) and this fixes the problem.

Background colours in the TABLE tag ignored the "don't print any
backgrounds" Print Style setting. Fixed. Meanwhile, the "black
text with no backgrounds" option wasn't getting this right either;
fixed this also.

Event logging implemented; HTTP errors and script output via.
window.print extension. No internal error output yet.

Faith:Never behaviour extended. If ever a server sends something with
no content type or an unhandleable type, the browser will try and get a
filetype from the URL. If it gets text or HTML, it'll render the file.
Else it'll save it. Hacks around IIS 4's lack of a content type field
in the Marketeye login stuff, and similar other slightly broken sites.
@
text
@d15 45
a59 50
/***************************************************/
/* File   : Protocols.c                            */
/*                                                 */
/* Purpose: Handle some common protocol stuff,     */
/*          such as inter-application data         */
/*          transfer.                              */
/*                                                 */
/*          Function naming convention is as usual */
/*          a source leafname derived prefix, then */
/*          a code based on the protocol being     */
/*          dealt with:                            */
/*                                                 */
/*          _atats_  App To App Transfer, Save     */
/*          _atatl_  App To App Transfer, Load     */
/*          _pp_     Printer Protocol              */
/*          _auh_    Acorn URI Handler             */
/*          _ih_     Interactive Help              */
/*          _aub_    ANT URL Broadcast             */
/*          _multi_  Message is used in more than  */
/*                   one message protocol scheme   */
/*          _util_   A utility function not        */
/*                   directly connected with a     */
/*                   specific protocol.            */
/*                                                 */
/*          This is followed by the direction, so  */
/*          to speak - i.e. '_got_' for got a      */
/*          message, '_send_' for sending a        */
/*          message. Alternatively, a prefix       */
/*          '_bounced' is used for messages which  */
/*          return as a UserMessage_Acknowledge    */
/*          event.                                 */
/*                                                 */
/*          Because the Plug-In message protocol   */
/*          is such a large and self-contained     */
/*          entity, this is kept separate, in      */
/*          PlugIn.c.                              */
/*                                                 */
/*          Do NOT use MemLib here, as you will    */
/*          hit the Wimp bug relating to message   */
/*          blocks stored at high addresses (given */
/*          an old enough Wimp) if you do.         */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 29-Aug-97: Created.                    */
/*                                                 */
/*          06-Sep-97: Significant rewriting to    */
/*                     stop various clashes and    */
/*                     increase flexibility.       */
/***************************************************/
d65 2
a66 2
#include "swis.h"
#include "kernel.h"
d68 1
a68 1
#include "URI.h" /* URI handler API, in URILib:h */
d70 3
a72 3
#include "wimp.h"
#include "wimplib.h"
#include "event.h"
d74 6
a79 1
#include "toolbox.h"
a80 1
#include "svcprint.h"
d242 10
a251 11
/*************************************************/
/* protocols_atats_send_data_open()              */
/*                                               */
/* Broadcasts a Message_DataOpen for the given   */
/* filetype and given pathname.                  */
/*                                               */
/* Parameters: The filetype to use;              */
/*                                               */
/*             Pointer to a null-terminated      */
/*             pathname to use.                  */
/*************************************************/
d288 13
a300 13
/*************************************************/
/* protocols_atats_data_open_bounced()           */
/*                                               */
/* For a View Source function, the browser       */
/* broadcasts a Message_DataOpen. If this        */
/* bounces, attempt to start an editor instead,  */
/* with the pathname specified in the message.   */
/*                                               */
/* See PRM 3-265.                                */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d366 31
a396 37
/*************************************************/
/* protocols_atats_send_data_save()              */
/*                                               */
/* Send out a Message_DataSave to initiate       */
/* saving of data to another applicaion.         */
/*                                               */
/* See PRM 3-250 to 3-252.                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the save (or NULL);   */
/*                                               */
/*             Pointer to an item that will vary */
/*             depending on what is being saved  */
/*             - e.g. an HStream struct, a       */
/*             hotlist item, or NULL... full     */
/*             details by the definition of the  */
/*             protocols_saving enumeration in   */
/*             Protocols.h;                      */
/*                                               */
/*             Pointer to a null terminated      */
/*             leafname to use;                  */
/*                                               */
/*             If possible, the estimated size   */
/*             of the data, else -1;             */
/*                                               */
/*             Filetype to quote;                */
/*                                               */
/*             A protocols_saving value to say   */
/*             what is being saved (see          */
/*             Protocols.h);                     */
/*                                               */
/*             A WimpGetPointerInfo block        */
/*             pointer, from which the window    */
/*             and icon handle to send to, and   */
/*             x and y coords to send to, are    */
/*             read.                             */
/*************************************************/
d591 10
a600 10
/*************************************************/
/* protocols_atats_data_save_bounced()           */
/*                                               */
/* Deals with a Message_DataSave bouncing.       */
/*                                               */
/* See PRM 3-252.                                */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d614 15
a628 18
/*************************************************/
/* protocols_atats_got_ram_fetch()               */
/*                                               */
/* After the browser sends a Message_DataSave to */
/* an application, it may reply with             */
/* Message_RAMFetch rather than                  */
/* Message_DataSaveAck if it can handle RAM      */
/* transfer. In that case, we should see if we   */
/* can do RAM transfer for this filetype         */
/* ourselves, and if so, transfer data.          */
/*                                               */
/* See PRM 3-255 and 256.                        */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the Message_RAMFetch. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d745 21
a765 25
/*************************************************/
/* protocols_atats_send_ram_transmit()           */
/*                                               */
/* Send out a Message_RAMTransmit in response to */
/* a Message_RAMFetch from another application,  */
/* as part of an ongoing dialogue for RAM        */
/* transfer.                                     */
/*                                               */
/* See PRM 3-255 and 256.                        */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the Message_RAMFetch. The     */
/*             contents will be modified and     */
/*             used in a reply;                  */
/*                                               */
/*             The number of bytes written to    */
/*             the buffer given in the           */
/*             Message_RAMFetch;                 */
/*                                               */
/*             1 if this is the last message in  */
/*             the transfer (so it won't be sent */
/*             UserMessageRecorded and raise an  */
/*             error when it doesn't get         */
/*             acknowledged...).                 */
/*************************************************/
d860 11
a870 12
/*************************************************/
/* protocols_atats_ram_transmit_bounced()        */
/*                                               */
/* If a RAMTransmit is not acknowledged, we      */
/* should abort file transfer and raise an       */
/* error.                                        */
/*                                               */
/* See PRM 3-255 and 256.                        */
/*                                               */
/* Parameters Pointer to the WimpMessage struct  */
/*            for the received message.          */
/*************************************************/
d890 19
a908 22
/*************************************************/
/* protocols_atats_got_data_save_ack()           */
/*                                               */
/* Once we've sent out Message_DataSave we could */
/* get Message_RAMFetch back and proceed with    */
/* RAM transfer. Or the other task could respond */
/* with a Message_DataSaveAck, for transfer via  */
/* a temporary file on disc. This can also       */
/* happen if the other application responds with */
/* a Message_RAMFetch but we decide we can't do  */
/* RAM transfer for that particular object;      */
/* the application sees its Message_RAMFetch     */
/* bounce and drops back to Message_DataSaveAck  */
/* instead.                                      */
/*                                               */
/* See PRM 3-250, 251 and 253.                   */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d1217 13
a1229 15
/*************************************************/
/* protocols_atats_send_data_load()              */
/*                                               */
/* Send out a Message_DataLoad in response to a  */
/* Message_DataSaveAck from another application, */
/* as part of an ongoing dialogue for file       */
/* transfer.                                     */
/*                                               */
/* See PRM 3-251 and 253.                        */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the Message_DataSaveAck. The  */
/*             contents will be modified and     */
/*             used in the reply.                */
/*************************************************/
d1292 11
a1302 12
/*************************************************/
/* protocols_atats_data_load_bounced()           */
/*                                               */
/* Called if a Message_DataLoad bounces. Need to */
/* delete any scrap files written and report an  */
/* appropriate error.                            */
/*                                               */
/* See PRM 3-253, 254.                           */
/*                                               */
/* Parameters Pointer to the WimpMessage struct  */
/*            for the received message.          */
/*************************************************/
d1471 11
a1481 11
/*************************************************/
/* protocols_atats_got_data_load_ack()           */
/*                                               */
/* Deals with a Message_DataLoadAck - completion */
/* of app to app transfer from the browser.      */
/*                                               */
/* See PRM 3-250, 251, 254.                      */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d1495 9
a1503 11
/*************************************************/
/* protocols_atats_send_any_pendings()           */
/*                                               */
/* Sends any pending messages related to the     */
/* given browser, in the context of application  */
/* to application saving.                        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the pending messages, */
/*             if any.                           */
/*************************************************/
d1611 14
a1624 16
/*************************************************/
/* protocols_atatl_got_data_open()               */
/*                                               */
/* Handle reception of a Message_DataOpen - we   */
/* may want to load a given file. It is an       */
/* application to application related the        */
/* consideration as we are transfering data      */
/* from the Filer, in a sense.                   */
/*                                               */
/* See PRM 3-265.                                */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d1668 12
a1679 13
/*************************************************/
/* protocols_atatl_got_data_load()               */
/*                                               */
/* Deals with a Message_DataLoad - if we can     */
/* handle the file, load it.                     */
/*                                               */
/* See PRM 3-253.                                */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d2041 12
a2052 13
/*************************************************/
/* protocols_atatl_send_data_load_ack()          */
/*                                               */
/* In response to a Message_DataLoad, reply with */
/* a Message_DataLoadAck.                        */
/*                                               */
/* See PRM 3-252 and 254.                        */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d2066 13
a2078 14
/*************************************************/
/* protocols_atatl_got_data_save()               */
/*                                               */
/* Handle reception of a Message_DataSave - load */
/* data from another application. Handles RAM    */
/* transfer for some filetypes.                  */
/*                                               */
/* See PRM 3-252, 253, 255 and 256.              */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d2269 25
a2293 28
/*************************************************/
/* protocols_atatl_ram_fetch_bounced()           */
/*                                               */
/* Following getting a Message_DataSave,         */
/* protocols_atatl_got_data_save may send out a  */
/* Message_RAMFetch. If this bounces, this       */
/* function is called. If the bounce is indeed   */
/* due to the RAMFetch we sent, then send out    */
/* a Message_DataSaveAck instead, to try and use */
/* scrap file transfer. This is stored in the    */
/* 'pending' block by the same function that     */
/* sends the Message_RAMFetch.                   */
/*                                               */
/* Alternatively, a Message_RAMFetch being sent  */
/* in reply to a Message_RAMTransmit *during*    */
/* RAM transfer could bounce, and this function  */
/* would be called. In that case, we should      */
/* abort data transfer. The other end is meant   */
/* to raise an error (which is odd, since it     */
/* seems likely that it will have died - since   */
/* it's sending, the changes of running out of   */
/* memory at that end are slim).                 */
/*                                               */
/* See PRM 3-255.                                */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d2380 12
a2391 13
/*************************************************/
/* protocols_atatl_got_ram_transmit()            */
/*                                               */
/* Deals with a Message_RAMTransmit - we have    */
/* some data in the 'rtb' buffer.                */
/*                                               */
/* See PRM 3-255, 256.                           */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d2763 8
a2770 8
/*************************************************/
/* protocols_pp_send_print_save()                */
/*                                               */
/* First stage of the Print Protocol - broadcast */
/* a Message_PrintSave.                          */
/*                                               */
/* See PRM 3-259, 262.                           */
/*************************************************/
d2815 14
a2828 16
/*************************************************/
/* protocols_pp_print_save_bounced()             */
/*                                               */
/* If a Message_PrintSave bounces, the browser   */
/* tried to use the printer protocol to do a     */
/* print job but the printer wasn't loaded. In   */
/* that case, print directly to the 'printer:'   */
/* device.                                       */
/*                                               */
/* See PRM 3-259 for details of where this fits  */
/* into the protocol, or 3-262 for the message   */
/* structure.                                    */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d2859 11
a2869 11
/*************************************************/
/* protocols_pp_got_print_error()                */
/*                                               */
/* Handle reception of a Message_PrintError -    */
/* report an error from the printer driver.      */
/*                                               */
/* See PRM 3-262.                                */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d2894 15
a2908 17
/*************************************************/
/* protocols_pp_got_data_save_ack()              */
/*                                               */
/* Handle reception of a Message_DataSaveAck     */
/* where the your_ref field shows that it has    */
/* been sent in relation to a print job. Only    */
/* call in those circumstances...                */
/*                                               */
/* See PRM 3-259 / 3-260 for details of where    */
/* this fits into the protocol, or PRM 3-253     */
/* for details on the message structure.         */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d2968 26
a2993 29
/*************************************************/
/* protocols_pp_got_print_type_odd()             */
/*                                               */
/* Handle reception of a Message_PrintTypeOdd.   */
/*                                               */
/* If this is sent directly to the task, we can  */
/* print immediately to 'printer:'.              */
/*                                               */
/* The use of an Alias$PrintType_FF4 system      */
/* variable makes it unnecessary to deal with    */
/* the case of a broadcast PrintTypeOdd. This    */
/* happens when a queued PrintOut file that the  */
/* browser has been asked to print rises to the  */
/* top of !Printers' queue. Bizarrely, !Printers */
/* doesn't recognise the filetype and raises the */
/* message. We allow this to fall back to the    */
/* system variable, which copies the PrintOut    */
/* file to the 'printer:' device.                */
/*                                               */
/* This is a hole in an otherwise workable, if   */
/* cumbersome, protocol.                         */
/*                                               */
/* See PRM 3-263.                                */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d3071 11
a3081 11
/*************************************************/
/* protocols_auh_got_started()                   */
/*                                               */
/* Handle reception of a URI_MStarted - the URI  */
/* handler has starting up.                      */
/*                                               */
/* See 1307,260/FS.                              */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d3096 11
a3106 11
/*************************************************/
/* protocols_auh_got_dying()                     */
/*                                               */
/* Handle reception of a URI_MDying - the URI    */
/* handler is closing down.                      */
/*                                               */
/* See 1307,260/FS.                              */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d3117 12
a3128 14
/*************************************************/
/* protocols_auh_got_process()                   */
/*                                               */
/* Handle reception of a URI_MProcess - process  */
/* a URI from the URI handler, replying if we    */
/* can handle the URI.                           */
/*                                               */
/* See 1307,260/FS.                              */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d3132 3
a3134 3
  URIProcessMessage * uri    = (URIProcessMessage *) &m->data;
  int                 ok;
  unsigned int        sender = m->hdr.sender;
d3226 13
a3238 14
/*************************************************/
/* protocols_auh_got_return_result()             */
/*                                               */
/* Handle reception of a URI_MReturnResult -     */
/* the URI handler is reporting what happened to */
/* a URI we dispatched through it.               */
/*                                               */
/* See 1307,260/FS.                              */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d3268 8
a3275 10
/*************************************************/
/* protocols_ih_send_help_request()              */
/*                                               */
/* Sends out HelpRequest messages for the item   */
/* the mouse pointer is currently over, every    */
/* 20 centiseconds or so.                        */
/*                                               */
/* Parameters are as standard for a Wimp NULL    */
/* event handler.                                */
/*************************************************/
d3304 1
a3304 1
      if (task_handle == task_from_window(i.window_handle))
d3341 15
a3355 18
/*************************************************/
/* protocols_ih_help_request_bounced()           */
/*                                               */
/* If a Message_HelpRequest comes in as a        */
/* UserMessage_Acknowledge, then the browser     */
/* tried to send out such a message and it       */
/* bounced - there is no help on that item.      */
/* In this case, if we're displaing help items   */
/* in the status bar, return to a non-help       */
/* status string.                                */
/*                                               */
/* See PRM 3-244 for details of the message or   */
/* protocols_ih_send_help_request for the        */
/* message origin.                               */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d3395 11
a3405 11
/*************************************************/
/* protocols_ih_got_help_reply()                 */
/*                                               */
/* On receiving a Message_HelpReply, we may want */
/* to display the Help text in the status bar.   */
/*                                               */
/* See PRM 3-245.                                */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d3476 12
a3487 13
/*************************************************/
/* protocols_aub_got_open_url()                  */
/*                                               */
/* Handle ANT Open URL broadcasts.               */
/*                                               */
/* See http://www.ant.co.uk/support/tech/        */
/* notes/url.html (15 Sep 1997).                 */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
/*************************************************/
d3581 9
a3589 10
/*************************************************/
/* protocols_multi_got_data_save_ack()           */
/*                                               */
/* Got a DataSaveAck - this could be part of the */
/* print protocol, or standard file transfer     */
/* between applications.                         */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/
d3597 18
a3614 20
/*************************************************/
/* protocols_util_update_reference()             */
/*                                               */
/* When a message is sent out as part of an      */
/* ongoing conversation, this function should be */
/* called after Wimp_SendMessage to update the   */
/* internal records of known my_ref numbers.     */
/*                                               */
/* Parameters: The value of the your_ref field   */
/*             in the *original* message, before */
/*             a reply was generated (so you     */
/*             will need to remember this before */
/*             setting your_ref to my_ref prior  */
/*             to replying);                     */
/*                                               */
/*             The value of the my_ref field     */
/*             filled in by the Wimp after       */
/*             Wimp_SendMessage was called to    */
/*             send the reply.                   */
/*************************************************/
d3658 18
a3675 20
/*************************************************/
/* protocols_util_make_unique_name()             */
/*                                               */
/* Generates a browser-unique pathname in the    */
/* given buffer, based on Wimp$ScrapDir. This is */
/* hopefully system-unique as the function       */
/* keeps going until it can't find a file under  */
/* the name it has constructed.                  */
/*                                               */
/* Parameters: Pointer to the buffer;            */
/*                                               */
/*             Size of the buffer.               */
/*                                               */
/* Assumes:    Well it won't crash if you give   */
/*             it a NULL buffer pointer or a     */
/*             buffer size of less than 2 bytes, */
/*             but there's not exactly a huge    */
/*             amount of worth in calling the    */
/*             function under those conditions!  */
/*************************************************/
@


1.25
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d130 1
a130 1
static int            data_open_reference                = 0;
d134 3
a136 3
static int            save_source_reference              = 0;
static int            save_source_transmitted            = 0;
static browser_data * save_source_browser                = NULL;
d140 3
a142 3
static int            save_as_text_reference             = 0;
static browser_data * save_as_text_browser               = NULL;
static int            save_as_text_embelishments         = 0;
d146 3
a148 3
static int            save_as_draw_reference             = 0;
static browser_data * save_as_draw_browser               = NULL;
static int            save_as_draw_backgrounds           = 0;
d152 2
a153 2
static int            save_as_shelp_reference            = 0;
static browser_data * save_as_shelp_browser              = NULL;
d157 5
a161 5
static int            save_link_reference                = 0;
static int            save_link_transmitted              = 0;
static browser_data * save_link_browser                  = NULL;
static HStream      * save_link_token                    = NULL;
static int            save_link_as_url                   = 0;
d165 11
a175 4
static int            save_location_reference            = 0;
static int            save_location_transmitted          = 0;
static browser_data * save_location_browser              = NULL;
static int            save_location_as_url               = 0;
d181 4
a184 4
  static int            save_hotlist_entry_reference     = 0;
  static int            save_hotlist_entry_transmitted   = 0;
  static hotlist_item * save_hotlist_entry_item          = NULL;
  static int            save_hotlist_entry_as_url        = 0;
d200 2
a201 2
static int            save_history_reference             = 0;
static browser_data * save_history_browser               = NULL;
d205 4
a208 4
static int            save_object_reference              = 0;
static int            save_object_transmitted            = 0;
static browser_data * save_object_browser                = NULL;
static int            save_object_through_scrap          = 0;
d212 5
a216 5
static int            save_image_reference               = 0;
static int            save_image_transmitted             = 0;
static browser_data * save_image_browser                 = NULL;
static HStream      * save_image_token                   = NULL;
static int            save_image_as_original             = 0;
d222 2
a223 2
static WimpMessage  * pending_data_save_ack              = NULL;
static char         * data_save_suggested_leafname       = NULL;
d225 2
a226 2
static void         * rtb                                = NULL;
static int            ram_fetch_reference                = 0;
d228 3
a230 3
static char         * ram_load_uri_buffer                = NULL;
static int            ram_load_buffer_size               = 0;
static int            ram_load_started                   = 0;
d234 1
a234 1
static int            print_save_reference               = 0;
d510 11
d725 9
d844 1
a844 1
  /* was in a menu... Well, things Go Wrong.                  */
d855 2
a856 1
         m->hdr.my_ref == save_location_reference
d1028 10
d1344 1
d3679 1
@


1.24
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d52 5
d96 1
d677 1
d695 4
d700 1
a700 1
      return save_transfer_uri(browser_current_url(save_location_browser),
d972 1
d987 9
a996 1
      e = save_save_uri(path, browser_current_url(save_location_browser), title, save_location_as_url);
d1672 1
d1688 1
a1688 1
                                  NULL,
d1726 1
d1811 5
a1815 1
      urlutils_load_uri_file(url, sizeof(url), title, sizeof(title), m->data.data_load.leaf_name);
d1827 39
a1865 1
      /* Load file to icon bar - i.e. open a new window. */
d1868 29
d1901 1
a1901 1
      else
a1902 2
        int handled = 0;

d1911 1
a1911 1
          ObjectId this;
d1913 3
a1915 1
          /* If we can get the window object ID... */
d1917 1
a1917 9
          if (
               !window_wimp_to_toolbox(0,
                                       m->data.data_load.destination_window,
                                       -1,
                                       &this,
                                       NULL)
             )
          {
            /* ...and it matches that of the hotlist, add the item. */
d1919 1
a1919 1
            if (this == hotlist_return_window_id())
d1921 4
a1924 1
              char * leaf = NULL;
d1926 1
a1926 1
              /* If we have a title for the URL, use it, else try other methods... */
d1928 3
a1930 6
              if (!*title)
              {
                /* For the description, use the source leafname, unless this */
                /* is from another app (your_ref is non-zero), in which case */
                /* use the URL, as <Wimp$Scrap> isn't very friendly or       */
                /* unique.                                                   */
d1932 4
a1935 1
                if (!m->hdr.your_ref) leaf = strrchr(m->data.data_load.leaf_name, '.');
d1937 1
a1937 11
                if (!leaf) leaf = url;
                else       leaf ++;
              }

              ChkError(hotlist_add_position(m->data.data_load.destination_x,
                                            m->data.data_load.destination_y,
                                            *title ? title : leaf,
                                            url));

              handled = 1;
            }
d1971 3
d1975 1
a1975 1
        /* If not handled yet, deal with the file */
d1977 3
a1979 3
        if (!handled)
        {
          browser_data * b = NULL;
d1981 2
a1982 2
          /* Otherwise, load file to a browser window. Need to find */
          /* its browser_data structure for this.                   */
d1984 1
a1984 1
          utils_browser_from_window(m->data.data_load.destination_window, &b);
d1986 3
a1988 3
          if (b && !b->small_fetch)
          {
            int dont_load_to_form = (filetype != FileType_TEXT);
d1990 1
a1990 1
            #ifdef JAVASCRIPT
d1992 3
a1994 3
              /* If this is a JavaScript URL, the script will end up    */
              /* being executed. Tell the JavaScript interface routines */
              /* that it came from the URL writable.                    */
d1996 5
a2000 5
              if (javascript_url(url))
              {
                dont_load_to_form = 1;
                javascript_set_source(JavaScript_Source_URLWritable);
              }
d2002 1
a2002 1
            #endif
d2004 2
a2005 2
            /* If flagged not to try, or trying to load the file into a */
            /* writeable forms item fails, do a conventional fetch.     */
d2007 10
a2016 10
            if (
                 dont_load_to_form ||
                 !form_could_load_text_at_pointer(b, m->data.data_load.leaf_name)
               )
            {
              ChkError(fetchpage_new(b, url, 1, 0));
            }
            else
            {
              /* If the item was sent through Scrap, we should remove it */
d2018 1
a2018 3
              if (apptoapp) remove(m->data.data_load.leaf_name);
            }
          }
d2021 1
a2021 2

    #endif
d2084 1
a2084 1
  /* an ANT URL file filetype.                                            */
d2092 1
a2092 1
  if (c == URLBarWrit && filetype == FileType_TEXT) filetype = FileType_URL;
d2437 1
d2440 2
a2441 2
    /* Was this dragged to the URL writable, and thus should be */
    /* treated as an ANT URL file (if text)?                    */
d2446 1
a2446 1
                                    NULL,
d2449 1
a2449 1
    if (c == URLBarWrit && filetype == FileType_TEXT) filetype = FileType_URL;
d2574 2
d2591 10
d2605 1
a2605 1
            else
d2607 1
a2607 2
              /* As with DataLoad, this can go to a Hotlist window or a browser; */
              /* the hotlist is the simpler case, check that first.              */
d2609 1
a2609 12
              ObjectId this;
              int      handled = 0;

              /* If we can get the window object ID... */

              if (
                   !window_wimp_to_toolbox(0,
                                           pending_data_save_ack->data.data_save_ack.destination_window,
                                           -1,
                                           &this,
                                           NULL)
                 )
d2611 1
a2611 1
                /* ...and it matches that of the hotlist, add the item. */
d2613 8
a2620 1
                if (this == hotlist_return_window_id())
d2622 9
a2630 1
                  /* Use the title, if we have one */
d2632 1
a2632 14
                  if (*(ram_load_uri_buffer + strlen(ram_load_uri_buffer) + 1))
                  {
                    ChkError(hotlist_add_position(pending_data_save_ack->data.data_save_ack.destination_x,
                                                  pending_data_save_ack->data.data_save_ack.destination_y,
                                                  ram_load_uri_buffer + strlen(ram_load_uri_buffer) + 1,
                                                  ram_load_uri_buffer));
                  }
                  else
                  {
                    ChkError(hotlist_add_position(pending_data_save_ack->data.data_save_ack.destination_x,
                                                  pending_data_save_ack->data.data_save_ack.destination_y,
                                                  ram_load_uri_buffer,
                                                  ram_load_uri_buffer));
                  }
d2634 1
a2634 3
                  handled = 1;
                }
              }
d2636 3
a2638 3
              if (!handled)
              {
                browser_data * b;
d2640 1
a2640 1
                /* The message was for a specific window, so find out which one */
d2642 1
a2642 1
                utils_browser_from_window(pending_data_save_ack->data.data_save_ack.destination_window, &b);
d2644 3
a2646 3
                if (b && !b->small_fetch)
                {
                  #ifdef JAVASCRIPT
d2648 3
a2650 3
                    /* If this is a JavaScript URL, the script will end up    */
                    /* being executed. Tell the JavaScript interface routines */
                    /* that it came from the URL writable.                    */
d2652 1
a2652 1
                    if (javascript_url(ram_load_uri_buffer)) javascript_set_source(JavaScript_Source_URLWritable);
d2654 1
a2654 1
                  #endif
d2656 1
a2656 3
                  e = fetchpage_new(b, ram_load_uri_buffer, 1, 0);
                }
              }
d2658 1
a2658 2

          #endif
@


1.23
log
@All !Run[D], Choices, Messages, Controls and Res files are up to date.

RefoKeep and RefoHold options added to, respectively, try and maintain
the line at the top of the visible area when reformatting, and not shrink
the vertical extent at the start of a reformat to try and avoid flicker
to the top of the page and back down again when RefoKeep is on. Choices
front-end implemented, which also allows RefoWait and RefoTime to be set.
Unfortunately for various reasons this doesn't help the page jumping when
unsized images come in (but RefoHold can improve matters...) - roll on
the image history.

DragToScroll and NoScrollBars options added for frames; included new
pointer type, Mouse_Shape_DTS, so relevant Controls file entries done
and Sprites[22] files updated as required. Noticed some builds have
a low-res ptr_link with a mask - mask removed.

Named anchor following fixed up somewhat - anchors near the bottom of
the page shouldn't be displayed, and then pulled down when the fetcher
releases null polls and ensures the y extent is correct (this through
implementing the min_height field in the browser_data structure).

RefoHang was never implemented and there seems little point to it now,
so the entry for it has been removed from the global choices structure
and all Choices files.

Markers menus should work properly now (in last check-in they would not
update correctly if Adjust was used on the entries).

URI handler usage now a lot more sensible, with configuration of how the
browser uses the module from both a Utils menu submenu (sic) and the
Choices dialogue.

Slightly dodgy 'hang around waiting for user input' stuff for the Cookies
dialogue box: All fetches are suspended; the fetcher remembers some info
about its state at the time the cookie came in, and restores it later; it
will only do this for one fetch at a time. It's necessary to single-thread
the fetcher at this point anyway, since other fetches may have a
dependency on the cookie that is hanging in mid-air at that point. As part
of this, some of the fetcher code has been split out into separate
functions (to try and 'black box' the code a bit). Anyway, Cookie Query
dialogue box now implemented with appropriate Choices file entry and
UI work in the Choices dialogue box.

Phoenix build Choices rearranged. Can now choose when the image history
is saved from the front end. Added also MSIE 4-style table option menu
for JPEG support (OS only, OS if it can handle it, internal only).

Should be a bit faster at loading the history - though 95% of the time
is spent in SWI URL_ParseURL. URL descriptions are stored more
efficiently as part of this - one malloc block instead of several
small blocks. The minimum block size for malloc blocks typically leads
to a significantly smaller startup wimpslot depending on the visit
history size.

Nasty bug in image system fixed. If an image size came in and a reformat
was to take place, the line the image lies in is found and the reformat
progresses from there. Unforunately, this didn't check to see if the
token can't be found in the line list, so it'd reformat from the top
of the page...! This would happen if, for example, an image halfway down
the page came in whilst a reformat for an image higher up had just begun.

In Choices.c, made choices_set_timetype_field, choices_set_uri_field,
choices_set_plugin_field, choices_set_cookie_field, and
choices_set_jpeg_field static (so they're not declared in Choices.h now).

Two memory leaks plugged in URL comparison routines in URLutils.c
(calling free() url_description instead of urlutils_free_descripton()).

Client pull reload handler was setting the reload flag if reloading
the same page, but forgetting to turn on reload_lock so
fetchpage_postprocessed was clearing the reload state... Similarly,
Ctrl+Shift+SELECT-Click on a link when the Controls file 'UseSmall'
entry is 'no' would not have reloaded as it should. Both fixed.

Frames shouldn't be so keen on acquiring horizontal scroll bars and never
letting them go when their width is decreased now. Frames set up for
'scrolling="yes"' will not start with no scroll bars and then gain them
shortly afterwards, causing flicker and two reformats - they'll start
with, and continue to hold, both scroll bars.

Pointer shouldn't flicker when over a frame border whilst other fetches
are progressing now.
@
text
@d85 1
d89 1
d96 1
d136 1
d144 5
d451 1
d455 1
a455 1
    /* Export the document as text */
d465 9
d919 1
a919 1
      e = savetext_save_text(save_as_text_browser, path);
d933 10
d1220 1
a1220 1
  if (found != 1)
d1283 1
d1651 1
d1653 2
a1654 1
  ComponentId c;
a1705 2
    int  apptoapp = m->hdr.your_ref ? 1 : 0; /* your_ref is zero if from filer, else filled in for app to app */

d1905 35
a1939 1
          if (b && !b->small_fetch) ChkError(fetchpage_new(b, url, 1, 0));
d2565 14
a2578 1
                if (b && !b->small_fetch) e = fetchpage_new(b, ram_load_uri_buffer, 1, 0);
d3099 10
d3561 1
@


1.22
log
@Programming warehouse link removed from all hotlists - the page has gone.

Some compile-time hacks in place to use MemLib, a dynamic area based
malloc replacement which shrinks its heap when possible. All builds
have these switched off at the moment. Seemed to work with just Browse,
though there would be problems with message blocks stored in dynamic
areas because of the Wimp's '&3800000' check - however, it failed when
HTMLLib was made to use it, too. Don't know why yet.

ItemInfo.[c/h] source added, with Res file additions for testbed Browse
and Phoenix.

Small fetch windows now work properly regardless of toolbar settings
in the Choices.

Reload now reloads all images too, rather than only reloading them for
as long as the main page was being fetched.

Added a simple 'Find' facility.

Realised that event handlers in eventlib are called in reverse order
of registration, so the miscellaneous event handler is now registered
first rather than last.

Multiuser code added (most only active if SINGLE_USER is undefined). As
part of this, hotlist code now knows about read-only items (done for the
Customer-style 'Resources' file, but works generally anyway).
handle_add_hotlist doesn't try to save the hotlist itself anymore (the
hotlist_add function does all that through hotlist_modified anyway).

Customer build Choices and Controls updated slightly (e.g. ClaimHelp
off, hotlist to save on quit only).

Customer build now uses Phoenix-style buttons. Sprites files which
worked at the time (but will probably be out of date now) and included
most of the original Customer-style sprites are in
'Utils.Icons.Customer'.

Choices, Messages and Res files for all builds now stripped down to only
single user items or single plus multiuser for Customer build and testbed
build. Before, all contained a few multiuser bits in at least the Choices
file if not more.

Grammatical error ("Fetching frames contents" (sic.)) corrected in
default message, Toolbars.c, and all of the Messages files.

Customer build brought back to a servicable level (including
implementation of the Find dialogue box with animation and fixing
up authorisation and 'Stop' state in the tristate). Quite a few
missing #ifndef REMOTE_HOTLIST bits from hotlist code added...

Customer build will not use <Choices$Write> or Boot:Choices for any
file finding now. UseProxy defaults to 'yes', MaxImages to 2. Res
file includes Proxy Address setting (save_save_choices() now writes
the ProxyAddress line).
@
text
@d82 1
d2920 46
d2986 8
a3104 21

  return NULL;
}

/*************************************************/
/* protocols_auh_got_dying()                     */
/*                                               */
/* Handle reception of a URI_MDying - the URI    */
/* handler is closing down.                      */
/*                                               */
/* See 1307,260/FS.                              */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/

_kernel_oserror * protocols_auh_got_dying(WimpMessage * m)
{
  /* If the URI handler is dying, don't try and use it anymore... */

  uri_module_present = 0;
@


1.21
log
@RefoSingle option added to Controls.

Precautions taken in table code to avoid divide by zero errors.

Framesets defining more frames than the frameset implies, for whatever
reason, should never cause a crash now - just report a 'Frames definition
is badly nested' error (if STRICT_PARSER defined). Along the same lines,
in a single document defining a set of nested frames, two /FRAMESETs in
succession could cause a fairly nasty crash. Fixed.

TIFFs do not get loaded by double-click now.

If holding down SHIFT to save a link contents to disc, you can also hold
down CTRL to bypass the cache (sets the browser's reloading flag). Noticed
when testing this that windows_create_browser didn't take account of the
Controls file 'UseSmall' entry when adjust-shift-clicking on links. It
does now.

There is now a complete and up to date set of interactive help messages
built into the Ursula, Customer and Phoenix build Res files.
@
text
@d972 1
a972 1
      e = hotlist_save_hotlist(path, 1);
d984 1
a984 1
      e = hotlist_save_hotlist(path, 0);
d1679 28
d2951 7
d2977 17
@


1.20
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d1576 1
d1582 1
@


1.19
log
@Enabled printing when Printer Manager not present
@
text
@d639 1
d648 2
a649 1
        char * url = browser_current_url(save_link_browser);
d654 1
d665 10
a674 7
    if (
         is_known_browser(save_location_browser)
       )
       return save_transfer_uri(browser_current_url(save_location_browser),
                                save_location_as_url,
                                &save_location_transmitted,
                                m);
d687 1
d921 1
a921 1
        e = save_save_uri(path, save_link_token->anchor, save_link_as_url);
d926 3
a930 2
        char * url = browser_current_url(save_link_browser);

d933 1
a933 1
        e = save_save_uri(path, url, 0);
d944 3
a946 1
      e = save_save_uri(path, browser_current_url(save_location_browser), save_location_as_url);
d959 1
a959 1
        e = save_save_uri(path, save_hotlist_entry_item->data.url, save_hotlist_entry_as_url);
d1618 2
a1619 1
  int filetype = m->data.data_load.file_type;
d1625 12
d1668 3
a1670 1
    char url[Limits_URL];
d1728 1
a1728 1
      urlutils_load_uri_file(url, sizeof(url), m->data.data_load.leaf_name);
d1777 1
a1777 4
              /* For the description, use the source leafname, unless this */
              /* is from another app (your_ref is non-zero), in which case */
              /* use the URL, as <Wimp$Scrap> isn't very friendly or       */
              /* unique.                                                   */
d1779 6
a1784 1
              if (!m->hdr.your_ref) leaf = strrchr(m->data.data_load.leaf_name, '.');
d1786 5
a1790 2
              if (!leaf) leaf = url;
              else       leaf ++;
d1794 1
a1794 1
                                            leaf,
d1899 3
a1901 2
  _kernel_oserror * e   = NULL;
  int               ram = 0;
d1903 1
d1909 12
d1924 2
a1925 2
       m->data.data_save.file_type == FileType_URI ||
       m->data.data_save.file_type == FileType_URL
d2008 2
a2009 2
  reply->hdr.your_ref       = m->hdr.my_ref;
  reply->hdr.action_code    = Wimp_MDataSaveAck;
d2042 3
a2044 3
      raf->hdr.size         = 28;
      raf->hdr.your_ref     = m->hdr.my_ref;
      raf->hdr.action_code  = Wimp_MRAMFetch;
d2263 15
a2277 1
    switch (pending_data_save_ack->data.data_save_ack.file_type)
d2406 1
a2406 2
          /* For URI files, parse the contents - this call leaves the */
          /* URI the file contained at the head of the buffer.        */
d2408 1
a2408 4
          if (pending_data_save_ack->data.data_save_ack.file_type == FileType_URI)
          {
            urlutils_extract_uri(ram_load_uri_buffer, ram_load_buffer_size);
          }
d2441 16
a2456 4
                  ChkError(hotlist_add_position(pending_data_save_ack->data.data_save_ack.destination_x,
                                                pending_data_save_ack->data.data_save_ack.destination_y,
                                                ram_load_uri_buffer,
                                                ram_load_uri_buffer));
@


1.18
log
@Not all resources are up to date in this check-in, and documentation
both within source and stuff in 'Docs' is out of date or missing - I
was very pushed for time on this one... Hopefully will do another
'tidy up' check-in before close on Friday; until then, beware of
anything other than the Ursula (Desktop browser) build. Anyway...

Export As Draw done. As part of this, FONT SIZE and SUP / SUB adjustment
of font size is done in fm_token_font_info rather than fm_find_token_font.

Bullets and switches are plotted as indirected sprite items, rather than
indirected text + sprite items - this relied on being in a redraw loop to
pick the sprites up from the local pool (failed during printing).

URI files now have a LF line ending rather than CR... '*' recognised
as an empty field when loading via. RAM transfer now (only worked for
loading from disc before).

Gave placeholder bounding boxes 4 OS units more minimum extra gap
vertically and reduced horizontal addition to this value * 1.5, rather
than * 2 (see reformat_get_placeholder_size).

Background image tiling starts at ymax - h + 4, rather than ymax, so
there isn't the bottom line of pixels from the top tile always present
at the top of the window. The '+4' is for caution's sake.

Can now save a frame's HTML source, that of its parent or its ancestor,
and the same for the URI pointing to those documents - see Menus.h for
the relevant component IDs that should lead to the SaveFile dialogue.

Have hopefully fixed timeout = 0 values (i.e. 'forever') on things
like LinkTo; before, image fetches could override the state (so you'd
only ever see brief flickers of a given URL as the pointer went over
a link).

Save File dialogue will remember the state of option or radio buttons
for a given parent component origin and restore that state when the
dialogue is next opened from the same place (stops turning on saving
as a URL file also turning on 'save background images' for Draw file
export, etc.).

Use of a META tag to reload the *same* page now sets the 'reloading'
flag in the browser so that it doesn't go through a proxy - otherwise
pages which are meant to update periodically through client pull
don't work, as they keep coming out of the cache.

Can now handle images specifying just a width or height in the HTML
(other dimension is scaled accordingly, but note that the placeholder
size must still be 'dumb' until the image data comes in). An image
will now override an image history size entry for the same entry
with a different size.
@
text
@d2578 1
a2578 1
  if (m->hdr.your_ref && m->hdr.your_ref == print_save_reference)
d2589 1
a2589 1
    else if (m->hdr.your_ref)
@


1.17
log
@Note that the 'Docs' documentation (possibly contrary to previous
log messages) still hasn't been updated with the new SaveFile
stuff, and function header comments have yet to be written for
SaveFile.c.

Fixed urlutils_pathname_to_url - OS_GSTrans doesn't like the same
input buffer as output buffer (fairly obvious, but I was living in
the hope of not having to duplicate the input path string).

Image history will not cache scrap file images anymore. Browser's
image handling library won't cross reference them either.

When dragging a single item from the hotlist to a Filer window, the
code now checks Ctrl - if held down, a URL file is written, else a
URI file. The state of any option buttons or radios in the last
Save File dialogue that was opened is no longer relevant...!

history_save_as_html could write out broken files when titles
for items in the History were not present. Fixed.

Hourglass switched on for hotlist and history saving as HTML;
hotlist_save_entries no longer closes the output file on error
(it should be done by the caller, since the caller is responsible
for opening the file and passing the FILE * pointer to
hotlist_save_entries).
@
text
@d90 1
d133 6
d444 10
d896 10
d1242 1
d2589 1
a2589 1
    else
d2774 1
a2774 1
    else
d3319 1
@


1.16
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d469 1
a469 1
        save_hotlist_entry_as_url          = savefile_alternative_selected();
@


1.15
log
@Image history can be emptied from the History menu.

Significant reduction in number of times reformatter is called during
a table widthing session results in a dramatic speed increase for nested
tables (e.g. 64 deep with a paragraph of text in the deepest table takes
about two seconds to load with near-instantaneous subsequent reformats,
as opposed to taking optimistically 28 days for a 32 deep table!).
This code relies on a very big stack of assumptions...

Save as plain text implemented.

Choices, Messages and Res files brought up to date where necessary.
Version number taken to 1.28, 04-Dec-97 (so I don't forget later,
basically...).
@
text
@d68 1
a68 1
#include "URI.h"     /* URI handler API, in URILib:h */
d138 1
d145 1
d154 1
d182 5
a186 4
static int            save_sprite_reference              = 0;
static int            save_sprite_transmitted            = 0;
static browser_data * save_sprite_browser                = NULL;
static HStream      * save_sprite_token                  = NULL;
d227 1
a227 2
  _kernel_oserror * e;
  WimpMessage       dop;
d379 1
a379 2
  _kernel_oserror * e;
  WimpMessage       m;
d445 1
d456 1
d469 1
d508 5
a512 4
      save_sprite_reference              = m.hdr.my_ref;
      save_sprite_transmitted            = 0;
      save_sprite_browser                = b;
      save_sprite_token                  = (HStream *) extra;
d622 1
a622 1
                                 0,
d635 1
a635 1
                                 0,
d649 1
a649 1
                                0,
d664 1
a664 1
                                  0,
d702 1
a702 2
  _kernel_oserror * e;
  int               old_ref = m->hdr.your_ref;
d849 1
a849 1
  int               ok   = 0;
d887 1
a887 1
        e = save_save_uri(path, save_link_token->anchor, 0);
d909 1
a909 1
      e = save_save_uri(path, browser_current_url(save_location_browser), 0);
d922 1
a922 1
        e = save_save_uri(path, save_hotlist_entry_item->data.url, 0);
d1018 1
a1018 1
  else if (m->hdr.your_ref && m->hdr.your_ref == save_sprite_reference)
d1020 1
a1020 1
    if (is_known_browser(save_sprite_browser))
d1022 65
a1086 2
      e = image_export_sprite(path, save_sprite_browser, save_sprite_token);
      if (!e) ok = 1;
d1094 1
a1094 1
    e = protocols_atats_send_data_load(m);
d1129 2
a1130 3
  _kernel_oserror * e;
  int               old_ref = m->hdr.your_ref;
  int               found   = 0;
d1227 1
a1227 1
       m->hdr.my_ref == save_sprite_reference              ||
d2490 1
a2490 2
  _kernel_oserror * e;
  WimpMessage       m;
d2720 1
a2720 2
  _kernel_oserror * e;
  WimpMessage     * ptk = m;
a2810 1
  _kernel_oserror   * e;
a2879 1
  _kernel_oserror        * e;
d3025 2
a3026 1
    _kernel_oserror         * e;
a3027 2
    browser_data            * b = NULL;
    WimpGetPointerInfoBlock   i;
d3079 2
a3080 1
    _kernel_oserror         * e;
a3081 2
    browser_data            * b = NULL;
    WimpGetPointerInfoBlock   i;
a3223 2
    _kernel_oserror * e;

d3303 1
a3303 1
  else if (old_ref == save_sprite_reference)              save_sprite_reference            = new_ref;
@


1.14
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d92 1
d115 1
a115 1
/* a lot of statics are needed.                               */
d127 5
d426 9
d864 10
d1147 1
d3231 1
@


1.13
log
@Removed 'The Onion' link from some Hotlist files. Time showed that the
site wasn't entirely Family Friendly (TM)... Removed Shift Control (it's
gone offline now), and corrected the Telegraph URL from ...the-telegraph...
to just ...telegraph...

StrongHelp manual generator now tries to work out the number of lines in
the table on the root page more intelligently.

Plug-in support extended to handle Shockwave. Quite a lot of underlying
work for this, including a pseudo cache system for temporary files.

Bug in redraw routines: they plotted background images within table
cells, when nothing should have been drawn. Oops. When background images
in cells are properly supported, this can get sorted out.

Tweaked vertical plot position of HRs (up to 4 OS units too high before due
to rounding).

Various Res file bits and pieces, Ursula build taken up to v1.26 beta
for release on the Browser site. *Note* not all resources are up to date!
This will be done after AW97.
@
text
@d84 1
d87 1
d159 5
d493 17
d923 15
d1134 2
a1135 1
       m->hdr.my_ref == save_sprite_reference
d1441 4
a1444 5
  /* Don't want to load a text file from double-clicking, */
  /* only by dragging to a window or the icon bar icon.   */
  /* Similarly, ANT's URL files should only be loaded if  */
  /* dragged on, and the same is true of URI files if we  */
  /* are using the URI handler.                           */
d1448 2
d1487 2
d1493 18
d1514 8
a1521 8
       m->data.data_load.file_type == FileType_HTML ||
       m->data.data_load.file_type == FileType_TEXT ||
       m->data.data_load.file_type == FileType_GIF  ||
       m->data.data_load.file_type == FileType_JPEG ||
       m->data.data_load.file_type == FileType_PNG  ||
       m->data.data_load.file_type == FileType_TIFF ||
       m->data.data_load.file_type == FileType_URL  ||
       m->data.data_load.file_type == FileType_URI
d1528 1
a1528 1
      if (tl & (1u<<28)) Printf("protocols_atatl_got_data_load: Can handle this filetype (0x%03x)\n", m->data.data_load.file_type);
d1534 2
a1535 2
         m->data.data_load.file_type != FileType_URI &&
         m->data.data_load.file_type != FileType_URL
d1553 2
a1554 2
             m->data.data_load.file_type == FileType_TEXT ||
             m->data.data_load.file_type == FileType_HTML
d1596 1
a1596 1
      ChkError(windows_create_browser(url, NULL, NULL, NULL, 0));
d1609 2
a1610 2
             m->data.data_load.file_type == FileType_URI ||
             m->data.data_load.file_type == FileType_URL
d1653 1
a1653 1
        if (m->data.data_load.file_type == FileType_HTML)
d2239 1
a2239 1
            e = windows_create_browser(ram_load_uri_buffer, NULL, NULL, NULL, 0);
d2754 1
a2754 1
      else RetError(windows_create_browser(uri->uri, NULL, NULL, NULL, 0));
d3145 1
a3145 1
                                    0));
d3218 1
@


1.12
log
@More reformatter code bugs fixed; this one regarding width of items. Any
kerned string was overestimated (causing redraw bugs and caret position
problems in forms, apart from other minor bits elsewhere) and the default
size of a writable icon wasn't especially clever.

Crude Plug-In support; just about manages Java, but can't fetch on
behalf of Plug-In (for example). Had to change the default file access
URL construction to be 'file:/' instead of 'file://', or local file
fetches that reference Java applets won't work. This is in its very
early stages, and is being checked in mostly so that various Choices
issues can be worked on.
@
text
@d557 1
a557 1
  if (m->hdr.your_ref == save_source_reference)
d568 1
a568 1
  else if (m->hdr.your_ref == save_link_reference)
d596 1
a596 1
  else if (m->hdr.your_ref == save_location_reference)
d611 1
a611 1
    else if (m->hdr.your_ref == save_hotlist_entry_reference)
d815 1
a815 1
  if (m->hdr.your_ref == save_source_reference)
d825 1
a825 1
  else if (m->hdr.your_ref == save_link_reference)
d849 1
a849 1
  else if (m->hdr.your_ref == save_location_reference)
d862 1
a862 1
    else if (m->hdr.your_ref == save_hotlist_entry_reference)
d877 1
a877 1
    else if (m->hdr.your_ref == save_hotlist_selection_reference)
d889 1
a889 1
    else if (m->hdr.your_ref == save_entire_hotlist_reference)
d899 1
a899 1
  else if (m->hdr.your_ref == save_object_reference)
d949 1
a949 1
  else if (m->hdr.your_ref == save_sprite_reference)
d2397 1
a2397 1
  if (m->hdr.your_ref == print_save_reference)
d2570 1
a2570 1
  if (m->hdr.your_ref == print_save_reference)
d3113 2
a3114 2
  if (m->hdr.your_ref == print_save_reference) return protocols_pp_got_data_save_ack(m);
  else                                         return protocols_atats_got_data_save_ack(m);
@


1.11
log
@!Run[D] files updated for new fetchers and GopherFetcher; protocols list
in Controls updated for Gopher. Debug builds now require 2760K rather than
2560K. Font$... variables set if not already, in anticipation of font
Choices work.

Additional bits in Choices section of Res file tidied and some name
changes (e.g. Netscape -> Navigator(TM)). Frames support option added
to Choices.

Grouped 'support_frames' under the Fetch Controls section and added
support_object in Global.h; appropriate entries placed in the Choices
files, and are read at startup. At present, though, only the frames
support flag is implemented.

For some reason, Menu was the button to use on history popups if you
wanted to show URLs instead of descriptions (or vice versa, depending
on Choices settings). Now, Select and Menu will show the Choices
defined setting, and Adjust will show the opposite.

History menus are built backwards, so local histories have the most
recently visited pages at the top. Global history has still no real
order to it, but this may be arranged later.

Customer name changed to Customer by request.

Customer browser now gets its own resources (SYSTEM=Customer), but
otherwise is unchanged, with the Ursula build now giving the
'spinning acorn' with a Bookworm-style toolbar. This is used for the
Desktop !Browse build.

!Sprites[22] files updated to include GIF, JPEG and PNG sprites;
!Run[D] files and !Boot files set appropriate File$Type_xxx variables.
Sprites in all sprites files have been checked for unnecessary palettes,
which have been removed where present.
@
text
@a194 1
static void              protocols_util_make_unique_name   (char * buffer, int buffer_size);
d1397 4
d3196 1
a3196 1
static void protocols_util_make_unique_name(char * buffer, int buffer_size)
@


1.10
log
@Tidied up Hotlist source a bit more, mostly so PSI can use the automatic
StrongHelp generator on it. Revealed a spurious toolbox_hide_object call
that would always fault and never do anything, and a few heinous uses
of show_error which have all been removed.

When dragging hotlist items, directories will now be highlighted whenever
the item would be added to them, rather than just over the sprite. In
practice this only changes if the item is open and has contents...

Drag box selections had broken in the hotlist; fixed (uninitialised
variable in hotlist_select_box). Adjust-drags now close the window on
completion. Minor problem with Shift+Drag (copy) reversing order of items
sorted out. Added hotlist_add_html_file and implemented loading of HTML.
DO NOT add broken HTML files, this has not been coded for and URLs of the
form http:///this/that (no host name) will hang the machine (bug in the
cookie code of the HTTP module up to at least version 0.39).

Made SELECT list items only as wide as the widest entry actually appears
(using fm_get_string_width), rather than as wide as the widest character
BBox in the font multiplied by the string length of the longest entry.

Updated !Run[D] files to require HTTP 0.39, FTP 0.12 and File 0.23.
@
text
@d47 5
@


1.9
log
@Now working on source merged with Kevin Bracey's internationalisation
support. UNIFONT is undefined in the Make File for now. All Res and
Choices files updated appropriately.

Having sorted out the old Choices and Messages to form Choices, Controls
and Messages, this build has had the same cleaning up done internally.
This includes greater consistency in naming schemes and the removal of
the inconsitent choices items - e.g. Choices file entries saying 'delay
images' and 'plain backgrounds' where internally all the flags say 'show
images' and 'show backgrounds'. ChoiceDefs.h and CtrlDefs.h added to
clarify the meaning of some fields, though usage of these is not 100%
in the source (there are cases where parameters are passed through to
functions as ints, and those functions still check these against hard
coded values rather than the #define stuff).

Fetcher status return bits (connected, sent request, etc.) now reflected
in status bar. Progress during fetchs to files are reported by %, where
the size of the object is known. Exceeding 100% drops back to a byte
counter, in case the estimated size was wrong. The progress counter
may be updated after specific delays, rather than 'as often as possible',
to reduce flicker (as requested by D.Brown some time ago).

I've done a small rewrite of the fetch prioritisation scheme in FetchPage.c;
how well this performs in general use across different processor speeds
remains to be tested, but certainly it has some advantages. For each small
fetch window before the rewrite, a 4cs tight loop was entered - this gave a
noticable and substantial drain to the Desktop performance if more than one
was opened. Now, several can be up at once with little hit. The actual file
fetch is on half the priority it was before, with all others taken back
just a bit - e.g. from 20cs per poll to 15cs per poll for flat out
reformatting. You don't seem to lose much time on the format in practice,
and the Desktop feels quite a bit lighter at the same time. There's the
potential for smoother frameset loading in this scheme, too.

When Shift+Clicking on a link meant you still fetched inside the main
browser window, several fetches could occur in a frameset - one per frame.
However, now that you can only do this by clicking on a link that leads to
non-displayable data - or by turning off the small fetch windows by
setting UseSmall to 'no' in Choices - a bug where fetchpage_preprocessed
would stop such fetches as new ones were started was revealed.
The API to frames_abort_fetching has now been extended to include a
'stop file spooling too' flag, allowing a fix to be made by having
fetchpage_preprocess's calls not set this (and it doesn't check the
savelink flag is unset before proceeding, since frames_abort_fetching
does that implicitly now).

Had left the RAM transfer buffer at 16 bytes (from testing) accidentally...
Oops. Upped it to 4K. In addition, when loading data by RAM transfer,
the browser didn't notice if a RAMFetch bounced during the transfer. It
would be treated as a 'first' RAMFetch bounce, basically, and try to go to
file transfer - oops. Fixed.
@
text
@d1582 33
@


1.8
log
@Support for ANT URL broadcast message added.

Image deletion routines rewritten; nasty animated GIF bug now gone
(it kept trying to update the cross-referenced image in the browser that
no longer existed, and I've no idea how animated GIFs ever managed to *not*
blow up if a cross referencing browser was shut down; and I've tested
this...). There are now as many image structures as there are total images
in the visible browsers, and no more; cross referenced images in the
to-be-deleted browser have their ownership moved to the cross
referencer before the cross referencee is wiped, with any required fetches
being transferred with them.

Reformatter sped up a bit by getting rid of strlen on the main text field
of tokens in all places bar one, where it is called extremely rarely. This
means direct app-to-app transfer of, say, a 359K text file to the browser
won't run like a drain as it tries to do strlen on a 359K string over and
over again! Most of the time the performance benefits won't really be
noticable, but on the above text file, formatting time went down from
290 seconds before the change to just under 7 seconds, a 41 fold speed
increase or thereabouts (SA110 228MHz).

MakeFile changed to force function name compilation on for debug builds
(-fn in the DD...FLAGS); useful for certain functions such as
register_null_handler, which can now output the name of the function
being registered.

...Which helped show up some nasties in the animation handler and animation
drift handler registration/deregistration process, which have been fixed
(callers of fetchpage_release_nulls were unaware that the drift handler
could be installed, and fragments of old code checking choices.anim_drift
had a value other than 1 or 0 were still hanging around - bit tricky for
a single bit item).

Added support for VALIGN in table cells. Spotted a bug or two in the
'what token is the pointer over' routines as a result, and fixed them - the
worst was in browser_line_at_y, which checked the y coordinate was below
the given one [the mouse], but didn't check the line height to see if the
given y coordinate was *within* the line, rather than just above it. Never
used to matter pre-tables, but a definite concern once multiple line
arrays can exist on one page.
@
text
@d99 1
a99 1
#define RTB_Size 16 /* RAM transfer buffer size, in bytes */
d166 3
a168 1
/* Loading files */
d172 2
d176 3
a178 1
static void         * rtb                                = NULL;
d840 2
a841 1
        return save_save_uri(path, url, 0);
d1797 4
d1832 10
d1851 1
a1851 1
    if (tl & (1u<<28)) Printf("protocols_atat_ram_fetch_bounced: Called\n");
d1854 1
a1854 1
  if (m->hdr.my_ref == ram_fetch_reference && pending_data_save_ack)
d1856 36
a1891 1
    _kernel_oserror * e;
d1893 2
a1894 3
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atatl_ram_fetch_bounced: This is a recognised message bounce\n");
    #endif
d1896 4
a1899 2
    /* Before doing this, make sure Scrap is present - the call */
    /* will raise an error if not, before returning here        */
d1901 5
a1905 1
    if (utils_check_scrap()) return NULL;
d1907 1
a1907 1
    /* Send the pending message */
d1909 4
a1912 5
    e = wimp_send_message(Wimp_EUserMessage,
                          pending_data_save_ack,
                          pending_data_save_ack->hdr.sender,
                          0,
                          NULL);
d1914 5
a1918 1
    /* Free the block and return any error that may have been generated */
d1920 1
a1920 2
    free(pending_data_save_ack);
    pending_data_save_ack = 0;
d1922 6
a1927 1
    return e;
d1957 5
a1961 1
  /* Flag if we've finished */
d1975 1
a1975 1
              "Expected to get buffer %p but got %p instead, in protocols_atat_got_ram_transmit",
d2006 1
a2006 3
        static char * uri_buffer  = NULL;
        static int    buffer_size = 0;
        int           first       = 0;
d2008 5
a2012 1
        /* Only proceed if any bytes were transferred */
d2018 1
a2018 1
          if (!uri_buffer)
d2027 2
a2028 2
            uri_buffer = malloc(m->data.ram_transmit.nbytes + 1);
            first      = 1;
d2032 1
a2032 1
            if (!uri_buffer)
d2044 1
a2044 1
                if (tl & (1u<<13)) Printf("** malloccount (protocols_atat_got_ram_transmit): \0211%d\0217\n",malloccount);
d2055 1
a2055 1
            local = realloc(uri_buffer, buffer_size + m->data.ram_transmit.nbytes);
d2061 2
a2062 2
              free(uri_buffer);
              uri_buffer  = NULL;
d2065 2
a2066 2
                malloccount -= buffer_size;
                if (tl & (1u<<13)) Printf("** malloccount (protocols_atat_got_ram_transmit): \0212%d\0217\n",malloccount);
d2069 1
a2069 1
              buffer_size = 0;
d2080 1
a2080 1
              uri_buffer = local;
d2084 1
a2084 1
                if (tl & (1u<<13)) Printf("** malloccount (protocols_atat_got_ram_transmit): \0211%d\0217\n",malloccount);
d2094 1
a2094 1
            memcpy(uri_buffer + buffer_size - !first,
d2102 1
a2102 1
            buffer_size += m->data.ram_transmit.nbytes + !!first;
d2108 2
a2109 2
              if (tl & (1u<<28)) trace_dump_buffer(uri_buffer,
                                                   buffer_size - 1,
d2112 12
d2125 2
a2126 1
            /* If the transfer has finished, fetch the URL */
d2128 4
a2131 5
            if (finished)
            {
              /* Remember we allocated 1 byte more than needed at the start, */
              /* so that this terminator could be inserted. This is required */
              /* for URL files, and won't hurt for URI files.                */
d2133 3
a2135 1
              uri_buffer[buffer_size - 1] = 0;
d2137 2
a2138 2
              /* For URI files, parse the contents - this call leaves the */
              /* URI the file contained at the head of the buffer.        */
d2140 1
a2140 1
              if (pending_data_save_ack->data.data_save_ack.file_type == FileType_URI) urlutils_extract_uri(uri_buffer, buffer_size);
d2142 7
a2148 3
              if (pending_data_save_ack->data.data_save_ack.destination_window <= 0)
              {
                /* The original Message_DataSave was for no specific window */
d2150 1
a2150 2
                e = windows_create_browser(uri_buffer, NULL, NULL, NULL, 0);
              }
d2152 9
a2160 1
              #ifndef REMOTE_HOTLIST
d2162 1
a2162 1
                else
d2164 4
a2167 2
                  /* As with DataLoad, this can go to a Hotlist window or a browser; */
                  /* the hotlist is the simpler case, check that first.              */
d2169 3
a2171 2
                  ObjectId this;
                  int      handled = 0;
d2173 3
a2175 1
                  /* If we can get the window object ID... */
d2177 1
a2177 24
                  if (
                       !window_wimp_to_toolbox(0,
                                               pending_data_save_ack->data.data_save_ack.destination_window,
                                               -1,
                                               &this,
                                               NULL)
                     )
                  {
                    /* ...and it matches that of the hotlist, add the item. */

                    if (this == hotlist_return_window_id())
                    {
                      ChkError(hotlist_add_position(pending_data_save_ack->data.data_save_ack.destination_x,
                                                    pending_data_save_ack->data.data_save_ack.destination_y,
                                                    uri_buffer,
                                                    uri_buffer));

                      handled = 1;
                    }
                  }

                  if (!handled)
                  {
                    browser_data * b;
d2179 1
a2179 1
                    /* The message was for a specific window, so find out which one */
d2181 3
a2183 1
                    utils_browser_from_window(pending_data_save_ack->data.data_save_ack.destination_window, &b);
d2185 1
a2185 3
                    if (b && !b->small_fetch) e = fetchpage_new(b, uri_buffer, 1, 0);
                  }
                }
d2187 2
a2188 1
              #endif
d2190 4
a2193 7
              free (uri_buffer);
              uri_buffer = NULL;

              #ifdef TRACE
                malloccount -= buffer_size;
                if (tl & (1u<<13)) Printf("** malloccount (protocols_atat_got_ram_transmit): \0212%d\0217\n",malloccount);
              #endif
d2195 1
a2195 1
              buffer_size = 0;
d2197 1
a2197 3
              if (!e) ok = 0;
            }
          }
d2210 1
a2210 1
                  "Unrecognised filetype 0x%03x (%x) in protocols_atat_got_ram_transmit",
d2245 1
a2245 1
    e = wimp_send_message(Wimp_EUserMessage,
d2250 2
d2254 1
a2254 3
  /* Free the RAM transfer buffer, if required; we no  */
  /* longer have a pending Message_DataSaveAck either, */
  /* so can free that too.                             */
d2258 2
d2263 7
d2272 4
d2277 1
a2277 1
      pending_data_save_ack = 0;
a2278 5

    #ifdef TRACE
      malloccount -= RTB_Size;
      if (tl & (1u<<13)) Printf("** malloccount (protocols_atat_got_ram_transmit): \0212%d\0217\n",malloccount);
    #endif
d2754 1
a2754 1
  /* Only proceed if the fixed choices say to do so */
d2756 1
a2756 1
  if (fixed.claimhelp)
d2832 1
a2832 1
  if (fixed.claimhelp)
d2887 1
a2887 1
  if (fixed.claimhelp)
@


1.7
log
@Added 'save current location'. Res files updated appropriately. Version
number taken to Beta-3; next will be 1.21, including K.Bracey's i18n code.
@
text
@d32 1
d73 1
d2861 108
@


1.6
log
@Got the deferred reformatter working properly. It doesn't do that 'OK,
the page is fetched and reformatted, but just to annoy you, I'm going
to wait 5 seconds and then suddenly reformat the whole thing again'
trick anymore. The fetcher was calling the reformatter in a delayed
form even when the reformatter was already running, so it would carry
on past the reformat point or from below what had become and invalidated
line, and some time later, get back to the delayed reformat. Now,
reformatting is only delayed by the fetcher when the reformatter is not
running. In practice this means body text reformats as it fetches, but
large tables will show delayed reformatting - which was exactly the
intended behaviour of the feature when it was originally thought of.

fetch_token_data_address removed; it was only needed in two places,
both of which already knew when to read tp->text and when to ignore
it. Its functionality is duplicated in an 'if' involving reformat_istext,
anyway.

!Run[D] files taken back to requiring HTTP 0.33, since 0.36 introduces
many weird and wonderful problems.

Typo in Messages files, 'All current images (sic.) fetches finished' -
'images' is now 'image'.

Shift+Click saving - you could save to an application. No problem. But
the equivalent (just clicking on a link that led to an unknown datatype
and getting the save dialogue that way) didn't work. It does now.
Another problem was saving to an application that didn't support the
datatype - oops, the dialogue would close but the fetch would sit there
waiting to be told where to save. It doesn't close now (as expected).

NB, doing several simultaneous fetches to a text editor may have problems
as the editors are too clever for their own good. Despite receiving
DataLoad messages for <Wimp$Scrap> for files of different types, sizes
and datestamps, the editors can decide it's still the same file and:

Zap      - Hats off, it gets it right, almost. You do get warned 'Multiple
           copies - one on disc is newer' as everything after the first
           text loads, but they do load, and in separate windows.
StrongED - Does not load the subsequent files, so the browser gives 'Data
           transfer failed' errors and opens up Scrap. Turning off 'Don't
           load same file twice' fixes it - each file is loaded in a new
           window with no warnings. At least in the first case, you don't
           lose data, since the files are kept in Scrap.
Edit     - Each time it loads the file, it *replaces* the other one in
           memory, using the same window for each. This is the worst
           behaviour as it isn't configurable (well, I don't know of a way
           to change it...) and results in data loss as successive texts
           get trounced by the new data.

I can't see how I can fix this in the browser as it's basically silly
behaviour on behalf of the editors. Other applications which don't try
to work out if it's a new file or not are fine!

When conducting image fetches, proxying is allowed unless reloading.
When conducting page fetches, proxying was never allowed - so web cache
stuff would have been, er, interesting. It now sets X-NoProxy: in the
request header when reloading, but otherwise this is not included.

AnimSpeed is, at last, independent of browser poll speed. They used to
be tied together. Guess how the animation code used to work ;-)

'Can't handle this datatype' - deprecated now that save dialogues can be
popped up. The 'can't save objects in full screen mode' error would never
be shown due to a bug, anyway; this now replaces 'can't handle', which
has been removed from all Messages files.

RefoWait, RefoHang and RefoTime moved from Controls back to Choices.

Trying to get rid of strlen in the reformatter - it can get very slow
(e.g. strlen of 8K chunks of text, or if a 330K text file is transferred
from a text editor straight to the browser, strlen of a 330K string...).
There will be unfinished bits of code in the reformatter that may seem
unnecessary - they've just not been plugged in yet (since they don't
actually work). Don't remove them!
@
text
@d558 16
a573 1
    /* Save a link as a URI file */
d575 8
a582 8
    if (
         is_known_browser(save_link_browser) &&
         save_link_token
       )
       return save_transfer_uri(save_link_token->anchor,
                                0,
                                &save_link_transmitted,
                                m);
d815 14
a828 1
    /* Save a link as a URI file */
d830 4
a833 7
    if (
         is_known_browser(save_link_browser) &&
         save_link_token
       )
    {
      e = save_save_uri(path, save_link_token->anchor, 0);
      if (!e) ok = 1;
@


1.5
log
@As warned in the last log, pretty much all event codes and component IDs
have now changed along with many of the names, to provide a consistent
name and numberspace for events and components. This also minimises
number clashes (e.g. as was, the Save File origin when opened from a
Hotlist menu with an already-used component ID). To get full details on
this, please carefully read through TBEvents.h.

Res files, Sprites files and Messages files have been updated again both
due to the above, and routine additions (e.g. message support for a few
Hotlist bits and pieces). !Run[D] files updated for FTP 0.11 and
HTTP 0.36.

In the Makefile, the Customer objects list was missing Save - must have
moved something when I should've copied it, when adding in SaveFile or
SaveObject in all probability. Now fixed. Couple of other bits and bobs
fixed in the build environment (e.g. stuff saying !Argo instead of
!Customer). Oh, and I've altered the MakeFile copy options again to the
best compromise I can come up with. Newer is turned on for everything
except !Run[D] and !RunImage, since both of those change between debug
builds - otherwise if you'd built debug and non-debug versions, it was
not possible to switch between them - one version would have the newer
timestamp and thus never get overwritten.

The default hotlist has had a few items added - that'll be about the end
of it, I think; there's more than enough stuff in there now.

Saving of the hotlist from the document menu and of URI files,
directories and selections from the hotlist menu tree is now implemented
- this new save system rocks... Oh, and you can save all images and
backgrounds as sprites.

Saving of items with Shift+Click to other applications directly now
works, and is robust. Unique Scrap filenames are used, with data load
bounces (e.g. if some pra - er, person quits the app they're sending
to) working correctly - that is, give an error, keep the file, rename
it to something safe, and open the directory it lies in. As opposed
to normal app-to-app bounces, where the scrap file is deleted (see
PRM 3-254). This means you can now look at README files in FTP
sites, say, without using a disc intermediate. Or you can send pictures
straight to ChangeFSI, fetch HTML links into editors, and so-on, and
so-on - it's all very funky. Known problems include the ambiguous
'invalid component ID' instead of 'file open' for *normal* (straight to
disc) shift+click saves, and I think I'll introduce a unique name
guarantee of some sort to stop 'file open' in the first place. Odd
that the really tricky part (app-to-app) should be least likely to
suffer from this!
@
text
@d82 1
d865 1
a865 1
      /* If this is through scrap, use a different filename */
d867 3
a869 1
      if (m->data.data_save_ack.estimated_size == -1)
d871 1
a871 1
        /* Need to store the Message_DataLoad for later */
d873 3
a875 2
        save_object_browser->pending_data_load = malloc(sizeof(WimpMessage));
        if (!save_object_browser->pending_data_load) return make_no_memory_error(13);
d877 2
a878 4
        #ifdef TRACE
          malloccount += sizeof(WimpMessage);
          if (tl & (1u<<13)) Printf("** malloccount (protocols_atats_got_data_save_ack): \0211%d\0217\n",malloccount);
        #endif
d880 4
a883 1
        *save_object_browser->pending_data_load = *m;
d885 1
a885 2
        /* Change the filename to something unique and */
        /* update the message length                   */
d887 2
a888 2
        protocols_util_make_unique_name(save_object_browser->pending_data_load->data.data_load.leaf_name,
                                        sizeof(save_object_browser->pending_data_load->data.data_load.leaf_name));
d890 2
a891 1
        save_object_browser->pending_data_load->hdr.size = (int) WordAlign(strlen(save_object_browser->pending_data_load->data.data_load.leaf_name) + 45);
d893 1
a893 1
        /* Exit through the save routine */
d895 5
a899 3
        return save_save_object(save_object_browser->pending_data_load->data.data_load.leaf_name,
                                save_object_browser);
      }
d901 1
a901 1
      /* Otherwise, save as normal */
d903 5
a907 4
      else
      {
        e = save_save_object(path, save_object_browser);
        if (!e) ok = 1;
@


1.4
log
@First a minor warning - the various Res files are out of sync in this build.
Only the Browse resources are currently valid.

Added Utils.Icons - has a few archives inside containing the resources
(well, some of them) used to build various UI sprites for various builds.
Archived because these are unlikely to change much, and putting them on
CVS was a move to, well, archive the stuff...

SaveDBox objects vanquished and requirements in !Run[D] files removed. The
data save code fits much more neatly in amongst the data load protocol
stuff now (with the slight exception of having to split the SaveObject
source into SaveObject and SaveFile - the former handles multiple persistent
dialogues for Shift+Click on links and the like, the latter handles 'one at
a time' transient dialogues for save source and similar). Export Link is now
supported, too, and writes a 'proper' version URI file. You'll find that
double-clicking on old URI files will work as the URI handler picks them up,
whilst new version ones don't; however, dragging onto the browser will only
work with new version files. Note that support for saving and loading URL
files (ANT suite stuff) is present too, so old URI files can be typed as URL
files if you want to keep them working without modification - the URI
handler itself will hopefully support the defined URI file format soon;
double-clicking on old URI files will stop working at that point. Note
there are *lots* of changes in every Res file to support all this. This may
all seem a bit pointless to some, but the changes do in fact make it very
easy to add new save dialogues all over the place. Certainly much easier
than with the previous system, anyway. In fact, post script, image
'save as sprite' took about half an hour, which I hope proves the worth
of the new system.

Merged in newer hotlist code with support for drag cancelling with Escape
(all relevant Res files appropriately updated) and cancelling scrolling
when you've reached the window scroll limit. Had to move some of the
Wimp message handling stuff to the central Protocols source, as clashes
were occuring, and also the hotlist routines were using independent saving
code - a lot of duplicated effort. This was fair enough as at the time the
Hotlist code was written, the Save code couldn't be used in the way it is
now.

New Save Source and Print buttons on the toolbar of some builds.

Phoenix Sprites file made more efficient - the Acorn base section has been
split from the animated upper region. Browse build has a new grey fade
sprite at the back, which is less grainy than the previous one and only
uses 16 colours (with a 16 greyscale palette).

Not really a bug, bug the routine to start an image fetch for INPUT
TYPE=IMAGE forms items only did so if the src field (or equivalent, for
this tag type) was non-NULL. In fact, you should always call image_new_image
and let that handle the rest, otherwise other sections of the code will fail
as they try to obtain an image number for a given HStream and get -1 back.
This problem only generally manifested itself when loading an HTML file to
the browser straight from an application, as many src fields become NULL
when the relativisation routines find nothing to relativise to...

Authentication got broken somewhere along the line - this has been fixed
(in HTMLLib and the browser).

Ctrl+Click on a cross referenced image updates *all* copies, not just the
one with the image data attached.

Next big step: Rip up TBEvents.h and rebuild that whole approach somewhat.
To all those working on the code, my apologies but this means all Res files
will receive a very large number of alterations and there will be extensive
code changes too (mostly naming convention stuff), in more or less all
source files. I am endeavouring to ensure that the new numberspace
convention does not clash with the work being done by Kevin on
internationalisation.
@
text
@d129 1
a129 1
/* Saving a hotlist item */
d131 1
a131 3
static int            save_hotlist_entry_reference       = 0;
static int            save_hotlist_entry_transmitted     = 0;
static hotlist_item * save_hotlist_entry_item            = NULL;
d133 3
a135 1
/* Saving a hotlist selection */
d137 11
a147 2
static int            save_hotlist_selection_reference   = 0;
static int            save_hotlist_selection_transmitted = 0;
d154 1
d180 3
d421 11
a431 1
    /* Save a hotlist item as a URI file */
d433 8
a440 7
    case protocols_saving_hotlist_entry:
    {
      save_hotlist_entry_reference       = m.hdr.my_ref;
      save_hotlist_entry_transmitted     = 0;
      save_hotlist_entry_item            = (hotlist_item *) extra;
    }
    break;
d442 1
a442 1
    /* Save a selection of hotlist items as an HTML file */
d444 8
a451 6
    case protocols_saving_hotlist_selection:
    {
      save_hotlist_selection_reference   = m.hdr.my_ref;
      save_hotlist_selection_transmitted = 0;
    }
    break;
d460 1
a558 1

a579 3
  else if (m->hdr.your_ref == save_hotlist_entry_reference)
  {
    /* Save a hotlist item as a URI file */
d581 16
a596 8
    if (
         save_hotlist_entry_item
       )
       return save_transfer_uri(save_hotlist_entry_item->data.url,
                                0,
                                &save_hotlist_entry_transmitted,
                                m);
  }
a635 20
  /* If this is the last item, may need to do some tidying up */

  if (last)
  {
    if (m->hdr.your_ref == save_hotlist_entry_reference) hotlist_clear_selection();

    if (
         m->hdr.your_ref == save_source_reference        ||
         m->hdr.your_ref == save_link_reference          ||
         m->hdr.your_ref == save_location_reference      ||
         m->hdr.your_ref == save_hotlist_entry_reference
       )
    {
      _swix(Wimp_CreateMenu,
            _IN(1),

            -1);
    }
  }

d638 2
a639 2
  m->hdr.your_ref    = m->hdr.my_ref;
  m->hdr.action_code = Wimp_MRAMTransmit;
d662 2
a663 2
                                               m->data.ram_transmit.nbytes,
                                               1);
d687 28
a819 3
  else if (m->hdr.your_ref == save_hotlist_entry_reference)
  {
    /* Save a hotlist item as a URI file */
d821 18
a838 1
    if (save_hotlist_entry_item)
d840 3
a842 1
      e = save_save_uri(path, save_hotlist_entry_item->data.url, 0);
d847 1
a847 1
        hotlist_clear_selection();
d850 7
a856 4
  }
  else if (m->hdr.your_ref == save_hotlist_selection_reference)
  {
    /* Save a hotlist selection as an HTML file */
d858 1
a858 1
    e = hotlist_save_hotlist(path, 1);
a859 6
    if (!e)
    {
      ok = 1;
      hotlist_clear_selection();
    }
  }
d864 37
a900 2
      e = save_save_object(path, save_object_browser);
      if (!e) ok = 1;
d916 6
a925 2

    e = protocols_atats_send_data_load(m);
d1026 2
d1036 14
a1049 7
       m->hdr.your_ref == save_source_reference            ||
       m->hdr.your_ref == save_link_reference              ||
       m->hdr.your_ref == save_location_reference          ||
       m->hdr.your_ref == save_hotlist_entry_reference     ||
       m->hdr.your_ref == save_hotlist_selection_reference ||
       m->hdr.your_ref == save_object_reference            ||
       m->hdr.your_ref == save_sprite_reference
d1054 88
a1141 1
    if (!strcmp(m->data.data_load.leaf_name, Save_ScrapFile)) remove (m->data.data_load.leaf_name);
d1147 15
a1161 4
    StrNCpy0(erb.errmess,
             lookup_token("RecvDied:Data transfer failed - receiver died.",
                          0,
                          0));
d1211 118
a1486 3
    else
    {
      int handled = 0;
d1488 1
a1488 2
      /* We allow two places for loading - a browser window (or bits of it), */
      /* and for URI / URL files, the hotlist window. Check the latter.      */
d1490 1
a1490 4
      if (
           m->data.data_load.file_type == FileType_URI ||
           m->data.data_load.file_type == FileType_URL
         )
d1492 1
a1492 1
        ObjectId this;
d1494 2
a1495 1
        /* If we can get the window object ID... */
d1498 2
a1499 5
             !window_wimp_to_toolbox(0,
                                     m->data.data_load.destination_window,
                                     -1,
                                     &this,
                                     NULL)
d1502 3
a1504 1
          /* ...and it matches that of the hotlist, add the item. */
d1506 7
a1512 1
          if (this == hotlist_return_window_id())
d1514 1
a1514 1
            char * leaf = NULL;
d1516 8
a1523 4
            /* For the description, use the source leafname, unless this */
            /* is from another app (your_ref is non-zero), in which case */
            /* use the URL, as <Wimp$Scrap> isn't very friendly or       */
            /* unique.                                                   */
d1525 1
a1525 1
            if (!m->hdr.your_ref) leaf = strrchr(m->data.data_load.leaf_name, '.');
d1527 2
a1528 2
            if (!leaf) leaf = url;
            else       leaf ++;
d1530 4
a1533 4
            ChkError(hotlist_add_position(m->data.data_load.destination_x,
                                          m->data.data_load.destination_y,
                                          leaf,
                                          url));
d1535 2
a1536 1
            handled = 1;
a1538 1
      }
d1540 3
a1542 3
      if (!handled)
      {
        browser_data * b = NULL;
d1544 2
a1545 2
        /* Otherwise, load file to a browser window. Need to find */
        /* its browser_data structure for this.                   */
d1547 1
a1547 1
        utils_browser_from_window(m->data.data_load.destination_window, &b);
d1549 2
a1550 1
        if (b && !b->small_fetch) ChkError(fetchpage_new(b, url, 1, 0));
d1552 2
a1553 1
    }
a2024 4
              else
              {
                /* As with DataLoad, this can go to a Hotlist window or a browser; */
                /* the hotlist is the simpler case, check that first.              */
d2026 6
a2031 2
                ObjectId this;
                int      handled = 0;
d2033 2
a2034 1
                /* If we can get the window object ID... */
d2036 1
a2036 9
                if (
                     !window_wimp_to_toolbox(0,
                                             pending_data_save_ack->data.data_save_ack.destination_window,
                                             -1,
                                             &this,
                                             NULL)
                   )
                {
                  /* ...and it matches that of the hotlist, add the item. */
d2038 7
a2044 1
                  if (this == hotlist_return_window_id())
d2046 8
a2053 4
                    ChkError(hotlist_add_position(pending_data_save_ack->data.data_save_ack.destination_x,
                                                  pending_data_save_ack->data.data_save_ack.destination_y,
                                                  uri_buffer,
                                                  uri_buffer));
d2055 2
a2056 1
                    handled = 1;
a2057 1
                }
d2059 3
a2061 3
                if (!handled)
                {
                  browser_data * b;
d2063 1
a2063 1
                  /* The message was for a specific window, so find out which one */
d2065 1
a2065 1
                  utils_browser_from_window(pending_data_save_ack->data.data_save_ack.destination_window, &b);
d2067 2
a2068 1
                  if (b && !b->small_fetch) e = fetchpage_new(b, uri_buffer, 1, 0);
d2070 2
a2071 1
              }
d2189 1
a2189 1
  m.data.data_save.estimated_size     = -1;
d2763 1
a2763 1
  static char last_help[Limits_DisplayStats];
d2869 1
a2869 1
void protocols_util_update_reference(int old_ref, int new_ref)
d2872 13
a2884 1
  /* I'm sure C is really a great language. Really.               */
d2886 3
a2888 8
  if      (old_ref == save_source_reference)            save_source_reference            = new_ref;
  else if (old_ref == save_link_reference)              save_link_reference              = new_ref;
  else if (old_ref == save_location_reference)          save_location_reference          = new_ref;
  else if (old_ref == save_hotlist_entry_reference)     save_hotlist_entry_reference     = new_ref;
  else if (old_ref == save_hotlist_selection_reference) save_hotlist_selection_reference = new_ref;
  else if (old_ref == save_object_reference)            save_object_reference            = new_ref;
  else if (old_ref == save_sprite_reference)            save_sprite_reference            = new_ref;
  else if (old_ref == print_save_reference)             print_save_reference             = new_ref;
d2897 1
a2897 1
              "Old message reference %x not recognised in protocols_util_update_reference",
d2904 91
@


1.3
log
@File fetches now set DEADDEAD during the fetch, Data if it is aborted, or
an appropriate filetype when finished. If the fetcher routines return a
zero or data filetype, the browser looks at a set of hard coded filename
extensions to try and determine if there's a better filetype to use
(urlutils_filetype_from_url) - since this is a centralised routine it can
use a Mime mapping system (or be removed entirely) as and when one becomes
available.

You can now drag URI / URL files to the Hotlist window to add them to the
list. They are added roughly where dragged to. (NB, note that I renamed
the function to return the window ID - just being picky; it matches other
similar functions now). Oh, and hotlist_add_position actually works now ;-)

The global history will save when titles are added, as well as when a URL
is added. Before, a browser crash could mean a title got dropped out
of the history file even if SaveHistory was set to 'always'.

SaveObject sources have been added but nothing references them or links
them in yet - they're not finished. Mostly checking this one in because
of the hotlist changes.
@
text
@d27 10
a36 4
/*          _atat_  App To App Transfer            */
/*          _pp_    Printer Protocol               */
/*          _auh_   Acorn URI Handler              */
/*          _ih_    Interactive Help               */
d44 1
a44 3
/*          event. Functions for a given set of    */
/*          messages in a protocol appear in the   */
/*          the order _send_, _got_, _bounced.     */
d49 4
d74 1
d76 1
d78 1
d81 1
d94 42
a135 1
/* Local statics */
d137 2
a138 2
static WimpMessage   pending;
static int           pending_type    = -1; /* If this is -1, there is no pending message */
d140 1
a140 6
static int           recorded_my_ref = 0;
static int           recorded_sender = 0;
static int           recorded_type   = 0;
static int           recorded_window = 0;
static int           recorded_x      = 0;
static int           recorded_y      = 0;
d142 3
a144 1
static void        * rtb             = NULL; /* RAM transfer buffer */
d146 1
a146 1
static char          leafname[Limits_Leafname];
d148 18
a165 1
/* Local definitions */
d167 2
a168 1
#define RTB_Size 2048 /* RAM transfer buffer size */
d171 1
a171 1
/* protocols_send_data_open()                    */
d182 1
a182 1
_kernel_oserror * protocols_send_data_open(int filetype, char * pathname)
d187 6
d196 2
d207 3
a209 1
  e = wimp_send_message(Wimp_EUserMessageRecorded, &dop, 0, 0, NULL);
d213 1
a213 1
  recorded_my_ref = dop.hdr.my_ref;
d215 1
a215 1
  return e;
d219 1
a219 1
/* protocols_atat_got_data_save()                */
d221 4
a224 3
/* Handle reception of a Message_DataSave - load */
/* data from another application. Handles RAM    */
/* transfer for some filetypes.                  */
d226 1
a226 1
/* See PRM 3-252, 253, 255 and 256.              */
d229 1
a229 3
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
d232 1
a232 1
_kernel_oserror * protocols_atat_got_data_save(WimpMessage * m)
a233 2
  _kernel_oserror * e = NULL;

d235 1
a235 1
    if (tl & (1u<<28)) Printf("protocols_atat_got_data_save: Called\n");
d238 17
a254 2
  /* First, we may need to use file transfer so fill in */
  /* a pending DataSaveAck block for later use.         */
d256 1
a256 1
  pending_type = Wimp_MDataSaveAck;
d258 1
a258 1
  pending = *m;
d260 2
a261 2
  pending.hdr.your_ref    = m->hdr.my_ref;
  pending.hdr.action_code = Wimp_MDataSaveAck;
d263 1
a263 1
  /* We're not the filer, so the data is unsafe */
d265 2
a266 1
  pending.data.data_save_ack.estimated_size = -1;
d268 1
a268 2
  /* Record the leafname, then ask the sender to save the data */
  /* to a scrap file                                           */
d270 1
a270 4
  if (*pending.data.data_save_ack.leaf_name)
  {
    char * leaf = pending.data.data_save_ack.leaf_name;
    int    copy = 0;
d272 2
a273 1
    while (leaf && *leaf > 31 && copy < sizeof(leafname)) leafname[copy++] = *leaf++;
d275 1
a275 2
    if (copy == sizeof(leafname)) leafname[copy - 1] = 0;
    else                          leafname[copy]     = 0;
d278 80
a357 1
  strcpy(pending.data.data_save_ack.leaf_name, Save_ScrapFile);
d359 1
a359 1
  /* Update the size information */
d361 1
a361 1
  pending.hdr.size = (int) WordAlign(strlen(Save_ScrapFile) + 45); /* (44 for stuff up to the pathname, plus 1 for terminator) */
d363 1
a363 1
  /* For URI / URL files, can use RAM transfer */
d365 1
a365 6
  if (
       m->data.data_save.file_type == FileType_URL ||
       m->data.data_save.file_type == FileType_URI
     )
  {
    WimpMessage * rat = m;
d367 5
a371 1
    /* Remember the filetype for future reference */
d373 1
a373 4
    recorded_type   = m->data.data_save.file_type;
    recorded_window = m->data.data_save.destination_window;
    recorded_x      = m->data.data_save.destination_x;
    recorded_y      = m->data.data_save.destination_y;
d375 3
a377 1
    /* Free any existing RAM transfer buffer and allocate a new one */
d379 7
a385 2
    if (rtb) free(rtb);
    rtb = malloc(RTB_Size);
d387 1
a387 1
    /* If the allocation fails, drop through to a scrap file method */
d389 1
a389 1
    if (rtb)
d391 8
a398 4
      #ifdef TRACE
        malloccount += RTB_Size;
        if (tl & (1u<<13)) Printf("** malloccount (protocols_atat_got_ram_transmit): \0211%d\0217\n",malloccount);
      #endif
d400 7
a406 3
      rat->hdr.size         = 28;
      rat->hdr.your_ref     = m->hdr.my_ref;
      rat->hdr.action_code  = Wimp_MRAMFetch;
d408 1
a408 2
      rat->data.ram_fetch.buffer      = rtb;
      rat->data.ram_fetch.buffer_size = RTB_Size;
d410 7
a416 1
      /* Remember who send the Message_DataSave */
d418 1
a418 1
      recorded_sender = m->hdr.sender;
d420 6
a425 1
      /* Send it */
d427 1
a427 3
      #ifdef TRACE
        if (tl & (1u<<28)) Printf("protocols_atat_got_data_save: Sending Message_RAMFetch in response\n");
      #endif
d429 7
a435 1
      e = wimp_send_message(Wimp_EUserMessageRecorded, rat, m->hdr.sender, 0, NULL);
d437 1
a437 1
      /* Remember my_ref in case it bounces */
d439 6
a444 1
      recorded_my_ref = rat->hdr.my_ref;
d448 1
a448 1
  /* Otherwise send the message */
d450 2
a451 5
  else
  {
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atat_got_data_save: Sending Message_DataSaveAck in response\n");
    #endif
d453 10
a462 1
    pending_type = -1;
d464 5
a468 1
    /* Before doing this, make sure Scrap is present */
d470 2
a471 1
    if (utils_check_scrap()) return NULL;
d473 1
a473 4
    e = wimp_send_message(Wimp_EUserMessage, &pending, m->hdr.sender, 0, NULL);
  }

  return e;
d477 1
a477 1
/* protocols_atat_got_data_load()                */
d479 7
a485 2
/* Deals with a Message_DataLoad - if we can     */
/* handle the file, load it.                     */
d487 1
a487 1
/* See PRM 3-253.                                */
d490 1
a490 1
/*             for the received message. The     */
d495 1
a495 1
_kernel_oserror * protocols_atat_got_data_load(WimpMessage * m)
d498 1
a498 1
    if (tl & (1u<<28)) Printf("protocols_atat_got_data_load: Called\n");
d501 15
a515 1
  /* Proceed only if it's a filetype we can handle */
d517 1
a517 10
  if (
       m->data.data_load.file_type == FileType_HTML ||
       m->data.data_load.file_type == FileType_TEXT ||
       m->data.data_load.file_type == FileType_GIF  ||
       m->data.data_load.file_type == FileType_JPEG ||
       m->data.data_load.file_type == FileType_PNG  ||
       m->data.data_load.file_type == FileType_TIFF ||
       m->data.data_load.file_type == FileType_URL  ||
       m->data.data_load.file_type == FileType_URI
     )
d519 1
a519 3
    WimpMessage * dla = m;
    char          url[Limits_URL];
    int           apptoapp = m->hdr.your_ref ? 1 : 0; /* your_ref is zero if from filer, else filled in for app to app */
d521 10
a530 3
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atat_got_data_load: Can handle this filetype (0x%03x)\n", m->data.data_load.file_type);
    #endif
a531 1
    /* Process the file */
d534 2
a535 2
         m->data.data_load.file_type != FileType_URI &&
         m->data.data_load.file_type != FileType_URL
d537 8
a544 2
    {
      /* Not a URI or URL file, so text, HTML, image... */
d546 11
a556 2
      StrNCpy0(url, m->data.data_load.leaf_name);
      urlutils_pathname_to_url(url, sizeof(url));
d558 8
a565 6
      /* For text and HTML, we can use an internal URL scheme */
      /* to allow the fetcher to load the scrap file and then */
      /* remove it, as it should. For other types, the main   */
      /* fetcher modules must be used; so we can't get rid    */
      /* of the scrap file. If something else trashes it,     */
      /* tough.                                               */
d567 2
a568 9
      if (
           apptoapp &&
           (
             m->data.data_load.file_type == FileType_TEXT ||
             m->data.data_load.file_type == FileType_HTML
           )
         )
      {
        StrNCpy0(url, Internal_URL ForScrapFile ":");
d570 25
a594 1
        /* Append the application suggested leafname */
d596 4
a599 13
        if (!*leafname)
        {
          if (strlen(url) + 9 <= sizeof(url)) strcat(url, "HTMLfile");
        }
        else
        {
          if (strlen(url) + strlen(leafname) + 1 <= sizeof(url)) strcat(url, leafname);
        }
      }
    }
    else
    {
      urlutils_load_uri_file(url, sizeof(url), m->data.data_load.leaf_name);
d601 3
a603 2
      /* Delete scrap if used - we've finished with the */
      /* file now, certainly.                           */
d605 1
a605 2
      if (apptoapp) remove(m->data.data_load.leaf_name);
    }
d607 3
a609 1
    /* Take appropriate action */
d611 6
a616 1
    if (m->data.data_load.destination_window <= 0)
d618 2
a619 1
      /* Load file to icon bar - i.e. open a new window. */
d621 1
a621 1
      ChkError(windows_create_browser(url, NULL, NULL, NULL, 0));
d623 6
a628 3
    else
    {
      int handled = 0;
d630 547
a1176 2
      /* We allow two places for loading - a browser window (or bits of it), */
      /* and for URI / URL files, the hotlist window. Check the latter.      */
d1185 212
a1396 1
        /* If we can get the window object ID... */
d1398 2
a1399 9
        if (
             !window_wimp_to_toolbox(0,
                                     m->data.data_load.destination_window,
                                     -1,
                                     &this,
                                     NULL)
           )
        {
          /* ...and it matches that of the hotlist, add the item. */
d1401 1
a1401 3
          if (this == hotlist_return_window_id())
          {
            char * leaf = NULL;
d1403 3
a1405 4
            /* For the description, use the source leafname, unless this */
            /* is from another app (your_ref is non-zero), in which case */
            /* use the URL, as <Wimp$Scrap> isn't very friendly or       */
            /* unique.                                                   */
d1407 4
a1410 1
            if (!m->hdr.your_ref) leaf = strrchr(m->data.data_load.leaf_name, '.');
d1412 3
a1414 2
            if (!leaf) leaf = url;
            else       leaf ++;
d1416 2
a1417 4
            ChkError(hotlist_add_position(m->data.data_load.destination_x,
                                          m->data.data_load.destination_y,
                                          leaf,
                                          url));
d1419 1
a1419 4
            handled = 1;
          }
        }
      }
d1421 3
a1423 3
      if (!handled)
      {
        browser_data * b = NULL;
d1425 5
a1429 2
        /* Otherwise, load file to a browser window. Need to find */
        /* its browser_data structure for this.                   */
d1431 1
a1431 1
        utils_browser_from_window(m->data.data_load.destination_window, &b);
d1433 1
a1433 2
        if (b && !b->small_fetch) ChkError(fetchpage_new(b, url, 1, 0));
      }
d1435 2
d1438 1
a1438 2
    dla->hdr.your_ref    = m->hdr.my_ref;
    dla->hdr.action_code = Wimp_MDataLoadAck;
d1440 7
a1446 5
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atat_got_data_load: Sending Message_DataLoadAck in response\n");
    #endif

    ChkError(wimp_send_message(Wimp_EUserMessage, dla, m->hdr.sender, 0, NULL));
d1449 1
a1449 1
  return NULL;
d1453 1
a1453 1
/* protocols_atat_got_data_open()                */
d1455 9
a1463 5
/* Handle reception of a Message_DataOpen - we   */
/* may want to load a given file. It is an       */
/* application to application related the        */
/* consideration as we are transfering data      */
/* from the Filer, in a sense.                   */
d1465 1
a1465 1
/* See PRM 3-265.                                */
d1468 1
a1468 3
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
d1471 1
a1471 1
_kernel_oserror * protocols_atat_got_data_open(WimpMessage * m)
d1474 1
a1474 1
    if (tl & (1u<<28)) Printf("protocols_atat_got_data_open: Called\n");
d1477 14
a1490 5
  /* Don't want to load a text file from double-clicking, */
  /* only by dragging to a window or the icon bar icon.   */
  /* Similarly, ANT's URL files should only be loaded if  */
  /* dragged on, and the same is true of URI files if we  */
  /* are using the URI handler.                           */
d1492 5
a1496 9
  if (
       m->data.data_open.file_type == FileType_TEXT ||
       m->data.data_open.file_type == FileType_URL  ||
       (
         m->data.data_open.file_type == FileType_URI &&
         uri_module_present
       )
     )
     return NULL;
d1498 1
a1498 1
  /* Now treat as a DataLoad message to avoid duplicating load code. */
d1500 2
a1501 3
  m->data.data_load.destination_window = 0; /* Force a new window to open */
  m->data.data_load.destination_icon   = -1;
  m->data.data_load.estimated_size     = 0;
d1503 2
a1504 3
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atat_got_data_open: Exitting through protocols_atat_got_data_load\n");
  #endif
d1506 1
a1506 1
  return protocols_atat_got_data_load(m);
d1510 1
a1510 1
/* protocols_atat_got_ram_transmit()             */
d1523 1
a1523 1
_kernel_oserror * protocols_atat_got_ram_transmit(WimpMessage * m)
d1530 1
a1530 1
    if (tl & (1u<<28)) Printf("protocols_atat_got_ram_transmit: Called with %d bytes to receive\n", m->data.ram_transmit.nbytes);
a1537 10
  /* If we're here, then any pending Message_DataSaveAck should */
  /* be cleared as from here on in, any error results in the    */
  /* transfer being abandoned (PRM 3-256).                      */

  if (
       pending_type == Wimp_MDataSaveAck &&
       recorded_sender == m->hdr.sender
     )
     pending_type = -1;

d1566 1
a1566 1
  if (ok)
d1568 1
a1568 1
    switch (recorded_type)
d1678 3
a1680 1
              if (tl & (1u<<28)) trace_dump_buffer(uri_buffer, buffer_size - 1);
d1688 2
a1689 1
              /* so that this terminator could be inserted.                  */
d1693 6
a1698 1
              if (recorded_window <= 0)
d1716 1
a1716 1
                                             recorded_window,
d1726 2
a1727 2
                    ChkError(hotlist_add_position(recorded_x,
                                                  recorded_y,
d1741 1
a1741 1
                  utils_browser_from_window(recorded_window, &b);
d1747 2
a1748 2
              free(uri_buffer);
              uri_buffer  = NULL;
d1773 2
a1774 2
                  recorded_type,
                  recorded_type);
d1789 1
a1789 1
  if (ok)
d1797 1
a1797 3
    if (!finished)
    {
      WimpMessage * rat = m;
d1799 3
a1801 3
      rat->hdr.size        = 28;
      rat->hdr.your_ref    = m->hdr.my_ref;
      rat->hdr.action_code = Wimp_MRAMFetch;
d1803 3
a1805 3
      #ifdef TRACE
        if (tl & (1u<<28)) Printf("protocols_atat_got_ram_transmit: Sending RAMFetch in reply\n");
      #endif
d1807 5
a1811 2
      e = wimp_send_message(Wimp_EUserMessage, rat, m->hdr.sender, 0, NULL);
    }
d1814 3
a1816 1
  /* Free the RAM transfer buffer, if required */
d1823 6
d1839 1
a1839 6
/* protocols_atat_data_open_bounced()            */
/*                                               */
/* For a View Source function, the browser       */
/* broadcasts a Message_DataOpen. If this        */
/* bounces, attempt to start an editor instead,  */
/* with the pathname specified in the message.   */
d1841 2
a1842 1
/* See PRM 3-265.                                */
d1844 1
a1844 2
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
d1847 1
a1847 1
_kernel_oserror * protocols_atat_data_open_bounced(WimpMessage * m)
d1849 2
a1850 12
  if (
       recorded_my_ref                  &&
       m->hdr.my_ref == recorded_my_ref
     )
  {
    _kernel_oserror * e;
    char            * combuf;
    char            * comstart = "If \"Alias$@@RunType_FFF\" <> \"\" Then @@RunType_FFF ";
    int               len;

    /* Want to run '@@RunType_FFF' with the given pathname as a parameter;  */
    /* need to assemble this command string. Work out how long it will be. */
d1852 1
a1852 3
    len = strlen(comstart) + strlen(m->data.data_open.path_name) + 1;

    /* Allocate space for it (complain if this fails). */
d1854 2
a1855 1
    combuf = malloc(len);
d1857 1
a1857 1
    if (!combuf) return make_no_memory_error(9);
d1859 6
a1864 1
    /* Assemble the string */
d1866 2
a1867 2
    strcpy(combuf, comstart);
    strcat(combuf, m->data.data_open.path_name);
d1869 1
a1869 1
    /* Execute the command */
d1871 2
a1872 2
    e = _swix(Wimp_StartTask,
              _IN(0),
d1874 1
a1874 1
              combuf);
d1876 5
a1880 1
    /* Free the command buffer and return the value the _swix call gave back */
d1882 3
a1884 1
    free(combuf);
d1886 1
a1886 2
    return e;
  }
d1892 1
a1892 1
/* protocols_atat_ram_fetch_bounced()            */
d1894 5
a1898 9
/* Following getting a Message_DataSave,         */
/* protocols_atat_got_data_save may send out a   */
/* Message_RAMFetch. If this bounces, this       */
/* function is called. If the bounce is indeed   */
/* due to the RAMFetch we sent, then send out    */
/* a Message_DataSaveAck instead, to try and use */
/* scrap file transfer. This is stored in the    */
/* 'pending' block by the same function that     */
/* sends the Message_RAMFetch.                   */
d1900 3
a1902 1
/* See PRM 3-255.                                */
d1908 1
a1908 1
_kernel_oserror * protocols_atat_ram_fetch_bounced(WimpMessage * m)
d1910 1
a1910 10
  #ifdef TRACE
    if (tl & (1u<<28)) Printf("protocols_atat_ram_fetch_bounced: Called\n");
  #endif

  if (
       recorded_sender                   &&
       recorded_my_ref                   &&
       m->hdr.my_ref == recorded_my_ref  &&
       pending_type == Wimp_MDataSaveAck
     )
d1912 1
a1912 1
    int sender = recorded_sender;
d1914 1
a1914 3
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atat_ram_fetch_bounced: This is a recognised message bounce\n");
    #endif
d1916 2
a1917 1
    /* Send the Message_DataSaveAck instead */
d1919 1
a1919 3
    pending_type    = -1;
    recorded_my_ref = 0;
    recorded_sender = 0;
d1921 3
a1923 3
    #ifdef TRACE
      if (tl & (1u<<28)) Printf("protocols_atat_ram_fetch_bounced: Replying with a pending Message_DataSaveAck\n");
    #endif
d1925 3
a1927 1
    /* Before doing this, make sure Scrap is present */
d1929 2
a1930 1
    if (utils_check_scrap()) return NULL;
d1932 1
a1932 2
    return wimp_send_message(Wimp_EUserMessage, &pending, sender, 0, NULL);
  }
d1943 1
a1943 52
/* See PRM 3-262.                                */
/*                                               */
/* Parameters: Pointer to the WimpMessage struct */
/*             for the received message.         */
/*************************************************/

_kernel_oserror * protocols_pp_got_print_error(WimpMessage * m)
{
  if (m->hdr.size == 20)
  {
    /* RISC OS 2 printer manager's PrintBusy response */

    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("PrintBusy:The printer is currently busy.",
                          0,
                          0));

    show_error_ret(&erb);
  }

  /* RISC OS 3 !Printers-generated specific error response */

  else show_error_ret((_kernel_oserror *) &m->data);

  return NULL;
}

/*************************************************/
/* protocols_pp_got_print_type_odd()             */
/*                                               */
/* Handle reception of a Message_PrintTypeOdd.   */
/*                                               */
/* If this is sent directly to the task, we can  */
/* print immediately to 'printer:'.              */
/*                                               */
/* The use of an Alias$PrintType_FF4 system      */
/* variable makes it unnecessary to deal with    */
/* the case of a broadcast PrintTypeOdd. This    */
/* happens when a queued PrintOut file that the  */
/* browser has been asked to print rises to the  */
/* top of !Printers' queue. Bizarrely, !Printers */
/* doesn't recognise the filetype and raises the */
/* message. We allow this to fall back to the    */
/* system variable, which copies the PrintOut    */
/* file to the 'printer:' device.                */
/*                                               */
/* This is a hole in an otherwise workable, if   */
/* cumbersome, protocol.                         */
/*                                               */
/* See PRM 3-263.                                */
d1946 1
a1946 3
/*             for the received message. The     */
/*             contents will be modified and     */
/*             used in a reply.                  */
d1949 1
a1949 1
_kernel_oserror * protocols_pp_got_print_type_odd(WimpMessage * m)
d1951 1
a1951 4
  _kernel_oserror * e;
  WimpMessage     * ptk = m;

  if (m->hdr.your_ref && m->hdr.your_ref == printer_message_ref)
d1953 1
a1953 2
    /* The printer manager sent PrintTypeOdd as a reply to this */
    /* task (not a broadcast), so go ahead and print.           */
d1955 1
a1955 1
    printer_message_ref = 0;
d1957 4
a1960 1
    /* Send PrintTypeKnown */
d1962 2
a1963 3
    ptk->hdr.size        = 20;
    ptk->hdr.your_ref    = m->hdr.my_ref;
    ptk->hdr.action_code = Browser_Message_PrintTypeKnown;
d1965 1
a1965 1
    RetError(wimp_send_message(Wimp_EUserMessage, ptk, m->hdr.sender, 0, NULL));
d1967 1
a1967 34
    print_print(NULL);
  }

// Commented out as the Alias$@@PrintType_FF4 system variable does this job
// anyway, and if we don't claim this message then anything else which may
// have a better idea of what to do at least gets a chance to try.
//
// This currently doesn't work, incidentally; the conditions on the 'if'
// are wrong (printer_message_ref has probably been set to 0, but I never
// got the chance to properly debug this before removing it due to time
// constraints...).
//
//   else if (printer_message_ref && m->data.data_save.file_type == FileType_POUT)
//   {
//     /* If the printer doesn't understand PrintOut files, then */
//     /* it may be broken (!) / PostScript. So reply, and copy  */
//     /* the file to the printer device directly.               */
//
//     printer_message_ref = 0;
//
//     ptk->hdr.size        = 20;
//     ptk->hdr.your_ref    = m->hdr.my_ref;
//     ptk->hdr.action_code = Browser_Message_PrintTypeKnown;
//
//     ChkError(wimp_send_message(Wimp_EUserMessage, ptk, m->hdr.sender, 0, NULL));
//
//     _swix(OS_FSControl,
//           _INR(0,3),
//
//           26,
//           m->data.data_save.leaf_name,
//           "printer:",
//           2); /* Flags - 'Force' set, but no others. */
//   }
d1990 1
a1990 1
_kernel_oserror * protocols_pp_got_data_save_ack(WimpMessage * m)
d2004 1
a2004 1
  printer_message_ref = 0;
d2034 2
a2035 1
  /* Send the DataLoad */
d2041 5
a2045 1
  return wimp_send_message(Wimp_EUserMessage, dl, m->hdr.sender, 0, NULL);
d2049 17
a2065 1
/* protocols_pp_print_save_bounced()             */
d2067 2
a2068 5
/* If a Message_PrintSave bounces, the browser   */
/* tried to use the printer protocol to do a     */
/* print job but the printer wasn't loaded. In   */
/* that case, print directly to the 'printer:'   */
/* device.                                       */
d2070 1
a2070 3
/* See PRM 3-259 for details of where this fits  */
/* into the protocol, or 3-262 for the message   */
/* structure.                                    */
d2073 3
a2075 1
/*             for the received message.         */
d2078 1
a2078 1
_kernel_oserror * protocols_pp_print_save_bounced(WimpMessage * m)
d2080 4
a2083 1
  if (printer_message_ref && m->hdr.my_ref == printer_message_ref)
d2085 10
a2094 1
    printer_message_ref = 0;
d2096 5
a2100 1
    /* Go for it. */
d2105 47
d2215 5
a2219 1
    RetError(wimp_send_message(Wimp_EUserMessage, m, sender, 0, NULL));
d2353 5
a2357 1
        ChkError(wimp_send_message(Wimp_EUserMessageRecorded, &m, i.window_handle, i.icon_handle, NULL));
d2366 58
d2506 1
a2506 9
/* protocols_ih_help_request_bounced()           */
/*                                               */
/* If a Message_HelpRequest comes in as a        */
/* UserMessage_Acknowledge, then the browser     */
/* tried to send out such a message and it       */
/* bounced - there is no help on that item.      */
/* In this case, if we're displaing help items   */
/* in the status bar, return to a non-help       */
/* status string.                                */
d2508 3
a2510 3
/* See PRM 3-244 for details of the message or   */
/* protocols_ih_send_help_request for the        */
/* message origin.                               */
d2516 1
a2516 1
_kernel_oserror * protocols_ih_help_request_bounced(WimpMessage * m)
d2518 24
a2541 6
  if (fixed.claimhelp)
  {
    _kernel_oserror         * e;
    ObjectId                  o, a = -1;
    browser_data            * b = NULL;
    WimpGetPointerInfoBlock   i;
d2543 4
a2546 2
    RetError(wimp_get_pointer_info(&i));
    RetError(window_wimp_to_toolbox(0, i.window_handle, i.icon_handle, &o, NULL));
d2548 8
a2555 2
    /* If we can get an ancestor, the pointer is over e.g. a toolbar */
    /* - otherwise, assume it is over a browser window.              */
d2557 1
a2557 1
    toolbox_get_ancestor(0, o, &a, NULL);
d2559 1
a2559 1
    if (a)
d2561 1
a2561 3
      toolbox_get_client_handle(0, a, (void *) &b);
    }
    else toolbox_get_client_handle(0, o, (void *) &b);
d2563 3
a2565 5
    /* If we haven't got a valid client handle, exit */

    if (!is_known_browser(b)) return NULL;

    /* Update the status line */
d2567 1
a2567 4
    if (b->status_help != NULL)
    {
      b->status_help = NULL;
      RetError(toolbars_cancel_status(b, Toolbars_Status_Help));
a2568 1
  }
d2570 1
a2570 1
  return NULL;
@


1.2
log
@This version is being checked in because the Hotlist manager in the test
build provokes a Wimp bug. All the variant resource files are out of sync
and there are several outstanding bugs in the main code, so I'd personally
avoid this build like the plague unless you're mad enough to want to
examine the Wimp problem ;-)
@
text
@d67 1
d91 2
d210 2
d374 1
a374 2
      /* Load file to a browser window. Need to find it's */
      /* browser_data structure.                          */
d376 2
a377 1
      browser_data * b = NULL;
d379 37
a415 1
      utils_browser_from_window(m->data.data_load.destination_window, &b);
d417 16
a432 1
      if (b && !b->small_fetch) ChkError(fetchpage_new(b, url, 1, 0));
d699 32
a730 1
                browser_data * b;
d732 1
a732 1
                /* The message was for a specific window, so find out which one */
d734 1
a734 1
                utils_browser_from_window(recorded_window, &b);
d736 2
a737 1
                if (b && !b->small_fetch) e = fetchpage_new(b, uri_buffer, 1, 0);
@


1.1
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d100 38
d192 1
a192 1
  pending.hdr.size = (int) WordAlign(strlen(Save_ScrapFile) + 45);
d301 2
d308 6
a313 1
    if (m->data.data_load.destination_window <= 0)
d315 4
a318 1
      /* Load file to icon bar - i.e. open a new window. */
d320 6
a325 1
      char url[Limits_URL];
d328 5
a332 2
           m->data.data_load.file_type != FileType_URI &&
           m->data.data_load.file_type != FileType_URL
d335 1
a335 1
        /* Not a URI or URL file, so text, HTML, image... */
d337 1
a337 2
        StrNCpy0(url, m->data.data_load.leaf_name);
        urlutils_pathname_to_url(url, sizeof(url));
d339 5
a343 11
        /* For text and HTML, we can use an internal URL scheme */
        /* to allow the fetcher to load the scrap file and then */
        /* remove it, as it should. For other types, the main   */
        /* fetcher modules must be used; so we can't get rid    */
        /* of the scrap file. If something else trashes it,     */
        /* tough.                                               */

        if (
             m->data.data_load.file_type == FileType_TEXT ||
             m->data.data_load.file_type == FileType_HTML
           )
d345 7
a351 1
          StrNCpy0(url, Internal_URL ForScrapFile ":");
d353 2
a354 1
          /* Append the application suggested leafname */
d356 2
a357 13
          if (!*leafname)
          {
            if (strlen(url) + 9 <= sizeof(url)) strcat(url, "HTMLfile");
          }
          else
          {
            if (strlen(url) + strlen(leafname) + 1 <= sizeof(url)) strcat(url, leafname);
          }
        }
      }
      else
      {
        urlutils_load_uri_file(url, sizeof(url), m->data.data_load.leaf_name);
d359 1
a359 2
        /* Delete scrap if used - we've finished with the */
        /* file now, certainly.                           */
d361 3
a363 2
        if (!strcmp(m->data.data_load.leaf_name, Save_ScrapFile)) remove(Save_ScrapFile);
      }
a371 1
      char           url[Limits_URL];
d376 1
a376 36
      if (b)
      {
        if (
             m->data.data_load.file_type != FileType_URI &&
             m->data.data_load.file_type != FileType_URL
           )
        {
          StrNCpy0(url, m->data.data_load.leaf_name);
          urlutils_pathname_to_url(url, sizeof(url));

          /* As for the case when opening a new window, we can use */
          /* an internal URL scheme for HTML and text files.       */

          if (
               m->data.data_load.file_type == FileType_TEXT ||
               m->data.data_load.file_type == FileType_HTML
             )
          {
            StrNCpy0(url, Internal_URL ForScrapFile ":");

            /* Append the application suggested leafname */

            if (!*leafname)
            {
              if (strlen(url) + 9 <= sizeof(url)) strcat(url, "HTMLfile");
            }
            else
            {
              if (strlen(url) + strlen(leafname) + 1 <= sizeof(url)) strcat(url, leafname);
            }
          }
        }
        else urlutils_load_uri_file(url, sizeof(url), m->data.data_load.leaf_name);

        ChkError(fetchpage_new(b, url, 1, 0));
      }
d649 1
a649 1
                if (b) e = fetchpage_new(b, uri_buffer, 1, 0);
d735 59
d1320 4
@

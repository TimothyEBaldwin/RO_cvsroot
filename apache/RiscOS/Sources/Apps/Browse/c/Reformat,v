head	1.56;
access;
symbols
	Browse-2_16:1.56
	Browse-2_15:1.56
	Browse-2_14:1.56
	Browse-2_13:1.56
	Browse-2_12:1.56
	Browse-2_11:1.55
	Browse-2_10:1.55
	Browse-2_09:1.55
	ahodgkin_208_i4_2:1.54
	ahodgkin_208_i4:1.52
	ahodgkin_208_i3:1.52
	ahodgkin_208_i2:1.51
	ahodgkin_208_i1:1.50
	ahodgkin_207release:1.47
	ahodgkin_206release:1.44
	ahodgkin_205release:1.43
	ahodgkin_204release:1.42
	ahodgkin_202release:1.40
	ahodgkin_201release:1.39
	ahodgkin_200release:1.39
	ahodgkin_133beta:1.39
	ahodgkin_132beta:1.38
	ahodgkin_131beta:1.37
	ahodgkin_130beta:1.36
	ahodgkin_129:1.35
	ahodgkin_128beta:1.34
	ahodgkin_128alpha:1.33
	ahodgkin_127beta2:1.30
	ahodgkin_127beta:1.30
	ahodgkin_126beta:1.29
	ahodgkin_AW97patch:1.28
	ahodgkin_AW97:1.25;
locks; strict;
comment	@# @;


1.56
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.55;

1.55
date	2005.04.26.09.42.34;	author ahodgkin;	state Exp;
branches;
next	1.54;

1.54
date	2000.11.14.08.45.07;	author ahodgkin;	state Exp;
branches;
next	1.53;

1.53
date	2000.05.31.15.58.45;	author ahodgkin;	state Exp;
branches;
next	1.52;

1.52
date	2000.03.01.08.45.35;	author ahodgkin;	state Exp;
branches;
next	1.51;

1.51
date	2000.02.25.17.08.54;	author ahodgkin;	state Exp;
branches;
next	1.50;

1.50
date	99.09.02.13.10.31;	author ahodgkin;	state Exp;
branches;
next	1.49;

1.49
date	99.03.30.15.52.00;	author ahodgkin;	state Exp;
branches;
next	1.48;

1.48
date	98.10.14.15.21.58;	author ahodgkin;	state Exp;
branches;
next	1.47;

1.47
date	98.10.06.09.28.56;	author ahodgkin;	state Exp;
branches;
next	1.46;

1.46
date	98.09.23.13.18.13;	author ahodgkin;	state Exp;
branches;
next	1.45;

1.45
date	98.09.07.11.46.59;	author ahodgkin;	state Exp;
branches;
next	1.44;

1.44
date	98.07.09.10.27.22;	author ahodgkin;	state Exp;
branches;
next	1.43;

1.43
date	98.04.21.10.38.15;	author ahodgkin;	state Exp;
branches;
next	1.42;

1.42
date	98.04.16.08.14.22;	author ahodgkin;	state Exp;
branches;
next	1.41;

1.41
date	98.03.26.14.21.10;	author ahodgkin;	state Exp;
branches;
next	1.40;

1.40
date	98.03.20.12.12.56;	author ahodgkin;	state Exp;
branches;
next	1.39;

1.39
date	98.02.13.17.32.25;	author ahodgkin;	state Exp;
branches;
next	1.38;

1.38
date	98.02.06.13.55.25;	author ahodgkin;	state Exp;
branches;
next	1.37;

1.37
date	98.01.31.10.55.31;	author ahodgkin;	state Exp;
branches;
next	1.36;

1.36
date	97.12.18.10.07.06;	author ahodgkin;	state Exp;
branches;
next	1.35;

1.35
date	97.12.12.11.18.03;	author ahodgkin;	state Exp;
branches;
next	1.34;

1.34
date	97.12.04.11.23.04;	author ahodgkin;	state Exp;
branches;
next	1.33;

1.33
date	97.12.02.16.14.00;	author ahodgkin;	state Exp;
branches;
next	1.32;

1.32
date	97.11.27.17.50.06;	author ahodgkin;	state Exp;
branches;
next	1.31;

1.31
date	97.11.26.17.11.10;	author ahodgkin;	state Exp;
branches;
next	1.30;

1.30
date	97.11.19.10.29.10;	author ahodgkin;	state Exp;
branches;
next	1.29;

1.29
date	97.10.30.17.11.15;	author ahodgkin;	state Exp;
branches;
next	1.28;

1.28
date	97.10.22.13.16.00;	author ahodgkin;	state Exp;
branches;
next	1.27;

1.27
date	97.10.20.07.09.22;	author ahodgkin;	state Exp;
branches;
next	1.26;

1.26
date	97.10.18.16.42.29;	author ahodgkin;	state Exp;
branches;
next	1.25;

1.25
date	97.10.16.13.23.19;	author ahodgkin;	state Exp;
branches;
next	1.24;

1.24
date	97.10.13.07.07.03;	author ahodgkin;	state Exp;
branches;
next	1.23;

1.23
date	97.10.09.11.40.55;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	97.10.07.17.03.45;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	97.10.07.13.52.01;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	97.10.06.15.18.25;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	97.10.05.17.16.25;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	97.10.03.16.15.12;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	97.10.03.10.58.14;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	97.10.03.09.19.05;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	97.09.26.12.36.06;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	97.09.24.11.14.21;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.09.22.07.43.24;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.09.18.08.59.02;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.09.14.19.18.17;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.08.31.18.38.21;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.08.28.16.08.06;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.08.18.16.15.43;	author kbracey;	state Exp;
branches;
next	1.7;

1.7
date	97.08.18.09.24.04;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.08.12.09.26.39;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.16.38.56;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.08.05.08.42.58;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.08.01.09.00.55;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	97.07.31.14.50.14;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.28.57;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.56
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Reformat.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Functions to handle page reformatting.            */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 03-Dec-1996 (ADH): Created.                       */
/*          16-Apr-1997 (ADH): First merge with T.Cheal's     */
/*                             table code...                  */
/*          22-May-1997 (ADH): Amazingly, *still* trying to   */
/*                             get this to work.              */
/*          18-Jun-1997 (ADH): Hpmh; works, but very slow.    */
/*                             Will need to rewrite at some   */
/*                             stage; for the moment, moved a */
/*                             few bits over to Tables.c as   */
/*                             they fitted in better there.   */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>
#include <tboxlibs/flex.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include "Global.h"
#include "FromROSLib.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Browser.h"
#include "Fetch.h" /* (Which itself includes URLstat.h) */
#include "FetchPage.h"
#include "FontManage.h"
#include "Forms.h"
#include "History.h"
#include "Images.h"
#include "Memory.h"
#include "Object.h"
#include "Redraw.h"
#include "Tables.h"
#include "Toolbars.h"
#include "Windows.h"

#include "Reformat.h"

/* Local constant definitions */

#define BULLET_GAP 12

/* Static function prototypes */

static int               reformat_useless_token         (HStream * tp);
static int               reformat_newline_check         (HStream * current, HStream * last, int offset);
static int               reformat_datasize              (HStream * p);
static _kernel_oserror * reformat_token_width           (reformat_width_data * w, unsigned int flags);
static void              reformat_check_visited         (browser_data * b, HStream * token);

static _kernel_oserror * reformat_add_line              (browser_data * b, reformat_cell * cell);
static _kernel_oserror * reformat_add_line_chunk        (browser_data * b, reformat_cell * cell);

static _kernel_oserror * reformat_format_from_now       (browser_data * b, int lastline);

static void              reformat_correct_for_alignment (const browser_data * restrict b, const HStream * restrict tp, imgalign align, BBox * restrict box);
static _kernel_oserror * reformat_check_height          (int toplevel, browser_data * b, reformat_cell * d, int line, HStream * tp, HStream * tpLast, int offset);
static int               reformat_reformatter_r         (unsigned int flags, browser_data * b, reformat_cell * d, HStream * streambase);

/* Local compilation options */

#undef  SUPPORT_NOBR
#define SUPPORT_PER_LINE_PARA_MARKS
#define SUPPORT_MTT

#ifdef SUPPORT_MTT

  #include "Main.h"
  #include "Multiuser.h"

  unsigned int poll_counter = 0;

  static unsigned int reformat_poll (browser_data * b, unsigned int pc, int * redraw_y);

#endif

// static void              reformat_strip_prespace (browser_data * b, int chunk, HStream * tp);

/**************************************************************/
/* reformat_formatting()                                      */
/*                                                            */
/* Returns 0 if reformatting is not in progress, else         */
/* non-zero.                                                  */
/*                                                            */
/* Parameters: Pointer to the browser_data structure          */
/*             associated with the page which might be        */
/*             reformatting.                                  */
/*                                                            */
/* Returns:    0 if reformatting is not in progress, else it  */
/*             is.                                            */
/**************************************************************/

int reformat_formatting(browser_data * b)
{
//  if (b->suspend_format) dprintf(("", "reformat_formatting: %p suspend_format set\n",b));
//  else if (b->last_token)
//  {
//    if (!b->last_token->next) dprintf(("", "reformat_formatting: %p b->last_token->next = NULL\n",b));
//    else if (b->last_token->next && !(b->last_token->next->flags & HFlags_DealtWithToken)) dprintf(("", "reformat_formatting: %p last_token->next HFlags NULL\n",b));
//    else if (b->cell->nlines <= 0) dprintf(("", "reformat_formatting: %p will return b->final_token != NULL: %d\n",b,b->final_token != NULL));
//    else dprintf(("", "reformat_formatting: %p will return 1\n",b));
//  }
//  else if (b->cell->nlines <= 0) dprintf(("", "reformat_formatting: %p will return b->final_token != NULL: %d\n",b,b->final_token != NULL));
//  else dprintf(("", "reformat_formatting: %p will return 1\n",b));

  /* Reformatting had been suspended due to an error */

  if (b->suspend_format) return 0;

  if (b->last_token)
  {
    /* If we've not overrun the tokens dealt with by the fetcher, */
    /* the fetcher could have exitted and this could be the last  */
    /* token (so we've finished).                                 */
    /*                                                            */
    /* The check for a 'next' token is done as final_token only   */
    /* records main token stream tokens dealt with by the         */
    /* preprocessor. It is possible for a precise set of          */
    /* circumstances to leave last_token and final_token          */
    /* equivalent due to table parsing, though there is more data */
    /* in the main token stream after it (this happened during    */
    /* testing, so it isn't all that rare).                       */

    if (!b->last_token->next) return 0;

    /* If the token after the last one dealt with by the   */
    /* fetcher had not been looked at by the preprocessor, */
    /* the reformatter must have exitted for that reason.  */

    if (b->last_token->next && !(b->last_token->next->flags & HFlags_DealtWithToken)) return 0;
  }

  /* If there are no lines, are there any HStream structures? */
  /* If so, the preprocessor has got stuff from the fetcher   */
  /* but the reformatter hasn't built anything with them yet. */

  if (b->cell->nlines <= 0) return (b->final_token != NULL);

  /* If none of the above, we must still be formatting */

  return 1;
}

/**************************************************************/
/* reformat_stop()                                            */
/*                                                            */
/* Suspends a reformat, flagging that this has been done in   */
/* the browser_data structure.                                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct with the      */
/*             details of the reformat process to stop inside */
/*             it.                                            */
/**************************************************************/

_kernel_oserror * reformat_stop(browser_data * b)
{
  b->suspend_format = 1;

  return toolbars_set_button_states(b);
}

/**************************************************************/
/* reformat_istext()                                          */
/*                                                            */
/* Returns 1 if an HStream structure represents a text item - */
/* e.g. not an image, HR, object, table...                    */
/*                                                            */
/* Parameters: Pointer to the HStream structure.              */
/*                                                            */
/* Returns:    1 if the struct represents text, else 0.       */
/**************************************************************/

int reformat_istext(const HStream * restrict tp)
{
  return (
           ((tp->style) & (IMG | HR)) == 0 &&
           tp->tagno != TAG_TABLE          &&
           !ISOBJECT(tp)                   &&
           !
           (
             tp->tagno         == TAG_INPUT &&
             HtmlINPUTtype(tp) == inputtype_IMAGE
           )
         );
}

/**************************************************************/
/* reformat_token_width()                                     */
/*                                                            */
/* Fills in the 'width' and 'bytes' fields of a               */
/* reformat_width_data structure according to the contents of */
/* the token (HStream structure) that the reformat_width_data */
/* structure points to (this structure is defined in          */
/* Reformat.h).                                               */
/*                                                            */
/* The idea is to fit the token into maxwidth coordinates (in */
/* millipoints). The actual width is returned (which may be   */
/* greater than, or less than maxwidth) and the number of     */
/* bytes used to make that width is returned.                 */
/*                                                            */
/* Parameters: Pointer to a reformat_width_data structure     */
/*             (see Reformat.h);                              */
/*                                                            */
/*             A flags word, as ppassed to                    */
/*             reformat_reformatter.                          */
/*                                                            */
/* Returns:    Fills in the structure's 'width' and 'bytes'   */
/*             fields with width and byte count information.  */
/**************************************************************/

static _kernel_oserror * reformat_token_width(reformat_width_data * w, unsigned int flags)
{
  _kernel_oserror * e = NULL;
  BBox box;

  /* Deal with tables */

  if (w->tp->tagno == TAG_TABLE)
  {
    reformat_cell * cellarray;
    table_stream  * table = (table_stream *) w->tp;
    int             size;
    int             toplevel;

    dprintf(("Tabl", "reformat_token_width: Dealing with table, token %p\n",table));

    tables_count_table(w->b, table);

    size = table->ColSpan * table->RowSpan;

    #ifdef TRACE

                 dprintf(("Tabl", "reformat_token_width: Size of table is %d\n", size));
      if (!size) dprintf(("Tabl", "                      (Table has no cells...)\n"));

    #endif

    if (size) tables_position_table(w->b, table);

    dprintf(("Tabl", "reformat_token_width: Tag is now 0x%x\n",w->tp->tag));

    /* If the table has no cells, may need to clear an existing cell array */

    if (!size)
    {
      if (table->cells) HtmlFree(table->cells);

      table->ncells = 0;
    }
    else
    {
      /* If we've got an existing cell array and the number of cells has */
      /* not changed, don't need to do anything. Otherwise, (re)allocate */
      /* the cell array.                                                 */

      if (!table->cells || table->ncells != size)
      {
        reformat_cell * old_cells = table->cells;

        /* Now allocate a new cell array and initialise the cell contents */

        table->cells = HtmlMalloc(size * sizeof(reformat_cell), table);

        /* If the allocation fails, can't possibly continue so jump */
        /* back to poll loop after reporting the error.             */

        if (!table->cells)
        {
          table->cells         = old_cells;
          w->b->suspend_format = 1;

          show_error_cont(make_no_table_memory_error(9));
        }

        /* Otherwise, initialise the cell contents */

        tables_init_table(w->b, table, table->cells);

        /* Copy over any old cells ('ncells' still holds the old number) */

        if (table->ncells && old_cells)
        {
          memcpy(table->cells, old_cells, table->ncells * sizeof(reformat_cell));

          /* Free the old cell array */

          HtmlFree(old_cells);
        }

        /* Now update 'ncells' */

        table->ncells = size;
      }
    }

    cellarray = table->cells;

    if (cellarray)
    {
      /* Find the width and height of the cells and fix their positions */
      /* as millipoint offsets from the top left of the table.          */
      /*                                                                */
      /* If the reformatter flags say not to generate lines, then we    */
      /* must be doing a width finding session as part of a parent      */
      /* table, so toplevel is 0. Otherwise, this is the highest level  */
      /* and toplevel is therefore set to 1.                            */

      if (flags & Reformatter_Virtual) toplevel = 1;
      else                             toplevel = 0;

      w->width = tables_width_table (toplevel, w->b, table, w->maxwid, cellarray, flags);
      w->bytes = tables_height_table(toplevel, w->b, table,            cellarray);

      tables_fix_table(w->b, table, cellarray);
    }

    dprintf(("Tabl", "reformat_token_width: Tag is now 0x%x\n",w->tp->tag));

    /* Return the cell array pointer for convenience (may prove useful */
    /* to have this in the reformatter some time...).                  */

    w->data = (char *) cellarray;

    return e;
  }

  /* Deal with forms: Text-based elements */

  else if (
            w->tp->tagno == TAG_SELECT   ||
            w->tp->tagno == TAG_TEXTAREA ||
            w->tp->tagno == TAG_INPUT
          )
  {
    if (
         w->tp->tagno         == TAG_SELECT         ||
         w->tp->tagno         == TAG_TEXTAREA       ||
         HtmlINPUTtype(w->tp) == inputtype_PASSWORD ||
         HtmlINPUTtype(w->tp) == inputtype_TEXT
       )
    {
      int h;
      int done = 0;
      int length;

      if (w->tp->tagno == TAG_TEXTAREA)
      {
        /* Text areas */

        length = w->tp->cols;

        if (length == 1) length = 2;
        else if (length < 2) length = 30;

        done = 0;
      }
      else if (w->tp->tagno == TAG_SELECT)
      {
        /* SELECT elements (have pop-up menus) */

        int    width, l;
        int    extra = 0;
        char * p;

        e = utils_read_sprite_size("fgright", &width, NULL);
        if (e) return e;

        width += 32; /* Account for border and gap */
        convert_to_points(width, &extra);

        /* Need to find out the actual used width, or we end up */
        /* generally overestimating the required size.          */

        p      = (char *) HtmlSELECToptions(w->tp) + 8;
        h      = fm_find_token_font(w->b, w->tp, 0);
        l      = 0;
        width  = 0;
        length = 0; /* Not used, but stops compiler giving warnings */

        /* Some fields can hold the selNONE or selMANY text, as well */
        /* as the menu item texts.                                   */

        if (HtmlSELECTmultiple(w->tp) || *p == 0xff)
        {
          e = fm_get_string_width(h,
                                  lookup_token("selNONE:<None>",0,0),
                                  Reformat_AsWideAsPossible_MP,
                                  strlen(tokens),
                                  -1,
                                  NULL,
                                  &width);

          if (!e && width > l) l = width;
        }

        if (HtmlSELECTmultiple(w->tp))
        {
          e = fm_get_string_width(h,
                                  lookup_token("selMANY:<Many>",0,0),
                                  Reformat_AsWideAsPossible_MP,
                                  strlen(tokens),
                                  -1,
                                  NULL,
                                  &width);

          if (!e && width > l) l = width;
        }

        /* Look for the width of the widest OPTION field */

        while (*p != 0xff)
        {
          p++;

          e = fm_get_string_width(h,
                                  p,
                                  Reformat_AsWideAsPossible_MP,
                                  strlen(p),
                                  -1,
                                  NULL,
                                  &width);

          if (e)
          {
            erb   = *e, e = &erb;
            width = 16000; /* Arbitrary! Give it 40 OS units on error */
            break;
          }

          /* Record if this is the widest and skip to the next field */

          if (width > l) l = width;

          p += strlen(p) + 1;
          p += strlen(p) + 1;
        }

        /* Set the width and flag that we've done the calculation */
        /* already so code lower down doesn't try.                */

        w->width = l + extra;
        done     = 1;
      }
      else
      {
        /* One line writable */

        length = HtmlINPUTsize(w->tp);

        if (length == 1) length = 2;
        else if (length < 2)
        {
          length = w->tp->maxlen;
          if (length > 40) length = 40;
        }

        done = 0;
      }

      /* Some cases above may have worked out the width already. */
      /* For those that haven't, do it on the basis of 'length', */
      /* holding the maximum number of characters, and the       */
      /* width of the widest character possible in the item.     */

      if (!done)
      {
        BBox box;

        if (length == 1) length = 2;
        else if (length < 2) length = 20;

        /* Finding the width based on font BBox multipled by the */
        /* field length usually is a significant overestimation, */
        /* so use a number instead - this is typically closer.   */

        h = fm_find_token_font(w->b, w->tp, 0);

        e = fm_char_box(h, '0', &box);

        if (e) erb = *e, e = &erb;
        else
        {
          w->width = ((box.xmax - box.xmin) * length) + 20;

          convert_to_points(w->width, &w->width);
        }
      }

      w->bytes = 0;

      return e;
    }
    else switch(HtmlINPUTtype(w->tp))
    {
      case inputtype_SUBMIT: /* No break - same as RESET */
      case inputtype_BUTTON: /* Again, no break          */
      case inputtype_RESET:
      {
        const char * p;
        int    h, length, end;

        p = form_button_text(w->tp);
        length = strlen(p);
        end = 0;

        while(end < length && p[end] != '\n') end++;

        h = fm_find_token_font(w->b, w->tp, 0);
        e = fm_get_string_width(h,
                                p,
                                Reformat_AsWideAsPossible_MP,
                                end - w->offset,
                                -1,
                                &w->bytes,
                                &w->width);

        if (e) erb = *e, e = &erb;

        w->width += 400 * 4 * 12; /* Account for border */
        w->bytes  = 0;

        return e;
      }
      break;

      case inputtype_CHECKBOX:
      {
        w->bytes = 0;

        utils_read_sprite_size("fopton", &w->width, NULL);

        convert_to_points(w->width, &w->width);
      }
      break;

      case inputtype_RADIO:
      {
        w->bytes = 0;

        utils_read_sprite_size("fradioon", &w->width, NULL);

        convert_to_points(w->width, &w->width);
      }
      break;

      case inputtype_HIDDEN:
      {
        w->width = w->bytes = 0;
      }
      break;

      case inputtype_IMAGE:
      {
        goto do_image; /* See below */
      }
      break;
    }
  }

  /* Handle OBJECT, EMBED and APPLET tags */

  else if (ISOBJECT(w->tp))
  {
    RetError(reformat_get_object_size(w->b, w->tp, &box));

    w->width = box.xmax - box.xmin;

    convert_to_points(w->width, &w->width);
  }

  /* Handle images */

  else if (w->tp->style & IMG)
  {
do_image: /* Used by switch statement above */

    w->bytes = 0;
    w->width = 0;

    /* Now get the size of the image for reformatting purposes */

    RetError(reformat_get_image_size(w->b, w->tp, &box));

    w->width = box.xmax - box.xmin;

    convert_to_points(w->width, &w->width);
  }
  else if (w->tp->style & HR)
  {
    /* For a horizontal rule, there's no extra data to put in (so */
    /* the w->bytes field is zero) and the width is as wide as    */
    /* the specified maximum width, unless the HR specifies a     */
    /* particular width directly.                                 */
    /*                                                            */
    /* The special case of finding min/max widths is checked in   */
    /* the flags here, as otherwise any HR tag can force the      */
    /* width up to maxwid - which may be very large.              */

    w->bytes = 0;

    if (!HR_HAS_WIDTH(w->tp) || HR_WIDTH_UNITS(w->tp) == UNITS_PERCENT)
    {
      if (
           !(flags & Reformatter_FindingWidest)   &&
           !(flags & Reformatter_FindingSmallest)
         )
      {
        if (HR_HAS_WIDTH(w->tp)) w->width = (w->maxwid * HR_WIDTH(w->tp)) / 100;
        else                     w->width = w->maxwid;
      }

      else w->width = 0;
    }
    else
    {
      w->width = HR_WIDTH(w->tp) * 2; /* 1 'web pixel' = 2 OS units */

      convert_to_points(w->width, &w->width);
    }
  }
  else if (ISBULLET(w->tp)) /* ISBULLET is defined in Fetch.h */
  {
    /* For a bullet, there is again no extra data so bytes = 0, */
    /* and the width is taken from the sprite width of the      */
    /* bullet point.                                            */

    w->bytes = 0;

    convert_to_points(reformat_bullet_width(w->tp->indent), &w->width);
  }
  else
  {
    int h, end, split;

    /* Can't do anything if there's no text */

    if (!w->data || !*w->data)
    {
      w->bytes = 0;
      w->width = 0;
    }
    else
    {
      /* Loop round until a newline is found, or the end of the  */
      /* string is reached, starting at the offset into the data */
      /* specified by the 'offset' field.                        */

      end = w->offset;

      while (w->data[end] && w->data[end] != '\n') end++;

      /* If the text is preformatted, set a null split character. */
      /* Else specify splitting on spaces.                        */

      split = (w->tp->style & PRE) ? -1 : ' ';

      /* Get a font handle for rendering the token */

      h = fm_find_token_font(w->b, w->tp, 0);

      /* If end > offset, the loop above must have gone through at least */
      /* one non-newline character in the string, or there was no string */
      /* to look through; find the width of the string (the call won't   */
      /* mind if there's no string, it'll just return 0)                 */

      if (end > w->offset) e = fm_get_string_width(h,
                                                   w->data + w->offset,
                                                   w->maxwid,
                                                   end - w->offset,
                                                   split,

                                                   &w->bytes,
                                                   &w->width);

      /* If finding the minimum or maximum width for tables, add a little to */
      /* the above width to account for italics etc. - the font manager will */
      /* not have returned the upper limit on either side.                   */

      if (
           (flags & Reformatter_FindingWidest)   ||
           (flags & Reformatter_FindingSmallest)
         )
         w->width += 3200;

      /* If the scan for a newline finished before the end of the string (so */
      /* a newline was found) and the chunk of data defined by the call to   */
      /* fm_get_string_width above gave a string ending in a newline, add 1  */
      /* to the bytes counter to ensure that the chunk includes it.          */

      if (w->data[end] && w->data[w->offset + w->bytes] == '\n') w->bytes++;
    }
  }

  return e;
}

/**************************************************************/
/* reformat_useless_token()                                   */
/*                                                            */
/* Checks to see if a token (HStream struct) is of any use to */
/* the reformatter.                                           */
/*                                                            */
/* Parameters: Pointer to the HStream struct.                 */
/*                                                            */
/* Returns:    1 = the token is useless, else 0.              */
/**************************************************************/

static int reformat_useless_token(HStream * tp)
{
  if (ISHEAD(tp)) return 1;
  if (ISNULL(tp)) return 1;

  if (tp->flags & HFlags_IgnoreObject) return 1;

  if (
       ISBODY(tp)   &&
       !tp->tag     &&
       !tp->tagno   &&
       !tp->text    &&
       !tp->anchor  &&
       !tp->src     &&
       !tp->enctype &&
       !tp->name    &&
       !tp->value   &&
       !tp->target  &&
       (
         tp->style == 0x00000000 ||
         tp->style == 0x80000000
       )
     )
     return 1;

  return 0;
}

/**************************************************************/
/* reformat_newline_check()                                   */
/*                                                            */
/* Works out whether or not there should be a line break in   */
/* the page, according to the token (HStream structure) that  */
/* is currently being considered and the token that was last  */
/* considered, and the offset into the data of the tokens.    */
/*                                                            */
/* Parameters: Pointer to the current token (the HStream      */
/*             structure that is being dealt with by the      */
/*             reformatter, say, at the moment);              */
/*                                                            */
/*             Pointer to the last token that was dealt with; */
/*                                                            */
/*             Data offset into the tokens.                   */
/*                                                            */
/* Returns:    0 if there is no line break needed, or a value */
/*             between 1 and 8 that says 'yes, line break     */
/*             needed' and also holds details of the          */
/*             conditions that were met to determine the line */
/*             break was needed.                              */
/**************************************************************/

static int reformat_newline_check(HStream * current, HStream * last, int offset)
{
  /* It generally looks better if there's a line break for tables, */
  /* though this is theoretically not necessary. In practice you   */
  /* find various line spacing and redraw problems without the     */
  /* break - this may get sorted one day...!                       */

  if (current->tagno == TAG_TABLE || last->tagno == TAG_TABLE) return 9;

  /* If the current token represents a horizontal rule and the last token also */
  /* represented one, with no offset indicating extra data in the tokens (and  */
  /* provided that there is actually a last token!), then return 1.            */

  if (((current->style) & HR) || ((!offset) && (last) && ((last->style) & HR))) return 1;

  /* If we have a paragraph break but the last item was a <li> tag, and we are */
  /* at the top of the line, then HTML like '<ul><li><p>Text' is being used -  */
  /* we should ignore the <p> tag. The position of this line of code relative  */
  /* to other checks in this function is obviously quite important (so be      */
  /* careful with it!)...                                                      */

  if (!offset && (current->style & P) && (last->style & LI)) return 0;

  /* If the tag itself indicates that a linebreak is needed, and we are at the */
  /* start of this line (offset into it is zero), return 2. This may be due to */
  /* <P>, <BR> and the like, in the document source.                           */

  if ((!offset) && ((current->style) & LINEBREAK)) return 2;

  /* If, again, this is the start of a line, and the pointer to the previous */
  /* token dealt with is not null, proceed with other line break checks.     */

  if ((!offset) && (last))
  {
    /* If the indentation has changed since the last token (e.g. a new list has */
    /* been started or an old one closed between the two tokens) then return 3. */

    if (current->indent != last->indent) return 3;

    /* If the header type changed between the two tokens, then provided the     */
    /* last token wasn't a list item (in which case a line break will already   */
    /* have been put in) return 4.                                              */

    if (((current->style & H_MASK) != (last->style & H_MASK)) && !(last->style & LI)) return 4;

    /* When certain tags are turned on or off, we want a linebreak. For example */
    /* it looks tidier for preformatted text to have a gap above and below it,  */
    /* rather than having it touch the previous and following text. The macro   */
    /* LINEBREAKSW (defined in Reformat.h) has a list of these tags ORed        */
    /* together to form a mask - if this mask changes between the tokens, one   */
    /* of the listed tags must have turned on or off. So we want a line break;  */
    /* hence, return 5.                                                         */

    if ((current->style & LINEBREAKSW) != (last->style & LINEBREAKSW)) return 5;

    /* CENTRED is defined in Reformat.h, and is 1 if the token holds data that  */
    /* should be displayed centred in the page. If switching from centred to    */
    /* uncentred text or vice versa, there must be a line break. So return 6.   */

    if (CENTRED(current) != CENTRED(last)) return 6;

    /* Some tags need a line break when they turn on, for example at the start  */
    /* of certain special kinds of list. The LINEBREAKON macro is defined in    */
    /* reformat.h and contains an ORed together list of such tags (just like    */
    /* the LINEBREAKSW macro used above) - so if the current token has one of   */
    /* these turned on, but the last token had it turned off, we want another   */
    /* line break; return 7.                                                    */

    if ((current->style & LINEBREAKON) && !(last->style & LINEBREAKON)) return 7;

    /* Similarly, some tags need a line break when they turn off; for example,  */
    /* headers look better if they have a gap underneath them. So again, there  */
    /* is a macro (LINEBREAKOFF) in Reformat.h which has a list of these tags   */
    /* and a value of 8 is returned if we go from one of these being turned     */
    /* on to one being turned off.                                              */

    if (!(current->style & LINEBREAKOFF) && (last->style & LINEBREAKOFF)) return 8;
  }

  /* If none of the above conditions are met, we need no line break - return 0. */

  return 0;
}

/**************************************************************/
/* reformat_newline()                                         */
/*                                                            */
/* Returns 1 if a line break should be inserted onto the      */
/* page, or 0 if not. Does this by calling                    */
/* reformat_newline_check and is only interested in if the    */
/* value the call returned was zero or not.                   */
/*                                                            */
/* Parameters: As for reformat_newline_check.                 */
/*                                                            */
/* Returns:    1 = line break required, else 0.               */
/**************************************************************/

int reformat_newline(HStream * current, HStream * last, int offset)
{
  return (reformat_newline_check(current, last, offset) != 0);
}

/**************************************************************/
/* reformat_datasize()                                        */
/*                                                            */
/* Returns the size of standard data pointed to by an HStream */
/* (e.g. the length of any text string it points to).         */
/*                                                            */
/* Parameters: Pointer to the HStream struct                  */
/*                                                            */
/* Returns:    Size of associated data in bytes.              */
/**************************************************************/

static int reformat_datasize(HStream * tp)
{
  /* Is this a text item? */

  if (!reformat_istext(tp)) return 0;

  /* If the HStream has a pointer to some text, return the */
  /* length of that text, else return zero.                */

  return (tp->text ? strlen(tp->text) : 0);
}

/**************************************************************/
/* reformat_shift_vertically()                                */
/*                                                            */
/* Shifts all lines between two given line numbers            */
/* (inclusive) by a given y coordinate, in OS units. A redraw */
/* is generated with Wimp_BlockCopy if moved lines lie inside */
/* the visible area of the browser window.                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct holding       */
/*             information on the lines;                      */
/*                                                            */
/*             The line number at which to start (inclusive); */
/*                                                            */
/*             The line number at which to end (inclusive);   */
/*                                                            */
/*             The value to shift the lines by, in OS units - */
/*             since the Y coords of the lines are for a      */
/*             window, a negative value would move the lines  */
/*             down the window and vice versa.                */
/**************************************************************/

_kernel_oserror * reformat_shift_vertically(browser_data * b, int start, int end, int y_shift)
{
  _kernel_oserror         * e;
  reformat_cell           * cell = b->cell;
  int                       line;
  WimpGetWindowStateBlock   s;

  if (!y_shift) return NULL;

  /* Limit check start and end, and exit if there appear */
  /* to be no lines to move                              */

  if (start > cell->nlines - 1) return NULL;
  if (start < 0) start = 0;
  if (end > cell->nlines - 1) end = cell->nlines - 1;
  if (end < 0) end = 0;
  if (start > end) line = start, start = end, end = line;

  if ((end < 0) || (start < 0) || (!cell->ldata)) return NULL;

  /* Alter the lines' y-coordinates */

  for (line = start; line <= end; line ++) cell->ldata[line].y += y_shift;

  /* Have to force a redraw of the entire page to ensure */
  /* that image positions are updated                    */

  s.window_handle = b->window_handle;
  e = wimp_get_window_state(&s);
  if (e) return e;

  coords_box_toworkarea(&s.visible_area, (WimpRedrawWindowBlock *) &s);

  return wimp_force_redraw(s.window_handle,
                           s.visible_area.xmin,
                           s.visible_area.ymin,
                           s.visible_area.xmax,
                           s.visible_area.ymax);
}

/**************************************************************/
/* reformat_format_from()                                     */
/*                                                            */
/* Starts a new reformat session, possibly starting after a   */
/* given last line (i.e. from a certain point in the page,    */
/* rather than the whole page).                               */
/*                                                            */
/* The reformat session may be postponed until later          */
/* according to the RefoTime and RefoWait entires in the      */
/* Choices file.                                              */
/*                                                            */
/* The defined way to ensure all line and chunk data for a    */
/* given browser is freed, including that tied up in tables,  */
/* is by calling with the browser_data struct, -1, 1, and -1  */
/* (see parameters list below).                               */
/*                                                            */
/* Parameters: A pointer to a browser_data structure for      */
/*             which the reformat is to take place;           */
/*                                                            */
/*             The number of the last valid reformat_line     */
/*             structure;                                     */
/*                                                            */
/*             1 to format now, else the request may be       */
/*             delayed for some time;                         */
/*                                                            */
/*             For requests generated by the resizing of      */
/*             images, pass the image number, else pass -1.   */
/**************************************************************/

_kernel_oserror * reformat_format_from(browser_data * b, int lastline, int immediate, int image)
{
  _kernel_oserror * e;

  /* Do we delay these requests? Yes if told to in the Choices,  */
  /* in the function parameters, or if we're showing an external */
  /* image (want to see that come in progressively, not wait for */
  /* a reformat which is in this particular case completely      */
  /* trivial anyway).                                            */

  if (
       !choices.refo_wait ||
       immediate          ||
       b->displayed == Display_External_Image
     )
  {
    reformat_format_from_now(b, lastline);
  }
  else
  {
    if (b->refo_time)
    {
      /* If there's already a pending request, is the line number */
      /* specified for this one lower than the one already there? */
      /* If so, then use that higher line, else stick with the    */
      /* old one. Nothing else to do - the null handler takes     */
      /* care of it all.                                          */

      if (lastline < b->refo_line) b->refo_line = lastline;
    }
    else
    {
      /* This is the first reformat request; so set the timer and */
      /* install a null handler for it.                           */

      e = _swix(OS_ReadMonotonicTime,
                _OUT(0),

                &b->refo_time);

      if (e) return e;

      b->refo_line = lastline;

      register_null_claimant(Wimp_ENull, (WimpEventHandler *) reformat_format_timer, b);
    }
  }

  return NULL;
}

/**************************************************************/
/* reformat_format_timer()                                    */
/*                                                            */
/* Calls the reformatter after a delay given by the Choices   */
/* file entry 'RefoTime', according to the start time         */
/* specified by the 'refo_time' field of the browser_data     */
/* structure.                                                 */
/*                                                            */
/* Parameters are as standard for a Wimp event handler.       */
/**************************************************************/

int reformat_format_timer(int eventcode, WimpPollBlock * b, IdBlock * idb, browser_data * handle)
{
  int timenow;

  /* If there appears to be no initiation time specified in the      */
  /* browser_data structure, dereigster and exit (being cautions...) */

  if (!handle->refo_time)
  {
    handle->refo_time = 1; /* So that reformat_stop_pending will deregister this handler */

    reformat_stop_pending(handle);

    return 0;
  }

  /* Otherwise, get the current time into 'timenow' */

  if (_swix(OS_ReadMonotonicTime,
            _OUT(0),

            &timenow)) return 0;

  /* Do we need to reformat yet? */

  if (timenow - handle->refo_time > choices.refo_time)
  {
    /* reformat_format_from_now will deregister this handler */

    ChkError(reformat_format_from_now(handle, handle->refo_line));
  }

  return 0;
}

/**************************************************************/
/* reformat_format_from_now()                                 */
/*                                                            */
/* Starts a new reformat session, possibly starting after a   */
/* given last line (i.e. from a certain point in the page,    */
/* rather than the whole page).                               */
/*                                                            */
/* The reformat session will be stared immediately - it will  */
/* not be delayed. Don't call this directly - go through      */
/* reformat_format_from instead.                              */
/*                                                            */
/* Parameters: A pointer to a browser_data structure for      */
/*             which the reformat is to take place;           */
/*                                                            */
/*             The number of the last valid reformat_line     */
/*             structure.                                     */
/**************************************************************/

static _kernel_oserror * reformat_format_from_now(browser_data * b, int lastline)
{
  int             bottom = 0;
  reformat_cell * cell   = b->cell;

  /* If there is a threaded reformat going on, must tell it to exit */

  if (b->table_format != 0) b->table_format = 0;

  /* If this browser had any queued reformats, cancel them */

  if (b->refo_time)
  {
    if (b->refo_line < lastline) lastline = b->refo_line;

    reformat_stop_pending(b);
  }

  /* Line numbers less than -1 are invalid, and can't end */
  /* on a line greater than the number of lines present!  */

  if (lastline < -1) lastline = -1;
  if (lastline >= cell->nlines) lastline = cell->nlines - 1;

  /* Are we reformatting everything? */

  if (lastline < 0 && !printing)
  {
    WimpGetWindowStateBlock state;

    if (b->ancestor)
    {
//      windows_set_tools(b, NULL, 0, 0, 0, 0);
      windows_check_tools(b, NULL);
    }

    state.window_handle = b->window_handle;

    if (!wimp_get_window_state(&state))
    {
      /* Reset the minimum height setting */

      if (choices.refo_hold) b->min_height = state.visible_area.ymax - state.visible_area.ymin - state.yscroll;

      /* Pull the display width and extent down to match */
      /* the visible area, minimum values accepted.      */

      b->display_width = state.visible_area.xmax - state.visible_area.xmin;
      if (b->display_width < MinimumWidth) b->display_width = MinimumWidth;
      b->display_extent = b->display_width;
    }
    else b->min_height = 0;
  }

  /* Clear the flag that says formatting is suspended due to error */

  b->suspend_format = 0;

  /* Clear the field holding the last token number for which */
  /* reformatting was definitely completed                   */

  b->last_token = NULL;

  /* If lastline holds a valid line number, set bottom to the */
  /* bottom y coordinate of the last line. Otherwise leave    */
  /* bottom set at 0 (we're reformatting to no lines).        */

  if (lastline >= 0) bottom = cell->ldata[lastline].y;

  /* If there's existing line data, need to ensure that all  */
  /* memory allocated in table cells is freed before getting */
  /* rid of the lines after lastline.                        */

  tables_free_memory(1, b, cell, lastline + 1);

  /* If we're reformatting to less than the current number of */
  /* lines, 'chop off' those that are left over.              */

  if (lastline + 1 < cell->nlines)
  {
    int size;

    /* Size = offset of line chunks for the last line, plus  */
    /*        the number of line chunks times the size of a  */
    /*        chunk. I.e. the offset for the end of the line */
    /*        chunks for the last line - so size = size of   */
    /*        data that is needed for all the line chunks    */
    /*        with lastline chunks present.                  */

    if (lastline < 0) size = 0;
    else
    {
      /* If it turns out this line has no chunks, need to use the chunk address */
      /* and number of chunks for the previous line; unless, of course, this is */
      /* line 0, in which case there are no previous lines to refer to.         */

      if (!cell->ldata[lastline].n)
      {
        if (lastline == 0) size = 0;
        else size = (cell->ldata[lastline - 1].chunks + /* Base array offset into chunks                                    */
                    cell->ldata[lastline - 1].n)      * /* Add number of chunks for this line to get total number of chunks */
                    sizeof(reformat_line_chunk);        /* Multiply by size of a reformat_line_chunk to get total size      */
      }

      /* Otherwise, we're OK; the last line has line chunks. */

      else size = (cell->ldata[lastline].chunks +
                  cell->ldata[lastline].n)      *
                  sizeof(reformat_line_chunk);
    }

    /* Clip the number of lines to the new value */

    cell->nlines = lastline + 1;

    /* Make sure that the right amount of memory is allocated */

    dprintf(("LMem", "reformat_format_from: Chunk CK_LINE set to %d\n",(lastline + 1) * sizeof(reformat_line)));

    memory_set_chunk_size(b, cell, CK_LINE, (lastline + 1) * sizeof(reformat_line));

    dprintf(("LMem", "reformat_format_from: Chunk CK_LDAT set to %d\n",size));

    memory_set_chunk_size(b, cell, CK_LDAT, size);
  }

  if (!printing)
  {
    /* Ensure null events are claimed for the rest of the reformat */

    if (!b->fetch_handler) fetchpage_claim_nulls(b);

    /* Update the status bar */

    toolbars_update_status(b, Toolbars_Status_Formatting);
  }

  /* Ensure the pointer shape is OK */

  browser_pointer_check(0, NULL, NULL, b);

  #ifndef PARANOID_REFORMAT

    return NULL;

  #else

    /* Redraw the bottom line of the window if not printing */

    return (!printing ? browser_update_bottom(b, bottom) : NULL);

  #endif
}

/**************************************************************/
/* reformat_stop_pending()                                    */
/*                                                            */
/* Stops any pending reformats from happening, deregistering  */
/* handlers etc. as needed.                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the queue.                                     */
/**************************************************************/

void reformat_stop_pending(browser_data * b)
{
  if (b->refo_time) deregister_null_claimant(Wimp_ENull, (WimpEventHandler *) reformat_format_timer, b);

  b->refo_time = 0;
  b->refo_line = Reformat_UnrealisticallyHighLineNumber;
}

/**************************************************************/
/* reformat_correct_for_alignment()                           */
/*                                                            */
/* Given a bounding box representing an image or object with  */
/* xmin/ymin = 0 and xmax/ymax = width/height, shift the      */
/* coordinates vertically to account for alignment to text on */
/* the baseline around y = 0 according go the given image     */
/* alignment type.                                            */
/*                                                            */
/* Parameters: Pointer to a browser_data structure relevant   */
/*             to the image or object being corrected;        */
/*                                                            */
/*             Pointer to the token representing the image or */
/*             object;                                        */
/*                                                            */
/*             Alignment of that image or object;             */
/*                                                            */
/*             Bounding box with xmin = ymin = 0, xmax =      */
/*             width, ymax = height, all in OS units. On exit */
/*             box may have been updated.                     */
/**************************************************************/

static void reformat_correct_for_alignment
            (
              const browser_data * restrict b,
              const HStream      * restrict tp,
              imgalign                      align,
              BBox               * restrict box
            )
{
  fm_face h;
  BBox    hbox;
  int     height = 0;

  (void) b; /* Not used now, but might be used for scaling in future */

  /* We can't easily find out how high text is surrounding */
  /* the image for align=top, align=middle or whatever,    */
  /* but we can do a reasonable guess based on whatever    */
  /* font the given token would use if it held text.       */

  h = fm_find_token_font(NULL, tp, 0);

  if (h)
  {
    if (!fm_font_box(h, &hbox)) height = hbox.ymax - hbox.xmin;

    fm_lose_font(NULL, h);
  }

  /* Default alignment is to the baseline, which needs no  */
  /* modification. The other cases require more effort.    */

  switch (align)
  {
    case imgalign_MIDDLE:
    {
      int hh = height    / 3; /* Technically '/ 2', but '/ 3' looks, on average, better in practice */
      int ym = box->ymax / 2;

      box->ymin = box->ymin - ym + hh;
      box->ymax = box->ymax - ym + hh;
    }
    break;

    case imgalign_TOP:
    {
      box->ymin = height - box->ymax;
      box->ymax = height;
    }
    break;
  }

  /* That's it! */

  return;
}

/**************************************************************/
/* reformat_get_image_size()                                  */
/*                                                            */
/* Gets a BBox for a specified image in OS coordinates        */
/* relative to the font base line and left hand edge.         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
/*                                                            */
/*             A token address for the image;                 */
/*                                                            */
/*             Pointer to a BBox in which the relevant coords */
/*             are returned.                                  */
/*                                                            */
/* Assumes:    Pointer to the BBox may not be NULL.           */
/**************************************************************/

_kernel_oserror * reformat_get_image_size
                  (
                    browser_data  * restrict b,
                    const HStream * restrict tp,
                    BBox          * restrict box
                  )
{
  _kernel_oserror * e;
  imgalign          align;

  /* Get the image size from the image library */

  e = image_get_token_image_size(b, tp, box);
  if (e) return e;

  /* Account for HSPACE / VSPACE and a border for images (nothing */
  /* for image based input elements).                             */

  if (tp->style & IMG)
  {
    /* At the moment the bounding box is based at (0,0) with the  */
    /* max fields holding width and height - that's how the token */
    /* size call made above says it returns info. So multiply the */
    /* spaces by 4: 2 for 1 'web pixel' -> 2 OS units; 2 more for */
    /* the combination of left/right top/bottom borders/spacers.  */

    int border = HtmlIMGborder(tp) * 4;
    int vspace = HtmlIMGvspace(tp) * 4;
    int hspace = HtmlIMGhspace(tp) * 4;

    box->xmax += border + hspace;
    box->ymax += border + vspace;
  }

  /* Deal with alignments now that borders and spacers are included */

  if (tp->style & IMG) /* It'll either be an IMG or an INPUT TYPE=IMAGE item */
  {
    if      ((tp->type & TYPE_ALIGN_MASK) == TYPE_MIDDLE) align = imgalign_MIDDLE;
    else if ((tp->type & TYPE_ALIGN_MASK) == TYPE_TOP)    align = imgalign_TOP;
    else                                                  align = imgalign_NONE;
  }
  else align = HtmlINPUTalign(tp);

  reformat_correct_for_alignment(b, tp, align, box);

  return NULL;
}

/**************************************************************/
/* reformat_get_object_size()                                 */
/*                                                            */
/* Gets a BBox for a specified Object in OS coordinates       */
/* relative to the font base line and left hand edge.         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the Object;                                    */
/*                                                            */
/*             A token address for the Object;                */
/*                                                            */
/*             Pointer to a BBox in which the relevant coords */
/*             are returned.                                  */
/*                                                            */
/* Assumes:    Pointer to the BBox may not be NULL.           */
/**************************************************************/

_kernel_oserror * reformat_get_object_size
                  (
                    browser_data  * restrict b,
                    const HStream * restrict tp,
                    BBox          * restrict box
                  )
{
  /* Get the Object size from the Object library */

  RetError(object_get_token_object_size(b, tp, box));

  /* At the moment the bounding box is based at (0,0) with the  */
  /* max fields holding width and height - that's how the token */
  /* size call made above says it returns info. So multiply the */
  /* spaces by 4: 2 for 1 'web pixel' -> 2 OS units; 2 more for */
  /* the combination of left/right top/bottom borders/spacers.  */

  int border = HtmlOBJECTborder(tp) * 4;
  int vspace = HtmlOBJECTvspace(tp) * 4;
  int hspace = HtmlOBJECThspace(tp) * 4;

  box->xmax += border + hspace;
  box->ymax += border + vspace;

  /* Deal with alignments */

  reformat_correct_for_alignment(b,
                                 tp,
                                 HtmlOBJECTalign(tp),
                                 box);
  return NULL;
}

/**************************************************************/
/* reformat_get_placeholder_size()                            */
/*                                                            */
/* Gets a BBox that a placeholder would fill based on given   */
/* ALT text to plot inside it.                                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the placeholder;                               */
/*                                                            */
/*             Pointer to an HStream struct representing the  */
/*             placeholder (or NULL for a default size        */
/*             holder);                                       */
/*                                                            */
/*             Pointer to the ALT text (or NULL or a null     */
/*             string for no text);                           */
/*                                                            */
/*             Pointer to a BBox, in which the required       */
/*             bounding box for the placeholder is written.   */
/*                                                            */
/* Assumes:    Pointer to the BBox not NULL and valid.        */
/**************************************************************/

void reformat_get_placeholder_size
     (
       browser_data  * restrict b,
       const HStream * restrict tp,
       const char    * restrict text,
       BBox          * restrict box
     )
{
  int  h, temp, size;
  BBox fbox;

  /* Quick sanity check */

  if (!box) return;

  box->xmin = box->ymin = 0;

  if (!b || !tp || !text || !*text)
  {
    box->xmax = ImageDefaultOSSize_X;
    box->ymax = ImageDefaultOSSize_Y;

    return;
  }

  /* Claim the font */

  size = (fm_size(tp->fontsize) * 80) / 100;

  h = fm_find_font(b,
                   "sans",
                   size,
                   size,
                   0,
                   0);

  /* Find the string width of the ALT text */

  fm_get_string_width(h,
                      text,
                      Reformat_AsWideAsPossible_MP,
                      strlen(text),
                      -1,
                      &temp,
                      &box->xmax);

  convert_to_os(box->xmax, &box->xmax);

  /* Find the font height */

  fm_font_box(h, &fbox);

  /* As well as subtracting ymin (the y minimum coordinate */
  /* of the font bbox) from ymax, need to also add some    */
  /* height to give a gap between the text and slabbed box */
  /* that's drawn to mark the image's position.            */

  box->ymax = fbox.ymax - fbox.ymin;

  convert_to_os(choices.font_size, &temp);

  if (temp < 20) temp = 20;

  box->ymax += temp;
  box->xmax += temp + temp / 2; /* Looks better to have extra horizontally */

  /* Don't want to force the page width up just because of */
  /* ALT text in images, especially in narrow items such   */
  /* as navigation frames, so limit check xmax.            */

  // Currently this is done by an absolute hard coded upper
  // limit, but ultimately it would ideally be limited e.g.
  // by cell width. Just as soon as I work out a nice way
  // of doing that... (Remember, you may not know the cell
  // width at times when this is being called to try and
  // determine it; yet you must return consistent and
  // appropriate values subsequently for redraw purposes).

  {
    int remain;

    convert_to_os(b->left_margin + b->right_margin, &remain);

    remain = b->display_width - remain;
    if (remain > 320) remain = 320;

    if (box->xmax > remain) box->xmax = remain;
  }

  /* Finished */

  return;
}

/**************************************************************/
/* reformat_bullet_width()                                    */
/*                                                            */
/* Returns the width of a given bullet in OS units.           */
/*                                                            */
/* Parameters: The bullet number (in the Sprites file,        */
/*             bullets are named b1, b2, ...bn).              */
/**************************************************************/

int reformat_bullet_width(int bullet)
{
  char spr[32];
  int  w;

  sprintf(spr, "b%d\0", (bullet + bullets - 1) % bullets);

  if (utils_read_sprite_size(spr, &w, NULL)) w = 32;

  /* See top of the file for BULLET_GAP */

  return w + BULLET_GAP;
}

/**************************************************************/
/* reformat_bullet_height()                                   */
/*                                                            */
/* Returns the height of a given bullet in OS units.          */
/*                                                            */
/* Parameters: The bullet number (in the Sprites file,        */
/*             bullets are named b1, b2, ...bn).              */
/**************************************************************/

int reformat_bullet_height(int bullet)
{
  char spr[32];
  int  h;

  sprintf(spr, "b%d\0", (bullet + bullets - 1) % bullets);

  if (utils_read_sprite_size(spr, NULL, &h)) h = 32;

  return h;
}

/**************************************************************/
/* reformat_y_offset()                                        */
/*                                                            */
/* Returns the y offset from the top of a page, in OS units,  */
/* for all lines on that page.                                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct representing  */
/*             the page.                                      */
/*                                                            */
/* Returns:    y offset for all the lines on the page, in OS  */
/*             units, from the top.                           */
/**************************************************************/

int reformat_y_offset (browser_data * b)
{
  int offset;

  if (!controls.swap_bars) offset = toolbars_button_height(b) + toolbars_url_height(b);
  else                     offset = toolbars_status_height(b);

  /* Account for the bottom window frame of the toolbars */

  if (offset) offset += wimpt_dy();

  if (!b->ancestor) offset += b->leading; /* Only put a gap at the top for base browsers, not for frames */

  return -offset;
}

/**************************************************************/
/* reformat_text_line_height()                                */
/*                                                            */
/* Works out how tall a line of text should be, returning the */
/* height above and below the notional text baseline in OS    */
/* units.                                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the line;                                      */
/*                                                            */
/*             Pointer to an HStream which is used to         */
/*             determine what font the line would use;        */
/*                                                            */
/*             Pointer to an int, in which the height above   */
/*             the baseline is written;                       */
/*                                                            */
/*             Pointer to an int, in which the height below   */
/*             the baseline is written.                       */
/*                                                            */
/* Assumes:    Either int pointer may be NULL. If the HStream */
/*             pointer is NULL, a value based on the base     */
/*             (normal) font size will be used.               */
/**************************************************************/

_kernel_oserror * reformat_text_line_height(browser_data * b, HStream * tp, int * top, int * bot)
{
  int  h;
  int  rettop, retbot;
  BBox box;

  if (tp) h = fm_find_token_font(b, tp, 1);
  else    h = fm_find_font(b, "serif", choices.font_size, choices.font_size, 0, 0);

//  {
//     int face, size, italic, bold, scale;

  RetError(fm_font_box(h, &box));

  /* We know the font is 'size' 16ths, so we can work */
  /* out the line spacing from this. Don't use the    */
  /* font metrics - otherwise, bold text (say) will   */
  /* force the line spacing higher than plain.        */

  if (b->page_is_text && !choices.system_font)
  {
    rettop = box.ymax - b->leading;
    retbot = -box.ymin;
  }
  else
  {
    rettop = box.ymax;
    retbot = -box.ymin + b->leading;
  }

//     fm_token_font_info(tp, &face, &size, &italic, &bold);
//
//     bot = b->leading;
//
//     convert_to_points(1, &scale);
//     top += (size * 1000) / (16 * scale);

  if (top) *top = rettop;
  if (bot) *bot = retbot;

  return NULL;
}

/**************************************************************/
/* reformat_check_height()                                    */
/*                                                            */
/* Looks at the contents of a reformat_line structure and     */
/* ensures that it's y coordinate, height and font baseline   */
/* offset fields are correctly filled in.                     */
/*                                                            */
/* Parameters: 1 for all external callers, but will be 0 if   */
/*             it calls itself internally;                    */
/*                                                            */
/*             Pointer to a browser_data struct relevant to   */
/*             the line;                                      */
/*                                                            */
/*             Pointer to a reformat_cell struct that the     */
/*             line lies in;                                  */
/*                                                            */
/*             Number of the line to alter;                   */
/*                                                            */
/*             Pointer to the token that may cause the line   */
/*             height to alter;                               */
/*                                                            */
/*             Pointer to the last token dealt with by the    */
/*             reformatter;                                   */
/*                                                            */
/*             Offset into the current token's data.          */
/*                                                            */
/* Returns:    Fills in bits of the line struct, as mentioned */
/*             above.                                         */
/**************************************************************/

static _kernel_oserror * reformat_check_height(int toplevel, browser_data * b, reformat_cell * d, int line, HStream * tp, HStream * tpLast, int offset)
{
  _kernel_oserror * e;
  int               top     = 0;
  int               bot     = 0;
  int               setpara = 0; /* Flags that a paragraph break should be added later on */
  int               waspara = 0; /* Flags that a paragraph break was due to a P tag and nothing else */
  int               dy;

  if (!d) d = b->cell;

  /* Some initial white space calculations. All these rely on the */
  /* item being at the start of a paragraph - 'offset' is zero.   */

  if (!offset)
  {
    #ifdef SUPPORT_PER_LINE_PARA_MARKS

      if (
           d->ldata[line].n &&
           (d->cdata[d->ldata[line].chunks].t->flags & HFlags_MarksParaSpace)
         )
      {
        setpara = 1;
      }
      else
      {

    #endif

        /* If the token represents a line break, include a gap, unless */
        /* we're at the top of a page / cell or just after a LI tag.   */

        if (
             line > 0              &&
             tpLast                &&
             !(tpLast->style & LI) &&
             (tp->style & P)
           )
           setpara = 1, waspara = 1;

        /* Alternatively, if the indent has changed, insert some */
        /* space above the item (but don't do this for UL and DL */
        /* items, as these are handled more carefully later).    */

        else if (
                  tpLast                       &&
                  tpLast->indent != tp->indent &&
                  !(tp->style & UL)            &&
                  !(tp->style & DL)
                )
                setpara = 1;

        /* The next few require text before them to gain a gap, or if */
        /* the last tag was BR and the tag before that was text, the  */
        /* gaps can still be added as BR just breaks the line.        */

        else if (
                  tpLast &&
                  (
                    (tpLast->style & PCDATA) ||
                    (
                      (tpLast->tagno == TAG_BR)      &&
                      tpLast->prev                   &&
                      (tpLast->prev->style & PCDATA)
                    )
                  )
                )
        {
          /* Want a space above UL items */

          if (tp->style & UL) setpara = 1;

          /* If a header type has changed, and we are dealing with a */
          /* text token, insert a gap above the item to push it away */
          /* either from the text above or from the header above.    */

          else if (
                    (tp->style & PCDATA) &&
                    redraw_header(tp->style) != redraw_header(tpLast->style)
                  )
                  setpara = 1;

          /* If we're about to enter a definition list, the 'spaces if */
          /* indent changes' code above will make the spaces look odd  */
          /* unless we also give a space above the first item in the   */
          /* definition list (the DT elements are not indented, so no  */
          /* white space would have been inserted so far).             */

          else if (tp->style & DL) setpara = 1;
        }

    #ifdef SUPPORT_PER_LINE_PARA_MARKS
      }
    #endif

  }

  /* If flagged to do so, set 'top' for an initial paragraph break */

  if (setpara)
  {
    int texttop, textbot;

    RetError(reformat_text_line_height(b,
                                       NULL,
                                       &texttop,
                                       &textbot));

    top = ((texttop + textbot) * 7) >> 3;

    #ifdef SUPPORT_PER_LINE_PARA_MARKS

      /* If this is the first token in a line, set the paragraph */
      /* bit else clear it                                       */

      if (d->ldata[line].n && d->cdata[d->ldata[line].chunks].t == tp)
      {
        tp->flags |= HFlags_MarksParaSpace;
      }
      else
      {
        tp->flags &= ~HFlags_MarksParaSpace;
      }

    #endif
  }

  #ifdef SUPPORT_PER_LINE_PARA_MARKS

    else
    {
      /* Ensure the token's paragraph bit is clear */

      tp->flags &= ~HFlags_MarksParaSpace;
    }

  #endif

  /* BRs - a single BR between bits of text will force a new line and be the     */
  /* first token in the new line, but will then have other tokens in that same   */
  /* line. It should not alter the line height itself under these circumstances. */
  /* However, two consecutive BRs should - that is, when the second is found, it */
  /* should force a P-style break, and so-on for all subsequent BRs. It is also  */
  /* the case that a BR at the top of a page / cell should similarly force a     */
  /* paragraph-like break.                                                       */

  {
    HStream * fol; /* First On Line */

    fol = d->cdata[d->ldata[line].chunks].t;

    if (
         (fol->tagno == TAG_BR) &&
         (
           (
             fol->prev &&
             (fol->prev->tagno == TAG_BR)
           )
           || line == 0
         )
       )
    {
      int texttop, textbot;

      RetError(reformat_text_line_height(b,
                                         tp,
                                         &texttop,
                                         &textbot));

      top = texttop + textbot;
    }
  }

  /* Find out the height of an image */

  if (
       (tp->style & IMG) ||
       (
         tp->tagno         == TAG_INPUT &&
         HtmlINPUTtype(tp) == inputtype_IMAGE
       )
     )
  {
//    /* If the image floats to the left or right, add it to the deferred */
//    /* list so that on the next new line we can place it. Do not change */
//    /* the height of the *current* line at all. Otherwise, treat it as  */
//    /* an in-this-line image, and adjust line height accordingly.       */
//
//    imgalign align;
//
//    if (tp->style & IMG)
//    {
//      if      ((tp->type & TYPE_ALIGN_MASK) == TYPE_LEFT)  align = imgalign_LEFT;
//      else if ((tp->type & TYPE_ALIGN_MASK) == TYPE_RIGHT) align = imgalign_RIGHT;
//      else                                                 align = imgalign_NONE;
//    }
//    else align = HtmlINPUTalign(tp);
//
//    if (
//         align != imgalign_LEFT &&
//         align != imgalign_RIGHT
//       )
//    {
//      /* Not floating */

      BBox box;

      RetError(reformat_get_image_size(b, tp, &box));

      top +=  box.ymax;
      bot  = -box.ymin;
//    }
//    else
//    {
//      /* Is floating */
//    }
  }

  /* Deal with OBJECT, APPLET and EMBED tags */

  else if (ISOBJECT(tp))
  {
    BBox box;

    RetError(reformat_get_object_size(b, tp, &box));

    top += box.ymax;
    bot  = -box.ymin;
  }

  /* Size of a horizontal rule; the rule is plotted */
  /* centred vertically within its bounding box so  */
  /* there is no need to set both bot and top to    */
  /* the same value. With top = 0, setting bot is   */
  /* enough.                                        */

  else if (tp->style & HR)
  {
    int size;

    /* Deal with a (vertical) size specifier */

    if (HR_HAS_SIZE(tp))
    {
      /* (Only recognise pixels at present) */

      switch (HR_SIZE_UNITS(tp))
      {
        case UNITS_PIXELS: size = HR_SIZE(tp) * 2; break;

        default: size = 4; break;
      }
    }
    else size = 4;

    if (size < 24) size = 24;

    bot = size + 4;
  }

  /* A few easy to work out forms elements */

  else if (
            tp->tagno         == TAG_INPUT &&
            HtmlINPUTtype(tp) == inputtype_CHECKBOX
          )
  {
    int size;

    utils_read_sprite_size("fopton", NULL, &size);
    top += size - 8;
    bot = 8;
  }

  else if (
            tp->tagno         == TAG_INPUT &&
            HtmlINPUTtype(tp) == inputtype_RADIO
          )
  {
    int size;

    utils_read_sprite_size("fradioon", NULL, &size);
    top += size - 8;
    bot = 8;
  }

  /* Height of a bullet point */

  else if (ISBULLET(tp))
  {
    top += reformat_bullet_height(tp->indent);
  }

  else if (tp->tagno == TAG_TABLE)
  {
    /* Don't do anything! h is already correct */

    tp = tp; /* Make sure the compiler gets the if..else if.. etc. right */
  }

  /* If the above matches aren't found, use a more general routine */

  else
  {
    /* Get the bounding box of the font that should be used for the token */
    /* if we've got some text, and we're either a visible forms element   */
    /* or the text consists of more than one single space.                */

    if (
         (
           (tp->style & FORM)        &&
           tp->tagno != TAG_FORM     &&
           tp->tagno != TAG_FORM_END &&
           HtmlINPUTtype(tp) != inputtype_HIDDEN
         )

         /* In the case of '<p> <b>text', "text" does not have the P bit  */
         /* set in the style word. This comes in the token preceeding it. */
         /* However, that token has the white space stripped leaving it   */
         /* with a NULL text field. So, for this specific special case,   */
         /* allow line height to be allocated.                            */

         ||
         (
           (tp->style & PCDATA) &&
           !tp->text            &&
           waspara
         )

         /* If all else fails, make sure we've got more than a single */
         /* space in the text.                                        */

         ||
         (
           (tp->text) &&
           (
             tp->text[0] &&
             !
             (
               tp->text[0] == ' '  &&
               tp->text[1] == '\0'
             )
           )
         )
       )
    {
      int texttop, textbot;

      RetError(reformat_text_line_height(b,
                                         tp,
                                         &texttop,
                                         &textbot));

      top += texttop;
      bot =  textbot;
    }
  }

  /* Work out height of various forms elements */

  if (tp->tagno == TAG_TEXTAREA)
  {
    /* Text areas, based on the number of rows */

    BBox box;
    int  h;
    int  r;
    int  lh, lb;

    h = fm_find_token_font(b, tp, 0);
    e = fm_font_box(h, &box);
    if (e) return e;

    r = tp->rows;
    if (r < 2) r = 2;

    form_get_linesize(&box, &lh, &lb);

    bot += lh * (r - 1) + 8; /* + 8 for the border; r - 1 as bot is already below the first text line, so drop it by (rows - 1) more  */
    top += 8;
  }
  else if (tp->tagno == TAG_SELECT)
  {
    /* Selection lists - a pop-up menu icon */

    int h;

    if (utils_read_sprite_size("fgright", NULL, &h)) h = 44;

    bot += 8;
    top += 8;

    if (top + bot < h) top += h - top - bot;
  }
  else if (tp->tagno == TAG_INPUT)
  {
    /* General input types */

    switch(HtmlINPUTtype(tp))
    {
      case inputtype_TEXT: /* No break - same as PASSWORD */
      case inputtype_PASSWORD:
      {
        bot += 8;
        top += 8;
      }
      break;

      case inputtype_SUBMIT: /* No break - same as RESET */
      case inputtype_BUTTON: /* Again, no break          */
      case inputtype_RESET:
      {
        bot += 8;
        top += 12;
      }
      break;
    }
  }

  /* Round up top and bot to a multiple of wimpt_dy */

  dy = wimpt_dy() - 1;

  if (top & dy) top += dy + 1 - (top & dy);
  if (bot & dy) bot += dy + 1 - (bot & dy);

  /* 'top' will correspond to the line height above the font baseline. */
  /* If it is greater than the current value, extend the top of the    */
  /* line by the difference. Move the line y coordinate down to make   */
  /* room for the extra height.                                        */

  if (top > (d->ldata[line].h - d->ldata[line].b))
  {
    int diff;

    diff = top - (d->ldata[line].h - d->ldata[line].b);

    d->ldata[line].h += diff;
    d->ldata[line].y -= diff;
  }

  /* Similarly, if bot is greater than the offset of the baseline from */
  /* the bottom of the line, account for the extra offset.             */

  if (bot > d->ldata[line].b)
  {
    int diff;

    diff = bot - d->ldata[line].b;

    d->ldata[line].h += diff; /* (Since 'h' is the total height above and below the baseline) */
    d->ldata[line].b += diff;
    d->ldata[line].y -= diff;
  }

  return NULL;
}

/**************************************************************/
/* reformat_check_visited()                                   */
/*                                                            */
/* Looks at a given token and compares it to the global       */
/* history, setting a bit in the flags word if a link it      */
/* represents has been visited before.                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the token;                                     */
/*                                                            */
/*             Pointer to the token.                          */
/**************************************************************/

static void reformat_check_visited(browser_data * b, HStream * token)
{
  if (ISLINK(token) && history_visited(token->anchor)) token->flags |= HFlags_LinkVisited;
}

/**************************************************************/
/* reformat_check_extent()                                    */
/*                                                            */
/* Sets the browser window vertical extent to match the page, */
/* by looking at the last line in the line list.              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct holding       */
/*             details of the window to alter.                */
/**************************************************************/

_kernel_oserror * reformat_check_extent(browser_data * b)
{
  /* Nothing to do for small fetch windows */

  if (b->small_fetch) return NULL;

  /* Otherwise exit through the extent setting routines */

  return reformat_set_extent(b, -reformat_return_extent(b, NULL));
}

/**************************************************************/
/* reformat_return_extent()                                   */
/*                                                            */
/* Returns the height of a page in OS units, according to its */
/* current formatted state.                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct holding       */
/*             details of the page;                           */
/*                                                            */
/*             Pointer to a reformat_cell struct holding      */
/*             redraw information.                            */
/**************************************************************/

int reformat_return_extent(browser_data * b, reformat_cell * cell)
{
  int extent = 0;

  if (!cell) cell = b->cell;

  if (cell->ldata) extent = -cell->ldata[cell->nlines - 1].y;

  return extent;
}

/**************************************************************/
/* reformat_set_extent()                                      */
/*                                                            */
/* Sets the browser window vertical extent. The extent can    */
/* only ever grow.                                            */
/*                                                            */
/* Parameters: A pointer to a browser_data structure          */
/*             containing details of the window to alter;     */
/*                                                            */
/*             A new vertical extent in OS units - this is a  */
/*             *negative* number, expressed as a downward     */
/*             offset from the top of the window.             */
/**************************************************************/

_kernel_oserror * reformat_set_extent(browser_data * b, int y_extent)
{
  WimpGetWindowStateBlock s;
  BBox                    new_extent;
  int                     hbot, width;

  dprintf(("Refo", "\nreformat_set_extent: Called, -y_extent = %d\n",-y_extent));

  /* For windows with frames, don't want to mess around with the extent */

  if (b->nchildren) return NULL;

  s.window_handle = b->window_handle;
  RetError(wimp_get_window_state(&s));

  /* Y extent is set to the requested value plus an amount for the toolbars */
  /* and an extra amount for aesthetics.                                    */

  if (!controls.swap_bars) hbot = toolbars_status_height(b);
  else                     hbot = toolbars_button_height(b) + toolbars_url_height(b);

  y_extent -= (hbot + b->leading);

  /* Ensure that the extent is at least as great as the minimum height */

  if ((-y_extent) < b->min_height) y_extent = -(b->min_height);

  /* For the height, don't want to resize below the current */
  /* visible height. Things are a bit messy due to the      */
  /* negative signs on extent, etc.                         */

  if ((-y_extent) < (s.visible_area.ymax - s.visible_area.ymin)) y_extent = -(s.visible_area.ymax - s.visible_area.ymin);

  new_extent.ymax = 0;
  new_extent.ymin = y_extent;

  /* x extent must only match or be larger than the visible */
  /* area, never smaller.                                   */

  width = s.visible_area.xmax - s.visible_area.xmin;

  if (b->display_width  < width)            b->display_width  = width;
  if (b->display_extent < b->display_width) b->display_extent = b->display_width;

  new_extent.xmin = 0;
  new_extent.xmax = b->display_extent;

  /* Update height, too */

  {
    int h1, h2;

    h1 = toolbars_button_height(b) + toolbars_url_height(b);
    h2 = toolbars_status_height(b);

    if (h1) h1 += wimpt_dy();
    if (h2) h2 += wimpt_dy();

    b->display_height = s.visible_area.ymax - s.visible_area.ymin - h1 - h2;
  }

  /* Set the extent */

  RetError(window_set_extent(0,b->self_id,&new_extent));

  /* Can't set extent so visible area is now outside the work area; */
  /* call wimp_open_window to make sure scroll positions are OK.    */

  {
    ObjectId    po;
    ComponentId pc;

    RetError(toolbox_get_parent(0, b->self_id, &po, &pc));

    return toolbox_show_object(0, b->self_id, 1, (void *) &s.visible_area, po, pc);
  }
}

/**************************************************************/
/* reformat_return_width()                                    */
/*                                                            */
/* Returns the width of a page in OS units, according to its  */
/* current formatted state - i.e. this looks through the line */
/* list to find the widest line.                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct holding       */
/*             details of the page;                           */
/*                                                            */
/*             Pointer to a reformat_cell struct holding      */
/*             redraw information.                            */
/**************************************************************/

int reformat_return_width(browser_data * b, reformat_cell * cell)
{
  int widest = 0;

  if (!cell) cell = b->cell;

  if (cell->ldata)
  {
    int l;

    for (l = 0; l < cell->nlines; l++)
    {
      int c, w = 0;

      for (
            c = cell->ldata[l].chunks;
            c < cell->ldata[l].chunks + cell->ldata[l].n;
            c++
          )
      {
        w += cell->cdata[c].w;
      }

      convert_to_os(w, &w);
      if (w > widest) widest = w;
    }
  }

  return widest;
}

/**************************************************************/
/* reformat_add_line()                                        */
/*                                                            */
/* Adds a line to the array of line structures. The contents  */
/* are NOT initialised.                                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page;                                      */
/*                                                            */
/*             Pointer to the reformat_cell structure to add  */
/*             the chunks to.                                 */
/**************************************************************/

static _kernel_oserror * reformat_add_line(browser_data * b, reformat_cell * cell)
{
  _kernel_oserror * e;

  dprintf(("Refo", "reformat_add_line: Called with cell %p, cell->nlines = %d\n",cell,cell->nlines));

  /* Allocate memory for the new number of lines */

  dprintf(("LMem", "reformat_add_line: Chunk CK_LINE set to %d\n",(cell->nlines + 1) * sizeof(reformat_line)));

  e = memory_set_chunk_size(b,
                            cell,
                            !cell->table ? CK_LINE : CK_LINV, /* Variable granularity allocation for table cells */
                            (cell->nlines + 1) * sizeof(reformat_line));
  if (e) return e;

  /* Increment the line counter in the browser_data structure */

  cell->ldata[cell->nlines].x = cell->ldata[cell->nlines].y = 0;

  cell->nlines++;

//  memset( - something! - ,0,sizeof(reformat_line));

  dprintf(("Refo", "reformat_add_line: Successful with cell->nlines = %d\n",cell->nlines));

  return NULL;
}

/**************************************************************/
/* reformat_add_line_chunk()                                  */
/*                                                            */
/* Adds a line chunk to the array of line chunks associated   */
/* with a particular line structure. This is complicated      */
/* slightly by the variable length of the arrays of line      */
/* chunks. The new chunk's contents are NOT initialised.      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page;                                      */
/*                                                            */
/*             Pointer to the reformat_cell structure to add  */
/*             the chunks to.                                 */
/**************************************************************/

static _kernel_oserror * reformat_add_line_chunk(browser_data * b, reformat_cell * cell)
{
  int               size, cline = cell->nlines - 1;
  _kernel_oserror * e;

  dprintf(("Refo", "reformat_add_line_chunk: Called\n"));

  /* The function can only ever add a chunk to the end of the list. */
  /* So the chunk must belong to the last line in the list, and     */
  /* if it is the first chunk for the line structure that line      */
  /* structure's pointer to the chunks will be filled in. The chunk */
  /* counter for that line is incremented.                          */

  #ifdef TRACE
    /* If there are no lines, we can't proceed - something has gone wrong */

    if (!cell->nlines)
    {
      erb.errnum = 0;

      strcpy(erb.errmess,
             "Serious internal error - There are no line structures defined in reformat_add_line_chunk; must exit immediately.");
      show_error(&erb);
    }
  #endif

  /* If there is no chunk data already, this is the first   */
  /* chunk allocation so the block size we want to move to  */
  /* is easy to work out.                                   */

  if (!cell->cdata) size = sizeof(reformat_line_chunk);
  else
  {
    /* We want to find the current size of data and put it into size. To do this, */
    /* get the last line's offset to the chunks and add the number of chunks it   */
    /* claims to have multiplied by the size of one chunk. The complication is    */
    /* that the last line(s) may not have any chunks, so we need to go back to    */
    /* a line that does, if that is the case.                                     */

    while (!cell->ldata[cline].n && cline >= 0) cline --;

    #ifdef TRACE
      if (cline < 0)
      {
        erb.errnum = 0;

        strcpy(erb.errmess,
               "Serious internal error - No lines have associated chunks defined in reformat_add_line_chunk; must exit immediately.");
        show_error(&erb);
      }
    #endif

    size = (cell->ldata[cline].chunks +
            cell->ldata[cline].n + 1) *
            sizeof(reformat_line_chunk);
  }

  // if (cell->cdata) dprintf(("", "!! Consistency check - Current block size for chunks  = %p\n",(void *) flex_size((flex_ptr) &cell->cdata)));
  // else dprintf(("", "!! Consistency check - Current block size for chunks  = none allocated\n"));
  // dprintf(("", "!!                     New block size to be allocated = %p\n",(void *) size));

  /* Now allocate the memory */

  dprintf(("LMem", "reformat_add_line_chunk: Chunk CK_LDAT set to %d\n",size));

  e = memory_set_chunk_size(b,
                            cell,
                            !cell->table ? CK_LDAT : CK_LDAV, /* Variable granularity allocation for table cells */
                            size);
  if (e) return e;

  /* Update the chunk counter on the last line and the base chunk */
  /* array number, if it wasn't already set (when the line is     */
  /* created, the chunks field is filled with -1. When the first  */
  /* chunk is added for the line the chunks field is filled in,   */
  /* and it is left alone subsequently - which is exactly what we */
  /* want, as the chunks field holds the base array index of the  */
  /* chunks for the line, not the last chunk array index.         */

  cline = cell->nlines - 1;
  cell->ldata[cline].n++;
  if (cell->ldata[cline].chunks < 0) cell->ldata[cline].chunks = (int) size / sizeof(reformat_line_chunk) - 1;

  /* Success */

  dprintf(("Refo", "reformat_add_line_chunk: Successful\n"));

  return NULL;
}

/**************************************************************/
/* reformat_reformatter()                                     */
/*                                                            */
/* The actual working end of the reformat routines - takes    */
/* the list of HStream structs (or tokens) and turns them     */
/* into reformat_line structures for the redraw routines etc. */
/*                                                            */
/* Parameters: Pointer to a browser_data struct containing    */
/*             all the info on the fetch for which            */
/*             reformatting is to take place.                 */
/**************************************************************/

void reformat_reformatter(browser_data * b)
{
  #ifdef SUPPORT_MTT

    if (controls.table_multi != 0)
    {
      if (poll_counter == 0)
      {
        _swix(OS_ReadMonotonicTime,
              _OUT(0),

              &poll_counter);
      }

      b->poll_redraw = b->cell->nlines <= 1 ? 0 : b->cell->ldata[b->cell->nlines - 2].y;
    }

  #endif

  reformat_reformatter_r(0, b, b->cell, b->stream);

  /* The browser may have the input focus inside a forms */
  /* item, so after each loop of the reformatter ask the */
  /* forms library to ensure the caret position is OK.   */

  form_caret_may_need_moving(b);
}

/**************************************************************/
/* reformat_reformatter_r()                                   */
/*                                                            */
/* Recursive back-end to reformat_reformatter.                */
/*                                                            */
/* Parameters: Flags (see Reformat.h);                        */
/*                                                            */
/*             Pointer to a browser_data struct relevant to   */
/*             the reformat session;                          */
/*                                                            */
/*             Pointer to the reformat_cell struct that is to */
/*             be acted upon;                                 */
/*                                                            */
/*             Pointer to the first token in the list of      */
/*             HStreams to use if there is no evidence of a   */
/*             previous incomplete reformat session in the    */
/*             browser_data structure.                        */
/*                                                            */
/* Returns:    Width of the widest line that was generated,   */
/*             in millipoints. This includes the left hand    */
/*             margin / gap; however, if there is no stream   */
/*             to reformat, 0 is returned rather than purely  */
/*             the left hand margin plus zero to indicate     */
/*             this special case to the caller. Ideally the   */
/*             caller should never invoke the reformatter     */
/*             without a stream though, it's not very         */
/*             efficient...                                   */
/**************************************************************/

static int reformat_reformatter_r(unsigned int flags, browser_data * b, reformat_cell * d, HStream * streambase)
{
  int                   lnCurr        = -1;
  int                   cnCurr        = -1;
  int                   cnLast        = 0;
  _kernel_oserror     * e             = NULL;
  HStream             * tpCurr        = NULL, * tpLast   = NULL;
  HStream             * tnCurr        = NULL, * tnLast   = NULL;
  int                   bottom        = 0,      extent   = 0;
  int                   newlines      = 0,      newline  = 0;
  int                   newchunks     = 0,      newchunk = 0;
  int                   done          = 0;
  int                   linewidth     = 0;
  int                   widest        = 0;
  int                   offset        = 0;
  reformat_width_data   wd;
  int                   displaywidth, left_margin, right_margin;
  int                   toplevel, doall, fromstart, noalloc;
  int                   token_has_text;

  /* Read various flags */

  toplevel  = !(flags & Reformatter_KeepGoingToEnd); /* (This may get more complex, hence 'doall' is not just '!toplevel') */

  #ifdef ALWAYS_REFORMAT_ALL
    doall   = 1;
  #else
    doall   = (flags & Reformatter_KeepGoingToEnd);
  #endif

  fromstart = (flags & Reformatter_FromStreamStart);

  if (doall != 0) noalloc = (flags & Reformatter_Virtual);
  else            noalloc = 0;

  /* If there is more than one line, find the y coordinate */
  /* of the last one and put it into 'bottom'              */

  if      (d->nlines > 2)  bottom = d->ldata[d->nlines - 2].y;
  else if (d->nlines == 1) bottom = d->ldata[0].y;

  /* This y coordinate is for the last line, so it also gives the vertical extent */

  extent = bottom;

  /* Work out the current width to format to, in millipoints. */
  /* The width is the size of the visible area, but not less  */
  /* than min_width.                                          */

  if      (flags & Reformatter_FindingWidest)   displaywidth = Reformat_AsWideAsPossible_MP;
  else if (flags & Reformatter_FindingSmallest) displaywidth = 1600;
  else convert_to_points(redraw_display_width(b, d), &displaywidth);

  if (d->nlines && !noalloc)
  {
    /* If there are some lines, set up the local variables */
    /* according to the last line's contents.              */

    int i;

    /* Set lnCurr to the last line, and set cnLast to the first chunk */
    /* number on that line. Note that if the line has no chunks, the  */
    /* routine steps back one. The function will exit if it turns out */
    /* that the first line has no chunks (after all, there's nothing  */
    /* to format if this is the case!)                                */

    lnCurr = d->nlines - 1;

    while (!d->ldata[lnCurr].n && lnCurr >= 0) lnCurr --;
    if (lnCurr < 0) return 0;

    cnLast = d->ldata[lnCurr].chunks;

    /* Get the address of the HStream associated with the */
    /* first chunk of the last line into tpLast.          */

    tpLast = d->cdata[cnLast].t;

//    /* Since the current tag is be at the start of this line,   */
//    /* strip out any preceeding spaces in it (the function      */
//    /* deals with the special case of preformatted text, etc.). */
//
//    reformat_strip_prespace(b, cnCurr, tpCurr);

    /* Set 'linewidth' to the indentation requried at this line, */
    /* and add the widths of the line chunks to this.            */

    linewidth = redraw_left_gap(b, d, tpLast);

    for (
          i = 0;
          i < d->ldata[lnCurr].n;
          i++, cnLast++
        )
        linewidth += d->cdata[cnLast].w;

    if (linewidth > widest) widest = linewidth;

    /* Restore new line state */

    newline = b->force_newline, b->force_newline = 0;

    /* If the current line has at least 1 chunk... */

    if (d->ldata[lnCurr].n)
    {
      /* Set cnLast to now hold the number of the last chunk for the */
      /* last line, and tpCurr and tpLast to hold the address of the */
      /* token associated with the chunk.                            */

      cnLast = d->ldata[lnCurr].n + d->ldata[lnCurr].chunks - 1;
      tnCurr = tnLast = tpCurr = tpLast = d->cdata[cnLast].t;

      /* Set 'offset' to the offset into the token associated with the last */
      /* chunk in the last line, plus the amount of data to take from that  */
      /* token - i.e. it points to the first unused byte in that token,     */
      /* as far as the last chunk of the last line is concerned.            */

      offset = d->cdata[cnLast].o + d->cdata[cnLast].l;

      /* If the number of bytes into the token is <=0, then find out the */
      /* total size of data normally associated with the token (e.g. the */
      /* string length of any text it points to) and put this in offset. */

      if (d->cdata[cnLast].l <= 0)
      {
        /* In this case associated data will *almost* always be zero length, */
        /* in terms of text, but there are some rare circumstances when it   */
        /* won't be. Hence the reformat_datasize call.                       */

        offset = reformat_datasize(tpLast);
      }

      /* If the tag represents text, points to a text string, and that text */
      /* string terminates in a new line character, then need to start on a */
      /* new line.                                                          */

      if (
           offset > 0                       &&
           reformat_istext(tpCurr)          &&
           tpCurr->text                     &&
           tpCurr->text[offset - 1] == '\n'
         )
         newline = 1;
    }
    else newchunk = 1; /* Otherwise, flag that a chunk needs adding */
  }

  /* There are no line structures currently present; we aren't, then, */
  /* going to add to an existing line and need to flag that a new     */
  /* line must be created before chunks can be added.                 */

  else newline = 1;

  /* Loop round the reformatter whilst there is no error, the reformat */
  /* hasn't completed (we are still reformatting and the 'done' flag   */
  /* isn't set), and the number of new lines dealt with is less than   */
  /* 10 (don't want to do too much in one go, or the Desktop will      */
  /* feel very jerky) or we haven't flagged a new line is needed - the */
  /* reformat will only keep going for a certain number of lines, but  */
  /* won't stop mid-line.                                              */

  while (
          !e    &&
          !done &&
          (
            doall         ||
            newlines < 10 ||
            !newline
          )
          && reformat_formatting(b)
        )
  {
    /* tpCurr points the the token we're currently dealing with. If */
    /* this is NULL, or the offset into that token seems to point   */
    /* past its associated data, we've finished with the token. So  */
    /* move onto another, or if there are no more, set 'done' to 1. */

    if (tpCurr) token_has_text = tpCurr->text ? reformat_istext(tpCurr) : 0;
    else        token_has_text = 0;

    // Used to be 'if (!tpCurr || offset >= reformat_datasize(tpCurr))'
    // Really should check that the below never differs from it.

    if (!token_has_text || offset < 0 || !tpCurr->text[offset])
    {
      /* Record the last token that was dealt with in the browser_data structure */

      if (!fromstart) b->last_token = tnLast;

      /* Advance to the next token after that last one */

      if (tpLast) tnCurr = tnLast->next;
      else        tnCurr = streambase;

      /* Proceed if we haven't just run out of tokens */

      if (tnCurr && (tnCurr->flags & HFlags_DealtWithToken))
      {
        tpCurr = tnCurr;

        /* If this token isn't of any use to the reformatter (it */
        /* might correspond to header information rather than    */
        /* body text, say), keep getting new tokens until they   */
        /* are useful or we run out. If we run out, set 'done'   */
        /* again to show that the tokens have all been dealt     */
        /* with.                                                 */

        while (
                tpCurr                                  &&
                (tpCurr->flags & HFlags_DealtWithToken) &&
                reformat_useless_token(tpCurr))
        {
          if (!fromstart) b->last_token = tpCurr; /* Update the record of the last token dealt with */
          tnCurr = tpCurr = tpCurr->next;         /* Get the pointer to the new token               */
        }

        /* If we've ended up off the end of the token list (tpCurr is */
        /* NULL) or on a token that the fetcher hasn't dealt with yet */
        /* (the HFlags_DealtWithToken bit in the flags word is unset) */
        /* then signal that the reformatter should exit by setting    */
        /* 'done' to 1.                                               */

        if (!tpCurr) done = 1;
        else
        {
          if (!(tpCurr->flags & HFlags_DealtWithToken))
          {
            b->last_token = tpCurr->prev;
            tpCurr        = NULL;
            tnCurr        = NULL;
            done          = 1;
          }
        }

        /* Offset is set to 0 to show this is a new token, and we haven't */
        /* dealt with any of the data in it yet.                          */

        offset = 0;
      }

      /* The current token number was greater than the number of tokens - */
      /* we've run out of tokens, so flag that this in 'done'.            */

      else done = 1;
    }

    /* Continue with the reformat if it hasn't been flagged as finished through 'done'. */

    if (!done)
    {
      /* The left hand margin - zero for horizontal rules, which can span the whole     */
      /* display (their actual visible extent is determined by the redraw routine);     */
      /* else equal to the result of redraw_left_gap in Redraw.c (converted to points). */

      left_margin = redraw_left_gap(b, d, tpCurr);

      /* Can't have a margin greater than display width, but this consideration */
      /* only applies if we're not finding the smallest the stream can be.      */

      if (!(flags & Reformatter_FindingSmallest) && left_margin > displaywidth) left_margin = 0;

      /* The right hand gap value */

      right_margin = redraw_right_gap(b, d, tpCurr);

      /* Can't have margins greater than the display width */

      if (left_margin + right_margin > displaywidth) right_margin = 0;

//      /* If the text is not preformatted and the line width has gone over */
//      /* over the available display width, flag that a new line is needed */
//
      if (!newline && !(tpCurr->style & PRE) && linewidth > displaywidth - right_margin) newline = 1;

      /* If the difference between the current and last tags say we should */
      /* put in a line break, flag this in newline.                        */

      if (!newline && reformat_newline(tpCurr,tpLast,offset)) newline = 1;

      /* Right, if newline is set, create a new line. */

      if (newline)
      {
        int y = 0;

        newline  = 0;
        newchunk = 1;
        newlines ++;

        if (!noalloc)
        {
          /* Set y to hold the y coordinate the line is to be placed */
          /* at. This will either be determined by the previous      */
          /* line's y coordinate or if there are no lines, the       */
          /* toolbars and aesthetic lead-in considerations. The line */
          /* at this stage is of zero height; as it's height grows,  */
          /* the y value worked out here has the height subtracted   */
          /* from it to get the actual line position.                */

          if (lnCurr >= 0) y = d->ldata[lnCurr].y;
          else y = toplevel ? reformat_y_offset(b) : 0;

          /* If there aren't any new chunks, the bottom line hasn't */
          /* changed so set bottom to y; this stops the unchanged   */
          /* line being redrawn.                                    */

          if (!newchunks) bottom = y;

          /* If this is the first line for a whole page, see if we should */
          /* now clear the background colour and image                    */

          if (!d->table && !d->nlines)
          {
            if (!b->onload && !b->onunload)
            {
              b->background_colour = -1;                /* Background colour, or -1 for default  */
              b->background_image  = -1;                /* Image no. of background image, 0=none */
              b->antialias_colour  = redraw_backcol(b); /* Colour to anti-alias to, or -1=none   */

              browser_update_bottom(b, 0);

              b->onload            = "";
              b->onunload          = "";
            }
          }

          /* Add the new line structure */

          e = reformat_add_line(b, d);
        }
        else e = NULL;

        /* If the addition was successful, fill in various details */

        if (!e)
        {
          tpCurr = tnCurr;
          tpLast = tnLast;

          if (!noalloc)
          {
            /* Advance the current line number in lnCurr to this new line */

            lnCurr = d->nlines - 1;

            /* Set the line height as zero, and baseline offset as zero. We */
            /* have no contents with which to do anything different yet.    */
            /* Changing 'b' will move the font baseline relative to the     */
            /* line base, and force the line height up. 'h' is the line     */
            /* height total including the baseline offset.                  */
            /*                                                              */
            /* When reformat_check_height is called, it will go through     */
            /* working out values called 'top' and 'bot'. The first is the  */
            /* amount by which the line height above the baseline (i.e.     */
            /* ...[...].h - ...[...].b) is to be extended; the second is    */
            /* the amount by which the space below the baseline is to be    */
            /* extended. These can thus be played about with to do vertical */
            /* alignment on images and so-forth.                            */

            d->ldata[lnCurr].h = 0;
            d->ldata[lnCurr].y = y;
            d->ldata[lnCurr].b = 0;

            /* The line has no chunks associated with it yet. */

            d->ldata[lnCurr].n      = 0;
            d->ldata[lnCurr].chunks = -1;
          }

          /* In light of this new line, set linewidth back to just the left margin,  */
          /* as there are no previous chunks to consider in working out chunk widths */
          /* in the add chunk code below.                                            */

          linewidth = left_margin;

          if (linewidth > widest) widest = linewidth;
        }

      /* End of newline check; if newline != 0, a new line is added to the line structure array. */
      }

      /* If there's no error, continue with the reformat procedure. */

      if (!e)
      {
        int available;

//        /* If the image has a known width and height, the reformatter is  */
//        /* about to deal with it - so the image library can mark it as    */
//        /* redrawable now (otherwise, for delayed reformats, some images  */
//        /* which were cross referenced and did not have reformat sessions */
//        /* explicitly started for them, may get stuck in a                */
//        /* 'non-redrawable' state).                                       */
//        /*                                                                */
//        /* Important to call this *before* trying to find the item height */
//        /* or width, as the image size routines will lie about the real   */
//        /* size if they think the item is not redrawable because it has   */
//        /* not be reformatted yet - chicken and egg...                    */
//
//        // Mmm, nice. And robust too. Or Your Money Back (TM).
//        //
//        // Really *must* do something about this (but probably won't...)
//
//        if (
//             (tpCurr->style & IMG) ||
//             (
//               tpCurr->tagno         == TAG_INPUT &&
//               HtmlINPUTtype(tpCurr) == inputtype_IMAGE
//             )
//           )
//           image_token_check_redrawable(b, tpCurr);

        /* If the image has a known width and height, the reformatter */
        /* has dealt with it; so both mark it as redrawable, and lock */
        /* its size down.                                             */

        image_token_reformatted(b, tpCurr);

        /* Fill in the reformat_width_data structure */

        wd.b      = b;
        wd.d      = d;
        wd.tp     = tpCurr;
        wd.data   = reformat_istext(tpCurr) ? tpCurr->text : NULL;
        wd.offset = offset;

        /* Tables, when specifying percentage widths, take up the whole */
        /* page - e.g. 100% when in an indented list will result in the */
        /* right hand edge of the table being off the page. Well, this  */
        /* is what MSIE / NN do anyway, despite it being stupid IMHO.   */
        /* Fortunately, it's optional, so check the Choices first.      */

        if (
             choices.msie4_style_tables                 &&
             tpCurr->tagno == TAG_TABLE                 &&
             (TABLE_HAS_WIDTH((table_stream *) tpCurr))
           )
        {
          available = displaywidth - redraw_left_margin(b, d) - right_margin;
        }
        else
        {
          available = displaywidth - linewidth - right_margin;
        }

        /* The maximum width is 'very large' for preformatted text (effectively limitless).  */
        /* Similarly, for any text items in NOBR, the width in effect is without a limit.    */
        /* For other tokens, the left hand edge is at an indent equal to the left hand       */
        /* margin plus the summed widths of preceeding chunks (this is kept in 'linewidth'), */
        /* so the width is the available display width minus this left hand value.           */

        wd.maxwid = (
                      (
                        (tpCurr->style & PRE) &&
                        reformat_istext(tpCurr)
                      )

                      #ifdef SUPPORT_NOBR
                        ||
                        (
                          (tpCurr->style & PCDATA) &&
                          (tpCurr->style & NOBR)
                        )
                      #endif

                    )

                    ?

                    Reformat_AsWideAsPossible_MP : available;

        if (wd.maxwid < 0) wd.maxwid = 0;

        /* Set the (returned) bytes and width fields to zero initially */

        wd.bytes = wd.width = 0;

        /* Find out the width */

        #ifdef SUPPORT_MTT

          if (controls.table_multi != 0)
          {
            poll_counter = reformat_poll(b, poll_counter, &b->poll_redraw);
            if (b->poll_redraw < bottom) bottom = b->poll_redraw;
          }

        #endif

        if (lnCurr >= d->nlines)
        {
          done = 1;
          continue;
        }

        e = reformat_token_width(&wd, flags);

        /* Adjust the line height for tables based on */
        /* the data from the above call               */

        if (tpCurr->tagno == TAG_TABLE)
        {
          if (!noalloc)
          {
            /* Take the height in millipoints (overloaded into wd.bytes) and use */
            /* this as the line height.                                          */

            convert_to_os(wd.bytes, &d->ldata[lnCurr].h);

            /* Correct the line's y coordinate given the above height. */

            d->ldata[lnCurr].y -= d->ldata[lnCurr].h;

            /* P tags before tables get attached to the TABLE HStream itself. */

            if ((tpCurr->style & P) && (lnCurr > 0))
            {
              int texttop, textbot;

              e = reformat_text_line_height(b, NULL, &texttop, &textbot);

              if (!e) d->ldata[lnCurr].y -= texttop + textbot;
            }
          }

          wd.bytes = 0;
        }

        /* If the chunk width'd and defined by the above call ends in a newline character, */
        /* flag a line break is needed through newline = 1.                                */

        else if (reformat_istext(tpCurr) && wd.bytes && wd.data[wd.offset + wd.bytes - 1] == '\n') newline = 1;
      }

      /* A new chunk is forced by setting 'newchunk' if the previous item and this one    */
      /* should not be split up. For example, an LI bullet point and the text that        */
      /* follows it (if any) should appear on the same line.                              */

      if (!e && !newchunk)
      {
        if (
             !offset                    &&
             tpCurr->prev               &&
             !(tpCurr->style & LI)      &&
             (tpCurr->prev->style & LI)
           )
           newchunk = 1;
      }

      /* Proceed if there is no error, to add a chunk. If the current line has no chunks, */
      /* then one will always be added. If there are already chunks present, another is   */
      /* added only if it will fit in the display (wd.width is less than wd.maxwid), or   */
      /* if the text is preformatted (in which case you keep adding chunks until there's  */
      /* a line break in the source).                                                     */

      if (
           !e &&
           (
             newchunk              || /* Will be set if current line has no chunks yet */
             wd.width <= wd.maxwid ||
             (tpCurr->style & PRE)
           )
         )
      {
        newchunk = 0;
        newchunks ++;

        if (!noalloc) e = reformat_add_line_chunk(b, d);
        else          e = NULL;

        /* Proceed if the above didn't return an error */

        if (!e)
        {
          tpCurr = tnCurr;
          tpLast = tnLast;

          if (!noalloc)
          {
            /* Set cnCurr to the array index of the last (i.e new) chunk; */
            /* we know that if a new chunk has been added the last line   */
            /* must have at least the one chunk now, so no need for all   */
            /* the checking for various cases of lines not having chunks  */
            /* that has gone on elsewhere.                                */

            cnCurr = d->ldata[d->nlines - 1].chunks + d->ldata[d->nlines - 1].n - 1;

            /* Fill in the new line chunk */

            d->cdata[cnCurr].t = tpCurr;
            d->cdata[cnCurr].w = wd.width;
            d->cdata[cnCurr].o = offset;
            d->cdata[cnCurr].l = wd.bytes;

            /* If this holds an image, need to invalidate the x and y position */
            /* information that the redraw routines set up, as it may have     */
            /* moved. The new position will be set when the reformatted        */
            /* region is next redrawn.                                         */

            if (
                 (tpCurr->style & IMG) ||
                 (
                   tpCurr->tagno         == TAG_INPUT &&
                   HtmlINPUTtype(tpCurr) == inputtype_IMAGE
                 )
               )
               image_set_token_image_position(b, tpCurr, -1, -1);

            #ifdef TRACE
              if (tpCurr->tagno == TAG_TABLE) dprintf(("Tabl", "reformat_reformatter_r: Added a table\n"));
            #endif

//            if (d->ldata[d->nlines - 1].n == 1)
//            {
//              /* Since the current chunk will be at the start of a new line, */
//              /* strip out any preceeding spaces in it (the function deals   */
//              /* with the special case of preformatted text, etc.).          */
//
//              reformat_strip_prespace(b, cnCurr, tpCurr);
//            }

//            if (d->ldata[d->nlines - 1].n == 1)
//            {
//              if (tpCurr->text && !(tpCurr->style & PRE))
//              {
//                while (*(tpCurr->text + d->cdata[cnCurr].o) == ' ' && d->cdata[cnCurr].l) d->cdata[cnCurr].o++, d->cdata[cnCurr].l--, offset++;
//              }
//            }


            /* Set the Visited flag if this token is a link and is in the global History */

            reformat_check_visited(b, tpCurr);

            /* Ensure the line's height details are updated in light of the new chunk */

            e = reformat_check_height(toplevel, b, d, lnCurr, tpCurr, tpLast, offset);
          }
          else e = NULL;

          if (!e)
          {
            int w;

//            if (!noalloc)
//            {
//              /* If a form had input focus, hopefully the forms library can now find */
//              /* the caret. This call will check if the token we're dealing with is  */
//              /* the currently editing one, and if so try to find its position and   */
//              /* move the caret as necessary. We do this only if 'noalloc' is unset, */
//              /* as if we're a 'virtual reformat loop', the token won't necessarily  */
//              /* have presence in any lines anyway. It might not be found if noalloc */
//              /* is unset anyway, but at least we increase the chances...            */
//
//              form_caret_may_be_moving(b, tnCurr);
//            }

            /* Advance through the token data */

            if (wd.bytes <= 0) offset = -1; /* Flag we need a new token */
            else
            {
              int has_text;

              offset += wd.bytes;

              /* Need a new line if we've not run off the end of the text - */
              /* there must have been a split point within it. This is not  */
              /* true, though, if NOBR is set.                              */

              if (tpCurr) has_text = tpCurr->text ? reformat_istext(tpCurr) : 0;
              else        has_text = 0;

              #ifdef SUPPORT_NOBR
                if (has_text && tpCurr->text[offset] && !(tpCurr->style & NOBR)) newline = 1;
              #else
                if (has_text && tpCurr->text[offset]) newline = 1;
              #endif
            }

            /* Make the last poken pointer is now updated */

            tnLast = tnCurr;
            tpLast = tpCurr;

            /* Add the chunk's width to the line width total */

            linewidth += wd.width;

            if (linewidth > widest) widest = linewidth;

            /* Convert the width to OS units and compare to the minimum width for */
            /* the browser so far. If the width as gone up, i.e. there is an      */
            /* enforced minimum for whatever reason (preformatted text, say) then */
            /* update the minimum width field appropriately.                      */

            convert_to_os(linewidth, &w);

            if (linewidth >= displaywidth - right_margin)
            {
              /* ...But shouldn't flag a new line if NOBR is set... */

              #ifdef SUPPORT_NOBR
                if (!(tpCurr->style & 0*NOBR)) newline = 1;
              #else
                newline = 1;
              #endif

              if (!d->table && w > b->display_extent) b->display_extent = w;
            }
          }
        }
      }
      else newline = 1;
    }
  }

  /* If there has been an error, stop the reformat and report it */

  if (e)
  {
    reformat_stop(b);
    show_error_ret(e); /* This call returns to this point rather than jumping to the poll loop */
  }
  else
  {
    browser_data * ancestor = utils_ancestor(b);

    /* For keyboard control, the preprocessor should have found a token */
    /* to select if there are any. However, if at a later stage the     */
    /* browser that this token lies in acquired children (frames), we   */
    /* must start trying to move the selection to a visible location.   */

    if (choices.keyboard_ctrl)
    {
      if (ancestor->selected)
      {
        browser_data * owner = ancestor->selected_owner;

        if (owner && owner->nchildren)
        {
          HStream * sel = browser_find_first_selectable(b, NULL, 0);

          if (sel)
          {
            browser_clear_selection(owner, 0);

            ancestor->selected       = sel;
            ancestor->selected_owner = b;
          }
        }
      }
    }
  }

  /* Make sure the window is the right size and ensure */
  /* that the altered regions are redrawn, unless      */
  /* we are printing (so the reformat doesn't actually */
  /* correspond to any real window).                   */

  if (toplevel && !printing)
  {
    reformat_check_extent(b);
    browser_update_bottom(b, bottom + 4);
  }

  /* Record our newline state. Otherwise, we can exit here having formatted half */
  /* a text token onto one line, not including its trailing space in the width   */
  /* (so you can get right up to the margins) but including it in the count. We  */
  /* get called later, examine the last formatted line, and determine that one   */
  /* extra word can be fitted in - because we've lost the space basically. This  */
  /* gives that old Customer browser bug of joining two words together at the   */
  /* end of lines now and again.                                                 */

  b->force_newline = !!newline;

  /* Return the width of the widest line generated in this session, in millipoints */

  return widest;
}

/**************************************************************/
/* reformat_format_cell()                                     */
/*                                                            */
/* Reformats a specific table cell to a given width.          */
/*                                                            */
/* Parameters: 1 for a top level call, 0 if being called as   */
/*             part of a nested table parse;                  */
/*                                                            */
/*             Pointer to a browser_data struct relevant to   */
/*             the table;                                     */
/*                                                            */
/*             Pointer to the first HStream structure in the  */
/*             stream that will be formatted into the cell;   */
/*                                                            */
/*             Pointer to the table_stream struct             */
/*             representing the table;                        */
/*                                                            */
/*             Pointer to the table's array of reformat_cell  */
/*             structures;                                    */
/*                                                            */
/*             Allowed cell (column) width, in millipoints;   */
/*                                                            */
/*             Row number of the cell;                        */
/*                                                            */
/*             Column number of the cell.                     */
/*                                                            */
/* Returns:    Actual final cell width in millipoints.        */
/**************************************************************/

int reformat_format_cell(int toplevel, browser_data * b, HStream * streambase, table_stream * table,
                         reformat_cell * cellarray, int ColWidth, int Row, int Column)
{
  int             dheight;
  int             cellindex = Row * table->ColSpan + Column;
  reformat_cell * c;

  /* Can't do anything if the cell index is out of range */

  if (cellindex >= table->RowSpan * table->ColSpan) return 1600;
  else c = &cellarray[cellindex];

  dprintf(("Tabl", "tables_width_cell: %p %d %d %d %d\n"
                   "tables_width_cell in: %d\n",

                   streambase, ColWidth, table->ColSpan, Row, Column,
                   ColWidth / 400));

  /* Format the cell to the specified width. If 'toplevel' is 0, this is */
  /* being called as part of a format for a parent table, so don't       */
  /* generate lines (flag Virtual in the reformatter). Otherwise, allow  */
  /* line generation (don't flag Virtual).                               */

  c->width = c->cellwidth = ColWidth;

  if (c->width <= 400) c->width = 400; /* Give at least 1 OS unit to avoid possible problems in the reformatter */

  reformat_reformatter_r(Reformatter_KeepGoingToEnd            |
                         Reformatter_FromStreamStart           |
                         (toplevel ? Reformatter_Virtual : 0),

                         b,
                         c,
                         streambase);

  /* Set the height to the line list extent, rounded down to an */
  /* integer number of pixels.                                  */

  dheight = reformat_return_extent(b, c) & ~(wimpt_dy() - 1);

  /* Convert to millipoints for storing in the cell */

  convert_to_points(dheight, &c->height);

  dprintf(("Tabl", "width found is %d\n"
                   "height found is %d\n",

                   c->width,
                   c->height));

  return c->width;
}

/**************************************************************/
/* reformat_find_cell_limits()                                */
/*                                                            */
/* Works out the narrowest and widest widths a given table    */
/* cell could be, in millipoints.                             */
/*                                                            */
/* Parameters: 1 for a top level call, 0 if being called as   */
/*             part of a nested table parse;                  */
/*                                                            */
/*             Pointer to a browser_data struct relevant to   */
/*             the table;                                     */
/*                                                            */
/*             Pointer to the first HStream structure in the  */
/*             stream that the cell is to contain;            */
/*                                                            */
/*             Pointer to the table_stream struct             */
/*             representing the table;                        */
/*                                                            */
/*             Pointer to the table's array of reformat_cell  */
/*             structures;                                    */
/*                                                            */
/*             Row number of the cell;                        */
/*                                                            */
/*             Column number of the cell;                     */
/*                                                            */
/*             Pointer to an int, in which the minimum width  */
/*             is returned;                                   */
/*                                                            */
/*             Pointer to an int, in which the maximum width  */
/*             is returned;                                   */
/**************************************************************/

void reformat_find_cell_limits(int toplevel, browser_data * b, HStream * streambase, table_stream * table,
                               reformat_cell * cellarray, int Row, int Column, int * retmin, int * retmax)
{
  int             maxwidth  = 0;
  int             minwidth  = 0;
  int             cellindex = Row * table->ColSpan + Column;
  reformat_cell * c;

  /* Can't find the limits of something outside the cell range */
  /* of the table...                                           */

  if (cellindex >= table->RowSpan * table->ColSpan)
  {
    if (retmin) *retmin = 1600;
    if (retmax) *retmax = 1600;

    return;
  }
  else c = &cellarray[cellindex];

  /* If we've already got values for this cell, return them now */

  if (c->minwid >= 0 && c->maxwid >= 0)
  {
    if (retmin) *retmin = c->minwid;
    if (retmax) *retmax = c->maxwid;

    return;
  }

  if (streambase)
  {
    /* Find the maximum width used by the cell; first, reformat */
    /* to a 'large width' (effectively, no line breaks).        */

    maxwidth = reformat_reformatter_r(Reformatter_KeepGoingToEnd  |
                                      Reformatter_FindingWidest   |
                                      Reformatter_FromStreamStart |
                                      Reformatter_Virtual,

                                      b,
                                      c,
                                      streambase);

    #ifdef TRACE
      if (c->nlines || c->ldata || c->cdata)
      {
        erb.errnum = Utils_Error_Custom_Normal;

        strcpy(erb.errmess,"Line or chunk data allocated inside reformat_find_cell_limits for maxwidth check");

        show_error_ret(&erb);
      }
    #endif

    /* Find the minimum width */

    minwidth = reformat_reformatter_r(Reformatter_KeepGoingToEnd  |
                                      Reformatter_FindingSmallest |
                                      Reformatter_FromStreamStart |
                                      Reformatter_Virtual,

                                      b,
                                      c,
                                      streambase);

    #ifdef TRACE
      if (c->nlines || c->ldata || c->cdata)
      {
        erb.errnum = Utils_Error_Custom_Normal;

        strcpy(erb.errmess,"Line or chunk data allocated inside reformat_find_cell_limits for minwidth check");

        show_error_ret(&erb);
      }
    #endif
  }
  else minwidth = maxwidth = redraw_left_margin(b, c);

  /* Account for cellpadding */

  {
    int cellpadmp = table->cellpadding * 2;  /* 1 'web pixel' = 2 OS units, but only for right hand edge - redraw_left_margin takes care of the rest */

    convert_to_points(cellpadmp, &cellpadmp);

    minwidth += cellpadmp;
    maxwidth += cellpadmp;
  }

  /* Store the values */

  c->minwid = minwidth;
  c->maxwid = maxwidth;

  if (retmin) *retmin = minwidth;
  if (retmax) *retmax = maxwidth;

  /* Finished */

  return;
}

/**************************************************************/
/* reformat_change_text()                                     */
/*                                                            */
/* Used to alter text in a tag, to provide (for example)      */
/* smart quotes handling.                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct with          */
/*             information on the fetch Pointer to a token to */
/*             alter.                                         */
/*                                                            */
/* Assumes:    The browser_data struct may not be NULL, but   */
/*             the token pointer can be and the token does    */
/*             not have to contain text.                      */
/**************************************************************/

void reformat_change_text(browser_data * b, HStream * tp)
{
// Note that this, then, does nothing right now - fix this function up some time!

  return;

  if (tp && tp->text && !(tp->style & TT) && (reformat_istext(tp)))
  {
    char * curr = tp->text;

    while (*curr)
    {
      if (*curr == '`') *curr = 148; /* Always make this quote an opening quote */

      if (*curr == '\'') /* Dumb single quote */
      {
        if   (b->last_char == ' '
           || b->last_char == '('
           || b->last_char == 148  /* Opening double quote */
           || b->last_char == '\"')

             *curr = 144; /* Opening single quote */
        else *curr = 145; /* Closing single quote */
      }
      else if (*curr == '\"') /* Dumb double quote */
      {
        if   (b->last_char == ' '
           || b->last_char == '('
           || b->last_char == 144  /* Opening single quote */
           || b->last_char == '\''
           || b->last_char == '`')

             *curr = 148; /* Opening double quote */
        else *curr = 149; /* Closing double quote */
      }
      else if (*curr == '-' && b->last_char == ' ') *curr = 151; /* 'en' dash */
//      else if (*curr == '-' && b->last_char == 151) memmove - something!

      b->last_char = *curr;
      curr ++;
    }
  }

  /* If we have ALT text for an image, strip off any preceeding */
  /* spaces or [s, and any trailing spaces or ]s.               */

  else if (
            tp       &&
            tp->text &&
            (
              (tp->style & IMG) ||
              (
                tp->tagno         == TAG_INPUT &&
                HtmlINPUTtype(tp) == inputtype_IMAGE
              )
            )
          )
  {
    char * start, * end;
    char   last;
    int    len;

    len = strlen(tp->text);

    /* Get rid of preceeding characters */

    start = tp->text;
    end   = tp->text + len - 1;

    while (*start == ' ' || *start == '[') start ++;

    /* If there's anything left... */

    if (*start)
    {
      /* Get rid of trailing characters */

      while (*end == ' ' || *end == ']')
      {
        *end = '\0';
        end --;
      }
    }

    /* If there's still something left, move the */
    /* string contents down so tp->text points   */
    /* past the stripped preceeding chracters.   */

    if (start <= end) memmove(tp->text, start, strlen(start) + 1); /* 'strlen + 1' to get the string terminator */
    else
    {
      /* If there was nothing left, did we originally have     */
      /* enough to put '[]' to mark that there's no text left? */

      if (len > 1) strcpy(tp->text,"[]");
    }

    /* Now do smart quotes substitution. Need to do this  */
    /* separately from the main text routines as the      */
    /* last_char variable must not be changed by ALT text */
    /* - it stands alone for each image.                  */

    last = ' ';
    start = tp->text;

    while (*start)
    {
      if (*start == '\'' || *start == '`') /* Dumb single quote */
      {
        if   (last == ' '
           || last == '('
           || last == 148  /* Opening double quote */
           || last == '\"')

             *start = 144; /* Opening single quote */
        else *start = 145; /* Closing single quote */
      }
      else if (*start == '\"') /* Dumb double quote */
      {
        if   (last == ' '
           || last == '('
           || last == 144  /* Opening single quote */
           || last == '\''
           || last == '`')

             *start = 148; /* Opening double quote */
        else *start = 149; /* Closing double quote */
      }
      else if (*start == '-' && last == ' ') *start = 151; /* 'en' dash */

      last = *start;
      start ++;
    }
  }
}

#ifdef SUPPORT_MTT

  /**************************************************************/
  /* reformat_poll()                                            */
  /*                                                            */
  /* Attempt to poll the Wimp (for use e.g. whilst formatting a */
  /* table).                                                    */
  /*                                                            */
  /* Parameters: Pointer to a browser_data struct relevant to   */
  /*             the table being formatted;                     */
  /*                                                            */
  /*             Counter value for start of timer;              */
  /*                                                            */
  /*             Pointer to int holding bottom y coordinate at  */
  /*             last top-level redraw point - may be updated   */
  /*             on exit.                                       */
  /*                                                            */
  /* Returns:    Updated counter if polling was done.           */
  /**************************************************************/

  static unsigned int reformat_poll(browser_data * b, unsigned int pc, int * redraw_y)
  {
    unsigned int now;

    _swix(OS_ReadMonotonicTime,
          _OUT(0),

          &now);

    if (printing) return now;

    if (now - pc >= 10)
    {
      WimpPollBlock     bl;
      unsigned int      mask;
      int               eventcode;
      int               post_y;
      _kernel_oserror * e;

      pc = now;

      e                = event_get_mask(&mask);
      if (e == NULL) e = event_set_mask((mask & (~Wimp_Poll_NullMask)) |
                                        Wimp_Poll_PollWordNonZeroMask  |
                                        0);

      /* Yikes! */

      if (e == NULL)
      {
        b->table_format = 1;
        e = event_poll(&eventcode, &bl, NULL);

        /* Was the window closed? */

        if (!is_known_browser(b)) longjmp(env, Main_FromFormatter);

        /* Otherwise, carry on. Regrettably have to suppress errors  */
        /* in the redraw routines in order to clear the thread flag. */

        post_y = b->cell->nlines <= 1 ? 0 : b->cell->ldata[b->cell->nlines - 2].y;

        if (post_y != *redraw_y)
        {
          reformat_check_extent(b);
          browser_update_bottom(b, *redraw_y);
          *redraw_y = post_y;
        }

        event_set_mask(mask);

        /* If the format flag is already clear, something's telling us to jump out */

        if (b->table_format == 0) longjmp(env, Main_FromFormatter);
        else b->table_format = 0;
      }

      /* If we're asked to quit, allow it; but must force the quit here as */
      /* windows would be closed (and closing a window whilst deep inside  */
      /* a format process for that window is Bad, unless you exit).        */

      if (quit)
      {
        _swix(Hourglass_Smash, 0);
        show_error_ret(multiuser_logout());
        exit(EXIT_SUCCESS);
      }
    }

    return pc;
  }

#endif
@


1.55
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d78 14
a91 13
static int               reformat_useless_token    (HStream * tp);
static int               reformat_newline_check    (HStream * current, HStream * last, int offset);
static int               reformat_datasize         (HStream * p);
static _kernel_oserror * reformat_token_width      (reformat_width_data * w, unsigned int flags);
static void              reformat_check_visited    (browser_data * b, HStream * token);

static _kernel_oserror * reformat_add_line         (browser_data * b, reformat_cell * cell);
static _kernel_oserror * reformat_add_line_chunk   (browser_data * b, reformat_cell * cell);

static _kernel_oserror * reformat_format_from_now  (browser_data * b, int lastline);

static _kernel_oserror * reformat_check_height     (int toplevel, browser_data * b, reformat_cell * d, int line, HStream * tp, HStream * tpLast, int offset);
static int               reformat_reformatter_r    (unsigned int flags, browser_data * b, reformat_cell * d, HStream * streambase);
d206 1
a206 1
int reformat_istext(HStream * tp)
d398 1
a398 1
        e = read_sprite_size("fgright", &width, NULL);
d563 1
a563 1
        read_sprite_size("fopton", &w->width, NULL);
d573 1
a573 1
        read_sprite_size("fradioon", &w->width, NULL);
d1295 1
a1295 1
/* reformat_get_image_size()                                  */
d1297 5
a1301 2
/* Gets a BBox for a specified image in OS coordinates        */
/* relative to the font base line and left hand edge.         */
d1303 2
a1304 2
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the image;                                     */
d1306 2
a1307 1
/*             A token address for the image;                 */
d1309 1
a1309 2
/*             Pointer to a BBox in which the relevant coords */
/*             are returned.                                  */
d1311 3
a1313 1
/* Assumes:    Pointer to the BBox may not be NULL.           */
d1316 7
a1322 1
_kernel_oserror * reformat_get_image_size(browser_data * b, HStream * tp, BBox * box)
d1324 5
a1328 5
  _kernel_oserror * e;
  imgalign          align;
  fm_face           h;
  BBox              hbox;
  int               height = 0;
d1344 2
a1345 14
  /* Get the image size from the image library */

  e = image_get_token_image_size(b, tp, box);
  if (e) return e;

  /* Deal with alignments */

  if (tp->style & IMG) /* It'll either be an IMG or an INPUT TYPE=IMAGE item */
  {
    if      ((tp->type & TYPE_ALIGN_MASK) == TYPE_MIDDLE) align = imgalign_MIDDLE;
    else if ((tp->type & TYPE_ALIGN_MASK) == TYPE_TOP)    align = imgalign_TOP;
    else                                                  align = imgalign_NONE;
  }
  else align = HtmlINPUTalign(tp);
d1351 2
a1352 4
      int hh = height / 3; /* Technically '/ 2', but '/ 3' looks, on average, better in practice */

      box->ymin -= box->ymax / 2;
      box->ymax /= 2;
d1354 2
a1355 2
      box->ymin += hh;
      box->ymax += hh;
d1367 33
a1399 2
  /* Deal with HSPACE / VSPACE; these OBJECT function calls */
  /* can be made on IMG items too.                          */
d1401 2
a1402 2
  box->xmax += HtmlOBJECThspace(tp) * 4; /* *2 for one gap either side, and *2 again for 1 'web pixel' = 2 OS units */
  box->ymax += HtmlOBJECTvspace(tp) * 4;
d1404 2
a1405 3
  /* Deal with links - need to account for a border */
  /* of maxlen * 2 pixels width. ISLINK is defined  */
  /* in Fetch.h.                                    */
d1409 5
a1413 1
    int b;
d1415 3
a1417 1
    b = tp->maxlen * 2;
d1419 2
a1420 4
    box->xmax += b;
    box->ymax += b;
    box->xmin -= b;
    box->ymin -= b;
d1423 12
d1455 6
a1460 1
_kernel_oserror * reformat_get_object_size(browser_data * b, HStream * tp, BBox * box)
a1461 2
  imgalign align;

d1466 9
a1474 1
  /* Deal with alignments */
d1476 2
a1477 1
  align = HtmlOBJECTalign(tp);
d1479 1
a1479 37
  switch (align)
  {
    case imgalign_MIDDLE:
    {
      box->ymin -= box->ymax / 2;
      box->ymax /= 2;
    }
    break;

    // Sort this out, as with image handling

    case imgalign_TOP:
    {
      box->ymin =- box->ymax;
      box->ymax = 0;
    }
    break;
  }

  /* Deal with HSPACE / VSPACE */

  box->xmax += HtmlOBJECThspace(tp) * 4; /* *2 for one gap either side, and *2 again for 1 'web pixel' = 2 OS units */
  box->ymax += HtmlOBJECTvspace(tp) * 4;

  /* Account for a border */

  if (HtmlOBJECTborder(tp))
  {
    int b;

    b = HtmlOBJECTborder(tp) * 2;

    box->xmax += b;
    box->ymax += b;
    box->xmin -= b;
    box->ymin -= b;
  }
d1481 4
d1507 1
a1507 1
/* Assumes:    Pointer to the BBox may not be NULL.           */
d1510 7
a1516 1
void reformat_get_placeholder_size(browser_data * b, HStream * tp, const char * text, BBox * box)
d1620 1
a1620 1
  if (read_sprite_size(spr, &w, NULL)) w = 32;
d1643 1
a1643 1
  if (read_sprite_size(spr, NULL, &h)) h = 32;
d2044 1
a2044 1
    read_sprite_size("fopton", NULL, &size);
d2056 1
a2056 1
    read_sprite_size("fradioon", NULL, &size);
d2162 1
a2162 1
    if (read_sprite_size("fgright", NULL, &h)) h = 44;
@


1.54
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d94 1
a94 1
#undef SUPPORT_NOBR
d96 12
d1126 4
d2564 17
d2642 7
a2648 1
  doall     = (flags & Reformatter_KeepGoingToEnd);
d2651 2
a2652 2
  if (doall) noalloc = (flags & Reformatter_Virtual);
  else       noalloc = 0;
d3099 16
d3768 94
@


1.53
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a50 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d115 1
a115 1
//  if (b->suspend_format) Printf("reformat_formatting: %p suspend_format set\n",b);
d118 4
a121 4
//    if (!b->last_token->next) Printf("reformat_formatting: %p b->last_token->next = NULL\n",b);
//    else if (b->last_token->next && !(b->last_token->next->flags & HFlags_DealtWithToken)) Printf("reformat_formatting: %p last_token->next HFlags NULL\n",b);
//    else if (b->cell->nlines <= 0) Printf("reformat_formatting: %p will return b->final_token != NULL: %d\n",b,b->final_token != NULL);
//    else Printf("reformat_formatting: %p will return 1\n",b);
d123 2
a124 2
//  else if (b->cell->nlines <= 0) Printf("reformat_formatting: %p will return b->final_token != NULL: %d\n",b,b->final_token != NULL);
//  else Printf("reformat_formatting: %p will return 1\n",b);
d245 1
a245 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("reformat_token_width: Dealing with table, token %p\n",table);
    #endif
d253 2
a254 5
      if (tl & (1u<<20))
      {
        Printf("reformat_token_width: Size of table is %d\n",size);
        if (!size) Printf("                      (Table has no cells...)\n");
      }
d260 1
a260 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("reformat_token_width: Tag is now 0x%x\n",w->tp->tag);
    #endif
d337 1
a337 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("reformat_token_width: Tag is now 0x%x\n",w->tp->tag);
    #endif
d1222 1
a1222 3
    #ifdef TRACE
      if (tl & (1u<<12)) Printf("reformat_format_from: Chunk CK_LINE set to %d\n",(lastline + 1) * sizeof(reformat_line));
    #endif
d1226 1
a1226 3
    #ifdef TRACE
      if (tl & (1u<<12)) Printf("reformat_format_from: Chunk CK_LDAT set to %d\n",size);
    #endif
d2270 1
a2270 3
  #ifdef TRACE
    if (tl & (1u<<8)) Printf("\nreformat_set_extent: Called, -y_extent = %d\n",-y_extent);
  #endif
d2404 1
a2404 3
  #ifdef TRACE
    if (tl & (1u<<8)) Printf("reformat_add_line: Called with cell %p, cell->nlines = %d\n",cell,cell->nlines);
  #endif
d2408 1
a2408 3
  #ifdef TRACE
    if (tl & (1u<<12)) Printf("reformat_add_line: Chunk CK_LINE set to %d\n",(cell->nlines + 1) * sizeof(reformat_line));
  #endif
d2424 1
a2424 3
  #ifdef TRACE
    if (tl & (1u<<8)) Printf("reformat_add_line: Successful with cell->nlines = %d\n",cell->nlines);
  #endif
d2449 1
a2449 3
  #ifdef TRACE
    if (tl & (1u<<8)) Printf("reformat_add_line_chunk: Called\n");
  #endif
d2501 3
a2503 3
  // if (cell->cdata) Printf("!! Consistency check - Current block size for chunks  = %p\n",(void *) flex_size((flex_ptr) &cell->cdata));
  // else Printf("!! Consistency check - Current block size for chunks  = none allocated\n");
  // Printf("!!                     New block size to be allocated = %p\n",(void *) size);
d2507 1
a2507 3
  #ifdef TRACE
    if (tl & (1u<<12)) Printf("reformat_add_line_chunk: Chunk CK_LDAT set to %d\n",size);
  #endif
d2529 1
a2529 3
  #ifdef TRACE
    if (tl & (1u<<8)) Printf("reformat_add_line_chunk: Successful\n");
  #endif
d3174 1
a3174 1
              if ((tl & (1u<<20)) && tpCurr->tagno == TAG_TABLE) Printf("reformat_reformatter_r: Added a table\n");
d3387 5
a3391 7
  #ifdef TRACE
    if (tl & (1u<<20))
    {
      Printf("tables_width_cell: %p %d %d %d %d\n",streambase,ColWidth,table->ColSpan,Row,Column);
      Printf("tables_width_cell in: %d\n", ColWidth / 400);
    }
  #endif
d3419 5
a3423 7
  #ifdef TRACE
    if (tl & (1u<<20))
    {
      Printf("width found is %d\n", c->width);
      Printf("height found is %d\n",c->height);
    }
  #endif
@


1.52
log
@Header and footer support working a lot better than in the previous
release. Could do with some code tidying, but little else to do.
Fixed a typo in JavaScript.c that stopped debug builds compiling,
and updated Trace.c to know about all current HStream flags bits.
@
text
@d15 21
a35 19
/***************************************************/
/* File   : Reformat.c                             */
/*                                                 */
/* Purpose: Functions to handle page reformatting. */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 03-Dec-96: Created                     */
/*          16-Apr-97: First merge with T.Cheal's  */
/*                     table code...               */
/*          22-May-97: Amazingly, *still* trying   */
/*                     to get this to work.        */
/*          18-Jun-97: Hpmh; works, but very slow. */
/*                     Will need to rewrite at     */
/*                     some stage; for the moment, */
/*                     moved a few bits over to    */
/*                     Tables.c as they fitted in  */
/*                     better over there.          */
/***************************************************/
d41 14
a54 2
#include "swis.h"
#include "flex.h"
a55 7
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "svcprint.h"
d104 13
a116 13
/*************************************************/
/* reformat_formatting()                         */
/*                                               */
/* Returns 0 if reformatting is not in progress, */
/* else non-zero.                                */
/*                                               */
/* Parameters: Pointer to the browser_data       */
/*             structure associated with the     */
/*             page which might be reformatting. */
/*                                               */
/* Returns:    0 if reformatting is not in       */
/*             progress, else it is.             */
/*************************************************/
d169 10
a178 10
/*************************************************/
/* reformat_stop()                               */
/*                                               */
/* Suspends a reformat, flagging that this has   */
/* been done in the browser_data structure.      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             with the details of the reformat  */
/*             process to stop inside it.        */
/*************************************************/
d187 10
a196 12
/*************************************************/
/* reformat_istext()                             */
/*                                               */
/* Returns 1 if an HStream structure represents  */
/* a text item - e.g. not an image, HR, object,  */
/* table...                                      */
/*                                               */
/* Parameters: Pointer to the HStream structure. */
/*                                               */
/* Returns:    1 if the struct represents text,  */
/*             else 0.                           */
/*************************************************/
d212 23
a234 25
/*************************************************/
/* reformat_token_width()                        */
/*                                               */
/* Fills in the 'width' and 'bytes' fields of a  */
/* reformat_width_data structure according to    */
/* the contents of the token (HStream structure) */
/* that the reformat_width_data structure points */
/* to (this structure is defined in Reformat.h). */
/*                                               */
/* The idea is to fit the token into maxwidth    */
/* coordinates (in millipoints). The actual      */
/* width is returned (which may be greater than, */
/* or less than maxwidth) and the number of      */
/* bytes used to make that width is returned.    */
/*                                               */
/* Parameters: Pointer to a reformat_width_data  */
/*             structure (see Reformat.h);       */
/*                                               */
/*             A flags word, as ppassed to       */
/*             reformat_reformatter.             */
/*                                               */
/* Returns:    Fills in the structure's 'width'  */
/*             and 'bytes' fields with width and */
/*             byte count information.           */
/*************************************************/
d731 10
a740 10
/*************************************************/
/* reformat_useless_token()                      */
/*                                               */
/* Checks to see if a token (HStream struct) is  */
/* of any use to the reformatter.                */
/*                                               */
/* Parameters: Pointer to the HStream struct.    */
/*                                               */
/* Returns:    1 = the token is useless, else 0. */
/*************************************************/
d770 22
a791 28
/*************************************************/
/* reformat_newline_check()                      */
/*                                               */
/* Works out whether or not there should be a    */
/* line break in the page, according to the      */
/* token (HStream structure) that is currently   */
/* being considered and the token that was last  */
/* considered, and the offset into the data of   */
/* the tokens.                                   */
/*                                               */
/* Parameters: Pointer to the current token (the */
/*             HStream structure that is being   */
/*             dealt with by the reformatter,    */
/*             say, at the moment);              */
/*                                               */
/*             Pointer to the last token that    */
/*             was dealt with;                   */
/*                                               */
/*             Data offset into the tokens.      */
/*                                               */
/* Returns:    0 if there is no line break       */
/*             needed, or a value between 1 and  */
/*             8 that says 'yes, line break      */
/*             needed' and also holds details of */
/*             the conditions that were met to   */
/*             determine the line break was      */
/*             needed.                           */
/*************************************************/
d877 12
a888 13
/*************************************************/
/* reformat_newline()                            */
/*                                               */
/* Returns 1 if a line break should be inserted  */
/* onto the page, or 0 if not. Does this by      */
/* calling reformat_newline_check and is only    */
/* interested in if the value the call returned  */
/* was zero or not.                              */
/*                                               */
/* Parameters: As for reformat_newline_check.    */
/*                                               */
/* Returns:    1 = line break required, else 0.  */
/*************************************************/
d895 10
a904 11
/*************************************************/
/* reformat_datasize()                           */
/*                                               */
/* Returns the size of standard data pointed to  */
/* by an HStream (e.g. the length of any text    */
/* string it points to).                         */
/*                                               */
/* Parameters: Pointer to the HStream struct     */
/*                                               */
/* Returns:    Size of associated data in bytes. */
/*************************************************/
d918 20
a937 25
/*************************************************/
/* reformat_shift_vertically()                   */
/*                                               */
/* Shifts all lines between two given line       */
/* numbers (inclusive) by a given y coordinate,  */
/* in OS units. A redraw is generated with       */
/* Wimp_BlockCopy if moved lines lie inside the  */
/* visible area of the browser window.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             holding information on the lines; */
/*                                               */
/*             The line number at which to start */
/*             (inclusive);                      */
/*                                               */
/*             The line number at which to end   */
/*             (inclusive);                      */
/*                                               */
/*             The value to shift the lines by,  */
/*             in OS units - since the Y coords  */
/*             of the lines are for a window,    */
/*             a negative value would move the   */
/*             lines down the window and vice    */
/*             versa.                            */
/*************************************************/
d979 28
a1006 32
/*************************************************/
/* reformat_format_from()                        */
/*                                               */
/* Starts a new reformat session, possibly       */
/* starting after a given last line (i.e. from   */
/* a certain point in the page, rather than the  */
/* whole page).                                  */
/*                                               */
/* The reformat session may be postponed until   */
/* later according to the RefoTime and RefoWait  */
/* entires in the Choices file.                  */
/*                                               */
/* The defined way to ensure all line and chunk  */
/* data for a given browser is freed, including  */
/* that tied up in tables, is by calling with    */
/* the browser_data struct, -1, 1, and -1 (see   */
/* parameters list below).                       */
/*                                               */
/* Parameters: A pointer to a browser_data       */
/*             structure for which the reformat  */
/*             is to take place;                 */
/*                                               */
/*             The number of the last valid      */
/*             reformat_line structure;          */
/*                                               */
/*             1 to format now, else the request */
/*             may be delayed for some time;     */
/*                                               */
/*             For requests generated by the     */
/*             resizing of images, pass the      */
/*             image number, else pass -1.       */
/*************************************************/
d1059 10
a1068 12
/*************************************************/
/* reformat_format_timer()                       */
/*                                               */
/* Calls the reformatter after a delay given by  */
/* the Choices file entry 'RefoTime', according  */
/* to the start time specified by the            */
/* 'refo_time' field of the browser_data         */
/* structure.                                    */
/*                                               */
/* Parameters are as standard for a Wimp event   */
/* handler.                                      */
/*************************************************/
d1105 17
a1121 20
/*************************************************/
/* reformat_format_from_now()                    */
/*                                               */
/* Starts a new reformat session, possibly       */
/* starting after a given last line (i.e. from   */
/* a certain point in the page, rather than the  */
/* whole page).                                  */
/*                                               */
/* The reformat session will be stared           */
/* immediately - it will not be delayed. Don't   */
/* call this directly - go through               */
/* reformat_format_from instead.                 */
/*                                               */
/* Parameters: A pointer to a browser_data       */
/*             structure for which the reformat  */
/*             is to take place;                 */
/*                                               */
/*             The number of the last valid      */
/*             reformat_line structure.          */
/*************************************************/
d1277 9
a1285 9
/*************************************************/
/* reformat_stop_pending()                       */
/*                                               */
/* Stops any pending reformats from happening,   */
/* deregistering handlers etc. as needed.        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the queue.            */
/*************************************************/
d1295 16
a1310 18
/*************************************************/
/* reformat_get_image_size()                     */
/*                                               */
/* Gets a BBox for a specified image in OS       */
/* coordinates relative to the font base line    */
/* and left hand edge.                           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             A token address for the image;    */
/*                                               */
/*             Pointer to a BBox in which the    */
/*             relevant coords are returned.     */
/*                                               */
/* Assumes:    Pointer to the BBox may not be    */
/*             NULL.                             */
/*************************************************/
d1396 16
a1411 18
/*************************************************/
/* reformat_get_object_size()                    */
/*                                               */
/* Gets a BBox for a specified Object in OS      */
/* coordinates relative to the font base line    */
/* and left hand edge.                           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             A token address for the Object;   */
/*                                               */
/*             Pointer to a BBox in which the    */
/*             relevant coords are returned.     */
/*                                               */
/* Assumes:    Pointer to the BBox may not be    */
/*             NULL.                             */
/*************************************************/
d1465 22
a1486 23
/*************************************************/
/* reformat_get_placeholder_size()               */
/*                                               */
/* Gets a BBox that a placeholder would fill     */
/* based on given ALT text to plot inside it.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the placeholder;      */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the placeholder (or  */
/*             NULL for a default size holder);  */
/*                                               */
/*             Pointer to the ALT text (or NULL  */
/*             or a null string for no text);    */
/*                                               */
/*             Pointer to a BBox, in which the   */
/*             required bounding box for the     */
/*             placeholder is written.           */
/*                                               */
/* Assumes:    Pointer to the BBox may not be    */
/*             NULL.                             */
/*************************************************/
d1576 8
a1583 10
/*************************************************/
/* reformat_bullet_width()                       */
/*                                               */
/* Returns the width of a given bullet in OS     */
/* units.                                        */
/*                                               */
/* Parameters: The bullet number (in the Sprites */
/*             file, bullets are named b1, b2,   */
/*             ...bn).                           */
/*************************************************/
d1599 8
a1606 10
/*************************************************/
/* reformat_bullet_height()                      */
/*                                               */
/* Returns the height of a given bullet in OS    */
/* units.                                        */
/*                                               */
/* Parameters: The bullet number (in the Sprites */
/*             file, bullets are named b1, b2,   */
/*             ...bn).                           */
/*************************************************/
d1620 12
a1631 12
/*************************************************/
/* reformat_y_offset()                           */
/*                                               */
/* Returns the y offset from the top of a page,  */
/* in OS units, for all lines on that page.      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             representing the page.            */
/*                                               */
/* Returns:    y offset for all the lines on the */
/*             page, in OS units, from the top.  */
/*************************************************/
d1649 23
a1671 27
/*************************************************/
/* reformat_text_line_height()                   */
/*                                               */
/* Works out how tall a line of text should be,  */
/* returning the height above and below the      */
/* notional text baseline in OS units.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the line;             */
/*                                               */
/*             Pointer to an HStream which is    */
/*             used to determine what font the   */
/*             line would use;                   */
/*                                               */
/*             Pointer to an int, in which the   */
/*             height above the baseline is      */
/*             written;                          */
/*                                               */
/*             Pointer to an int, in which the   */
/*             height below the baseline is      */
/*             written.                          */
/*                                               */
/* Assumes:    Either int pointer may be NULL.   */
/*             If the HStream pointer is NULL, a */
/*             value based on the base (normal)  */
/*             font size will be used.           */
/*************************************************/
d1716 29
a1744 32
/*************************************************/
/* reformat_check_height()                       */
/*                                               */
/* Looks at the contents of a reformat_line      */
/* structure and ensures that it's y coordinate, */
/* height and font baseline offset fields are    */
/* correctly filled in.                          */
/*                                               */
/* Parameters: 1 for all external callers, but   */
/*             will be 0 if it calls itself      */
/*             internally;                       */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             relevant to the line;             */
/*                                               */
/*             Pointer to a reformat_cell struct */
/*             that the line lies in;            */
/*                                               */
/*             Number of the line to alter;      */
/*                                               */
/*             Pointer to the token that may     */
/*             cause the line height to alter;   */
/*                                               */
/*             Pointer to the last token dealt   */
/*             with by the reformatter;          */
/*                                               */
/*             Offset into the current token's   */
/*             data.                             */
/*                                               */
/* Returns:    Fills in bits of the line struct, */
/*             as mentioned above.               */
/*************************************************/
d2205 12
a2216 13
/*************************************************/
/* reformat_check_visited()                      */
/*                                               */
/* Looks at a given token and compares it to the */
/* global history, setting a bit in the flags    */
/* word if a link it represents has been visited */
/* before.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the token;            */
/*                                               */
/*             Pointer to the token.             */
/*************************************************/
d2223 9
a2231 11
/*************************************************/
/* reformat_check_extent()                       */
/*                                               */
/* Sets the browser window vertical extent to    */
/* match the page, by looking at the last line   */
/* in the line list.                             */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             holding details of the window to  */
/*             alter.                            */
/*************************************************/
d2244 12
a2255 12
/*************************************************/
/* reformat_return_extent()                      */
/*                                               */
/* Returns the height of a page in OS units,     */
/* according to its current formatted state.     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             holding details of the page;      */
/*                                               */
/*             Pointer to a reformat_cell struct */
/*             holding redraw information.       */
/*************************************************/
d2268 13
a2280 15
/*************************************************/
/* reformat_set_extent()                         */
/*                                               */
/* Sets the browser window vertical extent. The  */
/* extent can only ever grow.                    */
/*                                               */
/* Parameters: A pointer to a browser_data       */
/*             structure containing details of   */
/*             the window to alter;              */
/*                                               */
/*             A new vertical extent in OS units */
/*             - this is a *negative* number,    */
/*             expressed as a downward offset    */
/*             from the top of the window.       */
/*************************************************/
d2362 13
a2374 14
/*************************************************/
/* reformat_return_width()                       */
/*                                               */
/* Returns the width of a page in OS units,      */
/* according to its current formatted state -    */
/* i.e. this looks through the line list to find */
/* the widest line.                              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             holding details of the page;      */
/*                                               */
/*             Pointer to a reformat_cell struct */
/*             holding redraw information.       */
/*************************************************/
d2406 13
a2418 12
/*************************************************/
/* reformat_add_line()                           */
/*                                               */
/* Adds a line to the array of line structures.  */
/* The contents are NOT initialised.             */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the page;             */
/*                                               */
/*             Pointer to the reformat_cell      */
/*             structure to add the chunks to.   */
/*************************************************/
d2455 14
a2468 15
/*************************************************/
/* reformat_add_line_chunk()                     */
/*                                               */
/* Adds a line chunk to the array of line chunks */
/* associated with a particular line structure.  */
/* This is complicated slightly by the variable  */
/* length of the arrays of line chunks. The new  */
/* chunk's contents are NOT initialised.         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the page;             */
/*                                               */
/*             Pointer to the reformat_cell      */
/*             structure to add the chunks to.   */
/*************************************************/
d2566 11
a2576 13
/*************************************************/
/* reformat_reformatter()                        */
/*                                               */
/* The actual working end of the reformat        */
/* routines - takes the list of HStream structs  */
/* (or tokens) and turns them into reformat_line */
/* structures for the redraw routines etc.       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             containing all the info on the    */
/*             fetch for which reformatting is   */
/*             to take place.                    */
/*************************************************/
d2589 28
a2616 32
/*************************************************/
/* reformat_reformatter_r()                      */
/*                                               */
/* Recursive back-end to reformat_reformatter.   */
/*                                               */
/* Parameters: Flags (see Reformat.h);           */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             relevant to the reformat session; */
/*                                               */
/*             Pointer to the reformat_cell      */
/*             struct that is to be acted upon;  */
/*                                               */
/*             Pointer to the first token in the */
/*             list of HStreams to use if there  */
/*             is no evidence of a previous      */
/*             incomplete reformat session in    */
/*             the browser_data structure.       */
/*                                               */
/* Returns:    Width of the widest line that was */
/*             generated, in millipoints. This   */
/*             includes the left hand margin /   */
/*             gap; however, if there is no      */
/*             stream to reformat, 0 is returned */
/*             rather than purely the left hand  */
/*             margin plus zero to indicate this */
/*             special case to the caller.       */
/*             Ideally the caller should never   */
/*             invoke the reformatter without a  */
/*             stream though, it's not very      */
/*             efficient...                      */
/*************************************************/
d3378 28
a3405 33
/*************************************************/
/* reformat_format_cell()                        */
/*                                               */
/* Reformats a specific table cell to a given    */
/* width.                                        */
/*                                               */
/* Parameters: 1 for a top level call, 0 if      */
/*             being called as part of a nested  */
/*             table parse;                      */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             relevant to the table;            */
/*                                               */
/*             Pointer to the first HStream      */
/*             structure in the stream that will */
/*             be formatted into the cell;       */
/*                                               */
/*             Pointer to the table_stream       */
/*             struct representing the table;    */
/*                                               */
/*             Pointer to the table's array of   */
/*             reformat_cell structures;         */
/*                                               */
/*             Allowed cell (column) width, in   */
/*             millipoints;                      */
/*                                               */
/*             Row number of the cell;           */
/*                                               */
/*             Column number of the cell.        */
/*                                               */
/* Returns:    Actual final cell width in        */
/*             millipoints.                      */
/*************************************************/
d3464 31
a3494 33
/*************************************************/
/* reformat_find_cell_limits()                   */
/*                                               */
/* Works out the narrowest and widest widths a   */
/* given table cell could be, in millipoints.    */
/*                                               */
/* Parameters: 1 for a top level call, 0 if      */
/*             being called as part of a nested  */
/*             table parse;                      */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             relevant to the table;            */
/*                                               */
/*             Pointer to the first HStream      */
/*             structure in the stream that the  */
/*             cell is to contain;               */
/*                                               */
/*             Pointer to the table_stream       */
/*             struct representing the table;    */
/*                                               */
/*             Pointer to the table's array of   */
/*             reformat_cell structures;         */
/*                                               */
/*             Row number of the cell;           */
/*                                               */
/*             Column number of the cell;        */
/*                                               */
/*             Pointer to an int, in which the   */
/*             minimum width is returned;        */
/*                                               */
/*             Pointer to an int, in which the   */
/*             maximum width is returned;        */
/*************************************************/
d3599 14
a3612 15
/*************************************************/
/* reformat_change_text()                        */
/*                                               */
/* Used to alter text in a tag, to provide (for  */
/* example) smart quotes handling.               */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             with information on the fetch     */
/*             Pointer to a token to alter.      */
/*                                               */
/* Assumes:    The browser_data struct may not   */
/*             be NULL, but the token pointer    */
/*             can be and the token does not     */
/*             have to contain text.             */
/*************************************************/
@


1.51
log
@Misecllaneous tweaks and fixes. Major addition is full header and footer
support in the printing system - see the Phoenix Choices file for more
information.

Only the Phoenix resources are up to date currently.
@
text
@a75 1
static int               reformat_istext           (HStream * tp);
d184 2
a185 1
/* neither a horizontal rule nor an image.       */
d193 1
a193 1
static int reformat_istext(HStream * tp)
@


1.50
log
@Long overdue check-in of intermediate browser build, from continued "out
of hours" work. Forgot to add a few files last time too.

List dialogue box handler complete, and exclusion lists implemented
within the main browser code. Full documentation in Choices file.
Save routine knows all about it but is now getting very slow - must
come up with a better scheme; for now, it puts the hourglass on...

StripExtensions option controls auto stripping of filename extensions.

More sensible ancestor / frame selection for keyboard shortcut items
and the save dialogues - having selected a frame won't lock you into
it for F3 and related shortcuts now (input focus in URL writable ->
get ancestor details, input focus in frame -> get frame details). F4
works in frames. F5 now generally present for 'view source' with a
corresponding menu entry in the File menu.

Odd thing in later Res files; there's no action set for Adjust clicks
on the main ToolAction items in the button bar. Very odd. Nothing
appears to be set in v2.07 either, yet adjust-click works. Even
stranger. Anyway, added in the relevant event details (same as for
Select click in all cases) and this fixes the problem.

Background colours in the TABLE tag ignored the "don't print any
backgrounds" Print Style setting. Fixed. Meanwhile, the "black
text with no backgrounds" option wasn't getting this right either;
fixed this also.

Event logging implemented; HTTP errors and script output via.
window.print extension. No internal error output yet.

Faith:Never behaviour extended. If ever a server sends something with
no content type or an unhandleable type, the browser will try and get a
filetype from the URL. If it gets text or HTML, it'll render the file.
Else it'll save it. Hacks around IIS 4's lack of a content type field
in the Marketeye login stuff, and similar other slightly broken sites.
@
text
@a87 1
static _kernel_oserror * reformat_text_line_height (browser_data * b, HStream * tp, int * top, int * bot);
d94 1
d1705 1
a1705 1
static _kernel_oserror * reformat_text_line_height(browser_data * b, HStream * tp, int * top, int * bot)
d1797 1
a1797 2
    /* If the token represents a line break, include a gap, unless */
    /* we're at the top of a page / cell or just after a LI tag.   */
d1799 34
a1832 7
    if (
         line > 0              &&
         tpLast                &&
         !(tpLast->style & LI) &&
         (tp->style & P)
       )
       setpara = 1, waspara = 1;
d1834 14
a1847 24
    /* Alternatively, if the indent has changed, insert some */
    /* space above the item (but don't do this for UL and DL */
    /* items, as these are handled more carefully later).    */

    else if (
              tpLast                       &&
              tpLast->indent != tp->indent &&
              !(tp->style & UL)            &&
              !(tp->style & DL)
            )
            setpara = 1;

    /* The next few require text before them to gain a gap, or if */
    /* the last tag was BR and the tag before that was text, the  */
    /* gaps can still be added as BR just breaks the line.        */

    else if (
              tpLast &&
              (
                (tpLast->style & PCDATA) ||
                (
                  (tpLast->tagno == TAG_BR)      &&
                  tpLast->prev                   &&
                  (tpLast->prev->style & PCDATA)
d1849 4
a1852 4
              )
            )
    {
      /* Want a space above UL items */
d1854 15
a1868 1
      if (tp->style & UL) setpara = 1;
d1870 6
a1875 15
      /* If a header type has changed, and we are dealing with a */
      /* text token, insert a gap above the item to push it away */
      /* either from the text above or from the header above.    */

      else if (
                (tp->style & PCDATA) &&
                redraw_header(tp->style) != redraw_header(tpLast->style)
              )
              setpara = 1;

      /* If we're about to enter a definition list, the 'spaces if */
      /* indent changes' code above will make the spaces look odd  */
      /* unless we also give a space above the first item in the   */
      /* definition list (the DT elements are not indented, so no  */
      /* white space would have been inserted so far).             */
a1876 2
      else if (tp->style & DL) setpara = 1;
    }
d1891 16
d1909 11
d1965 33
a1997 6
    BBox box;

    RetError(reformat_get_image_size(b, tp, &box));

    top +=  box.ymax;
    bot  = -box.ymin;
d2757 4
d3409 10
@


1.49
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d1283 1
a1283 1
  /* Redraw the bottom line of the window if not printing */
d1285 9
a1293 1
  return (!printing ? browser_update_bottom(b, bottom) : NULL);
@


1.48
log
@Corrected the Font Manager bug that never was - adjustment calculations
for line height in preformatted text were bogus. Fixed also daft use of
'&&' instead of '&' in trace build conditional debug output for
image_purge_deleted_entries.
@
text
@d296 7
a302 1
        if (!table->cells) show_error_cont(make_no_table_memory_error(9));
@


1.47
log
@Another intermediate version, rather more stable than the last I hope.

Lazy clearing of backgrounds - pages with the same background image or
colour won't be cleared to grey when going from one to the next anymore.

BODY element onLoad script attribute implemented properly (beyond the
Customer hackery).

Images use independent flex blocks for URL and transient fetch data;
greatly improved data throughput in image system as a result. Image
renumbering implemented - speeds up closing of pages / frames with
many images. Image xref is still rather slow though and images with
a 0 width or height specified in the HTML still cause an incorrectly
formatted page to appear.

Have, I think, fixed the "stops anti-aliasing" bug. Noticed that some
background images are not being processed as Fast (e.g. at the
Fibblesnork Lego Guide) - that old problem has reappeared, then.

Background images would cross reference when two pages had the same
background colour set in <body> elements but one was configured to use
document colours and one wasn't (so xref should not occur). Code was
looking at b->background_colour; corrected to call redraw_backcol(b).

Titles were added to the history according to the fetch URL not the
display URL, though the former is more likely to be in the history due
to the code execution order in the fetcher; changed to see whether this
improves upon the rather hit and miss addition of titles.

The 'about:' page now gets entered into the history (makes for much more
sensible behaviour if it is configured as a Home page, for example).
@
text
@d1710 10
a1719 2
  rettop = box.ymax - ((b->page_is_text && !choices.system_font) ? b->leading * 2 : 0);
  retbot = -box.ymin + b->leading;
@


1.46
log
@Another intermediate check-in, resources may not be up to date; items
most likely to be buildable are PhoenixJ and BrowseD. Done because I'm
about to make some rather dodgy changes to code otherwise unchanged
since the Customer browser and I may well have to back them out...

In Handlers.c now set the HFlags_HasBeenVisited bit of a token at the point
it is first clicked on. Means the link returns to a "visited" colour after
the highlight flash immediately. This will persist for as long as the browser
window is kept open on that page, though if the URL doesn't end up making it
into the history for whatever reason it would "unhighlight" on reload; fair
enough, really. The highlight is window-local, so there are no redraw worries
for other open windows with links to the same URL (though other same-URL
links on the same page aren't updated either).

All forms submissions force a reload (principally for eudoramail.com, but
many other sites have similar requirements).

!MkClean and !MkClnAll didn't correctly call the utility to strip Makefile
dependencies. Fixed.

On fetch closedown, fetchpage_preprocess_token could be called on a token
which had already been run through the preprocessor. Now checks the flags
word before proceeding.

Image RAM cache and garbage collection system implemented - see new Choices
file entries CollectAfter, FreeRAMLimit and UnusedImageLimit to get an
overview. This contains groundwork for JavaScript image array support.

More JavaScript support improvements. Any one window object will know its
parent, top, this, etc.; frames array working except for a frameset created
via. multiple documents; opener for something created with window.open is
currently not set and don't know why (property is being created, pointer to
valid object is held, but JS engine returns 'null'. Ho hum) - JSChain won't
work yet, then.
@
text
@d2869 18
@


1.45
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d1484 2
a1485 1
/*             representing the placeholder;     */
@


1.44
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d1779 1
d2307 45
d3254 4
a3257 6
    /* For keyboard control, try to find something to select. */
    /* Browser windows that have children can't have visible  */
    /* tokens, so don't bother for them, and for anything     */
    /* with a selected item, check that it has't acquired     */
    /* children over the reformat - if it has, move the       */
    /* selection out of there.                                */
a3260 2
      /* Clear the selection if the owner has acquired children */

d3265 3
a3267 2
        if (owner && owner->nchildren) browser_clear_selection(owner, 0);
      }
d3269 3
a3271 3
      /* If there is no selection (whether this is due to the */
      /* above code or not), and the current browser has no   */
      /* children, try to select something in it.             */
d3273 4
a3276 5
      if (!ancestor->selected && !b->nchildren)
      {
        ancestor->selected = browser_find_first_selectable(b, NULL, 0);

        if (ancestor->selected) ancestor->selected_owner = b;
@


1.43
log
@Updated Hotlists - USNA HTML resources and 6025 TV room pages had moved,
MIDI themes is unreachable, Hensa has been restructured.

For table cells where the line or chunk data totals less than Flex_256_Point
bytes (see top of Memory.c, current value is 8192) there would be an over-
allocation of 1 byte per cell due to a (now fixed) bug in the granular
allocator. This would translate into 4 bytes wastage of course, and may
represent a small speed penalty depending on how flex works out block
word alignment.

Several entries in the Choices file were missing from save_save_choices in
its new form (see last check-in). Added back in. Ursula and Phoenix Res
files contained an incorrect component ID in pane 3 that was stopping the
'no scroll bars' option in pane 7 working correctly (duplicate component
ID). Res files corrected; TRACE builds will now spot such errors and give
a warning when they occur (in choices_find_component).

Table widthing code fixes:

 * Very wide table cell specifiers (e.g. TD WIDTH="2000") were ignored,
   but this isn't what Navigator / MSIE 4 do. This code was present
   because of other bugs in the widther, long since fixed. The code has
   been commented out - if the problem reappears the use of the code can
   be re-investigated, but as far as I can tell it isn't needed.

 * If two pixel specified cells appear one above the other, the first
   would always have been taken for use in the final width calculation
   even if it specified a smaller width than the second. The check was
   made to ensure that pixel specifiers were chosen in preference to
   other cells, which is OK, but it didn't notice if the current cell
   was also a pixel specifier! Fixed; you now get the widest.

 * The TRACE build 'Colspan cell xxx would have been width yyy, below
   minimum width of zzz' error should no longer happen. In a manner similar
   to the bug mentioned above, two cells above each other spanning the
   same columns with the lower cell narrower than the upper would end up
   with the narrower width. The code that trapped and corrected the error
   was not compiled out of release builds, even though the error message
   generation was, because the rendering would fail otherwise. The widther
   has now been fixed not to make this mistake and the final check is now
   strictly TRACE build only, thereby speeding up table widthing for
   non-TRACE builds.

 * Another use of MSIE4StyleTables option, for cellspacing; it's based
   on the actual used cells, rather than the maximum cell width caused
   by COLSPAN etc. So if you've a cell with a big COLSPAN but as a
   heading but the rest of the table only uses, say, 4 columns, you won't
   get a gap to the right which adds up to the spacing for all of the
   cells that the COLSPAN attribute in the heading implied. The option
   was actually intended as 'bad things when switched on', and though in
   this case it makes for a better rendering, it does hide an error in
   the HTML. Note Navigator 4 acts as Browse with MSIE4StyleTables off
   in this particular case. Oh, it works in both ways of course, so
   the table height routine had to be updated too. A new function,
   tables_find_actual_size, exists to support the feature in general.

Messages files updated to v2.05 (21-Apr-98). Help menu items renamed a
bit in Ursula, Phoenix and Customer Res files, but entries still point
to the same URLs. Phoenix button bar markers have been brought closer
together to stop them being visible when only the URL bar is meant to
be present.
@
text
@d1158 1
a1158 1
  if (lastline < 0)
d1378 6
d1453 5
d1764 2
d1782 1
a1782 1
       setpara = 1;
d2000 17
d2104 3
a2106 1
  /* Round up top and bot to a multiple of 4 */
d2108 2
a2109 2
  if (top & 3) top += 4 - (top & 3);
  if (bot & 3) bot += 4 - (bot & 3);
@


1.42
log
@All !Run[D], Choices, Messages, Controls and Res files are up to date.

RefoKeep and RefoHold options added to, respectively, try and maintain
the line at the top of the visible area when reformatting, and not shrink
the vertical extent at the start of a reformat to try and avoid flicker
to the top of the page and back down again when RefoKeep is on. Choices
front-end implemented, which also allows RefoWait and RefoTime to be set.
Unfortunately for various reasons this doesn't help the page jumping when
unsized images come in (but RefoHold can improve matters...) - roll on
the image history.

DragToScroll and NoScrollBars options added for frames; included new
pointer type, Mouse_Shape_DTS, so relevant Controls file entries done
and Sprites[22] files updated as required. Noticed some builds have
a low-res ptr_link with a mask - mask removed.

Named anchor following fixed up somewhat - anchors near the bottom of
the page shouldn't be displayed, and then pulled down when the fetcher
releases null polls and ensures the y extent is correct (this through
implementing the min_height field in the browser_data structure).

RefoHang was never implemented and there seems little point to it now,
so the entry for it has been removed from the global choices structure
and all Choices files.

Markers menus should work properly now (in last check-in they would not
update correctly if Adjust was used on the entries).

URI handler usage now a lot more sensible, with configuration of how the
browser uses the module from both a Utils menu submenu (sic) and the
Choices dialogue.

Slightly dodgy 'hang around waiting for user input' stuff for the Cookies
dialogue box: All fetches are suspended; the fetcher remembers some info
about its state at the time the cookie came in, and restores it later; it
will only do this for one fetch at a time. It's necessary to single-thread
the fetcher at this point anyway, since other fetches may have a
dependency on the cookie that is hanging in mid-air at that point. As part
of this, some of the fetcher code has been split out into separate
functions (to try and 'black box' the code a bit). Anyway, Cookie Query
dialogue box now implemented with appropriate Choices file entry and
UI work in the Choices dialogue box.

Phoenix build Choices rearranged. Can now choose when the image history
is saved from the front end. Added also MSIE 4-style table option menu
for JPEG support (OS only, OS if it can handle it, internal only).

Should be a bit faster at loading the history - though 95% of the time
is spent in SWI URL_ParseURL. URL descriptions are stored more
efficiently as part of this - one malloc block instead of several
small blocks. The minimum block size for malloc blocks typically leads
to a significantly smaller startup wimpslot depending on the visit
history size.

Nasty bug in image system fixed. If an image size came in and a reformat
was to take place, the line the image lies in is found and the reformat
progresses from there. Unforunately, this didn't check to see if the
token can't be found in the line list, so it'd reformat from the top
of the page...! This would happen if, for example, an image halfway down
the page came in whilst a reformat for an image higher up had just begun.

In Choices.c, made choices_set_timetype_field, choices_set_uri_field,
choices_set_plugin_field, choices_set_cookie_field, and
choices_set_jpeg_field static (so they're not declared in Choices.h now).

Two memory leaks plugged in URL comparison routines in URLutils.c
(calling free() url_description instead of urlutils_free_descripton()).

Client pull reload handler was setting the reload flag if reloading
the same page, but forgetting to turn on reload_lock so
fetchpage_postprocessed was clearing the reload state... Similarly,
Ctrl+Shift+SELECT-Click on a link when the Controls file 'UseSmall'
entry is 'no' would not have reloaded as it should. Both fixed.

Frames shouldn't be so keen on acquiring horizontal scroll bars and never
letting them go when their width is decreased now. Frames set up for
'scrolling="yes"' will not start with no scroll bars and then gain them
shortly afterwards, causing flicker and two reformats - they'll start
with, and continue to hold, both scroll bars.

Pointer shouldn't flicker when over a frame border whilst other fetches
are progressing now.
@
text
@d1162 5
a1166 1
    if (b->ancestor) windows_check_tools(b, NULL);
@


1.41
log
@This is NOT a 'final' version of anything in particular. I'm checking it
in as I'm about to start playing around with low level window handling
(as part of the thing mentioned at the bottom of this log) - this could
screw things up quite badly if it goes wrong! =8*P

Consequently, I advise you not to check this out over your working sources,
and preferably not to check this out at all.

Markers system - events defined in MiscEvents.h will make Browse remember
where it is on the page. This position can be jumped back to later.
Some builds will have defined keyboard shortcuts Ctrl+Shift+F5 through
F8 to set a marker, and Ctrl+F5 through F8 to jump to a marker.

The front-end for the above now has gadgets 0x80 upwards on the Toolbar or
a set of menus (see Menus.h). Noticed an omission in copy_toolaction_info()
(didn't copy the gadget state) in passing; fixed.

browser_top_line() now works properly, as part of the above, but it'll be
slower than before. If flagged to only find a complete line, it'll do just
that, but whereas before this would require any tables that it looked
inside to be wholly visible, tables can now be partially visible and have
lines inside that are fully visible. This should help the Find function
too. There is a new call, browser_top_line_offset, which works as
browser_top_line but also returns a vertical scroll offset in the found
line (used for more accurate marker position). browser_bottom_line[_r]
turn out to never be used, even by the keyboard control routines, so they
have been removed from Browser.c (rather than spend a lot of time and
effort fixing them).

browser_show_token erroneously subtracted 1 from a particular coordinate
when calculating the y scroll position, which could lead to single pixel
page creep using the markers system. Corrected.

The View Resources button (see Toolbars.h) has been finally implemented,
insofar as it fetches the resources file to the current browser page (or
to a new window if Adjust is used, Controls file settings permitting).

menus_toggle_bars did not take account of the toolbar lower window border
edge correctly. It does now.

The reformatter has a prototype system to keep the vertical page position
when reformatting. This was coded about 5 minutes ago, and is not likely
to be reliable...
@
text
@d66 1
d1156 26
d1206 1
a1206 1
  if ((lastline + 1) < cell->nlines)
d1208 1
a1208 19
    WimpGetWindowStateBlock   state;
    reformat_cell           * topcell;
    int                       topline;
    int                       size;

    /* Before anything else, mark the token currently displayed at the */
    /* top of the page so it can be shown after the reformat.          */

    state.window_handle = b->window_handle;
    if (!wimp_get_window_state(&state))
    {
      topline = browser_top_line_offset(b, &topcell, &b->display_vscroll, &state);

      if (topcell && topline >= 0 && lastline < topline)
      {
        b->display_request = topcell->cdata[topcell->ldata[topline].chunks].t;
        b->display_offset  = topcell->cdata[topcell->ldata[topline].chunks].o;
      }
    }
d2232 1
a2232 1
  if (b->display_width < width) b->display_width = width;
d2890 1
d2892 5
a2896 1
        if (tpCurr->tagno == TAG_TABLE && (TABLE_HAS_WIDTH((table_stream *) tpCurr)))
@


1.40
log
@Programming warehouse link removed from all hotlists - the page has gone.

Some compile-time hacks in place to use MemLib, a dynamic area based
malloc replacement which shrinks its heap when possible. All builds
have these switched off at the moment. Seemed to work with just Browse,
though there would be problems with message blocks stored in dynamic
areas because of the Wimp's '&3800000' check - however, it failed when
HTMLLib was made to use it, too. Don't know why yet.

ItemInfo.[c/h] source added, with Res file additions for testbed Browse
and Phoenix.

Small fetch windows now work properly regardless of toolbar settings
in the Choices.

Reload now reloads all images too, rather than only reloading them for
as long as the main page was being fetched.

Added a simple 'Find' facility.

Realised that event handlers in eventlib are called in reverse order
of registration, so the miscellaneous event handler is now registered
first rather than last.

Multiuser code added (most only active if SINGLE_USER is undefined). As
part of this, hotlist code now knows about read-only items (done for the
Customer-style 'Resources' file, but works generally anyway).
handle_add_hotlist doesn't try to save the hotlist itself anymore (the
hotlist_add function does all that through hotlist_modified anyway).

Customer build Choices and Controls updated slightly (e.g. ClaimHelp
off, hotlist to save on quit only).

Customer build now uses Phoenix-style buttons. Sprites files which
worked at the time (but will probably be out of date now) and included
most of the original Customer-style sprites are in
'Utils.Icons.Customer'.

Choices, Messages and Res files for all builds now stripped down to only
single user items or single plus multiuser for Customer build and testbed
build. Before, all contained a few multiuser bits in at least the Choices
file if not more.

Grammatical error ("Fetching frames contents" (sic.)) corrected in
default message, Toolbars.c, and all of the Messages files.

Customer build brought back to a servicable level (including
implementation of the Find dialogue box with animation and fixing
up authorisation and 'Stop' state in the tristate). Quite a few
missing #ifndef REMOTE_HOTLIST bits from hotlist code added...

Customer build will not use <Choices$Write> or Boot:Choices for any
file finding now. UseProxy defaults to 'yes', MaxImages to 2. Res
file includes Proxy Address setting (save_save_choices() now writes
the ProxyAddress line).
@
text
@d1181 4
a1184 1
    int size;//, topline;
d1186 14
a1199 11
//    /* Before anything else, mark the token currently displayed at the */
//    /* top of the page so it can be shown after the reformat.          */
//
//    topline = browser_top_line(b, cell, 0) - 1;
//
//    if (topline >= 0 && (lastline + 1) < topline)
//    {
//      b->display_request = cell->cdata[cell->ldata[topline].chunks].t;
//      b->display_offset  = cell->cdata[cell->ldata[topline].chunks].o;
//      b->display_vscroll = 0;
//    }
d1629 1
a1629 1
  /* The '4' accounts for the bottom window frame of the toolbars */
a2768 3

          /* (The 4 is to allow for the window frame of the toolbars) */

@


1.39
log
@RefoSingle option added to Controls.

Precautions taken in table code to avoid divide by zero errors.

Framesets defining more frames than the frameset implies, for whatever
reason, should never cause a crash now - just report a 'Frames definition
is badly nested' error (if STRICT_PARSER defined). Along the same lines,
in a single document defining a set of nested frames, two /FRAMESETs in
succession could cause a fairly nasty crash. Fixed.

TIFFs do not get loaded by double-click now.

If holding down SHIFT to save a link contents to disc, you can also hold
down CTRL to bypass the cache (sets the browser's reloading flag). Noticed
when testing this that windows_create_browser didn't take account of the
Controls file 'UseSmall' entry when adjust-shift-clicking on links. It
does now.

There is now a complete and up to date set of interactive help messages
built into the Ursula, Customer and Phoenix build Res files.
@
text
@d2879 1
a2879 1
        if (tpCurr->tagno == TAG_TABLE)
@


1.38
log
@*Don't* try to load FilterManager 0.18 in !Run[D] files. Requires
WindowManager 3.98. Sets URI handler environment variables for
http, ftp and gopher.

Fixed 'doesn't reformat for unsized images' bug - only happens when the
deferred reformatter is enabled, hadn't remembered to check this in my
debug build where this is turned off. Oops.

Caret position in forms could get left behind despite attempts to rectify
this in v1.31 - now fixed (and faster, fortunately).

Hourglass + percentage displayed for History and Image History when
loading - it can take a while for very big histories, though in
practice you only see the visit history loading (has to do a lot
more work, and is thus quite a bit slower than the image history).

POST forms worked when targetted to frames, but were broken when
not targetted! (Forms data inherited from one browser to the same
browser; ended up freeing the flex block...). Fixed.

Now support 303 response code (redirect to GET). Treated as 301, i.e.
not support if STRICT_PARSER is defined, otherwise drops through to
the 302 handling code.

Pointer shouldn't get stuck in odd shapes when going to a new page now;
it gets reset to a standard shape every time the null handler that
checks the position is called, though (whether or not the handler thinks
the pointer is over a different token, if that token is NULL, it sets
the standard shape). A possible work around would be for a browser to
remember the pointer shape too; that's for the future, though.

Early stage table formatting functions could blow themselves apart if
tables_count_table decided there were no rows, columns or both. A
net table size of zero cells is now dealt with; slow, partial table
fetches in multiple windows with image loading turned on will now
*hopefully* be stable, where v1.31 would have bombed out repeatedly.

A nested frameset within one document will now inherit the border
width (frame spacing) and border colour of its parent. This is done
by copying the maxlen and indent fields of the parent token over
the child, and note it's done in the browser (fetch_preprocess_token),
not HTMLLib.

Border colour on a FRAMESET now used, with the first colour on any
FRAME within it overriding, as in NN 4 and MSIE 4.

<LI> bullets really do stick to the text next to them now (I'd done
that in an experimental piece of code and forgotten to merge it back
before the last check-in).

Browse$HotlistURL/URIFile and Browse$HomeURL/URIFile now work from
_TaskName in the Messages file, and are thus of the generic form
<App>$HotlistURL etc. - Docs.Notes and Docs.User updated appropriately.

Event 0x11d00 through to 0x11d7f will make the browser look up Controls
file entries 'JumpTo00' through to 'JumpTo7f' and read a URL from them.
This will be fetched in the ancestor window of the source of the event,
or a new window if such an ancestor can't be found [for Daytona demo].

NB: Nasty frames-related crash at http://www.teledanmark.dk/menu/start.htm
is *not* fixed in this source. NOBR is not supported.
@
text
@d91 4
d2899 9
a2907 5
                      ||
                      (
                        (tpCurr->style & PCDATA) &&
                        (tpCurr->style & 0*NOBR)
                      )
d3100 5
a3104 1
              if (has_text && tpCurr->text[offset] && !(tpCurr->style & 0*NOBR)) newline = 1;
d3129 5
a3133 1
              if (!(tpCurr->style & 0*NOBR)) newline = 1;
@


1.37
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d248 2
d251 7
a257 1
      if (tl & (1u<<20)) Printf("reformat_token_width: Tag is now 0x%x\n",w->tp->tag);
d260 1
a260 1
    tables_position_table(w->b, table);
d266 1
a266 1
    size = table->ColSpan * table->RowSpan;
d268 3
a270 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("reformat_token_width: Size of table is %d\n",size);
    #endif
d272 7
a278 3
    /* If we've got an existing cell array and the number of cells has */
    /* not changed, don't need to do anything. Otherwise, (re)allocate */
    /* the cell array.                                                 */
d280 3
a282 3
    if (!table->cells || table->ncells != size)
    {
      reformat_cell * old_cells = table->cells;
d284 1
a284 1
      /* Now allocate a new cell array and initialise the cell contents */
d286 1
a286 1
      table->cells = HtmlMalloc(size * sizeof(reformat_cell), table);
d288 2
a289 2
      /* If the allocation fails, can't possibly continue so jump */
      /* back to poll loop after reporting the error.             */
d291 1
a291 1
      if (!table->cells) show_error_cont(make_no_table_memory_error(9));
d293 1
a293 1
      /* Otherwise, initialise the cell contents */
d295 1
a295 1
      tables_init_table(w->b, table, table->cells);
d297 1
a297 1
      /* Copy over any old cells ('ncells' still holds the old number) */
d299 3
a301 3
      if (table->ncells && old_cells)
      {
        memcpy(table->cells, old_cells, table->ncells * sizeof(reformat_cell));
d303 1
a303 1
        /* Free the old cell array */
d305 2
a306 2
        HtmlFree(old_cells);
      }
d308 1
a308 1
      /* Now update 'ncells' */
d310 2
a311 1
      table->ncells = size;
d316 9
a324 7
    /* Find the width and height of the cells and fix their positions */
    /* as millipoint offsets from the top left of the table.          */
    /*                                                                */
    /* If the reformatter flags say not to generate lines, then we    */
    /* must be doing a width finding session as part of a parent      */
    /* table, so toplevel is 0. Otherwise, this is the highest level  */
    /* and toplevel is therefore set to 1.                            */
d326 2
a327 2
    if (flags & Reformatter_Virtual) toplevel = 1;
    else                             toplevel = 0;
d329 2
a330 2
    w->width = tables_width_table (toplevel, w->b, table, w->maxwid, cellarray, flags);
    w->bytes = tables_height_table(toplevel, w->b, table,            cellarray);
d332 2
a333 1
    tables_fix_table(w->b, table, cellarray);
a599 8
    /* If the image has a known width and height, the reformatter has */
    /* dealt with it - so the image library can mark it as redrawable */
    /* now (otherwise, for delayed reformats, some images which were  */
    /* cross referenced and did not have reformat sessions explicitly */
    /* started for them, may get stuck in a 'non-redrawable' state).  */

    image_token_check_redrawable(w->b, w->tp);

d1250 4
d2427 6
d2831 31
d2957 1
a2957 1
      if (!e && !newchunk && 0)
d2959 7
a2965 1
        if (tpCurr->prev && !(tpCurr->style & LI) && (tpCurr->prev->style & LI)) newchunk = 1;
d3013 4
a3016 4
            /* If this holds and image, need to invalidate the x and y position */
            /* information that the redraw routines set up, as it may have      */
            /* moved. The new position will be set when the reformatted         */
            /* region is next redrawn.                                          */
a3026 8
            /* If the image has a known width and height, the reformatter has */
            /* dealt with it - so the image library can mark it as redrawable */
            /* now (otherwise, for delayed reformats, some images which were  */
            /* cross referenced and did not have reformat sessions explicitly */
            /* started for them, may get stuck in a 'non-redrawable' state).  */

            image_token_check_redrawable(b, tpCurr);

d3063 12
a3074 12
            if (!noalloc)
            {
              /* If a form had input focus, hopefully the forms library can now find */
              /* the caret. This call will check if the token we're dealing with is  */
              /* the currently editing one, and if so try to find its position and   */
              /* move the caret as necessary. We do this only if 'noalloc' is unset, */
              /* as if we're a 'virtual reformat loop', the token won't necessarily  */
              /* have presence in any lines anyway. It might not be found if noalloc */
              /* is unset anyway, but at least we increase the chances...            */

              form_caret_may_be_moving(b, tnCurr);
            }
@


1.36
log
@Not all resources are up to date in this check-in, and documentation
both within source and stuff in 'Docs' is out of date or missing - I
was very pushed for time on this one... Hopefully will do another
'tidy up' check-in before close on Friday; until then, beware of
anything other than the Ursula (Desktop browser) build. Anyway...

Export As Draw done. As part of this, FONT SIZE and SUP / SUB adjustment
of font size is done in fm_token_font_info rather than fm_find_token_font.

Bullets and switches are plotted as indirected sprite items, rather than
indirected text + sprite items - this relied on being in a redraw loop to
pick the sprites up from the local pool (failed during printing).

URI files now have a LF line ending rather than CR... '*' recognised
as an empty field when loading via. RAM transfer now (only worked for
loading from disc before).

Gave placeholder bounding boxes 4 OS units more minimum extra gap
vertically and reduced horizontal addition to this value * 1.5, rather
than * 2 (see reformat_get_placeholder_size).

Background image tiling starts at ymax - h + 4, rather than ymax, so
there isn't the bottom line of pixels from the top tile always present
at the top of the window. The '+4' is for caution's sake.

Can now save a frame's HTML source, that of its parent or its ancestor,
and the same for the URI pointing to those documents - see Menus.h for
the relevant component IDs that should lead to the SaveFile dialogue.

Have hopefully fixed timeout = 0 values (i.e. 'forever') on things
like LinkTo; before, image fetches could override the state (so you'd
only ever see brief flickers of a given URL as the pointer went over
a link).

Save File dialogue will remember the state of option or radio buttons
for a given parent component origin and restore that state when the
dialogue is next opened from the same place (stops turning on saving
as a URL file also turning on 'save background images' for Draw file
export, etc.).

Use of a META tag to reload the *same* page now sets the 'reloading'
flag in the browser so that it doesn't go through a proxy - otherwise
pages which are meant to update periodically through client pull
don't work, as they keep coming out of the cache.

Can now handle images specifying just a width or height in the HTML
(other dimension is scaled accordingly, but note that the placeholder
size must still be 'dumb' until the image data comes in). An image
will now override an image history size entry for the same entry
with a different size.
@
text
@d314 1
a314 1
    w->width = tables_width_table (toplevel, w->b, table, w->maxwid, cellarray);
d499 2
a500 1
      case inputtype_SUBMIT: /*; no break - same as RESET */
a578 1

d604 2
a605 1
    /* the specified maximum width.                               */
d613 16
a628 5
    if (
         !(flags & Reformatter_FindingWidest)   &&
         !(flags & Reformatter_FindingSmallest)
       )
       w->width = w->maxwid;
d630 2
a631 1
    else w->width = 0;
a1236 4
    /* Make sure the forms library knows where the caret should be */

    form_check_caret(b);

d1663 1
a1663 1
  rettop = box.ymax - (b->page_is_text ? b->leading * 2 : 0);
d1757 1
a1757 1
                  (tpLast->style == BR)          && /* Note, NOT '& BR'... HTMLLib bug. */
d1816 1
a1816 1
         (fol->style == BR) && /* Note, NOT '& BR'... HTMLLib bug. */
d1820 1
a1820 1
             (fol->prev->style == BR)
d1942 2
a1943 2
    /* if we've got some text, and we're either a forms element or the    */
    /* text consists of more than one single space.                       */
d1946 7
a1952 1
         (tp->style & FORM) ||
d2027 1
d2029 1
d2209 11
a2219 1
  b->display_height = s.visible_area.ymax - s.visible_area.ymin;
d2437 11
a2447 1
/*             generated, in millipoints.        */
d2531 1
a2531 2
    if (tpLast->style & HR) linewidth = 0;
    else                    linewidth = redraw_margin(b, d, tpLast);
d2691 3
a2693 3
      /* The left hand margin - zero for horizontal rules, which can span the whole   */
      /* display (their actual visible extent is determined by the redraw routine);   */
      /* else equal to the result of redraw_margin in Redraw.c (converted to points). */
d2695 1
a2695 2
      if (tpCurr->style & HR) left_margin = 0;
      else                    left_margin = redraw_margin(b, d, tpCurr);
d2697 2
a2698 1
      /* Can't have a margin greater than display width... */
d2700 1
a2700 1
      if (left_margin > displaywidth) left_margin = 0;
d2702 1
a2702 3
      /* The right hand margin - zero for horizontal rules, which can span the whole   */
      /* display (their actual visible extent is determined by the redraw routine);    */
      /* same as the left margin for block quotations; else the right margin quantity. */
d2704 1
a2704 6
      if (!(tpCurr->style & HR))
      {
        if (tpCurr->style & BLOCKQUOTE) right_margin = left_margin;
        else                            right_margin = redraw_right_margin(b, d);
      }
      else right_margin = 0;
d2710 3
a2712 3
      /* If the text is not preformatted and the line width has gone over */
      /* over the available display width, flag that a new line is needed */

d2720 2
d2811 2
d2816 1
d2821 14
d2836 1
d2846 5
d2855 3
a2857 1
                    Reformat_AsWideAsPossible_MP : displaywidth - linewidth - right_margin;
d2904 9
d3016 13
d3039 2
a3040 1
              /* there must have been a split point within it.              */
d3045 1
a3045 1
              if (has_text && tpCurr->text[offset]) newline = 1;
d3068 4
a3071 1
              newline = 1;
a3177 1
  int             cellpadmp = table->cellpadding * 2; /* 1 'web pixel' = 2 OS units, but only for right hand edge - redraw_left_margin takes care of the rest */
a3179 2
  convert_to_points(cellpadmp, &cellpadmp);

d3198 1
a3198 1
  c->width = c->cellwidth = ColWidth - cellpadmp;
d3294 4
a3297 2
  /* Find the maximum width used by the cell; first, reformat */
  /* to a 'large width' (effectively, no line breaks).        */
d3299 8
a3306 8
  maxwidth = reformat_reformatter_r(Reformatter_KeepGoingToEnd  |
                                    Reformatter_FindingWidest   |
                                    Reformatter_FromStreamStart |
                                    Reformatter_Virtual,

                                    b,
                                    c,
                                    streambase);
d3308 4
a3311 4
  #ifdef TRACE
    if (c->nlines || c->ldata || c->cdata)
    {
      erb.errnum = Utils_Error_Custom_Normal;
d3313 1
a3313 1
      strcpy(erb.errmess,"Line or chunk data allocated inside reformat_find_cell_limits for maxwidth check");
d3315 3
a3317 3
      show_error_ret(&erb);
    }
  #endif
d3319 1
a3319 1
  /* Find the minimum width */
d3321 8
a3328 8
  minwidth = reformat_reformatter_r(Reformatter_KeepGoingToEnd  |
                                    Reformatter_FindingSmallest |
                                    Reformatter_FromStreamStart |
                                    Reformatter_Virtual,

                                    b,
                                    c,
                                    streambase);
d3330 4
a3333 4
  #ifdef TRACE
    if (c->nlines || c->ldata || c->cdata)
    {
      erb.errnum = Utils_Error_Custom_Normal;
d3335 1
a3335 1
      strcpy(erb.errmess,"Line or chunk data allocated inside reformat_find_cell_limits for minwidth check");
d3337 5
a3341 3
      show_error_ret(&erb);
    }
  #endif
@


1.35
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d1497 1
a1497 1
  if (temp < 16) temp = 16;
d1500 1
a1500 1
  box->xmax += temp * 2;
@


1.34
log
@Fixed some glitches in the modified status bar code (e.g. status inference
wasn't working properly).

Shift+Toggle size always opened to not obscure the icon bar. If CMOS is
set to always show the icon bar, then Shift+Toggle size is meant to
reverse sense and open to absolute full size. It now does this.

!Run[D] files now require URL 0.22, HTTP 0.64, FTP 0.22, Gopher 0.08
and File 0.32.

Minor overhaul of 'Docs.Notes' (with 'Docs.User' similarly updated) to
include a few new bits and pieces.

Timeout values of 0 now mean 'forever'. Plug-in status messages now have
their own timeout setting. New Messages token 'Actv' for extra info when
a status message times out and the status line drops to 'Viewing' or
'Ready' when there is still a Busy state registered by the Plug-in.

Small Fetch windows don't become visible briefly for Plug-in fetches
when the fetch is complete (for SeeFetches:no, where these windows
should be hidden all the time).

WebServe may be controlled through the Browse front-end via.
Wimp_MAppControl reason code 4 (Wimp_MAppControl_Configure). Note the
renaming internally of 'WebServ' or 'WebServe' has been changed to
'Proxy' (with lower case equivalents where relevant); proxy name
and starting details come from the Messages file 'ProxyName' and
'ProxyComm' tokens. More in 'Docs.Notes'.

Res files updated for image history and PRE/TT font aspect ratio
choices. 'Don't expire' labels changed to 'Expire' (oops, didn't
notice the change in the development Browse's Res file when I
updated all of the others until now...).

When printing, Wimp_PlotIcon appears to ignore R4 and R5, plots
'somewhere' on the page, and tries to get the sprite from the global
pool. This latter part normally causes an error to be raised; though
on my machine I just get a corrupted error message. The Desktop font
gets lost at this point too. All have yet to be fixed; as an
interim work around, Wimp_PlotIcon objects are never drawn at all
if the global 'printing' flag is set.
@
text
@d73 1
a73 1
/* Statics */
d75 15
a89 14
static int               reformat_istext          (HStream * tp);
static int               reformat_useless_token   (HStream * tp);
static int               reformat_newline_check   (HStream * current, HStream * last, int offset);
static int               reformat_datasize        (HStream * p);
static _kernel_oserror * reformat_token_width     (reformat_width_data * w, unsigned int flags);
static void              reformat_check_visited   (browser_data * b, HStream * token);

static _kernel_oserror * reformat_add_line        (browser_data * b, reformat_cell * cell);
static _kernel_oserror * reformat_add_line_chunk  (browser_data * b, reformat_cell * cell);

static _kernel_oserror * reformat_format_from_now (browser_data * b, int lastline);

static _kernel_oserror * reformat_check_height    (int toplevel, browser_data * b, reformat_cell * d, int line, HStream * tp, HStream * tpLast, int offset);
static int               reformat_reformatter_r   (unsigned int flags, browser_data * b, reformat_cell * d, HStream * streambase);
d766 7
d779 8
d1374 1
a1374 2
  _kernel_oserror * e;
  imgalign          align;
d1608 63
d1675 1
a1675 1
/* height and font baselines offset fields are   */
d1679 1
a1679 1
/*             will be 0 when it calls itself    */
d1706 5
a1710 4
  int               top      = 0;
  int               bot      = 0;
  int               fontsize = choices.font_size >> 4;
  unsigned char     add      = (unsigned char) 3 * fontsize;
d1718 1
a1718 1
    /* we're at the top of a page / cell.                          */
d1720 6
a1725 1
    if (line > 0 && (tp->style & P)) top = add;
d1737 1
a1737 1
            top = add;
d1748 1
a1748 1
                  tpLast->style == BR            &&
d1757 1
a1757 1
      if (tp->style & UL) top = add;
d1767 1
a1767 1
              top = add;
d1775 50
a1824 1
      else if (tp->style & DL) top = add;
a1931 3
    int  h;
    BBox box;

d1951 1
a1951 20
//      int face, size, italic, bold, scale;

      h = fm_find_token_font(b, tp, 1);
      e = fm_font_box(h, &box);
      if (e) return e;

      /* We know the font is 'size' 16ths, so we can work */
      /* out the line spacing from this. Don't use the    */
      /* font metrics - otherwise, bold text (say) will   */
      /* force the line spacing higher than plain.        */

      top += box.ymax - (b->page_is_text ? b->leading * 2: 0);
      bot =  -box.ymin + b->leading;

//      fm_token_font_info(tp, &face, &size, &italic, &bold);
//
//      bot = b->leading;
//
//      convert_to_points(1, &scale);
//      top += (size * 1000) / (16 * scale);
d1953 4
a1956 1
      /* Ensure the bottom line is not negative */
d1958 2
a1959 1
      if (bot < 0) bot = 0;
a1962 5
  /* Round up top and bot to a multiple of 4 */

  if (top & 3) top += 4 - (top & 3);
  if (bot & 3) bot += 4 - (bot & 3);

d2022 5
d2143 3
a2145 4
  _kernel_oserror           * e;
  WimpGetWindowStateBlock     s;
  BBox                        new_extent;
  int                         hbot, width;
a2685 12
      /* It generally looks better if there's a line break for tables, */
      /* though this is strictly not necessary.                        */

      if (
           !newline &&
           (
             tpCurr->tagno == TAG_TABLE ||
             tpLast->tagno == TAG_TABLE
           )
         )
         newline = 1;

d2818 3
d2823 2
d2826 11
@


1.33
log
@Implemented Message_PlugIn_ReshapeRequest, Message_PlugIn_Status and
Message_PlugIn_Busy. Plug-in code more robust when given invalid
browser instance handles by the plug-in.

Line spacing is now calculated on the basis of the normal style base serif
font, with all other fonts being forced into that line height. This does
mean that an unusually tall (say) sans serif font may get clipped. It
appears to be the only way to get around wildly different baseline
depths returned from the font metrics - you can't work out line spacing
based on each different font style; the line spacing will vary.

Table heighting (as opposed to widthing...) improved considerably; rowspan
can no longer cause very tall cells in odd places. Having trouble getting
rid of the single pixel breaks between vertically adjacent cells, though
I've not tried too hard. Widthing, though, seems fairly badly broken at
present... :-/

Set/clear of page_is_text flag made more robust (it looked as though there
was the potential for this to get stuck in a set state, though I've never
see the front-end behave in a manner which indicates this is the case).
The reformatter will now decrease leading if this flag is set (plain text
pages look daft with a line spacing that is OK for 'rich' text pages).
No reformatting is done if the page width changes by dragging on the
resize icon, though toggle size / full screen will still reformat even
if the contents are only text (browser needs to sort out various width
flags at this point).

Cut down on excessive redrawing when reformatting due to a change in
window dimensions is not done. If display_width hasn't changed, then no
redraw is needed. If this causes redraw problems, then whatever is
changing display_width needs investigating. It shouldn't be kludged
(basically) by forcing a redraw instead of a reformat.

TT/PRE/etc. text can now have a non-100% aspect ratio. 80-90% looks
best (ArcWeb, for example, uses 86%). New option 'TTAspect' in
the Choices files.

Debug builds link to a non-debug Unicode library now; stops stderr
being dumped to the bottom left of the screen if you've not redirected
it in the Run file.

RISC OS 3.1 seems to need more initial WimpSlot than later OS versions.
The 64 deep nested table set gives a 'No stack for trap handler' error
(which it really means in this case!) without 800K, even though 3.71
is happy with just 640K. So, the !Run file checks if Boot$OSVersion
is exactly 300, 310 or 311, and sets the WimpSlot accordingly.

!Run[D] files now require latest fetcher module versions (URL 0.21,
File 0.31, HTTP 0.58).
@
text
@d1977 6
@


1.32
log
@Image history can be emptied from the History menu.

Significant reduction in number of times reformatter is called during
a table widthing session results in a dramatic speed increase for nested
tables (e.g. 64 deep with a paragraph of text in the deepest table takes
about two seconds to load with near-instantaneous subsequent reformats,
as opposed to taking optimistically 28 days for a 32 deep table!).
This code relies on a very big stack of assumptions...

Save as plain text implemented.

Choices, Messages and Res files brought up to date where necessary.
Version number taken to 1.28, 04-Dec-97 (so I don't forget later,
basically...).
@
text
@d378 1
a378 1
        h      = fm_find_token_font(w->b, w->tp);
d479 1
a479 1
        h = fm_find_token_font(w->b, w->tp);
d510 1
a510 1
        h = fm_find_token_font(w->b, w->tp);
d657 1
a657 1
      h = fm_find_token_font(w->b, w->tp);
d1272 1
a1272 1
  h = fm_find_token_font(NULL, tp);
d1821 3
a1823 1
      h = fm_find_token_font(b, tp);
d1827 7
a1833 1
      top += box.ymax;
d1835 6
a1840 1
      bot = -box.ymin + b->leading;
d1864 1
a1864 1
    h = fm_find_token_font(b, tp);
d3007 8
a3014 2
  convert_to_points(reformat_return_extent(b, c), &dheight);
  c->height = dheight;
@


1.31
log
@Image history - sizes of images are remembered for future reference (if
the sizes aren't specified in the HTML, they can be looked for in the
image history instead to minimise reformatting requirements). Choices
file options ImageHistoryPath, ImageExpiryAge, ImageMaxSize and
SaveImageHistory added to support this (all have a direct analogy to
the global History items of the same name after removing 'Image').

Text area items are now the correct height for the number of rows
specified in the HTML, don't scroll a line too early, and have the
caret placed at the start of the text when moved into from above
or at the end when moved into from below (rather than always at
the end, which was behaviour inherited from single line writables,
where this is desirable). The top of the text area is aligned to
the top of any line of text on the same line, with the text area
dropping below the text, rather than the bottom of the area matching
the text baseline and extending upwards.

Filename extensions for download files are only stripped if an
attempt to convert to a RISC OS filetype through the Mime Mapper module
does not return an error or Data (0xffd) filetype. '.cgi' is a special
case which is always stripped.

Altered heading styles - all are bold, none are italic, H3 is as big
as H2 was, H2 is a little larger, and others scale down to H6 being
the size as normal text (but, as I say, bold).

Sorted out tables and forms. We can just look for tagno=TAG_FORM, and
get rid of the wobbly form_flag; also discarded the redundant
reprocess_table flag in fetch_preprocess_token. Two separate forms
in consecutive table cells (for example) which used to fail - they
were submitted as one single form - will now work correctly.

Fixed nasty bug in FontManage.c where font size 7 would intermittently
fail. The stupid font sizes that it could ask the Font Manager for may
be responsible for the occasional Font Manager crashes that have been
noticed. Array for font sizes was declared as [Limits_FontSizes], but
indices 1 to Limits_FontSizes are actually used - so needed a '+ 1'
in the declaration... :-/

Replaced the case insensitive string comparison functions in Utils.c
with more efficient versions by S.Brodie.

MAXLENGTH specifier in INPUT tags is now supported. If unspecified or
specifically zero, the browser overrides and allows any length.
@
text
@d263 3
a265 2
    /* If reformatting, the table structure's 'cells' field will */
    /* already have information attached, so free this first.    */
d267 14
a280 1
    if (table->cells) HtmlFree(table->cells);
d282 1
a282 1
    /* Now allocate a new cell array and initialise the cell contents */
d284 1
a284 1
    table->cells = cellarray = HtmlMalloc(size * sizeof(reformat_cell), table);
d286 8
a293 2
    /* If the allocation fails, can't possibly continue so jump */
    /* back to poll loop after reporting the error.             */
d295 1
a295 1
    if (!table->cells) show_error_cont(make_no_table_memory_error(9));
d297 2
a298 1
    /* Otherwise, initialise the cell contents */
d300 1
a300 1
    tables_init_table(w->b, table, cellarray);
d3062 10
d3128 5
d3135 4
@


1.30
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d1828 1
d1836 5
a1840 2
    top += (box.ymax - box.ymin) * r + 8;
    bot += 8;
d1878 4
a1881 3
  /* lp->h - lp->b equates to the height of the line in OS units minus */
  /* the y offset of the font baseline from the bottom of the line. If */
  /* 'top' is greater than this the line needs to grow vertically.     */
d1902 2
a1903 2
    d->ldata[line].h += diff;
    d->ldata[line].b += diff; /* Was lp->b = bot; */
d2598 13
a2610 11
//            /* Set the new line to have a default minimum height of 3 OS units, */
//            /* and its bottom y coordinate must therefore be the bottom of the  */
//            /* page as worked out so far (in 'y') minus this height.            */
//
//            d->ldata[lnCurr].h = 3;
//            d->ldata[lnCurr].y = y - 3;
//
//            /* The 'b' field holds the y offset of the font baseline from the */
//            /* bottom of the line - this is filled in somewhat arbitrarily.   */
//
//            d->ldata[lnCurr].b = 1;
@


1.29
log
@Removed 'The Onion' link from some Hotlist files. Time showed that the
site wasn't entirely Family Friendly (TM)... Removed Shift Control (it's
gone offline now), and corrected the Telegraph URL from ...the-telegraph...
to just ...telegraph...

StrongHelp manual generator now tries to work out the number of lines in
the table on the root page more intelligently.

Plug-in support extended to handle Shockwave. Quite a lot of underlying
work for this, including a pseudo cache system for temporary files.

Bug in redraw routines: they plotted background images within table
cells, when nothing should have been drawn. Oops. When background images
in cells are properly supported, this can get sorted out.

Tweaked vertical plot position of HRs (up to 4 OS units too high before due
to rounding).

Various Res file bits and pieces, Ursula build taken up to v1.26 beta
for release on the Browser site. *Note* not all resources are up to date!
This will be done after AW97.
@
text
@d1242 17
d1279 2
d1283 3
a1288 2
    // Sort this out... Should align to top line of text, not baseline!

d1291 2
a1292 2
      box->ymin =- box->ymax;
      box->ymax = 0;
d1589 1
a1589 1
/*             Number of the line in to alter;   */
d1617 2
a1618 1
    /* If the token represents a line break, include a gap */
d1620 1
a1620 1
    if (tp->style & P) top = add;
d1921 1
a1921 1
  if (ISLINK(token) && history_visited(token->anchor, 0) >= 0) token->flags |= HFlags_LinkVisited;
@


1.28
log
@fetch_get_raw_data will notice if up->fetching is zero and return a
'finished' status rather than trying to continue reading data for the
fetch. Fetches should never fall through that far but at least it
will cope if they do.

3D table borders are now supported. 2D borders are used if the
inter-cell spacing is too small to fit the borders in (display resolution
dependent) - the external table border is 2D if the internal borders are,
else 3D. For cellspacing of 0, internal table borders must plot over the
outer edge of pixels inside the cell; for all greater spacings, the
borders take up all or part of the gap between them. The external border
will always fit around the outside of the cells, including the
cellspacing value in the gap between the outer cells and the border.

Anti-alias colour for placeholder ALT text was incorrect. Fixed.

I'd changed 'point' to 'points' in some of the Font Choices dialogues;
now changed back to 'point'.

The routine to find out how large an otherwise unsized object or image
placeholder based on its ALT text has been centralised in Reformat.c,
so that the image and object routines can both access it without
code duplication (this means non-image objects will now have the correct
size if they contain ALT text, rather than assuming a standard default
size as before). ALT text in images that were also objects was never
plotted either, though the placeholder size would have been correct.
This has been fixed.
@
text
@d192 1
a192 1
           tp->tagno != TAG_OBJECT         &&
d543 1
a543 1
  else if (w->tp->tagno == TAG_OBJECT)
d690 2
d1673 1
a1673 1
  else if (tp->tagno == TAG_OBJECT)
a2719 4

            /* Similarly for objects */

//            if (tpCurr->tagno == TAG_OBJECT) object_set_token_object_position(b, tpCurr, -1, -1);
@


1.27
log
@Weird - the line registering the ENavigateToBeShown event disappeared from
Main.c, so the last log was incorrect; Navigate menu items wouldn't have
been greyed out. Probably a(nother?) CVS update screw up on my part; now
fixed. This sort of thing is happening far too often...

Font manager would crash in system font or if a font face was not found
in the previous release - that hacky business of returning weird font
handles when system font is to be used instead ensured a rather less than
valid array reference on behalf of fm_claim_basic_typefaces.

Added in a few more calls to the 'check the button bar' routines, to
ensure that things like Stop are greyed/ungreyed when needed.

Cellpadding code could lead to rmarg overlapping lmarg, or the sum
being greater than dwidth, or something like that (!) in the reformatter.
Anyway the results were unpleasant; this has been sorted out by range
checking right and left margins w.r.t. display width in the relevant
section of the code.

People who specify 'td width = 2000' in tables expecting to get something
sensible now do, though I was half inclined to leave it alone... I can
only assume that they don't know about % specification or it didn't
work in their browser at authorship time, and the huge width served as
an attempt to get the table to fill the available window width. Anyway,
the table reformatter spots when the maximum width a cell requires is
less than half of what it asks for, and ignores the width specifier if
this is the case.
@
text
@d1302 1
a1302 1
/*             relevant to the Object            */
d1361 110
d2507 8
a2514 1
      if (!newline && (tpCurr->tagno == TAG_TABLE)) newline = 1;
@


1.26
log
@Sorted out Res files, including fixing position of 'bytes' label in one
of the Choices dialogues (I'd missed it out of a selection when everything
else got moved down a bit). Unfaded Enc_Chinese menu entries, made sure
text labels were wide enough for system font, changed 'Apply' on Choices
dialogue to 'Set', and added ^K to hotlist keyboard shortcut lists.
Print Setup (i.e. Print dialogue) buttons all set to 'local', so the
stupid Toolbox doesn't close the dialogue and lose the caret before I
can see if it was in there to start with...

256 colour hotlist sprites taken back to standard 16 colour versions,
since there's a significant speed penalty on slower machines. The
testbed browser still has the 256 colour versions so the designs aren't
completely lost.

Changed access settings to exported builds to wr/r - lr/r was really getting
on my nerves whenever I wanted to try something temporary out.

View source, save source and print handlers would all try to work if
there was no source to act on - despite the fact that toolbar buttons
would be greyed out form them. This is fixed.

The Navigate menu has components greyed to match the toolbar state,
when opened. It isn't kept up to date dynamically, though this shouldn't
really be a problem (reopen the submenu...). As part of this, finally
sorted out conditions for the Stop button to be greyed, or the
GoTo/Go/Stop tristate to be at 'Stop' versus 'GoTo'.

Deferred reformatting is now disabled for external image fetches.

Browser-local client pull flag removed; hitting the Stop button simply
cancels any null handlers working for it. That way, client pull switches
back on in passing at the next fetch (it was never really switched off).
So to stop client pull, hit the stop button at any point.

Done CELLPADDING attribute; cellpadding field in reformat_cell (Global.h)
is redundant since the table token is accessible from there, and so it has
been removed. CELLSPACING support also added.
@
text
@d2370 4
d2385 4
d2819 2
@


1.25
log
@Now handles PARAM tags. Sorted out Plug-In bug that was related to Java
setting a 0 by 0 graphics window before calling Wimp_Poll (fixed in Java).
Implemented queue for Plug-Ins so multiple broadcasts aren't sent for
several Objects in one data chunk.

Added Docs directory with some documentation in it. More things to keep
checking for stylistic consistency, horray ;-)

Corrected !Run[D] for Ursula build to need AcornURI but not TaskModule
(URI handler needed for !Mail to pick up mailto: links).

Added display_height field to browser_data, analogous to display_width,
to cope with % sized objects by width and height (see how HRs are
handled in Redraw.c for an example of how it was always fairly easy
with width, but not height until this addition). Though you do have
to reload to get a new size; reformat isn't enough. Must see to this
some time...

Fixed bug where basic typefaces were claimed *before* the Choices file
had been read. For unusual Choices settings, this could create some
'interesting' problems now and again. This was part of narrower scope
work in the Choices code to allow font changing without leaking font
handles (now done; fm_shutdown only ditches fonts, it keeps internal
structures - must then call  fm_lose_fonts for all browsers to get the
bitfields up to date, then rewrite the typeface definitions and reclaim
basic fonts). Noticed that fm_claim_basic_typefaces would claim multiple
instances of the same font if there were several cases of the same font
mapped to different typeface styles - fixed.

Implemented PlugInControl settings, but not SupportObject (fully).
@
text
@d292 2
a293 2
    w->width = tables_width_table (toplevel, w->b, table, w->maxwid, cellarray); // + 3200 * (table->ColSpan + 1); //3200 for edge grooves
    w->bytes = tables_height_table(toplevel, w->b, table,            cellarray); // + 3200 * (table->RowSpan + 1); //3200 for edge grooves
d955 5
a959 1
  /* Do we delay these requests? */
d961 8
a968 1
  if (!choices.refo_wait || immediate) reformat_format_from_now(b, lastline);
d2787 1
d2790 2
d2810 1
a2810 1
  c->width = c->cellwidth = ColWidth;
d2933 1
a2933 3
  // Should do the CELLPADDING stuff here, but where is the actual table
  // definition HStream? The TableStream passed in is just the head of
  // the data stream, not the definition.
d2935 4
a2938 1
  // This would be an 'else' to having no cellpadding info.
d2940 3
a2942 6
//  {
//    /* Default 8 OS unit padding for aesthetics */
//
//    minwidth += 3200;
//    maxwidth += 3200;
//  }
@


1.24
log
@More reformatter code bugs fixed; this one regarding width of items. Any
kerned string was overestimated (causing redraw bugs and caret position
problems in forms, apart from other minor bits elsewhere) and the default
size of a writable icon wasn't especially clever.

Crude Plug-In support; just about manages Java, but can't fetch on
behalf of Plug-In (for example). Had to change the default file access
URL construction to be 'file:/' instead of 'file://', or local file
fetches that reference Java applets won't work. This is in its very
early stages, and is being checked in mostly so that various Choices
issues can be worked on.
@
text
@d1268 1
a1268 1
  if (ISLINK(tp) && (tp->style & IMG))
d1887 4
d2585 1
a2585 1
            if (tpCurr->tagno == TAG_OBJECT) object_set_token_object_position(b, tpCurr, -1, -1);
@


1.23
log
@Bug in reformat_check_height were TEXTAREA element heights were highly
overestimated fixed.
@
text
@d324 3
a326 3
      int h, length;
      int extra = 0;
      int done  = 0;
d343 2
a344 1
        int    width, l, temp;
d357 1
a357 1
        h      = fm_find_token_font(NULL, w->tp);
d372 1
a372 1
                                  &temp,
d385 1
a385 1
                                  &temp,
d402 1
a402 1
                                  &temp,
a424 2

        fm_lose_font(NULL, h);
d449 2
d454 3
a456 1
        /* Arbitrary adjustment for proportional fonts */
d458 1
a458 1
        if ((!choices.system_font) && !(w->tp->style & (PRE | TT))) length /= 2;
d460 1
a460 2
        h = fm_find_token_font(NULL, w->tp);
        e = fm_font_box(h, &box);
d463 3
d467 2
a468 5
        convert_box_to_points(&box, &box);

        w->width = (((box.xmax - box.xmin) * length)) + 16 * 400 + extra;

        fm_lose_font(NULL, h);
d489 1
a489 1
        h = fm_find_token_font(NULL, w->tp);
a501 2

        fm_lose_font(NULL, h);
@


1.22
log
@Added MimeMap module support. OBJECT routines now use this to determine
if the item is an inline image, and if so pass it to the image routines.
At present, support relies on a (correct) content type.
@
text
@d1681 7
a1687 1
    int r;
d1691 2
a1692 2
    top = (top + bot) * r + 12 - bot;
    bot += 16;
@


1.21
log
@Res files had component 0x29fc in frame gadgets for Choices - that's
meant to be the 'fake page' display. Sorted that out.

Got rid of unnecessary #define in Choices.h; the gadget autodetect
for the colour choices took its place.

Unsized objects now default to the same dimensions as unsized images.
@
text
@d192 1
d2572 4
@


1.20
log
@Calling HtmlEndParse at the end of html_get_next_token and setting
up->context to NULL was wrong; fetch_fetcher would end up recalling
html_get_next_token later which would then call HtmlParse even though
the document parse had just finished! The HtmlEndParse call has now
been moved to fetch_stop.

Altered reformatter to claim fonts inside a browser, rather than
claiming them for nothing and losing them afterwards.

Got rid of TAG == TABLE and ISBODY tests, replacing with tagno == TAG_TABLE.
Removed all references to TD, TH, TR and TABLE in the style word.
@
text
@d1253 2
d1304 1
a1304 2

//  imgalign          align;
d1310 36
a1345 42
//  /* Deal with alignments */
//
//  if (tp->style & IMG) /* It'll either be an IMG or an INPUT TYPE=IMAGE item */
//  {
//    if      ((tp->type & TYPE_ALIGN_MASK) == TYPE_MIDDLE) align = imgalign_MIDDLE;
//    else if ((tp->type & TYPE_ALIGN_MASK) == TYPE_TOP)    align = imgalign_TOP;
//    else                                                  align = imgalign_NONE;
//  }
//  else align = HtmlINPUTalign(tp);
//
//  switch (align)
//  {
//    case imgalign_MIDDLE:
//    {
//      box->ymin -= box->ymax / 2;
//      box->ymax /= 2;
//    }
//    break;
//
//    case imgalign_TOP:
//    {
//      box->ymin =- box->ymax;
//      box->ymax = 0;
//    }
//    break;
//  }
//
//  /* Deal with links - need to account for a border */
//  /* of maxlen * 2 pixels width. ISLINK is defined  */
//  /* in Fetch.h.                                    */
//
//  if (ISLINK(tp) && (tp->style & IMG))
//  {
//    int b;
//
//    b = tp->maxlen * 2;
//
//    box->xmax += b;
//    box->ymax += b;
//    box->xmin -= b;
//    box->ymin -= b;
//  }
@


1.19
log
@Big steps forward in vertical white space handling as a result of
improvements in HTMLLib in this area ( -> all versions now 1.22 beta-2).
As a result, the 'last_space' field in browser_data struct has been
removed. Note that this relies quite heavily on setting of the PCDATA
bit in the 'style' field of an HStream and the automatic collapsing
of (for example) multiple P tags inside HTMLLib.

Trace.c improved to recognise various bits in the 'style' field of an
HStream structure.

Phoenix defaults altered to a more 'standard' set of choices; Trinity
as the serif font, with a slightly larger default font size. This is
because there's a good chance it might get released to a wider audience
than Acorn internal (though the animation and icon bar sprites will
have to change before then...).

MiscDefs updated for new SWI numbers in HTTP module; !Run[D] files thus
updated to require HTTP 0.42 or later. At this point, all earlier
modules are not backwards compatible in terms of direct calls to the
HTTP module, though this only affects cookies_process_cookie at present.
At the same time, checks for System$Path, InetDBase$Path, and setting
of Inet$MimeMappings if not already defined have been added to the Run
files along with RMEnsures of Resolver and MimeMap.

Object and PlugIn c/h pairs created to handle OBJECT, EMBED and APPLET,
and the RISC OS Plug-In interface respectively. Not part of the build
process yet. Addition of 'odata' field in browser_data struct and
definition of chunk CK_OBJB for memory_set_chunk_size() are in support
of this.
@
text
@d62 1
d191 1
a191 1
           !(tp->tag == TABLE)             &&
d233 1
a233 1
  if (w->tp->tag == TABLE && ISBODY(w->tp))
d539 14
d571 1
a571 2
    e = reformat_get_image_size(w->b, w->tp, &box);
    if (e) return e;
d635 1
a635 1
      h = fm_find_token_font(NULL, w->tp);
a666 4

      /* We don't need to keep the font claimed for just finding out a width */

      fm_lose_font(NULL, h);
d1216 1
d1281 75
d1546 1
a1546 2
    e = reformat_get_image_size(b, tp, &box);
    if (e) return e;
d1552 12
d1627 1
a1627 1
  else if (tp->tag == TABLE && ISBODY(tp))
d2372 1
a2372 1
      if (!newline && (tpCurr->tag == TABLE && ISBODY(tpCurr))) newline = 1;
d2500 1
a2500 1
        if (tpCurr->tag == TABLE && ISBODY(tpCurr))
d2586 1
a2586 1
              if ((tl & (1u<<20)) && tpCurr->tag == TABLE && ISBODY(tpCurr)) Printf("reformat_reformatter_r: Added a table\n");
@


1.18
log
@!Run[D] files updated to require FTP 0.14, and ensure that the Resolver
and MimeMap modules are present. Paragraph tags can now affect images
and other such objects - previously they only worked on text (this was
noticed for a DIV element containing one image, which was preceeded by
a P element but didn't have any white space above it).

This is the source that will be released to PSI, and builds the Customer
!Customer and internal !Phoenix releases at about 5:00pm on 10/03/97.
@
text
@a1381 1
  int               spaced   = 0;
d1387 59
a1445 9
  /* If the token represents a line break but there is no extra  */
  /* data (so this is right at the top of the paragraph) include */
  /* a gap for the break.                                        */

  if ((!offset) && (tp->style & (P | UL)))
  {
    b->last_space += add, spaced = 1;
    // if (b->last_space <= add) top += add;
    top += add;
d1494 1
a1494 2
    bot            = size + 4;
    b->last_space += bot;
d1545 2
d1548 14
a1561 1
//    if (tp->text && *tp->text)
a1568 5
//    /* Account for leading. */
// // /* Don't do for bold/italic due to font manager bug... */
//
//    if (!(tp->style & (ITALIC | BOLD))) bot += b->leading;

a1574 83
//    else top = bot = box.xmin = box.xmax = box.ymin = box.ymax = 0;

    /* Leave a gap above any DT elements */

    if (!offset && (tp->style & DT))
    {
      b->last_space += add, spaced = 1;
      // if (b->last_space <= add) top += add;
      top += add;
    }

    if ((tpLast) && !(tp->style & (DD | DT)) && (tpLast->style & DD))
    {
      b->last_space += top, spaced = 1;
      // if (b->last_space <= add) top += add;
      top += add;
    }

// Debug section, useful to keep around in case things go wrong!
//
//    Printf("H_MASK: %d\n",(tp->style & H_MASK));
//    if (tp->text) Printf("Text  : '%s'\n",tp->text);
//    else Printf("(No text)\n");
//    Printf("Last  : %p\n",(void *) tpLast);
//    Printf("H_MASK: %d\n",(tpLast->style & H_MASK));
//    if (tpLast) Printf("Logic : %d\n\n",((tp->style & H_MASK) && !(tpLast->style & H_MASK)));
//    else Printf("(No last)\n\n");

    /* Gap if the indentation level changes */

    if ((tpLast) && (tp->indent != tpLast->indent))
    {
      b->last_space += add, spaced = 1;
      // if (b->last_space <= add) top += add;
      top += add;
    }

    /* Gaps for headers; first, if a header is turned on, */
    /* then, if it is turned off.                         */

    if ((tpLast) && ((tp->style & H_MASK) && !(tpLast->style & H_MASK)))
    {
      b->last_space += add, spaced = 1;
      // if (b->last_space <= add) top += add;
      top += add;
    }

    if ((tpLast) && ((tp->style & H_MASK) && !(tpLast->style & H_MASK)))
    {
      b->last_space += add, spaced = 1;
      // if (b->last_space <= add) bot += add;
      top += add;
    }

    /* Similarly give extra gaps around header entries */

    switch (redraw_header(tp->style))
    {
      case 1: bot += 16, top += 20;
      break;
      case 2: bot += 16, top += (64 & (!offset));
      break;
      case 3: bot += 16, top += (64 & (!offset));
      break;
      case 4: bot += 16, top += (32 & (!offset));
      break;
      case 5: top += (32 & (!offset));
      break;
      case 6: top += (4 & (!offset));
      break;

      /* Give a gap for block quotations as they switch on or off (i.e. the flag saying */
      /* if the tag is part of a block quote has changed between this tag and the last  */
      /* one).                                                                          */

      default: if (tpLast && ((tp->style & BLOCKQUOTE) != (tpLast->style & BLOCKQUOTE)) && !offset && !add)
               {
                 b->last_space += top, spaced = 1;
                 // if (b->last_space <= add) top += top;
               }
    }

    if (!spaced) b->last_space = 0;
d1605 1
d1616 1
d1619 1
d1623 1
d1626 1
d1640 1
@


1.17
log
@!Run[D] files updated to require HTTP 0.41 and FTP 0.13.

Redraw routines now allow tables to be indented with body text. Some page
layouts rely on this.
@
text
@d1382 16
a1397 1
  int               top = 0, bot = 0;
d1414 2
a1415 2
    top =  box.ymax;
    bot = -box.ymin;
d1456 4
a1459 2
    read_sprite_size("fopton", NULL, &top);
    top -= 8;
d1468 4
a1471 2
    read_sprite_size("fradioon", NULL, &top);
    top -= 8;
d1479 1
a1479 1
    top = reformat_bullet_height(tp->indent);
d1493 2
a1494 5
    int           h;
    int           spaced   = 0;
    int           fontsize = choices.font_size >> 4;
    unsigned char add;
    BBox          box;
d1504 1
a1504 1
      top = box.ymax;
a1517 15

    /* The amount to add to 'top' to give line break effects */

    add = (unsigned char) 3 * fontsize;

    /* If the token represents a line break but there is no extra  */
    /* data (so this is right at the top of the paragraph) include */
    /* a gap for the break.                                        */

    if ((!offset) && (tp->style & (P | UL)))
    {
      b->last_space += add, spaced = 1;
      // if (b->last_space <= add) top += add;
      top += add;
    }
@


1.16
log
@Version in Messages taken to 1.22 (03 Oct).

Updated Res files in appropriate builds to hold various (similar) Choices
designs.

Choices related menus were flagged as Shared, but none of the dialogues
(including ColourDBox) were - potential future problems, though shouldn't
cause any leaks at present. This has been sorted out anyway.

Encoding function encoding_init no longer returns an error from
toolbox_create_object, so the Encoding menu and all those attached
to it do not have to be present (e.g. the Customer build).

SUB, SUP, STRIKE and U supported. U underlines the baseline of the body text
font, whilst STRIKE will go through roughly the middle of the lower case
chars even if the font is SUP or SUB. Note that Navigator appears to shift
the underline point for SUB and SUP; it may be necessary to copy this
behaviour, but testing on real sites must proceed before that. There could
also be a problem with the automatic lowering of font size, which Navigator
doesn't do, so any FONT SIZE = -n commands could make it too small. Again,
this needs testing on real sites.

'http://' is added to URLs with no protocol specified, unless they start with
'ftp.', in which case the new behaviour is to add 'ftp://'.

Choices code altered to do less error checking on components! They should be
able to be missing without raising errors. Referencing of the subwindow
array changed from *(subwindows + number) to subwindows[number].

Made trace_tag_name code look pretty...

reformat_useless_token now checks tagno is non-zero.

User Agent string setting now done through URL_GetURL, on a per-session
basis.

Ellipsis character removed from all Messages files, replaced with '...'.
There's little difference between the two in an outline font, and in System
font the latter looks much better. Smart quotes left in, as they look
better in all cases.
@
text
@d2408 1
a2408 3
                    Reformat_AsWideAsPossible_MP : displaywidth - linewidth;

        wd.maxwid -= right_margin;
@


1.15
log
@Added support for HTMLLib HttpEndParse call.

Text items with no VALUE specified in the HTML were not cleared on
hitting a Reset button as the text field of the token is NULL; fixed.
SELECT lists with no default selection item were not being changed
on hitting a Reset button; fixed. In radio groups with no default
selection specified, no item will be selected. This goes against
the HTML 2 spec but allows broken Navigator-esque forms behaviour.
In consequence, radios can be deselected by clicking on the same
one twice. I'd fixed the flickering experienced when doing this
recently, but that, now, is irrelevant, since the state of a radio
must always change.

Reformatter's new 'find width of a SELECT field' didn't account for
the width of <none> and <many> items, and now does (particularly
important for broken items with no OPTION contents).

Under certain circumstances, illegally named targets would open in the
ancestor rather than a new window - a deliberate decision in the code,
but now reversed due to a test suite failure; they'll open in a new
window instead.

Altered the left hand indent handling for lists so that headings and
body text follow the Navigator 48 pixel indent and the bullet point
items drop to the left of the left hand margin, rather than sitting
on the margin with the text indented to the right.

Tightened up the hotlist_load_directory checking of URLs, so that
only those with '://' in - i.e. look fully specified - are accepted.
HTML files are loaded into a new directory now.

Items without a descriptive title in hotlist_new_url will have the URL
substituted in instead. White space before and after descriptions and
after URLs is stripped. Directories with zero length names or null
strings (after white space is stripped) will still be created, with a
generic name (see Messages, token 'HotlistUntitled').
@
text
@d682 1
@


1.14
log
@Tidied up Hotlist source a bit more, mostly so PSI can use the automatic
StrongHelp generator on it. Revealed a spurious toolbox_hide_object call
that would always fault and never do anything, and a few heinous uses
of show_error which have all been removed.

When dragging hotlist items, directories will now be highlighted whenever
the item would be added to them, rather than just over the sprite. In
practice this only changes if the item is open and has contents...

Drag box selections had broken in the hotlist; fixed (uninitialised
variable in hotlist_select_box). Adjust-drags now close the window on
completion. Minor problem with Shift+Drag (copy) reversing order of items
sorted out. Added hotlist_add_html_file and implemented loading of HTML.
DO NOT add broken HTML files, this has not been coded for and URLs of the
form http:///this/that (no host name) will hang the machine (bug in the
cookie code of the HTTP module up to at least version 0.39).

Made SELECT list items only as wide as the widest entry actually appears
(using fm_get_string_width), rather than as wide as the widest character
BBox in the font multiplied by the string length of the longest entry.

Updated !Run[D] files to require HTTP 0.39, FTP 0.12 and File 0.23.
@
text
@d359 31
d409 2
d416 3
@


1.13
log
@Now working on source merged with Kevin Bracey's internationalisation
support. UNIFONT is undefined in the Make File for now. All Res and
Choices files updated appropriately.

Having sorted out the old Choices and Messages to form Choices, Controls
and Messages, this build has had the same cleaning up done internally.
This includes greater consistency in naming schemes and the removal of
the inconsitent choices items - e.g. Choices file entries saying 'delay
images' and 'plain backgrounds' where internally all the flags say 'show
images' and 'show backgrounds'. ChoiceDefs.h and CtrlDefs.h added to
clarify the meaning of some fields, though usage of these is not 100%
in the source (there are cases where parameters are passed through to
functions as ints, and those functions still check these against hard
coded values rather than the #define stuff).

Fetcher status return bits (connected, sent request, etc.) now reflected
in status bar. Progress during fetchs to files are reported by %, where
the size of the object is known. Exceeding 100% drops back to a byte
counter, in case the estimated size was wrong. The progress counter
may be updated after specific delays, rather than 'as often as possible',
to reduce flicker (as requested by D.Brown some time ago).

I've done a small rewrite of the fetch prioritisation scheme in FetchPage.c;
how well this performs in general use across different processor speeds
remains to be tested, but certainly it has some advantages. For each small
fetch window before the rewrite, a 4cs tight loop was entered - this gave a
noticable and substantial drain to the Desktop performance if more than one
was opened. Now, several can be up at once with little hit. The actual file
fetch is on half the priority it was before, with all others taken back
just a bit - e.g. from 20cs per poll to 15cs per poll for flat out
reformatting. You don't seem to lose much time on the format in practice,
and the Desktop feels quite a bit lighter at the same time. There's the
potential for smoother frameset loading in this scheme, too.

When Shift+Clicking on a link meant you still fetched inside the main
browser window, several fetches could occur in a frameset - one per frame.
However, now that you can only do this by clicking on a link that leads to
non-displayable data - or by turning off the small fetch windows by
setting UseSmall to 'no' in Choices - a bug where fetchpage_preprocessed
would stop such fetches as new ones were started was revealed.
The API to frames_abort_fetching has now been extended to include a
'stop file spooling too' flag, allowing a fix to be made by having
fetchpage_preprocess's calls not set this (and it doesn't check the
savelink flag is unset before proceeding, since frames_abort_fetching
does that implicitly now).

Had left the RAM transfer buffer at 16 bytes (from testing) accidentally...
Oops. Upped it to 4K. In addition, when loading data by RAM transfer,
the browser didn't notice if a RAMFetch bounced during the transfer. It
would be treated as a 'first' RAMFetch bounce, basically, and try to go to
file transfer - oops. Fixed.
@
text
@d322 3
a324 1
      int  h, length, extra = 0;
d335 1
a335 1
        extra = 0;
d341 1
a341 1
        int    width, l;
d350 2
a351 2
        p = (char *) HtmlSELECToptions(w->tp) + 8;
        l = 8;
d353 7
a359 1
        while(*p != 0xff)
d362 18
a379 1
          if (strlen(p) > l) l = strlen(p);
d383 5
a387 1
        length = l;
d401 2
d405 11
a415 2
      if (length == 1) length = 2;
      else if (length < 2) length = 20;
d417 1
a417 1
      /* Arbitrary adjustment for proportional fonts */
d419 2
a420 1
      if ((!choices.system_font) && !(w->tp->style & (PRE | TT))) length /= 2;
d422 1
a422 2
      h = fm_find_token_font(NULL, w->tp);
      e = fm_font_box(h, &box);
d424 1
a424 1
      if (e) erb = *e, e = &erb;
d426 1
a426 1
      convert_box_to_points(&box, &box);
d428 2
a429 1
      w->width = (((box.xmax - box.xmin) * length)) + 16 * 400 + extra;
a430 1
      fm_lose_font(NULL, h);
@


1.12
log
@Support for ANT URL broadcast message added.

Image deletion routines rewritten; nasty animated GIF bug now gone
(it kept trying to update the cross-referenced image in the browser that
no longer existed, and I've no idea how animated GIFs ever managed to *not*
blow up if a cross referencing browser was shut down; and I've tested
this...). There are now as many image structures as there are total images
in the visible browsers, and no more; cross referenced images in the
to-be-deleted browser have their ownership moved to the cross
referencer before the cross referencee is wiped, with any required fetches
being transferred with them.

Reformatter sped up a bit by getting rid of strlen on the main text field
of tokens in all places bar one, where it is called extremely rarely. This
means direct app-to-app transfer of, say, a 359K text file to the browser
won't run like a drain as it tries to do strlen on a 359K string over and
over again! Most of the time the performance benefits won't really be
noticable, but on the above text file, formatting time went down from
290 seconds before the change to just under 7 seconds, a 41 fold speed
increase or thereabouts (SA110 228MHz).

MakeFile changed to force function name compilation on for debug builds
(-fn in the DD...FLAGS); useful for certain functions such as
register_null_handler, which can now output the name of the function
being registered.

...Which helped show up some nasties in the animation handler and animation
drift handler registration/deregistration process, which have been fixed
(callers of fetchpage_release_nulls were unaware that the drift handler
could be installed, and fragments of old code checking choices.anim_drift
had a value other than 1 or 0 were still hanging around - bit tricky for
a single bit item).

Added support for VALIGN in table cells. Spotted a bug or two in the
'what token is the pointer over' routines as a result, and fixed them - the
worst was in browser_line_at_y, which checked the y coordinate was below
the given one [the mouse], but didn't check the line height to see if the
given y coordinate was *within* the line, rather than just above it. Never
used to matter pre-tables, but a definite concern once multiple line
arrays can exist on one page.
@
text
@d112 1
a112 1
//    else if (b->cell->nlines <= 0) Printf("reformat_formatting: %p will return b->finaltoken != NULL: %d\n",b,b->finaltoken != NULL);
d115 1
a115 1
//  else if (b->cell->nlines <= 0) Printf("reformat_formatting: %p will return b->finaltoken != NULL: %d\n",b,b->finaltoken != NULL);
d128 1
a128 1
    /* The check for a 'next' token is done as finaltoken only    */
d131 1
a131 1
    /* circumstances to leave last_token and finaltoken           */
d149 1
a149 1
  if (b->cell->nlines <= 0) return (b->finaltoken != NULL);
d379 1
a379 1
      if ((!choices.systemfont) && !(w->tp->style & (PRE | TT))) length /= 2;
d869 1
a869 1
  if (!choices.refowait || immediate) reformat_format_from_now(b, lastline);
d872 1
a872 1
    if (b->refotime)
d880 1
a880 1
      if (lastline < b->refoline) b->refoline = lastline;
d890 1
a890 1
                &b->refotime);
d894 1
a894 1
      b->refoline = lastline;
d908 3
a910 2
/* to the start time specified by the 'refotime' */
/* field of the browser_data structure.          */
d923 1
a923 1
  if (!handle->refotime)
d925 1
a925 1
    handle->refotime = 1; /* So that reformat_stop_pending will deregister this handler */
d941 1
a941 1
  if (timenow - handle->refotime > choices.refotime)
d945 1
a945 1
    ChkError(reformat_format_from_now(handle, handle->refoline));
d979 1
a979 1
  if (b->refotime)
d981 1
a981 1
    if (b->refoline < lastline) lastline = b->refoline;
d1112 1
a1112 1
  if (b->refotime) deregister_null_claimant(Wimp_ENull, (WimpEventHandler *) reformat_format_timer, b);
d1114 2
a1115 2
  b->refotime = 0;
  b->refoline = Reformat_UnrealisticallyHighLineNumber;
d1257 2
a1258 2
  if (!fixed.swapbars) offset = toolbars_button_height(b) + toolbars_url_height(b);
  else                 offset = toolbars_status_height(b);
d1353 2
a1354 2
    bot           = size + 4;
    b->lastspace += bot;
d1399 1
a1399 1
    int           fontsize = choices.fontsize >> 4;
d1436 2
a1437 2
      b->lastspace += add, spaced = 1;
      // if (b->lastspace <= add) top += add;
d1445 2
a1446 2
      b->lastspace += add, spaced = 1;
      // if (b->lastspace <= add) top += add;
d1452 2
a1453 2
      b->lastspace += top, spaced = 1;
      // if (b->lastspace <= add) top += add;
d1471 2
a1472 2
      b->lastspace += add, spaced = 1;
      // if (b->lastspace <= add) top += add;
d1481 2
a1482 2
      b->lastspace += add, spaced = 1;
      // if (b->lastspace <= add) top += add;
d1488 2
a1489 2
      b->lastspace += add, spaced = 1;
      // if (b->lastspace <= add) bot += add;
d1516 2
a1517 2
                 b->lastspace += top, spaced = 1;
                 // if (b->lastspace <= add) top += top;
d1521 1
a1521 1
    if (!spaced) b->lastspace = 0;
d1700 2
a1701 2
  if (!fixed.swapbars) hbot = toolbars_status_height(b);
  else                 hbot = toolbars_button_height(b) + toolbars_url_height(b);
d1964 1
a1964 1
  int                   displaywidth, leftmargin, rightmargin;
d2194 2
a2195 2
      if (tpCurr->style & HR) leftmargin = 0;
      else                    leftmargin = redraw_margin(b, d, tpCurr);
d2203 2
a2204 2
        if (tpCurr->style & BLOCKQUOTE) rightmargin = leftmargin;
        else                            rightmargin = redraw_right_margin(b, d);
d2206 1
a2206 1
      else rightmargin = 0;
d2211 1
a2211 1
      if (!newline && !(tpCurr->style & PRE) && linewidth > displaywidth - rightmargin) newline = 1;
d2298 1
a2298 1
          linewidth = leftmargin;
d2333 1
a2333 1
        wd.maxwid -= rightmargin;
d2503 1
a2503 1
            if (linewidth >= displaywidth - rightmargin)
d2533 1
a2533 1
    if (choices.keyboardctl)
d2804 4
a2807 4
        if   (b->lastchar == ' '
           || b->lastchar == '('
           || b->lastchar == 148  /* Opening double quote */
           || b->lastchar == '\"')
d2814 5
a2818 5
        if   (b->lastchar == ' '
           || b->lastchar == '('
           || b->lastchar == 144  /* Opening single quote */
           || b->lastchar == '\''
           || b->lastchar == '`')
d2823 2
a2824 2
      else if (*curr == '-' && b->lastchar == ' ') *curr = 151; /* 'en' dash */
//      else if (*curr == '-' && b->lastchar == 151) memmove - something!
d2826 1
a2826 1
      b->lastchar = *curr;
d2885 4
a2888 4
    /* Now do smart quotes substitution. Need to do this */
    /* separately from the main text routines as the     */
    /* lastchar variable must not be changed by ALT text */
    /* - it stands alone for each image.                 */
@


1.11
log
@Got the deferred reformatter working properly. It doesn't do that 'OK,
the page is fetched and reformatted, but just to annoy you, I'm going
to wait 5 seconds and then suddenly reformat the whole thing again'
trick anymore. The fetcher was calling the reformatter in a delayed
form even when the reformatter was already running, so it would carry
on past the reformat point or from below what had become and invalidated
line, and some time later, get back to the delayed reformat. Now,
reformatting is only delayed by the fetcher when the reformatter is not
running. In practice this means body text reformats as it fetches, but
large tables will show delayed reformatting - which was exactly the
intended behaviour of the feature when it was originally thought of.

fetch_token_data_address removed; it was only needed in two places,
both of which already knew when to read tp->text and when to ignore
it. Its functionality is duplicated in an 'if' involving reformat_istext,
anyway.

!Run[D] files taken back to requiring HTTP 0.33, since 0.36 introduces
many weird and wonderful problems.

Typo in Messages files, 'All current images (sic.) fetches finished' -
'images' is now 'image'.

Shift+Click saving - you could save to an application. No problem. But
the equivalent (just clicking on a link that led to an unknown datatype
and getting the save dialogue that way) didn't work. It does now.
Another problem was saving to an application that didn't support the
datatype - oops, the dialogue would close but the fetch would sit there
waiting to be told where to save. It doesn't close now (as expected).

NB, doing several simultaneous fetches to a text editor may have problems
as the editors are too clever for their own good. Despite receiving
DataLoad messages for <Wimp$Scrap> for files of different types, sizes
and datestamps, the editors can decide it's still the same file and:

Zap      - Hats off, it gets it right, almost. You do get warned 'Multiple
           copies - one on disc is newer' as everything after the first
           text loads, but they do load, and in separate windows.
StrongED - Does not load the subsequent files, so the browser gives 'Data
           transfer failed' errors and opens up Scrap. Turning off 'Don't
           load same file twice' fixes it - each file is loaded in a new
           window with no warnings. At least in the first case, you don't
           lose data, since the files are kept in Scrap.
Edit     - Each time it loads the file, it *replaces* the other one in
           memory, using the same window for each. This is the worst
           behaviour as it isn't configurable (well, I don't know of a way
           to change it...) and results in data loss as successive texts
           get trounced by the new data.

I can't see how I can fix this in the browser as it's basically silly
behaviour on behalf of the editors. Other applications which don't try
to work out if it's a new file or not are fine!

When conducting image fetches, proxying is allowed unless reloading.
When conducting page fetches, proxying was never allowed - so web cache
stuff would have been, er, interesting. It now sets X-NoProxy: in the
request header when reloading, but otherwise this is not included.

AnimSpeed is, at last, independent of browser poll speed. They used to
be tied together. Guess how the animation code used to work ;-)

'Can't handle this datatype' - deprecated now that save dialogues can be
popped up. The 'can't save objects in full screen mode' error would never
be shown due to a bug, anyway; this now replaces 'can't handle', which
has been removed from all Messages files.

RefoWait, RefoHang and RefoTime moved from Controls back to Choices.

Trying to get rid of strlen in the reformatter - it can get very slow
(e.g. strlen of 8K chunks of text, or if a 330K text file is transferred
from a text editor straight to the browser, strlen of a 330K string...).
There will be unfinished bits of code in the reformatter that may seem
unnecessary - they've just not been plugged in yet (since they don't
actually work). Don't remove them!
@
text
@d190 1
d754 1
a754 2
  /* Horizontal Rule and Image tags have no relevant extra */
  /* data. HR and IMG are defined in HTMLLib:tags.h.       */
d756 1
a756 2
  if ((tp->style) & HR) return 0;
  if ((tp->style) & IMG) return 0;
d2062 8
a2069 1
      if (d->cdata[cnLast].l <= 0) offset = reformat_datasize(tpLast);
d2119 4
a2122 2
    // !token_has_text || !tpCurr->text[offset]
    if (!tpCurr || offset >= reformat_datasize(tpCurr))
d2468 15
a2482 2
            if (wd.bytes <= 0) offset = reformat_datasize(tpCurr) + 1;
            else offset += wd.bytes;
a2506 5

            /* If offset is still within the token data, there must have been a */
            /* line split point in there so we need another chunk.              */

            if (offset < reformat_datasize(tpCurr)) newline = 1;
@


1.10
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d518 1
a518 1
    int h, end, split, length;
d520 1
a520 2
    /* If there is text associated with the token, set 'length' */
    /* to the string length of that text; else set it to 0.     */
d522 10
a531 1
    length = w->tp->text ? strlen(w->tp->text) : 0;
d533 1
a533 3
    /* Loop round until a newline is found, or the end of the  */
    /* string is reached, starting at the offset into the data */
    /* specified by the 'offset' field.                        */
d535 1
a535 2
    end = w->offset;
    while ((end < length) && (w->data[end] != '\n')) end++;
d537 2
a538 2
    /* If the text is preformatted, set a null split character. */
    /* Else specify splitting on spaces.                        */
d540 1
a540 1
    split = (w->tp->style & PRE) ? -1 : ' ';
d542 1
a542 1
    /* Get a font handle for rendering the token */
d544 1
a544 1
    h = fm_find_token_font(NULL, w->tp);
d546 4
a549 4
    /* If end > offset, the loop above must have gone through at least */
    /* one non-newline character in the string, or there was no string */
    /* to look through; find the width of the string (the call won't   */
    /* mind if there's no string, it'll just return 0)                 */
d551 5
a555 5
    if (end > w->offset) e = fm_get_string_width(h,
                                                 w->data + w->offset,
                                                 w->maxwid,
                                                 end - w->offset,
                                                 split,
d557 2
a558 2
                                                 &w->bytes,
                                                 &w->width);
d560 3
a562 3
    /* If finding the minimum or maximum width for tables, add a little to */
    /* the above width to account for italics etc. - the font manager will */
    /* not have returned the upper limit on either side.                   */
d564 5
a568 5
    if (
         (flags & Reformatter_FindingWidest)   ||
         (flags & Reformatter_FindingSmallest)
       )
       w->width += 3200;
d570 4
a573 4
    /* If the scan for a newline finished before the end of the string (so */
    /* a newline was found) and the chunk of data defined by the call to   */
    /* fm_get_string_width above gave a string ending in a newline, add 1  */
    /* to the bytes counter to ensure that the chunk includes it.          */
d575 1
a575 1
    if (end < length && w->data[w->offset + w->bytes] == '\n') w->bytes++;
d577 1
a577 1
    /* We don't need to keep the font claimed for just finding out a width */
d579 2
a580 1
    fm_lose_font(NULL, h);
d983 1
a983 3
    b->refotime = 0;
    b->refoline = 0x1000000;
    deregister_null_claimant(Wimp_ENull, (WimpEventHandler *) reformat_format_timer, b);
d1115 1
a1115 1
  b->refoline = 0x1000000;
d1966 1
d2110 4
d2305 1
a2305 1
        wd.data   = fetch_token_data_address(b, tpCurr);
@


1.9
log
@Very long log entry alert - but hey, beats 'Bug fixed' (sorry, Richard) ;-)

Open URL implementation more or less complete, though may undergo UI
revision at a later date to allow named frames to be targetted. Hope to use
the ideas in this code as the foundation for other general dialogues.

In token stream dump for TRACE builds, table head items were not indented
as far as they should have been - this is fixed; and manual toolbar redraw
routines have been removed. They never worked, were commented out, and
would never be used in that form anyway.

DragBox source added, but it isn't at all complete and won't work - this is
an 'in spare time' thing. We need custom drag boxes constrained to windows
for the hotlist, and unconstrained for frame border resizing... Hey ho.

Ancestor window extents match visible areas if there are frames (no more
scrolling framesets...!). Frame resizing works whilst new documents fetch
without pulling the extent down now. However, frame horizontal extents
never shrink until a reload which is nasty, and this is all due for a
rewrite. Frames border redrawing routine moved out of Redraw.c and into
Frames.c. Bug regarding the mouse rectangle and frame border widths
(rectangle was too large, so you could squash the edges) for edge-drag
frame resizes fixed.

Window width change reformat tolerance fixed; you could creep the window
width down or up forever without any reformat, and centred objects would
move but not be redrawn (thereby giving rise to subsequent redraw errors).

Filetype on objects saved through Shift+Click correct. Save Source dialogue
recognises if that source is plain text, rather than assuming HTML. A
browser that fetches a file remembers the old store size it had before the
save, so even though the data is now ditched, it reports the same amount of
data fetched afterwards (looked awful when this could, for example,
suddenly say '0' after a file save). Progress indicator is now fully aware
of one or many file saves inside a frameset and reports the number of
saves, a colon, and the cumulative saved data count, instead of reporting
the sum total of fetched data in all frames, including non-file save stuff
(note that for just 1 save, '1:' is not shown as a special case for the
most common condition). A bug related to this, where you could in fact only
do one fetch per frame*set*, has been corrected (only one fetch allowed per
frame still, this is unlikely to ever change).

Hotlist support added (D.Brown's source), with various bits of integration
and modification still in progress there. Note additions to the Messages
files. On the subject of Messages, the whole mucky business about what
goes in Messages or Choices (and a few bugs where lookup_choice was used
instead of lookup_token or vice versa) has been sorted out. Messages
contains, more or less, just that. Choices contains user configurable
stuff which generally can't mess things up too badly. A new file, Controls,
is a Messages file holding the non-user configurable choices, which can
generally make things go badly wrong if misused. A lot of these are tied
to the Res file. StrongED users can get these to automatically fold out
the various sections (EMail me for details). Sorry, but at the time of
writing, Zap doesn't do folding... =8*P

Two bugs with images. Asking for images to be shown in browser B when
browser A uses the same ones and was loaded first didn't work correctly,
and now does (a bit weird - browser A does the fetch and browser B does the
display...). Second one occurred when the background image was also used on
the page as a foreground image. This has been fixed by flagging background
images in the image_info structure, and checking this before cross
referencing. This bit also allowed the image_restart_fetches API to be
extended, so that just background or foreground images may be fetched if
they weren't already and the user asked the browser to show them. Before,
the whole lot had to be fetched together (so turning on 'display
backgrounds' will now kick off an image fetch if required, you don't
need to reload the page anymore).

Makefile copy options tweaked to be 'newer' (so if you're testing with some
temporary Choices file or something, it won't write over it at the end of
every export), and REMOTE_HOTLIST flag added for Customer builds - means
the Hotlist.c functions aren't needed; the old, hotlist-by-file method is
used. Added support for Customer build (see later), though there were very
few additions needed in practice.

Table printing fixed - in many ways it wasn't broken, it was image printing
causing the oddities ever since the global image pool was introduced (this
is, again, fixed). The 'reformat to fit page' option didn't work as coded
any more; tables store cell addresses in the HStreams, so you can't then do
a background reformat in a different browser. Hence, it now has to reformat
to the page width, print, then put the page back again, all in the actual
displayed browser. This doesn't feel as slow in use as it perhaps should,
considering what is going on... Note that a line of a defined fraction (see
Print.h) of page height will now split over page boundaries, so tall images
or tall tables don't cause problems now (aside from the obvious problem of
having the line split over a page at all!). There was a bug in the routine
to print from a given start point until 'n' pages had been filled, in that
it always filled 'n + 1' - now fixed. Finally, as part of the printing
tweaks, a new dialogue exists - PrintStyle - with a similarly named source
file added to deal with it.

Global history auto save / load done, but only to the Choices file path -
the whole browser is still strictly single user at present, with all the
extra work for a multiuser Customer environment yet to be done. This has
shown up a global history corruption problem which I haven't fixed yet.

Rationalising TBEvents.h - things are migrating out of it, and into more
appropriate sources (e.g. definitions relating to the Open URL dialogue are
going into OpenURL.h, etc.). Event codes were at one stage deliberately
diverged in numberspace from the component IDs of typical gadgets raising
the events, to avoid anyone getting confused and thinking the IDs and event
codes must match. However, this is in fact unlikely and it is much easier
to remember the fewer numbers that result from tying the two together where
possible. This has resulted in changes to event codes raised in the
following objects of all Res files: Authorise, Find, OpenURL, and
PrintStyle.

And finally - !Run[D] files for all variants updated to require the latest
toolbox and fetcher modules. All Res files updated for hotlists etc. and
sprites files updated appropriately. All Messages, Choices and Controls
files brought in sync., and an Customer build has been added (based on the
Desktop build binary with different resources).

That's all for now...
@
text
@d272 1
a272 6
    if (!table->cells)
    {
      make_no_table_memory_error(9);

      show_error_cont(&erb);
    }
d595 17
@


1.8
log
@Modified to cope with withdrawal of #defines SELECT, INPUT etc.
Added right-align support.
@
text
@d107 1
a107 1
//  if (b->suspend_format) Printf("%p suspend_format set\n");
d110 4
a113 2
//    if (!b->last_token->next) Printf("%p b->last_token->next = NULL\n");
//    else if (b->last_token->next && !(b->last_token->next->flags & HFlags_DealtWithToken)) Printf("%p last_token->next HFlags NULL\n");
d115 2
a116 2
//  else if (b->cell->nlines <= 0) Printf("Will return b->finaltoken ! NULL: %d\n",b->finaltoken != NULL);
//  else Printf("Will return 1\n");
d188 8
a195 2
  return (((tp->style) & (IMG | HR)) == 0 &&
          !(tp->tagno == TAG_INPUT && HtmlINPUTtype(tp) == inputtype_IMAGE));
d313 11
a323 8
  else if (w->tp->tagno == TAG_INPUT    ||
           w->tp->tagno == TAG_TEXTAREA ||
           w->tp->tagno == TAG_SELECT)
  {
    if ( w->tp->tagno == TAG_TEXTAREA ||
         w->tp->tagno == TAG_SELECT ||
         HtmlINPUTtype(w->tp) == inputtype_TEXT ||
         HtmlINPUTtype(w->tp) == inputtype_PASSWORD
d825 6
d1189 1
a1189 1
  char spr[20];
a1191 21
  #ifdef TRACE

    {
      int len = utils_len_printf("b%d\0", (bullet + bullets - 1) % bullets);

      if (len > sizeof(spr))
      {
        erb.errnum = Utils_Error_Custom_Normal;
        sprintf(erb.errmess,
                "Would have overflowed sprite name string buffer in reformat_bullet_width (needed %d bytes, had %d)",
                sizeof(spr),
                len);

        show_error_ret(&erb);

        return 44;
      }
    }

  #endif

d1214 1
a1214 1
  char spr[20];
a1216 21
  #ifdef TRACE

    {
      int len = utils_len_printf("b%d\0", (bullet + bullets - 1) % bullets);

      if (len > sizeof(spr))
      {
        erb.errnum = Utils_Error_Custom_Normal;
        sprintf(erb.errmess,
                "Would have overflowed sprite name string buffer in reformat_bullet_height (needed %d bytes, had %d)",
                sizeof(spr),
                len);

        show_error_ret(&erb);

        return 44;
      }
    }

  #endif

d1296 1
a1296 1
         tp->tagno == TAG_INPUT &&
d1343 4
a1346 1
  else if (tp->tagno == TAG_INPUT && HtmlINPUTtype(tp) == inputtype_CHECKBOX)
d1353 4
a1356 1
  else if (tp->tagno == TAG_INPUT && HtmlINPUTtype(tp) == inputtype_RADIO)
d1381 3
a1383 1
    int           h, spaced = 0, fontsize = choices.fontsize >> 4;
d1656 1
a1656 1
/* extent can only ever grow.                    */
d1668 1
a1668 1
  int                         hbot;
d1679 1
a1679 2
  e = wimp_get_window_state(&s);
  if (e) return e;
d1705 3
d1715 1
a1715 2
  e = window_set_extent(0,b->self_id,&new_extent);
  if (e) return e;
d1724 1
a1724 2
    e = toolbox_get_parent(0, b->self_id, &po, &pc);
    if (e) return e;
d2384 8
a2391 3
            if (tpCurr->style & IMG ||
                (tpCurr->tagno == TAG_INPUT && HtmlINPUTtype(tpCurr)==inputtype_IMAGE))
              image_set_token_image_position(b, tpCurr, -1, -1);
d2796 11
a2806 1
  else if (tp && tp->text && ((tp->style & IMG) || (tp->tagno == TAG_INPUT && HtmlINPUTtype(tp) == inputtype_IMAGE)))
@


1.7
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@d187 1
a187 1
          !((tp->style & INPUT) && HtmlINPUTtype(tp) == inputtype_IMAGE));
d305 3
a307 1
  else if (w->tp->style & (INPUT | TEXTAREA | SELECT))
d309 2
a310 1
    if ( (w->tp->style & (TEXTAREA | SELECT) ||
a312 1
         )
d317 1
a317 1
      if (w->tp->style & TEXTAREA)
d328 1
a328 1
      else if (w->tp->style & SELECT)
d1321 1
a1321 1
         (tp->style & INPUT) &&
d1368 1
a1368 1
  else if ((tp->style & INPUT) && HtmlINPUTtype(tp) == inputtype_CHECKBOX)
d1375 1
a1375 1
  else if ((tp->style & INPUT) && HtmlINPUTtype(tp) == inputtype_RADIO)
d1532 1
a1532 1
  if (tp->style & TEXTAREA)
d1543 1
a1543 1
  else if (tp->style & SELECT)
d1555 1
a1555 1
  else if (tp->style & INPUT)
d2402 1
a2402 1
                ((tpCurr->style & INPUT) && HtmlINPUTtype(tpCurr)==inputtype_IMAGE))
d2808 1
a2808 1
  else if (tp && tp->text && ((tp->style & IMG) || ((tp->style & INPUT) && HtmlINPUTtype(tp) == inputtype_IMAGE)))
@


1.6
log
@Quite a few general source changes throughout many files to sort out swapped
toolbars. There will be more work on this shortly. svcprint.c has been
modified to allow it to output to a file in PipeFS, so TML-less machines
can still use the standard browser debug routines (albeit in a less than
elegant fashion). Comments in that source file give more details. Plus a
few more bug fixes.
@
text
@d17 3
a19 1
/* Purpose: Reformatting functions for the browser */
d21 1
d55 1
a55 1
#include "Fetch.h"
d107 9
d206 1
a206 1
/*             structure (see Reformat.h)        */
d208 2
a209 3
/* Returns: Fills in the structure's 'width' and */
/*          'bytes' fields with width and byte   */
/*          count information;                   */
d211 3
a213 2
/*          Flags word, as passed to             */
/*          reformat_reformatter.                */
d559 2
a560 2
    /* fm_get_string_width() above gave a string ending in a newline, add  */
    /* 1 to the bytes counter to ensure that the chunk includes it.        */
d605 1
d608 1
d694 3
a696 3
/* calling reformat_newline_check() (see above)  */
/* and is only interested in if the value the    */
/* call returned was zero or not.                */
d717 1
a717 1
/* Returns: Size of associated data, in bytes    */
d744 2
a745 1
/*             holding information on the lines  */
d747 2
d750 2
a751 1
/*                         (these are inclusive) */
d753 1
a753 1
/*             in OS units. Since the Y coords   */
d793 5
a797 10
  e = _swix(Wimp_ForceRedraw,
            _INR(0,4),

            s.window_handle,
            s.visible_area.xmin,
            s.visible_area.ymin,
            s.visible_area.xmax,
            s.visible_area.ymax);

  return e;
a1096 2
/* Returns:    See parameters list.              */
/*                                               */
d1173 22
a1194 1
  sprintf(spr, "b%d", (bullet + bullets - 1) % bullets);
d1219 22
a1240 1
  sprintf(spr, "b%d", (bullet + bullets - 1) % bullets);
d1671 1
d1832 1
a1832 1
             "Serious internal error - There are no line structures defined in reformat_add_line_chunk(); must exit immediately.");
d1858 1
a1858 1
               "Serious internal error - No lines have associated chunks defined in reformat_add_line_chunk(); must exit immediately.");
a2581 10
  /* in actual fact table_stream * is a synonym for HStream * */
  /* when we hit a table -                                    */
  /* we call tables_count_table(),tables_position_table()     */
  /* then tables_width_table()                                */
  /* this will call back here to find some answers...         */
  /* in practice this now means that we need to do a reformat */
  /* of the HStream structure using a new nlines,ldata,cdata  */
  /* oh joy                                                   */
  /* stuff therefore is an array of nlines,ldata,cdata        */

a2590 15
//  /* Try to run the tokens through the fetcher so images etc. */
//  /* can work.                                                */
//
//  {
//    HStream * list = streambase;
//
//    while (list)
//    {
//      // !! THIS WON'T HANDLE FORMS CORRECTLY !! //
//
//      if (!(list->flags & HFlags_DealtWithToken)) fetch_preprocess_token(b, list);
//      list = list->next;
//    }
//  }

a2659 2
/*                                               */
/* Returns:    See parameters list.              */
a2681 15
//  /* Try to run the tokens through the fetcher so images etc. */
//  /* can work.                                                */
//
//  {
//    HStream * list = streambase;
//
//    while (list)
//    {
//      // !! THIS WON'T HANDLE FORMS CORRECTLY !! //
//
//      if (!(list->flags & HFlags_DealtWithToken)) fetch_preprocess_token(b, list);
//      list = list->next;
//    }
//  }

d2762 2
a2884 2

/*************************************************/
@


1.5
log
@Checking in mostly because its Friday... Quite a few little bug fixes
(adding up to a greater whole), which include removal of the dastardly
'invalid image number' errors that trace builds would raise from time to
time. Frame highlights are now better controlled (releaseably so).
Generally, this build represents the first genuinely promising version
of the browser for quite some time, despite the known library problems
with comment handling etc.
@
text
@d744 4
a747 3
  _kernel_oserror * e;
  int               temp, topline, bottomline;
  reformat_cell   * cell = b->cell;
d758 1
a758 1
  if (start > end) temp = start, start = end, end = temp;
a761 3
  topline    = cell->ldata[start].y + cell->ldata[start].h;
  bottomline = cell->ldata[end].y;

d764 1
a764 1
  for (temp = start; temp <= end; temp ++) cell->ldata[temp].y += y_shift;
d766 2
a767 1
  /* Handle redraw / shifting of the page with Wimp_BlockCopy */
d769 3
a771 7
  {
    WimpGetWindowStateBlock s;
    BBox                    work;

    s.window_handle = b->window_handle;
    e = wimp_get_window_state(&s);
    if (e) return e;
d773 1
a773 1
    coords_box_toworkarea(&s.visible_area,(WimpRedrawWindowBlock *) &s);
d775 2
a776 1
    work = s.visible_area;
d778 5
a782 1
    coords_box_toworkarea(&work,(WimpRedrawWindowBlock *) &s);
d784 1
a784 15
    e = _swix(Wimp_BlockCopy,
              _INR(0,6),

              s.window_handle,
              work.xmin,
              bottomline,
              work.xmax,
              topline,
              work.xmin,
              bottomline + y_shift);

    if (e) return e;
  }

  return reformat_check_extent(b);
d1209 4
a1212 1
  int offset = toolbars_button_height(b) + toolbars_url_height(b);
d1629 1
d1646 4
a1649 1
  y_extent -= (toolbars_status_height(b) + b->leading);
@


1.4
log
@Fixed problems with unsourced images in tables and a couple of other bugs
here and there - nothing earth shattering... Just wanted to keep the CVS
source up to date.
@
text
@d113 14
d128 1
a128 6
    if (b->last_token == b->finaltoken) return 0;

    /* If the last token dealt with had not been looked at */
    /* by the fetcher, the reformatter must have exitted.  */

    if (!(b->last_token->flags & HFlags_DealtWithToken)) return 0;
d132 2
a572 4
  /* Say the token is useless if it is part of the document */
  /* header. Otherwise say it is useful. The ISHEAD macro   */
  /* is defined in Fetch.h.                                 */

d2085 4
a2088 1
        while (tpCurr && reformat_useless_token(tpCurr))
d2100 11
a2110 22
//        if (
//             !tpCurr ||
//             (
//               tpCurr && !(tpCurr->flags & HFlags_DealtWithToken)
//             )
//           )
//
//           done = 1;
if (!tpCurr) done = 1;

        /* Otherwise, can proceed with processing this token. */

//        // If a tag consists of a single space and nothing more,
//        // and is a link, clear it's link status - this gets
//        // around the underscores before some images, and is a
//        // temporary fix until the HTML library spacing rules
//        // get sorted out.
//
//        if (tpCurr && reformat_istext(tpCurr) && tpCurr->text)
//        {
//          if (*tpCurr->text == 32 && !*(tpCurr->text + 1) && ISLINK(tpCurr)) tpCurr->style &= ~A;
//        }
d2363 1
d2449 1
a2449 3
    browser_data * ancestor = b->ancestor;

    if (!ancestor) ancestor = b;
@


1.3
log
@Made INPUT type=image work
@
text
@a80 1
static void              reformat_deal_with_queue (browser_data * b);
a85 1
// static _kernel_oserror * reformat_check_height   (browser_data * b, int line, HStream * tp, HStream * tpLast, int offset);
d356 1
a356 1
      w->width = (((box.xmax - box.xmin) * length * 2) / 3) + 16 * 400 + extra;
d425 1
a425 1
          goto do_image;
d433 1
a433 1
  do_image:
d825 1
a825 1
  /* Do we queue these requests? */
a829 49
//    reformat_queue * entry;
//
//    /* Add an entry to the reformat queue. If the malloc */
//    /* fails it's not catastrophic - could just get some */
//    /* redraw failures before the reformat takes place - */
//    /* so proceed (complain in TRACE builds to warn the  */
//    /* programmer, though).                              */
//
//    entry = malloc(sizeof(reformat_queue));
//
//    #ifdef TRACE
//
//      if (!entry)
//      {
//        erb.errnum = Utils_Error_Custom_Normal;
//
//        sprintf(erb.errmess,
//                "A malloc for a reformat_queue structure in reformat_format_from failed (browser %08x)",
//                (int) b);
//
//        show_error_ret(&erb);
//      }
//
//    #endif
//
//    if (entry)
//    {
//      #ifdef TRACE
//        malloccount += (sizeof(reformat_queue));
//        if (tl & (1u<<13)) Printf("** malloccount: %d\n",malloccount);
//      #endif
//
//      /* Link the item into the list and fill in the rest of the contents */
//
//      entry->next        = b->refo_queue_base;
//      b->refo_queue_base = entry;
//
//      entry->line  = lastline;
//      entry->image = image;
//    }
//    else
//    {
//      /* If the allocation failed, we do want to mark the image as redrawable */
//      /* or it could stay hidden; rather have low memory redraw errors which  */
//      /* eventually get corrected by a reformat, than hide stuff altogether.  */
//
//      if (image >= 0) image_mark_as_redrawable(b, image);
//    }

d882 1
a882 1
    handle->refotime = 1; /* So that reformat_free_queue will deregister this handler */
d884 1
a884 1
    reformat_free_queue(handle);
a908 40
/* reformat_deal_with_queue()                    */
/*                                               */
/* Deals with the contents of the reformat_queue */
/* list prior to reformatting the page.          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the queue.            */
/*************************************************/

static void reformat_deal_with_queue(browser_data * b)
{
//  reformat_queue * entry = b->refo_queue_base;
//  reformat_queue * next;
//
//  /* At present, only interested in the image numbers */
//
//  while (entry)
//  {
//    next = entry->next;
//
//    /* About to reformat for the image, so mark that it can now be redrawn */
//
//    if (entry->image >= 0) image_mark_as_redrawable(b, entry->image);
//
//    /* Free this item and move onto the next one in the queue */
//
//    #ifdef TRACE
//      malloccount -= (sizeof(reformat_queue));
//      if (tl & (1u<<13)) Printf("** malloccount: %d\n",malloccount);
//    #endif
//
//    free(entry);
//
//    entry = next;
//  }

  b->refo_queue_base = NULL;
}

/*************************************************/
a942 2

    reformat_deal_with_queue(b);
d1060 1
a1060 1
/* reformat_free_queue()                         */
d1062 2
a1063 2
/* Frees any reformat_queue structures in a list */
/* associated with a given browser.              */
d1069 1
a1069 1
void reformat_free_queue(browser_data * b)
a1070 3
//  reformat_queue * entry = b->refo_queue_base;
//  reformat_queue * next;

a1074 16

//  while (entry)
//  {
//    next = entry->next;
//
//    #ifdef TRACE
//      malloccount -= (sizeof(reformat_queue));
//      if (tl & (1u<<13)) Printf("** malloccount: %d\n",malloccount);
//    #endif
//
//    free(entry);
//
//    entry = next;
//  }

  b->refo_queue_base = NULL;
d1086 1
d1100 3
a1102 1
  imgalign          al;
d1107 3
a1109 1
  if (tp->style & IMG)
d1111 3
a1113 6
    if ((tp->type & TYPE_ALIGN_MASK) == TYPE_MIDDLE)
      al = imgalign_MIDDLE;
    else if ((tp->type & TYPE_ALIGN_MASK) == TYPE_TOP)
      al = imgalign_TOP;
    else
      al = imgalign_NONE;
d1115 1
a1115 2
  else
    al = HtmlINPUTalign(tp);
d1117 1
a1117 1
  switch (al)
d1120 1
d1123 2
a1124 1
      break;
d1127 1
d1130 2
a1131 1
      break;
d1267 7
a1273 2
  if ((tp->style & IMG) ||
      (tp->style & INPUT) && HtmlINPUTtype(tp) == inputtype_IMAGE)
d2556 14
a2569 17
  /* Try to run the tokens through the fetcher so images etc. */
  /* can work.                                                */

  {
    HStream * oldfinal = b->finaltoken; /* Must preserve this */
    HStream * list     = streambase;

    while (list)
    {
      // !! THIS WON'T HANDLE FORMS CORRECTLY !! //

      if (!(list->flags & HFlags_DealtWithToken)) fetch_preprocess_token(b, list);
      list = list->next;
    }

    b->finaltoken = oldfinal; /* Restore old finaltoken value */
  }
d2664 14
a2677 17
  /* Try to run the tokens through the fetcher so images etc. */
  /* can work.                                                */

  {
    HStream * oldfinal = b->finaltoken; /* Must preserve this */
    HStream * list     = streambase;

    while (list)
    {
      // !! THIS WON'T HANDLE FORMS CORRECTLY !! //

      if (!(list->flags & HFlags_DealtWithToken)) fetch_preprocess_token(b, list);
      list = list->next;
    }

    b->finaltoken = oldfinal; /* Restore old finaltoken value */
  }
@


1.2
log
@Customer work complete, and this version just shipped. Had to comment out
the code in Main.c that sets the user agent string to fake Netscape, as the
persistent problems with forms in tables showed up much more on a modem
link - net result was that the customer's log in page didn't work. Not
faking Netscape gives an authorisation dialogue instead, allowing access
to the site even if not by the most elegant of methods.
@
text
@d165 2
a166 1
  return (((tp->style) & (IMG | HR)) == 0);
d198 1
d286 4
a289 4
    if (
         (w->tp->type  & TYPE_RESET) == TYPE_TEXT ||
         (w->tp->type  & TYPE_RESET) == TYPE_PASSWORD ||
         (w->tp->style & (TEXTAREA | SELECT))
a291 1
      BBox box;
d318 1
a318 1
        p = w->tp->value + 8;
d334 1
a334 1
        length = w->tp->size;
d365 1
a365 1
    else switch(w->tp->type & TYPE_RESET)
d367 2
a368 2
      case TYPE_SUBMIT: /*; no break - same as RESET */
      case TYPE_RESET:
d370 1
a370 1
        char * p;
d399 1
a399 1
      case TYPE_CHECKBOX:
d409 1
a409 1
      case TYPE_RADIO:
d419 1
a419 2
      case TYPE_IMAGE:
      case TYPE_HIDDEN:
d424 6
d434 2
a435 1
    BBox box;
d1211 1
d1216 1
a1216 1
  if ((tp->type & TYPE_ALIGN_MASK) == TYPE_MIDDLE)
d1218 6
a1223 2
    box->ymin -= box->ymax / 2;
    box->ymax /= 2;
d1225 2
d1228 1
a1228 1
  if ((tp->type & TYPE_ALIGN_MASK) == TYPE_TOP)
d1230 9
a1238 2
    box->ymin =- box->ymax;
    box->ymax = 0;
d1245 1
a1245 1
  if (ISLINK(tp))
d1374 2
a1375 1
  if (tp->style & IMG)
d1419 1
a1419 1
  else if ((tp->style & INPUT) && (tp->type & TYPE_RESET) == TYPE_CHECKBOX)
d1426 1
a1426 1
  else if ((tp->style & INPUT) && (tp->type & TYPE_RESET) == TYPE_RADIO)
d1610 1
a1610 1
    switch(tp->type & TYPE_RESET)
d1612 2
a1613 2
      case TYPE_TEXT: /* No break - same as PASSWORD */
      case TYPE_PASSWORD:
d1617 2
a1618 2
      case TYPE_SUBMIT: /* No break - same as RESET */
      case TYPE_RESET:
d2455 3
a2457 1
            if (tpCurr->style & IMG) image_set_token_image_position(b, tpCurr, -1, -1);
d2909 1
a2909 1
  else if (tp && tp->text && (tp->style & IMG))
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d357 1
a357 1
      w->width = (box.xmax - box.xmin) * length + 16*400 + extra;
d1302 2
d1306 5
a1310 1
  return -(toolbars_button_height(b) + toolbars_url_height(b) + b->leading + 4);
@

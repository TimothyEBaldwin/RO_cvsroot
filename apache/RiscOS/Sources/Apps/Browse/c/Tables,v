head	1.22;
access;
symbols
	Browse-2_16:1.22
	Browse-2_15:1.22
	Browse-2_14:1.22
	Browse-2_13:1.22
	Browse-2_12:1.22
	Browse-2_11:1.21
	Browse-2_10:1.21
	Browse-2_09:1.21
	ahodgkin_208_i4_2:1.20
	ahodgkin_208_i4:1.18
	ahodgkin_208_i3:1.18
	ahodgkin_208_i2:1.18
	ahodgkin_208_i1:1.18
	ahodgkin_207release:1.17
	ahodgkin_206release:1.17
	ahodgkin_205release:1.17
	ahodgkin_204release:1.16
	ahodgkin_202release:1.15
	ahodgkin_201release:1.15
	ahodgkin_200release:1.15
	ahodgkin_133beta:1.15
	ahodgkin_132beta:1.14
	ahodgkin_131beta:1.13
	ahodgkin_130beta:1.12
	ahodgkin_129:1.12
	ahodgkin_128beta:1.12
	ahodgkin_128alpha:1.11
	ahodgkin_127beta2:1.9
	ahodgkin_127beta:1.9
	ahodgkin_126beta:1.8
	ahodgkin_AW97patch:1.8
	ahodgkin_AW97:1.5;
locks; strict;
comment	@# @;


1.22
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.26.09.42.35;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.14.08.45.08;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.31.15.58.48;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	99.03.30.15.52.04;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	98.04.21.10.38.18;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	98.04.16.08.14.24;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	98.02.13.17.32.28;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	98.02.06.13.55.27;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	98.01.31.10.55.35;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.12.04.11.23.11;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.12.02.16.14.03;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.11.27.17.50.09;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.11.19.10.29.13;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.10.22.13.16.00;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.10.20.07.09.23;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.10.18.16.42.30;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.18.26;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.09.18.08.59.03;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.08.31.18.38.22;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.08.18.09.24.05;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.29.01;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.22
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Tables.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Table handling functions.                         */
/*                                                            */
/* Author:  Tony Cheal, adapted by A.D.Hodgkinson.            */
/*                                                            */
/* History: 18-Mar-1997 (ADH): Code received from T.Cheal.    */
/*          12-Apr-1997 (ADH): Tidied up, more comments, and  */
/*                             from here on continued         */
/*                             development of code content.   */
/*          18-Jun-1997 (ADH): Moved several functions that   */
/*                             were in the reformatter here,  */
/*                             as this is a more appropriate  */
/*                             location.                      */
/*          23-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>
#include <tboxlibs/flex.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>

#include "Global.h"
#include "FromROSLib.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Memory.h"
#include "Redraw.h"
#include "Reformat.h"
#include "TokenUtils.h"
#include "Toolbars.h"

#include "Tables.h"

/* Local definitions */

#define Tables_Hourglass_WidthingTableDelay 100
#define Tables_Hourglass_FreeingTablesDelay 25

#define CorrectRowSpan(D,p) ((D)->RowSpan > (p)->RowSpan ? (p)->RowSpan : (D)->RowSpan)
#define CorrectColSpan(D,p) ((D)->ColSpan > (p)->ColSpan ? (p)->ColSpan : (D)->ColSpan)

/* Statics */

static int width_table_leds = 1;

/* Static function prototypes */

static void tables_find_actual_size (table_stream * p, int * actual_colspan, int * actual_rowspan);
static void tables_align_contents   (browser_data * b, HStream * streambase, table_stream * table, reformat_cell * cellarray, int Row, int Column);

/**************************************************************/
/* tables_count_table()                                       */
/*                                                            */
/* Works out the number of rows and columns in a given table, */
/* and writes back into the given table_stream structure      */
/* these values plus pointers to two allocated blocks of      */
/* memory that can hold one integer for each row and column.  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct, which is the */
/*             parent of the table;                           */
/*                                                            */
/*             Pointer to a table_stream struct relevant to   */
/*             the table.                                     */
/*                                                            */
/* Returns:    Writes to the given table_stream struct, so    */
/*             this must not be in a read only area. The      */
/*             ColSpan and RowSpan fields are filled in with  */
/*             the number of columns and rows respectively,   */
/*             and the ColOffs and RowOffs fields are filled  */
/*             with the pointers to the arrays of Cols and    */
/*             Rows ints, respectively.                       */
/**************************************************************/

void tables_count_table(browser_data * b, table_stream * p)
{
  table_row      * R;
  table_headdata * D;
  int              I;
  int            * RowSpill;
  int              ColCount, RowCount;
  int              Cols,     Rows;

  /* Avoid compiler warning - b may be used in later revisions of this code */

  (void) b;

  dprintf(("Tabl", "\ntables_count_table: Called with &%08X\n",(int) P));

  /* How many rows are there? 'Rows' will keep count of the current row */
  /* number according to the table structure, 'RowCount' will represent */
  /* a maximum value of the current row number, plus any defined        */
  /* rowspan value for the cell.                                        */

  Rows     = 0;
  RowCount = 0;
  R        = p->List;

  while (R)
  {
    D = R->List;

    if (!D)
    {
      if (Rows + 1 > RowCount) RowCount = Rows + 1;
    }
    else
    {
      while (D)
      {
        switch (D->Tag)
        {
          case TagTableData:
          case TagTableHead:
          {
            int this_count;

            if (D->RowSpan > 1) this_count = Rows + D->RowSpan;
            else                this_count = Rows + 1;

            if (this_count > RowCount) RowCount = this_count;
          }
          break;
        }

        D = D->Next;
      }
    }

    Rows ++;

    R = R->Next;
  }

  /* The RowSpill array is used to hold the number of columns */
  /* defined in other rows, when a cell 'spills' onto those   */
  /* other rows by having a rowspan value specified for it.   */
  /*                                                          */
  /* When scanning rows that a cell above has spilled into,   */
  /* the table structures themselves will skip over that      */
  /* column - as a cell above that row has already defined    */
  /* contents here. To be able to work out how many actual    */
  /* columns there are, then, need to fill this array with    */
  /* the number of columns any such cells span.               */
  /*                                                          */
  /* If not clear already, hopefully it'll become more so in  */
  /* the code later which actually deals with the array.      */

  RowSpill = (int *) memory_alloc_and_set(RowCount * (sizeof(int)), 0);

  /* If allocation fails, report the error and jump out to */
  /* polling - can't possibly continue here.               */

  if (!RowSpill) show_error_cont(make_no_table_memory_error(1));

  /* Now restart the process starting the */
  /* column count as the total of all row */
  /* spillage to date.                    */

  Rows = 0;
  Cols = 0;
  R    = p->List;

  /* Move through all rows */

  while (R)
  {
    dprintf(("Tabl", "tables_count_table: Row &%08X\n",(int) R));

    ColCount = RowSpill[Rows];
    D        = R->List;

    /* Move through all columns in the current row */

    while (D)
    {
      dprintf(("Tabl", "tables_count_table: HeadData &%08X\n",(int) D));

      switch (D->Tag)
      {
        /* Items which if present, define a column */

        case TagTableData:
        case TagTableHead:
        {
          if (D->ColSpan) ColCount += D->ColSpan;
          else            ColCount ++;

          /* If this column is meant to span several rows, */
          /* fill in the RowSpill arrays for all the rows  */
          /* it spans (except the current one) with the    */
          /* number of columns this tag defines. So when   */
          /* we get to those rows, they'll already have    */
          /* some columns counted in from previous columns */
          /* which had a rowspan specified.                */

          if (D->RowSpan > 1)
          {
            int index;

            for (I = 1; I < D->RowSpan; I++)
            {
              index = Rows + I;

              if (index < RowCount) /* Stupidity check */
              {
                if (D->ColSpan) RowSpill[index] += D->ColSpan;
                else            RowSpill[index] ++;
              }
            }
          }
        }
        break;
      }

      D = D->Next;
    }

    /* Keep Cols up to date as the highest column count */
    /* encountered so far, and move to the next row.    */

    if (Cols < ColCount) Cols = ColCount;

    Rows ++;

    R = R->Next;
  }

  /* Free the temporary rowspill array */

  free(RowSpill);

  dprintf(("Tabl", "tables_count_table: Rows, Cols = %d, %d\n", RowCount, Cols));

  /* Fill in the table_stream structure with the number of rows */
  /* and columns, and pointers to two allocated blocks of Rows  */
  /* and Cols integers.                                         */
  /*                                                            */
  /* Note that if a table cell specifies colspans or rowspans   */
  /* that extend into rows or columns that would otherwise not  */
  /* be defined anywhere, these extra rows/cols will **NOT** be */
  /* included in the count here. This is why loops dealing with */
  /* such values *must* be very careful not to run off the end  */
  /* of arrays and suchlike!                                    */

  p->ColSpan = Cols;
  p->RowSpan = RowCount;

  /* May be reformatting the table, in which case there will already */
  /* be arrays attached to p.                                        */

  if (p->ColOffs)
  {
    HtmlFree(p->ColOffs);
    p->ColOffs = NULL;
  }

  if (p->RowOffs)
  {
    HtmlFree(p->RowOffs);
    p->RowOffs = NULL;
  }

  /* Now allocate the array, in the context of the HStream list.   */
  /* When the list is eventually discarded this will automatically */
  /* be discard too.                                               */

  if (p->ColSpan)
  {
    if (p->ColSpan) p->ColOffs = HtmlMalloc(p->ColSpan * sizeof(int), p);
    if (!p->ColOffs) show_error_cont(make_no_table_memory_error(10));
  }

  if (p->RowSpan)
  {
    p->RowOffs = HtmlMalloc(p->RowSpan * sizeof(int), p);
    if (!p->RowOffs) show_error_cont(make_no_table_memory_error(11));
  }

  return;
}

/**************************************************************/
/* tables_position_table()                                    */
/*                                                            */
/* Fills in the RowOffs and ColOffs fields for the given      */
/* table and all cells in a given table, taking account of    */
/* multiple row and column spanning. These are integers       */
/* which, for a given cell, give the number of rows and       */
/* columns from the top left of the table (starting at (0,    */
/* 0)) that the cell is offset by.                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct, which is the */
/*             parent of the table;                           */
/*                                                            */
/*             Pointer to a table_stream struct relevant to   */
/*             the table.                                     */
/**************************************************************/

void tables_position_table(browser_data * b, table_stream * p)
{
  table_row      * R;
  table_headdata * D;
  int              Cols, Rows, ColCount;
  int            * ColOffs;
  int            * RowOffs;
  unsigned char  * RowSpill;

  if (!p->ColSpan || !p->RowSpan) return;

  /* Avoid compiler warning - b may be used in later revisions of this code */

  (void) b;

  dprintf(("Tabl", "tables_position_table: Called with &%08X\n",(int) P));

  Rows     = 0;
  RowSpill = (unsigned char *) memory_alloc_and_set(p->ColSpan * p->RowSpan, 0); /* Enough for all rows & cols */
  ColCount = p->ColSpan;
  ColOffs  = p->ColOffs;
  RowOffs  = p->RowOffs;

  /* If allocation fails, report the error and jump out to */
  /* polling - can't possibly continue here.               */

  if (!RowSpill) show_error_cont(make_no_table_memory_error(2));

  R = p->List;

  /* Loop through all rows */

  while (R && Rows < p->RowSpan)
  {
    Cols = 0;

    /* Look through the RowSpill array for this row, skipping */
    /* any columns which have already been done - marked by a */
    /* non-zero value in the array.                           */

    while (RowSpill[Rows * ColCount + Cols]) Cols++;

    /* Cols now points at a column that hasn't been positioned yet. */

    if (R->Width)
    {
      if (ColOffs[Cols] < R->Width) ColOffs[Cols] = R->Width;
    }

    D = R->List;

    /* Loop through all columns pointed to by this row */

    while (D && Cols < ColCount)
    {
      int C, R, I, J;

      switch (D->Tag)
      {
        case TagTableData:
        case TagTableHead:
        {
          dprintf(("Tabl", "tables_position_table: In scan, D (&%08X) RowOffs = %d, ColOffs = %d\n", (int) D, Rows, Cols));

          D->ColOffs = Cols;
          D->RowOffs = Rows; /* This is where this cell is, honest */

          if (D->ColSpan) C = CorrectColSpan(D, p);
          else            C = 1;

          if (D->RowSpan) R = CorrectRowSpan(D, p);
          else            R = 1;

          /* Loops contain a stupidity check... */

          for (I = Cols; I <= Cols + C - 1; I++)
          {
            for (J = Rows; J <= Rows + R - 1; J++)
            {
              /* For all columns and rows that this cell covers, mark that these */
              /* have been dealt with in the RowSpill array.                     */

              if (I < p->ColSpan && J < p->RowSpan) RowSpill[J * ColCount + I] = 0xff;
            }
          }
          Cols += C;

          /* Ensure that Cols is advanced appropriately to get past */
          /* anything marked as dealt with by the above code.       */

          while (RowSpill[Rows * ColCount + Cols]) Cols++;
        }
        break;
      }

      D = D->Next;
    }

    Rows ++;

    R = R->Next;
  }

  /* Free up the temporary array and exit */

  free(RowSpill);
}

/**************************************************************/
/* tables_init_table()                                        */
/*                                                            */
/* For a new, uninitialised array of reformat_cell            */
/* structures, fills in any initial information prior to      */
/* sizing and positioning (as in, coordinate origins) of the  */
/* cells.                                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the tables;                                    */
/*                                                            */
/*             Pointer to the table_stream struct             */
/*             representing the table;                        */
/*                                                            */
/*             Pointer to the cell array.                     */
/*                                                            */
/* Assumes:    At least tables_count_table must have been     */
/*             called to work out how many rows and columns   */
/*             there are.                                     */
/**************************************************************/

void tables_init_table(browser_data * b, table_stream * table, reformat_cell * cellarray)
{
  int i, size;

  size = table->ColSpan * table->RowSpan;

  if (!size) return;

  memset(&cellarray[0], 0, sizeof(reformat_cell) * size);

  for (i = 0; i < size; i++)
  {
    cellarray[i].table  = table;
    cellarray[i].minwid = -1;
    cellarray[i].maxwid = -1;
  }

  return;
}

/**************************************************************/
/* tables_find_actual_size()                                  */
/*                                                            */
/* Find the number of actual used rows and cols in a table,   */
/* ignoring whatever colspan and rowspan attributes might     */
/* say.                                                       */
/*                                                            */
/* Expects each cell's RowOffs and ColOffs fields to hold the */
/* row/column offset of that cell within the table            */
/* (tables_position_table must have been called beforehand).  */
/*                                                            */
/* Parameters: Pointer to a table_stream struct for the       */
/*             table;                                         */
/*                                                            */
/*             Pointer to an int, in which the number of      */
/*             columns is written;                            */
/*                                                            */
/*             Pointer to an int, in which the number of rows */
/*             is written.                                    */
/*                                                            */
/* Assumes:    The int pointers may be NULL.                  */
/**************************************************************/

static void tables_find_actual_size(table_stream * p, int * actual_colspan, int * actual_rowspan)
{
  table_row      * R;
  table_headdata * D;
  int              cellmax = p->ColSpan * p->RowSpan;
  int              cs      = 0;
  int              rs      = 0;;

  if (cellmax)
  {
    R = p->List;

    while (R)
    {
      int row, col;

      D = R->List;

      while (D && D->ColOffs < p->ColSpan)
      {
        col = D->ColOffs;
        row = D->RowOffs;

        switch (D->Tag)
        {
          case TagTableData:
          case TagTableHead:
          {
            int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;

            if (cellnumber < cellmax && col < p->ColSpan)
            {
              if (col + 1 > cs) cs = col + 1;
              if (row + 1 > rs) rs = row + 1;
            }
          }
        }

        D = D->Next;
      }

      R = R->Next;
    }
  }

  if (actual_colspan) *actual_colspan = cs;
  if (actual_rowspan) *actual_rowspan = rs;

  return;
}

/**************************************************************/
/* tables_width_table()                                       */
/*                                                            */
/* Works out the widths in millipoints for all cells in a     */
/* given table. This is called by the reformatter routines as */
/* they try to find the width of various page elements. To    */
/* find out the width of, and finally format a particular     */
/* cell, this function then itself calls the reformatter.     */
/* This can of course then call back here for nested tables - */
/* i.e. this is a recursive function, though it's not         */
/* immediately obvious as the callers and callees are spread  */
/* over a wide area of code.                                  */
/*                                                            */
/* Because of the way tables define column widths, for each   */
/* cell three reformats take place - minimum width find,      */
/* maximum width find, and final decided width.               */
/*                                                            */
/* Coupled with all the juggling of those maxs and mins -     */
/* taking into account anything that was specified in the     */
/* HTML - this is something of a monster function and it is   */
/* certainly not efficient at present. Hopefully this will    */
/* improve in a future interation of the tables code...       */
/*                                                            */
/* Parameters: 1 for a top level call, else 0 if being called */
/*             as part of a nested tables reformat session;   */
/*                                                            */
/*             Pointer to a browser_data struct, which is the */
/*             parent of the table;                           */
/*                                                            */
/*             Pointer to a table_stream struct relevant to   */
/*             the table;                                     */
/*                                                            */
/*             The available width for the table in           */
/*             millipoints;                                   */
/*                                                            */
/*             Pointer to an array of points to reformat_cell */
/*             structures which will hold the final table     */
/*             layout;                                        */
/*                                                            */
/*             Flags as for reformat_token_width - needed as  */
/*             the widthing routines need to know if the      */
/*             widest a table can be is being found or not    */
/*             (for nested tables - avoids nested tables      */
/*             saying they're 100% wide, say, ending up       */
/*             huge).                                         */
/*                                                            */
/* Returns:    The table width, in millipoints.               */
/**************************************************************/

int tables_width_table(int toplevel, browser_data * b, table_stream * p,
                       int available_width, reformat_cell * cellarray, unsigned int flags)
{
  table_row       * R;
  table_headdata  * D;
  int               I;
  int             * ColOffs;
  int               finding_widest;

  int               cellmax  = p->ColSpan * p->RowSpan;
  int               rowcount = 0;

  int               real_width,      new_width;
  int               min_table_width, max_table_width;
  int               display_width;

  int             * mins,       * maxs;
  int             * overmins,   * overmaxs;
  int             * pcwidths;
  table_headdata ** usedcells;

  int               have_colspans = 0;
  int               have_percents = 0;
  int               have_pixels   = 0;

  int               have_checked  = 0;
  int               subtract      = 0;

  int               cellspacingos = p->cellspacing * 2; /* 1 'web pixel' = 2 OS units */
  int               cellspacingmp;

  int               tbordmp;

  dprintf(("Tabl", "tables_width_table: Called, P = &%08X, available width %d (%d OS), cell array = &%08X\n", (int) P, available_width, available_width / 400, (int) cellarray));

  if (!cellmax) return 1600;

  convert_to_points(cellspacingos, &cellspacingmp);
  convert_to_points(TABLE_BORDER(p) * 2, &tbordmp); /* 1 'web pixel' = 2 OS units */

  /* We may need the browser page width available in millipoints quite */
  /* frequently, so do the conversion just the once for speed.         */

  convert_to_points(b->display_width, &display_width);

  /* If we've been given a very large value for available_width, we're */
  /* trying to find the widest a table can be.                         */
  /*                                                                   */
  /* If 'finding_widest' is 2, the available_width field is valid even */
  /* though we're finding the greatest width because the table gave an */
  /* absolute width in pixels.                                         */

  if (flags & Reformatter_FindingWidest) finding_widest = 1;
  else                                   finding_widest = 0;

  /* Deal with specific non-zero table widths */

  if (TABLE_HAS_WIDTH(p) && TABLE_WIDTH(p))
  {
    int width = 0, dx;

    switch (TABLE_WIDTH_UNITS(p))
    {
      default:
      case UNITS_PIXELS:
      {
        convert_to_points(wimpt_dx(), &dx);
        width = TABLE_WIDTH(p) * dx;

        if (finding_widest) finding_widest = 2;
      }
      break;

      case UNITS_PERCENT:
      {
        /* We may be finding the widest the table can be, and if so we shouldn't */
        /* try to calculate the percentage as this will give a coordinate        */
        /* overflow.                                                             */

        if (!finding_widest) width = (TABLE_WIDTH(p) * available_width) / 100;
      }
      break;
    }

    if (width) available_width = width;
  }

  /* Allocate various arrays. */

  /* First, two arrays of ints to hold the minimum and */
  /* maximum widths of the table's cells.              */

  maxs = (int *) memory_alloc_and_set(sizeof(int) * cellmax, 0);

  if (!maxs)
  {
    show_error_ret(make_no_table_memory_error(3));

    return 0;
  }

  mins = (int *) memory_alloc_and_set(sizeof(int) * cellmax, 0);

  if (!mins)
  {
    free(maxs);

    show_error_ret(make_no_table_memory_error(4));

    return 0;
  }

  /* Allocate arrays to hold min and max widths of columns */
  /* worked out overall.                                   */

  overmaxs = (int *) memory_alloc_and_set(sizeof(int) * p->ColSpan, 0);

  if (!overmaxs)
  {
    free(mins);
    free(maxs);

    show_error_ret(make_no_table_memory_error(5));

    return 0;
  }

  overmins = (int *) memory_alloc_and_set(sizeof(int) * p->ColSpan, 0);

  if (!overmins)
  {
    free(overmaxs);
    free(mins);
    free(maxs);

    show_error_ret(make_no_table_memory_error(6));

    return 0;
  }

  /* Array to hold the stated or inferred percentage widths of cells */

  pcwidths = (int *) memory_alloc_and_set(sizeof(int) * cellmax, 0);

  if (!pcwidths)
  {
    free(overmins);
    free(overmaxs);
    free(mins);
    free(maxs);

    show_error_ret(make_no_table_memory_error(7));

    return 0;
  }

  /* Array to hold addresses of the cells used to decide the overall */
  /* column widths - the attributes the HTML uses to define these    */
  /* cells can alter the final stage table widthing. The first 'row' */
  /* of the array is used for the addresses of min values, the       */
  /* second for addresses of max values.                             */

  usedcells = (table_headdata **) memory_alloc_and_set(sizeof(table_headdata *) * p->ColSpan * 2, 0);

  if (!usedcells)
  {
    free(pcwidths);
    free(overmins);
    free(overmaxs);
    free(mins);
    free(maxs);

    show_error_ret(make_no_table_memory_error(7));

    return 0;
  }

  /* Decrease available width according to cell spacing constraints    */
  /* and account for the overall table border.                         */

  subtract = tbordmp * 2;

  if (!choices.msie4_style_tables)
  {
    /* First case - Navigator / Browse behaviour. Here, we just subtract */
    /* spacing for enough columns as there appear to be. However, if     */
    /* there is a large colspan cell which effectively 'drops off' the   */
    /* right hand edge of the notionally used cells, we could end up     */
    /* with excess space allocated on the edge of the table:             */
    /*                                                                   */
    /* +===============================================================+ */
    /* H                                                               H */
    /* H +-----------------------------------------------------------+ H */
    /* H | Cell with colspan value of, say, 7                        | H */
    /* H +-----------------------------------------------------------+ H */
    /* H                                                               H */
    /* H +--------+ +--------+ +--------+ +--------+ +--------+        H */
    /* H | There  | | only   | | actual | | really | | use... | Gap at H */
    /* H | are    | | five   | | cells  | | in     | | So --> | right  H */
    /* H |        | |        | |        | |        | |        | edge.  H */
    /* H +--------+ +--------+ +--------+ +--------+ +--------+        H */
    /* H                                                               H */
    /* +===============================================================+ */

    subtract += cellspacingmp * (p->ColSpan + 1);
  }
  else
  {
    int number_used;

    /* Second case - MSIE 4 style behaviour. Here, MSIE seems to count   */
    /* up and see which cells are actually in use, and only account for  */
    /* spacing between them. This eliminates the spurious gap at the     */
    /* right hand edge as above.                                         */
    /*                                                                   */
    /* Whilst choices.msie4_style_tables is generally only used to       */
    /* switch on daft features for compatibility's sake, this seems at   */
    /* first glance a sensible thing to have. However, the feature hides */
    /* an error in the HTML - the top cell had too big a colspan value.  */
    /* So really, to write better HTML, it's more sensible to not have   */
    /* the browser hide such an error.                                   */

    tables_find_actual_size(p, &number_used, NULL);

    if (number_used) subtract += cellspacingmp * (number_used + 1);
  }

  /* Subtract the value from available_width, if the latter is a */
  /* valid constraint (i.e. we're not trying to find the widest  */
  /* the table can be).                                          */

  if (finding_widest != 1)
  {
    available_width -= subtract;
  }

  if (controls.table_multi == 0)
  {
    /* This can get s l o w... */

    _swix(Hourglass_Start,
          _IN(0),

          Tables_Hourglass_WidthingTableDelay);
  }

  /* Treat the p->ColOffs field as an array of millipoint offsets */
  /* from the left of the table for each column.                  */

  ColOffs = p->ColOffs;

  /* First pass - find min and max widths of the columns. */

  R = p->List; /* p is a table_stream, so R now points to the first table_row */

  while (R && rowcount < p->RowSpan)
  {
    /* Preliminaries */

    int row_pc_total;

    dprintf(("Tabl", "tables_width_table: Row struct &%08X\n",(int) R));

    /* This is used to keep track of the total of */
    /* width specifiers in the row                */

    row_pc_total  = 0;
    have_percents = 0;
    have_pixels   = 0;

    if (controls.table_multi == 0)
    {
      /* Flick the LEDs around a bit to show progress. Not much point */
      /* trying to do %s because of nested tables.                    */

      _swix(Hourglass_LEDs,
            _INR(0,1),

            3,
            width_table_leds);

      width_table_leds ^= 3;
    }

    /* R is a table_row, so D now points to a table_headdata */

    D = R->List;

    while (D && D->ColOffs < p->ColSpan)
    {
      dprintf(("Tabl", "tables_width_table: Head struct &%08X, tag &%08X\n",(int) D,(int) D->Tag));

      switch (D->Tag)
      {
        case TagTableData:
        case TagTableHead:
        {
          int width      = -1;
          int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;

          if (cellnumber < cellmax)
          {
            /* First stage of dealing with specific cell widths, and find cell size limits from reformatter */

            dprintf(("Tabl", "tables_width_table: Dealing with column tag &%08X\n",(int) D->Tag));

            /* Need a fair bit of extra work if there are any */
            /* column spanning cells, but can avoid another   */
            /* scan of the table if we flag whether or not    */
            /* there are any present.                         */

            if (D->ColSpan > 1) have_colspans = 1;

            /* This cell starts with no actual or implied percentage */
            /* sizespecifier                                         */

            pcwidths[cellnumber] = -1;

            /* Does the cell specify a width? */

            if (TD_HAS_WIDTH(D))
            {
              switch (TD_WIDTH_UNITS(D))
              {
                default:
                case UNITS_PIXELS:
                {
                  int dx;

                  have_pixels ++;

                  convert_to_points(wimpt_dx(), &dx); /* Millipoints per pixel in dx */

                  width = TD_WIDTH(D) * dx;
                }
                break;

                /* Don't allow percentage specifiers on a row to exceed 100 */

                case UNITS_PERCENT:
                {
                  have_percents ++;

                  if (row_pc_total == 100)                   pcwidths[cellnumber] = 0;
                  else if (TD_WIDTH(D) + row_pc_total > 100) pcwidths[cellnumber] = 100 - row_pc_total, row_pc_total  = 100;
                  else                                       pcwidths[cellnumber] = TD_WIDTH(D),        row_pc_total += TD_WIDTH(D);
                }
                break;
              }

// Um... Improvements to other widthing code mean this doesn't seem to be
// needed anymore. It was only causing problems in fact.
//
//              if (finding_widest != 1)
//              {
//                /* Deal with garbage like 'TD WIDTH="2000"' - if a cell */
//                /* wants to be wider than the table can be, ignore it   */
//                /* completely.                                          */
//
//                if (width > available_width) width = -1;
//              }
//              else
//              {
//                /* Because this is a scan to find the widest limit of a table, */
//                /* we can't use available_width to limit the item; so instead  */
//                /* use the browser's display width as a second best option.    */
//
//                if (width > display_width) width = -1;
//              }
            }

            /* Unfortunately, still need to find the minimum size. So bang */
            /* goes any possible speed up from knowing it in advance. If   */
            /* only web page designers could count...                      */

            reformat_find_cell_limits(toplevel,
                                      b,
                                      (HStream *) D->List,
                                      p,
                                      cellarray,
                                      D->RowOffs,
                                      D->ColOffs,
                                      &mins[cellnumber],
                                      &maxs[cellnumber]);

            /* If the table cell specified a particular width, and it's */
            /* greater than the minimum width size, then the maximum    */
            /* cell size should be considered as the given width value. */
            /* Otherwise, the maximum size should be as close as        */
            /* possible - i.e., the same as the minimum size.           */
            /*                                                          */
            /* This is so that table cells containing, say, a column of */
            /* images, work - if there are no BRs between the images,   */
            /* then the max width is large. But we shouldn't let the    */
            /* cell get wider than its specified width (if it has one), */
            /* or images that are meant to be in a column could appear  */
            /* side by side.                                            */

            if (width >= 0)
            {
              if (width > mins[cellnumber]) maxs[cellnumber] = width;
              else                          maxs[cellnumber] = mins[cellnumber]; /* (Keep it is small as possible) */
            }

          /* Closure of 'if (cellnumber < cellmax)' */
          }
        }
        break;

      /* Closure of 'switch (D->Tag)' */
      }

      D = D->Next;

    /* Closure of 'while (D && ...)' */
    }

    /* Right, we've done that row, marking out any cells which had */
    /* percentage specifiers (and cropping values where the total  */
    /* exceeds 100%). If there were any % specifiers on the row,   */
    /* we need to width them and deal with any effects this has on */
    /* other cells in the row.                                     */

    if (have_percents > 0) /* have_percents holds the number of % specified cells */
    {
      int min_pc       = 100;
      int explicit_pc  = 0;
      int pc_size      = 0;
      int max_row      = 0;
      int min_row      = 0;
      int do_inference = 0;

      /* If the whole row contains % cells, MSIE / NN seem to find the smallest */
      /* non-zero % specifier in the row. If there is more than one cell with   */
      /* this specifier, find the one with the greatest max size value. The     */
      /* width of the chosen cell, coupled with the percentage width specifier  */
      /* on the cell, gives you the width of 1% by division. The other cells    */
      /* can thus be widthed.                                                   */
      /*                                                                        */
      /* If the row has some unspecified cells, these acquire inferred          */
      /* percentage widths based on 100% minus the total of all percentage      */
      /* specified cells on that row, divided by the number of unspecified      */
      /* cells on the row.                                                      */
      /*                                                                        */
      /* If there are any pixel specified values, it gets complex. First, if    */
      /* the total of explicit % specified cells is < 100, then infer % sizes   */
      /* on the pixel specified cells. You *don't* use this for widthing - you  */
      /* use their pixel values - but you *do* use it as part of the 'what is   */
      /* 1%' algorithm as described above. However, if the total of explicit %  */
      /* specified cells is greater than 100%, then the meaning of 1% will now  */
      /* change. It now becomes 1/100th of the total available width for the    */
      /* row, after all the pixel specified cell widths have been subtracted.   */
      /*                                                                        */
      /* First, do we have any unspecified cells to infer percentages on? We    */
      /* can look for this at the same time as we look for the smallest         */
      /* percentage specifier.                                                  */

      D = R->List;

      while (D && D->ColOffs < p->ColSpan)
      {
        switch (D->Tag)
        {
          case TagTableData:
          case TagTableHead:
          {
            int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;

            if (cellnumber < cellmax)
            {
              if (pcwidths[cellnumber] == -1)
              {
                /* If everything is either %s of pixels, count the */
                /* pixels (pcwidths[] = -1, so this doesn't have a */
                /* percentage specifier)                           */

                if (p->ColSpan == have_percents + have_pixels)
                {
                  max_row += maxs[cellnumber];
                  min_row += mins[cellnumber];
                }

                /* Otherwise, there is a mixture of %s, pixels (maybe) */
                /* and unspecified cells - only count the latter.      */

                else if (!TD_HAS_WIDTH(D))
                {
                  max_row += maxs[cellnumber];
                  min_row += mins[cellnumber];
                }
              }
            }
          }
          break;
        }

        D = D->Next;
      }

      D = R->List;

      while (D && D->ColOffs < p->ColSpan)
      {
        switch (D->Tag)
        {
          case TagTableData:
          case TagTableHead:
          {
            int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;

            if (cellnumber < cellmax)
            {
              int infer = pcwidths[cellnumber];

              /* If we have any cells with no percentage specifiers, then there are two */
              /* cases; the other cells all have pixel specifiers on them, or only some */
              /* of the cells do. In the former case, infer percentage specifiers on    */
              /* all of the other cells. In the latter, only infer percentages on the   */
              /* cells that don't specify a width in any other way.                     */
              /*                                                                        */
              /* We need to find the lowest % specifier, and of those in the row, the   */
              /* one with the greatest maximum width (if there are several with the     */
              /* same minimum % value). For this, the cells we infer %s onto get a      */
              /* distribution of (100% - explicitly specifieds) / (number of cells we   */
              /* are inferring sizes on); i.e. a linear distribution. So this is used   */
              /* to work out what 1% means. However, for later calculation of the sizes */
              /* based on this value of 1%, we infer %s in proportion to the sizes of   */
              /* the columns in question. That's why the 'infer' variable is used at    */
              /* first, but then there's a second bit of code to fill in pcwidths[] for */
              /* an inferred cell with a proportionally scaled, rather than linearly    */
              /* scaled value.                                                          */

              if (infer == -1)
              {
                if (p->ColSpan == have_percents + have_pixels)
                {
                  int div = p->ColSpan - have_percents;

                  if (!div) div = 1;

                  infer = (100 - row_pc_total) / div;
                }
                else if (!TD_HAS_WIDTH(D))
                {
                  int div = p->ColSpan - (have_percents + have_pixels);

                  if (!div) div = 1;

                  infer = (100 - row_pc_total) / div;
                }
              }
              else
              {
                explicit_pc += infer;
              }

              /* Remember the smallest non-zero value */

              if (
                   infer > 0 &&
                   infer <= min_pc
                 )
              {
                if (min_pc == infer)
                {
                  if (maxs[cellnumber] > pc_size)
                  {
                    pc_size = maxs[cellnumber];

                    if (pcwidths[cellnumber] == -1) do_inference = 0;
                    else                            do_inference = 1;
                  }
                }
                else
                {
                  min_pc  = infer;
                  pc_size = maxs[cellnumber];

                  if (pcwidths[cellnumber] == -1) do_inference = 0;
                  else                            do_inference = 1;
                }
              }
            }
          }
          break;
        }

        D = D->Next;
      }

      if (do_inference)
      {
        D = R->List;

        while (D && D->ColOffs < p->ColSpan)
        {
          switch (D->Tag)
          {
            case TagTableData:
            case TagTableHead:
            {
              int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;

              if (cellnumber < cellmax)
              {
                /* The *actual* inferred value is based on the cell size */

                if (pcwidths[cellnumber] == -1)
                {
                  if (p->ColSpan == have_percents + have_pixels)
                  {
                    pcwidths[cellnumber] = ((100 - row_pc_total) * maxs[cellnumber]) / (max_row ? max_row : 1);
                  }
                  else if (!TD_HAS_WIDTH(D))
                  {
                    pcwidths[cellnumber] = ((100 - row_pc_total) * maxs[cellnumber]) / (max_row ? max_row : 1);
                  }
                }
              }
            }
            break;
          }

          D = D->Next;
        }
      }

      /* If we have less than 100% explicitly specified total in the row, */
      /* find the smallest explicit or inferred non-zero % specifier cell */
      /* (and if there are several with this value, find the one with the */
      /* greatest maximum content width), and use this to find what 1%    */
      /* should be.                                                       */

      if (explicit_pc < 100)
      {
        /* We now know what min_pc percent is in OS units (pc_size), and thus */
        /* what 1 percent is in OS units. We can thus assign actual widths to */
        /* the columns and store them in overmaxs array if larger than the    */
        /* existing value.                                                    */

        D = R->List;

        while (D && D->ColOffs < p->ColSpan)
        {
          switch (D->Tag)
          {
            case TagTableData:
            case TagTableHead:
            {
              int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;
              int pc_based_width;

              if (cellnumber < cellmax)
              {
                if (!TD_HAS_WIDTH(D) || TD_WIDTH_UNITS(D) != UNITS_PIXELS)
                {
                  pc_based_width = (pcwidths[cellnumber] * pc_size) / (min_pc ? min_pc : 1);

                  if (pc_based_width > maxs[cellnumber]) maxs[cellnumber] = pc_based_width;
                }
              }
            }
            break;
          }

          D = D->Next;
        }
      }

      /* If, instead, we do have pixel specifiers, 1% comes from the width */
      /* left over after the pixel specifier widths have been subtracted   */
      /* from the whole width available to the row.                        */
      /*                                                                   */
      /* If we're finding the widest a table can be, just leave the full   */
      /* width from the reformatter for all cells - 1% of 'very very wide' */
      /* doens't make much sense...                                        */

      else if (finding_widest != 1)
      {
        int remaining = available_width;

        /* Find how much is left for the percentage cells */

        D = R->List;

        while (D && D->ColOffs < p->ColSpan)
        {
          switch (D->Tag)
          {
            case TagTableData:
            case TagTableHead:
            {
              int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;

              if (cellnumber < cellmax)
              {
                /* If the cell has no specified or inferred percentage width, */
                /* subtract the cell's *minimum* size from the remaining      */
                /* available width - the remainder thus represents a maximum  */
                /* value.                                                     */

                if (pcwidths[cellnumber] < 0) remaining -= mins[cellnumber];

                if (remaining < 0) remaining = 0;
              }
            }
            break;
          }

          D = D->Next;
        }

        /* Now calculate all of the percentage specified widths based on this */

        D = R->List;

        while (D && D->ColOffs < p->ColSpan)
        {
          switch (D->Tag)
          {
            case TagTableData:
            case TagTableHead:
            {
              int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;
              int pc_based_width;

              if (cellnumber < cellmax)
              {
                if (TD_HAS_WIDTH(D) && TD_WIDTH_UNITS(D) == UNITS_PERCENT)
                {
                  pc_based_width = (remaining * pcwidths[cellnumber]) / 100;

                  if (pc_based_width > maxs[cellnumber]) maxs[cellnumber] = pc_based_width;
                }
              }
            }
            break;
          }

          D = D->Next;
        }
      }
    }

    /* Carry on for the other rows. */

    rowcount ++;
    R = R->Next;

  /* Closure of 'while (R && ...)' */
  }

  /* Debug output to show mins and maxs */

  #ifdef TRACE

    {
      int rowc,colc;

      dprintf(("Tabl", "\ntables_width_table: Table %p, size before COLSPAN/ROWSPAN: mins then maxs\n", p));

      for(rowc=0;rowc<p->RowSpan;rowc++)
      {
        dprintf(("Tabl", "%d: ",rowc));

        for(colc=0;colc<p->ColSpan;colc++)
        {
          dprintf(("Tabl", "%d (%d) ",mins[rowc*p->ColSpan+colc],mins[rowc*p->ColSpan+colc]/400));
        }
        dprintf(("Tabl", "\n"));
      }

      dprintf(("Tabl", "\n"));

      for(rowc=0;rowc<p->RowSpan;rowc++)
      {
        dprintf(("Tabl", "%d: ",rowc));

        for(colc=0;colc<p->ColSpan;colc++)
        {
          dprintf(("Tabl", "%d (%d) ",maxs[rowc*p->ColSpan+colc],maxs[rowc*p->ColSpan+colc]/400));
        }
        dprintf(("Tabl", "\n"));
      }
      dprintf(("Tabl", "\n"));
    }

  #endif

  /* mins and maxs arrays consequently now hold the min and max */
  /* sizes of all cells (not accounting for row or column       */
  /* spanning, though).                                         */
  /*                                                            */
  /* We now need to work out the overall greatest minimum and   */
  /* maximum width for each column. Any cells specifying a      */
  /* colspan > 1 are ignored in this, as they will have a large */
  /* width (they span several cells, after all). We're only     */
  /* interested in single cells for now.                        */
  /*                                                            */
  /* We follow the table structure to do this as we must record */
  /* the addresses of cells used in the final width, and want   */
  /* to be able to skip those cells that specify a colspan.     */

  R = p->List;

  while (R)
  {
    int col;

    D = R->List;

    while (D && D->ColOffs < p->ColSpan)
    {
      col = D->ColOffs;

      switch (D->Tag)
      {
        case TagTableData:
        case TagTableHead:
        {
          int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;

          if (cellnumber < cellmax && col < p->ColSpan)
          {
            /* If the cell doesn't span more than 1 column and has a min or max */
            /* value wider than the cells in the same column above it, use the  */
            /* min or max values of this cell instead. Record the cell in the   */
            /* usedcells array accordingly.                                     */

            if (D->ColSpan < 2)
            {
              if (mins[cellnumber] > overmins[col])
              {
                overmins [col] = mins[cellnumber];
                usedcells[col] = D;
              }

              if (maxs[cellnumber] > overmaxs[col])
              {
                table_headdata * lc = usedcells[p->ColSpan + col];

                /* Only use the maximum value if the cell isn't 'locked' by one */
                /* already in use that specifies a pixel size (provided this    */
                /* one doesn't itself specify a greater pixel size).            */

                if (
                     (
                       !TD_HAS_WIDTH(D)                  ||
                       TD_WIDTH_UNITS(D) != UNITS_PIXELS
                     )
                     && lc
                     && TD_HAS_WIDTH(lc)
                     && TD_WIDTH_UNITS(lc) == UNITS_PIXELS
                   )
                {
                  /* May be forced to use this cell anyway, if the *minimum* value */
                  /* of this cell is greater the maximum set from the one already  */
                  /* marked for use in usedcells[]!                                */

                  if (mins[cellnumber] > overmaxs[col])
                  {
                    overmaxs [col]              = mins     [cellnumber];
                    usedcells[p->ColSpan + col] = usedcells[col];
                  }
                }
                else
                {
                  overmaxs [col]              = maxs[cellnumber];
                  usedcells[p->ColSpan + col] = D;
                }
              }
            }
          }
        }
        break;
      }

      D = D->Next;
    }

    R = R->Next;
  }

  /* Debug output to show the results so far... */

  #ifdef TRACE

    {
      int colc;

      dprintf(("Tabl", "\ntables_width_table: Table %p, overall 1: mins / maxs\n", p));

      for(colc=0;colc<p->ColSpan;colc++)
      {
        dprintf(("Tabl", "%d (%d) ",overmins[colc],overmins[colc]/400));
      }

      dprintf(("Tabl", "\n"));

      for(colc=0;colc<p->ColSpan;colc++)
      {
        dprintf(("Tabl", "%d (%d) ",overmaxs[colc],overmaxs[colc]/400));
      }
      dprintf(("Tabl", "\n\n"));
    }

  #endif

  /* Now deal with cells with colspans > 1. For each case, add up   */
  /* the width of the spanned cells from the array just calculated. */
  /* If these work out more than the width calculated for that      */
  /* cell, then nothing needs to be done; else distribute the       */
  /* difference over the spanned cells.                             */

  if (have_colspans)
  {
    R        = p->List;
    rowcount = 0;

    while (R && rowcount < p->RowSpan)
    {
      D = R->List;

      while (D && D->ColOffs < p->ColSpan)
      {
        switch (D->Tag)
        {
          case TagTableData:
          case TagTableHead:
          {
            if (D->ColSpan > 1)
            {
              int currcol;
              int cellnumber         = D->RowOffs * p->ColSpan + D->ColOffs;
              int spanned_total_mins = 0;
              int spanned_total_maxs = 0;
              int px_specifiers      = 0;
              int pc_specifiers      = 0;

              if (cellnumber < cellmax)
              {
                /* Count the spanned columns' minimum and maximum widths, and  */
                /* gather some statistics on the width specifiers on the cells */
                /* used to arrive at those widths.                             */

                for (
                      currcol = D->ColOffs;
                      currcol < D->ColOffs + D->ColSpan && currcol < p->ColSpan;
                      currcol ++
                    )
                {
                  spanned_total_mins += overmins[currcol];
                  spanned_total_maxs += overmaxs[currcol];

                  if (usedcells[currcol + p->ColSpan])
                  {
                    table_headdata * head = usedcells[currcol + p->ColSpan];

                    if (TD_HAS_WIDTH(head))
                    {
                      if (TD_WIDTH_UNITS(head) == UNITS_PERCENT) pc_specifiers ++;
                      else                                       px_specifiers ++;
                    }
                  }
                }

                dprintf(("Tabl", "tables_width_table: Spanned total maxs, mins: %d, %d (%d, %d)\n",

                                 spanned_total_mins,
                                 spanned_total_maxs,
                                 spanned_total_mins / 400,
                                 spanned_total_maxs / 400));

                /* If not big enough, distribute the difference over the columns. */
                /* We can't start altering the minimum values here as when the    */
                /* distribution over the table width (if any) takes place, the    */
                /* total of the spanned columns may end up large enough. So we    */
                /* only increase the potential maximum values, and then must      */
                /* check after the 'final decision' on the column widths that all */
                /* column spanning cells got allocated at least as much as they   */
                /* require.                                                       */

                if (spanned_total_maxs < maxs[cellnumber] && D->ColSpan)
                {
                  int max_diff = maxs[cellnumber] - spanned_total_maxs;
                  int basic;
                  int remainder;
                  int distribute_over;

                  /* If there are any pixel specified columns spanned, but they aren't */
                  /* all pixel specified, then distribute the width over the others    */
                  /* instead.                                                          */

                  distribute_over = D->ColSpan - px_specifiers;

                  basic     = max_diff / (distribute_over ? distribute_over : D->ColSpan);
                  remainder = max_diff - (basic * (distribute_over ? distribute_over : D->ColSpan));

                  for (
                        currcol = D->ColOffs;
                        currcol < D->ColOffs + D->ColSpan && currcol < p->ColSpan;
                        currcol ++
                      )
                  {
                    if (
                         !distribute_over                                                ||
                         !usedcells[currcol + p->ColSpan]                                ||
                         !TD_HAS_WIDTH(usedcells[currcol + p->ColSpan])                  ||
                         TD_WIDTH_UNITS(usedcells[currcol + p->ColSpan]) != UNITS_PIXELS
                       )
                    {
                      if (remainder < 0)
                      {
                        overmaxs[currcol] += basic - 1;
                        remainder ++;
                      }
                      else if (remainder > 0)
                      {
                        overmaxs[currcol] += basic + 1;
                        remainder --;
                      }
                      else overmaxs[currcol] += basic;
                    }

                    /* Make sure the minimum value is less than the maximum! They */
                    /* may have swapped when we added to overmins - but of course */
                    /* can't do this check until afterwards, or overmaxs will get */
                    /* set to overmins, and then added to *again* by the above    */
                    /* loop.                                                      */

                    if (overmaxs[currcol] < overmins[currcol]) overmaxs[currcol] = overmins[currcol];
                  }
                }

              /* Closure of 'if (cellnumber < cellmax)' */
              }
            }
          }
          break;

        /* Closure of 'switch (D->Tag)' */
        }

        D = D->Next;

      /* Closure of 'while (D && ...)' */
      }

      rowcount ++;
      R = R->Next;

    /* Closure of 'while (R && ...)' */
    }

  /* Closure of 'if (have_colspans)' */
  }

tables_width_table_assign_finals: /* (The colspan code below this section may jump back here) */

  /* RFC 1942-like autolayout algorithm - if the *minimum* widths exceed */
  /* the width we're trying to fit the table into, assign the min sizes  */
  /* anyway and (elsewhere) allow horizontal scrolling.                  */
  /*                                                                     */
  /* NB, note the 'usedcells' array needs to have its two 'rows' of      */
  /* cells used for min and max values rationalised at the same time as  */
  /* the final widths are chosen. We'll put the final values in the      */
  /* first 'row' of usedcells.                                           */

  min_table_width = max_table_width = 0;

  for (I = 0; I < p->ColSpan; I++) min_table_width += overmins[I], max_table_width += overmaxs[I];

  if (finding_widest != 1 && min_table_width > available_width)
  {
    /* Assign minimum widths. All of the cells used for minimum values */
    /* are already stored in the first 'row' of usedcells, so we have  */
    /* no more work to do there in this case.                          */

    dprintf(("Tabl", "\ntables_width_table: Forced to assign minimum widths:\n\n"));

    for (I = 0; I < p->ColSpan; I++)
    {
      ColOffs[I] = overmins[I];

      dprintf(("Tabl", "%d: %d OS units\n", I, overmins[I] / 400));
    }

    dprintf(("Tabl", "\n"));
  }

  /* Otherwise, do the maximum widths fit in? If so, assign */
  /* those maximum widths.                                  */

  else if (finding_widest == 1 || max_table_width <= available_width)
  {
    /* Assign maximum widths */

    dprintf(("Tabl", "\ntables_width_table: Table fits, assigning maximum widths:\n\n"));

    for (I = 0; I < p->ColSpan; I++)
    {
      ColOffs[I] = overmaxs[I];

      /* Move all of the second 'row' of usedcells to the first row, as we're */
      /* using the maximum value for all cells.                               */

      usedcells[I] = usedcells[p->ColSpan + I];

      dprintf(("Tabl", "%d: %d OS units\n", I, overmaxs[I] / 400));
    }

    dprintf(("Tabl", "\n"));
  }

  /* Otherwise the maximum width of the table is greater than the available */
  /* space, but the minimum width is less than it.                          */
  /*                                                                        */
  /* According to RFC 1942, the following widthing algorithm is best.       */

  else
  {
    float d, W, D; /* Must be floats as ints will overflow, hmph. */

    dprintf(("Tabl", "\ntables_width_table: Assigning variable column widths:\n\n"));

    W = (float) available_width - (float) min_table_width; /* Difference between minimum table width and available width */
    D = (float) max_table_width - (float) min_table_width; /* Difference between minimum and maximum table width */

    if (D > 0)
    {
      for (I = 0; I < p->ColSpan; I++)
      {
        d = (float) overmaxs[I] - (float) overmins[I]; /* Difference between minimum and maximum column width */
        if (d < 0) d = 0;

        /* The following makes columns with large differences between their minimum and maximum */
        /* widths wider than columns with small differences.                                    */

        ColOffs[I] = overmins[I] + (int) (d * W / D);

        /* Hmm, hard to know what to do with 'usedcells' here. For now, move all */
        /* of the second 'row' of usedcells to the first row, as if we're using  */
        /* the max values.                                                       */

        usedcells[I] = usedcells[p->ColSpan + I];

        dprintf(("Tabl", "%d: %d OS units\n", I, ColOffs[I] / 400));
      }
    }

    #ifdef TRACE
      else dprintf(("Tabl", "...can't, max_table_width = min_table_width\n"));
    #endif

    dprintf(("Tabl", "\n"));
  }

  /* If we have any colspan cells, we must ensure that the columns they span */
  /* give at least as much space as the spanning cell requires. If not,      */
  /* distribute the space over the minimum size values of the spanned        */
  /* columns and rewidth the table overall.                                  */

  if (have_colspans && !have_checked)
  {
    int must_rewidth = 0;

    have_checked = 1;
    R            = p->List;
    rowcount     = 0;

    while (R && rowcount < p->RowSpan)
    {
      D = R->List;

      while (D && D->ColOffs < p->ColSpan)
      {
        switch (D->Tag)
        {
          case TagTableData:
          case TagTableHead:
          {
            if (D->ColSpan > 1)
            {
              int currcol;
              int cellnumber    = D->RowOffs * p->ColSpan + D->ColOffs;
              int spanned_total = 0;
              int mins_total    = 0;

              if (cellnumber < cellmax)
              {
                /* Count the spanned columns */

                for (
                      currcol = D->ColOffs;
                      currcol < D->ColOffs + D->ColSpan && currcol < p->ColSpan;
                      currcol ++
                    )
                    spanned_total += ColOffs[currcol],
                    mins_total    += overmins[currcol];

                /* If not big enough, distribute the difference between the minimum */
                /* size of the colspan cell and the sum of the minimum sizes of the */
                /* columns it spans. Using minimums ensures that when rewidthing    */
                /* the table, we won't need to check colspan cells again in case    */
                /* they are still undersize...!                                     */
                /*                                                                  */
                /* mins_total is checked because a colspan cell in a row above may  */
                /* have already redistributed its width in overmins. If in total it */
                /* was wider than this cell, mins[cellnumber] - mins_total would be */
                /* negative. We'd then go and *reduce* the spanned width to this    */
                /* cell's value, meaning the cell above ended up underwidth. Oops!  */
                /* So, do this extra check to avoid making that error.              */

                if (spanned_total < mins[cellnumber] && mins_total < mins[cellnumber])
                {
                  int min_diff  = mins[cellnumber] - mins_total;
                  int basic     = min_diff / (D->ColSpan ? D->ColSpan : 1);
                  int remainder = min_diff - (basic * D->ColSpan);

                  must_rewidth = 1;

                  /* Distribute over the minimums, handling rounding carefully */

                  for (
                        currcol = D->ColOffs;
                        currcol < D->ColOffs + D->ColSpan && currcol < p->ColSpan;
                        currcol ++
                      )
                  {
                    if (remainder < 0)
                    {
                      overmins[currcol] += basic - 1;
                      remainder ++;
                    }
                    else if (remainder > 0)
                    {
                      overmins[currcol] += basic + 1;
                      remainder --;
                    }
                    else overmins[currcol] += basic;

                    if (overmaxs[currcol] < overmins[currcol]) overmaxs[currcol] = overmins[currcol];
                  }
                }

              /* Closure of 'if (cellnumber < cellmax)' */
              }
            }
          }
          break;

        /* Closure of 'switch (D->Tag)' */
        }

        D = D->Next;

      /* Closure of 'while (D && ...)' */
      }

      rowcount ++;
      R = R->Next;

    /* Closure of 'while (R && ...)' */
    }

    if (must_rewidth)
    {
      /* Now need to rewidth the table on the basis that the */
      /* minimum widths in overmins[] changed.               */

      dprintf(("Tabl", "\ntables_width_table: Second table widthing pass due to colspan cells:\n"));

      goto tables_width_table_assign_finals;

    /* Closure of 'if (must_rewidth)' */
    }

  /* Closure of 'if (have_colspans)' */
  }

  #ifdef TRACE

    /* Final sanity check - the algorithms above should ensure that */
    /* by this stage, no cell whether spanning multiple columns or  */
    /* not should be below its minimum size. In TRACE builds, this  */
    /* check warns if this is not the case (this indicates a bug in */
    /* the widthing code above).                                    */
    /*                                                              */
    /* A single cell being underwidth is really quite serious;      */
    /* there is much more room for colspan to go wrong, really, so  */
    /* the error this check raises is rather more urgent sounding   */
    /* than the similar check for colspan cells.                    */

    R        = p->List;
    rowcount = 0;

    while (R && rowcount < p->RowSpan)
    {
      D = R->List;

      while (D && D->ColOffs < p->ColSpan)
      {
        switch (D->Tag)
        {
          case TagTableData:
          case TagTableHead:
          {
            int currcol    = D->ColOffs;
            int cellnumber = D->RowOffs * p->ColSpan + D->ColOffs;

            if (cellnumber < cellmax)
            {
              if (
                   D->ColSpan <= 1 &&
                   ColOffs[currcol] < mins[cellnumber]
                 )
              {
                /* This ifdef is left here so that in the event the widther is   */
                /* changed so that this final 'emergency' check may be needed in */
                /* non-trace builds, it can be brought back by just removing the */
                /* outer ifdef checks. Be aware that any widther which does this */
                /* *is* broken in some way!                                      */

                #ifdef TRACE

                  erb.errnum = Utils_Error_Custom_Normal;

                  sprintf(erb.errmess,
                          "Warning! NON-colspan cell %d would have ended up at %d OS units (%d mp), below minimum width of %d OS units (%d mp).",
                          cellnumber,
                          ColOffs[currcol] / 400,
                          ColOffs[currcol],
                          mins[cellnumber] / 400,
                          mins[cellnumber]);

                  show_error_ret(&erb);

                #endif

                ColOffs[currcol] = mins[cellnumber];
              }
            }
          }
          break;
        }

        D = D->Next;
      }

      rowcount ++;
      R = R->Next;
    }

    /* Now deal with cells with colspans > 1. For each case, add up   */
    /* the width of the spanned cells from the array just calculated. */
    /* If these work out more than the width calculated for that      */
    /* cell, then nothing needs to be done; else distribute the       */
    /* difference over the spanned cells.                             */

    if (have_colspans)
    {
      R        = p->List;
      rowcount = 0;

      while (R && rowcount < p->RowSpan)
      {
        D = R->List;

        while (D && D->ColOffs < p->ColSpan)
        {
          switch (D->Tag)
          {
            case TagTableData:
            case TagTableHead:
            {
              if (D->ColSpan > 1)
              {
                int currcol;
                int cellnumber    = D->RowOffs * p->ColSpan + D->ColOffs;
                int spanned_total = 0;

                if (cellnumber < cellmax)
                {
                  /* Count the spanned columns */

                  for (
                        currcol = D->ColOffs;
                        currcol < D->ColOffs + D->ColSpan && currcol < p->ColSpan;
                        currcol ++
                      )
                      spanned_total += ColOffs[currcol];

                  /* If not big enough, distribute the difference over the columns. */
                  /* We can't start altering the minimum values here as when the    */
                  /* distribution over the table width (if any) takes place, the    */
                  /* total of the spanned columns may end up large enough.          */

                  if (spanned_total < mins[cellnumber])
                  {
                    int min_diff  = mins[cellnumber] - spanned_total;
                    int basic     = min_diff / (D->ColSpan ? D->ColSpan : 1);
                    int remainder = min_diff - (basic * D->ColSpan);

                    /* This ifdef is left here so that in the event the widther is   */
                    /* changed so that this final 'emergency' check may be needed in */
                    /* non-trace builds, it can be brought back by just removing the */
                    /* outer ifdef checks. Be aware that any widther which does this */
                    /* *is* broken in some way!                                      */

                    #ifdef TRACE

                      erb.errnum = Utils_Error_Custom_Normal;

                      sprintf(erb.errmess,
                              "Colspan cell %d would have ended up at %d OS units (%d mp), below minimum width of %d OS units (%d mp).",
                              cellnumber,
                              spanned_total / 400,
                              spanned_total,
                              mins[cellnumber] / 400,
                              mins[cellnumber]);

                      show_error_ret(&erb);

                    #endif

                    /* Distribute for minimums, handling rounding carefully */

                    for (
                          currcol = D->ColOffs;
                          currcol < D->ColOffs + D->ColSpan && currcol < p->ColSpan;
                          currcol ++
                        )
                    {
                      if (remainder < 0)
                      {
                        ColOffs[currcol] += basic - 1;
                        remainder ++;
                      }
                      else if (remainder > 0)
                      {
                        ColOffs[currcol] += basic + 1;
                        remainder --;
                      }
                      else ColOffs[currcol] += basic;
                    }
                  }

                /* Closure of 'if (cellnumber < cellmax)' */
                }
              }
            }
            break;

          /* Closure of 'switch (D->Tag)' */
          }

          D = D->Next;

        /* Closure of 'while (D && ...)' */
        }

        rowcount ++;
        R = R->Next;

      /* Closure of 'while (R && ...)' */
      }

    /* Closure of 'if (have_colspans)' */
    }

  #endif

  /* Add up the widths */

  real_width = 0;

  for (I = 0; I < p->ColSpan; I++) real_width += ColOffs[I];

  /* Did the table specify a non-zero width to fit to? */

  if (TABLE_HAS_WIDTH(p) && TABLE_WIDTH(p))
  {
    /* If the width is less than that available, distribute */
    /* the extra width over the table to make it fit.       */

    dprintf(("Tabl", "\nTable specifies a width - should columns be extended to fit?\n"));

    if (finding_widest != 1 && real_width && real_width < available_width)
    {
      float W,  add = 0;

      int   rw, aw;

      int   pix = 0;
      int   per = 0;
      int   usp = 0;

      rw = real_width;
      aw = available_width;

      /* If we have any pixel specified cells, only distribute over */
      /* non-pixel specified cells. For some reason, MSIE only does */
      /* this if there are some unspecified cells on the row. If    */
      /* there are only pixel or percentage specified cells, the    */
      /* distribution occurs across all cells.                      */
      /*                                                            */
      /* Of course, by this stage we're working on an amalgamation  */
      /* of individual rows into overall columns, but the principle */
      /* is the same... ;-)                                         */

      for (I = 0; I < p->ColSpan; I++)
      {
        if (usedcells[I])
        {
          if      (!TD_HAS_WIDTH(usedcells[I]))                   usp += ColOffs[I];
          else if (TD_WIDTH_UNITS(usedcells[I]) == UNITS_PIXELS)  pix += ColOffs[I];
          else if (TD_WIDTH_UNITS(usedcells[I]) == UNITS_PERCENT) per += ColOffs[I];
          else                                                    usp += ColOffs[I];
        }
      }

      if (usp)
      {
        /* If we have pixel specifiers and also some other types of cell, */
        /* reduce the apparent table width by the width of the pixel      */
        /* specified cells. The distribution routine below will then skip */
        /* these cells.                                                   */

        if (pix && pix != rw) rw -= pix, aw -= pix;
        else pix = 0;
      }
      else pix = 0;

      dprintf(("Tabl", "\ntables_width_table: Resizing all columns to fit space:\n\n"));

      W = (float) aw - (float) rw;

      for (I = 0; I < p->ColSpan; I++)
      {
        if (
             !pix ||
             (
               !usedcells[I] ||
               !TD_HAS_WIDTH(usedcells[I]) ||
               TD_WIDTH_UNITS(usedcells[I]) != UNITS_PIXELS
             )
           )
        {
          add = W * ((float) ColOffs[I] / (float) (rw ? rw : 1));

          ColOffs[I] += (int) add;

          dprintf(("Tabl", "%d: %d OS units\n", I, ColOffs[I] / 400));
        }
      }
    }
    #ifdef TRACE
      else dprintf(("Tabl", "...can't, real_width = %d\n", real_width));
    #endif

    dprintf(("Tabl", "\n"));
  }

  /* We've finished with the temporary arrays */

  free(maxs);
  free(mins);
  free(overmaxs);
  free(overmins);
  free(pcwidths);
  free(usedcells);

  /* Now we need to go back and reformat the cell contents to the known width */

  rowcount = 0;
  R        = p->List;

  while (R && rowcount < p->RowSpan)
  {
    D = R->List;

    while (D && D->ColOffs < p->ColSpan)
    {
      switch (D->Tag)
      {
        case TagTableData:
        case TagTableHead:
        {
          /* Use the tag's number of columns offset from the left  */
          /* of the table as an index into the array of millipoint */
          /* offsets.                                              */

          new_width = abs(ColOffs[D->ColOffs]);

          /* If the tag spans more than one column, add in the widths */
          /* of the extra columns it covers.                          */

          if (D->ColSpan > 1)
          {
            int index;

            for(I = 1; I < D->ColSpan; I++)
            {
              index = D->ColOffs + I;

              if (index < p->ColSpan) new_width += abs(ColOffs[index]);
            }
          }

          /* Reformat the cell, recursing for inner tables */

          real_width = tables_width_cell(toplevel,
                                         b,
                                         (HStream *) D->List,
                                         p,
                                         cellarray,
                                         new_width,
                                         D->RowOffs,
                                         D->ColOffs);
        }
        break;
      }

      D = D->Next;
    }

    rowcount ++;
    R = R->Next;
  }

  /* Finally, add up all the widths of the columns and return it */

  max_table_width = 0;

  for (I = 0; I < p->ColSpan; I++) max_table_width += abs(ColOffs[I]);

  dprintf(("Tabl", "tables_width_table: Finished, returning %d (%d OS)\n", max_table_width, max_table_width / 400));

  if (controls.table_multi == 0)
  {
    _swix(Hourglass_Off, 0);
  }

  /* Must of course add in whatever we subtracted from available */
  /* width to allow for cellspacing to the returned table width, */
  /* and allow for the outer table border.                       */

  max_table_width += subtract;

  return max_table_width;
}

/**************************************************************/
/* tables_width_cell()                                        */
/*                                                            */
/* Returns the actual width of a given table cell after       */
/* attempting to reformat it to a given width.                */
/*                                                            */
/* Parameters: 1 for a top level call, 0 if being called as   */
/*             part of a nested table parse;                  */
/*                                                            */
/*             Pointer to a browser_data struct relevant to   */
/*             the table;                                     */
/*                                                            */
/*             Pointer to the first HStream structure in the  */
/*             stream that the cell is to contain;            */
/*                                                            */
/*             Pointer to the table_stream struct             */
/*             representing the table;                        */
/*                                                            */
/*             Pointer to the table's array of reformat_cell  */
/*             structures;                                    */
/*                                                            */
/*             Allowed column width (millipts);               */
/*                                                            */
/*             Row number of the cell;                        */
/*                                                            */
/*             Column number of the cell.                     */
/*                                                            */
/* Returns:    Actual width after formatting, in millipoints. */
/**************************************************************/

int tables_width_cell(int toplevel, browser_data * b, HStream * streambase, table_stream * table,
                      reformat_cell * cellarray, int ColWidth, int Row, int Column)
{
  return reformat_format_cell(toplevel,
                              b,
                              streambase,
                              table,
                              cellarray,
                              ColWidth,
                              Row,
                              Column);
}

/**************************************************************/
/* tables_height_table()                                      */
/*                                                            */
/* Works out the heights in millipoints for all cells in a    */
/* given table. This may be called from recursively called    */
/* functions, but does not enter into recursion itself as the */
/* height information for particular cells is stored when     */
/* finding the width - there's no need to call the            */
/* reformatter again.                                         */
/*                                                            */
/* Parameters: 1 for a top level call, else 0 if being called */
/*             as part of a nested tables reformat session;   */
/*                                                            */
/*             Pointer to a browser_data struct, which is the */
/*             parent of the table;                           */
/*                                                            */
/*             Pointer to a table_stream struct relevant to   */
/*             the table;                                     */
/*                                                            */
/*             Pointer to an array of points to reformat_cell */
/*             structures which will hold the final table     */
/*             layout.                                        */
/*                                                            */
/* Returns:    Height of the whole table, in millipoints.     */
/**************************************************************/

int tables_height_table(int toplevel, browser_data * b, table_stream * p, reformat_cell * cellarray)
{
  int              ReturnHeight = 0, Height, NewWidth;
  int            * RowOffs;
  int            * ColOffs;
  int              Row;
  table_row      * R;
  table_headdata * D;
  int              I, C;
  int              scale_height  = 0;
  int              cellmax       = p->ColSpan * p->RowSpan;
  int              cellspacingos = p->cellspacing * 2; /* 1 'web pixel' = 2 OS units */
  int              cellspacingmp;
  int              tbordmp;

  if (!cellmax) return 1600;

  convert_to_points(cellspacingos, &cellspacingmp);
  convert_to_points(TABLE_BORDER(p) * 2, &tbordmp); /* 1 'web pixel' = 2 OS units */

  dprintf(("Tabl", "tables_height_table: Called with P = &%08X, cellarray = &%08X\n",(int) P,(int) cellarray));

  /* To work out height, must know the width (so that the */
  /* reformatter knows what width to wrap to, etc.). So   */
  /* must only call this *after* tables_width_table.      */

  RowOffs = p->RowOffs;
  ColOffs = p->ColOffs;

  Row = 0;
  R   = p->List;

  /* Deal with specific table heights - we may need */
  /* to scale everything up to these afterwards.    */

  if (TABLE_HAS_HEIGHT(p))
  {
    int height = 0, dy;

    switch (TABLE_HEIGHT_UNITS(p))
    {
      default:
      case UNITS_PIXELS:
      {
        convert_to_points(wimpt_dy(), &dy);
        height = TABLE_HEIGHT(p) * dy;
      }
      break;

      case UNITS_PERCENT:
      {
        convert_to_points(redraw_display_height(b, NULL), &height);
        height = (TABLE_HEIGHT(p) * height) / 100;
      }
      break;
    }

    scale_height = height;
  }

  /* Now find the collective row heights for all of the cells */

  while (R)
  {
    D = R->List;

    /* Scan the cells */

    while (D)
    {
      switch (D->Tag)
      {
        case TagTableData:
        case TagTableHead:
        {
          /* Work out the width that this cell uses, for ROWSPAN = 1 cells only */

          if (D->ColOffs < p->ColSpan && D->RowOffs < p->RowSpan && D->RowSpan <= 1)
          {
            NewWidth = abs(ColOffs[D->ColOffs]);

            if (D->ColSpan > 1)
            {
              int index;

              for (I = 1; I < D->ColSpan; I++)
              {
                index = D->ColOffs + I;

                if (index < p->ColSpan) NewWidth += abs(ColOffs[index]);
              }
            }

            /* Find the required cell height (this is not a    */
            /* recursive call - the height is stored in the    */
            /* relevant place by tables_width_cell called from */
            /* tables_width_table above, which is where the    */
            /* recursion is handled).                          */

            Height = tables_height_cell(toplevel,
                                        b,
                                        (HStream *) D->List,
                                        p,
                                        cellarray,
                                        NewWidth,
                                        D->RowOffs,
                                        D->ColOffs);

            /* Deal with direct height specifiers */

            if (TD_HAS_HEIGHT(D))
            {
              int hc = 0;

              /* Percentages come from the whole visible area size */

              if (TD_HEIGHT_UNITS(D) == UNITS_PERCENT)
              {
                hc = (b->display_height * TD_HEIGHT(D)) / 100;
              }

              /* Pixel specifiers are easier */

              else
              {
                hc = TD_HEIGHT(D) * 2; /* 2 'web pixels' = 1 OS unit */
              }

              convert_to_points(hc, &hc);

              if (hc > Height) Height = hc;
            }

            /* If this is the greatest height so far for the row, remember it */

            if (Height > RowOffs[Row]) RowOffs[Row] = Height;
          }
        }
        break;
      }

      D = D->Next;
    }

    dprintf(("Tabl", "tables_height_table: First pass, row %d, height %d (%d OS)\n", Row, RowOffs[Row], RowOffs[Row] / 400));

    Row ++;

    R = R->Next;
  }

  /* Another scan, for ROWSPAN this time */

  Row = 0;
  R   = p->List;

  while (R)
  {
    D = R->List;

    while (D)
    {
      switch (D->Tag)
      {
        case TagTableData:
        case TagTableHead:
        {
          /* Work out the width that this cell uses, for ROWSPAN = 1 cells only */

          if (D->ColOffs < p->ColSpan && D->RowOffs < p->RowSpan && D->RowSpan > 1)
          {
            NewWidth = abs(ColOffs[D->ColOffs]);

            if (D->ColSpan > 1)
            {
              int index;

              for (I = 1; I < D->ColSpan; I++)
              {
                index = D->ColOffs + I;

                if (index < p->ColSpan) NewWidth += abs(ColOffs[index]);
              }
            }

            /* Find the required cell height (this is not a    */
            /* recursive call - the height is stored in the    */
            /* relevant place by tables_width_cell called from */
            /* tables_width_table above, which is where the    */
            /* recursion is handled).                          */

            Height = tables_height_cell(toplevel,
                                        b,
                                        (HStream *) D->List,
                                        p,
                                        cellarray,
                                        NewWidth,
                                        D->RowOffs,
                                        D->ColOffs);

            /* Deal with direct height specifiers */

            if (TD_HAS_HEIGHT(D))
            {
              /* Percentages come from the whole visible area size */

              if (TD_HEIGHT_UNITS(D) == UNITS_PERCENT)
              {
                int hc = (b->display_height * TD_HEIGHT(D)) / 100;

                if (hc > Height) Height = hc;
              }

              /* Pixel specifiers are easier */

              else if (TD_HEIGHT_UNITS(D) == UNITS_PIXELS)
              {
                int hc = TD_HEIGHT(D) * 2; /* 2 'web pixels' = 1 OS unit */

                if (hc > Height) Height = hc;
              }
            }

            /* The cell spans several rows, so we must count up the height */
            /* already present in the rows it spans. Any extra that this   */
            /* cell requires is added to the last row it touches.          */

            C = D->RowSpan;
            if (C + Row >= p->RowSpan) C = p->RowSpan - Row;

            if (C > 0)
            {
              int TotalHeight = 0;

              for (I = Row; I < Row + C && I < p->RowSpan; I++)
              {
                TotalHeight += RowOffs[I];
              }

              /* If the total amount the cell spans is less than this cell */
              /* requires, add in the extra to the last cell.              */

              if (TotalHeight < Height) RowOffs[Row + C - 1] += Height - TotalHeight;
            }
          }
        }
        break;
      }

      D = D->Next;
    }

    dprintf(("Tabl", "tables_height_table: Second pass, row %d, height %d (%d OS)\n", Row, RowOffs[Row], RowOffs[Row] / 400));

    Row ++;

    R = R->Next;
  }

  /* Calculate the table height */

  for (Row = 0; Row < p->RowSpan; Row ++) ReturnHeight += RowOffs[Row];

  /* If this is below the table scale height, do a *linear* scale up */

  if (ReturnHeight < scale_height)
  {
    int difference = scale_height - ReturnHeight;
    int basic;
    int remainder;

    basic     = difference / (p->RowSpan ? p->RowSpan : 1);
    remainder = difference - (basic * p->RowSpan);

    for (
          Row = 0;
          Row < p->RowSpan;
          Row ++
        )
    {
      if (remainder < 0)
      {
        RowOffs[Row] += basic - 1;
        remainder ++;
      }
      else if (remainder > 0)
      {
        RowOffs[Row] += basic + 1;
        remainder --;
      }
      else RowOffs[Row] += basic;
    }

    /* Recalculate height (may not be dead on scale_height because */
    /* of rounding errors, though it won't be far out because of   */
    /* the above code)                                             */

    ReturnHeight = 0;

    for (Row = 0; Row < p->RowSpan; Row ++) ReturnHeight += RowOffs[Row];
  }

  /* Add in cell spacings and the table outer border */

  if (choices.msie4_style_tables)
  {
    int actual_rowspan;

    tables_find_actual_size(p, NULL, &actual_rowspan);

    ReturnHeight += cellspacingmp * (actual_rowspan + 1) + tbordmp * 2;
  }
  else
  {
    ReturnHeight += cellspacingmp * (p->RowSpan + 1) + tbordmp * 2;
  }

  /* Return the height */

  dprintf(("Tabl", "tables_height_table: Finished, returning %d (%d OS)\n\n", ReturnHeight, ReturnHeight / 400));

  return ReturnHeight;
}

/**************************************************************/
/* tables_height_cell()                                       */
/*                                                            */
/* Returns the height of a cell widthed by a previous call to */
/* tables_width_cell.                                         */
/*                                                            */
/* Parameters: 1 for a top level call, 0 if being called as   */
/*             part of a nested table parse;                  */
/*                                                            */
/*             Pointer to a browser_data struct relevant to   */
/*             the table;                                     */
/*                                                            */
/*             Pointer to the first HStream structure in the  */
/*             stream that the cell is to contain;            */
/*                                                            */
/*             Pointer to the table_stream struct             */
/*             representing the table;                        */
/*                                                            */
/*             Pointer to the table's array of reformat_cell  */
/*             structures;                                    */
/*                                                            */
/*             Allowed column width (millipts - this is not   */
/*             used at present);                              */
/*                                                            */
/*             Row number of the cell;                        */
/*                                                            */
/*             Column number of the cell.                     */
/*                                                            */
/* Returns:    Cell height in millipoints.                    */
/**************************************************************/

int tables_height_cell(int toplevel, browser_data * b, HStream * streambase, table_stream * table,
                       reformat_cell * cellarray, int ColWidth, int Row, int Column)
{
  int             cellindex = Row * table->ColSpan + Column;
  int             cellpadmp;
  reformat_cell * c;

  /* Can't do anything if the cell index is out of range */

  if (cellindex >= table->RowSpan * table->ColSpan) return 1600;
  else c = &cellarray[cellindex];

  /* OK, so not used for now, but may be - this is to avoid a compiler warning */

  b = b;

  /* Add in the cell padding values to the top and bottom */

  cellpadmp = table->cellpadding * 4; /* 1 'web pixel' = 2 OS units, times two for top and bottom */
  convert_to_points(cellpadmp, &cellpadmp);

  c->height += cellpadmp;

  dprintf(("Tabl", "tables_height_cell: Streambase, table, ColWidth, Row, Column = %p, %p, %d, %d, %d\n"
                   "tables_height_cell: Returning %d\n",

                   streambase, table, ColWidth, Row, Column,
                   c->height));

  return c->height;
}

/**************************************************************/
/* tables_fix_table()                                         */
/*                                                            */
/* Having found the width and height of the cells in a given  */
/* table, and their row/column offset from the top left, this */
/* fixes the cell positions as x and y coordinates in         */
/* millipoints from the top left.                             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct, which is the */
/*             parent of the table;                           */
/*                                                            */
/*             Pointer to a table_stream struct relevant to   */
/*             the table;                                     */
/*                                                            */
/*             Pointer to an array of points to reformat_cell */
/*             structures which will hold the final table     */
/*             layout.                                        */
/**************************************************************/

void tables_fix_table(browser_data * b, table_stream * p, reformat_cell * cellarray)
{
  table_row      * R;
  table_headdata * D;
  int              I;
  int              Width, Height;
  int            * ColOffs;
  int            * RowOffs;
  int              CurX, CurY;
  int              cellcount      = 0;
  int              cellmax        = p->ColSpan * p->RowSpan;
  int              cellspacingos  = p->cellspacing * 2; /* 1 'web pixel' = 2 OS units */
  int              cellspacingmp;
  int              tbordmp;
  int              actual_colspan = p->ColSpan;
  int              actual_rowspan = p->RowSpan;

  convert_to_points(cellspacingos, &cellspacingmp);
  convert_to_points(TABLE_BORDER(p) * 2, &tbordmp); /* 1 'web pixel' = 2 OS units */

  /* First thing - for MSIE4 compatibility regarding cell spacing, */
  /* work out the number of actually used rows and columsn in the  */
  /* table. For more, see comments around code calculating the     */
  /* value of 'subtract' in tables_width_table.                    */

  if (choices.msie4_style_tables)
  {
    tables_find_actual_size(p, &actual_colspan, &actual_rowspan);
  }

  /* Have ColOffs and RowOffs as the arrays holding millipoint */
  /* offsets from the top left of the table.                   */

  R       = p->List;
  ColOffs = p->ColOffs;
  RowOffs = p->RowOffs;

  while (R && cellcount < cellmax)
  {
    D = R->List;

    /* In here, D->RowOffs or D->ColOffs will be the number of */
    /* rows / columns from the top left that this cell is      */
    /* offset by.                                              */

    while (D && cellcount < cellmax)
    {
      if (D->ColOffs < p->ColSpan && D->RowOffs < p->RowSpan)
      {
        /* If the cell is offset horizontally, add up the widths of */
        /* all the columns before it into CurX.                     */

        CurX = cellspacingmp + tbordmp;

        if (D->ColOffs)
        {
          for (I = 0; I < D->ColOffs; I++)
          {
            CurX += abs(ColOffs[I]) + cellspacingmp;
          }
        }

        CurY = -cellspacingmp - tbordmp;

        /* Similarly, add up the row heights */

        if (D->RowOffs)
        {
          for (I = 0; I < D->RowOffs; I++)
          {
            CurY -= abs(RowOffs[I]) + cellspacingmp;
          }
        }

        /* Set Width to the width of this cell, */
        /* taking account of column spanning.   */

        Width = abs(ColOffs[D->ColOffs]);

        if (D->ColSpan > 1)
        {
          int spanned, available;

          for (I = 1; I < D->ColSpan; I++)
          {
            Width += abs(ColOffs[D->ColOffs + I]);
          }

          /* Account for cell spacing */

          spanned   = D->ColSpan;
          available = actual_colspan - D->ColOffs;

          if (spanned > available ) spanned = available;

          Width += cellspacingmp * (spanned - 1);
        }

        /* Do the same for the height */

        Height = abs(RowOffs[D->RowOffs]);

        if (D->RowSpan > 1)
        {
          int spanned, available;

          for (I = 1; I < CorrectRowSpan(D, p); I++)
          {
            Height += abs(RowOffs[D->RowOffs + I]);
          }

          spanned   = D->RowSpan;
          available = actual_rowspan - D->RowOffs;

          if (spanned > available ) spanned = available;

          /* Account for cell spacing */

          Height += cellspacingmp * (spanned - 1);
        }

        /* We now know the X and Y millipoint offsets of the cell and */
        /* its width and height (again, in millipoints). Now call     */
        /* tables_fix_cell to fix the positions of the cell inside    */
        /* the relevant data structure components.                    */

        switch (D->Tag)
        {
          case TagTableData: tables_fix_cell(b, (HStream *) D->List, p, cellarray, CurX, CurY, Width, Height, D->RowOffs, D->ColOffs); break;
          case TagTableHead: tables_fix_cell(b, (HStream *) D->List, p, cellarray, CurX, CurY, Width, Height, D->RowOffs, D->ColOffs); break;
        }
      }

      cellcount++;

      D = D->Next;
    }

    R = R->Next;
  }
}

/**************************************************************/
/* tables_fix_cell()                                          */
/*                                                            */
/* Fixes the position of a given table cell as an offset from */
/* the top left of the table in millipoints.                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct owning the    */
/*             table;                                         */
/*                                                            */
/*             Pointer to the first HStream structure in the  */
/*             stream that the cell is to contain;            */
/*                                                            */
/*             Pointer to the table_stream struct             */
/*             representing the table;                        */
/*                                                            */
/*             Pointer to the table's array of reformat_cell  */
/*             structures;                                    */
/*                                                            */
/*             X offset from top left, in millipoints;        */
/*                                                            */
/*             Yoffset from top left, in millipoints;         */
/*                                                            */
/*             Total cell width (millipoints);                */
/*                                                            */
/*             Total cell height (millipoints);               */
/*                                                            */
/*             Row number of the cell;                        */
/*                                                            */
/*             Column number of the cell.                     */
/**************************************************************/

void tables_fix_cell(browser_data * b, HStream * streambase, table_stream * table, reformat_cell * cellarray,
                     int x, int y, int Width, int Height, int Row, int Column)
{
  int              cellindex = Row * table->ColSpan + Column;
  reformat_cell  * c;

  dprintf(("Tabl", "tables_fix_cell: Called; streambase, table, Row, Column = %p, %p, %d, %d\n",streambase,table,Row,Column));

  /* Can't do anything if the cell index is out of range */

  if (cellindex >= table->RowSpan * table->ColSpan) return;
  else c = &cellarray[cellindex];

  //the 3200's in here should be replaced by border sizes in due course

  c->x = x + Column;// * 3200 + 1600;
  c->y = y - Row;// * 3200 - 1600;

  c->cellwidth  = Width;
  c->cellheight = Height;

  /* Post-correct Y for VALIGN and cellpadding considerations */

  tables_align_contents(b,
                        streambase,
                        table,
                        cellarray,
                        Row,
                        Column);

  /* Finished */

  dprintf(("Tabl", "tables_fix_cell: Successful\n"));
}

/**************************************************************/
/* tables_align_contents()                                    */
/*                                                            */
/* Once the cellheight field of a reformat_cell struct is     */
/* filled in, it is possible to look at the VALIGN            */
/* specification on the table cell tag represented by the     */
/* reformat_cell struct and align the cell contents in an     */
/* appropriate fashion. This is done by increasing the height */
/* of the first line as required, shifting the y coordinate   */
/* of all subsequent lines as needed, and increasing the used */
/* height value in the cell to match.                         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct owning the    */
/*             table;                                         */
/*                                                            */
/*             Pointer to the first HStream structure in the  */
/*             stream that the cell is to contain;            */
/*                                                            */
/*             Pointer to the table_stream struct             */
/*             representing the table;                        */
/*                                                            */
/*             Pointer to the table's array of reformat_cell  */
/*             structures;                                    */
/*                                                            */
/*             Row number of the cell;                        */
/*                                                            */
/*             Column number of the cell.                     */
/**************************************************************/

static void tables_align_contents(browser_data * b, HStream * streambase, table_stream * table, reformat_cell * cellarray, int Row, int Column)
{
  int              cellindex = Row * table->ColSpan + Column;
  int              cellpadmp = table->cellpadding * 2; /* 1 'web pixel' = 2 OS units */
  int              valign_offset_mp, valign_offset_os;
  table_headdata * head;
  reformat_cell  * c;

  dprintf(("Tabl", "tables_align_contents: Called; streambase, table, Row, Column = %p, %p, %d, %d\n",streambase,table,Row,Column));

  convert_to_points(cellpadmp, &cellpadmp);

  /* Can't do anything if the cell index is out of range */

  if (cellindex >= table->RowSpan * table->ColSpan) return;
  else c = &cellarray[cellindex];

  /* If the cell has no lines, again, can't do anything */

  if (!c->nlines) return;

  /* OK, so not used for now, but may be - this is to avoid a compiler warning */

  b = b;

  /* Work out the vertical alignment offset value in OS units and millipoints */

  head = streambase ? (table_headdata *) streambase->parent : NULL;

  if (head)
  {
    if      (TD_VALIGN(head) == ALIGN_BOTTOM) valign_offset_mp = c->cellheight - c->height;
    else if (TD_VALIGN(head) == ALIGN_MIDDLE) valign_offset_mp = (c->cellheight - c->height) / 2;
    else                                      valign_offset_mp = 0;

    valign_offset_mp += cellpadmp;

    convert_to_os(valign_offset_mp, &valign_offset_os);

    /* Only proceed if there's a change to be made */

    if (valign_offset_mp && valign_offset_os)
    {
      int l;

      /* Shift the y coordinates of the lines */

      for (l = 0; l < c->nlines; l++) c->ldata[l].y -= valign_offset_os;

      /* Increase the used height value */

      c->height += valign_offset_mp;
    }
  }

  dprintf(("Tabl", "tables_align_contents: Successful\n"));
}

/**************************************************************/
/* tables_free_memory()                                       */
/*                                                            */
/* Goes through the lines of a reformat_cell structure,       */
/* freeing all allocated memory relating to any tables in     */
/* that list; that is, the lines and chunks allocated in any  */
/* assoc- iated cells. Does not free the given cell's line or */
/* chunk arrays, or any HTMLLib allocated data such as the    */
/* cell arrays allocated through HTMLLib or the HStream lists */
/* (HtmlStreamFree should be used for those).                 */
/*                                                            */
/* Parameters: 1 for top level call, 0 for a recursive one    */
/*             (only used for the hourglass);                 */
/*                                                            */
/*             Pointer to a browser_data struct relevant to   */
/*             the tables;                                    */
/*                                                            */
/*             Pointer to a reformat_cell struct holding the  */
/*             line array;                                    */
/*                                                            */
/*             Line number in that line array from which      */
/*             freeing is to start.                           */
/**************************************************************/

void tables_free_memory(int toplevel, browser_data * b, reformat_cell * d, int line)
{
  int l, c;

  if (!d->nlines || line >= d->nlines) return;
  if (line < 0) line = 0;

  if (toplevel) _swix(Hourglass_Start,
                      _IN(0),

                      Tables_Hourglass_FreeingTablesDelay);

  /* Scan through the lines from last line to the requested one */
  /* (this is so that flex thrashage will hopefully be reduced, */
  /* as other cells in lines of higher numbers will on average  */
  /* appear in memory above cells in lines of lower numbers).   */

  for (l = d->nlines - 1; l >= line; l--)
  {
    /* Scan through all chunks on the line */

    for (c = d->ldata[l].chunks + d->ldata[l].n - 1; c >= d->ldata[l].chunks; c--)
    {
      /* Does the chunk represent a table? */

      if (d->cdata[c].t->tagno == TAG_TABLE)
      {
        table_stream   * table     = (table_stream *) d->cdata[c].t;
        table_row      * row       = NULL;
        table_headdata * head      = NULL;
        reformat_cell  * cellarray = table->cells;
        reformat_cell  * cell;
        int              cellindex;
        int              cellcount = 0;
        int              cellmax   = table->ColSpan * table->RowSpan;

        if (cellarray)
        {
          row = table->List;

          while (row && cellcount < cellmax)
          {
            head = row->List;

            while (head && cellcount < cellmax)
            {
              switch (head->Tag)
              {
                case TagTableData:
                case TagTableHead:
                {
                  cellindex = head->RowOffs * table->ColSpan + head->ColOffs;

                  if (cellindex < cellmax)
                  {
                    cell = &cellarray[cellindex];

                    /* Recursive call to free any nested tables inside this cell */

                    tables_free_memory(0, b, cell, 0);

                    /* Free the line and chunk lists for the cell */

                    if (cell->ldata) flex_free((flex_ptr) &cell->ldata);
                    if (cell->cdata) flex_free((flex_ptr) &cell->cdata);

                    cell->nlines = 0;

                    /* Invalidate the min and max width information */

                    cell->minwid = -1;
                    cell->maxwid = -1;
                  }
                }
                break;

              /* Closure of 'switch (head->Tag)' */
              }

              cellcount++;

              head = head->Next;

            /* Closure of 'while (head && ...)' */
            }

            row = row->Next;

          /* Closure of 'while (row && ...)' */
          }

        /* Closure of 'if (cellarray)' */
        }

      /* Closure of 'if (d->cdata[c].t->tagno == TAG_TABLE)' */
      }

    /* Closure of loop scanning this line's chunks */
    }

    if (!printing && toplevel && d->nlines) utils_hourglass_percent(d->nlines - l, d->nlines);

  /* Closure of loop scanning the cell's lines */
  }

  if (toplevel) _swix(Hourglass_Off, 0);
}
@


1.21
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d3146 1
a3146 1
    if (toplevel && d->nlines) _swix(Hourglass_Percentage, _IN(0), (100 * (d->nlines - l - 1)) / d->nlines);
@


1.20
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@a70 9
/* Local compile-time options */

#undef BROKEN_TABLE_POLLING_HACK

#ifdef BROKEN_TABLE_POLLING_HACK
  #include <tboxlibs/wimp.h>
  #include "Multiuser.h"
#endif

a634 13
  #ifdef BROKEN_TABLE_POLLING_HACK

    // This doesn't work properly, see elsewhere for reasons

    unsigned int poll_counter;

    _swix(OS_ReadMonotonicTime,
          _OUT(0),

          &poll_counter);

  #endif

d836 3
a838 1
  /* This can get s l o w... */
d840 2
a841 2
  _swix(Hourglass_Start,
        _IN(0),
d843 2
a844 1
        Tables_Hourglass_WidthingTableDelay);
d870 4
a873 2
    /* Flick the LEDs around a bit to show progress. Not much point */
    /* trying to do %s because of nested tables.                    */
d875 2
a876 2
    _swix(Hourglass_LEDs,
          _INR(0,1),
d878 2
a879 2
          3,
          width_table_leds);
d881 2
a882 63
    width_table_leds ^= 3;

    /* Trust me - you do *not* want to enable this ;-) */

    #ifdef BROKEN_TABLE_POLLING_HACK

      {
        unsigned int now;

        _swix(OS_ReadMonotonicTime,
              _OUT(0),

              &now);

        // ************************************************************* //
        // ************************************************************* //
        // ************************************************************* //

        /* This doesn't work properly as this function is called several */
        /* times. The polling stuff needs to have the timer initialised  */
        /* at a top level function, rather than at the top of this       */
        /* function.                                                     */

        // ************************************************************* //
        // ************************************************************* //
        // ************************************************************* //

        if (now - poll_counter > 5)
        {
          WimpPollBlock b;
          int           eventcode;
          unsigned int  mask;

          poll_counter = now;

          ChkError(event_get_mask(&mask));
          ChkError(event_set_mask((mask & (~Wimp_Poll_NullMask))      |
                                  Wimp_Poll_PointerLeavingWindowMask  |
                                  Wimp_Poll_PointerEnteringWindowMask |
                                  Wimp_Poll_MouseClickMask            |
                                  Wimp_Poll_KeyPressedMask            |
                                  Wimp_Poll_PollWordNonZeroMask       |
                                  Wimp_Poll_UserMessageMask           |
                                  Wimp_Poll_UserMessageRecordedMask   |
                                  Wimp_Poll_UserMessageAcknowledgeMask|
                                  0));

          /* Yikes! "One or two" holes this introduces. For example, */
          /* close a window during table formatting. Ick.            */

          ChkError(event_poll(&eventcode, &b, NULL));
          ChkError(event_set_mask(mask));

          if (quit)
          {
            _swix(Hourglass_Smash, 0);
            show_error_ret(multiuser_logout());
            exit(EXIT_SUCCESS);
          }
        }
      }

    #endif
d2142 3
a2144 6
               pix &&
               (
                 !usedcells[I] ||
                 !TD_HAS_WIDTH(usedcells[I]) ||
                 TD_WIDTH_UNITS(usedcells[I]) != UNITS_PIXELS
               )
d2238 4
a2241 1
  _swix(Hourglass_Off, 0);
@


1.19
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a49 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d71 9
d123 1
a123 1
  b = b;
d125 1
a125 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("\ntables_count_table entered: 0x%x\n",(int) P);
  #endif
d205 1
a205 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("tables_count_table row: 0x%x\n",(int) R);
    #endif
d214 1
a214 3
      #ifdef TRACE
        if (tl & (1u<<20)) Printf("tables_count_table headdata: 0x%x\n",(int) D);
      #endif
d270 1
a270 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("Rows, Cols: %d, %d\n", RowCount, Cols);
  #endif
d350 1
a350 1
  b = b;
d352 1
a352 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("tables_position_table entered: 0x%x\n",(int) P);
  #endif
d399 1
a399 3
          #ifdef TRACE
            if (tl & (1u<<20)) Printf("tables_position_table: In scan, D (0x%x) RowOffs = %d, ColOffs = %d\n", D, Rows, Cols);
          #endif
d642 13
a654 2
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("tables_width_table entered: 0x%x %d (%d OS) 0x%x\n", (int) P, available_width, available_width / 400, cellarray);
d880 1
a880 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("tables_width_table: Row struct 0x%x\n",(int) R);
    #endif
d900 62
d968 1
a968 3
      #ifdef TRACE
        if (tl & (1u<<20)) Printf("tables_width_table: Head struct, tag 0x%x 0x%x\n",(int) D,(int) D->Tag);
      #endif
d982 1
a982 3
            #ifdef TRACE
              if (tl & (1u<<20)) Printf("tables_width_table: Dealing with column tag 0x%x\n",(int) D->Tag);
            #endif
a1433 1
    if (tl & (1u<<20))
d1437 1
a1437 1
      Printf("\nTable %p, size before COLSPAN/ROWSPAN: mins then maxs\n", p);
d1441 1
a1441 1
        Printf("%d: ",rowc);
d1445 1
a1445 1
          Printf("%d (%d) ",mins[rowc*p->ColSpan+colc],mins[rowc*p->ColSpan+colc]/400);
d1447 1
a1447 1
        Printf("\n");
d1450 1
a1450 1
      Printf("\n");
d1454 1
a1454 1
        Printf("%d: ",rowc);
d1458 1
a1458 1
          Printf("%d (%d) ",maxs[rowc*p->ColSpan+colc],maxs[rowc*p->ColSpan+colc]/400);
d1460 1
a1460 1
        Printf("\n");
d1462 1
a1462 1
      Printf("\n");
a1564 1
    if (tl & (1u<<20))
d1568 1
a1568 1
      Printf("\nTable %p, overall 1: mins / maxs\n", p);
d1572 1
a1572 1
        Printf("%d (%d) ",overmins[colc],overmins[colc]/400);
d1575 1
a1575 1
      Printf("\n");
d1579 1
a1579 1
        Printf("%d (%d) ",overmaxs[colc],overmaxs[colc]/400);
d1581 1
a1581 1
      Printf("\n\n");
d1644 1
a1644 1
                #ifdef TRACE
d1646 4
a1649 6
                  if (tl & (1u<<20)) Printf("spanned total maxs, mins: %d, %d (%d, %d)\n",
                                            spanned_total_mins,
                                            spanned_total_maxs,
                                            spanned_total_mins/400,
                                            spanned_total_maxs/400);
                #endif
d1756 1
a1756 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("\ntables_width_table: Forced to assign minimum widths:\n\n");
    #endif
d1762 1
a1762 3
      #ifdef TRACE
        if (tl & (1u<<20)) Printf("%d: %d OS units\n", I, overmins[I] / 400);
      #endif
d1765 1
a1765 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("\n");
    #endif
d1775 1
a1775 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("\ntables_width_table: Table fits, assigning maximum widths:\n\n");
    #endif
d1786 1
a1786 3
      #ifdef TRACE
        if (tl & (1u<<20)) Printf("%d: %d OS units\n", I, overmaxs[I] / 400);
      #endif
d1789 1
a1789 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("\n");
    #endif
d1801 1
a1801 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("\ntables_width_table: Assigning variable column widths:\n\n");
    #endif
d1824 1
a1824 3
        #ifdef TRACE
          if (tl & (1u<<20)) Printf("%d: %d OS units\n", I, ColOffs[I] / 400);
        #endif
d1829 2
d1832 1
a1832 8
      else
      {
        if (tl & (1u<<20)) Printf("...can't, max_table_width = min_table_width\n");
      }

      if (tl & (1u<<20)) Printf("\n");

    #endif
d1948 1
a1948 3
      #ifdef TRACE
        if (tl & (1u<<20)) Printf("\ntables_width_table: Second table widthing pass due to colspan cells:\n");
      #endif
d2163 1
a2163 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("\nTable specifies a width - should columns be extended to fit?\n");
    #endif
d2211 1
a2211 3
      #ifdef TRACE
        if (tl & (1u<<20)) Printf("\ntables_width_table: Resizing all columns to fit space:\n\n");
      #endif
d2233 1
a2233 3
          #ifdef TRACE
            if (tl & (1u<<20)) Printf("%d: %d OS units\n", I, ColOffs[I] / 400);
          #endif
d2238 2
d2241 1
a2241 8
      else
      {
        if (tl & (1u<<20)) Printf("...can't, real_width = %d\n", real_width);
      }

      if (tl & (1u<<20)) Printf("\n");

    #endif
d2317 1
a2317 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("tables_width_table: Finished, returning %d (%d OS)\n", max_table_width, max_table_width / 400);
  #endif
d2419 1
a2419 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("tables_height_table entered: 0x%x 0x%x\n",(int) P,(int) cellarray);
  #endif
d2543 1
a2543 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("tables_height_table: First pass, row %d, height %d (%d OS)\n", Row, RowOffs[Row], RowOffs[Row] / 400);
    #endif
d2651 1
a2651 3
    #ifdef TRACE
      if (tl & (1u<<20)) Printf("tables_height_table: Second pass, row %d, height %d (%d OS)\n", Row, RowOffs[Row], RowOffs[Row] / 400);
    #endif
d2718 1
a2718 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("tables_height_table: Finished, returning %d (%d OS)\n\n", ReturnHeight, ReturnHeight / 400);
  #endif
d2777 5
a2781 7
  #ifdef TRACE
    if (tl & (1u<<20))
    {
      Printf("tables_height_cell: %p %p %d %d %d\n",streambase,table,ColWidth,Row,Column);
      Printf("tables_height_cell returning %d\n",c->height);
    }
  #endif
d2984 1
a2984 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("tables_fix_cell: %p %p %d %d\n",streambase,table,Row,Column);
  #endif
d3010 1
a3010 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("tables_fix_cell: Successful\n");
  #endif
d3050 1
a3050 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("tables_align_contents: %p %p %d %d\n",streambase,table,Row,Column);
  #endif
d3097 1
a3097 3
  #ifdef TRACE
    if (tl & (1u<<20)) Printf("tables_align_contents: Successful\n");
  #endif
@


1.18
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d15 19
a33 19
/***************************************************/
/* File   : Tables.c                               */
/*                                                 */
/* Purpose: Table handling functions.              */
/*                                                 */
/* Author : T.Cheal, adapted by A.D.Hodgkinson     */
/*                                                 */
/* History: 18-Mar-97: Datestamp on code received  */
/*                     from T.Cheal.               */
/*          12-Apr-97: Tidied up, more comments,   */
/*                     and from here on continued  */
/*                     development of the code     */
/*                     content.                    */
/*          18-Jun-97: Moved several functions     */
/*                     that were in the            */
/*                     reformatter here, as this   */
/*                     is a more appropriate       */
/*                     location for them.          */
/***************************************************/
d38 16
a53 1
#include "swis.h"
a54 9
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "toolbox.h"

#include "svcprint.h"
d85 22
a106 26
/*************************************************/
/* tables_count_table()                          */
/*                                               */
/* Works out the number of rows and columns in a */
/* given table, and writes back into the given   */
/* table_stream structure these values plus      */
/* pointers to two allocated blocks of memory    */
/* that can hold one integer for each row and    */
/* column.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct, */
/*             which is the parent of the table; */
/*                                               */
/*             Pointer to a table_stream struct  */
/*             relevant to the table.            */
/*                                               */
/* Returns:    Writes to the given table_stream  */
/*             struct, so this must not be in a  */
/*             read only area. The ColSpan and   */
/*             RowSpan fields are filled in with */
/*             the number of columns and rows    */
/*             respectively, and the ColOffs and */
/*             RowOffs fields are filled with    */
/*             the pointers to the arrays of     */
/*             Cols and Rows ints, respectively. */
/*************************************************/
d324 16
a339 18
/*************************************************/
/* tables_position_table()                       */
/*                                               */
/* Fills in the RowOffs and ColOffs fields for   */
/* the given table and all cells in a given      */
/* table, taking account of multiple row and     */
/* column spanning. These are integers which,    */
/* for a given cell, give the number of rows and */
/* columns from the top left of the table        */
/* (starting at (0, 0)) that the cell is offset  */
/* by.                                           */
/*                                               */
/* Parameters: Pointer to a browser_data struct, */
/*             which is the parent of the table; */
/*                                               */
/*             Pointer to a table_stream struct  */
/*             relevant to the table.            */
/*************************************************/
d453 20
a472 21
/*************************************************/
/* tables_init_table()                           */
/*                                               */
/* For a new, uninitialised array of             */
/* reformat_cell structures, fills in any        */
/* initial information prior to sizing and       */
/* positioning (as in, coordinate origins) of    */
/* the cells.                                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the tables;           */
/*                                               */
/*             Pointer to the table_stream       */
/*             struct representing the table;    */
/*                                               */
/*             Pointer to the cell array.        */
/*                                               */
/* Assumes:    At least tables_count_table must  */
/*             have been called to work out how  */
/*             many rows and columns there are.  */
/*************************************************/
d494 22
a515 23
/*************************************************/
/* tables_find_actual_size()                     */
/*                                               */
/* Find the number of actual used rows and cols  */
/* in a table, ignoring whatever colspan and     */
/* rowspan attributes might say.                 */
/*                                               */
/* Expects each cell's RowOffs and ColOffs       */
/* fields to hold the row/column offset of that  */
/* cell within the table (tables_position_table  */
/* must have been called beforehand).            */
/*                                               */
/* Parameters: Pointer to a table_stream struct  */
/*             for the table;                    */
/*                                               */
/*             Pointer to an int, in which the   */
/*             number of columns is written;     */
/*                                               */
/*             Pointer to an int, in which the   */
/*             number of rows is written.        */
/*                                               */
/* Assumes:    The int pointers may be NULL.     */
/*************************************************/
d568 48
a615 55
/*************************************************/
/* tables_width_table()                          */
/*                                               */
/* Works out the widths in millipoints for all   */
/* cells in a given table. This is called by the */
/* reformatter routines as they try to find the  */
/* width of various page elements. To find out   */
/* the width of, and finally format a particular */
/* cell, this function then itself calls the     */
/* reformatter. This can of course then call     */
/* back here for nested tables - i.e. this is a  */
/* recursive function, though it's not           */
/* immediately obvious as the callers and        */
/* callees are spread over a wide area of code.  */
/*                                               */
/* Because of the way tables define column       */
/* widths, for each cell three reformats take    */
/* place - minimum width find, maximum width     */
/* find, and final decided width.                */
/*                                               */
/* Coupled with all the juggling of those maxs   */
/* and mins - taking into account anything that  */
/* was specified in the HTML - this is something */
/* of a monster function and it is certainly not */
/* efficient at present. Hopefully this will     */
/* improve in a future interation of the tables  */
/* code...                                       */
/*                                               */
/* Parameters: 1 for a top level call, else 0 if */
/*             being called as part of a nested  */
/*             tables reformat session;          */
/*                                               */
/*             Pointer to a browser_data struct, */
/*             which is the parent of the table; */
/*                                               */
/*             Pointer to a table_stream struct  */
/*             relevant to the table;            */
/*                                               */
/*             The available width for the table */
/*             in millipoints;                   */
/*                                               */
/*             Pointer to an array of points to  */
/*             reformat_cell structures which    */
/*             will hold the final table layout; */
/*                                               */
/*             Flags as for reformat_token_width */
/*             - needed as the widthing routines */
/*             need to know if the widest a      */
/*             table can be is being found or    */
/*             not (for nested tables - avoids   */
/*             nested tables saying they're      */
/*             100% wide, say, ending up huge).  */
/*                                               */
/* Returns:    The table width, in millipoints.  */
/*************************************************/
d2311 29
a2339 33
/*************************************************/
/* tables_width_cell()                           */
/*                                               */
/* Returns the actual width of a given table     */
/* cell after attempting to reformat it to a     */
/* given width.                                  */
/*                                               */
/* Parameters: 1 for a top level call, 0 if      */
/*             being called as part of a nested  */
/*             table parse;                      */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             relevant to the table;            */
/*                                               */
/*             Pointer to the first HStream      */
/*             structure in the stream that the  */
/*             cell is to contain;               */
/*                                               */
/*             Pointer to the table_stream       */
/*             struct representing the table;    */
/*                                               */
/*             Pointer to the table's array of   */
/*             reformat_cell structures;         */
/*                                               */
/*             Allowed column width (millipts);  */
/*                                               */
/*             Row number of the cell;           */
/*                                               */
/*             Column number of the cell.        */
/*                                               */
/* Returns:    Actual width after formatting,    */
/*             in millipoints.                   */
/*************************************************/
d2354 25
a2378 28
/*************************************************/
/* tables_height_table()                         */
/*                                               */
/* Works out the heights in millipoints for all  */
/* cells in a given table. This may be called    */
/* from recursively called functions, but does   */
/* not enter into recursion itself as the height */
/* information for particular cells is stored    */
/* when finding the width - there's no need to   */
/* call the reformatter again.                   */
/*                                               */
/* Parameters: 1 for a top level call, else 0 if */
/*             being called as part of a nested  */
/*             tables reformat session;          */
/*                                               */
/*             Pointer to a browser_data struct, */
/*             which is the parent of the table; */
/*                                               */
/*             Pointer to a table_stream struct  */
/*             relevant to the table;            */
/*                                               */
/*             Pointer to an array of points to  */
/*             reformat_cell structures which    */
/*             will hold the final table layout. */
/*                                               */
/* Returns:    Height of the whole table, in     */
/*             millipoints.                      */
/*************************************************/
d2712 30
a2741 32
/*************************************************/
/* tables_height_cell()                          */
/*                                               */
/* Returns the height of a cell widthed by a     */
/* previous call to tables_width_cell.           */
/*                                               */
/* Parameters: 1 for a top level call, 0 if      */
/*             being called as part of a nested  */
/*             table parse;                      */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             relevant to the table;            */
/*                                               */
/*             Pointer to the first HStream      */
/*             structure in the stream that the  */
/*             cell is to contain;               */
/*                                               */
/*             Pointer to the table_stream       */
/*             struct representing the table;    */
/*                                               */
/*             Pointer to the table's array of   */
/*             reformat_cell structures;         */
/*                                               */
/*             Allowed column width (millipts -  */
/*             this is not used at present);     */
/*                                               */
/*             Row number of the cell;           */
/*                                               */
/*             Column number of the cell.        */
/*                                               */
/* Returns:    Cell height in millipoints.       */
/*************************************************/
d2777 18
a2794 19
/*************************************************/
/* tables_fix_table()                            */
/*                                               */
/* Having found the width and height of the      */
/* cells in a given table, and their row/column  */
/* offset from the top left, this fixes the      */
/* cell positions as x and y coordinates         */
/* in millipoints from the top left.             */
/*                                               */
/* Parameters: Pointer to a browser_data struct, */
/*             which is the parent of the table; */
/*                                               */
/*             Pointer to a table_stream struct  */
/*             relevant to the table;            */
/*                                               */
/*             Pointer to an array of points to  */
/*             reformat_cell structures which    */
/*             will hold the final table layout. */
/*************************************************/
d2938 30
a2967 34
/*************************************************/
/* tables_fix_cell()                             */
/*                                               */
/* Fixes the position of a given table cell as   */
/* an offset from the top left of the table in   */
/* millipoints.                                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             owning the table;                 */
/*                                               */
/*             Pointer to the first HStream      */
/*             structure in the stream that the  */
/*             cell is to contain;               */
/*                                               */
/*             Pointer to the table_stream       */
/*             struct representing the table;    */
/*                                               */
/*             Pointer to the table's array of   */
/*             reformat_cell structures;         */
/*                                               */
/*             X offset from top left, in        */
/*             millipoints;                      */
/*                                               */
/*             Yoffset from top left, in         */
/*             millipoints;                      */
/*                                               */
/*             Total cell width (millipoints);   */
/*                                               */
/*             Total cell height (millipoints);  */
/*                                               */
/*             Row number of the cell;           */
/*                                               */
/*             Column number of the cell.        */
/*************************************************/
d3008 28
a3035 31
/*************************************************/
/* tables_align_contents()                       */
/*                                               */
/* Once the cellheight field of a reformat_cell  */
/* struct is filled in, it is possible to look   */
/* at the VALIGN specification on the table      */
/* cell tag represented by the reformat_cell     */
/* struct and align the cell contents in an      */
/* appropriate fashion. This is done by          */
/* increasing the height of the first line as    */
/* required, shifting the y coordinate of all    */
/* subsequent lines as needed, and increasing    */
/* the used height value in the cell to match.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             owning the table;                 */
/*                                               */
/*             Pointer to the first HStream      */
/*             structure in the stream that the  */
/*             cell is to contain;               */
/*                                               */
/*             Pointer to the table_stream       */
/*             struct representing the table;    */
/*                                               */
/*             Pointer to the table's array of   */
/*             reformat_cell structures;         */
/*                                               */
/*             Row number of the cell;           */
/*                                               */
/*             Column number of the cell.        */
/*************************************************/
d3099 23
a3121 27
/*************************************************/
/* tables_free_memory()                          */
/*                                               */
/* Goes through the lines of a reformat_cell     */
/* structure, freeing all allocated memory       */
/* relating to any tables in that list; that is, */
/* the lines and chunks allocated in any assoc-  */
/* iated cells. Does not free the given cell's   */
/* line or chunk arrays, or any HTMLLib          */
/* allocated data such as the cell arrays        */
/* allocated through HTMLLib or the HStream      */
/* lists (HtmlStreamFree should be used for      */
/* those).                                       */
/*                                               */
/* Parameters: 1 for top level call, 0 for a     */
/*             recursive one (only used for the  */
/*             hourglass);                       */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             relevant to the tables;           */
/*                                               */
/*             Pointer to a reformat_cell struct */
/*             holding the line array;           */
/*                                               */
/*             Line number in that line array    */
/*             from which freeing is to start.   */
/*************************************************/
@


1.17
log
@Updated Hotlists - USNA HTML resources and 6025 TV room pages had moved,
MIDI themes is unreachable, Hensa has been restructured.

For table cells where the line or chunk data totals less than Flex_256_Point
bytes (see top of Memory.c, current value is 8192) there would be an over-
allocation of 1 byte per cell due to a (now fixed) bug in the granular
allocator.This would translate into 4 bytes wastage of course, and may
represent a small speed penalty depending on how flex works out block
word alignment.

Several entries in the Choices file were missing from save_save_choices in
its new form (see last check-in). Added back in. Ursula and Phoenix Res
files contained an incorrect component ID in pane 3 that was stopping the
'no scroll bars' option in pane 7 working correctly (duplicate component
ID). Res files corrected; TRACE builds will now spot such errors and give
a warning when they occur (in choices_find_component).

Table widthing code fixes:

 * Very wide table cell specifiers (e.g. TD WIDTH="2000") were ignored,
   but this isn't what Navigator / MSIE 4 do. This code was present
   because of other bugs in the widther, long since fixed. The code has
   been commented out - if the problem reappears the use of the code can
   be re-investigated, but as far as I can tell it isn't needed.

 * If two pixel specified cells appear one above the other, the first
   would always have been taken for use in the final width calculation
   even if it specified a smaller width than the second. The check was
   made to ensure that pixel specifiers were chosen in preference to
   other cells, which is OK, but it didn't notice if the current cell
   was also a pixel specifier! Fixed; you now get the widest.

 * The TRACE build 'Colspan cell xxx would have been width yyy, below
   minimum width of zzz' error should no longer happen. In a manner similar
   to the bug mentioned above, two cells above each other spanning the
   same columns with the lower cell narrower than the upper would end up
   with the narrower width. The code that trapped and corrected the error
   was not compiled out of release builds, even though the error message
   generation was, because the rendering would fail otherwise. The widther
   has now been fixed not to make this mistake and the final check is now
   strictly TRACE build only, thereby speeding up table widthing for
   non-TRACE builds.

 * Another use of MSIE4StyleTables option, for cellspacing; it's based
   on the actual used cells, rather than the maximum cell width caused
   by COLSPAN etc. So if you've a cell with a big COLSPAN but as a
   heading but the rest of the table only uses, say, 4 columns, you won't
   get a gap to the right which adds up to the spacing for all of the
   cells that the COLSPAN attribute in the heading implied. The option
   was actually intended as 'bad things when switched on', and though in
   this case it makes for a better rendering, it does hide an error in
   the HTML. Note Navigator 4 acts as Browse with MSIE4StyleTables off
   in this particular case. Oh, it works in both ways of course, so
   the table height routine had to be updated too. A new function,
   tables_find_actual_size, exists to support the feature in general.

Messages files updated to v2.05 (21-Apr-98). Help menu items renamed a
bit in Ursula, Phoenix and Customer Res files, but entries still point
to the same URLs. Phoenix button bar markers have been brought closer
together to stop them being visible when only the URL bar is meant to
be present.
@
text
@d238 1
a238 1
            for (I = 1; I < RowCount; I++)
d2777 7
a2790 7

  /* Add in the cell padding values to the top and bottom */

  cellpadmp = table->cellpadding * 4; /* 1 'web pixel' = 2 OS units, times two for top and bottom */
  convert_to_points(cellpadmp, &cellpadmp);

  c->height += cellpadmp;
@


1.16
log
@All !Run[D], Choices, Messages, Controls and Res files are up to date.

RefoKeep and RefoHold options added to, respectively, try and maintain
the line at the top of the visible area when reformatting, and not shrink
the vertical extent at the start of a reformat to try and avoid flicker
to the top of the page and back down again when RefoKeep is on. Choices
front-end implemented, which also allows RefoWait and RefoTime to be set.
Unfortunately for various reasons this doesn't help the page jumping when
unsized images come in (but RefoHold can improve matters...) - roll on
the image history.

DragToScroll and NoScrollBars options added for frames; included new
pointer type, Mouse_Shape_DTS, so relevant Controls file entries done
and Sprites[22] files updated as required. Noticed some builds have
a low-res ptr_link with a mask - mask removed.

Named anchor following fixed up somewhat - anchors near the bottom of
the page shouldn't be displayed, and then pulled down when the fetcher
releases null polls and ensures the y extent is correct (this through
implementing the min_height field in the browser_data structure).

RefoHang was never implemented and there seems little point to it now,
so the entry for it has been removed from the global choices structure
and all Choices files.

Markers menus should work properly now (in last check-in they would not
update correctly if Adjust was used on the entries).

URI handler usage now a lot more sensible, with configuration of how the
browser uses the module from both a Utils menu submenu (sic) and the
Choices dialogue.

Slightly dodgy 'hang around waiting for user input' stuff for the Cookies
dialogue box: All fetches are suspended; the fetcher remembers some info
about its state at the time the cookie came in, and restores it later; it
will only do this for one fetch at a time. It's necessary to single-thread
the fetcher at this point anyway, since other fetches may have a
dependency on the cookie that is hanging in mid-air at that point. As part
of this, some of the fetcher code has been split out into separate
functions (to try and 'black box' the code a bit). Anyway, Cookie Query
dialogue box now implemented with appropriate Choices file entry and
UI work in the Choices dialogue box.

Phoenix build Choices rearranged. Can now choose when the image history
is saved from the front end. Added also MSIE 4-style table option menu
for JPEG support (OS only, OS if it can handle it, internal only).

Should be a bit faster at loading the history - though 95% of the time
is spent in SWI URL_ParseURL. URL descriptions are stored more
efficiently as part of this - one malloc block instead of several
small blocks. The minimum block size for malloc blocks typically leads
to a significantly smaller startup wimpslot depending on the visit
history size.

Nasty bug in image system fixed. If an image size came in and a reformat
was to take place, the line the image lies in is found and the reformat
progresses from there. Unforunately, this didn't check to see if the
token can't be found in the line list, so it'd reformat from the top
of the page...! This would happen if, for example, an image halfway down
the page came in whilst a reformat for an image higher up had just begun.

In Choices.c, made choices_set_timetype_field, choices_set_uri_field,
choices_set_plugin_field, choices_set_cookie_field, and
choices_set_jpeg_field static (so they're not declared in Choices.h now).

Two memory leaks plugged in URL comparison routines in URLutils.c
(calling free() url_description instead of urlutils_free_descripton()).

Client pull reload handler was setting the reload flag if reloading
the same page, but forgetting to turn on reload_lock so
fetchpage_postprocessed was clearing the reload state... Similarly,
Ctrl+Shift+SELECT-Click on a link when the Controls file 'UseSmall'
entry is 'no' would not have reloaded as it should. Both fixed.

Frames shouldn't be so keen on acquiring horizontal scroll bars and never
letting them go when their width is decreased now. Frames set up for
'scrolling="yes"' will not start with no scroll bars and then gain them
shortly afterwards, causing flicker and two reformats - they'll start
with, and continue to hold, both scroll bars.

Pointer shouldn't flicker when over a frame border whilst other fetches
are progressing now.
@
text
@d76 2
a77 1
static void tables_align_contents(browser_data * b, HStream * streambase, table_stream * table, reformat_cell * cellarray, int Row, int Column);
d496 75
d631 1
a631 1
  int               I; // S, T; // For code commented out below
d652 1
a658 5
  // Trying to work out why the final 'are we underwidth' pass is needed,
  // but due to code freeze (29/01/1998) have to put this on hold... :-(
  //
  // Printf("Table %p, aw %d, flags %x\n",p,available_width/400,flags);

d805 6
a810 1
  if (finding_widest != 1)
d812 19
a830 1
    /* Decrease available width according to cell spacing constraints */
d832 5
a836 1
    if (p->ColSpan) available_width -= cellspacingmp * (p->ColSpan + 1);
d838 20
a857 1
    /* Decrease available width according to overall table border */
d859 3
a861 1
    available_width -= tbordmp * 2;
d978 19
a996 16
              if (finding_widest != 1)
              {
                /* Deal with garbage like 'TD WIDTH="2000"' - if a cell */
                /* wants to be wider than the table can be, ignore the  */
                /* width specifier completely.                          */

                if (width > available_width) width = -1;
              }
              else
              {
                /* Because this is a scan to find the widest limit of a table, */
                /* we can't use available_width to limit the item; so instead  */
                /* use the browser's display width as a second best option.    */

                if (width > display_width) width = -1;
              }
d1471 2
a1472 1
                /* already in use that specifies a pixel size                   */
d1474 9
a1482 1
                if (TD_HAS_WIDTH(lc) && TD_WIDTH_UNITS(lc) == UNITS_PIXELS)
d1484 3
a1486 2
                  /* May be forced to use this cell if the *minimum* value */
                  /* ends up greater than the maximum!                     */
d1858 7
d1866 1
a1866 1
                if (spanned_total < mins[cellnumber])
d1935 1
a1935 1
//  #ifdef TRACE
d1942 5
d1972 6
d1983 1
a1983 1
                          "Non-colspan cell %d would have ended up at %d OS units, below minimum width of %d",
d1986 3
a1988 1
                          mins[cellnumber] / 400);
d2058 6
d2069 1
a2069 1
                              "Colspan cell %d would have ended up at %d OS units, below minimum width of %d",
d2072 3
a2074 1
                              mins[cellnumber] / 400);
d2125 1
a2125 1
//  #endif
d2315 1
a2315 1
  if (p->ColSpan) max_table_width += cellspacingmp * (p->ColSpan + 1) + tbordmp * 2;
a2449 1

d2706 12
a2717 1
  if (p->RowSpan) ReturnHeight += cellspacingmp * (p->RowSpan + 1) + tbordmp * 2;
d2824 3
a2826 3
  int              cellcount     = 0;
  int              cellmax       = p->ColSpan * p->RowSpan;
  int              cellspacingos = p->cellspacing * 2; /* 1 'web pixel' = 2 OS units */
d2829 2
d2835 10
d2896 2
d2905 6
a2910 1
          Width += cellspacingmp * (D->ColSpan - 1);
d2919 2
d2926 5
d2933 1
a2933 1
          Height += cellspacingmp * (D->RowSpan - 1);
@


1.15
log
@RefoSingle option added to Controls.

Precautions taken in table code to avoid divide by zero errors.

Framesets defining more frames than the frameset implies, for whatever
reason, should never cause a crash now - just report a 'Frames definition
is badly nested' error (if STRICT_PARSER defined). Along the same lines,
in a single document defining a set of nested frames, two /FRAMESETs in
succession could cause a fairly nasty crash. Fixed.

TIFFs do not get loaded by double-click now.

If holding down SHIFT to save a link contents to disc, you can also hold
down CTRL to bypass the cache (sets the browser's reloading flag). Noticed
when testing this that windows_create_browser didn't take account of the
Controls file 'UseSmall' entry when adjust-shift-clicking on links. It
does now.

There is now a complete and up to date set of interactive help messages
built into the Ursula, Customer and Phoenix build Res files.
@
text
@d944 1
a944 1
      /* If the row has some unspecified cells, these aquire inferred           */
@


1.14
log
@*Don't* try to load FilterManager 0.18 in !Run[D] files. Requires
WindowManager 3.98. Sets URI handler environment variables for
http, ftp and gopher.

Fixed 'doesn't reformat for unsized images' bug - only happens when the
deferred reformatter is enabled, hadn't remembered to check this in my
debug build where this is turned off. Oops.

Caret position in forms could get left behind despite attempts to rectify
this in v1.31 - now fixed (and faster, fortunately).

Hourglass + percentage displayed for History and Image History when
loading - it can take a while for very big histories, though in
practice you only see the visit history loading (has to do a lot
more work, and is thus quite a bit slower than the image history).

POST forms worked when targetted to frames, but were broken when
not targetted! (Forms data inherited from one browser to the same
browser; ended up freeing the flex block...). Fixed.

Now support 303 response code (redirect to GET). Treated as 301, i.e.
not support if STRICT_PARSER is defined, otherwise drops through to
the 302 handling code.

Pointer shouldn't get stuck in odd shapes when going to a new page now;
it gets reset to a standard shape every time the null handler that
checks the position is called, though (whether or not the handler thinks
the pointer is over a different token, if that token is NULL, it sets
the standard shape). A possible work around would be for a browser to
remember the pointer shape too; that's for the future, though.

Early stage table formatting functions could blow themselves apart if
tables_count_table decided there were no rows, columns or both. A
net table size of zero cells is now dealt with; slow, partial table
fetches in multiple windows with image loading turned on will now
*hopefully* be stable, where v1.31 would have bombed out repeatedly.

A nested frameset within one document will now inherit the border
width (frame spacing) and border colour of its parent. This is done
by copying the maxlen and indent fields of the parent token over
the child, and note it's done in the browser (fetch_preprocess_token),
not HTMLLib.

Border colour on a FRAMESET now used, with the first colour on any
FRAME within it overriding, as in NN 4 and MSIE 4.

<LI> bullets really do stick to the text next to them now (I'd done
that in an experimental piece of code and forgotten to merge it back
before the last check-in).

Browse$HotlistURL/URIFile and Browse$HomeURL/URIFile now work from
_TaskName in the Messages file, and are thus of the generic form
<App>$HotlistURL etc. - Docs.Notes and Docs.User updated appropriately.

Event 0x11d00 through to 0x11d7f will make the browser look up Controls
file entries 'JumpTo00' through to 'JumpTo7f' and read a URL from them.
This will be fetched in the ancestor window of the source of the event,
or a new window if such an ancestor can't be found [for Daytona demo].

NB: Nasty frames-related crash at http://www.teledanmark.dk/menu/start.htm
is *not* fixed in this source. NOBR is not supported.
@
text
@d1041 5
a1045 1
                  infer = (100 - row_pc_total) / (p->ColSpan - have_percents);
d1049 5
a1053 1
                  infer = (100 - row_pc_total) / (p->ColSpan - (have_percents + have_pixels));
d1116 1
a1116 1
                    pcwidths[cellnumber] = ((100 - row_pc_total) * maxs[cellnumber]) / max_row;
d1120 1
a1120 1
                    pcwidths[cellnumber] = ((100 - row_pc_total) * maxs[cellnumber]) / max_row;
d1161 1
a1161 1
                  pc_based_width = (pcwidths[cellnumber] * pc_size) / min_pc;
d1481 1
a1481 1
                if (spanned_total_maxs < maxs[cellnumber])
d1729 1
a1729 1
                  int basic     = min_diff / D->ColSpan;
d1902 1
a1902 1
                    int basic     = min_diff / D->ColSpan;
d2049 1
a2049 1
          add = W * ((float) ColOffs[I] / (float) rw);
d2513 1
a2513 1
    basic     = difference / p->RowSpan;
d3056 1
a3056 1
    if (toplevel) _swix(Hourglass_Percentage, _IN(0), (100 * (d->nlines - l - 1)) / d->nlines);
@


1.13
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d290 11
a300 2
  if (p->ColOffs) HtmlFree(p->ColOffs);
  if (p->RowOffs) HtmlFree(p->RowOffs);
d306 5
a310 5
  p->ColOffs = HtmlMalloc(p->ColSpan * sizeof(int), p);

  if (!p->ColOffs) show_error_cont(make_no_table_memory_error(10));

  p->RowOffs = HtmlMalloc(p->RowSpan * sizeof(int), p);
d312 5
a316 1
  if (!p->RowOffs) show_error_cont(make_no_table_memory_error(11));
@


1.12
log
@Fixed some glitches in the modified status bar code (e.g. status inference
wasn't working properly).

Shift+Toggle size always opened to not obscure the icon bar. If CMOS is
set to always show the icon bar, then Shift+Toggle size is meant to
reverse sense and open to absolute full size. It now does this.

!Run[D] files now require URL 0.22, HTTP 0.64, FTP 0.22, Gopher 0.08
and File 0.32.

Minor overhaul of 'Docs.Notes' (with 'Docs.User' similarly updated) to
include a few new bits and pieces.

Timeout values of 0 now mean 'forever'. Plug-in status messages now have
their own timeout setting. New Messages token 'Actv' for extra info when
a status message times out and the status line drops to 'Viewing' or
'Ready' when there is still a Busy state registered by the Plug-in.

Small Fetch windows don't become visible briefly for Plug-in fetches
when the fetch is complete (for SeeFetches:no, where these windows
should be hidden all the time).

WebServe may be controlled through the Browse front-end via.
Wimp_MAppControl reason code 4 (Wimp_MAppControl_Configure). Note the
renaming internally of 'WebServ' or 'WebServe' has been changed to
'Proxy' (with lower case equivalents where relevant); proxy name
and starting details come from the Messages file 'ProxyName' and
'ProxyComm' tokens. More in 'Docs.Notes'.

Res files updated for image history and PRE/TT font aspect ratio
choices. 'Don't expire' labels changed to 'Expire' (oops, didn't
notice the change in the development Browse's Res file when I
updated all of the others until now...).

When printing, Wimp_PlotIcon appears to ignore R4 and R5, plots
'somewhere' on the page, and tries to get the sprite from the global
pool. This latter part normally causes an error to be raised; though
on my machine I just get a corrupted error message. The Desktop font
gets lost at this point too. All have yet to be fixed; as an
interim work around, Wimp_PlotIcon objects are never drawn at all
if the global 'printing' flag is set.
@
text
@d55 1
d122 6
a130 5
  /* Do an initial count of rows/columns just by following the */
  /* structures. This isn't sufficient in itself as rowspan or */
  /* colspan parameters can make the table larger than it      */
  /* initally seems.                                           */

d133 30
a162 1
    RowCount ++;
d237 1
a237 1
            for (I = 1; I < CorrectRowSpan(D,p); I++)
d243 1
a243 1
                if (D->ColSpan) RowSpill[index] += CorrectColSpan(D,p);
a247 1
          break;
d249 1
d270 1
a270 1
    if (tl & (1u<<20)) Printf("Rows, Cols: %d, %d\n", Rows, Cols);
d285 1
a285 1
  p->RowSpan = Rows;
d297 1
a297 1
  p->ColOffs = HtmlMalloc(Cols * sizeof(int), p);
d301 1
a301 1
  p->RowOffs = HtmlMalloc(Rows * sizeof(int), p);
d445 2
a446 1
/* positioning the cells.                        */
d455 4
d524 9
a532 1
/*             will hold the final table layout. */
d537 2
a538 1
int tables_width_table(int toplevel, browser_data * b, table_stream * p, int available_width, reformat_cell * cellarray)
d540 33
a572 22
  table_row      * R;
  table_headdata * D;
  int              I; // S, T; // For code commented out below
  int            * ColOffs;

  int              cellmax  = p->ColSpan * p->RowSpan;
  int              rowcount = 0;

  int              real_width,      new_width;
  int              min_table_width, max_table_width;
  int              remain_min,      remain_max;

  int            * mins,       * maxs;
  int            * overmins,   * overmaxs;

  int              have_colspans = 0;
  int              have_percents = 0;

  int              cellspacingos = p->cellspacing * 2; /* 1 'web pixel' = 2 OS units */
  int              cellspacingmp;

  int              tbordmp;
d583 4
a586 1
  /* Deal with specific table widths */
d588 13
a600 1
  if (TABLE_HAS_WIDTH(p))
d602 1
a602 1
    int width, dx;
d611 2
d618 5
a622 1
        width = (TABLE_WIDTH(p) * available_width) / 100;
d627 1
a627 1
    available_width = width;
d630 4
a633 2
  /* Allocate two arrays of ints to hold the minimum and maximum */
  /* widths of the table's cells.                                */
d645 1
d659 1
d671 1
d683 1
a683 1
  /* Decrease available width according to cell spacing constraints */
d685 1
a685 1
  if (p->ColSpan) available_width -= cellspacingmp * (p->ColSpan + 1);
d687 6
a692 1
  /* Decrease available width according to overall table border */
d694 36
a729 1
  available_width -= tbordmp * 2;
d749 4
d757 7
d785 1
a785 1
      switch(D->Tag)
a789 1
          int minw, maxw;
d795 2
d801 4
a804 1
            /* Will need to do another scan for colspan cells */
d808 7
a816 2
              /* Deal with specific cell widths */

d824 2
d827 1
d832 2
d836 1
a836 2
                  /* Need to deal with this after anything else, as % width specifiers */
                  /* mean 'n% of the space left after other cells have been widthed'.  */
d838 3
a840 1
                  have_percents = 1;
d845 16
a860 1
              maxs[cellnumber] = mins[cellnumber] = width;
d874 2
a875 13
                                      &minw,
                                      &maxw);

            /* Take the largest - the values found from the reformatter, */
            /* or any values specified in the cell.                      */

            if (minw > mins[cellnumber]) mins[cellnumber] = minw;
            if (maxw > maxs[cellnumber]) maxs[cellnumber] = maxw;

            /* Deal with garbage like 'TD WIDTH="2000"' - if a cell */
            /* wants to be wider than the table can be, ignore the  */
            /* width specifier completely and go with the values    */
            /* determined by the reformatter call.                  */
d877 12
a888 1
            if (width > available_width) maxs[cellnumber] = maxw, mins[cellnumber] = minw;
d890 1
a890 3
            /* Deal with rowspans */

            if (D->RowSpan > 1)
d892 2
a893 15
              int rsc, index;

              for (rsc = 1; rsc < CorrectRowSpan(D, p); rsc ++)
              {
                index = p->ColSpan * rsc + D->ColOffs;

                /* Sanity check */

                if (index >= cellmax) break;

                /* Write the values into the row */

                mins[index] = mins[cellnumber];
                maxs[index] = maxs[cellnumber];
              }
d909 5
a913 9
    /* Carry on for the other rows. */

    rowcount ++;
    R = R->Next;

  /* Closure of 'while (R && ...)' */
  }

  #ifdef TRACE
d915 1
a915 1
    if (tl & (1u<<20))
d917 31
a947 1
      int rowc,colc;
d949 1
a949 1
      Printf("\nTable size: mins\n");
d951 1
a951 1
      for(rowc=0;rowc<p->RowSpan;rowc++)
d953 1
a953 3
        Printf("%d: ",rowc);

        for(colc=0;colc<p->ColSpan;colc++)
d955 2
a956 56
          Printf("%d (%d) ",mins[rowc*p->ColSpan+colc],mins[rowc*p->ColSpan+colc]/400);
        }
        Printf("\n");
      }

      Printf("\nTable size: maxs\n");

      for(rowc=0;rowc<p->RowSpan;rowc++)
      {
        Printf("%d: ",rowc);

        for(colc=0;colc<p->ColSpan;colc++)
        {
          Printf("%d (%d) ",maxs[rowc*p->ColSpan+colc],maxs[rowc*p->ColSpan+colc]/400);
        }
        Printf("\n");
      }
      Printf("\n");
    }

  #endif

  /* Now have the mins and maxs arrays filled with the calculated */
  /* minimum and maximum size of some cells; those with no width  */
  /* specifier, those with a pixel size specifier, but not those  */
  /* with percentage specifiers yet.                              */
  /*                                                              */
  /* We now need to work out the overall greatest minimum and     */
  /* maximum width for each column. Any cells specifying a        */
  /* colspan > 1 are ignored in this, as they will have a large   */
  /* width (they span several cells, after all). We're only       */
  /* interested in single cells here.                             */
  /*                                                              */
  /* Must follow the linked list here to ensure that colspans are */
  /* known about and to ensure that spurious rowspan values, put  */
  /* into the array for the above percentage width calculation    */
  /* code to work, are not thought to represent real cell widths. */
  /*                                                              */
  /* The next step is to use this to find what is left of the     */
  /* available width for percentage width specifiers.             */

  R        = p->List;
  rowcount = 0;

  while (R && rowcount < p->RowSpan)
  {
    D = R->List;

    while (D && D->ColOffs < p->ColSpan)
    {
      switch(D->Tag)
      {
        case TagTableData:
        case TagTableHead:
        {
          if (D->ColSpan <= 1)
d962 21
a982 2
              if (mins[cellnumber] > overmins[D->ColOffs]) overmins[D->ColOffs] = mins[cellnumber];
              if (maxs[cellnumber] > overmaxs[D->ColOffs]) overmaxs[D->ColOffs] = maxs[cellnumber];
d985 1
a986 1
        break;
d988 1
a988 25
      /* Closure of 'switch (D->Tag)' */
      }

      D = D->Next;

    /* Closure of 'while (D && ...)' */
    }

    rowcount ++;
    R = R->Next;

  /* Closure of 'while (R && ...)' */
  }

  #ifdef TRACE

    if (tl & (1u<<20))
    {
      int colc;

      Printf("\nTable overall 1: mins\n");

      for(colc=0;colc<p->ColSpan;colc++)
      {
        Printf("%d (%d) ",overmins[colc],overmins[colc]/400);
a989 1
      Printf("\n\nTable overall 1: maxs\n");
a990 36
      for(colc=0;colc<p->ColSpan;colc++)
      {
        Printf("%d (%d) ",overmaxs[colc],overmaxs[colc]/400);
      }
      Printf("\n\n");
    }

  #endif

  /* OK, now deal with percentage specifiers. First, work out the */
  /* remaining widths.                                            */

  remain_min = remain_max = available_width;

  for (I = 0; I < p->ColSpan; I++)
  {
    remain_min -= overmins[I];
    remain_max -= overmaxs[I];
  }

  if (remain_min < 0) remain_min = 0;
  if (remain_max < 0) remain_max = 0;

  /* Now go through the table structure working out the widths from this, */
  /* doing it all on a cell by cell level.                                */

  if (have_percents)
  {
    int total_percents = 0;
    int none_specified = 0;

    R        = p->List;
    rowcount = 0;

    while (R && rowcount < p->RowSpan)
    {
a994 3
        /* First count up all of the % specifiers and */
        /* count how many cells specify nothing       */

d1000 3
a1002 1
            if (TD_HAS_WIDTH(D))
d1004 62
a1065 1
              if (TD_WIDTH_UNITS(D) == UNITS_PERCENT) total_percents += TD_WIDTH(D);
a1066 1
            else none_specified ++;
d1068 1
d1074 3
a1076 10
      /* We'll use the percent count to scale down % specifiers if the total */
      /* is > 100, as otherwise tables can force themselves to be wider than */
      /* the display width regardless of that width!                         */
      /*                                                                     */
      /* We'll use the count of cells with no width specifiers to imply a    */
      /* percent specifier equal to the (100 - percentage total) / number of */
      /* cells without a specifier. This way, tables which want to, say, do  */
      /* a 30% / 70% bar graph, can specify the left cell as 30% width but   */
      /* leave the right cell alone. There are tables out there that do      */
      /* this, hence the extra code (04/11/97).                              */
d1078 1
a1078 5
      D = R->List;

      while (D && D->ColOffs < p->ColSpan)
      {
        switch (D->Tag)
d1080 1
a1080 2
          case TagTableData:
          case TagTableHead:
d1082 2
a1083 1
            if (!TD_HAS_WIDTH(D) || TD_WIDTH_UNITS(D) == UNITS_PERCENT)
a1084 2
              int min_p_w;
              int max_p_w;
d1089 1
a1089 1
                int width_to_use;
d1091 1
a1091 4
                /* Work out what width we should actually use (see earlier comments for more). */
                /* First, the case where the row total of % specifiers exceeds 100%.           */

                if (total_percents > 100)
d1093 13
a1105 1
                  /* If we've no width specifier, there's no room left - give it zero */
d1107 3
a1109 1
                  if (!TD_HAS_WIDTH(D)) width_to_use = 0;
d1111 12
a1122 2
                  /* Otherwise use the cell specified width, scaled down so the row */
                  /* total doesn't exceed 100%.                                     */
d1124 1
a1124 2
                  else width_to_use = (TD_WIDTH(D) * 100) / total_percents;
                }
d1126 9
a1134 1
                /* Now the case where the row total <= 100%. */
d1136 3
a1138 1
                else
d1140 1
a1140 7
                  /* If a width is specified, use it */

                  if (TD_HAS_WIDTH(D)) width_to_use = TD_WIDTH(D);

                  /* If no width is used, use a fraction of whatever is left over */
                  /* in percentage terms after all of the specifying cells have   */
                  /* been counted.                                                */
d1142 1
a1142 1
                  else width_to_use = (100 - total_percents) / none_specified;
d1144 4
d1149 3
a1151 1
                /* Now churn the relevant numbers through the cell width arrays */
d1153 7
a1159 2
                min_p_w = (remain_min * width_to_use) / 100;
                max_p_w = (remain_max * width_to_use) / 100;
d1161 3
a1163 3
                #ifdef TRACE
                  if (tl & (1u<<20)) Printf("min_p_w, max_p_w: %d, %d\n", min_p_w, max_p_w);
                #endif
d1165 1
a1165 1
                /* Does this work out larger than values already obtained? */
d1167 1
a1167 2
                if (min_p_w > mins[cellnumber]) mins[cellnumber] = min_p_w;
                if (max_p_w > maxs[cellnumber]) maxs[cellnumber] = max_p_w;
d1169 8
a1176 1
                /* Deal with rowspans */
d1178 6
a1183 7
                if (D->RowSpan > 1)
                {
                  int rsc, index;

                  for (rsc = 1; rsc < CorrectRowSpan(D, p); rsc ++)
                  {
                    index = p->ColSpan * rsc + D->ColOffs;
d1185 1
a1185 1
                    /* Sanity check */
d1187 1
a1187 10
                    if (index >= cellmax) break;

                    /* Write the values into the row */

                    mins[index] = mins[cellnumber];
                    maxs[index] = maxs[cellnumber];
                  }
                }

              /* Closure of 'if (cellnumber < cellmax)' */
d1190 1
a1191 1
          break;
d1193 1
a1193 1
        /* Closure of 'switch (D->Tag)' */
d1196 1
a1196 18
        D = D->Next;

      /* Closure of 'while (D && ...)' */
      }

      rowcount ++;
      R = R->Next;

    /* Closure of 'while (R && ...)' */
    }

    /* Tedious but true - we now have to rescan the updated   */
    /* mins and maxs array to see if the percentage specified */
    /* cells will affect the overall column sizes in overmins */
    /* and overmaxs.                                          */

    R        = p->List;
    rowcount = 0;
d1198 1
a1198 3
    while (R && rowcount < p->RowSpan)
    {
      D = R->List;
d1200 1
a1200 3
      while (D && D->ColOffs < p->ColSpan)
      {
        switch(D->Tag)
d1202 1
a1202 2
          case TagTableData:
          case TagTableHead:
d1204 2
a1205 1
            if (D->ColSpan <= 1)
d1208 1
d1212 6
a1217 2
                if (mins[cellnumber] > overmins[D->ColOffs]) overmins[D->ColOffs] = mins[cellnumber];
                if (maxs[cellnumber] > overmaxs[D->ColOffs]) overmaxs[D->ColOffs] = maxs[cellnumber];
d1220 1
a1221 1
          break;
d1223 1
a1223 1
        /* Closure of 'switch (D->Tag)' */
d1225 4
d1230 5
a1234 1
        D = D->Next;
d1236 1
a1236 2
      /* Closure of 'while (D && ...)' */
      }
d1238 1
a1238 2
      rowcount ++;
      R = R->Next;
d1240 3
a1242 2
    /* Closure of 'while (R && ...)' */
    }
d1244 1
a1244 1
    #ifdef TRACE
d1246 1
a1246 1
      if (tl & (1u<<20))
d1248 1
a1248 3
        int colc;

        Printf("\nTable overall 2 (post-percents): mins\n");
d1252 1
a1252 1
          Printf("%d (%d) ",overmins[colc],overmins[colc]/400);
d1254 8
a1261 1
        Printf("\n\nTable overall 2 (post-percents): maxs\n");
d1265 1
a1265 1
          Printf("%d (%d) ",overmaxs[colc],overmaxs[colc]/400);
d1267 1
a1267 1
        Printf("\n\n");
d1269 2
d1272 49
a1320 1
    #endif
d1322 3
a1324 2
  /* Closure of 'if (have_percents)' */
  }
d1326 2
d1329 4
d1334 17
d1352 2
d1355 2
d1358 1
d1360 1
d1362 3
a1364 10
// ***************** DON'T FORGET!
// That the old tables source
// has the better distribution code base on the
// RFC1942 table autowidth stuff.
// *****************
//
// 18/10/97 (ADH) Is it better? Seems so in theory but in
// practice the existing code seems to do OK. Sigh; I still
// need to rewrite it for those CNET and Onion tables. Or
// patch it up, or whatever.
d1366 1
d1368 4
d1373 1
d1375 6
d1382 1
d1401 1
a1401 1
        switch(D->Tag)
d1412 2
d1417 3
a1419 1
                /* Count the spanned columns */
a1425 15
                    spanned_total_mins += overmins[currcol],
                    spanned_total_maxs += overmaxs[currcol];

                #ifdef TRACE

                  if (tl & (1u<<20)) Printf("spanned total maxs, mins: %d, %d (%d, %d)\n",
                                           spanned_total_mins,
                                           spanned_total_maxs,
                                           spanned_total_mins/400,
                                           spanned_total_maxs/400);
                #endif

                /* If not big enough, distribute the difference over the columns */

                if (spanned_total_mins < mins[cellnumber])
d1427 2
a1428 3
                  int min_diff  = mins[cellnumber] - spanned_total_mins;
                  int basic     = min_diff / D->ColSpan;
                  int remainder = min_diff - (basic * D->ColSpan);
d1430 3
a1432 1
                  /* Distribute for minimums, handling rounding carefully */
d1434 1
a1434 12
                  for (
                        currcol = D->ColOffs;
                        currcol < D->ColOffs + D->ColSpan && currcol < p->ColSpan;
                        currcol ++
                      )
                  {
                    if (remainder < 0)
                    {
                      overmins[currcol] += basic - 1;
                      remainder ++;
                    }
                    else if (remainder > 0)
d1436 2
a1437 2
                      overmins[currcol] += basic + 1;
                      remainder --;
a1438 1
                    else overmins[currcol] += basic;
d1442 17
a1458 1
                /* Same for maximums */
d1462 13
a1474 3
                  int max_diff  = maxs[cellnumber] - spanned_total_maxs;
                  int basic     = max_diff / D->ColSpan;
                  int remainder = max_diff - (basic * D->ColSpan);
d1482 6
a1487 1
                    if (remainder < 0)
d1489 11
a1499 2
                      overmaxs[currcol] += basic - 1;
                      remainder ++;
d1501 8
a1508 6
                    else if (remainder > 0)
                    {
                      overmaxs[currcol] += basic + 1;
                      remainder --;
                    }
                    else overmaxs[currcol] += basic;
d1535 2
d1540 5
d1550 1
a1550 1
  if (min_table_width > available_width)
d1552 3
a1554 1
    /* Assign minimum widths */
d1574 2
a1575 3
  /* Otherwise, do the maximum widths fit in? If so, assign the minimum */
  /* widths (and in future - not implemented yet - possibly linearly    */
  /* expand those widths out to fill the given space).                  */
d1577 1
a1577 1
  else if (max_table_width <= available_width)
d1589 5
d1625 1
d1632 6
d1656 289
d1951 1
a1951 1
  /* Did the table specify a width to fit to? */
d1953 1
a1953 1
  if (TABLE_HAS_WIDTH(p))
d1958 5
a1962 1
    if (real_width && real_width < available_width)
d1964 43
a2006 1
      float W, add = 0;
d2012 1
a2012 1
      W = (float) available_width - (float) real_width;
d2016 13
a2028 1
        add = W * ((float) ColOffs[I] / (float) real_width);
d2030 1
a2030 1
        ColOffs[I] += (int) add;
d2032 4
a2035 3
        #ifdef TRACE
          if (tl & (1u<<20)) Printf("%d: %d OS units\n", I, ColOffs[I] / 400);
        #endif
d2042 1
a2042 1
        if (tl & (1u<<20)) Printf("...can't, real_width = 0\n");
d2050 1
a2050 1
  /* We've finished with the temporary mins and maxs arrays */
d2056 2
d2070 1
a2070 1
      switch(D->Tag)
a2105 26

// Never should be run, but low overhead to check it
// and adds robustness; so keep this code?
//
//          /* If the returned width is greater than the cell width worked */
//          /* out above, distribute that extra width evenly through the   */
//          /* columns that the tag spans.                                 */
//
//          if (new_width < real_width)
//          {
//            T = real_width - new_width;
//
//            if (D->ColSpan) C = D->ColSpan;
//            else            C = 1;
//
//            T = T / C;
//
//            for (I = 0; I < C; I++)
//            {
//              // Should keep the lowest value too if S<0 somewhere else...
//
//              S = (ColOffs[D->ColOffs + I] >= 0) ? 1 : -1;
//
//              ColOffs[D->ColOffs + I] += S * T;
//            }
//          }
d2248 28
a2275 28
//  /* Deal with specific table heights - we may need */
//  /* to scale everything up to these afterwards.    */
//
//  if (TABLE_HAS_HEIGHT(p))
//  {
//    int height = 0, dy;
//
//    switch (TABLE_HEIGHT_UNITS(p))
//    {
//      default:
//      case UNITS_PIXELS:
//      {
//        convert_to_points(wimpt_dy(), &dy);
//        height = TABLE_HEIGHT(p) * dy;
//      }
//      break;
//
//      case UNITS_PERCENT:
//      {
//        convert_to_points(redraw_display_height(b, NULL), &height);
//
//        height = (TABLE_HEIGHT(p) * height) / 100;
//      }
//      break;
//    }
//
//    scale_height = height;
//  }
d2482 40
a2521 1
  for (I = 0; I < p->RowSpan; I++) ReturnHeight += RowOffs[I];
d2723 1
a2723 1
        switch(D->Tag)
@


1.11
log
@Implemented Message_PlugIn_ReshapeRequest, Message_PlugIn_Status and
Message_PlugIn_Busy. Plug-in code more robust when given invalid
browser instance handles by the plug-in.

Line spacing is now calculated on the basis of the normal style base serif
font, with all other fonts being forced into that line height. This does
mean that an unusually tall (say) sans serif font may get clipped. It
appears to be the only way to get around wildly different baseline
depths returned from the font metrics - you can't work out line spacing
based on each different font style; the line spacing will vary.

Table heighting (as opposed to widthing...) improved considerably; rowspan
can no longer cause very tall cells in odd places. Having trouble getting
rid of the single pixel breaks between vertically adjacent cells, though
I've not tried too hard. Widthing, though, seems fairly badly broken at
present... :-/

Set/clear of page_is_text flag made more robust (it looked as though there
was the potential for this to get stuck in a set state, though I've never
see the front-end behave in a manner which indicates this is the case).
The reformatter will now decrease leading if this flag is set (plain text
pages look daft with a line spacing that is OK for 'rich' text pages).
No reformatting is done if the page width changes by dragging on the
resize icon, though toggle size / full screen will still reformat even
if the contents are only text (browser needs to sort out various width
flags at this point).

Cut down on excessive redrawing when reformatting due to a change in
window dimensions is not done. If display_width hasn't changed, then no
redraw is needed. If this causes redraw problems, then whatever is
changing display_width needs investigating. It shouldn't be kludged
(basically) by forcing a redraw instead of a reformat.

TT/PRE/etc. text can now have a non-100% aspect ratio. 80-90% looks
best (ArcWeb, for example, uses 86%). New option 'TTAspect' in
the Choices files.

Debug builds link to a non-debug Unicode library now; stops stderr
being dumped to the bottom left of the screen if you've not redirected
it in the Run file.

RISC OS 3.1 seems to need more initial WimpSlot than later OS versions.
The 64 deep nested table set gives a 'No stack for trap handler' error
(which it really means in this case!) without 800K, even though 3.71
is happy with just 640K. So, the !Run file checks if Boot$OSVersion
is exactly 300, 310 or 311, and sets the WimpSlot accordingly.

!Run[D] files now require latest fetcher module versions (URL 0.21,
File 0.31, HTTP 0.58).
@
text
@a1623 1
  int              cellcount     = 0;
@


1.10
log
@Image history can be emptied from the History menu.

Significant reduction in number of times reformatter is called during
a table widthing session results in a dramatic speed increase for nested
tables (e.g. 64 deep with a paragraph of text in the deepest table takes
about two seconds to load with near-instantaneous subsequent reformats,
as opposed to taking optimistically 28 days for a 32 deep table!).
This code relies on a very big stack of assumptions...

Save as plain text implemented.

Choices, Messages and Res files brought up to date where necessary.
Version number taken to 1.28, 04-Dec-97 (so I don't forget later,
basically...).
@
text
@d1678 1
a1678 1
  /* Now find the height of all of the cells */
d1680 1
a1680 1
  while (R && cellcount < cellmax && Row < p->RowSpan)
d1684 3
a1686 1
    while (D && cellcount < cellmax && Row < p->RowSpan)
d1693 1
a1693 1
          /* Work out the width that this cell uses */
d1695 1
a1695 1
          if (D->ColOffs < p->ColSpan && D->RowOffs < p->RowSpan)
d1711 5
a1715 5
            /* Find the required cell height (this is not   */
            /* a recursive call - the height is stored in   */
            /* the relevant place by tables_width_cell called from  */
            /* tables_width_table above, which is where the */
            /* recursion is handled).                       */
d1726 3
a1728 1
            if (TD_HAS_HEIGHT(D) && TD_HEIGHT_UNITS(D) == UNITS_PIXELS) /* Can't see how a cell height in % could possibly be meaningful... */
d1730 3
a1732 1
              int dy, hc;
d1734 4
a1737 1
              convert_to_points(2, &dy); /* Authors assume square pixels, so do a 2 OS unit to 1 pixel scaling */
d1739 8
a1746 1
              hc = TD_HEIGHT(D) * dy;
d1751 59
d1811 8
a1818 2
            if (D->RowSpan) C = CorrectRowSpan(D, p);
            else            C = 1;
d1820 1
a1820 1
            /* Distribute the height over the rows this cell spans */
d1822 3
a1824 1
            Height = Height / C;
d1826 25
a1850 1
            for (I = 0; I < C; I++)
d1852 11
a1862 1
              if (Height > RowOffs[Row + I]) RowOffs[Row + I] = Height;
a1868 2
      cellcount++;

d1873 1
a1873 1
      if (tl & (1u<<20)) Printf("tables_height_table: Row %d, height %d (%d OS)\n", Row, RowOffs[Row], RowOffs[Row] / 400);
a1875 2
    ReturnHeight += RowOffs[Row];

d1878 1
a1878 1
    R=R->Next;
d1880 4
@


1.9
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d437 3
a439 1
    cellarray[i].table = table;
d2245 1
d2247 5
@


1.8
log
@fetch_get_raw_data will notice if up->fetching is zero and return a
'finished' status rather than trying to continue reading data for the
fetch. Fetches should never fall through that far but at least it
will cope if they do.

3D table borders are now supported. 2D borders are used if the
inter-cell spacing is too small to fit the borders in (display resolution
dependent) - the external table border is 2D if the internal borders are,
else 3D. For cellspacing of 0, internal table borders must plot over the
outer edge of pixels inside the cell; for all greater spacings, the
borders take up all or part of the gap between them. The external border
will always fit around the outside of the cells, including the
cellspacing value in the gap between the outer cells and the border.

Anti-alias colour for placeholder ALT text was incorrect. Fixed.

I'd changed 'point' to 'points' in some of the Font Choices dialogues;
now changed back to 'point'.

The routine to find out how large an otherwise unsized object or image
placeholder based on its ALT text has been centralised in Reformat.c,
so that the image and object routines can both access it without
code duplication (this means non-image objects will now have the correct
size if they contain ALT text, rather than assuming a standard default
size as before). ALT text in images that were also objects was never
plotted either, though the placeholder size would have been correct.
This has been fixed.
@
text
@d718 4
a721 2
            /* Deal with people who specify 'TD WIDTH="2000"'. It's annoying */
            /* having to do this, but necessary.                             */
d723 1
a723 8
            if (width > 0)
            {
              /* OK, if the maximum width the cell requires is less than half of what the cell asks */
              /* for, then ignore the cell and use the reformatter values. Reformatter rocks, yay,  */
              /* etc. Wobbly as it is, it still beats the average Web Master hands down...          */

              if (maxw * 2 < width) maxs[cellnumber] = maxw, mins[cellnumber] = minw;
            }
d905 3
d917 35
a951 1
        switch(D->Tag)
d956 1
a956 1
            if (TD_HAS_WIDTH(D) && TD_WIDTH_UNITS(D) == UNITS_PERCENT)
d964 36
a999 2
                min_p_w = (remain_min * TD_WIDTH(D)) / 100;
                max_p_w = (remain_max * TD_WIDTH(D)) / 100;
d1621 1
d1646 31
@


1.7
log
@Weird - the line registering the ENavigateToBeShown event disappeared from
Main.c, so the last log was incorrect; Navigate menu items wouldn't have
been greyed out. Probably a(nother?) CVS update screw up on my part; now
fixed. This sort of thing is happening far too often...

Font manager would crash in system font or if a font face was not found
in the previous release - that hacky business of returning weird font
handles when system font is to be used instead ensured a rather less than
valid array reference on behalf of fm_claim_basic_typefaces.

Added in a few more calls to the 'check the button bar' routines, to
ensure that things like Stop are greyed/ungreyed when needed.

Cellpadding code could lead to rmarg overlapping lmarg, or the sum
being greater than dwidth, or something like that (!) in the reformatter.
Anyway the results were unpleasant; this has been sorted out by range
checking right and left margins w.r.t. display width in the relevant
section of the code.

People who specify 'td width = 2000' in tables expecting to get something
sensible now do, though I was half inclined to leave it alone... I can
only assume that they don't know about % specification or it didn't
work in their browser at authorship time, and the huge width served as
an attempt to get the table to fill the available window width. Anyway,
the table reformatter spots when the maximum width a cell requires is
less than half of what it asks for, and ignores the width specifier if
this is the case.
@
text
@d514 2
d523 1
d601 5
a605 1
  if (p->ColSpan) available_width -= cellspacingmp * (p->ColSpan - 1);
d1461 3
a1463 2
  /* Must of course add in whatever we subtracted from available   */
  /* width to allow for cellspacing to the returned table width... */
d1465 1
a1465 1
  if (p->ColSpan) max_table_width += cellspacingmp * (p->ColSpan - 1);
d1559 1
d1564 1
d1668 1
a1668 1
  /* Add in cell spacings */
d1670 1
a1670 1
  if (p->RowSpan) ReturnHeight += cellspacingmp * (p->RowSpan - 1);
d1781 1
d1784 1
d1808 1
a1808 1
        CurX = 0;
d1818 1
a1818 1
        CurY = 0;
@


1.6
log
@Sorted out Res files, including fixing position of 'bytes' label in one
of the Choices dialogues (I'd missed it out of a selection when everything
else got moved down a bit). Unfaded Enc_Chinese menu entries, made sure
text labels were wide enough for system font, changed 'Apply' on Choices
dialogue to 'Set', and added ^K to hotlist keyboard shortcut lists.
Print Setup (i.e. Print dialogue) buttons all set to 'local', so the
stupid Toolbox doesn't close the dialogue and lose the caret before I
can see if it was in there to start with...

256 colour hotlist sprites taken back to standard 16 colour versions,
since there's a significant speed penalty on slower machines. The
testbed browser still has the 256 colour versions so the designs aren't
completely lost.

Changed access settings to exported builds to wr/r - lr/r was really getting
on my nerves whenever I wanted to try something temporary out.

View source, save source and print handlers would all try to work if
there was no source to act on - despite the fact that toolbar buttons
would be greyed out form them. This is fixed.

The Navigate menu has components greyed to match the toolbar state,
when opened. It isn't kept up to date dynamically, though this shouldn't
really be a problem (reopen the submenu...). As part of this, finally
sorted out conditions for the Stop button to be greyed, or the
GoTo/Go/Stop tristate to be at 'Stop' versus 'GoTo'.

Deferred reformatting is now disabled for external image fetches.

Browser-local client pull flag removed; hitting the Stop button simply
cancels any null handlers working for it. That way, client pull switches
back on in passing at the next fetch (it was never really switched off).
So to stop client pull, hit the stop button at any point.

Done CELLPADDING attribute; cellpadding field in reformat_cell (Global.h)
is redundant since the table token is accessible from there, and so it has
been removed. CELLSPACING support also added.
@
text
@d649 1
a649 1
          int width      = 0;
d710 12
@


1.5
log
@Calling HtmlEndParse at the end of html_get_next_token and setting
up->context to NULL was wrong; fetch_fetcher would end up recalling
html_get_next_token later which would then call HtmlParse even though
the document parse had just finished! The HtmlEndParse call has now
been moved to fetch_stop.

Altered reformatter to claim fonts inside a browser, rather than
claiming them for nothing and losing them afterwards.

Got rid of TAG == TABLE and ISBODY tests, replacing with tagno == TAG_TABLE.
Removed all references to TD, TH, TR and TABLE in the style word.
@
text
@d511 2
a512 1
  int              padding;
d518 3
a520 2
  if (cellmax) padding = tables_cell_padding(b, &cellarray[0]);
  else return 1600;
d596 4
d1050 6
d1379 1
a1379 1
              if (index < p->ColSpan) new_width += abs(ColOffs[index]) - padding;
d1442 5
d1535 6
a1540 3
  int              cellcount = 0;
  int              cellmax   = p->ColSpan * p->RowSpan;
  int              padding;
d1542 1
a1542 2
  if (cellmax) padding = tables_cell_padding(b, &cellarray[0]) * 2;
  else return 1600;
d1646 6
d1696 1
d1716 7
d1755 6
a1760 2
  int              cellcount = 0;
  int              cellmax   = p->ColSpan * p->RowSpan;
d1790 1
a1790 1
            CurX += abs(ColOffs[I]);
d1800 1
a1800 1
          for(I = 0; I < D->RowOffs; I++)
d1802 1
a1802 1
            CurY -= abs(RowOffs[I]);
d1817 4
d1833 4
d1918 1
a1918 1
  /* Post-correct Y for VALIGN considerations */
d1969 1
d1978 2
d2003 2
d2009 1
a2009 1
    if (valign_offset_mp)
a2155 25
}

/*************************************************/
/* tables_cell_padding()                         */
/*                                               */
/* Works out the cell padding (internal top,     */
/* left, right and bottom margin) for a given    */
/* table cell, in millipoints.                   */
/*                                               */
/* Returns: Cell padding (internal margin), in   */
/*          millipoints.                         */
/*************************************************/

int tables_cell_padding(browser_data * b, reformat_cell * cell)
{
  int margin = TABLES_DEFAULT_CELLPADDING;

// This works, but the external stuff that calls it will start messing
// up for non-zero returns, since I didn't get the time to finish the
// implementation. **AGAIN**. To be continued (perhaps).
return 0;

  if (TABLE_HAS_CELLPADDING(cell->table)) convert_to_points(TABLE_CELLPADDING(cell->table) * wimpt_dx(), &margin);

  return margin;
@


1.4
log
@Support for ANT URL broadcast message added.

Image deletion routines rewritten; nasty animated GIF bug now gone
(it kept trying to update the cross-referenced image in the browser that
no longer existed, and I've no idea how animated GIFs ever managed to *not*
blow up if a cross referencing browser was shut down; and I've tested
this...). There are now as many image structures as there are total images
in the visible browsers, and no more; cross referenced images in the
to-be-deleted browser have their ownership moved to the cross
referencer before the cross referencee is wiped, with any required fetches
being transferred with them.

Reformatter sped up a bit by getting rid of strlen on the main text field
of tokens in all places bar one, where it is called extremely rarely. This
means direct app-to-app transfer of, say, a 359K text file to the browser
won't run like a drain as it tries to do strlen on a 359K string over and
over again! Most of the time the performance benefits won't really be
noticable, but on the above text file, formatting time went down from
290 seconds before the change to just under 7 seconds, a 41 fold speed
increase or thereabouts (SA110 228MHz).

MakeFile changed to force function name compilation on for debug builds
(-fn in the DD...FLAGS); useful for certain functions such as
register_null_handler, which can now output the name of the function
being registered.

...Which helped show up some nasties in the animation handler and animation
drift handler registration/deregistration process, which have been fixed
(callers of fetchpage_release_nulls were unaware that the drift handler
could be installed, and fragments of old code checking choices.anim_drift
had a value other than 1 or 0 were still hanging around - bit tricky for
a single bit item).

Added support for VALIGN in table cells. Spotted a bug or two in the
'what token is the pointer over' routines as a result, and fixed them - the
worst was in browser_line_at_y, which checked the y coordinate was below
the given one [the mouse], but didn't check the line height to see if the
given y coordinate was *within* the line, rather than just above it. Never
used to matter pre-tables, but a definite concern once multiple line
arrays can exist on one page.
@
text
@d2031 1
a2031 1
      if (d->cdata[c].t->tag == TABLE && ISBODY(d->cdata[c].t))
d2094 1
a2094 1
      /* Closure of 'if (d->cdata[c].t->tag == TABLE && ISBODY(d->cdata[c].t))' */
@


1.3
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d73 4
d1587 1
a1587 1
              convert_to_points(wimpt_dy(), &dy);
a1681 5
  /* a second pass is required because the width may have changed  */
  /* currently this is kludge to save throwing away all the memory */
  /* add it back when a throw-away routine exists                  */
  /* method is then... tables_width_table,ThrowAway,tables_height_table            */

d1822 2
a1823 3
/* Parameters: 1 for a top level call, 0 if      */
/*             being called as part of a nested  */
/*             table parse;                      */
d1853 2
a1854 2
  int             cellindex = Row * table->ColSpan + Column;
  reformat_cell * c;
a1864 4
  /* OK, so not used for now, but may be - this is to avoid a compiler warning */

  b = b;

d1873 100
d1974 1
a1974 1
    if (tl & (1u<<20)) Printf("tables_fix_cell: Exitting\n");
@


1.2
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@d151 1
a151 6
  if (!RowSpill)
  {
    make_no_table_memory_error(1);

    show_error_cont(&erb);
  }
d264 1
a264 6
  if (!p->ColOffs)
  {
    make_no_table_memory_error(10);

    show_error_cont(&erb);
  }
d268 1
a268 6
  if (!p->RowOffs)
  {
    make_no_table_memory_error(11);

    show_error_cont(&erb);
  }
d320 1
a320 6
  if (!RowSpill)
  {
    make_no_table_memory_error(2);

    show_error_cont(&erb);
  }
d546 1
d549 1
a549 2
    make_no_table_memory_error(3);
    show_error_ret(&erb);
d559 1
a559 2
    make_no_table_memory_error(4);
    show_error_ret(&erb);
d573 1
a573 2
    make_no_table_memory_error(5);
    show_error_ret(&erb);
d585 1
a585 2
    make_no_table_memory_error(6);
    show_error_ret(&erb);
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d17 3
a19 1
/* Purpose: Table handling functions               */
d21 1
@

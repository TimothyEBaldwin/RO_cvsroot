head	1.42;
access;
symbols
	Browse-2_16:1.42
	Browse-2_15:1.42
	Browse-2_14:1.42
	Browse-2_13:1.42
	Browse-2_12:1.42
	Browse-2_11:1.41
	Browse-2_10:1.41
	Browse-2_09:1.40
	ahodgkin_208_i4_2:1.40
	ahodgkin_208_i4:1.38
	ahodgkin_208_i3:1.38
	ahodgkin_208_i2:1.38
	ahodgkin_208_i1:1.38
	ahodgkin_207release:1.38
	ahodgkin_206release:1.37
	ahodgkin_205release:1.36
	ahodgkin_204release:1.36
	ahodgkin_202release:1.36
	ahodgkin_201release:1.35
	ahodgkin_200release:1.35
	ahodgkin_133beta:1.35
	ahodgkin_132beta:1.35
	ahodgkin_131beta:1.35
	ahodgkin_130beta:1.34
	ahodgkin_129:1.34
	ahodgkin_128beta:1.32
	ahodgkin_128alpha:1.32
	ahodgkin_127beta2:1.32
	ahodgkin_127beta:1.32
	ahodgkin_126beta:1.30
	ahodgkin_AW97patch:1.30
	ahodgkin_AW97:1.29;
locks; strict;
comment	@# @;


1.42
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.26.17.15.25;	author ahodgkin;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.14.08.45.06;	author ahodgkin;	state Exp;
branches;
next	1.39;

1.39
date	2000.05.31.15.58.35;	author ahodgkin;	state Exp;
branches;
next	1.38;

1.38
date	98.09.07.11.46.48;	author ahodgkin;	state Exp;
branches;
next	1.37;

1.37
date	98.07.09.10.27.10;	author ahodgkin;	state Exp;
branches;
next	1.36;

1.36
date	98.03.20.12.12.40;	author ahodgkin;	state Exp;
branches;
next	1.35;

1.35
date	98.01.31.10.55.20;	author ahodgkin;	state Exp;
branches;
next	1.34;

1.34
date	97.12.12.17.12.23;	author ahodgkin;	state Exp;
branches;
next	1.33;

1.33
date	97.12.12.11.17.52;	author ahodgkin;	state Exp;
branches;
next	1.32;

1.32
date	97.11.20.16.04.36;	author ahodgkin;	state Exp;
branches;
next	1.31;

1.31
date	97.11.19.10.28.59;	author ahodgkin;	state Exp;
branches;
next	1.30;

1.30
date	97.10.16.14.37.03;	author dbrown;	state Exp;
branches;
next	1.29;

1.29
date	97.10.16.13.23.12;	author ahodgkin;	state Exp;
branches;
next	1.28;

1.28
date	97.10.03.10.38.44;	author kbracey;	state Exp;
branches;
next	1.27;

1.27
date	97.09.29.11.10.02;	author dbrown;	state Exp;
branches;
next	1.26;

1.26
date	97.09.26.12.36.00;	author ahodgkin;	state Exp;
branches;
next	1.25;

1.25
date	97.09.24.11.14.17;	author ahodgkin;	state Exp;
branches;
next	1.24;

1.24
date	97.09.22.07.43.16;	author ahodgkin;	state Exp;
branches;
next	1.23;

1.23
date	97.09.18.15.29.43;	author dbrown;	state Exp;
branches;
next	1.22;

1.22
date	97.09.18.12.37.15;	author kbracey;	state Exp;
branches;
next	1.21;

1.21
date	97.09.18.10.23.47;	author dbrown;	state Exp;
branches;
next	1.20;

1.20
date	97.09.17.15.11.14;	author dbrown;	state Exp;
branches;
next	1.19;

1.19
date	97.09.16.08.22.59;	author dbrown;	state Exp;
branches;
next	1.18;

1.18
date	97.09.15.11.49.01;	author dbrown;	state Exp;
branches;
next	1.17;

1.17
date	97.09.12.17.19.23;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	97.09.09.14.13.15;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	97.09.05.11.59.06;	author dbrown;	state Exp;
branches;
next	1.14;

1.14
date	97.09.05.08.37.56;	author dbrown;	state Exp;
branches;
next	1.13;

1.13
date	97.09.03.15.48.10;	author dbrown;	state Exp;
branches;
next	1.12;

1.12
date	97.09.03.12.36.09;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.09.03.09.13.40;	author dbrown;	state Exp;
branches;
next	1.10;

1.10
date	97.09.02.16.56.28;	author kbracey;	state Exp;
branches;
next	1.9;

1.9
date	97.09.02.12.40.04;	author dbrown;	state Exp;
branches;
next	1.8;

1.8
date	97.09.01.11.52.05;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.08.31.18.38.17;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.08.29.17.27.12;	author dbrown;	state Exp;
branches;
next	1.5;

1.5
date	97.08.29.15.17.37;	author dbrown;	state Exp;
branches;
next	1.4;

1.4
date	97.08.28.10.50.58;	author dbrown;	state Exp;
branches;
next	1.3;

1.3
date	97.08.28.08.23.12;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.08.27.17.03.38;	author dbrown;	state Exp;
branches;
next	1.1;

1.1
date	97.08.27.09.03.54;	author ahodgkin;	state Exp;
branches;
next	;


desc
@@


1.42
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Hotlist.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Managing a hotlist in the browser.                */
/*                                                            */
/* Author:  D.T.A.Brown.                                      */
/*                                                            */
/* History: 06-Aug-1997 (DTAB): Created.                      */
/*          22-Aug-1997 (ADH / DTAB): Integrated into main    */
/*                             browser code.                  */
/*          25-Aug-1997 (ADH): Definitions imported from      */
/*                             TBEvents.h.                    */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/menu.h>
#include <tboxlibs/event.h>
#include <tboxlibs/gadgets.h>

#include "Global.h"
#include "FromROSLib.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "FetchPage.h"
#include "Filetypes.h"
#include "Menus.h"
#include "Mouse.h"
#include "Multiuser.h"
#include "Protocols.h"
#include "Save.h"
#include "Toolbars.h"
#include "URLUtils.h"
#include "Windows.h"

#include "Hotlist.h"

/* Internationalisation support */

#ifdef UNIFONT
  #define CHARSET_SPECIFIER "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n"
#else
  #define CHARSET_SPECIFIER "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n"
#endif

/* Local definitions */

#define HotlistWrite(fn) {written = (fn); if (written < 0) goto hotlist_save_error;}

/* Local statics */

static int            autoopen_oldtime;                            /* Base time for autoopen directory */
static hotlist_item * hotlist_root                = NULL;          /* Pointer to the hotlist root directory item */
static int            hotlist_windowid            = NULL_ObjectId; /* Object ID of the hotlist window */

static hotlist_item * hotlist_newitem;                             /* When ever a new item is created this points to it */

static int            menu_itemno                 = 0;             /* Item over which menu was pressed */

static int            menu_select                 = 0;             /* 1 if an item had to be selected when the menu was opened */
static unsigned int   last_selected_item          = 0xffffffff;    /* The last item which was selected */

static unsigned int   highlighted_itemno;                          /* During dragging, the number of a directory item using the '...+' sprite */
static hotlist_item * hotlist_current_highlighted = NULL;          /* To save scanning lists, pointer to the highlighted item */
static int            hl_show_urls;                                /* 0 when url descriptions to be shown, 1 to show urls */

static unsigned int   hotlist_bbar_size           = 0;             /* Height in OS units of the button bar */
static unsigned int   alter_new;                                   /* Remembers if the edit dialogue is Alter or New; see   */
                                                                   /* HOTLIST_MENUSECTION_NEW and HOTLIST_MENUSECTION_ALTER */
/* Local structures */

typedef struct hl_dragging_details
{
  char         drag_type;       /* One of HOTIST_NOT_DRAGGING, HOTLIST_BOX_DRAG, HOTLIST_SOLID_DRAG_OBJECT, */
                                /* HOTLIST_SOLID_DRAG_SPRITE, or HOTLIST_BOX_DRAG_SELECTION - See Hotlist.h */
  unsigned int using_adjust :1;
}
hl_dragging_details;

static hl_dragging_details hotlist_dragging;

/* Event handler prototypes */

// Write these out in full, to clearly state exactly what parameters are needed?
// Or is this in fact more robust, as the compiler will fault mismatched functions
// in this source as opposed to wherever a registration of the handler occurs?

static _kernel_oserror     * hotlist_selection_box_start(void);

static WimpEventHandler      hotlist_redraw_handler;
static WimpEventHandler      hotlist_mouse_click_handler;
static WimpEventHandler      hotlist_drag_completed_handler;
static WimpEventHandler      hotlist_null_handler;
static WimpEventHandler      hotlist_null_drag_select_handler;

static ToolboxEventHandler   hotlist_menuopen_handler;
static ToolboxEventHandler   hotlist_menuclose_handler;
static ToolboxEventHandler   hotlist_select_all_handler;
static ToolboxEventHandler   hotlist_clear_selection_handler;
static ToolboxEventHandler   hotlist_menu_openall_handler;
static ToolboxEventHandler   hotlist_menu_closeall_handler;
static ToolboxEventHandler   hotlist_menu_delete_handler;
static ToolboxEventHandler   hotlist_save_to_server_handler;
static ToolboxEventHandler   hotlist_show_editurl_handler;
static ToolboxEventHandler   hotlist_show_rendirectory_handler;
static ToolboxEventHandler   hotlist_show_newurl_handler;
static ToolboxEventHandler   hotlist_show_newdirectory_handler;
static ToolboxEventHandler   hotlist_newedit_url_handler;
static ToolboxEventHandler   hotlist_newren_directory_handler;
static ToolboxEventHandler   hotlist_reset_url_handler;
static ToolboxEventHandler   hotlist_reset_directory_handler;
static ToolboxEventHandler   hotlist_show_descriptions_handler;
static ToolboxEventHandler   hotlist_show_urls_handler;
static ToolboxEventHandler   hotlist_drag_stop_handler;
static ToolboxEventHandler   hotlist_close_handler;

/* Debug functions */

#ifdef TRACE

  static void hotlist_display_item(hotlist_item * item);
  static void hotlist_display_tree(hotlist_item * list, int indent);

#endif

/* List enquiry and manupulation */

static _kernel_oserror * hotlist_link                    (hotlist_item * item, hotlist_item * target, unsigned int position);
static void              hotlist_unlink                  (hotlist_item * item);
static _kernel_oserror * hotlist_new_directory           (hotlist_item * parent, char * directory_name, unsigned int position, hotlist_item ** new);
static _kernel_oserror * hotlist_new_url                 (hotlist_item * parent, unsigned int position, char * url_desc, char * url);
static void              hotlist_delete_item             (hotlist_item * item);
static _kernel_oserror * hotlist_move_item               (hotlist_item * source, hotlist_item * target, unsigned int position);
static _kernel_oserror * hotlist_copy_item               (hotlist_item * source, hotlist_item * target, unsigned int position, hotlist_item ** new_item);

/* Item enquiry and manipulation */

static _kernel_oserror * hotlist_get_entry_sizes         (unsigned int * item_height, unsigned int * item_dir_width, unsigned int * item_url_width);
static int               hotlist_set_flags               (hotlist_item * list, hotlist_type type, unsigned int flags);
static int               hotlist_clear_flags             (hotlist_item * list, hotlist_type type, unsigned int flags);

/* Finding items */

static hotlist_item    * hotlist_find_item               (hotlist_item * list, unsigned int item_no);
static hotlist_item    * hotlist_find_item_r             (hotlist_item * list, unsigned int item_no, int * curr_item);
static int               hotlist_find_no_from_item       (hotlist_item * item);
static int               hotlist_find_no_from_item_r     (hotlist_item * list, hotlist_item * item, int * curr_item);
static hotlist_item    * hotlist_find_selected_item_r    (hotlist_item * list);

/* Counting items */

static void              hotlist_count_selected_items_r  (hotlist_item * list, int * count);
static unsigned int      hotlist_count_displayed_items   (hotlist_item * list);
static void              hotlist_count_displayed_items_r (hotlist_item * list, int * count);

// Categorisation work in progress...

static _kernel_oserror * hotlist_draw                    (hotlist_item * list, unsigned int first_item, unsigned int last_item);
static _kernel_oserror * hotlist_draw_r                  (hotlist_item *list, unsigned int first_item, unsigned int last_item, int * curr_item, unsigned int indent, unsigned int item_height, unsigned int item_dir_width, unsigned int item_url_width);
static unsigned int      hotlist_contents_selected       (hotlist_item * item);
static unsigned int      hotlist_no_contents_selected    (hotlist_item * item);
static unsigned int      hotlist_get_max_width           (hotlist_item * list);
static _kernel_oserror * hotlist_get_max_width_r         (hotlist_item *list, unsigned int indent, int * max_width, unsigned int item_height, unsigned int item_dir_width, unsigned int item_url_width);
static _kernel_oserror * hotlist_redraw_now              (void);
static _kernel_oserror * hotlist_redraw_now_r            (hotlist_item * list, int * curr_item);
static _kernel_oserror * hotlist_get_shape               (int * xmin, int * xmax, hotlist_item * item);
static _kernel_oserror * hotlist_directory_open_close    (hotlist_item * item, unsigned int itemno);
static _kernel_oserror * hotlist_redraw_items            (unsigned int firstitem, unsigned int lastitem);
static _kernel_oserror * hotlist_launch_url              (hotlist_item * item);
static _kernel_oserror * hotlist_process_click_on_item   (unsigned int itemno, hotlist_item * item, int buttons, int x, int y);
static _kernel_oserror * hotlist_process_click           (int x, int y, int buttons);
static int               hotlist_preopen                 (void);
static _kernel_oserror * hotlist_set_menu_details        (ObjectId menuid);
static _kernel_oserror * hotlist_save_entries            (FILE * fileptr, hotlist_item * list, int type, int save_read_only);
static void              hotlist_lower_tags              (char * string);
static void              hotlist_drag_renderer           (hotlist_item * item, unsigned int item_height, unsigned int item_dir_width, unsigned int item_url_width);
static _kernel_oserror * hotlist_start_drag              (void);
static _kernel_oserror * hotlist_start_drag_backend      (void);
static _kernel_oserror * hotlist_modified                (unsigned int type);
static void              hotlist_convert_drag_selection  (hotlist_item * item);
static _kernel_oserror * hotlist_autoscroll              (int window);
static _kernel_oserror * hotlist_load_directory          (FILE * fileptr, hotlist_item * target);

static int               hotlist_get_selected_shape      (BBox * box);
static _kernel_oserror * hotlist_get_selected_shape_r    (hotlist_item * list, BBox * box, unsigned int * itemno, int * found, unsigned int item_height);

static _kernel_oserror * hotlist_select_box              (unsigned int first_item, unsigned int last_item, int minx, int maxx);
static _kernel_oserror * hotlist_select_box_r            (unsigned int first_item, unsigned int last_item, hotlist_item *item, unsigned int *itemno, int minx, int maxx);

static void              hotlist_find_match_r            (flex_ptr match_list, const char * match, hotlist_item * item, int * got_any);

/* Save Protocol */

static _kernel_oserror * hotlist_initiate_uri_save       (hotlist_item *sourceitem);
static _kernel_oserror * hotlist_initiate_html_save      (char *filename);

#ifdef TRACE

  /**************************************************************/
  /* hotlist_display_item()                                     */
  /*                                                            */
  /* This function display the data held by a single            */
  /* hotlist_item                                               */
  /*                                                            */
  /* Parameters: Pointer to a hotlist_item                      */
  /**************************************************************/

  static void hotlist_display_item(hotlist_item * item)
  {
    dprintf(("Hotl", "\nhotlist_display_item for %p\n",item));
    dprintf(("Hotl", "--------------------\n"));
    dprintf(("Hotl", "type              = %d\n", item->type));
    dprintf(("Hotl", "name              = %s\n", item->name));
    dprintf(("Hotl", "flags             = %d\n", item->flags));
    dprintf(("Hotl", "parent            = %p\n", item->parent));
    dprintf(("Hotl", "previous          = %p\n", item->previous));
    dprintf(("Hotl", "next              = %p\n", item->next));
    dprintf(("Hotl", "data.generic_data = %p ",  item->data.generic_data));

    switch(item->type)
    {
      case hl_url:
      {
        dprintf(("Hotl", "URL(%s)\n", item->data.url));
      }
      break;

      case hl_directory:
      {
        dprintf(("Hotl", "sub directory pointer\n"));
      }
      break;

      default:
      {
        dprintf(("Hotl", "\n"));
      }
      break;
    }
  }

  /**************************************************************/
  /* hotlist_display_tree()                                     */
  /*                                                            */
  /* Recursivly display the hotlist tree starting from the      */
  /* passed item                                                */
  /*                                                            */
  /* Parameters: Pointer to a hotlist_item value to start       */
  /*             indent at recommended 0                        */
  /**************************************************************/

  static void hotlist_display_tree(hotlist_item * list, int indent)
  {
    int count;

    dprintf(("Hotl", "\nhotlist_display_tree for %p, indent %d\n", list, indent));
    dprintf(("Hotl", "--------------------\n\n"));

    while (list)
    {
      for (count = 0; count < indent; count++) dprintf(("Hotl", "| "));

      switch (list->type)
      {
        case hl_url:
        {
          dprintf(("Hotl", "%s:URL(%s)\n", list->name, list->data.url));
        }
        break;

        case hl_directory:
        {
          dprintf(("Hotl", "%s:DIRECTORY", list->name));
        }

        if (list->flags & HOTLIST_D_IS_OPEN)
        {
          dprintf(("Hotl", " (Open)\n"));
          hotlist_display_tree(list->data.directory_content, indent + 1);
        }
        else
        {
          dprintf(("Hotl", " (Closed)\n"));
          hotlist_display_tree(list->data.directory_content, indent + 1);
        }
        break;

        default:
        {
          dprintf(("Hotl", "%s:UNRECOGNISED TYPE\n", list->name));
        }
        break;
      }
      list = list->next;
    }
  }

#endif

// /*************************************************/
// /* hotlist_is_inside()                           */
// /*                                               */
// /* Checks if one hotlist_item is held inside     */
// /* the directory structure of another            */
// /* hotlist_item                                  */
// /*                                               */
// /* Parameters: Pointer to the hotlist_item that  */
// /*             may be inside the parent;         */
// /*                                               */
// /*             Pointer to the parent             */
// /*             hotlist_item.                     */
// /*                                               */
// /* Returns:    1 if item is inside, else 0.      */
// /*************************************************/
//
// static int hotlist_is_inside(hotlist_item * inside, hotlist_item * outside)
// {
//   while (inside)
//   {
//     if (inside == outside) return 1;
//     inside = inside->parent;
//   }
//
//   return 0;
// }

/**************************************************************/
/* hotlist_link()                                             */
/*                                                            */
/* This function links the passed item to the passed target.  */
/*                                                            */
/* It can link the item in four different ways; before or     */
/* after the target, or if the target is a directory, at the  */
/* beginning or end of that directory's contents.             */
/*                                                            */
/* Parameters: Pointer to the hotlist_item struct to link in; */
/*                                                            */
/*             Pointer to the hotlist_item struct to link to; */
/*                                                            */
/*             Position to link to -                          */
/*             HOTLIST_POSITION_BEGINNING                     */
/*             HOTLIST_POSITION_END HOTLIST_POSITION_BEFORE   */
/*             or HOTLIST_POSITION_AFTER.                     */
/*                                                            */
/* Assumes:    The item and target pointers are not NULL and  */
/*             are valid;                                     */
/*                                                            */
/*             That if adding to the beginning or end, the    */
/*             target is a directory (in both cases, an error */
/*             will be raised in TRACE builds if the          */
/*             assumptions are violated).                     */
/**************************************************************/

static _kernel_oserror * hotlist_link(hotlist_item * item, hotlist_item * target, unsigned int position)
{
  #ifdef TRACE

    /* Test certain basic assumptions are not violated */

    if (!item || !target)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess, "NULL hotlist item or target pointer in hotlist_link");
      show_error_ret(&erb);
      return NULL;
    }

    if (
         (
           position == HOTLIST_POSITION_BEGINNING ||
           position == HOTLIST_POSITION_END
         )
         && target->type != hl_directory
       )
    {
      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess, "Cannot insert at item at the beginning or end when the target is not a directory, in hotlist_link");
      show_error_ret(&erb);
      return NULL;
    }

  #endif

  switch (position)
  {
    case HOTLIST_POSITION_BEFORE:
    {
      /* Simple insertion above the target item */

      item->next     = target;
      item->previous = target->previous;
      item->parent   = target->parent;

      target->previous = item;

      if (item->previous) item->previous->next = item;
      if (item->parent && item->parent->data.directory_content == target) item->parent->data.directory_content = item;
    }
    break;

    default: /* We'll allow a default to adding after the target item */

    case HOTLIST_POSITION_AFTER:
    {
      /* Again, a simple insertion after the target item */

      item->previous = target;
      item->next     = target->next;
      item->parent   = target->parent;

      target->next = item;

      if (item->next) item->next->previous = item;
    }
    break;

    case HOTLIST_POSITION_BEGINNING:
    {
      /* A bit harder - insert at the top of a directory. */
      /* First a quick sanity check - TRACE builds will   */
      /* already have faulted this, but For non-TRACE     */
      /* builds, at least this will stop things dying.    */

      if (target->type != hl_directory) return NULL;

      /* This item is going to be at the beginning of a */
      /* directory, so there is never a previous item.  */

      item->previous = NULL;

      /* The next item is the one that used to be at the top */
      /* of the directory, and the parent for this item will */
      /* obviously be the target.                            */

      item->next   = target->data.directory_content;
      item->parent = target;

      /* If we have a next item, make sure its previous field */
      /* now points to the new item at the top.               */

      if (item->next) item->next->previous = item;

      /* The target should point to the new top item, too. */

      target->data.directory_content = item;
    }
    break;

    case HOTLIST_POSITION_END:
    {
      hotlist_item * last;

      /* Similarly, add to the end of the directory */

      if (target->type != hl_directory) return NULL;

      /* As before the parent must be the target item */

      item->parent = target;

      /* Now look from the start of the directory downwards for */
      /* the last item currently present.                       */

      last = target->data.directory_content;

      while(last && last->next) last = last->next;

      /* The new item must point to that one as in its previous field, */
      /* and has no next item to point to.                             */

      item->previous = last;
      item->next     = NULL;

      if (last)
      {
        /* If there were any items in the directory, make sure that the */
        /* last one points to the new bottom entry.                     */

        last->next = item;
      }
      else
      {
        /* Otherwise, the parent directory should point to this item */

        target->data.directory_content = item;
      }
    }
    break;
  }

  /* Finished... */

  return NULL;
}

/**************************************************************/
/* hotlist_unlink()                                           */
/*                                                            */
/* This function unlinks the passed item from the items       */
/* linked in before and after it.                             */
/*                                                            */
/* Parameters: Pointer to the hotlist_item struct to remove.  */
/**************************************************************/

static void hotlist_unlink(hotlist_item *item)
{
  if (item->parent && item->parent->data.directory_content == item) item->parent->data.directory_content = item->next;
  if (item->previous) item->previous->next = item->next;
  if (item->next) item->next->previous = item->previous;

  /* Not strictly needed, but added to ensure robustness */

  item->next     = NULL;
  item->previous = NULL;
  item->parent   = NULL;
}

/**************************************************************/
/* hotlist_new_directory()                                    */
/*                                                            */
/* This function creates a new directory at the beginning of  */
/* the given parent.                                          */
/*                                                            */
/* Parameters: Pointer to a hotlist_item of type directory    */
/*             that represents the parent item for this new   */
/*             entry;                                         */
/*                                                            */
/*             Name of new directory to create;               */
/*                                                            */
/*             Position to create the new item relative to    */
/*             the parent (as for hotlist_link);              */
/*                                                            */
/*             Pointer to a pointer to a hotlist_item struct, */
/*             which will be filled in with the address of    */
/*             the new item (unless there is an error         */
/*             returned).                                     */
/*                                                            */
/* Assumes:    That the pointer to a pointer to a             */
/*             hotlist_item struct is not NULL (it would make */
/*             little sense to allow this...).                */
/**************************************************************/

static _kernel_oserror * hotlist_new_directory(hotlist_item * parent, char * directory_name, unsigned int position, hotlist_item ** new)
{
  char             * perm_dirname;
  hotlist_item     * item;
  _kernel_oserror  * e;
  int                is_untitled = 0;

  if (!directory_name) is_untitled = 1;
  else
  {
    while (*directory_name && *directory_name <= ' ') directory_name ++;

    if (!*directory_name) is_untitled = 1;
    else
    {
      int len = strlen(directory_name);

      while (len && directory_name[len - 1] <= ' ') len--;

      if (!len) is_untitled = 1;
      else directory_name[len] = '\0';
    }
  }

  if (is_untitled) directory_name = lookup_token("HotlistUntitled:(Untitled)",0,0);

  /* Allocate space for the item and its name */

  item = malloc(sizeof(hotlist_item));

  if (!item) return make_no_memory_error(4);

  perm_dirname = malloc(strlen(directory_name) + 1);

  if (!perm_dirname)
  {
    free(item);

    return make_no_memory_error(5);
  }

  /* Copy the name into the new buffer */

  strcpy(perm_dirname, directory_name);

  /* Initialise the new hotlist item */

  item->type                   = hl_directory;
  item->flags                  = DIRECTORY_FLAGS;
  item->name                   = perm_dirname;
  item->data.directory_content = NULL;

  if (parent)
  {
    /* If we have been given a parent item, link this new */
    /* directory to it.                                   */

    e = hotlist_link(item, parent, position);

    /* If there's an error, free the item structure and name, */
    /* and return that error.                                 */

    if (e)
    {
      free(item);
      free(perm_dirname);

      return e;
    }
  }
  else
  {
    /* If there's no parent item, fill the various pointers */
    /* to other things in the list with NULL.               */

    item->next     = NULL;
    item->previous = NULL;
    item->parent   = NULL;
  }

  /* Record the new item in the hotlist_newitem static */

  hotlist_newitem = item;

  /* Return the address of the new item and exit */

  *new = item;

  return NULL;
}

/**************************************************************/
/* hotlist_new_url()                                          */
/*                                                            */
/* This function creates a new url at the end of the passed   */
/* directory                                                  */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct representing  */
/*             a directory to add the URL to;                 */
/*                                                            */
/*             Position within that directory to link to      */
/*             (number of items from the start);              */
/*                                                            */
/*             Description of the URL (e.g. from the page     */
/*             title);                                        */
/*                                                            */
/*             Pointer to the URL itself.                     */
/**************************************************************/

static _kernel_oserror * hotlist_new_url(hotlist_item * parent, unsigned int position, char * url_desc, char * url)
{
  char            * perm_url_desc;
  char            * perm_url;
  hotlist_item    * item;
  _kernel_oserror * e;

  /* Do we have a URL string? */

  if (!url) return NULL;

  while (*url && *url <= ' ') url++;

  if (!*url) return NULL;

  /* Do we have a useful title string? */

  if (!url_desc) url_desc = url;
  else
  {
    while (*url_desc && *url_desc <= ' ') url_desc ++;

    if (!*url_desc) url_desc = url;
    else
    {
      int len = strlen(url_desc) - 1;

      while (len && url_desc[len] <= ' ') len--;

      if (!len) url_desc = url;
      else url_desc[len + 1] = '\0';
    }
  }

  /* Allocate a new hotlist_item structure */

  if ((item = malloc(sizeof(hotlist_item))) == NULL)
  {
    dprintf(("Hotl", "hotlist_new_url: Could not allocate room for new URL item\n"));

    goto hotlist_new_url_no_memory; /* See bottom of function */
  }

  /* Allocate space for the description string */

  perm_url_desc = malloc(strlen(url_desc) + 1);

  if (perm_url_desc == NULL) goto hotlist_new_url_no_memory; /* See bottom of function */

  /* Allocate space for the URL */

  perm_url = malloc(strlen(url) + 1);

  if (perm_url == NULL)
  {
    free(perm_url_desc);
    goto hotlist_new_url_no_memory; /* See bottom of function */
  }

  /* Copy the given description and URL to the allocated space */

  strcpy(perm_url_desc, url_desc);
  strcpy(perm_url, url);

  /* Fill in miscellaneous parts of the hotlist_item structure */

  item->type     = hl_url;
  item->flags    = URL_FLAGS;
  item->name     = perm_url_desc;
  item->data.url = perm_url;

  /* Link the item to the rest of the hotlist */

  e = hotlist_link(item, parent, position);

  if (e)
  {
    free(item);
    free(perm_url_desc);
    free(perm_url);

    return e;
  }

  /* Remember which item was added in the hotlist_newitem static */
  /* and exit with no error.                                     */

  hotlist_newitem = item;

  return NULL;

  /* Code for a common error case */

hotlist_new_url_no_memory:

  erb.errnum = Utils_Error_Custom_Normal;

  StrNCpy0(erb.errmess,
           lookup_token("NoMemURL:There is not enough free memory to add another URL to the hotlist.",
           0,
           0));

  return &erb;
}

/**************************************************************/
/* hotlist_delete_item()                                      */
/*                                                            */
/* This function deletes an item from the hotlist structure;  */
/* it will recursively delete directories.                    */
/*                                                            */
/* Parameters: Pointer to the hotlist_item struct to delete.  */
/**************************************************************/

static void hotlist_delete_item(hotlist_item * item)
{
  if (item)
  {
    switch (item->type)
    {
      /* For a URL item, unlink it from the list */
      /* and free associated memory.             */

      case hl_url:
      {
        hotlist_unlink(item);
        free(item->name);
        free(item->data.url);
        free(item);
      }
      break;

      case hl_directory:
      {
        /* Recursively delete all items in the directory */

        while (item->data.directory_content)
        {
          hotlist_delete_item(item->data.directory_content);
        }

        /* Now unlink the item */

        hotlist_unlink(item);

        /* Free associated memory */

        free(item);
        free(item->name);

      }
      break;

      default:
      {
        #ifdef TRACE

          /* A 'should never happen' case! */

          erb.errnum = Utils_Error_Custom_Message;
          strcpy(erb.errmess, "Unrecognised item type in hotlist_delete_item - possibly memory corruption?");
          show_error_ret(&erb);

        #endif
      }
      break;
    }
  }
}

/**************************************************************/
/* hotlist_move_item()                                        */
/*                                                            */
/* This function takes an item and moves its position within  */
/* the directory tree.                                        */
/*                                                            */
/* Parameters: Pointer to the hotlist_item struct to move;    */
/*                                                            */
/*             Pointer to the hotlist_item structure to move  */
/*             to;                                            */
/*                                                            */
/*             Position relative to that struct for the item  */
/*             to go to, as for hotlist_link.                 */
/*                                                            */
/* Assumes:    It is assumed that if the object is a          */
/*             directory it is not being moved into it self   */
/*             or one of its children. If this is not the     */
/*             case then both it and its children will become */
/*             unlinked from the hotlist structure            */
/*             (nasty...!).                                   */
/**************************************************************/

static _kernel_oserror * hotlist_move_item(hotlist_item * source, hotlist_item * target, unsigned int position)
{
  hotlist_item * newdir, * tempptr;

  /* If the item is read only, don't move it; copy instead. */

  if (source->flags & HOTLIST_G_IS_READ_ONLY)
  {
    return hotlist_copy_item(source, target, position, NULL);
  }

  /* Otherwise, moving it is OK */

  if (!(source->type == hl_directory && !hotlist_contents_selected(source->data.directory_content)))
  {
    /* Unlink item from directory structure */

    hotlist_unlink(source);

    /* Link into new position in directory structure */

    return hotlist_link(source, target, position);
  }
  else
  {
    /* Special case - moving a directory whose contents are only partially selected. */
    /* We can't move a directory whose contents are only partially to be moved,      */
    /* there would be nowhere to leave the items which were not moved with it.       */

    /* So, create a new directory based on the old */

    RetError(hotlist_new_directory(target, source->name, position, &newdir));

    /* Move the contents recursively into the new directory */

    source = source->data.directory_content;

    while (source)
    {
      tempptr = source->next;

      if (source->flags & HOTLIST_G_IS_SELECTED)
      {
        hotlist_move_item(source, newdir, HOTLIST_POSITION_END);
        source->flags &= ~HOTLIST_G_IS_SELECTED;
      }

      source = tempptr;
    }
  }

  return NULL;
}

/**************************************************************/
/* hotlist_copy_item()                                        */
/*                                                            */
/* This function copies an item, and in the case of it being  */
/* a directory, its children, to the specified place.         */
/*                                                            */
/* Parameters: Pointer to the hotlist_item struct to copy;    */
/*                                                            */
/*             Pointer to the hotlist_item struct to copy to; */
/*                                                            */
/*             Position relative to that item to copy to, as  */
/*             for hotlist_link;                              */
/*                                                            */
/*             Pointer to a pointer to a hotlist_item struct, */
/*             in which the address of the new item is        */
/*             returned.                                      */
/*                                                            */
/* Assumes:    It is assumed that if the object is a          */
/*             directory it is not being copied into it self  */
/*             or one of its children - if it is the function */
/*             will keep recursing and eventually run out of  */
/*             stack;                                         */
/*                                                            */
/*             The pointer to the pointer to the hotlist_item */
/*             struct may be NULL.                            */
/**************************************************************/

static _kernel_oserror * hotlist_copy_item(hotlist_item * source, hotlist_item * target,
                                           unsigned int position, hotlist_item ** new_item)
{
  hotlist_item * newdir;

  newdir = NULL;

  switch(source->type)
  {
    /* For a URL, create a new item based on the source one */

    case hl_url:
    {
      RetError(hotlist_new_url(target, position, source->name, source->data.url));
    }
    break;

    /* For a directory, first create a new item based on the source one */

    case hl_directory:
    {
      hotlist_item * content;

      RetError(hotlist_new_directory(target, source->name, position, &newdir));

      /* Now copy the contents recursively */

      content = source->data.directory_content;

      while (content)
      {
        if (content->flags & HOTLIST_G_IS_SELECTED)
        {
          RetError(hotlist_copy_item(content, newdir, HOTLIST_POSITION_END, NULL));
        }

        content = content->next;
      }
    }
    break;
  }

  /* Fill in the new_item return value */

  if (new_item)
  {
    if (newdir) *new_item = newdir;
    else        *new_item = hotlist_newitem;
  }

  return NULL;
}

/**************************************************************/
/* hotlist_get_entry_sizes()                                  */
/*                                                            */
/* This function reads the size of the sprites to be used by  */
/* the hotlist and from them determines the size of the       */
/* hotlist entries.                                           */
/*                                                            */
/* Parameters: Pointer to an int, in which the height of an   */
/*             item is placed in OS units;                    */
/*                                                            */
/*             Pointer to an int, in which the minimum width  */
/*             of a directory item is returned, in OS units;  */
/*                                                            */
/*             Pointer to an int, in which the minimum width  */
/*             of a URL item is returned, in OS units.        */
/*                                                            */
/* Assumes:    Any of the pointers may be NULL.               */
/**************************************************************/

static _kernel_oserror * hotlist_get_entry_sizes(unsigned int * item_height, unsigned int * item_dir_width, unsigned int * item_url_width)
{
  int width, height;

  /* Get the open directory sprite size */

  RetError(utils_read_sprite_size(OPEN_DIRECTORY_SPRITE, &width, &height));

  /* Use this for the minimum width of a directory entry */
  /* and the height of an item.                          */

  if (item_dir_width) *item_dir_width = width;
  if (item_height)    *item_height    = height;

  /* Now read the closed sprite; if the size is greater */
  /* than the width or height found above, use the new  */
  /* sizes instead.                                     */

  RetError(utils_read_sprite_size(CLOSED_DIRECTORY_SPRITE, &width, &height));

  if (item_height    && height > *item_height)    *item_height    = height;
  if (item_dir_width && width  > *item_dir_width) *item_dir_width = width;

  /* Similarly for the insert item sprite. */

  RetError(utils_read_sprite_size(INSERT_DIRECTORY_SPRITE, &width, &height));

  if (item_height    && height > *item_height)    *item_height    = height;
  if (item_dir_width && width  > *item_dir_width) *item_dir_width = width;

  /* Find the URL sprite size, and if required increase the */
  /* minimum entry height again based on this.              */

  RetError(utils_read_sprite_size(URL_SPRITE, &width, &height));

  if (item_height && height > *item_height) *item_height= height;

  /* Set the URL width to the value found above and add 8 to */
  /* all of them for aesthetics.                             */

  if (item_url_width) *item_url_width = width + 8;
  if (item_dir_width) *item_dir_width += 8;
  if (item_height)    *item_height    += 8;

  return NULL;
}

/**************************************************************/
/* hotlist_set_flags()                                        */
/*                                                            */
/* This function will recursively set flags for either a      */
/* specified type of hotlist_item or all hotlist_items, to    */
/* the given value. All items which are changed will have     */
/* their HOTLIST_G_REDRAW_NOW bit set.                        */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct to start on;  */
/*                                                            */
/*             Type of hotlist_item to set flags for, or      */
/*             hl_ALL for all types;                          */
/*                                                            */
/*             Flags to set.                                  */
/*                                                            */
/* Returns:    1 if any flags were set, else 0.               */
/**************************************************************/

static int hotlist_set_flags(hotlist_item * list, hotlist_type type, unsigned int flags)
{
  int changed = 0;

  while (list)
  {
    /* Alter all items, or those of the correct type */

    if (type == hl_ALL || type == list->type)
    {
      if (list->flags | flags != list->flags)
      {
        list->flags |= HOTLIST_G_REDRAW_NOW;
        changed = 1;
      }

      list->flags |= flags;
    }

    /* Recursive call for directories */

    if (list->type == hl_directory)
    {
      if (hotlist_set_flags(list->data.directory_content, type, flags)) changed = 1;
    }

    list = list->next;
  }

  return changed;
}

/**************************************************************/
/* hotlist_clear_flags()                                      */
/*                                                            */
/* This function will recursively clear flags for either a    */
/* specified type of hotlist_item or all hotlist_items. All   */
/* items changed will have their HOTLIST_G_REDRAW_NOW bit     */
/* set, unless, of course, the routine is called to clear     */
/* that bit.                                                  */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct to start on;  */
/*                                                            */
/*             Type of hotlist_item to set flags for, or      */
/*             hl_ALL for all types;                          */
/*                                                            */
/*             Flags clear word (any bits set in this word    */
/*             are cleared in the item flags).                */
/*                                                            */
/* Returns:    1 if flags were cleared, else 0.               */
/**************************************************************/

static int hotlist_clear_flags(hotlist_item * list, hotlist_type type, unsigned int flags)
{
  int changed = 0;

  while (list)
  {
    /* Only alter the requested item types */

    if (type == hl_ALL || type == list->type)
    {
      if ((list->flags & ~flags) != list->flags)
      {
        list->flags |= HOTLIST_G_REDRAW_NOW;
        changed = 1;
      }

      list->flags &= ~flags;
    }

    /* Recursive call for directories */

    if (list->type == hl_directory)
    {
      if (hotlist_clear_flags(list->data.directory_content, type, flags)) changed = 1;
    }

    list = list->next;
  }

  return changed;
}

/**************************************************************/
/* hotlist_find_item()                                        */
/*                                                            */
/* This function will recursivly scan through a hotlist       */
/* structure and return a pointer to the n'th item. It will   */
/* only recurse through open directories.                     */
/*                                                            */
/* Parameters: Pointer to a hotlist_item at the top of the    */
/*             directory to scan;                             */
/*                                                            */
/*             The nth item to return within it.              */
/*                                                            */
/* Returns:    Pointer to the requested item or NULL if it    */
/*             does not exist.                                */
/**************************************************************/

static hotlist_item * hotlist_find_item(hotlist_item * list, unsigned int item_no)
{
  int curr_item = 0;

  return hotlist_find_item_r(list, item_no, &curr_item);
}

/**************************************************************/
/* hotlist_find_item_r()                                      */
/*                                                            */
/* Recursive back-end to hotlist_find_item.                   */
/*                                                            */
/* Parameters: Pointer to a hotlist_item at the top of the    */
/*             directory to scan;                             */
/*                                                            */
/*             The nth item to return within it;              */
/*                                                            */
/*             Pointer to an int, in which the number of the  */
/*             current item is accumulated (initialised to an */
/*             appropriate value, usually 0).                 */
/*                                                            */
/* Returns:    As hotlist_find_item.                          */
/*                                                            */
/* Assumes:    The pointer to the int may *not* be NULL.      */
/**************************************************************/

static hotlist_item * hotlist_find_item_r(hotlist_item * list, unsigned int item_no, int * curr_item)
{
  hotlist_item * temp;

  while (list)
  {
    if (*curr_item == item_no) return list; /* Found the list item */

    /* Increment the item counter */

    *curr_item += 1;

    /* Recursively scan open directories */

    if (list->type == hl_directory && list->flags & HOTLIST_D_IS_OPEN)
    {
      temp = hotlist_find_item_r(list->data.directory_content, item_no, curr_item);
      if (temp) return temp;
    }

    /* Move to the next list item */

    list = list->next;
  }

  return NULL; /* List does not extend far enough */
}

/**************************************************************/
/* hotlist_find_no_from_item()                                */
/*                                                            */
/* This function will recursivly scan through a hotlist       */
/* structure and return the position of the specified item.   */
/* It will only recurse through open directories.             */
/*                                                            */
/* Parameters: Pointer to a hotlist_item to start at;         */
/*                                                            */
/*             Pointer to the item whos position is to be     */
/*             returned.                                      */
/*                                                            */
/* Returns:    The item position or -1 if it is not found.    */
/**************************************************************/

static int hotlist_find_no_from_item(hotlist_item * item)
{
  int curr_item = 0;

  return hotlist_find_no_from_item_r(hotlist_root->data.directory_content, item, &curr_item);
}

/**************************************************************/
/* hotlist_find_no_from_item_r()                              */
/*                                                            */
/* Recursive back-end to hotlist_find_no_from_item.           */
/*                                                            */
/* Parameters: Pointer to a hotlist_item to start at;         */
/*                                                            */
/*             Pointer to the item whos position is to be     */
/*             returned;                                      */
/*                                                            */
/*             Pointer to an int, in which the number of the  */
/*             current item is accumulated (initialised to an */
/*             appropriate value, usually 0).                 */
/*                                                            */
/* Returns:    As hotlist_find_no_from_item.                  */
/*                                                            */
/* Assumes:    The pointer to the int may *not* be NULL.      */
/**************************************************************/

static int hotlist_find_no_from_item_r(hotlist_item * list, hotlist_item * item, int * curr_item)
{
  /* Start the search at the given item */

  while (list)
  {
    if (item == list) return *curr_item; /* Found the list item */

    *curr_item += 1;

    /* Recursively scan open directories */

    if (list->type == hl_directory && list->flags & HOTLIST_D_IS_OPEN)
    {
      int found;

      found = hotlist_find_no_from_item_r(list->data.directory_content, item, curr_item);
      if (found >= 0) return found;
    }

    /* Move to the next item */

    list = list->next;
  }

  /* Didn't find it */

  return -1;
}

/**************************************************************/
/* hotlist_find_selected_item()                               */
/*                                                            */
/* This function returns a pointer to the first selected item */
/* found.                                                     */
/*                                                            */
/* Returns:    Pointer to a hotlist_item struct which was the */
/*             first selected item found in a search starting */
/*             from the root, or NULL if there is nothing     */
/*             selected.                                      */
/**************************************************************/

hotlist_item * hotlist_find_selected_item(void)
{
  return hotlist_find_selected_item_r(hotlist_root);
}

/**************************************************************/
/* hotlist_find_selected_item_r()                             */
/*                                                            */
/* Recursive back-end to hotlist_find_selected_item.          */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct to start at.  */
/*                                                            */
/* Returns:    As hotlist_find_selected_item.                 */
/**************************************************************/

static hotlist_item * hotlist_find_selected_item_r(hotlist_item * list)
{
  while (list)
  {
    if (list->flags & HOTLIST_G_IS_SELECTED) return list; /* Found it */

    /* Recursively scan all directories */

    if (list->type == hl_directory)
    {
      hotlist_item * found;

      found = hotlist_find_selected_item_r(list->data.directory_content);
      if (found) return found;
    }

    /* Move to the next item */

    list = list->next;
  }

  /* Didn't find it */

  return NULL;
}

/**************************************************************/
/* hotlist_count_selected_items()                             */
/*                                                            */
/* Count the number of items that are currently selected in   */
/* the hotlist window.                                        */
/*                                                            */
/* If you want to know if all items are selected use          */
/* hotlist_contents_selected. If you want to know if no items */
/* are selected, it is faster to use                          */
/* hotlist_no_contents_selected than compare the return value */
/* of this function against zero (this function *must* scan   */
/* all hotlist items, whereas the other can exit as soon as a */
/* selected item is found).                                   */
/*                                                            */
/* Returns:    The number of selected items.                  */
/**************************************************************/

unsigned int hotlist_count_selected_items(void)
{
  int count = 0;

  hotlist_count_selected_items_r(hotlist_root->data.directory_content, &count);

  return count;
}

/**************************************************************/
/* hotlist_count_selected_items_r()                           */
/*                                                            */
/* Recursive back-end to hotlist_count_selected_items.        */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct representing  */
/*             the first item in a directory to count;        */
/*                                                            */
/*             Pointer to an int, in which the total is       */
/*             accumulated.                                   */
/*                                                            */
/* Assumes:    The pointer to the int may *not* be NULL.      */
/**************************************************************/

static void hotlist_count_selected_items_r(hotlist_item * list, int * count)
{
  while (list)
  {
    if (list->flags & HOTLIST_G_IS_SELECTED)
    {
      *count += 1;
    }
    else
    {
      /* Only recurse through directories which are not selected */

      if (list->type == hl_directory)
      {
        hotlist_count_selected_items_r(list->data.directory_content, count);
      }
    }

    list = list->next;
  }
}

/**************************************************************/
/* hotlist_count_displayed_items()                            */
/*                                                            */
/* This routine counts the number of items displayed in the   */
/* hotlist window.                                            */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct to start at.  */
/*                                                            */
/* Returns:    The number of displayed items.                 */
/**************************************************************/

static unsigned int hotlist_count_displayed_items(hotlist_item * list)
{
  int count = 0;

  hotlist_count_displayed_items_r(list, &count);

  return count;
}

/**************************************************************/
/* hotlist_count_displayed_items_r()                          */
/*                                                            */
/* Recursive back-end to hotlist_count_displayed_items.       */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct to start at;  */
/*                                                            */
/*             Pointer to an int, in which the total is       */
/*             accumulated.                                   */
/*                                                            */
/* Assumes:    The pointer to the int may *not* be NULL.      */
/**************************************************************/

static void hotlist_count_displayed_items_r(hotlist_item *list, int * count)
{
  while (list)
  {
    /* Recursive scan for open directories */

    if (list->type == hl_directory && list->flags & HOTLIST_D_IS_OPEN)
    {
      hotlist_count_displayed_items_r(list->data.directory_content, count);
    }

    list = list->next;

    *count += 1;
  }
}

/**************************************************************/
/* hotlist_draw()                                             */
/*                                                            */
/* Redraws a specified region of the hotlist. Assumes         */
/* graphics rectangles are set up appropriately (e.g. the     */
/* function is called during a Wimp redraw session).          */
/*                                                            */
/* Parameters: Pointer to a hotlist_item giving the list that */
/*             we're to draw;                                 */
/*                                                            */
/*             First item number to draw (count the visible   */
/*             items from the top of the window downwards     */
/*             starting at an item number of zero);           */
/*                                                            */
/*             Last item number to draw.                      */
/**************************************************************/

static _kernel_oserror * hotlist_draw(hotlist_item * list, unsigned int first_item, unsigned int last_item)
{
  int          curr_item = 0;
  unsigned int item_height, item_dir_width, item_url_width;

  RetError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  return hotlist_draw_r(list,
                        first_item,
                        last_item,
                        &curr_item,
                        0,
                        item_height,
                        item_dir_width,
                        item_url_width);
}

/**************************************************************/
/* hotlist_draw_r()                                           */
/*                                                            */
/* Recursive back-end to hotlist_draw.                        */
/*                                                            */
/* Parameters: Pointer to a hotlist_item giving the list that */
/*             we're to draw;                                 */
/*                                                            */
/*             First item number to draw (count the visible   */
/*             items from the top of the window downwards     */
/*             starting at an item number of zero);           */
/*                                                            */
/*             Last item number to draw;                      */
/*                                                            */
/*             Pointer to an int, which is used to accumulate */
/*             the current item number - the contents should  */
/*             be initialised to an appropriate value for the */
/*             first three parameters (usually, zero);        */
/*                                                            */
/*             Level of indentation (OS units);               */
/*                                                            */
/*             Height of an item (OS units);                  */
/*                                                            */
/*             Width of a directory item (OS units);          */
/*                                                            */
/*             Width of a URL item (OS units).                */
/*                                                            */
/* Assumes:    The pointer to the int may *not* be NULL.      */
/**************************************************************/

static _kernel_oserror * hotlist_draw_r(hotlist_item *list, unsigned int first_item, unsigned int last_item,
                                        int * curr_item, unsigned int indent, unsigned int item_height,
                                        unsigned int item_dir_width, unsigned int item_url_width)
{
  WimpIconBlock icon;
  unsigned int  temp_width;
  int           text_width;

  while (list)
  {
    /* Break out if done all items to be displayed */

    if (*curr_item > last_item) return NULL;

    /* Don't draw until we reach the required first item */

    if (*curr_item >= first_item)
    {
      /* Construct an icon block for Wimp_PlotIcon. First, icon flags. */

      icon.flags = HOTLIST_SPRITE_ICON_FLAGS;

      if (((list->flags & HOTLIST_G_IS_SELECTED) ? 1 : 0) ^
          ((list->flags & HOTLIST_G_DRAG_SELECTED) ? 1 : 0)
         ) icon.flags |= WimpIcon_Selected;

      /* Point to the main sprite pool */

      icon.data.is.sprite_area = (void*) sprite_block;

      /* Set type-dependent characteristics */

      switch(list->type)
      {
        case hl_url:
        {
          /* A URL item; set the sprite name and item width accordingly */

          icon.data.is.sprite             = !(list->flags & HOTLIST_G_IS_READ_ONLY) ? URL_SPRITE : RESOURCES_URL_SPRITE;
          icon.data.is.sprite_name_length = strlen(URL_SPRITE);
          temp_width = item_url_width;
        }
        break;

        case hl_directory:
        {
          /* Directories are a bit more complex, as they can be open, */
          /* closed, or showing a '+' if a dragged item is hovering   */
          /* over it and would drop 'into' the directory if released. */

          temp_width = item_dir_width; /* Width is based on the widest sprite of the three */

          if (list->flags & HOTLIST_D_IS_HIGHLIGHTED)
          {
            /* The item is either selected (something is 'hovering' over it)... */

            icon.data.is.sprite             = INSERT_DIRECTORY_SPRITE;
            icon.data.is.sprite_name_length = strlen(INSERT_DIRECTORY_SPRITE);
          }
          else
          {
            /* ...or unselected. In that case it is either open or closed. */

            if (list->flags & HOTLIST_D_IS_OPEN)
            {
              icon.data.is.sprite = !(list->flags & HOTLIST_G_IS_READ_ONLY) ? OPEN_DIRECTORY_SPRITE : OPEN_RESOURCES_DIRECTORY_SPRITE;
            }
            else
            {
              icon.data.is.sprite = !(list->flags & HOTLIST_G_IS_READ_ONLY) ? CLOSED_DIRECTORY_SPRITE : CLOSED_RESOURCES_DIRECTORY_SPRITE;
            }

            icon.data.is.sprite_name_length = strlen(icon.data.is.sprite);
          }
        }
        break;

        default:
        {
          temp_width = 0; /* Should never happen... */
        }
        break;
      }

      /* Set the item bounding box appropriately */

      icon.bbox.xmin = indent;
      icon.bbox.xmax = indent + temp_width;

      icon.bbox.ymin = -item_height * (*curr_item) - item_height;
      icon.bbox.ymax = -item_height * (*curr_item);

      /* Plot the item */

      RetError(wimp_plot_icon(&icon));

      /* We now need to plot the item text. First, get the width, */
      /* taking the opportunity to point the icon that we'll plot */
      /* to the appropriate text, too.                            */

      if (list->type == hl_url && hl_show_urls)
      {
        /* If this is a URL item and we are to show URLs, then find */
        /* the width of the URL rather than the description.        */

        RetError(utils_text_width(list->data.url, &text_width, 0));

        /* Point to the URL text */

        icon.data.it.buffer      = list->data.url;
        icon.data.it.buffer_size = strlen(list->data.url);
        icon.data.it.validation  = NULL;
      }
      else
      {
        /* Otherwise (any other item, or a URL item when we're showing */
        /* descriptions) just find the name's width.                   */

        RetError(utils_text_width(list->name, &text_width, 0));

        /* Point to the description */

        icon.data.it.buffer      = list->name;
        icon.data.it.buffer_size = strlen(list->name);
        icon.data.it.validation  = NULL;
      }

      /* Set the bounding box for the text. The hard coded */
      /* constants are nothing critical - just aesthetics. */

      icon.bbox.xmin = indent + temp_width + 2;
      icon.bbox.xmax = indent + temp_width + 2 + text_width + 12;

      icon.bbox.ymin = -item_height * (*curr_item) - item_height + 2;
      icon.bbox.ymax = -item_height * (*curr_item) - 2;

      /* Set the flags accordingly if the text is selected or unselected */

      if (((list->flags & HOTLIST_G_IS_SELECTED) ? 1 : 0) ^
          ((list->flags & HOTLIST_G_DRAG_SELECTED) ? 1 : 0)) icon.flags = HOTLIST_TEXT_ICON_FLAGS_SELECTED;
      else                                                   icon.flags = HOTLIST_TEXT_ICON_FLAGS_UNSELECTED;

      /* Finally, plot the item. */

      RetError(wimp_plot_icon(&icon));
    }

    /* Increment the item number */

    *curr_item += 1;

    /* Recursive redraw for directories */

    if (list->type == hl_directory && list->flags & HOTLIST_D_IS_OPEN)
    {
      RetError(hotlist_draw_r(list->data.directory_content,
                              first_item,
                              last_item,
                              curr_item,
                              indent + item_dir_width,
                              item_height,
                              item_dir_width,
                              item_url_width));
    }

    /* Move on down the list */

    list = list->next;
  }

  return NULL;
}

/**************************************************************/
/* hotlist_get_max_width_r                                    */
/*                                                            */
/* Recursive back-end to hotlist_get_max_width.               */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct to start at;  */
/*                                                            */
/*             An indent in OS units, as for redrawing the    */
/*             hotlist;                                       */
/*                                                            */
/*             Pointer to an int, in which the width of the   */
/*             widest item so far is accumulated;             */
/*                                                            */
/*             Height of a hotlist item in OS units;          */
/*                                                            */
/*             Width of a hotlist directory sprite in OS      */
/*             units;                                         */
/*                                                            */
/*             Width of a hotlist URL sprite in OS units.     */
/*                                                            */
/* Assumes:    The pointer to the int may *not* be NULL.      */
/**************************************************************/

static _kernel_oserror * hotlist_get_max_width_r(hotlist_item *list, unsigned int indent, int * max_width,
                                                 unsigned int item_height, unsigned int item_dir_width, unsigned int item_url_width)
{
  _kernel_oserror * e;
  unsigned int      item_width;
  int               text_width;

  while (list)
  {
    /* Get width of the icon */

    switch (list->type)
    {
      case hl_directory: item_width = item_dir_width; break;
      case hl_url:       item_width = item_url_width; break;
      default:           item_width = 0;              break;
    }

    /* Work out width of the text */

    if (list->type == hl_url && hl_show_urls) e = utils_text_width(list->data.url, &text_width, 0);
    else                                      e = utils_text_width(list->name,     &text_width, 0);

    if (e) return e;

    /* Account for the indent and spacers (aesthetics) */

    item_width += indent + 2 + text_width + 12;

    /* If this is wider than so far recorded, store the new value */

    if (item_width > *max_width) *max_width = item_width;

    /* Recursive call for open directories */

    if (list->type == hl_directory && list->flags & HOTLIST_D_IS_OPEN)
    {
      RetError(hotlist_get_max_width_r(list->data.directory_content,
                                       indent + item_dir_width,
                                       max_width,
                                       item_height,
                                       item_dir_width,
                                       item_url_width));
    }

    /* Move on down the list */

    list = list->next;
  }

  return NULL;
}

/**************************************************************/
/* hotlist_get_max_width()                                    */
/*                                                            */
/* This function returns the maximum width of of the          */
/* displayed hotlist entries.                                 */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct to start at.  */
/*             This is assumed to be at zero indent from the  */
/*             left hand side.                                */
/*                                                            */
/* Returns:    Of all visible entries, the width of the       */
/*             widest, in OS units.                           */
/**************************************************************/

static unsigned int hotlist_get_max_width(hotlist_item * list)
{
  unsigned int item_height, item_dir_width, item_url_width;
  int          widest = 0;

  /* Find basic item size information */

  if (hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width)) return 0;

  /* Scan the directory and all open directories with in it for */
  /* the widest item                                            */

  if (hotlist_get_max_width_r(list,
                              0,
                              &widest,
                              item_height,
                              item_dir_width,
                              item_url_width)) return 0;

  /* Return the result */

  return widest;
}

/**************************************************************/
/* hotlist_redraw_now()                                       */
/*                                                            */
/* This function redraws all visible items with the           */
/* HOTLIST_G_REDRAW_NOW bit set.                              */
/**************************************************************/

static _kernel_oserror * hotlist_redraw_now(void)
{
  int curr_item = 0;

  return hotlist_redraw_now_r(hotlist_root->data.directory_content, &curr_item);
}

/**************************************************************/
/* hotlist_redraw_now_r()                                     */
/*                                                            */
/* Recursive back-end to hotlist_redraw_now.                  */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct to start on;  */
/*                                                            */
/*             Pointer to an int, in which the current item   */
/*             number being redrawn is accumulated.           */
/*                                                            */
/* Assumes:    The pointer to the int may *not* be NULL.      */
/**************************************************************/

static _kernel_oserror * hotlist_redraw_now_r(hotlist_item * list, int * curr_item)
{
  while (list)
  {
    if (list->flags & HOTLIST_G_REDRAW_NOW)
    {
      /* Redraw just the one item */

      RetError(hotlist_redraw_items(*curr_item, *curr_item));

      /* Clear the flag */

      list->flags &= ~HOTLIST_G_REDRAW_NOW;
    }

    *curr_item += 1;

    if (list->type == hl_directory && list->flags & HOTLIST_D_IS_OPEN)
    {
      /* Recursive call for open directories */

      RetError(hotlist_redraw_now_r(list->data.directory_content, curr_item));
    }

    list = list->next;
  }

  return NULL;
}

/**************************************************************/
/* hotlist_add()                                              */
/*                                                            */
/* Add a new URL to the hotlist.                              */
/*                                                            */
/* Parameters: Description of the URL (e.g. from the page     */
/*             title);                                        */
/*                                                            */
/*             Pointer to the URL itself;                     */
/*                                                            */
/*             0 to add to the top, 1 to add to the bottom.   */
/**************************************************************/

_kernel_oserror * hotlist_add(char * description, char * url, int at_bottom)
{
  _kernel_oserror * e = NULL;
  int               position;
  hotlist_item    * target;
  int               type;

  target = hotlist_find_selected_item();

  if (!target)
  {
    position = at_bottom ? HOTLIST_POSITION_END : HOTLIST_POSITION_BEGINNING;
    target   = hotlist_root;
    type     = 1;

    /* If adding to the beginning of the hotlist, skip any */
    /* read-only items at the top first.                   */

    if (position == HOTLIST_POSITION_BEGINNING)
    {
      hotlist_item * check = target->data.directory_content;

      /* Look for something not read-only */

      while (check && check->next)
      {
        if (check->next->flags & HOTLIST_G_IS_READ_ONLY) check = check->next;
        else break;
      }

      if (check && (check->flags & HOTLIST_G_IS_READ_ONLY))
      {
        position = HOTLIST_POSITION_AFTER;
        target   = check;
      }
    }
  }
  else
  {
    if (target->type == hl_directory)
    {
      position = HOTLIST_POSITION_BEGINNING;
    }
    else
    {
      position = HOTLIST_POSITION_AFTER;
    }

    type = 2;
  }

  /* Add the item and ensure the window extent etc. is correct */

  e = hotlist_new_url(target,
                      position,
                      description,
                      url);

  if (!e) hotlist_preopen();

  /* Optimise the redraw to do as little as possible depending */
  /* upon where in the list the item was added.                */

  switch (position)
  {
    default:
    case HOTLIST_POSITION_END:
    {
      hotlist_redraw_now();
    }
    break;

    case HOTLIST_POSITION_BEGINNING:
    {
      if (type == 1)
      {
        hotlist_redraw_items(0,
                             hotlist_count_displayed_items(hotlist_root->data.directory_content));
      }
      else
      {
        if (target->flags & HOTLIST_D_IS_OPEN)
        {
          hotlist_redraw_items(hotlist_find_no_from_item(target),
                               hotlist_count_displayed_items(hotlist_root->data.directory_content));
        }
      }
    }
    break;

    case HOTLIST_POSITION_BEFORE:
    case HOTLIST_POSITION_AFTER:
    {
      hotlist_redraw_items(hotlist_find_no_from_item(hotlist_newitem),
                           hotlist_count_displayed_items(hotlist_root->data.directory_content));
    }
  }

  if (!e) return hotlist_modified(HL_MODIFIED_ADD);

  return e;
}

/**************************************************************/
/* hotlist_get_shape()                                        */
/*                                                            */
/* This function calculates the xmin and xmax of the passed   */
/* hotlist_item.                                              */
/*                                                            */
/* Parameters: Pointer to an int, in which the xmin offset    */
/*             (in OS units) from the left hand edge is       */
/*             returned;                                      */
/*                                                            */
/*             Similarly, a pointer to an int to take the     */
/*             xmax offset;                                   */
/*                                                            */
/*             Pointer to the hotlist_item to examine.        */
/*                                                            */
/* Assumes:    Any pointer may be NULL.                       */
/**************************************************************/

static _kernel_oserror * hotlist_get_shape(int * xmin, int * xmax, hotlist_item * item)
{
  hotlist_item * tempitem;
  unsigned int   item_height, item_dir_width, item_url_width;
  int            icon_width;
  int            text_width;
  int            count = 0;

  if (xmin) *xmin = 0;
  if (xmax) *xmax = 0;

  if (!item) return NULL;

  /* Find entry sizes */

  RetError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  /* Count how many parent items we have. This allows */
  /* the left hand indent to be calculated.           */

  tempitem = item;

  while (tempitem)
  {
    tempitem = tempitem->parent;
    count++;
  }

  count -= 2;

  /* Find the text width */

  if (item->type == hl_url && hl_show_urls) utils_text_width(item->data.url, &text_width, 0);
  else                                      utils_text_width(item->name,     &text_width, 0);

  /* Add in the sprite width */

  switch (item->type)
  {
    case hl_directory: icon_width = item_dir_width;
    break;

    case hl_url:       icon_width = item_url_width;
    break;

    default:           icon_width = 0;
    break;
  }

  /* Add up the total and exit */

  if (xmin) *xmin = count * item_dir_width;
  if (xmax) *xmax = count * item_dir_width + icon_width + 2 + text_width + 12;

  return NULL;
}

/**************************************************************/
/* hotlist_directory_open_close()                             */
/*                                                            */
/* This function opens or closes a directory, dealing with    */
/* all required redrawing.                                    */
/*                                                            */
/* Parameters: Pointer to the hotlist_item struct             */
/*             representing the directory to open or close;   */
/*                                                            */
/*             Number of that item (counting the visible      */
/*             hotlist items from the top of the window       */
/*             downwards, starting at zero).                  */
/**************************************************************/

static _kernel_oserror * hotlist_directory_open_close(hotlist_item * item, unsigned int itemno)
{
  unsigned int item_height, item_dir_width, item_url_width;
  int          top, window_handle;
  BBox         bbox;

  RetError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  /* Swap the flag saying whether the directory is open or not */

  item->flags ^= HOTLIST_D_IS_OPEN;

  /* Clear all selected items within the directory */

  hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED | HOTLIST_G_REDRAW_NOW);

  /* Do the appropriate redrawing */

  hotlist_preopen();

  RetError(window_get_wimp_handle(0, hotlist_windowid, &window_handle));
  RetError(window_get_extent(0, hotlist_windowid, &bbox));

  top = -itemno * item_height;

  if (item->data.directory_content)
  {
    RetError(wimp_force_redraw(window_handle,
                               bbox.xmin,
                               bbox.ymin,
                               bbox.xmax,
                               top));
  }
  else
  {
    RetError(wimp_force_redraw(window_handle,
                               bbox.xmin,
                               top-item_height,
                               bbox.xmax,
                               top));
  }

  return NULL;
}

/**************************************************************/
/* hotlist_redraw_items()                                     */
/*                                                            */
/* This function forces the redraw of a set of items.         */
/*                                                            */
/* Parameters: Item number of the first item to redraw        */
/*             (counting the visible items from the top of    */
/*             the window downwards, starting at zero) - this */
/*             is inclusive;                                  */
/*                                                            */
/*             Item number of the last item to redraw (also   */
/*             inclusive).                                    */
/**************************************************************/

static _kernel_oserror * hotlist_redraw_items(unsigned int firstitem, unsigned int lastitem)
{
  unsigned int item_height, item_dir_width, item_url_width;
  BBox         bbox;
  int          window_handle;

  /* Get the entry sizes */

  RetError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  /* Find the window extent */

  RetError(window_get_wimp_handle(0, hotlist_windowid, &window_handle));
  RetError(window_get_extent(0, hotlist_windowid, &bbox));

  /* Force a redraw for the whole extent width, over a vertical */
  /* span determined by the given item numbers.                 */

  return wimp_force_redraw(window_handle,
                           bbox.xmin,
                           - (lastitem + 1) * item_height,
                           bbox.xmax,
                           - firstitem * item_height);
}

/**************************************************************/
/* hotlist_clear_selection()                                  */
/*                                                            */
/* This function unselects all items, redrawing as required.  */
/**************************************************************/

_kernel_oserror * hotlist_clear_selection(void)
{
  if (
       hotlist_clear_flags(hotlist_root->data.directory_content,
                           hl_ALL,
                           HOTLIST_G_IS_SELECTED)
     )
     return hotlist_redraw_now();

  return NULL;
}

/**************************************************************/
/* hotlist_launch_url()                                       */
/*                                                            */
/* This function launches the url in the passed item.         */
/*                                                            */
/* Parameters: Pointer to a hotlist_item struct holding the   */
/*             URL to launch.                                 */
/**************************************************************/

static _kernel_oserror * hotlist_launch_url(hotlist_item * item)
{
  #ifdef TRACE
    hotlist_display_item(item);
  #endif

  return windows_create_browser(item->data.url, NULL, NULL, NULL, Windows_CreateBrowser_Normal);
}

/**************************************************************/
/* hotlist_process_click_on_item()                            */
/*                                                            */
/* Deal with clicks on hotlist items.                         */
/*                                                            */
/* Parameters: Item number that was clicked upon (counting    */
/*             visible items from the top of the window       */
/*             downwards, starting with item number 0);       */
/*                                                            */
/*             Pointer to a hotlist_item struct representing  */
/*             the item clicked on;                           */
/*                                                            */
/*             State of the mouse buttons, as                 */
/*             Wimp_GetPointerInfo would return for clicks on */
/*             a window of button type 10                     */
/*             (Double/Click/Drag);                           */
/*                                                            */
/*             Screen x coordinate of the click;              */
/*                                                            */
/*             Screen y coordinate of the click.              */
/**************************************************************/

static _kernel_oserror * hotlist_process_click_on_item(unsigned int itemno, hotlist_item * item, int buttons, int x, int y)
{
  _kernel_oserror * e = NULL;

  switch (buttons)
  {
    /* The window button type is Double/Click/Drag, so */
    /* this represents a double click with Select.     */

    case Wimp_MouseButtonSelect:
    {
      /* Open or close directories, open URLs in a new window */

      if (last_selected_item == itemno)
      {
        switch(item->type)
        {
          case hl_directory: e = hotlist_directory_open_close(item, itemno);
          break;

          case hl_url:       e = hotlist_launch_url(item);
          break;
        }

        if (e) show_error_ret(e);

        /* Deselect the item that was double-clicked upon */

        item->flags &= ~HOTLIST_G_IS_SELECTED;
        e = hotlist_redraw_items(itemno, itemno);
      }
    }
    break;

    /* Double-click with Adjust */

    case Wimp_MouseButtonAdjust:
    {
      /* Open or close directories, but for URLs, open them in */
      /* a new window and close the hotlist.                   */

      if (last_selected_item == itemno)
      {
        switch(item->type)
        {
          case hl_directory: e = hotlist_directory_open_close(item, itemno);
          break;

          case hl_url:
          {
            e = hotlist_launch_url(item);

            if (!e) toolbox_hide_object(0, hotlist_windowid);
          }
          break;
        }

        if (e) show_error_ret(e);

        /* Deselect the item that was double-clicked upon */

        item->flags &= ~HOTLIST_G_IS_SELECTED;
        e = hotlist_redraw_items(itemno, itemno);
      }
    }
    break;

    /* Drag with Select */

    case 64:
    {
      e = hotlist_start_drag();
    }
    break;

    /* Drag with Adjust */

    case 16:
    {
      /* If the item clicked upon wasn't selected, select it */

      if (!(item->flags & HOTLIST_G_IS_SELECTED))
      {
        item->flags |= HOTLIST_G_IS_SELECTED;

        last_selected_item = itemno;
      }

      /* Start the drag and redraw the item clicked upon */

      e = hotlist_start_drag();

      if (!e) e = hotlist_redraw_items(itemno, itemno);
    }
    break;

    /* Click with Select */

    case 1024:
    {
      if (!(item->flags & HOTLIST_G_IS_SELECTED)) /* (Do nothing when selected) */
      {
        /* Clear the selected flags of everything else */

        e = hotlist_clear_selection();

        /* Select this item and if a directory, all items within it */

        item->flags |= HOTLIST_G_IS_SELECTED | HOTLIST_G_REDRAW_NOW;

        if (item->type == hl_directory) hotlist_set_flags(item->data.directory_content,
                                                          hl_ALL,
                                                          HOTLIST_G_IS_SELECTED);

        /* Redraw to reflect the selection */

        if (!e) e = hotlist_redraw_now();
      }

      last_selected_item = itemno;
    }
    break;

    /* Click with Adjust */

    case 256:
    {
      /* Swap the selected state of the item */

      item->flags ^= HOTLIST_G_IS_SELECTED;
      item->flags |= HOTLIST_G_REDRAW_NOW;

      last_selected_item = itemno;

      /* If a directory, select or deselect the contents */

      if (item->type == hl_directory)
      {
        if (item->flags & HOTLIST_G_IS_SELECTED)
        {
          hotlist_set_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
        }
        else
        {
          hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
        }
      }

      /* Redraw to reflect the selection */

      e = hotlist_redraw_now();
    }
    break;
  }

  /* Return any errors that may have been generated */

  return e;
}

/**************************************************************/
/* hotlist_process_click()                                    */
/*                                                            */
/* This function deals with mouse clicks on the hotlist       */
/* window.                                                    */
/*                                                            */
/* Parameters: X position of click, in window coords;         */
/*                                                            */
/*             Y position of click, in window coords;         */
/*                                                            */
/*             Button state (as returned by                   */
/*             Wimp_GetPointerInfo).                          */
/**************************************************************/

static _kernel_oserror * hotlist_process_click(int x, int y, int buttons)
{
  _kernel_oserror * e = NULL;
  hotlist_item    * item;
  unsigned int      item_height, item_dir_width, item_url_width;
  unsigned int      itemno;
  int               xmin, xmax;

  /* Get information on what was clicked upon */

  RetError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  itemno = -y / item_height;
  item   = hotlist_find_item(hotlist_root->data.directory_content, itemno);

  if (item) RetError(hotlist_get_shape(&xmin, &xmax, item));

  if (item && x >= xmin && x <= xmax)
  {
    /* If we have a specific item, process the click on it */

    return hotlist_process_click_on_item(itemno, item, buttons, x, y);
  }
  else
  {
    /* Otherwise, actions depend on the button type */

    switch(buttons)
    {
      /* Drag with Select */

      case 64:
      {
        RetError(hotlist_clear_selection());

        e = hotlist_selection_box_start();
      }
      break;

      /* Drag with Adjust */

      case 16:
      {
        e = hotlist_selection_box_start();
      }
      break;

      /* Click with Select */

      case 1024:
      {
        e = hotlist_clear_selection();

        last_selected_item = 0xffffffff;
      }
      break;

      /* Click with Adjust */

      case 256:
      {
        last_selected_item = 0xffffffff;
      }
      break;
    }
  }

  return e;
}

/**************************************************************/
/* hotlist_preopen()                                          */
/*                                                            */
/* This function should be called before opening the hotlist  */
/* window. If the window is already showing, then the extent  */
/* may be altered but it will never shrink the visible area   */
/* of the window. If the window is currently closed, it will  */
/* set the extent to the minimum possible value, which may    */
/* well drag the visible area down too.                       */
/*                                                            */
/* Returns:    1 if window was already open, or 0 if it was   */
/*             closed.                                        */
/**************************************************************/

static int hotlist_preopen(void)
{
  _kernel_oserror         * e;
  WimpGetWindowStateBlock   state;
  BBox                      bbox;
  ObjectId                  parent_id;
  ComponentId               parent_component;
  unsigned int              item_height, item_dir_width, item_url_width;
  unsigned int              number, maxlen;
  unsigned int              objectstate;
  int                       height, width;

  #define HotlistPreopen_ShowError(e) {if(e){show_error_ret(e);return 0;}}

  /* Is the window open or closed? */

  e = toolbox_get_object_state(0, hotlist_windowid, &objectstate);
  HotlistPreopen_ShowError(e);

  /* Get entry sizes */

  e = hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
  HotlistPreopen_ShowError(e);

  /* General information */

  number = hotlist_count_displayed_items(hotlist_root->data.directory_content);
  maxlen = hotlist_get_max_width(hotlist_root->data.directory_content) + 4;

  /* Find out window details */

  e = window_get_wimp_handle(0, hotlist_windowid, &state.window_handle);
  HotlistPreopen_ShowError(e);

  e = wimp_get_window_state(&state);
  HotlistPreopen_ShowError(e);

  /* Sanity check... */

  if (number < HOTLIST_WINDOW_MIN_HEIGHT) number = HOTLIST_WINDOW_MIN_HEIGHT;
  if (maxlen < HOTLIST_WINDOW_MIN_WIDTH)  maxlen = HOTLIST_WINDOW_MIN_WIDTH;

  /* If the window is open, get its extent */

  if (objectstate & Toolbox_GetObjectState_Showing)
  {
    e = window_get_extent(0, hotlist_windowid, &bbox);
    HotlistPreopen_ShowError(e);
  }

  /* Work out the y extent and x extent required for showing */
  /* as much of the visible items in the hotlist as possible */

  bbox.ymin = -number * item_height;
  bbox.xmax = maxlen;

  /* If the window was already open, don't let the visible */
  /* area change - otherwise go for a best fit to the      */
  /* items, as worked out above.                           */

  if (objectstate & Toolbox_GetObjectState_Showing)
  {
    width  = state.visible_area.xmax - state.visible_area.xmin;
    height = state.visible_area.ymax - state.visible_area.ymin + hotlist_bbar_size;

    if (bbox.ymin > -height) bbox.ymin = -height;
    if (bbox.xmax < width) bbox.xmax = width;
  }

  /* Account for a button bar, if one were present. */

  bbox.ymax = hotlist_bbar_size;
  bbox.xmin = 0;

  /* Set the extent */

  e = window_set_extent(0, hotlist_windowid, &bbox);
  HotlistPreopen_ShowError(e);

  /* (Re)open the window */

  if (objectstate & Toolbox_GetObjectState_Showing)
  {
    e = window_get_wimp_handle(0, hotlist_windowid, &state.window_handle);

    if (!e) e = wimp_get_window_state(&state);
    if (!e) e = toolbox_get_parent(0, hotlist_windowid, &parent_id, &parent_component);
    if (!e) e = toolbox_show_object(0, hotlist_windowid, Toolbox_ShowObject_FullSpec, &(state.visible_area), parent_id, parent_component);

    HotlistPreopen_ShowError(e);
  }

  return !!(objectstate & Toolbox_GetObjectState_Showing);
}

/**************************************************************/
/* hotlist_redraw_handler()                                   */
/*                                                            */
/* This handles redraw events from the Wimp, for the hotlist  */
/* window.                                                    */
/*                                                            */
/* Parameters are as standard for a Wimp event handler.       */
/**************************************************************/

static int hotlist_redraw_handler(int event_code, WimpPollBlock * event, IdBlock * id_block, void * handle)
{
  _kernel_oserror       * e = NULL;
  WimpRedrawWindowBlock   block;
  unsigned int            item_height, item_dir_width, item_url_width;
  unsigned int            first_item, last_item;
  int                     more;

  /* Get entry sizes */

  ChkError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  block.window_handle = event->redraw_window_request.window_handle;

  /* Start the redraw loop */

  wimp_redraw_window(&block, &more);

  while (more && !e)
  {
    /* Work out which bits to redraw... */

    first_item =  -(block.redraw_area.ymax - (block.visible_area.ymax - block.yscroll)) / item_height;
    last_item  = (-(block.redraw_area.ymin - (block.visible_area.ymax - block.yscroll)) / item_height) + 1;

    /* ...and redraw them */

    e = hotlist_draw(hotlist_root->data.directory_content,
                     first_item,
                     last_item);

    /* Get the next redraw rectangle */

    if (!e) e = wimp_get_rectangle(&block, &more);
  }

  return 1;
}

/**************************************************************/
/* hotlist_mouse_click_handler()                              */
/*                                                            */
/* Event handler to deal with mouse clicks in the hotlist     */
/* window; converts coordinates from screen to window, and    */
/* runs the result through hotlist_process_click.             */
/*                                                            */
/* Parameters are as standard for a Wimp event handler.       */
/**************************************************************/

static int hotlist_mouse_click_handler(int event_code, WimpPollBlock * event, IdBlock * id_block, void * handle)
{
  WimpGetWindowStateBlock state;

  state.window_handle = event->mouse_click.window_handle;
  wimp_get_window_state(&state);

  wimp_set_caret_position(state.window_handle, -1, 0, 0, -1, -1);

  ChkError(hotlist_process_click(event->mouse_click.mouse_x + (state.xscroll - state.visible_area.xmin),
                                 event->mouse_click.mouse_y + (state.yscroll - state.visible_area.ymax),
                                 event->mouse_click.buttons));
  return 1;
}

/**************************************************************/
/* hotlist_menuclose_handler()                                */
/*                                                            */
/* Called when menus close.                                   */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_menuclose_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  ObjectId submenu_id;

  /* Deselect any items selected by the menu */

  if (menu_select)
  {
    hotlist_clear_selection();
    menu_select = 0;
  }

  /* Get rid of any submenus */

  ChkError(menu_get_sub_menu_show(0, id_block->self_id, HOTLIST_URL_MENUITEM, &submenu_id));

  if (submenu_id) ChkError(toolbox_delete_object(0, submenu_id));

  ChkError(menu_set_sub_menu_show(0, id_block->self_id, HOTLIST_URL_MENUITEM, 0));

  return 1;
}

/**************************************************************/
/* hotlist_set_menu_details()                                 */
/*                                                            */
/* When a menu is to be opened or the hotlist state changes   */
/* in a way that can affect open menus, this can be used to   */
/* update the menu contents.                                  */
/*                                                            */
/* Parameters: Object ID of the hotlist root menu.            */
/**************************************************************/

static _kernel_oserror * hotlist_set_menu_details(ObjectId menuid)
{
  hotlist_item * item;
  char           entrytext[Limits_Hotlist_ItemName];
  ObjectId       submenu_id;

  switch (hotlist_count_selected_items())
  {
    /* No selected items - set the URL/Directory name string to */
    /* "URL ''" and grey it out, along with the Clear Selection */
    /* entry.                                                   */

    case 0:
    {
      RetError(menu_set_entry_text(0, menuid, HOTLIST_URL_MENUITEM, "URL ''"));

      RetError(menu_set_fade(0, menuid, HOTLIST_URL_MENUITEM, 1));
      RetError(menu_set_fade(0, menuid, HOTLIST_CLEARSELECTION_MENUITEM, 1));
    }
    break;

    /* Only 1 item selected */

    case 1:
    {
      int name_len;

      item = hotlist_find_selected_item();

      switch(item->type)
      {
        /* One directory selected - set the URL/Directory name */
        /* string to a relevant value, and create and attach   */
        /* the relevant submenu.                               */

        case hl_directory:
        {
          StrNCpy0(entrytext, "Dir. '");

          RetError(toolbox_create_object(0, "HLDirmenu", &submenu_id));
          RetError(menu_set_sub_menu_show(0, menuid, HOTLIST_URL_MENUITEM, submenu_id));

          /* If the item is read-only, grey out the 'delete' entry */

          if (item->flags & HOTLIST_G_IS_READ_ONLY) menu_set_fade(0, submenu_id, HOTLIST_DELETE_SUBMENUITEM, 1);
          else                                      menu_set_fade(0, submenu_id, HOTLIST_DELETE_SUBMENUITEM, 0);
        }
        break;

        /* Similarly, deal with a single URL being selected */

        case hl_url:
        {
          StrNCpy0(entrytext, "URL '");

          RetError(toolbox_create_object(0, "HLURLmenu", &submenu_id));
          RetError(menu_set_sub_menu_show(0, menuid, HOTLIST_URL_MENUITEM, submenu_id));

          if (item->flags & HOTLIST_G_IS_READ_ONLY) menu_set_fade(0, submenu_id, HOTLIST_DELETE_SUBMENUITEM, 1);
          else                                      menu_set_fade(0, submenu_id, HOTLIST_DELETE_SUBMENUITEM, 0);
        }
        break;
      }

      name_len = strlen(item->name);

      /* Add the item name in. If the whole item will not fit, put as much as */
      /* will do, followed by '...'.                                          */

      if (name_len < sizeof(entrytext) - strlen(entrytext) - 1) strcat(entrytext, item->name); /* ('<' accounts for terminator, -1 accounts for closing "'") */
      else if (sizeof(entrytext) - strlen(entrytext) > 5)
      {
        strncat(entrytext, item->name, sizeof(entrytext) - strlen(entrytext) - 5);             /* (-5 accounts for closing "'", "..." and terminator)        */
        strcat(entrytext, "...");
      }

      if (strlen(entrytext) < sizeof(entrytext) - 1) strcat(entrytext, "'");

      /* Set the text, unfade the item, and unfade the Clear Selection item */

      RetError(menu_set_entry_text(0, menuid, HOTLIST_URL_MENUITEM, entrytext));

      RetError(menu_set_fade(0, menuid, HOTLIST_URL_MENUITEM, 0));
      RetError(menu_set_fade(0, menuid, HOTLIST_CLEARSELECTION_MENUITEM, 0));
    }
    break;

    /* Many items selected */

    default:
    {
      /* Set the URL/Directory name string, ungrey that item and Clear Selection, */
      /* and create and attach an appropriate submenu.                            */

      RetError(menu_set_entry_text(0, menuid, HOTLIST_URL_MENUITEM, "Selection"));

      RetError(menu_set_fade(0, menuid, HOTLIST_URL_MENUITEM, 0));
      RetError(menu_set_fade(0, menuid, HOTLIST_CLEARSELECTION_MENUITEM, 0));

      RetError(toolbox_create_object(0, "HLSlctmenu", &submenu_id));
      RetError(menu_set_sub_menu_show(0, menuid, HOTLIST_URL_MENUITEM, submenu_id));
    }
    break;

  }

  /* If *everything* is selected, want to grey out Select All; */
  /* else ungrey it.                                           */

  if (hotlist_contents_selected(hotlist_root)) RetError(menu_set_fade(0, menuid, HOTLIST_SELECTALL_MENUITEM, 1));
  else                                         RetError(menu_set_fade(0, menuid, HOTLIST_SELECTALL_MENUITEM, 0));

  /* Set the ticks on 'Show Descriptions' or 'Show URLs' in the */
  /* Display submenu.                                           */

  RetError(menu_get_sub_menu_show(0, menuid, HOTLIST_DISPLAY_MENUITEM, &submenu_id));

  if (hl_show_urls)
  {
    RetError(menu_set_tick(0, submenu_id, HOTLIST_MENU_SHOWDESCRIPTIONS, 0));
    RetError(menu_set_tick(0, submenu_id, HOTLIST_MENU_SHOWURLS, 1));
  }
  else
  {
    RetError(menu_set_tick(0, submenu_id, HOTLIST_MENU_SHOWDESCRIPTIONS, 1));
    RetError(menu_set_tick(0, submenu_id, HOTLIST_MENU_SHOWURLS, 0));
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* hotlist_menuopen_handler()                                 */
/*                                                            */
/* Handles events raised when menus are about to be shown.    */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_menuopen_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  WimpGetWindowStateBlock   state;
  WimpGetPointerInfoBlock   pointerblock;
  hotlist_item            * item;
  unsigned int              item_height, item_dir_width, item_url_width;
  int                       xmin, xmax, window_handle;
  ObjectId                  sub_menu;

  /* Get entry sizes. */

  ChkError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  if (event_code == EHotlistToBeShown)
  {
    /* Work out which item the pointer was over. */

    ChkError(window_get_wimp_handle(0, hotlist_windowid, &window_handle));

    state.window_handle = window_handle;
    ChkError(wimp_get_window_state(&state));

    ChkError(wimp_get_pointer_info(&pointerblock));

    pointerblock.x = pointerblock.x + (state.xscroll - state.visible_area.xmin);
    pointerblock.y = pointerblock.y + (state.yscroll - state.visible_area.ymax);

    menu_itemno = -pointerblock.y / item_height;
  }

  ChkError(menu_get_sub_menu_show(0, id_block->self_id, HOTLIST_DISPLAY_MENUITEM, &sub_menu));

  /* If there are no selected items, select the one the menu */
  /* was opened over.                                        */

  if (hotlist_count_selected_items() == 0)
  {
    item = hotlist_find_item(hotlist_root->data.directory_content, menu_itemno);

    if (item) ChkError(hotlist_get_shape(&xmin, &xmax, item));

    if (item && pointerblock.x >= xmin && pointerblock.x <= xmax)
    {
      item->flags |= HOTLIST_G_IS_SELECTED | HOTLIST_G_REDRAW_NOW;
      if (item->type == hl_directory) hotlist_set_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);

      menu_select = 1;

      ChkError(hotlist_redraw_now());
    }
  }

  /* Update the menus */

  ChkError(hotlist_set_menu_details(id_block->self_id));

  return 0;
}

/**************************************************************/
/* hotlist_save_entries()                                     */
/*                                                            */
/* This function recurses through the hotlist directory       */
/* structure saving all directories and entries as it goes.   */
/*                                                            */
/* Parameters: Pointer to a FILE struct for the file to write */
/*             to;                                            */
/*                                                            */
/*             Pointer to a hotlist_item struct representing  */
/*             the first item in the directory to save (which */
/*             may itself be a directory);                    */
/*                                                            */
/*             0 - save all of hotlist, 1 - only save         */
/*             selection portions, but in both cases obey the */
/*             next parameter;                                */
/*                                                            */
/*             0 - don't save read-only items, 1 - allow      */
/*             saving of read-only items.                     */
/*                                                            */
/* Assumes:    The FILE pointer must not be NULL however the  */
/*             hotlist_item pointer can be (e.g. an empty     */
/*             directory).                                    */
/**************************************************************/

static _kernel_oserror * hotlist_save_entries(FILE * fileptr, hotlist_item * list, int type, int save_read_only)
{
  int written;

  /* Follow the directory list */

  while (list)
  {
    /* Don't save read-only entries unless told to */

    if (save_read_only || !(list->flags & HOTLIST_G_IS_READ_ONLY))
    {
      switch (list->type)
      {
        /* Write a link for URLs */

        case hl_url:
        {
          if (type == 0 || (type == 1 && list->flags & HOTLIST_G_IS_SELECTED))
          {
            HotlistWrite(fprintf(fileptr, "<li><a href=\"%s\">%s</a>\n", list->data.url, list->name));
          }
        }
        break;

        /* Write a heading for directories */

        case hl_directory:
        {
          if (type == 0 || !hotlist_no_contents_selected(list->data.directory_content))
          {
            if (type == 0 || (type == 1 && list->flags & HOTLIST_G_IS_SELECTED))
            {
              HotlistWrite(fprintf(fileptr, "<h4>%s</h4>\n", list->name));

              if (list->flags & HOTLIST_D_IS_OPEN)
              {
                HotlistWrite(fprintf(fileptr, "<ul><!--open-->\n"));
              }
              else
              {
                HotlistWrite(fprintf(fileptr, "<ul>\n"));
              }
            }
            /* Recursive call for the directory contents First, */
            /* write the entry header.                          */

            /* Do the contents */

            RetError(hotlist_save_entries(fileptr, list->data.directory_content, type, save_read_only));
            if (type == 0 || (type == 1 && list->flags & HOTLIST_G_IS_SELECTED))
            {
              HotlistWrite(fprintf(fileptr, "</ul>\n"));
            }
          }
        }
        break;
      }
    }

    /* Continue down the list */

    list = list->next;
  }

  return NULL;

  /* Error condition exit */

hotlist_save_error:

  RetLastE;
}

/**************************************************************/
/* hotlist_save_hotlist()                                     */
/*                                                            */
/* This function saves the hotlist as an HTML file.           */
/*                                                            */
/* Parameters: Pointer to the filename to save to (null       */
/*             terminated);                                   */
/*                                                            */
/*             Pointer to a buffer containing any extra       */
/*             information to put in the top of the file      */
/*             (intended for multiuser builds);               */
/*                                                            */
/*             0 to save all of hotlist, 1 to save only the   */
/*             selected portions.                             */
/**************************************************************/

_kernel_oserror * hotlist_save_hotlist(char * filename, char * extradata, int type)
{
  _kernel_oserror * e;
  FILE            * fileptr;
  static char     * local_path = NULL;
  int               written;

  if (!filename || !*filename) return NULL;

  /* Canonicalise the path */

  RetError(utils_canonicalise_path(filename, &local_path));

  /* Ensure it is present */

  e = utils_build_tree(local_path);

  if (e)
  {
    free(local_path);
    return e;
  }

  /* Could take a while... */

  _swix(Hourglass_On, 0);

  /* Open the file for writng */

  fileptr = fopen(local_path, "wb");

  /* Complain if it fails */

  if (fileptr == NULL)
  {
    free(local_path);
    RetLastE;
  }

  /* Write the extra data */

  if (extradata) HotlistWrite(fprintf(fileptr, "%s", extradata));

  /* Write the file header */

  HotlistWrite(fprintf(fileptr, "<html>\n"
                                "<head>\n"
                                CHARSET_SPECIFIER
                                "<title>"));

  HotlistWrite(fprintf(fileptr, "%s", lookup_token("HotlistHTMLTitle:Hotlist",0,0)));

  HotlistWrite(fprintf(fileptr, "</title>\n"
                                "</head>\n"
                                "<body>\n"
                                "<ul>\n"));

  /* Fill in the body */

  e = hotlist_save_entries(fileptr,
                           hotlist_root->data.directory_content,
                           type,
                           type == 1 ? 1 : 0); /* If saving part of the hotlist, allow saving of read-only components */

  if (e)
  {
    _swix(Hourglass_Off, 0);

    fclose(fileptr);
    free(local_path);

    return e;
  }

  /* Write the footer and close the file */

  HotlistWrite(fprintf(fileptr, "</ul>\n"));
  HotlistWrite(fprintf(fileptr, "</body>\n"));
  HotlistWrite(fprintf(fileptr, "</html>\n"));

  fclose(fileptr);

  _swix(Hourglass_Off, 0);

  /* Set the filetype to HTML (0xfaf) */

  e = _swix(OS_File,
            _INR(0,2),

            18,
            local_path,
            FileType_HTML);

  free(local_path);

  return e;

  /* Error condition exit */

hotlist_save_error:

  StrLastE;

  if (fileptr)
  {
    fclose(fileptr);

    _swix(Hourglass_Off, 0);
  }

  free(local_path);

  return &erb;
}

/**************************************************************/
/* hotlist_save()                                             */
/*                                                            */
/* Veneer onto hotlist_save_hotlist - saves all of the        */
/* hotlist, created to preserve API.                          */
/*                                                            */
/* Parameters: Pointer to the filename to save to (null       */
/*             terminated).                                   */
/**************************************************************/

_kernel_oserror * hotlist_save(char * filename)
{
  return hotlist_save_hotlist(filename, NULL, 0); /* Save entire hotlist */
}

/**************************************************************/
/* hotlist_lower_tags()                                       */
/*                                                            */
/* This function processes the passed string turning all      */
/* characters within a tag to lower case. It will detect      */
/* characters within quotes and leave their case the same;    */
/* this will preserve the case of URLs.                       */
/*                                                            */
/* Obviously, this assumes that the HTML file being fed in is */
/* not broken; tags and quoted text must always be correctly  */
/* closed, and in both cases must not span multiple lines.    */
/*                                                            */
/* Parameters: Pointer to the string to process.              */
/**************************************************************/

static void hotlist_lower_tags(char *string)
{
  int intag = 0, inquotes = 0;

  while (*string)
  {
    if (intag)
    {
      if (inquotes)
      {
        if (*string == '"') inquotes = 0;
      }
      else
      {
        if (*string == '"') inquotes = 1;
        if (*string == '>') intag --;

        *string = tolower(*string);
      }
    }
    else
    {
      if (*string == '<') intag++;
    }

    string++;
  }
}

/**************************************************************/
/* hotlist_load_directory()                                   */
/*                                                            */
/* This function loads the directory contents of a hotlist    */
/* HTML file previously saved by hotlist_save or a compatible */
/* source. For example, at the time of creation this can      */
/* correctly load and understand hotlist files from at least  */
/* one other popular browser.                                 */
/*                                                            */
/* Parameters: Pointer to a FILE struct through which data    */
/*             will be read;                                  */
/*                                                            */
/*             Pointer to a hotlist_item; new data structures */
/*             generated from the file contents are added to  */
/*             the linked list that this struct lies in.      */
/**************************************************************/

static _kernel_oserror * hotlist_load_directory(FILE * fileptr, hotlist_item * target)
{
  _kernel_oserror * e = NULL;

  static char     * next_directory_name = NULL;
  static char     * string_buffer       = NULL;
  static char     * str_ptr;

  char            * url;
  hotlist_item    * new_dir;
  unsigned int      unfollowed_uls = 0;
  long int          file_position;
  int               character, count;
  int               target_type;

  /* Go through the file in chunks */

  target_type = 0; /* At end of directory */

  while (!feof(fileptr)) /* In theory the code below means you'll never get this; but just to be safe... */
  {
    file_position = ftell(fileptr);

    /* Scan ahead to find the end of line - marked by any */
    /* control character, in this case; need to include   */
    /* as many consecutive control chars as are present   */
    /* in the file, in the count.                         */

    do
    {
      /* First, get to either a control char or EOF */

      character = fgetc(fileptr);
    }
    while (character > 31 && character != EOF);

    while (character < 32 && character != EOF)
    {
      /* If we're not on EOF, continue until we're no longer */
      /* on a control char or hit EOF.                       */

      character = fgetc(fileptr);
    }

    /* Work out how many bytes we've read */

    count = (int) (ftell(fileptr) - file_position);

    /* If count is zero, we're at the end of the file */

    if (!count) break;

    /* If we're not on EOF and don't have a control char, then */
    /* we overshot by one; so we would want to subtract one    */
    /* from count. However, to ensure string manipulation      */
    /* works OK, we'll need one char to null terminate the     */
    /* string. So in that case, we need to *add* one to count  */
    /* if the above condition isn't true.                      */

    if (!(character > 31 && character != EOF)) count ++;

    /* Right, after all that messing around rewind to the stored */
    /* file position and allocate a buffer for this string.      */

    if (fseek(fileptr, file_position, SEEK_SET))
    {
      StrLastE;

      e = &erb;

      goto hotlist_load_directory_exit; /* (See near end of function) */
    }

    /* Note that string_buffer is a static, as this way only one */
    /* of these buffers ever exists, even for recursive calls.   */

    if (string_buffer) free(string_buffer);

    string_buffer = malloc(count);

    /* Complain if the allocation fails */

    if (!string_buffer)
    {
      StrLastE;

      e = &erb;

      goto hotlist_load_directory_exit; /* (See near end of function) */
    }

    /* Read the data and force a terminator at the end of the buffer, */
    /* just to be safe.                                               */

    if (fread(string_buffer, sizeof(char), count - 1, fileptr) != count - 1)
    {
      StrLastE;

      e = &erb;

      goto hotlist_load_directory_exit; /* (See near end of function) */
    }

    string_buffer[count - 1] = 0;

    /* Convert tags to lower case */

    hotlist_lower_tags(string_buffer);

    /* Treat any opening '<h...>' tag (header) as the title to a directory */

    str_ptr = strstr(string_buffer, "<h");

    if (
         str_ptr           &&
         str_ptr[2] >= '1' &&
         str_ptr[2] <= '6' &&
         str_ptr[3] == '>'
       )
    {
      /* Read the directory name (up to the closing '</h...>') */

      str_ptr = strtok(str_ptr + 4, "<");

      /* Allocate space for it */

      if (next_directory_name) free(next_directory_name);

      next_directory_name = malloc(strlen(str_ptr) + 1);

      /* Complain if the allocation fails */

      if (!next_directory_name)
      {
        e = make_no_memory_error(3);

        goto hotlist_load_directory_exit; /* (See near end of function) */
      }

      /* Otherwise, copy the name in */

      strcpy(next_directory_name, str_ptr);
    }

    /* Treat any '<a href=...>' attribute contents (link) as a URL for the hotlist */

    else if ((str_ptr = strstr(string_buffer, "<a href=\"")) != NULL) /* Using '!= NULL' stops a compiler warning... */
    {
      /* First extract the URL */

      str_ptr += 9; /* Derived from strlen("<a href=\"") */

      str_ptr = strtok(str_ptr, "\"");

      /* Because we're about to use strtok() to extract the title, it'll */
      /* put a convenient terminator into the string_buffer block at the */
      /* end of the URL. So all we need to do is record the current      */
      /* pointer in the block, str_ptr, for use when we finally add the  */
      /* item to the hotlist.                                            */

      url = str_ptr;

      /* Extract the title - between the closing '>' of the '<a href=...' */
      /* and the opening '<' of the '</a>'.                               */

      str_ptr = strtok(NULL, "><");

      /* Get ready to add this item, provided that the URL string has */
      /* ':/' in - i.e. looks fully specified                        */

      if (strstr(url, ":/"))
      {
        if (target_type == 0)
        {
          e = hotlist_new_url(target, HOTLIST_POSITION_END, str_ptr, url);
          target_type = 1;
        }
        else
        {
          e = hotlist_new_url(target, HOTLIST_POSITION_AFTER, str_ptr, url);
        }
        if (e) goto hotlist_load_directory_exit; /* (See near end of function) */

        target = hotlist_newitem;
      }
    }

    /* Treat any '<ul>' tags as the start of a new directory. The name comes */
    /* from a preceeding '<h...>' tag (see above).                           */

    else if ((str_ptr = strstr(string_buffer, "<ul>")) != NULL) /* New directory */
    {
      if (!next_directory_name)
      {
        /* If we don't have a directory name for this one, apparently, flag it */
        /* by incrementing the unmatched '<ul>' counter.                       */

        unfollowed_uls ++;
      }
      else
      {
        /* Otherwise, add the directory */

        if (target_type == 0)
        {
          e = hotlist_new_directory(target, next_directory_name, HOTLIST_POSITION_END, &new_dir);
          target_type = 1;
        }
        else
        {
          e = hotlist_new_directory(target, next_directory_name, HOTLIST_POSITION_AFTER, &new_dir);
        }
        if (e) goto hotlist_load_directory_exit;

        target = hotlist_newitem;

        if (strstr(string_buffer, "<!--open-->") != NULL)
        {
          new_dir->flags |= HOTLIST_D_IS_OPEN;
        }

        free(next_directory_name);
        next_directory_name = NULL;

        /* If the directory was added, recursively load the contents */

        if (new_dir)
        {
          /* Note this will invalidate string_buffer. The contents must */
          /* not be used after the call!                                */

          e = hotlist_load_directory(fileptr, new_dir);
          if (e) goto hotlist_load_directory_exit; /* (See near end of function) */
        }
        else
        {
          /* If the directory was not added, flag it */

          unfollowed_uls ++;
        }
      }
    }

    /* Treat any '</ul>' tags as the end of a directory. */

    else if ((str_ptr = strstr(string_buffer, "</ul>")) != NULL) /* Close directory */
    {
      /* If we have unfollowed '<ul>' tags, decrement the counter; */
      /* otherwise, exit quietly.                                  */

      if (unfollowed_uls) unfollowed_uls--;
      else goto hotlist_load_directory_exit; /* (See near end of function) */
    }
  }

  /* This section is not necessarily an error exit condition, so */
  /* the code falls through to it in normal running. If 'e' is   */
  /* NULL there's still no error returned in the end. Note       */
  /* though how the various buffers are freed, and thus          */
  /* invalidated, at this point; so during recursive routines,   */
  /* they must not be accessed after the recursive call has      */
  /* been made (unless, of course, they are reallocated).        */

hotlist_load_directory_exit:

  /* Free up the temporary buffers */

  if (string_buffer)
  {
    free(string_buffer);
    string_buffer = NULL;
  }

  if (next_directory_name)
  {
    free(next_directory_name);
    next_directory_name = NULL;
  }

  // We could at this point give a warning if unfollowed_uls is non-zero.

  return e;
}

/**************************************************************/
/* hotlist_discard()                                          */
/*                                                            */
/* Empties the hotlist. The hotlist window is not updated     */
/* (expected usage is to close the window shotly before or    */
/* after discarding the contents).                            */
/**************************************************************/

void hotlist_discard(void)
{
  while (hotlist_root->data.directory_content)
  {
    hotlist_delete_item(hotlist_root->data.directory_content);
  }
}

/**************************************************************/
/* hotlist_load()                                             */
/*                                                            */
/* This function loads an HTML file previously saved by       */
/* hotlist_save as the new hotlist.                           */
/*                                                            */
/* Parameters: Pointer to the filename to load (null          */
/*             terminated).                                   */
/**************************************************************/

_kernel_oserror * hotlist_load(char * filename)
{
  _kernel_oserror * e;
  static char     * local_path = NULL;
  FILE            * fileptr;

  if (!filename || !*filename) return NULL;

  local_path = malloc(strlen(filename) + 1);
  if (!local_path) return NULL;

  strcpy(local_path, filename);

  /* First delete all the existing hotlist items */

  hotlist_discard();

  /* Open the file */

  fileptr = fopen(local_path, "r");

  if (fileptr == NULL)
  {
    free(local_path);

    erb.errnum = Utils_Error_Custom_Normal;
    StrNCpy0(erb.errmess,
             lookup_token("HlCantLoad:Hotlist file could not be loaded",
                          0,
                          0));
    return &erb;
  }

  /* Load it (any errors are returned right at the end) */

  e = hotlist_load_directory(fileptr, hotlist_root);

  fclose(fileptr);

  /* Clear all of the various flags for redraw, */
  /* selection etc. now that we have a new      */
  /* hotlist.                                   */

  hotlist_clear_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);

  #ifdef TRACE

    /* Show the tree now the file is loaded */

    hotlist_display_tree(hotlist_root, 0);

  #endif

  /* Finished; redraw issues are left to the caller */

  if (!e) e = hotlist_modified(HL_MODIFIED_LOAD);

  free(local_path);

  return e;
}

/**************************************************************/
/* hotlist_initialise()                                       */
/*                                                            */
/* This function initialises the hotlist library routines,    */
/* and must be called before any other hotlist functions.     */
/**************************************************************/

_kernel_oserror * hotlist_initialise(void)
{
  ObjectId     toolbar;
  ObjectId     menu_id;
  BBox         bbox;
  unsigned int item_height, item_dir_width, item_url_width;
  char         root[] = "Root";

  /* Set some initial flags */

  hotlist_dragging.drag_type    = HOTLIST_NOT_DRAGGING;
  hotlist_dragging.using_adjust = 0;

  /* Create root directory item */

  RetError(hotlist_new_directory(NULL, root, 0, &hotlist_root));

  /* Create the hotlist window */

  RetError(toolbox_create_object(0, "HotlistWind", &hotlist_windowid));

  /* Is there a toolbar? */

  RetError(window_get_tool_bars(InternalTopLeft,
                                hotlist_windowid,
                                NULL,
                                &toolbar,
                                NULL,
                                NULL));

  /* If so, read the size */

  if (toolbar != 0)
  {
    RetError(window_get_extent(0, toolbar, &bbox));

    hotlist_bbar_size = bbox.ymax - bbox.ymin;
  }
  else hotlist_bbar_size = 0;

  /* Read sprite sizes to see if the sprites actually exist */

  RetError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  /* Register event handlers for redraw, clicks and drags in the */
  /* main hotlist window.                                        */

  RetError(event_register_wimp_handler(hotlist_windowid,
                                       Wimp_ERedrawWindow,
                                       hotlist_redraw_handler,
                                       NULL));

  RetError(event_register_wimp_handler(hotlist_windowid,
                                       Wimp_EMouseClick,
                                       hotlist_mouse_click_handler,
                                       NULL));

  RetError(event_register_wimp_handler(-1,
                                       Wimp_EUserDrag,
                                       hotlist_drag_completed_handler,
                                       NULL));

  /* Menu handlers */

  RetError(window_get_menu(0, hotlist_windowid, &menu_id));

  RetError(event_register_toolbox_handler(menu_id,
                                          EHotlistToBeShown,
                                          hotlist_menuopen_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(menu_id,
                                          EHotlistHidden,
                                          hotlist_menuclose_handler,
                                          NULL));

  /* Main menu items */

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistSelectAll,
                                          hotlist_select_all_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistClearSelect,
                                          hotlist_clear_selection_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistOpenAll,
                                          hotlist_menu_openall_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistCloseAll,
                                          hotlist_menu_closeall_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistDelete,
                                          hotlist_menu_delete_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistSaveToServer,
                                          hotlist_save_to_server_handler, /* a.k.a. Save As Default */
                                          NULL));

  /* Submenu warning events */

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistShowEditURL,
                                          hotlist_show_editurl_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistShowRenameDirectory,
                                          hotlist_show_rendirectory_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistShowNewURL,
                                          hotlist_show_newurl_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistShowNewDirectory,
                                          hotlist_show_newdirectory_handler,
                                          NULL));

  /* Hotlist related dialogue events */

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistClose,
                                          hotlist_close_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistNewEditURLOK,
                                          hotlist_newedit_url_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistNewEditURLCancel,
                                          hotlist_reset_url_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistNewRenameDirectoryOK,
                                          hotlist_newren_directory_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistNewRenameDirectoryCancel,
                                          hotlist_reset_directory_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistShowDescriptions,
                                          hotlist_show_descriptions_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistShowURLs,
                                          hotlist_show_urls_handler,
                                          NULL));

  RetError(event_register_toolbox_handler(-1,
                                          EHotlistCancelDrag,
                                          hotlist_drag_stop_handler,
                                          NULL));

  return NULL;
}

/**************************************************************/
/* hotlist_open()                                             */
/*                                                            */
/* Opens the hotlist window. If already open, all this does   */
/* is bring it to the front - it doesn't move it. The display */
/* type is changed, if required, in any case.                 */
/*                                                            */
/* Parameters: Show type (as for a call to                    */
/*             Toolbox_ShowObject);                           */
/*                                                            */
/*             Show block (as for a call to                   */
/*             Toolbox_ShowObject);                           */
/*                                                            */
/*             0 to open showing descriptions, or 1 to open   */
/*             showing URLs.                                  */
/**************************************************************/

_kernel_oserror * hotlist_open(int show_type, void * type, int show_urls)
{
  int               open, old_show_urls;
  _kernel_oserror * e;

  old_show_urls = hl_show_urls;

  /* Sets show descriptions / show URLs */

  hl_show_urls = show_urls;

  /* Set the size of the window etc. */

  open = hotlist_preopen();

  /* Show the hotlist. We have to do this twice; if we try to centre */
  /* it just the once, then that call seems to read the visible area */
  /* as it was *before* hotlist_preopen changed the extent.          */
  /*                                                                 */
  /* This Is Bad. In any case, for opening centred, we want to open  */
  /* full size, if not already open.                                 */

  if (open)
  {
    /* Open window once to let the wimp/toolbox see what shape it really is,  */
    /* but don't fiddle with the visible area as the window was already open. */

    e = toolbox_show_object(0,
                            hotlist_windowid,
                            Toolbox_ShowObject_Default,
                            0,
                            0,
                            -1);
  }
  else
  {
    BBox                  extent;
    WindowShowObjectBlock show;

    RetError(window_get_extent(0, hotlist_windowid, &extent));

    show.visible_area = extent;
    show.behind       = -3;

    e = toolbox_show_object(0,
                            hotlist_windowid,
                            Toolbox_ShowObject_FullSpec,
                            &show,
                            0,
                            -1);

    /* Open it once again in the place the window is really wanted */

    e = toolbox_show_object(0,
                            hotlist_windowid,
                            show_type,
                            type,
                            0,
                            -1);
  }

  /* Redraw the window if the display type has changed */

  if (!e && open && hl_show_urls != old_show_urls)
  {
    hotlist_redraw_items(0, hotlist_count_displayed_items(hotlist_root->data.directory_content));
  }

  return e;
}

/**************************************************************/
/* hotlist_close()                                            */
/*                                                            */
/* Closes the hotlist window.                                 */
/**************************************************************/

_kernel_oserror * hotlist_close(void)
{
  if (hotlist_windowid) return toolbox_hide_object(0, hotlist_windowid);
  else                  return NULL;
}

/**************************************************************/
/* hotlist_close_handler()                                    */
/*                                                            */
/* Closes the hotlist window. .                               */
/**************************************************************/

static int hotlist_close_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  ChkError(hotlist_close());

  return 1;
}

/**************************************************************/
/* hotlist_select_all_handler()                               */
/*                                                            */
/* This function handles the 'select all' menu item.          */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_select_all_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  ObjectId main_menu;

  menu_select = 0;

  /* Select everything */

  hotlist_set_flags(hotlist_root, hl_ALL, HOTLIST_G_IS_SELECTED);
  hotlist_root->flags &= ~HOTLIST_G_IS_SELECTED;

  hotlist_redraw_now();

  /* Get the main menu ID */

  ChkError(window_get_menu(0, hotlist_windowid, &main_menu));

  /* Update the main menu contents to reflect the new state */

  hotlist_set_menu_details(main_menu);

  return 1;
}

/**************************************************************/
/* hotlist_clear_selection_handler()                          */
/*                                                            */
/* This function handles the clear selection menu item        */
/**************************************************************/

static int hotlist_clear_selection_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  ObjectId main_menu;

  menu_select = 0;

  /* Get the main menu ID */

  ChkError(window_get_menu(0, hotlist_windowid, &main_menu));

  /* Clear the selection */

  hotlist_clear_selection();

  /* Update the main menu */

  hotlist_set_menu_details(main_menu);

  return 1;
}

/**************************************************************/
/* hotlist_menu_openall_handler()                             */
/*                                                            */
/* Deal with the Open All menu item.                          */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_menu_openall_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  if (hotlist_root->data.directory_content)
  {
    menu_itemno = 0;

    /* Set all Open flags, clear all Redraw Now flags, and force a redraw of everything */

    hotlist_set_flags  (hotlist_root->data.directory_content, hl_directory, HOTLIST_D_IS_OPEN);
    hotlist_clear_flags(hotlist_root->data.directory_content, hl_directory, HOTLIST_G_REDRAW_NOW);

    ChkError(hotlist_redraw_items(0, hotlist_count_displayed_items(hotlist_root->data.directory_content)));

    hotlist_preopen();
  }

  return 1;
}

/**************************************************************/
/* hotlist_menu_closeall_handler()                            */
/*                                                            */
/* Deal with the Close All menu item.                         */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_menu_closeall_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  unsigned int noitems;
  ObjectId     main_menu;

  if (hotlist_root->data.directory_content)
  {
    menu_itemno = 0;

    /* Clear all Open and Redraw Now flags, and deselect all items */

    noitems = hotlist_count_displayed_items(hotlist_root->data.directory_content);

    hotlist_clear_flags(hotlist_root->data.directory_content,
                        hl_directory,
                        HOTLIST_D_IS_OPEN | HOTLIST_G_REDRAW_NOW);

    ChkError(hotlist_clear_selection());
    ChkError(hotlist_redraw_items(0, noitems));

    /* Get the main menu ID */

    ChkError(window_get_menu(0, hotlist_windowid, &main_menu));

    /* Update the menus to reflect there's nothing selected */

    ChkError(hotlist_set_menu_details(main_menu));

    hotlist_preopen();
  }

  return 1;
}

/**************************************************************/
/* hotlist_menu_delete_handler()                              */
/*                                                            */
/* Deal with the Delete menu item.                            */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_menu_delete_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  hotlist_item * item;
  unsigned int   noitems;
  ObjectId       hotlist_window;
  int            deleted = 0;

  if (!id_block->ancestor_id) hotlist_window = id_block->self_id;
  else                        hotlist_window = id_block->ancestor_id;

  /* If there are no selected items, can't do anything */

  noitems = hotlist_count_displayed_items(hotlist_root->data.directory_content);

  if (!hotlist_count_selected_items()) return 0;

  /* If there's a drag in progress, cancel it */

  if (
       hotlist_dragging.drag_type == HOTLIST_BOX_DRAG          ||
       hotlist_dragging.drag_type == HOTLIST_SOLID_DRAG_OBJECT ||
       hotlist_dragging.drag_type == HOTLIST_SOLID_DRAG_SPRITE
     )
     hotlist_drag_stop_handler(0, NULL, NULL, NULL);

  /* Make sure all menus are closed - a bit draconian but it */
  /* avoids various possible combinations of things getting  */
  /* out of date.                                            */

  _swix(Wimp_CreateMenu,
        _IN(1),

        -1);

  /* Delete all selected items */

  while ((item = hotlist_find_selected_item()) != NULL)
  {
    if (item->flags & HOTLIST_G_IS_READ_ONLY)
    {
      /* Just clear selection on read only items */

      item->flags &= ~HOTLIST_G_IS_SELECTED;
    }
    else
    {
      /* Delete read/write items */

      deleted ++;

      hotlist_delete_item(item);
    }
  }

  /* Redraw */

  hotlist_redraw_items(0, noitems);

  /* We may have no more work to do if all of the selected items */
  /* were read-only; otherwise, 'deleted' will be non-zero.      */

  if (deleted)
  {
    /* Update the window extent */

    hotlist_preopen();

    /* The hotlist has been modified... */

    hotlist_modified(HL_MODIFIED_DELETE);
  }

  /* Finished */

  return 1;
}

/**************************************************************/
/* hotlist_save_to_server_handler()                           */
/*                                                            */
/* Deal with the 'Save to server' menu item (also known as    */
/* 'Save as default').                                        */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_save_to_server_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  #ifdef SINGLE_USER

    show_error_ret(hotlist_save(lookup_choice("HotlistSave:Browse:User.Hotlist",0,0)));

  #else

    show_error_ret(multiuser_save_hotlist());

  #endif

  return 1;
}

/**************************************************************/
/* hotlist_show_newurl_handler()                              */
/*                                                            */
/* This function fills in the edit / create URL dialogue to   */
/* be a New URL object.                                       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_show_newurl_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  ObjectId dboxid;

  dprintf(("Hotl", "hotlist_show_newurl_handler: Called\n"));

  ChkError(menu_get_sub_menu_show(0, id_block->self_id, id_block->self_component, &dboxid));

  alter_new = HOTLIST_MENUSECTION_NEW;

  /* Set the title, clear the description writable and URL writable, */
  /* and set the default action button text. 'Cancel' stays as       */
  /* 'Cancel'.                                                       */

  ChkError(window_set_title(0, dboxid, lookup_token("HotlistCreateURLTitle:Create new URL",0,0)));

  ChkError(writablefield_set_value(0, dboxid, HOTLIST_NEWURL_NAME, ""));
  ChkError(writablefield_set_value(0, dboxid, HOTLIST_NEWURL_URL,  ""));

  ChkError(actionbutton_set_text  (0, dboxid, HOTLIST_NEWURL_NEW,  lookup_token("HotlistCreateURLAction:Create",0,0)));

  return 1;
}

/**************************************************************/
/* hotlist_show_editurl_handler()                             */
/*                                                            */
/* This function fills in the edit / create URL dialogue to   */
/* be an Edit URL object.                                     */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_show_editurl_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  hotlist_item * item;
  ObjectId       dboxid;

  dprintf(("Hotl", "hotlist_show_editurl_handler: Called\n"));

  /* Must have a selected item... */

  item = hotlist_find_selected_item();
  if (!item) return 0;

  ChkError(menu_get_sub_menu_show(0, id_block->self_id, id_block->self_component, &dboxid));

  alter_new = HOTLIST_MENUSECTION_ALTER;

  /* Set the title, description writable, URL writable, and  */
  /* default action button text. 'Cancel' stays as 'Cancel'. */

  ChkError(window_set_title(0, dboxid, lookup_token("HotlistEditURLTitle:Edit URL",0,0)));

  ChkError(writablefield_set_value(0, dboxid, HOTLIST_NEWURL_NAME, item->name));
  ChkError(writablefield_set_value(0, dboxid, HOTLIST_NEWURL_URL,  item->data.url));

  ChkError(actionbutton_set_text  (0, dboxid, HOTLIST_NEWURL_NEW,  lookup_token("HotlistEditURLAction:Alter",0,0)));

  /* If the item's flags show it is read-only, it can't be altered */

  if (item->flags & HOTLIST_G_IS_READ_ONLY) set_gadget_state(dboxid, HOTLIST_NEWURL_NEW, 1);
  else                                      set_gadget_state(dboxid, HOTLIST_NEWURL_NEW, 0);

  return 1;
}

/**************************************************************/
/* hotlist_show_newdirectory_handler()                        */
/*                                                            */
/* This function fills in the edit / create directory         */
/* dialogue to be a New Directory object.                     */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_show_newdirectory_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  ObjectId dboxid;

  dprintf(("Hotl", "hotlist_show_newdirectory_handler: Called\n"));

  ChkError(menu_get_sub_menu_show(0, id_block->self_id, id_block->self_component, &dboxid));

  alter_new = HOTLIST_MENUSECTION_NEW;

  /* Set the title, clear the writable contents, and set */
  /* the default action button text. 'Cancel' stays as   */
  /* 'Cancel'.                                           */

  ChkError(window_set_title(0, dboxid, lookup_token("HotlistCreateDirTitle:Create new directory",0,0)));

  ChkError(writablefield_set_value(0, dboxid, HOTLIST_NEWDIRECTORY_NAME, ""));
  ChkError(actionbutton_set_text  (0, dboxid, HOTLIST_NEWDIRECTORY_NEW,  lookup_token("HotlistCreateDirAction:Create",0,0)));

  return 1;
}

/**************************************************************/
/* hotlist_show_rendirectory_handler()                        */
/*                                                            */
/* This function fills in the edit / create directory         */
/* dialogue to be a Rename Directory object.                  */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_show_rendirectory_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  hotlist_item * item;
  ObjectId       dboxid;

  dprintf(("Hotl", "hotlist_show_rendirectory_handler: Called\n"));

  /* Must have a selected item... */

  item = hotlist_find_selected_item();
  if (!item) return 0;

  ChkError(menu_get_sub_menu_show(0, id_block->self_id, id_block->self_component, &dboxid));

  alter_new = HOTLIST_MENUSECTION_ALTER;

  /* Set the title, writable contents, and default action */
  /* button text. 'Cancel' stays as 'Cancel'.             */

  ChkError(window_set_title(0, dboxid, lookup_token("HotlistRenameDirTitle:Rename directory",0,0)));

  ChkError(writablefield_set_value(0, dboxid, HOTLIST_NEWDIRECTORY_NAME, item->name));
  ChkError(actionbutton_set_text  (0, dboxid, HOTLIST_NEWDIRECTORY_NEW,  lookup_token("HotlistRenameDirAction:Rename",0,0)));

  /* If the item's flags show it is read-only, it can't be renamed */

  if (item->flags & HOTLIST_G_IS_READ_ONLY) set_gadget_state(dboxid, HOTLIST_NEWDIRECTORY_NEW, 1);
  else                                      set_gadget_state(dboxid, HOTLIST_NEWDIRECTORY_NEW, 0);

  return 1;
}

/**************************************************************/
/* hotlist_newedit_url_handler()                              */
/*                                                            */
/* This function either alters the name and URL fields of a   */
/* selected URL, or creates a new URL item in the directory   */
/* that the pointer was over when the main menu was opened.   */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_newedit_url_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  _kernel_oserror * e = NULL;
  hotlist_item    * item;
  hotlist_item    * tempitem;
  char            * tempdesc;
  char            * tempurl;
  int               size;

  /* Is there a selected item? */

  item = hotlist_find_selected_item();

  /* Get the length of the description (name) text */

  ChkError(writablefield_get_value(0,
                                   id_block->self_id,
                                   HOTLIST_NEWURL_NAME,
                                   NULL,
                                   0,
                                   &size));

  /* Try to allocate space for it */

  tempdesc = malloc(size + 1); /* '+1' to be safe (above call *should* return 'size of buffer required'...) */

  if (!tempdesc)
  {
    show_error_cont(make_no_memory_error(15));
    return 1;
  }

  /* Get the value, making absolutely sure it's terminated */

  ChkError(writablefield_get_value(0,
                                   id_block->self_id,
                                   HOTLIST_NEWURL_NAME,
                                   tempdesc,
                                   size,
                                   NULL));
  tempdesc[size] = 0;

  /* Do the same for the URL */

  ChkError(writablefield_get_value(0,
                                   id_block->self_id,
                                   HOTLIST_NEWURL_URL,
                                   NULL,
                                   0,
                                   &size));
  tempurl = malloc(size + 1);

  if (!tempurl)
  {
    free(tempdesc);

    show_error_cont(make_no_memory_error(15));
    return 1;
  }

  ChkError(writablefield_get_value(0,
                                   id_block->self_id,
                                   HOTLIST_NEWURL_URL,
                                   tempurl,
                                   size,
                                   NULL));
  tempurl[size] = 0;

  /* 'alter_new' is set by the menu handling functions to */
  /* reflect whether we should create or alter items.     */

  switch (alter_new)
  {
    case HOTLIST_MENUSECTION_NEW:
    {
      /* Create a new item. First, find the one the menu was */
      /* opened over.                                        */

      tempitem = hotlist_find_item(hotlist_root->data.directory_content, menu_itemno);

      /* If we can't, add to the start of the root directory */

      if (!tempitem)
      {
        menu_itemno = 0;

        e = hotlist_new_url(hotlist_root,
                            HOTLIST_POSITION_BEGINNING,
                            tempdesc,
                            tempurl);
      }

      /* Otherwise add it after the item, unless the parent is read-only */

      else
      {
        if (tempitem->parent && (tempitem->parent->flags & HOTLIST_G_IS_READ_ONLY))
        {
          erb.errnum = Utils_Error_Custom_Message;

          StrNCpy0(erb.errmess,
                   lookup_token("HLNewRO:You can't create an item here (the directory is read-only).",
                                0,0));

          e = &erb;
        }
        else
        {
          e = hotlist_new_url(tempitem,
                              HOTLIST_POSITION_AFTER,
                              tempdesc,
                              tempurl);
        }
      }

      if (!e)
      {
        /* Ensure the window extent is up to date */

        hotlist_preopen();

        /* Deal with redraw issues */

        e = hotlist_redraw_items(menu_itemno,
                                 hotlist_count_displayed_items(hotlist_root->data.directory_content));

        hotlist_clear_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);

        /* Call the 'hotlist has changed' function */

        hotlist_modified(HL_MODIFIED_ADD);
      }

      /* Free temporary data and report any errors */

      free(tempdesc);
      free(tempurl);

      ChkError(e);
    }
    break;

    case HOTLIST_MENUSECTION_ALTER:
    {
      /* Alter an existing item. If it is read-only, complain; */
      /* otherwise, free its URL and description text.         */

      if (item->flags & HOTLIST_G_IS_READ_ONLY)
      {
        erb.errnum = Utils_Error_Custom_Message;

        StrNCpy0(erb.errmess,
                 lookup_token("NLAlterRO:You can't alter this item (it is read-only).",
                              0,0));

        e = &erb;

        free(tempdesc);
        free(tempurl);
      }
      else
      {
        free(item->name);
        free(item->data.url);

        /* Point to the new URL and description */

        item->name     = tempdesc;
        item->data.url = tempurl;

        /* Deal with redraw issues */

        item->flags |= HOTLIST_G_REDRAW_NOW;

        hotlist_preopen();

        e = hotlist_redraw_now();

        /* Call the 'hotlist has changed' function */

        hotlist_modified(HL_MODIFIED_ALTER);
      }

      /* Report any errors */

      ChkError(e);
    }
    break;
  }

  return 1;
}

/**************************************************************/
/* hotlist_newren_directory_handler()                         */
/*                                                            */
/* As hotlist_newedit_url_handler, but for directory items.   */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_newren_directory_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  _kernel_oserror * e = NULL;
  hotlist_item    * item;
  hotlist_item    * tempitem;
  char            * tempname;
  int               size;

  /* This bit is similar to the start of hotlist_newedit_url_handler */

  item = hotlist_find_selected_item();

  ChkError(writablefield_get_value(0,
                                   id_block->self_id,
                                   HOTLIST_NEWDIRECTORY_NAME,
                                   NULL,
                                   0,
                                   &size));

  tempname = malloc(size + 1);

  if (!tempname)
  {
    show_error_cont(make_no_memory_error(16));
    return 1;
  }

  ChkError(writablefield_get_value(0,
                                   id_block->self_id,
                                   HOTLIST_NEWDIRECTORY_NAME,
                                   tempname,
                                   size,
                                   NULL));

  switch (alter_new)
  {
    case HOTLIST_MENUSECTION_NEW:
    {
      tempitem = hotlist_find_item(hotlist_root->data.directory_content, menu_itemno);

      /* If we can't find the item the pointer was near, at at the */
      /* start of the root; else add near the item.                */

      if (!tempitem)
      {
        menu_itemno = 0;

        e = hotlist_new_directory(hotlist_root,
                                  tempname,
                                  HOTLIST_POSITION_END,
                                  &tempitem);
      }
      else
      {
        /* The parent may be read-only */

        if (tempitem->parent && (tempitem->parent->flags & HOTLIST_G_IS_READ_ONLY))
        {
          erb.errnum = Utils_Error_Custom_Message;

          StrNCpy0(erb.errmess,
                   lookup_token("HLNewRO:You can't create an item here (the directory is read-only).",
                                0,0));

          e = &erb;
        }
        else
        {
          e = hotlist_new_directory(tempitem,
                                    tempname,
                                    HOTLIST_POSITION_AFTER,
                                    &tempitem);
        }
      }

      if (!e)
      {
        hotlist_preopen();

        e = hotlist_redraw_items(menu_itemno,
                                 hotlist_count_displayed_items(hotlist_root->data.directory_content));

        hotlist_clear_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);
        hotlist_modified(HL_MODIFIED_ADD);
      }

      /* Free the temporary block and report any errors */

      free(tempname);

      ChkError(e);
    }
    break;

    case HOTLIST_MENUSECTION_ALTER:
    {
      /* Alter an existing directory. If it is read-only, complain. */

      if (item->flags & HOTLIST_G_IS_READ_ONLY)
      {
        erb.errnum = Utils_Error_Custom_Message;

        StrNCpy0(erb.errmess,
                 lookup_token("NLAlterRO:You can't alter this item (it is read-only).",
                              0,0));

        e = &erb;

        free(tempname);
      }
      else
      {
        /* Free the item's existing name, link to the new */
        /* name, and do the relevant redraws / hotlist    */
        /* modified calls.                                */

        free(item->name);

        item->name = tempname;
        item->flags |= HOTLIST_G_REDRAW_NOW;

        hotlist_preopen();

        e = hotlist_redraw_now();

        hotlist_modified(HL_MODIFIED_ALTER);
      }

      /* Report any errors */

      ChkError(e);
    }
    break;
  }

  return 1;
}

/**************************************************************/
/* hotlist_reset_url_handler()                                */
/*                                                            */
/* This function is called when Cancel is clicked on in the   */
/* New (aka Edit) URLdialogue box. It resets the contents to */
/* their previous state.                                      */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_reset_url_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  /* Action depends on whether we were altering, or creating an item */

  switch (alter_new)
  {
    case HOTLIST_MENUSECTION_NEW:
    {
      ChkError(writablefield_set_value(0, id_block->self_id, HOTLIST_NEWURL_NAME, ""));
      ChkError(writablefield_set_value(0, id_block->self_id, HOTLIST_NEWURL_URL,  ""));
    }
    break;

    case HOTLIST_MENUSECTION_ALTER:
    {
      hotlist_item * item = hotlist_find_selected_item();

      if (item)
      {
        ChkError(writablefield_set_value(0, id_block->self_id, HOTLIST_NEWURL_NAME, item->name));
        ChkError(writablefield_set_value(0, id_block->self_id, HOTLIST_NEWURL_URL,  item->data.url));
      }
    }
    break;
  }

  return 1;
}

/**************************************************************/
/* hotlist_reset_directory_handler()                          */
/*                                                            */
/* Similar to hotlist_reset_url_handler, but for resetting    */
/* the New (aka Rename) Directory dialogue.                   */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int hotlist_reset_directory_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  switch (alter_new)
  {
    case HOTLIST_MENUSECTION_NEW:
    {
      ChkError(writablefield_set_value(0,
                                       id_block->self_id,
                                       HOTLIST_NEWDIRECTORY_NAME,
                                       ""));
    }
    break;

    case HOTLIST_MENUSECTION_ALTER:
    {
      hotlist_item * item = hotlist_find_selected_item();

      if (item) ChkError(writablefield_set_value(0,
                                                 id_block->self_id,
                                                 HOTLIST_NEWDIRECTORY_NAME,
                                                 item->name));
    }
    break;
  }

  return 1;
}

/**************************************************************/
/* hotlist_drag_renderer()                                    */
/*                                                            */
/* Renders a single hotlist item at 0,0 for use with          */
/* DragAnObject.                                              */
/*                                                            */
/* Parameters: Pointer to the item to render;                 */
/*                                                            */
/*             Height of a hotlist item in OS units;          */
/*                                                            */
/*             Width of a hotlist directory sprite in OS      */
/*             units;                                         */
/*                                                            */
/*             Width of a hotlist URL sprite in OS units.     */
/**************************************************************/

static void hotlist_drag_renderer(hotlist_item * item, unsigned int item_height,
                                  unsigned int item_dir_width, unsigned int item_url_width)
{
  /* DON'T put printf's in here... Doesn't work, at least, */
  /* not with PipeFS output methods.                       */

  WimpIconBlock hotlist_iconblock;
  int           temp_width;
  int           text_width;

  /* Create an icon block for the sprite component */

  hotlist_iconblock.flags               = HOTLIST_SPRITE_ICON_FLAGS;
  hotlist_iconblock.data.is.sprite_area = (void *) sprite_block;

  /* Set appropriate sprite and width of sprite */

  switch(item->type)
  {
    case hl_url:
    {
      hotlist_iconblock.data.is.sprite             = !(item->flags & HOTLIST_G_IS_READ_ONLY) ? URL_SPRITE : RESOURCES_URL_SPRITE;
      hotlist_iconblock.data.is.sprite_name_length = strlen(hotlist_iconblock.data.is.sprite);

      temp_width = item_url_width;
    }
    break;

    case hl_directory:
    {
      hotlist_iconblock.data.is.sprite             = !(item->flags & HOTLIST_G_IS_READ_ONLY) ? CLOSED_DIRECTORY_SPRITE : CLOSED_RESOURCES_DIRECTORY_SPRITE;
      hotlist_iconblock.data.is.sprite_name_length = strlen(hotlist_iconblock.data.is.sprite);

      temp_width = item_dir_width;
    }
    break;

    default:
    {
      temp_width = 0;
    }
    break;
  }

  /* Set the bounding box */

  hotlist_iconblock.bbox.xmin = 2;
  hotlist_iconblock.bbox.xmax = 2 + temp_width;
  hotlist_iconblock.bbox.ymax = 2 + item_height;
  hotlist_iconblock.bbox.ymin = 2;

  /* Plot the item */

  if (wimp_plot_icon(&hotlist_iconblock)) return; /* Bail out on error! */

  /* Create an icon block for the text component */

  if (item->type == hl_url && hl_show_urls) utils_text_width(item->data.url, &text_width, 0);
  else                                      utils_text_width(item->name,     &text_width, 0);

  hotlist_iconblock.flags = HOTLIST_TEXT_ICON_FLAGS_DRAG;

  /* Set the bounding box */

  hotlist_iconblock.bbox.xmin = temp_width + 4;
  hotlist_iconblock.bbox.xmax = temp_width + text_width + 16;
  hotlist_iconblock.bbox.ymax = item_height;
  hotlist_iconblock.bbox.ymin = 4;

  /* Set the text according to the item type */

  if (item->type == hl_url && hl_show_urls)
  {
    hotlist_iconblock.data.it.buffer      = item->data.url;
    hotlist_iconblock.data.it.buffer_size = strlen(item->data.url);
    hotlist_iconblock.data.it.validation  = NULL;
  }
  else
  {
    hotlist_iconblock.data.it.buffer      = item->name;
    hotlist_iconblock.data.it.buffer_size = strlen(item->name);
    hotlist_iconblock.data.it.validation  = NULL;
  }

  /* Plot the icon */

  wimp_plot_icon(&hotlist_iconblock);

  /* Finished */

  return;
}

/**************************************************************/
/* hotlist_start_drag()                                       */
/*                                                            */
/* Start a new drag operation inside the hotlist window.      */
/**************************************************************/

static _kernel_oserror * hotlist_start_drag(void)
{
  /* Do the hard work elsewhere... */

  RetError(hotlist_start_drag_backend());

  /* Reset autoscroll */

  RetError(hotlist_autoscroll(0));

  /* Register NULL handler */

  register_null_claimant(Wimp_ENull, hotlist_null_handler, NULL);

  /* Finished */

  return NULL;
}

/**************************************************************/
/* hotlist_start_drag_backend()                               */
/*                                                            */
/* This function is called by hotlist_start_drag to do most   */
/* of the work for starting a drag operation from within the  */
/* hotlist window. A drag box is created, bounding all        */
/* selected items.                                            */
/**************************************************************/

static _kernel_oserror * hotlist_start_drag_backend(void)
{
  WimpGetWindowStateBlock   state;
  WimpGetPointerInfoBlock   pointerblock;
  WimpDragBox               box;
  hotlist_item            * item;
  unsigned int              item_height, item_dir_width, item_url_width;
  BBox                      bbox;
  int                       xorigin,     yorigin;
  int                       screenwidth, screenheight;

  /* Read the pointer position and get the hotlist item sizes */

  RetError(wimp_get_pointer_info(&pointerblock));
  RetError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  /* Record whether ot not Adjust (and only Adjust) was used */

  hotlist_dragging.using_adjust = (pointerblock.button_state == Wimp_MouseButtonAdjust);

  /* Get the shape of the selected items */

  hotlist_get_selected_shape(&bbox);

  /* Now get information on the hotlist window itself, */
  /* and the current screen shape.                     */

  RetError(window_get_wimp_handle(0, hotlist_windowid, &state.window_handle));
  RetError(wimp_get_window_state(&state));

  xorigin = state.xscroll - state.visible_area.xmin;
  yorigin = state.yscroll - state.visible_area.ymax;

  /* Screen size, pixels */

  screenwidth  = bbc_modevar(-1, BBC_XWindLimit);
  screenheight = bbc_modevar(-1, BBC_YWindLimit);

  /* Convert to OS units */

  screenwidth  = (screenwidth  + 1) << (bbc_modevar(-1, BBC_XEigFactor));
  screenheight = (screenheight + 1) << (bbc_modevar(-1, BBC_YEigFactor));

  /* Read CMOS - solid drags, or a dashed outline? */

  if (_kernel_osbyte(161, 28, 0) & (1 << (8 + 1)))
  {
    _kernel_swi_regs regs;
    int              redraw_params[4];

    /* Solid drags */

    item = hotlist_find_selected_item();

    /* A single item, or several? */

    if (
         (hotlist_count_selected_items() == 1 && item->type == hl_url) ||
         (
           hotlist_count_selected_items() == 1 &&
           item->type == hl_directory &&
           (
             !(item->flags & HOTLIST_D_IS_OPEN) ||
             hotlist_no_contents_selected(item->data.directory_content) ||
             item->data.directory_content == NULL
           )
         )
       )
    {
      /* A single item. Set up the box shape */

      box.dragging_box.xmin = bbox.xmin - xorigin;
      box.dragging_box.ymin = bbox.ymin - yorigin;
      box.dragging_box.xmax = bbox.xmax - xorigin;
      box.dragging_box.ymax = bbox.ymax - yorigin;

      /* Store details of the redraw */

      redraw_params[0] = (int) hotlist_find_selected_item();
      redraw_params[1] = (int) item_height;
      redraw_params[2] = (int) item_dir_width;
      redraw_params[3] = (int) item_url_width;

      /* Fill in the register block */

      regs.r[0] = (2<<0) | (2<<2) | (1<<6) | (1<<7) | (1<<16) | (1<<18);
      regs.r[1] = (int) hotlist_drag_renderer;
      regs.r[2] = (int) redraw_params;
      regs.r[3] = (int) &(box.dragging_box);

      /* Start the drag - use DragAnObject, as then we can show */
      /* the item's text, as seen in the hotlist window, during */
      /* the drag.                                              */

      RetError(_kernel_swi(DragAnObject_Start, &regs, &regs));

      /* Finished; flag that we're solid-dragging an object and exit */

      hotlist_dragging.drag_type = HOTLIST_SOLID_DRAG_OBJECT;

      return NULL;
    }
    else
    {
      int width, height;

      /* Several items. */

      RetError(utils_read_sprite_size(SELECTION_SPRITE, &width, &height));

      /* Set the box shape, based around the mouse pointer coordinates  */

      box.dragging_box.xmin = pointerblock.x - (width  / 2 + 10); /* '+ 10' = aesthetics */
      box.dragging_box.ymin = pointerblock.y - (height / 2 + 10);
      box.dragging_box.xmax = pointerblock.x + (width  / 2 + 10);
      box.dragging_box.ymax = pointerblock.y + (height / 2 + 10);

      /* Fill in the register block */

      regs.r[0] = (1<<0) | (1<<2) | (1<<6) | (1<<7);
      regs.r[1] = (int) sprite_block;
      regs.r[2] = (int) "package";
      regs.r[3] = (int) &(box.dragging_box);

      /* Start the drag - use DragASprite as there's no text to */
      /* show with the 'package' icon.                          */

      RetError(_kernel_swi(DragASprite_Start, &regs, &regs));

      /* Finished; flag that we're solid-dragging an object and exit */

      hotlist_dragging.drag_type = HOTLIST_SOLID_DRAG_SPRITE;

      return NULL;
    }
  }

  /* CMOS said - use a dashed outline drag. */

  box.drag_type         = Wimp_DragBox_DragFixedDash;

  /* Set the box shape */

  box.dragging_box.xmin = bbox.xmin - xorigin;
  box.dragging_box.xmax = bbox.xmax - xorigin;
  box.dragging_box.ymin = bbox.ymin - yorigin;
  box.dragging_box.ymax = bbox.ymax - yorigin;

  /* Constrain the drag to the screen size */

  box.parent_box.xmin   = box.dragging_box.xmin - pointerblock.x;
  box.parent_box.xmax   = box.dragging_box.xmax - pointerblock.x + screenwidth;
  box.parent_box.ymin   = box.dragging_box.ymin - pointerblock.y;
  box.parent_box.ymax   = box.dragging_box.ymax - pointerblock.y + screenheight;

  /* Start the drag */

  RetError(wimp_drag_box(&box));

  /* Finished; flag that we're dragging an object with a dashed outline and exit */

  hotlist_dragging.drag_type = HOTLIST_BOX_DRAG;

  return NULL;
}

/**************************************************************/
/* hotlist_drag_stop_handler()                                */
/*                                                            */
/* Terminates any hotlist drag in progress.                   */
/*                                                            */
/* None of the parameters are actually used, so calling       */
/* directly (rather than by eventlib) is easy.                */
/**************************************************************/

static int hotlist_drag_stop_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  _kernel_oserror * e;
  int               dragging = hotlist_dragging.drag_type;

  dprintf(("Hotl", "hotlist_drag_stop_handler: Called\n"));

  /* If we're not dragging in the hotlist, something weird is */
  /* going on! So definitely, ignore the event...             */

  if (hotlist_dragging.drag_type == HOTLIST_NOT_DRAGGING) return 0;

  /* Make sure we clear the dragging flag as soon as possible. */
  /* If it gets left switched on, then drags in other parts of */
  /* the browser could get misinterpreted by the hotlist code. */

  dragging                   = hotlist_dragging.drag_type;
  hotlist_dragging.drag_type = HOTLIST_NOT_DRAGGING;

  if (hotlist_current_highlighted)
  {
    hotlist_current_highlighted->flags &= ~HOTLIST_D_IS_HIGHLIGHTED;

    ChkError(hotlist_redraw_items(highlighted_itemno, highlighted_itemno));

    hotlist_current_highlighted = NULL;
  }

  /* Deal with each dragging type */

  switch (dragging)
  {
    /* Complain if we don't understand it */

    default:
    {
      hotlist_dragging.drag_type = HOTLIST_NOT_DRAGGING;

      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;
        sprintf(erb.errmess,
                "Value %d of hotlist_dragging.drag_type not understood in hotlist_drag_stop_handler",
                hotlist_dragging.drag_type);

        show_error_ret(&erb);

      #endif

      return 0;
    }
    break;

    case HOTLIST_SOLID_DRAG_OBJECT:
    {
      /* Stop drag an object */

      e = _swix(DragAnObject_Stop, 0);

      deregister_null_claimant(Wimp_ENull, hotlist_null_handler, NULL);

      ChkError(e);
    }
    break;

    case HOTLIST_SOLID_DRAG_SPRITE:
    {
      /* Stop drag a sprite */

      e = _swix(DragASprite_Stop, 0);

      deregister_null_claimant(Wimp_ENull, hotlist_null_handler, NULL);

      ChkError(e);
    }
    break;

    case HOTLIST_BOX_DRAG_SELECTION:
    {
      /* Stop drag box */

      e = wimp_drag_box(NULL);

      deregister_null_claimant(Wimp_ENull, hotlist_null_drag_select_handler, NULL);

      /* Deselect anything that is currently selected */

      hotlist_clear_flags(hotlist_root->data.directory_content, hl_ALL, HOTLIST_G_DRAG_SELECTED);
      ChkError(hotlist_redraw_now());

      ChkError(e);
    }
    break;

    case HOTLIST_BOX_DRAG:
    {
      e = wimp_drag_box(NULL);

      deregister_null_claimant(Wimp_ENull, hotlist_null_handler, NULL);

      ChkError(e);
    }
    break;
  }

  return 1;
}

/**************************************************************/
/* hotlist_drag_completed_handler()                           */
/*                                                            */
/* This function is called when a user_drag completes. If the */
/* drag is one started by the hotlist section it is           */
/* processed. Dropping the drag in the hotlist window will    */
/* move or copy the items being dragged; dropping in any      */
/* other window will try to save the relevant datatype (URI   */
/* or HTML) to that window.                                   */
/**************************************************************/

static int hotlist_drag_completed_handler(int event_code, WimpPollBlock * event, IdBlock * id_block, void * handle)
{
  WimpGetWindowStateBlock   state;
  WimpGetPointerInfoBlock   pointerblock;
  hotlist_item            * targetitem;
  hotlist_item            * sourceitem;
  int                       window_handle;
  unsigned int              item_height, item_dir_width, item_url_width;
  unsigned int              top,         bottom;
  int                       xmin,        xmax;
  int                       winx,        winy;
  int                       position;
  int                       dragging;
  int                       shift = 0;

  dprintf(("Hotl", "hotlist_drag_completed_handler: Called\n"));

  /* If we're not dragging in the hotlist, the Wimp returned */
  /* this because someone else completed a drag (e.g. a save */
  /* dialogue). In that case, ignore the event.              */

  if (hotlist_dragging.drag_type == HOTLIST_NOT_DRAGGING) return 0;

  /* Make sure we clear the dragging flag as soon as possible. */
  /* If it gets left switched on, then drags in other parts of */
  /* the browser could get misinterpreted by the hotlist code. */

  dragging                   = hotlist_dragging.drag_type;
  hotlist_dragging.drag_type = HOTLIST_NOT_DRAGGING;

  /* Check if SHIFT is pressed */

  _swix(OS_Byte,
        _INR(0,1) | _OUT(1),

        121,
        128,

        &shift);

  /* Reset autoscrolling (To restore pointer if necessary) */

  show_error_ret(hotlist_autoscroll(0));

  /* Deal with each dragging type */

  switch (dragging)
  {
    /* Complain if we don't understand it */

    default:
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;
        sprintf(erb.errmess,
                "Value %d of hotlist_dragging.drag_type not understood in hotlist_drag_completed_handler",
                hotlist_dragging.drag_type);

        show_error_ret(&erb);

      #endif

      return 0;
    }
    break;

    /* For e.g. dragging a single URL or directory item */

    case HOTLIST_SOLID_DRAG_OBJECT:
    {
      _swix(DragAnObject_Stop, 0);
    }
    break;

    /* For e.g. dragging a selection under the 'package' icon */

    case HOTLIST_SOLID_DRAG_SPRITE:
    {
      _swix(DragASprite_Stop, 0);
    }
    break;

    /* For e.g. dragging a single URL or selection without solid drags emables */

    case HOTLIST_BOX_DRAG:
    {
      /* No special action required in this case */
    }
    break;

    /* When dragging out a box to dynamically select hotlist items */

    case HOTLIST_BOX_DRAG_SELECTION:
    {
      deregister_null_claimant(Wimp_ENull, hotlist_null_drag_select_handler, NULL);
      hotlist_convert_drag_selection(hotlist_root->data.directory_content);

      return 0;
    }
    break;
  }

  /* If there is a currently highlighted directory (i.e. something */
  /* was to be dropped into it) unhighlight that item.             */

  if (hotlist_current_highlighted)
  {
    hotlist_current_highlighted->flags &= ~HOTLIST_D_IS_HIGHLIGHTED;
    hotlist_redraw_items(highlighted_itemno, highlighted_itemno);

    hotlist_current_highlighted = NULL;
  }

  /* Remove the drag null handler */

  deregister_null_claimant(Wimp_ENull, hotlist_null_handler, NULL);

  /* Remember the first selected item in the hotlist */

  sourceitem = hotlist_find_selected_item();

  /* Get information on the pointer */

  wimp_get_pointer_info(&pointerblock);

  /* Was the drag ended over the hotlist window? */

  ChkError(window_get_wimp_handle(0,
                                  hotlist_windowid,
                                  &window_handle));

  if (window_handle == pointerblock.window_handle)
  {
    /* Yes, the drag ended over the hotlist window. */

    if (pointerblock.icon_handle != -1) return 0; /* (Only understand drops on workspace) */

    /* Find item sizes, the window x and y coordinate of the  */
    /* drop point, and from this, the targetted hotlist item. */

    ChkError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

    state.window_handle = pointerblock.window_handle;
    ChkError(wimp_get_window_state(&state));

    winx       = pointerblock.x + (state.xscroll - state.visible_area.xmin);
    winy       = pointerblock.y + (state.yscroll - state.visible_area.ymax);

    top        = (-winy) / item_height;
    targetitem = hotlist_find_item(hotlist_root->data.directory_content, top);

    /* Decide where to put the items */

    if (targetitem)
    {
      /* If we've dropped on a selected or read-only item, do nothing */

      if (targetitem->flags & (HOTLIST_G_IS_SELECTED | HOTLIST_G_IS_READ_ONLY)) return 0;

      /* Otherwise, find the x coordinate span of the target item... */

      hotlist_get_shape(&xmin, &xmax, targetitem);

      if (targetitem->type == hl_directory && winx >= xmin && winx <= xmin + item_dir_width)
      {
        /* ...and if the drop point was within the x span of the */
        /* directory icon part of a directory, place in that     */
        /* directory (directories will only show the '+' icon,   */
        /* i.e. highlighted, when the pointer hovers over the    */
        /* sprite component).                                    */

        position = HOTLIST_POSITION_BEGINNING;
      }
      else
      {
        if ((-winy % item_height) > item_height / 2)
        {
          /* If we're over half way past the item, place after it, unless */
          /* it is an open directory. Again, the null handler dealing     */
          /* with highlighting directory sprites reflects this situation  */
          /* correctly.                                                   */

          if (
               targetitem->type == hl_directory      &&
               targetitem->flags & HOTLIST_D_IS_OPEN
             )
          {
            position = HOTLIST_POSITION_BEGINNING;
          }
          else
          {
            position = HOTLIST_POSITION_AFTER;
          }
        }
        else
        {
          /* Otherwise, place before */

          position = HOTLIST_POSITION_BEFORE;
        }
      }
    }
    else
    {
      /* If there is no target item, add to the end of the hotlist root */

      targetitem = hotlist_root;
      position   = HOTLIST_POSITION_END;
    }

    /* Find the selected item. If its number is less than the one */
    /* we estimated from the drop y coordinate, use that instead. */

    {
      int selected;

      selected = hotlist_find_no_from_item(hotlist_find_selected_item());
      if (selected < top) top = selected;
    }

    /* Count how many items are displayed to get the last hotlist item */

    bottom = hotlist_count_displayed_items(hotlist_root->data.directory_content);

    if (!shift)
    {
      /* If shift isn't pressed, move selected items */

      do
      {
        /* Ensure the source item is deselected */

        sourceitem->flags &= ~HOTLIST_G_IS_SELECTED;

        /* Move it */

        ChkError(hotlist_move_item(sourceitem,
                                   targetitem,
                                   position));

        /* If this is a directory, deselect its contents */

        if (sourceitem->type == hl_directory)
        {
          hotlist_clear_flags(sourceitem->data.directory_content,
                              hl_ALL,
                              HOTLIST_G_IS_SELECTED);
        }

        targetitem = sourceitem;
        sourceitem = hotlist_find_selected_item();

        /* Loop round moving all following items for as long as */
        /* anything is still selected - making sure we copy     */
        /* them all after what we just added.                   */

        position = HOTLIST_POSITION_AFTER;
      }
      while (sourceitem);

      ChkError(hotlist_modified(HL_MODIFIED_MOVE));
    }
    else
    {
      /* Shift is pressed, so copy the items. The code is very */
      /* similar in structure to the move stuff above.         */

      do
      {
        sourceitem->flags &= ~HOTLIST_G_IS_SELECTED;

        ChkError(hotlist_copy_item(sourceitem,
                                   targetitem,
                                   position,
                                   &targetitem));

        if (sourceitem->type == hl_directory)
        {
          hotlist_clear_flags(sourceitem->data.directory_content,
                              hl_ALL,
                              HOTLIST_G_IS_SELECTED);
        }

        sourceitem = hotlist_find_selected_item();
        position   = HOTLIST_POSITION_AFTER;
      }
      while (sourceitem);

      ChkError(hotlist_modified(HL_MODIFIED_COPY));
    }

    /* The displayed item count may have changed, so take the greatest */
    /* value of this as the bottom item to redraw between.             */

    {
      int new_bottom = hotlist_count_displayed_items(hotlist_root->data.directory_content);

      if (new_bottom > bottom) bottom = new_bottom;
    }

    /* Ensure the window extent etc. is up to date */

    hotlist_preopen();

    /* Redraw the relevant regions of the window */

    ChkError(hotlist_redraw_items(top, bottom));
  }
  else
  {
    /* No - the drag did not end over the hotlist window */

    if (
         sourceitem                          &&
         hotlist_count_selected_items() == 1 &&
         sourceitem->type == hl_url
       )
    {
      /* There is a single selected item which is a URL. So, save */
      /* it as a URI file.                                        */

      hotlist_initiate_uri_save(sourceitem);
    }
    else
    {
      /* Can't save URI file when saving more than one URL, */
      /* so save an HTML file instead.                      */

      hotlist_initiate_html_save(lookup_token("HotlistLeafname:Hotlist",0,0));
    }
  }

  /* If we were using Adjust, close the window */

  if (hotlist_dragging.using_adjust)
  {
    hotlist_dragging.using_adjust = 0;

    ChkError(toolbox_hide_object(0, hotlist_windowid));
  }

  /* Finished */

  return 1;
}

/**************************************************************/
/* hotlist_autoscroll()                                       */
/*                                                            */
/* Auto-scrolls a window.                                     */
/*                                                            */
/* Parameters: Object ID of the window to scroll or 0 to      */
/*             reset autoscrolling.                           */
/**************************************************************/

static _kernel_oserror * hotlist_autoscroll(int window)
{
  WimpGetWindowStateBlock state;
  ObjectId                over_window;
  ObjectId                parent;
  ComponentId             component;
  BBox                    extent;
  int                     scroll_changed;
  int                     x, y, position;
  int                     autoscroll_newtime;

  static unsigned int     scrolling, autoscroll_oldtime;
  static unsigned int     mouse_shape = Mouse_Shape_Normal;

  /* Reset autoscroll handling if requested */

  if (!window)
  {
    dprintf(("Hotl", "hotlist_autoscroll: Resetting\n"));

    scrolling = 0;

    mouse_set_pointer_shape(Mouse_Shape_Normal);
    mouse_shape = Mouse_Shape_Normal;

    return _swix(OS_ReadMonotonicTime,
                 _OUT(0),

                 &autoscroll_oldtime);
  }

  /* What window is the pointer over? */

  RetError(window_get_pointer_info(0, &x, &y, NULL, &over_window, NULL));

  /* Get information on the window given to the function */

  RetError(window_get_wimp_handle(0, window, &state.window_handle));
  RetError(wimp_get_window_state(&state));
  RetError(window_get_extent(0, window, &extent));

  /* Find location of pointer relative to the given window */

  if (
       x < state.visible_area.xmin ||
       x > state.visible_area.xmax ||
       y < state.visible_area.ymin ||
       y > state.visible_area.ymax
     )
  {
    /* Outside the visible area */

    position = 0;
  }
  else if (
            x > state.visible_area.xmin + choices.auto_scroll_margin &&
            x < state.visible_area.xmax - choices.auto_scroll_margin &&
            y > state.visible_area.ymin + choices.auto_scroll_margin &&
            y < state.visible_area.ymax - choices.auto_scroll_margin
          )
  {
    /* Pointer is inside the non-scrolling region of the given window */

    position = 1;
  }
  else
  {
    /* Pointer is inside the scrolling region of the given window */

    position = 2;
  }

  /* Work out what scroll settings to give, flagging if there is */
  /* a change in 'scroll_changed'.                               */

  scroll_changed = 0;

  if (position == 0 || position == 2)
  {
    /* Check position relative to the top/bottom of the window */

    if (y > state.visible_area.ymax - choices.auto_scroll_margin)
    {
      /* At or over the top of the window */

      if (state.yscroll < extent.ymax)
      {
        scroll_changed = 1;
        state.yscroll += (y - (state.visible_area.ymax - choices.auto_scroll_margin));
      }
    }
    else
    {
      if (y < state.visible_area.ymin + choices.auto_scroll_margin)
      {
        /* At or under the bottom of the window */

        if (state.yscroll > extent.ymin + (state.visible_area.ymax - state.visible_area.ymin))
        {
          scroll_changed = 1;
          state.yscroll -= ((state.visible_area.ymin + choices.auto_scroll_margin) - y);
        }
      }
    }

    /* Check the position relative to the left/right of the window, too */

    if (x > state.visible_area.xmax - choices.auto_scroll_margin)
    {
      /* At or to the right of the right hand edge of the window */

      if (state.xscroll < extent.xmax - (state.visible_area.xmax - state.visible_area.xmin))
      {
        scroll_changed = 1;
        state.xscroll += (x - (state.visible_area.xmax - choices.auto_scroll_margin));
      }
    }
    else
    {
      if (x < state.visible_area.xmin + choices.auto_scroll_margin)
      {
        /* At or to the left of the left hand edge of the window */

        if (state.xscroll > extent.xmin)
        {
          scroll_changed = 1;
          state.xscroll -= ((state.visible_area.xmin + choices.auto_scroll_margin) - x);
        }
      }
    }
  }

  /* Deal with flags and the mouse pointer */

  switch (position)
  {
    /* If we're outside the visible area of the window, and not scrolling, */
    /* set the pointer back to a normal shape (else leave it alone).       */

    case 0:
    {
      if (!scrolling)
      {
        RetError(_swix(OS_ReadMonotonicTime,
                       _OUT(0),

                       &autoscroll_oldtime));

        if (mouse_shape != Mouse_Shape_Normal)
        {
          mouse_set_pointer_shape(Mouse_Shape_Normal);
          mouse_shape = Mouse_Shape_Normal;
        }
      }
    }
    break;

    /* If we're in the non-scrolling region, unset the 'scrolling' flag */
    /* and set the mouse pointer back to a normal shape.                */

    case 1:
    {
      scrolling = 0;

      RetError(_swix(OS_ReadMonotonicTime,
                     _OUT(0),

                     &autoscroll_oldtime));

      if (mouse_shape != Mouse_Shape_Normal)
      {
        mouse_set_pointer_shape(Mouse_Shape_Normal);
        mouse_shape = Mouse_Shape_Normal;
      }
    }
    break;

    /* If inside the scrolling region, wait a while on the 'ToScroll' */
    /* pointer, then start scrolling.                                 */

    case 2:
    {
      if (!scrolling && scroll_changed)
      {
        RetError(_swix(OS_ReadMonotonicTime,
                       _OUT(0),

                       &autoscroll_newtime));

        /* If we exceed the autoscroll delay, set the scrolling flag */

        if (autoscroll_newtime - autoscroll_oldtime > choices.auto_scroll_delay)
        {
          scrolling = 1;
        }

        /* Otherwise, set the 'ToScroll' pointer */

        else
        {
          if (mouse_shape != Mouse_Shape_ToScroll)
          {
            mouse_shape = Mouse_Shape_ToScroll;
            mouse_set_pointer_shape(Mouse_Shape_ToScroll);
          }
        }
      }

      /* If the scroll position hasn't changed, update oldtime */

      if (!scroll_changed)
      {
        RetError(_swix(OS_ReadMonotonicTime,
                       _OUT(0),

                       &autoscroll_oldtime));
      }
    }
    break;
  }

  /* Closing actions to take if scrolling is in progress. */

  if (scrolling)
  {
    if (scroll_changed)
    {
      /* If the scroll position has changed, update the window */

      RetError(toolbox_get_parent(0,
                                  window,
                                  &parent,
                                  &component));

      RetError(toolbox_show_object(0,
                                   window,
                                   Toolbox_ShowObject_FullSpec,
                                   &state.visible_area,
                                   parent,
                                   component));

      /* Ensure the pointer shape is correct */

      if (mouse_shape != Mouse_Shape_Scrolling)
      {
        mouse_shape = Mouse_Shape_Scrolling;
        mouse_set_pointer_shape(Mouse_Shape_Scrolling);
      }
    }
    else
    {
      /* If the scroll position has not changed, set the pointer */
      /* shape to normal, and unset the scrolling flag - we've   */
      /* scrolled to the limit of the window extent.             */

      if (mouse_shape != Mouse_Shape_Normal)
      {
        mouse_shape = Mouse_Shape_Normal;
        mouse_set_pointer_shape(Mouse_Shape_Normal);

        scrolling = 0;
      }
    }
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* hotlist_null_handler()                                     */
/*                                                            */
/* Called every null event while a drag is in operation.      */
/*                                                            */
/* Parameters are as standard for a Wimp event handler.       */
/**************************************************************/

static int hotlist_null_handler(int event_code, WimpPollBlock * event, IdBlock * id_block, void * handle)
{
  WimpGetWindowStateBlock   state;
  hotlist_item            * item;
  ObjectId                  window;
  unsigned int              item_height, item_dir_width, item_url_width;
  unsigned int              itemno;
  int                       x, y, buttons;
  int                       xmin, xmax;
  int                       remove_highlight = 0;

  /* Get information on the pointer position */

  ChkError(window_get_pointer_info(0, &x, &y, &buttons, &window, NULL));

  /* Deal with autoscroll */

  ChkError(hotlist_autoscroll(hotlist_windowid));

  if (window == hotlist_windowid)
  {
    /* The pointer is over the hotlist window */

    ChkError(window_get_wimp_handle(0, window, &state.window_handle));

    /* Display arrow pointing into directory to say that dropping */
    /* here will put in directory rather than next to it. First,  */
    /* get the window state.                                      */

    ChkError(wimp_get_window_state(&state));

    /* Work out the item that the pointer is over */

    ChkError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

    x += (state.xscroll - state.visible_area.xmin);
    y += (state.yscroll - state.visible_area.ymax);

    itemno = -y / item_height;
    item   = hotlist_find_item(hotlist_root->data.directory_content, itemno);

    /* Is this a directory item which is already not selected? (The */
    /* selected check is so that we don't end up highlighting the   */
    /* item we're dragging if this item is a directory).            */

    if (item && item->type == hl_directory && !(item->flags & HOTLIST_G_IS_SELECTED))
    {
      ChkError(hotlist_get_shape(&xmin, &xmax, item));

      /* If we're over the directory sprite, or half way under the item height when */
      /* the directory is open.                                                     */

      if (
           (
             x >= xmin &&
             x <= xmin + item_dir_width
           )
           ||
           (
             ((-y % item_height) > item_height / 2) &&
             item->flags & HOTLIST_D_IS_OPEN
           )
         )
      {
        /* ...and the currently highlighted item isn't the one we're over, and */
        /* it isn't read only...                                               */

        if (
             hotlist_current_highlighted != item     &&
             !(item->flags & HOTLIST_G_IS_READ_ONLY)
           )
        {
          /* ...then first, clear any highlighted item */

          if (hotlist_current_highlighted)
          {
            hotlist_current_highlighted->flags &= ~HOTLIST_D_IS_HIGHLIGHTED;

            ChkError(hotlist_redraw_items(highlighted_itemno, highlighted_itemno));
          }

          /* Now highlight the item we're over */

          item->flags |= HOTLIST_D_IS_HIGHLIGHTED;

          hotlist_current_highlighted = item;
          highlighted_itemno          = itemno;

          ChkError(hotlist_redraw_items(highlighted_itemno, highlighted_itemno));

          /* Reset the auto-open timer */

          ChkError(_swix(OS_ReadMonotonicTime,
                         _OUT(0),

                         &autoopen_oldtime));
        }
        else if (hotlist_current_highlighted == item)
        {
          int new_time;

          /* If we've stayed over the same highlighted item, */
          /* keep a count of for how long, and if required,  */
          /* automatically open the directory.               */

          ChkError(_swix(OS_ReadMonotonicTime,
                         _OUT(0),

                         &new_time));

          if (
               choices.auto_open_delay                               &&
               !(item->flags & HOTLIST_D_IS_OPEN)                    &&
               new_time - autoopen_oldtime > choices.auto_open_delay
             )
          {
            /* Auto-open the directory */

            item->flags |= HOTLIST_D_IS_OPEN;

            hotlist_preopen();

            ChkError(hotlist_redraw_items(highlighted_itemno,
                                          hotlist_count_displayed_items(hotlist_root->data.directory_content)));
          }
        }
      }
      else
      {
        /* If we're not over a directory sprite, clear any existing */
        /* highlight.                                               */

        remove_highlight = 1;
      }
    }

    /* If we're not over a directory at all, never mind it's directory */
    /* sprite component, again, clear any existing highlight.          */

    else remove_highlight = 1;
  }

  /* The following executes if the pointer is not over the hotlist window */

  else
  {
    /* Again, clear any highlighted directory sprite. */

    remove_highlight = 1;
  }

  /* If we're not over a directory sprite, clear any existing */
  /* highlight.                                               */

  if (remove_highlight && hotlist_current_highlighted)
  {
    hotlist_current_highlighted->flags &= ~HOTLIST_D_IS_HIGHLIGHTED;

    ChkError(hotlist_redraw_items(highlighted_itemno, highlighted_itemno));

    hotlist_current_highlighted = NULL;
  }

  /* Finished */

  return 0;
}

//
// Simple non-scrolling selection box, to be improved later...
// Workarea relative corner of selection box may not be needed.
//
static int selection_x, selection_y;

/**************************************************************/
/* hotlist_start_drag()                                       */
/*                                                            */
/* This function is called to start a selection box operation */
/* in the hotlist window.                                     */
/**************************************************************/

static _kernel_oserror * hotlist_selection_box_start(void)
{
  WimpGetPointerInfoBlock pointerblock;
  WimpGetWindowStateBlock state;
  WimpDragBox             box;

  /* Get the pointer position and info on the hotlist window */

  RetError(wimp_get_pointer_info(&pointerblock));

  RetError(window_get_wimp_handle(0, hotlist_windowid, &state.window_handle));
  RetError(wimp_get_window_state(&state));

  /* Remember the pointer position in window coordinates */

  selection_x = pointerblock.x + (state.xscroll - state.visible_area.xmin);
  selection_y = pointerblock.y + (state.yscroll - state.visible_area.ymax);

  /* Set up the drag box structure */

  box.drag_type         = Wimp_DragBox_DragRubberDash;

  box.dragging_box.xmin = pointerblock.x;
  box.dragging_box.xmax = pointerblock.x;
  box.dragging_box.ymin = pointerblock.y;
  box.dragging_box.ymax = pointerblock.y;

  box.parent_box.xmin   = state.visible_area.xmin;
  box.parent_box.xmax   = state.visible_area.xmax;
  box.parent_box.ymin   = state.visible_area.ymin;
  box.parent_box.ymax   = state.visible_area.ymax;

  /* Start the drag */

  RetError(wimp_drag_box(&box));

  /* Set global variable saying we are currently dragging */
  /* so we know whether to process a user_drag_box event  */

  hotlist_dragging.drag_type = HOTLIST_BOX_DRAG_SELECTION;

  /* Install the null handler */

  register_null_claimant(Wimp_ENull, hotlist_null_drag_select_handler, NULL);

  return NULL;
}

/**************************************************************/
/* hotlist_null_drag_select_handler()                         */
/*                                                            */
/* This function is called as a null handler; it is           */
/* responsible for selecting and deselecting items within and */
/* outside the rubber drag box started by                     */
/* hotlist_selection_box_start.                               */
/*                                                            */
/* Parameters are as standard for a Wimp event handler.       */
/**************************************************************/

static int hotlist_null_drag_select_handler(int event_code, WimpPollBlock * event, IdBlock * id_block, void * handle)
{
  WimpGetPointerInfoBlock pointerblock;
  WimpGetWindowStateBlock state;
  unsigned int            item_height, item_dir_width, item_url_width;
  unsigned int            item_min,    item_max;
  int                     workx,       worky;
  int                     minx,        maxx;

  /* Find the pointer position and get information on the hotlist window */

  ChkError(wimp_get_pointer_info(&pointerblock));

  ChkError(window_get_wimp_handle(0, hotlist_windowid, &state.window_handle));
  ChkError(wimp_get_window_state(&state));

  ChkError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));

  /* Get the mouse position in window coordinates */

  workx = pointerblock.x + (state.xscroll - state.visible_area.xmin);
  worky = pointerblock.y + (state.yscroll - state.visible_area.ymax);

  /* Work out the items spanned by the drag box */

  item_min = -worky / item_height;
  if (-selection_y / item_height < item_min) item_min = -selection_y / item_height;
  item_max = (-worky / item_height);
  if ((-selection_y / item_height) > item_max) item_max = (-selection_y / item_height);

  if (selection_x < workx)
  {
    minx = selection_x;
    maxx = workx;
  }
  else
  {
    minx = workx;
    maxx = selection_x;
  }

  /* Select them */

  ChkError(hotlist_select_box(item_min, item_max, minx, maxx));

  return 0;
}

/**************************************************************/
/* hotlist_select_box()                                       */
/*                                                            */
/* Sets the HOTLIST_G_DRAG_SELECTED flag for all visible      */
/* items in the range first_item to last_item where their     */
/* horizontal visible area intersects with the a line draw    */
/* from minx to maxx. Clears the HOTLIST_G_DRAG_SELECTED flag */
/* for all other items.                                       */
/*                                                            */
/* Parameters: Number of the first visible item;              */
/*                                                            */
/*             Number of the last visible item;               */
/*                                                            */
/*             minx (window coords);                          */
/*                                                            */
/*             maxx (window coords).                          */
/**************************************************************/

_kernel_oserror * hotlist_select_box(unsigned int first_item, unsigned int last_item, int minx, int maxx)
{
  unsigned int itemno = 0;

  return hotlist_select_box_r(first_item,
                              last_item,
                              hotlist_root->data.directory_content,
                              &itemno,
                              minx,
                              maxx);
}

/**************************************************************/
/* hotlist_select_box_r()                                     */
/*                                                            */
/* Recursive backend to hotlist_select_box.                   */
/*                                                            */
/* Parameters: Number of the first visible item;              */
/*                                                            */
/*             Number of the last visible item;               */
/*                                                            */
/*             First item in the directory to scan;           */
/*                                                            */
/*             Pointer to an int, in which the current item   */
/*             number is kept (for internal use only);        */
/*                                                            */
/*             minx (window coords);                          */
/*                                                            */
/*             maxx (window coords).                          */
/**************************************************************/

_kernel_oserror * hotlist_select_box_r(unsigned int first_item, unsigned int last_item, hotlist_item * item,
                                       unsigned int * itemno, int minx, int maxx)
{
  _kernel_oserror * e;
  int               itemxmin, itemxmax;

  while (item)
  {
    if (*itemno >= first_item && *itemno <= last_item)
    {
      /* As long as we're within the item number specified, deal with items */

      RetError(hotlist_get_shape(&itemxmin, &itemxmax, item));

      /* Select items within the horizontal range */

      if (!(maxx < itemxmin || minx > itemxmax))
      {
        if (!(item->flags & HOTLIST_G_DRAG_SELECTED))
        {
          item->flags |= HOTLIST_G_DRAG_SELECTED;

          e = hotlist_redraw_items(*itemno, *itemno);

          /* If directory is closed, select everything in it (if it is open, */
          /* we should only select items the drag box covers).               */

          if (item->type == hl_directory && !(item->flags & HOTLIST_D_IS_OPEN))
          {
            hotlist_set_flags  (item->data.directory_content, hl_ALL, HOTLIST_G_DRAG_SELECTED);
            hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_REDRAW_NOW);
          }

          if (e) return e;
        }
      }

      /* Deselect items outside of the horizontal range */

      else
      {
        if (item->flags & HOTLIST_G_DRAG_SELECTED)
        {
          item->flags &= ~HOTLIST_G_DRAG_SELECTED;

          e = hotlist_redraw_items(*itemno, *itemno);

          /* If directory is closed unselect everything in it */

          if (item->type == hl_directory && !(item->flags & HOTLIST_D_IS_OPEN))
          {
            hotlist_clear_flags(item->data.directory_content,
                                hl_ALL,
                                HOTLIST_G_DRAG_SELECTED | HOTLIST_G_REDRAW_NOW);
          }

          if (e) return e;
        }
      }
    }
    else
    {
      /* If we're not within the item numbers specified, then deselect things */

      if (item->flags & HOTLIST_G_DRAG_SELECTED)
      {
        item->flags &= ~HOTLIST_G_DRAG_SELECTED;

        e = hotlist_redraw_items(*itemno, *itemno);

        /* If directory is closed unselect everything in it */

        if (item->type == hl_directory && !(item->flags & HOTLIST_D_IS_OPEN))
        {
          hotlist_clear_flags(item->data.directory_content,
                              hl_ALL,
                              HOTLIST_G_DRAG_SELECTED | HOTLIST_G_REDRAW_NOW);
        }

        if (e) return e;
      }
    }

    /* Increment the item number character */

    *itemno += 1;

    /* Recurse for any open directory items */

    if (item->type == hl_directory && item->flags & HOTLIST_D_IS_OPEN)
    {
      RetError(hotlist_select_box_r(first_item,
                                    last_item,
                                    item->data.directory_content,
                                    itemno,
                                    minx,
                                    maxx));
    }

    /* Get the next item */

    item = item->next;
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* hotlist_contents_selected()                                */
/*                                                            */
/* Checks if all items and subdirectories are selected.       */
/*                                                            */
/* Parameters: Pointer to the first hotlist_item to check.    */
/*                                                            */
/* Returns:    1 if all items are selected, else 0 (there are */
/*             unselected items).                             */
/**************************************************************/

static unsigned int hotlist_contents_selected(hotlist_item * item)
{
  while (item)
  {
    /* Keep trying to find an unselected item and */
    /* immediately return 0 if found.             */

    if (!item->flags & HOTLIST_G_IS_SELECTED) return 0;

    if (item->type == hl_directory)
    {
      if (!hotlist_contents_selected(item->data.directory_content)) return 0;
    }

    item = item->next;
  }
  return 1;
}

/**************************************************************/
/* hotlist_no_contents_selected()                             */
/*                                                            */
/* Checks if all items and subdirectories are unselected.     */
/*                                                            */
/* Parameters: Pointer to the first hotlist_item to check.    */
/*                                                            */
/* Returns:    1 if all items are unselected, or 0 (there are */
/*             selected items).                               */
/**************************************************************/

static unsigned int hotlist_no_contents_selected(hotlist_item * item)
{
  while (item)
  {
    /* Keep trying to find a selected item and */
    /* immediately return 0 if found.          */

    if (item->flags & HOTLIST_G_IS_SELECTED) return 0;

    if (item->type == hl_directory)
    {
      if (!hotlist_no_contents_selected(item->data.directory_content)) return 0;
    }

    item = item->next;
  }

  return 1;
}

/**************************************************************/
/* hotlist_show_descriptions_handler()                        */
/*                                                            */
/* Selects Show Descriptions and redraws the hotlist window   */
/* and relevant menus to reflect this. Parameters are as      */
/* standard for a Toolbox event handler.                      */
/**************************************************************/

static int hotlist_show_descriptions_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  ObjectId main_menu;

  hl_show_urls = 0;

  /* Update the menus */

  ChkError(window_get_menu(0, hotlist_windowid, &main_menu));
  hotlist_set_menu_details(main_menu);

  /* Ensure the window is up to date */

  hotlist_preopen();

  /* Redraw as required */

  ChkError(hotlist_redraw_items(0,
                                hotlist_count_displayed_items(hotlist_root->data.directory_content)));

  return 1;
}

/**************************************************************/
/* hotlist_show_urls_handler()                                */
/*                                                            */
/* Selects Show URLs and redraws the hotlist window and       */
/* relevant menus to reflect this. Parameters are as standard */
/* for a Toolbox event handler.                               */
/**************************************************************/

static int hotlist_show_urls_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  ObjectId main_menu;

  hl_show_urls = 1;

  /* Update the menus */

  ChkError(window_get_menu(0, hotlist_windowid, &main_menu));
  hotlist_set_menu_details(main_menu);

  /* Ensure the window is up to date */

  hotlist_preopen();

  /* Redraw as required */

  ChkError(hotlist_redraw_items(0,
                                hotlist_count_displayed_items(hotlist_root->data.directory_content)));
  return 1;
}

/**************************************************************/
/* hotlist_convert_drag_selection()                           */
/*                                                            */
/* Recurses through the hotlist_item structure altering all   */
/* 'HOTLIST_G_DRAG_SELECTED' items to have                    */
/* 'HOTLIST_G_IS_SELECTED' set or unset as is appropriate.    */
/*                                                            */
/* dragselected and selected = unselected dragselected =      */
/* selected selected = selected neither = unselected          */
/*                                                            */
/* Parameters: Pointer to a hotlist_item to start on.         */
/**************************************************************/

static void hotlist_convert_drag_selection(hotlist_item *item)
{
  while (item)
  {
    if (item->flags & HOTLIST_G_DRAG_SELECTED)
    {
      item->flags &= ~HOTLIST_G_DRAG_SELECTED;

      if (item->flags & HOTLIST_G_IS_SELECTED) item->flags &= ~HOTLIST_G_IS_SELECTED;
      else                                     item->flags |= HOTLIST_G_IS_SELECTED;
    }

    /* Recursive call for directories */

    if (item->type == hl_directory)
    {
      hotlist_convert_drag_selection(item->data.directory_content);
    }

    item = item->next;
  }
}

/**************************************************************/
/* hotlist_modified()                                         */
/*                                                            */
/* Called whenever the hotlist is modified.                   */
/*                                                            */
/* Parameters: The operaton that modified the hotlist, as a   */
/*             number; see the HL_MODIFIED_... definitions in */
/*             Hotlist.h.                                     */
/**************************************************************/

static _kernel_oserror * hotlist_modified(unsigned int type)
{
  dprintf(("Hotl", "hotlist_modified: Called\n"));

  if (choices.save_hotlist == Choices_SaveHotlist_Always)
  {
    /* If we've loaded a resources file, there's no point  */
    /* saving the hotlist because the read-only parts will */
    /* not get saved anyway.                               */

    if (type != HL_MODIFIED_LOADED_RESOURCES)
    {
      #ifdef SINGLE_USER

        return hotlist_save(lookup_choice("HotlistSave:Browse:User.Hotlist",0,0));

      #else

        multiuser_save_hotlist();
        return NULL;

      #endif
    }
  }

  return NULL;
}

/**************************************************************/
/* hotlist_initiate_uri_save()                                */
/*                                                            */
/* Starts file transfer of a URI file to another application. */
/*                                                            */
/* Parameters: Pointer to the hotlist item to save as a URI   */
/*             file.                                          */
/**************************************************************/

static _kernel_oserror * hotlist_initiate_uri_save(hotlist_item * item)
{
  WimpGetPointerInfoBlock block;
  WimpMessage             message;
  int                     ctrl;

  /* Is Control being pressed? */

  _swix(OS_Byte,
        _INR(0,1) | _OUT(1),

        121,
        129,

        &ctrl);

  /* Find out where the pointer is */

  RetError(wimp_get_pointer_info(&block));

  /* Get the leafname. Use a message block for the buffer because  */
  /* there's no point generating anything longer than can actually */
  /* be sent out in a message.                                     */

  urlutils_leafname_from_url(item->data.url,
                             message.data.data_save.leaf_name,
                             sizeof(message.data.data_save.leaf_name));

  /* Send Message_DataSave to start file transfer - a URI file, */
  /* or if Control is held down, a URL file.                    */

  return protocols_atats_send_data_save(NULL,
                                        item,
                                        message.data.data_save.leaf_name,
                                        save_uri_size(item->data.url, item->name, 0),
                                        ctrl ? FileType_URL : FileType_URI,
                                        protocols_saving_hotlist_entry,
                                        &block);
}

/**************************************************************/
/* hotlist_initiate_html_save()                               */
/*                                                            */
/* Starts file transfer of a selection in the hotlist as an   */
/* HTML file.                                                 */
/*                                                            */
/* Parameters: Pointer to a null-terminated leafname to save  */
/*             as.                                            */
/**************************************************************/

static _kernel_oserror * hotlist_initiate_html_save(char * filename)
{
  WimpGetPointerInfoBlock block;
  WimpMessage             message;

  RetError(wimp_get_pointer_info(&block));

  /* Ensure the leafname isn't too long for a message */

  StrNCpy0(message.data.data_save.leaf_name, filename);

  /* Send Message_DataSave to start file transfer */

  return protocols_atats_send_data_save(NULL,
                                        NULL,
                                        message.data.data_save.leaf_name,
                                        -1,
                                        FileType_HTML,
                                        protocols_saving_hotlist_selection,
                                        &block);
}

/**************************************************************/
/* hotlist_return_window_id()                                 */
/*                                                            */
/* Returns:    The toolbox object ID of the hotlist window.   */
/**************************************************************/

ObjectId hotlist_return_window_id(void)
{
  return hotlist_windowid;
}

/**************************************************************/
/* hotlist_add_position()                                     */
/*                                                            */
/* Add a new URL to the hotlist at a specified position.     */
/*                                                            */
/* Parameters: Screen relative x position;                    */
/*                                                            */
/*             Screen relative y position;                    */
/*                                                            */
/*             Description of the URL (e.g. from the page     */
/*             title);                                        */
/*                                                            */
/*             Pointer to the URL itself.                     */
/**************************************************************/

_kernel_oserror * hotlist_add_position(int x, int y, char * description, char * url)
{
  WimpGetWindowStateBlock   state;
  hotlist_item            * targetitem;
  unsigned int              item_height, item_dir_width, item_url_width;
  int                       winx, winy;
  int                       top, position;

  /* Calculate window relative coordinates */

  RetError(window_get_wimp_handle(0,
                                  hotlist_windowid,
                                  &state.window_handle));

  RetError(wimp_get_window_state(&state));

  winx = coords_x_toworkarea(x, (WimpRedrawWindowBlock *) &state);
  winy = coords_y_toworkarea(y, (WimpRedrawWindowBlock *) &state);

  /* Calculate which item add is over */

  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);

  top        = (-winy) / item_height;
  targetitem = hotlist_find_item(hotlist_root->data.directory_content, top);

  /* Decide where to put the new item */

  if (targetitem)
  {
    if ((-winy % item_height) > item_height / 2)
    {
      /* Put item after the target if we're over */
      /* half way past its height                */

      position = HOTLIST_POSITION_AFTER;
    }
    else
    {
      /* Otherwise, put item before the target */

      position = HOTLIST_POSITION_BEFORE;
    }
  }
  else
  {
    /* Put item at end of root directory */

    position   = HOTLIST_POSITION_END;
    targetitem = hotlist_root;
  }

  /* Create new item in appropriate place */

  RetError(hotlist_new_url(targetitem,
                           position,
                           description,
                           url));

  hotlist_preopen();

  /* Optimise the redraw to do as little as possible depending */
  /* upon where in the list the item was added.                */

  switch (position)
  {
    case HOTLIST_POSITION_END:
    {
      RetError(hotlist_redraw_now());
    }
    break;

    default:
    {
      hotlist_clear_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);

      RetError(hotlist_redraw_items(top - 1,
                                    hotlist_count_displayed_items(hotlist_root->data.directory_content)));
    }
    break;
  }

  /* Exit by calling the routine that we must call every */
  /* time the hotlist changes (so that it can, for       */
  /* example, be saved - should the Choices require it.  */

  return hotlist_modified(HL_MODIFIED_ADD);
}

/**************************************************************/
/* hotlist_add_html_file()                                    */
/*                                                            */
/* Read in an HTML file, adding items starting at the         */
/* specified position.                                        */
/*                                                            */
/* Parameters: Screen relative x position;                    */
/*                                                            */
/*             Screen relative y position;                    */
/*                                                            */
/*             Pathname of the HTML file.                     */
/**************************************************************/

_kernel_oserror * hotlist_add_html_file(int x, int y, char * path)
{
  _kernel_oserror         * e;
  hotlist_item            * targetitem;
  hotlist_item            * newitem;
  FILE                    * fileptr;
  WimpGetWindowStateBlock   state;
  unsigned int              item_height, item_dir_width, item_url_width;
  int                       winx, winy;
  int                       top, position;
  char                    * dirname;

  /* Calculate window relative coordinates */

  RetError(window_get_wimp_handle(0,
                                  hotlist_windowid,
                                  &state.window_handle));

  RetError(wimp_get_window_state(&state));

  winx = coords_x_toworkarea(x, (WimpRedrawWindowBlock *) &state);
  winy = coords_y_toworkarea(y, (WimpRedrawWindowBlock *) &state);

  /* Calculate which item add is over */

  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);

  top        = (-winy) / item_height;
  targetitem = hotlist_find_item(hotlist_root->data.directory_content, top);

  /* Decide where to put the new item */

  if (targetitem)
  {
    if ((-winy % item_height) > item_height / 2)
    {
      /* Put item after the target if we're over */
      /* half way past its height                */

      position = HOTLIST_POSITION_AFTER;
    }
    else
    {
      /* Otherwise, put item before the target */

      position = HOTLIST_POSITION_BEFORE;
    }
  }
  else
  {
    /* Put item at end of root directory */

    position   = HOTLIST_POSITION_END;
    targetitem = hotlist_root;
  }

  dirname = strrchr(path, '.');
  if (dirname) dirname ++;
  if (!dirname || !*dirname) dirname = lookup_token("HotlistUntitled:(Untitled)",0,0);

  RetError(hotlist_new_directory(targetitem, dirname, position, &newitem));

  /* Open the file */

  fileptr = fopen(path, "r");

  if (fileptr == NULL)
  {
    erb.errnum = Utils_Error_Custom_Normal;

    StrNCpy0(erb.errmess,
             lookup_token("HlCantLoad:Hotlist file could not be loaded",
                          0,
                          0));

    return &erb;
  }

  /* Load it, adding to the new directory */

  e = hotlist_load_directory(fileptr, newitem);

  fclose(fileptr);

  if (e) return e;

  /* Handle redraw */

  hotlist_preopen();

  hotlist_set_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);

  RetError(hotlist_redraw_now());

  /* Exit through the 'has modified' routine */

  return hotlist_modified(HL_MODIFIED_ADD);
}

/**************************************************************/
/* hotlist_load_resources()                                   */
/*                                                            */
/* Read in a read-only 'Resources' hotlist, at the top of the */
/* hotlist window. This will not be saved when the rest of    */
/* the hotlist is.                                            */
/*                                                            */
/* Errors are raised if there is not enough memory etc., but  */
/* not if the file doesn't exist.                             */
/*                                                            */
/* Parameters: Pathname of the HTML file.                     */
/**************************************************************/

_kernel_oserror * hotlist_load_resources(char * path)
{
  _kernel_oserror * e;
  hotlist_item    * newitem;
  FILE            * fileptr;

  RetError(hotlist_new_directory(hotlist_root,
                                 lookup_token("HotlistResDir:Resources",0,0),
                                 HOTLIST_POSITION_BEGINNING,
                                 &newitem));

  /* Open the file */

  fileptr = fopen(path, "r");

  /* Fail silently if there's an error opening it */

  if (fileptr == NULL) return NULL;

  /* Load it, adding to the new directory */

  e = hotlist_load_directory(fileptr, newitem);

  fclose(fileptr);

  if (e) return e;

  /* Set all contained items as read-only, and mark the top-level */
  /* Resources directory as both read-only and, if the Choices    */
  /* say so, open.                                                */

  newitem->flags |= (HOTLIST_G_IS_READ_ONLY);

  hotlist_set_flags(newitem->data.directory_content,
                    hl_ALL,
                    HOTLIST_G_IS_READ_ONLY);

  if (!strcmp(lookup_choice("OpenResources:no",0,0), "yes"))
  {
    newitem->flags |= (HOTLIST_D_IS_OPEN);
  }

  /* Handle redraw */

  hotlist_preopen();
  hotlist_set_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);

  RetError(hotlist_redraw_now());

  /* Exit through the 'has modified' routine */

  return hotlist_modified(HL_MODIFIED_LOADED_RESOURCES);
}

/**************************************************************/
/* hotlist_get_selected_shape()                               */
/*                                                            */
/* This routine gets the coordinates required to bound every  */
/* selected item in the hotlist window (window relative       */
/* coordinated)                                               */
/*                                                            */
/* Parameters: Pointer to window relative bounding box.       */
/*                                                            */
/* Returns:    1 if there were selected item(s), 0 if there   */
/*             weren't.                                       */
/**************************************************************/

static int hotlist_get_selected_shape(BBox * box)
{
  _kernel_oserror * e;
  unsigned int      itemno, item_height;
  int               found;

  found  = 0;
  itemno = 0;

  /* Get item sizes */

  e = hotlist_get_entry_sizes(&item_height, NULL, NULL);

  if (e)
  {
    show_error_ret(e);
    return 0;
  }

  /* Enter the recursive routine */

  e = hotlist_get_selected_shape_r(hotlist_root->data.directory_content,
                                   box,
                                   &itemno,
                                   &found,
                                   item_height);
  if (e)
  {
    show_error_ret(e);
    return 0;
  }

  return found;
}

/**************************************************************/
/* hotlist_get_selected_shape_r()                             */
/*                                                            */
/* Recursive back-end to hotlist_get_selected_shape().        */
/*                                                            */
/* Parameters: Pointer to a hotlist_item;                     */
/*                                                            */
/*             Pointer to window relative bounding box;       */
/*                                                            */
/*             Pointer to the current item number (for        */
/*             internal use);                                 */
/*                                                            */
/*             Pointer to found flag;                         */
/*                                                            */
/*             The height of a single entry in OS units.      */
/**************************************************************/

static _kernel_oserror * hotlist_get_selected_shape_r(hotlist_item * list, BBox * box, unsigned int * itemno, int * found, unsigned int item_height)
{
  int newxmin, newxmax;

  while (list)
  {
    if (list->flags & HOTLIST_G_IS_SELECTED)
    {
      RetError(hotlist_get_shape(&newxmin, &newxmax, list));

      /* If we've already found an open item, then only extend the */
      /* bounding box in appropriate directions.                   */

      if (*found)
      {
        if (newxmin < box->xmin) box->xmin = newxmin;
        if (newxmax > box->xmax) box->xmax = newxmax;

        box->ymin = -((*itemno) + 1) * item_height;
      }
      else
      {
        /* This section run for first selected item found only; */
        /* set the selected shape box to match the item's       */
        /* bounding box.                                        */

        box->xmin = newxmin;
        box->xmax = newxmax;
        box->ymax = -(*itemno)       * item_height;
        box->ymin = -((*itemno) + 1) * item_height;

        /* Flag that we've found a selected item */

        *found = 1;
      }
    }

    *itemno += 1;

    /* Recursively scan all open directories */

    if (list->type == hl_directory && (list->flags & HOTLIST_D_IS_OPEN))
    {
      RetError(hotlist_get_selected_shape_r(list->data.directory_content,
                                            box,
                                            itemno,
                                            found,
                                            item_height));
    }

    /* Follow the list */

    list = list->next;
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* hotlist_find_match()                                       */
/*                                                            */
/* Takes a string from the given buffer and sees if there's   */
/* something in the Hotlist that matches it in some way.      */
/*                                                            */
/* If it finds something it adds any hits to the given        */
/* match_list list, and returns 1.                            */
/*                                                            */
/* The search is case sensitive.                              */
/*                                                            */
/* Parameters: flex_ptr to hang the list of matches from;     */
/*                                                            */
/*             Pointer to the buffer holding the string to    */
/*             try and match.                                 */
/*                                                            */
/* Returns:    1 if match_list is updated with one or more    */
/*             matches, else 0.                               */
/**************************************************************/

int hotlist_find_match(flex_ptr match_list, const char * match)
{
  int got_any = 0;

  if (!match_list || !match || !*match) return 0;

  hotlist_find_match_r(match_list, match, hotlist_root, &got_any);

  return got_any;
}

/**************************************************************/
/* hotlist_find_match_r()                                     */
/*                                                            */
/* Recursive back-end to hotlist_find_match.                  */
/*                                                            */
/* Parameters: flex_ptr to hang the list of matches from;     */
/*                                                            */
/*             Pointer to the buffer holding the string to    */
/*             try and match;                                 */
/*                                                            */
/*             Pointer to the hotlist_item to treat as a root */
/*             directory for the search;                      */
/*                                                            */
/*             Pointer to an int, which at exit is updated to */
/*             hold 1 if any hits were made in the search,    */
/*             else it is left alone.                         */
/*                                                            */
/* Assumes: All pointers are non-NULL and valid.              */
/**************************************************************/

static void hotlist_find_match_r(flex_ptr match_list, const char * match, hotlist_item * item, int * got_any)
{
  while (item)
  {
    if (item->type == hl_directory)
    {
      hotlist_find_match_r(match_list,
                           match,
                           item->data.directory_content,
                           got_any);
    }
    else
    {
      const char * found = NULL;

      if (item->data.url)
      {
        found = strstr(item->data.url, match);
      }

      if (!found && item->name)
      {
        found = strstr(item->name, match);
      }

      if (found)
      {
        int ok = browser_add_match_list_entry(match_list, item->data.url);

        if (ok) *got_any = 1;
        else if (!*match_list) return;
      }
    }

    item = item->next;
  }

  return;
}

/**************************************************************/
/* hotlist_empty()                                            */
/*                                                            */
/* See if the hotlist is empty or not.                        */
/*                                                            */
/* Returns:    1 if the hotlist is empty else 0.              */
/**************************************************************/

int hotlist_empty(void)
{
  if (
       !hotlist_root                         ||
       !hotlist_root->data.directory_content
     )
     return 1;

  return 0;
}
@


1.41
log
@  Completion of v2.11 check-in of Phoenix (note that the application
  gets its reported version number and date from Messages, not the
  VersionNum file, which updates independently).
Detail:
  Various resources updated. New About stuff included. Modification to
  Hotlist.c to ask DragAnObject to *really* call it in USR mode; requires
  DragAnObject 0.09. New "RMTry" utility in Phoenix to help make finding
  up to date modules more friendly - works well in itself but slows down
  the loading time quite a bit; would be nice to find a better solution.
  This will do in the short term, as it's a definite improvement over
  the way the !Run files used to work.
Admin:
  Use of DragAnObject 0.09 fixes aborts when trying to drag items around
  in the hotlist.

Version 2.10. Tagged as 'Browse-2_10'
@
text
@d1031 1
a1031 1
  RetError(read_sprite_size(OPEN_DIRECTORY_SPRITE, &width, &height));
d1043 1
a1043 1
  RetError(read_sprite_size(CLOSED_DIRECTORY_SPRITE, &width, &height));
d1050 1
a1050 1
  RetError(read_sprite_size(INSERT_DIRECTORY_SPRITE, &width, &height));
d1058 1
a1058 1
  RetError(read_sprite_size(URL_SPRITE, &width, &height));
d4936 1
a4936 1
      RetError(read_sprite_size(SELECTION_SPRITE, &width, &height));
@


1.40
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d4913 1
a4913 1
      regs.r[0] = (2<<0) | (2<<2) | (1<<6) | (1<<7) | (1<<16);
@


1.39
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a46 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d238 9
a246 9
    Printf("\nhotlist_display_item for %p\n",item);
    Printf("--------------------\n");
    Printf("type              = %d\n", item->type);
    Printf("name              = %s\n", item->name);
    Printf("flags             = %d\n", item->flags);
    Printf("parent            = %p\n", item->parent);
    Printf("previous          = %p\n", item->previous);
    Printf("next              = %p\n", item->next);
    Printf("data.generic_data = %p ",  item->data.generic_data);
d252 1
a252 1
        Printf("URL(%s)\n", item->data.url);
d258 1
a258 1
        Printf("sub directory pointer\n");
d264 1
a264 1
        Printf("\n");
d284 2
a285 2
    Printf("\nhotlist_display_tree for %p, indent %d\n", list, indent);
    Printf("--------------------\n\n");
d289 1
a289 1
      for (count = 0; count < indent; count++) Printf("| ");
d295 1
a295 1
          Printf("%s:URL(%s)\n", list->name, list->data.url);
d301 1
a301 1
          Printf("%s:DIRECTORY", list->name);
d306 1
a306 1
          Printf(" (Open)\n");
d311 1
a311 1
          Printf(" (Closed)\n");
d318 1
a318 1
          Printf("%s:UNRECOGNISED TYPE\n", list->name);
d718 1
a718 3
    #ifdef TRACE
        if (tl & (1<<25)) Printf("hotlist_new_url: Could not allocate room for new URL item\n");
    #endif
d2207 1
a2207 1
    if (tl & (1u<<25)) hotlist_display_item(item);
d3567 1
a3567 1
    if (tl & (1u<<25)) hotlist_display_tree(hotlist_root, 0);
d4125 1
a4125 3
  #ifdef TRACE
    if (tl & (1u<<25)) Printf("hotlist_show_newurl_handler: Called\n");
  #endif
d4159 1
a4159 3
  #ifdef TRACE
    if (tl & (1u<<25)) Printf("hotlist_show_editurl_handler: Called\n");
  #endif
d4201 1
a4201 3
  #ifdef TRACE
    if (tl & (1u<<25)) Printf("hotlist_show_newdirectory_handler: Called\n");
  #endif
d4233 1
a4233 3
  #ifdef TRACE
    if (tl & (1u<<25)) Printf("hotlist_show_rendirectory_handler: Called\n");
  #endif
d4704 1
a4704 1
  /* DON'T put Printf's in here... Doesn't work, at least, */
d5008 1
a5008 3
  #ifdef TRACE
    if (tl & (1u<<25)) Printf("hotlist_drag_stop_handler: Called\n");
  #endif
d5137 1
a5137 3
  #ifdef TRACE
    if (tl & (1u<<25)) Printf("hotlist_drag_completed_handler: Called\n");
  #endif
d5496 1
a5496 3
    #ifdef TRACE
      if (tl & (1<<25)) Printf("hotlist_autoscroll: Resetting\n");
    #endif
d6372 1
a6372 3
  #ifdef TRACE
    if (tl & (1u<<25)) Printf("hotlist_modified: Called\n");
  #endif
@


1.38
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d15 16
a30 11
/***************************************************/
/* File   : Hotlist.c                              */
/*                                                 */
/* Purpose: Managing a hotlist in the browser.     */
/*                                                 */
/* Author : D.T.A.Brown                            */
/*                                                 */
/* History: 06-Aug-97: Created.                    */
/*          22-Aug-97: (ADH/DTAB) Integrated into  */
/*                     main browser code.          */
/***************************************************/
d37 2
a38 1
#include "swis.h"
d40 11
a50 6
#include "toolbox.h"
#include "wimp.h"
#include "wimplib.h"
#include "menu.h"
#include "event.h"
#include "gadgets.h"
a51 1
#include "svcprint.h"
d232 8
a239 8
  /*************************************************/
  /* hotlist_display_item()                        */
  /*                                               */
  /* This function display the data held by a      */
  /* single hotlist_item                           */
  /*                                               */
  /* Parameters: Pointer to a hotlist_item         */
  /*************************************************/
d275 9
a283 10
  /*************************************************/
  /* hotlist_display_tree()                        */
  /*                                               */
  /* Recursivly display the hotlist tree starting  */
  /* from the passed item                          */
  /*                                               */
  /* Parameters: Pointer to a hotlist_item         */
  /*             value to start indent at          */
  /*             recommended 0                     */
  /*************************************************/
d360 26
a385 32
/*************************************************/
/* hotlist_link()                                */
/*                                               */
/* This function links the passed item to the    */
/* passed target.                                */
/*                                               */
/* It can link the item in four different ways;  */
/* before or after the target, or if the target  */
/* is a directory, at the beginning or end of    */
/* that directory's contents.                    */
/*                                               */
/* Parameters: Pointer to the hotlist_item       */
/*             struct to link in;                */
/*                                               */
/*             Pointer to the hotlist_item       */
/*             struct to link to;                */
/*                                               */
/*             Position to link to -             */
/*             HOTLIST_POSITION_BEGINNING        */
/*             HOTLIST_POSITION_END              */
/*             HOTLIST_POSITION_BEFORE or        */
/*             HOTLIST_POSITION_AFTER.           */
/*                                               */
/* Assumes:    The item and target pointers are  */
/*             not NULL and are valid;           */
/*                                               */
/*             That if adding to the beginning   */
/*             or end, the target is a directory */
/*             (in both cases, an error will be  */
/*             raised in TRACE builds if the     */
/*             assumptions are violated).        */
/*************************************************/
d529 8
a536 9
/*************************************************/
/* hotlist_unlink()                              */
/*                                               */
/* This function unlinks the passed item from    */
/* the items linked in before and after it.      */
/*                                               */
/* Parameters: Pointer to the hotlist_item       */
/*             struct to remove.                 */
/*************************************************/
d551 24
a574 27
/*************************************************/
/* hotlist_new_directory()                       */
/*                                               */
/* This function creates a new directory         */
/* at the beginning of the given parent.         */
/*                                               */
/* Parameters: Pointer to a hotlist_item of type */
/*             directory that represents the     */
/*             parent item for this new entry;   */
/*                                               */
/*             Name of new directory to create;  */
/*                                               */
/*             Position to create the new item   */
/*             relative to the parent (as for    */
/*             hotlist_link);                    */
/*                                               */
/*             Pointer to a pointer to a         */
/*             hotlist_item struct, which will   */
/*             be filled in with the address of  */
/*             the new item (unless there is an  */
/*             error returned).                  */
/*                                               */
/* Assumes:    That the pointer to a pointer to  */
/*             a hotlist_item struct is not NULL */
/*             (it would make little sense to    */
/*             allow this...).                   */
/*************************************************/
d667 17
a683 19
/*************************************************/
/* hotlist_new_url()                             */
/*                                               */
/* This function creates a new url               */
/* at the end of the passed directory            */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             representing a directory to add   */
/*             the URL to;                       */
/*                                               */
/*             Position within that directory    */
/*             to link to (number of items from  */
/*             the start);                       */
/*                                               */
/*             Description of the URL (e.g. from */
/*             the page title);                  */
/*                                               */
/*             Pointer to the URL itself.        */
/*************************************************/
d792 8
a799 10
/*************************************************/
/* hotlist_delete_item()                         */
/*                                               */
/* This function deletes an item from the        */
/* hotlist structure; it will recursively delete */
/* directories.                                  */
/*                                               */
/* Parameters: Pointer to the hotlist_item       */
/*             struct to delete.                 */
/*************************************************/
d857 21
a877 24
/*************************************************/
/* hotlist_move_item()                           */
/*                                               */
/* This function takes an item and moves its     */
/* position within the directory tree.           */
/*                                               */
/* Parameters: Pointer to the hotlist_item       */
/*             struct to move;                   */
/*                                               */
/*             Pointer to the hotlist_item       */
/*             structure to move to;             */
/*                                               */
/*             Position relative to that struct  */
/*             for the item to go to, as for     */
/*             hotlist_link.                     */
/*                                               */
/* Assumes:    It is assumed that if the object  */
/*             is a directory it is not being    */
/*             moved into it self or one of its  */
/*             children. If this is not the case */
/*             then both it and its children     */
/*             will become unlinked from the     */
/*             hotlist structure (nasty...!).    */
/*************************************************/
d933 26
a958 31
/*************************************************/
/* hotlist_copy_item()                           */
/*                                               */
/* This function copies an item, and in the case */
/* of it being a directory, its children, to the */
/* specified place.                              */
/*                                               */
/* Parameters: Pointer to the hotlist_item       */
/*             struct to copy;                   */
/*                                               */
/*             Pointer to the hotlist_item       */
/*             struct to copy to;                */
/*                                               */
/*             Position relative to that item to */
/*             copy to, as for hotlist_link;     */
/*                                               */
/*             Pointer to a pointer to a         */
/*             hotlist_item struct, in which the */
/*             address of the new item is        */
/*             returned.                         */
/*                                               */
/* Assumes:    It is assumed that if the object  */
/*             is a directory it is not being    */
/*             copied into it self or one of its */
/*             children - if it is the function  */
/*             will keep recursing and           */
/*             eventually run out of stack;      */
/*                                               */
/*             The pointer to the pointer to the */
/*             hotlist_item struct may be NULL.  */
/*************************************************/
d1013 18
a1030 21
/*************************************************/
/* hotlist_get_entry_sizes()                     */
/*                                               */
/* This function reads the size of the sprites   */
/* to be used by the hotlist and from them       */
/* determines the size of the hotlist entries.   */
/*                                               */
/* Parameters: Pointer to an int, in which the   */
/*             height of an item is placed in    */
/*             OS units;                         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             minimum width of a directory item */
/*             is returned, in OS units;         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             minimum width of a URL item is    */
/*             returned, in OS units.            */
/*                                               */
/* Assumes:    Any of the pointers may be NULL.  */
/*************************************************/
d1079 17
a1095 19
/*************************************************/
/* hotlist_set_flags()                           */
/*                                               */
/* This function will recursively set flags for  */
/* either a specified type of hotlist_item or    */
/* all hotlist_items, to the given value. All    */
/* items which are changed will have their       */
/* HOTLIST_G_REDRAW_NOW bit set.                 */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             to start on;                      */
/*                                               */
/*             Type of hotlist_item to set flags */
/*             for, or hl_ALL for all types;     */
/*                                               */
/*             Flags to set.                     */
/*                                               */
/* Returns:    1 if any flags were set, else 0.  */
/*************************************************/
d1129 19
a1147 22
/*************************************************/
/* hotlist_clear_flags()                         */
/*                                               */
/* This function will recursively clear flags    */
/* for either a specified type of hotlist_item   */
/* or all hotlist_items. All items changed will  */
/* have their HOTLIST_G_REDRAW_NOW bit set,      */
/* unless, of course, the routine is called to   */
/* clear that bit.                               */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             to start on;                      */
/*                                               */
/*             Type of hotlist_item to set flags */
/*             for, or hl_ALL for all types;     */
/*                                               */
/*             Flags clear word (any bits set in */
/*             this word are cleared in the item */
/*             flags).                           */
/*                                               */
/* Returns:    1 if flags were cleared, else 0.  */
/*************************************************/
d1181 15
a1195 16
/*************************************************/
/* hotlist_find_item()                           */
/*                                               */
/* This function will recursivly scan through    */
/* a hotlist structure and return a pointer to   */
/* the n'th item.  It will only recurse through  */
/* open directories.                             */
/*                                               */
/* Parameters: Pointer to a hotlist_item at the  */
/*             top of the directory to scan;     */
/*                                               */
/*             The nth item to return within it. */
/*                                               */
/* Returns:    Pointer to the requested item or  */
/*             NULL if it does not exist.        */
/*************************************************/
d1204 18
a1221 20
/*************************************************/
/* hotlist_find_item_r()                         */
/*                                               */
/* Recursive back-end to hotlist_find_item.      */
/*                                               */
/* Parameters: Pointer to a hotlist_item at the  */
/*             top of the directory to scan;     */
/*                                               */
/*             The nth item to return within it; */
/*                                               */
/*             Pointer to an int, in which the   */
/*             number of the current item is     */
/*             accumulated (initialised to an    */
/*             appropriate value, usually 0).    */
/*                                               */
/* Returns:    As hotlist_find_item.             */
/*                                               */
/* Assumes:    The pointer to the int may *not*  */
/*             be NULL.                          */
/*************************************************/
d1251 14
a1264 17
/*************************************************/
/* hotlist_find_no_from_item()                   */
/*                                               */
/* This function will recursivly scan through    */
/* a hotlist structure and return the position   */
/* of the specified item. It will only recurse   */
/* through open directories.                     */
/*                                               */
/* Parameters: Pointer to a hotlist_item to      */
/*             start at;                         */
/*                                               */
/*             Pointer to the item whos position */
/*             is to be returned.                */
/*                                               */
/* Returns:    The item position or -1 if it is  */
/*             not found.                        */
/*************************************************/
d1273 18
a1290 22
/*************************************************/
/* hotlist_find_no_from_item_r()                 */
/*                                               */
/* Recursive back-end to                         */
/* hotlist_find_no_from_item.                    */
/*                                               */
/* Parameters: Pointer to a hotlist_item to      */
/*             start at;                         */
/*                                               */
/*             Pointer to the item whos position */
/*             is to be returned;                */
/*                                               */
/*             Pointer to an int, in which the   */
/*             number of the current item is     */
/*             accumulated (initialised to an    */
/*             appropriate value, usually 0).    */
/*                                               */
/* Returns:    As hotlist_find_no_from_item.     */
/*                                               */
/* Assumes:    The pointer to the int may *not*  */
/*             be NULL.                          */
/*************************************************/
d1322 11
a1332 12
/*************************************************/
/* hotlist_find_selected_item()                  */
/*                                               */
/* This function returns a pointer to the first  */
/* selected item found.                          */
/*                                               */
/* Returns:    Pointer to a hotlist_item struct  */
/*             which was the first selected item */
/*             found in a search starting        */
/*             from the root, or NULL if there   */
/*             is nothing selected.              */
/*************************************************/
d1339 9
a1347 11
/*************************************************/
/* hotlist_find_selected_item_r()                */
/*                                               */
/* Recursive back-end to                         */
/* hotlist_find_selected_item.                   */
/*                                               */
/* Parameters: Pointer to a hotlist_item         */
/*             struct to start at.               */
/*                                               */
/* Returns:    As hotlist_find_selected_item.    */
/*************************************************/
d1375 16
a1390 17
/*************************************************/
/* hotlist_count_selected_items()                */
/*                                               */
/* Count the number of items that are currently  */
/* selected in the hotlist window.               */
/*                                               */
/* If you want to know if all items are selected */
/* use hotlist_contents_selected. If you want to */
/* know if no items are selected, it is faster   */
/* to use hotlist_no_contents_selected than      */
/* compare the return value of this function     */
/* against zero (this function *must* scan all   */
/* hotlist items, whereas the other can exit as  */
/* soon as a selected item is found).            */
/*                                               */
/* Returns:    The number of selected items.     */
/*************************************************/
d1401 13
a1413 16
/*************************************************/
/* hotlist_count_selected_items_r()              */
/*                                               */
/* Recursive back-end to                         */
/* hotlist_count_selected_items.                 */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             representing the first item in a  */
/*             directory to count;               */
/*                                               */
/*             Pointer to an int, in which the   */
/*             total is accumulated.             */
/*                                               */
/* Assumes:    The pointer to the int may *not*  */
/*             be NULL.                          */
/*************************************************/
d1437 10
a1446 11
/*************************************************/
/* hotlist_count_displayed_items()               */
/*                                               */
/* This routine counts the number of items       */
/* displayed in the hotlist window.              */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             to start at.                      */
/*                                               */
/* Returns:    The number of displayed items.    */
/*************************************************/
d1457 12
a1468 15
/*************************************************/
/* hotlist_count_displayed_items_r()             */
/*                                               */
/* Recursive back-end to                         */
/* hotlist_count_displayed_items.                */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             to start at;                      */
/*                                               */
/*             Pointer to an int, in which the   */
/*             total is accumulated.             */
/*                                               */
/* Assumes:    The pointer to the int may *not*  */
/*             be NULL.                          */
/*************************************************/
d1487 16
a1502 18
/*************************************************/
/* hotlist_draw()                                */
/*                                               */
/* Redraws a specified region of the hotlist.    */
/* Assumes graphics rectangles are set up        */
/* appropriately (e.g. the function is called    */
/* during a Wimp redraw session).                */
/*                                               */
/* Parameters: Pointer to a hotlist_item giving  */
/*             the list that we're to draw;      */
/*                                               */
/*             First item number to draw (count  */
/*             the visible items from the top of */
/*             the window downwards starting at  */
/*             an item number of zero);          */
/*                                               */
/*             Last item number to draw.         */
/*************************************************/
d1521 29
a1549 34
/*************************************************/
/* hotlist_draw_r()                              */
/*                                               */
/* Recursive back-end to hotlist_draw.           */
/*                                               */
/* Parameters: Pointer to a hotlist_item giving  */
/*             the list that we're to draw;      */
/*                                               */
/*             First item number to draw (count  */
/*             the visible items from the top of */
/*             the window downwards starting at  */
/*             an item number of zero);          */
/*                                               */
/*             Last item number to draw;         */
/*                                               */
/*             Pointer to an int, which is used  */
/*             to accumulate the current item    */
/*             number - the contents should be   */
/*             initialised to an appropriate     */
/*             value for the first three         */
/*             parameters (usually, zero);       */
/*                                               */
/*             Level of indentation (OS units);  */
/*                                               */
/*             Height of an item (OS units);     */
/*                                               */
/*             Width of a directory item (OS     */
/*             units);                           */
/*                                               */
/*             Width of a URL item (OS units).   */
/*                                               */
/* Assumes:    The pointer to the int may *not*  */
/*             be NULL.                          */
/*************************************************/
d1724 22
a1745 27
/*************************************************/
/* hotlist_get_max_width_r                       */
/*                                               */
/* Recursive back-end to hotlist_get_max_width.  */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             to start at;                      */
/*                                               */
/*             An indent in OS units, as for     */
/*             redrawing the hotlist;            */
/*                                               */
/*             Pointer to an int, in which the   */
/*             width of the widest item so far   */
/*             is accumulated;                   */
/*                                               */
/*             Height of a hotlist item in OS    */
/*             units;                            */
/*                                               */
/*             Width of a hotlist directory      */
/*             sprite in OS units;               */
/*                                               */
/*             Width of a hotlist URL sprite in  */
/*             OS units.                         */
/*                                               */
/* Assumes:    The pointer to the int may *not*  */
/*             be NULL.                          */
/*************************************************/
d1800 13
a1812 14
/*************************************************/
/* hotlist_get_max_width()                       */
/*                                               */
/* This function returns the maximum width of    */
/* of the displayed hotlist entries.             */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             to start at. This is assumed to   */
/*             be at zero indent from the left   */
/*             hand side.                        */
/*                                               */
/* Returns:    Of all visible entries, the width */
/*             of the widest, in OS units.       */
/*************************************************/
d1838 6
a1843 6
/*************************************************/
/* hotlist_redraw_now()                          */
/*                                               */
/* This function redraws all visible items with  */
/* the HOTLIST_G_REDRAW_NOW bit set.             */
/*************************************************/
d1852 12
a1863 15
/*************************************************/
/* hotlist_redraw_now_r()                        */
/*                                               */
/* Recursive back-end to hotlist_redraw_now.     */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             to start on;                      */
/*                                               */
/*             Pointer to an int, in which the   */
/*             current item number being redrawn */
/*             is accumulated.                   */
/*                                               */
/* Assumes:    The pointer to the int may *not*  */
/*             be NULL.                          */
/*************************************************/
d1895 12
a1906 13
/*************************************************/
/* hotlist_add()                                 */
/*                                               */
/* Add a new URL to the hotlist.                 */
/*                                               */
/* Parameters: Description of the URL (e.g. from */
/*             the page title);                  */
/*                                               */
/*             Pointer to the URL itself;        */
/*                                               */
/*             0 to add to the top, 1 to add to  */
/*             the bottom.                       */
/*************************************************/
d2011 17
a2027 18
/*************************************************/
/* hotlist_get_shape()                           */
/*                                               */
/* This function calculates the xmin and xmax    */
/* of the passed hotlist_item.                   */
/*                                               */
/* Parameters: Pointer to an int, in which the   */
/*             xmin offset (in OS units) from    */
/*             the left hand edge is returned;   */
/*                                               */
/*             Similarly, a pointer to an int to */
/*             take the xmax offset;             */
/*                                               */
/*             Pointer to the hotlist_item to    */
/*             examine.                          */
/*                                               */
/* Assumes:    Any pointer may be NULL.          */
/*************************************************/
d2086 13
a2098 15
/*************************************************/
/* hotlist_directory_open_close()                */
/*                                               */
/* This function opens or closes a directory,    */
/* dealing with all required redrawing.          */
/*                                               */
/* Parameters: Pointer to the hotlist_item       */
/*             struct representing the directory */
/*             to open or close;                 */
/*                                               */
/*             Number of that item (counting the */
/*             visible hotlist items from the    */
/*             top of the window downwards,      */
/*             starting at zero).                */
/*************************************************/
d2145 13
a2157 15
/*************************************************/
/* hotlist_redraw_items()                        */
/*                                               */
/* This function forces the redraw of a set of   */
/* items.                                        */
/*                                               */
/* Parameters: Item number of the first item to  */
/*             redraw (counting the visible      */
/*             items from the top of the window  */
/*             downwards, starting at zero) -    */
/*             this is inclusive;                */
/*                                               */
/*             Item number of the last item to   */
/*             redraw (also inclusive).          */
/*************************************************/
d2184 5
a2188 6
/*************************************************/
/* hotlist_clear_selection()                     */
/*                                               */
/* This function unselects all items, redrawing  */
/* as required.                                  */
/*************************************************/
d2202 8
a2209 9
/*************************************************/
/* hotlist_launch_url()                          */
/*                                               */
/* This function launches the url in the passed  */
/* item.                                         */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             holding the URL to launch.        */
/*************************************************/
d2220 21
a2240 22
/*************************************************/
/* hotlist_process_click_on_item()               */
/*                                               */
/* Deal with clicks on hotlist items.            */
/*                                               */
/* Parameters: Item number that was clicked upon */
/*             (counting visible items from the  */
/*             top of the window downwards,      */
/*             starting with item number 0);     */
/*                                               */
/*             Pointer to a hotlist_item struct  */
/*             representing the item clicked on; */
/*                                               */
/*             State of the mouse buttons, as    */
/*             Wimp_GetPointerInfo would return  */
/*             for clicks on a window of button  */
/*             type 10 (Double/Click/Drag);      */
/*                                               */
/*             Screen x coordinate of the click; */
/*                                               */
/*             Screen y coordinate of the click. */
/*************************************************/
d2402 13
a2414 15
/*************************************************/
/* hotlist_process_click()                       */
/*                                               */
/* This function deals with mouse clicks on the  */
/* hotlist window.                               */
/*                                               */
/* Parameters: X position of click, in window    */
/*             coords;                           */
/*                                               */
/*             Y position of click, in window    */
/*             coords;                           */
/*                                               */
/*             Button state (as returned by      */
/*             Wimp_GetPointerInfo).             */
/*************************************************/
d2486 13
a2498 15
/*************************************************/
/* hotlist_preopen()                             */
/*                                               */
/* This function should be called before opening */
/* the hotlist window. If the window is already  */
/* showing, then the extent may be altered but   */
/* it will never shrink the visible area of the  */
/* window. If the window is currently closed, it */
/* will set the extent to the minimum possible   */
/* value, which may well drag the visible area   */
/* down too.                                     */
/*                                               */
/* Returns:    1 if window was already open,     */
/*             or 0 if it was closed.            */
/*************************************************/
d2595 8
a2602 9
/*************************************************/
/* hotlist_redraw_handler()                      */
/*                                               */
/* This handles redraw events from the Wimp, for */
/* the hotlist window.                           */
/*                                               */
/* Parameters are as standard for a Wimp event   */
/* handler.                                      */
/*************************************************/
d2643 9
a2651 11
/*************************************************/
/* hotlist_mouse_click_handler()                 */
/*                                               */
/* Event handler to deal with mouse clicks in    */
/* the hotlist window; converts coordinates from */
/* screen to window, and runs the result through */
/* hotlist_process_click.                        */
/*                                               */
/* Parameters are as standard for a Wimp event   */
/* handler.                                      */
/*************************************************/
d2668 7
a2674 8
/*************************************************/
/* hotlist_menuclose_handler()                   */
/*                                               */
/* Called when menus close.                      */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d2699 9
a2707 11
/*************************************************/
/* hotlist_set_menu_details()                    */
/*                                               */
/* When a menu is to be opened or the hotlist    */
/* state changes in a way that can affect open   */
/* menus, this can be used to update the menu    */
/* contents.                                     */
/*                                               */
/* Parameters: Object ID of the hotlist root     */
/*             menu.                             */
/*************************************************/
d2842 7
a2848 9
/*************************************************/
/* hotlist_menuopen_handler()                    */
/*                                               */
/* Handles events raised when menus are about to */
/* be shown.                                     */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d2909 24
a2932 28
/*************************************************/
/* hotlist_save_entries()                        */
/*                                               */
/* This function recurses through the hotlist    */
/* directory structure saving all directories    */
/* and entries as it goes.                       */
/*                                               */
/* Parameters: Pointer to a FILE struct for the  */
/*             file to write to;                 */
/*                                               */
/*             Pointer to a hotlist_item struct  */
/*             representing the first item in    */
/*             the directory to save (which may  */
/*             itself be a directory);           */
/*                                               */
/*             0 - save all of hotlist,          */
/*             1 - only save selection portions, */
/*             but in both cases obey the next   */
/*             parameter;                        */
/*                                               */
/*             0 - don't save read-only items,   */
/*             1 - allow saving of read-only     */
/*             items.                            */
/*                                               */
/* Assumes:    The FILE pointer must not be NULL */
/*             however the hotlist_item pointer  */
/*             can be (e.g. an empty directory). */
/*************************************************/
d3008 15
a3022 17
/*************************************************/
/* hotlist_save_hotlist()                        */
/*                                               */
/* This function saves the hotlist as an HTML    */
/* file.                                         */
/*                                               */
/* Parameters: Pointer to the filename to save   */
/*             to (null terminated);             */
/*                                               */
/*             Pointer to a buffer containing    */
/*             any extra information to put in   */
/*             the top of the file (intended for */
/*             multiuser builds);                */
/*                                               */
/*             0 to save all of hotlist, 1 to    */
/*             save only the selected portions.  */
/*************************************************/
d3139 9
a3147 9
/*************************************************/
/* hotlist_save()                                */
/*                                               */
/* Veneer onto hotlist_save_hotlist - saves all  */
/* of the hotlist, created to preserve API.      */
/*                                               */
/* Parameters: Pointer to the filename to save   */
/*             to (null terminated).             */
/*************************************************/
d3154 14
a3167 16
/*************************************************/
/* hotlist_lower_tags()                          */
/*                                               */
/* This function processes the passed string     */
/* turning all characters within a tag to lower  */
/* case. It will detect characters within quotes */
/* and leave their case the same; this will      */
/* preserve the case of URLs.                    */
/*                                               */
/* Obviously, this assumes that the HTML file    */
/* being fed in is not broken; tags and quoted   */
/* text must always be correctly closed, and     */
/* in both cases must not span multiple lines.   */
/*                                               */
/* Parameters: Pointer to the string to process. */
/*************************************************/
d3198 16
a3213 19
/*************************************************/
/* hotlist_load_directory()                      */
/*                                               */
/* This function loads the directory contents of */
/* a hotlist HTML file previously saved by       */
/* hotlist_save or a compatible source. For      */
/* example, at the time of creation this can     */
/* correctly load and understand hotlist files   */
/* from at least one other popular browser.      */
/*                                               */
/* Parameters: Pointer to a FILE struct through  */
/*             which data will be read;          */
/*                                               */
/*             Pointer to a hotlist_item; new    */
/*             data structures generated from    */
/*             the file contents are added to    */
/*             the linked list that this struct  */
/*             lies in.                          */
/*************************************************/
d3499 7
a3505 8
/*************************************************/
/* hotlist_discard()                             */
/*                                               */
/* Empties the hotlist. The hotlist window is    */
/* not updated (expected usage is to close the   */
/* window shotly before or after discarding the  */
/* contents).                                    */
/*************************************************/
d3515 9
a3523 9
/*************************************************/
/* hotlist_load()                                */
/*                                               */
/* This function loads an HTML file previously   */
/* saved by hotlist_save as the new hotlist.     */
/*                                               */
/* Parameters: Pointer to the filename to load   */
/*             (null terminated).                */
/*************************************************/
d3587 6
a3592 7
/*************************************************/
/* hotlist_initialise()                          */
/*                                               */
/* This function initialises the hotlist library */
/* routines, and must be called before any other */
/* hotlist functions.                            */
/*************************************************/
d3769 16
a3784 17
/*************************************************/
/* hotlist_open()                                */
/*                                               */
/* Opens the hotlist window. If already open,    */
/* all this does is bring it to the front - it   */
/* doesn't move it. The display type is changed, */
/* if required, in any case.                     */
/*                                               */
/* Parameters: Show type (as for a call to       */
/*             Toolbox_ShowObject);              */
/*                                               */
/*             Show block (as for a call to      */
/*             Toolbox_ShowObject);              */
/*                                               */
/*             0 to open showing descriptions,   */
/*             or 1 to open showing URLs.        */
/*************************************************/
d3857 5
a3861 5
/*************************************************/
/* hotlist_close()                               */
/*                                               */
/* Closes the hotlist window.                    */
/*************************************************/
d3869 5
a3873 5
/*************************************************/
/* hotlist_close_handler()                       */
/*                                               */
/* Closes the hotlist window.             .      */
/*************************************************/
d3882 7
a3888 9
/*************************************************/
/* hotlist_select_all_handler()                  */
/*                                               */
/* This function handles the 'select all' menu   */
/* item.                                         */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d3914 5
a3918 6
/*************************************************/
/* hotlist_clear_selection_handler()             */
/*                                               */
/* This function handles the clear selection     */
/* menu item                                     */
/*************************************************/
d3941 7
a3947 8
/*************************************************/
/* hotlist_menu_openall_handler()                */
/*                                               */
/* Deal with the Open All menu item.             */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d3968 7
a3974 8
/*************************************************/
/* hotlist_menu_closeall_handler()               */
/*                                               */
/* Deal with the Close All menu item.            */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4010 7
a4016 8
/*************************************************/
/* hotlist_menu_delete_handler()                 */
/*                                               */
/* Deal with the Delete menu item.               */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4095 8
a4102 9
/*************************************************/
/* hotlist_save_to_server_handler()              */
/*                                               */
/* Deal with the 'Save to server' menu item      */
/* (also known as 'Save as default').            */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4119 8
a4126 9
/*************************************************/
/* hotlist_show_newurl_handler()                 */
/*                                               */
/* This function fills in the edit / create URL  */
/* dialogue to be a New URL object.              */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4154 8
a4161 9
/*************************************************/
/* hotlist_show_editurl_handler()                */
/*                                               */
/* This function fills in the edit / create URL  */
/* dialogue to be an Edit URL object.            */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4199 8
a4206 10
/*************************************************/
/* hotlist_show_newdirectory_handler()           */
/*                                               */
/* This function fills in the edit / create      */
/* directory dialogue to be a New Directory      */
/* object.                                       */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4232 8
a4239 10
/*************************************************/
/* hotlist_show_rendirectory_handler()           */
/*                                               */
/* This function fills in the edit / create      */
/* directory dialogue to be a Rename Directory   */
/* object.                                       */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4275 9
a4283 11
/*************************************************/
/* hotlist_newedit_url_handler()                 */
/*                                               */
/* This function either alters the name and URL  */
/* fields of a selected URL, or creates a new    */
/* URL item in the directory that the pointer    */
/* was over when the main menu was opened.       */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4478 7
a4484 9
/*************************************************/
/* hotlist_newren_directory_handler()            */
/*                                               */
/* As hotlist_newedit_url_handler, but for       */
/* directory items.                              */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4624 9
a4632 11
/*************************************************/
/* hotlist_reset_url_handler()                   */
/*                                               */
/* This function is called when Cancel is        */
/* clicked on in the New (aka Edit) URLdialogue */
/* box. It resets the contents to their previous */
/* state.                                        */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4663 8
a4670 10
/*************************************************/
/* hotlist_reset_directory_handler()             */
/*                                               */
/* Similar to hotlist_reset_url_handler, but for */
/* resetting the New (aka Rename) Directory      */
/* dialogue.                                     */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d4700 15
a4714 17
/*************************************************/
/* hotlist_drag_renderer()                       */
/*                                               */
/* Renders a single hotlist item at 0,0 for use  */
/* with DragAnObject.                            */
/*                                               */
/* Parameters: Pointer to the item to render;    */
/*                                               */
/*             Height of a hotlist item in OS    */
/*             units;                            */
/*                                               */
/*             Width of a hotlist directory      */
/*             sprite in OS units;               */
/*                                               */
/*             Width of a hotlist URL sprite in  */
/*             OS units.                         */
/*************************************************/
d4809 5
a4813 6
/*************************************************/
/* hotlist_start_drag()                          */
/*                                               */
/* Start a new drag operation inside the hotlist */
/* window.                                       */
/*************************************************/
d4834 8
a4841 9
/*************************************************/
/* hotlist_start_drag_backend()                  */
/*                                               */
/* This function is called by hotlist_start_drag */
/* to do most of the work for starting a drag    */
/* operation from within the hotlist window. A   */
/* drag box is created, bounding all selected    */
/* items.                                        */
/*************************************************/
d5009 8
a5016 9
/*************************************************/
/* hotlist_drag_stop_handler()                   */
/*                                               */
/* Terminates any hotlist drag in progress.      */
/*                                               */
/* None of the parameters are actually used, so  */
/* calling directly (rather than by eventlib) is */
/* easy.                                         */
/*************************************************/
d5128 10
a5137 11
/*************************************************/
/* hotlist_drag_completed_handler()              */
/*                                               */
/* This function is called when a user_drag      */
/* completes. If the drag is one started by the  */
/* hotlist section it is processed. Dropping the */
/* drag in the hotlist window will move or copy  */
/* the items being dragged; dropping in any      */
/* other window will try to save the relevant    */
/* datatype (URI or HTML) to that window.        */
/*************************************************/
d5488 8
a5495 8
/*************************************************/
/* hotlist_autoscroll()                          */
/*                                               */
/* Auto-scrolls a window.                        */
/*                                               */
/* Parameters: Object ID of the window to scroll */
/*             or 0 to reset autoscrolling.      */
/*************************************************/
d5769 7
a5775 9
/*************************************************/
/* hotlist_null_handler()                        */
/*                                               */
/* Called every null event while a drag is in    */
/* operation.                                    */
/*                                               */
/* Parameters are as standard for a Wimp event   */
/* handler.                                      */
/*************************************************/
d5951 6
a5956 6
/*************************************************/
/* hotlist_start_drag()                          */
/*                                               */
/* This function is called to start a selection  */
/* box operation in the hotlist window.          */
/*************************************************/
d6006 10
a6015 12
/*************************************************/
/* hotlist_null_drag_select_handler()            */
/*                                               */
/* This function is called as a null handler;    */
/* it is responsible for selecting and           */
/* deselecting items within and outside the      */
/* rubber drag box started by                    */
/* hotlist_selection_box_start.                  */
/*                                               */
/* Parameters are as standard for a Wimp event   */
/* handler.                                      */
/*************************************************/
d6065 17
a6081 18
/*************************************************/
/* hotlist_select_box()                          */
/*                                               */
/* Sets the HOTLIST_G_DRAG_SELECTED flag for all */
/* visible items in the range first_item to      */
/* last_item where their horizontal visible area */
/* intersects with the a line draw from minx to  */
/* maxx. Clears the HOTLIST_G_DRAG_SELECTED      */
/* flag for all other items.                     */
/*                                               */
/* Parameters: Number of the first visible item; */
/*                                               */
/*             Number of the last visible item;  */
/*                                               */
/*             minx (window coords);             */
/*                                               */
/*             maxx (window coords).             */
/*************************************************/
d6095 18
a6112 20
/*************************************************/
/* hotlist_select_box_r()                        */
/*                                               */
/* Recursive backend to hotlist_select_box.      */
/*                                               */
/* Parameters: Number of the first visible item; */
/*                                               */
/*             Number of the last visible item;  */
/*                                               */
/*             First item in the directory to    */
/*             scan;                             */
/*                                               */
/*             Pointer to an int, in which the   */
/*             current item number is kept (for  */
/*             internal use only);               */
/*                                               */
/*             minx (window coords);             */
/*                                               */
/*             maxx (window coords).             */
/*************************************************/
d6223 10
a6232 12
/*************************************************/
/* hotlist_contents_selected()                   */
/*                                               */
/* Checks if all items and subdirectories are    */
/* selected.                                     */
/*                                               */
/* Parameters: Pointer to the first hotlist_item */
/*             to check.                         */
/*                                               */
/* Returns:    1 if all items are selected, else */
/*             0 (there are unselected items).   */
/*************************************************/
d6253 10
a6262 12
/*************************************************/
/* hotlist_no_contents_selected()                */
/*                                               */
/* Checks if all items and subdirectories are    */
/* unselected.                                   */
/*                                               */
/* Parameters: Pointer to the first hotlist_item */
/*             to check.                         */
/*                                               */
/* Returns:    1 if all items are unselected,    */
/*             or 0 (there are selected items).  */
/*************************************************/
d6284 7
a6290 8
/*************************************************/
/* hotlist_show_descriptions_handler()           */
/*                                               */
/* Selects Show Descriptions and redraws the     */
/* hotlist window and relevant menus to reflect  */
/* this. Parameters are as standard for a        */
/* Toolbox event handler.                        */
/*************************************************/
d6315 7
a6321 8
/*************************************************/
/* hotlist_show_urls_handler()                   */
/*                                               */
/* Selects Show URLs and redraws the hotlist     */
/* window and relevant menus to reflect this.    */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d6345 12
a6356 16
/*************************************************/
/* hotlist_convert_drag_selection()              */
/*                                               */
/* Recurses through the hotlist_item structure   */
/* altering all 'HOTLIST_G_DRAG_SELECTED' items  */
/* to have 'HOTLIST_G_IS_SELECTED' set or unset  */
/* as is appropriate.                            */
/*                                               */
/* dragselected and selected = unselected        */
/* dragselected              = selected          */
/* selected                  = selected          */
/* neither                   = unselected        */
/*                                               */
/* Parameters: Pointer to a hotlist_item to      */
/*             start on.                         */
/*************************************************/
d6381 9
a6389 10
/*************************************************/
/* hotlist_modified()                            */
/*                                               */
/* Called whenever the hotlist is modified.      */
/*                                               */
/* Parameters: The operaton that modified the    */
/*             hotlist, as a number; see the     */
/*             HL_MODIFIED_... definitions in    */
/*             Hotlist.h.                        */
/*************************************************/
d6421 8
a6428 9
/*************************************************/
/* hotlist_initiate_uri_save()                   */
/*                                               */
/* Starts file transfer of a URI file to another */
/* application.                                  */
/*                                               */
/* Parameters: Pointer to the hotlist item to    */
/*             save as a URI file.               */
/*************************************************/
d6470 9
a6478 9
/*************************************************/
/* hotlist_initiate_html_save()                  */
/*                                               */
/* Starts file transfer of a selection in the    */
/* hotlist as an HTML file.                      */
/*                                               */
/* Parameters: Pointer to a null-terminated      */
/*             leafname to save as.              */
/*************************************************/
d6502 5
a6506 6
/*************************************************/
/* hotlist_return_window_id()                    */
/*                                               */
/* Returns:    The toolbox object ID of the      */
/*             hotlist window.                   */
/*************************************************/
d6513 14
a6526 15
/*************************************************/
/* hotlist_add_position()                        */
/*                                               */
/* Add a new URL to the hotlist at a specified   */
/* position.                                    */
/*                                               */
/* Parameters: Screen relative x position;       */
/*                                               */
/*             Screen relative y position;       */
/*                                               */
/*             Description of the URL (e.g. from */
/*             the page title);                  */
/*                                               */
/*             Pointer to the URL itself.        */
/*************************************************/
d6617 12
a6628 12
/*************************************************/
/* hotlist_add_html_file()                       */
/*                                               */
/* Read in an HTML file, adding items starting   */
/* at the specified position.                    */
/*                                               */
/* Parameters: Screen relative x position;       */
/*                                               */
/*             Screen relative y position;       */
/*                                               */
/*             Pathname of the HTML file.        */
/*************************************************/
d6729 12
a6740 13
/*************************************************/
/* hotlist_load_resources()                      */
/*                                               */
/* Read in a read-only 'Resources' hotlist, at   */
/* the top of the hotlist window. This will not  */
/* be saved when the rest of the hotlist is.     */
/*                                               */
/* Errors are raised if there is not enough      */
/* memory etc., but not if the file doesn't      */
/* exist.                                        */
/*                                               */
/* Parameters: Pathname of the HTML file.        */
/*************************************************/
d6796 12
a6807 13
/*************************************************/
/* hotlist_get_selected_shape()                  */
/*                                               */
/* This routine gets the coordinates required to */
/* bound every selected item in the hotlist      */
/* window (window relative coordinated)          */
/*                                               */
/* Parameters: Pointer to window relative        */
/*             bounding box.                     */
/*                                               */
/* Returns:    1 if there were selected item(s), */
/*             0 if there weren't.               */
/*************************************************/
d6844 16
a6859 19
/*************************************************/
/* hotlist_get_selected_shape_r()                */
/*                                               */
/* Recursive back-end to                         */
/* hotlist_get_selected_shape().                 */
/*                                               */
/* Parameters: Pointer to a hotlist_item;        */
/*                                               */
/*             Pointer to window relative        */
/*             bounding box;                     */
/*                                               */
/*             Pointer to the current item       */
/*             number (for internal use);        */
/*                                               */
/*             Pointer to found flag;            */
/*                                               */
/*             The height of a single entry in   */
/*             OS units.                         */
/*************************************************/
d6921 19
a6939 21
/*************************************************/
/* hotlist_find_match()                          */
/*                                               */
/* Takes a string from the given buffer and sees */
/* if there's something in the Hotlist that      */
/* matches it in some way.                       */
/*                                               */
/* If it finds something it adds any hits to the */
/* given match_list list, and returns 1.         */
/*                                               */
/* The search is case sensitive.                 */
/*                                               */
/* Parameters: flex_ptr to hang the list of      */
/*             matches from;                     */
/*                                               */
/*             Pointer to the buffer holding the */
/*             string to try and match.          */
/*                                               */
/* Returns:    1 if match_list is updated with   */
/*             one or more matches, else 0.      */
/*************************************************/
d6952 19
a6970 22
/*************************************************/
/* hotlist_find_match_r()                        */
/*                                               */
/* Recursive back-end to hotlist_find_match.     */
/*                                               */
/* Parameters: flex_ptr to hang the list of      */
/*             matches from;                     */
/*                                               */
/*             Pointer to the buffer holding the */
/*             string to try and match;          */
/*                                               */
/*             Pointer to the hotlist_item to    */
/*             treat as a root directory for     */
/*             the search;                       */
/*                                               */
/*             Pointer to an int, which at exit  */
/*             is updated to hold 1 if any hits  */
/*             were made in the search, else it  */
/*             is left alone.                    */
/*                                               */
/* Assumes: All pointers are non-NULL and valid. */
/*************************************************/
d7012 7
a7018 7
/*************************************************/
/* hotlist_empty()                               */
/*                                               */
/* See if the hotlist is empty or not.           */
/*                                               */
/* Returns:    1 if the hotlist is empty else 0. */
/*************************************************/
@


1.37
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@a26 1

d46 1
d213 1
a213 1
static void              hotlist_find_match_r            (char * buffer, int buffer_size, hotlist_item * item, hotlist_item ** lowest_item, int * lowest_offset, int * lowest_diff);
d4133 18
d5131 4
d7074 2
a7075 2
/* If it finds something, it writes it back to   */
/* the buffer and returns 1.                     */
d7077 4
a7080 2
/* Parameters: Pointer to the buffer holding the */
/*             string to try and match;          */
d7082 2
a7083 1
/*             Size of the buffer in bytes.      */
d7085 2
a7086 3
/* Returns:    1 if the buffer is updated with a */
/*             match string, else 0 (buffer      */
/*             contents will be unaltered).      */
d7089 1
a7089 1
int hotlist_find_match(char * buffer, int buffer_size)
d7091 1
a7091 3
  hotlist_item * lowest_item   = NULL;
  int            lowest_offset = -1;
  int            lowest_diff   = 0;
d7093 1
a7093 1
  if (!buffer || !*buffer) return 0;
d7095 1
a7095 6
  hotlist_find_match_r(buffer,
                       buffer_size,
                       hotlist_root,
                       &lowest_item,
                       &lowest_offset,
                       &lowest_diff);
d7097 1
a7097 9
  if (lowest_item && lowest_offset >= 0)
  {
    strncpy(buffer, lowest_item->data.url, buffer_size);
    buffer[buffer_size - 1] = 0;

    return 1;
  }

  return 0;
d7105 4
a7108 1
/* Parameters: Pointer to the buffer holding the */
d7111 3
a7113 4
/*             Size of the buffer in bytes;      */
/*                                               */
/*             Pointer to a hotlist_item at the  */
/*             top of the directory to scan;     */
d7115 4
a7118 7
/*             Pointer to a hotlist_item * in    */
/*             which the best match hotlist_item */
/*             is written, if any;               */
/*                                               */
/*             Pointer to an int, in which the   */
/*             lowest offset into a string so    */
/*             far is written;                   */
d7120 1
a7120 4
/*             Pointer to an int, in which the   */
/*             lowest difference in lengths      */
/*             between the buffer and match      */
/*             string is written.               */
d7123 1
a7123 3
static void hotlist_find_match_r(char * buffer, int buffer_size, hotlist_item * item,
                                 hotlist_item ** lowest_item, int * lowest_offset,
                                 int * lowest_diff)
d7129 2
a7130 2
      hotlist_find_match_r(buffer,
                           buffer_size,
d7132 1
a7132 3
                           lowest_item,
                           lowest_offset,
                           lowest_diff);
d7136 1
a7136 3
      int          this_offset = 0;
      int          got_one     = 0;
      const char * found;
d7140 1
a7140 7
        found = strstr(item->data.url, buffer);

        if (found)
        {
          this_offset = found - item->data.url;
          got_one     = 1;
        }
d7143 1
a7143 1
      if (!got_one && item->name)
d7145 1
a7145 7
        found = strstr(item->name, buffer);

        if (found)
        {
          this_offset = found - item->name;
          got_one     = 1;
        }
d7148 1
a7148 1
      if (got_one)
d7150 1
a7150 5
        if (*lowest_offset < 0 || this_offset <= *lowest_offset)
        {
          int this_diff = strlen(item->data.url) - strlen(buffer);

          *lowest_offset = this_offset;
d7152 2
a7153 8
          if (this_offset < *lowest_offset) *lowest_diff = 0;

          if (!*lowest_diff || (this_diff && this_diff < *lowest_diff))
          {
            *lowest_diff = this_diff;
            *lowest_item = item;
          }
        }
@


1.36
log
@Programming warehouse link removed from all hotlists - the page has gone.

Some compile-time hacks in place to use MemLib, a dynamic area based
malloc replacement which shrinks its heap when possible. All builds
have these switched off at the moment. Seemed to work with just Browse,
though there would be problems with message blocks stored in dynamic
areas because of the Wimp's '&3800000' check - however, it failed when
HTMLLib was made to use it, too. Don't know why yet.

ItemInfo.[c/h] source added, with Res file additions for testbed Browse
and Phoenix.

Small fetch windows now work properly regardless of toolbar settings
in the Choices.

Reload now reloads all images too, rather than only reloading them for
as long as the main page was being fetched.

Added a simple 'Find' facility.

Realised that event handlers in eventlib are called in reverse order
of registration, so the miscellaneous event handler is now registered
first rather than last.

Multiuser code added (most only active if SINGLE_USER is undefined). As
part of this, hotlist code now knows about read-only items (done for the
Customer-style 'Resources' file, but works generally anyway).
handle_add_hotlist doesn't try to save the hotlist itself anymore (the
hotlist_add function does all that through hotlist_modified anyway).

Customer build Choices and Controls updated slightly (e.g. ClaimHelp
off, hotlist to save on quit only).

Customer build now uses Phoenix-style buttons. Sprites files which
worked at the time (but will probably be out of date now) and included
most of the original Customer-style sprites are in
'Utils.Icons.Customer'.

Choices, Messages and Res files for all builds now stripped down to only
single user items or single plus multiuser for Customer build and testbed
build. Before, all contained a few multiuser bits in at least the Choices
file if not more.

Grammatical error ("Fetching frames contents" (sic.)) corrected in
default message, Toolbars.c, and all of the Messages files.

Customer build brought back to a servicable level (including
implementation of the Find dialogue box with animation and fixing
up authorisation and 'Stop' state in the tristate). Quite a few
missing #ifndef REMOTE_HOTLIST bits from hotlist code added...

Customer build will not use <Choices$Write> or Boot:Choices for any
file finding now. UseProxy defaults to 'yes', MaxImages to 2. Res
file includes Proxy Address setting (save_save_choices() now writes
the ProxyAddress line).
@
text
@d2895 2
a2896 2
  if (hotlist_contents_selected(hotlist_root)) RetError(menu_set_fade(0, menuid, HOTLIST_SELECTALL_MENUITEM, 1))
  else                                         RetError(menu_set_fade(0, menuid, HOTLIST_SELECTALL_MENUITEM, 0))
d3210 2
d3221 1
a3221 1
  RetLastE;
d3371 3
a3373 2
      erb = *_kernel_last_oserror();
      e   = &erb;
d3389 3
a3391 2
      erb = *_kernel_last_oserror();
      e   = &erb;
d3401 3
a3403 2
      erb = *_kernel_last_oserror();
      e   = &erb;
@


1.35
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d52 1
d75 3
a77 3
static int            autoopen_oldtime;                   /* Base time for autoopen directory */
static hotlist_item * hotlist_root = NULL;                /* Pointer to the hotlist root directory item */
static int            hotlist_windowid;                   /* Object ID of the hotlist window */
d79 1
a79 1
static hotlist_item * hotlist_newitem;                    /* When ever a new item is created this points to it */
d81 1
a81 1
static int            menu_itemno = 0;                    /* Item over which menu was pressed */
d83 2
a84 2
static int            menu_select        = 0;             /* 1 if an item had to be selected when the menu was opened */
static unsigned int   last_selected_item = 0xffffffff;    /* The last item which was selected */
d86 3
a88 3
static unsigned int   highlighted_itemno;                 /* During dragging, the number of a directory item using the '...+' sprite */
static hotlist_item * hotlist_current_highlighted = NULL; /* To save scanning lists, pointer to the highlighted item */
static int            hl_show_urls;                       /* 0 when url descriptions to be shown, 1 to show urls */
d90 3
a92 3
static unsigned int   hotlist_bbar_size = 0;              /* Height in OS units of the button bar */
static unsigned int   alter_new;                          /* Remembers if the edit dialogue is Alter or New; see   */
                                                          /* HOTLIST_MENUSECTION_NEW and HOTLIST_MENUSECTION_ALTER */
d97 3
a99 2
  char         drag_type;       /* One of HOTIST_NOT_DRAGGING, HOTLIST_BOX_DRAG, HOTLIST_SOLID_DRAG_OBJECT, HOTLIST_SOLID_DRAG_SPRITE, or HOTLIST_BOX_DRAG_SELECTION - See Hotlist.h */
  unsigned int using_adjust:1;
d126 1
d138 1
d154 1
a154 1
static _kernel_oserror * hotlist_new_url                 (hotlist_item * parent, unsigned int position, char * url_description, char * url);
d197 1
a197 1
static _kernel_oserror * hotlist_save_entries            (FILE * fileptr, hotlist_item * list, int type);
d213 1
a213 1
static void hotlist_find_match_r(char * buffer, int buffer_size, hotlist_item * item, hotlist_item ** lowest_item, int * lowest_offset, int * lowest_diff);
d582 1
d584 1
a584 3
  lookup_token("HotlistUntitled:(Untitled)",0,0);

  if (!directory_name) directory_name = tokens;
d589 1
a589 1
    if (!*directory_name) directory_name = tokens;
d596 1
a596 1
      if (!len) directory_name = tokens;
d601 2
d688 1
a688 1
static _kernel_oserror * hotlist_new_url(hotlist_item * parent, unsigned int position, char * url_description, char * url)
d705 1
a705 1
  if (!url_description) url_description = url;
d708 1
a708 1
    while (*url_description && *url_description <= ' ') url_description ++;
d710 1
a710 1
    if (!*url_description) url_description = url;
d713 1
a713 1
      int len = strlen(url_description) - 1;
d715 1
a715 1
      while (len && url_description[len] <= ' ') len--;
d717 2
a718 2
      if (!len) url_description = url;
      else url_description[len + 1] = '\0';
d735 1
a735 1
  perm_url_desc = malloc(strlen(url_description) + 1);
d751 1
a751 1
  strcpy(perm_url_desc, url_description);
d891 9
d1638 1
a1638 1
          icon.data.is.sprite             = URL_SPRITE;
d1665 1
a1665 2
              icon.data.is.sprite             = OPEN_DIRECTORY_SPRITE;
              icon.data.is.sprite_name_length = strlen(OPEN_DIRECTORY_SPRITE);
d1669 1
a1669 2
              icon.data.is.sprite             = CLOSED_DIRECTORY_SPRITE;
              icon.data.is.sprite_name_length = strlen(CLOSED_DIRECTORY_SPRITE);
d1671 2
d1979 24
a2002 2
    target = hotlist_root;
    type = 1;
d2014 1
d2057 1
d2827 5
d2843 3
d3001 1
a3001 1
/*             itself be a directory).           */
d3003 8
a3010 2
/*             0 - save all of hotlist           */
/*             1 - only save selection portions  */
d3017 1
a3017 1
static _kernel_oserror * hotlist_save_entries(FILE * fileptr, hotlist_item * list, int type)
d3025 3
a3027 1
    switch (list->type)
d3029 3
a3031 1
      /* Write a link for URLs */
d3033 1
a3033 3
      case hl_url:
      {
        if (type == 0 || (type == 1 && list->flags & HOTLIST_G_IS_SELECTED))
d3035 4
a3038 1
          HotlistWrite(fprintf(fileptr, "<li><a href=\"%s\">%s</a>\n", list->data.url, list->name));
d3040 1
a3040 2
      }
      break;
d3042 1
a3042 1
      /* Write a heading for directories */
d3044 1
a3044 3
      case hl_directory:
      {
        if (type == 0 || !hotlist_no_contents_selected(list->data.directory_content))
d3046 1
a3046 1
          if (type == 0 || (type == 1 && list->flags & HOTLIST_G_IS_SELECTED))
d3048 3
a3050 1
            HotlistWrite(fprintf(fileptr, "<h4>%s</h4>\n", list->name));
d3052 8
a3059 3
            if (list->flags & HOTLIST_D_IS_OPEN)
            {
              HotlistWrite(fprintf(fileptr, "<ul><!--open-->\n"));
d3061 7
a3067 1
            else
d3069 1
a3069 1
              HotlistWrite(fprintf(fileptr, "<ul>\n"));
a3071 10
          /* Recursive call for the directory contents First, */
          /* write the entry header.                          */

          /* Do the contents */

          RetError(hotlist_save_entries(fileptr, list->data.directory_content, type));
          if (type == 0 || (type == 1 && list->flags & HOTLIST_G_IS_SELECTED))
          {
            HotlistWrite(fprintf(fileptr, "</ul>\n"));
          }
d3073 1
a3074 1
      break;
d3098 6
a3103 1
/*             to (null terminated).             */
d3109 1
a3109 1
_kernel_oserror * hotlist_save_hotlist(char * filename, int type)
d3148 4
d3168 4
a3171 1
  e = hotlist_save_entries(fileptr, hotlist_root->data.directory_content, type);
d3234 1
a3234 1
  return hotlist_save_hotlist(filename, 0); /* Save entire hotlist */
d3585 17
d3626 1
a3626 4
  while (hotlist_root->data.directory_content)
  {
    hotlist_delete_item(hotlist_root->data.directory_content);
  }
d3784 5
d3814 5
d3953 15
a3967 1
  return toolbox_hide_object(0, hotlist_windowid);
d4117 1
d4132 14
a4145 1
    hotlist_delete_item(item);
d4152 2
a4153 1
  /* Update the window extent */
d4155 3
a4157 1
  hotlist_preopen();
d4159 1
a4159 1
  /* The hotlist has been modified... */
d4161 4
a4164 1
  hotlist_modified(HL_MODIFIED_DELETE);
d4172 25
d4270 5
d4350 5
d4462 1
a4462 1
      /* Otherwise add it after the item */
d4466 17
a4482 4
        e = hotlist_new_url(tempitem,
                            HOTLIST_POSITION_AFTER,
                            tempdesc,
                            tempurl);
d4514 2
a4515 2
      /* Alter an existing item. First, free its URL and */
      /* description text.                               */
d4517 7
a4523 2
      free(item->name);
      free(item->data.url);
d4525 9
a4533 1
      /* Point to the new URL and description */
d4535 1
a4535 2
      item->name     = tempdesc;
      item->data.url = tempurl;
d4537 2
a4538 1
      /* Deal with redraw issues */
d4540 3
a4542 1
      item->flags |= HOTLIST_G_REDRAW_NOW;
d4544 1
a4544 1
      hotlist_preopen();
d4546 1
a4546 1
      e = hotlist_redraw_now();
d4548 1
a4548 1
      /* Call the 'hotlist has changed' function */
d4550 2
a4551 1
      hotlist_modified(HL_MODIFIED_ALTER);
d4627 19
a4645 4
        e = hotlist_new_directory(tempitem,
                                  tempname,
                                  HOTLIST_POSITION_AFTER,
                                  &tempitem);
d4669 1
a4669 3
      /* Free the item's existing name, link to the new */
      /* name, and do the relevant redraws / hotlist    */
      /* modified calls.                                */
d4671 3
a4673 1
      free(item->name);
d4675 18
a4692 2
      item->name = tempname;
      item->flags |= HOTLIST_G_REDRAW_NOW;
d4694 1
a4694 1
      hotlist_preopen();
d4696 1
a4696 1
      e = hotlist_redraw_now();
d4698 2
a4699 1
      hotlist_modified(HL_MODIFIED_ALTER);
d4830 2
a4831 2
      hotlist_iconblock.data.is.sprite             = URL_SPRITE;
      hotlist_iconblock.data.is.sprite_name_length = strlen(URL_SPRITE);
d4839 2
a4840 2
      hotlist_iconblock.data.is.sprite             = CLOSED_DIRECTORY_SPRITE;
      hotlist_iconblock.data.is.sprite_name_length = strlen(CLOSED_DIRECTORY_SPRITE);
d5390 1
a5390 1
      /* If we've dropped on a selected item, do nothing */
d5392 1
a5392 1
      if (targetitem->flags & HOTLIST_G_IS_SELECTED) return 0;
d5936 2
a5937 1
        /* ...and the currently highlighted item isn't the one we're over... */
d5939 4
a5942 1
        if (hotlist_current_highlighted != item)
d5969 1
a5969 1
        else
d6510 17
a6526 1
    return hotlist_save(lookup_choice("HotlistSave:Browse:User.Hotlist",0,0));
d6844 68
d7179 19
@


1.34
log
@Note that the 'Docs' documentation (possibly contrary to previous
log messages) still hasn't been updated with the new SaveFile
stuff, and function header comments have yet to be written for
SaveFile.c.

Fixed urlutils_pathname_to_url - OS_GSTrans doesn't like the same
input buffer as output buffer (fairly obvious, but I was living in
the hope of not having to duplicate the input path string).

Image history will not cache scrap file images anymore. Browser's
image handling library won't cross reference them either.

When dragging a single item from the hotlist to a Filer window, the
code now checks Ctrl - if held down, a URL file is written, else a
URI file. The state of any option buttons or radios in the last
Save File dialogue that was opened is no longer relevant...!

history_save_as_html could write out broken files when titles
for items in the History were not present. Fixed.

Hourglass switched on for hotlist and history saving as HTML;
hotlist_save_entries no longer closes the output file on error
(it should be done by the caller, since the caller is responsible
for opening the file and passing the FILE * pointer to
hotlist_save_entries).
@
text
@d3056 7
a3062 2
  local_path = malloc(strlen(filename) + 1);
  if (!local_path) return NULL;
d3064 5
a3068 1
  strcpy(local_path, filename);
d6283 1
a6283 1
    return hotlist_save(lookup_choice("HotlistPath:Browse:User.Hotlist",0,0));
d6333 1
a6333 1
                                        save_uri_size(item->data.url, 0),
@


1.33
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@a3030 2
  if (fileptr) fclose(fileptr);

d3061 4
d3097 2
d3113 2
d3132 6
a3137 1
  if (fileptr) fclose(fileptr);
d6294 13
d6318 2
a6319 1
  /* Send Message_DataSave to start file transfer */
d6325 1
a6325 1
                                        FileType_URI,
@


1.32
log
@Following the last check-in - all build resources brought up to date.

Adjust-click on forwards/backwards buttons did not work in the intermediate
build, and now does.

Adjust-click on form submission buttons where the submit method is POST
will now work correctly, as the new view inherits the extradata block
of the old. Failure of this is signalled through
make_no_fetch_memory_error, code 16 (see updated Errors file in Docs).
Note the name change of extradata in this context; more details below.

The passing of forms POST data and extra headers for sending in an
HTTP request via. the URL module was all done through pointers into
flex blocks, and was therefore very unsafe. All relevant functions now
use pointers to pointers to the data.

To remove confusion on the umpteen uses of the word 'extradata', the field
in browser_data has been renamed to 'post_data'. The 'extradata' parameters
used within FetchPage.c were all disconnected from the extra header info /
form POST data stuff that extradata is usually associated with, and have
thus also been renamed, in this case to 'appnddata' (Append Data).

As well as X-NoProxy, the browser sends the 'proper' HTTP headers
Pragma:no-cache and Cache-Control:no-cache.

A redirection from a POST request was not handled correctly; despite
what HTTP specs say, you're supposed to use GET for the new URL. The
browser was, but when it chopped off the redundant header data in the
request didn't terminate it and left Content-Type in anyway...! Fixed.

Ctrl+Tab implemented - URL completion. Comes from the hotlist URLs,
hotlist titles, history hosts, paths, full URLs and lastly titles.
See code comments for more (history_find_match, hotlist_find_match).

TableSupport option added to Choices; it is read, can be set by the
front-end, but doesn't actually do anything else yet.

Reversed Choices' semantics on 'don't expire by...' for History. Added
'needs_redraw' flag to choices_get_contents so that, for example, if the
table border types change, browsers get redrawn.
@
text
@d884 1
a884 2
  _kernel_oserror * e;
  hotlist_item    * newdir, * tempptr;
d962 1
a962 2
  _kernel_oserror * e;
  hotlist_item    * newdir;
d1036 1
a1036 2
  _kernel_oserror * e;
  int               width, height;
d1536 2
a1537 3
  _kernel_oserror * e;
  int               curr_item = 0;
  unsigned int      item_height, item_dir_width, item_url_width;
d1590 3
a1592 4
  _kernel_oserror * e;
  WimpIconBlock     icon;
  unsigned int      temp_width;
  int               text_width;
a1910 2
  _kernel_oserror * e;

d2053 5
a2057 6
  _kernel_oserror * e;
  hotlist_item    * tempitem;
  unsigned int      item_height, item_dir_width, item_url_width;
  int               icon_width;
  int               text_width;
  int               count = 0;
d2126 3
a2128 4
  _kernel_oserror * e;
  unsigned int      item_height, item_dir_width, item_url_width;
  int               top, window_handle;
  BBox              bbox;
d2187 3
a2189 4
  _kernel_oserror * e;
  unsigned int      item_height, item_dir_width, item_url_width;
  BBox              bbox;
  int               window_handle;
d2750 3
a2752 4
  _kernel_oserror * e;
  hotlist_item    * item;
  char              entrytext[Limits_Hotlist_ItemName];
  ObjectId          submenu_id;
d2967 1
a2967 2
  _kernel_oserror * e;
  int               written;
d3580 5
a3584 6
  _kernel_oserror * e;
  ObjectId          toolbar;
  ObjectId          menu_id;
  BBox              bbox;
  unsigned int      item_height, item_dir_width, item_url_width;
  char              root[] = "Root";
a4667 2
  _kernel_oserror * e;

a4699 1
  _kernel_oserror         * e;
d5349 8
a5356 9
  _kernel_oserror         * e;
  WimpGetWindowStateBlock   state;
  ObjectId                  over_window;
  ObjectId                  parent;
  ComponentId               component;
  BBox                      extent;
  int                       scroll_changed;
  int                       x, y, position;
  int                       autoscroll_newtime;
d5358 2
a5359 2
  static unsigned int       scrolling, autoscroll_oldtime;
  static unsigned int       mouse_shape = Mouse_Shape_Normal;
d5808 3
a5810 4
  _kernel_oserror         * e;
  WimpGetPointerInfoBlock   pointerblock;
  WimpGetWindowStateBlock   state;
  WimpDragBox               box;
d6281 2
a6282 3
  _kernel_oserror         * e;
  WimpGetPointerInfoBlock   block;
  WimpMessage               message;
d6317 2
a6318 3
  _kernel_oserror         * e;
  WimpGetPointerInfoBlock   block;
  WimpMessage               message;
d6367 1
a6367 1
  _kernel_oserror         * e;
a6368 1
  WimpGetWindowStateBlock   state;
d6637 1
a6637 2
  _kernel_oserror * e;
  int               newxmin, newxmax;
@


1.31
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@a88 1

a91 1

d209 2
d6715 141
@


1.30
log
@Altered new directory handler to create new directories at the end of the list
if the pointer was past the end of the list of items.
@
text
@d70 1
a70 1
#define HotlistWrite(fn) {written = (fn); if (written < 0) RetLastE}
d2255 1
a2255 1
  return windows_create_browser(item->data.url, NULL, NULL, NULL, 0);
d3038 8
d3055 1
a3055 1
/*             to (null terminated);             */
d3063 1
d3065 1
a3065 1
  _kernel_oserror * e;
d3068 7
d3077 1
a3077 1
  fileptr = fopen(filename, "wb");
d3081 5
a3085 1
  if (fileptr == NULL) RetLastE;
d3092 5
a3096 1
                                "<title>Hotlist</title>\n"
d3108 1
d3123 6
a3128 2
  return _swix(OS_File,
               _INR(0,2),
d3130 13
a3142 3
               18,
               filename,
               FileType_HTML);
d3152 1
a3152 1
/*             under (null terminated).          */
d3391 1
a3391 1
      /* '://' in - i.e. looks fully specified                        */
d3393 1
a3393 1
      if (strstr(url, "://"))
d3520 1
d3523 7
d3539 1
a3539 1
  fileptr = fopen(filename, "r");
d3543 2
d3575 3
a3577 1
  if (!e) return hotlist_modified(HL_MODIFIED_LOAD);
d6279 4
a6282 1
  if (choices.save_hotlist == Choices_SaveHotlist_Always) return hotlist_save(lookup_choice("HotlistPath:Browse:User.Hotlist",0,0));
@


1.29
log
@Now handles PARAM tags. Sorted out Plug-In bug that was related to Java
setting a 0 by 0 graphics window before calling Wimp_Poll (fixed in Java).
Implemented queue for Plug-Ins so multiple broadcasts aren't sent for
several Objects in one data chunk.

Added Docs directory with some documentation in it. More things to keep
checking for stylistic consistency, horray ;-)

Corrected !Run[D] for Ursula build to need AcornURI but not TaskModule
(URI handler needed for !Mail to pick up mailto: links).

Added display_height field to browser_data, analogous to display_width,
to cope with % sized objects by width and height (see how HRs are
handled in Redraw.c for an example of how it was always fairly easy
with width, but not height until this addition). Though you do have
to reload to get a new size; reformat isn't enough. Must see to this
some time...

Fixed bug where basic typefaces were claimed *before* the Choices file
had been read. For unusual Choices settings, this could create some
'interesting' problems now and again. This was part of narrower scope
work in the Choices code to allow font changing without leaking font
handles (now done; fm_shutdown only ditches fonts, it keeps internal
structures - must then call  fm_lose_fonts for all browsers to get the
bitfields up to date, then rewrite the typeface definitions and reclaim
basic fonts). Noticed that fm_claim_basic_typefaces would claim multiple
instances of the same font if there were several cases of the same font
mapped to different typeface styles - fixed.

Implemented PlugInControl settings, but not SupportObject (fully).
@
text
@d4373 1
a4373 1
                                  HOTLIST_POSITION_BEGINNING,
@


1.28
log
@Can now create one-character directory names.
Dropping on the lower half of an open, empty directory will now drop
inside it rather than after it.
@
text
@d3546 1
d3555 1
a3555 1
  RetError(hotlist_new_directory(NULL, "Root", 0, &hotlist_root));
@


1.27
log
@Altered hotlist_add to create the new url after the first selected item or
inside the first selected directory when an item is selected.
@
text
@d589 1
a589 1
      int len = strlen(directory_name) - 1;
d591 1
a591 1
      while (len && directory_name[len] <= ' ') len--;
d594 1
a594 1
      else directory_name[len + 1] = '\0';
d1968 1
a1968 1

d2026 1
a2026 1

d5134 3
a5136 3
          /* it is an open directory with something inside. Again, the    */
          /* null handler dealing with highlighting directory sprites     */
          /* reflects this situation correctly.                           */
d5140 1
a5140 2
               targetitem->flags & HOTLIST_D_IS_OPEN &&
               targetitem->data.directory_content
d5644 1
a5644 1
      /* the directory is open and has contents.                                    */
d5654 1
a5654 2
             item->flags & HOTLIST_D_IS_OPEN        &&
             item->data.directory_content
@


1.26
log
@Added support for HTMLLib HttpEndParse call.

Text items with no VALUE specified in the HTML were not cleared on
hitting a Reset button as the text field of the token is NULL; fixed.
SELECT lists with no default selection item were not being changed
on hitting a Reset button; fixed. In radio groups with no default
selection specified, no item will be selected. This goes against
the HTML 2 spec but allows broken Navigator-esque forms behaviour.
In consequence, radios can be deselected by clicking on the same
one twice. I'd fixed the flickering experienced when doing this
recently, but that, now, is irrelevant, since the state of a radio
must always change.

Reformatter's new 'find width of a SELECT field' didn't account for
the width of <none> and <many> items, and now does (particularly
important for broken items with no OPTION contents).

Under certain circumstances, illegally named targets would open in the
ancestor rather than a new window - a deliberate decision in the code,
but now reversed due to a test suite failure; they'll open in a new
window instead.

Altered the left hand indent handling for lists so that headings and
body text follow the Navigator 48 pixel indent and the bullet point
items drop to the left of the left hand margin, rather than sitting
on the margin with the text indented to the right.

Tightened up the hotlist_load_directory checking of URLs, so that
only those with '://' in - i.e. look fully specified - are accepted.
HTML files are loaded into a new directory now.

Items without a descriptive title in hotlist_new_url will have the URL
substituted in instead. White space before and after descriptions and
after URLs is stripped. Directories with zero length names or null
strings (after white space is stripped) will still be created, with a
generic name (see Messages, token 'HotlistUntitled').
@
text
@d1964 2
d1967 20
a1986 1
  position = at_bottom ? HOTLIST_POSITION_END : HOTLIST_POSITION_BEGINNING;
d1990 1
a1990 1
  e = hotlist_new_url(hotlist_root,
d2011 19
a2029 1
      hotlist_redraw_items(0,
a2031 1
    break;
@


1.25
log
@Tidied up Hotlist source a bit more, mostly so PSI can use the automatic
StrongHelp generator on it. Revealed a spurious toolbox_hide_object call
that would always fault and never do anything, and a few heinous uses
of show_error which have all been removed.

When dragging hotlist items, directories will now be highlighted whenever
the item would be added to them, rather than just over the sprite. In
practice this only changes if the item is open and has contents...

Drag box selections had broken in the hotlist; fixed (uninitialised
variable in hotlist_select_box). Adjust-drags now close the window on
completion. Minor problem with Shift+Drag (copy) reversing order of items
sorted out. Added hotlist_add_html_file and implemented loading of HTML.
DO NOT add broken HTML files, this has not been coded for and URLs of the
form http:///this/that (no host name) will hang the machine (bug in the
cookie code of the HTTP module up to at least version 0.39).

Made SELECT list items only as wide as the widest entry actually appears
(using fm_get_string_width), rather than as wide as the widest character
BBox in the font multiplied by the string length of the longest entry.

Updated !Run[D] files to require HTTP 0.39, FTP 0.12 and File 0.23.
@
text
@d579 18
a596 1
  if (!directory_name) return NULL;
d690 27
a1966 2
  if (!description || !*description) description = lookup_token("HotlistUntitled:(Untitled)",0,0);

d3313 2
a3314 1
      /* Add this item */
d3316 1
a3316 1
      if (target_type == 0)
d3318 12
a3329 6
        e = hotlist_new_url(target, HOTLIST_POSITION_END, str_ptr, url);
        target_type = 1;
      }
      else
      {
        e = hotlist_new_url(target, HOTLIST_POSITION_AFTER, str_ptr, url);
a3330 2
      if (e) goto hotlist_load_directory_exit; /* (See near end of function) */
      target = hotlist_newitem;
a6302 2
  if (!description || !*description) description = lookup_token("HotlistUntitled:(Untitled)",0,0);

d6407 1
d6453 6
d6475 1
a6475 1
  /* Load it, adding to the bottom of the root directory */
d6477 1
a6477 1
  e = hotlist_load_directory(fileptr, hotlist_root);
a6480 6
  /* Clear all of the various flags for redraw, */
  /* selection etc. now that we have a new      */
  /* hotlist.                                   */

  hotlist_clear_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);

a6482 23
  /* Move to the intended load position; first, find */
  /* the item we just added, then move it to the     */
  /* relevant position relative to the target item,  */
  /* as worked out above.                            */

  newitem = hotlist_root->data.directory_content;
  while (newitem && newitem->next) newitem = newitem->next;

  if (newitem)
  {
    /* Need to set the selected flags on the directory, or hotlist_move_item */
    /* will think we're moving only part of it, and will end up just copying */
    /* the directory item.                                                   */

    hotlist_set_flags(newitem, hl_ALL, HOTLIST_G_IS_SELECTED);

    RetError(hotlist_move_item(newitem, targetitem, position));

    /* Now deselect it... */

    hotlist_clear_flags(newitem, hl_ALL, HOTLIST_G_IS_SELECTED);
  }

d6487 1
a6487 2
  /* Optimise the redraw to do as little as possible depending */
  /* upon where in the list the item was added.                */
d6489 1
a6489 2
  RetError(hotlist_redraw_items(top,
                                hotlist_count_displayed_items(hotlist_root->data.directory_content)));
@


1.24
log
@Now working on source merged with Kevin Bracey's internationalisation
support. UNIFONT is undefined in the Make File for now. All Res and
Choices files updated appropriately.

Having sorted out the old Choices and Messages to form Choices, Controls
and Messages, this build has had the same cleaning up done internally.
This includes greater consistency in naming schemes and the removal of
the inconsitent choices items - e.g. Choices file entries saying 'delay
images' and 'plain backgrounds' where internally all the flags say 'show
images' and 'show backgrounds'. ChoiceDefs.h and CtrlDefs.h added to
clarify the meaning of some fields, though usage of these is not 100%
in the source (there are cases where parameters are passed through to
functions as ints, and those functions still check these against hard
coded values rather than the #define stuff).

Fetcher status return bits (connected, sent request, etc.) now reflected
in status bar. Progress during fetchs to files are reported by %, where
the size of the object is known. Exceeding 100% drops back to a byte
counter, in case the estimated size was wrong. The progress counter
may be updated after specific delays, rather than 'as often as possible',
to reduce flicker (as requested by D.Brown some time ago).

I've done a small rewrite of the fetch prioritisation scheme in FetchPage.c;
how well this performs in general use across different processor speeds
remains to be tested, but certainly it has some advantages. For each small
fetch window before the rewrite, a 4cs tight loop was entered - this gave a
noticable and substantial drain to the Desktop performance if more than one
was opened. Now, several can be up at once with little hit. The actual file
fetch is on half the priority it was before, with all others taken back
just a bit - e.g. from 20cs per poll to 15cs per poll for flat out
reformatting. You don't seem to lose much time on the format in practice,
and the Desktop feels quite a bit lighter at the same time. There's the
potential for smoother frameset loading in this scheme, too.

When Shift+Clicking on a link meant you still fetched inside the main
browser window, several fetches could occur in a frameset - one per frame.
However, now that you can only do this by clicking on a link that leads to
non-displayable data - or by turning off the small fetch windows by
setting UseSmall to 'no' in Choices - a bug where fetchpage_preprocessed
would stop such fetches as new ones were started was revealed.
The API to frames_abort_fetching has now been extended to include a
'stop file spooling too' flag, allowing a fix to be made by having
fetchpage_preprocess's calls not set this (and it doesn't check the
savelink flag is unset before proceeding, since frames_abort_fetching
does that implicitly now).

Had left the RAM transfer buffer at 16 bytes (from testing) accidentally...
Oops. Upped it to 4K. In addition, when loading data by RAM transfer,
the browser didn't notice if a RAMFetch bounced during the transfer. It
would be treated as a 'first' RAMFetch bounce, basically, and try to go to
file transfer - oops. Fixed.
@
text
@a84 1
static int            hotlist_dragging   = 0;             /* Holds a set of values for different dragging cases (see Hotlist.h) */
d94 11
d194 1
a194 1
static void              hotlist_set_menu_details        (ObjectId menuid);
a196 1
static _kernel_oserror * hotlist_load_directory          (FILE * fileptr, hotlist_item * target);
d202 2
a203 1
_kernel_oserror        * hotlist_autoscroll              (int window);
d206 4
a209 7
static void              hotlist_get_selected_shape_r    (hotlist_item * list,
                                                          BBox         * box,
                                                          unsigned int * itemno,
                                                          int          * found,
                                                          unsigned int   item_height);
void hotlist_select_box(unsigned int first_item, unsigned int last_item, int minx, int maxx);
void hotlist_select_box_r(unsigned int first_item, unsigned int last_item, hotlist_item *item, unsigned int *itemno, int minx, int maxx);
a550 1
/*                                               */
d678 1
a678 1
        if (tl & (1<<25)) Printf("Error: Could not allocate room for new URL item\n");
d835 1
a835 1
/*             hotlist structure (nasty...).     */
d867 1
a867 1
    while(source)
d880 1
d930 1
a930 1
      return hotlist_new_url(target, position, source->name, source->data.url);
d2154 1
a2154 3
  {
    return hotlist_redraw_now();
  }
d2203 2
d2218 1
a2218 1
          case hl_directory: hotlist_directory_open_close(item, itemno);
d2221 1
a2221 1
          case hl_url: hotlist_launch_url(item);
d2225 2
d2230 1
a2230 1
        hotlist_redraw_items(itemno, itemno);
d2246 1
a2246 1
          case hl_directory: hotlist_directory_open_close(item, itemno);
d2251 3
a2253 2
            hotlist_launch_url(item);
            toolbox_hide_object(0, hotlist_windowid);
d2258 2
d2263 1
a2263 1
        hotlist_redraw_items(itemno, itemno);
d2270 4
a2273 1
    case 64: hotlist_start_drag();
d2291 3
a2293 2
      hotlist_start_drag();
      hotlist_redraw_items(itemno, itemno);
d2297 3
a2299 6
    case 1024:                   /* Click select */
    if (item->flags & HOTLIST_G_IS_SELECTED)
    {
      /* Do nothing when selected */
    }
    else
d2301 1
a2301 3
      hotlist_clear_selection();
      item->flags |= HOTLIST_G_IS_SELECTED | HOTLIST_G_REDRAW_NOW;
      if (item->type == hl_directory)
d2303 15
a2317 1
        hotlist_set_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
d2319 2
a2320 1
      hotlist_redraw_now();
a2321 1
    last_selected_item = itemno;
d2324 3
a2326 5
    case 256:                   /* Click adjust */
    item->flags ^= HOTLIST_G_IS_SELECTED;
    item->flags |= HOTLIST_G_REDRAW_NOW;
    last_selected_item = itemno;
    if (item->type == hl_directory)
d2328 10
a2337 1
      if (item->flags & HOTLIST_G_IS_SELECTED)
d2339 8
a2346 5
        hotlist_set_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
      }
      else
      {
        hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
d2348 4
a2352 1
    hotlist_redraw_now();
d2356 3
a2358 1
  return NULL;
d2364 8
a2371 2
/* This function handles mouse clicks on the     */
/* hotlist window                                */
d2373 2
a2374 3
/* Parameters: x position                        */
/*             y position                        */
/*             button state                      */
d2379 7
a2385 5
  unsigned int item_height, item_dir_width, item_url_width;
  hotlist_item *item;
  int xmin, xmax;
  unsigned int itemno;
  _kernel_oserror *e;
d2390 3
a2392 2
  item = hotlist_find_item(hotlist_root->data.directory_content, itemno);
  if (item) hotlist_get_shape(&xmin, &xmax, item);
d2396 2
d2402 2
d2406 1
a2406 2
      case Wimp_MouseButtonSelect:
      break; /* Double click select */
d2408 3
a2410 2
      case Wimp_MouseButtonAdjust:
      break; /* Double click adjust */
d2412 2
a2413 3
      case 64:                     /* Drag select */
      hotlist_clear_selection();
      hotlist_selection_box_start();
d2416 6
a2421 2
      case 16:                     /* Drag adjust */
      hotlist_selection_box_start();
d2424 2
d2427 8
a2434 3
      hotlist_clear_selection();
      last_selected_item = 0xffffffff;
      break;                   /* Click select */
d2437 4
a2440 2
      last_selected_item = 0xffffffff;
      break;                   /* Click adjust */
d2443 2
a2444 1
  return NULL;
d2459 1
a2459 1
/* Returns:    1 if window was already open, 0   */
d2475 4
d2480 1
d2482 1
a2482 5
  if (e)
  {
    show_error_ret(e);
    return 0;
  }
d2485 1
d2487 1
a2487 5
  if (e)
  {
    show_error_ret(e);
    return 0;
  }
d2492 2
d2495 1
d2497 2
a2498 5
  if (e)
  {
    show_error_ret(e);
    return 0;
  }
d2500 1
a2500 6
  e = wimp_get_window_state(&state);
  if (e)
  {
    show_error_ret(e);
    return 0;
  }
d2505 2
d2510 1
a2510 5
    if (e)
    {
      show_error_ret(e);
      return 0;
    }
d2513 3
d2519 4
d2532 2
d2537 2
d2540 3
a2542 5
  if (e)
  {
    show_error_ret(e);
    return 0;
  }
d2547 1
d2552 1
a2552 5
    if (e)
    {
      show_error_ret(e);
      return 0;
    }
d2561 5
a2565 1
/* This function redraws the hotlist window      */
d2568 1
a2568 1
static int hotlist_redraw_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
d2570 7
a2576 4
  unsigned int item_height, item_dir_width, item_url_width;
  unsigned int first_item, last_item;
  int more;
  WimpRedrawWindowBlock block;
d2578 1
a2578 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d2582 2
d2585 2
a2586 1
  while(more)
d2588 3
a2590 1
    first_item = -(block.redraw_area.ymax - (block.visible_area.ymax - block.yscroll)) / item_height;
d2593 9
a2601 4
    hotlist_draw(hotlist_root->data.directory_content,
                 first_item,
                 last_item);
    wimp_get_rectangle(&block, &more);
d2603 2
a2604 1
  return 0;
d2610 7
a2616 2
/* This function handles mouse clicks in the     */
/* hotlist window                                */
d2619 1
a2619 1
static int hotlist_mouse_click_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
d2628 4
a2631 4
  hotlist_process_click(event->mouse_click.mouse_x + (state.xscroll - state.visible_area.xmin),
                        event->mouse_click.mouse_y + (state.yscroll - state.visible_area.ymax),
                        event->mouse_click.buttons);
  return 0;
d2637 4
a2640 1
/* This function handles closed menu events      */
d2643 1
a2643 1
static int hotlist_menuclose_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d2646 3
d2654 10
a2663 4
  show_error(menu_get_sub_menu_show(0, id_block->self_id, HOTLIST_URL_MENUITEM, &submenu_id));
  if (submenu_id) show_error(toolbox_delete_object(0, submenu_id));
  menu_set_sub_menu_show(0, id_block->self_id, HOTLIST_URL_MENUITEM, 0);
  return 0;
d2666 11
d2678 1
a2678 2

void hotlist_set_menu_details(ObjectId menuid)
d2680 4
a2683 3
  hotlist_item * item;
  char entrytext[32];
  ObjectId submenu_id;
d2687 4
d2693 4
a2696 3
      menu_set_entry_text(0, menuid, HOTLIST_URL_MENUITEM, "URL ''");
      menu_set_fade(0, menuid, HOTLIST_URL_MENUITEM, 1);
      menu_set_fade(0, menuid, HOTLIST_CLEARSELECTION_MENUITEM, 1); /* Fade clear selection */
d2700 2
d2704 3
a2706 1
      item = hotlist_find_selected_item();             /* One item selected */
d2710 4
d2715 6
a2720 3
        strcpy(entrytext, "Dir. '");
        toolbox_create_object(0, "HLDirmenu", &submenu_id);
        menu_set_sub_menu_show(0, menuid, HOTLIST_URL_MENUITEM, submenu_id);
d2723 2
d2726 6
a2731 3
        strcpy(entrytext, "URL '");
        toolbox_create_object(0, "HLURLmenu", &submenu_id);
        menu_set_sub_menu_show(0, menuid, HOTLIST_URL_MENUITEM, submenu_id);
d2733 1
d2735 10
d2747 8
a2754 6
      strncat(entrytext, item->name, 10);
      if (strlen(item->name) > 10) strcat(entrytext, "...");
      strcat(entrytext, "'");
      menu_set_entry_text(0, menuid, HOTLIST_URL_MENUITEM, entrytext);
      menu_set_fade(0, menuid, HOTLIST_URL_MENUITEM, 0);                    /* unfade URL '' */
      menu_set_fade(0, menuid, HOTLIST_CLEARSELECTION_MENUITEM, 0);         /* unfade clear selection */
d2758 2
d2762 10
a2771 5
      menu_set_entry_text(0, menuid, HOTLIST_URL_MENUITEM, "Selection");    /* Multiple items selected */
      menu_set_fade(0, menuid, HOTLIST_URL_MENUITEM, 0);                    /* unfade URL '' */
      menu_set_fade(0, menuid, HOTLIST_CLEARSELECTION_MENUITEM, 0);         /* unfade clear selection */
      toolbox_create_object(0, "HLSlctmenu", &submenu_id);
      menu_set_sub_menu_show(0, menuid, HOTLIST_URL_MENUITEM, submenu_id);
d2780 2
a2781 2
  if (hotlist_contents_selected(hotlist_root)) menu_set_fade(0, menuid, HOTLIST_SELECTALL_MENUITEM, 1);
  else                                         menu_set_fade(0, menuid, HOTLIST_SELECTALL_MENUITEM, 0);
d2783 4
a2786 1
  menu_get_sub_menu_show(0, menuid, HOTLIST_DISPLAY_MENUITEM, &submenu_id);
d2790 2
a2791 2
    menu_set_tick(0, submenu_id, HOTLIST_MENU_SHOWDESCRIPTIONS, 0);
    menu_set_tick(0, submenu_id, HOTLIST_MENU_SHOWURLS, 1);
d2795 2
a2796 2
    menu_set_tick(0, submenu_id, HOTLIST_MENU_SHOWDESCRIPTIONS, 1);
    menu_set_tick(0, submenu_id, HOTLIST_MENU_SHOWURLS, 0);
d2798 4
d2807 5
a2811 1
/* This function handles opened menu events      */
d2823 3
a2825 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d2829 4
a2832 1
    window_get_wimp_handle(0, hotlist_windowid, &window_handle);
d2834 3
a2836 1
    wimp_get_window_state(&state);
a2837 1
    wimp_get_pointer_info(&pointerblock);
d2844 4
a2847 1
  menu_get_sub_menu_show(0, id_block->self_id, HOTLIST_DISPLAY_MENUITEM, &sub_menu);
d2853 1
a2853 4
    if (item)
    {
      hotlist_get_shape(&xmin, &xmax, item);
    }
d2859 1
d2861 2
a2862 1
      hotlist_redraw_now();
d2866 3
a2868 1
  hotlist_set_menu_details(id_block->self_id);
d2872 1
d2898 1
a2899 1
  _kernel_oserror * e;
d2927 1
d3121 1
d3462 5
d3778 1
a3778 1
  return 0;
d3784 4
a3787 1
/* This function handles the open all menu item  */
d3790 1
a3790 1
static int hotlist_menu_openall_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d3795 4
a3798 1
    hotlist_set_flags(hotlist_root->data.directory_content, hl_directory, HOTLIST_D_IS_OPEN);
d3800 3
a3802 1
    hotlist_redraw_items(0, hotlist_count_displayed_items(hotlist_root->data.directory_content));
d3805 2
a3806 1
  return 0;
d3812 4
a3815 2
/* This function handles the close all menu      */
/* item                                          */
d3818 1
a3818 1
static int hotlist_menu_closeall_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d3821 2
d3826 3
d3834 12
a3845 5
    hotlist_clear_selection();
    hotlist_redraw_items(0, noitems);
    menu_set_entry_text(0, id_block->self_id, HOTLIST_URL_MENUITEM, "URL ''");
    menu_set_fade(0, id_block->self_id, HOTLIST_URL_MENUITEM, 1); /* Fade URL'' selection */
    menu_set_fade(0, id_block->self_id, HOTLIST_CLEARSELECTION_MENUITEM, 1); /* Fade clear selection */
d3848 2
a3849 1
  return 0;
d3855 4
a3858 1
/* This function handles the delete menu item    */
d3861 1
a3861 1
static int hotlist_menu_delete_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d3863 8
a3870 2
  hotlist_item *item;
  unsigned int noitems;
d3876 3
a3878 1
  while((item = hotlist_find_selected_item())!=NULL)
d3882 3
d3886 3
d3890 2
a3891 1
  toolbox_hide_object(0, id_block->ancestor_id);
d3895 3
a3897 1
  return 0;
d3901 4
a3904 1
/* hotlist_show_editurl_handler()                */
d3906 2
a3907 2
/* This function fills in the description and    */
/* url fields of the edit url dialogue box       */
d3910 1
a3910 1
static int hotlist_show_editurl_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
a3911 1
  hotlist_item *item;
d3915 1
a3915 1
    if (tl & (1u<<25)) Printf("hotlist_show_editurl_handler: Called\n");
d3918 16
a3933 9
  item = hotlist_find_selected_item();
  if (!item) return 0;
  menu_get_sub_menu_show(0, id_block->self_id, id_block->self_component, &dboxid);
  alter_new = HOTLIST_MENUSECTION_ALTER;
  window_set_title(0, dboxid, "Edit URL");
  writablefield_set_value(0, dboxid, 0x01, item->name);
  writablefield_set_value(0, dboxid, 0x05, item->data.url);
  actionbutton_set_text(0, dboxid, 0x02, "Alter");
  return 0;
d3937 4
a3940 1
/* hotlist_show_rendirectory_handler()           */
d3942 2
a3943 2
/* This function fills in the name field of the  */
/* rename directory dialogue box                 */
d3946 1
a3946 1
static int hotlist_show_rendirectory_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d3948 2
a3949 2
  hotlist_item *item;
  ObjectId dboxid;
d3952 1
a3952 1
    if (tl & (1u<<25)) Printf("hotlist_show_rendirectory_handler: Called\n");
d3955 2
d3960 1
a3960 1
  menu_get_sub_menu_show(0, id_block->self_id, id_block->self_component, &dboxid);
d3963 12
a3974 4
  window_set_title(0, dboxid, "Rename Directory");
  writablefield_set_value(0, dboxid, 0x01, item->name);
  actionbutton_set_text(0, dboxid, 0x02, "Rename");
  return 0;
d3978 5
a3982 1
/* hotlist_show_newurl_handler()                 */
d3984 2
a3985 2
/* This function emptys the description and url  */
/* fields of the new url dialogue box            */
d3988 1
a3988 1
static int hotlist_show_newurl_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d3993 1
a3993 1
    if (tl & (1u<<25)) Printf("hotlist_show_newurl_handler: Called\n");
d3996 1
a3996 1
  menu_get_sub_menu_show(0, id_block->self_id, id_block->self_component, &dboxid);
d3999 11
a4009 5
  writablefield_set_value(0, dboxid, 0x01, "");
  writablefield_set_value(0, dboxid, 0x05, "");
  window_set_title(0, dboxid, "Create new URL");
  actionbutton_set_text(0, dboxid, 0x02, "Create");
  return 0;
d4013 5
a4017 1
/* hotlist_show_newdirectory_handler()           */
d4019 2
a4020 2
/* This function emptys the name field of the    */
/* new directory dialogue box                    */
d4023 1
a4023 1
static int hotlist_show_newdirectory_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d4025 2
a4026 1
  ObjectId dboxid;
d4029 1
a4029 1
    if (tl & (1u<<25)) Printf("hotlist_show_newdirectory_handler: Called\n");
d4032 16
a4047 1
  menu_get_sub_menu_show(0, id_block->self_id, id_block->self_component, &dboxid);
d4049 1
a4049 5
  alter_new = HOTLIST_MENUSECTION_NEW;
  writablefield_set_value(0, dboxid, 0x01, "");
  window_set_title(0, dboxid, "Create new Directory");
  actionbutton_set_text(0, dboxid, 0x02, "Create");
  return 0;
d4055 7
a4061 4
/* This function either alters the selected urls */
/* name and url fields or creates a new url in   */
/* the directory the pointer was in when menu    */
/* was clicked in the hotlist window.            */
d4064 1
a4064 1
static int hotlist_newedit_url_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d4066 8
a4073 3
  hotlist_item *item, *tempitem;
  char *tempdesc, *tempurl;
  int size, atend;
d4076 40
a4115 22
  writablefield_get_value(0,
                          id_block->self_id,
                          HOTLIST_NEWURL_NAME,
                          NULL,
                          0,
                          &size);
  tempdesc = malloc(size);
  if (!tempdesc) return 0; /* ERROR can't rename */
  writablefield_get_value(0,
                          id_block->self_id,
                          HOTLIST_NEWURL_NAME,
                          tempdesc,
                          size,
                          &size);

  writablefield_get_value(0,
                          id_block->self_id,
                          HOTLIST_NEWURL_URL,
                          NULL,
                          0,
                          &size);
  tempurl = malloc(size);
d4119 3
a4121 1
    return 0; /* ERROR can't rename */
a4122 6
  writablefield_get_value(0,
                          id_block->self_id,
                          HOTLIST_NEWURL_URL,
                          tempurl,
                          size,
                          &size);
d4124 12
a4135 1
  switch(alter_new)
a4137 2
    tempitem = hotlist_find_item(hotlist_root->data.directory_content, menu_itemno);
    if (!tempitem)
d4139 46
a4184 14
      show_error(hotlist_new_url(hotlist_root,
                                 HOTLIST_POSITION_END,
                                 tempdesc,
                                 tempurl));
      atend = 1;
    }
    else
    {
      show_error(hotlist_new_url(tempitem,
                                 HOTLIST_POSITION_AFTER,
                                 tempdesc,
                                 tempurl));
      atend = 0;
    }
d4186 2
a4187 1
    hotlist_preopen();
d4189 1
a4189 4
    if (atend)
    {
      hotlist_redraw_items(hotlist_count_displayed_items(hotlist_root->data.directory_content)-1,
                           hotlist_count_displayed_items(hotlist_root->data.directory_content)-1);
a4190 9
    else
    {
      hotlist_redraw_items(menu_itemno,
                           hotlist_count_displayed_items(hotlist_root->data.directory_content));
    }
    hotlist_clear_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);
    hotlist_modified(HL_MODIFIED_ADD);
    free(tempdesc);
    free(tempurl);
d4194 28
a4221 8
    free(item->name);
    free(item->data.url);
    item->name = tempdesc;
    item->data.url = tempurl;
    item->flags |= HOTLIST_G_REDRAW_NOW;
    hotlist_preopen();
    hotlist_redraw_now();
    hotlist_modified(HL_MODIFIED_ALTER);
d4223 1
d4225 1
a4225 2
  }
  return 0;
d4231 5
a4235 4
/* This function either alters the selected      */
/* directorys name or creates a new directory in */
/* the directory the pointer was in when menu    */
/* was clicked in the hotlist window.            */
d4238 1
a4238 1
static int hotlist_newren_directory_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d4240 7
a4246 3
  int size, atend;
  hotlist_item *item, *tempitem;
  char *tempname;
a4248 14
  writablefield_get_value(0,
                          id_block->self_id,
                          HOTLIST_NEWDIRECTORY_NAME,
                          NULL,
                          0,
                          &size);
  tempname = malloc(size);
  if (!tempname) return 0; /* ERROR can't rename */
  writablefield_get_value(0,
                          id_block->self_id,
                          HOTLIST_NEWDIRECTORY_NAME,
                          tempname,
                          size,
                          &size);
d4250 23
a4272 1
  switch(alter_new)
d4275 33
a4307 1
    tempitem = hotlist_find_item(hotlist_root->data.directory_content, menu_itemno);
d4309 1
a4309 16
    if (!tempitem)
    {
      hotlist_new_directory(hotlist_root,
                            tempname,
                            HOTLIST_POSITION_END,
                            &tempitem);
      atend = 1;
    }
    else
    {
      hotlist_new_directory(tempitem,
                            tempname,
                            HOTLIST_POSITION_AFTER,
                            &tempitem);
      atend = 0;
    }
d4311 1
a4311 1
    hotlist_preopen();
d4313 1
a4313 9
    if (atend)
    {
      hotlist_redraw_items(hotlist_count_displayed_items(hotlist_root->data.directory_content)-1,
                           hotlist_count_displayed_items(hotlist_root->data.directory_content)-1);
    }
    else
    {
      hotlist_redraw_items(menu_itemno,
                           hotlist_count_displayed_items(hotlist_root->data.directory_content));
a4314 3
    hotlist_clear_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);
    hotlist_modified(HL_MODIFIED_ADD);
    free(tempname);
d4318 20
a4337 6
    free(item->name);
    item->name = tempname;
    item->flags |= HOTLIST_G_REDRAW_NOW;
    hotlist_preopen();
    hotlist_redraw_now();
    hotlist_modified(HL_MODIFIED_ALTER);
d4339 1
d4341 1
a4341 2
  }
  return 0;
d4345 1
a4345 1
/* hotlist_newren_directory_handler()            */
d4348 6
a4353 3
/* clicked on in the new or edit urldialogue    */
/* box.  It resets the contents to their         */
/* previous state.                               */
d4356 1
a4356 1
static int hotlist_reset_url_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d4358 3
a4360 2
  hotlist_item *item;
  switch(alter_new)
d4363 4
a4366 2
    writablefield_set_value(0, id_block->self_id, 0x01, "");
    writablefield_set_value(0, id_block->self_id, 0x05, "");
d4370 9
a4378 3
    item = hotlist_find_selected_item();
    writablefield_set_value(0, id_block->self_id, 0x01, item->name);
    writablefield_set_value(0, id_block->self_id, 0x05, item->data.url);
d4380 1
d4382 1
a4382 2
  }
  return 0;
d4388 6
a4393 4
/* This function is called when Cancel is        */
/* clicked on in the new or rename directory     */
/* dialogue box.  It resets the contents to      */
/* their previous state.                         */
d4396 1
a4396 1
static int hotlist_reset_directory_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d4398 1
a4398 2
  hotlist_item *item;
  switch(alter_new)
d4401 6
a4406 1
    writablefield_set_value(0, id_block->self_id, 0x01, "");
d4410 8
a4417 2
    item = hotlist_find_selected_item();
    writablefield_set_value(0, id_block->self_id, 0x01, item->name);
d4419 1
d4421 1
a4421 2
  }
  return 0;
d4427 2
a4428 2
/* renders a single hotlist item at 0,0 for use  */
/* with draganobject                             */
d4430 10
a4439 1
/* Parameters: pointer to the item to render     */
d4442 2
a4443 1
static void hotlist_drag_renderer(hotlist_item *item, unsigned int item_height, unsigned int item_dir_width, unsigned int item_url_width)
d4445 2
a4446 1
  /* DONT PUT Printf's in here, doesn't work (on pipefs anyway) */
d4449 2
a4450 1
  int           temp_width, text_width;
d4452 1
a4452 1
  hotlist_iconblock.flags = HOTLIST_SPRITE_ICON_FLAGS;
d4454 2
a4455 1
  hotlist_iconblock.data.is.sprite_area = (void*)sprite_block;
d4457 3
a4459 1
  switch(item->type)                                                /* Set appropriate sprite and width of sprite */
d4462 6
a4467 3
    hotlist_iconblock.data.is.sprite = URL_SPRITE;
    hotlist_iconblock.data.is.sprite_name_length = strlen(URL_SPRITE);
    temp_width = item_url_width;
d4471 6
a4476 3
    temp_width = item_dir_width;
    hotlist_iconblock.data.is.sprite = CLOSED_DIRECTORY_SPRITE;
    hotlist_iconblock.data.is.sprite_name_length = strlen(CLOSED_DIRECTORY_SPRITE);
d4480 3
a4482 1
    temp_width = 0; /* Prevent warnings */
d4486 2
d4493 5
a4497 4
  if (wimp_plot_icon(&hotlist_iconblock))                               /* Plot sprite icon */
  {
    /* Error has happened, don't know what to do about it */
  }
d4502 11
a4512 5
  hotlist_iconblock.flags               = HOTLIST_TEXT_ICON_FLAGS_DRAG;
  hotlist_iconblock.bbox.xmin           = temp_width + 4;
  hotlist_iconblock.bbox.xmax           = temp_width + text_width + 16;
  hotlist_iconblock.bbox.ymax           = item_height;
  hotlist_iconblock.bbox.ymin           = 4;
d4526 7
a4532 4
  if (wimp_plot_icon(&hotlist_iconblock))
  {
    /* Error has happened, don't know what to do about it */
  }
d4590 4
d4637 1
a4637 1
             hotlist_no_contents_selected(item->data.directory_content)   ||
d4672 2
a4673 1
      hotlist_dragging = HOTLIST_SOLID_DRAG_OBJECT;
d4705 2
a4706 1
      hotlist_dragging = HOTLIST_SOLID_DRAG_SPRITE;
d4735 2
a4736 1
  hotlist_dragging = HOTLIST_BOX_DRAG;
d4748 2
a4749 1
  int dragging = hotlist_dragging;
d4758 1
a4758 1
  if (!hotlist_dragging) return 0;
d4764 2
a4765 2
  dragging         = hotlist_dragging;
  hotlist_dragging = 0;
d4770 3
a4772 1
    hotlist_redraw_items(highlighted_itemno, highlighted_itemno);
d4784 1
a4784 1
      hotlist_dragging = 0;
d4790 2
a4791 2
                "Value %d of hotlist_dragging not understood in hotlist_drag_stop_handler",
                hotlist_dragging);
d4805 1
a4805 1
      _swix(DragAnObject_Stop, 0);
d4808 2
d4817 2
a4818 1
      _swix(DragASprite_Stop, 0);
d4820 2
d4829 1
a4829 1
      wimp_drag_box(NULL);
d4836 3
a4838 1
      hotlist_redraw_now();
d4844 2
a4845 1
      wimp_drag_box(NULL);
d4847 2
d4868 1
a4868 1
static int hotlist_drag_completed_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
d4891 1
a4891 1
  if (!hotlist_dragging) return 0;
d4897 2
a4898 2
  dragging         = hotlist_dragging;
  hotlist_dragging = 0;
d4926 2
a4927 2
                "Value %d of hotlist_dragging not understood in hotlist_drag_completed_handler",
                hotlist_dragging);
d5048 4
a5051 1
          /* If we're over half way past the item, place after it */
d5053 5
a5057 1
          if (targetitem->type == hl_directory && targetitem->flags & HOTLIST_D_IS_OPEN)
d5204 12
a5215 1
  return 0;
d5221 1
a5221 1
/* Auto scrolls a window.                        */
d5223 2
a5224 2
/* Parameters: handle of toolbox window to       */
/*             scroll or 0 to reset autoscroll.  */
d5227 1
a5227 1
_kernel_oserror * hotlist_autoscroll(int window)
d5229 9
a5237 9
  ObjectId parent;
  ComponentId component;
  int scroll_changed;
  _kernel_oserror *e;
  ObjectId over_window;
  BBox extent;
  int x, y, position;
  int autoscroll_newtime;
  WimpGetWindowStateBlock state;
d5239 2
a5240 1
  static unsigned int scrolling, autoscroll_oldtime, mouse_shape = Mouse_Shape_Normal;
d5243 1
d5247 1
a5247 1
      if (tl & (1<<25)) Printf("hotlist_autoscroll: resetting\n");
d5249 1
d5251 1
d5255 4
a5258 1
    return _swix(OS_ReadMonotonicTime, _OUTR(0, 0), &autoscroll_oldtime);
d5262 1
d5265 2
d5271 1
d5273 6
a5278 5
  /* Find location of pointer */
  if ((x < state.visible_area.xmin) ||
      (x > state.visible_area.xmax) ||
      (y < state.visible_area.ymin) ||
      (y > state.visible_area.ymax))
d5280 3
a5282 1
    position = 0; /* Outside visible area */
d5284 6
a5289 5
  else
  if ((x > state.visible_area.xmin + choices.auto_scroll_margin) &&
      (x < state.visible_area.xmax - choices.auto_scroll_margin) &&
      (y > state.visible_area.ymin + choices.auto_scroll_margin) &&
      (y < state.visible_area.ymax - choices.auto_scroll_margin))
d5291 3
a5293 1
    position = 1; /* Inside non scrolling region */
d5297 3
a5299 1
    position = 2; /* Inside scrolling region */
d5302 3
d5309 2
d5313 2
a5314 1
      /* Top */
d5325 1
a5325 1
        /* Bottom */
d5335 2
d5339 2
a5340 1
      /* Right */
d5351 2
a5352 1
        /* Left */
d5362 3
a5364 1
  switch(position)
d5366 3
a5369 1
    if (!scrolling)
d5371 1
a5371 2
      RetError(_swix(OS_ReadMonotonicTime, _OUTR(0, 0), &autoscroll_oldtime));
      if (mouse_shape != Mouse_Shape_Normal)
d5373 10
a5382 2
        mouse_set_pointer_shape(Mouse_Shape_Normal);
        mouse_shape = Mouse_Shape_Normal;
d5387 3
d5393 6
a5398 1
      RetError(_swix(OS_ReadMonotonicTime, _OUTR(0, 0), &autoscroll_oldtime));
d5407 3
a5410 1
    if ((!scrolling) && scroll_changed)
d5412 1
a5412 2
      RetError(_swix(OS_ReadMonotonicTime, _OUTR(0, 0), &autoscroll_newtime));
      if ((autoscroll_newtime - autoscroll_oldtime) > choices.auto_scroll_delay)
d5414 22
a5435 1
        scrolling = 1;
d5437 4
a5440 1
      else
d5442 4
a5445 5
        if (mouse_shape != Mouse_Shape_ToScroll)
        {
          mouse_shape = Mouse_Shape_ToScroll;
          mouse_set_pointer_shape(Mouse_Shape_ToScroll);
        }
a5447 4
    if (!scroll_changed)
    {
      RetError(_swix(OS_ReadMonotonicTime, _OUTR(0, 0), &autoscroll_oldtime));
    }
d5451 2
d5457 16
a5472 2
      RetError(toolbox_get_parent(0, window, &parent, &component));
      RetError(toolbox_show_object(0, window, Toolbox_ShowObject_FullSpec, &(state.visible_area), parent, component));
d5481 4
d5489 1
d5495 2
d5503 5
a5507 2
/* Called every null event while drag is in      */
/* operation                                     */
d5510 1
a5510 1
static int hotlist_null_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
d5512 12
a5523 9
  int x, y, buttons;
  unsigned int itemno;
  int          xmin, xmax;
  unsigned int item_height, item_dir_width, item_url_width;
  int new_time;
  hotlist_item *item;
  ObjectId window;
  ComponentId component;
  WimpGetWindowStateBlock state;
d5525 1
a5525 1
  window_get_pointer_info(0, &x, &y, &buttons, &window, &component);
d5527 1
a5527 1
  show_error_ret(hotlist_autoscroll(hotlist_windowid));
d5531 3
a5533 1
    window_get_wimp_handle(0, window, &state.window_handle);
d5536 8
a5543 3
    /* here will put in directory rather than next to it          */
    wimp_get_window_state(&state);
    hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d5549 5
a5553 1
    item = hotlist_find_item(hotlist_root->data.directory_content, itemno);
d5557 17
a5573 2
      hotlist_get_shape(&xmin, &xmax, item);
      if (x >= xmin && x <= xmin + item_dir_width)
d5575 2
d5579 2
d5584 2
a5585 1
            hotlist_redraw_items(highlighted_itemno, highlighted_itemno);
d5587 16
a5602 5
          item->flags |= HOTLIST_D_IS_HIGHLIGHTED;
          hotlist_current_highlighted = item;
          highlighted_itemno = itemno;
          hotlist_redraw_items(highlighted_itemno, highlighted_itemno);
          _swix(OS_ReadMonotonicTime, _OUTR(0, 0), &autoopen_oldtime);
d5606 8
a5613 1
          _swix(OS_ReadMonotonicTime, _OUTR(0, 0), &new_time);
d5615 1
a5615 1
          /* Auto open directories */
d5618 3
a5620 3
               choices.auto_open_delay                                 &&
               !(item->flags & HOTLIST_D_IS_OPEN)                      &&
               (new_time - autoopen_oldtime) > choices.auto_open_delay
d5623 2
d5628 3
a5630 2
            hotlist_redraw_items(highlighted_itemno,
                                 hotlist_count_displayed_items(hotlist_root->data.directory_content));
d5636 4
a5639 15
        if (hotlist_current_highlighted)
        {
          hotlist_current_highlighted->flags &= ~HOTLIST_D_IS_HIGHLIGHTED;
          hotlist_redraw_items(highlighted_itemno, highlighted_itemno);
          hotlist_current_highlighted = NULL;
        }
      }
    }
    else
    {
      if (hotlist_current_highlighted)
      {
        hotlist_current_highlighted->flags &= ~HOTLIST_D_IS_HIGHLIGHTED;
        hotlist_redraw_items(highlighted_itemno, highlighted_itemno);
        hotlist_current_highlighted = NULL;
d5642 5
d5648 3
d5653 15
a5667 7
    /* non hotlist window */
    if (hotlist_current_highlighted)
    {
      hotlist_current_highlighted->flags &= ~HOTLIST_D_IS_HIGHLIGHTED;
      hotlist_redraw_items(highlighted_itemno, highlighted_itemno);
      hotlist_current_highlighted = NULL;
    }
d5669 3
d5675 4
a5678 4
/* Simple non-scrolling selection box, to be improved later */

/* Workarea relative corner of selection box may not be needed later */
///////////////////////////////////////////////////////////////////////
a5679 2
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
d5688 1
a5688 1
static _kernel_oserror *hotlist_selection_box_start(void)
d5690 8
a5697 4
  _kernel_oserror *err;
  WimpDragBox box;
  WimpGetPointerInfoBlock pointerblock;
  WimpGetWindowStateBlock state;
d5699 2
a5700 1
  wimp_get_pointer_info(&pointerblock);                          /* Read pointer position */
d5702 1
a5702 2
  show_error(window_get_wimp_handle(0, hotlist_windowid, &state.window_handle));
  wimp_get_window_state(&state);
d5707 2
d5710 2
a5711 1
  box.dragging_box.xmin = pointerblock.x;                          /* box shape */
d5715 2
a5716 1
  box.parent_box.xmin   = state.visible_area.xmin;  /* Bounding box for dragged box */
d5720 11
a5730 4
  err = wimp_drag_box(&box);                                           /* start drag box */
  if (err) return err;
  hotlist_dragging = HOTLIST_BOX_DRAG_SELECTION;                 /* Set global variable saying we are currently dragging */
                                                                 /* so we know whether to process a user_drag_box event  */
d5733 1
a5752 2
  unsigned int item_height, item_dir_width, item_url_width;
  int workx, worky;
d5754 4
a5757 2
  unsigned int item_min, item_max;
  int minx, maxx;
d5759 1
a5759 1
  wimp_get_pointer_info(&pointerblock);                          /* Read pointer position */
d5761 6
a5766 2
  show_error(window_get_wimp_handle(0, hotlist_windowid, &state.window_handle));
  wimp_get_window_state(&state);
d5768 1
a5768 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d5773 2
d5791 3
a5793 1
  hotlist_select_box(item_min, item_max, minx, maxx);
d5805 6
a5810 2
/* maxx.  Clears the HOTLIST_G_DRAG_SELECTED     */
/* flag for all other items                      */
d5812 3
a5814 4
/* Parameters: first visible item                */
/* handler.    last visible item                 */
/*             minx workspace relative           */
/*             maxx workspace relative           */
d5817 1
a5817 1
void hotlist_select_box(unsigned int first_item, unsigned int last_item, int minx, int maxx)
d5819 8
a5826 2
  unsigned int itemno;
  hotlist_select_box_r(first_item, last_item, hotlist_root->data.directory_content, &itemno, minx, maxx);
d5832 16
a5847 1
/* Recursive backend to hotlist_select_box       */
d5850 2
a5851 1
void hotlist_select_box_r(unsigned int first_item, unsigned int last_item, hotlist_item *item, unsigned int *itemno, int minx, int maxx)
d5853 4
a5856 2
  int itemxmin, itemxmax;
  while(item)
a5857 2
    /* Do stuff */

d5860 7
a5866 2
      hotlist_get_shape(&itemxmin, &itemxmax, item);
      if ((!(maxx < itemxmin || minx > itemxmax)))
d5871 7
a5877 2
          hotlist_redraw_items(*itemno, *itemno);
          if (item->type == hl_directory && !(item->flags & HOTLIST_D_IS_OPEN)) /* If directory is closed select everything in it */
d5879 1
a5879 1
            hotlist_set_flags(item->data.directory_content, hl_ALL, HOTLIST_G_DRAG_SELECTED);
d5882 2
d5886 3
d5894 6
a5899 2
          hotlist_redraw_items(*itemno, *itemno);
          if (item->type == hl_directory && !(item->flags & HOTLIST_D_IS_OPEN)) /* If directory is closed unselect everything in it */
d5901 3
a5903 1
            hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_DRAG_SELECTED | HOTLIST_G_REDRAW_NOW);
d5905 2
d5912 2
d5917 6
a5922 2
        hotlist_redraw_items(*itemno, *itemno);
        if (item->type == hl_directory && !(item->flags & HOTLIST_D_IS_OPEN)) /* If directory is closed unselect everything in it */
d5924 3
a5926 1
          hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_DRAG_SELECTED | HOTLIST_G_REDRAW_NOW);
d5928 2
d5933 2
d5937 2
d5941 6
a5946 1
      hotlist_select_box_r(first_item, last_item, item->data.directory_content, itemno, minx, maxx);
d5948 3
d5953 4
d5974 1
a5974 1
  while(item)
d6140 4
d6340 136
d6482 2
a6483 2
/* Parameters: pointer to window relative        */
/*             bounding box                      */
d6485 2
a6486 2
/* Returns:    1 if there were selected item(s)  */
/*             0 if there weren't                */
d6491 3
a6493 2
  unsigned int itemno, item_height;
  int found;
d6497 23
a6519 6
  hotlist_get_entry_sizes(&item_height, NULL, NULL);
  hotlist_get_selected_shape_r(hotlist_root->data.directory_content,
                               box,
                               &itemno,
                               &found,
                               item_height);
d6528 1
a6528 1
/* hotlist_get_selected_shape_r()                */
d6530 1
a6530 1
/* Parameters: Pointer to a hotlist_item         */
d6532 2
a6533 2
/*             pointer to window relative        */
/*             bounding box                      */
d6535 2
a6536 1
/*             Pointer to the current item no    */
d6538 1
a6538 1
/*             pointer to found flag             */
d6541 1
a6541 1
/*             os units                          */
d6544 1
a6544 5
static void hotlist_get_selected_shape_r(hotlist_item * list,
                                         BBox         * box,
                                         unsigned int * itemno,
                                         int          * found,
                                         unsigned int item_height)
d6546 4
a6549 2
  int newxmin, newxmax;
  while(list)
d6553 4
a6556 1
      hotlist_get_shape(&newxmin, &newxmax, list);
d6562 2
a6563 1
        box->ymin = -((*itemno)+1)* item_height;
d6567 4
a6570 1
        /* This section run for first selected item found only */
d6573 5
a6577 2
        box->ymax = -(*itemno)     * item_height;
        box->ymin = -((*itemno)+1) * item_height;
d6582 1
a6582 1
    *itemno +=1;
d6588 5
a6592 1
      hotlist_get_selected_shape_r(list->data.directory_content, box, itemno, found, item_height);
d6594 3
d6599 4
@


1.23
log
@Much faster 3000%+ in some cases loading of hotlist files.
Also much faster drag box selections.
@
text
@d47 1
d60 1
a60 4
/* To be made choices/controls */

#define AUTOSCROLL_DELAY             50
#define HOTLIST_SCROLL_BOUNDARY_SIZE 32
d63 1
a63 1
#define CHARSET_SPECIFIER "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n"
d65 1
a65 1
#define CHARSET_SPECIFIER "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n"
d3099 1
a3099 1

d3139 1
a3139 1

d3141 1
a3141 1

d3146 1
a3146 1

d3852 1
a3852 1

d3854 1
a3854 1

d3921 1
a3921 1

d3938 1
a3938 1

d3940 1
a3940 1

d4595 1
a4595 1

d4799 4
a4802 4
  if ((x > state.visible_area.xmin + HOTLIST_SCROLL_BOUNDARY_SIZE) &&
      (x < state.visible_area.xmax - HOTLIST_SCROLL_BOUNDARY_SIZE) &&
      (y > state.visible_area.ymin + HOTLIST_SCROLL_BOUNDARY_SIZE) &&
      (y < state.visible_area.ymax - HOTLIST_SCROLL_BOUNDARY_SIZE))
d4815 1
a4815 1
    if (y > state.visible_area.ymax - HOTLIST_SCROLL_BOUNDARY_SIZE)
d4821 1
a4821 1
        state.yscroll += (y - (state.visible_area.ymax - HOTLIST_SCROLL_BOUNDARY_SIZE));
d4826 1
a4826 1
      if (y < state.visible_area.ymin + HOTLIST_SCROLL_BOUNDARY_SIZE)
d4833 1
a4833 1
          state.yscroll -= ((state.visible_area.ymin + HOTLIST_SCROLL_BOUNDARY_SIZE) - y);
d4838 1
a4838 1
    if (x > state.visible_area.xmax - HOTLIST_SCROLL_BOUNDARY_SIZE)
d4844 1
a4844 1
        state.xscroll += (x - (state.visible_area.xmax - HOTLIST_SCROLL_BOUNDARY_SIZE));
d4849 1
a4849 1
      if (x < state.visible_area.xmin + HOTLIST_SCROLL_BOUNDARY_SIZE)
d4855 1
a4855 1
          state.xscroll -= ((state.visible_area.xmin + HOTLIST_SCROLL_BOUNDARY_SIZE) - x);
d4891 1
a4891 1
      if ((autoscroll_newtime - autoscroll_oldtime) > AUTOSCROLL_DELAY)
d4996 1
d4998 6
a5003 3
          if (choices.autoopen_delay &&
              !(item->flags & HOTLIST_D_IS_OPEN) &&
              (new_time - autoopen_oldtime) > choices.autoopen_delay)
d5006 1
d5008 2
a5009 1
            hotlist_redraw_items(highlighted_itemno, hotlist_count_displayed_items(hotlist_root->data.directory_content));
d5141 1
a5141 1

d5181 1
a5181 1

d5223 1
a5223 1

d5225 1
a5225 1

d5415 1
a5415 1
  if (choices.save_hotlist == 2) return hotlist_save(lookup_choice("HotlistPath:Browse:User.Hotlist",0,0));
@


1.22
log
@Encoding support added: if UNIFONT is defined then the browser will
attempt to use the system font to render Unicode characters (new
International module required). If not defined, the browser will just
handle Acorn Latin-1 characters, but HTMLLib will convert other encodings
into Latin-1. Must keep the UNIFONT define in sync with HTMLLib (if
defined HTMLLib outputs UTF-8, otherwise Acorn Latin-1).

Still needed:

Reverse encoding (converting form input etc back into the server's
character set).
Reparse when encoding changes.
Setting of charset from an attribute on the <A> tag.
@
text
@d203 2
a204 1

d2950 2
d2953 1
a2953 1
  /* Go through the file in chunks */
d3101 10
a3110 2

      e = hotlist_new_url(target, HOTLIST_POSITION_END, str_ptr, url);
d3112 1
d3131 9
a3139 1
        e = hotlist_new_directory(target, next_directory_name, HOTLIST_POSITION_END, &new_dir);
d3142 2
a5107 1
  hotlist_item *item;
d5109 1
a5109 2
  unsigned int item_min, item_max, itemno;
  int itemxmin, itemxmax;
a5110 1
  int last_item;
d5137 21
d5159 11
a5169 1
  last_item = hotlist_count_displayed_items(hotlist_root->data.directory_content);
d5171 4
a5174 1
  for(itemno = 0; itemno <= last_item; itemno++)
d5176 3
a5178 2
    item = hotlist_find_item(hotlist_root->data.directory_content, itemno);
    if (item)
d5180 2
a5181 1
      if (itemno >= item_min && itemno <= item_max)
d5183 1
a5183 2
        hotlist_get_shape(&itemxmin, &itemxmax, item);
        if ((!(maxx < itemxmin || minx > itemxmax)))
d5185 3
a5187 1
          if (!(item->flags & HOTLIST_G_DRAG_SELECTED))
d5189 2
a5190 19
            item->flags |= HOTLIST_G_DRAG_SELECTED;
            hotlist_redraw_items(itemno, itemno);
            if (item->type == hl_directory && !(item->flags & HOTLIST_D_IS_OPEN)) /* If directory is closed select everything in it */
            {
              hotlist_set_flags(item->data.directory_content, hl_ALL, HOTLIST_G_DRAG_SELECTED);
              hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_REDRAW_NOW);
            }
          }
        }
        else
        {
          if (item->flags & HOTLIST_G_DRAG_SELECTED)
          {
            item->flags &= ~HOTLIST_G_DRAG_SELECTED;
            hotlist_redraw_items(itemno, itemno);
            if (item->type == hl_directory && !(item->flags & HOTLIST_D_IS_OPEN)) /* If directory is closed unselect everything in it */
            {
              hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_DRAG_SELECTED | HOTLIST_G_REDRAW_NOW);
            }
d5199 1
a5199 1
          hotlist_redraw_items(itemno, itemno);
d5207 20
a5227 2

  return 0;
@


1.21
log
@Modified opening and closing of directories to prevent unnecessary redraws.
Altered Newdirectory/NewURL routines to create new directories at the pointer.
@
text
@d64 6
d2818 7
a2824 4
  HotlistWrite(fprintf(fileptr, "<html>\n"));
  HotlistWrite(fprintf(fileptr, "<head><title>Hotlist</title></head>\n"));
  HotlistWrite(fprintf(fileptr, "<body>\n"));
  HotlistWrite(fprintf(fileptr, "<ul>\n"));
d4132 1
a4132 1

d4370 1
a4370 1

d4486 1
a4486 1

d5567 1
a5567 1

d5576 1
a5576 1

d5611 1
a5611 1

d5628 1
a5628 1

d5630 1
a5630 1

@


1.20
log
@Slight alteration to drag and drop model
@
text
@d2055 1
a2055 1
  hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
d3766 1
a3766 1
  int size;
d3807 8
a3814 1
    if (!tempitem) tempitem = hotlist_root;
d3817 5
a3821 1
      tempitem = tempitem->parent;
d3823 1
a3823 4
    show_error(hotlist_new_url(tempitem,
                               HOTLIST_POSITION_END,
                               tempdesc,
                               tempurl));
d3825 11
a3835 2
    hotlist_redraw_items(menu_itemno,
                         hotlist_count_displayed_items(hotlist_root->data.directory_content));
d3868 1
a3868 1
  int size;
d3892 9
a3900 1
    if (!tempitem) tempitem = hotlist_root;
d3902 8
a3909 5
    tempitem = tempitem->parent;
    hotlist_new_directory(tempitem,
                          tempname,
                          HOTLIST_POSITION_END,
                          &tempitem);
d3911 11
a3921 2
    hotlist_redraw_items(menu_itemno,
                         hotlist_count_displayed_items(hotlist_root->data.directory_content));
a3933 1
    //toolbox_hide_object(0, id_block->ancestor_id);
@


1.19
log
@Added saving of state of hotlist (directories are open or closed)
@
text
@d4530 9
a4538 2

          position = HOTLIST_POSITION_AFTER;
@


1.18
log
@Fixed problem where dashbox drags would not always bound entire selection
@
text
@d2751 8
a2758 1
            HotlistWrite(fprintf(fileptr, "<ul>\n"));
d3112 6
a3117 1

d5562 2
a5563 2
        if (newxmin                     < box->xmin) box->xmin = newxmin;
        if (newxmax                     > box->xmax) box->xmax = newxmax;
d5568 1
@


1.17
log
@As warned in the last log, pretty much all event codes and component IDs
have now changed along with many of the names, to provide a consistent
name and numberspace for events and components. This also minimises
number clashes (e.g. as was, the Save File origin when opened from a
Hotlist menu with an already-used component ID). To get full details on
this, please carefully read through TBEvents.h.

Res files, Sprites files and Messages files have been updated again both
due to the above, and routine additions (e.g. message support for a few
Hotlist bits and pieces). !Run[D] files updated for FTP 0.11 and
HTTP 0.36.

In the Makefile, the Customer objects list was missing Save - must have
moved something when I should've copied it, when adding in SaveFile or
SaveObject in all probability. Now fixed. Couple of other bits and bobs
fixed in the build environment (e.g. stuff saying !Argo instead of
!Customer). Oh, and I've altered the MakeFile copy options again to the
best compromise I can come up with. Newer is turned on for everything
except !Run[D] and !RunImage, since both of those change between debug
builds - otherwise if you'd built debug and non-debug versions, it was
not possible to switch between them - one version would have the newer
timestamp and thus never get overwritten.

The default hotlist has had a few items added - that'll be about the end
of it, I think; there's more than enough stuff in there now.

Saving of the hotlist from the document menu and of URI files,
directories and selections from the hotlist menu tree is now implemented
- this new save system rocks... Oh, and you can save all images and
backgrounds as sprites.

Saving of items with Shift+Click to other applications directly now
works, and is robust. Unique Scrap filenames are used, with data load
bounces (e.g. if some pra - er, person quits the app they're sending
to) working correctly - that is, give an error, keep the file, rename
it to something safe, and open the directory it lies in. As opposed
to normal app-to-app bounces, where the scrap file is deleted (see
PRM 3-254). This means you can now look at README files in FTP
sites, say, without using a disc intermediate. Or you can send pictures
straight to ChangeFSI, fetch HTML links into editors, and so-on, and
so-on - it's all very funky. Known problems include the ambiguous
'invalid component ID' instead of 'file open' for *normal* (straight to
disc) shift+click saves, and I think I'll introduce a unique name
guarantee of some sort to stop 'file open' in the first place. Odd
that the really tricky part (app-to-app) should be least likely to
suffer from this!
@
text
@d173 1
a173 1
static _kernel_oserror * hotlist_get_shape               (unsigned int * xmin, unsigned int * xmax, hotlist_item * item);
d191 8
d1966 1
a1966 1
static _kernel_oserror * hotlist_get_shape(unsigned int * xmin, unsigned int * xmax, hotlist_item * item)
d2331 2
a2332 1
  unsigned int xmin, xmax, itemno;
d2655 1
a2655 2
  unsigned int              xmin, xmax;
  int                       window_handle;
a4068 1
  int                       item_no;
d4070 1
a4070 2
  unsigned int              xmin,        xmax;
  int                       top,         bottom;
d4075 1
a4075 1

d4079 1
a4079 36
  /* Find the first selected item and work out various details */
  /* based on it.                                              */

  item    = hotlist_find_selected_item();
  item_no = hotlist_find_no_from_item(item);

  top     = -item_no * item_height;
  bottom  = -(item_no + 1) * item_height;

  /* Selected item not found... Shouldn't happen, but to be safe, */
  /* we check anyway.                                             */

  if (item_no < 0) return NULL;

  /* Get the horizontal extent of the item */

  hotlist_get_shape(&xmin, &xmax, item);

  /* If there are other selected items, find the leftmost and */
  /* rightmost points of the whole group.                     */

  item = item->next;

  if (hotlist_count_selected_items() > 1)
  {
    unsigned int xhigh, xlow;

    while (item)
    {
      item_no++;
      hotlist_get_shape(&xlow, &xhigh, item);

      if (item->flags & HOTLIST_G_IS_SELECTED)
      {
        if (xlow  < xmin) xmin = xlow; /* (Shouldn't really happen, the left hand side should not be ragged) */
        if (xhigh > xmax) xmax = xhigh;
d4081 1
a4081 5
        bottom = -(item_no + 1) * item_height;
      }
      item = item->next;
    }
  }
d4130 4
a4133 4
      box.dragging_box.xmin = xmin   - xorigin;
      box.dragging_box.ymin = bottom - yorigin;
      box.dragging_box.xmax = xmax   - xorigin;
      box.dragging_box.ymax = top    - yorigin;
d4200 4
a4203 4
  box.dragging_box.xmin = xmin   - xorigin;
  box.dragging_box.xmax = xmax   - xorigin;
  box.dragging_box.ymin = bottom - yorigin;
  box.dragging_box.ymax = top    - yorigin;
d4313 7
d4346 1
a4346 1
  unsigned int              xmin,        xmax;
d4422 8
d4863 2
a4864 1
  unsigned int itemno, xmin, xmax;
d5024 2
a5025 1
  unsigned int item_min, item_max, itemno, itemxmin, itemxmax;
d5483 91
@


1.16
log
@First a minor warning - the various Res files are out of sync in this build.
Only the Browse resources are currently valid.

Added Utils.Icons - has a few archives inside containing the resources
(well, some of them) used to build various UI sprites for various builds.
Archived because these are unlikely to change much, and putting them on
CVS was a move to, well, archive the stuff...

SaveDBox objects vanquished and requirements in !Run[D] files removed. The
data save code fits much more neatly in amongst the data load protocol
stuff now (with the slight exception of having to split the SaveObject
source into SaveObject and SaveFile - the former handles multiple persistent
dialogues for Shift+Click on links and the like, the latter handles 'one at
a time' transient dialogues for save source and similar). Export Link is now
supported, too, and writes a 'proper' version URI file. You'll find that
double-clicking on old URI files will work as the URI handler picks them up,
whilst new version ones don't; however, dragging onto the browser will only
work with new version files. Note that support for saving and loading URL
files (ANT suite stuff) is present too, so old URI files can be typed as URL
files if you want to keep them working without modification - the URI
handler itself will hopefully support the defined URI file format soon;
double-clicking on old URI files will stop working at that point. Note
there are *lots* of changes in every Res file to support all this. This may
all seem a bit pointless to some, but the changes do in fact make it very
easy to add new save dialogues all over the place. Certainly much easier
than with the previous system, anyway. In fact, post script, image
'save as sprite' took about half an hour, which I hope proves the worth
of the new system.

Merged in newer hotlist code with support for drag cancelling with Escape
(all relevant Res files appropriately updated) and cancelling scrolling
when you've reached the window scroll limit. Had to move some of the
Wimp message handling stuff to the central Protocols source, as clashes
were occuring, and also the hotlist routines were using independent saving
code - a lot of duplicated effort. This was fair enough as at the time the
Hotlist code was written, the Save code couldn't be used in the way it is
now.

New Save Source and Print buttons on the toolbar of some builds.

Phoenix Sprites file made more efficient - the Acorn base section has been
split from the animated upper region. Browse build has a new grey fade
sprite at the back, which is less grainy than the previous one and only
uses 16 colours (with a 16 greyscale palette).

Not really a bug, bug the routine to start an image fetch for INPUT
TYPE=IMAGE forms items only did so if the src field (or equivalent, for
this tag type) was non-NULL. In fact, you should always call image_new_image
and let that handle the rest, otherwise other sections of the code will fail
as they try to obtain an image number for a given HStream and get -1 back.
This problem only generally manifested itself when loading an HTML file to
the browser straight from an application, as many src fields become NULL
when the relativisation routines find nothing to relativise to...

Authentication got broken somewhere along the line - this has been fixed
(in HTMLLib and the browser).

Ctrl+Click on a cross referenced image updates *all* copies, not just the
one with the image data attached.

Next big step: Rip up TBEvents.h and rebuild that whole approach somewhat.
To all those working on the code, my apologies but this means all Res files
will receive a very large number of alterations and there will be extensive
code changes too (mostly naming convention stuff), in more or less all
source files. I am endeavouring to ensure that the new numberspace
convention does not clash with the work being done by Kevin on
internationalisation.
@
text
@d49 1
d61 2
a62 2
#define AUTOSCROLL_DELAY                    50
#define HOTLIST_SCROLL_BOUNDARY_SIZE        32
d66 1
a66 1
#define HotlistWrite(fn) {written = (fn); if (written < 0) return _kernel_last_oserror();}
a90 4
static hotlist_item * hotlist_save_item = NULL;           /* Item whose URL is being saved */
static int            hotlist_ram_transfer_sent;          /* Number of bytes which have already been sent by ram transfer */
static int            hotlist_save_type = HL_SAVE_NONE;   /* Variety of save currently in progress */

d107 2
a108 2
static ToolboxEventHandler   hotlist_menu_selectall_handler;
static ToolboxEventHandler   hotlist_menu_clearselect_handler;
a123 3
static WimpMessageHandler    hotlist_data_save_ack_handler;
static WimpMessageHandler    hotlist_ram_fetch_handler;

a154 1
static hotlist_item    * hotlist_find_selected_item      (void);
a158 1
static unsigned int      hotlist_count_selected_items    (void);
d171 6
a176 6
static void              hotlist_redraw_now              (void);
static void              hotlist_redraw_now_r            (hotlist_item * list, int * curr_item);
static void              hotlist_get_shape               (unsigned int * xmin, unsigned int * xmax, hotlist_item * item);
static void              hotlist_directory_open_close    (hotlist_item * item, unsigned int itemno);
static void              hotlist_redraw_items            (unsigned int firstitem, unsigned int lastitem);
static void              hotlist_launch_url              (hotlist_item * item);
d185 2
a186 1
static void              hotlist_start_drag              (void);
d190 1
d300 27
d1291 1
a1291 1
static hotlist_item * hotlist_find_selected_item(void)
d1308 1
a1308 1
hotlist_item * hotlist_find_selected_item_r(hotlist_item * list)
d1340 9
d1352 1
a1352 1
static unsigned int hotlist_count_selected_items(void)
d1465 4
a1468 1
/*             First item number to draw;        */
d1499 4
a1502 1
/*             First item number to draw;        */
d1827 1
a1827 1
static void hotlist_redraw_now(void)
d1831 1
a1831 1
  hotlist_redraw_now_r(hotlist_root->data.directory_content, &curr_item);
d1850 1
a1850 1
static void hotlist_redraw_now_r(hotlist_item * list, int * curr_item)
d1852 2
d1860 1
a1860 1
      hotlist_redraw_items(*curr_item, *curr_item);
d1873 1
a1873 1
      hotlist_redraw_now_r(list->data.directory_content, curr_item);
d1878 2
d1903 2
d1943 5
a1947 1
/* of the passed hotlist_item                    */
d1949 7
a1955 3
/* Parameters: *xmin                             */
/*             *xmax                             */
/*             item                              */
d1958 1
a1958 3
static void hotlist_get_shape(unsigned int *xmin,
                       unsigned int *xmax,
                       hotlist_item *item)
d1960 13
a1972 4
  unsigned int item_height, item_dir_width, item_url_width;
  int count = 0, temp_width, text_width;
  hotlist_item *tempitem;
  _kernel_oserror *e;
d1974 1
a1974 1
  e = hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d1976 2
a1977 7
  if (e)
  {
    show_error_ret(e);
    *xmin = 0;
    *xmax = 0;
    return;
  }
d1980 2
a1981 1
  while(tempitem)
d1989 2
d1994 3
a1996 1
  switch(item->type)
d1998 1
a1998 2
    case hl_directory:
    temp_width = item_dir_width;
d2001 1
a2001 2
    case hl_url:
    temp_width = item_url_width;
d2004 1
a2004 2
    default:
    temp_width = 0;
d2008 6
a2013 2
  *xmin = count * item_dir_width;
  *xmax = count * item_dir_width + temp_width + 2 + text_width + 12;
d2019 6
a2024 2
/* This function opens or closes a directory     */
/* along with all required redrawing             */
d2026 4
a2029 2
/* Parameters: hotlist_item                      */
/*             item number on screen             */
d2032 1
a2032 1
static void hotlist_directory_open_close(hotlist_item *item, unsigned int itemno)
d2034 4
a2037 4
  unsigned int item_height, item_dir_width, item_url_width;
  int top, window_handle;
  BBox bbox;
  _kernel_oserror *e;
d2039 1
a2039 1
  e = hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d2041 1
a2041 5
  if (e)
  {
    show_error_ret(e);
    return;
  }
d2045 2
d2049 2
a2051 1
  show_error(window_get_wimp_handle(0, hotlist_windowid, &window_handle));
d2053 2
a2054 1
  window_get_extent(0, hotlist_windowid, &bbox);
d2056 1
a2056 1
  top = -itemno * item_height;				/* Window relative coordinate */
d2060 5
a2064 5
    show_error(wimp_force_redraw(window_handle,
                                 bbox.xmin,
                                 bbox.ymin,
                                 bbox.xmax,
                                 top));
d2068 5
a2072 5
    show_error(wimp_force_redraw(window_handle,
                                 bbox.xmin,
                                 top-item_height,
                                 bbox.xmax,
                                 top));
d2074 2
d2082 7
a2088 1
/* items                                         */
d2090 2
a2091 1
/* Parameters: itemno                            */
d2094 1
a2094 1
static void hotlist_redraw_items(unsigned int firstitem, unsigned int lastitem)
d2096 8
a2103 4
  unsigned int item_height, item_dir_width, item_url_width;
  BBox bbox;
  int window_handle;
  _kernel_oserror *e;
d2105 1
a2105 1
  e = hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d2107 2
a2108 5
  if (e)
  {
    show_error_ret(e);
    return;
  }
d2110 2
a2111 2
  show_error(window_get_wimp_handle(0, hotlist_windowid, &window_handle));
  window_get_extent(0, hotlist_windowid, &bbox);
d2113 5
a2117 5
  wimp_force_redraw(window_handle,
                    bbox.xmin,
                    - (lastitem + 1) * item_height,
                    bbox.xmax,
                    - firstitem * item_height);
d2123 2
a2124 2
/* This function unselects all items and redraws */
/* appropriate items                             */
d2127 1
a2127 1
void hotlist_clear_selection(void)
d2129 10
a2138 2
  hotlist_clear_flags(hotlist_root->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
  hotlist_redraw_now();
d2145 1
a2145 1
/* item                                          */
d2147 2
a2148 1
/* Parameters: hotlist_item                      */
d2151 1
a2151 1
static void hotlist_launch_url(hotlist_item * item)
d2157 1
a2157 1
  windows_create_browser(item->data.url, NULL, NULL, NULL, 0);
d2163 18
a2180 2
/* This function handles mouse clicks on hotlist */
/* items                                         */
d2183 1
a2183 5
static _kernel_oserror * hotlist_process_click_on_item(unsigned int itemno,
                                                hotlist_item *item,
                                                int buttons,
                                                int x,
                                                int y)
d2185 1
a2185 1
  switch(buttons)
d2187 3
a2190 1
    if (last_selected_item == itemno)
d2192 3
a2194 1
      switch(item->type)
d2196 10
a2205 3
        case hl_directory:
        hotlist_directory_open_close(item, itemno);
        break;
d2207 2
a2208 3
        case hl_url:
        hotlist_launch_url(item);
        break;
a2209 2
    item->flags &= ~HOTLIST_G_IS_SELECTED;
    hotlist_redraw_items(itemno, itemno);
d2211 3
a2213 1
    break; /* Double click select */
a2215 1
    if (last_selected_item == itemno)
d2217 4
a2220 1
      switch(item->type)
d2222 14
a2235 3
        case hl_directory:
        hotlist_directory_open_close(item, itemno);
        break;
d2237 2
a2238 4
        case hl_url:
        hotlist_launch_url(item);
        toolbox_hide_object(0, hotlist_windowid);
        break;
a2239 2
      item->flags &= ~HOTLIST_G_IS_SELECTED;
      hotlist_redraw_items(itemno, itemno);
d2241 1
a2241 1
    break; /* Double click adjust */
d2243 1
a2243 3
    case 64:                     /* Drag select */
    hotlist_start_drag();
     break;
d2245 6
a2250 2
    case 16:                     /* Drag adjust */
    if (!(item->flags & HOTLIST_G_IS_SELECTED))
d2252 10
a2261 1
      item->flags |= HOTLIST_G_IS_SELECTED;
d2263 2
a2264 1
      last_selected_item = itemno;
a2265 2
    hotlist_start_drag();
    hotlist_redraw_items(itemno, itemno);
d2563 1
a2563 1
  switch(hotlist_count_selected_items())
d2566 5
a2570 3
    menu_set_entry_text(0, menuid, HOTLIST_URL_MENUITEM, "URL ''");
    menu_set_fade(0, menuid, HOTLIST_URL_MENUITEM, 1);
    menu_set_fade(0, menuid, HOTLIST_CLEARSELECTION_MENUITEM, 1); /* Fade clear selection */
a2572 1
    case -1:
d2574 10
a2583 1
    item = hotlist_find_selected_item();             /* One item selected */
d2585 5
a2589 7
    switch(item->type)
    {
      case hl_directory:
      strcpy(entrytext, "Dir. '");
      toolbox_create_object(0, "HLDirmenu", &submenu_id);
      menu_set_sub_menu_show(0, menuid, HOTLIST_URL_MENUITEM, submenu_id);
      break;
d2591 1
a2591 5
      case hl_url:
      strcpy(entrytext, "URL '");
      toolbox_create_object(0, "HLURLmenu", &submenu_id);
      menu_set_sub_menu_show(0, menuid, HOTLIST_URL_MENUITEM, submenu_id);
      break;
d2593 6
a2599 7

    strncat(entrytext, item->name, 10);
    if (strlen(item->name) > 10) strcat(entrytext, "...");
    strcat(entrytext, "'");
    menu_set_entry_text(0, menuid, HOTLIST_URL_MENUITEM, entrytext);
    menu_set_fade(0, menuid, HOTLIST_URL_MENUITEM, 0);                    /* unfade URL '' */
    menu_set_fade(0, menuid, HOTLIST_CLEARSELECTION_MENUITEM, 0);         /* unfade clear selection */
d2603 7
a2609 5
    menu_set_entry_text(0, menuid, HOTLIST_URL_MENUITEM, "Selection");    /* Multiple items selected */
    menu_set_fade(0, menuid, HOTLIST_URL_MENUITEM, 0);                    /* unfade URL '' */
    menu_set_fade(0, menuid, HOTLIST_CLEARSELECTION_MENUITEM, 0);         /* unfade clear selection */
    toolbox_create_object(0, "HLSlctmenu", &submenu_id);
    menu_set_sub_menu_show(0, menuid, HOTLIST_URL_MENUITEM, submenu_id);
d2614 6
d2652 1
a2652 1
  if (event_code == HotlistMenuOpened)
d2793 1
a2793 1
  if (fileptr == NULL) return _kernel_last_oserror();
d2975 3
a2977 1
      e = _kernel_last_oserror();
d2992 2
a2993 1
      e = make_no_memory_error(2);
d3003 3
a3005 1
      e = _kernel_last_oserror();
d3294 1
a3294 1
                                          HotlistMenuOpened,
d3299 1
a3299 1
                                          HotlistMenuClosed,
d3306 2
a3307 2
                                          HotlistSelectAll,
                                          hotlist_menu_selectall_handler,
d3311 2
a3312 2
                                          HotlistClearSelect,
                                          hotlist_menu_clearselect_handler,
d3316 1
a3316 1
                                          HotlistOpenAll,
d3321 1
a3321 1
                                          HotlistCloseAll,
d3326 1
a3326 1
                                          HotlistDelete,
d3333 1
a3333 1
                                          HotlistShowEditURL,
d3338 1
a3338 1
                                          HotlistShowRenameDirectory,
d3343 1
a3343 1
                                          HotlistShowNewURL,
d3348 1
a3348 1
                                          HotlistShowNewDirectory,
d3355 1
a3355 1
                                          HotlistNewEditURLOk,
d3360 2
a3361 2
                                          HotlistNewRenameDirectoryOk,
                                          hotlist_newren_directory_handler,
d3365 2
a3366 2
                                          HotlistNewEditURLCancel,
                                          hotlist_reset_url_handler,
d3370 1
a3370 1
                                          HotlistNewRenameDirectoryCancel,
d3375 1
a3375 1
                                          HotlistShowDesc,
d3380 1
a3380 1
                                          HotlistShowURLs,
a3383 8
  RetError(event_register_message_handler(Wimp_MDataSaveAck,
                                          hotlist_data_save_ack_handler,
                                          NULL));

  RetError(event_register_message_handler(Wimp_MRAMFetch,
                                          hotlist_ram_fetch_handler,
                                          NULL));

d3385 1
a3385 1
                                          HotlistEscape,
d3493 1
a3493 1
/* hotlist_menu_selectall_handler()              */
d3502 1
a3502 1
static int hotlist_menu_selectall_handler(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
d3504 1
a3504 2
  hotlist_item * item;
  ObjectId       sub_menu;
d3506 1
a3506 1
  if (!hotlist_root->data.directory_content) return 0;
d3508 1
a3508 1
  item = hotlist_find_item(hotlist_root->data.directory_content, menu_itemno);
d3510 2
a3511 3
  if (item && item->parent)
  {
    item = item->parent->data.directory_content;
d3513 1
a3513 9
    while (item)
    {
      item->flags |= HOTLIST_G_IS_SELECTED | HOTLIST_G_REDRAW_NOW;
      if (item->type == hl_directory) hotlist_set_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);

      item = item->next;
    }

    hotlist_redraw_now();
d3515 1
a3515 2
    menu_get_sub_menu_show(0, id_block->self_id, HOTLIST_URL_MENUITEM, &sub_menu);
    menu_set_sub_menu_show(0, id_block->self_id, HOTLIST_URL_MENUITEM, 0);
d3517 1
a3517 1
    if (sub_menu) toolbox_delete_object(0, sub_menu);
d3519 1
a3519 2
    hotlist_set_menu_details(id_block->self_id);
  }
d3521 1
a3521 1
  menu_select = 0;
d3527 1
a3527 1
/* hotlist_menu_clearselection_handler()         */
d3533 1
a3533 1
static int hotlist_menu_clearselect_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d3535 10
d3546 5
a3550 3
  menu_set_entry_text(0, id_block->self_id, 0x05, "URL ''");
  menu_set_fade(0, id_block->self_id, 0x05, 1); /* Fade URL'' selection */
  menu_set_fade(0, id_block->self_id, 0x01, 1); /* Fade clear selection */
d4019 32
a4050 3
/* This function is called to start a drag       */
/* operation from the hotlist window.  A drag    */
/* box will be initiated bounding all selected   */
d4054 1
a4054 1
static _kernel_oserror *_hotlist_start_drag(void)
d4056 13
a4068 11
  _kernel_swi_regs regs;
  _kernel_oserror *err;
  unsigned int item_height, item_dir_width, item_url_width;
  hotlist_item *item;
  WimpDragBox box;
  WimpGetPointerInfoBlock pointerblock;
  unsigned int xmin, xmax, xlow, xhigh;
  int top, bottom, item_no, xorigin, yorigin, screenwidth, screenheight, tempint;
  WimpGetWindowStateBlock state;
  int redraw_params[4];
  int width, height;
d4070 2
a4071 1
  wimp_get_pointer_info(&pointerblock);                          /* Read pointer position */
d4073 2
a4074 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d4076 1
a4076 1
  item = hotlist_find_selected_item();
d4078 10
a4087 3
  top = -item_no * item_height;
  bottom = -(item_no + 1) * item_height;
  if (item_no < 0) return NULL;                                  /* Selected item not found, this should never happen */
d4090 4
d4095 1
d4098 3
a4100 1
    while(item)
d4104 1
d4107 1
a4107 1
        if (xlow < xmin) xmin = xlow;                              /* Should never happen, left hand side should not be ragged */
d4109 1
d4116 5
a4120 2
  show_error(window_get_wimp_handle(0, hotlist_windowid, &state.window_handle));
  wimp_get_window_state(&state);
d4125 4
a4128 6
  _swix(OS_ReadModeVariable, _INR(0,1) | _OUT(2), -1, 11, &screenwidth);
  _swix(OS_ReadModeVariable, _INR(0,1) | _OUT(2), -1, 12, &screenheight);
  _swix(OS_ReadModeVariable, _INR(0,1) | _OUT(2), -1, 4, &tempint);
  screenwidth <<= tempint;
  _swix(OS_ReadModeVariable, _INR(0,1) | _OUT(2), -1, 5, &tempint);
  screenheight <<= tempint;
d4130 8
a4137 1
  if (_kernel_osbyte(161, 28, 0) & (1<<(8+1))) /* solid drag */
d4139 5
d4146 2
d4161 15
a4175 9
      box.dragging_box.xmin = xmin-xorigin;                          /* box shape */
      box.dragging_box.ymin = bottom-yorigin;
      box.dragging_box.xmax = xmax-xorigin;
      box.dragging_box.ymax = top-yorigin;

      redraw_params[0] = (int)hotlist_find_selected_item();
      redraw_params[1] = (int)item_height;
      redraw_params[2] = (int)item_dir_width;
      redraw_params[3] = (int)item_url_width;
d4178 14
a4191 10
      regs.r[1] = (int)hotlist_drag_renderer;
      regs.r[2] = (int)redraw_params;
      regs.r[3] = (int)&(box.dragging_box);

      if (!_kernel_swi(DragAnObject_Start, &regs, &regs))
      {
        hotlist_dragging = HOTLIST_SOLID_DRAG_OBJECT;                /* Set global variable saying we are currently dragging */
                                                                     /* so we know whether to process a user_drag_box event  */
        return NULL;
      }
d4195 22
a4216 11
      if (!read_sprite_size(SELECTION_SPRITE, &width, &height))
      {
        box.dragging_box.xmin = pointerblock.x - (width/2 + 10);                          /* box shape */
        box.dragging_box.ymin = pointerblock.y - (height/2 + 10);
        box.dragging_box.xmax = pointerblock.x + (width/2 + 10);
        box.dragging_box.ymax = pointerblock.y + (height/2 + 10);

        regs.r[0] = (1<<0) | (1<<2) | (1<<6) | (1<<7);
        regs.r[1] = (int)sprite_block; /* browser sprite area */
        regs.r[2] = (int)"package";
        regs.r[3] = (int)&(box.dragging_box);
d4218 6
a4223 6
        if (!_kernel_swi(DragASprite_Start, &regs, &regs))
        {
          hotlist_dragging = HOTLIST_SOLID_DRAG_SPRITE;
          return NULL;
        }
      }
d4226 3
a4229 14
  box.dragging_box.xmin = xmin-xorigin;                          /* box shape */
  box.dragging_box.xmax = xmax-xorigin;
  box.dragging_box.ymin = bottom-yorigin;
  box.dragging_box.ymax = top-yorigin;
  box.parent_box.xmin   = -(pointerblock.x - box.dragging_box.xmin);  /* Bounding box for dragged box */
  box.parent_box.xmax   = screenwidth+(box.dragging_box.xmax - pointerblock.x);
  box.parent_box.ymin   = -(pointerblock.y - box.dragging_box.ymin);
  box.parent_box.ymax   = screenheight+(box.dragging_box.ymax - pointerblock.y);
  err = wimp_drag_box(&box);                                           /* start drag box */
  if (err) return err;
  hotlist_dragging = HOTLIST_BOX_DRAG;                           /* Set global variable saying we are currently dragging */
                                                                 /* so we know whether to process a user_drag_box event */
  return NULL;
}
d4231 15
a4245 13
void hotlist_start_drag(void)
{
  _kernel_oserror *err;
  err = _hotlist_start_drag();
  if (err)
  {
    show_error_ret(err);
    return;
  }
  /* Register NULL handler */
  show_error_ret(hotlist_autoscroll(0)); /* Reset autoscroll */
  register_null_claimant(Wimp_ENull, hotlist_null_handler, NULL);
}
d4247 1
a4247 12
/*************************************************/
/* hotlist_is_inside()                           */
/*                                               */
/* Checks if one hotlist_item is held inside     */
/* the directory structure of another            */
/* hotlist_item                                  */
/*                                               */
/* Parameters: pointer to possibly inside item   */
/*             pointer to outside item           */
/*                                               */
/* Returns:    1 if item is inside, 0 otherwise  */
/*************************************************/
d4249 1
a4249 1
/* This routine is no longer used but the code will be left incase it is needed */
d4251 3
a4253 9
//  static int hotlist_is_inside(hotlist_item *inside, hotlist_item *outside)
//  {
//    while(inside)
//    {
//      if (inside == outside) return 1;
//      inside = inside->parent;
//    }
//    return 0;
//  }
d4258 1
a4258 1
/* Terminates any hotlist drag in progress       */
d4261 1
a4261 1
static int hotlist_drag_stop_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d4314 7
a4320 3
    /* Stop drag an object */
    _swix(DragAnObject_Stop, 0);
    deregister_null_claimant(Wimp_ENull, hotlist_null_handler, NULL);
d4324 6
a4329 3
    /* Stop drag a sprite */
    _swix(DragASprite_Stop, 0);
    deregister_null_claimant(Wimp_ENull, hotlist_null_handler, NULL);
d4333 12
a4344 5
    /* Stop drag box */
    wimp_drag_box(NULL);
    deregister_null_claimant(Wimp_ENull, hotlist_null_drag_select_handler, NULL);
    hotlist_clear_flags(hotlist_root->data.directory_content, hl_ALL, HOTLIST_G_DRAG_SELECTED);
    hotlist_redraw_now();
d4355 6
a4360 6
/* completes.  If the drag is one started by the */
/* hotlist section it is processed.  Dropping    */
/* the drag in the hotlist window will move or   */
/* copy the items being dragged.                 */
/* Dropping the drag in any other window is      */
/* currently ignored                             */
d4367 3
a4369 2
  ObjectId                  window_handle;
  ComponentId               comp;
d4371 1
a4371 1
  unsigned int              top,         bottom,         bottom2;
d4374 2
a4375 1
  int                       tempint,     position;
a4376 3
  int                       dragging;
  hotlist_item            * targetitem;
  hotlist_item            * sourceitem;
d4460 3
d4467 1
d4471 2
d4475 6
d4483 5
a4487 5
  show_error(window_wimp_to_toolbox(0,
                                    pointerblock.window_handle,
                                    pointerblock.icon_handle,
                                    &window_handle,
                                    &comp));
d4489 1
a4489 1
  if (window_handle == hotlist_windowid)
d4491 8
a4498 2
    /* Drag was dropped in hotlist window */
    if (pointerblock.icon_handle != -1) return 0; /* Only understand drops on workspace */
a4499 1
    hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d4501 7
a4507 5
    wimp_get_window_state(&state);
    winx = pointerblock.x + (state.xscroll - state.visible_area.xmin);
    winy = pointerblock.y + (state.yscroll - state.visible_area.ymax);
    targetitem = hotlist_find_item(hotlist_root->data.directory_content, -winy/item_height);
    top = -winy/item_height;
d4510 1
d4513 6
d4520 2
a4521 1
      if (targetitem->type == hl_directory && winx >= xmin && winx <= xmin+item_dir_width)
d4523 7
a4529 1
        position = HOTLIST_POSITION_BEGINNING; /* Put in directory */
d4534 5
a4538 1
          position = HOTLIST_POSITION_AFTER;          /* Put items after target item */
d4540 5
a4544 1
          position = HOTLIST_POSITION_BEFORE;         /* Put items before target item */
d4549 2
d4552 1
a4552 1
      position = HOTLIST_POSITION_END;
d4555 5
a4559 3
    tempint = hotlist_find_no_from_item(hotlist_find_selected_item());
    if (tempint < top) top = tempint;
    bottom = hotlist_count_displayed_items(hotlist_root->data.directory_content);
d4561 3
a4563 1
    if (targetitem->flags & HOTLIST_G_IS_SELECTED) return 0; /* do nothing if dropped on selected items */
d4565 1
a4565 1
    sourceitem = hotlist_find_selected_item();
d4567 1
a4567 1
    sourceitem->flags &= ~HOTLIST_G_IS_SELECTED;
d4571 1
a4571 1
      /* Move selected items */
d4573 3
a4575 2
      hotlist_move_item(sourceitem, targetitem, position);                      /* Move first item to specified position */
                                                                                /* before/after/in target                */
d4577 1
a4577 1
      if (sourceitem->type == hl_directory) hotlist_clear_flags(sourceitem->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
d4579 14
a4592 1
      targetitem = sourceitem;
a4593 6
      while((sourceitem = hotlist_find_selected_item()) != NULL)
      {
        sourceitem->flags &= ~HOTLIST_G_IS_SELECTED;
        hotlist_move_item(sourceitem, targetitem, HOTLIST_POSITION_AFTER);      /* Move all subsequent items to follow   */
                                                                                /* first moved item                      */
        if (sourceitem->type == hl_directory) hotlist_clear_flags(sourceitem->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
d4595 7
d4603 3
a4605 1
      hotlist_modified(HL_MODIFIED_MOVE);
d4609 6
a4614 1
      /* Copy selected items */
d4616 4
d4621 11
a4631 3
      hotlist_copy_item(sourceitem, targetitem, position, &targetitem);         /* Copy first item to specified position */
                                                                                /* before/after/in target                */
      if (sourceitem->type == hl_directory) hotlist_clear_flags(sourceitem->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
d4633 10
a4642 10
      while((sourceitem = hotlist_find_selected_item()) != NULL)
      {
        sourceitem->flags &= ~HOTLIST_G_IS_SELECTED;
        hotlist_copy_item(sourceitem,                                           /* Copy all subsequent items to follow   */
                          targetitem,                                           /* first copied item                     */
                          HOTLIST_POSITION_AFTER,
                          &targetitem);
        if (sourceitem->type == hl_directory) hotlist_clear_flags(sourceitem->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
      }
      hotlist_modified(HL_MODIFIED_COPY);
d4645 2
a4646 3
    bottom2 = hotlist_count_displayed_items(hotlist_root->data.directory_content);
    if (bottom2 > bottom) bottom = bottom2;
    hotlist_redraw_items(top, bottom);
d4648 4
d4655 7
a4661 1
    if (hotlist_count_selected_items() == 1 && (sourceitem = hotlist_find_selected_item())->type == hl_url)
d4663 3
a4665 1
      /* Dropped in non hotlist window - save as a URI file */
d4670 4
a4673 2
      /* Can't save URI file when saving more than one URL so save HTML file instead*/
      hotlist_initiate_html_save("Hotlist");
a4674 1
    /* Drag was dropped in non-hotlist window */
d4683 1
a4683 1
/* Auto scrolls a window                         */
d4686 1
a4686 1
/*             scroll or 0 to reset autoscroll   */
d4689 1
a4689 1
_kernel_oserror *hotlist_autoscroll(int window)
d5193 4
a5196 2
/* Selects show descriptions and redraws hotlist */
/* window and menu to reflect this               */
d5199 1
a5199 1
static int hotlist_show_descriptions_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d5201 2
d5204 8
a5211 1
  hotlist_set_menu_details(id_block->parent_id);
d5213 6
a5218 2
  hotlist_redraw_items(0,
                       hotlist_count_displayed_items(hotlist_root->data.directory_content));
d5225 4
a5228 2
/* Selects show urls and redraws hotlist  window */
/* and menu to reflect this                      */
d5231 1
a5231 1
static int hotlist_show_urls_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d5233 2
d5236 8
a5243 1
  hotlist_set_menu_details(id_block->parent_id);
d5245 5
a5249 2
  hotlist_redraw_items(0,
                       hotlist_count_displayed_items(hotlist_root->data.directory_content));
d5259 2
a5260 1
/* as is appropriate. ie. (effectivly eor'd)     */
d5266 2
a5267 1
/* Parameters: Pointer to hotlist_item           */
d5272 1
a5272 1
  while(item)
d5277 1
d5282 2
a5310 3
/* Data transfer routines follow */


a5381 171
/* hotlist_data_save_ack_handler()               */
/*                                               */
/* Handles Message_DataSaveAck. Care must be     */
/* taken to ensure the routine only traps        */
/* messages that it sent out itself.             */
/*                                               */
/* Parameters are as standard for a Wimp message */
/* handler.                                      */
/*************************************************/

static int hotlist_data_save_ack_handler(WimpMessage * message, void * handle)
{
  _kernel_oserror * e;
  int               save_type;

  /* Don't do anything if the hotlist isn't saving right now */

  if (hotlist_save_type == HL_SAVE_NONE) return 0;

  /* Must be *sure* the save type is cleared, or otherwise this */
  /* message handler will clash with the main browser Protocols */
  /* source handler for the same.                               */

  save_type         = hotlist_save_type;
  hotlist_save_type = HL_SAVE_NONE;

  /* Now deal with the individual cases */

  switch (save_type)
  {
    default:
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Save type %d not recognised in hotlist_data_save_ack_handler",
                save_type);

        show_error_ret(&erb);

      #endif

      return 0;
    }
    break;

    /* Save the item as a URI file */

    case HL_SAVE_URI:

    if (hotlist_save_item)
    {
      /* Save the URI file */

      e = save_save_uri(message->data.data_save_ack.leaf_name,
                        hotlist_save_item->data.url,
                        0);

      hotlist_save_item = NULL;

      /* Report any errors */

      ChkError(e);

      /* Send out the required Message_DataLoad */

      message->hdr.action_code = Wimp_MDataLoad;
      message->hdr.your_ref    = message->hdr.my_ref;

      e = wimp_send_message(Wimp_EUserMessageRecorded,
                            message,
                            message->hdr.sender,
                            0,
                            NULL);

      /* Again, report any errors from this */

      if (e)
      {
        remove(message->data.data_save_ack.leaf_name);
        show_error_cont(e); /* Jumps back to poll loop */
      }
    }
    break;

    /* Save the items as an HTML file */

    case HL_SAVE_HTML:
    {
      /* Save the file */

      e = hotlist_save_hotlist(message->data.data_save_ack.leaf_name, 1);

      hotlist_clear_selection();

      /* Report any errors */

      ChkError(e);

      /* Send out the required Message_DataLoad in reply */

      message->hdr.action_code = Wimp_MDataLoad;
      message->hdr.your_ref    = message->hdr.my_ref;

      e = wimp_send_message(Wimp_EUserMessageRecorded,
                            message,
                            message->hdr.sender,
                            0,
                            NULL);

      /* Again, report any errors from this */

      if (e)
      {
        remove(message->data.data_save_ack.leaf_name);
        show_error_cont(e); /* Jumps back to poll loop */
      }
    }
    break;
  }

  return 1;
}

/*************************************************/
/* hotlist_ram_fetch_handler()                   */
/*                                               */
/* Handles Message_RAMFetch messages,            */
/* transferring URI files directly to another    */
/* application.                                  */
/*                                               */
/* Parameters are as standard for a Wimp         */
/* message handler.                              */
/*************************************************/

static int hotlist_ram_fetch_handler(WimpMessage * message, void * handle)
{
  _kernel_oserror * e;

  /* If we know we are transferring data, then claim the event */

  if (hotlist_save_type == HL_SAVE_URI && hotlist_save_item)
  {
    e = save_transfer_uri(hotlist_save_item->data.url,
                          0,
                          &hotlist_ram_transfer_sent,
                          message);

    /* We have finished if the call returns an error or fills in */
    /* hotlist_ram_transfer_sent with -1 to signal successful    */
    /* transmission of all of the file.                          */

    if (e || hotlist_ram_transfer_sent == -1)
    {
      hotlist_save_item         = NULL;
      hotlist_ram_transfer_sent = 0;

      show_error_ret(e);
    }

    return 1;
  }

  /* If we don't know about this mesage, don't claim it */

  return 0;
}

/*************************************************/
d5399 1
a5399 1
/* Parameters: screen relative x position        */
d5401 1
a5401 1
/*             screen relative y position        */
d5406 1
a5406 1
/*             Pointer to the URL itself;        */
d5411 8
a5418 5
  _kernel_oserror *e;
  WimpGetWindowStateBlock state;
  int winx, winy, top, position;
  hotlist_item * targetitem;
  unsigned int item_height, item_dir_width, item_url_width;
d5432 1
d5434 3
a5436 2
  targetitem = hotlist_find_item(hotlist_root->data.directory_content, -winy/item_height);
  top = -winy/item_height;
d5439 1
d5444 3
a5446 1
      /* Put item after target item */
d5451 2
a5452 1
      /* Put item before target item */
d5459 2
a5460 1
    position = HOTLIST_POSITION_END;
a5464 4
  e = hotlist_new_url(targetitem,
                      position,
                      description,
                      url);
d5466 6
a5471 1
  if (!e) hotlist_preopen();
d5480 1
a5480 1
      hotlist_redraw_now();
d5487 3
a5489 2
      hotlist_redraw_items(-winy/item_height - 1,
                           hotlist_count_displayed_items(hotlist_root->data.directory_content));
d5494 3
a5496 1
  if (!e) return hotlist_modified(HL_MODIFIED_ADD);
d5498 1
a5498 1
  return e;
@


1.15
log
@Slight change to when scrolling is canceled in hotlist_autoscroll()
@
text
@d48 1
d50 1
a183 1
static void              hotlist_clear_selection         (void);
d2053 1
a2053 1
static void hotlist_clear_selection(void)
d3509 3
a3511 3
#ifdef TRACE
  Printf("hotlist_show_editurl_handler\n");
#endif
d3536 3
a3538 3
#ifdef TRACE
  Printf("hotlist_show_rendirectory_handler\n");
#endif
d3562 4
a3565 3
#ifdef TRACE
  Printf("hotlist_show_newurl_handler\n");
#endif
d3587 4
a3590 3
#ifdef TRACE
  Printf("hotlist_show_newdirectory_handler\n");
#endif
d3745 1
d4072 18
d4096 4
a4099 2

  switch(hotlist_dragging)
d4101 2
d4104 16
a4119 1
    return 0;
d4121 1
a4121 1

a4125 1
    hotlist_dragging = 0;
d4127 1
a4127 1

a4131 1
    hotlist_dragging = 0;
d4133 1
a4133 1

a4139 1
    hotlist_dragging = 0;
d4142 1
d4160 17
a4176 8
  unsigned int item_height, item_dir_width, item_url_width;
  ObjectId window_handle;
  ComponentId comp;
  WimpGetPointerInfoBlock pointerblock;
  WimpGetWindowStateBlock state;
  int winx, winy, shift;
  unsigned int top, bottom, bottom2, tempint, position, xmin, xmax;
  hotlist_item *targetitem, *sourceitem;
d4178 3
a4180 1
  _swix(OS_Byte, _INR(0,1) | _OUT(1), 121, 128, &shift); /* Check if SHIFT is pressed */
d4184 3
a4186 1
  show_error_ret(hotlist_autoscroll(0)); /* Reset autoscrolling (To restore pointer if necessary) */
d4188 20
a4207 1
  switch(hotlist_dragging)
d4209 21
d4231 3
a4233 1
    _swix(DragAnObject_Stop, 0);
d4236 2
d4239 3
a4241 1
    _swix(DragASprite_Stop, 0);
d4244 2
d4247 3
a4249 2
    deregister_null_claimant(Wimp_ENull, hotlist_null_drag_select_handler, NULL);
    hotlist_convert_drag_selection(hotlist_root->data.directory_content);
d4251 2
a4252 4
    return 0;
    break;

    default:
a4264 1
  hotlist_dragging = 0;
d4403 1
a4403 1

d4405 2
a4406 2

  /* Reset autoscroll handling if requested */
d4418 1
a4418 1

d4425 2
a4426 2


d4447 1
a4447 1

d4449 1
a4449 1

d4497 1
a4497 1

d4511 1
a4511 1

d4523 1
a4523 1

d4547 1
a4547 1

d4570 1
a4570 1

d4985 6
d4993 1
a4993 1
static _kernel_oserror *hotlist_initiate_uri_save(hotlist_item *item)
d4995 3
a4997 4
  WimpGetPointerInfoBlock block;
  WimpMessage message;
  int new_task_handle;
  _kernel_oserror *e;
d5001 17
a5017 23
  message.hdr.size        = sizeof(WimpMessage);
  message.hdr.your_ref    = 0;
  message.hdr.action_code = Wimp_MDataSave;

  message.data.data_save.destination_window = block.window_handle;
  message.data.data_save.destination_icon   = block.icon_handle;
  message.data.data_save.destination_x      = block.x;
  message.data.data_save.destination_y      = block.y;
  message.data.data_save.estimated_size     = strlen(item->data.url)+1;
  message.data.data_save.file_type          = 0xf91; /* URI file - to be replaced with a defined value */
  urlutils_leafname_from_url(item->data.url, message.data.data_save.leaf_name, 212);

  RetError(wimp_send_message(Wimp_EUserMessageRecorded,
                             &message,
                             block.window_handle,
                             block.icon_handle,
                             &new_task_handle));

  hotlist_save_item = item;
  hotlist_ram_transfer_sent = 0;
  hotlist_save_type = HL_SAVE_URI;

  return NULL;
d5022 6
d5030 1
a5030 1
static _kernel_oserror *hotlist_initiate_html_save(char *filename)
d5032 3
a5034 4
  WimpGetPointerInfoBlock block;
  WimpMessage message;
  int new_task_handle;
  _kernel_oserror *e;
d5038 1
a5038 18
  message.hdr.size        = sizeof(WimpMessage);
  message.hdr.your_ref    = 0;
  message.hdr.action_code = Wimp_MDataSave;

  message.data.data_save.destination_window = block.window_handle;
  message.data.data_save.destination_icon   = block.icon_handle;
  message.data.data_save.destination_x      = block.x;
  message.data.data_save.destination_y      = block.y;
  message.data.data_save.estimated_size     = -1; /* Dunno how big it's going to be */
  message.data.data_save.file_type          = FileType_HTML;

  strncpy(message.data.data_save.leaf_name, filename, 212);

  RetError(wimp_send_message(Wimp_EUserMessageRecorded,
                             &message,
                             block.window_handle,
                             block.icon_handle,
                             &new_task_handle));
d5040 1
a5040 2
  hotlist_ram_transfer_sent = 0;
  hotlist_save_type = HL_SAVE_HTML;
d5042 9
a5050 1
  return NULL;
d5055 7
d5064 1
a5064 1
static int hotlist_data_save_ack_handler(WimpMessage *message, void *handle)
d5066 15
a5080 3
  FILE *fileptr;
  int new_task_handle;
  _kernel_oserror *e;
d5082 1
a5082 1
  switch(hotlist_save_type)
d5084 20
d5105 1
d5108 9
a5116 4
      fileptr = fopen(message->data.data_save_ack.leaf_name, "w");
      if (fileptr)
      {
        fprintf(fileptr, hotlist_save_item->data.url);
d5118 1
a5118 7
        if (fclose(fileptr))
        {
          show_error_ret(_kernel_last_oserror());
          hotlist_save_item = NULL;
          hotlist_save_type = HL_SAVE_NONE;
          return 1;
        }
d5120 1
a5120 5
        e = _swix(OS_File,
                  _INR(0,2),
                  18,
                  message->data.data_save_ack.leaf_name,
                  0xf91);
d5122 2
a5123 7
        if (e)
        {
          show_error_ret(e);
          hotlist_save_item = NULL;
          hotlist_save_type = HL_SAVE_NONE;
          return 1;
        }
d5125 5
a5129 2
        message->hdr.action_code = Wimp_MDataLoad;
        message->hdr.your_ref    = message->hdr.my_ref;
d5131 1
a5131 5
        e = wimp_send_message(Wimp_EUserMessageRecorded,
                              message,
                              message->hdr.sender,
                              0,
                              &new_task_handle);
d5133 1
a5133 13
        if (e)
        {
          show_error_ret(e);
          if (remove(message->data.data_save_ack.leaf_name))
          {
            show_error_ret(_kernel_last_oserror());
          }
          hotlist_save_item = NULL;
          hotlist_save_type = HL_SAVE_NONE;
          return 1;
        }
      }
      else
d5135 2
a5136 1
        show_error_ret(_kernel_last_oserror());
a5137 4

      hotlist_save_item = NULL;
      hotlist_save_type = HL_SAVE_NONE;
      return 1;
d5141 2
d5144 6
d5151 1
a5151 1
    e = hotlist_save_hotlist(message->data.data_save_ack.leaf_name, 1);
d5153 3
a5155 1
    hotlist_clear_selection();
d5157 2
a5158 5
    if (e)
    {
      show_error_ret(e);
      hotlist_save_type = HL_SAVE_NONE;
    }
d5160 5
a5164 2
    message->hdr.action_code = Wimp_MDataLoad;
    message->hdr.your_ref    = message->hdr.my_ref;
d5166 1
a5166 5
    e = wimp_send_message(Wimp_EUserMessageRecorded,
                          message,
                          message->hdr.sender,
                          0,
                          &new_task_handle);
d5168 1
a5168 4
    if (e)
    {
      show_error_ret(e);
      if (remove(message->data.data_save_ack.leaf_name))
d5170 2
a5171 1
        show_error_ret(_kernel_last_oserror());
a5172 1
      hotlist_save_type = HL_SAVE_NONE;
a5173 6

    return 1;

    break;

    default:
d5177 1
a5177 1
  return 0;
d5182 7
d5191 1
a5191 1
static int hotlist_ram_fetch_handler(WimpMessage *message, void *handle)
d5193 3
a5195 2
  int left, towrite, new_task_handle;
  _kernel_oserror *e;
d5199 4
a5202 5
    /* Calculate the number of bytes left to send */
    /* Don't include the terminating null as it is not required for URI files*/
    left = (strlen(hotlist_save_item->data.url)) - hotlist_ram_transfer_sent;
    /* Use the smaller of the buffer size and the number of bytes to write */
    towrite = message->data.ram_fetch.buffer_size > left ? left : message->data.ram_fetch.buffer_size;
d5204 3
a5206 5
    e = wimp_transfer_block(task_handle,
                            (char*)(hotlist_save_item->data.url) + hotlist_ram_transfer_sent,
                            message->hdr.sender,
                            message->data.ram_fetch.buffer,
                            towrite);
d5208 1
a5208 1
    if (e)
d5210 2
a5211 14
      hotlist_save_item = NULL;
      show_error_ret(e);
      return 1;
    }

    message->hdr.your_ref             = message->hdr.my_ref;
    message->hdr.action_code          = Wimp_MRAMTransmit;
    message->data.ram_transmit.nbytes = towrite;

    e = wimp_send_message(Wimp_EUserMessage,
                          message,
                          message->hdr.sender,
                          0,
                          &new_task_handle);
a5212 3
    if (e)
    {
      hotlist_save_item = NULL;
a5213 1
      return 1;
d5216 2
a5217 7
    /* If no bytes were transmitted this is the last part of the ram transfer */
    if (!left)
    {
      hotlist_save_item = NULL;
      hotlist_ram_transfer_sent = 0;
      return 1;
    }
d5219 1
a5219 2
    /* Increase the total number of bytes send by the number just send */
    hotlist_ram_transfer_sent += towrite;
a5220 2
    return 1;
  }
d5252 1
a5252 1
_kernel_oserror * hotlist_add_position(int x, int y, char *description, char *url)
d5272 1
a5272 1
  RetError(hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width));
@


1.14
log
@Pointer now remains normal if autoscrolling will not occur
@
text
@a3741 1
    //toolbox_hide_object(0, id_block->ancestor_id);
d4468 1
d5188 1
a5188 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
@


1.13
log
@Canceling of drags implemented
@
text
@d4300 2
a4301 1
  WimpGetWindowStateBlock state;
d4303 1
a4303 2
  int x, y;
  int position;
d4305 2
a4306 3
  _kernel_oserror *e;
  ObjectId over_window;

d4308 2
a4309 1

d4313 1
a4313 1
      Printf("hotlist_autoscroll: resetting\n");
d4321 1
a4321 1

d4328 3
a4330 3

  scroll_changed = 0;

d4350 4
a4353 4

  #ifdef TRACE
  Printf("Pointer is ");
  switch(position)
d4355 14
a4368 11
    case 0:
    Printf("Outside visible area");
    break;
    case 1:
    Printf("inside non scrolling region");
    break;
    case 2:
    Printf("Inside scrolling region");
    break;
  }
  Printf(" of scrolling window\n");
d4370 7
a4376 2
  Printf("scrolling = %d\n", scrolling);
  #endif
d4378 1
a4378 3
  if (!scrolling)
  {
    if (window == over_window)
d4380 2
a4381 1
      if (position == 2)
d4383 2
a4384 19
        /* Check timer, see if it's time to start scrolling */
        RetError(_swix(OS_ReadMonotonicTime, _OUTR(0, 0), &autoscroll_newtime));
        if ((autoscroll_newtime - autoscroll_oldtime) > AUTOSCROLL_DELAY)
        {
          if (mouse_shape != Mouse_Shape_Scrolling)
          {
            mouse_set_pointer_shape(Mouse_Shape_Scrolling);
            mouse_shape = Mouse_Shape_Scrolling;
          }
          scrolling = 1;
        }
        else
        {
          if (mouse_shape != Mouse_Shape_ToScroll)
          {
            mouse_shape = Mouse_Shape_ToScroll;
            mouse_set_pointer_shape(Mouse_Shape_ToScroll);
          }
        }
d4386 4
a4389 1
      else
d4391 2
a4392 3
        /* Set scroll timer to zero */
        RetError(_swix(OS_ReadMonotonicTime, _OUTR(0, 0), &autoscroll_oldtime));
        if (mouse_shape != Mouse_Shape_Normal)
d4394 2
a4395 2
          mouse_set_pointer_shape(Mouse_Shape_Normal);
          mouse_shape = Mouse_Shape_Normal;
d4399 6
a4404 1
    else
d4413 3
a4415 4
  }
  else
  {
    if (position == 1)
a4416 1
      /* Stop scrolling */
d4425 4
a4428 1
    else
d4430 2
a4431 3
      /* Scroll a bit */

      if (y > state.visible_area.ymax - HOTLIST_SCROLL_BOUNDARY_SIZE)
d4433 1
a4433 6
        /* Top */
        if (state.yscroll < extent.ymax)
        {
          scroll_changed = 1;
          state.yscroll += (y - (state.visible_area.ymax - HOTLIST_SCROLL_BOUNDARY_SIZE));
        }
d4437 1
a4437 1
        if (y < state.visible_area.ymin + HOTLIST_SCROLL_BOUNDARY_SIZE)
d4439 2
a4440 7
          /* Bottom */

          if (state.yscroll > extent.ymin + (state.visible_area.ymax - state.visible_area.ymin))
          {
            scroll_changed = 1;
            state.yscroll -= ((state.visible_area.ymin + HOTLIST_SCROLL_BOUNDARY_SIZE) - y);
          }
d4443 15
a4457 2

      if (x > state.visible_area.xmax - HOTLIST_SCROLL_BOUNDARY_SIZE)
d4459 2
a4460 6
        /* Right */
        if (state.xscroll < extent.xmax - (state.visible_area.xmax - state.visible_area.xmin))
        {
          scroll_changed = 1;
          state.xscroll += (x - (state.visible_area.xmax - HOTLIST_SCROLL_BOUNDARY_SIZE));
        }
d4462 4
a4465 1
      else
d4467 2
a4468 9
        if (x < state.visible_area.xmin + HOTLIST_SCROLL_BOUNDARY_SIZE)
        {
          /* Left */
          if (state.xscroll > extent.xmin)
          {
            scroll_changed = 1;
            state.xscroll -= ((state.visible_area.xmin + HOTLIST_SCROLL_BOUNDARY_SIZE) - x);
          }
        }
d4472 1
a4472 7

  if (scroll_changed)
  {
    RetError(toolbox_get_parent(0, window, &parent, &component));
    RetError(toolbox_show_object(0, window, Toolbox_ShowObject_FullSpec, &(state.visible_area), parent, component));
  }

@


1.12
log
@File fetches now set DEADDEAD during the fetch, Data if it is aborted, or
an appropriate filetype when finished. If the fetcher routines return a
zero or data filetype, the browser looks at a set of hard coded filename
extensions to try and determine if there's a better filetype to use
(urlutils_filetype_from_url) - since this is a centralised routine it can
use a Mime mapping system (or be removed entirely) as and when one becomes
available.

You can now drag URI / URL files to the Hotlist window to add them to the
list. They are added roughly where dragged to. (NB, note that I renamed
the function to return the window ID - just being picky; it matches other
similar functions now). Oh, and hotlist_add_position actually works now ;-)

The global history will save when titles are added, as well as when a URL
is added. Before, a browser crash could mean a title got dropped out
of the history file even if SaveHistory was set to 'always'.

SaveObject sources have been added but nothing references them or links
them in yet - they're not finished. Mostly checking this one in because
of the hotlist changes.
@
text
@d123 1
d1083 1
a1083 1
      if (list->flags & ~flags != list->flags)
d3251 5
d4060 47
@


1.11
log
@Extended API and fixed window opening bug
@
text
@d57 1
d185 1
a185 1
static int               hotlist_window_preopen          (hl_opentype type);
d1868 1
a1868 1
  if (!e) hotlist_window_preopen(already_open);
d1985 1
a1985 1
  hotlist_window_preopen(already_open);
d2243 1
a2243 1
/* hotlist_window_preopen()                      */
d2246 7
a2252 10
/* the hotlist window.  When opentype is         */
/* not_open the window is opened as large as is  */
/* required to show all items.  When opentype is */
/* already_open the window size will grow enough */
/* to allow all items to fit but its screen size */
/* will not change, if the window needs to       */
/* it will do so but its work area will not get  */
/* any smaller than the current visible area     */
/*                                               */
/* Parameters: opentype                          */
d2255 1
a2255 1
/*             0 if it was closed                */
d2258 1
a2258 1
static int hotlist_window_preopen(hl_opentype type)
d2260 9
a2268 9
  unsigned int item_height, item_dir_width, item_url_width;
  unsigned int number, maxlen;
  BBox bbox;
  WimpGetWindowStateBlock state;
  int height, width;
  unsigned int objectstate;
  ObjectId parent_id;
  ComponentId parent_component;
  _kernel_oserror *e;
a2277 5
  if (type == already_open)
  {
    if (!objectstate & Toolbox_GetObjectState_Showing) return 0;
  }

d2307 1
a2307 1
  if (type == already_open)
d2320 1
a2320 1
  if (type == already_open)
d2339 1
a2339 1
  if (type == already_open)
d2353 1
a2353 8
  if (objectstate & Toolbox_GetObjectState_Showing)
  {
    return 1;
  }
  else
  {
    return 0;
  }
d3256 4
a3259 1
/* Opens the hotlist window.                     */
d3273 2
a3274 2
  int open, old_show_urls;
  _kernel_oserror *e;
d3284 27
a3310 1
  open = hotlist_window_preopen(not_open);
d3312 2
a3313 1
  /* Show the hotlist */
d3315 18
a3332 15
  /* Open window once to let the wimp/toolbox see what shape it really is */
  e = toolbox_show_object(0,
                          hotlist_windowid,
                          Toolbox_ShowObject_Default,
                          0,
                          0,
                          0);

  /* Open it once again in the place the window is really wanted */
  e = toolbox_show_object(0,
                          hotlist_windowid,
                          show_type,
                          type,
                          0,
                          0);
d3429 1
a3429 1
    hotlist_window_preopen(already_open);
d3457 1
a3457 1
    hotlist_window_preopen(already_open);
d3482 1
a3482 1
  hotlist_window_preopen(already_open);
d3655 1
a3655 1
    hotlist_window_preopen(already_open);
d3670 1
a3670 1
    hotlist_window_preopen(already_open);
d3721 1
a3721 1
    hotlist_window_preopen(already_open);
d3733 1
a3733 1
    hotlist_window_preopen(already_open);
d4213 1
a4213 1
    hotlist_window_preopen(already_open);
d4501 1
a4501 1
            hotlist_window_preopen(already_open);
d4767 1
a4767 1
  hotlist_window_preopen(already_open);
d4784 1
a4784 1
  hotlist_window_preopen(already_open);
d4804 1
d4828 6
a4833 1
/* Called whenever the hotlist is modified       */
d4836 1
a4836 1
static _kernel_oserror *hotlist_modified(unsigned int type)
d4838 2
d5102 1
a5102 1
/* hotlist_read_toolbox_id()                     */
d5104 2
a5105 1
/* Returns:    the hotlist window toolbox id     */
d5108 1
a5108 1
ObjectId hotlist_read_toolbox_id(void)
d5135 2
a5136 2
  unsigned int item_height, item_dir_width, item_url_width, xmin, xmax;

d5138 2
a5139 1
  RetError(window_wimp_to_toolbox(0,
d5141 2
a5142 3
                                  0,
                                  &state.window_handle,
                                  NULL));
d5144 4
a5147 3
  winx = x + (state.xscroll - state.visible_area.xmin);
  winy = y + (state.yscroll - state.visible_area.ymax);

d5156 1
a5156 2
    hotlist_get_shape(&xmin, &xmax, targetitem);
    if (targetitem->type == hl_directory && winx >= xmin && winx <= xmin+item_dir_width)
d5158 2
a5159 2
      /* Put item in directory */
      position = HOTLIST_POSITION_BEGINNING;
d5163 2
a5164 10
      if ((-winy % item_height) > item_height / 2)
      {
        /* Put item after target item */
        position = HOTLIST_POSITION_AFTER;
      }
      else
      {
        /* Put item before target item */
        position = HOTLIST_POSITION_BEFORE;
      }
d5173 1
a5173 1

d5180 1
a5180 1
  if (!e) hotlist_window_preopen(already_open);
a5192 8
    case HOTLIST_POSITION_BEGINNING:
    {
      hotlist_clear_flags(hotlist_root, hl_ALL, HOTLIST_G_REDRAW_NOW);
      hotlist_redraw_items(0,
                           hotlist_count_displayed_items(hotlist_root->data.directory_content));
    }
    break;

@


1.10
log
@Made sure validation string fields were zeroed.
@
text
@d3299 9
d4063 1
a4063 1
  show_error_ret(hotlist_autoscroll(0)); /* Reset autoscrolling (To remove pointer if necessary) */
d4523 4
a4526 1
static int selection_x, selection_y; ////////////
d5072 121
@


1.9
log
@Various bug fixes,new drag selection model and dragndrop compliant autoscroll
@
text
@d1509 1
a1509 1

d1599 1
d1612 1
d1973 1
a1973 1

d2273 1
a2273 1

d2286 1
a2286 1

d2297 1
a2297 1

d2303 1
a2303 1

d2359 1
a2359 1

d2691 1
a2691 1

d3140 1
a3140 1

d3310 1
a3310 1

d3832 1
d3838 1
d4069 1
a4069 1

d4226 1
a4226 1

d4228 1
a4228 1

d4237 1
a4237 1

d4240 1
a4240 1

d4243 1
a4243 1

d4247 1
a4247 1

d4249 1
a4249 1

d4269 1
a4269 1

d4285 1
a4285 1

d4288 1
a4288 1

d4308 1
a4308 1
          if (mouse_shape != Mouse_Shape_ToScroll)
d4352 1
a4352 1

d4365 1
a4365 1
        {
d4367 1
a4367 1

d4375 1
a4375 1

d4405 1
a4405 1

d4783 1
a4783 1

d4788 1
a4788 1

@


1.8
log
@A bit more tidying up
@
text
@d48 1
d56 4
d184 1
a184 1
static void              hotlist_window_preopen          (hl_opentype type);
d192 2
a193 1

d196 2
a197 2
_kernel_oserror        * hotlist_initiate_uri_save       (hotlist_item *sourceitem);
_kernel_oserror        * hotlist_initiate_html_save      (char *filename);
d1509 4
a1512 1
      if (list->flags & HOTLIST_G_IS_SELECTED) icon.flags |= WimpIcon_Selected;
d1624 3
a1626 2
      if (list->flags & HOTLIST_G_IS_SELECTED) icon.flags = HOTLIST_TEXT_ICON_FLAGS_SELECTED;
      else                                     icon.flags = HOTLIST_TEXT_ICON_FLAGS_UNSELECTED;
d1910 3
d1914 7
a1920 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d1968 1
d1970 7
a1976 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d2021 1
d2023 7
a2029 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d2195 1
d2197 1
a2197 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
a2222 1
      hotlist_clear_selection();
d2254 2
d2258 1
a2258 1
static void hotlist_window_preopen(hl_opentype type)
d2268 9
d2280 1
a2280 2
    toolbox_get_object_state(0, hotlist_windowid, &objectstate);
    if (!objectstate & Toolbox_GetObjectState_Showing) return;
d2283 7
a2289 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d2294 14
a2307 2
  show_error(window_get_wimp_handle(0, hotlist_windowid, &state.window_handle));
  wimp_get_window_state(&state);
d2313 8
a2320 1
    window_get_extent(0, hotlist_windowid, &bbox);
d2337 6
a2342 1
  window_set_extent(0, hotlist_windowid, &bbox);
d2346 19
a2364 9
    show_error(window_get_wimp_handle(0, hotlist_windowid, &state.window_handle));
    wimp_get_window_state(&state);
    toolbox_get_parent(0, hotlist_windowid, &parent_id, &parent_component);
    toolbox_show_object(0,
                        hotlist_windowid,
                        Toolbox_ShowObject_FullSpec,
                        &(state.visible_area),
                        parent_id, parent_component);
//    wimp_open_window((WimpOpenWindowBlock*)&state);
d2615 7
a2621 6
          HotlistWrite(fprintf(fileptr, "<h4>%s</h4>\n", list->name));

          /* Recursive call for the directory contents. First, */
          /* write the entry header.                           */

          HotlistWrite(fprintf(fileptr, "<ul>\n"));
d2626 4
a2629 4

          /* Write the entry footer */

          HotlistWrite(fprintf(fileptr, "</ul>\n"));
d2675 1
d2689 2
a2690 1

d3108 1
d3137 4
d3282 5
d3293 1
a3293 1
  hotlist_window_preopen(not_open);
d3297 13
a3309 6
  return toolbox_show_object(0,
                             hotlist_windowid,
                             show_type,
                             type,
                             0,
                             0);
d3994 1
d4050 2
d4064 3
a4066 1
    return 0; /* No action taken at end of drag, selection is done by null handler during drag */
a4187 1

a4193 1

d4201 10
a4210 1
void hotlist_autoscroll(int x, int y, int window_handle)
d4212 1
a4212 1
  ObjectId object, parent;
d4217 33
a4249 9
  static unsigned int hscroll_speed, vscroll_speed;          /* Separate h/v velocities */
  static int last_window_handle = 0;

  /* No error as autoscroll not working is not a major problem */
  if (window_wimp_to_toolbox(0, window_handle, -1, &object, NULL)) return;

  state.window_handle = window_handle;

  if (last_window_handle != window_handle)
d4251 1
a4251 3
    last_window_handle = window_handle;
    hscroll_speed = 0;
    vscroll_speed = 0;
d4253 5
a4257 8

  wimp_get_window_state(&state);

  window_get_extent(0, object, &extent);

  /* Auto scrolling of hotlist window when dragging */
  scroll_changed = 0;
  if ((y > state.visible_area.ymax - HOTLIST_SCROLL_BOUNDARY_SIZE) && y < state.visible_area.ymax)
d4259 1
a4259 6
    /* Don't scroll if already at bottom edge */
    if (state.yscroll < extent.ymax)
    {
      state.yscroll += vscroll_speed;
      scroll_changed |= 1;
    }
d4262 26
a4287 1
    if ((y < state.visible_area.ymin + HOTLIST_SCROLL_BOUNDARY_SIZE) && y > state.visible_area.ymin)
d4289 1
a4289 2
      /* Don't scroll if already at top edge */
      if (state.yscroll > extent.ymin + (state.visible_area.ymax - state.visible_area.ymin)) ///////
d4291 29
a4319 2
        state.yscroll -= vscroll_speed;
        scroll_changed |= 1;
d4322 1
a4322 5

  if ((x > state.visible_area.xmax - HOTLIST_SCROLL_BOUNDARY_SIZE) && x < state.visible_area.xmax)
  {
    /* Don't scroll if already at right hand edge */
    if (state.xscroll < extent.xmax - (state.visible_area.xmax - state.visible_area.xmin)) ///////
d4324 6
a4329 2
      state.xscroll += hscroll_speed;
      scroll_changed |= 2;
d4333 2
a4334 1
    if ((x < state.visible_area.xmin + HOTLIST_SCROLL_BOUNDARY_SIZE) && x > state.visible_area.xmin)
d4336 4
a4339 2
      /* Don't scroll if already at left hand edge */
      if (state.xscroll > extent.xmin)
d4341 2
a4342 2
        state.xscroll -= hscroll_speed;
        scroll_changed |= 2;
d4345 50
d4398 2
a4399 22
    toolbox_get_parent(0, object, &parent, &component);
    toolbox_show_object(0, object, Toolbox_ShowObject_FullSpec, &(state.visible_area), parent, component);
  }

  if (scroll_changed & 1)
  {
    vscroll_speed += HOTLIST_SCROLL_SPEED_INC;
    if (vscroll_speed > HOTLIST_SCROLL_SPEED_MAX) vscroll_speed = HOTLIST_SCROLL_SPEED_MAX;
  }
  else
  {
    vscroll_speed = HOTLIST_SCROLL_SPEED_MIN;
  }

  if (scroll_changed & 2)
  {
    hscroll_speed += HOTLIST_SCROLL_SPEED_INC;
    if (hscroll_speed > HOTLIST_SCROLL_SPEED_MAX) hscroll_speed = HOTLIST_SCROLL_SPEED_MAX;
  }
  else
  {
    hscroll_speed = HOTLIST_SCROLL_SPEED_MIN;
d4401 2
d4425 2
a4430 2
    hotlist_autoscroll(x, y, state.window_handle);

d4510 1
a4510 1
static int selection_x, selection_y;
d4519 1
a4519 1
_kernel_oserror *hotlist_selection_box_start(void)
d4565 1
a4565 1
int hotlist_null_drag_select_handler(int event_code, WimpPollBlock * event, IdBlock * id_block, void * handle)
d4614 1
a4614 1
          if (!(item->flags & HOTLIST_G_IS_SELECTED))
d4616 1
a4616 1
            item->flags |= HOTLIST_G_IS_SELECTED;
d4620 1
a4620 1
              hotlist_set_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
d4627 1
a4627 1
          if (item->flags & HOTLIST_G_IS_SELECTED)
d4629 1
a4629 1
            item->flags &= ~HOTLIST_G_IS_SELECTED;
d4633 1
a4633 1
              hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED | HOTLIST_G_REDRAW_NOW);
d4640 1
a4640 1
        if (item->flags & HOTLIST_G_IS_SELECTED)
d4642 1
a4642 1
          item->flags &= ~HOTLIST_G_IS_SELECTED;
d4646 1
a4646 1
            hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED | HOTLIST_G_REDRAW_NOW);
d4756 34
d4800 1
d4803 5
a4807 1
_kernel_oserror *hotlist_initiate_uri_save(hotlist_item *item)
d4812 1
d4814 1
a4814 1
  wimp_get_pointer_info(&block);
d4828 5
a4832 5
  wimp_send_message(Wimp_EUserMessageRecorded,
                    &message,
                    block.window_handle,
                    block.icon_handle,
                    &new_task_handle);
d4841 5
a4845 1
_kernel_oserror *hotlist_initiate_html_save(char *filename)
d4850 1
d4852 1
a4852 1
  wimp_get_pointer_info(&block);
d4867 5
a4871 5
  wimp_send_message(Wimp_EUserMessageRecorded,
                    &message,
                    block.window_handle,
                    block.icon_handle,
                    &new_task_handle);
d4879 5
a4883 1
int hotlist_data_save_ack_handler(WimpMessage *message, void *handle)
d4995 3
d4999 1
a4999 1
int hotlist_ram_fetch_handler(WimpMessage *message, void *handle)
d5004 1
a5004 1
  if (hotlist_save_item)
@


1.7
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@a81 2
static unsigned int   item_number;                        /* Current item being considered for drawing */

d168 2
a169 3
// Need renaming to hotlist_get_max_width_r and hotlist_redraw_now_r
static void              _hotlist_get_max_width          (hotlist_item * list, unsigned int indent);
static void              _hotlist_redraw_now             (hotlist_item * list);
d171 1
a171 1
static unsigned int      hotlist_get_max_width           (hotlist_item * list);
d983 1
a983 1
  if (item_url_width) *item_url_width = width + 8; /* +8 for aesthetics */
d1650 22
a1671 1
/* _hotlist_get_max_width                        */
d1673 2
a1674 2
/* This function does all the work for           */
/* hotlist_get_max_width                         */
d1677 2
a1678 1
static void _hotlist_get_max_width(hotlist_item *list, unsigned int indent)
d1680 3
a1682 3
  unsigned int item_height, item_dir_width, item_url_width;
  unsigned int temp_width;
  int          text_width;
d1684 1
a1684 2
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
  while(list)
d1686 3
a1688 1
    switch(list->type)
d1690 11
a1700 3
      case hl_directory:
      temp_width = item_dir_width;
      break;
d1702 1
a1702 3
      case hl_url:
      temp_width = item_url_width;
      break;
d1704 1
a1704 4
      default:
      temp_width = 0;
      break;
    }
d1706 1
a1706 2
    if (list->type == hl_url && hl_show_urls) utils_text_width(list->data.url, &text_width, 0);
    else                                      utils_text_width(list->name,     &text_width, 0);
d1708 1
a1708 1
    temp_width += indent + 2 + text_width + 12;
d1710 1
a1710 1
    if (temp_width > item_number) item_number = temp_width;
d1714 6
a1719 1
      _hotlist_get_max_width(list->data.directory_content, indent + item_dir_width);
d1721 3
a1724 1
    item_number++;
d1726 2
d1734 1
a1734 1
/* of the displayed hotlist entries              */
d1736 35
d1772 2
d1776 1
a1776 1
static unsigned int hotlist_get_max_width(hotlist_item *list)
d1778 3
a1780 3
  item_number = 0;
  _hotlist_get_max_width(list, 0);
  return item_number;
d1784 1
a1784 1
/* _hotlist_redraw_now()                         */
d1786 11
a1796 2
/* This function does the work for               */
/* hotlist_redraw_now()                          */
d1799 1
a1799 1
static void _hotlist_redraw_now(hotlist_item *list)
d1801 1
a1801 1
  while(list)
d1805 6
a1810 1
      hotlist_redraw_items(item_number, item_number);
d1813 3
a1815 1
    item_number++;
d1818 3
a1820 1
      _hotlist_redraw_now(list->data.directory_content);
d1822 1
a1827 13
/* hotlist_redraw_now()                          */
/*                                               */
/* This function redraws all visible items with  */
/* the HOTLIST_G_REDRAW_NOW bit set              */
/*************************************************/

static void hotlist_redraw_now(void)
{
  item_number = 0;
  _hotlist_redraw_now(hotlist_root->data.directory_content);
}

/*************************************************/
a2508 4
  /* Write the entry header */

  //HotlistWrite(fprintf(fileptr, "<ul>\n"));

d2534 3
a2536 1
          /* Recursive call for the directory contents */
d2538 3
d2542 3
a2555 4
  /* Write the entry footer */

  //HotlistWrite(fprintf(fileptr, "</ul>\n"));

d2565 2
a2566 2
/* Parameters: Pointer to the filename to load   */
/*             (null terminated).                */
d2568 2
a2569 2
/*             0 - save all of hotlist           */
/*             1 - only save selection portions  */
d2571 2
a2572 1
_kernel_oserror * hotlist_save_hotlist(char *filename, int type)
d2624 1
a2624 1
/* of the hotlist, created to preserve API       */
d2626 2
a2627 2
/* Parameters: Pointer to the filename to load   */
/*             (null terminated).                */
@


1.6
log
@Added support for saving HTML files from hotlist window
@
text
@a60 3
static int            autoopen_delay = 100;               /* Time in centiseconds before directory is autoopened */


d90 4
d132 11
a142 1
/* Miscellaneous function prototypes */
d145 4
a149 1
static hotlist_item    * hotlist_find_item_r             (hotlist_item * list, unsigned int item_no);
d151 1
a151 1
static int               _hotlist_find_no_from_item      (hotlist_item * list, hotlist_item * item);
d153 1
a153 1
static hotlist_item    * _hotlist_find_selected_item     (hotlist_item * list);
d155 6
a160 1
static void              _hotlist_count_displayed_items  (hotlist_item * list);
d162 6
a167 2
static void              hotlist_count_selected_items_r  (hotlist_item * list);
static unsigned int      hotlist_count_selected_items    (void);
d170 1
a170 2
static void              _hotlist_draw                   (hotlist_item * list, unsigned int first_item, unsigned int last_item, unsigned int indent);
static void              hotlist_draw                    (hotlist_item * list, unsigned int first_item, unsigned int last_item);
a195 12
/* List manupulation */

static void              hotlist_unlink                  (hotlist_item * item);
static _kernel_oserror * hotlist_link                    (hotlist_item * item, hotlist_item * target, unsigned int position);
static _kernel_oserror * hotlist_new_directory           (hotlist_item * parent, char * directory_name, unsigned int position, hotlist_item ** new);
static _kernel_oserror * hotlist_new_url                 (hotlist_item * parent, unsigned int position, char * url_description, char * url);
static void              hotlist_delete_item             (hotlist_item * item);
static _kernel_oserror * hotlist_move_item               (hotlist_item * source, hotlist_item * target, unsigned int position);
static _kernel_oserror * hotlist_copy_item               (hotlist_item * source, hotlist_item * target, unsigned int position, hotlist_item ** new_item);
static int               hotlist_set_flags               (hotlist_item * list, hotlist_type type, unsigned int flags);
static int               hotlist_clear_flags             (hotlist_item * list, hotlist_type type, unsigned int flags);

a300 93
/* hotlist_get_entry_sizes()                     */
/*                                               */
/* This function reads the size of the sprites   */
/* to be used by the hotlist and from them       */
/* determines the size of the hotlist entries.   */
/*                                               */
/* Parameters: Pointer to an int, in which the   */
/*             height of an item is placed in    */
/*             OS units;                         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             minimum width of a directory item */
/*             is returned, in OS units;         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             minimum width of a URL item is    */
/*             returned, in OS units.            */
/*                                               */
/* Assumes:    Any of the pointers may be NULL.  */
/*************************************************/

static _kernel_oserror * hotlist_get_entry_sizes(unsigned int * item_height, unsigned int * item_dir_width, unsigned int * item_url_width)
{
  _kernel_oserror * e;
  int               width, height;

  /* Get the open directory sprite size */

  RetError(read_sprite_size(OPEN_DIRECTORY_SPRITE, &width, &height));

  /* Use this for the minimum width of a directory entry */
  /* and the height of an item.                          */

  if (item_dir_width) *item_dir_width = width;
  if (item_height)    *item_height    = height;

  /* Now read the closed sprite; if the size is greater */
  /* than the width or height found above, use the new  */
  /* sizes instead.                                     */

  RetError(read_sprite_size(CLOSED_DIRECTORY_SPRITE, &width, &height));

  if (item_height    && height > *item_height)    *item_height    = height;
  if (item_dir_width && width  > *item_dir_width) *item_dir_width = width;

  /* Similarly for the insert item sprite. */

  RetError(read_sprite_size(INSERT_DIRECTORY_SPRITE, &width, &height));

  if (item_height    && height > *item_height)    *item_height    = height;
  if (item_dir_width && width  > *item_dir_width) *item_dir_width = width;

  /* Find the URL sprite size, and if required increase the */
  /* minimum entry height again based on this.              */

  RetError(read_sprite_size(URL_SPRITE, &width, &height));

  if (item_height && height > *item_height) *item_height= height;

  /* Set the URL width to the value found above and add 8 to */
  /* all of them for aesthetics.                             */

  if (item_url_width) *item_url_width = width + 8; /* +8 for aesthetics */
  if (item_dir_width) *item_dir_width += 8;
  if (item_height)    *item_height    += 8;

  return NULL;
}

/*************************************************/
/* hotlist_unlink()                              */
/*                                               */
/* This function unlinks the passed item from    */
/* the items linked in before and after it.      */
/*                                               */
/* Parameters: Pointer to the hotlist_item       */
/*             struct to remove.                 */
/*************************************************/

static void hotlist_unlink(hotlist_item *item)
{
  if (item->parent && item->parent->data.directory_content == item) item->parent->data.directory_content = item->next;
  if (item->previous) item->previous->next = item->next;
  if (item->next) item->next->previous = item->previous;

  /* Not strictly needed, but added to ensure robustness */

  item->next     = NULL;
  item->previous = NULL;
  item->parent   = NULL;
}

/*************************************************/
d476 23
d539 1
a539 6
  if (!item)
  {
    make_no_memory_error(4);

    return &erb;
  }
d547 1
a547 3
    make_no_memory_error(5);

    return NULL;
d924 177
d1119 1
a1119 1
  item_number = 0;
d1121 1
a1121 1
  return hotlist_find_item_r(list, item_no);
d1129 9
a1137 1
/* Parameters: As hotlist_find_item.             */
d1140 3
d1145 1
a1145 1
static hotlist_item * hotlist_find_item_r(hotlist_item * list, unsigned int item_no)
d1151 1
a1151 1
    if (item_number == item_no) return list; /* Found the list item */
d1155 1
a1155 1
    item_number++;
d1161 1
a1161 2
      temp = hotlist_find_item_r(list->data.directory_content, item_no);

d1174 35
a1208 1
/* _hotlist_find_no_from_item()                  */
d1210 4
a1213 2
/* This function does all the work for           */
/* hotlist_find_no_from_item()                   */
d1215 1
a1215 3
/* Parameters: Pointer to a hotlist_item         */
/*             the item whose position should be */
/*             returned.                         */
d1217 2
a1218 2
/* Returns:    The item position or              */
/*             -1 if it does not exist           */
d1221 1
a1221 1
static int _hotlist_find_no_from_item(hotlist_item *list, hotlist_item *item)
d1223 3
a1225 2
  int temp;
  while(list)
d1227 6
a1232 2
    if (item == list) return item_number;                             /* Found the list item */
    item_number++;
d1235 4
a1238 2
      temp = _hotlist_find_no_from_item(list->data.directory_content, item);
      if (temp >= 0) return temp;
d1240 3
d1244 3
a1247 1
  }
d1252 1
a1252 1
/* hotlist_find_no_from_item()                   */
d1254 2
a1255 7
/* This function will recursivly scan through    */
/* a hotlist structure and return the position   */
/* of the specified item.  It will only recurse  */
/* through open directories.                     */
/*                                               */
/* Parameters: Pointer to a hotlist_item         */
/*             Pointer to the item to find       */
d1257 5
a1261 8
/* Returns:    Position of the requested item or */
/*             -1 if it does not exist           */
/*                                               */
/* Note:       This function doesn't actually    */
/*             do any of the real work but       */
/*             merely sets up a global variable  */
/*             and calls                         */
/*             _hotlist_find_no_from_item()      */
d1264 1
a1264 1
static int hotlist_find_no_from_item(hotlist_item *item)
d1266 1
a1266 2
  item_number = 0;
  return _hotlist_find_no_from_item(hotlist_root->data.directory_content, item);
d1269 13
a1281 7
/************************************************/
/* _hotlist_find_selected_item()                */
/*                                              */
/* This function does the work for              */
/* hotlist_find_selected_item()                 */
/************************************************/
hotlist_item * _hotlist_find_selected_item(hotlist_item *list)
d1283 1
a1283 2
  hotlist_item *temp;
  while(list)
d1285 4
a1288 1
    if (list->flags & HOTLIST_G_IS_SELECTED) return list;
d1291 4
a1294 2
      temp = _hotlist_find_selected_item(list->data.directory_content);
      if (temp) return temp;
d1296 3
d1301 3
d1308 4
a1311 1
/* hotlist_find_selected_item()                  */
d1313 1
a1313 2
/* This function returns a pointer to the first  */
/* selected item found                           */
d1316 1
a1316 1
static hotlist_item * hotlist_find_selected_item(void)
d1318 5
a1322 1
  return _hotlist_find_selected_item(hotlist_root);
d1326 4
a1329 1
/* _hotlist_count_displayed_items()              */
d1331 9
a1339 2
/* This routine does all the work for            */
/* hotlist_count_displayed_items()               */
d1342 1
a1342 1
static void _hotlist_count_displayed_items(hotlist_item *list)
d1344 1
a1344 1
  while(list)
d1346 7
a1352 1
    if (list->type == hl_directory && list->flags & HOTLIST_D_IS_OPEN)
d1354 4
a1357 2
    {
      _hotlist_count_displayed_items(list->data.directory_content);
d1359 1
a1360 1
    item_number++;
d1367 2
a1368 2
/* This routine counts the number of items to be */
/* displayed in the hotlist window               */
d1370 2
a1371 1
/* Parameters: Pointer to a hotlist_item         */
d1373 1
a1373 2
/* Returns:    the number of items visible in    */
/*             the list                          */
d1376 1
a1376 1
static unsigned int hotlist_count_displayed_items(hotlist_item *list)
d1378 5
a1382 3
  item_number = 0;
  _hotlist_count_displayed_items(list);
  return item_number;
d1386 4
a1389 1
/* hotlist_set_flags()                           */
d1391 2
a1392 5
/* This function will recursivly set flags for   */
/* either a specified type of hotlist_item or    */
/* all hotlist_items if hl_ALL is specified      */
/* all items which are changed will also have    */
/* their HOTLIST_G_REDRAW_NOW bit set            */
d1394 2
a1395 4
/* Parameters: Pointer to a hotlist_item         */
/*             type of hotlist_item to set flags */
/*             for                               */
/*             flags to set                      */
d1397 2
a1398 2
/* Returns:    1 if any flags were set           */
/*             0 if no flags were set            */
d1401 1
a1401 1
static int hotlist_set_flags(hotlist_item *list, hotlist_type type, unsigned int flags)
d1403 1
a1403 3
  int changed;
  changed = 0;
  while(list)
d1405 3
a1407 10
    if (type == hl_ALL || type == list->type)
    {
      if (list->flags | flags != list->flags)
      {
        list->flags |= HOTLIST_G_REDRAW_NOW;
        changed = 1;
      }
      list->flags |= flags;
    }
    if (list->type == hl_directory)
d1409 1
a1409 1
      if (hotlist_set_flags(list->data.directory_content, type, flags)) changed = 1;
d1411 1
d1413 2
a1415 1
  return changed;
d1419 6
a1424 1
/* hotlist_clear_flags()                         */
d1426 2
a1427 7
/* This function will recursivly clear flags for */
/* either a specified type of hotlist_item or    */
/* all hotlist_items if hl_ALL is specified      */
/* all items which are changed will also have    */
/* their HOTLIST_G_REDRAW_NOW bit set except if  */
/* the routine is set to clear the               */
/* HOTLIST_G_REDRAW_NOW bit                      */
d1429 1
a1429 4
/* Parameters: Pointer to a hotlist_item         */
/*             type of hotlist_item to clear     */
/*             flags for                         */
/*             flags to clear                    */
d1431 1
a1431 2
/* Returns:    1 if any flags were cleared       */
/*             0 if no flags were cleared        */
d1434 1
a1434 1
static int hotlist_clear_flags(hotlist_item *list, hotlist_type type, unsigned int flags)
d1436 14
a1449 20
  int changed;
  changed = 0;
  while(list)
  {
    if (type == hl_ALL || type == list->type)
    {
      if (list->flags & ~flags != list->flags)
      {
        list->flags |= HOTLIST_G_REDRAW_NOW;
        changed = 1;
      }
      list->flags &= ~flags;
    }
    if (list->type == hl_directory)
    {
      if (hotlist_clear_flags(list->data.directory_content, type, flags)) changed = 1;
    }
    list = list->next;
  }
  return changed;
d1453 6
a1458 1
/* _hotlist_draw()                               */
d1460 19
a1478 2
/* This function does all the hard work for      */
/* hotlist_draw()                                */
d1480 2
a1481 4
/* Parameters: Pointer to a hotlist_item         */
/*             First item number to draw         */
/*             Last item number to draw          */
/*             Level of indentation              */
d1484 3
a1486 4
static void _hotlist_draw(hotlist_item *list,
                   unsigned int first_item,
                   unsigned int last_item,
                   unsigned int indent)
d1488 10
a1497 4
  WimpIconBlock hotlist_iconblock;
  unsigned int item_height, item_dir_width, item_url_width;
  unsigned int temp_width;
  _kernel_swi_regs regs;
d1499 1
a1499 1
  hotlist_get_entry_sizes(&item_height, &item_dir_width, &item_url_width);
d1501 1
a1501 4
  while(list)
  {
    if (item_number > last_item) return; /* Break out if done all items to be displayed */
    if (item_number >= first_item)
d1503 1
a1503 1
      /*  draw it */
d1505 2
a1506 2
      hotlist_iconblock.flags = HOTLIST_SPRITE_ICON_FLAGS;
      if (list->flags & HOTLIST_G_IS_SELECTED) hotlist_iconblock.flags |= WimpIcon_Selected;
d1508 1
a1508 1
      hotlist_iconblock.data.is.sprite_area = (void*)sprite_block;
d1510 5
a1514 1
      switch(list->type)                                                /* Set appropriate sprite and width of sprite */
d1517 7
a1523 3
        hotlist_iconblock.data.is.sprite = URL_SPRITE;
        hotlist_iconblock.data.is.sprite_name_length = strlen(URL_SPRITE);
        temp_width = item_url_width;
a1526 2
        temp_width = item_dir_width;
        if (list->flags & HOTLIST_D_IS_HIGHLIGHTED)
d1528 7
a1534 6
          hotlist_iconblock.data.is.sprite = INSERT_DIRECTORY_SPRITE;
          hotlist_iconblock.data.is.sprite_name_length = strlen(INSERT_DIRECTORY_SPRITE);
        }
        else
        {
          if (list->flags & HOTLIST_D_IS_OPEN)
d1536 4
a1539 2
            hotlist_iconblock.data.is.sprite = OPEN_DIRECTORY_SPRITE;
            hotlist_iconblock.data.is.sprite_name_length = strlen(OPEN_DIRECTORY_SPRITE);
d1543 12
a1554 2
            hotlist_iconblock.data.is.sprite = CLOSED_DIRECTORY_SPRITE;
            hotlist_iconblock.data.is.sprite_name_length = strlen(CLOSED_DIRECTORY_SPRITE);
d1560 4
a1563 1
        temp_width = 0;                                       /* Only here to stop warnings */
d1566 4
a1569 4
      hotlist_iconblock.bbox.xmin = indent;
      hotlist_iconblock.bbox.xmax = indent + temp_width;
      hotlist_iconblock.bbox.ymax = (-item_height*item_number);
      hotlist_iconblock.bbox.ymin = ((-item_height*item_number) - item_height);
d1571 2
a1572 1
      wimp_plot_icon(&hotlist_iconblock);                               /* Plot sprite icon */
d1574 1
a1574 7
      regs.r[0] = 1;

      if (list->type == hl_url && hl_show_urls) regs.r[1] = (int)list->data.url;
      else                                      regs.r[1] = (int)list->name;

      regs.r[2] = 0;
      wimp_text_op(&regs);                                              /* Get width of text for text icon */
d1576 1
d1578 3
a1580 4
      if (list->flags & HOTLIST_G_IS_SELECTED)
        hotlist_iconblock.flags = HOTLIST_TEXT_ICON_FLAGS_SELECTED;
      else
        hotlist_iconblock.flags = HOTLIST_TEXT_ICON_FLAGS_UNSELECTED;
a1581 5
      hotlist_iconblock.bbox.xmin = indent+temp_width+2;
      hotlist_iconblock.bbox.xmax = indent+temp_width+2+regs.r[0] + 12;
      hotlist_iconblock.bbox.ymax = (-item_height*item_number) - 2;
      hotlist_iconblock.bbox.ymin = (-item_height*item_number) - item_height + 2;

d1584 9
a1592 2
        hotlist_iconblock.data.it.buffer      = list->data.url;
        hotlist_iconblock.data.it.buffer_size = strlen(list->data.url);
d1596 9
a1604 2
        hotlist_iconblock.data.it.buffer      = list->name;
        hotlist_iconblock.data.it.buffer_size = strlen(list->name);
d1607 5
a1611 1
      wimp_plot_icon(&hotlist_iconblock);
d1613 11
a1623 1
      /*! drawit  */
d1626 5
a1630 1
    item_number++;
d1634 8
a1641 1
      _hotlist_draw(list->data.directory_content, first_item, last_item, indent + item_dir_width);
d1643 3
a1647 1
}
d1649 1
a1649 22
/*************************************************/
/* hotlist_draw()                                */
/*                                               */
/* This function will recursivly draw the        */
/* hotlist                                       */
/*                                               */
/* Parameters: Pointer to a hotlist_item         */
/*             First item number to draw         */
/*             Last item number to draw          */
/*                                               */
/* Note:       This function doesn't actually    */
/*             do any of the real work but       */
/*             merely sets up global variables   */
/*             and calls _hotlist_draw()         */
/*************************************************/

static void hotlist_draw(hotlist_item *list,
                  unsigned int first_item,
                  unsigned int last_item)
{
  item_number = 0;
  _hotlist_draw(list, first_item, last_item, 0);
d1663 1
a1663 1
  _kernel_swi_regs regs;
d1683 2
a1684 7
    regs.r[0] = 1;

    if (list->type == hl_url && hl_show_urls) regs.r[1] = (int)list->data.url;
    else                                      regs.r[1] = (int)list->name;

    regs.r[2] = 0;
    wimp_text_op(&regs);
d1686 1
a1686 1
    temp_width += indent+2+regs.r[0] + 12;
d1824 1
a1824 2
  int count = 0, temp_width;
  _kernel_swi_regs regs;
d1838 2
a1839 7
  regs.r[0] = 1;

  if (item->type == hl_url && hl_show_urls) regs.r[1] = (int)item->data.url;
  else                                      regs.r[1] = (int)item->name;

  regs.r[2] = 0;
  wimp_text_op(&regs);
d1857 1
a1857 1
  *xmax = count * item_dir_width + temp_width + regs.r[0] + 2 + 12;
d2202 2
a2203 2
    toolbox_show_object(0,
                        hotlist_windowid,
d2337 1
a2337 1

d2704 1
a2704 1
      make_no_memory_error(2);
a2705 1
      e = &erb;
d2749 1
a2749 1
        make_no_memory_error(3);
a2750 1
        e = &erb;
d2927 1
a2927 1

d2929 1
a2929 1

d3082 1
a3082 1

d3185 1
a3185 1

d3276 1
a3276 1

d3278 1
a3278 1

d3603 1
d3605 1
a3605 2
  int temp_width;
  _kernel_swi_regs regs;
d3640 2
a3641 9
  regs.r[0] = 1;

  if (item->type == hl_url && hl_show_urls) regs.r[1] = (int)item->data.url;
  else                                      regs.r[1] = (int)item->name;
  regs.r[2] = 0;
  if (wimp_text_op(&regs))                                              /* Get width of text for text icon */
  {
    /* Error has happened, don't know what to do about it */
  }
d3645 1
a3645 1
  hotlist_iconblock.bbox.xmax           = temp_width + regs.r[0] + 16;
d4002 1
a4002 1
    if (hotlist_count_selected_items() == 1 && (sourceitem = hotlist_find_selected_item())->type == hl_url)
d4012 1
a4012 1

d4043 1
a4043 1

d4093 1
a4093 1

d4174 1
a4174 1
          if (autoopen_delay &&
d4176 1
a4176 1
              (new_time - autoopen_oldtime) > autoopen_delay)
d4220 1
a4220 1
static int selection_x, selection_y;
a4365 56

/*************************************************/
/* hotlist_count_selected_items_r()              */
/*                                               */
/* Recursive back-end to                         */
/* hotlist_count_selected_items.                 */
/*                                               */
/* Parameters: Pointer to a hotlist_item struct  */
/*             representing the first item in a  */
/*             directory to count.               */
/*                                               */
/* Returns:    The number of items selected in   */
/*             that directory (selected          */
/*             directory items only count as 1;  */
/*             their contents are not counted).  */
/*************************************************/

static void hotlist_count_selected_items_r(hotlist_item * list)
{
  while(list)
  {
    if (list->flags & HOTLIST_G_IS_SELECTED)
    {
      item_number++;
    }
    else
    {
      /* Only recurse through directories which are not selected */

      if (list->type == hl_directory)
      {
        hotlist_count_selected_items_r(list->data.directory_content);
      }
    }

    list = list->next;
  }
}

/*************************************************/
/* hotlist_count_selected_items()                */
/*                                               */
/* Count the number of items in a selection.     */
/*                                               */
/* Returns:    The number of selected items.     */
/*************************************************/

static unsigned int hotlist_count_selected_items(void)
{
  item_number = 0;

  hotlist_count_selected_items_r(hotlist_root->data.directory_content);

  return item_number;
}

d4483 1
a4483 1

d4485 1
a4485 1

d4489 1
a4489 1

d4497 1
a4497 1

d4507 1
a4507 1

d4516 1
a4516 1

d4518 1
a4518 1

d4522 1
a4522 1

d4529 1
a4529 1

d4531 1
a4531 1

d4540 1
a4540 1

d4549 1
a4549 1

d4559 1
a4559 1

d4567 1
a4567 1

d4573 1
a4573 1

d4581 1
a4581 1

d4584 1
a4584 1

d4590 1
a4590 1

d4607 1
a4607 1

d4613 1
a4613 1

d4615 1
a4615 1

d4617 1
a4617 1

d4619 1
a4619 1

d4625 1
a4625 1

d4628 1
a4628 1

d4634 1
a4634 1

d4644 1
a4644 1

d4646 1
a4646 1

d4648 1
a4648 1

d4652 1
a4652 1

d4661 1
a4661 1

d4686 1
a4686 1

d4692 1
a4692 1

d4699 1
a4699 1

d4707 1
a4707 1

d4710 1
a4710 1

@


1.5
log
@Added support for saving URI files from hotlist window
@
text
@d162 1
a162 1
static _kernel_oserror * hotlist_save_entries            (FILE * fileptr, hotlist_item * list);
d172 1
d2199 3
d2207 1
a2207 1
static _kernel_oserror * hotlist_save_entries(FILE * fileptr, hotlist_item * list)
d2214 1
a2214 1
  HotlistWrite(fprintf(fileptr, "<ul>\n"));
d2226 4
a2229 1
        HotlistWrite(fprintf(fileptr, "<li><a href=\"%s\">%s</a>\n", list->data.url, list->name));
d2237 3
a2239 1
        HotlistWrite(fprintf(fileptr, "<h4>%s</h4>\n", list->name));
d2241 5
a2245 3
        /* Recursive call for the directory contents */

        RetError(hotlist_save_entries(fileptr, list->data.directory_content));
d2257 1
a2257 1
  HotlistWrite(fprintf(fileptr, "</ul>\n"));
d2263 1
a2263 1
/* hotlist_save()                                */
d2270 3
d2274 1
a2274 2

_kernel_oserror * hotlist_save(char * filename)
d2296 1
a2296 1
  e = hotlist_save_entries(fileptr, hotlist_root->data.directory_content);
d2323 15
d3788 1
a3788 1
    if (hotlist_count_selected_items() == 1)
d3791 2
a3792 6

      sourceitem = hotlist_find_selected_item();
      if (sourceitem->type == hl_url)
      {
        hotlist_initiate_uri_save(sourceitem);
      }
d3796 3
a3798 1
      /* Can't save URI file when saving more than one URL */
a3814 1
  _kernel_oserror *e;
d3816 2
a3817 3
  object = 0;
  show_error_ret(window_wimp_to_toolbox(0, window_handle, -1, &object, NULL));
  if (!object) return;
d4005 9
a4013 1
int selection_x, selection_y; /* Workarea relative corner of selection box */
a4097 2
  /* Change from here onwards */

d4353 33
d4410 13
a4422 5
        show_error_ret(_swix(OS_File,
                       _INR(0,2),
                       18,
                       message->data.data_save_ack.leaf_name,
                       0xf91));
d4455 36
@


1.4
log
@Various bug fixes and support for displaying either URLs or descriptions
@
text
@d50 1
d61 4
d87 4
d119 3
a133 1
static void              hotlist_scan_for_subdirectories (hotlist_item * item);
d169 4
a263 1
        if (list->flags & HOTLIST_D_HAS_SUBDIRECTORY) Printf(" (Has sub directory)");
a812 5
        /* The deletions will affect whether or not other */
        /* items have subdirectories, so update the       */
        /* relevant parts of all items in the list.       */

        hotlist_scan_for_subdirectories(item->parent);
a989 46
/* hotlist_scan_for_subdirectories()             */
/*                                               */
/* This function will scan a directory contents  */
/* for any subdirectories. If it finds one it    */
/* will set the directory's                      */
/* HOTLIST_HAS_SUBDIRECTORY bit, else it unsets  */
/* the bit.                                      */
/*                                               */
/* Parameters: Pointer to the hotlist_item       */
/*             struct representing the directory */
/*             to scan.                          */
/*************************************************/

static void hotlist_scan_for_subdirectories(hotlist_item * item)
{
  hotlist_item * list;

  /* Only proceed if we've been given an item and it */
  /* is a directory                                  */

  if (item && item->type == hl_directory)
  {
    list = item->data.directory_content;

    /* Go through the contents looking for a directory */
    /* within - as soon as one is found we can set the */
    /* bit and exit                                    */

    while(list)
    {
      if (list->type == hl_directory)
      {
        item->flags |= HOTLIST_D_HAS_SUBDIRECTORY;
        return;
      }
      list = list->next;
    }

    /* If the loop exits there were no directories inside */
    /* the given one, so unset the bit.                   */

    item->flags &= ~HOTLIST_D_HAS_SUBDIRECTORY;
  }
}

/*************************************************/
d1933 2
d1977 7
a1983 1
    wimp_open_window((WimpOpenWindowBlock*)&state);
d2839 8
d3590 11
a3600 9
static int hotlist_is_inside(hotlist_item *inside, hotlist_item *outside)
{
  while(inside)
  {
    if (inside == outside) return 1;
    inside = inside->parent;
  }
  return 0;
}
d3623 1
a3623 1
  hotlist_item *targetitem, *sourceitem, *tempitem;
a3708 25
    /* Check to see if moving the selection to this position is acceptable -----------------------*/

    /* This section is not sufficient for the new selection model ///////// */

    tempitem = sourceitem;
    while(tempitem)
    {
      if (tempitem->flags & HOTLIST_G_IS_SELECTED && tempitem->type == hl_directory)
      {
        if (hotlist_is_inside(targetitem, tempitem))
        {
          StrNCpy0(erb.errmess,
                   lookup_token("NotIntoself:A directory cannot be copied or moved into itself.",
                   0,
                   0));
          erb.errnum = Utils_Error_Custom_Message;
          show_error_ret(&erb);
          return 0;
        }
      }
      tempitem = tempitem->next;
    }

    /* Only get this far if it is ----------------------------------------------------------------*/

d3760 14
d3782 2
d3786 1
d3789 5
d3805 2
d3812 6
a3817 2
    state.yscroll += vscroll_speed;
    scroll_changed |= 1;
d3822 6
a3827 2
      state.yscroll -= vscroll_speed;
      scroll_changed |= 1;
d3832 6
a3837 2
    state.xscroll += hscroll_speed;
    scroll_changed |= 2;
d3842 6
a3847 2
      state.xscroll -= hscroll_speed;
      scroll_changed |= 2;
d3852 2
a3853 1
    wimp_open_window((WimpOpenWindowBlock*)&state);
d3855 1
d3889 1
d3930 14
d4286 163
@


1.3
log
@Added a missing _kernel_oserror * e declaration
@
text
@d73 1
a73 1

d107 2
d156 1
d1386 4
a1389 1
      regs.r[1] = (int)list->name;
d1403 11
a1413 2
      hotlist_iconblock.data.it.buffer      = list->name;
      hotlist_iconblock.data.it.buffer_size = strlen(list->name);
d1486 4
a1489 1
    regs.r[1] = (int)list->name;
d1610 2
d1647 4
a1650 1
  regs.r[1] = (int)item->name;
d1969 7
d2142 13
d2171 1
d2188 2
d2201 2
a2202 1
      item->flags |= HOTLIST_G_IS_SELECTED;
d2204 1
a2204 1
      hotlist_redraw_items(menu_itemno, menu_itemno);
d2707 3
a2709 1

d2858 10
d2888 1
a2888 1
  // Not implemented yet...
d2890 1
a2890 1
  show_urls = show_urls;
d2957 2
d3048 3
d3220 4
a3223 1
    hotlist_redraw_now();
d3236 1
a3236 1
    //toolbox_hide_object(0, id_block->ancestor_id);
d3286 4
a3289 1
    hotlist_redraw_now();
d3299 1
d3413 3
a3415 1
  regs.r[1] = (int)item->name;
d3427 10
a3436 2
  hotlist_iconblock.data.it.buffer      = item->name;
  hotlist_iconblock.data.it.buffer_size = strlen(item->name);
d3774 1
d3794 1
d4228 45
@


1.2
log
@Revised selection model
@
text
@d122 1
a122 1
static hotlist_item    * _hotlist_find_item              (hotlist_item * list, unsigned int item_no);
d130 4
a133 4
static void              _hotlist_count_selected_items  (hotlist_item * list);
static unsigned int      hotlist_count_selected_items   (void);
static unsigned int      hotlist_contents_selected(hotlist_item *item);
static unsigned int      hotlist_no_contents_selected(hotlist_item *item);
d148 1
a148 1
static void              hotlist_setmenu_details         (ObjectId menuid);
d848 3
a850 1
  hotlist_item *newdir, *tempptr;
d863 6
a868 3
    /* Special case - moving a directory whose contents are only partially selected */
    /* we can't move a directory whose contents are only partially to be moved,     */
    /* there would be no where to leave the items which were not moved.             */
d870 3
d874 1
d878 1
d881 1
a881 1
        hotlist_move_item(source, newdir, HOTLIST_POSITION_END); /* move items into new directory */
d884 1
d952 1
a952 1

d1024 1
a1024 1
/* _hotlist_find_item()                          */
d1026 7
a1032 2
/* This function does all the work for           */
/* hotlist_find_item()                           */
d1034 1
a1034 2
/* Parameters: Pointer to a hotlist_item         */
/*             the n'th item to return           */
d1037 1
a1037 1
/*             NULL if it does not exist         */
d1040 18
a1057 1
static hotlist_item * _hotlist_find_item(hotlist_item * list, unsigned int item_no)
d1060 2
a1061 1
  while(list)
d1063 4
a1066 1
    if (item_no == item_number) return list;                             /* Found the list item */
d1068 3
d1073 2
a1074 1
      temp = _hotlist_find_item(list->data.directory_content, item_no);
d1077 3
a1080 1

a1081 22
  return NULL;                                                          /* List does not extend far enough */
}

/*************************************************/
/* hotlist_find_item()                           */
/*                                               */
/* This function will recursivly scan through    */
/* a hotlist structure and return a pointer to   */
/* the n'th item.  It will only recurse through  */
/* open directories.                             */
/*                                               */
/* Parameters: Pointer to a hotlist_item         */
/*             the n'th item to return           */
/*                                               */
/* Returns:    Pointer to the requested item or  */
/*             NULL if it does not exist         */
/*                                               */
/* Note:       This function doesn't actually    */
/*             do any of the real work but       */
/*             merely sets up a global variable  */
/*             and calls _hotlist_find_item()    */
/*************************************************/
d1083 1
a1083 4
static hotlist_item * hotlist_find_item(hotlist_item *list, unsigned int item_no)
{
  item_number = 0;
  return _hotlist_find_item(list, item_no);
d1669 1
a1669 1

d1671 1
a1671 1

d1848 1
a1848 1
        hotlist_set_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
d1852 1
a1852 1
        hotlist_clear_flags(item->data.directory_content, hl_ALL, HOTLIST_G_IS_SELECTED);
d2061 1
a2061 1
void hotlist_setmenu_details(ObjectId menuid)
d2161 1
a2161 1
  hotlist_setmenu_details(id_block->self_id);
a2808 3
hotlist_load("InetDBase:hotlist\n");
hotlist_open(Toolbox_ShowObject_Default, 0, 0);

d2861 5
a2865 2
/* This function handles the select all menu     */
/* item                                          */
d2868 1
a2868 1
static int hotlist_menu_selectall_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
d2870 2
a2871 2
  hotlist_item *item;
  ObjectId sub_menu;
d2880 2
a2881 1
    while(item)
d2885 1
d2888 1
d2890 1
d2893 1
d2895 2
a2896 1
    hotlist_setmenu_details(id_block->self_id);
d2898 2
a2899 1
  return 0;
d3434 2
a3435 2
           hotlist_count_selected_items() == 1 &&
           item->type == hl_directory &&
d3437 2
a3438 2
             !(item->flags & HOTLIST_D_IS_OPEN) ||
             hotlist_no_contents_selected(item->data.directory_content)   ||
d3677 1
a3677 1

d3680 1
a3680 1

d3682 1
a3682 1

d3697 2
a3698 2


d3923 8
a3930 5
/* This function is called as a null handler,    */
/* it is responsible for selecting for selecting */
/* and deselecting items within and outside of   */
/* the rubber box drag started by                */
/* hotlist_selection_box_start                   */
d3933 1
a3933 1
int hotlist_null_drag_select_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
d4028 4
a4031 1
/* _hotlist_count_selected_items()               */
d4033 8
a4040 2
/* This routine does all the work for            */
/* hotlist_count_selected_items()                */
d4043 1
a4043 1
static void _hotlist_count_selected_items(hotlist_item *list)
d4051 1
a4051 1
    else /* Only recurse through directories which are not selected */
d4053 2
d4057 1
a4057 1
        _hotlist_count_selected_items(list->data.directory_content);
d4060 1
d4068 1
a4068 4
/* This routine counts the number of selected    */
/* items                                         */
/*                                               */
/* Parameters: Pointer to a hotlist_item         */
d4070 1
a4070 1
/* Returns:    the number of selected items      */
d4076 3
a4078 1
  _hotlist_count_selected_items(hotlist_root->data.directory_content);
d4086 1
a4086 1
/* selected                                      */
d4089 1
a4089 1
/*             to check                          */
d4091 2
a4092 2
/* Returns:    1 if all items are selected       */
/*             0 if there are unselected items   */
d4095 1
a4095 1
static unsigned int hotlist_contents_selected(hotlist_item *item)
d4099 3
d4103 1
d4108 1
d4118 1
a4118 1
/* selected                                      */
d4121 1
a4121 1
/*             to check                          */
d4123 2
a4124 2
/* Returns:    1 if all items are selected       */
/*             0 if there are unselected items   */
d4127 1
a4127 1
static unsigned int hotlist_no_contents_selected(hotlist_item *item)
d4129 1
a4129 1
  while(item)
d4131 3
d4135 1
d4140 1
d4143 1
@


1.1
log
@Tidied up Hotlist source a bit
@
text
@d67 1
a67 2
static hotlist_item * selected_parent    = NULL;          /* The parent directory of all selected items */
static int            number_selected    = 0;             /* The number of items selected */
d130 4
d848 4
a851 1
  /* Unlink item from directory structure */
d853 1
a853 1
  hotlist_unlink(source);
d855 1
a855 1
  /* Link into new position in directory structure */
d857 21
a877 1
  return hotlist_link(source, target, position);
d941 1
a941 1

d944 4
a947 1
        RetError(hotlist_copy_item(content, newdir, HOTLIST_POSITION_END, NULL));
d1652 3
a1717 1
  number_selected = 0;
a1766 1
    number_selected--;
a1785 1
      number_selected--;
a1797 1
      number_selected++;
a1798 1
      selected_parent = item->parent;
d1813 6
a1818 4
      item->flags |= HOTLIST_G_IS_SELECTED;
      selected_parent = item->parent;
      number_selected++;
      hotlist_redraw_items(itemno, itemno);
a1823 1
    if (selected_parent != item->parent && item->type != hl_url) hotlist_clear_selection();
d1825 3
a1827 1
    if (item->flags & HOTLIST_G_IS_SELECTED)
d1829 8
a1836 1
      number_selected++;
d1838 1
a1838 7
    else
    {
      number_selected--;
    }
    hotlist_redraw_items(itemno, itemno);
    selected_parent = item->parent;
    last_selected_item = itemno;
a1839 1

d2031 1
a2031 1
  if (number_selected == -1)
d2034 1
a2034 1
    number_selected = 0;
d2050 1
a2050 1
  switch(number_selected)
d2127 1
a2127 1
  if (number_selected == 0)
d2139 1
a2139 2
      selected_parent = item->parent;
      number_selected = -1;
d2791 4
a2862 1
    number_selected = 0;
d2866 1
a2866 1
      number_selected++;
d2954 1
a2954 1
  if (!number_selected) return 0;
a2959 1
  number_selected = 0;
d3374 1
a3374 1
  if (number_selected > 1)
d3405 14
a3418 1
    if (number_selected == 1)
d3625 2
d3653 1
d3656 3
d3666 1
d3673 2
d3677 2
d3686 1
a3689 3
    number_selected = 0;
    selected_parent = NULL;

d3896 10
d3955 1
a3955 1
        if (number_selected == 0)
d3957 1
a3957 1
          if (!(maxx < itemxmin || minx > itemxmax) && (!(item->flags & HOTLIST_G_IS_SELECTED)))
d3961 5
a3965 2
            selected_parent = item->parent;
            number_selected++;
d3970 1
a3970 1
          if (!(maxx < itemxmin || minx > itemxmax))
d3972 3
a3974 1
            if ((selected_parent == item->parent || item->type == hl_url) && (!(item->flags & HOTLIST_G_IS_SELECTED)))
d3976 1
a3976 12
              item->flags |= HOTLIST_G_IS_SELECTED;
              hotlist_redraw_items(itemno, itemno);
              number_selected++;
            }
          }
          else
          {
            if (item->flags & HOTLIST_G_IS_SELECTED)
            {
              item->flags &= ~HOTLIST_G_IS_SELECTED;
              hotlist_redraw_items(itemno, itemno);
              number_selected--;
d3987 4
a3990 1
          number_selected--;
d3997 99
@

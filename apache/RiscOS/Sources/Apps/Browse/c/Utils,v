head	1.34;
access;
symbols
	Browse-2_16:1.34
	Browse-2_15:1.34
	Browse-2_14:1.34
	Browse-2_13:1.34
	Browse-2_12:1.34
	Browse-2_11:1.33
	Browse-2_10:1.33
	Browse-2_09:1.33
	ahodgkin_208_i4_2:1.32
	ahodgkin_208_i4:1.30
	ahodgkin_208_i3:1.30
	ahodgkin_208_i2:1.30
	ahodgkin_208_i1:1.29
	ahodgkin_207release:1.28
	ahodgkin_206release:1.26
	ahodgkin_205release:1.25
	ahodgkin_204release:1.25
	ahodgkin_202release:1.23
	ahodgkin_201release:1.22
	ahodgkin_200release:1.22
	ahodgkin_133beta:1.22
	ahodgkin_132beta:1.22
	ahodgkin_131beta:1.22
	ahodgkin_130beta:1.21
	ahodgkin_129:1.20
	ahodgkin_128beta:1.19
	ahodgkin_128alpha:1.18
	ahodgkin_127beta2:1.17
	ahodgkin_127beta:1.17
	ahodgkin_126beta:1.15
	ahodgkin_AW97patch:1.14
	ahodgkin_AW97:1.11;
locks; strict;
comment	@# @;


1.34
date	2006.03.13.22.06.20;	author ahodgkin;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.26.09.42.35;	author ahodgkin;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.14.08.45.08;	author ahodgkin;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.31.15.58.51;	author ahodgkin;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.25.17.08.55;	author ahodgkin;	state Exp;
branches;
next	1.29;

1.29
date	99.03.30.15.52.07;	author ahodgkin;	state Exp;
branches;
next	1.28;

1.28
date	98.09.23.13.18.16;	author ahodgkin;	state Exp;
branches;
next	1.27;

1.27
date	98.09.07.11.47.05;	author ahodgkin;	state Exp;
branches;
next	1.26;

1.26
date	98.07.09.10.27.30;	author ahodgkin;	state Exp;
branches;
next	1.25;

1.25
date	98.04.16.08.14.26;	author ahodgkin;	state Exp;
branches;
next	1.24;

1.24
date	98.03.26.14.21.12;	author ahodgkin;	state Exp;
branches;
next	1.23;

1.23
date	98.03.20.12.13.02;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	98.01.31.10.55.42;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	97.12.18.10.07.13;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	97.12.12.11.18.09;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	97.12.04.11.23.17;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	97.11.26.17.11.17;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	97.11.19.10.29.17;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	97.11.05.15.25.59;	author kbracey;	state Exp;
branches;
next	1.15;

1.15
date	97.10.30.17.11.18;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	97.10.22.13.16.01;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.10.20.07.09.23;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.10.18.16.42.32;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.10.03.09.19.07;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.09.18.08.59.04;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.09.03.12.36.13;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.09.02.15.46.09;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.08.31.18.38.25;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.08.28.16.08.09;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.08.18.09.24.09;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.08.08.16.38.58;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.07.30.12.39.11;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.07.25.12.52.34;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.29.14;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.34
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Utils.c                                           */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Infrequently altered utilities.                   */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 18-Oct-1996 (ADH): Created.                       */
/*          23-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <setjmp.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/event.h>
#include <tboxlibs/quit.h>
#include <tboxlibs/proginfo.h>
#include <tboxlibs/window.h>
#include <tboxlibs/gadgets.h>

#include "ToolAction.h" /* Local copy that doesn't use OSLib */

#include "Global.h"
#include "MiscDefs.h"
#include "FromROSLib.h"

#include "Main.h"
#include "NestWimp.h"
#include "RedrawCore.h"
#include "Save.h"
#include "Scale.h"
#include "Toolbars.h"

/* Debug build includes */

#ifdef TRACE

  /* Needed to check conversion to millipoints routines don't overflow */

  #include <math.h>

#endif

/* Finally, Utils.h itself */

#include "Utils.h"

/* Local definitions */

#define Acorn_Agent_Start     "Tematic-"
#define Acorn_Agent_Middle    " (RISC OS "
#define Acorn_Agent_End       ")"

#define Netscape_Agent_Start  "Mozilla/4.01 (Compatible; Tematic "
#define Netscape_Agent_Middle "; RISC OS "
#define Netscape_Agent_End    ")"

#define MillipointsPerOSUnit 400

/* Locals */

static int  millipoints_per_os_unit_x = 400; /* See read_os_to_points */
static int  millipoints_per_os_unit_y = 400;
static int  half_mppou_x              = 200;
static int  half_mppou_y              = 200;
static int  overflow_limit_x          = 0x28f5c1; /* = (0x3fffffff / 400) rounded down for caution*/
static int  overflow_limit_y          = 0x28f5c1;

/* Static function prototypes */

static char * lookup_in_given (MessagesFD * control, const char * s, int flag, const char * arg);

/**************************************************************/
/* lookup_token()                                             */
/*                                                            */
/* Returns a pointer to an expanded message token, or '!' if  */
/* there was an error.                                        */
/*                                                            */
/* Lookup is done into a global fixed-size buffer. So if you  */
/* pass multiple calls to this function in as parameters to   */
/* something else, *it will fail* as each call points to the  */
/* same buffer (which will only contain data from the last    */
/* call).                                                     */
/*                                                            */
/* On the upside this means you can modify the returned       */
/* string directly without having to worry about taking a     */
/* copy. If you do this, though, you *must* invalidate the    */
/* record of the last looked up token; "*lasttokn = '\0'" is  */
/* sufficient. This is all clearly hideous and best avoided,  */
/* but hey, it's handy from time to time...!                  */
/*                                                            */
/* Parameters: Pointer to a message token;                    */
/*                                                            */
/*             1 to report an error if the token isn't found  */
/*             as well as returning a string of '!', else 0;  */
/*                                                            */
/*             An optional pointer to an argument to          */
/*             substitute into the looked up string, or NULL. */
/*                                                            */
/* Returns:    Pointer to the full message text or '!' to     */
/*             signal an error; never a null pointer.         */
/*                                                            */
/* Assumes:    That the pointer to the message token is never */
/*             NULL.                                          */
/**************************************************************/

char * lookup_token(const char * s, int flag, const char * arg)
{
  dprintf(("MsgT", "lookup_token: Called, exitting through lookup_in_given\n"));

  return lookup_in_given(&meb, s, flag, arg);
}

/**************************************************************/
/* lookup_choice()                                            */
/*                                                            */
/* As lookup_token, but looks up the token in the Choices     */
/* file, rather than the Messages file.                       */
/*                                                            */
/* Parameters: As lookup_token.                               */
/*                                                            */
/* Returns:    As lookup_token.                               */
/*                                                            */
/* Assumes:    As lookup_token.                               */
/**************************************************************/

char * lookup_choice(const char * s, int flag, const char * arg)
{
  dprintf(("MsgT", "lookup_choice: Called, exitting through lookup_in_given\n"));

  return lookup_in_given(chb, s, flag, arg);
}

/**************************************************************/
/* lookup_control()                                           */
/*                                                            */
/* As lookup_token, but looks up the token in the Controls    */
/* file, rather than the Messages file.                       */
/*                                                            */
/* Parameters: As lookup_token.                               */
/*                                                            */
/* Returns:    As lookup_token.                               */
/*                                                            */
/* Assumes:    As lookup_token.                               */
/**************************************************************/

char * lookup_control(const char * s, int flag, const char * arg)
{
  dprintf(("MsgT", "lookup_control: Called, exitting through lookup_in_given\n"));

  return lookup_in_given(cob, s, flag, arg);
}

/**************************************************************/
/* lookup_in_given()                                          */
/*                                                            */
/* Workhorse back-end to lookup_token, lookup_choice and      */
/* so-on. See lookup_token for more information.              */
/*                                                            */
/* Parameters: A MessagesFD pointer, giving the control block */
/*             of the file to look in;                        */
/*                                                            */
/*             Pointer to a message token;                    */
/*                                                            */
/*             1 to report an error if the token isn't found  */
/*             as well as returning a string of '!', else 0;  */
/*                                                            */
/*             An optional pointer to an argument to          */
/*             substitute into the looked up string, or NULL. */
/*                                                            */
/* Returns:    Pointer to the full message text or '!' to     */
/*             signal an error; never a null pointer.         */
/*                                                            */
/* Assumes:    That the pointer to the message token is never */
/*             NULL.                                          */
/**************************************************************/

static char * lookup_in_given(MessagesFD * control, const char * s, int flag, const char * arg)
{
  _kernel_oserror * e;

  dprintf(("MsgT", "lookup_in_given: Lookup token '%s'\n",s));

  if (strcmp(lasttokn, (char *) s))
  {
    dprintf(("MsgT", "lookup_in_given: Proceeding\n"));

    StrNCpy0(lasttokn, (char *) s);

    e = _swix(MessageTrans_Lookup,
              _INR(0,7),

              control,            /* Pointer to control block               */
              s,                  /* String to look up                      */
              tokens,             /* Global buffer to take looked up string */
              sizeof(tokens) - 1, /* Size of the buffer                     */
              arg,                /* Parameter 0                            */
              0,                  /* Parameter 1                            */
              0,                  /* Parameter 2                            */
              0);                 /* Parameter 3                            */

    tokens[Limits_Message - 1] = 0;

    if (e)
    {
      /* If the lookup fails, put '!' into the lookup buffer and if the */
      /* flag passed into the function is 1, report the error too.      */

      dprintf(("MsgT", "lookup_in_given: Failed\n"));

      *lasttokn = 0;
      strcpy(tokens, "!");

      if (flag == 1) show_error_cont(e);
    }
  }

  dprintf(("MsgT", "lookup_in_given: Returning %s\n",tokens));

  return (char *) &tokens;
}

/**************************************************************/
/* show_error()                                               */
/*                                                            */
/* Reports a (generally serious) error and exits with         */
/* EXIT_FAILURE.                                              */
/*                                                            */
/* Parameters: Pointer to a _kernel_oserror structure.        */
/*                                                            */
/* Assumes:    The pointer may be NULL.                       */
/**************************************************************/

void show_error(_kernel_oserror * e)
{
  if (e!=NULL)
  {
    _kernel_swi_regs r;
    char             name[Limits_TaskName];
    char             spri[Limits_OS_SpriteName];
    WimpSysInfo      s;

    /* This call checks if errors can be reported in the Desktop, */
    /* or if they need to go into a command window (useful for    */
    /* CLI routines for example)                                  */

    s.r0=0;
    s.r1=0;
    wimp_read_sys_info(3,&s);

    if (s.r0==0) fprintf(stderr,"%s\n",e->errmess);
    else
    {
      StrNCpy0(name,lookup_token("_TaskName:Browse",0,0));  /* Task name for 'Message from...' */
      StrNCpy0(spri,lookup_token("_SpriName:!browse",0,0)); /* Sprite name to put in error box */

      r.r[0] = (int) e;                                       /* Pointer to error block           */
      r.r[1] = (2<<9)+(1<<8);                                 /* Category 2 (warning)             */
      r.r[2] = (int) &name;                                   /* Application name looked up above */
      r.r[3] = (int) &spri;                                   /* Sprite name looked up above      */
      r.r[4] = 1;                                             /* Sprite block pointer (1 = WIMP)  */
      r.r[5] = (int) lookup_token("ErrorBtns:Quit",0,0);      /* Custom button, 'Quit'            */

      _kernel_swi(Wimp_ReportError,&r,&r);
    }

    exit(EXIT_FAILURE); /* Exit after reporting the error */
  }
}

/**************************************************************/
/* show_error_cont()                                          */
/*                                                            */
/* Reports an error but allows execution to then continue     */
/* (rather than calling exit()) if the user clicks on         */
/* 'Continue' rather than 'Quit'. This is accomplished by a   */
/* longjmp back into wherever the setjmp was (e.g. in a poll  */
/* loop).                                                     */
/*                                                            */
/* Parameters: Pointer to a _kernel_oserror structure.        */
/*                                                            */
/* Assumes:    The pointer may be NULL.                       */
/**************************************************************/

void show_error_cont(_kernel_oserror * e)
{
  if (e!=NULL)
  {
    _kernel_swi_regs r;
    char             name[Limits_TaskName];
    char             spri[Limits_OS_SpriteName];
    WimpSysInfo      s;

    #ifdef TRACE
      if (e->errnum == Utils_Error_Custom_Fatal) e->errnum = Utils_Error_Custom_Normal;
    #endif

    /* Force 'Quit' only for fatal errors */

    if (e->errnum == Utils_Error_Custom_Fatal) show_error(e);

    /* This all works in much the same way as show_error above. */

    s.r0=0;
    s.r1=0;
    wimp_read_sys_info(3,&s);

    if (s.r0==0) fprintf(stderr,"%s\n",e->errmess);
    else
    {
      StrNCpy0(name, lookup_token("_TaskName:Browse",0,0));
      StrNCpy0(spri, lookup_token("_SpriName:!browse",0,0));

      r.r[0] = (int) e;
      r.r[1] = (2<<9)+(1<<8)+1;
      r.r[2] = (int) &name;
      r.r[3] = (int) &spri;
      r.r[4] = 1;

      /* Have a quit button if not running full screen and the */
      /* error number isn't one defined as having a Continue   */
      /* button only.                                          */

      if (
           e->errnum != Utils_Error_OS_Escape      &&
           e->errnum != Utils_Error_Custom_Message &&
           !choices.full_screen
         )
         r.r[5] = (int) lookup_token("ErrorBtns:Quit",0,0);

      else r.r[5] = 0;

      _kernel_swi(Wimp_ReportError,&r,&r);

      if (r.r[1] == 1) longjmp(env, Main_FromShowErrorCont);

      exit(EXIT_FAILURE); /* Exit if 'Quit' is selected */
    }
  }
}

/**************************************************************/
/* show_error_ret()                                           */
/*                                                            */
/* Reports an error but allows execution to then continue     */
/* (rather than calling exit()) if the user clicks on         */
/* 'Continue' rather than 'Quit'. This is accomplished by     */
/* simply returning.                                          */
/*                                                            */
/* Parameters: Pointer to a _kernel_oserror structure.        */
/*                                                            */
/* Assumes:    The pointer may be NULL.                       */
/**************************************************************/

void show_error_ret(_kernel_oserror * e)
{
  if (e!=NULL)
  {
    _kernel_swi_regs r;
    char             name[Limits_TaskName];
    char             spri[Limits_OS_SpriteName];
    WimpSysInfo      s;

    #ifdef TRACE
      if (e->errnum == Utils_Error_Custom_Fatal) e->errnum = Utils_Error_Custom_Normal;
    #endif

    /* Force 'Quit' only for fatal errors */

    if (e->errnum == Utils_Error_Custom_Fatal) show_error(e);

    /* This all works in much the same way as show_error above. */

    s.r0=0;
    s.r1=0;
    wimp_read_sys_info(3,&s);

    if (s.r0==0) fprintf(stderr,"%s\n",e->errmess);
    else
    {
      StrNCpy0(name, lookup_token("_TaskName:Browse",0,0));
      StrNCpy0(spri, lookup_token("_SpriName:!browse",0,0));

      r.r[0] = (int) e;
      r.r[1] = (2<<9)+(1<<8)+1;
      r.r[2] = (int) &name;
      r.r[3] = (int) &spri;
      r.r[4] = 1;

      /* Have a quit button if not running full screen and the */
      /* error number isn't one defined as having a Continue   */
      /* button only.                                          */

      if (
           e->errnum != Utils_Error_OS_Escape      &&
           e->errnum != Utils_Error_Custom_Message &&
           !choices.full_screen
         )
         r.r[5] = (int) lookup_token("ErrorBtns:Quit",0,0);

      else r.r[5] = 0;

      _kernel_swi(Wimp_ReportError,&r,&r);

      if (r.r[1] != 1) exit(EXIT_FAILURE); /* Exit if 'Quit' is selected, else return normally */
    }
  }
}

/**************************************************************/
/* show_error_ask()                                           */
/*                                                            */
/* Reports an error as a query - return result of button      */
/* selection by user.                                         */
/*                                                            */
/* Parameters: Pointer to a _kernel_oserror structure.        */
/*                                                            */
/*             Pointer to a MessageTrans token to look up -   */
/*             the text is used for the buttons in the error  */
/*             box.                                           */
/*                                                            */
/* Assumes:    The error pointer may be NULL. If so, the      */
/*             other two are ignored as well. If not, the     */
/*             other must not be NULL.                        */
/*                                                            */
/* Returns:    Return value of R1 from call to SWI            */
/*             Wimp_ReportError (3, 4 or 5, depending on      */
/*             which of the up to 3 custom buttons were       */
/*             activated).                                    */
/**************************************************************/

int show_error_ask(_kernel_oserror * e, const char * buttons)
{
  if (e!=NULL)
  {
    _kernel_swi_regs r;
    char             name[Limits_TaskName];
    char             spri[Limits_OS_SpriteName];
    WimpSysInfo      s;

    #ifdef TRACE
      if (e->errnum == Utils_Error_Custom_Fatal) e->errnum = Utils_Error_Custom_Normal;
    #endif

    /* Force 'Quit' only for fatal errors */

    if (e->errnum == Utils_Error_Custom_Fatal) show_error(e);

    /* This all works in much the same way as show_error above. */

    s.r0=0;
    s.r1=0;
    wimp_read_sys_info(3,&s);

    if (s.r0==0) fprintf(stderr,"%s\n",e->errmess);
    else
    {
      StrNCpy0(name, lookup_token("_TaskName:Browse",0,0));
      StrNCpy0(spri, lookup_token("_SpriName:!browse",0,0));

      r.r[0] = (int) e;
      r.r[1] = (4<<9)+(1<<8);
      r.r[2] = (int) &name;
      r.r[3] = (int) &spri;
      r.r[4] = 1;

      r.r[5] = (int) lookup_token((char *) buttons,0,0);

      _kernel_swi(Wimp_ReportError,&r,&r);

      return r.r[1];
    }
  }

  return 0;
}

/**************************************************************/
/* report_toolbox_error()                                     */
/*                                                            */
/* If the toolbox generates an error this function will be    */
/* called to report it. Parameters are as standard for a      */
/* Toolbox event handler.                                     */
/**************************************************************/

int report_toolbox_error(int eventcode,ToolboxEvent *event,IdBlock *idb,void *handle)
{
  ChkError((_kernel_oserror *) &event->data);

  return 1;
}

#ifdef JAVASCRIPT

  /**************************************************************/
  /* make_no_javascript_memory_error()                          */
  /*                                                            */
  /* Called if a general allocation error appears to have       */
  /* occurred whilst doing some JavaScript related operation.   */
  /*                                                            */
  /* Parameters: A numerical value to include in the message to */
  /*             help the programmer know where the error came  */
  /*             from.                                          */
  /**************************************************************/

  _kernel_oserror * make_no_javascript_memory_error(int stage)
  {
    char num[20];

    sprintf(num, "%d", stage);
    return make_general_error("NoMemJSc:There is not enough free memory for this JavaScript operation (%0).",
                              num);
  }

#endif

/**************************************************************/
/* make_no_fetch_memory_error()                               */
/*                                                            */
/* Typically called from Fetch.c, if a memory claim fails     */
/* early in a fetch. Stores an appropriate error in the       */
/* global error block 'erb'.                                  */
/*                                                            */
/* Parameters: A numerical value to include in the message to */
/*             help the programmer know where the error came  */
/*             from.                                          */
/**************************************************************/

_kernel_oserror * make_no_fetch_memory_error(int stage)
{
  char num[20];

  sprintf(num, "%d", stage);
  return make_general_error("NoMemFet:There is not enough free memory to perform this fetch (%0).",
                            num);
}

/**************************************************************/
/* make_no_cont_memory_error()                                */
/*                                                            */
/* Called if a memory claim fails during a fetch - stores an  */
/* appropriate error in the global error block 'erb'.         */
/*                                                            */
/* Parameters: A numerical value to include in the message to */
/*             help the programmer know where the error came  */
/*             from.                                          */
/**************************************************************/

_kernel_oserror * make_no_cont_memory_error(int stage)
{
  char num[20];

  sprintf(num, "%d", stage);
  return make_general_error("NoMemRea:There is not enough free memory to continue the page fetch (%0).",
                            num);
}

/**************************************************************/
/* make_no_table_memory_error()                               */
/*                                                            */
/* Typically called from Tables.c, if a memory claim fails    */
/* during table parsing routines. Stores an appropriate error */
/* in the global error block 'erb'.                           */
/*                                                            */
/* Parameters: A numerical value to include in the message to */
/*             help the programmer know where the error came  */
/*             from.                                          */
/**************************************************************/

_kernel_oserror * make_no_table_memory_error(int stage)
{
  char num[20];

  sprintf(num, "%d", stage);
  return make_general_error("NoMemTab:There is not enough free memory to display this table (%0).",
                            num);
}

/**************************************************************/
/* make_no_memory_error()                                     */
/*                                                            */
/* A general error generation routine for failed memory       */
/* claims. Stores the error in the global error block 'erb'.  */
/*                                                            */
/* Parameters: A numerical value to include in the message to */
/*             help the programmer know where the error came  */
/*             from.                                          */
/**************************************************************/

_kernel_oserror * make_no_memory_error(int stage)
{
  char num[20];

  sprintf(num, "%d", stage);
  return make_general_error("NoMemGen:There is not enough free memory to continue this operation (%0).",
                            num);
}

/**************************************************************/
/* make_general_error()                                       */
/*                                                            */
/* Construct a general error block with error number zero and */
/* the given Messages token with up to one parameter to be    */
/* subtituted included. Builds in the global error block      */
/* 'erb' using error number Utils_Error_Custom_Normal (to     */
/* lead to a "continue" or "quit" choice for the user) and    */
/* returns a pointer back to the 'erb' for the caller's       */
/* convenience.                                               */
/*                                                            */
/* Parameters: NUL-terminated token to look up including an   */
/*             optional expansion ("Token:Expansion text");   */
/*                                                            */
/*             NUL-terminated parameter for substitution, or  */
/*             NULL if there is no parameter needed.          */
/**************************************************************/

_kernel_oserror * make_general_error(const char * token, const char * param)
{
  erb.errnum =  Utils_Error_Custom_Normal;
  StrNCpy0(erb.errmess, lookup_token(token, 0, param));

  return &erb;
}

/**************************************************************/
/* utils_kernel_last_error()                                  */
/*                                                            */
/* Store _kernel_last_oserror() in local error block 'erb'    */
/* with error number Utils_Error_Custom_Message. If there is  */
/* no last error (_kernel_last_oserror() returns NULL), an    */
/* "unidentified error" message is used instead. This allows  */
/* callers to store the last kernel error after operations    */
/* which might sometimes not set it, and still have something */
/* vaguely sensible happen later without lots of checking for */
/* NULL externally.                                           */
/*                                                            */
/* Returns a pointer to the local error block 'erb' for the   */
/* caller's convenience.                                      */
/**************************************************************/

_kernel_oserror * utils_kernel_last_error(void)
{
  _kernel_oserror * e = _kernel_last_oserror();

  if (e == NULL)
  {
    e = make_general_error("EUnknown:An unidentified error was encountered.", NULL);
    e->errnum = Utils_Error_Custom_Message;

    return e;
  }
  else
  {
    erb        = *e;
    erb.errnum = Utils_Error_Custom_Message;

    return &erb;
  }
}

/**************************************************************/
/* show_centred()                                             */
/*                                                            */
/* Shows a Toolbox object centred to the screen, opened       */
/* persistently where possible                                */
/*                                                            */
/* Parameters: An Object ID of any Toolbox object that will   */
/*             return its Wimp window handle when             */
/*             Toolbox_ObjectMiscOp is called for it with a   */
/*             reason code of 0 - e.g. Window, DCS, or        */
/*             ColourDBox.                                    */
/*                                                            */
/* Assumes:    That the ID is a valid one.                    */
/**************************************************************/

void show_centred(ObjectId o)
{
  WimpGetWindowStateBlock w;
  ObjectId                p;
  BBox                    b;
  _kernel_oserror        *e;

  /* Get the Wimp window handle of the Toolbox object */
  /* and get its size using Wimp_GetWindowState. This */
  /* sounds simple, but there's a different function  */
  /* call to get the window handle for each object    */
  /* class. The best (but still poor) approach is to  */
  /* call the Toolbox_MiscOp SWI with a reason code   */
  /* of 0, which in most cases will mean 'return Wimp */
  /* window handle'. If this is not the case for an   */
  /* object type, the Wimp call will then fault and   */
  /* this error condition can be used to default down */
  /* to some coordinate value that seems appropriate. */

  w.window_handle = 0;

  _swix(Toolbox_ObjectMiscOp,
        _INR(0,2) | _OUT(0),

        0,
        o,
        0,

        &w.window_handle);

  e = wimp_get_window_state(&w);

  if (e != NULL)
  {
    w.visible_area.xmin = 480;
    w.visible_area.ymin = 320;
  }
  else
  {
    w.visible_area.xmin = w.visible_area.xmax - w.visible_area.xmin;
    w.visible_area.ymin = w.visible_area.ymax - w.visible_area.ymin;
  }

  /* Find the screen x and y size in pixels and scale them  */
  /* to OS units using OS_ReadModeVariable calls; also work */
  /* out the top left coordinates at the same time          */

  _swix(OS_ReadModeVariable,_INR(0,1) | _OUT(2),-1,11,&w.xscroll);
  _swix(OS_ReadModeVariable,_INR(0,1) | _OUT(2),-1,4,&w.yscroll);
  b.xmin = (((w.xscroll + 1) << w.yscroll) - w.visible_area.xmin) / 2;

  _swix(OS_ReadModeVariable,_INR(0,1) | _OUT(2),-1,12,&w.xscroll);
  _swix(OS_ReadModeVariable,_INR(0,1) | _OUT(2),-1,5,&w.yscroll);
  b.ymin = (((w.xscroll + 1) << w.yscroll) + w.visible_area.ymin) / 2;

  ChkError(toolbox_get_parent(0,o,&p,NULL));

  ChkError(toolbox_show_object(0,       /* Bit 0 set - Wimp_CreateMenu semantics;          */
                                        /* Bit 1 set - Wimp_CreateSubMenu semantics        */
                               o,       /* Object ID given to function                     */
                               2,       /* 0 - 'default position'; 1 - specify position in */
                                        /* full; 2 - use top left corner coordinate pair   */
                               &b.xmin, /* Top left corner coordinate pair                 */
                               p,       /* Parent object ID                                */
                               -1));    /* Parent component ID (not interested in that)    */
}

/**************************************************************/
/* set_corrected_extent()                                     */
/*                                                            */
/* Sets the extent of a window, making sure that xmin = 0 and */
/* ymax = 0 (so ymin is negative, etc. etc.) - this means     */
/* that topx = topy = 0.                                      */
/*                                                            */
/* Parameters: Flags to pass to the Toolbox in the SetExtent  */
/*             call;                                          */
/*                                                            */
/*             The object ID of the browser window to be      */
/*             altered;                                       */
/*                                                            */
/*             Pointer to a BBox holding the extent           */
/*             coordinates.                                   */
/**************************************************************/

_kernel_oserror * set_corrected_extent(unsigned int f, ObjectId o, BBox * w)
{
  BBox t;

  t.xmin = 0;
  t.ymin = w->ymin - w->ymax;
  t.xmax = w->xmax - w->xmin;
  t.ymax = 0;

  return window_set_extent(f,o,&t);
}

/**************************************************************/
/* find_behind()                                              */
/*                                                            */
/* Returns the window handle of the first non- pane window in */
/* front of a given window.                                   */
/*                                                            */
/* Parameters: The window handle in question.                 */
/*                                                            */
/* Returns:    Handle of the first non-pane window in front   */
/*             of the given one, or -1 if it is at the top of */
/*             the stack.                                     */
/**************************************************************/

int find_behind(int w)
{
  WimpGetWindowStateBlock s;

  s.window_handle = w;

  ChkError(wimp_get_window_state(&s));

  if (s.behind != -1)
  {
    do
    {
      s.window_handle = s.behind;
      ChkError(wimp_get_window_state(&s));
    }
    while(((s.flags & WimpWindow_Pane) != 0) && (s.behind != -1));

    s.behind = s.window_handle;
  }

  return s.behind;
}

/**************************************************************/
/* find_tool_sizes()                                          */
/*                                                            */
/* Returns the title bar and scroll bar widths in OS units,   */
/* including their outlines.                                  */
/*                                                            */
/* Parameters: Pointer to an int, in which the title bar      */
/*             height is placed;                              */
/*                                                            */
/*             Pointer to an int, in which the horizontal     */
/*             scroll bar bar height is placed;               */
/*                                                            */
/*             Pointer to an int, in which the vertical       */
/*             scroll bar width is placed.                    */
/*                                                            */
/* Assumes:    Any of the pointers may be NULL.               */
/**************************************************************/

_kernel_oserror * find_tool_sizes(int * theight, int * hheight, int * vwidth)
{
  _kernel_oserror           * e;
  WimpGetWindowOutlineBlock   outline;
  WimpGetWindowStateBlock     s;
  ObjectId                    o;
  int                         th, hh, vw;

  /* Create an object with a title bar and both scroll bars */

  e = toolbox_create_object(0, "ToolSizes", &o);
  if (e) return e;

  /* Open it behind the Pinboard */

  s.visible_area.xmin = 256;
  s.visible_area.ymin = 256;
  s.visible_area.xmax = 512;
  s.visible_area.ymax = 512;
  s.xscroll           = 0;
  s.yscroll           = 0;
  s.behind            = -3;

  e = toolbox_show_object(0, o, Toolbox_ShowObject_FullSpec, &s.visible_area, 0, -1);
  if (e) return e;

  /* Get the window state (for current visible area) and outline */

  e = window_get_wimp_handle(0, o, &s.window_handle);
  if (e) return e;

  e = wimp_get_window_state(&s);
  if (e) return e;

  outline.window_handle = s.window_handle;
  e = wimp_get_window_outline(&outline);
  if (e) return e;

  /* Work out the various sizes */

  th = outline.outline.ymax - s.visible_area.ymax;
  hh = s.visible_area.ymin - outline.outline.ymin;
  vw = outline.outline.xmax - s.visible_area.xmax;

  if (theight) *theight = th;
  if (hheight) *hheight = hh;
  if (vwidth)  *vwidth  = vw;

  /* Return via. deleting the temporary window */

  return toolbox_delete_object(0, o);
}

/**************************************************************/
/* register_null_claimant()                                   */
/*                                                            */
/* Call if you want to claim null polls.                      */
/*                                                            */
/* Parameters: As for a Wimp event handler, but without the   */
/*             object ID.                                     */
/**************************************************************/

void register_null_claimant(int eventcode,WimpEventHandler * handler,browser_data * handle)
{
  null_counter++;
  ChkError(event_register_wimp_handler(-1,eventcode,handler,handle));

  #ifdef TRACE
    {
      int   shut_up_compiler = (int)   handler;
      int * function_name    = (int *) shut_up_compiler;

      dprintf(("Null", "register_null_claimant:   Registered a claimant for browser %p\n", handle));

      /* If the word before the function address has ff in the high */
      /* byte, the function name starts as many bytes before the    */
      /* function address as specified in the low 3 bytes.          */

      function_name -= 1;

      if (((*function_name) & 0xff000000) == 0xff000000)
      {
        dprintf(("Null", "                          Handler is '\0213%s\0217'\n", (char *) (((char *) function_name) - ((*function_name) & 0x00ffffff))));
      }
      else
      {
        dprintf(("Null", "                          Cannot find handler's name; address is \02130x%08x\0217\n", (int) handler));
      }
    }
  #endif

  if (null_counter == 1)
  {
    unsigned int mask;

    ChkError(event_get_mask(&mask));
    mask = (mask & (~Wimp_Poll_NullMask));
    ChkError(event_set_mask(mask));

    dprintf(("Null", "register_null_claimant:   \0211Nulls claimed\0217\n"));
  }
}

/**************************************************************/
/* deregister_null_claimant()                                 */
/*                                                            */
/* Call if you want to release null polls.                    */
/*                                                            */
/* Parameters: As for a Wimp event handler, but without the   */
/*             object ID.                                     */
/**************************************************************/

void deregister_null_claimant(int eventcode,WimpEventHandler * handler,browser_data * handle)
{
  null_counter--;
  ChkError(event_deregister_wimp_handler(-1,eventcode,handler,handle));

  #ifdef TRACE
    {
      int   shut_up_compiler = (int)   handler;
      int * function_name    = (int *) shut_up_compiler;

      dprintf(("Null", "deregister_null_claimant: Deregistered a claimant for browser %p\n", handle));

      /* If the word before the function address has ff in the high */
      /* byte, the function name starts as many bytes before the    */
      /* function address as specified in the low 3 bytes.          */

      function_name -= 1;

      if (((*function_name) & 0xff000000) == 0xff000000)
      {
        dprintf(("Null", "                          Handler is '\0216%s\0217'\n", (char *) (((char *) function_name) - ((*function_name) & 0x00ffffff))));
      }
      else
      {
        dprintf(("Null", "                          Cannot find handler's name; address is \2160x%08x\0217\n", (int) handler));
      }
    }
  #endif

  if (null_counter < 0) null_counter = 0;

  if (!null_counter)
  {
    unsigned int mask;

    ChkError(event_get_mask(&mask));
    mask = (mask | Wimp_Poll_NullMask);
    ChkError(event_set_mask(mask));

    dprintf(("Null", "deregister_null_claimant: \0212Nulls released\0217\n"));
  }
}

/**************************************************************/
/* utils_intersection()                                       */
/*                                                            */
/* Takes two BBoxes and updates a third to the intersection   */
/* of the two.                                                */
/*                                                            */
/* Parameters: Pointer to a BBox where x/ymin are inclusive   */
/*             and x/ymax are exclusive;                      */
/*                                                            */
/*             Pointer to a second BBox where x/ymin are also */
/*             inclusive and x/ymax exclusive;                */
/*                                                            */
/*             Pointer to the BBox to take rectangle formed   */
/*             by the intersection of the first two or NULL   */
/*             if not interested (you just want to look at    */
/*             the return value); x/ymin will be inclusive,   */
/*             x/ymax will be exclusive.                      */
/*                                                            */
/* Returns:    1 if the two did intersect, else zero (the     */
/*             intersection bounding box contents will NOT be */
/*             updated).                                      */
/**************************************************************/

int utils_intersection
    (
      const BBox * restrict a,
      const BBox * restrict b,
      BBox       * restrict intersect
    )
{
  #define utils_intersection_temp_max(a,b) ((a) > (b) ? (a) : (b))
  #define utils_intersection_temp_min(a,b) ((a) < (b) ? (a) : (b))

  if (a == NULL || b == NULL) return 0;

  if (
       (a->xmin >= b->xmax) ||
       (a->xmax <= b->xmin) ||
       (a->ymin >= b->ymax) ||
       (a->ymax <= b->ymin)
     )
     return 0;

  if (intersect != NULL)
  {
    intersect->xmin = utils_intersection_temp_max(a->xmin, b->xmin);
    intersect->xmax = utils_intersection_temp_min(a->xmax, b->xmax);
    intersect->ymin = utils_intersection_temp_max(a->ymin, b->ymin);
    intersect->ymax = utils_intersection_temp_min(a->ymax, b->ymax);
  }

  #undef utils_intersection_temp_max
  #undef utils_intersection_temp_min

  return 1;
}

/**************************************************************/
/* utils_set_graphics_window()                                */
/*                                                            */
/* Intended for redraw loop routines, this sets up a given    */
/* graphics rectangle, but takes account of the intersection  */
/* between this and the current (given) graphics rectangle    */
/* for the redraw. The rectangle *must* be restored with      */
/* restore_graphics_intersection() as soon as the rectangle   */
/* set here is finished with; the caller must thus remember   */
/* this rectangle for later.                                  */
/*                                                            */
/* If using vectored redraw output, do not use this call.     */
/* utils_intersection and redrawcore_clipping are all you     */
/* should need.                                               */
/*                                                            */
/* Parameters: Pointer to a BBox describing the rectangle to  */
/*             set, where xmax and ymax are exclusive;        */
/*                                                            */
/*             Pointer to a BBox describing the current       */
/*             graphics rectangle, where xmax and ymax are    */
/*             exclusive (e.g. as in a                        */
/*             WimpRedrawWindowBlock's redraw_area BBox).     */
/*                                                            */
/*             Pointer to the BBox to take rectangle formed   */
/*             by the intersection of the first two or NULL   */
/*             if not interested.                             */
/*                                                            */
/* Returns:    1 if the two did intersect, else zero (the     */
/*             intersection bounding box contents will not be */
/*             updated and no change was made to the graphics */
/*             window so no subsequent restoration is         */
/*             required).                                     */
/**************************************************************/

int utils_set_graphics_window
    (
      const BBox * restrict rbox,
      const BBox * restrict cbox,
      BBox       * restrict ibox
    )
{
  BBox inrect;

  /* Any intersection? */

  if (utils_intersection(rbox, cbox, &inrect) == 0) return 0;

  /* Yes, so set the window */

  bbc_gwindow(inrect.xmin,
              inrect.ymin,
              inrect.xmax - 1,
              inrect.ymax - 1);

  /* Update the caller's record of the intersection, if one */
  /* was given.                                             */

  if (ibox != NULL) *ibox = inrect;

  return 1;
}

/**************************************************************/
/* utils_restore_graphics_window()                            */
/*                                                            */
/* Restores the Wimp's redraw graphics rectangle which was    */
/* changed by a call to utils_set_graphics_window (which      */
/* must have been called before this restoring function).     */
/*                                                            */
/* If using vectored redraw output, do not use this call.     */
/* utils_intersection and redrawcore_clipping are all you     */
/* should need.                                               */
/*                                                            */
/* Parameters: Pointer to a BBox holding the graphics         */
/*             rectangle as it was before                     */
/*             set_graphics_intersection was called, where    */
/*             xmax and ymax are exclusive (e.g. as in a      */
/*             WimpRedrawWindowBlock's redraw_area BBox).     */
/**************************************************************/

void utils_restore_graphics_window(const BBox * restrict cbox)
{
  bbc_gwindow(cbox->xmin,
              cbox->ymin,
              cbox->xmax - 1,
              cbox->ymax - 1);
}

/**************************************************************/
/* read_os_to_points()                                        */
/*                                                            */
/* To avoid having to use a SWI every time a conversion is    */
/* made between OS units and points or vice versa, this       */
/* initialises some internal variables which are used         */
/* subsequently. It may be called on a mode change, for       */
/* example, to ensure things are up to date.                  */
/*                                                            */
/* If printing, values of MillipointsPerOSUnit as defined at  */
/* the top of this file are used, since you can't read it; it */
/* seems that during a print job, this call may *not* be      */
/* used, contrary to the information on PRM 3-573. This bug   */
/* caused *severe* grief during the development of the print  */
/* routines...                                                */
/**************************************************************/

void read_os_to_points(void)
{
  int x = 1, y = 1;

  if (!printing)
  {
    if (
          _swix(Font_Converttopoints,
                _INR(1,2) | _OUTR(1,2),

                x,
                y,

                &x,
                &y)
       )
    {
      millipoints_per_os_unit_x = MillipointsPerOSUnit;
      millipoints_per_os_unit_y = MillipointsPerOSUnit;
    }
    else
    {
      millipoints_per_os_unit_x = x;
      millipoints_per_os_unit_y = y;
    }
  }
  else
  {
    millipoints_per_os_unit_x = MillipointsPerOSUnit;
    millipoints_per_os_unit_y = MillipointsPerOSUnit;
  }

  overflow_limit_x = (0x3fffffff / millipoints_per_os_unit_x) - 1;
  overflow_limit_y = (0x3fffffff / millipoints_per_os_unit_y) - 1;

  half_mppou_x = millipoints_per_os_unit_x / 2;
  half_mppou_y = millipoints_per_os_unit_y / 2;
}

/**************************************************************/
/* convert_pair_to_os()                                       */
/*                                                            */
/* Converts from millipoints to OS units. The scale factor is */
/* determined by a previous call to read_os_to_points.        */
/*                                                            */
/* Parameters: A coordinate in millipoints;                   */
/*                                                            */
/*             Another coord in millipoints;                  */
/*                                                            */
/*             Pointer to an int into which the first         */
/*             coordinate, converted to OS units, is placed;  */
/*                                                            */
/*             Similarly a pointer to an int for the second   */
/*             coordinate.                                    */
/*                                                            */
/* Assumes:    The pointers may NOT be NULL. The input and    */
/*             output variables may be the same (so passing   */
/*             in x, y, &x, &y would work correctly).         */
/**************************************************************/

void convert_pair_to_os(int x, int y, int * restrict osx, int * restrict osy)
{
  *osx = ((x + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
  *osy = ((y + half_mppou_y) / millipoints_per_os_unit_y) & ~(wimpt_dy() - 1);
}

/**************************************************************/
/* convert_pair_to_points()                                   */
/*                                                            */
/* Converts from OS units to millipoints. The scale factor is */
/* determined by a previous call to read_os_to_points.        */
/*                                                            */
/* Parameters: A coordinate in OS units;                      */
/*                                                            */
/*             Another coordinate in OS units;                */
/*                                                            */
/*             Pointer to an int into which the first         */
/*             coordinate, converted to millipoints, is       */
/*             placed;                                        */
/*                                                            */
/*             Similarly a pointer to an int for the second   */
/*             coordinate.                                    */
/*                                                            */
/* Assumes:    The pointers may not be NULL. The input and    */
/*             output variables may be the same (so passing   */
/*             in x, y, &x, &y would work correctly).         */
/**************************************************************/

void convert_pair_to_points(int x, int y, int * restrict mpx, int * restrict mpy)
{
  #ifdef TRACE

    if (abs(x) > overflow_limit_x || abs(y) > overflow_limit_y)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,
              "convert_pair_to_points: Can't convert (%d, %d) to millipoints without overflow.",
              x,y);

      show_error_ret(&erb);

      *mpx = *mpy = 0;

      return;
    }

  #endif

  *mpx = x * millipoints_per_os_unit_x;
  *mpy = y * millipoints_per_os_unit_y;
}

/**************************************************************/
/* convert_to_os()                                            */
/*                                                            */
/* As convert_pair_to_os, but only converts one coordinate at */
/* a time.                                                    */
/*                                                            */
/* Parameters: An x coordinate in millipoints;                */
/*                                                            */
/*             Pointer to an int into which the coordinate,   */
/*             converted to OS units, is placed.              */
/*                                                            */
/* Assumes:    That the pointer is not NULL. The input and    */
/*             output variable may be the same (so passing in */
/*             x, &x would work correctly);                   */
/*                                                            */
/*             If x and y scalings differ, this will only     */
/*             ever use the x scaling.                        */
/**************************************************************/

void convert_to_os(int x, int * restrict osx)
{
  *osx = ((x + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
}

/**************************************************************/
/* convert_to_points()                                        */
/*                                                            */
/* As convert_pair_to_points, but only converts one           */
/* coordinate at a time.                                      */
/*                                                            */
/* Parameters: An x coordinate in OS units;                   */
/*                                                            */
/*             Pointer to an int into which the coordinate,   */
/*             converted to milli- points, is placed.         */
/*                                                            */
/* Assumes:    That the pointer is not NULL. The input and    */
/*             output variable may be the same (so passing in */
/*             x, &x would work correctly);                   */
/*                                                            */
/*             If x and y scalings differ, this will only     */
/*             ever use the x scaling.                        */
/**************************************************************/

void convert_to_points(int x, int * restrict mpx)
{
  #ifdef TRACE

    if (abs(x) > overflow_limit_x)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,
              "convert_to_points: Can't convert '%d' to millipoints without overflow.",
              x);

      show_error_ret(&erb);

      *mpx = 0;

      return;
    }

  #endif

  *mpx = x * millipoints_per_os_unit_x;
}

/**************************************************************/
/* convert_box_to_os()                                        */
/*                                                            */
/* As convert_pair_to_os, but converts the four coordinates   */
/* inside a BBox in one go.                                   */
/*                                                            */
/* Parameters: Pointer to a BBox containing coords in         */
/*             millipoints;                                   */
/*                                                            */
/*             Pointer to a BBox into which the first box's   */
/*             coords, converted to OS units, are placed.     */
/*                                                            */
/* Assumes:    That neither pointer is NULL. The two pointers */
/*             may be the same (so passing in &box, &box      */
/*             would work correctly).                         */
/**************************************************************/

void convert_box_to_os(const BBox * restrict mp, BBox * restrict os)
{
  os->xmin = ((mp->xmin + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
  os->ymin = ((mp->ymin + half_mppou_y) / millipoints_per_os_unit_y) & ~(wimpt_dy() - 1);
  os->xmax = ((mp->xmax + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
  os->ymax = ((mp->ymax + half_mppou_y) / millipoints_per_os_unit_y) & ~(wimpt_dy() - 1);
}

/**************************************************************/
/* convert_box_to_points()                                    */
/*                                                            */
/* As convert_pair_to_points, but converts the four           */
/* coordinates inside a BBox in one go.                       */
/*                                                            */
/* Parameters: Pointer to a BBox containing coords in OS      */
/*             units;                                         */
/*                                                            */
/*             Pointer to a BBox into which the first box's   */
/*             coords, converted to millipoints, are placed.  */
/*                                                            */
/* Assumes:    That neither pointer is NULL. The two pointers */
/*             may be the same (so passing in &box, &box      */
/*             would work correctly).                         */
/**************************************************************/

void convert_box_to_points(const BBox * restrict os, BBox * restrict mp)
{
  #ifdef TRACE

    if (
         abs(os->xmin) > overflow_limit_x ||
         abs(os->ymin) > overflow_limit_y ||
         abs(os->xmax) > overflow_limit_x ||
         abs(os->ymax) > overflow_limit_y
       )
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,
              "convert_box_to_points: Can't convert (%d, %d, %d, %d) to millipoints without overflow.",
              os->xmin,
              os->ymin,
              os->xmax,
              os->ymax);

      show_error_ret(&erb);

      mp->xmin = mp->ymin = 0;
      mp->xmax = mp->ymax = 0;

      return;
    }

  #endif

  mp->xmin = os->xmin * millipoints_per_os_unit_x;
  mp->ymin = os->ymin * millipoints_per_os_unit_y;
  mp->xmax = os->xmax * millipoints_per_os_unit_x;
  mp->ymax = os->ymax * millipoints_per_os_unit_y;
}

/**************************************************************/
/* utils_read_sprite_size()                                   */
/*                                                            */
/* Finds out the size of a given sprite in the application's  */
/* sprite pool in OS units.                                   */
/*                                                            */
/* Parameters: Pointer to the sprite name;                    */
/*                                                            */
/*             Pointer to int into which the sprite's width   */
/*             is returned;                                   */
/*                                                            */
/*             Pointer to int into which the sprite's height  */
/*             is returned.                                   */
/*                                                            */
/* Assumes:    The name pointer is not NULL, but either of    */
/*             the two int pointers may be.                   */
/**************************************************************/

_kernel_oserror * utils_read_sprite_size
                  (
                    const char * restrict name,
                    int        * restrict width,
                    int        * restrict height
                  )
{
  int w, h, m;

  RetError(_swix(OS_SpriteOp,
                 _INR(0,2) | _OUTR(3,4) | _OUT(6),

                 0x128,
                 sprite_block,
                 name,

                 &w,
                 &h,
                 &m));

  w = w << bbc_modevar(m, BBC_XEigFactor);
  h = h << bbc_modevar(m, BBC_YEigFactor);

  if (width)  *width  = w;
  if (height) *height = h;

  return NULL;
}

/**************************************************************/
/* utils_text_width()                                         */
/*                                                            */
/* Returns the width of a given piece of text, in OS units,   */
/* if it were to be plotted in the Desktop. Wimp_TextOp is    */
/* used if available, else the width and spacing of the       */
/* bitmap font is read and the width is calculated from this  */
/* instead.                                                   */
/*                                                            */
/* Parameters: Pointer to the text;                           */
/*                                                            */
/*             Pointer to an int, into which the width is     */
/*             written;                                       */
/*                                                            */
/*             0 to work out the whole string width, or the   */
/*             number of chars to read.                       */
/*                                                            */
/* Assumes:    Either pointer may be NULL;                    */
/*                                                            */
/*             If the number of chars to read is greater than */
/*             the string length, the value given is ignored  */
/*             and the string length used instead.            */
/**************************************************************/

_kernel_oserror * utils_text_width(char * text, int * width, int scan)
{
  int cwidth, cspacing;
  int len;

  /* Return if there's no text or 'width' is NULL */

  if (!width) return NULL;

  if (!text || !*text)
  {
    *width = 0;
    return NULL;
  }

  /* Otherwise, set 'len' either to the string length, */
  /* if 'scan' is zero, or to the value of 'scan'.     */

  len = strlen(text);
  if (scan && scan < len) len = scan;

  /* Rather than try mucking about guessing what version number of */
  /* Wimp supports Wimp_TextOp, simply use the alternative method  */
  /* if the SWI raises an error.                                   */

  if (
       _swix(Wimp_TextOp,
             _INR(0,2) | _OUT(0),

             1,
             text,
             len,

             width)
     )
  {
    /* Find out the spacing (start of one char to start of next) */
    /* and width of the text the Wimp is using, assuming that if */
    /* there is no nested wimp, Wimp_TextOp is unavailable.      */

    int vars[3] = {
                    BBC_GCharSizeX,
                    BBC_GCharSpaceX,
                    -1
                  };

    RetError(bbc_vduvars(vars, vars));

    cwidth   = vars[0];
    cspacing = vars[1];

    /* cspacing gives how much to increment x by after plotting a   */
    /* character, and therefore includes cwidth; so to find the     */
    /* width, we'd use (len * cspacing) - (cspacing - cwidth),      */
    /* which simplifies to the below (plus conversion to OS units). */

    *width = ((len - 1) * cspacing + cwidth) * wimpt_dx();
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* set_gadget_state()                                         */
/*                                                            */
/* Greys or ungreys a gadget, only changing its state to      */
/* avoid flicker.                                             */
/*                                                            */
/* Parameters: Object ID the gadget resides in;               */
/*                                                            */
/*             Component ID of the gadget;                    */
/*                                                            */
/*             1 to grey, 0 to ungrey.                        */
/**************************************************************/

_kernel_oserror * set_gadget_state(ObjectId o, ComponentId c, int grey_state)
{
  _kernel_oserror * e;
  unsigned int      flags;

  e = gadget_get_flags(0, o, c, &flags);
  if (e) return e;

  /* Only change state, to avoid flicker. */

  if (!!grey_state != !!(flags & Gadget_Faded))
  {
    if (grey_state) flags |=  Gadget_Faded;
    else            flags &= ~Gadget_Faded;

    return gadget_set_flags(0, o, c, flags);
  }

  return NULL;
}

/**************************************************************/
/* anti_twitter()                                             */
/*                                                            */
/* Calls the anti-twitter code over a given redraw area.      */
/*                                                            */
/* Parameters: Pointer to a WimpRedrawWindow block with the   */
/*             redraw_area BBox holding the area over which   */
/*             the anti-twitter code should be called.        */
/**************************************************************/

void anti_twitter(WimpRedrawWindowBlock * r)
{
  char         nhantitwitter[256];
  int          mode, ok = 1;
  unsigned int modeflags;

  #define AntiTwitter1 50
  #define AntiTwitter2 55

  #ifndef TRACE

    /* Older interlace modules only support modes 50 and 55 */
    /* directly, though can still appear to work in others. */

    _swix(OS_Byte,
          _IN(0) | _OUT(2),

          135,

          &mode);

    if (mode == AntiTwitter1 || mode == AntiTwitter2) ok = 1;
    else
    {
      /* If the current mode is not mode 50 or 55, this mode module  */
      /* may be new enough to support setting bit 8 of the modeflags */
      /* to indicate interlace.                                      */

      _swix(OS_ReadModeVariable,
            _INR(0,1) | _OUT(2),

            -1,
            0,

            &modeflags);

      ok = !!(modeflags & (1<<8));
    }

  #else

    /* For trace builds, always try to anti-twitter (allows testing */
    /* in certain non-interlaced Desktop screen modes)              */

    ok = 1;

    /* Hmph - stop compiler complaining about things not being used... */

    mode      = 0;
    modeflags = 0;

  #endif

  if (ok)
  {
    BBox gwind;
    BBox area;

    gwind.xmin = (bbc_vduvar(BBC_GWLCol))     * wimpt_dx();
    gwind.ymin = (bbc_vduvar(BBC_GWBRow))     * wimpt_dy();
    gwind.xmax = (bbc_vduvar(BBC_GWRCol) + 1) * wimpt_dx();
    gwind.ymax = (bbc_vduvar(BBC_GWTRow) + 1) * wimpt_dy();

    if (utils_intersection(&gwind, &r->redraw_area, &area))
    {
      sprintf(nhantitwitter,
              "%%NHAntiTwitter %d %d %d %d\n",

              area.xmin,
              area.ymin,
              area.xmax - area.xmin,
              area.ymax - area.ymin);

      _swix(OS_CLI,
            _IN(0),

            nhantitwitter);
    }
  }
}

/**************************************************************/
/* adjust()                                                   */
/*                                                            */
/* Returns 1 if Wimp_GetPointerInfo says that Adjust is being */
/* pressed, else 0.                                           */
/**************************************************************/

int adjust(void)
{
  WimpGetPointerInfoBlock info;

  wimp_get_pointer_info(&info);

  return !!(info.button_state & Wimp_MouseButtonAdjust);
}

/**************************************************************/
/* hide_gadget()                                              */
/*                                                            */
/* Hides a given gadget by moving it out of the visible area  */
/* of the window it is in.                                    */
/*                                                            */
/* Parameters: Object ID the gadget lies in; Component ID of  */
/*             the gadget.                                    */
/*                                                            */
/* Returns:    1 if the gadget was moved out, else 0.         */
/**************************************************************/

int hide_gadget(ObjectId o, ComponentId c)
{
  BBox g;

  if (gadget_get_bbox(0, o, c, &g)) return 0;

  /* If the gadget has a large negative X coordinate, */
  /* assume it's been moved out already.              */

  if (g.xmin < -4096) return 0;

  /* Otherwise, move it */

  g.xmin -= 8192;
  g.xmax -= 8192;

  if (gadget_move_gadget(0, o, c, &g)) return 0;

  return 1;
}

/**************************************************************/
/* show_gadget()                                              */
/*                                                            */
/* Shows a given gadget hidden by hide_gadget.                */
/*                                                            */
/* Parameters: Object ID the gadget lies in; Component ID of  */
/*             the gadget.                                    */
/*                                                            */
/* Returns:    1 if the gadget was moved in, else 0.          */
/**************************************************************/

int show_gadget(ObjectId o, ComponentId c)
{
  BBox g;

  if (gadget_get_bbox(0, o, c, &g)) return 0;

  /* If the gadget hasn't got a large negative X coordinate, */
  /* assume it's not been moved out.                         */

  if (g.xmin > -4096) return 0;

  /* Otherwise, move it */

  g.xmin += 8192;
  g.xmax += 8192;

  if (gadget_move_gadget(0, o, c, &g)) return 0;

  return 1;
}

/**************************************************************/
/* gadget_hidden()                                            */
/*                                                            */
/* Call to find out if a gadget has been moved out with       */
/* hide_gadget or is still visible.                           */
/*                                                            */
/* Parameters: Object ID the gadget lies in; Component ID of  */
/*             the gadget.                                    */
/*                                                            */
/* Returns:    1 if the gadget is hidden else 0.              */
/**************************************************************/

int gadget_hidden(ObjectId o, ComponentId c)
{
  BBox g;

  /* If there's an error getting the gadget's bounding box, then the gadget */
  /* is missing altogether or something else has gone wrong; in any case,   */
  /* safest action is to say it has been hidden.                            */

  if (gadget_get_bbox(0, o, c, &g)) return 1;

  /* Simple assumption that this much of a negative X value = gadget hidden */

  if (g.xmin < -4096) return 1;

  return 0;
}

/**************************************************************/
/* slab_gadget()                                              */
/*                                                            */
/* Slabs a gadget in briefly, by setting its Selected bit.    */
/* Gadget must be made of one icon only.                      */
/*                                                            */
/* Parameters: Object ID the gadget lies in; Component ID of  */
/*             the gadget.                                    */
/**************************************************************/

void slab_gadget(ObjectId o, ComponentId c)
{
  WimpSetIconStateBlock set;
  WimpGetIconStateBlock get;
  int                   icon[2];

  /* Get the icon number and window handle of the gadget */

  if (gadget_get_icon_list(0, o, c, icon, sizeof(icon), NULL)) return;
  if (window_get_wimp_handle(0, o, &get.window_handle)) return;
  get.icon_handle = icon[0];

  /* Get the icon state */

  if (wimp_get_icon_state(&get)) return;

  /* Set the flags as selected */

  set.window_handle = get.window_handle;
  set.icon_handle   = get.icon_handle;
  set.EOR_word      = get.icon.flags | WimpIcon_Selected;
  set.clear_word    = (int) 0xffffffff;

  if (wimp_set_icon_state(&set)) return;

  /* Wait a while */

  {
    int time_now, time_start;

    _swix(OS_ReadMonotonicTime, _OUT(0), &time_start);

    do
    {
      _swix(OS_ReadMonotonicTime, _OUT(0), &time_now);
    }
    while (time_now - time_start < 15);
  }

  /* Restore the old flags */

  set.EOR_word = get.icon.flags;

  wimp_set_icon_state(&set);
}

/**************************************************************/
/* slab_gadget_in()                                           */
/*                                                            */
/* Slabs a gadget in, by setting its Selected bit. Gadget     */
/* must be made of one icon only.                             */
/*                                                            */
/* Parameters: Object ID the gadget lies in; Component ID of  */
/*             the gadget.                                    */
/**************************************************************/

void slab_gadget_in(ObjectId o, ComponentId c)
{
  WimpSetIconStateBlock set;
  WimpGetIconStateBlock get;
  int                   icon[2];

  /* Get the icon number and window handle of the gadget */

  if (gadget_get_icon_list(0, o, c, icon, sizeof(icon), NULL)) return;
  if (window_get_wimp_handle(0, o, &get.window_handle)) return;
  get.icon_handle = icon[0];

  /* Get the icon state */

  if (wimp_get_icon_state(&get)) return;

  /* Set the flags as selected */

  set.window_handle = get.window_handle;
  set.icon_handle   = get.icon_handle;
  set.EOR_word      = get.icon.flags | WimpIcon_Selected;
  set.clear_word    = (int) 0xffffffff;

  wimp_set_icon_state(&set);
}

/**************************************************************/
/* slab_gadget_out()                                          */
/*                                                            */
/* Slabs a gadget out, by clearing its Selected bit. Gadget   */
/* must be made of one icon only.                             */
/*                                                            */
/* Parameters: Object ID the gadget lies in; Component ID of  */
/*             the gadget.                                    */
/**************************************************************/

void slab_gadget_out(ObjectId o, ComponentId c)
{
  WimpSetIconStateBlock set;
  WimpGetIconStateBlock get;
  int                   icon[2];

  /* Get the icon number and window handle of the gadget */

  if (gadget_get_icon_list(0, o, c, icon, sizeof(icon), NULL)) return;
  if (window_get_wimp_handle(0, o, &get.window_handle)) return;
  get.icon_handle = icon[0];

  /* Get the icon state */

  if (wimp_get_icon_state(&get)) return;

  /* Set the flags as unselected */

  set.window_handle = get.window_handle;
  set.icon_handle   = get.icon_handle;
  set.EOR_word      = get.icon.flags &~ WimpIcon_Selected;
  set.clear_word    = (int) 0xffffffff;

  wimp_set_icon_state(&set);
}

/**************************************************************/
/* utils_check_caret_restoration()                            */
/*                                                            */
/* Checks to see if the given dialogue has the caret, and if  */
/* it has a parent. If so, it'll return the Object ID of that */
/* parent, else NULL_ObjectId is written.                     */
/*                                                            */
/* Parameters: The Object ID of the dialogue to check.        */
/**************************************************************/

ObjectId utils_check_caret_restoration(ObjectId window_id)
{
  WimpGetCaretPositionBlock   caret_b;
  int                         caret_w;
  ObjectId                    parent = NULL_ObjectId;
  _kernel_oserror           * e      = NULL;

  /* Do we have the input focus? */

  e = wimp_get_caret_position(&caret_b);

  if (!e)
  {
    e = window_get_wimp_handle(0,
                               window_id,
                               &caret_w);

    if (!e)
    {
      if (caret_w == caret_b.window_handle)
      {
        /* Yes, we have the caret. So move it back to the Print */
        /* dialogue - well, this object's parent, anyway.       */

        e = toolbox_get_parent(0,
                               window_id,
                               &parent,
                               NULL);

        if (e) parent = NULL_ObjectId;

        else if (parent == NULL_ObjectId)
        {
          /* Maybe there's an ancestor? (E.g. PrintDBox using an  */
          /* alternate window -> doesn't pass Parent info through */
          /* so we need the ancestor instead... sigh).            */

          e = toolbox_get_ancestor(0,
                                   window_id,
                                   &parent,
                                   NULL);

          if (e) parent = NULL_ObjectId;
        }
      }
    }
  }

  /* Finished */

  return parent;
}

/**************************************************************/
/* utils_restore_caret()                                      */
/*                                                            */
/* If the given dialogue has the caret, put the caret into    */
/* the parent of this object, in the default input focus      */
/* position.                                                  */
/*                                                            */
/* Parameters: The Object ID of the dialogue whos parent is   */
/*             to gain the caret.                             */
/*                                                            */
/* Assumes:    The parent has a default caret position set    */
/*             up.                                            */
/**************************************************************/

_kernel_oserror * utils_restore_caret(ObjectId window_id)
{
  _kernel_oserror           * e = NULL;
  ObjectId                    parent;
  ComponentId                 focus_c;

  /* Do we have the input focus and a parent? */

  parent = utils_check_caret_restoration(window_id);

  if (parent != NULL_ObjectId)
  {
    /* Find the default caret position of the parent */

    e = window_get_default_focus(0,
                                 parent,
                                 &focus_c);

    /* Set the focus there */

    if (!e)
    {

      if (focus_c != NULL_ComponentId) gadget_set_focus(0,
                                                        parent,
                                                        focus_c);
    }
  }

  /* Finished */

  return e;
}

/**************************************************************/
/* copy_toolaction_info()                                     */
/*                                                            */
/* Copies the internal details of a given ToolAction gadget   */
/* to another.                                                */
/*                                                            */
/* Ident off, ident on, ident faded, select action, adjust    */
/* action and click-show details are copied with ToolAction   */
/* SWIs; the help text is copied with gadget library calls.   */
/*                                                            */
/* This does *not* copy state info, such as on/off or greyed. */
/*                                                            */
/* Parameters: Object ID the source gadget is in;             */
/*                                                            */
/*             Component ID of the source;                    */
/*                                                            */
/*             Object ID the destination gadget is in;        */
/*                                                            */
/*             Component ID of the destination.               */
/**************************************************************/

_kernel_oserror * copy_toolaction_info(ObjectId src_o, ComponentId src_c, ObjectId dst_o, ComponentId dst_c)
{
  _kernel_oserror * e;
  char              ident [Limits_ToolActionIdent];
  char              help  [Limits_Help];
  unsigned int      flags;
  unsigned int      state;
  int               adjust_act, select_act;
  int               adjust_cs,  select_cs;

  /* Off state ident string */

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,5),

            toolaction_SET_IDENT_OFF,
            src_o,
            ToolAction_GetIdent,
            src_c,
            ident,
            sizeof(ident));

  if (e) return e;

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,4),

            toolaction_SET_IDENT_OFF,
            dst_o,
            ToolAction_SetIdent,
            dst_c,
            ident);

  if (e) return e;

  /* On state ident string */

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,5),

            toolaction_SET_IDENT_ON,
            src_o,
            ToolAction_GetIdent,
            src_c,
            ident,
            sizeof(ident));

  if (e) return e;

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,4),

            toolaction_SET_IDENT_ON,
            dst_o,
            ToolAction_SetIdent,
            dst_c,
            ident);

  if (e) return e;

  /* Faded state ident string */

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,5),

            toolaction_SET_IDENT_FADE,
            src_o,
            ToolAction_GetIdent,
            src_c,
            ident,
            sizeof(ident));

  if (e) return e;

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,4),

            toolaction_SET_IDENT_FADE,
            dst_o,
            ToolAction_SetIdent,
            dst_c,
            ident);

  if (e) return e;

  /* Adjust and select actions */

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,3) | _OUTR(0,1),

            0,
            src_o,
            ToolAction_GetAction,
            src_c,

            &select_act,
            &adjust_act);

  if (e) return e;

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,5),

            0,
            dst_o,
            ToolAction_SetAction,
            dst_c,
            select_act,
            adjust_act);

  if (e) return e;

  /* Adjust and select click-shows */

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,3) | _OUTR(0,1),

            0,
            src_o,
            ToolAction_GetClickShow,
            src_c,

            &select_cs,
            &adjust_cs);

  if (e) return e;

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,5),

            0,
            dst_o,
            ToolAction_SetClickShow,
            dst_c,
            select_cs,
            adjust_cs);

  if (e) return e;

  /* The gadget state (on or off) */

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,3) | _OUT(0),

            0,
            src_o,
            ToolAction_GetState,
            src_c,

            &state);

  if (e) return e;

  e = _swix(Toolbox_ObjectMiscOp,
            _INR(0,4),

            0,
            dst_o,
            ToolAction_SetState,
            dst_c,
            state);

  if (e) return e;

  /* The gadget flags */

  e = gadget_get_flags(0, src_o, src_c, &flags);
  if (e) return e;

  e = gadget_set_flags(flags, dst_o, dst_c, flags);
  if (e) return e;

  /* Finally, the help text */

  e = gadget_get_help_message(0,
                              src_o,
                              src_c,
                              help,
                              sizeof(help),
                              NULL);

  if (e) return e;

  return gadget_set_help_message(0,
                                 dst_o,
                                 dst_c,
                                 help);
}

/**************************************************************/
/* set_window_flags()                                         */
/*                                                            */
/* Sets the flags of a given window, assuming the nested Wimp */
/* is available...                                            */
/*                                                            */
/* Parameters: Window handle; EOR word; Clear word.           */
/*                                                            */
/* Assumes:    That a window manager that supports extended   */
/*             Wimp_OpenWindow calls (R2 = 'TASK') is         */
/*             present.                                       */
/*                                                            */
/* The flags are set according to                             */
/*                                                            */
/* new = (old BIC clear word) EOR EOR word                    */
/*                                                            */
/* i.e.:                                                      */
/*                                                            */
/* C  E  Effect                                               */
/* ------------                                               */
/* 0  0  Preserve bit                                         */
/* 0  1  Toggle bit                                           */
/* 1  0  Clear bit                                            */
/* 1  1  Set bit                                              */
/**************************************************************/

_kernel_oserror * set_window_flags(int window_handle, unsigned int clear_word, unsigned int eor_word)
{
  /* Block required for the extended Wimp_OpenWindow */

  typedef struct
  {
    WimpOpenWindowBlock open;
    unsigned int        flags;
  }
  ExtendedOpenBlock;

  _kernel_oserror         * e;
  WimpGetWindowStateBlock   s;
  unsigned int              parent, align;
  unsigned int              new_flags;
  ExtendedOpenBlock         ext_o;

  /* Get the current window details */

  s.window_handle = window_handle;

  e = _swix(Wimp_GetWindowState,
            _INR(1, 2) | _OUTR(3, 4),

            &s,
            Magic_Word_TASK, /* See MiscDefs.h */

            &parent,
            &align);

  if (e) return e;

  /* Obtain the new flags word */

  new_flags = (s.flags & ~clear_word) ^ eor_word;

  /* Fill in the new open block and reopen the window with it */

  ext_o.open.window_handle = s.window_handle;
  ext_o.open.visible_area  = s.visible_area;
  ext_o.open.xscroll       = s.xscroll;
  ext_o.open.yscroll       = s.yscroll;
  ext_o.open.behind        = s.behind;
  ext_o.flags              = new_flags;

  return _swix(Wimp_OpenWindow,
               _INR(1,4),

               &ext_o,
               Magic_Word_TASK,
               parent,
               align | Alignment_NewFlagsGiven);
}

/**************************************************************/
/* debounce_keypress()                                        */
/*                                                            */
/* For some key presses (e.g. function keys), it is not       */
/* desirable to let the key autorepeat. This function sits in */
/* a tight loop waiting for all keys to be released before    */
/* exitting.                                                  */
/*                                                            */
/* Returns:    1 if a key was being pressed and the function  */
/*             waited for its release, else 0.                */
/**************************************************************/

int debounce_keypress(void)
{
  int               key, waited = 0;
  _kernel_oserror * e;

  do
  {
    e = _swix(OS_Byte,
              _INR(0,1) | _OUT(1),

              121, /* Keyboard scan */
              0,   /* Scan all keys */

              &key);

    if (key != 255) waited = 1;
  }
  while (!e && key != 255);

  if (waited) _swix(OS_Byte, _INR(0,1), 21, 0); /* Flush keyboard buffer */

  return waited;
}

/**************************************************************/
/* utils_task_from_window()                                   */
/*                                                            */
/* Returns the task handle of the owner of a given window.    */
/*                                                            */
/* Parameters: A window handle.                               */
/*                                                            */
/* Returns:    Task handle of the window owner.               */
/**************************************************************/

int utils_task_from_window (int window_handle)
{
  WimpMessage  m;
  int          handle;

  m.hdr.size        = 20;
  m.hdr.your_ref    = 0;
  m.hdr.action_code = 0;

  if (
       wimp_send_message(Wimp_EUserMessageAcknowledge,
                         &m,
                         window_handle,
                         0,
                         &handle)
     )
     return 0;

  return handle;
}

/**************************************************************/
/* utils_browser_from_window()                                */
/*                                                            */
/* Given a window handle, returns an associated browser_data  */
/* struct, if one may be found.                               */
/*                                                            */
/* Parameters: The window handle;                             */
/*                                                            */
/*             Pointer to a pointer to a browser_data struct, */
/*             in which the associated structure's address is */
/*             written, or NULL for none found / there is an  */
/*             error.                                         */
/*                                                            */
/* Assumes:    The last parameter may not be NULL (it is      */
/*             pointless to allow this).                      */
/**************************************************************/

_kernel_oserror * utils_browser_from_window(int window_handle, browser_data ** browser)
{
  ObjectId o = NULL, a = NULL;

  *browser = NULL;

  /* Get the associated Object ID */

  RetError(window_wimp_to_toolbox(0,
                                  window_handle,
                                  -1,
                                  &o,
                                  NULL));

  /* If this has an ancestor, check the ID against the ancestor's */
  /* toolbar IDs. This is because we could be a frame - in which  */
  /* case there is an ancestor - or a toolbar, in which case we   */
  /* want to return the browser_data struct for that ancestor.    */

  RetError(toolbox_get_ancestor(0, o, &a, NULL));

  if (a)
  {
    browser_data * ancestor = NULL;
    ObjectId       upper, lower;

    /* Get the ancestor's client handle */

    RetError(toolbox_get_client_handle(0, a, (void *) &ancestor));

    /* If a known browser, get the toolbars */

    if (is_known_browser(ancestor))
    {
      upper = toolbars_get_upper(ancestor);
      lower = toolbars_get_lower(ancestor);

      /* If either ID matches that which the message */
      /* came from, the return the ancestor ID.      */

      if (upper == o || lower == o)
      {
        *browser = ancestor;

        return NULL;
      }
    }
  }

  /* Get its client handle */

  RetError(toolbox_get_client_handle(0, o, (void *) browser));

  /* If this is not a known browser, don't use it */

  if (!is_known_browser(*browser)) *browser = NULL;

  /* Finished */

  return NULL;
}

/**************************************************************/
/* is_known_browser()                                         */
/*                                                            */
/* Finds out if the given browser_data struct is in the list  */
/* of known structures. The struct may be NULL (0 would be    */
/* returned), so this doesn't need to be checked for          */
/* externally.                                                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct to check.     */
/*                                                            */
/* Returns:    1 if the structure is in the list or 0 if it   */
/*             isn't.                                         */
/**************************************************************/

int is_known_browser(const browser_data * restrict b)
{
  const browser_data * restrict check = last_browser;
  int                           found = 0;

  /* If b is NULL, can't be a valid browser_data structure! */

  if (!b) return 0;

  /* Search the list */

  while (check && !found)
  {
    if (check == b) found = 1;
    else check = check->previous;
  }

  /* Return the search results */

  return found;
}

/**************************************************************/
/* utils_parent()                                             */
/*                                                            */
/* Works out a given browser_data structure's parent. If      */
/* there is only an ancestor or neither an ancestor or        */
/* parent, it returns NULL.                                   */
/*                                                            */
/* Does not care whether the frameset was built with one set  */
/* of nested frameset elements or through separate framesets  */
/* in different files and considers a parent to be the        */
/* browser immediately 'below' the given child.               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct that you want */
/*             the parent of.                                 */
/*                                                            */
/* Returns:    Pointer to the structure's parent, or NULL if  */
/*             there is only an ancestor or no parents at     */
/*             all.                                           */
/*                                                            */
/* Assumes:    If it gets NULL, it returns NULL.              */
/**************************************************************/

browser_data * utils_parent(const browser_data * restrict b)
{
  if (!b) return NULL;

  if (b->real_parent && b->real_parent != b->ancestor) return b->real_parent;

  return NULL;
}

/**************************************************************/
/* utils_flat_parent()                                        */
/*                                                            */
/* Works out a given browser_data structure's parent          */
/* according to the JavaScript model. This works as follows:  */
/*                                                            */
/* The parent of any child defined by <frameset> elements is  */
/* the browser holding the document in which the defining     */
/* <frameset> lies. No other 'intermediate' browsers exist,   */
/* as far as this model is concerned.                         */
/*                                                            */
/* If an item has no parent a pointer back to itself is       */
/* returned (parentless items are parents to themselves).     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct that you want */
/*             the parent of.                                 */
/*                                                            */
/* Returns:    Pointer to the structure's parent, as          */
/*             described above.                               */
/*                                                            */
/* Assumes:    If it gets NULL, it returns NULL.              */
/**************************************************************/

browser_data * utils_flat_parent(const browser_data * b)
{
  const browser_data * parent = b;

  if (!b) return NULL;

  /* The underlying, defining frameset will have a nesting level */
  /* of 1.                                                       */

  while (parent && parent->parent)
  {
    parent = parent->parent;
  }

  if (!parent->parent && parent->real_parent) return parent->real_parent;

  if (parent) return (browser_data *) parent;
  else        return (browser_data *) b;
}

/**************************************************************/
/* utils_ancestor()                                           */
/*                                                            */
/* Works out a given browser_data structure's ancestor (which */
/* may be the given structure!).                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct that you want */
/*             the ancestor of.                               */
/*                                                            */
/* Returns:    Pointer to the structure's ancestor.           */
/*                                                            */
/* Assumes:    If it gets NULL, it returns NULL. Otherwise,   */
/*             it never returns NULL.                         */
/**************************************************************/

browser_data * utils_ancestor(const browser_data * restrict b)
{
  if (!b) return NULL;

  if (b->ancestor) return b->ancestor;
  else             return (browser_data *) b;
}

/**************************************************************/
/* utils_encode_base64()                                      */
/*                                                            */
/* Passed a pointer to data and its length, this will fill    */
/* the output buffer with Base64- encoded data, returning the */
/* length of the output data (this is not terminated).        */
/*                                                            */
/* The length of the output will be -                         */
/*                                                            */
/* (length of input, rounded up to next multiple of 3) times  */
/* 4                                                          */
/*                                                            */
/* - so make sure you have a big enough output buffer.        */
/*                                                            */
/* Parameters: Pointer to the data to encode;                 */
/*                                                            */
/*             Length of the data to encode;                  */
/*                                                            */
/*             Pointer to the output buffer.                  */
/*                                                            */
/* Assumes:    That the output buffer is big enough (see      */
/*             above).                                        */
/**************************************************************/

int utils_encode_base64(const char * in, int len, char * out)
{
  static const char * base64_table = "ABCDEFGHIJKLMNOP"
                                     "QRSTUVWXYZabcdef"
                                     "ghijklmnopqrstuv"
                                     "wxyz0123456789+/";
  unsigned long       chunk;
  char              * out_ptr      = out;
  int                 p            = 0;
  int                 i;

  while (p < len)
  {
    chunk = 0;

    for (i = 0; i < 3; i++, p++)
    {
      if (p < len) chunk = (chunk << 8) | in[p];
      else         chunk = (chunk << 8);
    }

    *out++ = base64_table[chunk >> 18];
    *out++ = base64_table[(chunk >> 12) & 0x3f];

    if (p <= len + 1)
    {
      *out++ = base64_table[(chunk >> 6) & 0x3f];

      if (p <= len) *out++ = base64_table[chunk & 0x3f];
      else          *out++ = '=';
    }
    else
    {
      *out++ = '=';
      *out++ = '=';
    }
  }

  return out - out_ptr;
}

/**************************************************************/
/* utils_strcasecmp()                                         */
/*                                                            */
/* Function to compare two strings case insensitively.        */
/*                                                            */
/* Originally by S.Brodie.                                    */
/*                                                            */
/* The conversions to unsigned int stop the compiler messing  */
/* around with shifts all over the place whilst trying to     */
/* promote the chars to int whilst retaining the sign.        */
/*                                                            */
/* Problems: Choice of return value when strings do not match */
/* is based upon character number rather than any alphabetic  */
/* sorting.                                                   */
/*                                                            */
/* Parameters: As strcmp.                                     */
/*                                                            */
/* Returns:    As strcmp.                                     */
/**************************************************************/

int utils_strcasecmp(const char *a, const char *b)
{
  for (;;)
  {
    unsigned int f1 = *a++;
    unsigned int s1 = *b++;

    if (f1 == 0) return -s1;

    if (f1 != s1)
    {
      unsigned int f2     = (unsigned int) tolower(f1);
      unsigned int s2     = (unsigned int) tolower(s1);
      signed int   result = f2 - s2;

      if (result != 0) return result;
    }
  }
}

/**************************************************************/
/* utils_strncasecmp()                                        */
/*                                                            */
/* Function to compare two strings case insensitively up to a */
/* maximum char count.                                        */
/*                                                            */
/* Originally by S.Brodie.                                    */
/*                                                            */
/* The conversions to unsigned int stop the compiler messing  */
/* around with shifts all over the place whilst trying to     */
/* promote the chars to int whilst retaining the sign.        */
/*                                                            */
/* Problems: Choice of return value when strings do not match */
/* is based upon character number rather than any alphabetic  */
/* sorting.                                                   */
/*                                                            */
/* Parameters: As strncmp.                                    */
/*                                                            */
/* Returns:    As strncmp.                                    */
/**************************************************************/

int utils_strncasecmp(const char * a, const char * b, unsigned int n)
{
  for (; n; --n)
  {
    unsigned int f1 = *a++;
    unsigned int s1 = *b++;

    if (f1 == 0) return -s1;

    if (f1 != s1)
    {
      unsigned int f2     = (unsigned int) tolower(f1);
      unsigned int s2     = (unsigned int) tolower(s1);
      signed int   result = f2 - s2;

      if (result != 0) return result;
    }
  }

  return 0;
}

/**************************************************************/
/* utils_strnullcmp()                                         */
/*                                                            */
/* Compare two strings. The pointers may be NULL.             */
/*                                                            */
/* Parameters: Pointer to first string (may be NULL).         */
/*                                                            */
/*             Pointer to second string (may be NULL).        */
/*                                                            */
/* Returns:    Zero if both strings match or both pointers    */
/*             are NULL. Less than zero if the first string   */
/*             is by ASCII code less than the second, or the  */
/*             first pointer is NULL but the second is not.   */
/*             Greater than zero if the first string is by    */
/*             ASCII code more than the second, or the second */
/*             pointer is NULL but the first is not.          */
/**************************************************************/

int utils_strnullcmp(const char * a, const char * b)
{
  if (a != NULL && b == NULL) return 1;
  if (a == NULL && b == NULL) return 0;
  if (a == NULL && b != NULL) return -1;

  return strcmp(a, b);
}

/**************************************************************/
/* utils_strdup()                                             */
/*                                                            */
/* Returns a pointer to a malloc'd copy of the given string.  */
/*                                                            */
/* Parameters: Pointer to the string to copy.                 */
/*                                                            */
/* Returns:    Pointer to a malloc'd copy of the given        */
/*             string.                                        */
/*                                                            */
/* Assumes:    Returns NULL if it gets NULL or if memory      */
/*             allocation fails.                              */
/**************************************************************/

char * utils_strdup(const char * s1)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = (char *) malloc(strlen(s1) + 1);

  if (s2 == NULL) return NULL;

  return strcpy(s2, s1);
}

/**************************************************************/
/* utils_get_task_handle()                                    */
/*                                                            */
/* Returns the task handle of the given task (name comparison */
/* is case insensitive).                                      */
/*                                                            */
/* Parameters: Pointer to a null-terminated task name;        */
/*                                                            */
/*             Pointer to an unsigned int, in which the task  */
/*             handle is written, or 0 if the task is not     */
/*             found.                                         */
/*                                                            */
/* Assumes:    Neither pointer may be NULL.                   */
/**************************************************************/

_kernel_oserror * utils_get_task_handle(const char * task_to_get, unsigned int * found_handle)
{
  _kernel_oserror * e;
  char            * c;
  int             * p;
  int               buffer  [32];
  char              taskname[Limits_TaskName];
  int             * notused;
  int               t;
  int               len    = strlen(task_to_get);
  int               next   = 0;
  unsigned int      handle = 0;

  do
  {
    e = _swix(TaskManager_EnumerateTasks,
              _INR(0,2) | _OUTR(0,1),

              next,
              buffer,
              sizeof(buffer),

              &next,
              &notused);

    if (e) return e;

    /* Go through as much of the buffer as the call said it used */

    for (p = buffer; p < notused && handle == 0; p += 4)
    {
      c = (char *) p[1];
      t = 0;

      memset(taskname, 0, sizeof(taskname));
      while (*c > 31 && t < sizeof(taskname) - 1) taskname[t++] = *c++;

      if (!utils_strncasecmp(taskname, task_to_get, len)) handle = p[0];
    }
  }
  while (next >= 0 && handle == 0);

  /* Return the handle */

  *found_handle = handle;

  return NULL;
}

/**************************************************************/
/* utils_stop_proxy()                                         */
/*                                                            */
/* Stops the [WebServe] application by sending an AppControl  */
/* message.                                                   */
/**************************************************************/

_kernel_oserror * utils_stop_proxy(void)
{
  unsigned int handle = 0;
  WimpMessage  msg;

  /* First, get WebServe's task handle */

  RetError(utils_get_task_handle(lookup_token("ProxyName:Acorn WebServe",0,0), &handle));

  #ifdef TRACE

    if (!handle)
    {
      /* Didn't find WebServe, so complain and exit */

      erb.errnum = Utils_Error_Custom_Message;

      StrNCpy0(erb.errmess, "WebServe is not present");

      show_error_ret(&erb);

      return NULL;
    }

  #else

    if (!handle)
    {
      /* Didn't find WebServe, so exit */

      return NULL;
    }

  #endif

  /* If WebServe is present, send the message */

  msg.hdr.size        = 32;
  msg.hdr.your_ref    = 0;
  msg.hdr.action_code = Wimp_MAppControl;

  msg.data.app_control.version = 1;
  msg.data.app_control.flags   = Wimp_MAppControl_ImmediateAction;
  msg.data.app_control.reason  = Wimp_MAppControl_Stop;

  return wimp_send_message(Wimp_EUserMessage, &msg, handle, -1, NULL);
}

/**************************************************************/
/* utils_len_printf()                                         */
/*                                                            */
/* Returns the length of a given printf string. Can be useful */
/* for buffer length determination when wishing to use        */
/* sprintf, for example.                                      */
/*                                                            */
/* This function runs *very* slowly. If it is difficult /     */
/* impossible to determine the length (or upper limit of      */
/* length) any other way, use it; else find a different       */
/* approach (e.g. see utils_number_length).                   */
/*                                                            */
/* Parameters: As for printf.                                 */
/*                                                            */
/* Returns:    Length of the output string (as returned by    */
/*             vfprintf) or -1 if some error occurred.        */
/**************************************************************/

int utils_len_printf(const char * format, ...)
{
  int       len;
  va_list   ptr;
  FILE    * fp;

  fp = fopen("Null:", "wb");
  if (!fp) return -1;

  va_start(ptr, format);
  len = vfprintf(fp, format, ptr);
  va_end(ptr);

  fclose(fp);

  return len;
}

/**************************************************************/
/* utils_number_length()                                      */
/*                                                            */
/* Returns the number of bytes the given number would occupy  */
/* if converted to a string by sprintf with a '%d' specifier  */
/* used in the format string.                                 */
/*                                                            */
/* Parameters: The number to check.                           */
/*                                                            */
/* Returns:    The number of characters it would occupy as a  */
/*             string.                                        */
/*                                                            */
/* Assumes:    An 'int' is 32-bit signed.                     */
/**************************************************************/

int utils_number_length(int number)
{
  int len = 0;

  if (number < 0) len += 1, number = -number;

  if      (number < 10)         len += 1;
  else if (number < 100)        len += 2;
  else if (number < 1000)       len += 3;
  else if (number < 10000)      len += 4;
  else if (number < 100000)     len += 5;
  else if (number < 1000000)    len += 6;
  else if (number < 10000000)   len += 7;
  else if (number < 100000000)  len += 8;
  else if (number < 1000000000) len += 9;
  else                          len += 10;

  return len;
}

/**************************************************************/
/* utils_return_hash()                                        */
/*                                                            */
/* Returns a very crude hash number for a given string.       */
/*                                                            */
/* Parameters: Pointer to the string.                         */
/*                                                            */
/* Returns:    A hash number.                                 */
/**************************************************************/

unsigned int utils_return_hash(const char * s)
{
  unsigned int h = 0, c = 0;;

  if (!s) return 0;

  /* Limit to 40 chars for some attempt at reasonable speed */

  while (*s && c < 40) h += *s++, c++;

  return h;
}

/**************************************************************/
/* utils_build_user_agent_string                              */
/*                                                            */
/* Works out an appropriate HTTP response User Agent string.  */
/*                                                            */
/* Parameters: Flag to indicate fake Netscape header          */
/*             required.                                      */
/*                                                            */
/*             Pointer to a buffer to place the string in;    */
/*                                                            */
/*             Size of the buffer - note that a string longer */
/*             than Limits_UserAgent will never be generated. */
/**************************************************************/

void utils_build_user_agent_string(int netscape, char * buffer, int buffer_size)
{
  _kernel_oserror * e;
  char              agent[Limits_UserAgent];
  char              ver  [32];
  int               modnum, bcdver = 0;
  const char      * agent_middle, * agent_end;

  if (!buffer || !buffer_size) return;

  buffer[0] = '\0';

  /* The AGENT_... definitions are at the top of ths file.     */
  /*                                                           */
  /* First, the string start, e.g. 'Mozilla/2.0 (compatible; ' */

  StrNCpy0(agent, netscape ? Netscape_Agent_Start : Acorn_Agent_Start);

  /* The browser name */

  *lasttokn = 0; /* Being very (maybe over?) cautions here */
  *tokens   = 0;
  lookup_token("_TaskName",1,0);

  /* Can't have spaces outside the comment field */

  if (!strchr(agent, '('))
  {
    while (strchr(tokens, ' ')) *strchr(tokens, ' ') = '-';
  }

  if (strlen(tokens) + strlen(agent) + 2 < sizeof(agent))
  {
    strcat(agent, tokens);

    /* Separate version by a / outside the comment field (see HTTP 1.1 spec section 3.8) */

    if (strchr(agent, '(')) strcat(agent, " ");
    else                    strcat(agent, "/");
  }

  /* The browser version */

  *lasttokn = 0;
  *tokens   = 0;
  lookup_token("Version",1,0);

  /* Just do a simple version outside of the comment field */

  if (!strchr(agent, '('))
  {
    if (strchr(tokens, ' ')) *strchr(tokens, ' ') = '\0';
  }

  /* Can't have nested ()s in the User Agent string */

  if (strchr(tokens, '(')) *strchr(tokens, '(') = '[';
  if (strchr(tokens, ')')) *strchr(tokens, ')') = ']';

  /* Append the version, if it'll fit */

  if (strlen(tokens) + strlen(agent) + 1 < sizeof(agent)) strcat(agent, tokens);

  /* Intermediate string */

  agent_middle = netscape ? Netscape_Agent_Middle : Acorn_Agent_Middle;
  if (strlen(agent) + strlen(agent_middle) + 1 < sizeof(agent)) strcat(agent, agent_middle);

  /* Extract the Utility Module version number */

  e = _swix(OS_Module,
            _INR(0,1) | _OUT(1),

            18,
            "UtilityModule",

            &modnum);

  if (e) return;

  e = _swix(OS_Module,
            _INR(0,2) | _OUT(6),

            20,
            modnum,
            -1,

            &bcdver);

  if (e) return;

  /* Write the version number and put it into the agent string */

  sprintf(ver, "%d.%02x", bcdver >> 16, (bcdver & 0xffff) >> 8);

  if (strlen(agent) + strlen(ver) + 1 < sizeof(agent)) strcat(agent, ver);

  /* Finish things off */

  agent_end = netscape ? Netscape_Agent_End : Acorn_Agent_End;
  if (strlen(agent) + strlen(agent_end) + 1 < sizeof(agent)) strcat(agent, agent_end);

  /* Copy into the given buffer */

  strncpy(buffer, agent, buffer_size - 1);
  buffer[buffer_size - 1] = 0;

  /* Finished. */

  return;
}

/**************************************************************/
/* utils_check_scrap()                                        */
/*                                                            */
/* If Save_ScrapFile (which should represent a system         */
/* variable name, see Save.h) does not exist, report an       */
/* appropriate error and return 1. Else return 0.             */
/*                                                            */
/* Returns: See above.                                        */
/**************************************************************/

int utils_check_scrap(void)
{
  int              len;
  _kernel_swi_regs r;

  r.r[0] = (int) Save_ScrapVar;
  r.r[1] = (int) NULL;
  r.r[2] = -1;
  r.r[3] = 0;
  r.r[4] = 4;

  /* _swix will not work correctly for this particular SWI if */
  /* requiring the returned R2 value. Something to do with    */
  /* the call relying on generating an error, but _swix spots */
  /* it and pulls out earlier than the call expects. Or some  */
  /* such thing...                                            */

  _kernel_swi(OS_ReadVarVal, &r, &r);

  len = r.r[2];

  if (!len)
  {
    erb.errnum = Utils_Error_Custom_Message;
    sprintf(erb.errmess,
            "%s%s",
            Save_ScrapFile,
            lookup_token("NoScrapDef: not defined.",0,0));

    show_error_ret(&erb);

    return 1;
  }

  return 0;
}

/**************************************************************/
/* utils_canonicalise_path()                                  */
/*                                                            */
/* Take some pathname (which may include a path or other      */
/* general system variable) and expand (or canonicalise) it.  */
/*                                                            */
/* Caller is responsible for calling free() on the returned   */
/* block.                                                     */
/*                                                            */
/* Parameters: Pointer to the path to canonicalise;           */
/*                                                            */
/*             Pointer to a char *, which will be filled in   */
/*             with the address of a malloced block - the     */
/*             caller is responsible for freeing it.          */
/*                                                            */
/* Returns:    If there is an error, it returns it, but it    */
/*             may return NULL and also return NULL as the    */
/*             pointer to the malloced block if some other    */
/*             internal failure occurred.                     */
/**************************************************************/

_kernel_oserror * utils_canonicalise_path(const char * in, char ** out)
{
  int required;

  if (!in || !*in || !out) return NULL;

  RetError(_swix(OS_FSControl,
                 _INR(0, 5) | _OUT(5),

                 37,   in,
                 NULL, NULL,
                 NULL, 0,

                 &required)); /* Path length not including terminator returned as MINUS r5 */

  *out = malloc(1 - required); /* (Yes, '1 - required' - see above!) */

  if (!*out) return make_no_memory_error(30);

  RetError(_swix(OS_FSControl,
                 _INR(0, 5) | _OUT(5),

                 37,   in,
                 *out, NULL,
                 NULL, 1 - required,

                 &required));

  /* Er, 'something' went wrong... PRMs say to check, but not what to */
  /* do if you don't get 1 back here and haven't had an error from    */
  /* the SWI call!                                                    */

  if (required != 1)
  {
    free (*out);
    *out = NULL;
  }

  return NULL;
}

/**************************************************************/
/* utils_build_tree()                                         */
/*                                                            */
/* Takes a fully canonicalised pathname and ensures that all  */
/* the directories in the path exist. This is useful if you   */
/* are going to save something to a temporary directory in    */
/* Scrap or somewhere in <Choices$Write>, say, and need to    */
/* ensure that the directory structure you're addressing is   */
/* present.                                                   */
/*                                                            */
/* Parameters: Pointer to the path to ensure is present.      */
/**************************************************************/

_kernel_oserror * utils_build_tree(const char * path)
{
  char * temp;
  char * p;
  int    level, len;

  /* Sanity check, and take a local copy of the path */

  if (!path || !*path) return NULL;

  len = strlen(path);

  temp = malloc(len + 1);
  if (!temp) return make_no_memory_error(31);

retry:

  level = 0;
  strcpy(temp, path);

  /* Create the directories */

  do
  {
    p = strrchr(temp, '.');

    if (p)
    {
      *p = '\0';

      if (!_swix(OS_File,
                 _INR(0,1) | _IN(4),

                 8,
                 temp,
                 0))
      {
        if (level) goto retry;
        else       break;
      }
    }

    level++;
  }
  while (p);

  /* Finished */

  free(temp);

  return NULL;
}

/**************************************************************/
/* utils_hourglass_percent                                    */
/*                                                            */
/* Set the hourglass percentage based on a current value and  */
/* a maximum value. Will give 99% at maximum.                 */
/*                                                            */
/* Parameters: Current value, from 1 to maximum inclusive;    */
/*                                                            */
/*             Maximum value.                                 */
/**************************************************************/

void utils_hourglass_percent(unsigned int current, unsigned int max)
{
  /* Calculate the percentage from 0 to 99 (when rounded */
  /* down for integer maths).                            */

  unsigned int percent = (100 * (current - 1)) / (max == 0 ? 1 : max);

  /* Protect against supplied parameter error. */

  if (percent > 99) percent = 99;

  /* Set up the hourglass */

  (void) _swix(Hourglass_Percentage,
               _IN(0),

               percent);

  return;
}
@


1.33
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d60 1
d62 1
d81 1
a81 1
#define Acorn_Agent_Start     "Acorn-"
d85 1
a85 1
#define Netscape_Agent_Start  "Mozilla/4.01 (Compatible; Acorn "
d524 24
d565 2
a566 9

  erb.errnum =  0;

  StrNCpy0(erb.errmess,
           lookup_token("NoMemFet:There is not enough free memory to perform this fetch (%0).",
                        0,
                        num));

  return &erb;
d585 2
a586 9

  erb.errnum =  0;

  StrNCpy0(erb.errmess,
           lookup_token("NoMemRea:There is not enough free memory to continue the page fetch (%0).",
                        0,
                        num));

  return &erb;
d606 2
a607 9

  erb.errnum =  0;

  StrNCpy0(erb.errmess,
           lookup_token("NoMemTab:There is not enough free memory to display this table (%0).",
                        0,
                        num));

  return &erb;
a609 31
#ifdef JAVASCRIPT

  /**************************************************************/
  /* make_no_javascript_memory_error()                          */
  /*                                                            */
  /* Called if a general allocation error appears to have       */
  /* occurred whilst doing some JavaScript related operation.   */
  /*                                                            */
  /* Parameters: A numerical value to include in the message to */
  /*             help the programmer know where the error came  */
  /*             from.                                          */
  /**************************************************************/

  _kernel_oserror * make_no_javascript_memory_error(int stage)
  {
    char num[20];

    sprintf(num, "%d", stage);

    erb.errnum =  0;

    StrNCpy0(erb.errmess,
             lookup_token("NoMemJSc:There is not enough free memory for this JavaScript operation (%0).",
                          0,
                          num));

    return &erb;
  }

#endif

d626 3
d630 17
a646 1
  erb.errnum =  0;
d648 4
a651 4
  StrNCpy0(erb.errmess,
           lookup_token("NoMemGen:There is not enough free memory to continue this operation (%0).",
                        0,
                        num));
d657 36
d1013 1
a1013 1
/* intersection()                                             */
d1015 2
a1016 3
/* Takes two BBoxes and returns a pointer to a third which is */
/* the the intersection between the first two, or NULL, if    */
/* they don't intersect.                                      */
d1018 2
a1019 1
/* Parameters: Pointer to a BBox;                             */
d1021 2
a1022 1
/*             Pointer to another BBox.                       */
d1024 9
a1032 3
/* Returns:    Pointer to a BBox which is the intersection of */
/*             the given two, or NULL, if they don't          */
/*             intersect.                                     */
d1035 6
a1040 1
BBox * intersection(BBox * a, BBox * b)
d1042 2
a1043 1
  static BBox intersect;
d1045 1
a1045 2
  #define max(a,b) ((a) > (b) ? (a) : (b))
  #define min(a,b) ((a) < (b) ? (a) : (b))
d1047 7
a1053 1
  if (!a || !b) return NULL;
d1055 7
a1061 1
  if ((a->xmin >= b->xmax) || (a->xmax <= b->xmin) || (a->ymin >= b->ymax) || (a->ymax <= b->ymin)) return NULL;
d1063 2
a1064 4
  intersect.xmin = max(a->xmin,b->xmin);
  intersect.xmax = min(a->xmax,b->xmax);
  intersect.ymin = max(a->ymin,b->ymin);
  intersect.ymax = min(a->ymax,b->ymax);
d1066 1
a1066 1
  return &intersect;
d1070 1
a1070 1
/* set_graphics_intersection()                                */
d1080 4
d1085 1
a1085 1
/*             set, where xmax and ymax are inclusive;        */
d1092 9
a1100 5
/* Returns:    Pointer to a BBox describing the actual        */
/*             rectangle that was set. If this is NULL, the   */
/*             two do not intersect at all and the redraw     */
/*             subsequent graphics window restoration can and */
/*             should be skipped.                             */
d1103 6
a1108 1
BBox * set_graphics_intersection(BBox * rbox, BBox * cbox)
d1110 1
a1110 2
  BBox * ibox;
  BBox   ogrect = *cbox;
d1112 1
a1112 2
  ogrect.xmax -= 1;
  ogrect.ymax -= 1;
d1114 1
a1114 1
  ibox = intersection(rbox, &ogrect);
d1116 1
a1116 1
  if (!ibox) return NULL;
d1118 4
a1121 1
  bbc_gwindow(ibox->xmin, ibox->ymin, ibox->xmax, ibox->ymax);
d1123 6
a1128 1
  return ibox;
d1132 1
a1132 1
/* restore_graphics_intersection()                            */
d1135 6
a1140 2
/* changed by a call to set_graphics_intersection (which      */
/* *must* have been called before this restoring function).   */
d1149 1
a1149 1
void restore_graphics_intersection(BBox * cbox)
d1151 4
a1154 6
  BBox ogrect = *cbox;

  ogrect.xmax -= 1;
  ogrect.ymax -= 1;

  bbc_gwindow(ogrect.xmin, ogrect.ymin, ogrect.xmax, ogrect.ymax);
d1234 1
a1234 1
void convert_pair_to_os(int x, int y, int * osx, int * osy)
d1262 1
a1262 1
void convert_pair_to_points(int x, int y, int * mpx, int * mpy)
d1305 1
a1305 1
void convert_to_os(int x, int * osx)
d1329 1
a1329 1
void convert_to_points(int x, int * mpx)
d1369 1
a1369 1
void convert_box_to_os(const BBox * mp, BBox * os)
d1394 1
a1394 1
void convert_box_to_points(const BBox * os, BBox * mp)
d1430 1
a1430 1
/* read_sprite_size()                                         */
d1447 19
a1465 17
_kernel_oserror * read_sprite_size(char * name, int * width, int * height)
{
  int               w, h, m;
  _kernel_oserror * e;

  e = _swix(OS_SpriteOp,
            _INR(0,2) | _OUTR(3,4) | _OUT(6),

            0x128,
            sprite_block,
            name,

            &w,
            &h,
            &m);

  if (e) return e;
d1663 2
a1664 2
    BBox   gwind;
    BBox * area;
d1666 2
a1667 2
    gwind.xmin = (bbc_vduvar(BBC_GWLCol)) * wimpt_dx();
    gwind.ymin = (bbc_vduvar(BBC_GWBRow)) * wimpt_dy();
d1671 1
a1671 3
    area = intersection(&gwind, &r->redraw_area);

    if (area)
d1676 4
a1679 4
              area->xmin,
              area->ymin,
              area->xmax - area->xmin,
              area->ymax - area->ymin);
d2488 1
a2488 1
int is_known_browser(browser_data * b)
d2490 2
a2491 2
  browser_data * check = last_browser;
  int            found = 0;
d2532 1
a2532 1
browser_data * utils_parent(browser_data * b)
d2564 1
a2564 1
browser_data * utils_flat_parent(browser_data * b)
d2566 1
a2566 1
  browser_data * parent = b;
d2580 2
a2581 3
  if (parent) return parent;

  return b;
d2599 1
a2599 1
browser_data * utils_ancestor(browser_data * b)
d2604 1
a2604 1
  return b;
d2756 27
d3322 32
@


1.32
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d1758 1
a1758 1
  set.clear_word    = 0xffffffff;
d1814 1
a1814 1
  set.clear_word    = 0xffffffff;
d1850 1
a1850 1
  set.clear_word    = 0xffffffff;
d2562 1
a2562 1
  const static char * base64_table = "ABCDEFGHIJKLMNOP"
@


1.31
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a53 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d138 1
a138 3
  #ifdef TRACE
    if (tl & (1u<<0)) Printf("lookup_token: Called, exitting through lookup_in_given\n");
  #endif
d158 1
a158 3
  #ifdef TRACE
    if (tl & (1u<<0)) Printf("lookup_choice: Called, exitting through lookup_in_given\n");
  #endif
d178 1
a178 3
  #ifdef TRACE
    if (tl & (1u<<0)) Printf("lookup_control: Called, exitting through lookup_in_given\n");
  #endif
d211 1
a211 3
  #ifdef TRACE
    if (tl & (1u<<0)) Printf("lookup_in_given: Lookup token '%s'\n",s);
  #endif
d215 1
a215 3
    #ifdef TRACE
      if (tl & (1u<<0)) Printf("lookup_in_given: Proceeding\n");
    #endif
d238 1
a238 3
      #ifdef TRACE
        if (tl & (1u<<0)) Printf("lookup_in_given: Failed\n");
      #endif
d247 1
a247 3
  #ifdef TRACE
    if (tl & (1u<<0)) Printf("lookup_in_given: Returning %s\n",tokens);
  #endif
d510 1
a510 1
/* If the toolbox generates an error this funct- ion will be  */
a895 1
    if (tl & (1u<<2))
d900 1
a900 1
      Printf("register_null_claimant:   Registered a claimant for browser %p\n", handle);
d910 1
a910 1
        Printf("                          Handler is '\0213%s\0217'\n", (char *) (((char *) function_name) - ((*function_name) & 0x00ffffff)));
d914 1
a914 1
        Printf("                          Cannot find handler's name; address is \02130x%08x\0217\n", (int) handler);
d927 1
a927 3
    #ifdef TRACE
      if (tl & (1u<<2)) Printf("register_null_claimant:   \0211Nulls claimed\0217\n");
    #endif
a945 1
    if (tl & (1u<<2))
d950 1
a950 1
      Printf("deregister_null_claimant: Deregistered a claimant for browser %p\n", handle);
d960 1
a960 1
        Printf("                          Handler is '\0216%s\0217'\n", (char *) (((char *) function_name) - ((*function_name) & 0x00ffffff)));
d964 1
a964 1
        Printf("                          Cannot find handler's name; address is \2160x%08x\0217\n", (int) handler);
d979 1
a979 3
    #ifdef TRACE
      if (tl & (1u<<2)) Printf("deregister_null_claimant: \0212Nulls released\0217\n");
    #endif
@


1.30
log
@Misecllaneous tweaks and fixes. Major addition is full header and footer
support in the printing system - see the Phoenix Choices file for more
information.

Only the Phoenix resources are up to date currently.
@
text
@d15 12
a26 9
/***************************************************/
/* File   : Utils.c                                */
/*                                                 */
/* Purpose: Infrequently altered utilities.        */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 18-Oct-96: Created.                    */
/***************************************************/
d28 1
a28 1
#include "setjmp.h"
d36 1
a36 1
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */
d38 13
a50 3
#include "wimp.h"
#include "wimplib.h"
#include "event.h"
d52 1
a52 2
#include "swis.h"
#include "kernel.h"
d54 4
a57 8
#include "toolbox.h"
#include "event.h"
#include "quit.h"
#include "proginfo.h"
#include "window.h"
#include "gadgets.h"

#include "ToolAction.h" /* NOT the proper Toolbox header, as this needed OSLib... */
a58 1
#include "svcprint.h"
d107 33
a139 39
/*************************************************/
/* lookup_token()                                */
/*                                               */
/* Returns a pointer to an expanded message      */
/* token, or '!' if there was an error.          */
/*                                               */
/* Lookup is done into a global fixed-size       */
/* buffer. So if you pass multiple calls to this */
/* function in as parameters to something else,  */
/* *it will fail* as each call points to the     */
/* same buffer (which will only contain data     */
/* from the last call).                          */
/*                                               */
/* On the upside this means you can modify the   */
/* returned string directly without having to    */
/* worry about taking a copy. If you do this,    */
/* though, you *must* invalidate the record of   */
/* the last looked up token; "*lasttokn = '\0'"  */
/* is sufficient. This is all clearly hideous    */
/* and best avoided, but hey, it's handy from    */
/* time to time...!                              */
/*                                               */
/* Parameters: Pointer to a message token;       */
/*                                               */
/*             1 to report an error if the token */
/*             isn't found as well as returning  */
/*             a string of '!', else 0;          */
/*                                               */
/*             An optional pointer to an         */
/*             argument to substitute into the   */
/*             looked up string, or NULL.        */
/*                                               */
/* Returns:    Pointer to the full message text  */
/*             or '!' to signal an error; never  */
/*             a null pointer.                   */
/*                                               */
/* Assumes:    That the pointer to the message   */
/*             token is never NULL.              */
/*************************************************/
d150 12
a161 13
/*************************************************/
/* lookup_choice()                               */
/*                                               */
/* As lookup_token, but looks up the token in    */
/* the Choices file, rather than the Messages    */
/* file.                                         */
/*                                               */
/* Parameters: As lookup_token.                  */
/*                                               */
/* Returns:    As lookup_token.                  */
/*                                               */
/* Assumes:    As lookup_token.                  */
/*************************************************/
d172 12
a183 13
/*************************************************/
/* lookup_control()                              */
/*                                               */
/* As lookup_token, but looks up the token in    */
/* the Controls file, rather than the Messages   */
/* file.                                         */
/*                                               */
/* Parameters: As lookup_token.                  */
/*                                               */
/* Returns:    As lookup_token.                  */
/*                                               */
/* Assumes:    As lookup_token.                  */
/*************************************************/
d194 23
a216 28
/*************************************************/
/* lookup_in_given()                             */
/*                                               */
/* Workhorse back-end to lookup_token,           */
/* lookup_choice and so-on. See lookup_token     */
/* for more information.                         */
/*                                               */
/* Parameters: A MessagesFD pointer, giving the  */
/*             control block of the file to      */
/*             look in;                          */
/*                                               */
/*             Pointer to a message token;       */
/*                                               */
/*             1 to report an error if the token */
/*             isn't found as well as returning  */
/*             a string of '!', else 0;          */
/*                                               */
/*             An optional pointer to an         */
/*             argument to substitute into the   */
/*             looked up string, or NULL.        */
/*                                               */
/* Returns:    Pointer to the full message text  */
/*             or '!' to signal an error; never  */
/*             a null pointer.                   */
/*                                               */
/* Assumes:    That the pointer to the message   */
/*             token is never NULL.              */
/*************************************************/
d271 10
a280 11
/*************************************************/
/* show_error()                                  */
/*                                               */
/* Reports a (generally serious) error and exits */
/* with EXIT_FAILURE.                            */
/*                                               */
/* Parameters: Pointer to a _kernel_oserror      */
/*             structure.                        */
/*                                               */
/* Assumes:    The pointer may be NULL.          */
/*************************************************/
d319 13
a331 15
/*************************************************/
/* show_error_cont()                             */
/*                                               */
/* Reports an error but allows execution to then */
/* continue (rather than calling exit()) if the  */
/* user clicks on 'Continue' rather than 'Quit'. */
/* This is accomplished by a longjmp back into   */
/* wherever the setjmp was (e.g. in a poll       */
/* loop).                                        */
/*                                               */
/* Parameters: Pointer to a _kernel_oserror      */
/*             structure.                        */
/*                                               */
/* Assumes:    The pointer may be NULL.          */
/*************************************************/
d390 12
a401 13
/*************************************************/
/* show_error_ret()                              */
/*                                               */
/* Reports an error but allows execution to then */
/* continue (rather than calling exit()) if the  */
/* user clicks on 'Continue' rather than 'Quit'. */
/* This is accomplished by simply returning.     */
/*                                               */
/* Parameters: Pointer to a _kernel_oserror      */
/*             structure.                        */
/*                                               */
/* Assumes:    The pointer may be NULL.          */
/*************************************************/
d458 21
a478 23
/*************************************************/
/* show_error_ask()                              */
/*                                               */
/* Reports an error as a query - return result   */
/* of button selection by user.                  */
/*                                               */
/* Parameters: Pointer to a _kernel_oserror      */
/*             structure.                        */
/*                                               */
/*             Pointer to a MessageTrans token   */
/*             to look up - the text is used for */
/*             the buttons in the error box.     */
/*                                               */
/* Assumes:    The error pointer may be NULL. If */
/*             so, the other two are ignored as  */
/*             well. If not, the other must not  */
/*             be NULL.                          */
/*                                               */
/* Returns:    Return value of R1 from call to   */
/*             SWI Wimp_ReportError (3, 4 or 5,  */
/*             depending on which of the up to   */
/*             3 custom buttons were activated). */
/*************************************************/
d526 7
a532 7
/*************************************************/
/* report_toolbox_error()                        */
/*                                               */
/* If the toolbox generates an error this funct- */
/* ion will be called to report it. Parameters   */
/* are as standard for a Toolbox event handler.  */
/*************************************************/
d541 11
a551 13
/*************************************************/
/* make_no_fetch_memory_error()                  */
/*                                               */
/* Typically called from Fetch.c, if a memory    */
/* claim fails early in a fetch. Stores an       */
/* appropriate error in the global error         */
/* block 'erb'.                                  */
/*                                               */
/* Parameters: A numerical value to include in   */
/*             the message to help the           */
/*             programmer know where the error   */
/*             came from.                        */
/*************************************************/
d569 10
a578 12
/*************************************************/
/* make_no_cont_memory_error()                   */
/*                                               */
/* Called if a memory claim fails during a fetch */
/* - stores an appropriate error in the global   */
/* error block 'erb'.                            */
/*                                               */
/* Parameters: A numerical value to include in   */
/*             the message to help the           */
/*             programmer know where the error   */
/*             came from.                        */
/*************************************************/
d596 11
a606 13
/*************************************************/
/* make_no_table_memory_error()                  */
/*                                               */
/* Typically called from Tables.c, if a memory   */
/* claim fails during table parsing routines.    */
/* Stores an appropriate error in the global     */
/* error block 'erb'.                            */
/*                                               */
/* Parameters: A numerical value to include in   */
/*             the message to help the           */
/*             programmer know where the error   */
/*             came from.                        */
/*************************************************/
d626 10
a635 12
  /*************************************************/
  /* make_no_javascript_memory_error()             */
  /*                                               */
  /* Called if a general allocation error appears  */
  /* to have occurred whilst doing some JavaScript */
  /* related operation.                            */
  /*                                               */
  /* Parameters: A numerical value to include in   */
  /*             the message to help the           */
  /*             programmer know where the error   */
  /*             came from.                        */
  /*************************************************/
d655 10
a664 12
/*************************************************/
/* make_no_memory_error()                        */
/*                                               */
/* A general error generation routine for failed */
/* memory claims. Stores the error in the global */
/* error block 'erb'.                            */
/*                                               */
/* Parameters: A numerical value to include in   */
/*             the message to help the           */
/*             programmer know where the error   */
/*             came from.                        */
/*************************************************/
d682 14
a695 15
/*************************************************/
/* show_centred()                                */
/*                                               */
/* Shows a Toolbox object centred to the screen, */
/* opened persistently where possible            */
/*                                               */
/* Parameters: An Object ID of any Toolbox       */
/*             object that will return its Wimp  */
/*             window handle when                */
/*             Toolbox_ObjectMiscOp is called    */
/*             for it with a reason code of 0 -  */
/*             e.g. Window, DCS, or ColourDBox.  */
/*                                               */
/* Assumes:    That the ID is a valid one.       */
/*************************************************/
d764 16
a779 16
/*************************************************/
/* set_corrected_extent()                        */
/*                                               */
/* Sets the extent of a window, making sure that */
/* xmin = 0 and ymax = 0 (so ymin is negative,   */
/* etc. etc.) - this means that topx = topy = 0. */
/*                                               */
/* Parameters: Flags to pass to the Toolbox in   */
/*             the SetExtent call;               */
/*                                               */
/*             The object ID of the browser      */
/*             window to be altered;             */
/*                                               */
/*             Pointer to a BBox holding the     */
/*             extent coordinates.               */
/*************************************************/
d793 12
a804 13
/*************************************************/
/* find_behind()                                 */
/*                                               */
/* Returns the window handle of the first non-   */
/* pane window in front of a given window.       */
/*                                               */
/* Parameters: The window handle in question.    */
/*                                               */
/* Returns:    Handle of the first non-pane      */
/*             window in front of the given one, */
/*             or -1 if it is at the top of the  */
/*             stack.                            */
/*************************************************/
d829 17
a845 19
/*************************************************/
/* find_tool_sizes()                             */
/*                                               */
/* Returns the title bar and scroll bar widths   */
/* in OS units, including their outlines.        */
/*                                               */
/* Parameters: Pointer to an int, in which the   */
/*             title bar height is placed;       */
/*                                               */
/*             Pointer to an int, in which the   */
/*             horizontal scroll bar bar height  */
/*             is placed;                        */
/*                                               */
/*             Pointer to an int, in which the   */
/*             vertical scroll bar width is      */
/*             placed.                           */
/*                                               */
/* Assumes:    Any of the pointers may be NULL.  */
/*************************************************/
d900 8
a907 8
/*************************************************/
/* register_null_claimant()                      */
/*                                               */
/* Call if you want to claim null polls.         */
/*                                               */
/* Parameters: As for a Wimp event handler, but  */
/*             without the object ID.            */
/*************************************************/
d953 8
a960 8
/*************************************************/
/* deregister_null_claimant()                    */
/*                                               */
/* Call if you want to release null polls.       */
/*                                               */
/* Parameters: As for a Wimp event handler, but  */
/*             without the object ID.            */
/*************************************************/
d1008 15
a1022 16
/*************************************************/
/* intersection()                                */
/*                                               */
/* Takes two BBoxes and returns a pointer to a   */
/* third which is the the intersection between   */
/* the first two, or NULL, if they don't         */
/* intersect.                                    */
/*                                               */
/* Parameters: Pointer to a BBox;                */
/*                                               */
/*             Pointer to another BBox.          */
/*                                               */
/* Returns:    Pointer to a BBox which is the    */
/*             intersection of the given two,    */
/*             or NULL, if they don't intersect. */
/*************************************************/
d1043 25
a1067 31
/*************************************************/
/* set_graphics_intersection()                   */
/*                                               */
/* Intended for redraw loop routines, this sets  */
/* up a given graphics rectangle, but takes      */
/* account of the intersection between this and  */
/* the current (given) graphics rectangle for    */
/* the redraw. The rectangle *must* be restored  */
/* with restore_graphics_intersection() as soon  */
/* as the rectangle set here is finished with;   */
/* the caller must thus remember this rectangle  */
/* for later.                                    */
/*                                               */
/* Parameters: Pointer to a BBox describing the  */
/*             rectangle to set, where xmax and  */
/*             ymax are inclusive;               */
/*                                               */
/*             Pointer to a BBox describing the  */
/*             current graphics rectangle, where */
/*             xmax and ymax are exclusive (e.g. */
/*             as in a WimpRedrawWindowBlock's   */
/*             redraw_area BBox).                */
/*                                               */
/* Returns:    Pointer to a BBox describing the  */
/*             actual rectangle that was set. If */
/*             this is NULL, the two do not      */
/*             intersect at all and the redraw   */
/*             subsequent graphics window        */
/*             restoration can and should be     */
/*             skipped.                          */
/*************************************************/
d1086 13
a1098 16
/*************************************************/
/* restore_graphics_intersection()               */
/*                                               */
/* Restores the Wimp's redraw graphics rectangle */
/* which was changed by a call to                */
/* set_graphics_intersection (which *must* have  */
/* been called before this restoring function).  */
/*                                               */
/* Parameters: Pointer to a BBox holding the     */
/*             graphics rectangle as it was      */
/*             before set_graphics_intersection  */
/*             was called, where xmax and ymax   */
/*             are exclusive (e.g. as in a       */
/*             WimpRedrawWindowBlock's           */
/*             redraw_area BBox).                */
/*************************************************/
d1110 16
a1125 19
/*************************************************/
/* read_os_to_points()                           */
/*                                               */
/* To avoid having to use a SWI every time       */
/* a conversion is made between OS units and     */
/* points or vice versa, this initialises        */
/* some internal variables which are used        */
/* subsequently. It may be called on a mode      */
/* change, for example, to ensure things are up  */
/* to date.                                      */
/*                                               */
/* If printing, values of MillipointsPerOSUnit   */
/* as defined at the top of this file are used,  */
/* since you can't read it; it seems that during */
/* a print job, this call may *not* be used,     */
/* contrary to the information on PRM 3-573.     */
/* This bug caused *severe* grief during the     */
/* development of the print routines...          */
/*************************************************/
d1166 20
a1185 23
/*************************************************/
/* convert_pair_to_os()                          */
/*                                               */
/* Converts from millipoints to OS units. The    */
/* scale factor is determined by a previous call */
/* to read_os_to_points.                         */
/*                                               */
/* Parameters: A coordinate in millipoints;      */
/*                                               */
/*             Another coord in millipoints;     */
/*                                               */
/*             Pointer to an int into which the  */
/*             first coordinate, converted to OS */
/*             units, is placed;                 */
/*                                               */
/*             Similarly a pointer to an int for */
/*             the second coordinate.            */
/*                                               */
/* Assumes:    The pointers may NOT be NULL. The */
/*             input and output variables may be */
/*             the same (so passing in x, y, &x, */
/*             &y would work correctly).         */
/*************************************************/
d1193 21
a1213 23
/*************************************************/
/* convert_pair_to_points()                      */
/*                                               */
/* Converts from OS units to millipoints. The    */
/* scale factor is determined by a previous call */
/* to read_os_to_points.                         */
/*                                               */
/* Parameters: A coordinate in OS units;         */
/*                                               */
/*             Another coordinate in OS units;   */
/*                                               */
/*             Pointer to an int into which the  */
/*             first coordinate, converted to    */
/*             millipoints, is placed;           */
/*                                               */
/*             Similarly a pointer to an int for */
/*             the second coordinate.            */
/*                                               */
/* Assumes:    The pointers may not be NULL. The */
/*             input and output variables may be */
/*             the same (so passing in x, y, &x, */
/*             &y would work correctly).         */
/*************************************************/
d1239 18
a1256 20
/*************************************************/
/* convert_to_os()                               */
/*                                               */
/* As convert_pair_to_os, but only converts one  */
/* coordinate at a time.                         */
/*                                               */
/* Parameters: An x coordinate in millipoints;   */
/*                                               */
/*             Pointer to an int into which the  */
/*             coordinate, converted to OS       */
/*             units, is placed.                 */
/*                                               */
/* Assumes:    That the pointer is not NULL. The */
/*             input and output variable may be  */
/*             the same (so passing in x, &x     */
/*             would work correctly);            */
/*                                               */
/*             If x and y scalings differ, this  */
/*             will only ever use the x scaling. */
/*************************************************/
d1263 18
a1280 20
/*************************************************/
/* convert_to_points()                           */
/*                                               */
/* As convert_pair_to_points, but only converts  */
/* one coordinate at a time.                     */
/*                                               */
/* Parameters: An x coordinate in OS units;      */
/*                                               */
/*             Pointer to an int into which the  */
/*             coordinate, converted to milli-   */
/*             points, is placed.                */
/*                                               */
/* Assumes:    That the pointer is not NULL. The */
/*             input and output variable may be  */
/*             the same (so passing in x, &x     */
/*             would work correctly);            */
/*                                               */
/*             If x and y scalings differ, this  */
/*             will only ever use the x scaling. */
/*************************************************/
d1305 16
a1320 18
/*************************************************/
/* convert_box_to_os()                           */
/*                                               */
/* As convert_pair_to_os, but converts the four  */
/* coordinates inside a BBox in one go.          */
/*                                               */
/* Parameters: Pointer to a BBox containing      */
/*             coords in millipoints;            */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             first box's coords, converted to  */
/*             OS units, are placed.             */
/*                                               */
/* Assumes:    That neither pointer is NULL. The */
/*             two pointers may be the same (so  */
/*             passing in &box, &box would work  */
/*             correctly).                       */
/*************************************************/
d1330 16
a1345 18
/*************************************************/
/* convert_box_to_points()                       */
/*                                               */
/* As convert_pair_to_points, but converts the   */
/* four coordinates inside a BBox in one go.     */
/*                                               */
/* Parameters: Pointer to a BBox containing      */
/*             coords in OS units;               */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             first box's coords, converted to  */
/*             millipoints, are placed.          */
/*                                               */
/* Assumes:    That neither pointer is NULL. The */
/*             two pointers may be the same (so  */
/*             passing in &box, &box would work  */
/*             correctly).                       */
/*************************************************/
d1382 17
a1398 18
/*************************************************/
/* read_sprite_size()                            */
/*                                               */
/* Finds out the size of a given sprite in the   */
/* application's sprite pool in OS units.        */
/*                                               */
/* Parameters: Pointer to the sprite name;       */
/*                                               */
/*             Pointer to int into which the     */
/*             sprite's width is returned;       */
/*                                               */
/*             Pointer to int into which the     */
/*             sprite's height is returned.      */
/*                                               */
/* Assumes:    The name pointer is not NULL, but */
/*             either of the two int pointers    */
/*             may be.                           */
/*************************************************/
d1427 23
a1449 26
/*************************************************/
/* utils_text_width()                            */
/*                                               */
/* Returns the width of a given piece of text,   */
/* in OS units, if it were to be plotted in the  */
/* Desktop. Wimp_TextOp is used if available,    */
/* else the width and spacing of the bitmap font */
/* is read and the width is calculated from      */
/* this instead.                                 */
/*                                               */
/* Parameters: Pointer to the text;              */
/*                                               */
/*             Pointer to an int, into which the */
/*             width is written;                 */
/*                                               */
/*             0 to work out the whole string    */
/*             width, or the number of chars to  */
/*             read.                             */
/*                                               */
/* Assumes:    Either pointer may be NULL;       */
/*                                               */
/*             If the number of chars to read is */
/*             greater than the string length,   */
/*             the value given is ignored and    */
/*             the string length used instead.   */
/*************************************************/
d1515 12
a1526 12
/*************************************************/
/* set_gadget_state()                            */
/*                                               */
/* Greys or ungreys a gadget, only changing its  */
/* state to avoid flicker.                       */
/*                                               */
/* Parameters: Object ID the gadget resides in;  */
/*                                               */
/*             Component ID of the gadget;       */
/*                                               */
/*             1 to grey, 0 to ungrey.           */
/*************************************************/
d1549 9
a1557 12
/*************************************************/
/* anti_twitter()                                */
/*                                               */
/* Calls the anti-twitter code over a given      */
/* redraw area.                                  */
/*                                               */
/* Parameters: Pointer to a WimpRedrawWindow     */
/*             block with the redraw_area BBox   */
/*             holding the area over which the   */
/*             anti-twitter code should be       */
/*             called.                           */
/*************************************************/
d1642 6
a1647 6
/*************************************************/
/* adjust()                                      */
/*                                               */
/* Returns 1 if Wimp_GetPointerInfo says that    */
/* Adjust is being pressed, else 0.              */
/*************************************************/
d1658 11
a1668 12
/*************************************************/
/* hide_gadget()                                 */
/*                                               */
/* Hides a given gadget by moving it out of the  */
/* visible area of the window it is in.          */
/*                                               */
/* Parameters: Object ID the gadget lies in;     */
/*             Component ID of the gadget.       */
/*                                               */
/* Returns:    1 if the gadget was moved out,    */
/*             else 0.                           */
/*************************************************/
d1691 10
a1700 11
/*************************************************/
/* show_gadget()                                 */
/*                                               */
/* Shows a given gadget hidden by hide_gadget.   */
/*                                               */
/* Parameters: Object ID the gadget lies in;     */
/*             Component ID of the gadget.       */
/*                                               */
/* Returns:    1 if the gadget was moved in,     */
/*             else 0.                           */
/*************************************************/
d1723 11
a1733 11
/*************************************************/
/* gadget_hidden()                               */
/*                                               */
/* Call to find out if a gadget has been moved   */
/* out with hide_gadget or is still visible.     */
/*                                               */
/* Parameters: Object ID the gadget lies in;     */
/*             Component ID of the gadget.       */
/*                                               */
/* Returns:    1 if the gadget is hidden else 0. */
/*************************************************/
d1752 9
a1760 10
/*************************************************/
/* slab_gadget()                                 */
/*                                               */
/* Slabs a gadget in briefly, by setting its     */
/* Selected bit. Gadget must be made of one icon */
/* only.                                         */
/*                                               */
/* Parameters: Object ID the gadget lies in;     */
/*             Component ID of the gadget.       */
/*************************************************/
d1808 9
a1816 9
/*************************************************/
/* slab_gadget_in()                              */
/*                                               */
/* Slabs a gadget in, by setting its Selected    */
/* bit. Gadget must be made of one icon only.    */
/*                                               */
/* Parameters: Object ID the gadget lies in;     */
/*             Component ID of the gadget.       */
/*************************************************/
d1844 9
a1852 9
/*************************************************/
/* slab_gadget_out()                             */
/*                                               */
/* Slabs a gadget out, by clearing its Selected  */
/* bit. Gadget must be made of one icon only.    */
/*                                               */
/* Parameters: Object ID the gadget lies in;     */
/*             Component ID of the gadget.       */
/*************************************************/
d1880 9
a1888 11
/*************************************************/
/* utils_check_caret_restoration()               */
/*                                               */
/* Checks to see if the given dialogue has the   */
/* caret, and if it has a parent. If so, it'll   */
/* return the Object ID of that parent, else     */
/* NULL_ObjectId is written.                     */
/*                                               */
/* Parameters: The Object ID of the dialogue     */
/*             to check.                         */
/*************************************************/
d1943 13
a1955 13
/*************************************************/
/* utils_restore_caret()                         */
/*                                               */
/* If the given dialogue has the caret, put the  */
/* caret into the parent of this object, in the  */
/* default input focus position.                 */
/*                                               */
/* Parameters: The Object ID of the dialogue     */
/*             whos parent is to gain the caret. */
/*                                               */
/* Assumes:    The parent has a default caret    */
/*             position set up.                  */
/*************************************************/
d1991 20
a2010 24
/*************************************************/
/* copy_toolaction_info()                        */
/*                                               */
/* Copies the internal details of a given        */
/* ToolAction gadget to another.                 */
/*                                               */
/* Ident off, ident on, ident faded, select      */
/* action, adjust action and click-show details  */
/* are copied with ToolAction SWIs; the help     */
/* text is copied with gadget library calls.     */
/*                                               */
/* This does *not* copy state info, such as      */
/* on/off or greyed.                             */
/*                                               */
/* Parameters: Object ID the source gadget is    */
/*             in;                               */
/*                                               */
/*             Component ID of the source;       */
/*                                               */
/*             Object ID the destination gadget  */
/*             is in;                            */
/*                                               */
/*             Component ID of the destination.  */
/*************************************************/
d2201 25
a2225 27
/*************************************************/
/* set_window_flags()                            */
/*                                               */
/* Sets the flags of a given window, assuming    */
/* the nested Wimp is available...               */
/*                                               */
/* Parameters: Window handle;                    */
/*             EOR word;                         */
/*             Clear word.                       */
/*                                               */
/* Assumes:    That a window manager that        */
/*             supports extended Wimp_OpenWindow */
/*             calls (R2 = 'TASK') is present.   */
/*                                               */
/* The flags are set according to                */
/*                                               */
/* new = (old BIC clear word) EOR EOR word       */
/*                                               */
/* i.e.:                                         */
/*                                               */
/* C  E  Effect                                  */
/* ------------                                  */
/* 0  0  Preserve bit                            */
/* 0  1  Toggle bit                              */
/* 1  0  Clear bit                               */
/* 1  1  Set bit                                 */
/*************************************************/
d2281 11
a2291 12
/*************************************************/
/* debounce_keypress()                           */
/*                                               */
/* For some key presses (e.g. function keys), it */
/* is not desirable to let the key autorepeat.   */
/* This function sits in a tight loop waiting    */
/* for all keys to be released before exitting.  */
/*                                               */
/* Returns: 1 if a key was being pressed and the */
/*          function waited for its release,     */
/*          else 0.                              */
/*************************************************/
d2317 9
a2325 10
/*************************************************/
/* task_from_window()                            */
/*                                               */
/* Returns the task handle of the owner of a     */
/* given window.                                 */
/*                                               */
/* Parameters: A window handle.                  */
/*                                               */
/* Returns:    Task handle of the window owner.  */
/*************************************************/
d2327 1
a2327 1
int task_from_window (int window_handle)
d2348 16
a2363 18
/*************************************************/
/* utils_browser_from_window()                   */
/*                                               */
/* Given a window handle, returns an associated  */
/* browser_data struct, if one may be found.     */
/*                                               */
/* Parameters: The window handle;                */
/*                                               */
/*             Pointer to a pointer to a         */
/*             browser_data struct, in which the */
/*             associated structure's address is */
/*             written, or NULL for none found / */
/*             there is an error.                */
/*                                               */
/* Assumes:    The last parameter may not be     */
/*             NULL (it is pointless to allow    */
/*             this).                            */
/*************************************************/
d2427 13
a2439 14
/*************************************************/
/* is_known_browser()                            */
/*                                               */
/* Finds out if the given browser_data struct is */
/* in the list of known structures. The struct   */
/* may be NULL (0 would be returned), so this    */
/* doesn't need to be checked for externally.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             to check.                         */
/*                                               */
/* Returns:    1 if the structure is in the list */
/*             or 0 if it isn't.                 */
/*************************************************/
d2463 21
a2483 23
/*************************************************/
/* utils_parent()                                */
/*                                               */
/* Works out a given browser_data structure's    */
/* parent. If there is only an ancestor or       */
/* neither an ancestor or parent, it returns     */
/* NULL.                                         */
/*                                               */
/* Does not care whether the frameset was built  */
/* with one set of nested frameset elements or   */
/* through separate framesets in different       */
/* files and considers a parent to be the        */
/* browser immediately 'below' the given child.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             that you want the parent of.      */
/*                                               */
/* Returns:    Pointer to the structure's        */
/*             parent, or NULL if there is only  */
/*             an ancestor or no parents at all. */
/*                                               */
/* Assumes:    If it gets NULL, it returns NULL. */
/*************************************************/
d2494 22
a2515 25
/*************************************************/
/* utils_flat_parent()                           */
/*                                               */
/* Works out a given browser_data structure's    */
/* parent according to the JavaScript model.     */
/* This works as follows:                        */
/*                                               */
/* The parent of any child defined by <frameset> */
/* elements is the browser holding the document  */
/* in which the defining <frameset> lies. No     */
/* other 'intermediate' browsers exist, as far   */
/* as this model is concerned.                   */
/*                                               */
/* If an item has no parent a pointer back to    */
/* itself is returned (parentless items are      */
/* parents to themselves).                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             that you want the parent of.      */
/*                                               */
/* Returns:    Pointer to the structure's        */
/*             parent, as described above.       */
/*                                               */
/* Assumes:    If it gets NULL, it returns NULL. */
/*************************************************/
d2538 14
a2551 15
/*************************************************/
/* utils_ancestor()                              */
/*                                               */
/* Works out a given browser_data structure's    */
/* ancestor (which may be the given structure!). */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             that you want the ancestor of.    */
/*                                               */
/* Returns:    Pointer to the structure's        */
/*             ancestor.                         */
/*                                               */
/* Assumes:    If it gets NULL, it returns NULL. */
/*             Otherwise, it never returns NULL. */
/*************************************************/
d2561 23
a2583 25
/*************************************************/
/* encode_base64()                               */
/*                                               */
/* Passed a pointer to data and its length, this */
/* will fill the output buffer with Base64-      */
/* encoded data, returning the length of the     */
/* output data (this is not terminated).         */
/*                                               */
/* The length of the output will be -            */
/*                                               */
/* (length of input, rounded up to next multiple */
/* of 3) times 4                                 */
/*                                               */
/* - so make sure you have a big enough output   */
/* buffer.                                       */
/*                                               */
/* Parameters: Pointer to the data to encode;    */
/*                                               */
/*             Length of the data to encode;     */
/*                                               */
/*             Pointer to the output buffer.     */
/*                                               */
/* Assumes:    That the output buffer is big     */
/*             enough (see above).               */
/*************************************************/
d2585 1
a2585 1
int encode_base64(const char * in, int len, char * out)
d2626 19
a2644 21
/*************************************************/
/* utils_strcasecmp()                            */
/*                                               */
/* Function to compare two strings case          */
/* insensitively.                                */
/*                                               */
/* Originally by S.Brodie.                       */
/*                                               */
/* The conversions to unsigned int stop the      */
/* compiler messing around with shifts all over  */
/* the place whilst trying to promote the chars  */
/* to int whilst retaining the sign.             */
/*                                               */
/* Problems: Choice of return value when strings */
/* do not match is based upon character number   */
/* rather than any alphabetic sorting.           */
/*                                               */
/* Parameters: As strcmp.                        */
/*                                               */
/* Returns:    As strcmp.                        */
/*************************************************/
d2666 20
a2685 21
/*************************************************/
/* utils_strncasecmp()                           */
/*                                               */
/* Function to compare two strings case          */
/* insensitively up to a maximum char count.     */
/*                                               */
/* Originally by S.Brodie.                       */
/*                                               */
/* The conversions to unsigned int stop the      */
/* compiler messing around with shifts all over  */
/* the place whilst trying to promote the chars  */
/* to int whilst retaining the sign.             */
/*                                               */
/* Problems: Choice of return value when strings */
/* do not match is based upon character number   */
/* rather than any alphabetic sorting.           */
/*                                               */
/* Parameters: As strncmp.                       */
/*                                               */
/* Returns:    As strncmp.                       */
/*************************************************/
d2709 13
a2721 14
/*************************************************/
/* utils_strdup()                                */
/*                                               */
/* Returns a pointer to a malloc'd copy of the   */
/* given string.                                 */
/*                                               */
/* Parameters: Pointer to the string to copy.    */
/*                                               */
/* Returns:    Pointer to a malloc'd copy of the */
/*             given string.                     */
/*                                               */
/* Assumes:    Returns NULL if it gets NULL or   */
/*             if memory allocation fails.       */
/*************************************************/
d2736 14
a2749 15
/*************************************************/
/* utils_get_task_handle()                       */
/*                                               */
/* Returns the task handle of the given task     */
/* (name comparison is case insensitive).        */
/*                                               */
/* Parameters: Pointer to a null-terminated task */
/*             name;                             */
/*                                               */
/*             Pointer to an unsigned int, in    */
/*             which the task handle is written, */
/*             or 0 if the task is not found.    */
/*                                               */
/* Assumes:    Neither pointer may be NULL.      */
/*************************************************/
d2800 6
a2805 6
/*************************************************/
/* utils_stop_proxy()                            */
/*                                               */
/* Stops the [WebServe] application by sending   */
/* an AppControl message.                        */
/*************************************************/
d2855 17
a2871 19
/*************************************************/
/* utils_len_printf()                            */
/*                                               */
/* Returns the length of a given printf string.  */
/* Can be useful for buffer length determination */
/* when wishing to use sprintf, for example.     */
/*                                               */
/* This function runs *very* slowly. If it is    */
/* difficult / impossible to determine the       */
/* length (or upper limit of length) any other   */
/* way, use it; else find a different approach   */
/* (e.g. see utils_number_length).               */
/*                                               */
/* Parameters: As for printf.                    */
/*                                               */
/* Returns:    Length of the output string (as   */
/*             returned by vfprintf) or -1 if    */
/*             some error occurred.              */
/*************************************************/
d2891 14
a2904 15
/*************************************************/
/* utils_number_length()                         */
/*                                               */
/* Returns the number of bytes the given number  */
/* would occupy if converted to a string by      */
/* sprintf with a '%d' specifier used in the     */
/* format string.                                */
/*                                               */
/* Parameters: The number to check.              */
/*                                               */
/* Returns:    The number of characters it would */
/*             occupy as a string.               */
/*                                               */
/* Assumes:    An 'int' is 32-bit signed.        */
/*************************************************/
d2926 9
a2934 10
/*************************************************/
/* utils_return_hash()                           */
/*                                               */
/* Returns a very crude hash number for a given  */
/* string.                                       */
/*                                               */
/* Parameters: Pointer to the string.            */
/*                                               */
/* Returns:    A hash number.                    */
/*************************************************/
d2949 13
a2961 17
/*************************************************/
/* utils_build_user_agent_string                 */
/*                                               */
/* Works out an appropriate HTTP response User   */
/* Agent string.                                 */
/*                                               */
/* Parameters: Flag to indicate fake Netscape    */
/*             header required.                  */
/*                                               */
/*             Pointer to a buffer to place the  */
/*             string in;                        */
/*                                               */
/*             Size of the buffer - note that a  */
/*             string longer than                */
/*             Limits_UserAgent will never be    */
/*             generated.                        */
/*************************************************/
d3075 9
a3083 10
/*************************************************/
/* utils_check_scrap()                           */
/*                                               */
/* If Save_ScrapFile (which should represent a   */
/* system variable name, see Save.h) does not    */
/* exist, report an appropriate error and        */
/* return 1. Else return 0.                      */
/*                                               */
/* Returns: See above.                           */
/*************************************************/
d3122 20
a3141 24
/*************************************************/
/* utils_canonicalise_path()                     */
/*                                               */
/* Take some pathname (which may include         */
/* a path or other general system variable) and  */
/* expand (or canonicalise) it.                  */
/*                                               */
/* Caller is responsible for calling free() on   */
/* the returned block.                           */
/*                                               */
/* Parameters: Pointer to the path to            */
/*             canonicalise;                     */
/*                                               */
/*             Pointer to a char *, which will   */
/*             be filled in with the address of  */
/*             a malloced block - the caller is  */
/*             responsible for freeing it.       */
/*                                               */
/* Returns:    If there is an error, it returns  */
/*             it, but it may return NULL and    */
/*             also return NULL as the pointer   */
/*             to the malloced block if some     */
/*             other internal failure occurred.  */
/*************************************************/
d3184 12
a3195 14
/*************************************************/
/* utils_build_tree()                            */
/*                                               */
/* Takes a fully canonicalised pathname and      */
/* ensures that all the directories in the path  */
/* exist. This is useful if you are going to     */
/* save something to a temporary directory in    */
/* Scrap or somewhere in <Choices$Write>, say,   */
/* and need to ensure that the directory         */
/* structure you're addressing is present.       */
/*                                               */
/* Parameters: Pointer to the path to ensure is  */
/*             present.                          */
/*************************************************/
@


1.29
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d98 1
a98 1
static char * lookup_in_given (MessagesFD * control, char * s, int flag, char * arg);
d140 1
a140 1
char * lookup_token(char * s, int flag, char * arg)
d163 1
a163 1
char * lookup_choice(char * s, int flag, char * arg)
d186 1
a186 1
char * lookup_control(char * s, int flag, char * arg)
d224 1
a224 1
static char * lookup_in_given(MessagesFD * control, char * s, int flag, char * arg)
d232 1
a232 1
  if (strcmp(lasttokn, s))
d238 1
a238 1
    StrNCpy0(lasttokn, s);
d289 1
a289 1
void show_error(_kernel_oserror *e)
d342 1
a342 1
void show_error_cont(_kernel_oserror *e)
d413 1
a413 1
void show_error_ret(_kernel_oserror *e)
@


1.28
log
@Another intermediate check-in, resources may not be up to date; items
most likely to be buildable are PhoenixJ and BrowseD. Done because I'm
about to make some rather dodgy changes to code otherwise unchanged
since the Customer browser and I may well have to back them out...

In Handlers.c now set the HFlags_HasBeenVisited bit of a token at the point
it is first clicked on. Means the link returns to a "visited" colour after
the highlight flash immediately. This will persist for as long as the browser
window is kept open on that page, though if the URL doesn't end up making it
into the history for whatever reason it would "unhighlight" on reload; fair
enough, really. The highlight is window-local, so there are no redraw worries
for other open windows with links to the same URL (though other same-URL
links on the same page aren't updated either).

All forms submissions force a reload (principally for eudoramail.com, but
many other sites have similar requirements).

!MkClean and !MkClnAll didn't correctly call the utility to strip Makefile
dependencies. Fixed.

On fetch closedown, fetchpage_preprocess_token could be called on a token
which had already been run through the preprocessor. Now checks the flags
word before proceeding.

Image RAM cache and garbage collection system implemented - see new Choices
file entries CollectAfter, FreeRAMLimit and UnusedImageLimit to get an
overview. This contains groundwork for JavaScript image array support.

More JavaScript support improvements. Any one window object will know its
parent, top, this, etc.; frames array working except for a frameset created
via. multiple documents; opener for something created with window.open is
currently not set and don't know why (property is being created, pointer to
valid object is held, but JS engine returns 'null'. Ho hum) - JSChain won't
work yet, then.
@
text
@d106 1
a106 2
/* NB, due to various limitations of C, the      */
/* lookup is done into a global fixed-size       */
d113 9
d2715 1
a2715 1
/* Originally by sbrodie.                        */
d2757 1
a2757 1
/* Originally by sbrodie.                        */
@


1.27
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d2788 28
@


1.26
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d431 2
a432 2
      StrNCpy0(name,lookup_token("_TaskName:Browse",0,0));
      StrNCpy0(spri,lookup_token("_SpriName:!browse",0,0));
d2558 1
a2558 2
  if      (b->parent      && b->parent      != b->ancestor) return b->parent;
  else if (b->real_parent && b->real_parent != b->ancestor) return b->real_parent;
d2567 2
a2568 12
/* parent. If there is only an ancestor or       */
/* neither an ancestor or parent, it returns     */
/* NULL.                                         */
/*                                               */
/* Will only look to parents that are within the */
/* scope of a frameset built through one set of  */
/* frameset elements - a frame which has any     */
/* children because it loads a document that     */
/* goes on to define them is the parent of those */
/* children. Keeps going down until it has found */
/* the base parent - doesn't stop after one      */
/* check (like utils_parent).                    */
d2570 9
a2578 2
/* Originally created to support the JavaScript  */
/* parent/child model.                           */
d2584 1
a2584 2
/*             parent, or NULL if there is only  */
/*             an ancestor or no parents at all. */
d2591 1
a2591 1
  browser_data * parent;
d2595 2
a2596 1
  parent = b->parent;
d2598 1
a2598 1
  if (parent)
d2600 1
a2600 1
    while (parent->parent) parent = parent->parent;
d2603 5
a2607 1
  return parent;
@


1.25
log
@All !Run[D], Choices, Messages, Controls and Res files are up to date.

RefoKeep and RefoHold options added to, respectively, try and maintain
the line at the top of the visible area when reformatting, and not shrink
the vertical extent at the start of a reformat to try and avoid flicker
to the top of the page and back down again when RefoKeep is on. Choices
front-end implemented, which also allows RefoWait and RefoTime to be set.
Unfortunately for various reasons this doesn't help the page jumping when
unsized images come in (but RefoHold can improve matters...) - roll on
the image history.

DragToScroll and NoScrollBars options added for frames; included new
pointer type, Mouse_Shape_DTS, so relevant Controls file entries done
and Sprites[22] files updated as required. Noticed some builds have
a low-res ptr_link with a mask - mask removed.

Named anchor following fixed up somewhat - anchors near the bottom of
the page shouldn't be displayed, and then pulled down when the fetcher
releases null polls and ensures the y extent is correct (this through
implementing the min_height field in the browser_data structure).

RefoHang was never implemented and there seems little point to it now,
so the entry for it has been removed from the global choices structure
and all Choices files.

Markers menus should work properly now (in last check-in they would not
update correctly if Adjust was used on the entries).

URI handler usage now a lot more sensible, with configuration of how the
browser uses the module from both a Utils menu submenu (sic) and the
Choices dialogue.

Slightly dodgy 'hang around waiting for user input' stuff for the Cookies
dialogue box: All fetches are suspended; the fetcher remembers some info
about its state at the time the cookie came in, and restores it later; it
will only do this for one fetch at a time. It's necessary to single-thread
the fetcher at this point anyway, since other fetches may have a
dependency on the cookie that is hanging in mid-air at that point. As part
of this, some of the fetcher code has been split out into separate
functions (to try and 'black box' the code a bit). Anyway, Cookie Query
dialogue box now implemented with appropriate Choices file entry and
UI work in the Choices dialogue box.

Phoenix build Choices rearranged. Can now choose when the image history
is saved from the front end. Added also MSIE 4-style table option menu
for JPEG support (OS only, OS if it can handle it, internal only).

Should be a bit faster at loading the history - though 95% of the time
is spent in SWI URL_ParseURL. URL descriptions are stored more
efficiently as part of this - one malloc block instead of several
small blocks. The minimum block size for malloc blocks typically leads
to a significantly smaller startup wimpslot depending on the visit
history size.

Nasty bug in image system fixed. If an image size came in and a reformat
was to take place, the line the image lies in is found and the reformat
progresses from there. Unforunately, this didn't check to see if the
token can't be found in the line list, so it'd reformat from the top
of the page...! This would happen if, for example, an image halfway down
the page came in whilst a reformat for an image higher up had just begun.

In Choices.c, made choices_set_timetype_field, choices_set_uri_field,
choices_set_plugin_field, choices_set_cookie_field, and
choices_set_jpeg_field static (so they're not declared in Choices.h now).

Two memory leaks plugged in URL comparison routines in URLutils.c
(calling free() url_description instead of urlutils_free_descripton()).

Client pull reload handler was setting the reload flag if reloading
the same page, but forgetting to turn on reload_lock so
fetchpage_postprocessed was clearing the reload state... Similarly,
Ctrl+Shift+SELECT-Click on a link when the Controls file 'UseSmall'
entry is 'no' would not have reloaded as it should. Both fixed.

Frames shouldn't be so keen on acquiring horizontal scroll bars and never
letting them go when their width is decreased now. Frames set up for
'scrolling="yes"' will not start with no scroll bars and then gain them
shortly afterwards, causing flicker and two reformats - they'll start
with, and continue to hold, both scroll bars.

Pointer shouldn't flicker when over a frame border whilst other fetches
are progressing now.
@
text
@d461 70
d634 33
d2538 6
d2562 46
@


1.24
log
@This is NOT a 'final' version of anything in particular. I'm checking it
in as I'm about to start playing around with low level window handling
(as part of the thing mentioned at the bottom of this log) - this could
screw things up quite badly if it goes wrong! =8*P

Consequently, I advise you not to check this out over your working sources,
and preferably not to check this out at all.

Markers system - events defined in MiscEvents.h will make Browse remember
where it is on the page. This position can be jumped back to later.
Some builds will have defined keyboard shortcuts Ctrl+Shift+F5 through
F8 to set a marker, and Ctrl+F5 through F8 to jump to a marker.

The front-end for the above now has gadgets 0x80 upwards on the Toolbar or
a set of menus (see Menus.h). Noticed an omission in copy_toolaction_info()
(didn't copy the gadget state) in passing; fixed.

browser_top_line() now works properly, as part of the above, but it'll be
slower than before. If flagged to only find a complete line, it'll do just
that, but whereas before this would require any tables that it looked
inside to be wholly visible, tables can now be partially visible and have
lines inside that are fully visible. This should help the Find function
too. There is a new call, browser_top_line_offset, which works as
browser_top_line but also returns a vertical scroll offset in the found
line (used for more accurate marker position). browser_bottom_line[_r]
turn out to never be used, even by the keyboard control routines, so they
have been removed from Browser.c (rather than spend a lot of time and
effort fixing them).

browser_show_token erroneously subtracted 1 from a particular coordinate
when calculating the y scroll position, which could lead to single pixel
page creep using the markers system. Corrected.

The View Resources button (see Toolbars.h) has been finally implemented,
insofar as it fetches the resources file to the current browser page (or
to a new window if Adjust is used, Controls file settings permitting).

menus_toggle_bars did not take account of the toolbar lower window border
edge correctly. It does now.

The reformatter has a prototype system to keep the vertical page position
when reformatting. This was coded about 5 minutes ago, and is not likely
to be reliable...
@
text
@d2468 1
d2839 1
a2839 1
  unsigned int h = 0;
d2843 3
a2845 1
  while (*s) h += *s++;
@


1.23
log
@Programming warehouse link removed from all hotlists - the page has gone.

Some compile-time hacks in place to use MemLib, a dynamic area based
malloc replacement which shrinks its heap when possible. All builds
have these switched off at the moment. Seemed to work with just Browse,
though there would be problems with message blocks stored in dynamic
areas because of the Wimp's '&3800000' check - however, it failed when
HTMLLib was made to use it, too. Don't know why yet.

ItemInfo.[c/h] source added, with Res file additions for testbed Browse
and Phoenix.

Small fetch windows now work properly regardless of toolbar settings
in the Choices.

Reload now reloads all images too, rather than only reloading them for
as long as the main page was being fetched.

Added a simple 'Find' facility.

Realised that event handlers in eventlib are called in reverse order
of registration, so the miscellaneous event handler is now registered
first rather than last.

Multiuser code added (most only active if SINGLE_USER is undefined). As
part of this, hotlist code now knows about read-only items (done for the
Customer-style 'Resources' file, but works generally anyway).
handle_add_hotlist doesn't try to save the hotlist itself anymore (the
hotlist_add function does all that through hotlist_modified anyway).

Customer build Choices and Controls updated slightly (e.g. ClaimHelp
off, hotlist to save on quit only).

Customer build now uses Phoenix-style buttons. Sprites files which
worked at the time (but will probably be out of date now) and included
most of the original Customer-style sprites are in
'Utils.Icons.Customer'.

Choices, Messages and Res files for all builds now stripped down to only
single user items or single plus multiuser for Customer build and testbed
build. Before, all contained a few multiuser bits in at least the Choices
file if not more.

Grammatical error ("Fetching frames contents" (sic.)) corrected in
default message, Toolbars.c, and all of the Messages files.

Customer build brought back to a servicable level (including
implementation of the Find dialogue box with animation and fixing
up authorisation and 'Stop' state in the tristate). Quite a few
missing #ifndef REMOTE_HOTLIST bits from hotlist code added...

Customer build will not use <Choices$Write> or Boot:Choices for any
file finding now. UseProxy defaults to 'yes', MaxImages to 2. Res
file includes Proxy Address setting (save_save_choices() now writes
the ProxyAddress line).
@
text
@d1975 1
d2105 25
@


1.22
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@a289 2
//    Printf("show_error: errnum 0x%08x, errmess '%s'\n",e->errnum,e->errmess);

a342 2
//    Printf("show_error_cont: errnum 0x%08x, errmess '%s'\n",e->errnum,e->errmess);

a413 2
//    Printf("show_error_ret: errnum 0x%08x, errmess '%s'\n",e->errnum,e->errmess);

d1467 1
@


1.21
log
@Not all resources are up to date in this check-in, and documentation
both within source and stuff in 'Docs' is out of date or missing - I
was very pushed for time on this one... Hopefully will do another
'tidy up' check-in before close on Friday; until then, beware of
anything other than the Ursula (Desktop browser) build. Anyway...

Export As Draw done. As part of this, FONT SIZE and SUP / SUB adjustment
of font size is done in fm_token_font_info rather than fm_find_token_font.

Bullets and switches are plotted as indirected sprite items, rather than
indirected text + sprite items - this relied on being in a redraw loop to
pick the sprites up from the local pool (failed during printing).

URI files now have a LF line ending rather than CR... '*' recognised
as an empty field when loading via. RAM transfer now (only worked for
loading from disc before).

Gave placeholder bounding boxes 4 OS units more minimum extra gap
vertically and reduced horizontal addition to this value * 1.5, rather
than * 2 (see reformat_get_placeholder_size).

Background image tiling starts at ymax - h + 4, rather than ymax, so
there isn't the bottom line of pixels from the top tile always present
at the top of the window. The '+4' is for caution's sake.

Can now save a frame's HTML source, that of its parent or its ancestor,
and the same for the URI pointing to those documents - see Menus.h for
the relevant component IDs that should lead to the SaveFile dialogue.

Have hopefully fixed timeout = 0 values (i.e. 'forever') on things
like LinkTo; before, image fetches could override the state (so you'd
only ever see brief flickers of a given URL as the pointer went over
a link).

Save File dialogue will remember the state of option or radio buttons
for a given parent component origin and restore that state when the
dialogue is next opened from the same place (stops turning on saving
as a URL file also turning on 'save background images' for Draw file
export, etc.).

Use of a META tag to reload the *same* page now sets the 'reloading'
flag in the browser so that it doesn't go through a proxy - otherwise
pages which are meant to update periodically through client pull
don't work, as they keep coming out of the cache.

Can now handle images specifying just a width or height in the HTML
(other dimension is scaled accordingly, but note that the placeholder
size must still be 'dumb' until the image data comes in). An image
will now override an image history size entry for the same entry
with a different size.
@
text
@d2805 22
d3002 134
@


1.20
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d2407 28
@


1.19
log
@Fixed some glitches in the modified status bar code (e.g. status inference
wasn't working properly).

Shift+Toggle size always opened to not obscure the icon bar. If CMOS is
set to always show the icon bar, then Shift+Toggle size is meant to
reverse sense and open to absolute full size. It now does this.

!Run[D] files now require URL 0.22, HTTP 0.64, FTP 0.22, Gopher 0.08
and File 0.32.

Minor overhaul of 'Docs.Notes' (with 'Docs.User' similarly updated) to
include a few new bits and pieces.

Timeout values of 0 now mean 'forever'. Plug-in status messages now have
their own timeout setting. New Messages token 'Actv' for extra info when
a status message times out and the status line drops to 'Viewing' or
'Ready' when there is still a Busy state registered by the Plug-in.

Small Fetch windows don't become visible briefly for Plug-in fetches
when the fetch is complete (for SeeFetches:no, where these windows
should be hidden all the time).

WebServe may be controlled through the Browse front-end via.
Wimp_MAppControl reason code 4 (Wimp_MAppControl_Configure). Note the
renaming internally of 'WebServ' or 'WebServe' has been changed to
'Proxy' (with lower case equivalents where relevant); proxy name
and starting details come from the Messages file 'ProxyName' and
'ProxyComm' tokens. More in 'Docs.Notes'.

Res files updated for image history and PRE/TT font aspect ratio
choices. 'Don't expire' labels changed to 'Expire' (oops, didn't
notice the change in the development Browse's Res file when I
updated all of the others until now...).

When printing, Wimp_PlotIcon appears to ignore R4 and R5, plots
'somewhere' on the page, and tries to get the sprite from the global
pool. This latter part normally causes an error to be raised; though
on my machine I just get a corrupted error message. The Desktop font
gets lost at this point too. All have yet to be fixed; as an
interim work around, Wimp_PlotIcon objects are never drawn at all
if the global 'printing' flag is set.
@
text
@d1404 2
a1405 3
  _kernel_oserror * e;
  int               cwidth, cspacing;
  int               len;
d2309 1
a2309 2
  _kernel_oserror * e;
  ObjectId          o = NULL, a = NULL;
d2656 2
a2657 3
  _kernel_oserror * e;
  unsigned int      handle = 0;
  WimpMessage       msg;
a2691 2
  msg.hdr.sender      = task_handle;
  msg.hdr.my_ref      = 0;
@


1.18
log
@Image history - sizes of images are remembered for future reference (if
the sizes aren't specified in the HTML, they can be looked for in the
image history instead to minimise reformatting requirements). Choices
file options ImageHistoryPath, ImageExpiryAge, ImageMaxSize and
SaveImageHistory added to support this (all have a direct analogy to
the global History items of the same name after removing 'Image').

Text area items are now the correct height for the number of rows
specified in the HTML, don't scroll a line too early, and have the
caret placed at the start of the text when moved into from above
or at the end when moved into from below (rather than always at
the end, which was behaviour inherited from single line writables,
where this is desirable). The top of the text area is aligned to
the top of any line of text on the same line, with the text area
dropping below the text, rather than the bottom of the area matching
the text baseline and extending upwards.

Filename extensions for download files are only stripped if an
attempt to convert to a RISC OS filetype through the Mime Mapper module
does not return an error or Data (0xffd) filetype. '.cgi' is a special
case which is always stripped.

Altered heading styles - all are bold, none are italic, H3 is as big
as H2 was, H2 is a little larger, and others scale down to H6 being
the size as normal text (but, as I say, bold).

Sorted out tables and forms. We can just look for tagno=TAG_FORM, and
get rid of the wobbly form_flag; also discarded the redundant
reprocess_table flag in fetch_preprocess_token. Two separate forms
in consecutive table cells (for example) which used to fail - they
were submitted as one single form - will now work correctly.

Fixed nasty bug in FontManage.c where font size 7 would intermittently
fail. The stupid font sizes that it could ask the Font Manager for may
be responsible for the occasional Font Manager crashes that have been
noticed. Array for font sizes was declared as [Limits_FontSizes], but
indices 1 to Limits_FontSizes are actually used - so needed a '+ 1'
in the declaration... :-/

Replaced the case insensitive string comparison functions in Utils.c
with more efficient versions by S.Brodie.

MAXLENGTH specifier in INPUT tags is now supported. If unspecified or
specifically zero, the browser overrides and allows any length.
@
text
@d2585 1
a2585 1
/* utils_stop_webserv()                          */
d2587 11
a2597 2
/* Stops the WebServ application by sending it   */
/* an AppControl message.                        */
d2600 1
a2600 1
_kernel_oserror * utils_stop_webserv(void)
a2601 1
  WimpMessage       msg;
d2609 1
d2611 1
a2611 3
  int               handle = 0;

  /* First, get WebServ's task handle */
d2637 1
a2637 1
      if (!strcmp(taskname, "Acorn WebServe")) handle = p[0];
d2642 24
d2670 1
a2670 1
      /* Didn't find WebServ, so complain and exit */
d2685 1
a2685 1
      /* Didn't find WebServ, so exit */
d2692 1
a2692 1
  /* If WebServ is present, send the message */
@


1.17
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d2501 13
a2513 2
/* Case insensitive comparison of two given      */
/* strings.                                      */
d2520 1
a2520 1
int utils_strcasecmp(const char * a, const char * b)
d2522 1
a2522 1
  while(*a && *b)
d2524 4
a2527 2
    if (tolower(*a++) != tolower(*b++)) return 1;
  }
d2529 5
a2533 1
  if (!*a && !*b) return 0;
d2535 3
a2537 1
  return 1;
d2543 13
a2555 2
/* Case insensitive comparison of n chars of two */
/* given strings.                                */
d2564 1
a2564 1
  while(*a && *b && n--)
d2566 13
a2578 1
    if (tolower(*a++) != tolower(*b++)) return 1;
@


1.16
log
@Added system font option to choices.
Stopped UNIFONT forcing system font use and added calls to Font_WideFormat.
Made sure the system font option is read before fm_init is called!

User agent string now set if Netscape faking is disabled (format used is
"Acorn Browse/1.26 (RISC OS 3.71)".
@
text
@d77 3
a79 3
#define    Acorn_Agent_Start  "Acorn-"
#define    Acorn_Agent_Middle " (RISC OS "
#define    Acorn_Agent_End    ")"
d2751 1
d2753 3
a2755 2
    while (strchr(tokens, ' '))
      *strchr(tokens, ' ') = '-';
d2762 3
a2764 4
    if (strchr(agent, '('))
      strcat(agent, " ");
    else
      strcat(agent, "/");
d2774 1
d2776 3
a2778 2
    if (strchr(tokens, ' '))
      *strchr(tokens, ' ') = '\0';
@


1.15
log
@Removed 'The Onion' link from some Hotlist files. Time showed that the
site wasn't entirely Family Friendly (TM)... Removed Shift Control (it's
gone offline now), and corrected the Telegraph URL from ...the-telegraph...
to just ...telegraph...

StrongHelp manual generator now tries to work out the number of lines in
the table on the root page more intelligently.

Plug-in support extended to handle Shockwave. Quite a lot of underlying
work for this, including a pseudo cache system for temporary files.

Bug in redraw routines: they plotted background images within table
cells, when nothing should have been drawn. Oops. When background images
in cells are properly supported, this can get sorted out.

Tweaked vertical plot position of HRs (up to 4 OS units too high before due
to rounding).

Various Res file bits and pieces, Ursula build taken up to v1.26 beta
for release on the Browser site. *Note* not all resources are up to date!
This will be done after AW97.
@
text
@d77 7
a83 3
#define Agent_Start  "Mozilla/4.01 (Compatible; Acorn "
#define Agent_Middle "; RISC OS "
#define Agent_End    ")"
d2714 4
a2717 1
/* Parameters: Pointer to a buffer to place the  */
d2726 1
a2726 1
void utils_build_user_agent_string(char * buffer, int buffer_size)
d2732 1
d2742 1
a2742 1
  StrNCpy0(agent, Agent_Start);
d2749 6
d2758 6
a2763 1
    strcat(agent, " ");
d2772 5
d2788 2
a2789 1
  if (strlen(agent) + strlen(Agent_Middle) + 1 < sizeof(agent)) strcat(agent, Agent_Middle);
d2822 2
a2823 1
  if (strlen(agent) + strlen(Agent_End) + 1 < sizeof(agent)) strcat(agent, Agent_End);
@


1.14
log
@fetch_get_raw_data will notice if up->fetching is zero and return a
'finished' status rather than trying to continue reading data for the
fetch. Fetches should never fall through that far but at least it
will cope if they do.

3D table borders are now supported. 2D borders are used if the
inter-cell spacing is too small to fit the borders in (display resolution
dependent) - the external table border is 2D if the internal borders are,
else 3D. For cellspacing of 0, internal table borders must plot over the
outer edge of pixels inside the cell; for all greater spacings, the
borders take up all or part of the gap between them. The external border
will always fit around the outside of the cells, including the
cellspacing value in the gap between the outer cells and the border.

Anti-alias colour for placeholder ALT text was incorrect. Fixed.

I'd changed 'point' to 'points' in some of the Font Choices dialogues;
now changed back to 'point'.

The routine to find out how large an otherwise unsized object or image
placeholder based on its ALT text has been centralised in Reformat.c,
so that the image and object routines can both access it without
code duplication (this means non-image objects will now have the correct
size if they contain ALT text, rather than assuming a standard default
size as before). ALT text in images that were also objects was never
plotted either, though the placeholder size would have been correct.
This has been fixed.
@
text
@a941 3
#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))

d945 3
@


1.13
log
@Weird - the line registering the ENavigateToBeShown event disappeared from
Main.c, so the last log was incorrect; Navigate menu items wouldn't have
been greyed out. Probably a(nother?) CVS update screw up on my part; now
fixed. This sort of thing is happening far too often...

Font manager would crash in system font or if a font face was not found
in the previous release - that hacky business of returning weird font
handles when system font is to be used instead ensured a rather less than
valid array reference on behalf of fm_claim_basic_typefaces.

Added in a few more calls to the 'check the button bar' routines, to
ensure that things like Stop are greyed/ungreyed when needed.

Cellpadding code could lead to rmarg overlapping lmarg, or the sum
being greater than dwidth, or something like that (!) in the reformatter.
Anyway the results were unpleasant; this has been sorted out by range
checking right and left margins w.r.t. display width in the relevant
section of the code.

People who specify 'td width = 2000' in tables expecting to get something
sensible now do, though I was half inclined to leave it alone... I can
only assume that they don't know about % specification or it didn't
work in their browser at authorship time, and the huge width served as
an attempt to get the table to fill the available window width. Anyway,
the table reformatter spots when the maximum width a cell requires is
less than half of what it asks for, and ignores the width specifier if
this is the case.
@
text
@d56 1
d77 1
a77 1
#define Agent_Start  "Mozilla/2.0 (compatible; Acorn "
d85 1
a85 1
static int  millipoints_per_os_unit_x = 400;
d286 1
a286 1
    Printf("show_error: errnum 0x%08x, errmess '%s'\n",e->errnum,e->errmess);
d341 1
a341 1
    Printf("show_error_cont: errnum 0x%08x, errmess '%s'\n",e->errnum,e->errmess);
d360 2
a361 2
      StrNCpy0(name,lookup_token("_TaskName:Browse",0,0));
      StrNCpy0(spri,lookup_token("_SpriName:!browse",0,0));
d384 3
a386 2
      if (r.r[1] != 1) exit(EXIT_FAILURE); /* Exit if 'Quit' is selected  */
      else longjmp(env,1);                 /* Else jump back to poll loop */
d414 1
a414 1
    Printf("show_error_ret: errnum 0x%08x, errmess '%s'\n",e->errnum,e->errmess);
@


1.12
log
@Sorted out Res files, including fixing position of 'bytes' label in one
of the Choices dialogues (I'd missed it out of a selection when everything
else got moved down a bit). Unfaded Enc_Chinese menu entries, made sure
text labels were wide enough for system font, changed 'Apply' on Choices
dialogue to 'Set', and added ^K to hotlist keyboard shortcut lists.
Print Setup (i.e. Print dialogue) buttons all set to 'local', so the
stupid Toolbox doesn't close the dialogue and lose the caret before I
can see if it was in there to start with...

256 colour hotlist sprites taken back to standard 16 colour versions,
since there's a significant speed penalty on slower machines. The
testbed browser still has the 256 colour versions so the designs aren't
completely lost.

Changed access settings to exported builds to wr/r - lr/r was really getting
on my nerves whenever I wanted to try something temporary out.

View source, save source and print handlers would all try to work if
there was no source to act on - despite the fact that toolbar buttons
would be greyed out form them. This is fixed.

The Navigate menu has components greyed to match the toolbar state,
when opened. It isn't kept up to date dynamically, though this shouldn't
really be a problem (reopen the submenu...). As part of this, finally
sorted out conditions for the Stop button to be greyed, or the
GoTo/Go/Stop tristate to be at 'Stop' versus 'GoTo'.

Deferred reformatting is now disabled for external image fetches.

Browser-local client pull flag removed; hitting the Stop button simply
cancels any null handlers working for it. That way, client pull switches
back on in passing at the next fetch (it was never really switched off).
So to stop client pull, hit the stop button at any point.

Done CELLPADDING attribute; cellpadding field in reformat_cell (Global.h)
is redundant since the table token is accessible from there, and so it has
been removed. CELLSPACING support also added.
@
text
@d267 2
a268 1
/* Reports an error and exits with EXIT_FAILURE  */
d285 2
d322 2
a323 1
/* wherever the setjmp was (e.g. in a poll loop) */
d340 2
d411 2
@


1.11
log
@Version in Messages taken to 1.22 (03 Oct).

Updated Res files in appropriate builds to hold various (similar) Choices
designs.

Choices related menus were flagged as Shared, but none of the dialogues
(including ColourDBox) were - potential future problems, though shouldn't
cause any leaks at present. This has been sorted out anyway.

Encoding function encoding_init no longer returns an error from
toolbox_create_object, so the Encoding menu and all those attached
to it do not have to be present (e.g. the Customer build).

SUB, SUP, STRIKE and U supported. U underlines the baseline of the body text
font, whilst STRIKE will go through roughly the middle of the lower case
chars even if the font is SUP or SUB. Note that Navigator appears to shift
the underline point for SUB and SUP; it may be necessary to copy this
behaviour, but testing on real sites must proceed before that. There could
also be a problem with the automatic lowering of font size, which Navigator
doesn't do, so any FONT SIZE = -n commands could make it too small. Again,
this needs testing on real sites.

'http://' is added to URLs with no protocol specified, unless they start with
'ftp.', in which case the new behaviour is to add 'ftp://'.

Choices code altered to do less error checking on components! They should be
able to be missing without raising errors. Referencing of the subwindow
array changed from *(subwindows + number) to subwindows[number].

Made trace_tag_name code look pretty...

reformat_useless_token now checks tagno is non-zero.

User Agent string setting now done through URL_GetURL, on a per-session
basis.

Ellipsis character removed from all Messages files, replaced with '...'.
There's little difference between the two in an outline font, and in System
font the latter looks much better. Smart quotes left in, as they look
better in all cases.
@
text
@d1824 113
@


1.10
log
@Support for ANT URL broadcast message added.

Image deletion routines rewritten; nasty animated GIF bug now gone
(it kept trying to update the cross-referenced image in the browser that
no longer existed, and I've no idea how animated GIFs ever managed to *not*
blow up if a cross referencing browser was shut down; and I've tested
this...). There are now as many image structures as there are total images
in the visible browsers, and no more; cross referenced images in the
to-be-deleted browser have their ownership moved to the cross
referencer before the cross referencee is wiped, with any required fetches
being transferred with them.

Reformatter sped up a bit by getting rid of strlen on the main text field
of tokens in all places bar one, where it is called extremely rarely. This
means direct app-to-app transfer of, say, a 359K text file to the browser
won't run like a drain as it tries to do strlen on a 359K string over and
over again! Most of the time the performance benefits won't really be
noticable, but on the above text file, formatting time went down from
290 seconds before the change to just under 7 seconds, a 41 fold speed
increase or thereabouts (SA110 228MHz).

MakeFile changed to force function name compilation on for debug builds
(-fn in the DD...FLAGS); useful for certain functions such as
register_null_handler, which can now output the name of the function
being registered.

...Which helped show up some nasties in the animation handler and animation
drift handler registration/deregistration process, which have been fixed
(callers of fetchpage_release_nulls were unaware that the drift handler
could be installed, and fragments of old code checking choices.anim_drift
had a value other than 1 or 0 were still hanging around - bit tricky for
a single bit item).

Added support for VALIGN in table cells. Spotted a bug or two in the
'what token is the pointer over' routines as a result, and fixed them - the
worst was in browser_line_at_y, which checked the y coordinate was below
the given one [the mouse], but didn't check the line height to see if the
given y coordinate was *within* the line, rather than just above it. Never
used to matter pre-tables, but a definite concern once multiple line
arrays can exist on one page.
@
text
@d2582 1
a2582 1
/* utils_set_http_agent()                        */
d2584 2
a2585 3
/* Works out an appropriate HTTP agent string    */
/* and attempts to tell the HTTP module to use   */
/* this in the header for the given fetch.       */
d2587 2
a2588 2
/* If HTTP is not present, the routine will fail */
/* silently.                                     */
d2590 4
a2593 3
/* Parameters: Flags (currently always 0);       */
/*                                               */
/*             Session handle for the fetch.     */
d2596 1
a2596 1
_kernel_oserror * utils_set_http_agent(int flags, unsigned int session)
d2603 4
d2653 1
a2653 1
  if (e) return e;
d2664 1
a2664 1
  if (e) return e;
d2676 1
a2676 5
  /* Set the agent string, ignoring errors (as, say, the HTTP */
  /* module may not be present at all)                        */

  _swix(HTTP_UserAgent,
        _INR(0,2),
d2678 2
a2679 3
        flags,
        session,
        agent);
d2683 1
a2683 1
  return NULL;
@


1.9
log
@File fetches now set DEADDEAD during the fetch, Data if it is aborted, or
an appropriate filetype when finished. If the fetcher routines return a
zero or data filetype, the browser looks at a set of hard coded filename
extensions to try and determine if there's a better filetype to use
(urlutils_filetype_from_url) - since this is a centralised routine it can
use a Mime mapping system (or be removed entirely) as and when one becomes
available.

You can now drag URI / URL files to the Hotlist window to add them to the
list. They are added roughly where dragged to. (NB, note that I renamed
the function to return the window ID - just being picky; it matches other
similar functions now). Oh, and hotlist_add_position actually works now ;-)

The global history will save when titles are added, as well as when a URL
is added. Before, a browser crash could mean a title got dropped out
of the history file even if SaveHistory was set to 'always'.

SaveObject sources have been added but nothing references them or links
them in yet - they're not finished. Mostly checking this one in because
of the hotlist changes.
@
text
@d822 22
a843 1
    if (tl & (1u<<2)) Printf("register_null_claimant: Registered a claimant\n");
d855 1
a855 1
      if (tl & (1u<<2)) Printf("register_null_claimant: Nulls claimed\n");
d875 12
a886 1
    if (tl & (1u<<2)) Printf("deregister_null_claimant: Deregistered a claimant\n");
d888 8
a895 5
    if (null_counter < 0)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess, "deregister_null_claimant: Counter is negative; deregistrations have not matched registrations");
      show_error_ret(&erb);
d910 1
a910 1
      if (tl & (1u<<2)) Printf("deregister_null_claimant: Nulls released\n");
d2586 1
a2586 1
/* this in headers for fetches.                  */
d2590 4
d2596 1
a2596 1
_kernel_oserror * utils_set_http_agent(void)
d2625 8
d2676 1
a2676 1
        _IN(0),
d2678 2
@


1.8
log
@This version is being checked in because the Hotlist manager in the test
build provokes a Wimp bug. All the variant resource files are out of sync
and there are several outstanding bugs in the main code, so I'd personally
avoid this build like the plague unless you're mad enough to want to
examine the Wimp problem ;-)
@
text
@d76 3
a78 3
#define AGENT_START  "Mozilla/2.0 (compatible; Acorn "
#define AGENT_MIDDLE "; RISC OS "
#define AGENT_END    ")"
a83 5
const static char * base64_table="ABCDEFGHIJKLMNOP"
                                 "QRSTUVWXYZabcdef"
                                 "ghijklmnopqrstuv"
                                 "wxyz0123456789+/";

d2297 8
a2304 4
  char          * out_ptr = out;
  int             i;
  unsigned long   chunk;
  int             p = 0;
d2568 1
a2568 1
  StrNCpy0(agent, AGENT_START);
d2590 1
a2590 1
  if (strlen(agent) + strlen(AGENT_MIDDLE) + 1 < sizeof(agent)) strcat(agent, AGENT_MIDDLE);
d2623 1
a2623 1
  if (strlen(agent) + strlen(AGENT_END) + 1 < sizeof(agent)) strcat(agent, AGENT_END);
@


1.7
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d58 1
d1410 4
a1413 3
    /* Set the width - the width of a char plus the gap between */
    /* it and the next one. There are obviously 'len' chars and */
    /* 'len - 1' gaps.                                          */
d1415 1
a1415 1
    *width = len * cwidth + (len - 1) * cspacing;
d2154 1
a2154 1
  ObjectId          o;
d2165 35
@


1.6
log
@Very long log entry alert - but hey, beats 'Bug fixed' (sorry, Richard) ;-)

Open URL implementation more or less complete, though may undergo UI
revision at a later date to allow named frames to be targetted. Hope to use
the ideas in this code as the foundation for other general dialogues.

In token stream dump for TRACE builds, table head items were not indented
as far as they should have been - this is fixed; and manual toolbar redraw
routines have been removed. They never worked, were commented out, and
would never be used in that form anyway.

DragBox source added, but it isn't at all complete and won't work - this is
an 'in spare time' thing. We need custom drag boxes constrained to windows
for the hotlist, and unconstrained for frame border resizing... Hey ho.

Ancestor window extents match visible areas if there are frames (no more
scrolling framesets...!). Frame resizing works whilst new documents fetch
without pulling the extent down now. However, frame horizontal extents
never shrink until a reload which is nasty, and this is all due for a
rewrite. Frames border redrawing routine moved out of Redraw.c and into
Frames.c. Bug regarding the mouse rectangle and frame border widths
(rectangle was too large, so you could squash the edges) for edge-drag
frame resizes fixed.

Window width change reformat tolerance fixed; you could creep the window
width down or up forever without any reformat, and centred objects would
move but not be redrawn (thereby giving rise to subsequent redraw errors).

Filetype on objects saved through Shift+Click correct. Save Source dialogue
recognises if that source is plain text, rather than assuming HTML. A
browser that fetches a file remembers the old store size it had before the
save, so even though the data is now ditched, it reports the same amount of
data fetched afterwards (looked awful when this could, for example,
suddenly say '0' after a file save). Progress indicator is now fully aware
of one or many file saves inside a frameset and reports the number of
saves, a colon, and the cumulative saved data count, instead of reporting
the sum total of fetched data in all frames, including non-file save stuff
(note that for just 1 save, '1:' is not shown as a special case for the
most common condition). A bug related to this, where you could in fact only
do one fetch per frame*set*, has been corrected (only one fetch allowed per
frame still, this is unlikely to ever change).

Hotlist support added (D.Brown's source), with various bits of integration
and modification still in progress there. Note additions to the Messages
files. On the subject of Messages, the whole mucky business about what
goes in Messages or Choices (and a few bugs where lookup_choice was used
instead of lookup_token or vice versa) has been sorted out. Messages
contains, more or less, just that. Choices contains user configurable
stuff which generally can't mess things up too badly. A new file, Controls,
is a Messages file holding the non-user configurable choices, which can
generally make things go badly wrong if misused. A lot of these are tied
to the Res file. StrongED users can get these to automatically fold out
the various sections (EMail me for details). Sorry, but at the time of
writing, Zap doesn't do folding... =8*P

Two bugs with images. Asking for images to be shown in browser B when
browser A uses the same ones and was loaded first didn't work correctly,
and now does (a bit weird - browser A does the fetch and browser B does the
display...). Second one occurred when the background image was also used on
the page as a foreground image. This has been fixed by flagging background
images in the image_info structure, and checking this before cross
referencing. This bit also allowed the image_restart_fetches API to be
extended, so that just background or foreground images may be fetched if
they weren't already and the user asked the browser to show them. Before,
the whole lot had to be fetched together (so turning on 'display
backgrounds' will now kick off an image fetch if required, you don't
need to reload the page anymore).

Makefile copy options tweaked to be 'newer' (so if you're testing with some
temporary Choices file or something, it won't write over it at the end of
every export), and REMOTE_HOTLIST flag added for Customer builds - means
the Hotlist.c functions aren't needed; the old, hotlist-by-file method is
used. Added support for Customer build (see later), though there were very
few additions needed in practice.

Table printing fixed - in many ways it wasn't broken, it was image printing
causing the oddities ever since the global image pool was introduced (this
is, again, fixed). The 'reformat to fit page' option didn't work as coded
any more; tables store cell addresses in the HStreams, so you can't then do
a background reformat in a different browser. Hence, it now has to reformat
to the page width, print, then put the page back again, all in the actual
displayed browser. This doesn't feel as slow in use as it perhaps should,
considering what is going on... Note that a line of a defined fraction (see
Print.h) of page height will now split over page boundaries, so tall images
or tall tables don't cause problems now (aside from the obvious problem of
having the line split over a page at all!). There was a bug in the routine
to print from a given start point until 'n' pages had been filled, in that
it always filled 'n + 1' - now fixed. Finally, as part of the printing
tweaks, a new dialogue exists - PrintStyle - with a similarly named source
file added to deal with it.

Global history auto save / load done, but only to the Choices file path -
the whole browser is still strictly single user at present, with all the
extra work for a multiuser Customer environment yet to be done. This has
shown up a global history corruption problem which I haven't fixed yet.

Rationalising TBEvents.h - things are migrating out of it, and into more
appropriate sources (e.g. definitions relating to the Open URL dialogue are
going into OpenURL.h, etc.). Event codes were at one stage deliberately
diverged in numberspace from the component IDs of typical gadgets raising
the events, to avoid anyone getting confused and thinking the IDs and event
codes must match. However, this is in fact unlikely and it is much easier
to remember the fewer numbers that result from tying the two together where
possible. This has resulted in changes to event codes raised in the
following objects of all Res files: Authorise, Find, OpenURL, and
PrintStyle.

And finally - !Run[D] files for all variants updated to require the latest
toolbox and fetcher modules. All Res files updated for hotlists etc. and
sprites files updated appropriately. All Messages, Choices and Controls
files brought in sync., and an Customer build has been added (based on the
Desktop build binary with different resources).

That's all for now...
@
text
@d57 1
d485 1
a485 1
void make_no_fetch_memory_error(int stage)
d497 2
d514 1
a514 1
void make_no_cont_memory_error(int stage)
d526 2
d544 1
a544 1
void make_no_table_memory_error(int stage)
d556 2
d573 1
a573 1
void make_no_memory_error(int stage)
d585 2
d1331 91
d2131 47
d2600 48
@


1.5
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@d94 4
a131 2
  _kernel_oserror * e;

d133 1
a133 1
    if (tl & (1u<<0)) Printf("lookup_token: Lookup token '%s'\n",s);
d136 2
a137 5
  if (strcmp(lasttokn, s))
  {
    #ifdef TRACE
      if (tl & (1u<<0)) Printf("lookup_token: Proceeding\n");
    #endif
d139 13
a151 1
    StrNCpy0(lasttokn, s);
d153 5
a157 2
    e = _swix(MessageTrans_Lookup,
              _INR(0,7),
d159 2
a160 8
              &meb,               /* Pointer to control block               */
              s,                  /* String to look up                      */
              tokens,             /* Global buffer to take looked up string */
              sizeof(tokens) - 1, /* Size of the buffer                     */
              arg,                /* Parameter 0                            */
              0,                  /* Parameter 1                            */
              0,                  /* Parameter 2                            */
              0);                 /* Parameter 3                            */
d162 13
a174 17
    tokens[Limits_Message - 1] = 0;

    if (e)
    {
      /* If the lookup fails, put '!' into the lookup buffer and if the */
      /* flag passed into the function is 1, report the error too.      */

      #ifdef TRACE
        if (tl & (1u<<0)) Printf("lookup_token: Failed\n");
      #endif

      *lasttokn = 0;
      strcpy(tokens, "!");

      if (flag == 1) show_error_cont(e);
    }
  }
d176 2
d179 1
a179 1
    if (tl & (1u<<0)) Printf("lookup_token: Returning %s\n",tokens);
d182 1
a182 1
  return (char *) &tokens;
d186 5
a190 1
/* lookup_choice()                               */
d192 3
a194 3
/* As lookup_token, but looks up the token in    */
/* the Choices file, rather than the Messages    */
/* file.                                         */
d196 1
a196 1
/* Parameters: Pointer to a message token;       */
d214 1
a214 1
char * lookup_choice(char * s, int flag, char * arg)
d219 1
a219 1
    if (tl & (1u<<0)) Printf("lookup_choice: Lookup token '%s'\n",s);
d222 1
a222 1
  if (strcmp(lasttokn, s) != 0)
d225 1
a225 1
      if (tl & (1u<<0)) Printf("lookup_choice: Proceeding\n");
d233 1
a233 1
              chb,                /* Pointer to control block               */
d250 1
a250 1
        if (tl & (1u<<0)) Printf("lookup_choice: Failed\n");
d261 1
a261 1
    if (tl & (1u<<0)) Printf("lookup_choice: Returning %s\n",tokens);
d2296 5
a2300 4
/* This is unlikely to be faster than fairly     */
/* simple maths, so if it is possible to work    */
/* out how long things will be by such methods   */
/* it will be more efficient to do so.           */
d2323 36
@


1.4
log
@Checking in mostly because its Friday... Quite a few little bug fixes
(adding up to a greater whole), which include removal of the dastardly
'invalid image number' errors that trace builds would raise from time to
time. Frame highlights are now better controlled (releaseably so).
Generally, this build represents the first genuinely promising version
of the browser for quite some time, despite the known library problems
with comment handling etc.
@
text
@d15 9
a23 6
/*************************************************/
/* File   : Utils.c                              */
/* Purpose: Infrequently altered utilities       */
/* Author : A.D.Hodgkinson                       */
/* History: 18-Oct-96: Created                   */
/*************************************************/
d109 1
d113 1
d145 10
a154 8
              &meb,          /* Pointer to control block               */
              s,             /* String to look up                      */
              tokens,        /* Global buffer to take looked up string */
              MaxMsgLen - 1, /* Size of the buffer                     */
              arg,           /* Parameter 0                            */
              0,             /* Parameter 1                            */
              0,             /* Parameter 2                            */
              0);            /* Parameter 3                            */
d182 3
a184 3
/* As lookup_token() above, but looks up the     */
/* token in the Choices file, rather than the    */
/* Messages file.                                */
d187 1
d191 1
d223 10
a232 8
              chb,           /* Pointer to control block               */
              s,             /* String to look up                      */
              tokens,        /* Global buffer to take looked up string */
              MaxMsgLen - 1, /* Size of the buffer                     */
              arg,           /* Parameter 0                            */
              0,             /* Parameter 1                            */
              0,             /* Parameter 2                            */
              0);            /* Parameter 3                            */
d262 2
a263 2
/* Parameters:                                   */
/*    a pointer to a _kernel_oserror structure   */
d265 1
a265 2
/* Assumptions:                                  */
/*    none (so the pointer may be NULL)          */
d273 2
a274 2
    char             name[64];
    char             spri[13];
d314 2
a315 2
/* Parameters:                                   */
/*    a pointer to a _kernel_oserror structure   */
d317 1
a317 2
/* Assumptions:                                  */
/*    none (so the pointer may be NULL)          */
d325 2
a326 2
    char             name[64];
    char             spri[13];
d337 1
a337 1
    /* This all works in much the same way as show_error() above. */
d384 2
a385 2
/* Parameters:                                   */
/*    a pointer to a _kernel_oserror structure   */
d387 1
a387 2
/* Assumptions:                                  */
/*    none (so the pointer may be NULL)          */
d395 2
a396 2
    char             name[64];
    char             spri[13];
d407 1
a407 1
    /* This all works in much the same way as show_error() above. */
d576 6
a581 6
/* Parameters:                                   */
/*    An ID of any Toolbox object that will      */
/*    return it's Wimp window handle when        */
/*    Toolbox_ObjectMiscOp is called for it with */
/*    a reason code of 0 - e.g. Window, DCS,     */
/*    Colour dialogue.                           */
d583 1
a583 2
/* Assumptions:                                  */
/*    that the ID is a valid one                 */
d660 8
a667 8
/* Parameters: f contains flags to pass to the   */
/*             Toolbox in the set extent call    */
/*             o is the object ID of the browser */
/*             window to alter                   */
/*             w is a pointer to a BBox with the */
/*             extent coordinates in it          */
/* Returns:    Pointer to a _kernel_oserror or   */
/*             NULL, if there is no error        */
d688 6
a693 5
/* Parameters: int w is the handle of the window */
/*             in question                       */
/* Returns:    the handle of the first non-pane  */
/*             window in front of int w, or -1   */
/*             if it is at the top of the stack. */
d727 1
d731 1
d797 2
a798 2
/* Parameters: Exactly as for a Wimp event       */
/*             handler but without the object Id */
d829 2
a830 2
/* Parameters: Exactly as for a Wimp event       */
/*             handler but without the object Id */
d874 1
d1044 1
d1046 1
d1050 1
d1074 1
d1076 1
d1080 1
d1098 1
a1098 1
              "convert_pair_to_points(): Can't convert (%d, %d) to millipoints without overflow.",
d1117 2
a1118 2
/* As convert_pair_to_os() (above), but only     */
/* converts one coordinate at a time.            */
d1121 1
d1143 2
a1144 2
/* As convert_pair_to_points() (above), but only */
/* converts one coordinate at a time.            */
d1147 1
d1187 2
a1188 2
/* As convert_pair_to_os() (above), but converts */
/* the four coordinates inside a BBox in one go. */
d1192 1
d1214 2
a1215 3
/* As convert_pair_to_points() (above), but      */
/* converts the four coordinates inside a BBox   */
/* in one go.                                    */
d1219 1
d1272 1
d1275 1
a1278 2
/* Returns:    See Parameters list.              */
/*                                               */
d1319 1
d1493 1
a1493 2
/* Shows a given gadget hidden by hide_gadget()  */
/* above.                                        */
d1527 1
a1527 1
/* out with hide_gadget() or is still visible.   */
d1697 1
d1699 1
d1702 1
d1709 3
a1711 1
  char              ident[2048], help[MaxHelpLen];
a1713 1
  unsigned int      flags;
d2024 3
a2026 1
/* in the list of known structures.              */
d2075 1
d2201 1
a2201 1
  char              taskname[128];
d2280 37
d2330 1
a2330 1
  char              agent[1024];
a2406 2

/*************************************************/
@


1.3
log
@In the middle of customer support work.
@
text
@d2032 22
@


1.2
log
@Supported client pull, through a generalised handing of the META tag.
@
text
@d69 5
a73 1
/* Constant definitions */
d2095 23
d2120 2
a2121 2
/* Case insensitive comparisson of n chars of    */
/* two given strings.                            */
d2123 1
a2123 1
/* Parameters: As strncmp                        */
d2125 1
a2125 1
/* Returns:    As strncmp                        */
d2228 92
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d28 1
d87 1
a87 1
/***************************+*********************/
d168 1
a168 1
/***************************+*********************/
d1415 1
a1415 1
/***************************+*********************/
d1431 1
a1431 1
/***************************+*********************/
d1465 1
a1465 1
/***************************+*********************/
d1499 1
a1499 1
/***************************+*********************/
d1509 1
a1509 1
/***************************+*********************/
d1528 1
a1528 1
/***************************+*********************/
d1585 1
a1585 1
/***************************+*********************/
d1593 1
a1593 1
/***************************+*********************/
d1621 1
a1621 1
/***************************+*********************/
d1629 1
a1629 1
/***************************+*********************/
d1657 1
a1657 1
/***************************+*********************/
d1960 1
a1960 1
/***************************+*********************/
d1969 1
a1969 1
/***************************+*********************/
d1992 1
a1992 1
/***************************+*********************/
d2027 1
a2027 1
/***************************+*********************/
d2051 1
a2051 1
/***************************+*********************/
d2090 22
a2111 1
/***************************+*********************/
@

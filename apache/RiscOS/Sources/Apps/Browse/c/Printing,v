head	1.23;
access;
symbols
	Browse-2_16:1.23
	Browse-2_15:1.23
	Browse-2_14:1.23
	Browse-2_13:1.23
	Browse-2_12:1.22
	Browse-2_11:1.21
	Browse-2_10:1.21
	Browse-2_09:1.21
	ahodgkin_208_i4_2:1.20
	ahodgkin_208_i4:1.18
	ahodgkin_208_i3:1.17
	ahodgkin_208_i2:1.16
	ahodgkin_208_i1:1.15
	ahodgkin_207release:1.14
	ahodgkin_206release:1.14
	ahodgkin_205release:1.13
	ahodgkin_204release:1.13
	ahodgkin_202release:1.13
	ahodgkin_201release:1.13
	ahodgkin_200release:1.13
	ahodgkin_133beta:1.13
	ahodgkin_132beta:1.13
	ahodgkin_131beta:1.13
	ahodgkin_130beta:1.13
	ahodgkin_129:1.13
	ahodgkin_128beta:1.12
	ahodgkin_128alpha:1.12
	ahodgkin_127beta2:1.12
	ahodgkin_127beta:1.12
	ahodgkin_126beta:1.12
	ahodgkin_AW97patch:1.12
	ahodgkin_AW97:1.11;
locks; strict;
comment	@# @;


1.23
date	2006.03.16.12.26.52;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.26.09.42.34;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.14.08.45.07;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.31.15.58.43;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.03.09.20.04;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.01.08.45.34;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.25.17.08.53;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	99.03.30.15.51.57;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	98.07.09.10.27.19;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.12.12.11.18.00;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.10.18.16.42.28;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.10.16.13.23.17;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.09.24.11.14.20;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.09.22.11.51.14;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.09.22.07.43.21;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.09.12.17.19.29;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.09.09.14.13.18;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.08.31.18.38.20;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.08.28.16.08.04;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.08.18.09.24.02;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.08.12.09.26.37;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.28.53;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.23
log
@  Couple of bug fixes.
Detail:
  Triangular line end caps in Draw files now drawn in line colour. Header
  and footer special fields much more reliable; date formats better
  handled; "!!" and "!%" should work properly in both.
Admin:
  Tested fairly heavily, works as expected. This release does not address
  the crash Steve R has seen with images on the BBC news site, since I've
  not yet been able to reproduce it.

Version 2.13. Tagged as 'Browse-2_13'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File   : Printing.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Printing functions for the browser.               */
/*                                                            */
/*          This source is fairly closely tied to             */
/*          PrintStyle.c, as the Print dialogue can open and  */
/*          close the Print Style dialogue.                   */
/*                                                            */
/* Author : A.D.Hodgkinson                                    */
/*                                                            */
/* History: 27-Jan-1997 (ADH): Created.                       */
/*          25-Aug-1997 (ADH): Overhaul (read rewrite) to the */
/*                             new dialogue handling model,   */
/*                             as for Open URL and so-on.     */
/*          24-Feb-2000 (ADH): Headers and footers nearly     */
/*                             done, 64-wide comments with    */
/*                             Pace (C) started.              */
/*          24-May-2000 (ADH): 64-wide comments finished.     */
/**************************************************************/

#include <signal.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/printdbox.h>

#include "Global.h"
#include "FromROSLib.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "FontManage.h"
#include "Images.h"
#include "Markers.h"
#include "Memory.h"
#include "Protocols.h"
#include "PrintStyle.h"
#include "Redraw.h"
#include "RedrawCore.h"
#include "Reformat.h"
#include "SaveFile.h"
#include "SavePDF.h"
#include "Scale.h"
#include "Toolaction.h"
#include "Toolbars.h"
#include "Windows.h"

#include "Printing.h"

/* Local structures.                                           */
/*                                                             */
/* Holds info on the Print dialogue's contents; small enough   */
/* to hold as a static, as the code to dynamically allocate it */
/* would occupy more room than the structure itself.           */

#define End_Whole   0
#define End_Visible 1
#define End_Many    2

typedef struct
{
  int            copies;          /* Number of copies to print.                                                  */
  int            pages;           /* If 'end' is 2, the number of pages to fill.                                 */
  unsigned int   end          :2; /* 0 = whole page, 1 = to bottom of visible area, 2 = for 'pages' pages.       */
  unsigned int   start        :1; /* 1 = whole page, 0 = top of visible area.                                    */
  unsigned int   reformat     :1; /* 1 = reformat to fit page (if start is not 0 and end is not -1), else don't. */
  unsigned int   print_to_pdf :1; /* 1 = print to PDF file instead of paper, 0 = print normally.                 */
  unsigned int   orientation  :1; /* 1 = portrait, 0 = landscape.                                                */

} print_contents;

/* The following stores the four basic display type settings */
/* (underline links, show images etc.) for the browser to be */
/* printed. This is so that the settings may be restored     */
/* after a print.                                            */

typedef struct
{
  unsigned int underline_links :1;
  unsigned int use_source_cols :1;
  unsigned int show_foreground :1;
  unsigned int show_background :1;

} print_restorable;

/* Local variables */

static int              globaljob        = 0;
static int              globalold_job    = 0;

static int              defaults_set     = 0;

static ObjectId         self_id          = 0;
static ObjectId         window_id        = 0;
static ObjectId         ancestor_id      = 0;
static browser_data   * ancestor_browser = NULL;

static print_contents   contents;
static print_restorable restore;

/* Static function prototypes */

static _kernel_oserror * print_read_contents           (ObjectId dialogue, print_contents * contents);
static _kernel_oserror * print_set_contents            (ObjectId dialogue, print_contents * contents);

static int               print_start                   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               print_cancel                  (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static int               print_check_contents          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static _kernel_oserror * print_page                    (browser_data * b, int copies, int from, int end, int to, int reformat, int orientation, const char * path);

static void              print_prepare_browser         (browser_data * source, browser_data * store, int lmarg, int rmarg, int tmarg, int bmarg);
static void              print_restore_browser         (browser_data * original, browser_data * copy);
static _kernel_oserror * print_reformat_for_printing   (browser_data * b, int from);
static _kernel_oserror * print_reformat_to_restore     (browser_data * b, int from);
static _kernel_oserror * print_find_window_edges       (browser_data * b, int from, int * r_top, int * r_bottom);
static _kernel_oserror * print_declare_fonts           (void);

static char            * print_roman                   (char * temp, unsigned int value, int isupper);
static char            * print_alpha                   (char * temp, unsigned int value, int isupper);
static char            * print_date                    (const char * source, char * buffer, unsigned int buflen);
static char            * print_build_formatted         (browser_data * b, unsigned int pages, unsigned int page, const char * section, char * buffer, size_t buflen, const char * format);
static void              print_header_and_footer_sizes (browser_data * b, unsigned int pages, unsigned int page, const char * section, int * header, int * footer);
static _kernel_oserror * print_header                  (browser_data * b, unsigned int pages, unsigned int page, const char * section, int header_y, int width);
static _kernel_oserror * print_footer                  (browser_data * b, unsigned int pages, unsigned int page, const char * section, int footer_y, int width);

static unsigned int      print_count_pages             (browser_data * b, int end, int to, int lmarg, int rmarg, int tmarg, int bmarg, int top, int bottom);

static unsigned int      print_set_hourglass_by_area   (BBox * redraw_rect, BBox * last_rect, unsigned int pages, unsigned int page, unsigned int page_area, unsigned int completed_area);

/**************************************************************/
/* print_open_for()                                           */
/*                                                            */
/* Creates and opens a Print dialogue for a given browser,    */
/* opening near the pointer.                                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which is the  */
/*             ancestor of the dialogue;                      */
/*                                                            */
/*             Object ID to use as a parent, or 0 for none.   */
/**************************************************************/

_kernel_oserror * print_open_for(browser_data * b, ObjectId parent)
{
  ObjectId id;

  /* Create the object - if it is already created, this will */
  /* just return the ID of the existing object.              */

  RetError(toolbox_create_object(0,
                                 "PrintDbox",
                                 &id));

  RetError(toolbox_show_object(0,
                               id,
                               Toolbox_ShowObject_Centre,
                               NULL,
                               parent,
                               -1));

  return NULL;
}

/**************************************************************/
/* print_read_contents()                                      */
/*                                                            */
/* Reads the contents of the Print dialogue into a            */
/* print_contents structure.                                  */
/*                                                            */
/* Parameters: Object ID of the dialogue;                     */
/*                                                            */
/*             Pointer to the structure to write to.          */
/**************************************************************/

static _kernel_oserror * print_read_contents(ObjectId dialogue, print_contents * contents)
{
  int state, selected;

  /* Start at top of visible area (0) or whole page (1) radios */

  RetError(radiobutton_get_state(0, dialogue, PStartWhole, &state, NULL));
  contents->start = !!state;

  /* End radios - bottom of page, of visible area, or stop after */
  /* pages defined in the 'PEndManyNum' number range gadget      */

  RetError(radiobutton_get_state(0, dialogue, PEndWhole, NULL, &selected));
  RetError(numberrange_get_value(0, dialogue, PEndManyNum, &contents->pages));

  /* Note that PEndVisible etc. are component IDs defined in */
  /* Print.h, whilst End_Visible (with the underscore) etc.  */
  /* are option values defined at the top of this file.      */

  switch (selected)
  {
    default:
    case PEndWhole:   contents->end = End_Whole;
    break;

    case PEndVisible: contents->end = End_Visible;
    break;

    case PEndMany:    contents->end = End_Many;
    break;
  }

  /* Reformat page to fit */

  RetError(optionbutton_get_state(0, dialogue, PReformatToFit, &state));
  contents->reformat = !!state;

  /* Print to PDF file */

  if (optionbutton_get_state(0, dialogue, PPrintToPDF, &state))
  {
    contents->print_to_pdf = 0;
  }
  else
  {
    contents->print_to_pdf = !!state;
  }

  /* Orientation radios; portrait (1) or landscape (0) */

  RetError(radiobutton_get_state(0, dialogue, POriUpright, &state, NULL));
  contents->orientation = !!state;

  /* Read the 'Number of copies' number range gadget */

  RetError(numberrange_get_value(0, dialogue, PCopiesNum, &contents->copies));

  return NULL;
}

/**************************************************************/
/* print_set_contents()                                       */
/*                                                            */
/* Sets the contents of the Print dialogue from a             */
/* print_contents structure.                                  */
/*                                                            */
/* Parameters: Object ID of the dialogue;                     */
/*                                                            */
/*             Pointer to the structure to read from.         */
/**************************************************************/

static _kernel_oserror * print_set_contents(ObjectId dialogue, print_contents * contents)
{
  /* Start position */

  if (!contents->start) RetError(radiobutton_set_state(0, dialogue, PStartVisible, 1));
  else                  RetError(radiobutton_set_state(0, dialogue, PStartWhole,   1));

  /* End position, including the 'number of pages to fill' number range */

  switch (contents->end)
  {
    default:
    case End_Whole:     RetError(radiobutton_set_state(0, dialogue, PEndWhole,   1));
    break;
    case End_Visible:   RetError(radiobutton_set_state(0, dialogue, PEndVisible, 1));
    break;
    case End_Many:      RetError(radiobutton_set_state(0, dialogue, PEndMany,    1));
    break;
  }

  RetError(numberrange_set_value(0, dialogue, PEndManyNum, contents->pages));

  /* The reformat option, including greying / ungreying it */

  RetError(optionbutton_set_state(0, dialogue, PReformatToFit, contents->reformat));

  /* The print to PDF file option, including greying / ungreying it */

  (void) optionbutton_set_state(0, dialogue, PPrintToPDF, contents->print_to_pdf);

  /* As well as greying / ungreying the reformat option, this handles */
  /* the label text on the 'pages to fill' number range.              */

  print_check_contents(0, NULL, NULL, NULL);

  /* Orientation */

  if (!contents->orientation) RetError(radiobutton_set_state(0, dialogue, POriSideways, 1));
  else                        RetError(radiobutton_set_state(0, dialogue, POriUpright,  1));

  /* Number of copies */

  RetError(numberrange_set_value(0, dialogue, PCopiesNum, contents->copies));

  return NULL;
}

/**************************************************************/
/* print_set_defaults()                                       */
/*                                                            */
/* Fills in the local print_contents structure with the       */
/* default values to put in a Print dialogue, if they have    */
/* not already been filled in.                                */
/*                                                            */
/* If the dialogue is open, the contents are updated.         */
/*                                                            */
/* Returns:    1 if the structure was filled in, else 0.      */
/**************************************************************/

int print_set_defaults(void)
{
  if (!defaults_set)
  {
    /* Number of copies */

    contents.copies = choices.print_copies;

    /* Check it is within bounds */

    if (contents.copies < Limits_Lower_Copies) contents.copies = Limits_Lower_Copies;
    if (contents.copies > Limits_Upper_Copies) contents.copies = Limits_Upper_Copies;

    /* Start position - 'start' or 'visible', though in fact any */
    /* non-'visible' string defaults as 'start'.                 */

    if      (choices.print_start == 0)  contents.start = 1; /* Start   */
    else if (choices.print_start == -1) contents.start = 0; /* Visible */
    else                                contents.start = 1; /* Undef.  */

    /* End position - print the whole page, down to the bottom of the */
    /* visible area, or fill up as many sheets as specified in the    */
    /* 'pages' field of the print_contents structure (see below).     */

    if      (choices.print_end == 0)  contents.end = End_Whole,   contents.pages = 0;
    else if (choices.print_end == -1) contents.end = End_Visible, contents.pages = 0;
    else                              contents.end = End_Many,    contents.pages = choices.print_end;

    /* Check it is within bounds */

    if (contents.pages < Limits_Lower_Sheets) contents.pages = Limits_Lower_Sheets;
    if (contents.pages > Limits_Upper_Sheets) contents.pages = Limits_Upper_Sheets;

    /* Reformat - 'yes' or 'no', default to 'yes'; print to PDF - */
    /* 'yes' or 'no', default to 'no', no representation in the   */
    /* Choices at the moment.                                     */

    contents.reformat     = choices.print_reform;
    contents.print_to_pdf = 0;

    /* Orientation - 'upright' or 'sideways', though in fact any */
    /* non-'sideways' string defaults as 'upright'.              */

    if (choices.print_orient == Choices_PrintOrient_Upright) contents.orientation = 1;
    else                                                     contents.orientation = 0;

    defaults_set = 1;

    if (window_id) print_set_contents(window_id, &contents);

    return 1;
  }

  else return 0;
}

/**************************************************************/
/* print_to_be_shown()                                        */
/*                                                            */
/* Called before a print dialogue opens. Deals with setting   */
/* this up with default values and filling in print_old as    */
/* appropriate, so that if the dialogue is cancelled its      */
/* contents may be correctly restored.                        */
/*                                                            */
/* Parameters are as standard for a Toolbox event hander.     */
/**************************************************************/

int print_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int      was_open = 0;
  ObjectId ps_window;
  ObjectId ps_ancestor;

  /* If the stored dialogue ID is non-zero on entry, the dialogue */
  /* was reopened without closing - so get rid of the various     */
  /* event handlers before we reregister them.                    */

  if (window_id)
  {
    /* Was the Print Style window open too? */

    printstyle_return_dialogue_info(&ps_window, &ps_ancestor);

    if (ps_window) was_open = 1;

    /* This will close the Print window and Print Style (if open) */

    print_close(0, 1);
  }

  /* Record the dialogue ID, the ancestor ID, and if this is */
  /* non-zero, the browser to which that ID refers.          */

  self_id     = idb->self_id;
  ancestor_id = idb->ancestor_id;

  if (ancestor_id) ChkError(toolbox_get_client_handle(0, ancestor_id, (void *) &ancestor_browser));

  /* If this is for an ancestor browser, use whatever frame is selected */
  /* instead - allows toolbar buttons and keyboard shortcuts to work in */
  /* a sensible fashion...                                              */

  if (ancestor_browser->selected_frame)
  {
    ancestor_browser = ancestor_browser->selected_frame;
    ancestor_id      = ancestor_browser->self_id;
  }

  /* If we have a browser, remember its restorable details. */

  if (ancestor_browser)
  {
    restore.underline_links = ancestor_browser->underline_links;
    restore.use_source_cols = ancestor_browser->use_source_cols;
    restore.show_foreground = ancestor_browser->show_foreground;
    restore.show_background = ancestor_browser->show_background;

    /* If required, force background images off */

    if (choices.print_plain) browser_set_look(ancestor_browser,
                                              window_id,
                                              -1,
                                              -1,
                                              -1,
                                              0);
  }

  /* Get the underlying window ID */

  ChkError(printdbox_get_window_id(0, self_id, &window_id));

  /* The Print Style dialogue may be open, too. We could take the lazy route */
  /* and just close it, but instead, we will ask it for its window details,  */
  /* and then recall its close code and ToBeShown code with the right info.  */

  if (was_open)
  {
    IdBlock  ps_id;

    ps_id.self_id = ps_window;

    /* (Make sure the Print Style routines ask the Print routines for the (new) ancestor) */

    ps_id.ancestor_id = NULL;

    printstyle_to_be_shown(0, NULL, &ps_id, NULL);
  }
  /* Register handlers for alternate Print/Cancel buttons */

  ChkError(event_register_toolbox_handler(window_id,
                                          EPStartPrint,
                                          print_start,
                                          (void *) ancestor_id));

  ChkError(event_register_toolbox_handler(window_id,
                                          EPCancelPrint,
                                          print_cancel,
                                          (void *) ancestor_id));

  /* Various alterations of icons / buttons for different UI styles */

  if (!strcmp(lookup_control("AlterNumranges:no",0,0),"yes"))
  {
    _kernel_oserror       * e;
    WimpGetIconStateBlock   icon;
    int                     iconlist [Limits_NRangeIcons];
    char                    buffer   [Limits_Message];

    /* Get the object's window handle and the icon handle for the given component */

    e = window_get_wimp_handle(0, window_id, &icon.window_handle);

    if (!e)
    {
      ComponentId writable;
      int         loop;

      for (loop = 0; loop < 2; loop ++)
      {
        /* Get the number range's writable component ID */

        e = numberrange_get_components(NumberRange_GetComponents_ReturnNumericalField,
                                      window_id,
                                      loop == 1 ? PCopiesNum : PEndManyNum,
                                      &writable,
                                      NULL,
                                      NULL,
                                      NULL);

        /* Turn this into an icon handle */

        if (!e) e = gadget_get_icon_list(0, window_id, writable, iconlist, sizeof(iconlist), NULL);

        if (!e)
        {
          icon.icon_handle = iconlist[0];

          /* Get the icon state and set the icon flags with the */
          /* programming text defined in the Messages file      */

          e = wimp_get_icon_state(&icon);

          if (!e)
          {
            strncpy(buffer, lookup_control("AlterWith",1,0), sizeof(buffer) - 1);
            buffer[sizeof(buffer) - 1] = 0;

            windows_process_icon_text(&icon, buffer, 0);
          }
        }
      }
    }
  }

  /* Register a handler to cope with the pages number range changing */

  ChkError(event_register_toolbox_handler(window_id,
                                          NumberRange_ValueChanged,
                                          print_check_contents,
                                          (void *) window_id));

  /* Similarly, the same function is called to ensure things are greyed */
  /* or ungreyed as required when the radio buttons that affect the     */
  /* 'Reformat page to fit paper' option are activated.                 */

  ChkError(event_register_toolbox_handler(window_id,
                                          EPEnableReformat,
                                          print_check_contents,
                                          (void *) window_id));

  /* Install an animation handler, if there's an appropriate gadget */

  if (
       controls.dbox_anims &&
       !gadget_get_type(0, window_id, StatusBarAnimAnim, NULL)
     )
     register_null_claimant(Wimp_ENull,
                            toolbars_animate_slow,
                            (void *) window_id);

  /* If defaults have never been set before, set them now,
   * otherwise ensure the dialogue box contents are set up
   * again.
   */

  if (!defaults_set)
  {
    print_set_defaults();
  }
  else if (window_id != 0)
  {
    ChkError(print_set_contents(window_id, &contents));
  }

  /* Make sure the Print Style dialogue is set up, too */

  printstyle_set_defaults();

  /* Done! */

  return 1;
}

/**************************************************************/
/* print_start()                                              */
/*                                                            */
/* Handles clicks on the 'OK' (or 'Print', etc.) button in    */
/* the Print dialogue.                                        */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int print_start(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  /* First, make sure we effectively OK the contents of the */
  /* Print Style dialogue.                                  */

  printstyle_ok(0, NULL, NULL, NULL);

  /* Because the printing starts from reception of an external message, */
  /* can't use a local copy of the print_contents structure and allow   */
  /* Adjust-clicks on Print/OK/Whatever. So always close the window.    */

  ChkError(print_read_contents(window_id, &contents));
  ChkError(print_close(0, 0));

  /* If we're printing to a PDF file, check the font mappings first */

  if (contents.print_to_pdf != 0)
  {
    if (savepdf_get_font_mappings() == 0)
    {
      erb.errnum = Utils_Error_Custom_Message;

      StrNCpy0(erb.errmess,
               lookup_token("CantMap:Cannot print to a PDF file because the current font choices do not map to standard PDF fonts. Only Trinity, Homerton and Corpus are supported.",
                            0,
                            0));

      show_error_ret(&erb);
      return 1;
    }

    /* Open the Save As dialogue box */

    ChkError(savefile_open_for(ancestor_browser, save_as_pdf));
  }
  else
  {
    /* First stage of printing protocol: Broadcast a PrintSave message */

    ChkError(protocols_pp_send_print_save());
  }

  return 1;
}

/**************************************************************/
/* print_cancel()                                             */
/*                                                            */
/* Handles clicks on the 'Cancel' button in the Print         */
/* dialogue.                                                  */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int print_cancel(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  WimpGetPointerInfoBlock info;

  /* Restore the old contents */

  ChkError(print_set_contents(window_id, &contents));

  /* If Select was pressed, the dialogue should close. */
  /* (No button => Escape was pressed).                */

  ChkError(wimp_get_pointer_info(&info));

  if ((info.button_state & Wimp_MouseButtonSelect) || !info.button_state)
  {
    ChkError(print_close(0, 0));

    /* If we forced background images off, put them back again */

    if (choices.print_plain) browser_set_look(ancestor_browser,
                                              window_id,
                                              -1,
                                              -1,
                                              -1,
                                              restore.show_background);
  }

  return 1;
}

/**************************************************************/
/* print_close()                                              */
/*                                                            */
/* If the Print dialogue is opened, this will close it,       */
/* deregistering any associated event handlers.               */
/*                                                            */
/* Parameters: An object ID, or 0. If not zero, the ID must   */
/*             match the ancestor recorded when the dialogue  */
/*             was opened or no action is taken.              */
/*                                                            */
/*             0 to close the dialogue, 1 to do everything    */
/*             except that.                                   */
/**************************************************************/

_kernel_oserror * print_close(ObjectId ancestor, int do_not_close)
{
  _kernel_oserror * e = NULL;

  if (ancestor && ancestor != ancestor_id) return NULL;

  /* If the Print Style window is open, this will close it */

  printstyle_close(ancestor_id, do_not_close);

  if (window_id)
  {
    /* Deregister associated event handlers */

    e = event_deregister_toolbox_handlers_for_object(window_id);
    if (e) goto print_close_exit;

    /* If there was a null handler, remove it */

    if (
         controls.dbox_anims &&
         !gadget_get_type(0, window_id, StatusBarAnimAnim, NULL)
       )
       deregister_null_claimant(Wimp_ENull,
                                toolbars_animate_slow,
                                (void *) window_id);

    if (!do_not_close)
    {
      /* Restore input focus to the browser window, if the */
      /* print dialogue still had it.                      */

      if (ancestor_id != NULL_ObjectId)
      {
        WimpGetCaretPositionBlock caret_b;
        int                       caret_w;

        /* Do we have the input focus? */

        e = wimp_get_caret_position(&caret_b);

        if (!e)
        {
          e = window_get_wimp_handle(0,
                                     window_id,
                                     &caret_w);

          if (caret_w == caret_b.window_handle)
          {
            e = browser_give_general_focus(ancestor_browser);
            if (e) goto print_close_exit;
          }
        }
      }

      /* Close the dialogue */

      e = toolbox_hide_object(0, self_id);
    }
  }

print_close_exit:

  self_id = window_id = 0;

  return e;
}

/**************************************************************/
/* print_check_contents()                                     */
/*                                                            */
/* If the state of the various radio buttons changes, this    */
/* may be called to see if the Reformat option in the Print   */
/* dialogue should be enabled (ungreyed) or disabled          */
/* (greyed). Similarly, if the contents of the number of      */
/* sheets to fill number range changes, this should be called */
/* to ensure the label has the correct pluralisation applied. */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int print_check_contents(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int          state1, state2, pages;
  unsigned int flags;

  /* Get the radio button states */

  ChkError(radiobutton_get_state(0, window_id, PStartWhole, NULL, &state1));
  ChkError(radiobutton_get_state(0, window_id, PEndWhole,   NULL, &state2));

  /* If the PStartVisible and PEndVisible radios are not selected, */
  /* can enable the Reformat option; else disable it. But only     */
  /* change it's state (don't grey it if already greyed, say).     */

  ChkError(gadget_get_flags(0, window_id, PReformatToFit, &flags));

  if (state2 != PEndVisible) // state1 != PStartVisible && state2 != PEndVisible)
  {
    if (flags & Gadget_Faded)
    {
      ChkError(gadget_set_flags(0, window_id, PReformatToFit, flags & ~Gadget_Faded));
    }
  }
  else
  {
    if (!(flags & Gadget_Faded))
    {
      ChkError(gadget_set_flags(0, window_id, PReformatToFit, flags | Gadget_Faded));
    }
  }

  /* Check the pages number range, and update the label if necessary. */

  {
    char text[Limits_PEndManyLabel];

    ChkError(numberrange_get_value(0, window_id, PEndManyNum, &pages));

    ChkError(button_get_value(0, window_id, PEndManyLabel, text, Limits_PEndManyLabel, NULL));
    text[sizeof(text) - 1] = 0;

    if (pages == 1)
    {
      /* If the existing text isn't what we intend to change it to, then change it; */
      /* i.e. don't set the same thing twice, as this will flicker badly.           */

      if (strcmp(text, lookup_token("PagesSingle:sheet is filled",0,0)))
      {
        ChkError(button_set_value(0, window_id, PEndManyLabel, lookup_token("PagesSingle:sheet is filled",0,0)));
      }
    }
    else
    {
      /* Again, only change the text - don't set the same thing twice. */

      if (strcmp(text, lookup_token("PagesMany:sheets are filled",0,0)))
      {
        ChkError(button_set_value(0, window_id, PEndManyLabel, lookup_token("PagesMany:sheets are filled",0,0)));
      }
    }
  }

  return 1;
}

/**************************************************************/
/* print_print()                                              */
/*                                                            */
/* Calls the printing engine with parameters specified in the */
/* local static print_info structure 'print_current'.         */
/*                                                            */
/* Entry point is typically from a handler dealing with the   */
/* printing message protocol (see handle_messages).           */
/*                                                            */
/* THIS FUNCTION IS UNUSUAL in that it reports any errors     */
/* encountered internally directly, then continues. The       */
/* returned value is for the caller to know if an error was   */
/* raised BUT THE CALLER SHOULD NOT REPORT THAT ERROR.        */
/*                                                            */
/* Parameters: Pointer to pathname to print to, or NULL to go */
/*             straight to the 'printer:' device.             */
/**************************************************************/

_kernel_oserror * print_print(const char * path)
{
  _kernel_oserror * e;

  /* Must have a browser to print */

  if (!ancestor_browser) return NULL;

  /* Do the printing */

  if (contents.end == End_Visible) printing = 2;
  else                             printing = 1;

  e = print_page(ancestor_browser,
                 contents.copies,
                 contents.start,
                 contents.end,
                 contents.pages,
                 contents.reformat,
                 contents.orientation,
                 path);

  printing = 0;

  if (e) show_error_ret(e);

  /* On completion, with or without error (as e.g. Escape may */
  /* be pressed and you'd still want the following), restore  */
  /* the basic browser display characteristics, if the Print  */
  /* dialogue was closed (i.e. Print activated with Select).  */

  if (!window_id)
  {
    show_error_ret(browser_set_look(ancestor_browser,
                                    0,
                                    restore.underline_links,
                                    restore.use_source_cols,
                                    restore.show_foreground,
                                    restore.show_background));
  }

  return e;
}

/**************************************************************/
/* print_page()                                               */
/*                                                            */
/* MAINTENANCE WARNING - ANY ALTERATIONS HERE WILL NEED       */
/* ECHOING IN PRINT_COUNT_PAGES IF IN AN ANALOGOUS CODE       */
/* SECTION.                                                   */
/*                                                            */
/* Prints out a page, assuming that all the relevant protocol */
/* stuff to ensure it's OK to proceed has been done already.  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to print;                             */
/*                                                            */
/*             The number of copies to print;                 */
/*                                                            */
/*             1 to start at the top of the web page, else    */
/*             start from the top of the visible area in the  */
/*             window;                                        */
/*                                                            */
/*             Where to end - End_Whole, End_Visible or       */
/*             End_Many (as defined at the top of the file);  */
/*                                                            */
/*             For End_Many, how many sheets to fill;         */
/*                                                            */
/*             1 to reformat to fit the page width            */
/*             (orientation is taken into account), else 0 to */
/*             keep the width of the window (if it falls off  */
/*             the page, tough...!);                          */
/*                                                            */
/*             1 = portrait, 0 = landscape;                   */
/*                                                            */
/*             Pointer to pathname to print to, or NULL to go */
/*             straight to the 'printer:' device.             */
/**************************************************************/

static _kernel_oserror * print_page
                         (
                           browser_data * b,
                           int            copies,
                           int            from,
                           int            end,
                           int            to,
                           int            reformat,
                           int            is_portrait,
                           const char   * path
                         )
{
  _kernel_oserror       * e = NULL;

  WimpRedrawWindowBlock   redraw;

  BBox                    redraw_rect;
  BBox                    last_rect;

  BBox                    body_rect,      body_origin;
  BBox                    header_rect,    header_origin;
  BBox                    footer_rect,    footer_origin;

  int                     must_restore,   rect_id;
  int                     job,            old_job;
  int                     more;
  unsigned int            page,           pages;
  unsigned int            page_area,      area_completed;

  int                     paper_width,    paper_height;
  int                     lmarg,          bmarg;
  int                     rmarg,          tmarg;
  int                     unrot_lmarg,    unrot_bmarg;
  int                     unrot_rmarg,    unrot_tmarg;
  int                     top,            bottom;
  int                     header_size,    footer_size;
  int                     mp_header_size, mp_footer_size;
  int                     next_line,      temp;

  unsigned int            features;
  char                  * stored_section    = NULL;

  /* While there is no standard, GhostScript and many other packages treat */
  /* "landscape" to mean a 90 degree clockwise rotation of the *paper* in  */
  /* order to view the document correctly. The left edge of the paper is   */
  /* now the top edge. This makes sense for things like left edge binding, */
  /* if a printer was set for wider left margins, should someone print to  */
  /* such a printer in landscape mode, thus leaving the bound edge running */
  /* along the top of the document rather than the bottom.                 */
  /*                                                                       */
  /* With PDriver the paper doesn't move, so we produce a matrix for a 90  */
  /* degree *anticlockwise* rotation of the *content*, meaning that the    */
  /* final printed sheets of paper would be rotated 90 degrees clockwise   */
  /* in order to correctly view them - which is the required result.       */

  int                     portrait  [2] [2] = { {0x10000, 0}, {0,  0x10000} };
  int                     landscape [2] [2] = { {0, 0x10000}, {-0x10000, 0} };

  browser_data            localbrowser;

  void (*old_sigint_handler) (int);

  /* Check to see if there is a printer driver ready */

  e = _swix(PDriver_Info,
            _OUT(3),

            &features);

  if (e) return e;

  /* Find the current page margins (and therefore, page size, */
  /* as all margins are expressed as offsets from the bottom  */
  /* left hand corner of the paper).                          */

  e = _swix(PDriver_PageSize,
            _OUTR(1,6),

            &paper_width,
            &paper_height,
            &lmarg,
            &bmarg,
            &rmarg,
            &tmarg);

  if (e) return e;

  /* Remember the 'unrotated' margin values */

  unrot_lmarg = lmarg;
  unrot_bmarg = bmarg;
  unrot_rmarg = rmarg;
  unrot_tmarg = tmarg;

  /* Rotate the margins for landscape mode so that the margins are still */
  /* correct relative to the content.                                    */

  if (!is_portrait)
  {
    /* Remember that lmarg etc. are all offsets from the bottom left  */
    /* corner, so be careful with the rotation.                       */

    int ol =                lmarg;
    int ob =                bmarg;
    int or = paper_width  - rmarg;
    int ot = paper_height - tmarg;

    /* The notion of paper width and height swaps over for landscape. */

    Swap(paper_width, paper_height);

    if (contents.print_to_pdf)
    {
      /* For PDF printing, the content is not rotated during output,  */
      /* unlike with PDriver. We set up a wide page and draw on it so */
      /* rotate the argins 90 degrees clockwise.                      */
      /*                                                              */
      /*    T     90deg     l                                         */
      /* L     R   -->   b     t                                      */
      /*    B     clock     r                                         */

      lmarg =                ob;
      bmarg =                or;
      rmarg = paper_width  - ot;
      tmarg = paper_height - ol;
    }
    else
    {
      /* For printing, we perform an anticlockwise rotation so that   */
      /* after printing to an upright sheet the viewer rotates that   */
      /* sheet clockwise to see the content the right way up.         */
      /*                                                              */
      /*    T     90deg     r                                         */
      /* L     R   -->   t     b                                      */
      /*    B     anti.     l                                         */
      /*                                                              */

      lmarg =                ot;
      bmarg =                ol;
      rmarg = paper_width  - ob;
      tmarg = paper_height - or;
    }
  }

  /* Work out header and footer sizes (the height is currently unaffected */
  /* by contents, just whether or not there is any content, so we don't   */
  /* bother doing this per-page).                                         */

  print_header_and_footer_sizes(b,
                                1,
                                1,
                                NULL,
                                &header_size,
                                &footer_size);

  /* Convert to millipoints and modify the top/bottom margins accordingly */

  convert_pair_to_points(header_size, footer_size, &mp_header_size, &mp_footer_size);

  tmarg -= mp_header_size;
  bmarg += mp_footer_size;

  if (is_portrait)
  {
    unrot_tmarg -= mp_header_size;
    unrot_bmarg += mp_footer_size;
  }
  else
  {
    unrot_lmarg += mp_header_size;
    unrot_rmarg -= mp_footer_size;
  }

  /* Start the hourglass, this could take a while.              */
  /*                                                            */
  /* Using Hourglass_Start as otherwise the first percentage    */
  /* setting may be missed, since the hourglass isn't actually  */
  /* on yet (there's a default delay before appearance with     */
  /* calling Hourglass_On).                                     */

  _swix(Hourglass_Start, _IN(0), 1);

  /* If the user specified printing to or from something that */
  /* depends upon the visible area, can't then reformat. We   */
  /* can, however, use markers to try and preserve the offset */
  /* for printing from the top of the visible area.           */

  if (reformat && end != End_Visible)
  {
    print_prepare_browser(b, &localbrowser, lmarg, rmarg, tmarg, bmarg);
    must_restore = 1;

    print_reformat_for_printing(b, from);
  }
  else must_restore = 0;

  /* Now things diverge for PDF or real printing */

  if (contents.print_to_pdf == 0)
  {
    /* Open up the output stream */

    e = _swix(OS_Find,
              _INR(0,1) | _OUT(0),

              0x8F,
              path ? path : "printer:",

              &job);

    if (e) goto out3;

    globaljob = job;

    /* Stop the C library intercepting Escape, since */
    /* this should be left to the print SWIs.        */

    old_sigint_handler = signal(SIGINT, SIG_IGN);

    /* Start up the printing system */

    e = _swix(PDriver_SelectJob,
              _INR(0,1) | _OUT(0),

              job,
              lookup_token("PJobName:Web page",0,0),

              &old_job);

    if (e) goto out1;

    globalold_job = old_job;

    /* Declare fonts that have been used */

    if (features & Browser_Printer_DeclareFont)
    {
      e = print_declare_fonts();
      if (e) goto out2;
    }
  }
  else
  {
    /* Stop compiler warning about this being unset before use */

    old_sigint_handler = NULL;

    /* PDF printing - ask the PDF system to do the preamble */

    e = savepdf_start_session(b, path);
    if (e) goto out3;

    /* Start the PDF output. */

    if (contents.print_to_pdf)
    {
      e = savepdf_write_header();
      if (e) goto out2;
    }
  }

  /* Set 'top' to the offset from the top of the document to get  */
  /* to the top of the currently visible portion, and 'bottom'    */
  /* to the offset to get to the bottom of the currently visible  */
  /* portion. The positive direction is downwards (so they should */
  /* both be positive numbers).                                   */

  e = print_find_window_edges(b, from, &top, &bottom);
  if (e) goto out2;

  /* Clear any stored inferred section title for headers/footers. */

  free(b->inferred_section), b->inferred_section = NULL;

  /* Work out how many pages we have. The only reliable way to do */
  /* this is to run a dummy redraw loop with an empty redraw core */
  /* table and count the split points arising. It's not as slow   */
  /* as you might expect!                                         */

  pages = print_count_pages(b,
                            end,
                            to,
                            lmarg,
                            rmarg,
                            tmarg,
                            bmarg,
                            top,
                            bottom);

  /* Clear any sections which the above counting session may have */
  /* inadvertently discovered.                                    */

  free(b->inferred_section), b->inferred_section = NULL;

  /* Loop round for all pages */

  page           = 0;
  next_line      = 0;
  redraw.xscroll = 0;
  redraw.yscroll = -top;

  while (
          (
            end == End_Many &&
            page < to
          )
          ||
          (
            end != End_Many
          )
        )
  {
    /* Set the *current* page number in 'page' */

    page++;

    /* Check to see if we've a new section heading */

    if (b->inferred_section != NULL)
    {
      int ok = 0;

      if (stored_section != NULL)
      {
        if (strcmp(b->inferred_section, stored_section) != 0)
        {
          free(stored_section);
          ok = 1;
        }
      }
      else ok = 1;

      if (ok == 1)
      {
        stored_section      = b->inferred_section;
        b->inferred_section = NULL;

        if (contents.print_to_pdf)
        {
          e = savepdf_new_inferred_section(stored_section);
          if (e) goto out2;
        }
      }
    }

    /* For PDF files, output the start of the page object (must do */
    /* this *after* checking for new section headings).            */

    if (contents.print_to_pdf)
    {
      e = savepdf_start_page(paper_width, paper_height);
      if (e) goto out2;
    }

    /* Set up this page's area bounding box and origin. The plot origin is */
    /* for the bottom left of the print rectangle *before* application of  */
    /* the transformation matrix. The printer driver transforms the print  */
    /* rectangle but still bases it on our unchanged origin. The landscape */
    /* transformation matrix rotates the page 90 degrees but cannot effect */
    /* a translation too - so the box is rotated around the bottom left    */
    /* corner and disappears off the visible page. We have to correct our  */
    /* origin so that the box is in the right place *after* it is rotated. */
    /*                                                                     */
    /* For PDF printing, things are simpler as there's no rotation.        */

    if (is_portrait || contents.print_to_pdf)
    {
      body_origin.xmin = lmarg;
      body_origin.ymin = bmarg;
    }
    else /* Landscape paper printing */
    {
      body_origin.xmin = unrot_rmarg;
      body_origin.ymin = unrot_bmarg;
    }

    /* The body rectangle is actually simpler than the origin, since the */
    /* transformation matrix takes care of most aspects of this for us.  */

    body_rect.xmax   = rmarg - lmarg;
    body_rect.xmin   = 0;

    convert_to_os(body_rect.xmax, &body_rect.xmax);

    /* Vertical margins are complicated by the user settings. For printing    */
    /* down to the bottom of the web page, want to use a full page rectangle; */
    /* for printing down to the bottom of the visible area, want to use the   */
    /* 'bottom' variable worked out above. Note the checking to work out      */
    /* pagination - it *could* be possible that the visible area is taller    */
    /* than a single sheet of paper for the current printer.                  */

    convert_to_os(tmarg - bmarg, &temp); /* 'temp' now holds the printable page height in OS units */

    if (end != End_Visible)
    {
      body_rect.ymax = temp,
      body_rect.ymin = 0;
    }
    else
    {
      /* Need to subtract an amount from 'bottom' to mark that a page has been  */
      /* done, but must do that after the page rendering so the redraw routines */
      /* have filled in next_line with the y-coordinate of the top of the next  */
      /* line to draw. Without this, we can't tell how much of the web page was */
      /* actually used. Remember that next_line and yscroll are negative;       */
      /* next_line gives the vertical offset at which to start the next page    */
      /* and yscroll holds the offset at which the most recent page started.    */

      if (next_line != 0 && bottom) bottom -= (redraw.yscroll - next_line);

      if (bottom - top > temp) /* And *not* '>= temp'! See 'else' code below */
      {
        body_rect.ymax = temp;
      }
      else
      {
        body_rect.ymax = bottom - top;
        bottom = 0;

        /* Since this rectangle is at most a full page in height but probably */
        /* less, must shift the bottom left hand coordinate of it up an       */
        /* appropriate amount to print the page fragment at the top of the    */
        /* paper rather than the bottom.                                      */

        temp -= body_rect.ymax; /* (Page height minus rectangle height in OS units) */

        convert_to_points(temp, &temp);

        if (is_portrait) body_origin.ymin += temp;
        else             body_origin.xmin += temp;
      }

      body_rect.ymin = 0;
    }

    /* next_line gives the y-coordinate of the top of the next line */
    /* to print when it exits, through the next_line variable. Note */
    /* this must not be assigned to redraw.yscroll until AFTER the  */
    /* code calculating 'bottom' (see above).                       */

    if (next_line != 0) redraw.yscroll = next_line;

    /* Set the "visible area" to the whole of the page body so that */
    /* the redraw routines know what they're doing. This stays the  */
    /* same during page printing - the redraw area changes, the     */
    /* visible area stays the same.                                 */

    redraw.visible_area = body_rect;

    /* Set the draw rectangles. We use three - the main page,   */
    /* the header and the footer. Tell the printer driver about */
    /* each or store the information for the PDF routines.      */

    if (contents.print_to_pdf == 0)
    {
      e = _swix(PDriver_GiveRectangle,
                _INR(0,4),

                0, /* Use zero for the main page */
                &body_rect,
                is_portrait ? &portrait : &landscape,
                &body_origin,
                Redraw_Colour_White);
    }
    else
    {
      e = savepdf_give_rectangle(&body_rect, &body_origin);
    }

    if (e) goto out2;

    if (choices.print_headers_from > 0)
    {
      header_rect.xmin = body_rect.xmin;
      header_rect.xmax = body_rect.xmax;
      header_rect.ymin = 0;
      header_rect.ymax = header_size;

      /* Similar logic here as for printing the body; see comments above */
      /* for details of how that's worked out.                           */

      if (is_portrait || contents.print_to_pdf)
      {
        header_origin.xmin = lmarg;
        header_origin.ymin = tmarg;
      }
      else /* Landscape paper printing */
      {
        header_origin.xmin = unrot_lmarg; /* Header height is already included in unrot_lmarg */
        header_origin.ymin = unrot_bmarg;
      }

      if (contents.print_to_pdf == 0)
      {
        e = _swix(PDriver_GiveRectangle,
                  _INR(0,4),

                  1, /* Use 1 for the header */
                  &header_rect,
                  is_portrait ? &portrait : &landscape,
                  &header_origin,
                  Redraw_Colour_White);

        if (e) goto out2;
      }
    }

    if (choices.print_footers_from > 0)
    {
      footer_rect.xmin = body_rect.xmin;
      footer_rect.xmax = body_rect.xmax;
      footer_rect.ymin = 0;
      footer_rect.ymax = footer_size;

      /* Similar logic here as for printing the body; see comments above */
      /* for details of how that's worked out.                           */

      if (is_portrait || contents.print_to_pdf)
      {
        footer_origin.xmin = lmarg;
        footer_origin.ymin = bmarg - mp_footer_size;
      }
      else /* Landscape paper printing */
      {
        footer_origin.xmin = unrot_rmarg + mp_footer_size;
        footer_origin.ymin = unrot_bmarg;
      }

      if (contents.print_to_pdf == 0)
      {
        e = _swix(PDriver_GiveRectangle,
                  _INR(0,4),

                  2, /* Use 2 for the footer */
                  &footer_rect,
                  is_portrait ? &portrait : &landscape,
                  &footer_origin,
                  Redraw_Colour_White);

        if (e) goto out2;
      }
    }

    /* Get the first rectangle to print, or simulate the whole page */
    /* for PDF output.                                              */

    if (contents.print_to_pdf == 0)
    {
      e = _swix(PDriver_DrawPage,
                _INR(0,3) | _OUT(0) | _OUT(2),

                (copies) | ((features & Browser_Printer_PreScansRectangles) ? (1<<24) : (0)),
                &redraw_rect,
                page,
                NULL,

                &more,
                &rect_id);

      if (e) goto out2;
    }
    else
    {
      redraw_rect = body_rect;
    }

    /* Give an indication of progress */

    utils_hourglass_percent(page, pages);

    /* Calculate the area in OS units of the whole page, used for the */
    /* hourglass percentage when printing strips of the page body.    */

    page_area = (body_rect.xmax - body_rect.xmin) *
                (body_rect.ymax - body_rect.ymin);

    /* The redraw loop itself */

    last_rect.xmin = last_rect.xmax = last_rect.ymin = last_rect.ymax = 0;
    area_completed = 0;
    next_line      = 0;

    if (contents.print_to_pdf == 0)
    {
      while (more)
      {
        switch (rect_id)
        {
          default: /* Always default to printing the body of the page */
          {
            /* Ensure images are correct for the current mode */

            image_mode_change();

            /* Do the redraw */

            redraw.redraw_area = redraw_rect;

            e = redraw_draw(b,
                            &redraw,
                            &next_line,
                            0,
                            0);

            /* Don't alter hourglass setting if this is just a prescan */

            if (
                 ((features & Browser_Printer_PreScansRectangles) == 0) ||
                 ((more     & 1<<24)                              == 0)
               )
            {
              area_completed = print_set_hourglass_by_area(&redraw_rect,
                                                           &last_rect,
                                                           pages,
                                                           page,
                                                           page_area,
                                                           area_completed);

              last_rect = redraw_rect;
            }
          }
          break;

          case 1:
          {
            e = print_header(b,
                             pages,
                             page,
                             stored_section,
                             header_size,
                             redraw_rect.xmax - redraw_rect.xmin);
          }
          break;

          case 2:
          {
            e = print_footer(b,
                             pages,
                             page,
                             stored_section,
                             footer_size,
                             redraw_rect.xmax - redraw_rect.xmin);
          }
          break;
        }

        if (e) goto out2;

        /* Get the next rectangle */

        e = _swix(PDriver_GetRectangle,
                  _IN(1) | _OUT(0) | _OUT(2),

                  &redraw_rect,

                  &more,
                  &rect_id);

        if (e) goto out2;
      }
    }
    else /* From 'if (contents.print_to_pdf == 0)' */
    {
      for (rect_id = 0; rect_id < 3; rect_id++)
      {
        savepdf_replace_redraw_table();

        switch (rect_id)
        {
          default: /* Always default to printing the body of the page */
          {
            /* Ensure images are correct for the current mode */

            image_mode_change();

            /* Do the redraw */

            redraw.redraw_area = redraw_rect;

            e = redraw_draw(b,
                            &redraw,
                            &next_line,
                            0,
                            0);
          }
          break;

          case 1:
          {
            if (choices.print_headers_from > 0)
            {
              e = savepdf_give_rectangle(&header_rect, &header_origin);
              if (e) break;

              e = print_header(b,
                               pages,
                               page,
                               stored_section,
                               header_size,
                               redraw_rect.xmax - redraw_rect.xmin);
            }
            else e = NULL;
          }
          break;

          case 2:
          {
            if (choices.print_footers_from > 0)
            {
              e = savepdf_give_rectangle(&footer_rect, &footer_origin);
              if (e) break;

              e = print_footer(b,
                               pages,
                               page,
                               stored_section,
                               footer_size,
                               redraw_rect.xmax - redraw_rect.xmin);
            }
            else e = NULL;
          }
          break;
        }

        savepdf_restore_redraw_table();
        if (e) goto out2;
      }

      /* Finish the page information */

      e = savepdf_end_page();
      if (e) goto out2;

    } /* From 'else' of 'if (contents.print_to_pdf ==0)' */

    /* If we should print down to the bottom of the visible */
    /* area of the page, this is flagged with 'end' set to  */
    /* End_Visible; if 'bottom' is zero as well, there's    */
    /* nothing more to print.                               */

    if (end == End_Visible && !bottom) break;

    /* If next_line is 0, redraw_draw must not have found any */
    /* more lines to print. So there are no more pages.       */

    if (next_line == 0) break;

    /* Otherwise, close the outer while loop - which */
    /* may mean we loop for another page.            */
  }

  /* Finished, so end the job, close the output stream, */
  /* turn off the hourglass and restore the previous    */
  /* job.                                               */

  if (contents.print_to_pdf == 0)
  {
    e = _swix(PDriver_EndJob,
              _IN(0),

              job);

    if (e) goto out2;
  }
  else
  {
    e = savepdf_write_trailer();
    if (e) goto out2;

    e = savepdf_end_session();
    if (e) goto out3;
  }

  /* Ensure images are restored to the correct mode and clear any */
  /* stored section title                                         */

  image_mode_change();
  free(stored_section);
  free(b->inferred_section), b->inferred_section = NULL;

  if (contents.print_to_pdf == 0)
  {
    /* Restore the old Escape handler */

    signal(SIGINT, old_sigint_handler);

    /* Close the output stream */

    globaljob = 0;

    e = _swix(OS_Find,
              _INR(0,1),

              0x00,
              job);

    if (e) goto out3;
  }

  /* Remove the hourglass percentage indicator */

  _swix(Hourglass_Percentage,
        _IN(0),

        100);

  /* Now we have to put the page back where it was... */

  if (must_restore)
  {
    print_restore_browser(b, &localbrowser);
    (void) print_reformat_to_restore(b, from);
    must_restore = 0;
  }

  /* Turn off the hourglass */

  _swix(Hourglass_Off, 0);

  if (contents.print_to_pdf == 0)
  {
    /* Restore the previous print job */

    globalold_job = 0;

    return _swix(PDriver_SelectJob,
                 _INR(0,1),

                 old_job,
                 0);
  }
  else
  {
    return NULL;
  }

out1: /* 'Emergency exit' if PDriver_SelectJob fails */

  if (contents.print_to_pdf == 0)
  {
    signal(SIGINT, old_sigint_handler);
    globaljob = 0;

    /* Close the output stream */

    _swix(OS_Find,
          _INR(0,1),

          0x00,
          job);
  }
  else
  {
    (void) savepdf_end_session();
  }

  /* Flag that printing has finished */

  printing = 0;

  /* Force the hourglass off */

  _swix(Hourglass_Smash, 0);

  /* Put the browser back together again */

  if (must_restore)
  {
    print_restore_browser(b, &localbrowser);
    (void) reformat_format_from(b, -1, 1, -1);
    if (!from) markers_forget_position(b);
  }

  /* Ensure images are restored to the correct mode and clear any */
  /* stored section title                                         */

  image_mode_change();
  free(stored_section);
  free(b->inferred_section), b->inferred_section = NULL;

  return e;

out2: /* 'Emergency exit' for errors whilst printing */

  if (contents.print_to_pdf == 0)
  {
    signal(SIGINT, old_sigint_handler);
    print_abort_print();
  }
  else
  {
    (void) savepdf_end_session();
    printing = 0;
  }

  if (must_restore)
  {
    print_restore_browser(b, &localbrowser);
    (void) reformat_format_from(b, -1, 1, -1);
    if (!from) markers_forget_position(b);
  }

  image_mode_change();
  free(stored_section);
  free(b->inferred_section), b->inferred_section = NULL;

  return e;

out3: /* 'Emergency exit' for errors after printing */

  _swix(Hourglass_Smash, 0);
  printing = 0;

  if (must_restore)
  {
    print_restore_browser(b, &localbrowser);
    (void) reformat_format_from(b, -1, 1, -1);
    if (!from) markers_forget_position(b);
  }

  image_mode_change();
  free(stored_section);
  free(b->inferred_section), b->inferred_section = NULL;

  return e;
}

/**************************************************************/
/* print_abort_print()                                        */
/*                                                            */
/* Forcibly aborts a print job.                               */
/**************************************************************/

void print_abort_print(void)
{
  if (printing)
  {
    /* Clear the printing flag */

    printing = 0;

    /* Abort the current print job */

    _swix(PDriver_AbortJob,
          _IN(0),

          globaljob);

    /* Close the output stream */

    _swix(OS_Find,
          _INR(0,1),

          0x00,
          globaljob);

    globaljob = 0;

    /* Restore the previous print job */

    _swix(PDriver_SelectJob,
          _INR(0,1),

          globalold_job,
          0);

    globalold_job = 0;

    /* Force the hourglass off */

    _swix(Hourglass_Smash, 0);
  }
}

/**************************************************************/
/* print_prepare_browser()                                    */
/*                                                            */
/* Prepares a browser for internal reformatting prior to      */
/* printing a page, storing various overwritten values into   */
/* an alternative given structure.                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to print;                             */
/*                                                            */
/*             Pointer to the browser_data struct to copy     */
/*             into;                                          */
/*                                                            */
/*             Left hand page margin, in millipoints;         */
/*                                                            */
/*             Right hand page margin, in millipoints.        */
/**************************************************************/

static void print_prepare_browser(browser_data * source, browser_data * store, int lmarg, int rmarg, int tmarg, int bmarg)
{
  store->previous        = source->previous;
  store->next            = source->next;
  source->previous       = source->next = NULL;

  store->display_width   = source->display_width;
  source->display_width  = rmarg - lmarg;

  convert_to_os(source->display_width, &source->display_width);

  store->display_height  = source->display_height;
  source->display_height = bmarg - tmarg;

  convert_to_os(source->display_height, &source->display_height);

  store->display_extent  = source->display_extent;
  source->display_extent = source->display_width;

  store->fetch_status    = source->fetch_status;
  source->fetch_status   = BS_IDLE;
  store->fetch_handle    = source->fetch_handle;
  source->fetch_handle   = source->display_handle;
}

/**************************************************************/
/* print_restore_browser()                                    */
/*                                                            */
/* Puts back the bits and pieces replaced in the browser_data */
/* struct given to the print routines, copied out because a   */
/* reformat was required on the page.                         */
/*                                                            */
/* Parameters: Pointer to the browser_data struct given to    */
/*             the print routines;                            */
/*                                                            */
/*             Pointer to the browser_data struct used to     */
/*             store the over- written values from the        */
/*             original copy in print_prepare_browser.        */
/**************************************************************/

static void print_restore_browser(browser_data * original, browser_data * copy)
{
  original->previous       = copy->previous;
  original->next           = copy->next;
  original->display_width  = copy->display_width;
  original->display_extent = copy->display_extent;
  original->display_height = copy->display_height;
  original->fetch_status   = copy->fetch_status;
  original->fetch_handle   = copy->fetch_handle;
}

/**************************************************************/
/* print_reformat_for_printing()                              */
/*                                                            */
/* Reformat a page ready for printing. YOU MUST HAVE CALLED   */
/* print_prepare_browser FIRST!                               */
/*                                                            */
/* Parameters: Pointer to the browser_data struct relevant to */
/*             the page being printed and formatted;          */
/*                                                            */
/*             1 to start at the top of the web page, else    */
/*             start from the top of the visible area in the  */
/*             window;                                        */
/**************************************************************/

static _kernel_oserror * print_reformat_for_printing(browser_data * b, int from)
{
  _kernel_oserror * e;
  int               leds = 1;

  _swix(Hourglass_Start, _IN(0), 1);

  /* Reformat the page ready for printing. It used to be possible to do all of */
  /* this in a separate browser_data structure and, being careful about flex,  */
  /* reformat in that 'virtual' browser. This enabled reformatting internally  */
  /* not to affect the main browser page.                                      */
  /*                                                                           */
  /* Tables, however, screwed this up big time. Table cells were malloc'd, but */
  /* no record of this was kept, in the first cut of the code. So in the end,  */
  /* the address of the cell array was kept in the HStream defining the table. */
  /* However, you can only have one user of that at any one time...            */
  /*                                                                           */
  /* Four solutions to this (where NA = Not Acceptable):                       */
  /*                                                                           */
  /* 1. Get rid of the 'reformat to fit page' option (NA)                      */
  /* 2. Only allow the above when there are no tables on the page (NA)         */
  /* 3. Copy the entire token stream as well as the flex data (NA)             */
  /* 4. Reformat in the actual browser and have it reformat again afterwards.  */
  /*                                                                           */
  /* Since 1 to 3 aren't acceptable - 3 mostly because not only is it a lot of */
  /* memory to have to find, but it's in malloc space -> WimpSlot problems -   */
  /* only 4 is left. So this is what we now do here. Consequently, lots of     */
  /* bits of the browser_data structure have to be copied away and restored    */
  /* later, which can get quite messy.                                         */
  /*                                                                           */
  /* The fact that option 4 was chosen doesn't mean it isn't hideous...        */

  if (!from) markers_remember_position(b);

  e = reformat_format_from(b, -1, 1, -1);

  if (e != NULL)
  {
    _swix(Hourglass_Off, 0);
    return e;
  }

  while (reformat_formatting(b))
  {
    reformat_reformatter(b);

    if (!from) browser_check_for_request(b);

    /* It is virtually impossible to assess progress without */
    /* doing something time consuming like scan the token    */
    /* list and work out how far down it we are, compared to */
    /* the whole length. Instead, alternate the LEDs - this  */
    /* fits in well with what the table reformatter code     */
    /* will be doing with the hourglass.                     */

    leds ^= 3;

    _swix(Hourglass_LEDs,
          _INR(0,1),

          3,
          leds);
  }

  _swix(Hourglass_LEDs,
        _INR(0, 1),

        0,
        0);

  return _swix(Hourglass_Off, 0);
}

/**************************************************************/
/* print_reformat_to_restore()                                */
/*                                                            */
/* Restore a page formatted by print_reformat_for_printing.   */
/* YOU MUST HAVE CALLED print_restore_browser FIRST!          */
/*                                                            */
/* Parameters: Pointer to the browser_data struct relevant to */
/*             the page being printed and formatted;          */
/*                                                            */
/*             1 to start at the top of the web page, else    */
/*             start from the top of the visible area in the  */
/*             window;                                        */
/**************************************************************/

static _kernel_oserror * print_reformat_to_restore(browser_data * b, int from)
{
  int leds = 1;

  _swix(Hourglass_Start, _IN(0), 1);

  /* Wait around whilst the reformatter reformats. */

  reformat_format_from(b, -1, 1, -1); /* Ignore errors */

  while (reformat_formatting(b))
  {
    reformat_reformatter(b);

    if (!from) browser_check_for_request(b);

    leds ^= 3;

    _swix(Hourglass_LEDs,
          _INR(0,1),

          3,
          leds);
  }

  if (!from) markers_forget_position(b);

  return _swix(Hourglass_Off, 0);;
}

/**************************************************************/
/* print_find_window_edges()                                  */
/*                                                            */
/* Set 'top' to the offset from the top of the document to    */
/* get to the top of the currently visible portion, and       */
/* 'bottom' to the offset to get to the bottom of the         */
/* currently visible portion. The positive direction is       */
/* downwards (so they should both be positive numbers).       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the window edges of interest;                  */
/*                                                            */
/*             1 to start at the top of the web page, else    */
/*             start from the top of the visible area in the  */
/*             window;                                        */
/*                                                            */
/*             Pointer to an int, updated on successful exit  */
/*             with the "top" value - may be NULL;            */
/*                                                            */
/*             Pointer to an int, updated on successful exit  */
/*             with the "bottom" value - may be NULL.         */
/**************************************************************/

static _kernel_oserror * print_find_window_edges
                         (
                           browser_data * b,
                           int            from,
                           int          * r_top,
                           int          * r_bottom
                         )
{
  WimpGetWindowStateBlock state;
  int                     htop, hbot, top, bottom;

  state.window_handle = b->window_handle;
  RetError(wimp_get_window_state(&state));

  /* Get the basic offsets */

  top    = -state.yscroll;
  bottom = state.visible_area.ymax - state.visible_area.ymin;

  /* Correct for toolbar presence */

  if (!controls.swap_bars)
  {
    htop = toolbars_button_height(b) + toolbars_url_height(b);
    hbot = toolbars_status_height(b);
  }
  else
  {
    htop = toolbars_status_height(b);
    hbot = toolbars_button_height(b) + toolbars_url_height(b);
  }

  if (htop) htop += wimpt_dy();
  if (hbot) hbot += wimpt_dy();

  top    += htop;
  bottom -= (htop + hbot - top);

  /* If 'from' is non-zero, want to print from the top of the whole   */
  /* page; else from the top of the visible area as worked out above. */

  if (from) top = htop;

  if (r_top    != NULL) *r_top    = top;
  if (r_bottom != NULL) *r_bottom = bottom;

  return NULL;
}

/**************************************************************/
/* print_declare_fonts()                                      */
/*                                                            */
/* For printer drivers where the PDriver_Info SWI returns a   */
/* features word with the Browser_Printer_DeclareFont flags   */
/* bit set, call this function to do the declarations.        */
/**************************************************************/

static _kernel_oserror * print_declare_fonts(void)
{
  fm_face h;

  /* If using system font, only the system faces will be */
  /* used; otherwise, need to declare the sans, serif    */
  /* and fixed faces.                                    */

  if (!choices.system_font)
  {
    h = fm_find_font(NULL, "sans",  192,192,0,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "sans",  192,192,1,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "sans",  192,192,0,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "sans",  192,192,1,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);

    h = fm_find_font(NULL, "serif", 192,192,0,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "serif", 192,192,1,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "serif", 192,192,0,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "serif", 192,192,1,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);

    h = fm_find_font(NULL, "fixed", 192,192,0,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "fixed", 192,192,1,0); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "fixed", 192,192,0,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
    h = fm_find_font(NULL, "fixed", 192,192,1,1); RetError(_swix(PDriver_DeclareFont,_INR(0,2),h,0,2)); fm_lose_font(NULL, h);
  }

  /* Finish declaring fonts */

  return _swix(PDriver_DeclareFont,
               _INR(0,2),

               0,
               0,
               2);
}

/**************************************************************/
/* print_return_dialogue_info()                               */
/*                                                            */
/* Returns information on the Print dialogue, and its         */
/* ancestor.                                                  */
/*                                                            */
/* Parameters: Pointer to an ObjectId, in which the ID of the */
/*             PrintDBox object is placed;                    */
/*                                                            */
/*             Pointer to an ObjectId, in which the ID of the */
/*             underlying window object is placed;            */
/*                                                            */
/*             Pointer to an ObjectId, in which the ID of the */
/*             ancestor window is placed;                     */
/*                                                            */
/*             Pointer to a pointer to a browser_data struct, */
/*             in which the address of the browser_data       */
/*             struct associated with the ancestor object is  */
/*             placed.                                        */
/*                                                            */
/* Returns:    See parameters list, and note that the         */
/*             returned values will be 0, 0, 0 and NULL if    */
/*             the Print dialogue is closed.                  */
/*                                                            */
/* Assumes:    Any of the pointers may be NULL.               */
/**************************************************************/

void print_return_dialogue_info(ObjectId * self, ObjectId * window, ObjectId * ancestor, browser_data ** ancestor_b)
{
  if (self)       *self       = self_id;
  if (window)     *window     = window_id;
  if (ancestor)   *ancestor   = ancestor_id;
  if (ancestor_b) *ancestor_b = ancestor_browser;
}

/**************************************************************/
/* print_roman()                                              */
/*                                                            */
/* From HTMLLib (ol.c). Convert a value into a roman numeral  */
/* string in the given buffer. The buffer is assumed to be    */
/* large enough.                                              */
/*                                                            */
/* Parameters: Pointer to the buffer;                         */
/*                                                            */
/*             Value to convert;                              */
/*                                                            */
/*             Zero for lower case, else upper case.          */
/*                                                            */
/* Returns:    Pointer to the output buffer given in the      */
/*             parameters.                                    */
/**************************************************************/

static char * print_roman(char * temp, unsigned int value, int isupper)
{
  static const char ones[10][5] =
  {
    "", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix"
  };
  static const char tens[10][5] =
  {
    "", "x", "xx", "xxx", "xl", "l", "lx", "lxx", "lxxx", "xc"
  };
  static const char hundreds[10][5] =
  {
    "", "c", "cc", "ccc", "cd", "d", "dc", "dcc", "dccc", "cm"
  };

  char       * p = temp;
  const char * s;
  int          o, t, h;

  value %= 5000;

  while (value >= 1000)
  {
    *p++ = 'm';
    value -= 1000;
  }

  t = value / 10;
  o = value % 10;
  h = t     / 10;
  t = t     % 10;

  for (s = hundreds[h]; *s; ) *p++ = *s++;
  for (s = tens[t];     *s; ) *p++ = *s++;
  for (s = ones[o];     *s; ) *p++ = *s++;

  *p = '\0';

  if (isupper != 0)
  {
    char * t = temp;

    while (*t) *t++ -= 32;
  }

  return temp;
}

/**************************************************************/
/* print_roman()                                              */
/*                                                            */
/* Convert a value into an alphabetic indicator - 1 is a, 2   */
/* is b, 3 is c etc. up to 26 being z, 27 is aa, 28 is ab,    */
/* etc. to zz, to aaa, aab, aac...zzy, zzz, aaaa and so-on.   */
/* The output is a NUL terminated string in a given buffer,   */
/* assumed to be large enough.                                */
/*                                                            */
/* Parameters: Pointer to the buffer;                         */
/*                                                            */
/*             Value to convert;                              */
/*                                                            */
/*             Zero for lower case, else upper case.          */
/*                                                            */
/* Returns:    Pointer to the output buffer given in the      */
/*             parameters.                                    */
/**************************************************************/

static char * print_alpha(char * temp, unsigned int value, int isupper)
{
  unsigned int vcopy;
  int          top;
  char         base;

  /* Work out how many characters we'll need and fill in backwards */

  top   = 0;
  vcopy = value;

  while (vcopy != 0)
  {
    top += 1;
    vcopy = (vcopy - 1) / 26;
  }

  /* Now build the string */

  if (isupper != 0) base = 'A';
  else              base = 'a';

  temp[top--] = '\0';

  while (top >= 0 && value != 0)
  {
    temp[top--] = base + ((value - 1) % 26);
    value = (value - 1) / 26;
  }

  return temp;
}

/**************************************************************/
/* print_date()                                               */
/*                                                            */
/* Output either the current date or a given date formatted   */
/* according to PrintDateFormat in the Choices file.          */
/*                                                            */
/* Parameters: Pointer to a date string in the form of a      */
/*             LastModified header value which will be        */
/*             converted to the required format (NOT          */
/*             IMPLEMENTED YET!) or NULL to use the current   */
/*             date and time;                                 */
/*                                                            */
/*             Pointer to a buffer to write the time into;    */
/*                                                            */
/*             Size of the buffer.                            */
/*                                                            */
/* Returns:    Pointer to the output buffer given in the      */
/*             parameters.                                    */
/**************************************************************/

static char * print_date(const char * source, char * buffer, unsigned int buflen)
{
  char * format = utils_strdup(choices.print_date_format);
  char   block[5];
  char * separator;

  if (!format || !buffer || buflen < 1) return buffer;;

  separator = format;

  /* The date format uses '!' instead of '%' so you don't have to worry */
  /* about (re-)escaping it for the Choices file when saving. Convert   */
  /* these to '%' now.                                                  */

  while (*separator != '\0')
  {
    if (*separator == '!')
    {
      char * marker = separator;
      char   tag[2];

      /* Special field */

      separator++;
      if (toupper(*separator) == 'Z') separator++;

      tag[0] = toupper(*separator);

      if (*separator != '\0')
      {
        tag[1] = toupper(*(separator + 1));
      }
      else
      {
        tag[1] = '\0';
      }

      if (
           !strncmp(tag, "12", 2) ||
           !strncmp(tag, "24", 2) ||
           !strncmp(tag, "AM", 2) ||
           !strncmp(tag, "CE", 2) ||
           !strncmp(tag, "CS", 2) ||
           !strncmp(tag, "DN", 2) ||
           !strncmp(tag, "DY", 2) ||
           !strncmp(tag, "M3", 2) ||
           !strncmp(tag, "MI", 2) ||
           !strncmp(tag, "MN", 2) ||
           !strncmp(tag, "MO", 2) ||
           !strncmp(tag, "PM", 2) ||
           !strncmp(tag, "SE", 2) ||
           !strncmp(tag, "ST", 2) ||
           !strncmp(tag, "TZ", 2) ||
           !strncmp(tag, "W3", 2) ||
           !strncmp(tag, "WE", 2) ||
           !strncmp(tag, "WK", 2) ||
           !strncmp(tag, "WN", 2) ||
           !strncmp(tag, "YR", 2)
         )
      {
        /* A legal looking field; change the field separator back to */
        /* a '%' sign.                                               */

        *marker = '%';
        separator += 2;
      }
      else if (*separator == '0')
      {
        /* Attempt to include ASCII zero. Remove this field. */

        memmove(marker, separator + 1, strlen(separator + 1) + 1);
      }
      else if (*separator == '!')
      {
        /* Attempt to include a literal "!" - remove one of these to */
        /* leave just the single literal character.                  */

        memmove(marker + 1, separator + 1, strlen(separator + 1) + 1);
      }
      else if (*separator == '%')
      {
        /* Attempt to include a literal '%' - just change the field */
        /* separator again.                                         */

        *marker = '%';
        separator++;
      }
    }
    else
    {
      separator++;
    }
  }

  /* If we've no date string, read the current date/time */

  if (!source)
  {
    block[0] = 3; /* OS_Word 14 sub-reason code, read soft-copy of CMOS clock as 5-byte integer */

    if (
         _swix(OS_Word,
               _INR(0,1),

               14, /* 14 - read CMOS clock */
               block)
       )
       memset(block, 0, sizeof(block));
  }
  else
  {
    // Not implemented yet

    memset(block, 0, sizeof(block));
  }

  /* Now convert it */

  if (
       _swix(OS_ConvertDateAndTime,
             _INR(0,3) | _OUT(1),

             block,
             buffer,
             buflen,
             format,

             &separator)
     )
  {
    *buffer = '\0';
  }
  else
  {
    if ((unsigned int) separator - (unsigned int) buffer >= buflen) buffer[buflen - 1] = '\0';
    else *separator = '\0';
  }

  /* Don't forget to free the strdup'd format string... */

  free(format);

  return buffer;
}

/**************************************************************/
/* print_build_formatted()                                    */
/*                                                            */
/* Builds a header or footer string based on the given format */
/* string into the given buffer.                              */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the header or footer;                          */
/*                                                            */
/*             Number of pages or 0 if unknown;               */
/*                                                            */
/*             Notional current page number;                  */
/*                                                            */
/*             Notional current section or NULL;              */
/*                                                            */
/*             Pointer to the buffer into which to build the  */
/*             string, or NULL to find the required size;     */
/*                                                            */
/*             Length of the buffer (ignored if pointer to    */
/*             buffer is NULL);                               */
/*                                                            */
/*             Pointer to the format string.                  */
/*                                                            */
/* Returns:    Pointer to the buffer you gave so it can be    */
/*             used in expressions directly for non-NULL      */
/*             buffer pointers, else the required size for    */
/*             the buffer in bytes including a NUL string     */
/*             terminator character, cast to 'char *'.        */
/**************************************************************/

static char * print_build_formatted
              (
                browser_data * b,
                unsigned int   pages,
                unsigned int   page,
                const char   * section,
                char         * buffer,
                size_t         buflen,
                const char   * format
              )
{
  char         * url   = browser_current_url(b);
  char         * title = browser_current_title(b);
  char         * start = buffer;
  unsigned int   total = 0;
  unsigned int   written;

  /* Simple checks, plus, if we've a non-NULL buffer, */
  /* make a recursive call to ensure that the buffer  */
  /* is big enough.                                   */

  if (
       !b      ||
       !format ||
       (
         buffer != NULL &&
         buflen < (size_t) print_build_formatted(b,
                                                 pages,
                                                 page,
                                                 section,
                                                 NULL,
                                                 0,
                                                 format)
       )
     )
  {
    if (buffer && buflen > 0) *buffer = '\0';
    return buffer == NULL ? (char *) sizeof('\0') : buffer;
  }

  if (!url)     url       = "";
  if (!section) section   = "";
  if (buffer)   buffer[0] = '\0';

  /* Step through the format string */

  while (*format)
  {
    /* Is this a formatting command? */

    if (*format == '!')
    {
      written = 0;

      /* Yes; advance the pointer to its first character */

      format++;

      switch (*format)
      {
        default:
        {
          /* Any unrecognised character implies an unrecognised or invalid */
          /* format string - just copy the character straight out to the   */
          /* output buffer.                                                */

          if (buffer) sprintf(buffer, "!%c", *format);
          written = 2;
        }
        break;

        /* Escaped characters */

        case '!':
        case '%':
        {
          if (buffer) sprintf(buffer, "%c", *format);
          written = 1;
        }
        break;

        /* The next few items all have a secondary character as a parameter */

        case 'p': /* Current page number */
        case 'P': /* Total page count    */
        {
          unsigned int value;
          char         number[128];

          if (*format == 'p') value = page;
          else                value = pages;

          format++;

          switch (*format)
          {
            default:
            {
              /* Unrecognised parameter - output the literal string */

              if (buffer) sprintf(buffer, "!p%c", *format);
              written = 3;
            }
            break;

            case '1': /* Ordinary numbers */
            {
              if (buffer) sprintf(buffer, "%d%n", page, &written);
              else written = utils_number_length(page);
            }
            break;

            case 'i': /* Lower case Roman numerals */
            {
              if (buffer) sprintf(buffer, "%s%n", print_roman(number, page, 0), &written);
              else written = strlen(print_roman(number, page, 0));

            }
            break;

            case 'I': /* Upper case Roman numerals */
            {
              if (buffer) sprintf(buffer, "%s%n", print_roman(number, page, 1), &written);
              else written = strlen(print_roman(number, page, 1));
            }
            break;

            case 'a': /* Lower case alphabetic count */
            {
              if (buffer) sprintf(buffer, "%s%n", print_alpha(number, page, 0), &written);
              else written = strlen(print_alpha(number, page, 0));
            }
            break;

            case 'A': /* Upper case alphabetic count */
            {
              if (buffer) sprintf(buffer, "%s%n", print_alpha(number, page, 1), &written);
              else written = strlen(print_alpha(number, page, 1));
            }
            break;
          }
        }
        break;

        case 't': /* Document title */
        {
          format++;

          switch (*format)
          {
            default:
            {
              /* Unrecognised parameter - output the literal string */

              if (buffer) sprintf(buffer, "!t%c", *format);
              written = 3;
            }
            break;

            case 'k': /* Title if known */
            case 'a': /* Title always   */
            {
              char * output = title ? title : (*format == 'a' ? url : "");

              if (buffer) sprintf(buffer, "%s%n", output, &written);
              else written = strlen(output);
            }
            break;
          }
        }
        break;

        case 'd': /* Dates */
        {
          char date[128];

          format++;

          switch (*format)
          {
            default:
            {
              /* Unrecognised parameter - output the literal string */

              if (buffer) sprintf(buffer, "!d%c", *format);
              written = 3;
            }
            break;

            case 'p': /* Date of printing */
            {
              if (buffer) sprintf(buffer, "%s%n", print_date(NULL, date, sizeof(date)), &written);
              else written = strlen(print_date(NULL, date, sizeof(date)));
            }
            break;

            case 'm': /* Date of document modification */
            {
              const char * modified = b->last_modified ? b->last_modified : "";

              if (buffer) sprintf(buffer, "%s%n", print_date(modified, date, sizeof(date)), &written);
              else written = strlen(print_date(modified, date, sizeof(date)));
            }
            break;
          }
        }
        break;

        /* The next few items have no secondary character */

        case 'u': /* Document URL */
        {
          if (buffer) sprintf(buffer, "%s%n", url, &written);
          else written += strlen(url);
        }
        break;

        case 's': /* Inferred section */
        {
          if (buffer) sprintf(buffer, "%s%n", section, &written);
          else written += strlen(section);
        }
        break;
      }

      /* Advance through the input and output buffers */

      if (buffer)  buffer += written;
      if (*format) format ++;

      total += written;
    }
    else
    {
      /* Not a special field, so just output the current character */

      if (buffer)
      {
        sprintf(buffer, "%c", *format);
        buffer++;
      }

      format ++;
      total  ++;
    }
  }

  if (buffer) return start;
  else        return (char *) (total + 1);
}

/**************************************************************/
/* print_header_and_footer_sizes()                            */
/*                                                            */
/* Via. the above header and footer code, return the height   */
/* of the header and height of the footer for the given       */
/* browser window.                                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page being printed;                        */
/*                                                            */
/*             Notional current page number;                  */
/*                                                            */
/*             Number of pages or 0 if unknown;               */
/*                                                            */
/*             Notional current section or NULL;              */
/*                                                            */
/*             Pointer to an int into which the header height */
/*             is written, in OS units;                       */
/*                                                            */
/*             Pointer to an int into which the footer height */
/*             is written, in OS units.                       */
/*                                                            */
/* Assumes:    Pointers are non-NULL and valid.               */
/**************************************************************/

static void print_header_and_footer_sizes(browser_data * b, unsigned int pages, unsigned int page,
                                          const char * section, int * header, int * footer)
{
  char buffer[Limits_Message]; /* Slightly arbitrary choice */
  int  ok;
  int  top, bot;

  if (!header || !footer) return;

  *header = *footer = 0;

  /* Set bit 0 of ok for a header, and bit 1 for a footer */

  ok = 0;

  if (choices.print_headers_from != 0)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_left);

    if (*buffer) ok = 1;
    else
    {
      print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_mid);

      if (*buffer) ok = 1;
      else
      {
        print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_right);
        if (*buffer) ok = 1;
      }
    }
  }

  if (choices.print_footers_from != 0)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_left);

    if (*buffer) ok |= 2;
    else
    {
      print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_mid);

      if (*buffer) ok |= 2;
      else
      {
        print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_right);

        if (*buffer) ok |= 2;
      }
    }
  }

  if (reformat_text_line_height(b, NULL, &top, &bot)) return;

  if ((ok & 1) != 0) *header = ((top + bot) * PrintHeaderAndFooterHeightMultiplier * choices.print_hf_scale) / 1000;
  if ((ok & 2) != 0) *footer = ((top + bot) * PrintHeaderAndFooterHeightMultiplier * choices.print_hf_scale) / 1000;

  return;
}

/**************************************************************/
/* print_header()                                             */
/*                                                            */
/* Given a page number and y coordinate, print a page header. */
/* The LeftMargin and RightMargin Choices file entries are    */
/* dealt with internally.                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page being printed;                        */
/*                                                            */
/*             Number of pages or 0 if unknown;               */
/*                                                            */
/*             Current page number;                           */
/*                                                            */
/*             Current section or NULL;                       */
/*                                                            */
/*             Y coordinate of top of header in OS units;     */
/*                                                            */
/*             Printable header width in OS units.            */
/**************************************************************/

static _kernel_oserror * print_header(browser_data * b, unsigned int pages, unsigned int page,
                                      const char * section, int header_y, int width)
{
  char buffer[Limits_Message];
  int  top, bot, h;
  int  lm,  rm;

  if (choices.print_headers_from == 0 || page < choices.print_headers_from) return NULL;
  if (reformat_text_line_height(b, NULL, &top, &bot))                       return NULL;

  convert_to_os(b->left_margin,  &lm);
  convert_to_os(b->right_margin, &rm);

  top = (top * choices.print_hf_scale) / 100;
  bot = (bot * choices.print_hf_scale) / 100;

  header_y -= top;
  h         = fm_find_font(b,
                           "serif",
                           (choices.font_size * choices.print_hf_scale) / 100,
                           (choices.font_size * choices.print_hf_scale) / 100,
                           choices.print_hf_italic,
                           choices.print_hf_bold);

  convert_to_points(width, &width);

  /* Left hand side's string */

  /* We print the left hand item on the left hand side if facing pages is "No" */
  /* or otherwise on any even numbered page.                                   */

  if (choices.print_facing_pages == Choices_PrintFacingPages_No || (page % 2) == 0)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_left);
  }

  /* If we reach here we're on an odd page. In that case, we don't print anything */
  /* if facing pages is "Spread" and print the right hand item if it is "Page".   */

  else if (choices.print_facing_pages == Choices_PrintFacingPages_Page)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_right);
  }
  else *buffer = '\0';

  if (*buffer != '\0')
  {
    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user(b, b->left_margin),
                             scale_os_to_user         (b, header_y),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  /* Centre string */

  print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_mid);

  if (*buffer)
  {
    int w;

    RetError(fm_get_string_width(h,
                                 buffer,
                                 width,          /* Not splitting anyway right now, but might one day... */
                                 strlen(buffer),
                                 -1,
                                 NULL,
                                 &w));

    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user(b, (width - w) / 2),
                             scale_os_to_user         (b, header_y),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  /* Right hand side's string */

  /* We print the right hand item on the right hand side if facing pages is "No" */
  /* or if it is "Page" and we're on an even page, or "Spread" and we're on an   */
  /* odd page.                                                                   */

  if (
       choices.print_facing_pages == Choices_PrintFacingPages_No
       ||
       (
         (page % 2) == 0 &&
         choices.print_facing_pages == Choices_PrintFacingPages_Page
       )
       ||
       (
         (page % 2) == 1 &&
         choices.print_facing_pages == Choices_PrintFacingPages_Spread
       )
     )
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_right);
  }

  /* We print the left hand item on the right hand side if facing pages is "Page" */
  /* and we're on an odd page.                                                    */

  else if (
            (page % 2) == 1 &&
            choices.print_facing_pages == Choices_PrintFacingPages_Page
          )
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_header_left);
  }
  else *buffer = '\0';

  if (*buffer)
  {
    int w;

    RetError(fm_get_string_width(h,
                                 buffer,
                                 width,          /* Not splitting anyway right now, but might one day... */
                                 strlen(buffer),
                                 -1,
                                 NULL,
                                 &w));

    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user (b, width - w - b->right_margin),
                             scale_os_to_user          (b, header_y),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  return NULL;
}

/**************************************************************/
/* print_footer()                                             */
/*                                                            */
/* Given a page number and y coordinate, print a page footer. */
/* The LeftMargin and RightMargin Choices file entries are    */
/* dealt with internally.                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page being printed;                        */
/*                                                            */
/*             Number of pages or 0 if unknown;               */
/*                                                            */
/*             Current page number;                           */
/*                                                            */
/*             Current section or NULL;                       */
/*                                                            */
/*             Y coordinate of top of footer in OS units;     */
/*                                                            */
/*             Printable footer width in OS units.            */
/**************************************************************/

static _kernel_oserror * print_footer(browser_data * b, unsigned int pages, unsigned int page,
                                      const char * section, int footer_y, int width)
{
  char buffer[Limits_Message];
  int  top, bot, h;
  int  lm,  rm;

  if (choices.print_footers_from == 0 || page < choices.print_footers_from) return NULL;
  if (reformat_text_line_height(b, NULL, &top, &bot))                       return NULL;

  convert_to_os(b->left_margin,  &lm);
  convert_to_os(b->right_margin, &rm);

  top = (top * choices.print_hf_scale) / 100;
  bot = (bot * choices.print_hf_scale) / 100;

  h = fm_find_font(b,
                   "serif",
                   (choices.font_size * choices.print_hf_scale) / 100,
                   (choices.font_size * choices.print_hf_scale) / 100,
                   choices.print_hf_italic,
                   choices.print_hf_bold);

  convert_to_points(width, &width);

  /* Left hand side's string */

  /* We print the left hand item on the left hand side if facing pages is "No" */
  /* or otherwise on any even numbered page.                                   */

  if (choices.print_facing_pages == Choices_PrintFacingPages_No || (page % 2) == 0)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_left);
  }

  /* If we reach here we're on an odd page. In that case, we don't print anything */
  /* if facing pages is "Spread" and print the right hand item if it is "Page".   */

  else if (choices.print_facing_pages == Choices_PrintFacingPages_Page)
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_right);
  }
  else *buffer = '\0';

  if (*buffer != '\0')
  {
    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user(b, b->left_margin),
                             scale_os_to_user         (b, bot),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  /* Centre string */

  print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_mid);

  if (*buffer)
  {
    int w;

    RetError(fm_get_string_width(h,
                                 buffer,
                                 width,          /* Not splitting anyway right now, but might one day... */
                                 strlen(buffer),
                                 -1,
                                 NULL,
                                 &w));

    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user(b, (width - w) / 2),
                             scale_os_to_user         (b, bot),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  /* Right hand side's string */

  /* We print the right hand item on the right hand side if facing pages is "No" */
  /* or if it is "Page" and we're on an even page, or "Spread" and we're on an   */
  /* odd page.                                                                   */

  if (
       choices.print_facing_pages == Choices_PrintFacingPages_No
       ||
       (
         (page % 2) == 0 &&
         choices.print_facing_pages == Choices_PrintFacingPages_Page
       )
       ||
       (
         (page % 2) == 1 &&
         choices.print_facing_pages == Choices_PrintFacingPages_Spread
       )
     )
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_right);
  }

  /* We print the left hand item on the right hand side if facing pages is "Page" */
  /* and we're on an odd page.                                                    */

  else if (
            (page % 2) == 1 &&
            choices.print_facing_pages == Choices_PrintFacingPages_Page
          )
  {
    print_build_formatted(b, pages, page, section, buffer, sizeof(buffer), choices.print_footer_left);
  }
  else *buffer = '\0';

  if (*buffer)
  {
    int w;

    RetError(fm_get_string_width(h,
                                 buffer,
                                 width,          /* Not splitting anyway right now, but might one day... */
                                 strlen(buffer),
                                 -1,
                                 NULL,
                                 &w));

    RetError(redrawcore_text(b,
                             h,
                             scale_millipoints_to_user (b, width - w - b->right_margin),
                             scale_os_to_user          (b, bot),
                             buffer,
                             0,
                             Redraw_Colour_Black, Redraw_Colour_White,
                             0));
  }

  return NULL;
}

/**************************************************************/
/* print_count_pages()                                        */
/*                                                            */
/* MAINTENANCE WARNING - ANY ALTERATIONS TO PRINT_PAGE WILL   */
/* NEED ECHOING HERE IF IN AN ANALOGOUS CODE SECTION.         */
/*                                                            */
/* Count the number of pages that are about to be printed.    */
/* This is an internal service routine for print_page and     */
/* derives its core code from that function; as a result, a   */
/* lot of in-progress data in print_page has to be thrown in  */
/* through the following rather long parameter list.          */
/*                                                            */
/* The basic premise is to simulate a print and redraw loop   */
/* and return the final page count. It works pretty well.     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to be printed;                        */
/*                                                            */
/*             Where to end - End_Whole, End_Visible or       */
/*             End_Many (as defined at the top of the file);  */
/*                                                            */
/*             For End_Many, how many sheets to fill;         */
/*                                                            */
/*             In-use left margin position in millipoints;    */
/*                                                            */
/*             In-use right margin position in millipoints;   */
/*                                                            */
/*             In-use top margin position in millipoints;     */
/*                                                            */
/*             In-use bottom margin position in millipoints;  */
/*                                                            */
/*             Offset from top of document to get to top of   */
/*             currently visible region in OS units, positive */
/*             downwards;                                     */
/*                                                            */
/*             Offset from top of document to get to bottom   */
/*             of currently visible region in OS units,       */
/*             positive downwards.                            */
/*                                                            */
/* Returns:    The number of pages that will be printed.      */
/**************************************************************/

static unsigned int print_count_pages(browser_data * b, int end, int to, int lmarg, int rmarg,
                                      int tmarg, int bmarg, int top, int bottom)
{
  WimpRedrawWindowBlock redraw;
  unsigned int          page = 0;
  int                   temp;
  int                   round;
  int                   next_line;
  BBox                  last_rect;

  /* We'll use an empty table to draw nothing in the redraw loop */

  redrawcore_function_table_t empty_table;
  memset(&empty_table, 0, sizeof(empty_table));

  /* For more comments, see the inner print loop in print_page. */

  next_line      = 0;
  redraw.xscroll = 0;
  redraw.yscroll = -top;

  convert_to_points(1, &round);
  round /= 2;

  /* Set the empty redraw table up */

  redrawcore_replace_table(&empty_table);

  /* Redraw loop */

  while (
          (
            end == End_Many &&
            page < to
          )
          ||
          (
            end != End_Many
          )
        )
  {
    page ++;

    /* Set up the Redraw block ready for the calls to redraw_draw */

    redraw.visible_area.xmax = rmarg - lmarg;
    redraw.visible_area.xmin = 0;

    convert_to_os(redraw.visible_area.xmax, &redraw.visible_area.xmax);
    convert_to_os(tmarg - bmarg,            &temp); /* 'temp' now holds the printable page height in OS units */

    if (end != End_Visible)
    {
      redraw.visible_area.ymax = temp,
      redraw.visible_area.ymin = 0;
    }
    else
    {
      if (next_line != 0 && bottom != 0) bottom -= (redraw.yscroll - next_line);

      if (bottom - top > temp) /* And *not* '>= temp'! See 'else' code below */
      {
        redraw.visible_area.ymax = temp;
      }
      else
      {
        redraw.visible_area.ymax = bottom - top;
        bottom = 0;
      }

      redraw.visible_area.ymin = 0;
    }

    if (next_line != 0)
    {
      redraw.yscroll = next_line;
      next_line      = 0;
    }

    /* Imaginary call to PDriver_DrawPage */

    redraw.redraw_area.xmin = 0;
    redraw.redraw_area.ymin = 0;

    convert_pair_to_os(rmarg - lmarg + round,
                       tmarg - bmarg + round,
                       &redraw.redraw_area.xmax,
                       &redraw.redraw_area.ymax);

    /* The redraw loop itself */

    last_rect.xmin = last_rect.xmax = last_rect.ymin = last_rect.ymax = 0;

    /* Do the imaginary redraw */

    (void) redraw_draw(b,
                       &redraw,
                       &next_line,
                       0,
                       NULL);

    /* If we should print down to the bottom of the visible */
    /* area of the page, this is flagged with 'end' set to  */
    /* End_Visible; if 'bottom' is zero as well, there's    */
    /* nothing more to print.                               */

    if (end == End_Visible && !bottom) break;

    /* If next_line is 0, redraw_draw must not have found any */
    /* lines that fell off the bottom of the page - so there  */
    /* cannot be any more pages.                              */

    if (next_line == 0) break;

    /* Otherwise, close the outer while loop - which */
    /* may mean we loop for another page.            */
  }

  /* Restore the redraw table and return the page count */

  redrawcore_default_table();
  return page;
}

/**************************************************************/
/* print_find_splitting_point()                               */
/*                                                            */
/* Service routine for print_fake_redraw and redraw_draw_r.   */
/* Given a reformat cell, line number within it and page      */
/* dimensions, works out if a new page should be started.     */
/*                                                            */
/* Parameters: Pointer to the reformat_cell being printed     */
/*             (really this should always be top level);      */
/*                                                            */
/*             Notional y coord origin of cell in OS units;   */
/*                                                            */
/*             Current line number within the cell;           */
/*                                                            */
/*             Page bottom y coordinate in OS units;          */
/*                                                            */
/*             Page height in OS units;                       */
/*                                                            */
/*             Pointer to an int updated with the y coord     */
/*             split point (OS units, negative down from 0).  */
/*                                                            */
/*             Pointer to an int updated with 1 if the        */
/*             inferred section should be stored through the  */
/*             returned token, else 0.                        */
/*                                                            */
/* Returns:    Pointer to the token that will be used on the  */
/*             first line of the new page if a split point is */
/*             found, with the given int updated with the y   */
/*             coordinate; else NULL.                         */
/*                                                            */
/* Assumes:    All pointers are non-NULL and valid.           */
/**************************************************************/

HStream * print_find_splitting_point(const reformat_cell * d, int osyorg, int l, int page_bottom, int page_height,
                                     int * split_y, int * store)
{
  int page_top = page_bottom + page_height;

  *store = 0;

  /* Printing page split rules: First, simple "line drops off page" rule. */
  /* For large lines - e.g. very big images, tables, or lines taller than */
  /* the whole page - we either should, or in the latter case must, split */
  /* that line. So, if the line is taller than 1/PrintSplitFraction of    */
  /* the page height, it will be split over the page boundary. This 'if'  */
  /* checks to see if it should *NOT* be split, and if not, returns an    */
  /* a y-coordinate to start the next page on which is the top of the     */
  /* line we reckon shouldn't be split in two.                            */

  if (osyorg + d->ldata[l].y < page_bottom)
  {
    int remaining; /* Not unsigned, as line "l-1" might be taller than the page too! */

    if (l > 0) remaining = osyorg + d->ldata[l - 1].y - page_bottom;
    else       remaining = page_height;

    // Old logic - if line itself is <= 100/PrintSplitFraction, don't split it. Bad
    // as there's nothing wrong with dropping tall lines to the next page if they
    // only leave a tiny gap.
    //
    // if (d->ldata[l].h <= ((page_height * 100) / PrintSplitFraction)) /* (See Print.h) */

    if (remaining <= ((page_height * 100) / PrintSplitFraction)) /* (See Print.h) */
    {
      HStream * t1 = d->cdata[d->ldata[l].chunks].t;

      /* Set a split point equivalent to just above the top of this line, so */
      /* that we drop it to the next page. Lines can have gaps between them, */
      /* so the top of one line doesn't necessarily mean the bottom of the   */
      /* line preceeding it - so don't change this code to look at "l-1"'s   */
      /* y-coordinate, for example.                                          */

      *split_y = osyorg + d->ldata[l].y + d->ldata[l].h;

      if (
           choices.print_page_break_hx > 0 &&
           reformat_istext(t1)             &&
           redraw_header(t1->style) > 0    &&
           redraw_header(t1->style) <= choices.print_page_break_hx
         )
         *store = 1;

      return t1;
    }
  }

  /* ...with "line fits on *exactly*" adjustment. */

  else if (
            osyorg + d->ldata[l].y == page_bottom &&
            l + 1 < d->nlines
          )
  {
    HStream * t1 = d->cdata[d->ldata[l + 1].chunks].t;

    *split_y = osyorg + d->ldata[l + 1].y + d->ldata[l + 1].h;

    if (
         choices.print_page_break_hx > 0 &&
         reformat_istext(t1)             &&
         redraw_header(t1->style) > 0    &&
         redraw_header(t1->style) <= choices.print_page_break_hx
       )
       *store = 1;

    return t1;
  }

  /* Trying to get clever now. Here we look one line ahead, and see if */
  /* this line would fall off the page. If so, then should we allow it */
  /* to get seperated from the current line, or should we put *both*   */
  /* onto the next side? (Above caveat on fraction of page gap left    */
  /* applies).                                                         */

  /* Note that the "gap <= fraction of page height" stuff must be a signed */
  /* comparison this time, as line "l" may have its base off the bottom of */
  /* the page if (so far, at least) we're thinking of splitting it rather  */
  /* than carrying it to the next page.                                    */

  if (
       (l + 1 < d->nlines)                                               &&
       osyorg + d->ldata[l + 1].y < page_bottom                          &&
       (osyorg + d->ldata[l].y - page_bottom <= ((page_height * 100) / PrintSplitFraction))
     )
// Was (d->ldata[l + 1].h <= ((page_height * 100) / PrintSplitFraction))
  {
    HStream * t1 = d->cdata[d->ldata[l].chunks].t;
    HStream * t2 = d->cdata[d->ldata[l + 1].chunks].t;

    /* If current line is a heading and next line isn't, or current line */
    /* is a definition list term (heading) and the next line is data,    */
    /* then don't split up the two lines.                                */

    if (
         reformat_istext(t1) &&
         (
           (
             ((t1->style & H_MASK) != 0) &&
             (
               (t2->style & H_MASK) == 0 ||
               !reformat_istext(t2)
             )
           )
           ||
           (
             ((t1->style & DT) != 0) &&
             ((t2->style & DD) != 0)
           )
         )
       )
    {
      *split_y = osyorg + d->ldata[l].y + d->ldata[l].h;

      if (
           choices.print_page_break_hx > 0 &&
           reformat_istext(t1)             &&
           redraw_header(t1->style) > 0    &&
           redraw_header(t1->style) <= choices.print_page_break_hx
         )
         *store = 1;

      return t1;
    }
  }

  /* There's also a case for look-behind. If this line is heading 1 or 2 */
  /* and the previous wasn't, start a new page here.                     */

  if (l > 0 && choices.print_page_break_hx != 0)
  {
    int       scan = l - 1;

    HStream * t1   = d->cdata[d->ldata[scan].chunks].t;
    HStream * t2   = d->cdata[d->ldata[l].chunks].t;

    int       h1;
    int       h2;

    if (reformat_istext(t2))
    {
      /* The previous line might not be useful (e.g. two H2s in a row */
      /* would have a dummy tag in between occuping a zero height     */
      /* line of its own). So we need to scan backwards to get a      */
      /* useful token.                                                */

      while (
              t1 != NULL &&
              (
                reformat_istext(t1) &&
                t1->text == NULL
              )
              && --scan >= 0
            )
            t1 = d->cdata[d->ldata[scan].chunks].t;

      h1 = reformat_istext(t1) ? redraw_header(t1->style) : 0;
      h2 = redraw_header(t2->style);

      if (
           osyorg + d->ldata[scan].y < page_top &&
//           osyorg + d->ldata[scan].y + d->ldata[scan].h <= page_top
//           &&
           (
             h1 > choices.print_page_break_hx ||
             h1 == 0
           )
           && h2 <= choices.print_page_break_hx
           && h2 > 0
         )
      {
        *split_y = osyorg + d->ldata[l].y + d->ldata[l].h;
        *store   = 1;

        return t2;
      }
    }
  }

  /* No split point found */

  return NULL;
}

/**************************************************************/
/* print_set_hourglass_by_area()                              */
/*                                                            */
/* Give a percentage completed indicator. This is first based */
/* on the current page being printed, so there's some scaling */
/* of the 100% range to cope with the fact that if you're on  */
/* page 3 of 4, the variation must be between 50% and 75%,    */
/* for example. Since rectangle order cannot be relied upon,  */
/* need to use the area printed so far for the calculation.   */
/* This may fail under unusual circumstances, and certainly   */
/* is not fully accurate as the rectangles always overlap by  */
/* a small amount (the printer driver gives room for rounding */
/* errors by overlapping the rectangles) but in any case      */
/* there will at least be some kind of percentage indication! */
/* With bit image printing, which can be painfully slow, this */
/* is extremely important.                                    */
/*                                                            */
/* There is an attempt to correct for overlapping rectangles  */
/* which works if this one and the last were overlapping.     */
/*                                                            */
/* Parameters: Pointer to a BBox holding the redraw rectangle */
/*             in OS units;                                   */
/*                                                            */
/*             Pointer to a BBox holding the previous redraw  */
/*             rectangle in OS units, for intersections (set  */
/*             all fields to 0 if there is no previous box);  */
/*                                                            */
/*             Total number of pages;                         */
/*                                                            */
/*             Current page number;                           */
/*                                                            */
/*             Area of the complete visible page in square    */
/*             OS units;                                      */
/*                                                            */
/*             Current cumulative area printed on this page   */
/*             in square OS units (set to 0 at start of each  */
/*             new page).                                     */
/*                                                            */
/* Returns:    Updated cumulative printed area.               */
/**************************************************************/

static unsigned int print_set_hourglass_by_area
                    (
                      BBox         * redraw_rect,
                      BBox         * last_rect,
                      unsigned int   pages,
                      unsigned int   page,
                      unsigned int   page_area,
                      unsigned int   completed_area
                    )
{
  BBox i;
  int  this_area;
  int  percent;

  /* Calculate the area of the redraw rectangle */

  this_area = (redraw_rect->xmax - redraw_rect->xmin) *
              (redraw_rect->ymax - redraw_rect->ymin);


  /* If this intersects with the last redraw rectangle, */
  /* subtract the area of the intersection.             */

  if (utils_intersection(redraw_rect, last_rect, &i))
  {
    this_area -= (i.xmax - i.xmin) *
                 (i.ymax - i.ymin);
  }

  completed_area += this_area;
  if (completed_area > page_area) completed_area = page_area;

  percent = (100 * (page - 1)) / pages +
            ((100 / pages) * completed_area) / page_area;

  if (percent < 0)  percent = 0;
  if (percent > 99) percent = 99;

  (void) _swix(Hourglass_Percentage,
              _IN(0),

              percent);

  return completed_area;
}
@


1.22
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@d43 1
d152 1
a152 2
static char            * print_build_formatted         (browser_data * b, unsigned int pages, unsigned int page, const char * section, char * buffer, unsigned int buflen, const char * format);
static unsigned int      print_count_formatted         (browser_data * b, unsigned int pages, unsigned int page, const char * section, const char * format);
d2424 1
a2424 1
  while (*separator)
d2426 76
a2501 2
    if (*separator == '!') *separator = '%';
    separator++;
d2570 2
a2571 1
/*             Pointer to the buffer to build in;             */
d2573 2
a2574 1
/*             Length of the buffer;                          */
d2579 4
a2582 1
/*             used in expressions directly.                  */
d2592 1
a2592 1
                unsigned int   buflen,
d2596 9
a2604 6
  char          * url   = browser_current_url(b);
  char          * title = browser_current_title(b);

  char            tag   [3];
  char            roman [128];
  unsigned int    written;
d2607 12
a2618 6
       !b         ||
       !format    ||
       !buffer    ||
       buflen < 1 ||

       print_count_formatted(b, pages, page, section, format) >= buflen
d2622 1
a2622 1
    return buffer;
d2625 3
a2627 4
  if (!url) url = "";

  tag   [2] = '\0';
  buffer[0] = '\0';
d2637 2
d2643 1
a2643 1
      if (*format == '\0')
d2645 5
a2649 2
        /* If we reached the terminator, the format string is of invalid syntax, */
        /* and we just output the percentage sign that the string ended in       */
d2651 4
a2654 7
        sprintf(buffer, "!");
        buffer++;
      }
      else
      {
        /* Otherwise, record the character and advance the pointer. Record that  */
        /* character too, and if not a terminator, advance the pointer once more */
d2656 1
a2656 2
        tag[0] = *format, format++;
        tag[1] = *format;
d2658 7
a2664 1
        if (*format != '\0') format++;
d2666 1
a2666 2
        /* The first letter of a single character tag is unique so check those */
        /* first, then go on to look at the two character versions             */
d2668 2
a2669 1
        if (*tag == '!')
d2671 5
a2675 2
          sprintf(buffer, "!");
          buffer++;
d2677 1
a2677 10
          if (tag[1] != '\0')
          {
            sprintf(buffer, "%c", tag[1]);
            buffer++;
          }
        }
        else if (*tag == 's')
        {
          sprintf(buffer, "%s%n", section ? section : "", &written);
          buffer += written;
d2679 1
a2679 1
          if (tag[1] != '\0')
d2681 3
a2683 8
            sprintf(buffer, "%c", tag[1]);
            buffer++;
          }
        }
        else if (*tag == 'u')
        {
          sprintf(buffer, "%s%n", url, &written);
          buffer += written;
d2685 4
a2688 26
          if (tag[1] != '\0')
          {
            sprintf(buffer, "%c", tag[1]);
            buffer++;
          }
        }
        else
        {
          if      (!strcmp(tag, "p1")) sprintf(buffer, "%d%n", page, &written);
          else if (!strcmp(tag, "pi")) sprintf(buffer, "%s%n", print_roman(roman, page, 0), &written);
          else if (!strcmp(tag, "pI")) sprintf(buffer, "%s%n", print_roman(roman, page, 1), &written);
          else if (!strcmp(tag, "pa")) sprintf(buffer, "%s%n", print_alpha(roman, page, 0), &written);
          else if (!strcmp(tag, "pA")) sprintf(buffer, "%s%n", print_alpha(roman, page, 1), &written);

          else if (!strcmp(tag, "P1")) sprintf(buffer, "%d%n", pages, &written);
          else if (!strcmp(tag, "Pi")) sprintf(buffer, "%s%n", print_roman(roman, pages, 0), &written);
          else if (!strcmp(tag, "PI")) sprintf(buffer, "%s%n", print_roman(roman, pages, 1), &written);
          else if (!strcmp(tag, "Pa")) sprintf(buffer, "%s%n", print_alpha(roman, pages, 0), &written);
          else if (!strcmp(tag, "PA")) sprintf(buffer, "%s%n", print_alpha(roman, pages, 1), &written);

          else if (!strcmp(tag, "tk")) sprintf(buffer, "%s%n", title ? title : "", &written);
          else if (!strcmp(tag, "ta")) sprintf(buffer, "%s%n", title ? title : url, &written);

          else if (!strcmp(tag, "dp")) sprintf(buffer, "%s%n", print_date(NULL, roman, sizeof(roman)), &written);
          else if (!strcmp(tag, "dm")) sprintf(buffer, "%s%n", print_date(b->last_modified ? b->last_modified : "", roman, sizeof(roman)), &written);
          else                         sprintf(buffer, "!%s%n", tag, &written);
d2690 6
a2695 7
          buffer += written;
        }
      }
    }
    else
    {
      /* No, so just output the current character and advance the pointer */
d2697 4
a2700 4
      sprintf(buffer, "%c", *format++);
      buffer++;
    }
  }
d2702 2
a2703 2
  return buffer;
}
d2705 6
a2710 21
/**************************************************************/
/* print_count_formatted()                                    */
/*                                                            */
/* Return the string length that print_build_formatted()      */
/* would construct, not including the NUL terminator.         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the header or footer;                          */
/*                                                            */
/*             Number of pages or 0 if unknown;               */
/*                                                            */
/*             Notional current page number;                  */
/*                                                            */
/*             Notional current section or NULL;              */
/*                                                            */
/*             Pointer to the format string.                  */
/*                                                            */
/* Returns:    Length of the string that                      */
/*             print_count_formatted() would construct, not   */
/*             including the NUL terminator.                  */
/**************************************************************/
d2712 6
a2717 5
static unsigned int print_count_formatted(browser_data * b, unsigned int pages, unsigned int page,
                                          const char * section, const char * format)
{
  char         * url   = browser_current_url(b);
  char         * title = browser_current_title(b);
d2719 9
a2727 3
  char           tag   [3];
  char           roman [128];
  unsigned int   count;
d2729 3
a2731 2
  if (!b || !format) return 0;
  if (!url) url = "";
d2733 5
a2737 2
  tag[2] = '\0';
  count  = 0;
d2739 4
a2742 1
  /* Step through the format string */
d2744 4
a2747 3
  while (*format)
  {
    /* Is this a formatting command? */
d2749 7
a2755 3
    if (*format == '!')
    {
      /* Yes; advance the pointer to its first character */
d2757 3
a2759 1
      format++;
d2761 1
a2761 4
      if (*format == '\0')
      {
        /* If we reached the terminator, the format string is of invalid syntax, */
        /* and we just count the percentage sign that the string ended in        */
d2763 5
a2767 6
        count++;
      }
      else
      {
        /* Otherwise, record the character and advance the pointer. Record that  */
        /* character too, and if not a terminator, advance the pointer once more */
d2769 4
a2772 2
        tag[0] = *format, format++;
        tag[1] = *format;
d2774 6
a2779 1
        if (*format != '\0') format++;
d2781 3
a2783 2
        /* The first letter of a single character tag is unique so check those */
        /* first, then go on to look at the two character versions             */
d2785 5
a2789 4
        if (*tag == '!')
        {
          count++;
          if (tag[1] != '\0') count++;
d2791 5
a2795 1
        else if (*tag == 's')
d2797 2
a2798 2
          count += strlen(section ? section : "");
          if (tag[1] != '\0') count++;
d2800 3
a2802 1
        else if (*tag == 'u')
d2804 2
a2805 23
          count += strlen(url);
          if (tag[1] != '\0') count++;
        }
        else
        {
          if      (!strcmp(tag, "p1")) count += utils_number_length(page);
          else if (!strcmp(tag, "pi")) count += strlen(print_roman(roman, page, 0));
          else if (!strcmp(tag, "pI")) count += strlen(print_roman(roman, page, 1));
          else if (!strcmp(tag, "pa")) count += strlen(print_alpha(roman, page, 0));
          else if (!strcmp(tag, "pA")) count += strlen(print_alpha(roman, page, 1));

          else if (!strcmp(tag, "p1")) count += utils_number_length(pages);
          else if (!strcmp(tag, "pi")) count += strlen(print_roman(roman, pages, 0));
          else if (!strcmp(tag, "pI")) count += strlen(print_roman(roman, pages, 1));
          else if (!strcmp(tag, "pa")) count += strlen(print_alpha(roman, pages, 0));
          else if (!strcmp(tag, "pA")) count += strlen(print_alpha(roman, pages, 1));

          else if (!strcmp(tag, "tk")) count += strlen(title ? title : "");
          else if (!strcmp(tag, "ta")) count += strlen(title ? title : url);

          else if (!strcmp(tag, "dp")) count += strlen(print_date(NULL, roman, sizeof(roman)));
          else if (!strcmp(tag, "dm")) count += strlen(print_date(b->last_modified ? b->last_modified : "", roman, sizeof(roman)));
          else                         count += 1 + strlen(tag);
d2807 1
d2809 7
d2819 7
a2825 1
      /* No, so just count the current character and advance the pointer */
d2827 2
a2828 1
      count++, format++;
d2832 2
a2833 1
  return count;
@


1.21
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d67 1
d69 3
d90 7
a96 6
  int            copies;          /* Number of copies to print.                                                        */
  int            pages;           /* If 'end' is 2, the number of pages to fill.                                       */
  unsigned int   end          :2; /* 0 = whole page, 1 = to bottom of visible area, 2 = for 'pages' pages.             */
  unsigned int   start        :1; /* 1 = whole page, 0 = top of visible area.                                          */
  unsigned int   reformat     :1; /* 1 = reformat to fit page (if start is not 0 and end is not -1), else don't.       */
  unsigned int   orientation  :1; /* 1 = portrait, 0 = landscape.                                                      */
d143 4
d154 2
a155 2
static void              print_header                  (browser_data * b, unsigned int pages, unsigned int page, const char * section, int header_y, int width);
static void              print_footer                  (browser_data * b, unsigned int pages, unsigned int page, const char * section, int footer_y, int width);
d158 2
a159 1
static void              print_fake_redraw             (browser_data * b, WimpRedrawWindowBlock * r);
d242 11
d302 4
d368 3
a370 1
    /* Reformat - 'yes' or 'no', default to 'yes' */
d372 2
a373 1
    contents.reformat = choices.print_reform;
d575 4
a578 1
  /* If defaults have never been set before, set them now */
d580 8
a587 1
  print_set_defaults();
d621 1
a621 1
  /* First stage of printing protocol: Broadcast a PrintSave message */
d623 25
a647 1
  ChkError(protocols_pp_send_print_save());
d860 5
d869 1
a869 1
void print_print(const char * path)
d875 1
a875 1
  if (!ancestor_browser) return;
d909 2
d948 11
a958 2
static _kernel_oserror * print_page(browser_data * b, int copies, int from, int end, int to,
                                    int reformat, int orientation, const char * path)
d964 6
a969 1
  BBox                    box, last_rect;
d975 7
d983 2
a984 1
  int                     page_area,      area_completed;
a985 3
  int                     lmarg,          bmarg;
  int                     rmarg,          tmarg;
  int                     header,         footer;
d990 15
a1004 2
  int                     portrait  [2] [2] = { {0x10000,  0}, {0, 0x10000} };
  int                     landscape [2] [2] = { {0, -0x10000}, {0x10000, 0} };
d1024 1
a1024 1
            _OUTR(3,6),
d1026 2
d1035 1
a1035 2
  /* If in landscape mode, want to treat the margins */
  /* in a reversed sense.                            */
d1037 9
a1045 1
  if (!orientation)
d1047 43
a1089 2
    Swap(tmarg,rmarg);
    Swap(bmarg,lmarg);
d1096 6
a1101 1
  print_header_and_footer_sizes(b, 1, 1, NULL, &header, &footer);
d1103 1
a1103 1
  /* Clear any stored inferred section title for headers/footers */
d1105 1
a1105 1
  free(b->inferred_section), b->inferred_section = NULL;
d1107 2
a1108 1
  /* Convert to millipoints and modify the top/bottom margins accordingly */
d1110 6
d1117 2
a1118 6
    int hmp, fmp;

    convert_pair_to_points(header, footer, &hmp, &fmp);

    tmarg -= hmp;
    bmarg += fmp;
a1136 27
    int leds = 1;

    /* Reformat the page ready for printing. It used to be possible to do all of */
    /* this in a separate browser_data structure and, being careful about flex,  */
    /* reformat in that 'virtual' browser. This enabled reformatting internally  */
    /* not to affect the main browser page.                                      */
    /*                                                                           */
    /* Tables, however, screwed this up big time. Table cells were malloced, but */
    /* no record of this was kept, in the first cut of the code. So in the end,  */
    /* the address of the cell array was kept in the HStream defining the table. */
    /* However, you can only have one user of that at any one time...            */
    /*                                                                           */
    /* Four solutions to this (where NA = Not Acceptable):                       */
    /*                                                                           */
    /* 1. Get rid of the 'reformat to fit page' option (NA)                      */
    /* 2. Only allow the above when there are no tables on the page (NA)         */
    /* 3. Copy the entire token stream as well as the flex data (NA)             */
    /* 4. Reformat in the actual browser and have it reformat again afterwards.  */
    /*                                                                           */
    /* Since 1 to 3 aren't acceptable - 3 mostly because not only is it a lot of */
    /* memory to have to find, but it's in malloc space -> WimpSlot problems -   */
    /* only 4 is left. So this is what we now do here. Consequently, lots of     */
    /* bits of the browser_data structure have to be copied away and restored    */
    /* later, which can get quite messy.                                         */
    /*                                                                           */
    /* The fact that option 4 was chosen doesn't mean it isn't hideous...        */

d1140 1
a1140 34
    /* Now call the reformatter, and loop round until finished. */

    if (!from) markers_remember_position(b);

    e = reformat_format_from(b, -1, 1, -1);
    if (e) return e;

    while (reformat_formatting(b))
    {
      reformat_reformatter(b);

      if (!from) browser_check_for_request(b);

      /* It is virtually impossible to assess progress without */
      /* doing something time consuming like scan the token    */
      /* list and work out how far down it we are, compared to */
      /* the whole length. Instead, alternate the LEDs - this  */
      /* fits in well with what the table reformatter code     */
      /* will be doing with the hourglass.                     */

      leds ^= 3;

      _swix(Hourglass_LEDs,
            _INR(0,1),

            3,
            leds);
    }

    _swix(Hourglass_LEDs,
          _INR(0, 1),

          0,
          0);
d1144 1
a1144 1
  localbrowser.use_source_cols = 0;
d1146 3
a1148 1
  /* Open up the output stream */
d1150 2
a1151 2
  e = _swix(OS_Find,
            _INR(0,1) | _OUT(0),
d1153 2
a1154 2
            0x8F,
            path ? path : "printer:",
d1156 1
a1156 1
            &job);
d1158 1
a1158 1
  if (e) goto out3;
d1160 1
a1160 1
  globaljob = job;
d1162 2
a1163 2
  /* Stop the C library intercepting Escape, since */
  /* this should be left to the print SWIs.        */
d1165 1
a1165 1
  old_sigint_handler = signal(SIGINT, SIG_IGN);
d1167 1
a1167 1
  /* Start up the printing system */
d1169 2
a1170 2
  e = _swix(PDriver_SelectJob,
            _INR(0,1) | _OUT(0),
d1172 2
a1173 2
            job,
            lookup_token("PJobName:Web page",0,0),
d1175 1
a1175 1
            &old_job);
d1177 1
a1177 1
  if (e) goto out1;
d1179 1
a1179 1
  globalold_job = old_job;
d1181 1
a1181 1
  /* Declare fonts that have been used */
d1183 7
a1189 1
  if (features & Browser_Printer_DeclareFont)
d1191 3
a1193 1
    fm_face h;
d1195 1
a1195 3
    /* If using system font, only the system faces will be */
    /* used; otherwise, need to declare the sans, serif    */
    /* and fixed faces.                                    */
d1197 2
a1198 6
    if (!choices.system_font)
    {
      h = fm_find_font(NULL, "sans",   192,192,0,0); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "sans",   192,192,1,0); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "sans",   192,192,0,1); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "sans",   192,192,1,1); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
d1200 1
a1200 4
      h = fm_find_font(NULL, "serif",  192,192,0,0); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "serif",  192,192,1,0); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "serif",  192,192,0,1); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "serif",  192,192,1,1); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
d1202 4
a1205 4
      h = fm_find_font(NULL, "fixed",  192,192,0,0); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "fixed",  192,192,1,0); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "fixed",  192,192,0,1); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "fixed",  192,192,1,1); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
a1206 11

    /* Finish declaring fonts */

    e = _swix(PDriver_DeclareFont,
              _INR(0,2),

              0,
              0,
              2);

    if (e) goto out2;
a1208 5
  /* Set the bottom left hand corner of the rectangle to redraw */

  box.xmin = orientation ? lmarg : bmarg;
  box.ymin = orientation ? bmarg : rmarg;

d1215 2
a1216 3
  {
    WimpGetWindowStateBlock state;
    int                     htop, hbot;
d1218 1
a1218 3
    state.window_handle = b->window_handle;
    e = wimp_get_window_state(&state);
    if (e) goto out2;
d1220 1
a1220 1
    /* Get the basic offsets */
d1222 4
a1225 33
    top    = -state.yscroll;
    bottom = state.visible_area.ymax - state.visible_area.ymin;

    /* Correct for toolbar presence */

    if (!controls.swap_bars)
    {
      htop = toolbars_button_height(b) + toolbars_url_height(b);
      hbot = toolbars_status_height(b);
    }
    else
    {
      htop = toolbars_status_height(b);
      hbot = toolbars_button_height(b) + toolbars_url_height(b);
    }

    if (htop) htop += wimpt_dy();
    if (hbot) hbot += wimpt_dy();

    top    += htop;
    bottom -= (htop + hbot - top);

    /* If 'from' is non-zero, want to print from the top of the whole   */
    /* page; else from the top of the visible area as worked out above. */

    if (from) top = htop;
  }

  redraw.yscroll = -top;
  redraw.xscroll = 0;

  /* Work out how many pages we have. Cue flat service, small nut, and */
  /* large sledge hammer.                                              */
d1237 2
a1238 4
  /* Loop round for all pages. The y scroll position is set */
  /* initially to be correct for the place we want to print */
  /* from, and xscroll is set to 0 to mark that no calls    */
  /* to redraw_draw have happened yet.                      */
d1240 8
a1247 1
  page = 0;
d1260 3
a1262 1
    page ++;
d1282 8
a1289 2
        stored_section = utils_strdup(b->inferred_section);
        free(b->inferred_section), b->inferred_section = NULL;
d1293 33
a1325 1
    /* Set up the Redraw block ready for the calls to redraw_draw */
d1327 2
a1328 2
    redraw.visible_area.xmax = rmarg - lmarg;
    redraw.visible_area.xmin = 0;
d1330 1
a1330 1
    convert_to_os(redraw.visible_area.xmax, &redraw.visible_area.xmax);
d1343 2
a1344 2
      redraw.visible_area.ymax = temp,
      redraw.visible_area.ymin = 0;
d1350 5
a1354 5
      /* have filled in redraw.xscroll with the last coordinate used - if we    */
      /* don't do this, we can't tell how much of the web page was actually     */
      /* used. Remember that xscroll and yscroll are negative; xscroll refers   */
      /* to the vertical offset to start the next page at, and yscroll was the  */
      /* offset that this one started at.                                       */
d1356 1
a1356 1
      if (redraw.xscroll && bottom) bottom -= (redraw.yscroll - redraw.xscroll);
d1360 1
a1360 1
        redraw.visible_area.ymax = temp;
d1364 1
a1364 1
        redraw.visible_area.ymax = bottom - top;
d1372 1
a1372 1
        temp -= redraw.visible_area.ymax; /* (Page height minus rectangle height in OS units) */
d1376 2
a1377 2
        if (orientation) box.ymin += temp;
        else             box.xmin += temp;
d1380 1
a1380 1
      redraw.visible_area.ymin = 0;
d1383 33
a1415 18
    /* redraw_draw will give the y coordinate of the next line to */
    /* print when it exits by placing an appropriate coordinate   */
    /* in the xscroll field of the redraw block that is passed to */
    /* it during the main printer redraw loop.                    */

    if (redraw.xscroll) redraw.yscroll = redraw.xscroll, redraw.xscroll = 0;

    /* Start drawing things. We use three rectangles for the main */
    /* page, the header and the footer.                           */

    e = _swix(PDriver_GiveRectangle,
              _INR(0,4),

              0, /* Use zero for the main page */
              &redraw.visible_area,
              orientation ? &portrait : &landscape,
              &box,
              Redraw_Colour_White);
d1421 4
a1424 2
      BBox head;
      BBox hpof;
d1426 7
a1432 10
      head.xmin = redraw.visible_area.xmin;
      head.xmax = redraw.visible_area.xmax;
      head.ymin = 0;
      head.ymax = header;

      if (orientation)
      {
        hpof.xmin = box.xmin;
        convert_to_points(redraw.visible_area.ymax - redraw.visible_area.ymin, &hpof.ymin);
        hpof.ymin += box.ymin;
d1434 1
a1434 1
      else
d1436 2
a1437 7
        /* Yes, ymax and ymin again - remember, the redraw bounding box is always "right */
        /* way up" regardless of orientation, it's just the offset coordinates that are  */
        /* relative to a portrait page at all times.                                     */

        convert_to_points(redraw.visible_area.ymax - redraw.visible_area.ymin, &hpof.xmin);
        hpof.xmin += box.xmin;
        hpof.ymin = box.ymin;
d1440 4
a1443 2
      e = _swix(PDriver_GiveRectangle,
                _INR(0,4),
d1445 5
a1449 5
                1, /* Use 1 for the header */
                &head,
                orientation ? &portrait : &landscape,
                &hpof,
                Redraw_Colour_White);
d1451 2
a1452 1
      if (e) goto out2;
d1457 7
a1463 2
      BBox foot;
      BBox fpof;
d1465 4
a1468 10
      foot.xmin = redraw.visible_area.xmin;
      foot.xmax = redraw.visible_area.xmax;
      foot.ymin = 0;
      foot.ymax = footer;

      if (orientation)
      {
        fpof.xmin = box.xmin;
        convert_to_points(footer, &fpof.ymin);
        fpof.ymin = box.ymin - fpof.ymin;
d1470 1
a1470 1
      else
d1472 2
a1473 3
        convert_to_points(footer, &fpof.xmin);
        fpof.xmin = box.xmin - fpof.xmin;
        fpof.ymin = box.ymin;
d1476 4
a1479 2
      e = _swix(PDriver_GiveRectangle,
                _INR(0,4),
d1481 5
a1485 5
                2, /* Use 2 for the footer */
                &foot,
                orientation ? &portrait : &landscape,
                &fpof,
                Redraw_Colour_White);
d1487 2
a1488 1
      if (e) goto out2;
d1491 2
a1492 2
    e = _swix(PDriver_DrawPage,
              _INR(0,3) | _OUT(0) | _OUT(2),
d1494 4
a1497 4
              (copies) | ((features & Browser_Printer_PreScansRectangles) ? (1<<24) : (0)),
              &redraw.redraw_area,
              0,
              NULL,
d1499 4
a1502 2
              &more,
              &rect_id);
d1504 2
a1505 3
    if (e) goto out2;

    /* Give an indication of progress */
d1507 3
d1511 2
a1512 1
      int percent;
d1514 1
a1514 1
      percent = (100 * (page - 1)) / pages;
d1516 1
a1516 1
      if (percent > 99) percent = 99;
d1518 2
a1519 2
      _swix(Hourglass_Percentage, _IN(0), percent);
    }
d1521 2
a1522 2
    /* The redraw loop itself. The area stuff is for the */
    /* in-page hourglass percentage; see later comments. */
d1524 1
a1524 2
    page_area = (redraw.visible_area.xmax - redraw.visible_area.xmin) *
                (redraw.visible_area.ymax - redraw.visible_area.ymin);
d1527 2
d1530 1
a1530 3
    next_line = area_completed = 0;

    while (more)
d1532 1
a1532 1
      switch (rect_id)
d1534 1
a1534 1
        default: /* Always default to printing the body of the page */
d1536 5
a1540 1
          /* Ensure images are correct for the current mode */
d1542 1
a1542 1
          image_mode_change();
d1544 1
a1544 1
          /* Do the redraw */
d1546 5
a1550 4
          e = redraw_draw(b,
                          &redraw,
                          0,
                          0);
d1552 13
a1564 1
          if (e) goto out2;
d1566 4
a1569 1
          /* Don't want to start pagination issues if this is just a prescan */
d1571 1
a1571 1
          if ((features & Browser_Printer_PreScansRectangles) && (more & 1<<24))
d1573 6
a1578 1
            redraw.xscroll = 0;
d1580 3
a1582 1
          else
d1584 16
a1599 2
            int    this_area;
            BBox * i;
d1601 1
a1601 1
            if (redraw.xscroll != 0) next_line = redraw.xscroll, redraw.xscroll = 0;
d1603 2
a1604 16
            /* Give a percentage completed indicator. This is first based */
            /* on the current page being printed, so there's some scaling */
            /* of the 100% range to cope with the fact that if you're on  */
            /* page 3 of 4, the variation must be between 50% and 75%,    */
            /* for example. Since rectangle order cannot be relied upon,  */
            /* need to use the area printed so far for the calculation.   */
            /* This may fail under unusual circumstances, and certainly   */
            /* is not fully accurate as the rectangles always overlap by  */
            /* a small amount (the printer driver gives room for rounding */
            /* errors by overlapping the rectangles) but in any case      */
            /* there will at least be some kind of percentage indication! */
            /* With bit image printing, which can be painfully slow, this */
            /* is extremely important.                                    */
            /*                                                            */
            /* There is an attempt to correct for overlapping rectangles, */
            /* if this one and the last were overlapping.                 */
d1606 8
a1613 1
            i = intersection(&redraw.redraw_area, &last_rect);
d1615 7
a1621 12
            if (i)
            {
              this_area = (redraw.redraw_area.xmax - redraw.redraw_area.xmin) *
                          (redraw.redraw_area.ymax - redraw.redraw_area.ymin)
                        - (i->xmax                 - i->xmin) *
                          (i->ymax                 - i->ymin);
            }
            else
            {
              this_area = (redraw.redraw_area.xmax - redraw.redraw_area.xmin) *
                          (redraw.redraw_area.ymax - redraw.redraw_area.ymin);
            }
d1623 1
a1623 1
            last_rect = redraw.redraw_area;
d1625 1
a1625 2
            area_completed += this_area;
            if (area_completed > page_area) area_completed = page_area;
d1627 11
d1639 2
a1640 1
              int percent;
d1642 10
a1651 2
              percent = (100 * (page - 1)) / pages +
                        ((100 / pages) * area_completed) / page_area;
d1653 6
a1658 2
              if (percent < 0)  percent = 0;
              if (percent > 99) percent = 99;
d1660 6
a1665 1
              _swix(Hourglass_Percentage, _IN(0), percent);
d1667 1
d1669 1
a1670 12
        break;

        case 1:
        {
          print_header(b,
                       pages,
                       page,
                       stored_section,
                       header,
                       redraw.redraw_area.xmax - redraw.redraw_area.xmin);
        }
        break;
d1672 2
a1673 10
        case 2:
        {
          print_footer(b,
                       pages,
                       page,
                       stored_section,
                       footer,
                       redraw.redraw_area.xmax - redraw.redraw_area.xmin);
        }
        break;
d1676 1
a1676 9
      /* Get the next rectangle */

      e = _swix(PDriver_GetRectangle,
                _IN(1) | _OUT(0) | _OUT(2),

                &redraw.redraw_area,

                &more,
                &rect_id);
d1678 1
a1679 1
    }
d1681 1
a1681 1
    if (next_line) redraw.xscroll = next_line;
d1688 1
a1688 4
    if (end == End_Visible && !bottom)
    {
      break;
    }
d1690 2
a1691 3
    /* If xscroll is 0, redraw_draw must not have found any */
    /* lines that fell off the bottom of the page - so      */
    /* there cannot be any more pages.                      */
d1693 1
a1693 1
    if (redraw.xscroll == 0) break;
d1703 6
a1708 2
  e = _swix(PDriver_EndJob,
            _IN(0),
d1710 6
a1715 1
            job);
d1717 3
a1719 1
  if (e) goto out2;
d1728 3
a1730 1
  /* Restore the old Escape handler */
d1732 1
a1732 1
  signal(SIGINT, old_sigint_handler);
d1734 1
a1734 1
  /* Close the output stream */
d1736 1
a1736 1
  globaljob = 0;
d1738 2
a1739 2
  e = _swix(OS_Find,
            _INR(0,1),
d1741 2
a1742 2
            0x00,
            job);
d1744 2
a1745 1
  if (e) goto out3;
a1757 4
    int leds = 1;

    if (!from) markers_remember_position(b);

d1759 1
a1759 24

    /* As before, sit around whilst the reformatter reformats. */

    reformat_format_from(b, -1, 1, -1); /* Ignore errors */

    while (reformat_formatting(b))
    {
      reformat_reformatter(b);

      if (!from) browser_check_for_request(b);

      leds ^= 3;

      _swix(Hourglass_LEDs,
            _INR(0,1),

            3,
            leds);
    }

    if (!from) markers_forget_position(b);

    /* We don't need to restore anything now */

d1767 3
a1769 1
  /* Restore the previous print job */
d1771 1
a1771 1
  globalold_job = 0;
d1773 2
a1774 2
  e = _swix(PDriver_SelectJob,
            _INR(0,1),
d1776 7
a1782 4
            old_job,
            0);

  return e;
d1786 4
a1789 2
  signal(SIGINT, old_sigint_handler);
  globaljob = 0;
d1791 1
a1791 1
  /* Close the output stream */
d1793 2
a1794 2
  _swix(OS_Find,
        _INR(0,1),
d1796 7
a1802 2
        0x00,
        job);
d1817 1
a1817 2
    reformat_format_from(b, -1, 1, -1);

d1832 10
a1841 3
  signal(SIGINT, old_sigint_handler);

  print_abort_print();
d1846 1
a1846 2
    reformat_format_from(b, -1, 1, -1);

a1858 1

d1864 1
a1864 2
    reformat_format_from(b, -1, 1, -1);

d1992 247
d2506 10
a2515 2
static char * print_build_formatted(browser_data * b, unsigned int pages, unsigned int page, const char * section,
                                    char * buffer, unsigned int buflen, const char * format)
d2870 2
a2871 2
static void print_header(browser_data * b, unsigned int pages, unsigned int page,
                         const char * section, int header_y, int width)
d2877 2
a2878 2
  if (choices.print_headers_from == 0 || page < choices.print_headers_from) return;
  if (reformat_text_line_height(b, NULL, &top, &bot))                       return;
a2895 4
  fm_set_font_colour(h,
                     Redraw_Colour_Black,
                     Redraw_Colour_White);

d2917 8
a2924 6
    fm_puts(h,
            lm,
            header_y,
            buffer,
            1,
            0);
d2935 12
a2946 2
    if (
         fm_get_string_width(h,
d2948 3
a2950 16
                             width,          /* Not splitting anyway right now, but might one day... */
                             strlen(buffer),
                             -1,
                             NULL,
                             &w)
       )
       return;

    convert_to_os((width - w) / 2, &w);

    fm_puts(h,
            w,
            header_y,
            buffer,
            1,
            0);
d2992 12
a3003 2
    if (
         fm_get_string_width(h,
d3005 3
a3007 16
                             width,          /* Not splitting anyway right now, but might one day... */
                             strlen(buffer),
                             -1,
                             NULL,
                             &w)
       )
       return;

    convert_to_os(width - w, &w);

    fm_puts(h,
            w - rm,
            header_y,
            buffer,
            1,
            0);
d3010 1
a3010 1
  return;
d3034 2
a3035 2
static void print_footer(browser_data * b, unsigned int pages, unsigned int page,
                         const char * section, int footer_y, int width)
d3041 2
a3042 2
  if (choices.print_footers_from == 0 || page < choices.print_footers_from) return;
  if (reformat_text_line_height(b, NULL, &top, &bot))                       return;
a3058 4
  fm_set_font_colour(h,
                     Redraw_Colour_Black,
                     Redraw_Colour_White);

d3080 8
a3087 6
    fm_puts(h,
            lm,
            bot,
            buffer,
            1,
            0);
d3098 12
a3109 2
    if (
         fm_get_string_width(h,
d3111 3
a3113 16
                             width,          /* Not splitting anyway right now, but might one day... */
                             strlen(buffer),
                             -1,
                             NULL,
                             &w)
       )
       return;

    convert_to_os((width - w) / 2, &w);

    fm_puts(h,
            w,
            bot,
            buffer,
            1,
            0);
d3155 12
a3166 2
    if (
         fm_get_string_width(h,
d3168 3
a3170 16
                             width,          /* Not splitting anyway right now, but might one day... */
                             strlen(buffer),
                             -1,
                             NULL,
                             &w)
       )
       return;

    convert_to_os(width - w, &w);

    fm_puts(h,
            w - rm,
            bot,
            buffer,
            1,
            0);
d3173 1
a3173 1
  return;
d3228 5
d3235 1
d3242 6
d3276 1
a3276 1
      if (redraw.xscroll && bottom) bottom -= (redraw.yscroll - redraw.xscroll);
d3291 5
a3295 1
    if (redraw.xscroll) redraw.yscroll = redraw.xscroll, redraw.xscroll = 0;
a3309 1
    next_line = 0;
d3313 5
a3317 4
    print_fake_redraw(b,
                      &redraw);

    if (next_line) redraw.xscroll = next_line;
d3326 3
a3328 3
    /* If xscroll is 0, redraw_draw must not have found any */
    /* lines that fell off the bottom of the page - so      */
    /* there cannot be any more pages.                      */
d3330 1
a3330 1
    if (!redraw.xscroll) break;
d3336 3
a3342 157
/* print_fake_redraw()                                        */
/*                                                            */
/* MAINTENANCE WARNING - ANY ALTERATIONS TO REDRAW_DRAW_R     */
/* WILL NEED ECHOING HERE IF IN AN ANALOGOUS CODE SECTION.    */
/*                                                            */
/* Does the coordinates and splitting side of an in-print     */
/* redraw loop without actually drawing anything. Used in     */
/* conjunction with print_count_pages.                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the page to be printed;                        */
/*                                                            */
/*             Pointer to a redraw block set up exactly for   */
/*             printing a specific whole page within a print  */
/*             loop.                                          */
/**************************************************************/

static void print_fake_redraw(browser_data * b, WimpRedrawWindowBlock * r)
{
  reformat_cell   * d = b->cell;
  int               l = 0;
  int               page_bottom, page_height;
  BBox              wbox, fbox, sbox;

  /* For full comments, see redraw_draw_r in Redraw.c() */

  sbox = r->redraw_area; /* Set sbox to hold the redraw rectangle details */
  sbox.xmin -= 12, sbox.xmax += 12;
  convert_box_to_points(&sbox, &fbox);

  /* Convert the screen coord redraw region into work */
  /* area coords, putting the result in wbox.         */

  wbox = sbox;
  coords_box_toworkarea(&wbox, r);

  /* Get the page bottom in work area coordinates, and the page height. */

  page_bottom = coords_y_toworkarea(r->visible_area.ymin, r);
  page_height = r->visible_area.ymax - r->visible_area.ymin;

  if (b->nchildren != 0 || b->stream == NULL)
  {
    r->xscroll = 0;
  }
  else
  {
    /* Loop over every line in this cell. */

    for (l = 0; l < d->nlines; l++)
    {
      /* If there are line chunks for this line, and the bounding box y */
      /* coordinates lie within the redraw rectangle, process the line. */

      if (
           d->ldata[l].n                             &&
           d->ldata[l].y < wbox.ymax                 &&
           d->ldata[l].y + d->ldata[l].h > wbox.ymin
         )
      {
        HStream * tp;            /* Token Pointer */
        int       x, y;          /* Plotting origin */
        int       keepx, keepy;  /* Line's bottom left corner */
        int       base, i;
        int       cn;            /* Chunk Number */

        if (printing == 1) /* 1 = may force page break, 2 = don't */
        {
          int split_y, store;

          /* If we find a split point it's returned in r->xscroll (rather hacky, but */
          /* it's always zero during printing otherwise so why not...?).             */

          if (
               print_find_splitting_point(d,
                                          0,
                                          l,
                                          page_bottom,
                                          page_height,
                                          &split_y,
                                          &store)
               != NULL
             )
          {
            r->xscroll = split_y;
            return;
          }
        }

        /* Put the base address of the line's chunks into cp, */
        /* and point to its associated token in tp.           */

        cn = d->ldata[l].chunks;
        tp = d->cdata[cn].t;

        /* Get the x and y coordinates of the bottom left of the line in */
        /* millipoints into keepx and keepy, and the x and y coordinates */
        /* of the window origin in millipoints into x and y.             */

        keepy = d->ldata[l].y;
        keepx = redraw_start_x(b, d, tp, l);

        convert_pair_to_points(keepx, keepy, &keepx, &keepy);

        x = coords_x_toscreen(0, r);
        y = coords_y_toscreen(0, r);

        convert_pair_to_points(x, y, &x, &y);

        x += keepx;
        y += keepy;

        /* Set 'base' to hold the baseline offset in millipoints */

        convert_to_points(d->ldata[l].b, &base);

        /* Loop round for up to all the line chunks whilst staying */
        /* within the redraw rectangle horizontally.               */

        for (
              i = 0;
              i < d->ldata[l].n && x < fbox.xmax;
              x += d->cdata[cn].w, i++, cn++
            );

        /* Tell the print routines where we were up to */

        {
          int bottom = d->ldata[l].y;

          /* Correct for a possible gap */

          if (l + 1 < d->nlines)
          {
            bottom -= d->ldata[l].y -
                      (
                        d->ldata[l + 1].y +
                        d->ldata[l + 1].h
                      );
          }

          if (bottom < page_bottom) r->xscroll = page_bottom;
        }

      /* Closure of long 'if' checking if the current line lies */
      /* partially or entirely within the redraw area. The code */
      /* above executes if it does.                             */
      }

    /* Closure of 'for' looping for all lines in the document. */
    }
  }

  return;
}

/**************************************************************/
d3375 1
a3375 1
HStream * print_find_splitting_point(reformat_cell * d, int osyorg, int l, int page_bottom, int page_height,
d3564 87
@


1.20
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@a1696 2
  printing = 0;

d1740 5
a1744 1
  /* Abort the current print job */
d1746 1
a1746 2
  _swix(PDriver_AbortJob,
        _IN(0),
d1748 2
a1749 1
        globaljob);
d1751 1
a1751 1
  /* Close the output stream */
d1753 1
a1753 2
  _swix(OS_Find,
        _INR(0,1),
d1755 2
a1756 2
        0x00,
        globaljob);
d1758 2
a1759 1
  globaljob = 0;
d1761 1
a1761 1
  /* Restore the previous print job */
d1763 1
a1763 2
  _swix(PDriver_SelectJob,
        _INR(0,1),
d1765 2
a1766 2
        globalold_job,
        0);
d1768 2
a1769 1
  globalold_job = 0;
d1771 1
a1771 1
  /* Force the hourglass off */
d1773 4
a1776 1
  _swix(Hourglass_Smash, 0);
@


1.19
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a53 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d3137 4
a3140 1
  /* the page height, it will be split over the page boundary.            */
d3144 12
a3155 1
    if (d->ldata[l].h <= ((page_height * 100) / PrintSplitFraction)) /* (See Print.h) */
d3159 6
d3204 7
a3210 2
  /* onto the next side? (Above caveat on fraction of page height of   */
  /* the line we're looking ahead to applies).                         */
d3215 1
a3215 1
       (d->ldata[l + 1].h <= ((page_height * 100) / PrintSplitFraction))
d3217 1
d3293 2
a3294 2
           osyorg + d->ldata[scan].y + d->ldata[scan].h <= page_top
           &&
@


1.18
log
@Further printing tweaks. Font colours inside anchors now work (must be
built with the 02-Mar-2000 HTMLLib or later). Event log won't show guts
of internal URLs for just-born browser windows if displaying the list
by URL. Empty Location headers don't redirect down zero page and give a
nasty internal error; raise "no fetcher service found" instead.
@
text
@d35 1
d38 1
a38 1
#include "signal.h"
d44 2
a45 1
#include "swis.h"
d47 11
a57 3
#include "wimp.h"
#include "wimplib.h"
#include "event.h"
a58 4
#include "toolbox.h"
#include "printdbox.h"

#include "svcprint.h"
d156 11
a166 13
/*************************************************/
/* print_open_for()                              */
/*                                               */
/* Creates and opens a Print dialogue for a      */
/* given browser, opening near the pointer.      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which is the ancestor of the      */
/*             dialogue;                         */
/*                                               */
/*             Object ID to use as a parent, or  */
/*             0 for none.                       */
/*************************************************/
d189 10
a198 11
/*************************************************/
/* print_read_contents()                         */
/*                                               */
/* Reads the contents of the Print dialogue      */
/* into a print_contents structure.              */
/*                                               */
/* Parameters: Object ID of the dialogue;        */
/*                                               */
/*             Pointer to the structure to write */
/*             to.                               */
/*************************************************/
d249 10
a258 11
/*************************************************/
/* print_set_contents()                          */
/*                                               */
/* Sets the contents of the Print dialogue from  */
/* a print_contents structure.                   */
/*                                               */
/* Parameters: Object ID of the dialogue;        */
/*                                               */
/*             Pointer to the structure to read  */
/*             from.                             */
/*************************************************/
d303 11
a313 14
/*************************************************/
/* print_set_defaults()                          */
/*                                               */
/* Fills in the local print_contents structure   */
/* with the default values to put in a Print     */
/* dialogue, if they have not already been       */
/* filled in.                                    */
/*                                               */
/* If the dialogue is open, the contents are     */
/* updated.                                      */
/*                                               */
/* Returns:    1 if the structure was filled in, */
/*             else 0.                           */
/*************************************************/
d368 10
a377 12
/*************************************************/
/* print_to_be_shown()                           */
/*                                               */
/* Called before a print dialogue opens. Deals   */
/* with setting this up with default values and  */
/* filling in print_old as appropriate, so that  */
/* if the dialogue is cancelled its contents may */
/* be correctly restored.                        */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event hander.                                 */
/*************************************************/
d565 8
a572 9
/*************************************************/
/* print_start()                                 */
/*                                               */
/* Handles clicks on the 'OK' (or 'Print', etc.) */
/* button in the Print dialogue.                 */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d595 8
a602 9
/*************************************************/
/* print_cancel()                                */
/*                                               */
/* Handles clicks on the 'Cancel' button in the  */
/* Print dialogue.                               */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d634 13
a646 15
/*************************************************/
/* print_close()                                 */
/*                                               */
/* If the Print dialogue is opened, this will    */
/* close it, deregistering any associated event  */
/* handlers.                                     */
/*                                               */
/* Parameters: An object ID, or 0. If not zero,  */
/*             the ID must match the ancestor    */
/*             recorded when the dialogue was    */
/*             opened or no action is taken.     */
/*                                               */
/*             0 to close the dialogue, 1 to do  */
/*             everything except that.           */
/*************************************************/
d716 12
a727 15
/*************************************************/
/* print_check_contents()                        */
/*                                               */
/* If the state of the various radio buttons     */
/* changes, this may be called to see if the     */
/* Reformat option in the Print dialogue should  */
/* be enabled (ungreyed) or disabled (greyed).   */
/* Similarly, if the contents of the number of   */
/* sheets to fill number range changes, this     */
/* should be called to ensure the label has the  */
/* correct pluralisation applied.                */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
/*************************************************/
d794 12
a805 15
/*************************************************/
/* print_print()                                 */
/*                                               */
/* Calls the printing engine with parameters     */
/* specified in the local static print_info      */
/* structure 'print_current'.                    */
/*                                               */
/* Entry point is typically from a handler       */
/* dealing with the printing message protocol    */
/* (see handle_messages).                        */
/*                                               */
/* Parameters: Pointer to pathname to print to,  */
/*             or NULL to go straight to the     */
/*             'printer:' device.                */
/*************************************************/
d849 34
a882 39
/*************************************************/
/* print_page()                                  */
/*                                               */
/* MAINTENANCE WARNING - ANY ALTERATIONS HERE    */
/* WILL NEED ECHOING IN PRINT_COUNT_PAGES IF IN  */
/* AN ANALOGOUS CODE SECTION.                    */
/*                                               */
/* Prints out a page, assuming that all the      */
/* relevant protocol stuff to ensure it's OK to  */
/* proceed has been done already.                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the page to print;    */
/*                                               */
/*             The number of copies to print;    */
/*                                               */
/*             1 to start at the top of the web  */
/*             page, else start from the top of  */
/*             the visible area in the window;   */
/*                                               */
/*             Where to end - End_Whole,         */
/*             End_Visible or End_Many (as       */
/*             defined at the top of the file);  */
/*                                               */
/*             For End_Many, how many sheets to  */
/*             fill;                             */
/*                                               */
/*             1 to reformat to fit the page     */
/*             width (orientation is taken into  */
/*             account), else 0 to keep the      */
/*             width of the window (if it falls  */
/*             off the page, tough...!);         */
/*                                               */
/*             1 = portrait, 0 = landscape;      */
/*                                               */
/*             Pointer to pathname to print to,  */
/*             or NULL to go straight to the     */
/*             'printer:' device.                */
/*************************************************/
d1739 5
a1743 5
/*************************************************/
/* print_abort_print()                           */
/*                                               */
/* Forcibly aborts a print job.                  */
/*************************************************/
d1779 17
a1795 20
/*************************************************/
/* print_prepare_browser()                       */
/*                                               */
/* Prepares a browser for internal reformatting  */
/* prior to printing a page, storing various     */
/* overwritten values into an alternative        */
/* given structure.                              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the page to print;    */
/*                                               */
/*             Pointer to the browser_data       */
/*             struct to copy into;              */
/*                                               */
/*             Left hand page margin, in         */
/*             millipoints;                      */
/*                                               */
/*             Right hand page margin, in        */
/*             millipoints.                      */
/*************************************************/
d1822 14
a1835 17
/*************************************************/
/* print_restore_browser()                       */
/*                                               */
/* Puts back the bits and pieces replaced in the */
/* browser_data struct given to the print        */
/* routines, copied out because a reformat was   */
/* required on the page.                         */
/*                                               */
/* Parameters: Pointer to the browser_data       */
/*             struct given to the print         */
/*             routines;                         */
/*                                               */
/*             Pointer to the browser_data       */
/*             struct used to store the over-    */
/*             written values from the original  */
/*             copy in print_prepare_browser.    */
/*************************************************/
d1848 26
a1873 31
/*************************************************/
/* print_return_dialogue_info()                  */
/*                                               */
/* Returns information on the Print dialogue,    */
/* and its ancestor.                             */
/*                                               */
/* Parameters: Pointer to an ObjectId, in which  */
/*             the ID of the PrintDBox object    */
/*             is placed;                        */
/*                                               */
/*             Pointer to an ObjectId, in which  */
/*             the ID of the underlying window   */
/*             object is placed;                 */
/*                                               */
/*             Pointer to an ObjectId, in which  */
/*             the ID of the ancestor window is  */
/*             placed;                           */
/*                                               */
/*             Pointer to a pointer to a         */
/*             browser_data struct, in which the */
/*             address of the browser_data       */
/*             struct associated with the        */
/*             ancestor object is placed.        */
/*                                               */
/* Returns:    See parameters list, and note     */
/*             that the returned values will be  */
/*             0, 0, 0 and NULL if the Print     */
/*             dialogue is closed.               */
/*                                               */
/* Assumes:    Any of the pointers may be NULL.  */
/*************************************************/
d1883 16
a1898 17
/*************************************************/
/* print_roman()                                 */
/*                                               */
/* From HTMLLib (ol.c). Convert a value into a   */
/* roman numeral string in the given buffer. The */
/* buffer is assumed to be large enough.         */
/*                                               */
/* Parameters: Pointer to the buffer;            */
/*                                               */
/*             Value to convert;                 */
/*                                               */
/*             Zero for lower case, else upper   */
/*             case.                             */
/*                                               */
/* Returns:    Pointer to the output buffer      */
/*             given in the parameters.          */
/*************************************************/
d1948 18
a1965 20
/*************************************************/
/* print_roman()                                 */
/*                                               */
/* Convert a value into an alphabetic indicator  */
/* - 1 is a, 2 is b, 3 is c etc. up to 26 being  */
/* z, 27 is aa, 28 is ab, etc. to zz, to aaa,    */
/* aab, aac...zzy, zzz, aaaa and so-on. The      */
/* output is a NUL terminated string in a given  */
/* buffer, assumed to be large enough.           */
/*                                               */
/* Parameters: Pointer to the buffer;            */
/*                                               */
/*             Value to convert;                 */
/*                                               */
/*             Zero for lower case, else upper   */
/*             case.                             */
/*                                               */
/* Returns:    Pointer to the output buffer      */
/*             given in the parameters.          */
/*************************************************/
d2000 19
a2018 22
/*************************************************/
/* print_date()                                  */
/*                                               */
/* Output either the current date or a given     */
/* date formatted according to PrintDateFormat   */
/* in the Choices file.                          */
/*                                               */
/* Parameters: Pointer to a date string in the   */
/*             form of a LastModified header     */
/*             value which will be converted to  */
/*             the required format (NOT          */
/*             IMPLEMENTED YET!) or NULL to use  */
/*             the current date and time;        */
/*                                               */
/*             Pointer to a buffer to write the  */
/*             time into;                        */
/*                                               */
/*             Size of the buffer.               */
/*                                               */
/* Returns:    Pointer to the output buffer      */
/*             given in the parameters.          */
/*************************************************/
d2091 24
a2114 26
/*************************************************/
/* print_build_formatted()                       */
/*                                               */
/* Builds a header or footer string based on the */
/* given format string into the given buffer.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the header or footer; */
/*                                               */
/*             Number of pages or 0 if unknown;  */
/*                                               */
/*             Notional current page number;     */
/*                                               */
/*             Notional current section or NULL; */
/*                                               */
/*             Pointer to the buffer to build    */
/*             in;                               */
/*                                               */
/*             Length of the buffer;             */
/*                                               */
/*             Pointer to the format string.     */
/*                                               */
/* Returns:    Pointer to the buffer you gave so */
/*             it can be used in expressions     */
/*             directly.                         */
/*************************************************/
d2247 21
a2267 23
/*************************************************/
/* print_count_formatted()                       */
/*                                               */
/* Return the string length that                 */
/* print_build_formatted() would construct, not  */
/* including the NUL terminator.                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the header or footer; */
/*                                               */
/*             Number of pages or 0 if unknown;  */
/*                                               */
/*             Notional current page number;     */
/*                                               */
/*             Notional current section or NULL; */
/*                                               */
/*             Pointer to the format string.     */
/*                                               */
/* Returns:    Length of the string that         */
/*             print_count_formatted() would     */
/*             construct, not including the NUL  */
/*             terminator.                       */
/*************************************************/
@


1.17
log
@Header and footer support working a lot better than in the previous
release. Could do with some code tidying, but little else to do.
Fixed a typo in JavaScript.c that stopped debug builds compiling,
and updated Trace.c to know about all current HStream flags bits.
@
text
@d2494 2
d2516 1
d2521 3
d2535 5
a2539 1
  convert_to_points(width - (PrintHeaderAndFooterWidthAdjust * 2), &width);
d2563 1
a2563 1
            PrintHeaderAndFooterWidthAdjust,
d2652 1
a2652 1
            w,
d2666 2
d2688 1
d2693 3
d2706 5
a2710 1
  convert_to_points(width - (PrintHeaderAndFooterWidthAdjust * 2), &width);
d2734 1
a2734 1
            PrintHeaderAndFooterWidthAdjust,
d2823 1
a2823 1
            w,
d3049 1
a3049 1
          /* Printing page split rules: First, simple "line drops off page" rule */
d3051 2
a3052 21
          if (d->ldata[l].y < page_bottom)
          {
            if (d->ldata[l].h <= ((page_height * 100) / PrintSplitFraction)) /* (See Print.h) */
            {
              r->xscroll = d->ldata[l].y + d->ldata[l].h;
              return;
            }
          }

          /* ...with "line fits on *exactly*" adjustment. */

          else if (
                    d->ldata[l].y == page_bottom &&
                    l + 1 < d->nlines
                  )
          {
            r->xscroll = d->ldata[l + 1].y + d->ldata[l + 1].h;
            return;
          }

          /* Second, look ahead to keep heading lines and DT / DD lines together */
d3055 8
a3062 3
               (l + 1 < d->nlines)                                               &&
               d->ldata[l + 1].y < page_bottom                                   &&
               (d->ldata[l + 1].h <= ((page_height * 100) / PrintSplitFraction))
d3065 2
a3066 75
            HStream * t1 = d->cdata[d->ldata[l].chunks].t;
            HStream * t2 = d->cdata[d->ldata[l + 1].chunks].t;

            if (
                 reformat_istext(t1) &&
                 (
                   (
                     ((t1->style & H_MASK) != 0) &&
                     (
                       (t2->style & H_MASK) == 0 ||
                       !reformat_istext(t2)
                     )
                   )
                   ||
                   (
                     reformat_istext(t2)     &&
                     ((t1->style & DT) != 0) &&
                     ((t2->style & DD) != 0)
                   )
                 )
               )
            {
              r->xscroll = d->ldata[l].y + d->ldata[l].h;
              return;
            }
          }

          /* Last, look behind for page break at headings */

          if (l > 0 && choices.print_page_break_hx != 0)
          {
            int       scan = l - 1;

            HStream * t1   = d->cdata[d->ldata[scan].chunks].t;
            HStream * t2   = d->cdata[d->ldata[l].chunks].t;

            int       h1;
            int       h2;

            if (reformat_istext(t2))
            {
              /* The previous line might not be useful (e.g. two H2s in a row */
              /* would have a dummy tag in between occuping a zero height     */
              /* line of its own). So we need to scan backwards to get a      */
              /* useful token.                                                */

              while (
                      t1 != NULL &&
                      (
                        reformat_istext(t1) &&
                        t1->text == NULL
                      )
                      && --scan >= 0
                    )
                    t1 = d->cdata[d->ldata[scan].chunks].t;

              h1 = reformat_istext(t1) ? redraw_header(t1->style) : 0;
              h2 = redraw_header(t2->style);

              if (
                   d->ldata[scan].y < wbox.ymax &&
                   d->ldata[scan].y + d->ldata[scan].h <= wbox.ymax
                   &&
                   (
                     h1 > choices.print_page_break_hx ||
                     h1 == 0
                   )
                   && h2 <= choices.print_page_break_hx
                   && h2 > 0
                 )
              {
                r->xscroll = d->ldata[l].y + d->ldata[l].h;
                return;
              }
            }
d3135 197
@


1.16
log
@Misecllaneous tweaks and fixes. Major addition is full header and footer
support in the printing system - see the Phoenix Choices file for more
information.

Only the Phoenix resources are up to date currently.
@
text
@d1330 1
d1369 1
d1566 4
a1569 1
    if (end == End_Visible && !bottom) break;
d1575 1
a1575 1
    if (!redraw.xscroll) break;
d2435 1
d2439 2
d2482 1
a2482 14
  /* If we've got a header / footer, work out the height */

  if (ok != 0)
  {
    int top, bot;

    if (reformat_text_line_height(b, NULL, &top, &bot))
    {
      *header = *footer = 0;
      return;
    }

    if ((ok & 1) != 0) *header = ((top + bot) * PrintHeaderAndFooterHeightMultiplier * choices.print_hf_scale) / 1000;
    if ((ok & 2) != 0) *footer = ((top + bot) * PrintHeaderAndFooterHeightMultiplier * choices.print_hf_scale) / 1000;
d2484 2
a2485 2
  }
  else *header = *footer = 0;
d3040 11
d3063 1
a3063 1
                 t1->tagno != TAG_TABLE &&
d3067 4
a3070 1
                     ((t2->style & H_MASK) == 0)
d3074 1
d3098 1
a3098 1
            if (t2->tagno != TAG_TABLE)
d3100 5
d3106 6
a3111 4
                      t1->tagno != TAG_TABLE &&
                      !t1->text              &&
                      scan >= 0              &&
                      --scan
d3115 1
a3115 3
              if (t1->tagno == TAG_TABLE) h1 = 0;
              else                        h1 = redraw_header(t1->style);

d3119 2
a3120 6
                   (
                     t1->tagno == TAG_TABLE ||
                     t1->text
                   )
                   && d->ldata[scan].y < wbox.ymax
                   && d->ldata[scan].y + d->ldata[scan].h <= wbox.ymax
@


1.15
log
@Intermediate check-in; building a browser from this gives you something
between 2.07 and 2.08. Only the Phoenix JavaScript resources are fully
up to date.

I *think* these are the changes since the last check-in:

When saved as a Draw file, horizontal rules were plotted one page width
too far to the right (wonder when that started happening?!). Fixed. In
addition, DrawFiles now accepted as OBJECTs - they weren't in the
recognised filetype list before. Doh.

Table size calculator tables_count_table would overestimate the number
of cells where ROWSPAN was present and there were other rows below the
one spanned. Fixed. In certain odd cases (e.g. optimised image exports
as HTML tables (!!) from the Gimp) this can save vast amounts of RAM.

Fixed problem where printing stops in the middle of a document. Redraw
engine pagination code was written in the days where lines couldn't
have gaps between them; they can now. If a gap fell at the bottom of
a page the engine would look down, see no line straddling or touching
the page edge, and assume there was nothing more. This case is now
correctly handled.

Made sure desktop and testbed Browse Res files had up-to-date Encoding
menus (v2.07 Phoenix has different menus from v2.07 Browse by oversight).

URL auto-completion piggy-backed onto manual completion code; any string
without '.', '/' or ':' in it gets run through completion to see if a
more meaningful item can be produced - "www" special cased out though.

New List dialogue box handler, used for proxy exclusions etc.
(incomplete), complete with appropriate Res file objects.
@
text
@d15 21
a35 17
/***************************************************/
/* File   : Printing.c                             */
/*                                                 */
/* Purpose: Printing functions for the browser.    */
/*                                                 */
/*          This source is fairly closely tied to  */
/*          PrintStyle.c, as the Print dialogue    */
/*          can open and close the Print Style     */
/*          dialogue.                              */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 27-Jan-97: Created.                    */
/*          25-Aug-97: Overhaul (read rewrite) to  */
/*                     the new dialogue handling   */
/*                     model, as for Open URL etc. */
/***************************************************/
d58 1
d125 2
a126 2
static _kernel_oserror * print_read_contents   (ObjectId dialogue, print_contents * contents);
static _kernel_oserror * print_set_contents    (ObjectId dialogue, print_contents * contents);
d128 2
a129 2
static int               print_start           (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               print_cancel          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
d131 1
a131 1
static int               print_check_contents  (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
d133 13
a145 1
static _kernel_oserror * print_page            (browser_data * b, int copies, int from, int end, int to, int reformat, int orientation, const char * path);
d147 2
a148 2
static void              print_prepare_browser (browser_data * source, browser_data * store, int lmarg, int rmarg, int tmarg, int bmarg);
static void              print_restore_browser (browser_data * original, browser_data * copy);
d322 1
a322 1
    contents.copies = atoi(lookup_choice("PrintCopies:1",0,0));
d332 3
a334 2
    if (!strcmp(lookup_choice("PrintStart:start",0,0),"visible")) contents.start = 0;
    else contents.start = 1;
d340 3
a342 5
    if (!strcmp(lookup_choice("PrintEnd:end",0,0),"end"))      contents.end = End_Whole;
    else if (!strcmp(lookup_choice("PrintEnd",1,0),"visible")) contents.end = End_Visible;
    else                                                       contents.end = End_Many;

    contents.pages = atoi(lookup_choice("PrintEnd",1,0));
d351 1
a351 2
    if (!strcmp(lookup_choice("PrintReform:yes",0,0),"no")) contents.reformat = 0;
    else contents.reformat = 1;
d356 2
a357 2
    if (!strcmp(lookup_choice("PrintOrient:upright",0,0),"sideways")) contents.orientation = 0;
    else contents.orientation = 1;
d434 6
a439 6
    if (!strcmp(lookup_choice("PrintPlain:yes",0,0),"yes")) browser_set_look(ancestor_browser,
                                                                             window_id,
                                                                             -1,
                                                                             -1,
                                                                             -1,
                                                                             0);
d628 6
a633 6
    if (!strcmp(lookup_choice("PrintPlain:yes",0,0),"yes")) browser_set_look(ancestor_browser,
                                                                             window_id,
                                                                             -1,
                                                                             -1,
                                                                             -1,
                                                                             restore.show_background);
d830 2
a831 1
  printing = 1;
d865 4
d911 1
a911 1
  int                     must_restore;
d913 2
a914 1
  int                     more,           page;
d916 1
a917 2
  int                     estimated_pages;
  int                     area_completed, page_area;
d920 1
d923 1
d964 21
a1081 12
  /* Estimate the number of pages to print */

  {
    int page_height;

    /* Get the printable page height */

    convert_to_os(tmarg - bmarg, &page_height);

    estimated_pages = (reformat_return_extent(b, NULL) / page_height) + 1;
  }

d1195 13
d1228 23
a1303 6

        /* Signal to redraw_draw that the last line on this page may be split */
        /* over the bottom of the page, as that's what the user is seeing in  */
        /* the real window right now.                                         */

        printing = 2;
d1316 2
a1317 1
    /* Start drawing things */
d1322 1
a1322 1
              0, /* Rectangle ID word - only 1 per page, so 0 will do */
d1330 72
d1403 1
a1403 1
              _INR(0,3) | _OUT(0),
d1408 1
a1408 1
              0,
d1410 2
a1411 1
              &more);
d1420 1
a1420 1
      percent = (100 * (page - 1)) / estimated_pages;
d1439 5
a1443 1
      /* Ensure images are correct for the current mode */
d1445 1
a1445 1
      image_mode_change();
d1447 1
a1447 1
      /* Do the redraw */
d1449 4
a1452 4
      e = redraw_draw(b,
                      &redraw,
                      0,
                      0);
d1454 3
a1456 1
      if (e) goto out2;
d1458 8
a1465 1
      /* Don't want to start pagination issues if this is just a prescan */
d1467 1
a1467 8
      if ((features & Browser_Printer_PreScansRectangles) && (more & 1<<24))
      {
        redraw.xscroll = 0;
      }
      else
      {
        int    this_area;
        BBox * i;
d1469 39
a1507 1
        if (redraw.xscroll != 0) next_line = redraw.xscroll, redraw.xscroll = 0;
d1509 2
a1510 16
        /* Give a percentage completed indicator. This is first based */
        /* on the current page being printed, so there's some scaling */
        /* of the 100% range to cope with the fact that if you're on  */
        /* page 3 of 4, the variation must be between 50% and 75%,    */
        /* for example. Since rectangle order cannot be relied upon,  */
        /* need to use the area printed so far for the calculation.   */
        /* This may fail under unusual circumstances, and certainly   */
        /* is not fully accurate as the rectangles always overlap by  */
        /* a small amount (the printer driver gives room for rounding */
        /* errors by overlapping the rectangles) but in any case      */
        /* there will at least be some kind of percentage indication! */
        /* With bit image printing, which can be painfully slow, this */
        /* is extremely important.                                    */
        /*                                                            */
        /* There is an attempt to correct for overlapping rectangles, */
        /* if this one and the last were overlapping.                 */
d1512 2
a1513 1
        i = intersection(&redraw.redraw_area, &last_rect);
d1515 3
a1517 6
        if (i)
        {
          this_area = (redraw.redraw_area.xmax - redraw.redraw_area.xmin) *
                      (redraw.redraw_area.ymax - redraw.redraw_area.ymin)
                    - (i->xmax                 - i->xmin) *
                      (i->ymax                 - i->ymin);
d1519 3
a1521 1
        else
d1523 6
a1528 2
          this_area = (redraw.redraw_area.xmax - redraw.redraw_area.xmin) *
                      (redraw.redraw_area.ymax - redraw.redraw_area.ymin);
d1530 1
d1532 1
a1532 5
        last_rect = redraw.redraw_area;

        area_completed += this_area;
        if (area_completed > page_area) area_completed = page_area;

d1534 6
a1539 9
          int percent;

          percent = (100 * (page - 1)) / estimated_pages +
                    ((100 / estimated_pages) * area_completed) / page_area;

          if (percent < 0)  percent = 0;
          if (percent > 99) percent = 99;

          _swix(Hourglass_Percentage, _IN(0), percent);
d1541 1
d1547 1
a1547 1
                _IN(1) | _OUT(0),
d1550 3
a1552 1
                &more);
d1587 2
a1588 1
  /* Ensure images are restored to the correct mode */
d1591 2
d1629 1
a1629 2
    e = reformat_format_from(b, -1, 1, -1);
    if (e) return e;
d1700 2
a1701 1
  /* Ensure images are still OK */
d1704 2
d1726 2
d1746 2
d1905 1286
@


1.14
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d1017 5
a1021 1
    _swix(Hourglass_LEDs, 0, 0);
@


1.13
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d56 1
d245 1
a245 1
  if (!contents->start) RetError(radiobutton_set_state(0, dialogue, PStartVisible, 1))
d274 1
a274 1
  if (!contents->orientation) RetError(radiobutton_set_state(0, dialogue, POriSideways, 1))
d740 1
a740 1
  if (state1 != PStartVisible && state2 != PEndVisible)
d952 3
a954 1
  /* depends upon the visible area, can't then reformat.      */
d956 1
a956 1
  if (reformat && end != End_Visible && from)
d990 2
d999 2
d1450 2
d1463 2
d1474 2
a1484 6
  if (must_restore)
  {
    print_restore_browser(b, &localbrowser);
    reformat_format_from(b, -1, 1, -1);
  }

d1524 2
d1546 2
d1564 2
@


1.12
log
@Sorted out Res files, including fixing position of 'bytes' label in one
of the Choices dialogues (I'd missed it out of a selection when everything
else got moved down a bit). Unfaded Enc_Chinese menu entries, made sure
text labels were wide enough for system font, changed 'Apply' on Choices
dialogue to 'Set', and added ^K to hotlist keyboard shortcut lists.
Print Setup (i.e. Print dialogue) buttons all set to 'local', so the
stupid Toolbox doesn't close the dialogue and lose the caret before I
can see if it was in there to start with...

256 colour hotlist sprites taken back to standard 16 colour versions,
since there's a significant speed penalty on slower machines. The
testbed browser still has the 256 colour versions so the designs aren't
completely lost.

Changed access settings to exported builds to wr/r - lr/r was really getting
on my nerves whenever I wanted to try something temporary out.

View source, save source and print handlers would all try to work if
there was no source to act on - despite the fact that toolbar buttons
would be greyed out form them. This is fixed.

The Navigate menu has components greyed to match the toolbar state,
when opened. It isn't kept up to date dynamically, though this shouldn't
really be a problem (reopen the submenu...). As part of this, finally
sorted out conditions for the Stop button to be greyed, or the
GoTo/Go/Stop tristate to be at 'Stop' versus 'GoTo'.

Deferred reformatting is now disabled for external image fetches.

Browser-local client pull flag removed; hitting the Stop button simply
cancels any null handlers working for it. That way, client pull switches
back on in passing at the next fetch (it was never really switched off).
So to stop client pull, hit the stop button at any point.

Done CELLPADDING attribute; cellpadding field in reformat_cell (Global.h)
is redundant since the table token is accessible from there, and so it has
been removed. CELLSPACING support also added.
@
text
@d148 1
a148 2
  _kernel_oserror * e;
  ObjectId          id;
d181 1
a181 2
  _kernel_oserror * e;
  int               state, selected;
a241 2
  _kernel_oserror * e;

@


1.11
log
@Now handles PARAM tags. Sorted out Plug-In bug that was related to Java
setting a 0 by 0 graphics window before calling Wimp_Poll (fixed in Java).
Implemented queue for Plug-Ins so multiple broadcasts aren't sent for
several Objects in one data chunk.

Added Docs directory with some documentation in it. More things to keep
checking for stylistic consistency, horray ;-)

Corrected !Run[D] for Ursula build to need AcornURI but not TaskModule
(URI handler needed for !Mail to pick up mailto: links).

Added display_height field to browser_data, analogous to display_width,
to cope with % sized objects by width and height (see how HRs are
handled in Redraw.c for an example of how it was always fairly easy
with width, but not height until this addition). Though you do have
to reload to get a new size; reformat isn't enough. Must see to this
some time...

Fixed bug where basic typefaces were claimed *before* the Choices file
had been read. For unusual Choices settings, this could create some
'interesting' problems now and again. This was part of narrower scope
work in the Choices code to allow font changing without leaking font
handles (now done; fm_shutdown only ditches fonts, it keeps internal
structures - must then call  fm_lose_fonts for all browsers to get the
bitfields up to date, then rewrite the typeface definitions and reclaim
basic fonts). Noticed that fm_claim_basic_typefaces would claim multiple
instances of the same font if there were several cases of the same font
mapped to different typeface styles - fixed.

Implemented PlugInControl settings, but not SupportObject (fully).
@
text
@d672 2
a673 1
      /* Restore input focus to the browser window */
d675 1
a675 1
      if (ancestor_id)
d677 19
a695 2
        e = browser_give_general_focus(ancestor_browser);
        if (e) goto print_close_exit;
@


1.10
log
@Tidied up Hotlist source a bit more, mostly so PSI can use the automatic
StrongHelp generator on it. Revealed a spurious toolbox_hide_object call
that would always fault and never do anything, and a few heinous uses
of show_error which have all been removed.

When dragging hotlist items, directories will now be highlighted whenever
the item would be added to them, rather than just over the sprite. In
practice this only changes if the item is open and has contents...

Drag box selections had broken in the hotlist; fixed (uninitialised
variable in hotlist_select_box). Adjust-drags now close the window on
completion. Minor problem with Shift+Drag (copy) reversing order of items
sorted out. Added hotlist_add_html_file and implemented loading of HTML.
DO NOT add broken HTML files, this has not been coded for and URLs of the
form http:///this/that (no host name) will hang the machine (bug in the
cookie code of the HTTP module up to at least version 0.39).

Made SELECT list items only as wide as the widest entry actually appears
(using fm_get_string_width), rather than as wide as the widest character
BBox in the font multiplied by the string length of the longest entry.

Updated !Run[D] files to require HTTP 0.39, FTP 0.12 and File 0.23.
@
text
@d129 1
a129 1
static void              print_prepare_browser (browser_data * source, browser_data * store, int lmarg, int rmarg);
d968 1
a968 1
    print_prepare_browser(b, &localbrowser, lmarg, rmarg);
d1607 1
a1607 1
static void print_prepare_browser(browser_data * source, browser_data * store, int lmarg, int rmarg)
d1618 5
d1656 1
@


1.9
log
@Choices and Controls files are now loaded into malloc space (use chf and
cof to address them). Previously only in Main.c, task_dir is now globally
visible.

Choices updated to allow 16ths of a point in the font size specification
and the System font face has been removed - it isn't used. The use of
serif and sans serif fonts has been rationalised across builds (e.g. Desktop
builds use what they say, but the Customer build uses Homerton as the
default body (serif, so to speak) font as it matches the box's look and
feel better).

Font loading altered a bit to work properly! Font library defines some
standard startup fonts without using Choices, which Choices can then
override.
@
text
@d427 1
a427 1
                                                                             1);
@


1.8
log
@Now working on source merged with Kevin Bracey's internationalisation
support. UNIFONT is undefined in the Make File for now. All Res and
Choices files updated appropriately.

Having sorted out the old Choices and Messages to form Choices, Controls
and Messages, this build has had the same cleaning up done internally.
This includes greater consistency in naming schemes and the removal of
the inconsitent choices items - e.g. Choices file entries saying 'delay
images' and 'plain backgrounds' where internally all the flags say 'show
images' and 'show backgrounds'. ChoiceDefs.h and CtrlDefs.h added to
clarify the meaning of some fields, though usage of these is not 100%
in the source (there are cases where parameters are passed through to
functions as ints, and those functions still check these against hard
coded values rather than the #define stuff).

Fetcher status return bits (connected, sent request, etc.) now reflected
in status bar. Progress during fetchs to files are reported by %, where
the size of the object is known. Exceeding 100% drops back to a byte
counter, in case the estimated size was wrong. The progress counter
may be updated after specific delays, rather than 'as often as possible',
to reduce flicker (as requested by D.Brown some time ago).

I've done a small rewrite of the fetch prioritisation scheme in FetchPage.c;
how well this performs in general use across different processor speeds
remains to be tested, but certainly it has some advantages. For each small
fetch window before the rewrite, a 4cs tight loop was entered - this gave a
noticable and substantial drain to the Desktop performance if more than one
was opened. Now, several can be up at once with little hit. The actual file
fetch is on half the priority it was before, with all others taken back
just a bit - e.g. from 20cs per poll to 15cs per poll for flat out
reformatting. You don't seem to lose much time on the format in practice,
and the Desktop feels quite a bit lighter at the same time. There's the
potential for smoother frameset loading in this scheme, too.

When Shift+Clicking on a link meant you still fetched inside the main
browser window, several fetches could occur in a frameset - one per frame.
However, now that you can only do this by clicking on a link that leads to
non-displayable data - or by turning off the small fetch windows by
setting UseSmall to 'no' in Choices - a bug where fetchpage_preprocessed
would stop such fetches as new ones were started was revealed.
The API to frames_abort_fetching has now been extended to include a
'stop file spooling too' flag, allowing a fix to be made by having
fetchpage_preprocess's calls not set this (and it doesn't check the
savelink flag is unset before proceeding, since frames_abort_fetching
does that implicitly now).

Had left the RAM transfer buffer at 16 bytes (from testing) accidentally...
Oops. Upped it to 4K. In addition, when loading data by RAM transfer,
the browser didn't notice if a RAMFetch bounced during the transfer. It
would be treated as a 'first' RAMFetch bounce, basically, and try to go to
file transfer - oops. Fixed.
@
text
@d1057 1
a1057 8
    if (choices.system_font)
    {
      h = fm_find_font(NULL, "system", 192,192,0,0); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "system", 192,192,1,0); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "system", 192,192,0,1); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
      h = fm_find_font(NULL, "system", 192,192,1,1); _swix(PDriver_DeclareFont,_INR(0,2),h,0,2); fm_lose_font(NULL, h);
    }
    else
@


1.7
log
@As warned in the last log, pretty much all event codes and component IDs
have now changed along with many of the names, to provide a consistent
name and numberspace for events and components. This also minimises
number clashes (e.g. as was, the Save File origin when opened from a
Hotlist menu with an already-used component ID). To get full details on
this, please carefully read through TBEvents.h.

Res files, Sprites files and Messages files have been updated again both
due to the above, and routine additions (e.g. message support for a few
Hotlist bits and pieces). !Run[D] files updated for FTP 0.11 and
HTTP 0.36.

In the Makefile, the Customer objects list was missing Save - must have
moved something when I should've copied it, when adding in SaveFile or
SaveObject in all probability. Now fixed. Couple of other bits and bobs
fixed in the build environment (e.g. stuff saying !Argo instead of
!Customer). Oh, and I've altered the MakeFile copy options again to the
best compromise I can come up with. Newer is turned on for everything
except !Run[D] and !RunImage, since both of those change between debug
builds - otherwise if you'd built debug and non-debug versions, it was
not possible to switch between them - one version would have the newer
timestamp and thus never get overwritten.

The default hotlist has had a few items added - that'll be about the end
of it, I think; there's more than enough stuff in there now.

Saving of the hotlist from the document menu and of URI files,
directories and selections from the hotlist menu tree is now implemented
- this new save system rocks... Oh, and you can save all images and
backgrounds as sprites.

Saving of items with Shift+Click to other applications directly now
works, and is robust. Unique Scrap filenames are used, with data load
bounces (e.g. if some pra - er, person quits the app they're sending
to) working correctly - that is, give an error, keep the file, rename
it to something safe, and open the directory it lies in. As opposed
to normal app-to-app bounces, where the scrap file is deleted (see
PRM 3-254). This means you can now look at README files in FTP
sites, say, without using a disc intermediate. Or you can send pictures
straight to ChangeFSI, fetch HTML links into editors, and so-on, and
so-on - it's all very funky. Known problems include the ambiguous
'invalid component ID' instead of 'file open' for *normal* (straight to
disc) shift+click saves, and I think I'll introduce a unique name
guarantee of some sort to stop 'file open' in the first place. Odd
that the really tricky part (app-to-app) should be least likely to
suffer from this!
@
text
@d95 4
a98 4
  unsigned int underlinelks  :1;
  unsigned int sourcecolours :1;
  unsigned int displayimages :1;
  unsigned int plainback     :1;
d415 4
a418 4
    restore.underlinelks  = ancestor_browser->underlinelks;
    restore.sourcecolours = ancestor_browser->sourcecolours;
    restore.displayimages = ancestor_browser->displayimages;
    restore.plainback     = ancestor_browser->plainback;
d536 1
a536 1
       fixed.dboxanims &&
d621 1
a621 1
                                                                             restore.plainback);
d663 1
a663 1
         fixed.dboxanims &&
d824 4
a827 4
                                    restore.underlinelks,
                                    restore.sourcecolours,
                                    restore.displayimages,
                                    restore.plainback));
d1000 1
a1000 1
  localbrowser.sourcecolours = 0;
d1057 1
a1057 1
    if (choices.systemfont)
d1120 1
a1120 1
    if (!fixed.swapbars)
@


1.6
log
@First a minor warning - the various Res files are out of sync in this build.
Only the Browse resources are currently valid.

Added Utils.Icons - has a few archives inside containing the resources
(well, some of them) used to build various UI sprites for various builds.
Archived because these are unlikely to change much, and putting them on
CVS was a move to, well, archive the stuff...

SaveDBox objects vanquished and requirements in !Run[D] files removed. The
data save code fits much more neatly in amongst the data load protocol
stuff now (with the slight exception of having to split the SaveObject
source into SaveObject and SaveFile - the former handles multiple persistent
dialogues for Shift+Click on links and the like, the latter handles 'one at
a time' transient dialogues for save source and similar). Export Link is now
supported, too, and writes a 'proper' version URI file. You'll find that
double-clicking on old URI files will work as the URI handler picks them up,
whilst new version ones don't; however, dragging onto the browser will only
work with new version files. Note that support for saving and loading URL
files (ANT suite stuff) is present too, so old URI files can be typed as URL
files if you want to keep them working without modification - the URI
handler itself will hopefully support the defined URI file format soon;
double-clicking on old URI files will stop working at that point. Note
there are *lots* of changes in every Res file to support all this. This may
all seem a bit pointless to some, but the changes do in fact make it very
easy to add new save dialogues all over the place. Certainly much easier
than with the previous system, anyway. In fact, post script, image
'save as sprite' took about half an hour, which I hope proves the worth
of the new system.

Merged in newer hotlist code with support for drag cancelling with Escape
(all relevant Res files appropriately updated) and cancelling scrolling
when you've reached the window scroll limit. Had to move some of the
Wimp message handling stuff to the central Protocols source, as clashes
were occuring, and also the hotlist routines were using independent saving
code - a lot of duplicated effort. This was fair enough as at the time the
Hotlist code was written, the Save code couldn't be used in the way it is
now.

New Save Source and Print buttons on the toolbar of some builds.

Phoenix Sprites file made more efficient - the Acorn base section has been
split from the animated upper region. Browse build has a new grey fade
sprite at the back, which is less grainy than the previous one and only
uses 16 colours (with a 16 greyscale palette).

Not really a bug, bug the routine to start an image fetch for INPUT
TYPE=IMAGE forms items only did so if the src field (or equivalent, for
this tag type) was non-NULL. In fact, you should always call image_new_image
and let that handle the rest, otherwise other sections of the code will fail
as they try to obtain an image number for a given HStream and get -1 back.
This problem only generally manifested itself when loading an HTML file to
the browser straight from an application, as many src fields become NULL
when the relativisation routines find nothing to relativise to...

Authentication got broken somewhere along the line - this has been fixed
(in HTMLLib and the browser).

Ctrl+Click on a cross referenced image updates *all* copies, not just the
one with the image data attached.

Next big step: Rip up TBEvents.h and rebuild that whole approach somewhat.
To all those working on the code, my apologies but this means all Res files
will receive a very large number of alterations and there will be extensive
code changes too (mostly naming convention stuff), in more or less all
source files. I am endeavouring to ensure that the new numberspace
convention does not clash with the work being done by Kevin on
internationalisation.
@
text
@d187 1
a187 1
  RetError(radiobutton_get_state(0, dialogue, StartWhole, &state, NULL));
d191 1
a191 1
  /* pages defined in the 'EndManyNum' number range gadget       */
d193 2
a194 2
  RetError(radiobutton_get_state(0, dialogue, EndWhole, NULL, &selected));
  RetError(numberrange_get_value(0, dialogue, EndManyNum, &contents->pages));
d196 3
a198 3
  /* Note that EndVisible etc. are component IDs defined in */
  /* Print.h, whilst End_Visible (with the underscore) etc. */
  /* are option values defined at the top of this file.     */
d202 2
a203 1
    case EndVisible: contents->end = End_Visible;
d206 1
a206 1
    case EndMany:    contents->end = End_Many;
d209 1
a209 2
    default:
    case EndWhole:   contents->end = End_Whole;
d215 1
a215 1
  RetError(optionbutton_get_state(0, dialogue, ReformToFit, &state));
d220 1
a220 1
  RetError(radiobutton_get_state(0, dialogue, OriUpright, &state, NULL));
d225 1
a225 1
  RetError(numberrange_get_value(0, dialogue, CopiesNum, &contents->copies));
d248 2
a249 2
  if (!contents->start)       RetError(radiobutton_set_state(0, dialogue, StartVisible, 1))
  else                        RetError(radiobutton_set_state(0, dialogue, StartWhole,   1));
d256 1
a256 1
    case End_Whole:    RetError(radiobutton_set_state(0, dialogue, EndWhole,   1));
d258 1
a258 1
    case End_Visible:  RetError(radiobutton_set_state(0, dialogue, EndVisible, 1));
d260 1
a260 1
    case End_Many:     RetError(radiobutton_set_state(0, dialogue, EndMany,    1));
d264 1
a264 1
  RetError(numberrange_set_value(0, dialogue, EndManyNum, contents->pages));
d268 1
a268 1
  RetError(optionbutton_set_state(0, dialogue, ReformToFit, contents->reformat));
d277 2
a278 2
  if (!contents->orientation) RetError(radiobutton_set_state(0, dialogue, OriSideways, 1))
  else                        RetError(radiobutton_set_state(0, dialogue, OriUpright,  1));
d282 1
a282 1
  RetError(numberrange_set_value(0, dialogue, CopiesNum, contents->copies));
d453 1
a453 1
                                          EStartPrint,
d458 1
a458 1
                                          ECancelPrint,
d486 1
a486 1
                                      loop == 1 ? CopiesNum : EndManyNum,
d529 1
a529 1
                                          EEnableReformat,
d537 1
a537 1
       !gadget_get_type(0, window_id, DisplayAnim, NULL)
d664 1
a664 1
         !gadget_get_type(0, window_id, DisplayAnim, NULL)
d716 2
a717 2
  ChkError(radiobutton_get_state(0, window_id, StartWhole, NULL, &state1));
  ChkError(radiobutton_get_state(0, window_id, EndWhole,   NULL, &state2));
d719 3
a721 3
  /* If the StartVisible and EndVisible radios are not selected, */
  /* can enable the Reformat option; else disable it. But only   */
  /* change it's state (don't grey it if already greyed, say).   */
d723 1
a723 1
  ChkError(gadget_get_flags(0, window_id, ReformToFit, &flags));
d725 1
a725 1
  if (state1 != StartVisible && state2 != EndVisible)
d729 1
a729 1
      ChkError(gadget_set_flags(0, window_id, ReformToFit, flags & ~Gadget_Faded));
d736 1
a736 1
      ChkError(gadget_set_flags(0, window_id, ReformToFit, flags | Gadget_Faded));
d743 1
a743 1
    char text[Limits_EndManyLabel];
d745 1
a745 1
    ChkError(numberrange_get_value(0, window_id, EndManyNum, &pages));
d747 1
a747 1
    ChkError(button_get_value(0, window_id, EndManyLabel, text, Limits_EndManyLabel, NULL));
d757 1
a757 1
        ChkError(button_set_value(0, window_id, EndManyLabel, lookup_token("PagesSingle:sheet is filled",0,0)));
d766 1
a766 1
        ChkError(button_set_value(0, window_id, EndManyLabel, lookup_token("PagesMany:sheets are filled",0,0)));
@


1.5
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d57 1
a60 1
#include "Save.h"
d133 36
d401 10
a567 2
  WimpMessage m;

d582 1
a582 19
  m.hdr.your_ref    = 0;
  m.hdr.action_code = Browser_Message_PrintSave;

  m.data.data_save.destination_window = 0;
  m.data.data_save.destination_icon   = 0;
  m.data.data_save.destination_x      = 0;
  m.data.data_save.destination_y      = 0;
  m.data.data_save.estimated_size     = -1;
  m.data.data_save.file_type          = FileType_POUT;

  StrNCpy0(m.data.data_save.leaf_name,
           lookup_token("PrintName:WebPage",0,0));

  m.hdr.size = (strlen(m.data.data_save.leaf_name) + 44);
  if (m.hdr.size & 3) m.hdr.size = (m.hdr.size & ~3) + 4;

  ChkError(wimp_send_message(Wimp_EUserMessageRecorded, &m, 0, 0, NULL));

  printer_message_ref = m.hdr.my_ref;
@


1.4
log
@Very long log entry alert - but hey, beats 'Bug fixed' (sorry, Richard) ;-)

Open URL implementation more or less complete, though may undergo UI
revision at a later date to allow named frames to be targetted. Hope to use
the ideas in this code as the foundation for other general dialogues.

In token stream dump for TRACE builds, table head items were not indented
as far as they should have been - this is fixed; and manual toolbar redraw
routines have been removed. They never worked, were commented out, and
would never be used in that form anyway.

DragBox source added, but it isn't at all complete and won't work - this is
an 'in spare time' thing. We need custom drag boxes constrained to windows
for the hotlist, and unconstrained for frame border resizing... Hey ho.

Ancestor window extents match visible areas if there are frames (no more
scrolling framesets...!). Frame resizing works whilst new documents fetch
without pulling the extent down now. However, frame horizontal extents
never shrink until a reload which is nasty, and this is all due for a
rewrite. Frames border redrawing routine moved out of Redraw.c and into
Frames.c. Bug regarding the mouse rectangle and frame border widths
(rectangle was too large, so you could squash the edges) for edge-drag
frame resizes fixed.

Window width change reformat tolerance fixed; you could creep the window
width down or up forever without any reformat, and centred objects would
move but not be redrawn (thereby giving rise to subsequent redraw errors).

Filetype on objects saved through Shift+Click correct. Save Source dialogue
recognises if that source is plain text, rather than assuming HTML. A
browser that fetches a file remembers the old store size it had before the
save, so even though the data is now ditched, it reports the same amount of
data fetched afterwards (looked awful when this could, for example,
suddenly say '0' after a file save). Progress indicator is now fully aware
of one or many file saves inside a frameset and reports the number of
saves, a colon, and the cumulative saved data count, instead of reporting
the sum total of fetched data in all frames, including non-file save stuff
(note that for just 1 save, '1:' is not shown as a special case for the
most common condition). A bug related to this, where you could in fact only
do one fetch per frame*set*, has been corrected (only one fetch allowed per
frame still, this is unlikely to ever change).

Hotlist support added (D.Brown's source), with various bits of integration
and modification still in progress there. Note additions to the Messages
files. On the subject of Messages, the whole mucky business about what
goes in Messages or Choices (and a few bugs where lookup_choice was used
instead of lookup_token or vice versa) has been sorted out. Messages
contains, more or less, just that. Choices contains user configurable
stuff which generally can't mess things up too badly. A new file, Controls,
is a Messages file holding the non-user configurable choices, which can
generally make things go badly wrong if misused. A lot of these are tied
to the Res file. StrongED users can get these to automatically fold out
the various sections (EMail me for details). Sorry, but at the time of
writing, Zap doesn't do folding... =8*P

Two bugs with images. Asking for images to be shown in browser B when
browser A uses the same ones and was loaded first didn't work correctly,
and now does (a bit weird - browser A does the fetch and browser B does the
display...). Second one occurred when the background image was also used on
the page as a foreground image. This has been fixed by flagging background
images in the image_info structure, and checking this before cross
referencing. This bit also allowed the image_restart_fetches API to be
extended, so that just background or foreground images may be fetched if
they weren't already and the user asked the browser to show them. Before,
the whole lot had to be fetched together (so turning on 'display
backgrounds' will now kick off an image fetch if required, you don't
need to reload the page anymore).

Makefile copy options tweaked to be 'newer' (so if you're testing with some
temporary Choices file or something, it won't write over it at the end of
every export), and REMOTE_HOTLIST flag added for Customer builds - means
the Hotlist.c functions aren't needed; the old, hotlist-by-file method is
used. Added support for Customer build (see later), though there were very
few additions needed in practice.

Table printing fixed - in many ways it wasn't broken, it was image printing
causing the oddities ever since the global image pool was introduced (this
is, again, fixed). The 'reformat to fit page' option didn't work as coded
any more; tables store cell addresses in the HStreams, so you can't then do
a background reformat in a different browser. Hence, it now has to reformat
to the page width, print, then put the page back again, all in the actual
displayed browser. This doesn't feel as slow in use as it perhaps should,
considering what is going on... Note that a line of a defined fraction (see
Print.h) of page height will now split over page boundaries, so tall images
or tall tables don't cause problems now (aside from the obvious problem of
having the line split over a page at all!). There was a bug in the routine
to print from a given start point until 'n' pages had been filled, in that
it always filled 'n + 1' - now fixed. Finally, as part of the printing
tweaks, a new dialogue exists - PrintStyle - with a similarly named source
file added to deal with it.

Global history auto save / load done, but only to the Choices file path -
the whole browser is still strictly single user at present, with all the
extra work for a multiuser Customer environment yet to be done. This has
shown up a global history corruption problem which I haven't fixed yet.

Rationalising TBEvents.h - things are migrating out of it, and into more
appropriate sources (e.g. definitions relating to the Open URL dialogue are
going into OpenURL.h, etc.). Event codes were at one stage deliberately
diverged in numberspace from the component IDs of typical gadgets raising
the events, to avoid anyone getting confused and thinking the IDs and event
codes must match. However, this is in fact unlikely and it is much easier
to remember the fewer numbers that result from tying the two together where
possible. This has resulted in changes to event codes raised in the
following objects of all Res files: Authorise, Find, OpenURL, and
PrintStyle.

And finally - !Run[D] files for all variants updated to require the latest
toolbox and fetcher modules. All Res files updated for hotlists etc. and
sprites files updated appropriately. All Messages, Choices and Controls
files brought in sync., and an Customer build has been added (based on the
Desktop build binary with different resources).

That's all for now...
@
text
@d759 3
a761 1
/* Parameters: Pointer to pathname to print to.  */
d835 4
a838 1
/*             Pointer to pathname to print to.  */
@


1.3
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@d20 5
d28 3
a50 1
#include "TBEvents.h"
d57 1
d67 25
a91 1
/* Local structures */
d95 4
a98 7
  browser_data * p;           /* Records for whom the print dialogue was opened.                                   */
  int            copies;      /* Number of copies to print.                                                        */
  int            start;       /* 1 = whole page, 0 = top of visible area.                                          */
  int            end;         /* 0 = whole page, -1 = to bottom of visible area, > 0 = number of pages to fill.    */
  int            pages;       /* Remembers the number of pages set, if 'end' is 0 or -1, to enable Cancel to work. */
  int            reformat;    /* 1 = reformat to fit page (if start is not 0 and end is not -1), else don't.       */
  int            orientation; /* 1 = portrait, 0 = landscape.                                                      */
d100 1
a100 1
} print_info;
d104 2
a105 3
static int        globaljob     = 0;
static int        globalold_job = 0;
static int        mustfree      = 0;
d107 9
a115 2
static print_info print_current;
static print_info print_old;
d119 62
a180 2
static int  print_pre_initiate (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int  print_pre_restore  (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
d182 1
a182 1
static void print_free_memory  (browser_data * localbrowser);
d184 2
a185 1
/* Local macro - swap two signed / unsigned ints / chars. */
d187 133
a319 1
#define SWAP(a,b) { (a) ^= (b); (b) ^= (a); (a) ^= (b); }
d336 13
a348 2
  ObjectId id;
  int      upper, lower;
d350 1
a350 1
  /* Get the browser_data structure pointer */
d352 1
a352 1
  ChkError(toolbox_get_client_handle(0, idb->ancestor_id, (void *) &print_current.p));
d354 43
a396 1
  /* Get the print dialogue's actual window object ID into id. */
d398 1
a398 1
  ChkError(printdbox_get_window_id(0, idb->self_id, &id));
d400 4
d406 1
a406 1
  ChkError(event_register_toolbox_handler(id,
d408 2
a409 2
                                          print_pre_initiate,
                                          (void *) idb->ancestor_id));
d411 1
a411 1
  ChkError(event_register_toolbox_handler(id,
d413 2
a414 2
                                          print_pre_restore,
                                          (void *) idb->ancestor_id));
d418 1
a418 1
  if (!strcmp(lookup_token("AlterNumranges:no",0,0),"yes"))
d427 1
a427 1
    e = window_get_wimp_handle(0, id, &icon.window_handle);
d439 1
a439 1
                                      id,
d448 1
a448 1
        if (!e) e = gadget_get_icon_list(0, id, writable, iconlist, sizeof(iconlist), NULL);
d461 1
a461 1
            strncpy(buffer, lookup_token("AlterWith",1,0), sizeof(buffer) - 1);
d471 1
a471 2
  /* If print_current.copies is zero, this is the first time */
  /* the dialogue has been opened, so set up defaults.       */
d473 4
a476 3
  if (!print_current.copies)
  {
    /* Number of copies */
d478 3
a480 1
    print_current.copies = atoi(lookup_choice("PrintCopies:1",0,0));
d482 4
a485 1
    /* Check it's within bounds */
d487 1
a487 3
    ChkError(numberrange_get_bounds(NumberRange_LowerBound | NumberRange_UpperBound,
                                    id,
                                    CopiesNum,
d489 7
a495 4
                                    &lower,
                                    &upper,
                                    NULL,
                                    NULL));
d497 1
a497 2
    if (print_current.copies < lower) print_current.copies = lower;
    if (print_current.copies > upper) print_current.copies = upper;
d499 1
a499 2
    /* Start position - 'start' or 'visible', though in fact any */
    /* non-'visible' string defaults as 'start'.                 */
d501 1
a501 2
    if (!strcmp(lookup_choice("PrintStart:start",0,0),"visible")) print_current.start = 0;
    else print_current.start = 1;
d503 1
a503 3
    /* End position - 'end', 'visible', or a number of pages to fill. */
    /* if 'end' or 'visible' aren't recognised the number of pages is */
    /* defaulted to, if this gives a result <= 0, 1 is assumed.       */
d505 1
a505 7
    if (!strcmp(lookup_choice("PrintEnd:end",0,0),"end"))      print_current.end = 0;
    else if (!strcmp(lookup_choice("PrintEnd",1,0),"visible")) print_current.end = -1;
    else
    {
      print_current.end = atoi(lookup_choice("PrintEnd",1,0));
      if (print_current.end <= 0) print_current.end = 1;
    }
d507 2
a508 11
    ChkError(numberrange_get_bounds(NumberRange_LowerBound | NumberRange_UpperBound,
                                    id,
                                    CopiesNum,

                                    &lower,
                                    &upper,
                                    NULL,
                                    NULL));
    if (print_current.end > 1)
    {
      /* Check it's within bounds */
d510 9
a518 2
      if (print_current.end < lower) print_current.end = lower;
      if (print_current.end > upper) print_current.end = upper;
d520 3
a522 3
      print_current.pages = print_current.end;
    }
    else print_current.pages = lower;
d524 2
a525 1
    /* Reformat - 'yes' or 'no', default to 'yes' */
d527 1
a527 2
    if (!strcmp(lookup_choice("PrintReform:yes",0,0),"no")) print_current.reformat = 0;
    else print_current.reformat = 1;
d529 3
a531 2
    /* Orientation - 'upright' or 'sideways', though in fact any */
    /* non-'sideways' string defaults as 'upright'.              */
d533 2
a534 3
    if (!strcmp(lookup_choice("PrintOrient:upright",0,0),"sideways")) print_current.orientation = 0;
    else print_current.orientation = 1;
  }
d536 1
a536 2
  /* Copy print_current to print_old in case restoration is needed later, */
  /* and fill in the dialogue as appropriate.                             */
d538 2
a539 1
  print_old = print_current;
d541 6
a546 1
  /* Start position */
d548 2
a549 2
  if (!print_current.start)       ChkError(radiobutton_set_state(0, id, StartVisible, 1));
  else                            ChkError(radiobutton_set_state(0, id, StartWhole,   1));
d551 2
a552 1
  /* End position, including the 'number of pages to fill' number range */
d554 1
a554 3
  if (!print_current.end)         ChkError(radiobutton_set_state(0, id, EndWhole,     1));
  else if (print_current.end < 0) ChkError(radiobutton_set_state(0, id, EndVisible,   1));
  else                            ChkError(radiobutton_set_state(0, id, EndMany,      1));
d556 1
a556 2
  if (print_current.end > 0)      ChkError(numberrange_set_value(0, id, EndManyNum, print_current.end));
  else                            ChkError(numberrange_set_value(0, id, EndManyNum, print_current.pages));
d558 2
a559 1
  /* The reformat optionn, including greying / ungreying it */
d561 9
a569 1
  ChkError(optionbutton_set_state(0, id, ReformToFit, print_current.reformat));
d571 3
a573 2
  /* As well as greying / ungreying the reformat option, this handles */
  /* the label text on the 'pages to fill' number range.              */
d575 1
a575 2
  {
    IdBlock idlocal;
d577 1
a577 3
    idlocal.self_id = id;
    print_check_contents(NULL, NULL, &idlocal, NULL);
  }
d579 2
a580 1
  /* Orientation */
d582 1
a582 2
  if (!print_current.orientation) ChkError(radiobutton_set_state(0, id, OriSideways, 1));
  else                            ChkError(radiobutton_set_state(0, id, OriUpright,  1));
d584 3
a586 3
  /* Number of copies */

  ChkError(numberrange_set_value(0, id, CopiesNum, print_current.copies));
d588 1
a588 11
  /* Register a handler to cope with the pages number range changing */

  ChkError(event_register_toolbox_handler(id,
                                          NumberRange_ValueChanged,
                                          print_check_contents,
                                          NULL));

  /* Animation handler if there's an appropriate gadget */

  {
    int temp_type;
d590 6
a595 7
    if (
         fixed.dboxanims                                  &&
         !gadget_get_type(0, id, DisplayAnim, &temp_type)
       )
       register_null_claimant(Wimp_ENull,
                              toolbars_animate_slow,
                              (void *) id);
a597 2
  /* Done! */

d602 1
a602 1
/* print_pre_restore()                           */
d604 8
a611 6
/* Called for a non-standard Cancel button in a  */
/* PrintDBox object or an alternate window it is */
/* using. Closes the dialogue, resulting in an   */
/* appropriate DialogueCompleted event being     */
/* raised; print_restore will consequently be    */
/* called for the dialogue.                      */
d613 2
a614 2
/* Parameters are as standard for a Toolbox      */
/* event hander.                                 */
d617 1
a617 1
static int print_pre_restore(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d619 1
a619 1
  ChkError(toolbox_hide_object(0, idb->self_id));
d621 1
a621 2
  return 1;
}
d623 1
a623 12
/*************************************************/
/* print_restore()                               */
/*                                               */
/* Called when a print dialogue is cancelled.    */
/* Simply copies the local static print_info     */
/* structure 'print_old' over 'print_current' so */
/* that next time the dialogue is opened, it     */
/* holds the old settings.                       */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event hander.                                 */
/*************************************************/
d625 1
a625 3
int print_restore(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
//  print_current = print_old;
d627 3
a629 1
  ChkError(event_deregister_toolbox_handlers_for_object(idb->self_id));
d631 2
a632 1
  /* If there was a null handler for the dialogue, remove it */
d634 1
a634 2
  {
    int temp_type;
d637 2
a638 2
         fixed.dboxanims                                            &&
         !gadget_get_type(0, idb->self_id, DisplayAnim, &temp_type)
d642 1
a642 2
                                (browser_data *) idb->self_id);
  }
d644 3
a646 1
  /* Restore focus to the browser window */
d648 5
a652 2
  {
    browser_data * ancestor;
d654 1
a654 2
    if (idb->ancestor_id) ChkError(toolbox_get_client_handle(0, idb->ancestor_id, (void *) &ancestor));
    else ancestor = last_browser;
d656 2
a657 1
    if (ancestor) browser_give_general_focus(ancestor);
d660 1
a660 2
  return 1;
}
d662 1
a662 12
/*************************************************/
/* print_pre_restore()                           */
/*                                               */
/* Called for a non-standard Print button in a   */
/* PrintDBox object or an alternate window it is */
/* using. Raises appropriate events to complete  */
/* the dialogue and initate printing through     */
/* print_initiate.                               */
/*                                               */
/* Parameters are as standard for a Toolbox      */
/* event hander.                                 */
/*************************************************/
d664 1
a664 9
static int print_pre_initiate(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  idb->ancestor_id = (ObjectId) handle;

  print_initiate(eventcode, event, idb, (void *) 1 /* (Flag - see print_initiate) */);

  ChkError(toolbox_hide_object(0, idb->self_id));

  return 1;
d668 1
a668 1
/* print_initiate()                              */
d670 8
a677 5
/* Examines the Print dialogue box's contents    */
/* and fills in the local static print_info      */
/* structure 'print_current' with them; then     */
/* starts a print routine by broadcasting a      */
/* PrintSave message.                            */
d680 1
a680 1
/* event hander.                                 */
d683 1
a683 1
int print_initiate(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d685 4
a688 25
  browser_data * b;
  ObjectId       id;
  int            selected;

  /* Get the browser_data pointer for the ancestor window - i.e. */
  /* the browser from which this print dialogue was opened.      */

  ChkError(toolbox_get_client_handle(0,idb->ancestor_id,(void *) &b));

  /* Get the Object ID of the window that has opened on behalf of */
  /* the Print dialogue.                                          */
  /*                                                              */
  /* If called from print_pre_initiate, the self_id will be that  */
  /* of the alternate window anyway. (int) handle = 1 flags this. */
  /*                                                              */
  /* Amazingly, printdbox_get_window_id doesn't seem to return an */
  /* error - just an invalid ID - if called on something that is  */
  /* not a PrintDBox object...                                    */

  if (!((int) handle)) ChkError(printdbox_get_window_id(0, idb->self_id, &id));
  else id = idb->self_id;

  /* Fill in the local static print_info structure 'print_current'. */
  /*                                                                */
  /* 'start' = 1 for whole page, 0 for just the visible area        */
d690 2
a691 1
  ChkError(radiobutton_get_state(0, id, StartWhole, &print_current.start, NULL));
d693 3
a695 2
  /* 'end' = 0 for whole page, -1 for just the visible area, or */
  /* any other number = the number of pages to fill.            */
d697 1
a697 1
  ChkError(radiobutton_get_state(0, id, EndWhole, NULL, &selected));
d699 8
a706 1
  switch (selected)
d708 4
a711 6
    case EndVisible: print_current.end = -1;
    break;
    case EndMany:    ChkError(numberrange_get_value(0, id, EndManyNum, &print_current.end));
    break;
    case EndWhole:
    default:         print_current.end = 0;
d714 1
a714 13
  /* 'reformat' = 1 to reformat to fit the paper, else 0 */

  ChkError(optionbutton_get_state(0, id, ReformToFit, &print_current.reformat));

  /* 'orientation' = 1 for portrait, 0 for landscape */

  ChkError(radiobutton_get_state(0, id, OriUpright, &print_current.orientation, NULL));

  /* Get the number of copies into 'copies' */

  ChkError(numberrange_get_value(0, id, CopiesNum, &print_current.copies));

  /* First stage of printing protocol: Broadcast a PrintSave message */
d717 1
a717 1
    WimpMessage m;
d719 1
a719 2
    m.hdr.your_ref    = 0;
    m.hdr.action_code = Browser_Message_PrintSave;
d721 2
a722 6
    m.data.data_save.destination_window = 0;
    m.data.data_save.destination_icon   = 0;
    m.data.data_save.destination_x      = 0;
    m.data.data_save.destination_y      = 0;
    m.data.data_save.estimated_size     = -1;
    m.data.data_save.file_type          = FileType_POUT;
d724 4
a727 2
    StrNCpy0(m.data.data_save.leaf_name,
             lookup_token("PrintName:WebPage",0,0));
d729 8
a736 2
    m.hdr.size = (strlen(m.data.data_save.leaf_name) + 44);
    if (m.hdr.size & 3) m.hdr.size = (m.hdr.size & ~3) + 4;
d738 5
a742 3
    ChkError(wimp_send_message(Wimp_EUserMessageRecorded, &m, 0, 0, NULL));

    printer_message_ref = m.hdr.my_ref;
d755 4
d766 6
d774 7
a780 6
  e = print_page(print_current.p,
                 print_current.copies,
                 print_current.start,
                 print_current.end,
                 print_current.reformat,
                 print_current.orientation,
d786 15
d819 6
a824 5
/*             0 to end at the bottom of the web */
/*             page, -1 to end at the bottom of  */
/*             the visible area, or any >0 value */
/*             which is taken as the number of   */
/*             pages to try and fill;            */
d836 2
a837 2
_kernel_oserror * print_page(browser_data * b, int copies, int from, int to,
                             int reformat, int orientation, const char * path)
d842 1
a842 1
  int                     job, old_job;
d844 11
a854 3
  int                     more, page, maxpages, top, bottom, temp, next_line;
  int                     estimated_pages, area_completed, page_area;
  int                     lmarg, bmarg, rmarg, tmarg;
a860 1
  reformat_cell           localcell;
d892 2
a893 2
    SWAP(tmarg,rmarg);
    SWAP(bmarg,lmarg);
d896 8
a903 2
  localbrowser = *b;
  memset(&localcell, 0, sizeof(localcell));
d908 1
a908 1
  if (reformat && (to >= 0) && from)
d910 1
a910 1
//    int lastchunk, percentage;
d912 24
a935 4
    /* Reformat the page ready for printing.                       */
    /*                                                             */
    /* First copy over the existing browser_data structure, and    */
    /* modify the contents as appropriate.                         */
d937 2
a938 1
    localbrowser.previous = localbrowser.next = NULL;
d940 1
a940 1
    localbrowser.display_width = rmarg - lmarg;
d942 2
a943 1
    convert_to_os(localbrowser.display_width, &localbrowser.display_width);
d945 3
a947 1
    localbrowser.display_extent = localbrowser.display_width;
d949 6
a954 2
    localbrowser.fetch_status = BS_IDLE;
    localbrowser.fetch_handle = localbrowser.display_handle;
d956 1
a956 4
    localbrowser.source   = NULL;
    localbrowser.urlfdata = NULL;
    localbrowser.urlddata = NULL;
    localbrowser.cell     = &localcell;
d958 2
a959 3
    mustfree = 1;

    /* Now call the reformatter, and loop round until finished. */
d961 2
a962 24
    _swix(Hourglass_On, 0);

    e = reformat_format_from(&localbrowser, -1, 1, -1);
    if (e) return e;

    while (reformat_formatting(&localbrowser))
    {
      reformat_reformatter(&localbrowser);

// Broken now that there's no such thing as a token number...
// Moreover, needs adjusting to the cell based model.
//
//      /* Percentage progress indicator based on how far down the */
//      /* token list the reformat has reached.                    */
//
//      if (localbrowser.ldata && localbrowser.nlines)
//      {
//        lastchunk = localbrowser.ldata[localbrowser.nlines - 1].chunks + localbrowser.ldata[localbrowser.nlines - 1].n - 1;
//
//        percentage = (100 * localbrowser.cdata[lastchunk].t) / localbrowser.ntokens;
//        if (percentage > 99) percentage = 99;
//
//        _swix(Hourglass_Percentage, _IN(0), percentage);
//      }
d965 1
a965 1
    _swix(Hourglass_Off, 0);
d967 1
a967 1
  else mustfree = 0;
a970 8
  /* Hourglass for the print job, as this may take some time... */
  /* Using Hourglass_Start as otherwise the first percentage    */
  /* setting may be missed, since the hourglass isn't actually  */
  /* on yet (there's a default delay before appearance with     */
  /* calling Hourglass_On).                                     */

  _swix(Hourglass_Start, _IN(0), 1);

d992 1
a992 1
    estimated_pages = (reformat_return_extent(&localbrowser, NULL) / page_height) + 1;
a1114 11
  /* maxpages will be set either to the user-specified number of */
  /* sheets of paper to fill ('to' holds that number if greater  */
  /* than zero), else it holds a very large number - i.e. keep   */
  /* going until another exit condition occurs within the print  */
  /* loop (e.g. reaching the end of the web page).               */

  page = 0;

  if (to > 0) maxpages = to;
  else        maxpages = 0x1000000;

d1120 12
a1131 1
  while (page <= maxpages)
d1149 1
a1149 1
    convert_to_os(tmarg - bmarg, &temp); /* temp now holds the printable page height in OS units */
d1151 1
a1151 1
    if (to >= 0)
d1261 1
a1261 1
      e = redraw_draw(&localbrowser,
d1263 1
a1263 1
                      1,
d1345 3
a1347 2
    /* area of the page, this is flagged with 'to' < 0; if  */
    /* 'bottom' = 0 as well, there's nothing more to print. */
d1349 1
a1349 1
    if (to < 0 && !bottom) break;
a1375 4
  /* Turn off the hourglass */

  _swix(Hourglass_Off, 0);

d1392 47
a1438 1
  print_free_memory(&localbrowser);
d1465 4
d1473 1
a1473 1
  /* Free temporarily allocated memory */
d1475 5
a1479 1
  print_free_memory(&localbrowser);
d1490 1
d1492 9
a1500 1
  print_free_memory(&localbrowser);
d1505 1
a1505 1
out3: /* 'Emergency exit' for errors outside printing, where memory may be temporarily allocted */
d1508 9
a1516 1
  print_free_memory(&localbrowser);
d1563 15
a1577 1
/* print_free_memory()                           */
d1579 2
a1580 3
/* Frees up browser_data allocated memory used   */
/* locally for reformatting a page prior to      */
/* printing.                                     */
d1583 1
a1583 1
static void print_free_memory(browser_data * localbrowser)
d1585 35
a1619 1
  /* mustfree must be set to non-zero for any memory to be freed */
d1621 8
a1628 5
  if (mustfree)
  {
    memory_set_chunk_size(localbrowser, NULL, CK_LINE, 0);
    memory_set_chunk_size(localbrowser, NULL, CK_LDAT, 0);
  }
d1632 4
a1635 1
/* print_check_contents()                        */
d1637 22
a1658 8
/* If the state of the various radio buttons     */
/* changes, this may be called to see if the     */
/* Reformat option in the Print dialogue should  */
/* be enabled (ungreyed) or disabled (greyed).   */
/* Similarly, if the contents of the number of   */
/* sheets to fill number range changes, this     */
/* should be called to ensure the label has the  */
/* correct pluralisation applied.                */
d1660 1
a1660 2
/* Parameters are as standard for a Toolbox      */
/* event handler.                                */
d1663 1
a1663 1
int print_check_contents(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
d1665 4
a1668 61
  int          state1, state2, pages;
  unsigned int flags;

  /* Get the radio button states */

  ChkError(radiobutton_get_state(0, idb->self_id, StartWhole, NULL, &state1));
  ChkError(radiobutton_get_state(0, idb->self_id, EndWhole,   NULL, &state2));

  /* If the StartVisible and EndVisible radios are not selected, */
  /* can enable the Reformat option; else disable it. But only   */
  /* change it's state (don't grey it if already greyed, say).   */

  ChkError(gadget_get_flags(0, idb->self_id, ReformToFit, &flags));

  if (state1 != StartVisible && state2 != EndVisible)
  {
    if (flags & Gadget_Faded)
    {
      ChkError(gadget_set_flags(0, idb->self_id, ReformToFit, flags & ~Gadget_Faded));
    }
  }
  else
  {
    if (!(flags & Gadget_Faded))
    {
      ChkError(gadget_set_flags(0, idb->self_id, ReformToFit, flags | Gadget_Faded));
    }
  }

  /* Check the pages number range, and update the label if necessary. */

  {
    char text[Limits_EndManyLabel];

    ChkError(numberrange_get_value(0, idb->self_id, EndManyNum, &pages));

    ChkError(button_get_value(0, idb->self_id, EndManyLabel, text, Limits_EndManyLabel, NULL));
    text[sizeof(text) - 1] = 0;

    if (pages == 1)
    {
      /* If the existing text isn't what we intend to change it to, then change it; */
      /* i.e. don't set the same thing twice, as this will flicker badly.           */

      if (strcmp(text, lookup_token("PagesSingle:sheet is filled",0,0)))
      {
        ChkError(button_set_value(0, idb->self_id, EndManyLabel, lookup_token("PagesSingle:sheet is filled",0,0)));
      }
    }
    else
    {
      /* Again, only change the text - don't set the same thing twice. */

      if (strcmp(text, lookup_token("PagesMany:sheets are filled",0,0)))
      {
        ChkError(button_set_value(0, idb->self_id, EndManyLabel, lookup_token("PagesMany:sheets are filled",0,0)));
      }
    }
  }

  return 1;
@


1.2
log
@Quite a few general source changes throughout many files to sort out swapped
toolbars. There will be more work on this shortly. svcprint.c has been
modified to allow it to output to a file in PipeFS, so TML-less machines
can still use the standard browser debug routines (albeit in a less than
elegant fashion). Comments in that source file give more details. Plus a
few more bug fixes.
@
text
@d17 3
a19 1
/* Purpose: Printing functions for the browser     */
d21 2
a22 1
/* History: 27-Jan-97: Created                     */
d137 2
a138 2
    int                     iconlist[10];
    char                    buffer[MaxMsgLen];
d151 1
a151 1
        /* Get the number range's writabe component ID */
d555 1
d557 1
d561 1
d567 1
d573 1
d811 1
a823 3
    // Haven't done the wimpt_dy() stuff yet (work out the heights
    // separately, and if non-zero add wimpt_dy for the window border)

d826 2
a827 2
      top    += (toolbars_url_height(b) + toolbars_button_height(b));
      bottom -= (toolbars_url_height(b) + toolbars_button_height(b) + toolbars_status_height(b) - top);
d831 2
a832 2
      top    += toolbars_status_height(b);
      bottom -= (toolbars_url_height(b) + toolbars_button_height(b) + toolbars_status_height(b) - top);
a833 1
  }
d835 5
a839 2
  /* If 'from' is non-zero, want to print from the top of the whole   */
  /* page; else from the top of the visible area as worked out above. */
d841 2
a842 2
  // Haven't done the wimpt_dy() stuff yet (work out the heights
  // separately, and if non-zero add wimpt_dy for the window border)
d844 1
a844 7
  if (!fixed.swapbars)
  {
    if (from) top = toolbars_url_height(b) + toolbars_button_height(b);
  }
  else
  {
    if (from) top = toolbars_status_height(b);
d1091 2
a1092 2
    /* Otherwise, close the outer while() loop - which */
    /* may mean we loop for another page.              */
d1298 1
a1298 1
    char text[256];
d1302 2
a1303 1
    ChkError(button_get_value(0, idb->self_id, EndManyLabel, text, 256, NULL));
a1327 2

/*************************************************/
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d815 13
a827 2
    top    += (toolbars_url_height(b) + toolbars_button_height(b));
    bottom -= (toolbars_url_height(b) + toolbars_button_height(b) + toolbars_status_height(b) - top);
d833 11
a843 1
  if (from) top = toolbars_url_height(b) + toolbars_button_height(b);
@

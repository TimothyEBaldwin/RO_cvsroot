head	1.27;
access;
symbols
	Browse-2_16:1.27
	Browse-2_15:1.27
	Browse-2_14:1.27
	Browse-2_13:1.27
	Browse-2_12:1.27
	Browse-2_11:1.27
	Browse-2_10:1.27
	Browse-2_09:1.27
	ahodgkin_208_i4_2:1.26
	ahodgkin_208_i4:1.24
	ahodgkin_208_i3:1.24
	ahodgkin_208_i2:1.24
	ahodgkin_208_i1:1.24
	ahodgkin_207release:1.24
	ahodgkin_206release:1.23
	ahodgkin_205release:1.22
	ahodgkin_204release:1.22
	ahodgkin_202release:1.21
	ahodgkin_201release:1.20
	ahodgkin_200release:1.20
	ahodgkin_133beta:1.20
	ahodgkin_132beta:1.20
	ahodgkin_131beta:1.19
	ahodgkin_130beta:1.18
	ahodgkin_129:1.18
	ahodgkin_128beta:1.16
	ahodgkin_128alpha:1.16
	ahodgkin_127beta2:1.15
	ahodgkin_127beta:1.15
	ahodgkin_126beta:1.13
	ahodgkin_AW97patch:1.13
	ahodgkin_AW97:1.13;
locks; strict;
comment	@# @;


1.27
date	2005.04.26.09.42.34;	author ahodgkin;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.14.08.45.06;	author ahodgkin;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.31.15.58.35;	author ahodgkin;	state Exp;
branches;
next	1.24;

1.24
date	98.09.07.11.46.47;	author ahodgkin;	state Exp;
branches;
next	1.23;

1.23
date	98.07.09.10.27.09;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	98.04.16.08.14.13;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	98.03.20.12.12.37;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	98.02.06.13.55.12;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	98.01.31.10.55.19;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	97.12.12.17.12.21;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	97.12.12.11.17.50;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	97.11.26.17.10.58;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	97.11.20.16.04.35;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	97.11.19.10.28.57;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.10.16.13.23.11;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.10.09.10.52.04;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.09.24.11.14.16;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.09.22.07.43.15;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.09.12.17.19.22;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.09.09.14.13.14;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.09.03.12.36.08;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.09.03.07.48.59;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.08.31.18.38.16;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.08.28.16.08.00;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.08.18.09.23.57;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.08.08.16.38.51;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.28.43;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.27
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    History.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Handles the browser history.                      */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 07-Feb-1997 (ADH): Created.                       */
/*          06-Nov-1997 (ADH): Major revision, largely a      */
/*                             complete rewrite to make the   */
/*                             system more flexible and less  */
/*                             prone to bugs (but still do    */
/*                             Back/Forward as in Navigator   */
/*                             2, rather than Navigator 3).   */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <kernel.h>
#include <swis.h>
#include <tboxlibs/flex.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>
#include <tboxlibs/gadgets.h>
#include <tboxlibs/menu.h>

#include "Global.h"
#include "FromROSLib.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "FetchPage.h"
#include "Filetypes.h"
#include "JavaScript.h"
#include "Memory.h"
#include "OpenURL.h"
#include "Save.h"
#include "Toolbars.h"
#include "URLutils.h"
#include "Windows.h"

#include "History.h"

/**************************************************************************************************/
/*                                                                                                */
/* Browser History structure                                                                      */
/* =========================                                                                      */
/*                                                                                                */
/*          prev       next            The basic History structure is as pictured to the left.    */
/* (entry) <---- ENTRY ----> (entry)   Global History takes the form of a doubly-linked list of   */
/*                 | ^                 history_entry structures, which may point to another       */
/*            users| |parent           doubly-linked list of structures recording the usage of    */
/*                 | |                 a History item by a specific browser. Within these         */
/*                 | |                 history_user records, there are doubly-linked references   */
/*                 | |(user)           to other history_user structures referring to the same     */
/*                 | |^                browser - in this way, a local visit History is held. The  */
/*                 | ||prev            history_user structures point back to the history_entry    */
/*                 | ||                structures through the 'parent' field.                     */
/*                 v ||                                                                           */
/*    (LHPU) <---- USER ----> (LHNU)   LHPU and LHNU stand for 'Local History [Prev/Next] User'.  */
/*    history_prev    | history_next                                                              */
/*                    |                All memory allocations are through malloc, since the       */
/*                    |next            blocks in use are typically small and must not move (so a  */
/*                    v                granular allocation system or a shifting heap such as      */
/*                    (user)           that provided by flexlib would be inappropriate).          */
/*                                                                                                */
/* Two records are kept in the browser_data structure which are, as far as anyone else is         */
/* concerned, magic words. They are in fact both history_user pointers cast to void *. One is     */
/* updated every time a new history_user entry is created - this is needed so that prev/next      */
/* pointers within all the items relevant to the browser's local History may be updated quickly.  */
/* The other is a pointer to a history_user struct which when non-NULL, indicates a position      */
/* within the History itself.                                                                     */
/*                                                                                                */
/* Note that one history_entry may have several history_user structs threading through it for the */
/* same browser, if a user keeps going back to the same page by following links.                  */
/*                                                                                                */
/**************************************************************************************************/

/* Internationalisation support */

#ifdef UNIFONT
  #define CHARSET_SPECIFIER "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n"
#else
  #define CHARSET_SPECIFIER "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n"
#endif

/* Local definitions */

#define HistoryWrite(fn) {written = (fn); if (written < 0) goto history_save_error;}

/* Main History list structures */

struct history_entry;

/* Record usage by a specific browser */

typedef struct history_user
{
  struct history_entry * parent;

  struct history_user  * next;
  struct history_user  * prev;

  struct history_user  * history_next; /* (For the browser history, this is NOT a linked list) */
  struct history_user  * history_prev;

  browser_data         * user;
  time_t                 last_accessed;
}
history_user;

/* Global History structure, which points to */
/* an array of usage structures (see above)  */

typedef struct history_entry
{
  struct history_entry * next;
  struct history_entry * prev;

  url_description      * url; /* (Defined in URLutils.h) */
  unsigned int           hash;
  char                 * title;

  history_user         * users;

  unsigned int           last_accessed;
}
history_entry;

/* Static variables */

static history_entry   * history_base = NULL;

static void            * history_menu = NULL;
static int               menu_entries = 0;

static history_user   ** user_array   = NULL;
static history_entry  ** entry_array  = NULL;
static int               nusers       = 0;
static int               nentries     = 0;

/* Static function prototypes */

static history_entry   * history_find_entry      (const char * url);
static history_user    * history_find_user       (browser_data * b, history_entry * entry);

static _kernel_oserror * history_add_user        (browser_data * b, history_entry * found, history_user ** created);
static void              history_remove_user     (history_user * user);
static void              history_remove_entry    (browser_data * b, history_entry * entry);

static int               history_compare_entries (const void * first, const void * second);

/**************************************************************/
/* history_find_entry()                                       */
/*                                                            */
/* Returns a pointer to a history_entry for a given URL.      */
/*                                                            */
/* Parameters: Pointer to a null-terminated URL string to     */
/*             find.                                          */
/*                                                            */
/* Returns:    Pointer to a history_entry struct representing */
/*             the given URL, or NULL if no such entry is     */
/*             found in the History.                          */
/**************************************************************/

static history_entry * history_find_entry(const char * url)
{
  history_entry   * find = history_base;
  url_description * url_d;
  int               hash;

  if (!url || !*url) return NULL;

  /* Get a description of the URL - makes comparissons faster */

  url_d = urlutils_return_description(url);
  if (!url_d) return NULL;

  hash = utils_return_hash(url_d->full);

  /* Search the list */

  while (find)
  {
    if (hash == find->hash && !urlutils_urlddcmp(find->url, url_d)) break;

    find = find->next;
  }

  urlutils_free_description(url_d);

  return find;
}

/**************************************************************/
/* history_find_user                                          */
/*                                                            */
/* Returns a pointer to a history_user for a given browser in */
/* a given History entry.                                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct represented   */
/*             by the entry;                                  */
/*                                                            */
/*             Pointer to a history_entry struct to search    */
/*             in.                                            */
/*                                                            */
/* Returns:    Pointer to a history_user struct representing  */
/*             the given browser or NULL if no such entry is  */
/*             found.                                         */
/**************************************************************/

static history_user * history_find_user(browser_data * b, history_entry * entry)
{
  history_user * user;

  if (!b || !entry) return NULL;

  /* Search the list */

  user = entry->users;

  while (user)
  {
    if (user->user == b) return user;

    user = user->next;
  }

  return NULL;
}

/**************************************************************/
/* history_add_user()                                         */
/*                                                            */
/* Add an association of a given browser with a given History */
/* entry, updating the browser's record of where it is in the */
/* local History to the new association (user record). This   */
/* last step is required if subsequent additions are to be    */
/* correctly linked into the local History list (history_next */
/* and history_prev fields).                                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the association;                               */
/*                                                            */
/*             Pointer to a history_entry struct to associate */
/*             the browser to;                                */
/*                                                            */
/*             Pointer to a history_user *, in which the      */
/*             address of the new user record will be placed. */
/*                                                            */
/* Assumes:    The history_user * pointer may be NULL.        */
/**************************************************************/

static _kernel_oserror * history_add_user(browser_data * b, history_entry * found, history_user ** created)
{
  history_user * newuser;

  dprintf(("Hist", "history_add_user: Called for browser %p, entry %p\n",b,found));

  if (created) *created = NULL;

  newuser = malloc(sizeof(history_user));

  if (!newuser)
  {
    /* Oh just great, the allocation failed. Well, rather */
    /* than scrap everything, leave the global entry      */
    /* alone - just don't create the extra reference to   */
    /* this browser.                                      */

    dprintf(("Hist", "history_add_user: Could not allocate space for user record\n"));

    return make_no_memory_error(25);
  }

  dprintf(("Hist", "history_add_user: New user record is %p\n", newuser));

  /* Insert the item into the linked list of history_user */
  /* structures for this history_entry structure.         */

  newuser->parent = found;

  if (found->users) found->users->prev = newuser;

  newuser->next = found->users;
  newuser->prev = NULL;

  found->users  = newuser;

  /* Link the item into the linked list of history_user */
  /* structures forming the browser local history.      */

  newuser->history_prev = (history_user *) b->history_current;
  newuser->history_next = NULL;
  newuser->user         = b;

  /* Fill in the accessed time */

  newuser->last_accessed = found->last_accessed;

  /* If newuser->history_prev points in its history_next  */
  /* field to any other items, remove them, because we've */
  /* just branched the history at this point by adding    */
  /* the new item.                                        */

  if (newuser->history_prev && newuser->history_prev->history_next)
  {
    history_user * current = newuser->history_prev->history_next;
    history_user * next;

    dprintf(("Hist", "history_add_user: Adding from within an existing history; removing later entries...\n"));

    while (current)
    {
      next = current->history_next;

      dprintf(("Hist", "history_add_user: Calling history_remove_user for user record %p\n",current));

      history_remove_user(current);

      current = next;
    }
  }

  /* Fill in the link to the new structure */

  if (newuser->history_prev) newuser->history_prev->history_next = newuser;

  b->history_current = (void *) newuser;

  dprintf(("Hist", "history_add_user: Successful\n"));

  if (created) *created = newuser;

  return NULL;
}

/**************************************************************/
/* history_record()                                           */
/*                                                            */
/* Records the visiting of a given URL in the History,        */
/* optionally associating this visit with a given browser.    */
/*                                                            */
/* If there is already an entry for this URL, it will simply  */
/* have its latest visit time record updated.                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct to associate  */
/*             the visit with, or NULL for none;              */
/*                                                            */
/*             Pointer to a null-terminated URL string to     */
/*             record.                                        */
/**************************************************************/

_kernel_oserror * history_record(browser_data * b, const char * url)
{
  history_entry * found   = NULL;
  history_user  * newuser = NULL;

  if (!url || !*url) return NULL;

  dprintf(("Hist", "history_record: Called for %p and '%s'\n",b,url));

  /* First, see if we have the URL present already */

  found = history_find_entry(url);

  /* If this is for a specific browser which is fetching */
  /* from its own local History, then we don't record    */
  /* anything (it'd corrupt the history ordering). We    */
  /* should, however, update the timestamps.             */

  if (b && b->from_history)
  {
    dprintf(("Hist", "history_record: Browser fetching from History; updating timestamps and exitting\n"));

    if (found)
    {
      found->last_accessed = time(NULL);

      newuser = history_find_user(b, found);

      if (newuser) newuser->last_accessed = found->last_accessed;
    }

    return NULL;
  }

  /* If not fetching from the local History, proceed as normal */

  if (!found)
  {
    dprintf(("Hist", "history_record: No existing entry, so creating a new one\n"));

    /* Need to create an entry */

    found = malloc(sizeof(history_entry));

    if (!found)
    {
      dprintf(("Hist", "history_record: Couldn't allocate space for entry\n"));

      return make_no_memory_error(25);
    }

    /* Need to turn the URL into a more complete description, */
    /* but if we get NULL back, memory allocation must have   */
    /* failed somewhere.                                      */

    found->url = urlutils_return_description(url);

    if (!found->url)
    {
      free(found);

      dprintf(("Hist", "history_record: Couldn't allocate space for URL description\n"));

      return make_no_memory_error(25);
    }
    else
    {
      /* Create a hash number for the string */

      found->hash = utils_return_hash(found->url->full);
    }

    /* Link in the structure */

    found->prev = NULL;
    found->next = history_base;

    if (history_base) history_base->prev = found;

    history_base = found;

    /* Fill in some other fields */

    found->title = NULL;
    found->users = NULL;

    dprintf(("Hist", "history_record: OK, have entry %p with description block %p\n",found,found->url));
  }

  #ifdef TRACE
    else dprintf(("Hist", "history_record: Already have an entry %p\n",found));
  #endif

  /* Update the last accessed time for the global record */

  found->last_accessed = time(NULL);

  /* Always add a usage record for the browser, unless the URL being     */
  /* added matches that represented by the item the browser is currently */
  /* on in terms of its visit history.                                   */

  if (
       b &&
       (
         !b->history_current ||
         (
           ((history_user *) b->history_current)->parent != found
         )
       )
     )
     RetError(history_add_user(b, found, NULL));

  dprintf(("Hist", "history_record: Successful. History size is now %d\n"
                   "                Exitting through expiry functions.\n",

                   history_count()));

  if (choices.expiry_age) RetError(history_expire(NULL, time(NULL) - choices.expiry_age));
  if (choices.max_size)   RetError(history_limit(choices.max_size));

  #ifdef SINGLE_USER

    if (choices.save_history == Choices_SaveHistory_Always)
    {
      return history_save(lookup_choice("HistorySave:Browse:User.History",0,0));
    }

  #endif

  return NULL;
}

/**************************************************************/
/* history_inherit()                                          */
/*                                                            */
/* For any association in the History of a given base         */
/* (parent) browser with a URL, create a duplicate associaton */
/* with a given child browser with the same visit timestamps. */
/* The child browser thus inherits the history of the parent. */
/*                                                            */
/* The history_current field of the child is set to the       */
/* child's equivalent of the field in the parent.             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct representing  */
/*             the parent browser;                            */
/*                                                            */
/*             Pointer to a browser_data struct representing  */
/*             the child browser.                             */
/*                                                            */
/* Assumes:    The child browser has no existing history      */
/*             references. If it does, then this will become  */
/*             detached as the new references are put in      */
/*             place.                                         */
/**************************************************************/

_kernel_oserror * history_inherit(browser_data * parent, browser_data * child)
{
  history_user * parent_user;
  history_user * parent_current;
  history_user * child_user;
  history_user * child_equivalent = NULL;

  if (!parent || !child) return NULL;

  parent_user    = (history_user *) parent->history_current;
  parent_current = parent_user;

  if (!parent_user) return NULL; /* Nothing to inherit */

  /* Find the first item in the local History */

  while (parent_user->history_prev) parent_user = parent_user->history_prev;

  /* Now go through adding users for the new browser */

  child->history_current = NULL;

  while (parent_user)
  {
    /* Add the user record for the child */

    RetError(history_add_user(child, parent_user->parent, &child_user));

    /* If this record is equivalent to the history_current field */
    /* of the parent, remember the new user record's address in  */
    /* 'child_equivalent'.                                       */

    if (parent_user == parent_current) child_equivalent = child_user;

    /* Go on to the next user record in the parent's History */

    parent_user = parent_user->history_next;
  }

  /* Set the child's history_current field to the equivalent */
  /* of the same field in the parent.                        */

  if (child_equivalent) child->history_current = (void *) child_equivalent;

  /* Finished */

  return NULL;
}

/**************************************************************/
/* history_remove_user()                                      */
/*                                                            */
/* Removes a given history_user record from the various lists */
/* in which it may lie.                                       */
/*                                                            */
/* Parameters: Pointer to the history_user structure to       */
/*             remove.                                        */
/**************************************************************/

static void history_remove_user(history_user * user)
{
  dprintf(("Hist", "history_remove_user: Called for %p\n",user));

  if (!user) return;

  /* Repoint within the linked list of items attached to a history_entry structure, */
  /* and within the local history list.                                             */

  if (user->prev) user->prev->next = user->next;
  if (user->next) user->next->prev = user->prev;

  if (user->history_prev) user->history_prev->history_next = user->history_next;
  if (user->history_next) user->history_next->history_prev = user->history_prev;

  /* If required, repoint the parent history_entry structure's 'users' field. */

  if (user == user->parent->users) user->parent->users = user->next;

  /* Does the owner browser point to this item? If so, invalidate */
  /* that pointer (set it to NULL).                               */

  if (
       is_known_browser(user->user)                 &&
       user->user->history_current == (void *) user
     )
     user->user->history_current = NULL;

  /* Finally, free the item. */

  free(user);

  dprintf(("Hist", "history_remove_user: Successful\n"));

  return;
}

/**************************************************************/
/* history_remove_entry()                                     */
/*                                                            */
/* Removes a given record from the History, removes all       */
/* associations with this entry, and/or removes all           */
/* associations between any URLs in the History and a given   */
/* browser. In the latter case, URLs left with no assocations */
/* are *not* removed; they stay as global visit History       */
/* records.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct to remove all */
/*             associations for, or NULL to not do this;      */
/*                                                            */
/*             Pointer to the history_entry struct to remove, */
/*             or NULL not to do this;                        */
/*                                                            */
/* Assumes:    Either or both pointers may be valid or NULL,  */
/*             though obviously there's little point calling  */
/*             with both set to NULL...                       */
/**************************************************************/

static void history_remove_entry(browser_data * b, history_entry * entry)
{
  dprintf(("Hist", "history_remove_entry: Called for browser %p, entry %p\n",b,entry));

  if (entry)
  {
    history_user * user = entry->users;
    history_user * next;

    /* We've found the entry. First remove all user structures */

    dprintf(("Hist", "history_remove_entry: Have found the entry - removing user records from %p...\n",user));

    while (user)
    {
      next = user->next;

      dprintf(("Hist", "history_remove_entry: Calling history_remove_user for user record %p\n",user));

      history_remove_user(user);

      user = next;
    }

    /* Point other History entries elsewhere too, and correct */
    /* the history_base pointer if required.                  */

    if (entry->prev) entry->prev->next = entry->next;
    if (entry->next) entry->next->prev = entry->prev;

    if (entry == history_base) history_base = entry->next;

    /* Free the URL description */

    dprintf(("Hist", "history_remove_entry: Calling urlutils_free_description for URL description %p\n",entry->url));

    if (entry->url) urlutils_free_description(entry->url);

    /* Free the title string */

    dprintf(("Hist", "history_remove_entry: Freeing entry title string\n"));

    free(entry->title);

    /* Free the entry */

    dprintf(("Hist", "history_remove_entry: Freeing entry itself\n"));

    free(entry);
  }

  /* Deal with removing all associations for a given browser */

  if (b)
  {
    history_user * user;
    history_user * next;

    dprintf(("Hist", "history_remove_entry: Removing all user records for browser %p\n",b));

    entry = history_base;

    /* Go through all entries... */

    while (entry)
    {
      user = entry->users;

      /* ...and all users (associations) in each entry... */

      while (user)
      {
        next = user->next;

        /* ...and remove any associated with the given browser. */

        if (user->user == b)
        {
          dprintf(("Hist", "history_remove_entry: Calling history_remove_user for user record %p\n",user));

          history_remove_user(user);
        }

        user = next;
      }

      entry = entry->next;
    }
  }

  /* Finished */

  dprintf(("Hist", "history_remove_entry: Successful\n"));

  return;
}

/**************************************************************/
/* history_remove()                                           */
/*                                                            */
/* Removes a record in the History of a given URL and all     */
/* associations with this URL, and/or removes all             */
/* associations between any URLs in the History and a given   */
/* browser. In the latter case, URLs left with no assocations */
/* are *not* removed; they stay as global visit History       */
/* records.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct to remove all */
/*             associations for, or NULL to not do this;      */
/*                                                            */
/*             Pointer to a null-terminated URL string to     */
/*             remove, or NULL to not do this.                */
/*                                                            */
/* Assumes:    Either or both pointers may be valid or NULL,  */
/*             though obviously there's little point calling  */
/*             with both set to NULL...                       */
/**************************************************************/

void history_remove(browser_data * b, const char * url)
{
  history_entry * entry = NULL;

  dprintf(("Hist", "history_remove: Called for browser %p, URL address %p\n",b,url));

  /* Deal with removing a specific URL */

  if (url)
  {
    dprintf(("Hist", "history_remove: Removing entry for URL '%s'\n",url));

    entry = history_find_entry(url);

    dprintf(("Hist", "history_remove: Entry for this URL %p\n",entry));
  }

  dprintf(("Hist", "history_remove: Calling history_remove_entry\n"));

  history_remove_entry(b, entry);

  dprintf(("Hist", "history_remove: Successful. History size is now %d\n", history_count()));
}

/**************************************************************/
/* history_add_title()                                        */
/*                                                            */
/* Associates a given title string with a given URL and all   */
/* associations with this URL, and/or removes all             */
/* associations between any URLs in the History and a given   */
/* browser.                                                   */
/*                                                            */
/* Parameters: Pointer to a null-terminated URL string for    */
/*             which the title is to be associated;           */
/*                                                            */
/*             Pointer to a null-terminated title string to   */
/*             associate with the URL.                        */
/**************************************************************/

_kernel_oserror * history_add_title(const char * url, const char * title)
{
  history_entry * entry;

  if (!url || !*url || !title || !*title) return NULL;

  dprintf(("Hist", "history_add_title: Called for URL '%s'\n"
                   "                        and title '%s'\n",

                   url, title));

  /* Find the item */

  entry = history_find_entry(url);

  dprintf(("Hist", "history_add_title: Entry returned by history_find_entry is 0x%08x\n", (int) entry));

  if (!entry) return NULL;

  /* Add the title */

  free(entry->title);

  entry->title = malloc(strlen(title) + 1);

  if (!entry->title)
  {
    dprintf(("Hist", "history_add_title: Couldn't allocate space for title string\n"));

    return make_no_memory_error(26);
  }
  else strcpy(entry->title, title);

  /* Finished */

  dprintf(("Hist", "history_add_title: Successful. History size is now %d\n", history_count()));

  return NULL;
}

/**************************************************************/
/* history_return_title()                                     */
/*                                                            */
/* Returns a title string (if any) associated with a given    */
/* URL.                                                       */
/*                                                            */
/* Parameters: Pointer to a null-terminated URL string for    */
/*             which a title is to be found.                  */
/*                                                            */
/* Returns:    Pointer to a null-terminated title string      */
/*             associated with the URL, or NULL if either the */
/*             URL had no associated title, or the URL        */
/*             couldn't be found in the History at all.       */
/**************************************************************/

char * history_return_title(char * url)
{
  history_entry * entry;

  if (!url || !*url) return NULL;

  dprintf(("Hist", "history_return_title: Called for URL '%s'\n",url));

  entry = history_find_entry(url);

  dprintf(("Hist", "history_return_title: Entry returned by history_find_entry is 0x%08x\n", (int) entry));

  if (!entry) return NULL;

  #ifdef TRACE
    if (entry->title) dprintf(("Hist", "history_return_title: Successful, returning '%s'\n", entry->title));
    else              dprintf(("Hist", "history_return_title: Successful, but there is no title (returning NULL)\n"));
  #endif

  return entry->title;
}

/**************************************************************/
/* history_expire()                                           */
/*                                                            */
/* Remove all associations of a URL which have been visited   */
/* before a given time (i.e. are greater than a certain age). */
/* This may only be for associations with a specific browser. */
/*                                                            */
/* Any URL left with no associations and an overall last      */
/* visit time before that given will be removed from the      */
/* History completely.                                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct for which     */
/*             associations are to be expired, or NULL if the */
/*             expiry is for all History items;               */
/*                                                            */
/*             Time (in time() function format) which a URL   */
/*             must have not been visited on or since for     */
/*             expiry to take place.                          */
/**************************************************************/

_kernel_oserror * history_expire(browser_data * b, unsigned int time)
{
  history_entry * this_entry;
  history_entry * next_entry;
  history_user  * this_user;
  history_user  * next_user;

  dprintf(("Hist", "history_expire: Called for %p and time %d\n",b,time));

  this_entry = history_base;

  /* Scan the main entry list */

  while (this_entry)
  {
    next_entry = this_entry->next;
    this_user  = this_entry->users;

    /* For each entry, scan the associated users */

    while (this_user)
    {
      next_user = this_user->next;

      /* If we've not been given a browser, or we have and it matches */
      /* the user for this user record, and the last accessed time is */
      /* earlier than that given (the record is older), remove it.    */

      if ((!b || this_user->user == b) && this_user->last_accessed < time)
      {
        dprintf(("Hist", "history_expire: Calling history_remove_user for user record %p\n",this_user));

        history_remove_user(this_user);
      }

      this_user = next_user;
    }

    /* If this item has no users [now], and the last accessed time */
    /* is earlier than that given (the entry is older), remove it. */

    if (!this_entry->users && this_entry->last_accessed < time)
    {
      dprintf(("Hist", "history_expire: Calling history_remove_entry for entry %p\n",this_entry));

      history_remove_entry(NULL, this_entry);
    }

    /* Next... */

    this_entry = next_entry;
  }

  openurl_update_popup();

  dprintf(("Hist", "history_expire: Successful, exitting through toolbars_set_all_button_states\n"));

  return toolbars_set_all_button_states();
}

/**************************************************************/
/* history_count()                                            */
/*                                                            */
/* Counts the size in memory of all strings and structures    */
/* used by the History.                                       */
/*                                                            */
/* Returns:    Size of all strings and structs used by the    */
/*             History, in bytes.                             */
/**************************************************************/

int history_count(void)
{
  int             count = 0;
  history_entry * entry = history_base;
  history_user  * user;

  dprintf(("Hist", "history_count: Called\n"));

  while (entry)
  {
    /* Work out how much the entry takes up. First */
    /* the structure itself.                       */

    count += sizeof(entry);

    /* The title string, if present */

    if (entry->title) count += strlen(entry->title) + 1;

    /* The URL description, if present (should always be!) */

    if (entry->url)
    {
      /* This has a structure itself */

      count += sizeof(url_description);

      /* Then add in all the strings it can carry */

      if (entry->url->full)     count += strlen(entry->url->full)     + 1;
      if (entry->url->protocol) count += strlen(entry->url->protocol) + 1;
      if (entry->url->host)     count += strlen(entry->url->host)     + 1;
      if (entry->url->port)     count += strlen(entry->url->port)     + 1;
      if (entry->url->user)     count += strlen(entry->url->user)     + 1;
      if (entry->url->password) count += strlen(entry->url->password) + 1;
      if (entry->url->account)  count += strlen(entry->url->account)  + 1;
      if (entry->url->path)     count += strlen(entry->url->path)     + 1;
      if (entry->url->query)    count += strlen(entry->url->query)    + 1;
      if (entry->url->fragment) count += strlen(entry->url->fragment) + 1;
    }

    /* Now deal with any user records in this entry */

    user = entry->users;

    while (user)
    {
      /* Only need to count the structure size itself here */

      count += sizeof(history_user);

      user = user->next;
    }

    /* Next entry */

    entry = entry->next;
  }

  dprintf(("Hist", "history_count: Successful, returning %d\n", count));

  return count;
}

/**************************************************************/
/* history_limit()                                            */
/*                                                            */
/* Counts the history size, and will expire the oldest item   */
/* if it is over the given size. This continues until the     */
/* history falls at or below the given size limit.            */
/*                                                            */
/* This is quite a slow process.                              */
/*                                                            */
/* Parameters: Size in bytes at or below which the history is */
/*             to fall on exit.                               */
/**************************************************************/

_kernel_oserror * history_limit(unsigned int size)
{
  int size_now;

  dprintf(("Hist", "history_limit: Called with limit size %d\n",size));

  do
  {
    size_now = history_count();

    dprintf(("Hist", "history_limit: Current size is %d\n",size_now));

    if (size_now > size)
    {
      history_entry * entry  = history_base;
      history_entry * old    = NULL;
      int             oldest = 0;

      /* If we're oversize, find the oldest item */

      dprintf(("Hist", "history_limit: Need to remove entries\n"));

      while (entry)
      {
        if (!oldest || entry->last_accessed < oldest) oldest = entry->last_accessed, old = entry;

        entry = entry->next;
      }

      /* Now expire it */

      dprintf(("Hist", "history_limit: Expiring entry %p\n", old));

      if (old) history_remove_entry(NULL, old);
    }

    /* Continue until we fall within the required size */
  }
  while (size_now > size);

  /* Exit through a toolbar button update, as some local histories */
  /* may well have been disturbed by the loss of History entries.  */

  openurl_update_popup();

  dprintf(("Hist", "history_limit: Successful, exitting through toolbars_set_all_button_states\n"));

  return toolbars_set_all_button_states();
}

/**************************************************************/
/* history_visited()                                          */
/*                                                            */
/* Returns 1 if a given URL is in the History, else 0.        */
/*                                                            */
/* Parameters: Pointer to a null-terminated URL string to     */
/*             look for.                                      */
/*                                                            */
/* Returns:    1 if a record of this can be found in the      */
/*             History, else 0.                               */
/**************************************************************/

int history_visited(const char * url)
{
  if (history_find_entry(url)) return 1;

  return 0;
}

/**************************************************************/
/* history_empty()                                            */
/*                                                            */
/* Inquire if there are any History items present for a given */
/* browser or the global History.                             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the enquiry, or NULL for the global History.   */
/*                                                            */
/* Returns:    1 if there are no items, else 0.               */
/**************************************************************/

int history_empty(browser_data * b)
{
  if (!b) return !history_base;

  return !b->history_current;
}

/**************************************************************/
/* history_can_go_backwards()                                 */
/*                                                            */
/* Reports whether or not there are more pages to go back to  */
/* in the local History of a given browser.                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the History.                                   */
/*                                                            */
/* Returns:    1 if there are more items in the local history */
/*             to go back to, else 0.                         */
/**************************************************************/

int history_can_go_backwards(browser_data * b)
{
  history_user * user;

  if (!b) return 0;

  user = (history_user *) b->history_current;

  if (!user || !user->history_prev) return 0;

  return 1;
}

/**************************************************************/
/* history_can_go_forwards()                                  */
/*                                                            */
/* Reports whether or not there are more pages to go forward  */
/* to in the local History of a given browser.                */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the History.                                   */
/*                                                            */
/* Returns:    1 if there are more items in the local history */
/*             to go forwards to, else 0.                     */
/**************************************************************/

int history_can_go_forwards(browser_data * b)
{
  history_user * user;

  if (!b) return 0;

  user = (history_user *) b->history_current;

  if (!user || !user->history_next) return 0;

  return 1;
}

/**************************************************************/
/* history_fetch_backwards()                                  */
/*                                                            */
/* When called, will fetch the previous page in a given       */
/* browser's local History.                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the History;                                   */
/*                                                            */
/*             1 to open the URL in a new window or 0 to open */
/*             it in the window to which the browser_data     */
/*             struct is relevant.                            */
/**************************************************************/

_kernel_oserror * history_fetch_backwards(browser_data * b, int new_view)
{
  history_user * user;
  const char   * url;

  dprintf(("Hist", "history_fetch_backwards: Called for %p\n", b));

  if (!is_known_browser(b)) return NULL;

  /* Only proceed if we're not right at the start of the history */

  user = (history_user *) b->history_current;

  if (!user || !user->history_prev)
  {
    dprintf(("Hist", "history_fetch_backwards: Can't go back any further, exitting\n"));

    return NULL;
  }

  dprintf(("Hist", "history_fetch_backwards: Proceeding\n"));

  /* Step backwards - even if we're going to open a new view, */
  /* when the child inherits the parent's history this needs  */
  /* to have been set up to make sure the child gains the     */
  /* right position in the inherited history list. We will    */
  /* correct the parent's history position later.             */

  b->history_current = (void *) (user->history_prev);

  /* Get a pointer to the URL */

  url = user->history_prev->parent->url->full;

  /* Flag that this will be a History based fetch */

  b->from_history = 1;

  /* Get the URL in either the same window or a new window. */

  if (!new_view)
  {
    dprintf(("Hist", "history_fetch_backwards: Exitting through fetchpage_new\n"));

    /* Fetch the URL, flagging not to record this URL in the history */

    return (fetchpage_new(b, (char *) url, 0, 1, 0));
  }
  else
  {
    dprintf(("Hist", "history_fetch_backwards: Exitting through windows_create_browser and browser_inherit\n"));

    RetError(windows_create_browser((char *) url, NULL, NULL, NULL, Windows_CreateBrowser_Normal));
    RetError(browser_inherit(b, last_browser));

    /* We didn't end up moving anywhere in b, and only stepped backwards */
    /* so that the indirectly called history_inherit could work properly */
    /* - so now make sure that b's current history position has not been */
    /* altered.                                                          */

    b->history_current = (void *) (user);
  }

  return NULL;
}

/**************************************************************/
/* history_fetch_forwards()                                   */
/*                                                            */
/* When called, will fetch the next page in a given browser's */
/* local History.                                             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the History;                                   */
/*                                                            */
/*             1 to open the URL in a new window or 0 to open */
/*             it in the window to which the browser_data     */
/*             struct is relevant.                            */
/**************************************************************/

_kernel_oserror * history_fetch_forwards(browser_data * b, int new_view)
{
  history_user * user;
  const char   * url;

  dprintf(("Hist", "history_fetch_forwards: Called for %p\n", b));

  if (!is_known_browser(b)) return NULL;

  /* Only proceed if we're not right at the start of the history */

  user = (history_user *) b->history_current;

  if (!user || !user->history_next)
  {
    dprintf(("Hist", "history_fetch_forwards: Can't go forwards any further, exitting\n"));

   return NULL;
  }

  dprintf(("Hist", "history_fetch_forwards: Proceeding\n"));

  /* Step forwards - even if we're going to open a new view, */
  /* when the child inherits the parent's history this needs */
  /* to have been set up to make sure the child gains the    */
  /* right position in the inherited history list. We will   */
  /* correct the parent's history position later.            */

  b->history_current = (void *) (user->history_next);

  /* Get a pointer to the URL */

  url = user->history_next->parent->url->full;

  /* Flag that this will be a History based fetch */

  b->from_history = 1;

  /* Get the URL in either the same window or a new window. */

  if (!new_view)
  {
    dprintf(("Hist", "history_fetch_forwards: Exitting through fetchpage_new\n"));

    /* Fetch the URL, flagging not to record this URL in the history */

    return (fetchpage_new(b, (char *) url, 0, 1, 0));
  }
  else
  {
    dprintf(("Hist", "history_fetch_forwards: Exitting through windows_create_browser and browser_inherit\n"));

    RetError(windows_create_browser((char *) url, NULL, NULL, NULL, Windows_CreateBrowser_Normal));
    RetError(browser_inherit(b, last_browser));

    /* We didn't end up moving anywhere in b, and only stepped forwards  */
    /* so that the indirectly called history_inherit could work properly */
    /* - so now make sure that b's current history position has not been */
    /* altered.                                                          */

    b->history_current = (void *) (user);
  }

  return NULL;
}

/**************************************************************/
/* history_menu_popup()                                       */
/*                                                            */
/* Handles clicks on a history menu popup item.               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the history to show, or NULL if this is for a  */
/*             global history from an OpenURL dialogue box;   */
/*                                                            */
/*             Object ID of the item holding the menu gadget; */
/*                                                            */
/*             Component ID of the item that was clicked on;  */
/*                                                            */
/*             1 to show the global history even if the first */
/*             parameter is not NULL, else 0;                 */
/*                                                            */
/*             1 to show the URLs, 0 to show page titles      */
/*             where available.                               */
/**************************************************************/

_kernel_oserror * history_menu_popup(browser_data * b, ObjectId object, ComponentId component, int global, int show_urls)
{
  _kernel_oserror         * e;
  WimpGetWindowStateBlock   state;
  BBox                      menu;

  /* If there's already a menu open, close it */
  /* (so the action is to toggle the menu).   */

  if ((menusrc == Menu_LocalHist || menusrc == Menu_GlobalHist) && menuhdl == b)
  {
    menusrc = Menu_None;
    menuhdl = NULL;

    return wimp_create_menu((void *) -1, 0, 0);
  }

  /* Get the Wimp handle for the tool bar and get the window state */

  e = window_get_wimp_handle(0, object, &state.window_handle);
  if (e) return e;

  e = wimp_get_window_state(&state);
  if (e) return e;

  /* Get the bounding box of the popup icon that was used */

  e = gadget_get_bbox(0, object, component, &menu);
  if (e) return e;

  /* Convert that to screen coords ready for opening the menu */
  /* next to it.                                              */

  coords_box_toscreen(&menu, (WimpRedrawWindowBlock *) &state);

  if (component == URLBarHistoryMenuR || component == OpenHistory)
  {
    /* Build and show menu to right of menu icon for URLBarHistoryMenuR object */

    e = (history_build_menu(b,
                            menu.xmax - 2,
                            menu.ymax,
                            global,
                            show_urls,
                            0));
    if (e) return e;
  }
  else
  {
    /* Otherwise, show it to the left of the icon */

    e = history_build_menu(b,
                           menu.xmin - 4,
                           menu.ymin + 4,
                           global,
                           show_urls,
                           1);
    if (e) return e;
  }

  return NULL;
}

/**************************************************************/
/* history_compare_entries()                                  */
/*                                                            */
/* A comparisson function for qsort(); compares the           */
/* last_accessed fields of two given history_entry structures */
/* so that an array being sorted will have highest            */
/* last_accessed field (newest) items first.                  */
/*                                                            */
/* Parameters: Pointer to the first history_entry struct as a */
/*             void *.                                        */
/*                                                            */
/*             Pointer to the second history_entry struct as  */
/*             a void *.                                      */
/**************************************************************/

static int history_compare_entries(const void * first, const void * second)
{
  history_entry * f = *((history_entry **) first);
  history_entry * s = *((history_entry **) second);

  if (f->last_accessed < s->last_accessed) return 1; /* We want the greatest last_accessed field to come first */
  if (f->last_accessed > s->last_accessed) return -1;

  return 0;
}

/**************************************************************/
/* history_build_menu()                                       */
/*                                                            */
/* Builds a history menu for the given browser, showing it at */
/* the specified coordinates.                                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the menu, or NULL to build from the global     */
/*             history;                                       */
/*                                                            */
/*             x coordinate to show at;                       */
/*                                                            */
/*             y coordinate to show at;                       */
/*                                                            */
/*             1 to show the global history even if the first */
/*             parameter is not NULL;                         */
/*                                                            */
/*             Non-0 to only show URLs, 0 to allow titles in  */
/*             the menu;                                      */
/*                                                            */
/*             Non-0 to subtract the width of the menu from   */
/*             the given show x coordinate (e.g. to show to   */
/*             the left of a given position) else 0.          */
/**************************************************************/

_kernel_oserror * history_build_menu(browser_data * b, int x, int y, int global, int show_urls, int subtract)
{
  _kernel_oserror * e;
  wimp_menuhdr    * mhp;
  wimp_menuitem   * mip;
  char            * menudata;
  history_entry   * entry;

  int               i;
  int               size;
  int               width, awidth, thiswidth;
  int               len;
  unsigned int      precount = 0, runcount = 0;

  /* Clear out any existing menu-related data */

  free(history_menu); history_menu = NULL;
  free(entry_array);  entry_array  = NULL, nentries = 0;
  free(user_array);   user_array   = NULL, nusers   = 0;

  dprintf(("Hist", "history_build_menu: Called with %p\n", (void *) b));

  /* If there are no History items, flag an error. */

  if (!history_base) goto history_build_menu_empty_history;

  /* Work out the data size required for the menu structure. */
  /* Can't just point the menu to the history list as it's a */
  /* flex block, which may shift whilst the menu is open.    */

  size   = sizeof(wimp_menuhdr);
  width  = 8;
  awidth = 0;

  /* Loop round finding the string length of the longest entry */
  /* in 'width' and the OS unit width of it in 'awidth'.       */

  _swix(Hourglass_On, 0);

  dprintf(("Hist", "\nhistory_build_menu: Widthing menu\n"
                     "=================================\n\n"));

  entry = history_base;

  while (entry)
  {
    precount ++;
    entry = entry->next;
  }

  if (b && !global)
  {
    history_user  * current;

    /* Want a local (visit history).                                     */
    /*                                                                   */
    /* For this, we want to build a menu which shows where the forwards  */
    /* / backwards buttons will go, with the current position in the     */
    /* local History ticked. So we need to find the browser's current    */
    /* position, move right to the end of it, and build the menu from    */
    /* there. The build order will follow the history path by definition */
    /* so no sorting is needed afterwards.                               */

    current = (history_user *) b->history_current;

    if (!current) goto history_build_menu_empty_history;

    /* Track to the end of the local History */

    while (current->history_next) current = current->history_next;

    /* Now add in each entry */

    menu_entries = 0;

    while (current)
    {
      history_user    ** new_array;
      const char       * used;
      const char       * url;
      const char       * title = current->parent->title;
      url_description  * url_d = current->parent->url;

      _swix(Hourglass_Percentage,
            _IN(0),

            (100 * runcount++) / precount);

      /* Rremember the item in the array */

      new_array = realloc(user_array, (++nusers) * sizeof(history_user *));

      if (!new_array) /* Zoiks! The allocation failed */
      {
        goto history_build_menu_out_of_memory;
      }

      user_array             = new_array;
      user_array[nusers - 1] = current;

      menu_entries ++;

      if (url_d) url = url_d->full;
      else       url = "";

      /* (So from the above, 'url' is never NULL) */

      if (show_urls || !title || !*title) len = strlen(url),   used = url;
      else                                len = strlen(title), used = title;

      dprintf(("Hist", "Local  - URL  : '%s'\n"
                       "Local  - Title: '%s'\n\n",

                       url,
                       title ? title : ""));

      /* Account for an appended space to stop e.g. 'Home' being taken */
      /* as a keyboard shortcut by the Wimp                            */

      len ++;

      /* Work out the space requirement for this entry and record the */
      /* widest entry in characters in 'width'.                       */

      size += len + 1 + sizeof(wimp_menuitem); /* (+1 = string terminator) */

      if (len > width) width = len;

      /* Find the width of the entry in OS units */

      RetError(utils_text_width((char *) used, &thiswidth, 0));

      /* Record the widest entry in OS units in 'awidth' */

      if (thiswidth > awidth) awidth = thiswidth;

      /* Go on to the next (or rather, given the order we want the */
      /* menu items in, previous!) item.                           */

      current = current->history_prev;
    }
  }
  else
  {
    history_entry   * entry = history_base;
    history_entry  ** new_array;
    const char      * used;
    const char      * url;
    const char      * title;
    url_description * url_d;

    /* Want a global history.                                        */
    /*                                                               */
    /* We need to go through all history_entry structures, recording */
    /* each on in the entry_array array so menu entry numbers can be */
    /* associated with history_entry structures.                     */

    menu_entries = 0;

    while (entry)
    {
      _swix(Hourglass_Percentage,
            _IN(0),

            (100 * runcount++) / precount);

      new_array = realloc(entry_array, (++nentries) * sizeof(history_user *));

      if (!new_array)
      {
        goto history_build_menu_out_of_memory;
      }

      entry_array = new_array;
      entry_array[nentries - 1] = entry;

      /* Find the maximum width in chars and OS units of the URL or title strings */

      title = entry_array[nentries - 1]->title;
      url_d = entry_array[nentries - 1]->url;

      /* From here on it's more or less identical to the local history code above */

      if (url_d) url = url_d->full;
      else       url = NULL;

      if (show_urls || !title || !*title) len = url ? strlen(url) : 0, used = url;
      else                                len = strlen(title),         used = title;

      dprintf(("Hist", "Global - URL  : '%s'\n"
                       "Global - Title: '%s'\n\n",

                       url   ? url   : "",
                       title ? title : ""));

      len ++;
      size += len + 1 + sizeof(wimp_menuitem);

      if (len > width) width = len;

      RetError(utils_text_width((char *) used, &thiswidth, 0));

      if (thiswidth > awidth) awidth = thiswidth;

      menu_entries ++;

      /* Next item */

      entry = entry->next;
    }

    /* Sort the entries array based on the entry datestamps - */
    /* newest (highest datestamp number) first.               */

    qsort(entry_array, nentries, sizeof(history_entry *), history_compare_entries);

    #ifdef TRACE

      {
        history_entry * entry;

        dprintf(("Hist", "Post-sorting, entry array looks like:\n\n"));

        for (i = 0; i < nentries; i++)
        {
          entry = entry_array[i];

          dprintf(("Hist", "Entry %04d - URL '%s'\n", i, entry->url ? entry->url->full : ""));
        }

        dprintf(("Hist", "\n"));
      }

    #endif
  }

  size += 4;

  /* Deallocate any existing menu data and allocate the new required size. */

  #ifdef TRACE
    if (history_menu) dprintf(("Hist", "history_build_menu: Freeing existing store\n"));
    else              dprintf(("Hist", "history_build_menu: There is no existing store\n"));
  #endif

  free(history_menu);
  history_menu = NULL;

  dprintf(("Hist", "history_build_menu: Attempting to malloc %d bytes\n",size));

  history_menu = calloc(1, size);
  if (!history_menu) goto history_build_menu_out_of_memory;

  /* Point mhp to the start of the menu header, and mip  */
  /* to the first menu item (straight after the header). */

  mhp = (wimp_menuhdr  *) history_menu;
  mip = (wimp_menuitem *) (((int) mhp) + sizeof(wimp_menuhdr));

  /* Fill in the header. */

  strncpy(mhp->title, lookup_token("HistMenT:History",0,0), 12);

  mhp->tit_fcol  = 7;
  mhp->tit_bcol  = 2;
  mhp->work_fcol = 7;
  mhp->work_bcol = 0;
  mhp->width     = awidth;
  mhp->height    = 44;
  mhp->gap       = 0;

  /* Pointer arithmetic - mip + menu_entries adds menu_entries */
  /* lots of sizeof(mip) to menudata, since the cast to char * */
  /* is the last thing that happens. So menudata points past   */
  /* all the menu structure stuff to the data area.            */

  menudata = (char *) (mip + menu_entries);

  /* Fill in each menu item. */

  dprintf(("Hist", "\nhistory_build_menu: Building menu\n"
                     "=================================\n\n"));

  for (i = 0; i < menu_entries; i++)
  {
    /* No percentage here, it's very quick compared with the stuff */
    /* above. Unfortunately though, the Wimp can take *ages* when  */
    /* we call Wimp_CreateMenu...                                  */

    url_description * url_d;
    char            * url;
    char            * title;

    /* Find the URL or title string for this entry */

    if (b && !global)
    {
      history_user * user = user_array[i];

      url_d = user->parent->url;
      title = user->parent->title;

      url = url_d ? url_d->full : "";

      dprintf(("Hist", "Local  - URL  : '%s'\n"
                       "Local  - Title: '%s'\n\n",

                       url,
                       title ? title : ""));
    }
    else
    {
      history_entry * entry = entry_array[i];

      url_d = entry->url;
      title = entry->title;

      url = url_d ? url_d->full : "";

      dprintf(("Hist", "Global - URL  : '%s'\n"
                       "Global - Title: '%s'\n\n",

                       url,
                       title ? title : ""));
    }

    /* Fill in the entry header */

    mip->flags     = (
                       (i == menu_entries - 1)
                       ?
                       wimp_MLAST
                       :
                       0
                     )
                     |
                     (
                       (
                         b       &&
                         !global &&
                         user_array[i] == (history_user *) b->history_current
                       )
                       ?
                       wimp_MTICK
                       :
                       0
                     );

    mip->submenu   = (wimp_menuptr) -1;
    mip->iconflags = wimp_ITEXT    |
                     wimp_IFILLED  |
                     wimp_INDIRECT |
                     (7<<24);

    mip->data.indirecttext.validstring = NULL;
    mip->data.indirecttext.bufflen     = 0;
    mip->data.indirecttext.buffer      = menudata;

    /* Use the URL if we're told to, or the title is NULL / a null string */

    if (show_urls || !title || !*title)
    {
      /* Use the URL */

      strcpy(menudata, url);
      strcat(menudata, " "); /* To stop e.g. 'Home' at the end of an item being taken as a keyboard shortcut by the Wimp */

      len = strlen(menudata);

      /* Advance the data pointer, possibly removing any */
      /* CGI information if HIDE_CGI is defined inside   */
      /* the compiler.                                   */

      #ifdef HIDE_CGI

        toolbars_hide_cgi(menudata);

      #else

        /* If not hiding all CGI information, still don't want to  */
        /* put all the CGI stuff in the menu or it can get far too */
        /* wide. So leave an indicator to show there was CGI info. */

        toolbars_hide_cgi(menudata);

        if      (len > strlen(menudata) + 7) strcat(menudata, " (+CGI)");
        else if (len > strlen(menudata) + 4) strcat(menudata, "?...");

      #endif
    }
    else
    {
      /* Use the title */

      strcpy(menudata, title);
      strcat(menudata, " "); /* To stop e.g. 'Home' at the end of an item being taken as a keyboard shortcut by the Wimp */

      len = strlen(menudata);
    }

    /* If we've gone over the width limit on this entry,  */
    /* show the right hand portion of the item with '...' */
    /* before it.                                         */

    if (len + 4 > Limits_HistoryMenuItemSize) /* '+4' to account for the '...' we'll put in front plus terminator */
    {
      memmove(menudata + 3, menudata + len - (Limits_HistoryMenuItemSize - 3), Limits_HistoryMenuItemSize - 3);
      strncpy(menudata, "...", 3);
      menudata[Limits_HistoryMenuItemSize - 1] = '\0';
    }

    menudata += strlen(menudata) + 1;

    /* Next item... */

    mip ++;
  }

  #ifdef TRACE
    if (menudata > ((char *) history_menu) + size)
    {
      erb.errnum = 0;
      sprintf(erb.errmess,"Fatal error inside history_build_menu: Overran menu buffer! Allocated %d bytes, then used %d.",size,(int) menudata - (int) history_menu);
      show_error(&erb);
    }
  #endif

  /* Finally, open the menu */

  dprintf(("Hist", "history_build_menu: Exitting through wimp_create_menu\n"));

  menuhdl = (void *) b;

  if (global) menusrc = Menu_GlobalHist;
  else        menusrc = Menu_LocalHist;

  /* Cancal any % indicator before the Wimp gets called, as leaving */
  /* it at 99% looks worse than leaving no indicator.               */

  _swix(Hourglass_Percentage,
        _IN(0),

        100);

  e = wimp_create_menu(history_menu, x - (subtract ? (mhp->width + 64) : 0), y);

  _swix(Hourglass_Off, 0);

  return e;

  /* Forced exits... */

history_build_menu_out_of_memory:

  _swix(Hourglass_Off, 0);

  free(history_menu); history_menu = NULL;
  free(entry_array);  entry_array  = NULL, nentries = 0;
  free(user_array);   user_array   = NULL, nusers   = 0;

  /* Out of memory */

  erb.errnum = Utils_Error_Custom_Normal;

  StrNCpy0(erb.errmess,
           lookup_token("NoMemLHi:There is not enough free memory to open the history menu.",
                        0,
                        0));

  dprintf(("Hist", "history_build_menu: Exitting (out of memory)\n"));

  return &erb;

history_build_menu_empty_history:

  _swix(Hourglass_Off, 0);

  free(history_menu); history_menu = NULL;
  free(entry_array);  entry_array  = NULL, nentries = 0;
  free(user_array);   user_array   = NULL, nusers   = 0;

  /* Empty history (nothing at all, nothing for a given */
  /* browser, or whatever)                              */

  erb.errnum = Utils_Error_Custom_Message;

  StrNCpy0(erb.errmess,
           lookup_token("EmptyHistE:The history list is empty.",
                        0,
                        0));

  dprintf(("Hist", "history_build_menu: Exitting (history is empty)\n"));

  return &erb;
}

/**************************************************************/
/* history_menu_selection()                                   */
/*                                                            */
/* Jumps to a URL according to the item selected in a history */
/* menu.                                                      */
/*                                                            */
/* If Adjust is used the menu is not reopened as the fetch    */
/* will occur in a new window (as with following page links)  */
/* - it doesn't make sense to reopen the menu in this case.   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the history, or NULL for the global history -  */
/*             in this case it is assumed that the menu       */
/*             opened from an Open URL dialogue and           */
/*             appropriate alternative functions will be      */
/*             called;                                        */
/*                                                            */
/*             Pointer to a WimpPollBlock struct from which   */
/*             the menu item that was selected may be         */
/*             determined.                                    */
/**************************************************************/

_kernel_oserror * history_menu_selection(browser_data * b, WimpPollBlock * block)
{
  int          item, adj;
  int          global;
  const char * url = NULL;

  /* What type of menu was it? */

  if (menusrc == Menu_GlobalHist || !b) global = 1;
  else                                  global = 0;

  /* Flag that there is no known menu source anymore */
  /* and fetch the new URL.                          */

  menusrc = Menu_None;

  /* What item was clicked on? */

  item = block->menu_selection[0];

  /* If the menu selection appears to be out of range, */
  /* exit quietly.                                     */

  if (
       item < 0             ||
       item >= menu_entries ||
       (
         global           &&
         item >= nentries
       )
       ||
       (
         !global        &&
         item >= nusers
       )
     )
  {
    dprintf(("Hist", "history_menu_selection: Warning, menu selection out of range\n"));

    return NULL;
  }

  /* Otherwise find out the button that was used. */

  adj = controls.ignore_adjust ? 0 : adjust();

  /* If a new window isn't going to be opened, */
  /* need to remember that we've just dived    */
  /* into the History list so that forwards /  */
  /* backwards work correctly.                 */

  if (!adj && b && !global)
  {
    history_user * user = user_array[item];

    b->history_current = (void *) user;
  }

  /* Point to the required URL */

  if (!global)
  {
    history_user * user = user_array[item];

    if (user->parent && user->parent->url) url = user->parent->url->full;
  }
  else
  {
    history_entry * entry = entry_array[item];

    if (entry->url) url = entry->url->full;
  }

  /* If b is set, this is from a browser toolbar */

  if (b)
  {
    #ifdef JAVASCRIPT

      /* If this is a JavaScript URL, the script will end up    */
      /* being executed. Tell the JavaScript interface routines */
      /* that it came from a history popup next to the URL      */
      /* writeable (so in effect, it came from the writeable).  */

      if (javascript_url(url)) javascript_set_source(JavaScript_Source_URLWritable);

    #endif

    /* Somewhat non-standard behaviour to have an adjust-click  */
    /* open a new window instead of leaving the menu up, but    */
    /* this is more consistent with the rest of the browser UI. */

    if (!adj) return fetchpage_new(b,
                                   url,
                                   0,
                                   1,
                                   0);

    else return windows_create_browser((char *) url,
                                       NULL,
                                       NULL,
                                       NULL,
                                       Windows_CreateBrowser_Normal);
  }

  /* Otherwise, if b is NULL, it's from an Open URL dialogue */

  else
  {
    return openurl_fill_in_url((char *) url);
  }

  return NULL;
}

/**************************************************************/
/* history_ensure_sane()                                      */
/*                                                            */
/* Attempts to correct for corrupted files by seeing if there */
/* are any '\n' chars in a read string and rereading up to    */
/* but not including the '\n' if so.                          */
/*                                                            */
/* Used by both the visit and image history loaders.          */
/*                                                            */
/* Parameters: Pointer to the FILE * to read through;         */
/*                                                            */
/*             Pointer to the string just read;               */
/*                                                            */
/*             Expected length of the string;                 */
/*                                                            */
/*             Long int holding position to seek to in order  */
/*             to re-read the item.                           */
/*                                                            */
/* Returns:    Length of item after checking.                 */
/**************************************************************/

unsigned int history_ensure_sane(FILE * file, char * item, unsigned int item_len, long int old_position)
{
  unsigned int count = 0;

  if (item == NULL || item_len == 0) return item_len;

  while (item[count] != '\0' && count < item_len)
  {
    /* If we find any '\r' characters we probably read off the end of the  */
    /* item and onto another one. This can happen if the file is corrupted */
    /* in some way. The only way we can try to correct it is to read as    */
    /* much of the item as we have on this line.                           */

    if (item[count] == '\n')
    {
      fseek(file, old_position, SEEK_SET);
      if (count > 0) fread(item, count, sizeof(char), file);
      item[count] = '\0';
      return count;
    }

    count++;
  }

  return item_len;
}

/**************************************************************/
/* history_load()                                             */
/*                                                            */
/* Loads the global history from the given path. Will raise   */
/* errors (usually, due to RISC OS C's file I/O, the wrong    */
/* ones...) if there is a failure during loading, but not if  */
/* the file refuses to open or the number of items cannot be  */
/* read from it (i.e. a missing or zero length History file). */
/*                                                            */
/* Parameters: Pointer to the full pathname for the history   */
/*             file.                                          */
/**************************************************************/

_kernel_oserror * history_load(char * pathname)
{
  FILE        * file;
  char        * title      = NULL;
  char        * url        = NULL;
  static char * local_path = NULL;
  int           last_accessed, title_len, url_len;
  int           items, item;

  dprintf(("Hist", "history_load: Called with '%s'\n", pathname ? pathname : "<NULL>"));

  if (!pathname || !*pathname) return NULL;

  local_path = malloc(strlen(pathname) + 1);
  if (!local_path) return NULL;

  strcpy(local_path, pathname);

  file = fopen(local_path, "rb");

  if (!file)
  {
    free(local_path);
    return NULL; /* Fail silently - there may be no History file; this is OK */
  }

  /* Read how many items there are - again file silently, the */
  /* file may just be zero bytes long.                        */

  dprintf(("Hist", "history_load: File opened OK\n"));

  if (fscanf(file, "%d\n", &items) == EOF)
  {
    fclose(file);
    free(local_path);

    return NULL;
  }

  #ifdef TRACE
    if (items > 1) dprintf(("Hist", "history_load: There are %d items\n",items));
    else           dprintf(("Hist", "history_load: There is 1 item\n"));
  #endif

  _swix(Hourglass_On, 0);

  for (item = 0; item < items; item++)
  {
    _swix(Hourglass_Percentage,
          _IN(0),

          (100 * item) / items);

    /* Read the last accessed time and required string lengths */

    if (
         fscanf(file,
                "%d,%d,%d\n",

                &last_accessed,
                &title_len,
                &url_len)

         == EOF
       )
       goto history_load_exit;

    /* Allocate buffers for the strings */

    free(title);
    title = malloc(title_len + 1);

    if (!title)
    {
      fclose(file);

      _swix(Hourglass_Off, 0);

      free(local_path);

      return make_no_memory_error(27);
    }

    free(url);
    url = malloc(url_len + 1);

    if (!url)
    {
      fclose(file);

      _swix(Hourglass_Off, 0);

      free(title);
      free(local_path);

      return make_no_memory_error(27);
    }

    /* Read the title */

    if (title_len)
    {
      long int reread = ftell(file);

      if (!fread(title, title_len, sizeof(char), file))
      {
        goto history_load_exit;
      }
      else title_len = history_ensure_sane(file, title, title_len, reread);
    }

    title[title_len] = 0;

    /* Skip the '\n' */

    if (fgetc(file) == EOF) goto history_load_exit;

    /* Read the URL */

    if (url_len)
    {
      long int reread = ftell(file);

      if (!fread(url, url_len, sizeof(char), file))
      {
        goto history_load_exit;
      }
      else url_len = history_ensure_sane(file, url, url_len, reread);
    }

    url[url_len] = 0;

    /* Skip the '\n' */

    if (fgetc(file) == EOF) goto history_load_exit;

    dprintf(("Hist", "history_load: %04d Title = \0213'%s'\0217\n"
                     "                     URL = \0216'%s'\0217\n",

                     item, title,
                     url));

    /* Now make the entry */

    if (url_len)
    {
      history_entry * found = calloc(1, sizeof(history_entry));

      if (!found)
      {
        dprintf(("Hist", "history_load: Couldn't allocate space for entry\n"));

        fclose(file);

        _swix(Hourglass_Off,0);

        free(url);
        free(title);
        free(local_path);

        return make_no_memory_error(25);
      }

      found->url = urlutils_return_description(url);

      /* We've now finished with the temporary URL string */

      free(url);
      url = NULL;

      if (!found->url)
      {
        free(found);

        dprintf(("Hist", "history_load: Couldn't allocate space for URL description (or URL is unparseable)\n"));

        fclose(file);

        _swix(Hourglass_Off,0);

        free(title);
        free(local_path);

        return make_no_memory_error(25);
      }
      else
      {
        /* Create a hash number for the string */

        found->hash = utils_return_hash(found->url->full);
      }

      /* Link in the structure */

      found->prev = NULL;
      found->next = history_base;

      if (history_base) history_base->prev = found;

      history_base = found;

      /* Fill in some other fields */

      found->title         = title; /* Use the title string directly */
      found->users         = NULL;
      found->last_accessed = last_accessed;

      title = NULL;

      dprintf(("Hist", "history_load: OK, have entry %p with description block %p\n",found,found->url));
    }

  /* (Closure of 'for' loop) */
  }

  fclose(file);

  dprintf(("Hist", "history_load: Successful, exitting via. expiry functions\n"));

  _swix(Hourglass_Off,0);

  free(url);
  free(title);
  free(local_path);

  if (choices.expiry_age) RetError(history_expire(NULL, time(NULL) - choices.expiry_age));

  if (choices.max_size) return history_limit(choices.max_size);
  else return NULL;

  /* Error condition exit routine */

history_load_exit:

  StrLastE;

  if (file) fclose(file);

  _swix(Hourglass_Off, 0);

  free(url);
  free(title);
  free(local_path);

  return &erb;
}

/**************************************************************/
/* history_save()                                             */
/*                                                            */
/* Saves the global history to the given path.                */
/*                                                            */
/* Parameters: Pointer to the full pathname for the history   */
/*             file.                                          */
/**************************************************************/

_kernel_oserror * history_save(char * pathname)
{
  history_entry * entry      = history_base;
  FILE          * file;
  static char   * local_path = NULL;
  int             wrote;
  int             items = 0;

  if (!pathname || !*pathname) return NULL;

  /* Canonicalise the path */

  RetError(utils_canonicalise_path(pathname, &local_path));

  /* Ensure it is present */

  {
    _kernel_oserror * e = utils_build_tree(local_path);

    if (e)
    {
      free(local_path);
      return e;
    }
  }

  /* How many items are there? */

  while (entry)
  {
    items ++;
    entry = entry->next;
  }

  entry = history_base;

  /* Create the file */

  file = fopen(local_path, "wb");

  if (!file)
  {
    free(local_path);

    RetLastE;
  }

  /* Write the number of items */

  wrote = fprintf(file, "%d\n", items);

  if (wrote <= 0)
  {
    StrLastE;

    fclose(file);
    free(local_path);

    return &erb;
  }

  /* Write the item contents */

  while (entry)
  {
    if (entry->url)
    {
      wrote = fprintf(file,

                      "%d,%d,%d\n%s\n%s\n",

                      entry->last_accessed,

                      entry->title     ? strlen(entry->title)     : 0,
                      entry->url->full ? strlen(entry->url->full) : 0,

                      entry->title     ? entry->title     : "",
                      entry->url->full ? entry->url->full : "");

      if (wrote <= 0)
      {
        StrLastE;

        fclose(file);
        free(local_path);

        return &erb;
      }
    }

    entry = entry->next;
  }

  /* Close the file and exit */

  fclose(file);
  free(local_path);

  return NULL;
}

/**************************************************************/
/* history_save_as_html()                                     */
/*                                                            */
/* This function saves the History as an HTML file.           */
/*                                                            */
/* Parameters: Pointer to the filename to save to (null       */
/*             terminated);                                   */
/*                                                            */
/*             Pointer to a browser_data struct to save the   */
/*             History for if you want a local history, else  */
/*             NULL for the global history.                   */
/**************************************************************/

_kernel_oserror * history_save_as_html(char * pathname, browser_data * b)
{
  _kernel_oserror * e;
  static char     * local_path = NULL;
  history_entry   * entry      = history_base;
  history_user    * user;
  FILE            * fileptr;
  int               written;

  if (!pathname || !*pathname) return NULL;

  local_path = malloc(strlen(pathname) + 1);
  if (!local_path) return NULL;

  strcpy(local_path, pathname);

  /* Could take a while... */

  _swix(Hourglass_On, 0);

  /* Open the file for writng */

  fileptr = fopen(local_path, "wb");

  /* Complain if it fails */

  if (fileptr == NULL)
  {
    free(local_path);

    RetLastE;
  }

  /* Write the file header */

  HistoryWrite(fprintf(fileptr, "<html>\n"
                                "<head>\n"
                                CHARSET_SPECIFIER
                                "<title>"));

  HistoryWrite(fprintf(fileptr, lookup_token("HistoryHTMLTitle:History",0,0)));

  HistoryWrite(fprintf(fileptr, "</title>\n"
                                "</head>\n"
                                "<body>\n"
                                "<ul>\n"));

  /* Fill in the body for global histories */

  if (!b)
  {
    while (entry)
    {
      if (entry->url && entry->url->full)
      {
        HistoryWrite(fprintf(fileptr, "<li><a href=\"%s\">%s</a>\n",
                                      entry->url->full,
                                      (entry->title && *entry->title) ? entry->title : entry->url->full));
      }

      entry = entry->next;
    }
  }

  /* Fill in the body for local histories */

  else
  {
    user = (history_user *) b->history_current;

    while (user && user->history_next) user = user->history_next;

    while (user)
    {
      entry = user->parent;

      if (entry && entry->url && entry->url->full)
      {
        HistoryWrite(fprintf(fileptr, "<li><a href=\"%s\">%s</a>\n",
                                      entry->url->full,
                                      (entry->title && *entry->title) ? entry->title : ""));
      }

      user = user->history_prev;
    }
  }

  /* Write the footer and close the file */

  HistoryWrite(fprintf(fileptr, "</ul>\n"));
  HistoryWrite(fprintf(fileptr, "</body>\n"));
  HistoryWrite(fprintf(fileptr, "</html>\n"));

  fclose(fileptr);

  _swix(Hourglass_Off, 0);

  /* Set the filetype to HTML (0xfaf) */

  e = _swix(OS_File,
            _INR(0,2),

            18,
            local_path,
            FileType_HTML);

  free(local_path);

  return e;

  /* Error condition exit */

history_save_error:

  StrLastE;

  if (fileptr)
  {
    fclose(fileptr);

    _swix(Hourglass_Off, 0);
  }

  free(local_path);

  return &erb;
}

/**************************************************************/
/* history_find_match()                                       */
/*                                                            */
/* Try to find the given fragment of text in the global visit */
/* history, searching through the history entry titles and    */
/* URLs. If found, add the item to the start of the list of   */
/* URLs in the given match_list set of URL strings. If this   */
/* is empty on entry, the block is initialised by creating    */
/* the empty string that signals the last item when the first */
/* item is added.                                             */
/*                                                            */
/* The search is case-sensitive.                              */
/*                                                            */
/* If there are no found entries, the function will leave     */
/* match_list unaltered.                                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct who's         */
/*             match_list list should be added to;            */
/*                                                            */
/*             Pointer to the buffer holding the string to    */
/*             try and match.                                 */
/*                                                            */
/* Returns:    1 if match_list is updated with one or more    */
/*             matches, else 0.                               */
/**************************************************************/

int history_find_match(flex_ptr match_list, const char * match)
{
  history_entry * entry;
  const char    * found;
  int             got_any = 0;

  if (!match_list || !match || !*match) return 0;

  entry = history_base;

  while (entry)
  {
    if (entry->url && entry->url->full)
    {
      found = NULL;

      /* Try the title string first */

      if (entry->title)
      {
        found = strstr(entry->title, match);
      }

      /* Match in the host, if present */

      if (!found && entry->url->host)
      {
        found = strstr(entry->url->host, match);
      }

      /* Match in the path, if nothing found in the host */

      if (!found && entry->url->path)
      {
        found = strstr(entry->url->path, match);
      }

      /* Match in the full URL, if all else fails */

      if (!found && entry->url->full)
      {
        found = strstr(entry->url->full, match);
      }

      /* If we found something, add it to the match_list */

      if (found)
      {
        int ok = browser_add_match_list_entry(match_list, entry->url->full);

        if (ok) got_any = 1;
        else if (!*match_list) return 0;
      }
    }

    /* Try the next item */

    entry = entry->next;
  }

  return got_any;
}
@


1.26
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@a178 2
static unsigned int      history_ensure_sane     (FILE * file, char * item, unsigned int item_len, long int old_position);

d1253 1
a1253 1
    return (fetchpage_new(b, (char *) url, 0, 1));
d1333 1
a1333 1
    return (fetchpage_new(b, (char *) url, 0, 1));
d2100 2
a2101 1
                                   1);
d2127 2
d2141 1
a2141 1
static unsigned int history_ensure_sane(FILE * file, char * item, unsigned int item_len, long int old_position)
a2186 1
  int           result;
d2190 2
a2198 2
  dprintf(("Hist", "history_load: Called\n"));

d2212 1
a2212 3
  result = fscanf(file, "%d\n", &items);

  if (result == EOF)
d2236 11
a2246 2
    result = fscanf(file, "%d,%d,%d\n", &last_accessed, &title_len, &url_len);
    if (result == EOF) goto history_load_exit;
d2290 1
d2292 1
a2292 1
      /* Skip the '\n' */
d2294 1
a2294 2
      if (fgetc(file) == EOF) goto history_load_exit;
    }
d2296 1
a2296 1
    title[title_len] = 0;
d2311 2
a2316 2
    url[url_len] = 0;

@


1.25
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a51 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d179 2
d286 1
a286 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_add_user: Called for browser %p, entry %p\n",b,found);
  #endif
d299 1
a299 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_add_user: Could not allocate space for user record\n");
    #endif
d304 1
a304 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_add_user: New user record is %p\n", newuser);
  #endif
d339 1
a339 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_add_user: Adding from within an existing history; removing later entries...\n");
    #endif
d345 1
a345 3
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_add_user: Calling history_remove_user for user record %p\n",current);
      #endif
d359 1
a359 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_add_user: Successful\n");
  #endif
d389 1
a389 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_record: Called for %p and '%s'\n",b,url);
  #endif
d402 1
a402 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_record: Browser fetching from History; updating timestamps and exitting\n");
    #endif
d420 1
a420 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_record: No existing entry, so creating a new one\n");
    #endif
d428 1
a428 3
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_record: Couldn't allocate space for entry\n");
      #endif
d443 1
a443 3
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_record: Couldn't allocate space for URL description\n");
      #endif
d468 1
a468 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_record: OK, have entry %p with description block %p\n",found,found->url);
    #endif
d472 1
a472 4
    else
    {
      if (tl & (1u<<16)) Printf("history_record: Already have an entry %p\n",found);
    }
d494 4
a497 7
  #ifdef TRACE
    if (tl & (1u<<16))
    {
      Printf("history_record: Successful. History size is now %d\n", history_count());
      Printf("                Exitting through expiry functions.\n");
    }
  #endif
d598 1
a598 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_remove_user: Called for %p\n",user);
  #endif
d628 1
a628 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_remove_user: Successful\n");
  #endif
d656 1
a656 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_remove_entry: Called for browser %p, entry %p\n",b,entry);
  #endif
d665 1
a665 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_remove_entry: Have found the entry - removing user records...\n");
    #endif
d671 1
a671 3
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_remove_entry: Calling history_remove_user for user record %p\n",user);
      #endif
d688 1
a688 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_remove_entry: Calling urlutils_free_description for URL description %p\n",entry->url);
    #endif
d690 1
a690 1
    urlutils_free_description(entry->url);
d694 1
a694 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_remove_entry: Freeing entry title string\n");
    #endif
d700 1
a700 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_remove_entry: Freeing entry itself\n");
    #endif
d712 1
a712 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_remove_entry: Removing all user records for browser %p\n",b);
    #endif
d732 1
a732 3
          #ifdef TRACE
            if (tl & (1u<<16)) Printf("history_remove_entry: Calling history_remove_user for user record %p\n",user);
          #endif
d746 1
a746 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_remove_entry: Successful\n");
  #endif
d776 1
a776 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_remove: Called for browser %p, URL address %p\n",b,url);
  #endif
d782 1
a782 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_remove: Removing entry for URL '%s'\n",url);
    #endif
d786 1
a786 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_remove: Entry for this URL %p\n",entry);
    #endif
d789 1
a789 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_remove: Calling history_remove_entry\n");
  #endif
d793 1
a793 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_remove: Successful. History size is now %d\n", history_count());
  #endif
d817 4
a820 4
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_add_title: Called for URL '%s'\n"
                              "                        and title '%s'\n",url,title);
  #endif
d826 1
a826 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_add_title: Entry returned by history_find_entry is 0x%08x\n",entry);
  #endif
d838 1
a838 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_add_title: Couldn't allocate space for title string\n");
    #endif
d846 1
a846 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_add_title: Successful. History size is now %d\n", history_count());
  #endif
d872 1
a872 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_return_title: Called for URL '%s'\n",url);
  #endif
d876 1
a876 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_return_title: Entry returned by history_find_entry is 0x%08x\n",entry);
  #endif
d881 2
a882 7

    if (tl & (1u<<16))
    {
      if (entry->title) Printf("history_return_title: Successful, returning '%s'\n",entry->title);
      else              Printf("history_return_title: Successful, but there is no title (returning NULL)\n");
    }

d915 1
a915 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_expire: Called for %p and time %d\n",b,time);
  #endif
d938 1
a938 3
        #ifdef TRACE
          if (tl & (1u<<16)) Printf("history_expire: Calling history_remove_user for user record %p\n",this_user);
        #endif
d951 1
a951 3
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_expire: Calling history_remove_entry for entry %p\n",this_entry);
      #endif
d963 1
a963 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_expire: Successful, exitting through toolbars_set_all_button_states\n");
  #endif
d984 1
a984 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_count: Called\n");
  #endif
d1037 1
a1037 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_count: Successful, returning %d\n", count);
  #endif
d1059 1
a1059 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_limit: Called with limit size %d\n",size);
  #endif
d1065 1
a1065 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_limit: Current size is %d\n",size_now);
    #endif
d1075 1
a1075 3
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_limit: Need to remove entries\n");
      #endif
d1086 1
a1086 3
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_limit: Expiring entry %p\n", old);
      #endif
d1100 1
a1100 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_limit: Successful, exitting through toolbars_set_all_button_states\n");
  #endif
d1214 1
a1214 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_fetch_backwards: Called for %p\n", b);
  #endif
d1224 1
a1224 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_fetch_backwards: Can't go back any further, exitting\n");
    #endif
d1229 1
a1229 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_fetch_backwards: Proceeding\n");
  #endif
d1251 1
a1251 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting through fetchpage_new\n");
    #endif
d1259 1
a1259 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting through windows_create_browser and browser_inherit\n");
    #endif
d1294 1
a1294 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_fetch_forwards: Called for %p\n", b);
  #endif
d1304 1
a1304 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_fetch_forwards: Can't go forwards any further, exitting\n");
    #endif
d1309 1
a1309 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_fetch_forwards: Proceeding\n");
  #endif
d1331 1
a1331 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_fetch_forwards: Exitting through fetchpage_new\n");
    #endif
d1339 1
a1339 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_fetch_forwards: Exitting through windows_create_browser and browser_inherit\n");
    #endif
d1495 1
d1501 1
d1509 1
a1509 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_build_menu: Called with %p\n", (void *) b);
  #endif
d1528 10
a1537 7
  #ifdef TRACE
    if (tl & (1u<<16))
    {
      Printf("\nhistory_build_menu: Widthing menu\n"
               "=================================\n\n");
    }
  #endif
d1572 5
d1599 5
a1603 7
      #ifdef TRACE
        if (tl & (1u<<16))
        {
          Printf("Local  - URL  : '%s'\n",   url);
          Printf("Local  - Title: '%s'\n\n", title ? title : "");
        }
      #endif
d1650 5
d1678 5
a1682 7
      #ifdef TRACE
        if (tl & (1u<<16))
        {
          Printf("Global - URL  : '%s'\n",   url   ? url   : "");
          Printf("Global - Title: '%s'\n\n", title ? title : "");
        }
      #endif
a1706 1
      if (tl & (1u<<16))
d1710 1
a1710 1
        Printf("Post-sorting, entry array looks like:\n\n");
d1716 1
a1716 1
          Printf("Entry %04d - URL '%s'\n", i, entry->url ? entry->url->full : "");
d1719 1
a1719 1
        Printf("\n");
d1730 2
a1731 5
    if (tl & (1u<<16))
    {
      if (history_menu) Printf("history_build_menu: Freeing existing store\n");
      else              Printf("history_build_menu: There is no existing store\n");
    }
d1737 1
a1737 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_build_menu: Attempting to malloc %d bytes\n",size);
  #endif
d1769 2
a1770 7
  #ifdef TRACE
    if (tl & (1u<<16))
    {
      Printf("\nhistory_build_menu: Building menu\n"
               "=================================\n\n");
    }
  #endif
d1774 4
d1793 5
a1797 7
      #ifdef TRACE
        if (tl & (1u<<16))
        {
          Printf("Local  - URL  : '%s'\n",   url);
          Printf("Local  - Title: '%s'\n\n", title ? title : "");
        }
      #endif
d1808 5
a1812 7
      #ifdef TRACE
        if (tl & (1u<<16))
        {
          Printf("Global - URL  : '%s'\n",   url);
          Printf("Global - Title: '%s'\n\n", title ? title : "");
        }
      #endif
d1918 1
a1918 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_build_menu: Exitting through wimp_create_menu\n");
  #endif
d1925 8
d1958 1
a1958 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_build_menu: Exitting (out of memory)\n");
  #endif
d1980 1
a1980 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_build_menu: Exitting (history is empty)\n");
  #endif
d2044 1
a2044 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_menu_selection: Warning, menu selection out of range\n");
    #endif
d2122 46
d2197 1
a2197 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_load: Called\n");
  #endif
d2210 1
a2210 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_load: File opened OK\n");
  #endif
d2223 2
a2224 5
    if (tl & (1u<<16))
    {
      if (items > 1) Printf("history_load: There are %d items\n",items);
      else           Printf("history_load: There is 1 item\n");
    }
d2276 2
d2282 1
d2284 1
a2284 3
      /* Skip the '\n', only if there was a title string to */
      /* read (otherwise fscanf() above will have skipped   */
      /* past the '\n' already).                            */
d2295 2
d2301 1
d2304 1
a2304 3
    /* Skip the '\n'. This time, because the reading of this line was */
    /* not preceeded by lines read by fscanf(), read it regardless of */
    /* whether or not the URL string itself was 0 bytes long.         */
d2310 5
a2314 7
    #ifdef TRACE
      if (tl & (1u<<16))
      {
        Printf("history_load: %04d Title = \0213'%s'\0217\n", item, title);
        Printf("                     URL = \0216'%s'\0217\n", url);
      }
    #endif
d2320 1
a2320 1
      history_entry * found = malloc(sizeof(history_entry));
d2324 1
a2324 3
        #ifdef TRACE
          if (tl & (1u<<16)) Printf("history_load: Couldn't allocate space for entry\n");
        #endif
d2348 1
a2348 3
        #ifdef TRACE
          if (tl & (1u<<16)) Printf("history_load: Couldn't allocate space for URL description\n");
        #endif
a2353 1
        free(url);
a2356 2
        history_remove_entry(NULL, found);

d2383 1
a2383 3
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_load: OK, have entry %p with description block %p\n",found,found->url);
      #endif
d2391 1
a2391 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_load: Successful, exitting via. expiry functions\n");
  #endif
@


1.24
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d15 18
a32 17
/***************************************************/
/* File   : History.c                              */
/*                                                 */
/* Purpose: Handles the browser History.           */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 07-Feb-97: Created.                    */
/*                                                 */
/*          06-Nov-97: Major revision, largely a   */
/*                     complete rewrite to make    */
/*                     the system more flexible    */
/*                     and less prone to bugs (but */
/*                     still do Back/Forward as in */
/*                     Navigator 2, rather than    */
/*                     Navigator 3).               */
/***************************************************/
d39 17
a55 12
#include "kernel.h"
#include "swis.h"
#include "flex.h"

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "toolbox.h"
#include "window.h"
#include "gadgets.h"
#include "menu.h"
a56 1
#include "svcprint.h"
d184 12
a195 14
/*************************************************/
/* history_find_entry()                          */
/*                                               */
/* Returns a pointer to a history_entry for a    */
/* given URL.                                    */
/*                                               */
/* Parameters: Pointer to a null-terminated URL  */
/*             string to find.                   */
/*                                               */
/* Returns:    Pointer to a history_entry struct */
/*             representing the given URL, or    */
/*             NULL if no such entry is found    */
/*             in the History.                   */
/*************************************************/
d226 16
a241 16
/*************************************************/
/* history_find_user                             */
/*                                               */
/* Returns a pointer to a history_user for a     */
/* given browser in a given History entry.       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             represented by the entry;         */
/*                                               */
/*             Pointer to a history_entry struct */
/*             to search in.                     */
/*                                               */
/* Returns:    Pointer to a history_user struct  */
/*             representing the given browser or */
/*             NULL if no such entry is found.   */
/*************************************************/
d263 21
a283 24
/*************************************************/
/* history_add_user()                            */
/*                                               */
/* Add an association of a given browser with a  */
/* given History entry, updating the browser's   */
/* record of where it is in the local History to */
/* the new association (user record). This last  */
/* step is required if subsequent additions are  */
/* to be correctly linked into the local History */
/* list (history_next and history_prev fields).  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the association;      */
/*                                               */
/*             Pointer to a history_entry struct */
/*             to associate the browser to;      */
/*                                               */
/*             Pointer to a history_user *,      */
/*             in which the address of the new   */
/*             user record will be placed.       */
/*                                               */
/* Assumes:    The history_user * pointer may    */
/*             be NULL.                          */
/*************************************************/
d381 15
a395 18
/*************************************************/
/* history_record()                              */
/*                                               */
/* Records the visiting of a given URL in the    */
/* History, optionally associating this visit    */
/* with a given browser.                         */
/*                                               */
/* If there is already an entry for this URL, it */
/* will simply have its latest visit time        */
/* record updated.                               */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             to associate the visit with, or   */
/*             NULL for none;                    */
/*                                               */
/*             Pointer to a null-terminated URL  */
/*             string to record.                 */
/*************************************************/
d547 22
a568 26
/*************************************************/
/* history_inherit()                             */
/*                                               */
/* For any association in the History of a given */
/* base (parent) browser with a URL, create a    */
/* duplicate associaton with a given child       */
/* browser with the same visit timestamps. The   */
/* child browser thus inherits the history of    */
/* the parent.                                   */
/*                                               */
/* The history_current field of the child is set */
/* to the child's equivalent of the field in the */
/* parent.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             representing the parent browser;  */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             representing the child browser.   */
/*                                               */
/* Assumes:    The child browser has no existing */
/*             history references. If it does,   */
/*             then this will become detached as */
/*             the new references are put in     */
/*             place.                            */
/*************************************************/
d619 9
a627 9
/*************************************************/
/* history_remove_user()                         */
/*                                               */
/* Removes a given history_user record from the  */
/* various lists in which it may lie.            */
/*                                               */
/* Parameters: Pointer to the history_user       */
/*             structure to remove.              */
/*************************************************/
d670 20
a689 24
/*************************************************/
/* history_remove_entry()                        */
/*                                               */
/* Removes a given record from the History,      */
/* removes all associations with this entry,     */
/* and/or removes all associations between any   */
/* URLs in the History and a given browser. In   */
/* the latter case, URLs left with no            */
/* assocations are *not* removed; they stay as   */
/* global visit History records.                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             to remove all associations for,   */
/*             or NULL to not do this;           */
/*                                               */
/*             Pointer to the history_entry      */
/*             struct to remove, or NULL not to  */
/*             do this;                          */
/*                                               */
/* Assumes:    Either or both pointers may be    */
/*             valid or NULL, though obviously   */
/*             there's little point calling with */
/*             both set to NULL...               */
/*************************************************/
d806 20
a825 24
/*************************************************/
/* history_remove()                              */
/*                                               */
/* Removes a record in the History of a given    */
/* URL and all associations with this URL,       */
/* and/or removes all associations between any   */
/* URLs in the History and a given browser. In   */
/* the latter case, URLs left with no            */
/* assocations are *not* removed; they stay as   */
/* global visit History records.                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             to remove all associations for,   */
/*             or NULL to not do this;           */
/*                                               */
/*             Pointer to a null-terminated URL  */
/*             string to remove, or NULL to not  */
/*             do this.                          */
/*                                               */
/* Assumes:    Either or both pointers may be    */
/*             valid or NULL, though obviously   */
/*             there's little point calling with */
/*             both set to NULL...               */
/*************************************************/
d861 14
a874 16
/*************************************************/
/* history_add_title()                           */
/*                                               */
/* Associates a given title string with a given  */
/* URL and all associations with this URL,       */
/* and/or removes all associations between any   */
/* URLs in the History and a given browser.      */
/*                                               */
/* Parameters: Pointer to a null-terminated URL  */
/*             string for which the title is to  */
/*             be associated;                    */
/*                                               */
/*             Pointer to a null-terminated      */
/*             title string to associate with    */
/*             the URL.                          */
/*************************************************/
d922 14
a935 17
/*************************************************/
/* history_return_title()                        */
/*                                               */
/* Returns a title string (if any) associated    */
/* with a given URL.                             */
/*                                               */
/* Parameters: Pointer to a null-terminated URL  */
/*             string for which a title is to be */
/*             found.                            */
/*                                               */
/* Returns:    Pointer to a null-terminated      */
/*             title string associated with the  */
/*             URL, or NULL if either the URL    */
/*             had no associated title, or the   */
/*             URL couldn't be found in the      */
/*             History at all.                   */
/*************************************************/
d968 19
a986 22
/*************************************************/
/* history_expire()                              */
/*                                               */
/* Remove all associations of a URL which have   */
/* been visited before a given time (i.e. are    */
/* greater than a certain age). This may only be */
/* for associations with a specific browser.     */
/*                                               */
/* Any URL left with no associations and an      */
/* overall last visit time before that given     */
/* will be removed from the History completely.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             for which associations are to be  */
/*             expired, or NULL if the expiry is */
/*             for all History items;            */
/*                                               */
/*             Time (in time() function format)  */
/*             which a URL must have not been    */
/*             visited on or since for expiry to */
/*             take place.                       */
/*************************************************/
d1056 9
a1064 9
/*************************************************/
/* history_count()                               */
/*                                               */
/* Counts the size in memory of all strings and  */
/* structures used by the History.               */
/*                                               */
/* Returns:    Size of all strings and structs   */
/*             used by the History, in bytes.    */
/*************************************************/
d1134 12
a1145 13
/*************************************************/
/* history_limit()                               */
/*                                               */
/* Counts the history size, and will expire the  */
/* oldest item if it is over the given size.     */
/* This continues until the history falls at or  */
/* below the given size limit.                   */
/*                                               */
/* This is quite a slow process.                 */
/*                                               */
/* Parameters: Size in bytes at or below which   */
/*             the history is to fall on exit.   */
/*************************************************/
d1207 11
a1217 12
/*************************************************/
/* history_visited()                             */
/*                                               */
/* Returns 1 if a given URL is in the History,   */
/* else 0.                                       */
/*                                               */
/* Parameters: Pointer to a null-terminated URL  */
/*             string to look for.               */
/*                                               */
/* Returns:    1 if a record of this can be      */
/*             found in the History, else 0.     */
/*************************************************/
d1226 11
a1236 13
/*************************************************/
/* history_empty()                               */
/*                                               */
/* Inquire if there are any History items        */
/* present for a given browser or the global     */
/* History.                                      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the enquiry, or NULL  */
/*             for the global History.           */
/*                                               */
/* Returns:    1 if there are no items, else 0.  */
/*************************************************/
d1245 12
a1256 14
/*************************************************/
/* history_can_go_backwards()                    */
/*                                               */
/* Reports whether or not there are more pages   */
/* to go back to in the local History of a       */
/* given browser.                                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the History.          */
/*                                               */
/* Returns:    1 if there are more items in the  */
/*             local history to go back to, else */
/*             0.                                */
/*************************************************/
d1271 12
a1282 14
/*************************************************/
/* history_can_go_forwards()                     */
/*                                               */
/* Reports whether or not there are more pages   */
/* to go forward to in the local History of a    */
/* given browser.                                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the History.          */
/*                                               */
/* Returns:    1 if there are more items in the  */
/*             local history to go forwards to,  */
/*             else 0.                           */
/*************************************************/
d1297 13
a1309 14
/*************************************************/
/* history_fetch_backwards()                     */
/*                                               */
/* When called, will fetch the previous page in  */
/* a given browser's local History.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the History;          */
/*                                               */
/*             1 to open the URL in a new window */
/*             or 0 to open it in the window to  */
/*             which the browser_data struct is  */
/*             relevant.                         */
/*************************************************/
d1387 13
a1399 14
/*************************************************/
/* history_fetch_forwards()                      */
/*                                               */
/* When called, will fetch the next page in a    */
/* given browser's local History.                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the History;          */
/*                                               */
/*             1 to open the URL in a new window */
/*             or 0 to open it in the window to  */
/*             which the browser_data struct is  */
/*             relevant.                         */
/*************************************************/
d1477 19
a1495 24
/*************************************************/
/* history_menu_popup()                          */
/*                                               */
/* Handles clicks on a history menu popup item.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the history to show,  */
/*             or NULL if this is for a global   */
/*             history from an OpenURL dialogue  */
/*             box;                              */
/*                                               */
/*             Object ID of the item holding the */
/*             menu gadget;                      */
/*                                               */
/*             Component ID of the item that was */
/*             clicked on;                       */
/*                                               */
/*             1 to show the global history even */
/*             if the first parameter is not     */
/*             NULL, else 0;                     */
/*                                               */
/*             1 to show the URLs, 0 to show     */
/*             page titles where available.      */
/*************************************************/
d1560 14
a1573 15
/*************************************************/
/* history_compare_entries()                     */
/*                                               */
/* A comparisson function for qsort(); compares  */
/* the last_accessed fields of two given         */
/* history_entry structures so that an array     */
/* being sorted will have highest last_accessed  */
/* field (newest) items first.                   */
/*                                               */
/* Parameters: Pointer to the first              */
/*             history_entry struct as a void *. */
/*                                               */
/*             Pointer to the second             */
/*             history_entry struct as a void *. */
/*************************************************/
d1586 24
a1609 26
/*************************************************/
/* history_build_menu()                          */
/*                                               */
/* Builds a history menu for the given browser,  */
/* showing it at the specified coordinates.      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the menu, or NULL to  */
/*             build from the global history;    */
/*                                               */
/*             x coordinate to show at;          */
/*                                               */
/*             y coordinate to show at;          */
/*                                               */
/*             1 to show the global history even */
/*             if the first parameter is not     */
/*             NULL;                             */
/*                                               */
/*             Non-0 to only show URLs, 0 to     */
/*             allow titles in the menu;         */
/*                                               */
/*             Non-0 to subtract the width of    */
/*             the menu from the given show x    */
/*             coordinate (e.g. to show to the   */
/*             left of a given position) else 0. */
/*************************************************/
d2107 21
a2127 23
/*************************************************/
/* history_menu_selection()                      */
/*                                               */
/* Jumps to a URL according to the item selected */
/* in a history menu.                            */
/*                                               */
/* If Adjust is used the menu is not reopened as */
/* the fetch will occur in a new window (as with */
/* following page links) - it doesn't make sense */
/* to reopen the menu in this case.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the history, or NULL  */
/*             for the global history - in this  */
/*             case it is assumed that the menu  */
/*             opened from an Open URL dialogue  */
/*             and appropriate alternative       */
/*             functions will be called;         */
/*                                               */
/*             Pointer to a WimpPollBlock struct */
/*             from which the menu item that was */
/*             selected may be determined.       */
/*************************************************/
d2245 12
a2256 14
/*************************************************/
/* history_load()                                */
/*                                               */
/* Loads the global history from the given path. */
/* Will raise errors (usually, due to RISC OS    */
/* C's file I/O, the wrong ones...) if there is  */
/* a failure during loading, but not if the file */
/* refuses to open or the number of items cannot */
/* be read from it (i.e. a missing or zero       */
/* length History file).                         */
/*                                               */
/* Parameters: Pointer to the full pathname for  */
/*             the history file.                 */
/*************************************************/
d2517 8
a2524 8
/*************************************************/
/* history_save()                                */
/*                                               */
/* Saves the global history to the given path.   */
/*                                               */
/* Parameters: Pointer to the full pathname for  */
/*             the history file.                 */
/*************************************************/
d2627 12
a2638 14
/*************************************************/
/* history_save_as_html()                        */
/*                                               */
/* This function saves the History as an HTML    */
/* file.                                         */
/*                                               */
/* Parameters: Pointer to the filename to save   */
/*             to (null terminated);             */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             to save the History for if you    */
/*             want a local history, else NULL   */
/*             for the global history.           */
/*************************************************/
d2768 25
a2792 28
/*************************************************/
/* history_find_match()                          */
/*                                               */
/* Try to find the given fragment of text in the */
/* global visit history, searching through the   */
/* history entry titles and URLs. If found, add  */
/* the item to the start of the list of URLs in  */
/* the given match_list set of URL strings. If   */
/* this is empty on entry, the block is          */
/* initialised by creating the empty string that */
/* signals the last item when the first item is  */
/* added.                                        */
/*                                               */
/* The search is case-sensitive.                 */
/*                                               */
/* If there are no found entries, the function   */
/* will leave match_list unaltered.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             who's match_list list should be   */
/*             added to;                         */
/*                                               */
/*             Pointer to the buffer holding the */
/*             string to try and match.          */
/*                                               */
/* Returns:    1 if match_list is updated with   */
/*             one or more matches, else 0.      */
/*************************************************/
@


1.23
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d2818 9
a2826 3
/* Takes a string from the given buffer and sees */
/* if there's something in the global History    */
/* that matches it in some way.                  */
d2828 1
a2828 2
/* If it finds something, it writes it back to   */
/* the buffer and returns 1.                     */
d2830 2
a2831 2
/* Parameters: Pointer to the buffer holding the */
/*             string to try and match;          */
d2833 3
a2835 1
/*             Size of the buffer in bytes.      */
d2837 5
a2841 3
/* Returns:    1 if the buffer is updated with a */
/*             match string, else 0 (buffer      */
/*             contents will be unaltered).      */
d2844 1
a2844 1
int history_find_match(char * buffer, int buffer_size)
d2846 5
a2850 7
  history_entry * entry         = history_base;
  history_entry * lowest_entry  = NULL;
  const char    * found         = NULL;
  int             lowest_offset = -1;
  int             lowest_diff   = 0;
  int             this_offset   = 0;
  int             got_one;
d2852 1
a2852 1
  if (!buffer || !*buffer) return 0;
d2858 1
a2858 1
      got_one = 0;
d2860 1
a2860 1
      /* Match in the host, if present */
d2862 1
a2862 1
      if (entry->url->host)
d2864 2
a2865 1
        /* See if we can find the string */
d2867 1
a2867 1
        found = strstr(entry->url->host, buffer);
d2869 3
a2871 8
        if (found)
        {
          /* If so, record the offset into the string where  */
          /* the match was found and mark we've got a match. */

          this_offset = found - entry->url->host;
          got_one     = 1;
        }
d2876 1
a2876 1
      if (!got_one && entry->url->path)
d2878 1
a2878 7
        found = strstr(entry->url->path, buffer);

        if (found)
        {
          this_offset = found - entry->url->path;
          got_one     = 1;
        }
d2883 1
a2883 1
      if (!got_one)
d2885 1
a2885 7
        found = strstr(entry->url->full, buffer);

        if (found)
        {
          this_offset = found - entry->url->full;
          got_one     = 1;
        }
d2888 1
a2888 1
      /* Match in the title, out of desperation! */
d2890 1
a2890 1
      if (!got_one && entry->title)
d2892 1
a2892 1
        found = strstr(entry->title, buffer);
d2894 2
a2895 55
        if (found)
        {
          this_offset = found - entry->title;
          got_one     = 1;
        }
      }

      /* If found, have we not recorded an offset before, or is this offset  */
      /* lower than any previously recorded? If so, remember the entry. This */
      /* way, 'digital' will match 'www.digital.com' rather than             */
      /* 'www.altavista.digital.com' regardless of where the entry is in the */
      /* History. Matching the first one we come to would obviously rely on  */
      /* the order of appearance in the list.                                */

      if (got_one)
      {
        if (lowest_offset < 0 || this_offset <= lowest_offset)
        {
          int this_diff = strlen(entry->url->full) - strlen(buffer);

          lowest_offset = this_offset;

          /* Having found an entry that matches in the lowest part of the string */
          /* so far, we also want to choose one which has the smallest string    */
          /* length difference between itself and the given match string, which  */
          /* is non-zero. This ensures we would go 'www.acorn.com/acorn/',       */
          /* 'www.acorn.com/acorn/news/', 'www.acorn.com/acorn/news/releases/'   */
          /* again regardless of the relative position of the entries in the     */
          /* History list.                                                       */
          /*                                                                     */
          /* Of course, the whole thing is still fairly undetermined - whatever  */
          /* the next directory is after you've found a match on the root of a   */
          /* site (say) which happens to be the shortest will be the tree you    */
          /* always end up fetching. But it's a reasonable start on this anyway, */
          /* and the mists of time may well reveal that further enhancements are */
          /* not necessary in practice.                                          */

          if (this_offset < lowest_offset)
          {
            /* First thing, we've found a new lowest offset; so forget any previous */
            /* string length differences.                                           */

            lowest_diff = 0;
          }

          /* If we've not got a lowest difference yet, or we have a current difference */
          /* and it's lower than the recorded lowest, then remember the difference and */
          /* the entry that generated it.                                              */

          if (!lowest_diff || (this_diff && this_diff < lowest_diff))
          {
            lowest_diff  = this_diff;
            lowest_entry = entry;
          }
        }
d2904 1
a2904 16
  /* Did we end up finding anything? */

  if (lowest_entry && lowest_offset >= 0)
  {
    /* Yes - copy the full URL into the buffer and return, saying */
    /* we updated the buffer contents.                            */

    strncpy(buffer, lowest_entry->url->full, buffer_size);
    buffer[buffer_size - 1] = 0;

    return 1;
  }

  /* No - exit, saying we didn't touch the buffer contents. */

  return 0;
@


1.22
log
@All !Run[D], Choices, Messages, Controls and Res files are up to date.

RefoKeep and RefoHold options added to, respectively, try and maintain
the line at the top of the visible area when reformatting, and not shrink
the vertical extent at the start of a reformat to try and avoid flicker
to the top of the page and back down again when RefoKeep is on. Choices
front-end implemented, which also allows RefoWait and RefoTime to be set.
Unfortunately for various reasons this doesn't help the page jumping when
unsized images come in (but RefoHold can improve matters...) - roll on
the image history.

DragToScroll and NoScrollBars options added for frames; included new
pointer type, Mouse_Shape_DTS, so relevant Controls file entries done
and Sprites[22] files updated as required. Noticed some builds have
a low-res ptr_link with a mask - mask removed.

Named anchor following fixed up somewhat - anchors near the bottom of
the page shouldn't be displayed, and then pulled down when the fetcher
releases null polls and ensures the y extent is correct (this through
implementing the min_height field in the browser_data structure).

RefoHang was never implemented and there seems little point to it now,
so the entry for it has been removed from the global choices structure
and all Choices files.

Markers menus should work properly now (in last check-in they would not
update correctly if Adjust was used on the entries).

URI handler usage now a lot more sensible, with configuration of how the
browser uses the module from both a Utils menu submenu (sic) and the
Choices dialogue.

Slightly dodgy 'hang around waiting for user input' stuff for the Cookies
dialogue box: All fetches are suspended; the fetcher remembers some info
about its state at the time the cookie came in, and restores it later; it
will only do this for one fetch at a time. It's necessary to single-thread
the fetcher at this point anyway, since other fetches may have a
dependency on the cookie that is hanging in mid-air at that point. As part
of this, some of the fetcher code has been split out into separate
functions (to try and 'black box' the code a bit). Anyway, Cookie Query
dialogue box now implemented with appropriate Choices file entry and
UI work in the Choices dialogue box.

Phoenix build Choices rearranged. Can now choose when the image history
is saved from the front end. Added also MSIE 4-style table option menu
for JPEG support (OS only, OS if it can handle it, internal only).

Should be a bit faster at loading the history - though 95% of the time
is spent in SWI URL_ParseURL. URL descriptions are stored more
efficiently as part of this - one malloc block instead of several
small blocks. The minimum block size for malloc blocks typically leads
to a significantly smaller startup wimpslot depending on the visit
history size.

Nasty bug in image system fixed. If an image size came in and a reformat
was to take place, the line the image lies in is found and the reformat
progresses from there. Unforunately, this didn't check to see if the
token can't be found in the line list, so it'd reformat from the top
of the page...! This would happen if, for example, an image halfway down
the page came in whilst a reformat for an image higher up had just begun.

In Choices.c, made choices_set_timetype_field, choices_set_uri_field,
choices_set_plugin_field, choices_set_cookie_field, and
choices_set_jpeg_field static (so they're not declared in Choices.h now).

Two memory leaks plugged in URL comparison routines in URLutils.c
(calling free() url_description instead of urlutils_free_descripton()).

Client pull reload handler was setting the reload flag if reloading
the same page, but forgetting to turn on reload_lock so
fetchpage_postprocessed was clearing the reload state... Similarly,
Ctrl+Shift+SELECT-Click on a link when the Controls file 'UseSmall'
entry is 'no' would not have reloaded as it should. Both fixed.

Frames shouldn't be so keen on acquiring horizontal scroll bars and never
letting them go when their width is decreased now. Frames set up for
'scrolling="yes"' will not start with no scroll bars and then gain them
shortly afterwards, causing flicker and two reformats - they'll start
with, and continue to hold, both scroll bars.

Pointer shouldn't flicker when over a frame border whilst other fetches
are progressing now.
@
text
@d60 1
d2251 11
d2549 2
d2559 1
a2559 1
  RetLastE;
d2624 2
d2629 1
a2629 1
    RetLastE;
d2652 2
d2657 1
a2657 1
        RetLastE;
d2801 2
d2812 1
a2812 1
  RetLastE;
@


1.21
log
@Programming warehouse link removed from all hotlists - the page has gone.

Some compile-time hacks in place to use MemLib, a dynamic area based
malloc replacement which shrinks its heap when possible. All builds
have these switched off at the moment. Seemed to work with just Browse,
though there would be problems with message blocks stored in dynamic
areas because of the Wimp's '&3800000' check - however, it failed when
HTMLLib was made to use it, too. Don't know why yet.

ItemInfo.[c/h] source added, with Res file additions for testbed Browse
and Phoenix.

Small fetch windows now work properly regardless of toolbar settings
in the Choices.

Reload now reloads all images too, rather than only reloading them for
as long as the main page was being fetched.

Added a simple 'Find' facility.

Realised that event handlers in eventlib are called in reverse order
of registration, so the miscellaneous event handler is now registered
first rather than last.

Multiuser code added (most only active if SINGLE_USER is undefined). As
part of this, hotlist code now knows about read-only items (done for the
Customer-style 'Resources' file, but works generally anyway).
handle_add_hotlist doesn't try to save the hotlist itself anymore (the
hotlist_add function does all that through hotlist_modified anyway).

Customer build Choices and Controls updated slightly (e.g. ClaimHelp
off, hotlist to save on quit only).

Customer build now uses Phoenix-style buttons. Sprites files which
worked at the time (but will probably be out of date now) and included
most of the original Customer-style sprites are in
'Utils.Icons.Customer'.

Choices, Messages and Res files for all builds now stripped down to only
single user items or single plus multiuser for Customer build and testbed
build. Before, all contained a few multiuser bits in at least the Choices
file if not more.

Grammatical error ("Fetching frames contents" (sic.)) corrected in
default message, Toolbars.c, and all of the Messages files.

Customer build brought back to a servicable level (including
implementation of the Find dialogue box with animation and fixing
up authorisation and 'Stop' state in the tristate). Quite a few
missing #ifndef REMOTE_HOTLIST bits from hotlist code added...

Customer build will not use <Choices$Write> or Boot:Choices for any
file finding now. UseProxy defaults to 'yes', MaxImages to 2. Res
file includes Proxy Address setting (save_save_choices() now writes
the ProxyAddress line).
@
text
@d133 1
a133 1
  unsigned int           last_accessed;
d1007 1
a1007 3
/*             take place - so to expire 1 day   */
/*             old URLs, say, you'd pass         */
/*             time() - 60*60*24.                */
a2299 1
  int           cc, ch;
d2368 1
a2368 1
      _swix(Hourglass_Off,0);
d2382 1
a2382 1
      _swix(Hourglass_Off,0);
d2392 1
a2392 1
    for (cc = 0; cc < title_len; cc++)
d2394 4
a2397 1
      int ch = fgetc(file);
d2399 3
a2401 1
      if (ch == EOF) goto history_load_exit;
d2403 1
a2403 1
      title[cc] = (char) ch;
d2408 1
a2408 3
    /* Hmm, should not be needed? But it seems fscanf reads one \n extra */
    /* when there is a NULL title string. It probably thinks the line    */
    /* ending type is '\n\n' or something.                               */
d2410 1
a2410 1
    if (title_len)
d2412 4
a2415 4
      /* Skip the '\n' */

      ch = fgetc(file);
      if (ch == EOF) goto history_load_exit;
d2418 3
a2420 7
    /* Read the URL */

    for (cc = 0; cc < url_len; cc++)
    {
      int ch = fgetc(file);

      if (ch == EOF) goto history_load_exit;
d2422 1
a2422 2
      url[cc] = (char) ch;
    }
a2424 5

    /* Skip the '\n' */

    ch = fgetc(file);
    if (ch == EOF) goto history_load_exit;
@


1.20
log
@*Don't* try to load FilterManager 0.18 in !Run[D] files. Requires
WindowManager 3.98. Sets URI handler environment variables for
http, ftp and gopher.

Fixed 'doesn't reformat for unsized images' bug - only happens when the
deferred reformatter is enabled, hadn't remembered to check this in my
debug build where this is turned off. Oops.

Caret position in forms could get left behind despite attempts to rectify
this in v1.31 - now fixed (and faster, fortunately).

Hourglass + percentage displayed for History and Image History when
loading - it can take a while for very big histories, though in
practice you only see the visit history loading (has to do a lot
more work, and is thus quite a bit slower than the image history).

POST forms worked when targetted to frames, but were broken when
not targetted! (Forms data inherited from one browser to the same
browser; ended up freeing the flex block...). Fixed.

Now support 303 response code (redirect to GET). Treated as 301, i.e.
not support if STRICT_PARSER is defined, otherwise drops through to
the 302 handling code.

Pointer shouldn't get stuck in odd shapes when going to a new page now;
it gets reset to a standard shape every time the null handler that
checks the position is called, though (whether or not the handler thinks
the pointer is over a different token, if that token is NULL, it sets
the standard shape). A possible work around would be for a browser to
remember the pointer shape too; that's for the future, though.

Early stage table formatting functions could blow themselves apart if
tables_count_table decided there were no rows, columns or both. A
net table size of zero cells is now dealt with; slow, partial table
fetches in multiple windows with image loading turned on will now
*hopefully* be stable, where v1.31 would have bombed out repeatedly.

A nested frameset within one document will now inherit the border
width (frame spacing) and border colour of its parent. This is done
by copying the maxlen and indent fields of the parent token over
the child, and note it's done in the browser (fetch_preprocess_token),
not HTMLLib.

Border colour on a FRAMESET now used, with the first colour on any
FRAME within it overriding, as in NN 4 and MSIE 4.

<LI> bullets really do stick to the text next to them now (I'd done
that in an experimental piece of code and forgotten to merge it back
before the last check-in).

Browse$HotlistURL/URIFile and Browse$HomeURL/URIFile now work from
_TaskName in the Messages file, and are thus of the generic form
<App>$HotlistURL etc. - Docs.Notes and Docs.User updated appropriately.

Event 0x11d00 through to 0x11d7f will make the browser look up Controls
file entries 'JumpTo00' through to 'JumpTo7f' and read a URL from them.
This will be fetched in the ancestor window of the source of the event,
or a new window if such an ancestor can't be found [for Daytona demo].

NB: Nasty frames-related crash at http://www.teledanmark.dk/menu/start.htm
is *not* fixed in this source. NOBR is not supported.
@
text
@d537 8
a544 4
  if (choices.save_history == Choices_SaveHistory_Always)
  {
    return history_save(lookup_choice("HistorySave:Browse:User.History",0,0));
  }
@


1.19
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d2344 2
d2348 5
d2367 2
d2381 2
d2454 2
d2480 2
d2528 2
d2543 3
a2545 1
  fclose(file);
@


1.18
log
@Note that the 'Docs' documentation (possibly contrary to previous
log messages) still hasn't been updated with the new SaveFile
stuff, and function header comments have yet to be written for
SaveFile.c.

Fixed urlutils_pathname_to_url - OS_GSTrans doesn't like the same
input buffer as output buffer (fairly obvious, but I was living in
the hope of not having to duplicate the input path string).

Image history will not cache scrap file images anymore. Browser's
image handling library won't cross reference them either.

When dragging a single item from the hotlist to a Filer window, the
code now checks Ctrl - if held down, a URL file is written, else a
URI file. The state of any option buttons or radios in the last
Save File dialogue that was opened is no longer relevant...!

history_save_as_html could write out broken files when titles
for items in the History were not present. Fixed.

Hourglass switched on for hotlist and history saving as HTML;
hotlist_save_entries no longer closes the output file on error
(it should be done by the caller, since the caller is responsible
for opening the file and passing the FILE * pointer to
hotlist_save_entries).
@
text
@d145 2
a146 1
  url_description      * url;    /* (Defined in MiscDefs.h) */
d197 1
d204 1
d206 1
a206 1
  if (!url_d) return NULL;
d212 1
a212 6
    if (!urlutils_urlddcmp(find->url, url_d))
    {
      urlutils_free_description(url_d);

      return find;
    }
d219 1
a219 1
  return NULL;
d474 6
d539 1
a539 1
    return history_save(lookup_choice("HistoryPath:Browse:User.History",0,0));
d1651 9
a1659 8
  wimp_menuhdr  * mhp;
  wimp_menuitem * mip;
  char          * menudata;

  int             i;
  int             size;
  int             width, awidth, thiswidth;
  int             len;
d1686 2
d2089 5
a2093 1
  return wimp_create_menu(history_menu, x - (subtract ? (mhp->width + 64) : 0), y);
d2099 2
d2122 2
d2475 6
d2554 8
a2561 2
  local_path = malloc(strlen(pathname) + 1);
  if (!local_path) return NULL;
d2563 6
a2568 1
  strcpy(local_path, pathname);
@


1.17
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d2640 4
d2681 1
a2681 1
                                      entry->title ? entry->title : entry->url->full));
d2704 1
a2704 1
                                      entry->title ? entry->url->full : ""));
d2719 2
d2738 6
a2743 1
  if (fileptr) fclose(fileptr);
@


1.16
log
@Image history - sizes of images are remembered for future reference (if
the sizes aren't specified in the HTML, they can be looked for in the
image history instead to minimise reformatting requirements). Choices
file options ImageHistoryPath, ImageExpiryAge, ImageMaxSize and
SaveImageHistory added to support this (all have a direct analogy to
the global History items of the same name after removing 'Image').

Text area items are now the correct height for the number of rows
specified in the HTML, don't scroll a line too early, and have the
caret placed at the start of the text when moved into from above
or at the end when moved into from below (rather than always at
the end, which was behaviour inherited from single line writables,
where this is desirable). The top of the text area is aligned to
the top of any line of text on the same line, with the text area
dropping below the text, rather than the bottom of the area matching
the text baseline and extending upwards.

Filename extensions for download files are only stripped if an
attempt to convert to a RISC OS filetype through the Mime Mapper module
does not return an error or Data (0xffd) filetype. '.cgi' is a special
case which is always stripped.

Altered heading styles - all are bold, none are italic, H3 is as big
as H2 was, H2 is a little larger, and others scale down to H6 being
the size as normal text (but, as I say, bold).

Sorted out tables and forms. We can just look for tagno=TAG_FORM, and
get rid of the wobbly form_flag; also discarded the redundant
reprocess_table flag in fetch_preprocess_token. Two separate forms
in consecutive table cells (for example) which used to fail - they
were submitted as one single form - will now work correctly.

Fixed nasty bug in FontManage.c where font size 7 would intermittently
fail. The stupid font sizes that it could ask the Font Manager for may
be responsible for the occasional Font Manager crashes that have been
noticed. Array for font sizes was declared as [Limits_FontSizes], but
indices 1 to Limits_FontSizes are actually used - so needed a '+ 1'
in the declaration... :-/

Replaced the case insensitive string comparison functions in Utils.c
with more efficient versions by S.Brodie.

MAXLENGTH specifier in INPUT tags is now supported. If unspecified or
specifically zero, the browser overrides and allows any length.
@
text
@d403 2
a404 3
  _kernel_oserror * e;
  history_entry   * found   = NULL;
  history_user    * newuser = NULL;
d570 4
a573 5
  _kernel_oserror * e;
  history_user    * parent_user;
  history_user    * parent_current;
  history_user    * child_user;
  history_user    * child_equivalent = NULL;
a1393 2
    _kernel_oserror * e;

a1484 2
    _kernel_oserror * e;

d1647 8
a1654 10
  _kernel_oserror * e;

  wimp_menuhdr    * mhp;
  wimp_menuitem   * mip;
  char            * menudata;

  int               i;
  int               size;
  int               width, awidth, thiswidth;
  int               len;
d2276 8
a2283 9
  _kernel_oserror * e;
  FILE            * file;
  char            * title      = NULL;
  char            * url        = NULL;
  static char     * local_path = NULL;
  int               result;
  int               last_accessed, title_len, url_len;
  int               items, item;
  int               cc, ch;
@


1.15
log
@Following the last check-in - all build resources brought up to date.

Adjust-click on forwards/backwards buttons did not work in the intermediate
build, and now does.

Adjust-click on form submission buttons where the submit method is POST
will now work correctly, as the new view inherits the extradata block
of the old. Failure of this is signalled through
make_no_fetch_memory_error, code 16 (see updated Errors file in Docs).
Note the name change of extradata in this context; more details below.

The passing of forms POST data and extra headers for sending in an
HTTP request via. the URL module was all done through pointers into
flex blocks, and was therefore very unsafe. All relevant functions now
use pointers to pointers to the data.

To remove confusion on the umpteen uses of the word 'extradata', the field
in browser_data has been renamed to 'post_data'. The 'extradata' parameters
used within FetchPage.c were all disconnected from the extra header info /
form POST data stuff that extradata is usually associated with, and have
thus also been renamed, in this case to 'appnddata' (Append Data).

As well as X-NoProxy, the browser sends the 'proper' HTTP headers
Pragma:no-cache and Cache-Control:no-cache.

A redirection from a POST request was not handled correctly; despite
what HTTP specs say, you're supposed to use GET for the new URL. The
browser was, but when it chopped off the redundant header data in the
request didn't terminate it and left Content-Type in anyway...! Fixed.

Ctrl+Tab implemented - URL completion. Comes from the hotlist URLs,
hotlist titles, history hosts, paths, full URLs and lastly titles.
See code comments for more (history_find_match, hotlist_find_match).

TableSupport option added to Choices; it is read, can be set by the
front-end, but doesn't actually do anything else yet.

Reversed Choices' semantics on 'don't expire by...' for History. Added
'needs_redraw' flag to choices_get_contents so that, for example, if the
table border types change, browsers get redrawn.
@
text
@d1006 1
a1006 1
_kernel_oserror * history_expire(browser_data * b, int time)
d1166 1
a1166 1
_kernel_oserror * history_limit(int size)
a2293 2
  #define HistoryLoad_ExitIfEOF(var) if ((var) == EOF) {fclose(file); RetLastE;}

d2343 1
a2343 1
    HistoryLoad_ExitIfEOF(result);
d2352 2
d2355 1
d2364 2
d2368 1
d2378 1
a2378 1
      HistoryLoad_ExitIfEOF(ch);
d2394 1
a2394 1
      HistoryLoad_ExitIfEOF(ch);
d2403 1
a2403 1
      HistoryLoad_ExitIfEOF(ch);
d2413 1
a2413 1
    HistoryLoad_ExitIfEOF(ch);
d2460 1
d2509 12
@


1.14
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d1359 1
a1359 1
   return NULL;
d1366 5
a1370 1
  /* Step backwards */
d1396 2
d1399 1
a1399 1
      if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting through windows_create_browser\n");
d1402 9
a1410 1
    return windows_create_browser((char *) url, NULL, NULL, NULL, Windows_CreateBrowser_Normal);
d1412 2
d1459 5
a1463 1
  /* Step forwards */
d1489 2
d1492 1
a1492 1
      if (tl & (1u<<16)) Printf("history_fetch_forwards: Exitting through windows_create_browser\n");
d1495 9
a1503 1
    return windows_create_browser((char *) url, NULL, NULL, NULL, Windows_CreateBrowser_Normal);
d1505 2
d2729 169
@


1.13
log
@Now handles PARAM tags. Sorted out Plug-In bug that was related to Java
setting a 0 by 0 graphics window before calling Wimp_Poll (fixed in Java).
Implemented queue for Plug-Ins so multiple broadcasts aren't sent for
several Objects in one data chunk.

Added Docs directory with some documentation in it. More things to keep
checking for stylistic consistency, horray ;-)

Corrected !Run[D] for Ursula build to need AcornURI but not TaskModule
(URI handler needed for !Mail to pick up mailto: links).

Added display_height field to browser_data, analogous to display_width,
to cope with % sized objects by width and height (see how HRs are
handled in Redraw.c for an example of how it was always fairly easy
with width, but not height until this addition). Though you do have
to reload to get a new size; reformat isn't enough. Must see to this
some time...

Fixed bug where basic typefaces were claimed *before* the Choices file
had been read. For unusual Choices settings, this could create some
'interesting' problems now and again. This was part of narrower scope
work in the Choices code to allow font changing without leaking font
handles (now done; fm_shutdown only ditches fonts, it keeps internal
structures - must then call  fm_lose_fonts for all browsers to get the
bitfields up to date, then rewrite the typeface definitions and reclaim
basic fonts). Noticed that fm_claim_basic_typefaces would claim multiple
instances of the same font if there were several cases of the same font
mapped to different typeface styles - fixed.

Implemented PlugInControl settings, but not SupportObject (fully).
@
text
@d18 1
a18 1
/* Purpose: History functions for the browser.     */
d23 8
d59 1
d69 48
a116 1
/* Static variables */
d118 1
a118 3
static void * global_history    = NULL;
static void * view_history_menu = NULL;
static int    menu_entries      = 0;
d120 1
a120 1
/* Static function prototypes */
d122 3
a124 1
static char * history_title(char * url);
d126 2
a127 116
// void browser_save_history(void)
// {
//   char command[sizeof(user.historyfile)+32];
//
//   sprintf(command,"Save %s %p +%x",user.historyfile,global_history,flex_size(&global_history));
//   os_cli(command);
// }
//
// void browser_lose_history(void)
// {
//   if(global_history)
//   {
//     flex_free(&global_history);
//     global_history=NULL;
//   }
//   if(authorise)
//   {
//     flex_free(&authorise);
//     authorise=NULL;
//   }
// }
//
// /*----------------------------------------------------------------------*/
// void browser_load_history(void)
// {
//   browser_lose_history();
//   load_file_into_flex(user.historyfile,&global_history);
// }
//
//
// static int hotlist_make_history_file(int count,browser_data * b,char *filename)
// { /* make the history export file or, if count is 1, just get its length.
//      If filename is set, write to it, otherwise use the save library. */
//   int  length,i;
//   char title[100];
//   char buffer[200];
//   char *p,*e;
//   FILE *f=NULL;
//
//   length=0;
//   if(filename)
//   {
//     f=fopen(filename,"w");
//
//     if(!f)
//     {
//       erb = *_kernel_last_oserror();
//       show_error_ret(&erb);
//
//       return 0;
//     }
//   }
//   sprintf(title,msgs_lookup("HTITLEH:Browser history list for %s"),user.name);
//   sprintf(buffer,"<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",title);
//   hotlist_output(buffer,count,&length,f);
//   sprintf(buffer,"<h1>%s</h1>\n<p><dl>\n",title);
//   hotlist_output(buffer,count,&length,f);
//   p=(char*)global_history;
//   e=p+flex_size(&global_history)-1;
//   while(p && p<e)
//   {
//     p+=sizeof(int);
//     hotlist_output("    <dt><a href=\"",count,&length,f);
//     hotlist_output(p,count,&length,f);
//     hotlist_output("\">",count,&length,f);
//     hotlist_output(p,count,&length,f);
//     p+=strlen(p)+1;
//     while((int)p&3) p++; /* word aligned */
//     hotlist_output("</a>\n",count,&length,f);
//   }
//   hotlist_output("</dl><p>\n</body>\n</html>\n",count,&length,f);
//   if(!count) length=!length;
//   if(f) fclose(f);
//   return(length);
// }
// static int hotlist_history_saver(void *handle,char *pathname)
// {
//   pathname=pathname;
//   return(hotlist_make_history_file(0,(browser*)handle,NULL));
// }
//
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
// static int hotlist_file_history_size(browser_data * b)
// {
//   return(hotlist_make_history_file(1,b,NULL));
// }
//
// /*----------------------------------------------------------------------*/

/*************************************************/
/* history_title()                               */
/*                                               */
/* Returns a pointer to the title string for a   */
/* given URL in the global history, or NULL if   */
/* the URL can't be found / the global history   */
/* is empty. NULL is also returned if the title  */
/* string is of zero length.                     */
/*                                               */
/* This pointer is in a flex block, so beware of */
/* flex block shifts when using it.              */
/*                                               */
/* Parameters: Pointer to the URL.               */
/*                                               */
/* Returns:    Pointer to the title string, or   */
/*             NULL if the URL isn't found / the */
/*             global history is empty / the     */
/*             title string is of zero length.   */
/*************************************************/

static char * history_title(char * url)
{
  int entry;

  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_title: Called with URL '%s'\n", url);
  #endif
d129 2
a130 1
  /* If history is empty, return NULL */
d132 4
a135 5
  if (!global_history)
  {
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_title: Exitting, the history is empty\n", url);
    #endif
d137 2
a138 2
    return NULL;
  }
d140 4
a143 1
  /* Find the offset of the history entry */
d145 2
a146 1
  entry = history_visited(url, 0);
d148 1
a148 1
  /* Return NULL if the URL wasn't found */
d150 3
a152 5
  if (entry < 0)
  {
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_title: Exitting, the URL wasn't found\n", url);
    #endif
d154 1
a154 2
    return NULL;
  }
d156 1
a156 1
  /* Else calculate the offset of the title string */
d158 2
a159 2
  entry += sizeof(int);
  entry += strlen((char *) ((int) global_history + entry)) + 1;
d161 4
a164 2
  /* If the string is zero length return NULL, else */
  /* return a pointer to it.                        */
d166 1
a166 5
  if (!strlen((char *) ((int) global_history + entry)))
  {
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_title: Exitting, the title was a null string\n", url);
    #endif
d168 2
a169 2
    return NULL;
  }
d171 3
a173 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_title: Successful, pointing to '%s'\n", (char *) ((int) global_history + entry));
  #endif
d175 1
a175 2
  return (char *) ((int) global_history + entry);
}
d178 1
a178 6
/* history_visited()                             */
/*                                               */
/* Returns an offset into the global history if  */
/* a given URL has been visited before (i.e. is  */
/* in the global history), optionally            */
/* timestamping it if it's there.                */
d180 2
a181 1
/* Parameters: Pointer to the URL;               */
d183 2
a184 1
/*             1 to timestamp it, else 0.        */
d186 4
a189 3
/* Returns:    -1 if the item is not in the      */
/*             global history, else an offset    */
/*             into the history of the item.     */
d192 1
a192 1
int history_visited(char * url, int stamp)
d194 2
a195 1
  int offset = 0;
d197 1
a197 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_visited: Called with URL '%s'\n", url);
  #endif
d199 1
a199 3
  if (global_history)
  {
    int e;
d201 1
a201 1
    /* If the history exists, set e to the offset of the end */
d203 1
a203 1
    e = flex_size(&global_history) - 1;
d205 1
a205 1
    /* Loop around inside the history list, searching for the given URL */
d207 3
a209 1
    while (offset < e)
d211 1
a211 2
      /* If the URL is found, timestamp it if required and exit, */
      /* returning the offset of this entry.                     */
d213 2
a214 5
//Printf("comparing '%s'\n"
//       "to        '%s'\n\n",url,(char *) global_history + offset + sizeof(int));
      if (!strcmp((char *) global_history + offset + sizeof(int), url))
      {
        if (stamp) *(int *) ((char *) global_history + offset) = time(NULL);
d216 1
a216 16
        #ifdef TRACE
          if (tl & (1u<<16)) Printf("history_visited: Succesful, found URL\n");
        #endif

        return offset;
      }

      /* Jump past the current entry (i.e. a timestamp plus the two */
      /* strings that follow including terminators, word aligned).  */

      offset += sizeof(int);
      offset += strlen((char *) global_history + offset) + 1;
      offset += strlen((char *) global_history + offset) + 1;

      offset = (int) WordAlign(offset);
    }
d219 1
a219 1
  /* URL not found - return -1. */
d221 1
a221 5
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_visited: Successful, but URL was not found\n");
  #endif

  return -1;
d225 1
a225 1
/* history_record_global()                       */
d227 2
a228 5
/* Records a URL in the global history. The URL  */
/* must NOT be in a flex block, as this routine  */
/* may allocate flex store which could lead to   */
/* other blocks shifting, invalidating the URL   */
/* pointer passed in.                            */
d230 9
a238 2
/* Parameters: Pointer to a URL, which is not in */
/*             a flex block.                     */
d241 1
a241 1
_kernel_oserror * history_record_global(char * url)
d243 1
a243 1
  /* Proceed if the URL isn't already in the history */
d245 1
a245 3
  #ifdef TRACE
    if (tl & (1u<<16)) Printf("history_record_global: Called with URL '%s'\n", url);
  #endif
d247 1
a247 3
  if (history_visited(url, 1) < 0)
  {
    int len, oldsize, ok;
d249 1
a249 1
//    toolbars_hide_internal(url);
d251 3
a253 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_record_global: Proceeding\n", url);
    #endif
d255 2
a256 3
    /* Set 'len' to the size of this entry; the */
    /* URL plus terminator, null title string,  */
    /* and the timestamp, word aligned.         */
d258 2
a259 2
    len = strlen(url) + 1 + 1 + sizeof(int);
    len = (int) WordAlign(len);
d261 24
a284 4
    if (global_history)
    {
      /* If the history already exists, may need to ensure */
      /* it hasn't got too long                            */
d286 3
a288 6
      while (
              flex_size(&global_history) > 4 &&
              (flex_size(&global_history) + len) > choices.g_hist_size * 1024
            )
      {
        /* As long as the history is oversized, delete the oldest entry */
d290 3
a292 4
        int    size, oldest = *(int *) global_history;
        char * e;
        char * f = NULL;
        char * p;
d294 1
a294 3
        /* Lock flex - we want to store pointers for a moment and */
        /* can't allow it to move (it shouldn't anyway, but this  */
        /* makes absolutely sure!).                               */
d296 1
a296 1
        flex_set_budge(0);
d298 6
a303 2
        /* Point to the first byte in 'p', the last byte in 'e', and */
        /* start with 'f' pointing to the first byte too.            */
d305 3
a307 3
        p = (char *) global_history;
        e = p + flex_size(&global_history) - 1;
        f = p;
d309 2
a310 1
        /* Search for the oldest entry */
d312 3
a314 11
        while (p < e)
        {
          if (*(int *) p < oldest)
          {
            oldest = *(int *) p;
            f = p;
          }

          p += sizeof(int);
          p += strlen(p) + 1; /* Get past URL   */
          p += strlen(p) + 1; /* Get past title */
d316 2
a317 2
          p = WordAlign(p);
        }
d319 1
a319 1
        /* Get the size of this oldest entry */
d321 1
a321 1
        size = strlen(f + sizeof(int)) + 1; /* Length of URL plus terminator */
d323 2
a324 1
        size = sizeof(int) + size + strlen(f + sizeof(int) + size) + 1;
d326 1
a326 1
        size = (int) WordAlign(size);
d328 2
a329 2
        /* Copy entries above the entry down over it */
        /* and shrink the flex block as appropriate  */
d331 3
a333 1
        memmove(f, f + size, (e - f + 1) - size); /* (e - f + 1 as e points to the last used byte, not to the first free one) */
d335 1
a335 1
        /* Allow flex to move again */
d337 1
a337 1
        flex_set_budge(1);
d339 4
a342 4
        #ifdef TRACE
          flexcount -= size;
          if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
        #endif
d344 4
a347 2
        flex_extend(&global_history, flex_size(&global_history) - size);
      }
d349 3
a351 16
      /* Allocate space for the entry */

      oldsize = flex_size(&global_history);

      ok = flex_extend(&global_history, oldsize + len);

      #ifdef TRACE
        if (ok)
        {
          flexcount += len;
          if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
        }
      #endif
    }

    /* If the history doesn't exist, create it */
d353 1
a353 1
    else
d355 1
a355 2
      oldsize = 0;
      ok = flex_alloc(&global_history, len);
d358 1
a358 5
        if (ok)
        {
          flexcount += len;
          if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
        }
a359 1
    }
d361 1
a361 12
    if (!ok)
    {
      erb.errnum = Utils_Error_Custom_Normal;

      StrNCpy0(erb.errmess,
               lookup_token("NoMemGHi:There is not enough free memory to add the page to the global history.",
                            0,
                            0));

      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_record_global: Exitting with error\n", url);
      #endif
d363 1
a363 1
      return &erb;
d365 1
d367 1
a367 5
    /* Add the entry */

    *(int *) ((char *) global_history + oldsize) = time(NULL);                       /* Timestamp         */
    strcpy(((char *) global_history + oldsize) + sizeof(int), url);                  /* URL string        */
    strcpy(((char *) global_history + oldsize) + sizeof(int) + strlen(url) + 1, ""); /* Null title string */
d369 1
a369 1
    /* If required, save the history */
d371 1
a371 2
    if (choices.save_history == Choices_SaveHistory_Always) return history_save(lookup_choice("HistoryPath:Browse:User.History",0,0));
  }
d374 1
a374 1
    if (tl & (1u<<16)) Printf("history_record_global: Successful\n", url);
d377 2
d383 1
a383 1
/* history_record_local()                        */
d385 7
a391 9
/* Records a URL in the local (view) history.    */
/* The URL must NOT be in a flex block, as this  */
/* routine may allocate flex store which could   */
/* lead to other blocks shifting, invalidating   */
/* the URL Pointer passed in.                    */
/*                                               */
/* If the URL pointer is NULL, then the current  */
/* URL as returned by browser_current_url() in   */
/* Windows.c will be added.                      */
d394 2
a395 1
/*             relevant to the history;          */
d397 2
a398 2
/*             Pointer to the URL, which must    */
/*             not be in a flex block.           */
d401 1
a401 1
_kernel_oserror * history_record_local(browser_data * b, char * url)
d404 4
d410 1
a410 1
    if (tl & (1u<<16)) Printf("history_record_local: Called with %p\n", (void *) b);
d413 1
a413 5
  if (!url) url = browser_current_url(b);

  /* If we're in the history, truncate it to avoid circular references. */
  /* Don't bother freeing memory here, it'll be set to the required     */
  /* amount next time an addition is made anyway.                       */
d415 1
a415 5
  if (b->hpos)
  {
    b->hnum = b->hpos;
    b->hpos = 0;
  }
d417 4
a420 1
  /* Otherwise, provided we've a URL, proceed. */
d422 1
a422 1
  else if (url && *url)
d424 3
a426 3
    int    bytes, count, needed, len;
    char * p;
    char * last = NULL;
d428 1
a428 8
    bytes = 0;

    p     = b->histdata;
    count = b->hnum;

    /* Point to the last entry */

    while (count--)
d430 1
a430 1
      /* Get past the URL */
d432 1
a432 1
      len = strlen(p) + 1;
d434 1
a434 3
      last   = p;
      bytes += len;
      p     += len;
d437 4
a440 2
    /* If the given URL matches the last one on the history list, */
    /* there's nothing to add.                                    */
d442 2
d445 1
a445 1
      if (tl & (1u<<16)) Printf("history_record_local: Exitting with no action\n");
d448 3
a450 1
    if (last && !strcmp(last, url)) return NULL;
d452 5
a456 1
    /* Needed = space required to store URL plus terminator. */
d458 2
a459 1
    needed = strlen(url) + 1;
d461 3
a463 1
    /* Allocate the memory and store the URL */
d465 1
a465 1
    e = memory_set_chunk_size(b, NULL, CK_HIST, bytes + needed);
d467 1
a467 1
    if (e)
d469 2
d472 1
a472 1
        if (tl & (1u<<16)) Printf("history_record_local: Exitting (error from memory_set_chunk_size)\n", (void *) b);
d475 1
a475 1
      return e;
d478 8
a485 3
    strcpy(b->histdata + bytes, url);
    toolbars_hide_internal(b->histdata + bytes);
    b->hnum ++;
d487 1
a487 1
    bytes += strlen(b->histdata +  bytes) + 1;
d489 10
a498 1
    while(b->hnum > choices.v_hist_size)
d500 3
a502 2
      /* If the history is oversized, remove old entries. */
      /* 'count' = length of the bottom (oldest) entry.   */
d504 1
a504 1
      count  = strlen(b->histdata) + 1;
d506 1
a506 4
      /* Copy the newer entries down over the old and  */
      /* decrement the entries counter. Again, no need */
      /* to free memory as the next history addition   */
      /* will allocate the required amount anyway.     */
d508 3
a510 1
      memmove(b->histdata, b->histdata + count, bytes - count);
d512 10
a521 3
      b->hnum--;
    }
  }
d524 5
a528 1
    if (tl & (1u<<16)) Printf("history_record_local: Successful\n", (void *) b);
d531 8
d543 1
a543 1
/* history_pull_local_last()                     */
d545 10
a554 2
/* Copies the last visited URL, according to the */
/* local history, to the given buffer.           */
d557 1
a557 4
/*             relevant to the history;          */
/*                                               */
/*             Pointer to the buffer (not in a   */
/*             flex block!);                     */
d559 2
a560 1
/*             Size of the buffer.               */
d562 5
a566 1
/* Assumes:    That neither pointer is NULL.     */
d569 1
a569 1
void history_pull_local_last(browser_data * b, char * last, int size)
d571 7
a577 2
  char * p;
  int    count;
d579 10
a588 5
// This function doesn't work yet... =8*O
#ifdef TRACE
  Printf("** history_pull_local_last: Not run\n");
#endif
return;
d590 1
a590 1
  count = b->hnum;
d592 1
a592 1
  if (count <= 0)
d594 13
a606 2
    *last = 0;
    return;
d609 2
a610 1
  /* Get a pointer to the URL */
d612 1
a612 2
  p = b->histdata;
  while(--count > 0) p += strlen(p) + 1;
d614 1
a614 2
  strncpy(last, p, size - 1);
  last[size - 1] = 0;
d616 1
a616 1
  return;
d620 1
a620 1
/* history_add_title()                           */
d622 2
a623 7
/* Adds a title for the given URL in the global  */
/* history. The title must NOT be stored in a    */
/* flex block as this routine may allocate flex  */
/* store which could shift the block with the    */
/* title in, invalidating the pointer to it.     */
/* However, this occurs after the URL is dealt   */
/* with, so the URL can be in a flex block.      */
d625 47
a671 3
/* If the URL already has a title string, the    */
/* existing title is kept. If the URL can't be   */
/* found, the function will fail silently.       */
d673 7
a679 3
/* This may make the history exceed its maximum  */
/* size. The history will not be truncated to    */
/* within that value until a new URL is added.   */
d681 3
a683 2
/* Parameters: Pointer to the title string which */
/*             is not in a flex block;           */
d685 3
a687 2
/*             Pointer to the URL with which it  */
/*             is to be associated.              */
d689 4
a692 2
/* Assumes:    That the title and URL pointers   */
/*             are not NULL.                     */
d695 1
a695 1
_kernel_oserror * history_add_title(char * title, char * url)
a696 2
  int offset, entrysize, pretitle, needed;

d698 1
a698 2
    if (tl & (1u<<16)) Printf("history_add_title: Called with title '%s'\n"
                              "                             and URL '%s'\n",title,url);
d701 1
a701 3
  /* Exit with an error if the history is empty */

  if (!global_history)
d703 2
a704 1
    erb.errnum = Utils_Error_Custom_Message;
d706 1
a706 4
    StrNCpy0(erb.errmess,
             lookup_token("EmptyHistE:The history list is empty.",
                          0,
                          0));
d709 1
a709 1
      if (tl & (1u<<16)) Printf("history_add_title: Exitting with error (history is empty)\n");
d712 18
a729 2
    return &erb;
  }
d731 1
a731 1
  /* Exit if the URL isn't there. */
d733 1
a733 1
  offset = history_visited(url, 0);
a734 2
  if (offset < 0)
  {
d736 1
a736 1
      if (tl & (1u<<16)) Printf("history_add_title: Exitting (couldn't find URL)\n");
d739 3
a741 2
    return NULL;
  }
d743 3
a745 1
  /* Otherwise, is there already a title string? */
d747 1
a747 3
  offset    += sizeof(int);                                                /* Get past timestamp   */
  entrysize  = strlen((char *) global_history + offset) + 1 + sizeof(int);
  offset    += strlen((char *) global_history + offset) + 1;               /* Get past URL         */
d749 1
a749 1
  /* Exit if there was already a title present */
a750 2
  if (strlen((char *) global_history + offset))
  {
d752 1
a752 1
      if (tl & (1u<<16)) Printf("history_add_title: Exitting (URL already had a title)\n");
d755 1
a755 1
    return NULL;
d758 6
a763 3
  /* Otherwise, extend the flex block. For 'needed', we already have */
  /* the terminator of the (currently null) title string in the      */
  /* history, so don't need to add one to the string length here.    */
d765 3
a767 3
  pretitle   = (int) WordAlign(entrysize + 1); /* Word aligned size of the history entry including null title string */
  entrysize += strlen(title) + 1;
  entrysize  = (int) WordAlign(entrysize); /* Word aligned size of the history entry including new title string */
d769 1
a769 1
  needed = entrysize - pretitle;
d771 1
a771 3
  if (!flex_midextend(&global_history, offset, needed))
  {
    erb.errnum = Utils_Error_Custom_Normal;
d773 3
a775 4
    StrNCpy0(erb.errmess,
             lookup_token("NoMemGHi:There is not enough free memory to add the page to the global history.",
                          0,
                          0));
d777 1
a777 3
    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_add_title: Exitting with error\n", url);
    #endif
d779 3
a781 2
    return &erb;
  }
d783 1
a783 4
  #ifdef TRACE
    flexcount += needed;
    if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
  #endif
d785 5
a789 1
  /* Copy in the URL */
d791 2
a792 1
  strcpy((char *) global_history + offset, title);
d794 2
a795 1
  /* If required, save the history */
d797 3
a799 1
  if (choices.save_history == Choices_SaveHistory_Always) return history_save(lookup_choice("HistoryPath:Browse:User.History",0,0));
d801 1
a801 1
  /* Success. */
d804 1
a804 1
    if (tl & (1u<<16)) Printf("history_add_title: Successful\n");
d807 1
a807 1
  return NULL;
d811 1
a811 1
/* history_fetch_forwards()                      */
d813 7
a819 3
/* When called, will fetch the next page in the  */
/* history list (assuming we've moved into it    */
/* with history_fetch_backwards()).              */
d822 6
a827 1
/*             relevant to the history;          */
d829 4
a832 4
/*             1 to open the URL in a new window */
/*             or 0 to open it in the window to  */
/*             which the browser_data struct is  */
/*             relevant.                         */
d835 1
a835 1
_kernel_oserror * history_fetch_forwards(browser_data * b, int new_view)
d837 1
a837 2
  /* Can only go forward if we're somewhere within */
  /* the local history list...                     */
d840 1
a840 1
    if (tl & (1u<<16)) Printf("history_fetch_forwards: Called with %p\n", (void *) b);
d843 3
a845 1
  if (b->hpos > 0 && b->hpos < b->hnum)
d847 5
a851 2
    int    count;
    char * p;
d854 1
a854 1
      if (tl & (1u<<16)) Printf("history_fetch_forwards: Proceeding\n");
d856 1
d858 3
a860 1
    /* Set 'count' to the next entry in the list */
d862 1
a862 1
    count = ++b->hpos;
d864 4
a867 2
    /* Only set up this window to look as though it's gone forwards */
    /* if the URL isn't to be opened in a new window.               */
d869 160
a1028 1
    if (!new_view)
d1030 5
a1034 6
      /* If the position now lies outside of the history, */
      /* we've gone forward past its end; set hpos to 0   */
      /* to show that we're not in the history and remove */
      /* the last item, as that's what will be fetched    */
      /* now and 'back' shouldn't then go back to it      */
      /* again.                                           */
d1036 1
a1036 1
      if (b->hpos >= b->hnum)
d1038 5
a1042 2
        b->hpos = 0;
        if (b->hnum > 0) b->hnum--;
d1044 14
d1060 6
a1065 1
    /* Get a pointer to the URL */
d1067 3
a1069 2
    p = b->histdata;
    while (--count) p += strlen(p) + 1;
d1071 2
a1072 1
    /* Get the URL in either the same window or a new window. */
d1074 109
a1182 1
    if (!new_view)
d1184 6
d1191 1
a1191 1
        if (tl & (1u<<16)) Printf("history_fetch_forwards: Exitting through fetchpage_new\n");
d1194 8
a1201 1
      /* Fetch the URL, flagging not to record this URL in the history */
a1202 4
      return (fetchpage_new(b, p, 0, 1));
    }
    else
    {
d1204 1
a1204 1
        if (tl & (1u<<16)) Printf("history_fetch_forwards: Exitting through windows_create_browser\n");
d1207 1
a1207 1
      return windows_create_browser(p, NULL, NULL, NULL, 0);
d1209 2
d1212 6
d1220 1
a1220 1
    if (tl & (1u<<16)) Printf("history_fetch_forwards: Exitting with no action\n");
d1223 98
a1320 1
  return NULL;
d1327 1
a1327 1
/* the history list.                             */
d1330 1
a1330 1
/*             relevant to the history;          */
d1340 3
d1344 1
a1344 1
    if (tl & (1u<<16)) Printf("history_fetch_backwards: Called with %p\n", (void *) b);
d1347 2
a1349 1
  /* (hpos > 1) or we're not in the history at all (hpos = 0).   */
d1351 3
a1353 1
  if ((b->hpos > 1 || b->hpos == 0) && b->hnum)
a1354 3
    int    count;
    char * p;

d1356 1
a1356 1
      if (tl & (1u<<16)) Printf("history_fetch_backwards: Proceeding\n");
d1359 2
a1360 3
    /* Need to be careful manipulating the history, as if the */
    /* URL is to be opened in a new view then the position of */
    /* this window in its history is unchanged.               */
d1362 5
a1366 3
    if (b->hpos == 0)
    {
      _kernel_oserror * e = NULL;
d1368 1
a1368 1
      /* If not already in the history list... */
d1370 1
a1370 4
      if (!new_view)
      {
        /* Ensure the current URL is put at the top of the history, */
        /* unless it is a temporary file.                           */
d1372 1
a1372 3
        if (b->displayed != Display_Scrap_File)
        {
          e = history_record_local(b, NULL);
d1374 1
a1374 5
          if (e)
          {
            #ifdef TRACE
              if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting with error\n");
            #endif
d1376 1
a1376 4
            return e;
          }
        }
      }
d1378 1
a1378 1
      /* Step backwards. */
d1380 5
a1384 2
      count = b->hnum - 1;
      if (count < 1) count = 1;
d1386 1
a1386 2
      if (!new_view) b->hpos = count;
    }
d1388 7
a1394 1
    /* If already in the history list, just step back again. */
d1396 3
a1398 3
    else
    {
      count = b->hpos - 1;
d1400 14
a1413 2
      if (!new_view) b->hpos--;
    }
d1415 4
a1418 1
    /* Get a pointer to the URL */
d1420 3
a1422 2
    p = b->histdata;
    while(--count > 0) p += strlen(p) + 1;
d1424 1
a1424 1
    /* Get the URL in either the same window or a new window. */
d1426 1
a1426 5
    if (!new_view)
    {
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting through fetchpage_new\n");
      #endif
d1428 1
a1428 1
      /* Fetch the URL, flagging not to record this URL in the history */
d1430 5
a1434 7
      return (fetchpage_new(b, p, 0, 1));
    }
    else
    {
      #ifdef TRACE
        if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting through windows_create_browser\n");
      #endif
d1436 1
a1436 2
      return windows_create_browser(p, NULL, NULL, NULL, 0);
    }
d1440 1
a1440 1
    if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting with no action\n");
d1443 32
a1474 1
  return NULL;
d1566 27
d1622 1
a1624 1
  int               size, i, offset, width, awidth, tempwidth, len, entry;
d1626 11
a1636 2
  char            * title;
  int               tlen;
d1642 1
a1642 3
  /* If there are no history items, flag an error. */

  if (b && !b->hnum) global = 1;
d1644 1
a1644 15
  if (global && !global_history)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("EmptyHistE:The history list is empty.",
                          0,
                          0));

    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_build_menu: Exitting (history is empty)\n");
    #endif

    return &erb;
  }
a1650 1
  offset = 0;
a1664 1

d1667 16
a1682 1
    menu_entries = b->hnum;
d1684 7
a1690 1
    for (i = 0; i < menu_entries; i++)
d1692 27
a1718 3
      len   = strlen(b->histdata + offset) + 1;
      entry = history_visited(b->histdata + offset, 0);
      title = history_title(b->histdata + offset);
d1723 2
a1724 2
          Printf("Local  - URL  : '%s'\n",   b->histdata + offset);
          Printf("Local  - Title: '%s'\n\n", title);
d1728 2
a1729 2
      /* If the URL isn't in the history or it has no title, */
      /* or if the global choices dictate it, use the URL.   */
d1731 6
a1736 4
      if (entry < 0 || !title || show_urls)
      {
        size += len + sizeof(wimp_menuitem);
        if ((len - 1) > width) width = len - 1;
d1738 1
a1738 1
        /* Find the width of the entry in OS units. */
d1740 1
a1740 7
        RetError(utils_text_width(b->histdata + offset, &tempwidth, width));
      }
      else
      {
        tlen = strlen(title);
        size += tlen + 1 + sizeof(wimp_menuitem);
        if (tlen > width) width = tlen;
d1742 1
a1742 2
        RetError(utils_text_width(title, &tempwidth, width));
      }
d1744 1
a1744 1
      /* If the string is wider than previously recorded, store the new width */
d1746 1
a1746 1
      if (tempwidth > awidth) awidth = tempwidth;
d1748 2
a1749 1
      /* Move past the current URL in the local history */
d1751 1
a1751 1
      offset += len;
d1756 12
a1767 4
    int hsize = flex_size(&global_history) - 1;

    /* The code is analogous to the local history stuff */
    /* above, so see that for comments.                 */
d1771 1
a1771 1
    while (offset < hsize)
d1773 19
a1791 2
      menu_entries ++;
      offset  += sizeof(int); /* Skip timestamp */
d1793 2
a1794 2
      len  = strlen((char *) global_history + offset)       + 1;
      tlen = strlen((char *) global_history + offset + len) + 1;
d1799 2
a1800 2
          Printf("Global - URL  : '%s'\n",   (char *) global_history + offset);
          Printf("Global - Title: '%s'\n\n", (char *) global_history + offset + len);
d1804 24
a1827 1
      if (tlen < 2 || show_urls)
d1829 3
a1831 2
        size += len + sizeof(wimp_menuitem);
        if ((len - 1) > width) width = len - 1;
d1833 6
a1838 6
        RetError(utils_text_width((char *) global_history + offset, &tempwidth, width));
      }
      else
      {
        size += tlen + sizeof(wimp_menuitem);
        if ((tlen - 1) > width) width = tlen - 1;
d1840 1
a1840 1
        RetError(utils_text_width((char *) global_history + offset + len, &tempwidth, width));
d1843 1
a1843 5
      if (tempwidth > awidth) awidth = tempwidth;

      offset += len + tlen;
      offset = (int) WordAlign(offset);
    }
d1853 2
a1854 2
      if (view_history_menu) Printf("history_build_menu: Freeing existing store\n");
      else                   Printf("history_build_menu: There is no existing store\n");
d1858 2
a1859 1
  if (view_history_menu) free(view_history_menu);
d1865 2
a1866 21
  view_history_menu = malloc(size);

  if (!view_history_menu)
  {
    erb.errnum = Utils_Error_Custom_Normal;

    StrNCpy0(erb.errmess,
             lookup_token("NoMemLHi:There is not enough free memory to open the history menu.",
                          0,
                          0));

    #ifdef TRACE
      if (tl & (1u<<16)) Printf("history_build_menu: Exitting (couldn't claim %d bytes for menu)\n", size);
    #endif

    return &erb;
  }

  /* Ensure the contents are zeroed. */

  memset(view_history_menu, 0, size);
d1871 1
a1871 1
  mhp = (wimp_menuhdr  *) view_history_menu;
a1891 7
  offset   = 0;

  /* Right, now point 'mip' to the last item - we'll fill */
  /* the entries in backwards, so that the newest item    */
  /* appears first in the menu.                           */

  mip += (menu_entries - 1);
d1905 6
d1913 6
a1918 3
      len   = strlen(b->histdata + offset) + 1;
      entry = history_visited(b->histdata + offset, 0);
      title = history_title(b->histdata + offset);
d1923 2
a1924 2
          Printf("Local  - URL  : '%s'\n",   b->histdata + offset);
          Printf("Local  - Title: '%s'\n\n", title);
d1930 1
a1930 1
      offset += sizeof(int);
d1932 4
a1935 3
      entry = -1;
      len   = strlen((char *) global_history + offset) + 1;
      title = (char *) global_history + offset + len;
d1940 2
a1941 2
          Printf("Global - URL  : '%s'\n",   (char *) global_history + offset);
          Printf("Global - Title: '%s'\n\n", title);
d1946 21
a1966 3
    /* We're going to fill in the entries backwards, so that */
    /* the newest items appear first. Hence when i is zero,  */
    /* we want to set the 'last item' bit.                   */
a1967 1
    mip->flags     = (i == 0 ? wimp_MLAST : 0);
d1978 3
a1980 12
    /* If the URL isn't in the global history, or it doesn't */
    /* have a title string associated with it, or if the     */
    /* global choices dicate it, use the URL in the menu.    */

    if (
         show_urls ||
         !title    ||
         (
           title &&
           strlen(title) < 1
         )
       )
d1982 1
a1982 1
      int item_len;
d1984 2
a1985 1
      /* Copy the history item into the data area */
d1987 1
a1987 2
      if (b && !global) strcpy(menudata, b->histdata + offset);
      else              strcpy(menudata, (char *) global_history + offset);
a2008 15

      /* If we've gone over the width limit on this entry,  */
      /* show the right hand portion of the item with '...' */
      /* before it.                                         */

      item_len = strlen(menudata);

      if (item_len + 4 > Limits_HistoryMenuItemSize) /* '+3' to account for the '...' we'll put in front plus terminator */
      {
        strncpy(menudata + 3, menudata + item_len - (Limits_HistoryMenuItemSize - 4), Limits_HistoryMenuItemSize - 4);
        strncpy(menudata, "...", 3);
        menudata[Limits_HistoryMenuItemSize - 1] = '\0';
      }

      menudata += strlen(menudata) + 1;
d2012 1
a2012 4
      int item_len;

      /* Copy the title string in and advance the data pointer; */
      /* but don't exceed the width limit on the entry.         */
d2015 1
d2017 2
a2018 1
      item_len = strlen(menudata);
d2020 3
a2022 6
      if (item_len + 4 > Limits_HistoryMenuItemSize) /* '+3' to account for the '...' we'll put in front plus terminator */
      {
        strncpy(menudata + 3, menudata + item_len - (Limits_HistoryMenuItemSize - 4), Limits_HistoryMenuItemSize - 4);
        strncpy(menudata, "...", 3);
        menudata[Limits_HistoryMenuItemSize - 1] = '\0';
      }
d2024 5
a2028 1
      menudata += strlen(menudata) + 1;
d2031 2
d2035 1
a2035 9
    offset += len;

    if (global)
    {
      offset += strlen(title) + 1;
      offset = (int) WordAlign(offset);
    }

    mip --;
d2039 1
a2039 1
    if (menudata > ((char *) view_history_menu) + size)
d2042 1
a2042 1
      sprintf(erb.errmess,"Fatal error inside history_build_menu: Overran menu buffer! Allocated %d bytes, then used %d.",size,(int) menudata - (int) view_history_menu);
d2058 46
a2103 1
  return wimp_create_menu(view_history_menu, x - (subtract ? (mhp->width + 64) : 0), y);
d2132 3
a2134 3
  int item, adj;
  int global;
  int offset;
d2141 5
d2153 13
a2165 1
  if (item < 0 || item >= menu_entries)
a2173 4
  /* History menu items are filled in backwards */

  item = menu_entries - item - 1;

d2183 1
a2183 1
  if (!adj && b)
d2185 1
a2185 24
    /* If jumping from the top of the history, ensure that the */
    /* page we're currently on is added to it first.           */

    if (!b->hpos)
    {
      _kernel_oserror * e;

      /* Ensure the current URL is put at the top of the history */

      e = history_record_local(b, NULL);

      if (e)
      {
        #ifdef TRACE
          if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting with error\n", (void *) b);
        #endif

        return e;
      }
    }

    /* Set the position in the history */

    b->hpos = item + 1;
d2187 1
a2187 3
    /* Is this the end of the history? */

    if (b->hpos == b->hnum) b->hpos = 0;
d2190 1
a2190 1
  /* Point to the required entry in the history. */
d2194 1
a2194 5
    offset = 0;

    while (item--)
    {
      /* Get past each URL... */
d2196 1
a2196 2
      offset += strlen(b->histdata + offset) + 1;
    }
d2200 1
a2200 1
    offset = sizeof(int);
d2202 1
a2202 10
    while (item--)
    {
      /* Get past each URL, title, and datestamp for next entry */

      offset += strlen((char *) global_history + offset) + 1;
      offset += strlen((char *) global_history + offset) + 1;
      offset += sizeof(int);

      offset = (int) WordAlign(offset);
    }
a2204 5
  /* Flag that there is no known menu source anymore */
  /* and fetch the new URL.                          */

  menusrc = Menu_None;

d2214 1
a2214 1
                                   (global ? (char *) global_history : b->histdata) + offset,
d2218 1
a2218 1
    else return windows_create_browser((global ? (char *) global_history : b->histdata) + offset,
d2222 1
a2222 1
                                       0);
d2229 1
a2229 1
    return openurl_fill_in_url((char *) global_history + offset);
d2239 6
d2253 21
a2273 1
  int               type, length;
d2275 1
a2275 1
  /* Find out the file length */
d2277 5
a2281 2
  e = _swix(OS_File,
            _INR(0,1) | _OUT(0) | _OUT(4),
d2283 2
a2284 2
            17, /* Read catalogue info */
            pathname,
d2286 3
a2288 2
            &type,
            &length);
d2290 1
a2290 1
  if (e) return e;
d2292 4
a2295 1
  if (!type) return NULL; /* Not found - fail quietly, not finding it is fine */
d2297 2
a2298 1
  /* Free any existing store and allocate space for the file */
d2300 7
a2306 1
  if (global_history) flex_free((flex_ptr) &global_history);
d2308 1
a2308 1
  if (length)
d2310 44
a2353 1
    if (!flex_alloc((flex_ptr) &global_history, length))
d2355 7
a2361 1
      /* Complain if the allocation fails */
d2363 3
a2365 1
      erb.errnum = Utils_Error_Custom_Normal;
d2367 1
a2367 4
      StrNCpy0(erb.errmess,
               lookup_token("NoMemHiF:There is not enough free memory to load the global history.",
               0,
               0));
d2369 1
a2369 1
      return &erb;
d2372 55
a2426 1
    /* Load the file */
d2428 1
a2428 2
    return _swix(OS_File,
                 _INR(0,3),
d2430 26
a2455 4
                 16, /* Load named file */
                 pathname,
                 global_history,
                 0);
d2458 14
a2471 1
  return NULL;
d2475 1
a2475 1
/* history_load()                                */
a2478 3
/* If there is no global history allocated or it */
/* is empty, a zero byte length file is written. */
/*                                               */
d2485 7
a2491 2
  int    length;
  FILE * file;
d2493 2
a2494 1
  /* Determine the file length */
d2496 11
a2506 2
  if (!global_history) length = 0;
  else                 length = flex_size((flex_ptr) &global_history);
d2510 43
a2552 2
  file = fopen(pathname, "wb");
  if (!file) RetLastE;
d2554 3
a2556 1
  /* Write the data */
d2558 2
a2559 1
  if (fwrite(global_history, 1, length, file) < length) RetLastE;
d2564 1
d2567 130
@


1.12
log
@!Run[D] files updated for new fetchers and GopherFetcher; protocols list
in Controls updated for Gopher. Debug builds now require 2760K rather than
2560K. Font$... variables set if not already, in anticipation of font
Choices work.

Additional bits in Choices section of Res file tidied and some name
changes (e.g. Netscape -> Navigator(TM)). Frames support option added
to Choices.

Grouped 'support_frames' under the Fetch Controls section and added
support_object in Global.h; appropriate entries placed in the Choices
files, and are read at startup. At present, though, only the frames
support flag is implemented.

For some reason, Menu was the button to use on history popups if you
wanted to show URLs instead of descriptions (or vice versa, depending
on Choices settings). Now, Select and Menu will show the Choices
defined setting, and Adjust will show the opposite.

History menus are built backwards, so local histories have the most
recently visited pages at the top. Global history has still no real
order to it, but this may be arranged later.

Customer name changed to Customer by request.

Customer browser now gets its own resources (SYSTEM=Customer), but
otherwise is unchanged, with the Ursula build now giving the
'spinning acorn' with a Bookworm-style toolbar. This is used for the
Desktop !Browse build.

!Sprites[22] files updated to include GIF, JPEG and PNG sprites;
!Run[D] files and !Boot files set appropriate File$Type_xxx variables.
Sprites in all sprites files have been checked for unnecessary palettes,
which have been removed where present.
@
text
@d1447 4
a1450 1
      /* Copy the title string in and advance the data pointer */
d1453 11
a1463 1
      menudata += strlen(title) + 1;
@


1.11
log
@Tidied up Hotlist source a bit more, mostly so PSI can use the automatic
StrongHelp generator on it. Revealed a spurious toolbox_hide_object call
that would always fault and never do anything, and a few heinous uses
of show_error which have all been removed.

When dragging hotlist items, directories will now be highlighted whenever
the item would be added to them, rather than just over the sprite. In
practice this only changes if the item is open and has contents...

Drag box selections had broken in the hotlist; fixed (uninitialised
variable in hotlist_select_box). Adjust-drags now close the window on
completion. Minor problem with Shift+Drag (copy) reversing order of items
sorted out. Added hotlist_add_html_file and implemented loading of HTML.
DO NOT add broken HTML files, this has not been coded for and URLs of the
form http:///this/that (no host name) will hang the machine (bug in the
cookie code of the HTTP module up to at least version 0.39).

Made SELECT list items only as wide as the widest entry actually appears
(using fm_get_string_width), rather than as wide as the widest character
BBox in the font multiplied by the string length of the longest entry.

Updated !Run[D] files to require HTTP 0.39, FTP 0.12 and File 0.23.
@
text
@d64 1
a1117 1
  int               entries;
d1166 1
a1166 1
    entries = b->hnum;
d1168 1
a1168 1
    for (i = 0; i < entries; i++)
d1219 1
a1219 1
    entries = 0;
d1223 1
a1223 1
      entries ++;
d1317 4
a1320 4
  /* Pointer arithmetic - mip + entries adds entries lots */
  /* of sizeof(mip) to menudata, since the cast to char * */
  /* is the last thing that happens. So menudata points   */
  /* past all the menu structure stuff to the data area.  */
d1322 1
a1322 1
  menudata = (char *) (mip + entries);
d1325 6
d1341 1
a1341 1
  for (i = 0; i < entries; i++)
d1374 5
a1378 1
    mip->flags     = (i == entries - 1 ? wimp_MLAST : 0);
d1402 2
a1415 1
        menudata += strlen(menudata) + 1;
d1428 7
a1434 1
        menudata += strlen(menudata) + 1;
d1436 8
a1443 1
      #endif
d1463 1
a1463 1
    mip ++;
d1531 1
a1531 1
  if (!global && (item < 0 || (item + 1) > b->hnum))
d1539 4
@


1.10
log
@Now working on source merged with Kevin Bracey's internationalisation
support. UNIFONT is undefined in the Make File for now. All Res and
Choices files updated appropriately.

Having sorted out the old Choices and Messages to form Choices, Controls
and Messages, this build has had the same cleaning up done internally.
This includes greater consistency in naming schemes and the removal of
the inconsitent choices items - e.g. Choices file entries saying 'delay
images' and 'plain backgrounds' where internally all the flags say 'show
images' and 'show backgrounds'. ChoiceDefs.h and CtrlDefs.h added to
clarify the meaning of some fields, though usage of these is not 100%
in the source (there are cases where parameters are passed through to
functions as ints, and those functions still check these against hard
coded values rather than the #define stuff).

Fetcher status return bits (connected, sent request, etc.) now reflected
in status bar. Progress during fetchs to files are reported by %, where
the size of the object is known. Exceeding 100% drops back to a byte
counter, in case the estimated size was wrong. The progress counter
may be updated after specific delays, rather than 'as often as possible',
to reduce flicker (as requested by D.Brown some time ago).

I've done a small rewrite of the fetch prioritisation scheme in FetchPage.c;
how well this performs in general use across different processor speeds
remains to be tested, but certainly it has some advantages. For each small
fetch window before the rewrite, a 4cs tight loop was entered - this gave a
noticable and substantial drain to the Desktop performance if more than one
was opened. Now, several can be up at once with little hit. The actual file
fetch is on half the priority it was before, with all others taken back
just a bit - e.g. from 20cs per poll to 15cs per poll for flat out
reformatting. You don't seem to lose much time on the format in practice,
and the Desktop feels quite a bit lighter at the same time. There's the
potential for smoother frameset loading in this scheme, too.

When Shift+Clicking on a link meant you still fetched inside the main
browser window, several fetches could occur in a frameset - one per frame.
However, now that you can only do this by clicking on a link that leads to
non-displayable data - or by turning off the small fetch windows by
setting UseSmall to 'no' in Choices - a bug where fetchpage_preprocessed
would stop such fetches as new ones were started was revealed.
The API to frames_abort_fetching has now been extended to include a
'stop file spooling too' flag, allowing a fix to be made by having
fetchpage_preprocess's calls not set this (and it doesn't check the
savelink flag is unset before proceeding, since frames_abort_fetching
does that implicitly now).

Had left the RAM transfer buffer at 16 bytes (from testing) accidentally...
Oops. Upped it to 4K. In addition, when loading data by RAM transfer,
the browser didn't notice if a RAMFetch bounced during the transfer. It
would be treated as a 'first' RAMFetch bounce, basically, and try to go to
file transfer - oops. Fixed.
@
text
@d112 1
d115 2
a116 1
//       show_error_ret(_kernel_last_oserror());
@


1.9
log
@As warned in the last log, pretty much all event codes and component IDs
have now changed along with many of the names, to provide a consistent
name and numberspace for events and components. This also minimises
number clashes (e.g. as was, the Save File origin when opened from a
Hotlist menu with an already-used component ID). To get full details on
this, please carefully read through TBEvents.h.

Res files, Sprites files and Messages files have been updated again both
due to the above, and routine additions (e.g. message support for a few
Hotlist bits and pieces). !Run[D] files updated for FTP 0.11 and
HTTP 0.36.

In the Makefile, the Customer objects list was missing Save - must have
moved something when I should've copied it, when adding in SaveFile or
SaveObject in all probability. Now fixed. Couple of other bits and bobs
fixed in the build environment (e.g. stuff saying !Argo instead of
!Customer). Oh, and I've altered the MakeFile copy options again to the
best compromise I can come up with. Newer is turned on for everything
except !Run[D] and !RunImage, since both of those change between debug
builds - otherwise if you'd built debug and non-debug versions, it was
not possible to switch between them - one version would have the newer
timestamp and thus never get overwritten.

The default hotlist has had a few items added - that'll be about the end
of it, I think; there's more than enough stuff in there now.

Saving of the hotlist from the document menu and of URI files,
directories and selections from the hotlist menu tree is now implemented
- this new save system rocks... Oh, and you can save all images and
backgrounds as sprites.

Saving of items with Shift+Click to other applications directly now
works, and is robust. Unique Scrap filenames are used, with data load
bounces (e.g. if some pra - er, person quits the app they're sending
to) working correctly - that is, give an error, keep the file, rename
it to something safe, and open the directory it lies in. As opposed
to normal app-to-app bounces, where the scrap file is deleted (see
PRM 3-254). This means you can now look at README files in FTP
sites, say, without using a disc intermediate. Or you can send pictures
straight to ChangeFSI, fetch HTML links into editors, and so-on, and
so-on - it's all very funky. Known problems include the ambiguous
'invalid component ID' instead of 'file open' for *normal* (straight to
disc) shift+click saves, and I think I'll introduce a unique name
guarantee of some sort to stop 'file open' in the first place. Odd
that the really tricky part (app-to-app) should be least likely to
suffer from this!
@
text
@d49 1
d352 1
a352 1
              (flex_size(&global_history) + len) > choices.maxghistory * 1024
d472 1
a472 1
    if (choices.save_history == 2) return history_save(lookup_choice("HistoryPath:Browse:User.History",0,0));
d580 1
a580 1
    while(b->hnum > choices.maxvhistory)
d687 1
a687 1
                           "                             and URL '%s'\n",title,url);
d775 1
a775 1
  if (choices.save_history == 2) return history_save(lookup_choice("HistoryPath:Browse:User.History",0,0));
d1516 1
a1516 1
  adj = fixed.ignoreadjust ? 0 : adjust();
@


1.8
log
@First a minor warning - the various Res files are out of sync in this build.
Only the Browse resources are currently valid.

Added Utils.Icons - has a few archives inside containing the resources
(well, some of them) used to build various UI sprites for various builds.
Archived because these are unlikely to change much, and putting them on
CVS was a move to, well, archive the stuff...

SaveDBox objects vanquished and requirements in !Run[D] files removed. The
data save code fits much more neatly in amongst the data load protocol
stuff now (with the slight exception of having to split the SaveObject
source into SaveObject and SaveFile - the former handles multiple persistent
dialogues for Shift+Click on links and the like, the latter handles 'one at
a time' transient dialogues for save source and similar). Export Link is now
supported, too, and writes a 'proper' version URI file. You'll find that
double-clicking on old URI files will work as the URI handler picks them up,
whilst new version ones don't; however, dragging onto the browser will only
work with new version files. Note that support for saving and loading URL
files (ANT suite stuff) is present too, so old URI files can be typed as URL
files if you want to keep them working without modification - the URI
handler itself will hopefully support the defined URI file format soon;
double-clicking on old URI files will stop working at that point. Note
there are *lots* of changes in every Res file to support all this. This may
all seem a bit pointless to some, but the changes do in fact make it very
easy to add new save dialogues all over the place. Certainly much easier
than with the previous system, anyway. In fact, post script, image
'save as sprite' took about half an hour, which I hope proves the worth
of the new system.

Merged in newer hotlist code with support for drag cancelling with Escape
(all relevant Res files appropriately updated) and cancelling scrolling
when you've reached the window scroll limit. Had to move some of the
Wimp message handling stuff to the central Protocols source, as clashes
were occuring, and also the hotlist routines were using independent saving
code - a lot of duplicated effort. This was fair enough as at the time the
Hotlist code was written, the Save code couldn't be used in the way it is
now.

New Save Source and Print buttons on the toolbar of some builds.

Phoenix Sprites file made more efficient - the Acorn base section has been
split from the animated upper region. Browse build has a new grey fade
sprite at the back, which is less grainy than the previous one and only
uses 16 colours (with a 16 greyscale palette).

Not really a bug, bug the routine to start an image fetch for INPUT
TYPE=IMAGE forms items only did so if the src field (or equivalent, for
this tag type) was non-NULL. In fact, you should always call image_new_image
and let that handle the rest, otherwise other sections of the code will fail
as they try to obtain an image number for a given HStream and get -1 back.
This problem only generally manifested itself when loading an HTML file to
the browser straight from an application, as many src fields become NULL
when the relativisation routines find nothing to relativise to...

Authentication got broken somewhere along the line - this has been fixed
(in HTMLLib and the browser).

Ctrl+Click on a cross referenced image updates *all* copies, not just the
one with the image data attached.

Next big step: Rip up TBEvents.h and rebuild that whole approach somewhat.
To all those working on the code, my apologies but this means all Res files
will receive a very large number of alterations and there will be extensive
code changes too (mostly naming convention stuff), in more or less all
source files. I am endeavouring to ensure that the new numberspace
convention does not clash with the work being done by Kevin on
internationalisation.
@
text
@d113 1
a113 1
//       show_error_ret((_kernel_oserror *) _kernel_last_oserror());
d1050 1
a1050 1
  if (component == DisplayMenu || component == OpenHistory)
d1052 1
a1052 1
    /* Build and show menu to right of menu icon for DisplayMenu object */
d1706 1
a1706 1
  if (!file) return _kernel_last_oserror();
d1710 1
a1710 1
  if (fwrite(global_history, 1, length, file) < length) return _kernel_last_oserror();
@


1.7
log
@File fetches now set DEADDEAD during the fetch, Data if it is aborted, or
an appropriate filetype when finished. If the fetcher routines return a
zero or data filetype, the browser looks at a set of hard coded filename
extensions to try and determine if there's a better filetype to use
(urlutils_filetype_from_url) - since this is a centralised routine it can
use a Mime mapping system (or be removed entirely) as and when one becomes
available.

You can now drag URI / URL files to the Hotlist window to add them to the
list. They are added roughly where dragged to. (NB, note that I renamed
the function to return the window ID - just being picky; it matches other
similar functions now). Oh, and hotlist_add_position actually works now ;-)

The global history will save when titles are added, as well as when a URL
is added. Before, a browser crash could mean a title got dropped out
of the history file even if SaveHistory was set to 'always'.

SaveObject sources have been added but nothing references them or links
them in yet - they're not finished. Mostly checking this one in because
of the hotlist changes.
@
text
@a510 7
  /* If displaying a scrap file, use a more appropriate string */

  if (b->displayed == Display_Scrap_File)
  {
    url = FileMethod ProtocolSeparator Save_ScrapFile; /* (URLutils.h, Save.h) */
  }

@


1.6
log
@This log message covers changes from the version before last up until now
- i.e. it includes the changes that were part of the intermediate check-in
done yesterday (02/09/97).

New function to go from URL to pathname in urlutils, also changed return
values on those functions which alter the given buffer to return nothing,
rather than the buffer address (which wasn't helpful).

Fixed nasty in the Message_DataLoad code (it thought all loads were
app to app - oops; can in fact just check your_ref, which is 0 if this
is a DataOpen or DataLoad direct from the Filer. PRM 3-253).

Implemented Load Images and View Source buttons.

Small fetch window - configurable in Choices (UseSmall) is the use of a
special 'small' window for fetches. Configurable as if you Shift+Select
click it'll open one of these, which some people might hate, so you
can turn the feature off and the fetch will progress in the browser
window you clicked on, as normal. Default is for this to be on, since
it matches the behaviour of other browsers. This means all Res files
have been updated, except for the Customer build, which can't fetch
external objects as it is a full screen variant.

New pointers for the hotlist autoscroll, including full specification
of their active point offsets in Controls. This means all Sprites files
have been updated.

New sprites for HTML and URI files, so all !Sprites and !Sprites22 have
been updated.

(Suggested by KBracey) You can now drag objects to the toolbars of a window
to fetch into the ancestor (useful for framesets).

Function windows_close_browser now returns void; it only returned an int as
it used to be a Toolbox event handler and I obviously forgot to get rid of
this when I turned it into a general purpose function.

!Run/!RunD/etc. files updated yet again, since the browser now supports
different application names. Corrected fault where Browse$CookiePath was
being unset - should've been Browse$CookieFile and Browse$CookieFileFormat.
420K is no longer enough, so they've all been given 512K for the non-debug
versions (OK since malloc will fill up any excess allocation before starting
to extend the slot size itself).

Fixed global history bug - the history would become corrupted whenever
it exceeded the maximum size specified in Choices.

Fetcher now supports HTTP return code 301 (Moved Permanently). Wrapped in
#ifndef STRICT_PARSER.

I've started on some general documentation, aside from the overdetailed
PSI memory information (which needs updating). Once this gets some substance
to it and achieves a recognisable, maintainable structure, it'll get added
to CVS - for now, there's no point (you'd have trouble making sense of the
various unsorted fragments!).

Right. Time to get rid of SaveDBox.
@
text
@d779 4
@


1.5
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d359 1
a359 1
        char * p = (char *) global_history;
d361 10
d402 5
a406 1
        memmove(f, f + size, (e - f) - size);
d672 4
@


1.4
log
@Very long log entry alert - but hey, beats 'Bug fixed' (sorry, Richard) ;-)

Open URL implementation more or less complete, though may undergo UI
revision at a later date to allow named frames to be targetted. Hope to use
the ideas in this code as the foundation for other general dialogues.

In token stream dump for TRACE builds, table head items were not indented
as far as they should have been - this is fixed; and manual toolbar redraw
routines have been removed. They never worked, were commented out, and
would never be used in that form anyway.

DragBox source added, but it isn't at all complete and won't work - this is
an 'in spare time' thing. We need custom drag boxes constrained to windows
for the hotlist, and unconstrained for frame border resizing... Hey ho.

Ancestor window extents match visible areas if there are frames (no more
scrolling framesets...!). Frame resizing works whilst new documents fetch
without pulling the extent down now. However, frame horizontal extents
never shrink until a reload which is nasty, and this is all due for a
rewrite. Frames border redrawing routine moved out of Redraw.c and into
Frames.c. Bug regarding the mouse rectangle and frame border widths
(rectangle was too large, so you could squash the edges) for edge-drag
frame resizes fixed.

Window width change reformat tolerance fixed; you could creep the window
width down or up forever without any reformat, and centred objects would
move but not be redrawn (thereby giving rise to subsequent redraw errors).

Filetype on objects saved through Shift+Click correct. Save Source dialogue
recognises if that source is plain text, rather than assuming HTML. A
browser that fetches a file remembers the old store size it had before the
save, so even though the data is now ditched, it reports the same amount of
data fetched afterwards (looked awful when this could, for example,
suddenly say '0' after a file save). Progress indicator is now fully aware
of one or many file saves inside a frameset and reports the number of
saves, a colon, and the cumulative saved data count, instead of reporting
the sum total of fetched data in all frames, including non-file save stuff
(note that for just 1 save, '1:' is not shown as a special case for the
most common condition). A bug related to this, where you could in fact only
do one fetch per frame*set*, has been corrected (only one fetch allowed per
frame still, this is unlikely to ever change).

Hotlist support added (D.Brown's source), with various bits of integration
and modification still in progress there. Note additions to the Messages
files. On the subject of Messages, the whole mucky business about what
goes in Messages or Choices (and a few bugs where lookup_choice was used
instead of lookup_token or vice versa) has been sorted out. Messages
contains, more or less, just that. Choices contains user configurable
stuff which generally can't mess things up too badly. A new file, Controls,
is a Messages file holding the non-user configurable choices, which can
generally make things go badly wrong if misused. A lot of these are tied
to the Res file. StrongED users can get these to automatically fold out
the various sections (EMail me for details). Sorry, but at the time of
writing, Zap doesn't do folding... =8*P

Two bugs with images. Asking for images to be shown in browser B when
browser A uses the same ones and was loaded first didn't work correctly,
and now does (a bit weird - browser A does the fetch and browser B does the
display...). Second one occurred when the background image was also used on
the page as a foreground image. This has been fixed by flagging background
images in the image_info structure, and checking this before cross
referencing. This bit also allowed the image_restart_fetches API to be
extended, so that just background or foreground images may be fetched if
they weren't already and the user asked the browser to show them. Before,
the whole lot had to be fetched together (so turning on 'display
backgrounds' will now kick off an image fetch if required, you don't
need to reload the page anymore).

Makefile copy options tweaked to be 'newer' (so if you're testing with some
temporary Choices file or something, it won't write over it at the end of
every export), and REMOTE_HOTLIST flag added for Customer builds - means
the Hotlist.c functions aren't needed; the old, hotlist-by-file method is
used. Added support for Customer build (see later), though there were very
few additions needed in practice.

Table printing fixed - in many ways it wasn't broken, it was image printing
causing the oddities ever since the global image pool was introduced (this
is, again, fixed). The 'reformat to fit page' option didn't work as coded
any more; tables store cell addresses in the HStreams, so you can't then do
a background reformat in a different browser. Hence, it now has to reformat
to the page width, print, then put the page back again, all in the actual
displayed browser. This doesn't feel as slow in use as it perhaps should,
considering what is going on... Note that a line of a defined fraction (see
Print.h) of page height will now split over page boundaries, so tall images
or tall tables don't cause problems now (aside from the obvious problem of
having the line split over a page at all!). There was a bug in the routine
to print from a given start point until 'n' pages had been filled, in that
it always filled 'n + 1' - now fixed. Finally, as part of the printing
tweaks, a new dialogue exists - PrintStyle - with a similarly named source
file added to deal with it.

Global history auto save / load done, but only to the Choices file path -
the whole browser is still strictly single user at present, with all the
extra work for a multiuser Customer environment yet to be done. This has
shown up a global history corruption problem which I haven't fixed yet.

Rationalising TBEvents.h - things are migrating out of it, and into more
appropriate sources (e.g. definitions relating to the Open URL dialogue are
going into OpenURL.h, etc.). Event codes were at one stage deliberately
diverged in numberspace from the component IDs of typical gadgets raising
the events, to avoid anyone getting confused and thinking the IDs and event
codes must match. However, this is in fact unlikely and it is much easier
to remember the fewer numbers that result from tying the two together where
possible. This has resulted in changes to event codes raised in the
following objects of all Res files: Authorise, Find, OpenURL, and
PrintStyle.

And finally - !Run[D] files for all variants updated to require the latest
toolbox and fetcher modules. All Res files updated for hotlists etc. and
sprites files updated appropriately. All Messages, Choices and Controls
files brought in sync., and an Customer build has been added (based on the
Desktop build binary with different resources).

That's all for now...
@
text
@d54 1
d497 7
d900 1
a900 1
      _kernel_oserror * e;
d906 2
a907 1
        /* Ensure the current URL is put at the top of the history */
d909 3
a911 1
        e = history_record_local(b, NULL);
d913 5
a917 5
        if (e)
        {
          #ifdef TRACE
            if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting with error\n");
          #endif
d919 2
a920 1
          return e;
a1095 1
  int               cspacing = 0, cwidth = 0;
a1133 18
  if (!nested_wimp)
  {
    /* Find out the spacing (start of one char to start of next) */
    /* and width of the text the Wimp is using, assuming that if */
    /* there is no nested wimp, Wimp_TextOp is unavailable.      */

    int vars[3] = {
                    BBC_GCharSizeX,
                    BBC_GCharSpaceX,
                    -1
                  };

    RetError(bbc_vduvars(vars, vars));

    cwidth   = vars[0];
    cspacing = vars[1];
  }

d1172 1
a1172 6
        /* Find the width of the entry in OS units. If nested_wimp */
        /* is set assume Wimp_TextOp is available, else assume it  */
        /* is not available.                                       */

        if (nested_wimp) _swix(Wimp_TextOp,
                               _INR(0,2) | _OUT(0),
d1174 1
a1174 11
                               1,
                               b->histdata + offset,
                               width,

                               &tempwidth);

        /* Spacing is width of char plus the gap between it and the */
        /* next one. String length is in 'width', so want to do     */
        /* (width - 1) lots of spacing plus the last char's width.  */

        else tempwidth = (width - 1) * cspacing + cwidth;
d1182 1
a1182 12
        /* See above code for comments */

        if (nested_wimp) _swix(Wimp_TextOp,
                               _INR(0,2) | _OUT(0),

                               1,
                               title,
                               width,

                               &tempwidth);

        else tempwidth = (width - 1) * cspacing + cwidth;
d1196 1
a1196 1
    int e = flex_size(&global_history) - 1;
d1203 1
a1203 1
    while (offset < e)
d1224 1
a1224 10
        if (nested_wimp) _swix(Wimp_TextOp,
                               _INR(0, 2) | _OUT(0),

                               1,
                               (char *) global_history + offset,
                               width,

                               &tempwidth);

        else tempwidth = (width - 1) * cspacing + cwidth;
d1231 1
a1231 10
        if (nested_wimp) _swix(Wimp_TextOp,
                               _INR(0, 2) | _OUT(0),

                               1,
                               (char *) global_history + offset + len,
                               width,

                               &tempwidth);

        else tempwidth = (width - 1) * cspacing + width;
@


1.3
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@a45 1
#include "TBEvents.h"
d51 2
d453 4
d964 88
d1058 2
a1059 1
/*             relevant to the menu;             */
d1065 4
d1078 1
a1078 1
_kernel_oserror * history_build_menu(browser_data * b, int x, int y, int show_urls, int subtract)
d1080 9
a1088 6
  wimp_menuhdr  * mhp;
  wimp_menuitem * mip;
  int             size, i, offset, width, awidth, tempwidth, len, entry;
  int             cspacing = 0, cwidth = 0;
  char          * menudata;
  char          * title;
d1096 3
a1098 1
  if (!b->hnum)
d1129 5
a1133 1
    int vars[3] = {BBC_GCharSizeX, BBC_GCharSpaceX, -1};
d1135 1
a1135 1
    _swix(OS_ReadVduVariables, _INR(0, 1), &vars, &vars);
d1144 10
a1153 1
  for (i = 0; i < b->hnum; i++)
d1155 1
a1155 3
    len   = strlen(b->histdata + offset) + 1;
    entry = history_visited(b->histdata + offset, 0);
    title = history_title(b->histdata + offset);
d1157 13
a1169 2
    /* If the URL isn't in the history or it has no title, */
    /* or if the global choices dictate it, use the URL.   */
d1171 41
a1211 4
    if (entry < 0 || !title || show_urls)
    {
      size += len + sizeof(wimp_menuitem);
      if ((len - 1) > width) width  = len - 1;
d1213 1
a1213 3
      /* Find the width of the entry in OS units. If nested_wimp */
      /* is set assume Wimp_TextOp is available, else assume it  */
      /* is not available.                                       */
d1215 2
a1216 2
      if (nested_wimp) _swix(Wimp_TextOp,
                             _INR(0,2) | _OUT(0),
d1218 1
a1218 3
                             1,
                             b->histdata + offset,
                             width,
d1220 1
a1220 1
                             &tempwidth);
d1222 1
a1222 3
      /* Spacing is width of char plus the gap between it and the */
      /* next one. String length is in 'width', so want to do     */
      /* (width - 1) lots of spacing plus the last char's width.  */
d1224 1
a1224 1
      else tempwidth = (width - 1) * cspacing + cwidth;
d1226 11
a1236 1
    else
d1238 2
a1239 1
      int tlen;
d1241 2
a1242 3
      tlen = strlen(title);
      size += tlen + 1 + sizeof(wimp_menuitem);
      if (tlen > width) width = tlen;
d1244 12
a1255 1
      /* See above code for comments */
d1257 2
a1258 2
      if (nested_wimp) _swix(Wimp_TextOp,
                             _INR(0,2) | _OUT(0),
d1260 12
a1271 3
                             1,
                             title,
                             width,
d1273 2
a1274 1
                             &tempwidth);
d1276 3
a1278 2
      else tempwidth = (width - 1) * cspacing + cwidth;
    }
d1280 1
a1280 1
    /* If the string is wider than previously recorded, store the new width */
d1282 2
a1283 1
    if (tempwidth > awidth) awidth = tempwidth;
d1285 1
a1285 1
    /* Move past the current URL in the local history */
d1287 3
a1289 1
    offset += len;
d1311 1
d1340 1
a1340 1
  strncpy(mhp->title, lookup_token("HistMemT:History",0,0), 12);
d1350 1
a1350 1
  /* Pointer arithmetic - mip + b->hnum adds b->hnum lots */
d1355 1
a1355 1
  menudata = (char *) (mip + b->hnum);
d1360 9
a1368 1
  for (i = 0; i < b->hnum; i++)
d1370 5
a1374 3
    len = strlen(b->histdata + offset) + 1;
    entry = history_visited(b->histdata + offset, 0);
    title = history_title(b->histdata + offset);
d1376 26
a1401 1
    mip->flags     = (i == b->hnum - 1 ? wimp_MLAST : 0);
d1416 8
a1423 1
    if (entry < 0 || !title || show_urls)
d1427 2
a1428 1
      strcpy(menudata, b->histdata + offset);
d1446 1
d1465 8
a1472 1
    mip    ++;
d1491 3
a1493 1
  menusrc = Menu_History;
d1510 6
a1515 1
/*             relevant to the history;          */
d1524 10
a1533 2
  int    item, adj;
  char * p;
d1540 1
a1540 1
  if (item < 0 || (item + 1) > b->hnum)
d1558 1
a1558 1
  if (!adj)
d1592 7
a1598 1
  p = b->histdata;
d1600 4
a1603 1
  while (item--)
d1605 9
a1613 1
    /* Get past each URL... */
d1615 2
a1616 1
    p += strlen(p) + 1;
d1624 125
a1748 3
  /* Somewhat non-standard behaviour to have an adjust-click  */
  /* open a new window instead of leaving the menu up, but    */
  /* this is more consistent with the rest of the browser UI. */
d1750 1
a1750 2
  if (!adj) return fetchpage_new(b, p, 0, 1);
  else      return windows_create_browser(p, NULL, NULL, NULL, 0);
@


1.2
log
@Checking in mostly because its Friday... Quite a few little bug fixes
(adding up to a greater whole), which include removal of the dastardly
'invalid image number' errors that trace builds would raise from time to
time. Frame highlights are now better controlled (releaseably so).
Generally, this build represents the first genuinely promising version
of the browser for quite some time, despite the known library problems
with comment handling etc.
@
text
@d17 3
a19 1
/* Purpose: History functions for the browser      */
d21 2
a22 1
/* History: 07-Feb-97: Created                     */
d240 1
d476 1
d592 1
d595 1
d648 1
d766 1
d824 1
a824 1
        if (tl & (1u<<16)) Printf("history_fetch_forwards: Exitting through fetchpage_new()\n");
d834 1
a834 1
        if (tl & (1u<<16)) Printf("history_fetch_forwards: Exitting through windows_create_browser()\n");
d837 1
a837 1
      return windows_create_browser(p, NULL, NULL, NULL);
d856 1
d934 1
a934 1
        if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting through fetchpage_new()\n");
d944 1
a944 1
        if (tl & (1u<<16)) Printf("history_fetch_backwards: Exitting through windows_create_browser()\n");
d947 1
a947 1
      return windows_create_browser(p, NULL, NULL, NULL);
d1236 1
a1236 1
      sprintf(erb.errmess,"Fatal error inside history_build_menu(): Overran menu buffer! Allocated %d bytes, then used %d.",size,(int) menudata - (int) view_history_menu);
d1266 1
d1353 1
a1353 1
  else      return windows_create_browser(p, NULL, NULL, NULL);
a1356 2

/*************************************************/
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d820 1
a820 1
      return (fetchpage_new(b, p, 0));
d929 1
a929 1
      return (fetchpage_new(b, p, 0));
a1174 1

d1341 1
a1341 1
  if (!adj) return fetchpage_new(b, p, 0);
@

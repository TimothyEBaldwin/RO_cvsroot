head	1.34;
access;
symbols
	Browse-2_16:1.34
	Browse-2_15:1.34
	Browse-2_14:1.34
	Browse-2_13:1.34
	Browse-2_12:1.34
	Browse-2_11:1.33
	Browse-2_10:1.33
	Browse-2_09:1.33
	ahodgkin_208_i4_2:1.32
	ahodgkin_208_i4:1.30
	ahodgkin_208_i3:1.30
	ahodgkin_208_i2:1.30
	ahodgkin_208_i1:1.30
	ahodgkin_207release:1.30
	ahodgkin_206release:1.29
	ahodgkin_205release:1.29
	ahodgkin_204release:1.29
	ahodgkin_202release:1.29
	ahodgkin_201release:1.29
	ahodgkin_200release:1.29
	ahodgkin_133beta:1.29
	ahodgkin_132beta:1.29
	ahodgkin_131beta:1.29
	ahodgkin_130beta:1.28
	ahodgkin_129:1.27
	ahodgkin_128beta:1.25
	ahodgkin_128alpha:1.25
	ahodgkin_127beta2:1.22
	ahodgkin_127beta:1.22
	ahodgkin_126beta:1.20
	ahodgkin_AW97patch:1.20
	ahodgkin_AW97:1.17;
locks; strict;
comment	@# @;


1.34
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.26.09.42.34;	author ahodgkin;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.14.08.45.06;	author ahodgkin;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.31.15.58.32;	author ahodgkin;	state Exp;
branches;
next	1.30;

1.30
date	98.09.07.11.46.43;	author ahodgkin;	state Exp;
branches;
next	1.29;

1.29
date	98.01.31.10.55.15;	author ahodgkin;	state Exp;
branches;
next	1.28;

1.28
date	97.12.18.10.06.56;	author ahodgkin;	state Exp;
branches;
next	1.27;

1.27
date	97.12.12.11.17.48;	author ahodgkin;	state Exp;
branches;
next	1.26;

1.26
date	97.12.08.09.01.13;	author kbracey;	state Exp;
branches;
next	1.25;

1.25
date	97.12.02.16.13.45;	author ahodgkin;	state Exp;
branches;
next	1.24;

1.24
date	97.11.28.15.35.47;	author kbracey;	state Exp;
branches;
next	1.23;

1.23
date	97.11.26.17.10.53;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	97.11.19.10.28.51;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	97.11.05.15.25.53;	author kbracey;	state Exp;
branches;
next	1.20;

1.20
date	97.10.20.07.09.19;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	97.10.18.16.42.23;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	97.10.17.11.08.16;	author dbrown;	state Exp;
branches;
next	1.17;

1.17
date	97.10.16.13.23.08;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	97.10.15.15.09.08;	author dbrown;	state Exp;
branches;
next	1.15;

1.15
date	97.10.13.07.06.54;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	97.10.08.12.17.26;	author kbracey;	state Exp;
branches;
next	1.13;

1.13
date	97.10.03.09.19.03;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.09.26.12.35.57;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.09.22.11.51.06;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.09.22.07.43.11;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.09.18.12.37.12;	author kbracey;	state Exp;
branches;
next	1.8;

1.8
date	97.08.31.18.38.14;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.08.28.16.07.53;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.08.18.17.00.43;	author kbracey;	state Exp;
branches;
next	1.5;

1.5
date	97.08.18.13.16.59;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	97.08.18.09.23.53;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.08.05.08.42.54;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.08.01.09.00.47;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.28.28;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.34
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    FontManage.c                                      */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: A range of font management veneers.               */
/*                                                            */
/* Author:  A.D.Hodgkinson, including various functions from  */
/*          original Customer browser by Merlyn Kline.       */
/*                                                            */
/* History: 05-Dec-1996 (ADH): Created.                       */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#include <kernel.h>
#include <swis.h>

#include <HTMLLib/HTMLLib.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/event.h>

#include "Global.h"
#include "FromROSLib.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Redraw.h"

#include "FontManage.h"

/* Conditional includes */

#ifdef UNIFONT
  #include <Unicode/iso10646.h>
  #include <Unicode/utf8.h>
  #include "Unifont.h"
#endif

/* This relatively new SWI call may not already have been */
/* defined by the header files included above.            */

#ifndef Font_WideFormat
  #define Font_WideFormat 0x400A9
#endif

/**************************************************************************************************/
/*                                                                                                */
/* Merlyn's original overview comments (corrected where necessary, due to changes in the source): */
/* ============================================================================================== */
/*                                                                                                */
/* RISC OS Font management                                                                        */
/*                                                                                                */
/* Merlyn Kline, 1995                                                                             */
/*                                                                                                */
/* This module provides a range of veneers for font management. It allows a typeface              */
/* to be defined including bold, italic and bold-italic attributes. These typefaces               */
/* are given names by which they are referred to in subsequent use. When defining a               */
/* typeface an alternative to be used can be specified for cases where the primary                */
/* selection is unavailable for some reason. If the alternative does not exist, *its*             */
/* alternative is checked. This goes on for several attempts (about 4) before giving              */
/* up after which the ordinary system font is used, scaled appropriately. This limit              */
/* on the number of attempts improves performance and means you don't have to worry too           */
/* much about defining loops (eg pairs of typefaces which specify each other as alternatives).    */
/*                                                                                                */
/* The system provides veneers for all font related functions and these use an internal           */
/* font handle. This font handle is either the RISC OS font handle when an appropriate            */
/* font was available or a negative number made up from the x and y font sizes.                   */
/*                                                                                                */
/* Note the use of the word 'typeface' to describe the four-font structure used by this           */
/* module. This is to avoid confusion with the RISC OS term 'font' underlying it.                 */
/*                                                                                                */
/* Typefaces are defined by passing strings to the font definition routine, which contain         */
/* a description of the desired font, like:                                                       */
/*                                                                                                */
/*    name=normal:italic:bold:bolditalic;alternative                                              */
/*                                                                                                */
/* where:                                                                                         */
/*                                                                                                */
/*    name         is the name you want to refer to this typeface by (case *sensitive* for speed) */
/*    normal       is the RISC OS font name to use in normal rendering                            */
/*    italic       is the RISC OS font name to use in italic rendering                            */
/*    bold         is the RISC OS font name to use in bold rendering                              */
/*    bolditalic   is the RISC OS font name to use in bold plus italic rendering                  */
/*    alternative  is the alternative typeface name to use if necessary                           */
/*                                                                                                */
/* Any of these fields may be missing except <name>. If the font names used for                   */
/* bold/italic rendering are missing, the normal one will be used instead. If                     */
/* the normal font name is missing, the alternative typface is used. If the                       */
/* alternative is missing, system font will be used when the requested fonts are                  */
/* not available.                                                                                 */
/*                                                                                                */
/* When defining typefaces for optimum performance define the one which will be used              */
/* most, last. This is because they are kept in a linked list and new ones are added to           */
/* the start of the list and so will be found more quickly.                                       */
/*                                                                                                */
/* If you define a typeface with the same name as an existing one the new definition              */
/* overwrites the old one.                                                                        */
/*                                                                                                */
/* Default font definitions are available as follows:                                             */
/*                                                                                                */
/*   system=System.Fixed:Corpus.Medium.Oblique:Corpus.Bold:Corpus.Bold.Oblique;fixed              */
/*   sans=Homerton.Medium:Homerton.Medium.Oblique:Homerton.Bold:Homerton.Bold.Oblique;serif       */
/*   serif=Trinity.Medium:Trinity.Medium.Italic:Trinity.Bold:Trinity.Bold.Italic;sans             */
/*   fixed=Corpus.Medium:Corpus.Medium.Oblique:Corpus.Bold:Corpus.Bold.Oblique                    */
/*                                                                                                */
/* Font sizes are defined in sixteenths of a point. The system font is treated as a font          */
/* with a 2:1 aspect ratio so set both xsize and ysize to the same to get normal looking text.    */
/* A size of 205 (=8*2*16*72/90 ie:                                                               */
/*                                                                                                */
/*    pixels * os_units_per_pixel * sixteenths_of_a _point_per_inch / os_units_per_inch )         */
/*                                                                                                */
/* will get system font at its normal size. This size should therefore be used for any display    */
/* of information where size is pretty arbitrary, ensuring a reasonable appearnce should system   */
/* font be used. To help, it is #defined as FM_Standard_Size in FontManage.h.                     */
/*                                                                                                */
/*                     ------------------------------------------------------                     */
/*                                                                                                */
/* (Merlyn then goes on to describe the font menu display and interpretation functions, which are */
/* more or less redundant in this source due to the Toolbox's automation).                        */
/*                                                                                                */
/* Note that some specialisation of the library for use in the browser has been necessary, so     */
/* for example references to browser_data structures would need to be removed were this version   */
/* of the library to be used elsewhere.                                                           */
/*                                                                                                */
/**************************************************************************************************/

/* Statics */

static fm_typeface * fm_new_typeface  (void);
static fm_face       fm_sub_find_font (fm_typeface * f, int xsize, int ysize, int italic, int bold);

static fm_facelist * fm_list       = NULL;
static int           fm_systemfont = 0;
static int           fm_allowblend = -1;

/* Locals */

/* fm_faces allows typeface numbers to be defined internally */
/* which relate to typeface names held by the font managing  */
/* routines; these are easier to deal with than strings.     */

char * fm_faces[] = {
                      "serif",
                      "sans",
                      "fixed"
                    };

/* fm_handles records usage of font handles. For every font  */
/* font claim, an appropriate bit is examined in the         */
/* browser_data structure of the claimant (if available). If */
/* the bit is unset, it is set and the entry in fm_handles   */
/* incremented by one. For every font discard, the bit is    */
/* examined again and if set, it is cleared, and the entry   */
/* in fm_handles decremented by one. If that entry is now    */
/* zero, Font_LoseFont is called for the handle.             */

int fm_handles[Limits_OS_FontHandles];

/* fm_sizes allows quick lookup of a font size number, which */
/* otherwise would needed to be calculated on the fly (this  */
/* is slow). Initialisation is done in fm_init, and the size */
/* is looked up through fm_size.                             */
/*                                                           */
/* Whilst fm_find_token_font scales using this, fm_find_font */
/* doesn't. For speed, it's quicker if the caller can do the */
/* scaling, if needed, when falling fm_find_font.            */

int fm_sizes[Limits_FontSizes + 1]; /* (Indices 1 to Limits_FontSizes are used, with index 0 */
                                    /* filled with base size in case something goes wrong    */
                                    /* and a size of 0 is given)                             */

/**************************************************************/
/* fm_find_typeface()                                         */
/*                                                            */
/* Goes through the linked list of fm_facelist structures     */
/* looking for one which is named, returning the address of   */
/* the fm_typeface structure containing that name if it is    */
/* found (or NULL if not). The name should be in lower case   */
/* charaters.                                                 */
/*                                                            */
/* Parameters: A pointer to a string holding the name of the  */
/*             typeface to find, in lower case.               */
/*                                                            */
/* Returns:    Pointer to the fm_typeface struct if found,    */
/*             else NULL.                                     */
/**************************************************************/

fm_typeface * fm_find_typeface(const char * restrict name)
{
  fm_facelist * f;

  /* Set f to point to the start of the list */
  /* of fm_facelist structures, and go up    */
  /* the list looking for the named font.    */
  /* Return the address of the fm_typeface   */
  /* structure itself (rather than the       */
  /* fm_facelist structure that contains it) */
  /* if found, NULL if not.                  */

  f = fm_list;

  while (f)
  {
    if (!strcmp(f->face.name, name)) return &f->face;
    f = f->next;
  }

  return NULL;
}

/**************************************************************/
/* fm_new_typeface()                                          */
/*                                                            */
/* Adds a new typeface to the list of typefaces. Returns a    */
/* pointer to the fm_typeface struct itself, when added, or   */
/* NULL if the malloc claim failed (so error check this       */
/* externally)                                                */
/*                                                            */
/* Returns:    Pointer to the new fm_typeface struct, or NULL */
/*             if malloc failed.                              */
/**************************************************************/

static fm_typeface * fm_new_typeface(void)
{
  fm_facelist * f;

  /* Allocate memory for the fm_facelist struct */

  dprintf(("LMem", "fm_new_typeface: malloc %d for 'fm_facelist' structure\n",sizeof(fm_facelist)));

  f = calloc(1, sizeof(fm_facelist));

  if (f)
  {
    #ifdef TRACE
      malloccount += sizeof(fm_facelist);
      dprintf(("CMal", "** malloccount (fm_new_typeface): \0211%d\0217\n",malloccount));
    #endif

    /* If the claim succeeded, link the new item into */
    /* the list, and return with the address of the   */
    /* fm_typeface structure.                         */

    f->next = fm_list;
    fm_list = f;

    return &f->face;
  }

  /* The malloc claim failed, so return NULL */

  return NULL;
}

/**************************************************************/
/* fm_define_typeface_explicit()                              */
/*                                                            */
/* Adds a new fm_facelist structure to the list of            */
/* fm_facelist structures, but also names the new typeface    */
/* and only allocates a new list item if one of the same name */
/* wasn't already present.                                    */
/*                                                            */
/* Parameters: A pointer to an fm_typeface structure, in      */
/*             which only the 'name' field is filled in. This */
/*             becomes the name for the new typeface and is   */
/*             used to check if a typeface of that name is    */
/*             already present.                               */
/**************************************************************/

_kernel_oserror * fm_define_typeface_explicit(fm_typeface * f)
{
  fm_typeface * fp;

  /* Try to find a typeface of the same name in the list */

  fp = fm_find_typeface(f->name);

  /* If there isn't one, create a new typeface entry */

  if (!fp) fp = fm_new_typeface();

  /* Report an error if the new typeface entry couldn't be created */

  if (!fp)
  {
    erb.errnum = Utils_Error_Custom_Fatal;

    StrNCpy0(erb.errmess,
             lookup_token("FontMem:There is not enough free memory for font handling (%0).",
                          0,
                          "1"));

    return(&erb);
  }

  /* Copy whole structure over to fp */

  *fp = *f;

  return(NULL);
}

/**************************************************************/
/* fm_define_typeface()                                       */
/*                                                            */
/* This function defines a whole new typeface in full,        */
/* according to a description string the format of which is   */
/* described in Merlyn's comments at the top of this file.    */
/*                                                            */
/* Parameters: A pointer to a string containing the typeface  */
/*             description.                                   */
/**************************************************************/

_kernel_oserror * fm_define_typeface(const char * description)
{
  fm_typeface   f;
  const char  * p = description;
  int           i = 0;

  /* Ensure that the fm_typeface struct has been */
  /* allocated locally, then zero the contents   */

  f.name[0] = 0;
  memset(&f,0,sizeof(f));

  /* Travel through the description string looking for */
  /* an equals sign - this separates the name of the   */
  /* typeface from the actual RISC OS fonts it uses.   */
  /* Copy the text - which is the typeface name - into */
  /* the 'name' field of the new typeface structure    */
  /* that was filled with zeros above.                 */

  while ((*p) && (*p != '='))
  {
    if (i < (sizeof(f.name) - 1)) f.name[i++] = *p++;
  }

  /* If we're not now at the end of the string, get the */
  /* four RISC OS font names from the string.           */

  if (*p)
  {
    int n;

    for (n = 0; n < 4; n++)
    {
      p++; /* Skip past the =, : or ; that we last ended on */
      i=0;

      /* Copy between the current position and the next separator */
      /* (i.e. the font name) into the relevant fontname field of */
      /* the fm_typeface structure.                               */

      while ((*p) && (*p != ':') && (*p != ';'))
      {
        if (i < sizeof(f.fontnames[n]) - 1) f.fontnames[n][i++] = *p++;
      }

      /* If we've reached the end of the string or a ';', exit now */
      /* as there are no more font names.                          */

      if ((!*p) || (*p == ';')) break;
    }

    /* If there's a semicolon, there is an alternative typeface */
    /* name defined                                             */

    if (*p == ';')
    {
      p++; /* Skip past the ; */

      /* Copy the alternative typeface name to the fm_typeface struct */

      strncpy(f.alternative, p, sizeof(f.alternative) - 1);
    }
  }

  /* If there's at least one font name present, */
  /* actually allocate the memory for the       */
  /* typeface (or copy over an old one with the */
  /* same name).                                */

  if (f.name[0]) return fm_define_typeface_explicit(&f);

  /* There are no font names - the typeface is badly defined */

  erb.errnum = Utils_Error_Custom_Fatal;

  StrNCpy0(erb.errmess,
           lookup_token("BadType:Internal error - Bad typeface definition in %0.",
                        0,
                        "fm_define_typeface"));
  return &erb;
}

/**************************************************************/
/* fm_define_default_typefaces()                              */
/*                                                            */
/* Sets up the default typeface settings, for system, fixed   */
/* space, sans serif and serif font 'banks'.                  */
/**************************************************************/

_kernel_oserror * fm_define_default_typefaces(void)
{
  /* These will be overridden if typefaces of the same name are read */
  /* in by load_choices later.                                       */

  RetError(fm_define_typeface("fixed=Corpus.Medium:Corpus.Medium.Oblique:Corpus.Bold:Corpus.Bold.Oblique"));
  RetError(fm_define_typeface("sans=Homerton.Medium:Homerton.Medium.Oblique:Homerton.Bold:Homerton.Bold.Oblique;serif"));
  RetError(fm_define_typeface("serif=Trinity.Medium:Trinity.Medium.Italic:Trinity.Bold:Trinity.Bold.Italic;sans"));

  return NULL;
}

/**************************************************************/
/* fm_claim_basic_typefaces()                                 */
/*                                                            */
/* Claim a few basic fonts which will probably be needed for  */
/* the duration of the application run time.                  */
/*                                                            */
/* Parameters: Base font size to claim at.                    */
/**************************************************************/

void fm_claim_basic_typefaces(int base_size)
{
  fm_face h;

  #define FMCIncHandles(f) {                                              \
                             if (f >= 0)                                  \
                             {                                            \
                               if (!fm_handles[(f)]) fm_handles[(f)] = 1; \
                               else fm_lose_font(NULL, (f));              \
                             }                                            \
                           }

  if (!choices.system_font)
  {
    /* Need to be a bit careful here... Must not claim a font twice, if the */
    /* typeface is the same (e.g. System.Fixed for both fixed width normal  */
    /* and fixed width bold). The fm_handles array is an *internal* usage   */
    /* count - as far as the RISC OS Font Manager is concerned, for every   */
    /* font marked as used inside fm_handles, there's only one user in the  */
    /* browser. So if we claim something two or more times here, it'll only */
    /* get released once later on, thereby 'leaking' the font handle.       */

    h = fm_find_font(NULL, "sans",  base_size, base_size, 0, 0); FMCIncHandles(h)
    h = fm_find_font(NULL, "sans",  base_size, base_size, 0, 1); FMCIncHandles(h)
    h = fm_find_font(NULL, "sans",  base_size, base_size, 1, 0); FMCIncHandles(h)
    h = fm_find_font(NULL, "sans",  base_size, base_size, 1, 1); FMCIncHandles(h)

    h = fm_find_font(NULL, "serif", base_size, base_size, 0, 0); FMCIncHandles(h)
    h = fm_find_font(NULL, "serif", base_size, base_size, 1, 0); FMCIncHandles(h)
    h = fm_find_font(NULL, "serif", base_size, base_size, 0, 1); FMCIncHandles(h)
    h = fm_find_font(NULL, "serif", base_size, base_size, 1, 1); FMCIncHandles(h)

    h = fm_find_font(NULL, "fixed", base_size, base_size, 0, 0); FMCIncHandles(h)
    h = fm_find_font(NULL, "fixed", base_size, base_size, 0, 1); FMCIncHandles(h)
  }
}

/**************************************************************/
/* fm_sub_find_font()                                         */
/*                                                            */
/* When asked for a standard, italic, bold or bold italic     */
/* variant of a typeface, this will return the font handle    */
/* for the requested font or -1 if it can't be found. The     */
/* routine will try for just a standard or bold variant if an */
/* italic or bold italic variant isn't defined, then drop to  */
/* just standard, before giving up.                           */
/*                                                            */
/* Parameters: Pointer to the fm_typeface struct for the      */
/*             typeface in question;                          */
/*                                                            */
/*             The X and Y sizes, in 1/16ths of a point, of   */
/*             the font to claim;                             */
/*                                                            */
/*             1 to specify italics, else 0;                  */
/*                                                            */
/*             1 to specify bold, else 0.                     */
/*                                                            */
/* Returns:    The RISC OS font manager's font handle for the */
/*             requested font (as an fm_face) or -1 if the    */
/*             font couldn't be found either by this routine, */
/*             or by the font manager itself.                 */
/**************************************************************/

static fm_face fm_sub_find_font(fm_typeface * f, int xsize, int ysize, int italic, int bold)
{
  int        n;
  fm_face    h;

  /* Set bit 0 of n if italic was specified, and bit 1 */
  /* if bold was specified.                            */

  n=(italic ? 1 : 0) | (bold ? 2 : 0);

  /* So n = 0 for standard, 1 for italic, 2 for bold */
  /* and 3 for bold italic.                          */

  /* If there is no fontname defined for that combination, */
  /* AND n with 2 - i.e., drop the italic specifier and    */
  /* just try plain / bold.                                */

  if (!f->fontnames[n][0]) n &= 2;

  /* If there is still no font name, try the standard only */

  if (!f->fontnames[n][0]) n = 0;

  /* If there is *still* no font name, we can't match this */
  /* so flag that by returning -1.                         */

  if (!f->fontnames[n][0]) return -1;

  /* If the font manager can't find the font, again flag the */
  /* problem by returning -1. Otherwise, return the font     */
  /* handle returned by the font manager.                    */

  if (_swix(Font_FindFont,
            _INR(1,5) | _OUT(0),

            f->fontnames[n],     /* Font name to find    */
            xsize,               /* x size in 16ths pt   */
            ysize,               /* y size in 16ths pt   */
            180 / wimpt_dx(),    /* Current mode's x dpi */
            180 / wimpt_dy(),    /* Current mode's y dpi */

            &h))                 /* Font handle put in h */

            return -1;

  return h;
}

/**************************************************************/
/* fm_size()                                                  */
/*                                                            */
/* Given an abstracted font size (from 1 to 7, with 3 being   */
/* 'base font' size), returns the actual size (in 16ths of a  */
/* point) to use.                                             */
/*                                                            */
/* Parameters: The font size, from 1 to 7.                    */
/*                                                            */
/* Returns:    The equivalent font size, in 16ths of a point. */
/**************************************************************/

int fm_size(int size)
{
  if (size < choices.minimum_font_size) size = choices.minimum_font_size;
  if (size > sizeof(fm_sizes) - 1)      size = sizeof(fm_sizes) - 1;

  return fm_sizes[size];
}

/**************************************************************/
/* fm_find_font()                                             */
/*                                                            */
/* Returns the font handle of a requested typeface variant,   */
/* optionally recording the usage in a given browser_data     */
/* structure.                                                 */
/*                                                            */
/* Parameters: Pointer to the browser_data struct relevant to */
/*             the font;                                      */
/*                                                            */
/*             Pointer to the typeface name;                  */
/*                                                            */
/*             X and Y sizes in 16ths of a pt;                */
/*                                                            */
/*             1 for italics, 0 for not italic;               */
/*                                                            */
/*             1 for bold, 0 for not bold.                    */
/*                                                            */
/* Returns:    A RISC OS font handle for the requested font   */
/*             or the closest available match to it; this may */
/*             be the system font if no good match could be   */
/*             found.                                         */
/*                                                            */
/* Assumes:    The browser_data struct pointer may be NULL.   */
/**************************************************************/

fm_face fm_find_font
        (
          browser_data * restrict b,
          const char   * restrict name,
          int            xsize,
          int            ysize,
          int            italic,
          int            bold
        )
{
  fm_typeface * f;
  fm_face       s,h;
  int           i;

  /* Work out the system font 'handle' for the given point size */

  s = FM_System_Handle(xsize,ysize); /* (Macro defined in FontManage.h) */

  /* If system font has been configured locally through the */
  /* fm_set_system_font function, return that handle now    */

  if (fm_systemfont) return s;

  /* The slower alternative - try to find the named typeface */

  f = fm_find_typeface(name);

  /* If it can't be found, return the system font */

  if (!f) return s;

  /* Get the RISC OS font handle for that typeface */

  h = fm_sub_find_font(f, xsize, ysize, italic, bold);

  /* If fm_sub_find_font returns -1, keep trying   */
  /* alternative typefaces as long as there are    */
  /* some defined, to a maximum of 4 alternatives. */

  for (
        i = 0;
        i < 3 && h < 0 && f->alternative[0];
        i++
      )
  {
    f = fm_find_typeface(f->alternative);
    if (!f) return s;
    h = fm_sub_find_font(f, xsize, ysize, italic, bold);
  }

  /* If we still haven't got a RISC OS font handle */
  /* return the system font handle.                */

  if (h < 0) return s;

  /* Success, eventually! */

  /* If the font has already been claimed (it has an entry in fm_handles) */
  /* don't want to keep the second claim caused by the Font_FindFont that */
  /* gave the handle. So, lose the font - we know that the Font Manager   */
  /* will still have a usage of at least 1 for the font as long as        */
  /* fm_handles has a non-zero usage count itself. This is somewhat       */
  /* inefficient, but otherwise, for every claimed font handle, the face  */
  /* name, style, and size would have to be recorded with it, and for     */
  /* every font claim these preclaimed fonts would need to checked        */
  /* through. This would end up being quite slow.                         */

  if (b && fm_handles[h]) _swix(Font_LoseFont, _IN(0), h);

  /* Record the usage of this font */

  if (b && !(Bitfield_Is_Set(&b->handles, h)))
  {
    fm_handles[h]++;
    Bitfield_Set_Bit(&b->handles, h);
  }

  return h;
}

/**************************************************************/
/* fm_lose_font()                                             */
/*                                                            */
/* Forgets about the usage of a given font by a given         */
/* browser, and if there are no users at this point, tell the */
/* RISC OS Font Manager that the font is no longer in use.    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the font;                                      */
/*                                                            */
/*             The RISC OS font handle for the font to        */
/*             forget.                                        */
/*                                                            */
/* Assumes:    The pointer to the browser_data struct *may*   */
/*             be NULL, in which case the RISC OS Font        */
/*             Manager is told the font isn't needed straight */
/*             away.                                          */
/**************************************************************/

void fm_lose_font(browser_data * restrict b, fm_face h)
{
  if (h >= 0)
  {
    if (b)
    {
      if (Bitfield_Is_Set(&b->handles, h))
      {
        fm_handles[h]--;

        Bitfield_Clear_Bit(&b->handles, h);
      }

      if (!fm_handles[h]) _swix(Font_LoseFont,_IN(0),h);
      else if (fm_handles[h] < 0) fm_handles[h] = 0;
    }
    else _swix(Font_LoseFont,_IN(0),h);
  }
}

/**************************************************************/
/* fm_lose_fonts()                                            */
/*                                                            */
/* Forgets about the usage of all fonts used by a given       */
/* browser, and if there are no longer any users of any of    */
/* the fonts, tells the RISC OS Font Manager that those fonts */
/* are no longer in use.                                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the fonts.                                     */
/**************************************************************/

void fm_lose_fonts(browser_data * restrict b)
{
  int fh;

  for (fh = 0; fh < Limits_OS_FontHandles; fh++)
  {
    if (Bitfield_Is_Set(&b->handles, fh)) fm_lose_font(b, fh);
  }
}

/**************************************************************/
/* fm_rescale_fonts()                                         */
/*                                                            */
/* For all currently claimed fonts, reclaim them with the     */
/* current screen DPI. Useful for (say) mode changes, when    */
/* the Desktop scaling may have changed.                      */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the fonts to rescale.                          */
/**************************************************************/

_kernel_oserror * fm_rescale_fonts(browser_data * restrict b)
{
  _kernel_oserror * e;
  browser_data      temp;
  int               fh, size, xsize, ysize;
  char              name[Limits_FontName];

  /* Can't lose and reclaim fonts within the same browser, */
  /* whilst scanning through its list of claimed fonts...  */
  /* if ever a font handle higher than the one just lost   */
  /* was returned, things would go very wrong. So copy     */
  /* the list of used fonts into a temporary store and use */
  /* this for the loses and claims, then copy that back to */
  /* the actual browser_data structure when finished.      */

  temp.handles = b->handles;

  /* Now loop round all the font handles */

  for (fh = 0; fh < Limits_OS_FontHandles; fh++)
  {
    /* If this font is claimed... */

    if (Bitfield_Is_Set(&b->handles, fh))
    {
      /* How much space does the font name need? */

      e = _swix(Font_ReadDefn,
                _INR(0,1) | _IN(3) | _OUT(2),

                fh,              /* Handle */
                0,               /* Return buffer size needed for name */
                Magic_Word_FULL, /* See MiscDefs.h */

                &size);

      if (e) return e;

      /* If the font name will fit, then get the name and size details */

      if (size < sizeof(name)) /* Not '<=' as need terminator */
      {
        int h;

        /* Fill the name buffer with zeros first, to ensure the */
        /* name string is correctly terminated.                 */

        memset(name, 0, sizeof(name));

        /* Now read the font information */

        e = _swix(Font_ReadDefn,
                  _INR(0,1) | _IN(3) | _OUTR(2,3),

                  fh,
                  name,
                  Magic_Word_FULL, /* See MiscDefs.h */

                  &xsize,
                  &ysize);

        if (e) return e;

        /* Lose the old font, and reclaim the same name and size */
        /* at a new resolution.                                  */

        fm_lose_font(&temp, fh);

        e = _swix(Font_FindFont,
                  _INR(1,5) | _OUT(0),

                  name,             /* Font name to find    */
                  xsize,            /* x size in 16ths pt   */
                  ysize,            /* y size in 16ths pt   */
                  180 / wimpt_dx(), /* Current mode's x dpi */
                  180 / wimpt_dy(), /* Current mode's y dpi */

                  &h);              /* Font handle put in h */

        if (e) return e;

        /* See fm_find_font for full comments on this bit, no need */
        /* to repeat it all here.                                  */

        if (fm_handles[h]) _swix(Font_LoseFont, _IN(0), h);

        /* Record the usage of this font */

        fm_handles[h]++;
        Bitfield_Set_Bit(&temp.handles, h);

      /* Closure of long 'if' to see if the font name would fit */
      /* in the allocated buffer. The code above executes if it */
      /* would.                                                 */
      }

    /* Closure of long 'if' to see if the current font handle */
    /* was claimed; the code above executes if it was.        */
    }

  /* Closure of 'for' loop going found all font handles. */
  }

  /* Copy the font usage information back to the actual browser. */

  b->handles = temp.handles;

  return NULL;
}

/**************************************************************/
/* fm_font_box()                                              */
/*                                                            */
/* Gets a bounding box large enough to cover any character in */
/* a given font, in OS units.                                 */
/*                                                            */
/* Parameters: RISC OS font handle of the font;               */
/*                                                            */
/*             Pointer to a BBox into which the bounding box  */
/*             is placed (min X and Y are inclusive, max X    */
/*             and Y are exclusive).                          */
/**************************************************************/

_kernel_oserror * fm_font_box(fm_face h, BBox * restrict box)
{
  if (h < 0)
  {
    /* If we're passed a system font handle, */
    /* treat that as a special case.         */

    int xs,ys;

    xs = FM_System_Size_X(h); /* (Macros defined in FontManage.h) */
    ys = FM_System_Size_Y(h);

    /* The code is derived from this:        */
    /*                                       */
    /* box->xmin=0;                          */
    /* box->ymin=ys * (10 * -3) / (64 * 16); */
    /*                                       */
    /* box->xmax=xs * 10 / 128;              */
    /* box->ymax=ys * (10 * 13) / (64 * 16); */

    box->xmin = 0;
    box->ymin = (ys * -30) / (1024);

    box->xmax = (xs * 10) / 128;
    box->ymax = (ys * 130) / (1024);
  }
  else
  {
    /* Otherwise, ask the Font Manager for the bounding box */

    // this probably needs to change to a char by char scan of the font and cache the result

    return _swix(Font_ReadInfo,
                 _IN(0) | _OUTR(1,4),

                 h,            /* Handle                    */

                 &box->xmin,   /* Minimum X of bounding box */
                 &box->ymin,   /* Minimum Y of bounding box */
                 &box->xmax,   /* Maximum X of bounding box */
                 &box->ymax);  /* Maximum Y of bounding box */
  }

  return NULL;
}

/**************************************************************/
/* fm_char_box()                                              */
/*                                                            */
/* Gets the bounding box of a char, in OS units.              */
/*                                                            */
/* Parameters: RISC OS font handle of the font;               */
/*                                                            */
/*             Character to measure;                          */
/*                                                            */
/*             Pointer to a BBox into which the bounding box  */
/*             is placed (min X and Y are inclusive, max X    */
/*             and Y are exclusive).                          */
/**************************************************************/

_kernel_oserror * fm_char_box(fm_face h, char c, BBox * restrict box)
{
  /* Very similar structure to fm_font_box, so see that for */
  /* more comments.                                         */

  if (h < 0)
  {
    int xs,ys;

    xs = FM_System_Size_X(h);
    ys = FM_System_Size_Y(h);

    box->xmin = 0;
    box->ymin = (ys * -30) / (1024);

    box->xmax = (xs * 10) / 128;
    box->ymax = (ys * 130) / (1024);
  }
  else
  {
    #ifdef UNIFONT
      _swix(Font_WideFormat, _INR(0,1), h, 12);
    #endif

    return _swix(Font_CharBBox,
                 _INR(0,2) | _OUTR(1,4),

                 h,            /* Handle                    */
                 c,            /* Character                 */
                 FM_OSUnits,   /* Flags -> OS units, please */

                 &box->xmin,   /* Minimum X of bounding box */
                 &box->ymin,   /* Minimum Y of bounding box */
                 &box->xmax,   /* Maximum X of bounding box */
                 &box->ymax);  /* Maximum Y of bounding box */
  }

  return NULL;
}

/**************************************************************/
/* fm_set_font_colour()                                       */
/*                                                            */
/* Sets the font colour for subsequent painting.              */
/*                                                            */
/* Parameters: The RISC OS font handle of the font in         */
/*             question;                                      */
/*                                                            */
/*             The foreground colour;                         */
/*                                                            */
/*             The background colour.                         */
/*                                                            */
/*             Colours are As palette entries, i.e. are in    */
/*             the form BBGGRRcc where cc = GCOL, else use    */
/*             the Red Green and Blue bytes.                  */
/**************************************************************/

_kernel_oserror * fm_set_font_colour(fm_face h, unsigned int fore, unsigned int back)
{
  /* First, the system font case */

  if (h < 0)
  {
    #ifdef UNIFONT

      /* Need to set the background colour too */

      _swix(ColourTrans_SetGCOL,

                            _IN(0) | _INR(3,4),

                            back,    /* Palette entry */
                            0x80,    /* Flags         */
                            0);      /* GCOL action   */

    #endif

    return _swix(ColourTrans_SetGCOL,
                          _IN(0) | _INR(3,4),

                          fore,    /* Palette entry */
                          0,       /* Flags         */
                          0);      /* GCOL action   */
  }
  else
  {
    /* Alternatively, deal with an outline font */

    return _swix(ColourTrans_SetFontColours,
                 _INR(0,3),

                 h,       /* Handle                            */
                 back,    /* Background colour palette entry   */
                 fore,    /* Foreground colour palette entry   */
                 14);     /* Maximum foreground colour offset  */
  }
}

/**************************************************************/
/* fm_puts()                                                  */
/*                                                            */
/* Outputs a string in a given font at specified coordinates  */
/* in a colour determined by calls to fm_set_font_colour()    */
/* prior to calling this function.                            */
/*                                                            */
/* Parameters: Font Manager internal font handle;             */
/*                                                            */
/*             X and Y coordinates of the bottom left of the  */
/*             bounding box of the plotted string. These may  */
/*             be in OS units or millipoints (see below);     */
/*                                                            */
/*             Pointer to the string to output;               */
/*                                                            */
/*             1 if using OS coords, else 0;                  */
/*                                                            */
/*             1 to use font blending, else 0. Font blending  */
/*             will not be allowed if the Font Manager in use */
/*             is too old, but requesting it is harmless.     */
/**************************************************************/

_kernel_oserror * fm_puts
                  (
                    fm_face               h,
                    int                   x,
                    int                   y,
                    const char * restrict s,
                    int                   os,
                    int                   blend
                  )
{
  /* These days, this is just a veneer */

  return fm_putsl(h, x, y, s, 0, os, blend);
}

/**************************************************************/
/* fm_putsl()                                                 */
/*                                                            */
/* As fm_puts above, but takes an extra parameter after the   */
/* string pointer which says how many characters of the       */
/* string should be plotted.                                  */
/*                                                            */
/* To work without damaging the original string, a copy is    */
/* taken. This means the function works quite a lot more      */
/* slowly than fm_puts - always use fm_puts unless you really */
/* must plot only a small part of an existing string.         */
/*                                                            */
/* Parameters: Font Manager internal font handle;             */
/*                                                            */
/*             X and Y coordinates of the bottom left of the  */
/*             bounding box of the plotted string. These may  */
/*             be in OS units or millipoints (see below);     */
/*                                                            */
/*             Pointer to the string to output;               */
/*                                                            */
/*             Number of *bytes* to use from the start of the */
/*             string - if this is equal to or greater than   */
/*             the actual string length, the function just    */
/*             calls straight to fm_puts instead;             */
/*                                                            */
/*             1 if using OS coords, else 0;                  */
/*                                                            */
/*             1 to use font blending, else 0. Font blending  */
/*             will not be allowed if the Font Manager in use */
/*             is too old, but requesting it is harmless.     */
/**************************************************************/

_kernel_oserror * fm_putsl
                  (
                    fm_face               h,
                    int                   x,
                    int                   y,
                    const char * restrict s,
                    size_t                numbytes,
                    int                   os,
                    int                   blend
                  )
{
  dprintf(("Font", "\nfm_putsl: Called with handle %p\n         String '%s'\n",(void *) h, s));

  /* Bound the number of characters to be printed. The check for */
  /* 'numbytes != 0' is only there to stop 'strlen' being called */
  /* if the font plot is length unlimited; a small optimisation. */

  if (numbytes != 0 && numbytes >= strlen(s)) numbytes = 0;

  /* First, system font output */

  if (h < 0)
  {
    _kernel_oserror * e;

    int xs, ys;

    if (!os) convert_pair_to_os(x, y, &x, &y);

    /* Work out the pixel size of the font; note that the */
    /* Y size is twice the X size for aesthetic reasons   */

    xs = FM_System_Size_X(h) * 10 / (128 * wimpt_dx());
    ys = FM_System_Size_Y(h) * 10 / (64  * wimpt_dy());

    /* Set the size and spacing */

    bbc_vduq(23, /* Miscellaneous command          */
             17, /* Miscellaneous operations       */
             7,  /* Set character size and spacing */
             6,  /* Bit 1 = size, bit 2 = spacing  */
             xs & 255, xs >> 8,
             ys & 255, ys >> 8,
             0,
             0);

    /* Move to the requested (converted) coordinates. 10/64 */
    /* converts to OS units, 13/16 is height above base     */

    bbc_move(x, y + (FM_System_Size_Y(h) * (10*13) / (64*16)) - 1);

    /* Output the string */

    #ifdef UNIFONT

      /* It would be more efficient to do the start/end calls at */
      /* a higher level, e.g. before entering a redraw loop, but */
      /* doing it down here doesn't introduce a huge hit and is  */
      /* more reliable - it won't be forgotten by accident.      */

      unifont_start_redraw();

      e = unifont_write(s,
                        numbytes,
                        x,
                        y + (FM_System_Size_Y(h) * (10*13) / (64*16)) - 1,
                        xs,
                        ys);

      (void) unifont_end_redraw();

    #else

      if (numbytes == 0) e = _swix(OS_Write0, _IN(0),    s);
      else               e = _swix(OS_WriteN, _INR(0,1), s, numbytes);

    #endif

    /* Set the text output size back (certainly get interesting */
    /* effects from Make if you don't do this...!)              */

    bbc_vduq(23, /* Miscellaneous command          */
             17, /* Miscellaneous operations       */
             7,  /* Set character size and spacing */
             6,  /* Bit 1 = size, bit 2 = spacing  */
             16 / wimpt_dx(), 0,
             32 / wimpt_dy(), 0,
             0,
             0);

    return e;
  }
  else
  {
    unsigned int flags;

    /* Outline font output */

    if (fm_allowblend < 0)
    {
      /* If we haven't already, check the Font Manager */
      /* version - for 3.37 or later, allow background */
      /* blending (fm_allowblend will set bit 11 of    */
      /* the flags for Font_Paint), else don't allow   */
      /* blending (earlier versions of the Font        */
      /* Manager will object strongly to bit 11 being  */
      /* set).                                         */

      int version;

      if (_swix(Font_CacheAddr,_OUT(0),&version)) version = 0;

      fm_allowblend = (version >= 337) ? FM_Blend : 0;
    }

    /* Paint the string. The parameters are a pointer to the string, */
    /* flags, and x and y coordinates. The flags have the blending   */
    /* set if asked for, specify absolute coordaintes, and tell the  */
    /* Font Manager whether x and y are OS units or millipoints.     */

    #ifdef TRACE
      {
        unsigned char * scan  = (unsigned char *) s;
        size_t          count = 0;

        while (*scan && (numbytes == 0 || count < numbytes))
        {
          if (*scan < 32 && *scan != 10 && *scan != 13) dprintf(("Font", "fm_putsl: Warning, non-CR/LF control char %d in string\n",(unsigned int) *scan));

          scan  ++;
          count ++;
        }

        dprintf(("Font", "fm_putsl: Calling Font_Paint prior to exiting\n"));
      }
    #endif

    if (printing) flags = 0;
    else          flags = blend ? fm_allowblend : 0;

    flags |= (
               (FM_GivenHandle)                    |
               (FM_Kern)                           |
               (os           ? FM_OSUnits     : 0) |
               (numbytes > 0 ? FM_GivenLength : 0)
             );

    #ifdef UNIFONT
      _swix(Font_WideFormat, _INR(0,1), h, 12);
    #endif

    return _swix(Font_Paint,
                 _INR(0,7),

                 h,
                 s,
                 flags,
                 x,
                 y,
                 NULL,      /* No extra parameters      */
                 NULL,      /* No transformation matrix */
                 numbytes); /* String length            */
  }
}

/**************************************************************/
/* fm_write_descriptor()                                      */
/*                                                            */
/* Writes the descriptor string for a typeface into a given   */
/* buffer.                                                    */
/*                                                            */
/* Parameters: Pointer to the typeface name;                  */
/*                                                            */
/*             Pointer to the buffer.                         */
/*                                                            */
/* Assumes:    That the buffer is big enough.                 */
/**************************************************************/

_kernel_oserror * fm_write_descriptor(const char * restrict name, char * restrict buffer)
{
  fm_typeface * f;

  /* Try to find the typeface */

  f = fm_find_typeface(name);

  /* If the typeface isn't found, give an error */

  if (!f)
  {
    erb.errnum = Utils_Error_Custom_Fatal;

    StrNCpy0(erb.errmess,
             lookup_token("BadTRef:Internal error - Reference to undefined typeface in %0.",
                          0,
                          "fm_write_descriptor"));
    return &erb;
  }

  /* Else fill in the buffer */

  sprintf(buffer,
          "%s=%s:%s:%s:%s;%s",
          f->name,
          f->fontnames[0],
          f->fontnames[1],
          f->fontnames[2],
          f->fontnames[3],
          f->alternative);

  return NULL;
}

/**************************************************************/
/* fm_write_name()                                            */
/*                                                            */
/* Writes the RISC OS font name for a given typeface variant  */
/* to a given buffer                                          */
/*                                                            */
/* Parameters: Typeface number from the fm_faces array;       */
/*                                                            */
/*             Pointer to the buffer;                         */
/*                                                            */
/*             1 for italics, else 0;                         */
/*                                                            */
/*             1 for bold, else 0.                            */
/*                                                            */
/* Assumes:    That the buffer is big enough.                 */
/**************************************************************/

_kernel_oserror * fm_write_name(int number, char * restrict buffer, int italic, int bold)
{
  fm_typeface * f;
  int           n;
  char        * name;

  if (number < 0 || number >= sizeof(fm_faces) / sizeof(*fm_faces))
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Illegal typeface number %d in fm_write_name.",
              number);

      return &erb;

    #endif

    return NULL;
  }
  else name = fm_faces[number];

  /* Index the correct font name using the bold and italic flags */

  n = (italic ? 1 : 0) | (bold ? 2 : 0);

  /* Try to find the typeface */

  f = fm_find_typeface(name);

  /* If the typeface isn't found, give an error */

  if (!f)
  {
    erb.errnum = Utils_Error_Custom_Fatal;

    StrNCpy0(erb.errmess,
             lookup_token("BadTRef:Internal error - Reference to undefined typeface in %0.",
                          0,
                          "fm_write_name"));
    return &erb;
  }

  /* Else fill in the buffer */

  sprintf(buffer,"%s",f->fontnames[n]);

  return NULL;
}

/**************************************************************/
/* fm_find_font_index_by_handle()                             */
/*                                                            */
/* Obtain a typeface number based on a font handle. Obtains   */
/* the RISC OS font name then searches for a match in the     */
/* list of known fonts. Will step through the fm_list and     */
/* increment a counter for each font checked; the value of    */
/* this counter is returned. Generally, we expect 3 families  */
/* - serif, sans-serif and monospaced in that order - each    */
/* with 4 variants, of normal, italic, bold and bold-italic   */
/* in that order; so a normal monospaced font would give      */
/* number 8, bold italic serif would give 3, and so-on.       */
/*                                                            */
/* For the caller's convenience, the X and Y sizes of the     */
/* font can be obtained at the same time as the index.        */
/*                                                            */
/* Parameters: Font manager handle;                           */
/*                                                            */
/*             Pointer to an int updated on exit with the     */
/*             X size in millipoints of the given font, or    */
/*             NULL if not interested;                        */
/*                                                            */
/*             Pointer to an int updated on exit with the     */
/*             Y size in millipoints of the given font, or    */
/*             NULL if not interested.                        */
/*                                                            */
/* Returns:    Index as described above or -1 for a problem   */
/*             (handle represents the system font, font name  */
/*             not found, etc.) - the returned size data is   */
/*             undefined in such cases and must be ignored.   */
/**************************************************************/

int fm_find_font_index_by_handle(fm_face handle, int * r_xsize, int * r_ysize)
{
  size_t        size;
  int           xsize, ysize;
  char        * name;
  fm_facelist * list = fm_list;
  int           num  = 0;
  int           add;

  /* Can't do anything with system fonts or no font list */

  if (handle < 0 || fm_list == NULL) return -1;

  /* Read how much buffer space is needed for the font name */

  if (_swix(Font_ReadDefn,
            _INR(0,1) | _IN(3) | _OUT(2),

            handle,
            0,
            Magic_Word_FULL, /* See MiscDefs.h */

            &size))

            return -1;

  /* Allocate the space and read the name */

  name = malloc(size + 1);
  if (name == NULL) return -1;

  if (_swix(Font_ReadDefn,
            _INR(0,1) | _IN(3) | _OUTR(2,3),

            handle,
            name,
            0,

            &xsize,
            &ysize))
  {
    free(name);
    return -1;
  }

  if (r_xsize != NULL) *r_xsize = xsize;
  if (r_ysize != NULL) *r_ysize = ysize;

  /* Ensure the name is terminated with a NUL byte */

  name[size] = '\0';

  for (add = 0; add < size; add++)
  {
    if (name[add] < ' ')
    {
      name[add] = '\0';
      break;
    }
  }

  /* See if the name is recognised */

  while (list != NULL)
  {
    for (
          add = 0;
          add < sizeof(list->face.fontnames) / sizeof(*list->face.fontnames);
          add++
        )
    {
      if (!strcmp(list->face.fontnames[add], name))
      {
        free(name);
        return num;
      }

      num++;
    }

    list = list->next;
  }

  /* No idea what font this is... */

  free(name);
  return -1;
}

/**************************************************************/
/* fm_read_typeface()                                         */
/*                                                            */
/* Given a typeface name inside an fm_typeface structure, the */
/* rest of the typeface details are filled in. If the         */
/* typeface name isn't found an error will be raised.         */
/*                                                            */
/* Parameters: A pointer to the fm_typeface with the name to  */
/*             look up inside its 'name' field.               */
/**************************************************************/

_kernel_oserror * fm_read_typeface(fm_typeface * restrict face)
{
  fm_typeface * f;

  /* Try to find the named typeface */

  f = fm_find_typeface(face->name);

  /* Raise an error if it can't be found */

  if (!f)
  {
    erb.errnum = Utils_Error_Custom_Fatal;

    StrNCpy0(erb.errmess,
             lookup_token("BadTRef:Internal error - Reference to undefined typeface in %0.",
                          0,
                          "fm_read_typeface"));
    return &erb;
  }

  /* Copy the found typeface contents across to the supplied typeface */

  *face = *f;

  return NULL;
}

/**************************************************************/
/* fm_destroy_typefaces()                                     */
/*                                                            */
/* Destroys *all* typeface records, therefore emptying the    */
/* list of typefaces.                                         */
/**************************************************************/

void fm_destroy_typefaces(void)
{
  fm_facelist * f, * c;

  /* Point f to the head of the list */

  f = fm_list;

  /* As long as f is non-null, there is a typeface. */
  /* Remember the typeface address and point f to   */
  /* the next item in the list; then free the       */
  /* typeface structure memory.                     */

  while(f)
  {
    c = f;
    f = f->next;

    #ifdef TRACE
      dprintf(("LMem", "fm_destroy_typefaces: free block %p, which held 'fm_facelist' structure\n",c));
      malloccount -= sizeof(fm_facelist);
      dprintf(("CMal", "** malloccount (fm_destroy_typefaces): \0212%d\0217\n",malloccount));
    #endif

    free(c);
  }

  /* Ensure that the list is flagged as empty. */

  fm_list=NULL;
}

/**************************************************************/
/* fm_set_system_font()                                       */
/*                                                            */
/* Sets the static local flag to say that system fonts only   */
/* should be used for font handling. This will only affect    */
/* any fonts claimed with e.g. fm_find_font after this        */
/* function has been called.                                  */
/*                                                            */
/* Parameters: 1 to use system font, 0 to allow outline       */
/*             fonts.                                         */
/**************************************************************/

void fm_set_system_font(int systemfont)
{
  fm_systemfont = systemfont;
}

/**************************************************************/
/* fm_system_font()                                           */
/*                                                            */
/* Returns 1 if the font library is currently using system    */
/* font for any new font finds, or 0 if outline fonts are     */
/* allowed. This is intended for external callers only (it is */
/* faster to use the fm_systemfont variable directly in       */
/* internal routines).                                        */
/**************************************************************/

int fm_system_font(void)
{
  return fm_systemfont;
}

/**************************************************************/
/* fm_init()                                                  */
/*                                                            */
/* Initialises the library for use.                           */
/*                                                            */
/* Parameters: 1 if the library is to only use the system     */
/*             font from the outset, or 0 to allow outline    */
/*             fonts;                                         */
/*                                                            */
/*             The 'base font' size, if going to use the      */
/*             fm_size function to allow an abstracted font   */
/*             size selection method (see fm_size).           */
/**************************************************************/

void fm_init(int systemfont, int base_size)
{
  fm_destroy_typefaces();
  fm_set_system_font(systemfont);
  fm_init_sizes(base_size);
}

/**************************************************************/
/* fm_init_sizes()                                            */
/*                                                            */
/* Sets up the size array for FONT SIZE=xxx and related       */
/* attributes, based on the given base font size.             */
/*                                                            */
/* Parameters: The 'base font' size.                          */
/**************************************************************/

void fm_init_sizes(int base_size)
{
  int size, scaleby;

  /* Set up the size array */

  fm_sizes[0] = base_size; /* Just in case 0 gets given to fm_size by accident - more likely than a large out of range value */

  for (size = 1; size <= 7; size ++)
  {
    scaleby        = size - 3;
    fm_sizes[size] = (int) (base_size * pow(1.2, scaleby));
  }
}

/**************************************************************/
/* fm_shutdown()                                              */
/*                                                            */
/* Tells the RISC OS Font Manager that all fonts currently    */
/* marked as used in fm_handles are not needed regardless of  */
/* the internal usage counter therein, and resets those       */
/* counters to zero.                                          */
/**************************************************************/

void fm_shutdown(void)
{
  int fh;

  for (fh = 0; fh < Limits_OS_FontHandles; fh++)
  {
    if (fm_handles[fh])
    {
      _swix(Font_LoseFont, _IN(0), fh);
      fm_handles[fh] = 0;
    }
  }
}

/**************************************************************/
/* fm_get_string_width()                                      */
/*                                                            */
/* Given a string, and the number of chars to consider in     */
/* that string, work out the width of the string. A maximum   */
/* width can be given, and if it is possible to split the     */
/* string (pass the character to split on), the width         */
/* returned will reflect this consideration (but can still be */
/* greater than maxwid, if no split characters were found for */
/* far enough). The number of bytes used to work out the      */
/* final returned width is itself returned, though any        */
/* trailing spaces are included in this value even if they    */
/* aren't used to get the width.                              */
/*                                                            */
/* Parameters: The RISC OS font handle to use in width        */
/*             calculations;                                  */
/*                                                            */
/*             Pointer to the string to use;                  */
/*                                                            */
/*             Maximum width to allow if splitting the line,  */
/*             in millipoints;                                */
/*                                                            */
/*             The maximum number of bytes of string to       */
/*             consider;                                      */
/*                                                            */
/*             The character to split at (such as a space),   */
/*             or -1 for 'don't split';                       */
/*                                                            */
/*             Pointer to an int, into which the number of    */
/*             characters used to get the returned width is   */
/*             placed. Any trailing spaces are skipped past   */
/*             and included in this returned value;           */
/*                                                            */
/*             Pointer to an int, into which the calculated   */
/*             width (in millipoints) is placed.              */
/*                                                            */
/* Assumes:    The two int pointers may be NULL.              */
/**************************************************************/

_kernel_oserror * fm_get_string_width
                  (
                    fm_face               h,
                    const char *          s,
                    int                   maxwid,
                    int                   maxbytes,
                    int                   split,
                    int        * restrict bytes,
                    int        * restrict width
                  )
{
  int retwidth = 0;
  int retbytes = 0;

  /* Now have to do some real work. */

  if (h >= 0)
  {
    /* The outline font case */

    _kernel_oserror * e = NULL;
    int               buffer[9];
    int               reached;

    /* For Font_ScanString, negative values of maxwid will  */
    /* produce a positive return as it copes with RTL text. */
    /* We don't want this, so skip the call if maxwid <= 0. */

    #ifdef UNIFONT
      _swix(Font_WideFormat, _INR(0,1), h, 12);
    #endif

    if (maxwid > 0)
    {
      buffer[0] = buffer[1] = buffer[2] = buffer[3] = 0;
      buffer[4] = split;

      e = _swix(Font_ScanString,
                _INR(0,5) | _IN(7) | _OUT(1) | _OUT(3),

                h,
                s,
                FM_GivenLength | FM_GivenBuffer | FM_Kern | FM_GivenHandle,
                maxwid,
                0x1000000,
                buffer,
                maxbytes,

                &reached,
                &retwidth);

      if (!e) retbytes = reached - ((int) s);

//      #ifdef TRACE
//        {
//          int wi, by;
//
//          e = _swix(Font_SetFont,_IN(0),h);
//
//          if (!e) e = _swix(Font_StringWidth,
//                            _INR(1,5) | _OUT(2) | _OUT(5),
//
//                            s,         /* String to find width of                   */
//                            maxwid,    /* Maximum width if splitting is allowed     */
//                            0x1000000, /* Maximum height if splitting is allowed    */
//                            split,     /* Character to split on, or -1 for no split */
//                            maxbytes,  /* Maximum string length                     */
//
//                            &wi,       /* Width of scanned string                   */
//                            &by);      /* Length of scanned string                  */
//
//          if (abs(wi - retwidth) > 2000 || by != retbytes)
//          {
//            dprintf(("Font", "fm_get_string_width: Width/Bytes mismatch in first call...\n"));
//            dprintf(("Font", "                     Font_ScanString  -> %d, %d\n", retwidth, retbytes));
//            dprintf(("Font", "                     Font_StringWidth -> %d, %d\n", wi, by));
//          }
//        }
//      #endif
    }

    /* If there was no error, a split character was specified */
    /* but the width is zero, the Font Manager did not find a */
    /* split char before the maximum width given to it was    */
    /* exceeded. We want to be able to spill over in this     */
    /* case, so recall the Font_StringWidth in a non-         */
    /* splitting mode, but only look as far as the first      */
    /* split char (if any) to allow the string to still split */
    /* up. This keeps the width as small as possible, even    */
    /* though individual words are wider than the space we    */
    /* had hoped to fit them into.                            */

    if (!e && !retwidth && split > 0)
    {
      const char * p = s;

      /* Scan only as far as the first split character.         */
      /*                                                        */
      /* Thanks to Tony Cheal for spotting this when doing      */
      /* tables stuff - the original Customer browser sources  */
      /* recognised 'some problem' with Font_StringWidth but    */
      /* didn't then allow any sort of splitting in this part   */
      /* of the code.                                           */

      while (*p && *(p++) != split);

      /* Now call the Font Manager without asking for a split, knowing that */
      /* the string length only runs up to the split character.             */

      _swix(Font_ScanString,
            _INR(0,4) | _IN(7) | _OUT(3),

            h,
            s,
            FM_GivenLength | FM_Kern | FM_GivenHandle,
            0x1000000,
            0x1000000,
            p - s,

            &retwidth);

      retbytes = p - s;

//      #ifdef TRACE
//        {
//          int wi, by;
//
//          _swix(Font_StringWidth,
//                _INR(1,5) | _OUT(2) | _OUT(5),
//
//                s,            /* String to find width of                   */
//                0x1000000,    /* Maximum width if splitting is allowed     */
//                0x1000000,    /* Maximum height if splitting is allowed    */
//                -1,           /* Character to split on, or -1 for no split */
//                p - s,        /* String length                             */
//
//                &wi,          /* Width of scanned string                   */
//                &by);         /* Length of scanned string                  */
//
//          if (abs(wi != retwidth) > 2000 || by != retbytes)
//          {
//            dprintf(("Font", "fm_get_string_width: Width/Bytes mismatch in second call...\n"));
//            dprintf(("Font", "                     Font_ScanString  -> %d, %d\n", retwidth, retbytes));
//            dprintf(("Font", "                     Font_StringWidth -> %d, %d\n", wi, by));
//          }
//        }
//      #endif
    }

    /* Exit if there was some error */

    if (e) return e;

    /* Include any trailing spaces in the byte count */

    while (retbytes < maxbytes && s[retbytes] == ' ') retbytes++;
  }
  else
  {
    /* The system font case. */

    int wCurr, wLastSplit, oLastSplit, oCurr;

    /* (Macro defined in FontManage.h). Important that we take */
    /* account of rounding correctly - compare with formula in */
    /* fm_puts().                                              */

    int wChar = (FM_System_Size_X(h) * 10 / (128 * wimpt_dx())) * wimpt_dx() * 400;

    wCurr = wLastSplit = oLastSplit = oCurr = 0;

    /* Whilst the byte counter is less than maxbytes and the width */
    /* calculated so far is less than maxwidth, or we haven't      */
    /* found a split character yet, go through adding              */
    /* the width of a character to the width total for each char   */
    /* of the string. If a split character is met during this, set */
    /* oLastSplit and wLastSplit to the byte counter and thus far  */
    /* calculated width at that point.                             */

    while (
            oCurr < maxbytes &&
            (
              (wCurr <= (unsigned) maxwid) ||
              (split > 0) && !oLastSplit
            )
          )
    {
      #ifdef UNIFONT
        UCS4 ucs;
      #endif

      if ((split > 0) && (s[oCurr] == split))
      {
        oLastSplit = oCurr;
        wLastSplit = wCurr;
      }

      #ifdef UNIFONT
        oCurr += UTF8_to_UCS4(s + oCurr, &ucs);
        wCurr += unifont_widechar(ucs) ? wChar * 2 : wChar;
      #else
        wCurr += wChar;
        oCurr ++;
      #endif
    }

    /* If the current width is greater than the maximum width and there is */
    /* a split point, go back to that last split point.                    */

    if ((wCurr > (unsigned) maxwid) && oLastSplit)
    {
      oCurr = oLastSplit;
      wCurr = wLastSplit;
    }

    /* Include any trailing spaces in the byte count */

    while ((oCurr < maxbytes) && (s[oCurr] == ' ')) oCurr++;

    retbytes = oCurr;
    retwidth = wCurr;
  }

  if (bytes) *bytes = retbytes;
  if (width) *width = retwidth;

  return NULL;
}

/**************************************************************/
/* fm_token_font_info()                                       */
/*                                                            */
/* Looks at a token and returns information on the best font  */
/* to use with it, e.g. bold, italic, a typeface number, etc. */
/*                                                            */
/* The returned typeface number is based on the array of      */
/* typeface names defined at the top of this file (called     */
/* redraw_faces).                                             */
/*                                                            */
/* Parameters: Pointer to the HStream struct (token) of       */
/*             interest;                                      */
/*                                                            */
/*             Address of an int into which the typeface      */
/*             number is placed;                              */
/*                                                            */
/*             Address of an int into which the font size to  */
/*             use is returned (in 16ths of a point);         */
/*                                                            */
/*             Address of an int into which 1 is placed if    */
/*             italics should be used (else 0 is returned);   */
/*                                                            */
/*             Address of an int into which 1 is placed if    */
/*             bold should be used (else 0 is returned).      */
/**************************************************************/

void fm_token_font_info
     (
       const HStream * restrict t,
       int           * restrict facenum,
       int           * restrict size,
       int           * restrict italic,
       int           * restrict bold
     )
{
  int flags;

  flags = t->style;

  *facenum = 0; /* 0 = Serif */
  *bold    = 0;
  *italic  = 0;

  /* May want to scale the size for certain tag types */

  if (ISSUP(t) || ISSUB(t)) *size = (choices.font_size * 3) / 5;
  else                      *size = choices.font_size;

  /* Scale the size according to the font size specifier */
  /* in the token                                        */

  #ifdef TRACE
    if (t->fontsize < 1 || t->fontsize > 7)
    {
      dprintf(("Font", "fm_token_font_info: fontsize '%d' out of range\n",t->fontsize));
    }
  #endif

  *size += fm_size(t->fontsize) - choices.font_size;

  /* Set font details according to specific tags */
  /* (or any header, with H_MASK). The macros    */
  /* defined in HTMLLib/tags.h.                  */

  if (flags & (ITALIC | BLOCKQUOTE)) *italic  = 1;
  if (flags & (BOLD   | DT))         *bold    = 1;

  if (flags & (H_MASK | ADDRESS))    *facenum = 1; /* 1 = Sans serif */
  if (flags & (PRE    | TT))         *facenum = 2; /* 2 = Monospaced */

  /* Set bold, italic and size details according  */
  /* to the header level (if the token represents */
  /* header information, that is).                */

  switch (redraw_header(flags))
  {
    case 1: *bold = 1, *size *= 2;              break;
    case 2: *bold = 1, *size = (*size * 8) / 5; break;
    case 3: *bold = 1, *size = (*size * 3) / 2; break;
    case 4: *bold = 1, *size = (*size * 4) / 3; break;
    case 5: *bold = 1, *size = (*size * 8) / 7; break;
    case 6: *bold = 1;                          break;
  }
}

/**************************************************************/
/* fm_find_token_font()                                       */
/*                                                            */
/* Returns an appropriate RISC OS font handle in which the    */
/* contents of a given token should be rendered, optionally   */
/* recording the usage in a given browser_data structure.     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the font (may be NULL for a non-browser        */
/*             specific font claim);                          */
/*                                                            */
/*             Pointer to the HStream struct (token) to find  */
/*             the font for;                                  */
/*                                                            */
/*             1 to ignore bold and italic flags and just     */
/*             find plain text, else 0.                       */
/**************************************************************/

fm_face fm_find_token_font
        (
          browser_data  * restrict b,
          const HStream * restrict t,
          int                      ignore_styles
        )
{
  int facenum, size, bold, italic;

  /* Get the recommended font */

  fm_token_font_info(t, &facenum, &size, &italic, &bold);

  if (ignore_styles) facenum = italic = bold = 0;

  /* Return the font handle - note that the typeface name is */
  /* passed to the font managing routines by looking up the  */
  /* typeface number in the redraw_faces array defined at    */
  /* the top of this file, and that 100% aspect ratio is     */
  /* always used due to 'size' being passed in for both the  */
  /* x and y sizes of the font.                              */

  if (facenum == 2) return fm_find_font(b, fm_faces[facenum], (size * choices.tt_aspect) / 100, size, italic, bold);
  else              return fm_find_font(b, fm_faces[facenum], size,                             size, italic, bold);
}
@


1.33
log
@  Huge pile of changes bringing relatively ancient sources up to date.
Detail:
  This check-in includes Phoenix version 2.11 (26-Apr-2005); only the
  debug and JavaScript builds of Phoenix have been tested and resources
  will definitely be out of date for other versions. The various "!..."
  scripts have been updated to require a minimum of 2MB with no maximum
  limit for building, as CC 5.60 is quite RAM hungry.
Admin:
  Phoenix 2.11 JS builds OK, works reasonably well. Many outstanding
  issues of course, as this is a very outdated browser now.

Version 2.09. Tagged as 'Browse-2_09'
@
text
@d209 1
a209 1
fm_typeface * fm_find_typeface(char * name)
d335 1
a335 1
_kernel_oserror * fm_define_typeface(char * description)
d338 1
a338 1
  char        * p = description;
d602 9
a610 1
fm_face fm_find_font(browser_data * b, char * name, int xsize, int ysize, int italic, int bold)
d701 1
a701 1
void fm_lose_font(browser_data * b, fm_face h)
d733 1
a733 1
void fm_lose_fonts(browser_data * b)
d754 1
a754 1
_kernel_oserror * fm_rescale_fonts(browser_data * b)
d877 1
a877 1
_kernel_oserror * fm_font_box(fm_face h, BBox * box)
d907 1
a907 1
    // this probably needs to a char by char scan of the font and cache the result
d937 1
a937 1
_kernel_oserror * fm_char_box(fm_face h, char c, BBox * box)
d1008 1
a1008 1
                            fore,    /* Palette entry */
d1042 1
a1042 1
/* Parameters: A RISC OS font handle;                         */
d1052 20
a1071 3
/*             1 to use font blending, else 0 - do NOT use    */
/*             font blending on a Font Manager earlier than   */
/*             v3.37!                                         */
d1073 47
d1121 3
a1123 3
_kernel_oserror * fm_puts(fm_face h, int x, int y, const char * s, int os, int blend)
{
  dprintf(("Font", "\nfm_puts: Called with handle %p\n         String '%s'\n",(void *) h, s));
d1127 1
a1127 1
    /* System font output */
d1129 1
a1129 1
    int xs,ys;
d1141 6
a1146 8
    bbc_vduq(23,
             17,
             7,
             6,
             xs & 255,
             xs >> 8,
             ys & 255,
             ys >> 8,
d1158 17
a1174 1
      unifont_write0(s, x, y + (FM_System_Size_Y(h) * (10*13) / (64*16)) - 1, xs, ys);
d1176 4
a1179 1
      _swix(OS_Write0, _IN(0), s);
d1185 6
a1190 8
    bbc_vduq(23,
             17,
             7,
             6,
             16 / wimpt_dx(),
             0,
             32 / wimpt_dy(),
             0,
d1194 1
a1194 1
    return NULL;
d1226 2
a1227 1
        unsigned char * scan = (unsigned char *) s;
d1229 1
a1229 1
        while (*scan)
d1231 4
a1234 2
          if (*scan < 32 && *scan != 10 && *scan != 13) dprintf(("Font", "fm_puts: Warning, non-CR/LF control char %d in string\n",(unsigned int) *scan));
          scan ++;
d1237 1
a1237 1
        dprintf(("Font", "fm_puts: Calling Font_Paint prior to exiting\n"));
d1245 4
a1248 4
               (FM_GivenHandle) |
               (FM_Kern)        |

               (os ? FM_OSUnits : 0)
d1263 3
a1265 1
                 NULL,NULL,0);
a1269 45
/* fm_putsl()                                                 */
/*                                                            */
/* As fm_puts above, but takes an extra parameter after the   */
/* string pointer which says how many characters of the       */
/* string should be plotted.                                  */
/*                                                            */
/* This will *write a character into the string* during       */
/* operation, so the string must be owned by the caller and   */
/* not in ROM.                                                */
/*                                                            */
/* Parameters: As fm_puts above, but after the pointer to the */
/*             string to output, pass the number of           */
/*             characters in the string that will be plotted. */
/**************************************************************/

_kernel_oserror * fm_putsl(fm_face handle, int x, int y, char * s, int chars, int os, int blend)
{
  char              c;
  _kernel_oserror * e = NULL;

  /* If chars doesn't point past the end of the */
  /* string, then forcibly terminate it and     */
  /* call fm_puts. Restore the character that   */
  /* the terminator wrote over whther or not    */
  /* there is an error.                         */

  if (s[chars] != '\0')
  {
    c        = s[chars];
    s[chars] = '\0';

    e = fm_puts(handle,x,y,s,os,blend);

    s[chars] = c;
  }

  /* If the number of chars is longer than the */
  /* string, plot as much as there is of it.   */

  else e = fm_puts(handle,x,y,s,os,blend);

  return e;
}

/**************************************************************/
d1282 1
a1282 1
_kernel_oserror * fm_write_descriptor(char * name, char * buffer)
d1334 1
a1334 1
_kernel_oserror * fm_write_name(int number, char * buffer, int italic, int bold)
d1340 1
a1340 1
  if (number < 0 || number >= sizeof(fm_faces))
d1387 121
d1518 1
a1518 1
_kernel_oserror * fm_read_typeface(fm_typeface * face)
d1704 2
a1705 1
/*             Maximum width to allow if splitting the line;  */
d1724 10
a1733 2
_kernel_oserror * fm_get_string_width(fm_face h, const char * s, int maxwid, int maxbytes,
                                      int split, int * bytes, int * width)
d1979 8
a1986 1
void fm_token_font_info(HStream * t, int * facenum, int * size, int * italic, int * bold)
d1993 2
a1994 2

  *bold    = *italic = 0;
a2007 1
      t->fontsize = 3;
d2019 1
a2020 1

d2056 6
a2061 1
fm_face fm_find_token_font(browser_data * b, HStream * t, int ignore_styles)
@


1.32
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d986 1
a986 1
_kernel_oserror * fm_set_font_colour(fm_face h, int fore, int back)
@


1.31
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a42 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d250 1
a250 3
  #ifdef TRACE
    if (tl & (1u<<12)) Printf("fm_new_typeface: malloc %d for 'fm_facelist' structure\n",sizeof(fm_facelist));
  #endif
d258 1
a258 1
      if (tl & (1u<<13)) Printf("** malloccount (fm_new_typeface): \0211%d\0217\n",malloccount);
d1051 1
a1051 3
  #ifdef TRACE
    if (tl & (1u<<10)) Printf("\nfm_puts: Called with handle %p\n         String '%s'\n",(void *) h, s);
  #endif
a1137 1
      if (tl & (1u<<10))
d1143 1
a1143 1
          if (*scan < 32 && *scan != 10 && *scan != 13) Printf("fm_puts: Warning, non-CR/LF control char %d in string\n",(unsigned int) *scan);
d1147 1
a1147 1
        Printf("fm_puts: Calling Font_Paint prior to exiting\n");
d1404 1
a1404 1
      if (tl & (1u<<12)) Printf("fm_destroy_typefaces: free block %p, which held 'fm_facelist' structure\n",c);
d1406 1
a1406 1
      if (tl & (1u<<13)) Printf("** malloccount (fm_destroy_typefaces): \0212%d\0217\n",malloccount);
d1620 3
a1622 3
//            Printf("fm_get_string_width: Width/Bytes mismatch in first call...\n");
//            Printf("                     Font_ScanString  -> %d, %d\n", retwidth, retbytes);
//            Printf("                     Font_StringWidth -> %d, %d\n", wi, by);
d1688 3
a1690 3
//            Printf("fm_get_string_width: Width/Bytes mismatch in second call...\n");
//            Printf("                     Font_ScanString  -> %d, %d\n", retwidth, retbytes);
//            Printf("                     Font_StringWidth -> %d, %d\n", wi, by);
d1823 1
a1823 1
      if (tl & (1u<<10)) Printf("fm_token_font_info: fontsize '%d' out of range\n",t->fontsize);
@


1.30
log
@Everyone else seems to be checking lots of stuff in lately, so I've
decided to join in. This is an intermediate check-in and so not all
resources etc. will be up to date. You should be able to make Phoenix
and a debug build out of it. As a reminder, to make a JavaScript build:

 * Build JSLib and NSPRLib. Recommend you leave -DUSEMEMLIB in there (as
   used by default) so you can watch it leak into a dynamic area... :-)
   If you do this, you'll need to build MemLib too, of course. If you
   do NOT use MemLib, *undefine JS_USING_MEMLIB in Main.c*!
 * Run !MkClean. This now strips dynamic dependencies from the MakeFile
   automatically, to save you having to do it yourself.
 * Run one of the TaskObey files with the "J" suffix, e.g. !DeskBrwsJ -
   this uses the same .o directory for object files and exports to the
   same position in the Targets directory as the non-JavaScript build,
   but it does produce a unique binary in 'abs' and symbols table in
   'syms'.
 * Sourcing an appropriate !Run (with increased WimpSlot value), !Boot
   and About resource is done automatically.
 * Some, but not all of the !xxxD (debug) TaskObey files will make
   JavaScript versions in passing - check the JSUFFIX value on the Make
   command line parameters in the file.

This'll only work on RISC OS 3.1 due to the use of MemLib.

Here's the change list:

Included MNG icons in sprites files; added Sprites23 for some builds.
Added in ANT URL file icon (b28) derived from URI file icon, because
the Save dialogue can need it.

No, you do *not* need to define the same keyboard shortcuts in each
frame since the ancestor keeps the input focus and we've basically
dropped non-nested Wimp support. Maintaining no less than 4 lists of
identical shortcuts was a pain. Some Res files now only have the
lists in the main browser window and button bar objects (these two
are both required still).

Ursula build Markers button arrangement changed from 1x3 horizontal to
2x2 tilted, as in Phoenix, by popular demand.

Couple of hotlist bugs fixed; dragging an item and deleteing it with
Ctrl+X didn't terminate the drag, and deleteting an item underneath a
menu opened for it didn't close the menu.

'SendReferer' option added to all Choices files, all set to 'always'.
Put just beneath 'Clone' as it refers to header items, though really,
both Clone and SendReferer should probably be in the "Fetch controls"
section rather than "Multiuser environments and proxying"! Front-end
control of this is available.

In image_export_original, save_save_source, save_transfer_source and
save_save_object, flex_set_budge(0) was called to lock the heap but the
return value wasn't stored. flex_set_budge(1) was then used to unlock
the heap. All calls now remember and restore the old value, which is
both safer in case one calls another and allows the flex_set_budge
call in Main.c to have an application-wide meaning, as intended.

Some restructuring to the data load and RAM transfer sections of
Protocols.c; remote hotlist builds wouldn't allow files to be loaded
to browser windows before, and can now drop URL, URI or text files to
the Open URL dialogue.

New option "MinimumFontSize", lets the 'size' attribute of the 'font'
element be overridden. Default value is 1, to allow the full range of
values for the attribute. Setting to 7, for example, would give font
size 7 text at all times. Another new option, "ToggleOnXOnly", to
make Toggle Size only extend the window vertically (with Ctrl then
being used to toggle to genuine full size, rather than vice versa).
All Choices files updated to hold both of these options; only the
first has front-end control available (see debug build Res file).

JavaScript Document object exists; frames array etc. working. Can now
just about use "http://www.acorn.com/~ahodgkin/jschain/" but it does
abort after a bit - problems with frames again, I suspect. Is is pretty
slow, too. Can now press Escape to terminate a script.

Main.c erroneously referred to Controls file entry "StopWebServe" as
"StopWebProxy". Fixed.

Keyboard shortcuts to raise SaveFile are now possible in a general sense;
the code before was in the ToBeShown handler and just checked for a parent
component of -1. It then assumed "save frame HTML source". Now there's the
savefile_raise_from_shortcut function, which together with the seven new
event codes in SaveFile.h allows saving of HTML source and frame location,
export of links, images, backgrounds and the page as text or draw, to all
be invoked by keyboard shortcuts. Some Res files have some of these defined.

In reformat_check_height, the first check to see if setpara should be set
references a field in tpLast without checking if it is NULL. Whilst the
'line > 0' check should mean that tpLast wasn't NULL anyway, a direct
call to the function from outside of the reformatter might have tripped
up on this - the check for tpLast != NULL is now made.

Adjust-click on close icon in window showing file: URL attempts to open
the parent Filer window.

Reformatter used to try and find a selectable token if keyboard control
was enabled in a really stupid place - could make reformatting become
very slow if no selectables were present, especially if the page had a
few tables on it. Preprocessor now does this (since it goes through all
of the tokens anyway), the reformatter just doing a last check to ensure
no frames have obscured the selectable and if so, it tries to move it.
Done in the reformatter as generating a line array implies the data really
is visible.

Ctrl+Tab URL completion now builds a full list of matches from the hotlist
and history and can cycle through them (Ctrl+Shift+Tab stepping backwards).

Will give a real error rather than just "Data Abort" if it goes wrong
now. Someone somewhere is setting bit 30 of the error which confused
the replacement signal handler. Flag bits are now masked off (as they
should've been to start with).
@
text
@d15 13
a27 14
/***************************************************/
/* File   : FontManage.c                           */
/*                                                 */
/* Purpose: A range of font management veneers.    */
/*                                                 */
/* Author : Merlyn Kline for Customer browser     */
/*          This source adapted by A.D.Hodgkinson  */
/*                                                 */
/* History: 05-Dec-96: Created.                    */
/*          14-Apr-97: Merged in a bug fix to      */
/*                     fm_get_string_width spotted */
/*                     by T.Cheal (see source for  */
/*                     more info).                 */
/***************************************************/
d35 2
a36 1
#include "swis.h"
d38 1
a38 1
#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */
d40 7
a46 2
#include "wimp.h"
#include "event.h"
a47 1
#include "svcprint.h"
d60 2
a61 2
  #include "Unicode/iso10646.h"
  #include "Unicode/utf8.h"
d198 15
a212 17
/*************************************************/
/* fm_find_typeface()                            */
/*                                               */
/* Goes through the linked list of fm_facelist   */
/* structures looking for one which is named,    */
/* returning the address of the fm_typeface      */
/* structure containing that name if it is found */
/* (or NULL if not). The name should be in lower */
/* case charaters.                               */
/*                                               */
/* Parameters: A pointer to a string holding the */
/*             name of the typeface to find, in  */
/*             lower case.                       */
/*                                               */
/* Returns:    Pointer to the fm_typeface struct */
/*             if found, else NULL.              */
/*************************************************/
d237 11
a247 11
/*************************************************/
/* fm_new_typeface()                             */
/*                                               */
/* Adds a new typeface to the list of typefaces. */
/* Returns a pointer to the fm_typeface struct   */
/* itself, when added, or NULL if the malloc     */
/* claim failed (so error check this externally) */
/*                                               */
/* Returns:    Pointer to the new fm_typeface    */
/*             struct, or NULL if malloc failed. */
/*************************************************/
d283 14
a296 17
/*************************************************/
/* fm_define_typeface_explicit()                 */
/*                                               */
/* Adds a new fm_facelist structure to the list  */
/* of fm_facelist structures, but also names     */
/* the new typeface and only allocates a new     */
/* list item if one of the same name wasn't      */
/* already present.                              */
/*                                               */
/* Parameters: A pointer to an fm_typeface       */
/*             structure, in which only the      */
/*             'name' field is filled in. This   */
/*             becomes the name for the new      */
/*             typeface and is used to check if  */
/*             a typeface of that name is        */
/*             already present.                  */
/*************************************************/
d331 10
a340 11
/*************************************************/
/* fm_define_typeface()                          */
/*                                               */
/* This function defines a whole new typeface in */
/* full, according to a description string the   */
/* format of which is described in Merlyn's      */
/* comments at the top of this file.             */
/*                                               */
/* Parameters: A pointer to a string containing  */
/*             the typeface description.         */
/*************************************************/
d424 6
a429 7
/*************************************************/
/* fm_define_default_typefaces()                 */
/*                                               */
/* Sets up the default typeface settings, for    */
/* system, fixed space, sans serif and serif     */
/* font 'banks'.                                 */
/*************************************************/
d443 8
a450 9
/*************************************************/
/* fm_claim_basic_typefaces()                    */
/*                                               */
/* Claim a few basic fonts which will probably   */
/* be needed for the duration of the application */
/* run time.                                     */
/*                                               */
/* Parameters: Base font size to claim at.       */
/*************************************************/
d489 25
a513 29
/*************************************************/
/* fm_sub_find_font()                            */
/*                                               */
/* When asked for a standard, italic, bold or    */
/* bold italic variant of a typeface, this will  */
/* return the font handle for the requested font */
/* or -1 if it can't be found. The routine       */
/* will try for just a standard or bold variant  */
/* if an italic or bold italic variant isn't     */
/* defined, then drop to just standard, before   */
/* giving up.                                    */
/*                                               */
/* Parameters: Pointer to the fm_typeface struct */
/*             for the typeface in question;     */
/*                                               */
/*             The X and Y sizes, in 1/16ths of  */
/*             a point, of the font to claim;    */
/*                                               */
/*             1 to specify italics, else 0;     */
/*                                               */
/*             1 to specify bold, else 0.        */
/*                                               */
/* Returns:    The RISC OS font manager's font   */
/*             handle for the requested font (as */
/*             an fm_face) or -1 if the font     */
/*             couldn't be found either by this  */
/*             routine, or by the font manager   */
/*             itself.                           */
/*************************************************/
d563 11
a573 12
/*************************************************/
/* fm_size()                                     */
/*                                               */
/* Given an abstracted font size (from 1 to 7,   */
/* with 3 being 'base font' size), returns the   */
/* actual size (in 16ths of a point) to use.     */
/*                                               */
/* Parameters: The font size, from 1 to 7.       */
/*                                               */
/* Returns:    The equivalent font size, in      */
/*             16ths of a point.                 */
/*************************************************/
d583 25
a607 27
/*************************************************/
/* fm_find_font()                                */
/*                                               */
/* Returns the font handle of a requested        */
/* typeface variant, optionally recording the    */
/* usage in a given browser_data structure.      */
/*                                               */
/* Parameters: Pointer to the browser_data       */
/*             struct relevant to the font;      */
/*                                               */
/*             Pointer to the typeface name;     */
/*                                               */
/*             X and Y sizes in 16ths of a pt;   */
/*                                               */
/*             1 for italics, 0 for not italic;  */
/*                                               */
/*             1 for bold, 0 for not bold.       */
/*                                               */
/* Returns:    A RISC OS font handle for the     */
/*             requested font or the closest     */
/*             available match to it; this may   */
/*             be the system font if no good     */
/*             match could be found.             */
/*                                               */
/* Assumes:    The browser_data struct pointer   */
/*             may be NULL.                      */
/*************************************************/
d681 18
a698 20
/*************************************************/
/* fm_lose_font()                                */
/*                                               */
/* Forgets about the usage of a given font by a  */
/* given browser, and if there are no users at   */
/* this point, tell the RISC OS Font Manager     */
/* that the font is no longer in use.            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the font;             */
/*                                               */
/*             The RISC OS font handle for the   */
/*             font to forget.                   */
/*                                               */
/* Assumes:    The pointer to the browser_data   */
/*             struct *may* be NULL, in which    */
/*             case the RISC OS Font Manager is  */
/*             told the font isn't needed        */
/*             straight away.                    */
/*************************************************/
d720 11
a730 12
/*************************************************/
/* fm_lose_fonts()                               */
/*                                               */
/* Forgets about the usage of all fonts used by  */
/* a given browser, and if there are no longer   */
/* any users of any of the fonts, tells the      */
/* RISC OS Font Manager that those fonts are no  */
/* longer in use.                                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the fonts.            */
/*************************************************/
d742 10
a751 11
/*************************************************/
/* fm_rescale_fonts()                            */
/*                                               */
/* For all currently claimed fonts, reclaim them */
/* with the current screen DPI. Useful for (say) */
/* mode changes, when the Desktop scaling may    */
/* have changed.                                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the fonts to rescale. */
/*************************************************/
d863 12
a874 13
/*************************************************/
/* fm_font_box()                                 */
/*                                               */
/* Gets a bounding box large enough to cover any */
/* character in a given font, in OS units.       */
/*                                               */
/* Parameters: RISC OS font handle of the font;  */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             bounding box is placed (min X and */
/*             Y are inclusive, max X and Y are  */
/*             exclusive).                       */
/*************************************************/
d922 13
a934 14
/*************************************************/
/* fm_char_box()                                 */
/*                                               */
/* Gets the bounding box of a char, in OS units. */
/*                                               */
/* Parameters: RISC OS font handle of the font;  */
/*                                               */
/*             Character to measure;             */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             bounding box is placed (min X and */
/*             Y are inclusive, max X and Y are  */
/*             exclusive).                       */
/*************************************************/
d976 16
a991 17
/*************************************************/
/* fm_set_font_colour()                          */
/*                                               */
/* Sets the font colour for subsequent painting. */
/*                                               */
/* Parameters: The RISC OS font handle of the    */
/*             font in question;                 */
/*                                               */
/*             The foreground colour;            */
/*                                               */
/*             The background colour.            */
/*                                               */
/*             Colours are As palette entries,   */
/*             i.e. are in the form BBGGRRcc     */
/*             where cc = GCOL, else use the Red */
/*             Green and Blue bytes.             */
/*************************************************/
d1034 21
a1054 24
/*************************************************/
/* fm_puts()                                     */
/*                                               */
/* Outputs a string in a given font at specified */
/* coordinates in a colour determined by calls   */
/* to fm_set_font_colour() prior to calling this */
/* function.                                     */
/*                                               */
/* Parameters: A RISC OS font handle;            */
/*                                               */
/*             X and Y coordinates of the bottom */
/*             left of the bounding box of the   */
/*             plotted string. These may be in   */
/*             OS units or millipoints (see      */
/*             below);                           */
/*                                               */
/*             Pointer to the string to output;  */
/*                                               */
/*             1 if using OS coords, else 0;     */
/*                                               */
/*             1 to use font blending, else 0 -  */
/*             do NOT use font blending on a     */
/*             Font Manager earlier than v3.37!  */
/*************************************************/
d1187 15
a1201 17
/*************************************************/
/* fm_putsl()                                    */
/*                                               */
/* As fm_puts above, but takes an extra          */
/* parameter after the string pointer which says */
/* how many characters of the string should be   */
/* plotted.                                      */
/*                                               */
/* This will *write a character into the string* */
/* during operation, so the string must be owned */
/* by the caller and not in ROM.                 */
/*                                               */
/* Parameters: As fm_puts above, but after the   */
/*             pointer to the string to output,  */
/*             pass the number of characters in  */
/*             the string that will be plotted.  */
/*************************************************/
d1232 12
a1243 12
/*************************************************/
/* fm_write_descriptor()                         */
/*                                               */
/* Writes the descriptor string for a typeface   */
/* into a given buffer.                          */
/*                                               */
/* Parameters: Pointer to the typeface name;     */
/*                                               */
/*             Pointer to the buffer.            */
/*                                               */
/* Assumes:    That the buffer is big enough.    */
/*************************************************/
d1280 16
a1295 17
/*************************************************/
/* fm_write_name()                               */
/*                                               */
/* Writes the RISC OS font name for a given      */
/* typeface variant to a given buffer            */
/*                                               */
/* Parameters: Typeface number from the fm_faces */
/*             array;                            */
/*                                               */
/*             Pointer to the buffer;            */
/*                                               */
/*             1 for italics, else 0;            */
/*                                               */
/*             1 for bold, else 0.               */
/*                                               */
/* Assumes:    That the buffer is big enough.    */
/*************************************************/
d1349 10
a1358 12
/*************************************************/
/* fm_read_typeface()                            */
/*                                               */
/* Given a typeface name inside an fm_typeface   */
/* structure, the rest of the typeface details   */
/* are filled in. If the typeface name isn't     */
/* found an error will be raised.                */
/*                                               */
/* Parameters: A pointer to the fm_typeface with */
/*             the name to look up inside its    */
/*             'name' field.                     */
/*************************************************/
d1388 6
a1393 6
/*************************************************/
/* fm_destroy_typefaces()                        */
/*                                               */
/* Destroys *all* typeface records, therefore    */
/* emptying the list of typefaces.               */
/*************************************************/
d1427 11
a1437 12
/*************************************************/
/* fm_set_system_font()                          */
/*                                               */
/* Sets the static local flag to say that system */
/* fonts only should be used for font handling.  */
/* This will only affect any fonts claimed with  */
/* e.g. fm_find_font after this function has     */
/* been called.                                  */
/*                                               */
/* Parameters: 1 to use system font, 0 to allow  */
/*             outline fonts.                    */
/*************************************************/
d1444 9
a1452 10
/*************************************************/
/* fm_system_font()                              */
/*                                               */
/* Returns 1 if the font library is currently    */
/* using system font for any new font finds, or  */
/* 0 if outline fonts are allowed. This is       */
/* intended for external callers only (it is     */
/* faster to use the fm_systemfont variable      */
/* directly in internal routines).               */
/*************************************************/
d1459 13
a1471 14
/*************************************************/
/* fm_init()                                     */
/*                                               */
/* Initialises the library for use.              */
/*                                               */
/* Parameters: 1 if the library is to only use   */
/*             the system font from the outset,  */
/*             or 0 to allow outline fonts;      */
/*                                               */
/*             The 'base font' size, if going    */
/*             to use the fm_size function to    */
/*             allow an abstracted font size     */
/*             selection method (see fm_size).   */
/*************************************************/
d1480 8
a1487 9
/*************************************************/
/* fm_init_sizes()                               */
/*                                               */
/* Sets up the size array for FONT SIZE=xxx and  */
/* related attributes, based on the given base   */
/* font size.                                    */
/*                                               */
/* Parameters: The 'base font' size.             */
/*************************************************/
d1504 8
a1511 9
/*************************************************/
/* fm_shutdown()                                 */
/*                                               */
/* Tells the RISC OS Font Manager that all fonts */
/* currently marked as used in fm_handles are    */
/* not needed regardless of the internal usage   */
/* counter therein, and resets those counters to */
/* zero.                                         */
/*************************************************/
d1527 37
a1563 44
/*************************************************/
/* fm_get_string_width()                         */
/*                                               */
/* Given a string, and the number of chars to    */
/* consider in that string, work out the width   */
/* of the string. A maximum width can be given,  */
/* and if it is possible to split the string     */
/* (pass the character to split on), the width   */
/* returned will reflect this consideration (but */
/* can still be greater than maxwid, if no split */
/* characters were found for far enough). The    */
/* number of bytes used to work out the final    */
/* returned width is itself returned, though any */
/* trailing spaces are included in this value    */
/* even if they aren't used to get the width.    */
/*                                               */
/* Parameters: The RISC OS font handle to use in */
/*             width calculations;               */
/*                                               */
/*             Pointer to the string to use;     */
/*                                               */
/*             Maximum width to allow if         */
/*             splitting the line;               */
/*                                               */
/*             The maximum number of bytes of    */
/*             string to consider;               */
/*                                               */
/*             The character to split at (such   */
/*             as a space), or -1 for 'don't     */
/*             split';                           */
/*                                               */
/*             Pointer to an int, into which the */
/*             number of characters used to get  */
/*             the returned width is placed. Any */
/*             trailing spaces are skipped past  */
/*             and included in this returned     */
/*             value;                            */
/*                                               */
/*             Pointer to an int, into which the */
/*             calculated width (in millipoints) */
/*             is placed.                        */
/*                                               */
/* Assumes:    The two int pointers may be NULL. */
/*************************************************/
d1786 25
a1810 29
/*************************************************/
/* fm_token_font_info()                          */
/*                                               */
/* Looks at a token and returns information on   */
/* the best font to use with it, e.g. bold,      */
/* italic, a typeface number, etc.               */
/*                                               */
/* The returned typeface number is based on the  */
/* array of typeface names defined at the top of */
/* this file (called redraw_faces).              */
/*                                               */
/* Parameters: Pointer to the HStream struct     */
/*             (token) of interest;              */
/*                                               */
/*             Address of an int into which the  */
/*             typeface number is placed;        */
/*                                               */
/*             Address of an int into which the  */
/*             font size to use is returned (in  */
/*             16ths of a point);                */
/*                                               */
/*             Address of an int into which 1 is */
/*             placed if italics should be used  */
/*             (else 0 is returned);             */
/*                                               */
/*             Address of an int into which 1 is */
/*             placed if bold should be used     */
/*             (else 0 is returned).             */
/*************************************************/
d1842 1
a1842 1
  /* defined in HTMLLib:tags.h.                  */
d1865 17
a1881 19
/*************************************************/
/* fm_find_token_font()                          */
/*                                               */
/* Returns an appropriate RISC OS font handle in */
/* which the contents of a given token should be */
/* rendered, optionally recording the usage in a */
/* given browser_data structure.                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the font (may be NULL */
/*             for a non-browser specific font   */
/*             claim);                           */
/*                                               */
/*             Pointer to the HStream struct     */
/*             (token) to find the font for;     */
/*                                               */
/*             1 to ignore bold and italic flags */
/*             and just find plain text, else 0. */
/*************************************************/
@


1.29
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d61 3
a581 7
/*                                               */
/* Assumes:    For speed, the parameter is not   */
/*             limit checked, so if it falls     */
/*             outside the allowed range the     */
/*             returned value will be undefined  */
/*             and probably very inappropriate   */
/*             for a font size!                  */
d586 3
@


1.28
log
@Not all resources are up to date in this check-in, and documentation
both within source and stuff in 'Docs' is out of date or missing - I
was very pushed for time on this one... Hopefully will do another
'tidy up' check-in before close on Friday; until then, beware of
anything other than the Ursula (Desktop browser) build. Anyway...

Export As Draw done. As part of this, FONT SIZE and SUP / SUB adjustment
of font size is done in fm_token_font_info rather than fm_find_token_font.

Bullets and switches are plotted as indirected sprite items, rather than
indirected text + sprite items - this relied on being in a redraw loop to
pick the sprites up from the local pool (failed during printing).

URI files now have a LF line ending rather than CR... '*' recognised
as an empty field when loading via. RAM transfer now (only worked for
loading from disc before).

Gave placeholder bounding boxes 4 OS units more minimum extra gap
vertically and reduced horizontal addition to this value * 1.5, rather
than * 2 (see reformat_get_placeholder_size).

Background image tiling starts at ymax - h + 4, rather than ymax, so
there isn't the bottom line of pixels from the top tile always present
at the top of the window. The '+4' is for caution's sake.

Can now save a frame's HTML source, that of its parent or its ancestor,
and the same for the URI pointing to those documents - see Menus.h for
the relevant component IDs that should lead to the SaveFile dialogue.

Have hopefully fixed timeout = 0 values (i.e. 'forever') on things
like LinkTo; before, image fetches could override the state (so you'd
only ever see brief flickers of a given URL as the pointer went over
a link).

Save File dialogue will remember the state of option or radio buttons
for a given parent component origin and restore that state when the
dialogue is next opened from the same place (stops turning on saving
as a URL file also turning on 'save background images' for Draw file
export, etc.).

Use of a META tag to reload the *same* page now sets the 'reloading'
flag in the browser so that it doesn't go through a proxy - otherwise
pages which are meant to update periodically through client pull
don't work, as they keep coming out of the cache.

Can now handle images specifying just a width or height in the HTML
(other dimension is scaled accordingly, but note that the placeholder
size must still be 'dumb' until the image data comes in). An image
will now override an image history size entry for the same entry
with a different size.
@
text
@a1186 1
               (FM_Absolute)    |
@


1.27
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d1311 2
a1312 1
/* Parameters: Pointer to the typeface name;     */
d1323 1
a1323 1
_kernel_oserror * fm_write_name(char * name, char * buffer, int italic, int bold)
d1327 19
d1582 1
a1582 1
/*             splitting th line;                */
d1865 18
a1882 1
  *size    = choices.font_size;
a1937 17

  /* Scale the size according to the font size specifier */
  /* in the token                                        */

  #ifdef TRACE
    if (t->fontsize < 1 || t->fontsize > 7)
    {
      if (tl & (1u<<10)) Printf("fm_find_token_font: fontsize '%d' out of range\n",t->fontsize);
      t->fontsize = 3;
    }
  #endif

  size += fm_size(t->fontsize) - choices.font_size;

  /* May want to scale the size for certain tag types */

  if (ISSUP(t) || ISSUB(t)) size = (size * 3) / 5;
@


1.26
log
@Made fm_get_string_width work for system font when the maximum width is
less than the width of the first word.
Corrected width of wide characters to 16 dots not 17.
@
text
@a432 2
  _kernel_oserror * e;

@


1.25
log
@Implemented Message_PlugIn_ReshapeRequest, Message_PlugIn_Status and
Message_PlugIn_Busy. Plug-in code more robust when given invalid
browser instance handles by the plug-in.

Line spacing is now calculated on the basis of the normal style base serif
font, with all other fonts being forced into that line height. This does
mean that an unusually tall (say) sans serif font may get clipped. It
appears to be the only way to get around wildly different baseline
depths returned from the font metrics - you can't work out line spacing
based on each different font style; the line spacing will vary.

Table heighting (as opposed to widthing...) improved considerably; rowspan
can no longer cause very tall cells in odd places. Having trouble getting
rid of the single pixel breaks between vertically adjacent cells, though
I've not tried too hard. Widthing, though, seems fairly badly broken at
present... :-/

Set/clear of page_is_text flag made more robust (it looked as though there
was the potential for this to get stuck in a set state, though I've never
see the front-end behave in a manner which indicates this is the case).
The reformatter will now decrease leading if this flag is set (plain text
pages look daft with a line spacing that is OK for 'rich' text pages).
No reformatting is done if the page width changes by dragging on the
resize icon, though toggle size / full screen will still reformat even
if the contents are only text (browser needs to sort out various width
flags at this point).

Cut down on excessive redrawing when reformatting due to a change in
window dimensions is not done. If display_width hasn't changed, then no
redraw is needed. If this causes redraw problems, then whatever is
changing display_width needs investigating. It shouldn't be kludged
(basically) by forcing a redraw instead of a reformat.

TT/PRE/etc. text can now have a non-100% aspect ratio. 80-90% looks
best (ArcWeb, for example, uses 86%). New option 'TTAspect' in
the Choices files.

Debug builds link to a non-debug Unicode library now; stops stderr
being dumped to the bottom left of the screen if you've not redirected
it in the Run file.

RISC OS 3.1 seems to need more initial WimpSlot than later OS versions.
The 64 deep nested table set gives a 'No stack for trap handler' error
(which it really means in this case!) without 800K, even though 3.71
is happy with just 640K. So, the !Run file checks if Boot$OSVersion
is exactly 300, 310 or 311, and sets the WimpSlot accordingly.

!Run[D] files now require latest fetcher module versions (URL 0.21,
File 0.31, HTTP 0.58).
@
text
@a1747 5
    #ifdef UNIFONT
      int wWidechar = (FM_System_Size_X(h) * 10 / (128 * wimpt_dx())) * 17 / 8 * wimpt_dx() * 400;
    #endif


d1751 2
a1752 1
    /* calculated so far is less than maxwidth, go through adding  */
d1758 7
a1764 1
    while ((oCurr < maxbytes) && (wCurr <= maxwid))
d1778 1
a1778 1
        wCurr += unifont_widechar(ucs) ? wWidechar : wChar;
d1788 1
a1788 1
    if ((wCurr > maxwid) && oLastSplit)
@


1.24
log
@Modified to use external Unicode resource directory and UnicodeLib.
@
text
@d1851 3
a1853 3
  if (flags & (ITALIC|BLOCKQUOTE)) *italic  = 1; /* 1 = Sans serif */
  if (flags & (BOLD  |DT))         *bold    = 1;
  if (flags & (H_MASK|ADDRESS))    *facenum = 1;
d1855 1
a1855 1
  if (flags & (PRE   |TT))         *facenum = 2; /* 2 = Monospaced */
d1881 3
a1883 1
/*             relevant to the font;             */
d1886 1
a1886 1
/*             (token) to find the font for.     */
d1888 2
a1889 2
/* Assumes:    The browser_data struct pointer   */
/*             may be NULL.                      */
d1892 1
a1892 1
fm_face fm_find_token_font(browser_data * b, HStream * t)
d1900 2
d1926 2
a1927 1
  return (fm_find_font(b, fm_faces[facenum], size, size, italic, bold));
@


1.23
log
@Image history - sizes of images are remembered for future reference (if
the sizes aren't specified in the HTML, they can be looked for in the
image history instead to minimise reformatting requirements). Choices
file options ImageHistoryPath, ImageExpiryAge, ImageMaxSize and
SaveImageHistory added to support this (all have a direct analogy to
the global History items of the same name after removing 'Image').

Text area items are now the correct height for the number of rows
specified in the HTML, don't scroll a line too early, and have the
caret placed at the start of the text when moved into from above
or at the end when moved into from below (rather than always at
the end, which was behaviour inherited from single line writables,
where this is desirable). The top of the text area is aligned to
the top of any line of text on the same line, with the text area
dropping below the text, rather than the bottom of the area matching
the text baseline and extending upwards.

Filename extensions for download files are only stripped if an
attempt to convert to a RISC OS filetype through the Mime Mapper module
does not return an error or Data (0xffd) filetype. '.cgi' is a special
case which is always stripped.

Altered heading styles - all are bold, none are italic, H3 is as big
as H2 was, H2 is a little larger, and others scale down to H6 being
the size as normal text (but, as I say, bold).

Sorted out tables and forms. We can just look for tagno=TAG_FORM, and
get rid of the wobbly form_flag; also discarded the redundant
reprocess_table flag in fetch_preprocess_token. Two separate forms
in consecutive table cells (for example) which used to fail - they
were submitted as one single form - will now work correctly.

Fixed nasty bug in FontManage.c where font size 7 would intermittently
fail. The stupid font sizes that it could ask the Font Manager for may
be responsible for the occasional Font Manager crashes that have been
noticed. Array for font sizes was declared as [Limits_FontSizes], but
indices 1 to Limits_FontSizes are actually used - so needed a '+ 1'
in the declaration... :-/

Replaced the case insensitive string comparison functions in Utils.c
with more efficient versions by S.Brodie.

MAXLENGTH specifier in INPUT tags is now supported. If unspecified or
specifically zero, the browser overrides and allows any length.
@
text
@d56 2
a57 2
  #include "iso10646.h"
  #include "utf8.h"
@


1.22
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d187 3
a189 1
int fm_sizes[Limits_FontSizes];
d1860 1
d1863 6
a1868 6
    case 1: *bold   = 1, *size *= 2;              break;
    case 2: *bold   = 1, *size = (*size * 3) / 2; break;
    case 3: *italic = 1, *size = (*size * 4) / 3; break;
    case 4: *bold   = 1, *size = (*size * 4) / 3; break;
    case 5: *bold   = 1;                          break;
    case 6: *italic = 1;                          break;
@


1.21
log
@Added system font option to choices.
Stopped UNIFONT forcing system font use and added calls to Font_WideFormat.
Made sure the system font option is read before fm_init is called!

User agent string now set if Netscape faking is disabled (format used is
"Acorn Browse/1.26 (RISC OS 3.71)".
@
text
@d62 1
a62 1
#define Font_WideFormat 0x400A9
d252 1
a252 1
  f = malloc(sizeof(fm_facelist));
d261 3
a263 5
    /* If the claim succeeded, zero the memory contents, */
    /* link the new item into the list, and return with  */
    /* the address of the fm_typeface structure.         */

    memset(f, 0, sizeof(fm_facelist));
d882 2
a883 1
/* Gets the bounding box of a font, in OS units. */
d975 1
a975 1
    _swix(Font_WideFormat, _INR(0,1), h, 12);
d977 1
d1195 1
a1195 1
    _swix(Font_WideFormat, _INR(0,1), h, 12);
d1606 1
a1606 1
    _swix(Font_WideFormat, _INR(0,1), h, 12);
@


1.20
log
@Weird - the line registering the ENavigateToBeShown event disappeared from
Main.c, so the last log was incorrect; Navigate menu items wouldn't have
been greyed out. Probably a(nother?) CVS update screw up on my part; now
fixed. This sort of thing is happening far too often...

Font manager would crash in system font or if a font face was not found
in the previous release - that hacky business of returning weird font
handles when system font is to be used instead ensured a rather less than
valid array reference on behalf of fm_claim_basic_typefaces.

Added in a few more calls to the 'check the button bar' routines, to
ensure that things like Stop are greyed/ungreyed when needed.

Cellpadding code could lead to rmarg overlapping lmarg, or the sum
being greater than dwidth, or something like that (!) in the reformatter.
Anyway the results were unpleasant; this has been sorted out by range
checking right and left margins w.r.t. display width in the relevant
section of the code.

People who specify 'td width = 2000' in tables expecting to get something
sensible now do, though I was half inclined to leave it alone... I can
only assume that they don't know about % specification or it didn't
work in their browser at authorship time, and the huge width served as
an attempt to get the table to fill the available window width. Anyway,
the table reformatter spots when the maximum width a cell requires is
less than half of what it asks for, and ignores the width specifier if
this is the case.
@
text
@d61 4
d975 3
d1194 4
d1604 4
@


1.19
log
@Sorted out Res files, including fixing position of 'bytes' label in one
of the Choices dialogues (I'd missed it out of a selection when everything
else got moved down a bit). Unfaded Enc_Chinese menu entries, made sure
text labels were wide enough for system font, changed 'Apply' on Choices
dialogue to 'Set', and added ^K to hotlist keyboard shortcut lists.
Print Setup (i.e. Print dialogue) buttons all set to 'local', so the
stupid Toolbox doesn't close the dialogue and lose the caret before I
can see if it was in there to start with...

256 colour hotlist sprites taken back to standard 16 colour versions,
since there's a significant speed penalty on slower machines. The
testbed browser still has the 256 colour versions so the designs aren't
completely lost.

Changed access settings to exported builds to wr/r - lr/r was really getting
on my nerves whenever I wanted to try something temporary out.

View source, save source and print handlers would all try to work if
there was no source to act on - despite the fact that toolbar buttons
would be greyed out form them. This is fixed.

The Navigate menu has components greyed to match the toolbar state,
when opened. It isn't kept up to date dynamically, though this shouldn't
really be a problem (reopen the submenu...). As part of this, finally
sorted out conditions for the Stop button to be greyed, or the
GoTo/Go/Stop tristate to be at 'Stop' versus 'GoTo'.

Deferred reformatting is now disabled for external image fetches.

Browser-local client pull flag removed; hitting the Stop button simply
cancels any null handlers working for it. That way, client pull switches
back on in passing at the next fetch (it was never really switched off).
So to stop client pull, hit the stop button at any point.

Done CELLPADDING attribute; cellpadding field in reformat_cell (Global.h)
is redundant since the table token is accessible from there, and so it has
been removed. CELLSPACING support also added.
@
text
@d455 6
a460 3
  #define FMCIncHandles(f) {                                            \
                             if (!fm_handles[(f)]) fm_handles[(f)] = 1; \
                             else fm_lose_font(NULL, (f));              \
@


1.18
log
@Fixed bug with font size clipping in main.c.
Implemented font size choices.
@
text
@d1480 3
a1482 1
/* Initialises the library for use.              */
d1484 1
a1484 4
/* Parameters: The 'base font' size, if going    */
/*             to use the fm_size function to    */
/*             allow an abstracted font size     */
/*             selection method (see fm_size).   */
d1489 2
a1490 1
  int     size, scaleby;
@


1.17
log
@Now handles PARAM tags. Sorted out Plug-In bug that was related to Java
setting a 0 by 0 graphics window before calling Wimp_Poll (fixed in Java).
Implemented queue for Plug-Ins so multiple broadcasts aren't sent for
several Objects in one data chunk.

Added Docs directory with some documentation in it. More things to keep
checking for stylistic consistency, horray ;-)

Corrected !Run[D] for Ursula build to need AcornURI but not TaskModule
(URI handler needed for !Mail to pick up mailto: links).

Added display_height field to browser_data, analogous to display_width,
to cope with % sized objects by width and height (see how HRs are
handled in Redraw.c for an example of how it was always fairly easy
with width, but not height until this addition). Though you do have
to reload to get a new size; reformat isn't enough. Must see to this
some time...

Fixed bug where basic typefaces were claimed *before* the Choices file
had been read. For unusual Choices settings, this could create some
'interesting' problems now and again. This was part of narrower scope
work in the Choices code to allow font changing without leaking font
handles (now done; fm_shutdown only ditches fonts, it keeps internal
structures - must then call  fm_lose_fonts for all browsers to get the
bitfields up to date, then rewrite the typeface definitions and reclaim
basic fonts). Noticed that fm_claim_basic_typefaces would claim multiple
instances of the same font if there were several cases of the same font
mapped to different typeface styles - fixed.

Implemented PlugInControl settings, but not SupportObject (fully).
@
text
@a1471 2
  int     size, scaleby;

d1474 2
d1477 14
@


1.16
log
@Font choices added (currently doesn't free old browser fonts).
@
text
@d455 5
d462 17
a478 7
    h = fm_find_font(NULL, "sans",  base_size, base_size, 0, 0); fm_handles[h]++;
    h = fm_find_font(NULL, "sans",  base_size, base_size, 0, 1); fm_handles[h]++;

    h = fm_find_font(NULL, "serif", base_size, base_size, 0, 0); fm_handles[h]++;
    h = fm_find_font(NULL, "serif", base_size, base_size, 1, 0); fm_handles[h]++;
    h = fm_find_font(NULL, "serif", base_size, base_size, 0, 1); fm_handles[h]++;
    h = fm_find_font(NULL, "serif", base_size, base_size, 1, 1); fm_handles[h]++;
d480 2
a481 2
    h = fm_find_font(NULL, "fixed", base_size, base_size, 0, 0); fm_handles[h]++;
    h = fm_find_font(NULL, "fixed", base_size, base_size, 1, 0); fm_handles[h]++;
d721 1
d723 1
d1493 3
a1495 2
/* not needed regardless of the usage counter    */
/* therein, and resets those counters to zero.   */
@


1.15
log
@More reformatter code bugs fixed; this one regarding width of items. Any
kerned string was overestimated (causing redraw bugs and caret position
problems in forms, apart from other minor bits elsewhere) and the default
size of a writable icon wasn't especially clever.

Crude Plug-In support; just about manages Java, but can't fetch on
behalf of Plug-In (for example). Had to change the default file access
URL construction to be 'file:/' instead of 'file://', or local file
fetches that reference Java applets won't work. This is in its very
early stages, and is being checked in mostly so that various Choices
issues can be worked on.
@
text
@a143 1
static fm_typeface * fm_find_typeface (char * name);
d203 1
a203 1
static fm_typeface * fm_find_typeface(char * name)
@


1.14
log
@Increased WimpSlot of debug !Browse by 200K.

FRAMES_SUPPORT #define removed.

Optimised fm_token_font_info().

Added support for LI tokens with text (for ordered lists).

Now outdents bullets from indent value, rather than indenting bullets by
the indent value and further indenting text. May need to look at default
Choices files because of this.

Limited the margin to always be non-negative.
@
text
@d880 2
a881 2
    xs=FM_System_Size_X(h); /* (Macros defined in FontManage.h) */
    ys=FM_System_Size_Y(h);
d918 51
d1534 2
a1535 1
/*             calculated width is placed.       */
d1537 1
a1537 2
/* Assumes:    The two int pointers may not be   */
/*             NULL.                             */
d1543 5
d1550 1
a1550 1
    /* The outline font case. */
d1552 3
a1554 1
    _kernel_oserror * e;
d1556 3
a1558 1
    /* Set the current font */
d1560 4
a1563 1
    e = _swix(Font_SetFont,_IN(0),h);
d1565 2
a1566 1
    /* Get the width */
d1568 40
a1607 11
    if (!e) e = _swix(Font_StringWidth,
                      _INR(1,5) | _OUT(2) | _OUT(5),

                      s,         /* String to find width of                   */
                      maxwid,    /* Maximum width if splitting is allowed     */
                      0x1000000, /* Maximum height if splitting is allowed    */
                      split,     /* Character to split on, or -1 for no split */
                      maxbytes,  /* Maximum string length                     */

                      width,     /* Width of scanned string                   */
                      bytes);    /* Length of scanned string                  */
d1620 1
a1620 1
    if (!e && !*width && split > 0)
d1630 1
a1630 2
      /* of the code. This fault was duplicated in the new      */
      /* source below, but is now fixed.                        */
d1637 2
a1638 2
      _swix(Font_StringWidth,
            _INR(1,5) | _OUT(2) | _OUT(5),
d1640 35
a1674 8
            s,            /* String to find width of                   */
            0x1000000,    /* Maximum width if splitting is allowed     */
            0x1000000,    /* Maximum height if splitting is allowed    */
            -1,           /* Character to split on, or -1 for no split */
            p - s,        /* String length                             */

            width,        /* Width of scanned string                   */
            bytes);       /* Length of scanned string                  */
d1683 1
a1683 1
    while ((*bytes < maxbytes) && s[*bytes] == ' ') (*bytes)++;
d1745 2
a1746 2
    *bytes = oCurr;
    *width = wCurr;
d1748 3
@


1.13
log
@Version in Messages taken to 1.22 (03 Oct).

Updated Res files in appropriate builds to hold various (similar) Choices
designs.

Choices related menus were flagged as Shared, but none of the dialogues
(including ColourDBox) were - potential future problems, though shouldn't
cause any leaks at present. This has been sorted out anyway.

Encoding function encoding_init no longer returns an error from
toolbox_create_object, so the Encoding menu and all those attached
to it do not have to be present (e.g. the Customer build).

SUB, SUP, STRIKE and U supported. U underlines the baseline of the body text
font, whilst STRIKE will go through roughly the middle of the lower case
chars even if the font is SUP or SUB. Note that Navigator appears to shift
the underline point for SUB and SUP; it may be necessary to copy this
behaviour, but testing on real sites must proceed before that. There could
also be a problem with the automatic lowering of font size, which Navigator
doesn't do, so any FONT SIZE = -n commands could make it too small. Again,
this needs testing on real sites.

'http://' is added to URLs with no protocol specified, unless they start with
'ftp.', in which case the new behaviour is to add 'ftp://'.

Choices code altered to do less error checking on components! They should be
able to be missing without raising errors. Referencing of the subwindow
array changed from *(subwindows + number) to subwindows[number].

Made trace_tag_name code look pretty...

reformat_useless_token now checks tagno is non-zero.

User Agent string setting now done through URL_GetURL, on a per-session
basis.

Ellipsis character removed from all Messages files, replaced with '...'.
There's little difference between the two in an outline font, and in System
font the latter looks much better. Smart quotes left in, as they look
better in all cases.
@
text
@d1687 9
a1695 7

  if (redraw_header(flags) == 1) *bold   = 1, *size *= 2;
  if (redraw_header(flags) == 2) *bold   = 1, *size = (*size * 3) / 2;
  if (redraw_header(flags) == 3) *italic = 1, *size = (*size * 4) / 3;
  if (redraw_header(flags) == 4) *bold   = 1, *size = (*size * 4) / 3;
  if (redraw_header(flags) == 5) *bold   = 1;
  if (redraw_header(flags) == 6) *italic = 1;
@


1.12
log
@Added support for HTMLLib HttpEndParse call.

Text items with no VALUE specified in the HTML were not cleared on
hitting a Reset button as the text field of the token is NULL; fixed.
SELECT lists with no default selection item were not being changed
on hitting a Reset button; fixed. In radio groups with no default
selection specified, no item will be selected. This goes against
the HTML 2 spec but allows broken Navigator-esque forms behaviour.
In consequence, radios can be deselected by clicking on the same
one twice. I'd fixed the flickering experienced when doing this
recently, but that, now, is irrelevant, since the state of a radio
must always change.

Reformatter's new 'find width of a SELECT field' didn't account for
the width of <none> and <many> items, and now does (particularly
important for broken items with no OPTION contents).

Under certain circumstances, illegally named targets would open in the
ancestor rather than a new window - a deliberate decision in the code,
but now reversed due to a test suite failure; they'll open in a new
window instead.

Altered the left hand indent handling for lists so that headings and
body text follow the Navigator 48 pixel indent and the bullet point
items drop to the left of the left hand margin, rather than sitting
on the margin with the text indented to the right.

Tightened up the hotlist_load_directory checking of URLs, so that
only those with '://' in - i.e. look fully specified - are accepted.
HTML files are loaded into a new directory now.

Items without a descriptive title in hotlist_new_url will have the URL
substituted in instead. White space before and after descriptions and
after URLs is stripped. Directories with zero length names or null
strings (after white space is stripped) will still be created, with a
generic name (see Messages, token 'HotlistUntitled').
@
text
@d859 1
a859 1
/* fm_font_bbox()                                */
d861 1
a861 1
/* Gets the bounding box of a font.              */
d1734 4
@


1.11
log
@Choices and Controls files are now loaded into malloc space (use chf and
cof to address them). Previously only in Main.c, task_dir is now globally
visible.

Choices updated to allow 16ths of a point in the font size specification
and the System font face has been removed - it isn't used. The use of
serif and sans serif fonts has been rationalised across builds (e.g. Desktop
builds use what they say, but the Customer build uses Homerton as the
default body (serif, so to speak) font as it matches the box's look and
feel better).

Font loading altered a bit to work properly! Font library defines some
standard startup fonts without using Choices, which Choices can then
override.
@
text
@d1158 1
a1158 1
  if (chars < strlen(s))
d1161 1
a1161 1
    s[chars] = 0;
@


1.10
log
@Now working on source merged with Kevin Bracey's internationalisation
support. UNIFONT is undefined in the Make File for now. All Res and
Choices files updated appropriately.

Having sorted out the old Choices and Messages to form Choices, Controls
and Messages, this build has had the same cleaning up done internally.
This includes greater consistency in naming schemes and the removal of
the inconsitent choices items - e.g. Choices file entries saying 'delay
images' and 'plain backgrounds' where internally all the flags say 'show
images' and 'show backgrounds'. ChoiceDefs.h and CtrlDefs.h added to
clarify the meaning of some fields, though usage of these is not 100%
in the source (there are cases where parameters are passed through to
functions as ints, and those functions still check these against hard
coded values rather than the #define stuff).

Fetcher status return bits (connected, sent request, etc.) now reflected
in status bar. Progress during fetchs to files are reported by %, where
the size of the object is known. Exceeding 100% drops back to a byte
counter, in case the estimated size was wrong. The progress counter
may be updated after specific delays, rather than 'as often as possible',
to reduce flicker (as requested by D.Brown some time ago).

I've done a small rewrite of the fetch prioritisation scheme in FetchPage.c;
how well this performs in general use across different processor speeds
remains to be tested, but certainly it has some advantages. For each small
fetch window before the rewrite, a 4cs tight loop was entered - this gave a
noticable and substantial drain to the Desktop performance if more than one
was opened. Now, several can be up at once with little hit. The actual file
fetch is on half the priority it was before, with all others taken back
just a bit - e.g. from 20cs per poll to 15cs per poll for flat out
reformatting. You don't seem to lose much time on the format in practice,
and the Desktop feels quite a bit lighter at the same time. There's the
potential for smoother frameset loading in this scheme, too.

When Shift+Clicking on a link meant you still fetched inside the main
browser window, several fetches could occur in a frameset - one per frame.
However, now that you can only do this by clicking on a link that leads to
non-displayable data - or by turning off the small fetch windows by
setting UseSmall to 'no' in Choices - a bug where fetchpage_preprocessed
would stop such fetches as new ones were started was revealed.
The API to frames_abort_fetching has now been extended to include a
'stop file spooling too' flag, allowing a fix to be made by having
fetchpage_preprocess's calls not set this (and it doesn't check the
savelink flag is unset before proceeding, since frames_abort_fetching
does that implicitly now).

Had left the RAM transfer buffer at 16 bytes (from testing) accidentally...
Oops. Upped it to 4K. In addition, when loading data by RAM transfer,
the browser didn't notice if a RAMFetch bounced during the transfer. It
would be treated as a 'first' RAMFetch bounce, basically, and try to go to
file transfer - oops. Fixed.
@
text
@d218 1
a218 1
  while(f)
d224 1
a224 1
  return(NULL);
d299 1
a299 1
  fp=fm_find_typeface(f->name);
d307 1
a307 1
  if(!fp)
d398 1
a398 1
      strncpy(f.alternative,p,sizeof(f.alternative)-1);
d407 1
a407 1
  if (f.name[0]) return(fm_define_typeface_explicit(&f));
d432 2
a433 2
  e = fm_define_typeface(lookup_choice("Typeface1:system=System.Fixed:Corpus.Medium.Oblique:Corpus.Bold:Corpus.Bold.Oblique;fixed",0,0));
  if (e) return e;
d435 3
a437 2
  e = fm_define_typeface(lookup_choice("Typeface2:fixed=Corpus.Medium:Corpus.Medium.Oblique:Corpus.Bold:Corpus.Bold.Oblique",0,0));
  if (e) return e;
d439 1
a439 4
  e = fm_define_typeface(lookup_choice("Typeface3:sans=Homerton.Medium:Homerton.Medium.Oblique:Homerton.Bold:Homerton.Bold.Oblique;serif",0,0));
  if (e) return e;

  return fm_define_typeface(lookup_choice("Typeface4:serif=Trinity.Medium:Trinity.Medium.Italic:Trinity.Bold:Trinity.Bold.Italic;sans",0,0));
@


1.9
log
@Encoding support added: if UNIFONT is defined then the browser will
attempt to use the system font to render Unicode characters (new
International module required). If not defined, the browser will just
handle Acorn Latin-1 characters, but HTMLLib will convert other encodings
into Latin-1. Must keep the UNIFONT define in sync with HTMLLib (if
defined HTMLLib outputs UTF-8, otherwise Acorn Latin-1).

Still needed:

Reverse encoding (converting form input etc back into the server's
character set).
Reparse when encoding changes.
Setting of charset from an attribute on the <A> tag.
@
text
@d53 2
d56 3
a58 3
#include "iso10646.h"
#include "utf8.h"
#include "Unifont.h"
d458 1
a458 1
  if (!choices.systemfont)
a943 3
    /* Need to set the background colour too */
    _swix(ColourTrans_SetGCOL,
                          _IN(0) | _INR(3,4),
d945 10
a954 3
                          fore,    /* Palette entry */
                          0x80,    /* Flags         */
                          0);      /* GCOL action   */
d956 1
a967 7
//    _kernel_oserror * e;
//
//    /* set the current font.                    */
//
//    e = _swix(Font_SetFont,_IN(0),h);
//    if (e) return e;

d1578 2
d1581 1
a1581 1
    int wWidechar = (FM_System_Size_X(h) * 10 / (128 * wimpt_dx())) * 17 / 8 * wimpt_dx() * 400;
d1583 1
a1583 1
    int wChar = (FM_System_Size_X(h) * 10 / (128 * wimpt_dx())) * wimpt_dx() * 400;
d1597 1
a1597 1
      UCS4 ucs;
d1607 2
a1608 2
      oCurr += UTF8_to_UCS4(s + oCurr, &ucs);
      wCurr += unifont_widechar(ucs) ? wWidechar : wChar;
d1610 2
a1611 2
      wCurr += wChar;
      oCurr ++;
d1674 1
a1674 1
  *size    = choices.fontsize;
d1735 1
a1735 1
  size += fm_size(t->fontsize) - choices.fontsize;
@


1.8
log
@Created Protocols source file and moved a lot of message handling from
handle_messages - the latter now serves as a high level distributor to
lower level functions in Protocols. Incidentally, URL files (as used by
the ANT suite) can be loaded by dragging to the browser in the same way
as URI files - Not A Lot Of People Know That, etc.

Merged new hotlist display type Res file to existing resources, added
support for DataSave message so items can be dragged from the hotlist
to a specific window (RAM transfer for URI and URL files; ScrapFile for
HTML and Text but deleted afterwards and there are appropriate guards
to stop Reload just saying 'not found'; images run through ScrapFile and
there is no choice but to leave them there and do a conventional fetch).

All !RunD files now give a WimpSlot of 2304K. Some small changes to
the Argo and Ursula build Res files to make the menu trees more sensible.
Controls files now take 'file:/' instead of 'file://' in Protocols
section. Definitions at top of URLutils.c *not* altered, as then you
end up with invalid URLs - so it will accept 'file:/', but always generate
'file://'. This is because some browsers exports 'file:/'. Sigh.

make_no_[..._]memory_error functions now return a _kernel_oserror * rather
than void. It's always &erb returned, but it enables users to use a more
elegant 'return make_no_memory_error(1);', say, rather than something
like 'make_no_memory_error(1); return &erb;'. I obviously should've written
it like that at the outset, but never mind. All callers have been
appropriately updated.

The urlutils_leafname_from_url function now replaces illegal characters
(A7000 Welcome Guide p54...) in the leaf with legal alternatives.

Internal URL scheme is now a bit cleaner, with everything properly defined
in URLutils.h. All references to http:, file: and ftp:, with or without
a following '//' use the definitions in here now.

More tidying and some reorganising of Hotlist source. Auto-open delay is
now a Choices item. Some dependencies on statics removed (e.g. the
counting functions don't accumulate into the global item_number now).
The redraw functions used Wimp_TextOp - oops, so this has been amended
to use whatever is supported on your Wimp. This is now in a new function
(utils_text_width()), which the History menu routines also use (there was
a bug in the width routine there anyway, which is therefore fixed in
passing). Several other routines used Wimp_TextOp directly too, and
they have been altered to use the new function as well.

In hotlist code, one of the larger changes is in the API to hotlist_draw_r()
(formerly _hotlist_draw()) which now takes item widths and heights as
parameters - discovering these is quite slow, so doing it every time the
function calls itself recursively is a little less efficient than
passing the values in from elsewhere. Note that underscore prefixed
functions are being slowly renamed to _r suffixed functions, to match
the convention established by Tony Cheal with is table routines. This
makes it much more obvious when something is recursive, as the same
naming convention is used in every browser source file.

Finally, note that I intend to ditch SaveDBox and use an alternate window
with manual control of the messaging in Protocols.c. This will allow
various improvements which at present the SaveDBox operational methods
preclude. I'm going to have to do at least an alternate Window object for
the SaveDBox module to use soon in any case. Getting rid of SaveDBox will
help reduce, if only slightly, demands on the RMA.
@
text
@d53 6
d939 12
a950 1
  if (h < 0) return _swix(ColourTrans_SetGCOL,
d956 1
d1043 5
a1047 1
    _swix(OS_Write0, _IN(0), s);
d1578 3
d1594 4
d1604 4
d1610 1
@


1.7
log
@Very long log entry alert - but hey, beats 'Bug fixed' (sorry, Richard) ;-)

Open URL implementation more or less complete, though may undergo UI
revision at a later date to allow named frames to be targetted. Hope to use
the ideas in this code as the foundation for other general dialogues.

In token stream dump for TRACE builds, table head items were not indented
as far as they should have been - this is fixed; and manual toolbar redraw
routines have been removed. They never worked, were commented out, and
would never be used in that form anyway.

DragBox source added, but it isn't at all complete and won't work - this is
an 'in spare time' thing. We need custom drag boxes constrained to windows
for the hotlist, and unconstrained for frame border resizing... Hey ho.

Ancestor window extents match visible areas if there are frames (no more
scrolling framesets...!). Frame resizing works whilst new documents fetch
without pulling the extent down now. However, frame horizontal extents
never shrink until a reload which is nasty, and this is all due for a
rewrite. Frames border redrawing routine moved out of Redraw.c and into
Frames.c. Bug regarding the mouse rectangle and frame border widths
(rectangle was too large, so you could squash the edges) for edge-drag
frame resizes fixed.

Window width change reformat tolerance fixed; you could creep the window
width down or up forever without any reformat, and centred objects would
move but not be redrawn (thereby giving rise to subsequent redraw errors).

Filetype on objects saved through Shift+Click correct. Save Source dialogue
recognises if that source is plain text, rather than assuming HTML. A
browser that fetches a file remembers the old store size it had before the
save, so even though the data is now ditched, it reports the same amount of
data fetched afterwards (looked awful when this could, for example,
suddenly say '0' after a file save). Progress indicator is now fully aware
of one or many file saves inside a frameset and reports the number of
saves, a colon, and the cumulative saved data count, instead of reporting
the sum total of fetched data in all frames, including non-file save stuff
(note that for just 1 save, '1:' is not shown as a special case for the
most common condition). A bug related to this, where you could in fact only
do one fetch per frame*set*, has been corrected (only one fetch allowed per
frame still, this is unlikely to ever change).

Hotlist support added (D.Brown's source), with various bits of integration
and modification still in progress there. Note additions to the Messages
files. On the subject of Messages, the whole mucky business about what
goes in Messages or Choices (and a few bugs where lookup_choice was used
instead of lookup_token or vice versa) has been sorted out. Messages
contains, more or less, just that. Choices contains user configurable
stuff which generally can't mess things up too badly. A new file, Controls,
is a Messages file holding the non-user configurable choices, which can
generally make things go badly wrong if misused. A lot of these are tied
to the Res file. StrongED users can get these to automatically fold out
the various sections (EMail me for details). Sorry, but at the time of
writing, Zap doesn't do folding... =8*P

Two bugs with images. Asking for images to be shown in browser B when
browser A uses the same ones and was loaded first didn't work correctly,
and now does (a bit weird - browser A does the fetch and browser B does the
display...). Second one occurred when the background image was also used on
the page as a foreground image. This has been fixed by flagging background
images in the image_info structure, and checking this before cross
referencing. This bit also allowed the image_restart_fetches API to be
extended, so that just background or foreground images may be fetched if
they weren't already and the user asked the browser to show them. Before,
the whole lot had to be fetched together (so turning on 'display
backgrounds' will now kick off an image fetch if required, you don't
need to reload the page anymore).

Makefile copy options tweaked to be 'newer' (so if you're testing with some
temporary Choices file or something, it won't write over it at the end of
every export), and REMOTE_HOTLIST flag added for Customer builds - means
the Hotlist.c functions aren't needed; the old, hotlist-by-file method is
used. Added support for Customer build (see later), though there were very
few additions needed in practice.

Table printing fixed - in many ways it wasn't broken, it was image printing
causing the oddities ever since the global image pool was introduced (this
is, again, fixed). The 'reformat to fit page' option didn't work as coded
any more; tables store cell addresses in the HStreams, so you can't then do
a background reformat in a different browser. Hence, it now has to reformat
to the page width, print, then put the page back again, all in the actual
displayed browser. This doesn't feel as slow in use as it perhaps should,
considering what is going on... Note that a line of a defined fraction (see
Print.h) of page height will now split over page boundaries, so tall images
or tall tables don't cause problems now (aside from the obvious problem of
having the line split over a page at all!). There was a bug in the routine
to print from a given start point until 'n' pages had been filled, in that
it always filled 'n + 1' - now fixed. Finally, as part of the printing
tweaks, a new dialogue exists - PrintStyle - with a similarly named source
file added to deal with it.

Global history auto save / load done, but only to the Choices file path -
the whole browser is still strictly single user at present, with all the
extra work for a multiuser Customer environment yet to be done. This has
shown up a global history corruption problem which I haven't fixed yet.

Rationalising TBEvents.h - things are migrating out of it, and into more
appropriate sources (e.g. definitions relating to the Open URL dialogue are
going into OpenURL.h, etc.). Event codes were at one stage deliberately
diverged in numberspace from the component IDs of typical gadgets raising
the events, to avoid anyone getting confused and thinking the IDs and event
codes must match. However, this is in fact unlikely and it is much easier
to remember the fewer numbers that result from tying the two together where
possible. This has resulted in changes to event codes raised in the
following objects of all Res files: Authorise, Find, OpenURL, and
PrintStyle.

And finally - !Run[D] files for all variants updated to require the latest
toolbox and fetcher modules. All Res files updated for hotlists etc. and
sprites files updated appropriately. All Messages, Choices and Controls
files brought in sync., and an Customer build has been added (based on the
Desktop build binary with different resources).

That's all for now...
@
text
@d247 1
a247 1
      if (tl & (1u<<13)) Printf("** malloccount (fm_new_typeface): \0216%d\0217\n",malloccount);
d1323 1
a1323 1
      if (tl & (1u<<13)) Printf("** malloccount (fm_destroy_typefaces): \0216%d\0217\n",malloccount);
@


1.6
log
@Stopped Images.c using Font SWIs instead of fm functions
@
text
@d1465 1
a1465 1
/* Assume:     The two int pointers may not be   */
@


1.5
log
@Corrected fm_string_width for system font and made it select fontsize 12.8\nwhen using system font.
@
text
@d1464 3
d1551 1
d1555 1
@


1.4
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@d1548 4
a1551 1
    int wChar = (FM_System_Size_X(h) * 4000) / 128;   /* (Macro defined in FontManage.h) */
@


1.3
log
@Fixed problems with unsourced images in tables and a couple of other bugs
here and there - nothing earth shattering... Just wanted to keep the CVS
source up to date.
@
text
@d17 3
a19 1
/* Purpose: A range of veneers for font management */
d22 2
a23 1
/* History: 05-Dec-96: Created                     */
d27 1
a27 1
/*                     more info)                  */
a57 2
/*                                                                                                */
/*                                                                                                */
d123 1
a123 1
/*                                                                                                */
d131 1
d165 1
a165 1
int fm_handles[256];
d169 2
a170 2
/* is slow). Initialisation is done in fm_init(), and the    */
/* size is looked up through fm_size().                      */
d176 1
a176 1
int fm_sizes[7];
a197 4
//  char          lname[TypeNameLen];
//  char        * p;
//  int           i;

a199 11
//  p=name;
//  i=0;
//
//  while(*p && i<sizeof(lname)-1)
//  {
//    lname[i++]=tolower(*p);
//    p++;
//  }
//
//  lname[i]=0;

d227 2
a228 2
/* Returns: Pointer to the new fm_typeface       */
/*          struct, or NULL if malloc failed.    */
d247 1
a247 1
      if (tl & (1u<<13)) Printf("** malloccount: %d\n",malloccount);
d406 1
a406 1
           lookup_token("BadType:Internal error - Bad typeface definition in %0().",
d479 2
a480 1
/*             The x and y sizes, in 1/16ths of  */
d482 1
d484 1
d577 1
d579 1
d581 1
d583 1
d607 1
a607 1
  /* fm_set_system_font() function, return that handle now  */
d623 1
a623 1
  /* If fm_sub_find_font() returns -1, keep trying */
d678 1
d724 1
a724 1
  for (fh = 0; fh < 256; fh++)
d747 1
a747 1
  char              name[1024];
d761 1
a761 1
  for (fh = 0; fh < 256; fh++)
d823 2
a824 2
        /* See fm_find_font() for comments on this bit, no need to */
        /* repeat it all here.                                     */
d858 1
d860 2
a861 2
/*             bounding box is placed (min x and */
/*             y are inclusive, max x and y are  */
d918 1
d920 1
d969 1
d975 1
d977 1
a978 1
/*             1 to use font blending, else 0.   */
d980 3
a982 2
/*             NB Do NOT use font blending on a  */
/*             Font Manager earlier than v3.37.  */
d1007 10
a1016 1
    bbc_vduq(23,17,7,6,xs & 255,xs >> 8,ys & 255,ys >> 8,0,0);
d1112 1
a1112 1
/* As fm_puts() above, but takes an extra        */
d1121 1
a1121 1
/* Parameters: As fm_puts() above, but after the */
d1134 1
a1134 1
  /* call fm_puts(). Restore the character that */
d1163 1
d1184 1
a1184 1
             lookup_token("BadTRef:Internal error - Reference to undefined typeface in %0().",
d1211 1
d1213 1
d1215 1
d1241 1
a1241 1
             lookup_token("BadTRef:Internal error - Reference to undefined typeface in %0().",
d1282 1
a1282 1
             lookup_token("BadTRef:Internal error - Reference to undefined typeface in %0().",
d1323 1
a1323 1
      if (tl & (1u<<13)) Printf("** malloccount: %d\n",malloccount);
d1340 1
a1340 1
/* e.g. fm_find_font() after this function has   */
d1376 1
d1378 1
a1378 1
/*             to use the fm_size() function to  */
d1380 1
a1380 1
/*             selection method (see fm_size()). */
d1392 1
a1392 1
  fm_sizes[0] = base_size; /* Just in case 0 gets given to fm_size() by accident - more likely than a large out of range value */
d1414 1
a1414 1
  for (fh = 0; fh < 256; fh++)
a1463 2
/*                                               */
/* Returns:    See parameters list.              */
d1604 1
d1607 1
d1611 1
d1615 1
a1618 2
/*                                               */
/* Returns:    See Parameters list.              */
d1664 1
a1701 2

/*************************************************/
@


1.2
log
@Made INPUT type=image work
@
text
@a1459 1
    char              c1 = 0, c2 = 0;
a1465 8
//    /* Force a terminator in the string */
//
//    if (maxbytes < strlen(s))
//    {
//      c1 = s[maxbytes];
//      s[maxbytes] = 0;
//    }

a1479 21
//if (!e && *width && split > 0 && *bytes <= strlen(s))
//{
//char p = s[*bytes];
//
//s[*bytes] = 0;
//    if (!e) e = _swix(Font_StringWidth,
//                      _INR(1,5) | _OUT(2),
//
//                      s,         /* String to find width of                   */
//                      0x1000000, /* Maximum width if splitting is allowed     */
//                      0x1000000, /* Maximum height if splitting is allowed    */
//                      -1,        /* Character to split on, or -1 for no split */
//                      maxbytes,  /* Maximum string length                     */
//
//                      width);    /* Width of scanned string                   */
//
//s[*bytes]=p;
//
//}


d1485 5
a1489 5
    /* splitting mode, having forced a terminator in at the   */
    /* first split char (if any) to allow the string to still */
    /* split up (even though individual words will be wider   */
    /* than the allowed width, causing the horizontal extent  */
    /* of the object the word lies in to increase).           */
d1495 3
a1497 2
      /* Adjust the string length to the first split character. */
      /* (Thanks to Tony Cheal for spotting this when doing     */
a1505 8
//      /* Force a terminator at the split character, if found */
//
//      if (*p)
//      {
//        c2 = *p;
//        *p = 0;
//      }

d1516 1
a1516 1
            p - s /*maxbytes*/,     /* Maximum string length                     */
a1519 4

      /* Restore the overwritten character, if any */

//      if (c2) *p = c2;
a1520 4

    /* Put the character that was overwritten by a terminator (if any) back */

//    if (c1) s[maxbytes] = c1;
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d984 1
a984 1
_kernel_oserror * fm_puts(fm_face h, int x, int y,char * s, int os, int blend)
d1453 1
a1453 1
_kernel_oserror * fm_get_string_width(fm_face h, char * s, int maxwid, int maxbytes,
d1467 7
a1473 7
    /* Force a terminator in the string */

    if (maxbytes < strlen(s))
    {
      c1 = s[maxbytes];
      s[maxbytes] = 0;
    }
d1523 1
a1523 1
      char * p = s;
d1535 7
a1541 7
      /* Force a terminator at the split character, if found */

      if (*p)
      {
        c2 = *p;
        *p = 0;
      }
d1553 1
a1553 1
            maxbytes,     /* Maximum string length                     */
d1560 1
a1560 1
      if (c2) *p = c2;
d1565 1
a1565 1
    if (c1) s[maxbytes] = c1;
@

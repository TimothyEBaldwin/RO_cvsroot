head	1.24;
access;
symbols
	Browse-2_16:1.24
	Browse-2_15:1.24
	Browse-2_14:1.24
	Browse-2_13:1.24
	Browse-2_12:1.24
	Browse-2_11:1.23
	Browse-2_10:1.23
	Browse-2_09:1.23
	ahodgkin_208_i4_2:1.23
	ahodgkin_208_i4:1.21
	ahodgkin_208_i3:1.21
	ahodgkin_208_i2:1.21
	ahodgkin_208_i1:1.21
	ahodgkin_207release:1.21
	ahodgkin_206release:1.21
	ahodgkin_205release:1.20
	ahodgkin_204release:1.20
	ahodgkin_202release:1.20
	ahodgkin_201release:1.19
	ahodgkin_200release:1.19
	ahodgkin_133beta:1.19
	ahodgkin_132beta:1.19
	ahodgkin_131beta:1.19
	ahodgkin_130beta:1.18
	ahodgkin_129:1.17
	ahodgkin_128beta:1.16
	ahodgkin_128alpha:1.15
	ahodgkin_127beta2:1.14
	ahodgkin_127beta:1.14
	ahodgkin_126beta:1.13
	ahodgkin_AW97patch:1.13
	ahodgkin_AW97:1.12;
locks; strict;
comment	@# @;


1.24
date	2006.03.13.22.06.19;	author ahodgkin;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.14.08.45.08;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.31.15.58.49;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	98.07.09.10.27.26;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	98.03.20.12.13.00;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	98.01.31.10.55.39;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	97.12.18.10.07.10;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	97.12.12.11.18.07;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	97.12.04.11.23.15;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	97.12.02.16.14.05;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	97.11.19.10.29.14;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	97.10.18.16.42.31;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	97.09.22.07.43.26;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	97.09.14.19.18.18;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	97.09.12.17.19.32;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	97.09.09.14.13.22;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	97.09.02.15.46.06;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	97.08.28.16.08.07;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	97.08.18.09.24.06;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	97.08.12.09.26.40;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	97.08.08.16.38.57;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.12.52.34;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	97.07.24.15.36.32;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	97.07.18.15.29.06;	author blaughto;	state Exp;
branches;
next	;


desc
@@


1.24
log
@  PDF export, some major redraw structural changes, updated resources,
  new build system, extensive Makefile modifications, const/restrict
  additions, various bug fixes.
Detail:
  PDF export facility. SEE Docs.User FOR DETAILS (important!). Includes
  UI for headers/footers in Choices and option switch in Print dialogue
  box. Minor bug fixes include printing bullet points and, at long last,
  the "print dialogue box contents are not set up" problem. Redraw engine
  now based entirely on function pointers. Draw export routine replaces
  screen output functions with Draw output functions; PDF does similar.
  Coordinate scaling system in Scale.c/h to help. Makefile changes: Now
  supports a more consistent set of build variants and has minimal
  duplication of object and library lists. New build system: !Mk...
  script files removed, FrontEnd tool !MkBrowse replaces it. See !ReadMe
  (replacing old ReadMe) in root for details. Requires FrontEnd 1.29,
  HTMLLib 0.02 and ImageLib 0.04 (by CVS VersionNum). Updated resources:
  Some attempt to bring all variants to a working level, but not much
  testing. Only the Phoenix JavaScript capable builds (Unicode or normal)
  are fully up to date, though, including PDF UI additions. Many other
  minor tweaks, and extensive use of const and restrict qualifiers
  propagated through source code in response to their use in the new
  redraw system.
Admin:
  Draw and PDF export tested quite heavily. Appears to work well. Text
  file 'Docs.User' describes limitations. Note required new module and
  library versions listed above. Note that only JavaScript capable
  Phoenix resources are updated and only Phoenix was heavily tested.

Version 2.12. Tagged as 'Browse-2_12'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    Toolbars.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Toolbar related functions for the browser.        */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 21-Nov-1996 (ADH): Created.                       */
/*          25-Aug-1997 (ADH): Definitions imported from      */
/*                             TBEvents.h.                    */
/*          23-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>
#include <tboxlibs/flex.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>
#include <tboxlibs/gadgets.h>

#include "Dialler.h"

#include "Global.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "CSIM.h"
#include "CtrlDefs.h"
#include "Fetch.h" /* (Which itself includes URLstat.h) */
#include "Handlers.h"
#include "History.h"
#include "Images.h"
#include "Memory.h"
#include "Mouse.h"
#include "Reformat.h"
#include "URLutils.h"
#include "URLveneer.h"

#include "Toolbars.h"

/* Locals */

static int bar_overlap = -1;

/* Local types */

/* Used to record the requirement of a particular browser to */
/* display a certain message in the status bar. For a given  */
/* page which may include frames, an array of these is built */
/* as the frameset is defined and starts to fetch pages.     */
/* The actual status message is derived from examining the   */
/* priorities of all of the messages.                        */

typedef struct status_content
{
  browser_data * b;
  status_type    type;
  unsigned int   start;
  unsigned int   end;
}
status_content;

/* Static function prototypes */

static ObjectId          toolbars_get_upper_backend      (const browser_data * restrict b);
static ObjectId          toolbars_get_lower_backend      (const browser_data * restrict b);

static void              toolbars_set_size               (ObjectId o, int height, int yscroll, int flags);
static int               toolbars_find_overlap           (ObjectId o);
static int               toolbars_bar_overlap            (ObjectId o);

static _kernel_oserror * toolbars_animation_set_sprite   (browser_data * b);
static _kernel_oserror * toolbars_update_specific_status (browser_data * b, browser_data * ancestor, int entry, status_type type);
static int               toolbars_write_status           (browser_data * ancestor);
static status_type       toolbars_return_inferred        (browser_data * b);
static _kernel_oserror * toolbars_infer_status           (browser_data * b, browser_data * ancestor, int entry);
static _kernel_oserror * toolbars_add_status_item        (browser_data * ancestor);
static status_type       toolbars_return_act_status      (browser_data * b);

static int               toolbars_count_file_saves       (browser_data * b);
static int               toolbars_count_file_saves_r     (browser_data * b);
static int               toolbars_calculate_progress     (browser_data * b);
static int               toolbars_calculate_progress_r   (browser_data * b, int saves);
static int               toolbars_create_progress        (browser_data * b, char * buffer, int buffer_size);

/**************************************************************/
/* toolbars_get_upper()                                       */
/*                                                            */
/* Returns the object ID of the upper toolbar. This may well  */
/* not be the internal top left toolbar of the window due to  */
/* the swap_bars flag or merged toolbars.                     */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the toolbar.                                   */
/*                                                            */
/* Returns:    Object ID of the toolbar, or NULL for an error */
/*             / no upper toolbar.                            */
/**************************************************************/

ObjectId toolbars_get_upper(const browser_data * restrict b)
{
  if (controls.swap_bars) return toolbars_get_lower_backend(b);
  else                    return toolbars_get_upper_backend(b);
}

/**************************************************************/
/* toolbars_get_upper_backend()                               */
/*                                                            */
/* Returns the object ID of the upper toolbar. This may well  */
/* not be the internal top left toolbar of the window due to  */
/* merged toolbars.                                           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the toolbar.                                   */
/*                                                            */
/* Returns:    Object ID of the toolbar, or NULL for an error */
/*             / no upper toolbar.                            */
/**************************************************************/

static ObjectId toolbars_get_upper_backend(const browser_data * restrict b)
{
  ObjectId t;

  if (b->all_in_bottom)
  {
    if (
         window_get_tool_bars(InternalBottomLeft,
                              b->self_id,
                              &t,
                              NULL,
                              NULL,
                              NULL)
       )
       return NULL;

    else return t;
  }

  if (
       window_get_tool_bars(InternalTopLeft,
                            b->self_id,
                            NULL,
                            &t,
                            NULL,
                            NULL)
     )
     return NULL;

  else return t;
}

/**************************************************************/
/* toolbars_get_lower()                                       */
/*                                                            */
/* Returns the object ID of the lower toolbar. This may well  */
/* not be the internal bottom left toolbar of the window due  */
/* to the swap_bars flag or merged toolbars.                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the toolbar.                                   */
/*                                                            */
/* Returns:    Object ID of the toolbar, or NULL for an error */
/*             / no lower toolbar.                            */
/**************************************************************/

ObjectId toolbars_get_lower(const browser_data * restrict b)
{
  if (controls.swap_bars) return toolbars_get_upper_backend(b);
  else                    return toolbars_get_lower_backend(b);
}

/**************************************************************/
/* toolbars_get_lower_backend()                               */
/*                                                            */
/* Returns the object ID of the lower toolbar. This may well  */
/* not be the internal bottom left toolbar of the window due  */
/* to merged toolbars.                                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the toolbar.                                   */
/*                                                            */
/* Returns:    Object ID of the toolbar, or NULL for an error */
/*             / no lower toolbar.                            */
/**************************************************************/

static ObjectId toolbars_get_lower_backend(const browser_data * restrict b)
{
  ObjectId t;

  if (b->all_in_top)
  {
    if (
         window_get_tool_bars(InternalTopLeft,
                              b->self_id,
                              NULL,
                              &t,
                              NULL,
                              NULL)
       )
       return NULL;

    else return t;
  }

  if (
       window_get_tool_bars(InternalBottomLeft,
                            b->self_id,
                            &t,
                            NULL,
                            NULL,
                            NULL)
     )
     return NULL;

  else return t;
}

/**************************************************************/
/* toolbars_set_size()                                        */
/*                                                            */
/* Sets the vertical visible height and scroll position of a  */
/* given toolbar.                                             */
/*                                                            */
/* Parameters: The object ID of the toolbar;                  */
/*                                                            */
/*             The visible height to set it to;               */
/*                                                            */
/*             The y scroll offset to give it;                */
/*                                                            */
/*             Flags - alter InternalTopLeft, or              */
/*             InternalBottomLeft toolbar.                    */
/**************************************************************/

static void toolbars_set_size(ObjectId o, int height, int yscroll, int flags)
{
  WimpGetWindowStateBlock s;
  ObjectId                p;

  /* Get the toolbar's parent object (the window) */

  dprintf(("TBar", "\ntoolbars_set_size: Called with object ID %p\n",(void *) o));

  toolbox_get_parent(0, o, &p, NULL);

  dprintf(("TBar", "toolbars_set_size: Parent ID is %p\n",(void *) p));

  /* This has to be here, or the toolbar can drop out of */
  /* the parent window (?!)...                           */

  ChkError(toolbox_show_object(0, o, 0, 0, p, -1));

  /* Get the toolbar's wimp handle and size through Wimp_GetWindowState */

  ChkError(window_get_wimp_handle(0, o, &s.window_handle));
  ChkError(wimp_get_window_state(&s));

  /* Set the vertical size. */

  if (!controls.swap_bars)
  {
    s.visible_area.ymin = s.visible_area.ymax - height;
    ChkError(toolbox_show_object(0, o, 1, &s.visible_area, p, -1));
  }
  else
  {
    s.visible_area.ymax = s.visible_area.ymin + height;
    ChkError(toolbox_show_object(0, o, 1, &s.visible_area, p, -1));
  }

  /* This call is needed for the toolbox to recognise the new size */

  ChkError(window_set_tool_bars(flags, p, o, o, 0, 0));

  /* Set the scroll position - the set_tool_bars call will */
  /* trounce the scroll position (sigh) if this call is    */
  /* done beforehand, as part of the first show_object     */
  /* call.                                                 */

  s.yscroll = yscroll;
  ChkError(toolbox_show_object(0, o, 1, &s.visible_area, p, -1));

  dprintf(("TBar", "toolbars_set_size: Successful\n"));
}

/**************************************************************/
/* toolbars_find_overlap()                                    */
/*                                                            */
/* Finds the overlap of the height gadgets 0xd and 0xe in the */
/* upper toolbar, recording this in the local bar_overlap int */
/* to make future references faster.                          */
/*                                                            */
/* Parameters: The object ID of the toolbar.                  */
/**************************************************************/

static int toolbars_find_overlap(ObjectId o)
{
  BBox url, but;
  int  overlap;

  if (gadget_get_bbox(0, o, URLBarSpacer,    &url)) return 0;
  if (gadget_get_bbox(0, o, ButtonBarSpacer, &but)) return 0;

  overlap = but.ymax - url.ymin;
  if (overlap >= 0) return overlap;

  return 0;
}

/**************************************************************/
/* toolbars_bar_overlap()                                     */
/*                                                            */
/* Returns the overlap of the height gadgets 0xd and 0xe in   */
/* the upper toolbar, using a local cached value for speed.   */
/*                                                            */
/* Parameters: The object ID of the toolbar.                  */
/**************************************************************/

static int toolbars_bar_overlap(ObjectId o)
{
  if (bar_overlap < 0) bar_overlap = toolbars_find_overlap(o);

  return bar_overlap;
}

/**************************************************************/
/* toolbars_set_presence()                                    */
/*                                                            */
/* Reads the browser_data structure associated with a given   */
/* browser window object ID, and ensures the toolbars         */
/* associated with that window match the flags set inside the */
/* data structure.                                            */
/*                                                            */
/* Parameters: A browser_data struct relevant to the window   */
/*             holding the toolbars;                          */
/*                                                            */
/*             A flags word holding the toolbars to alter -   */
/*             InternalTopLeft, or InternalBottomLeft.        */
/**************************************************************/

void toolbars_set_presence(browser_data * b, unsigned int flags)
{
  ObjectId o;
  ObjectId t;

  dprintf(("TBar", "\ntoolbars_set_presence: Called with %p\n", b));

  /* If not a valid browser_data structure, exit */

  if (!is_known_browser(b)) return;

  /* Toolbars can only exist on ancestor browser windows, not */
  /* in any child frames.                                     */

  b = utils_ancestor(b);
  o = b->self_id;

  /* Deal with merged toolbars separately - they're a simple case */

  if (b->all_in_top || b->all_in_bottom)
  {
    /* The URL bar flag is looked at to see if the toolbar is on or off */
    /* as well as the status bar flag, as the former is used for upper  */
    /* toolbars (as it prompts the vertical shift of page objects), and */
    /* the latter for bottom merged toolbars.                           */

    if (b->all_in_top)
    {
      t = toolbars_get_upper(b);

      if (t)
      {
        dprintf(("TBar", "toolbars_set_presence: Top left toolbar ID is %p\n",(void *) t));

        if (b->url_bar && b->status_bar) ChkError(toolbox_show_object(0, t, 0, NULL, o, -1));
        else ChkError(toolbox_hide_object(0, t));
      }
    }
    else
    {
      t = toolbars_get_lower(b);

      if (t)
      {
        dprintf(("TBar", "toolbars_set_presence: Bottom left toolbar ID is %p\n",(void *) t));

        if (b->url_bar && b->status_bar) ChkError(toolbox_show_object(0, t, 0, NULL, o, -1));
        else ChkError(toolbox_hide_object(0, t));
      }
    }

    return;
  }

  /* Proceed with 'normal' toolbars */

  if (flags & InternalTopLeft)
  {
    t = toolbars_get_upper(b);

    if (t)
    {
      dprintf(("TBar", "toolbars_set_presence: Top left toolbar ID is %p\n",(void *) t));

      /* URL and button bars both present */

      if ((b->url_bar) && (b->button_bar)) toolbars_set_size(t,
                                                             toolbars_button_height(b) + toolbars_url_height(b),
                                                             0,
                                                             controls.swap_bars ? InternalBottomLeft : InternalTopLeft);
      /* URL bar only present */

      else if ((b->url_bar) && !(b->button_bar)) toolbars_set_size(t,
                                                                   toolbars_url_height(b),
                                                                   0,
                                                                   controls.swap_bars ? InternalBottomLeft : InternalTopLeft);
      /* Button bar only present */

      else if (!(b->url_bar) && (b->button_bar))
      {
        /* Find what would be the URL bar height if it was present on its own */

        BBox w;

        gadget_get_bbox(0, t, URLBarSpacer, &w);

        /* Now set the toolbar size and Y scroll offset to show only the buttons */

        toolbars_set_size(t,
                          toolbars_button_height(b),
                          - (w.ymax - w.ymin) + toolbars_bar_overlap(t),
                          controls.swap_bars ? InternalBottomLeft : InternalTopLeft);
      }

      /* URL bar and button bar both absent */

      else toolbox_hide_object(0, t);
    }
  }

  if (flags & InternalBottomLeft)
  {
    t = toolbars_get_lower(b);

    if (t)
    {
      dprintf(("TBar", "toolbars_set_presence: Bottom left toolbar ID is %p\n",(void *) t));

      /* Status bar present */

      if (b->status_bar) ChkError(toolbox_show_object(0, t, 0, NULL, o, -1));

      /* Status bar absent */

      else ChkError(toolbox_hide_object(0, t));
    }
  }

  /* Make sure that the toolbars have the correct gadget positions */

  if (choices.move_gadgets != Choices_MoveGadgets_Never) toolbars_move_gadgets(b);

//  /* Make sure that the window is completely redrawn */
//
//  {
//    WimpGetWindowStateBlock s;
//    s.window_handle = b->window_handle;
//    ChkError(wimp_get_window_state(&s));
//    coords_box_toworkarea(&s.visible_area, (WimpRedrawWindowBlock *) &s);
//    ChkError(wimp_force_redraw(b->window_handle,
//                               s.visible_area.xmin,
//                               s.visible_area.ymin,
//                               s.visible_area.xmax,
//                               s.visible_area.ymax));
//  }

  dprintf(("TBar", "\ntoolbars_set_presence: Successful\n"));
}

/**************************************************************/
/* toolbars_move_gadgets()                                    */
/*                                                            */
/* Generally called as part of some window resize event, this */
/* function moves and/or resizes various gadgets in various   */
/* toolbars, if the toolbars are present in the window.       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the toolbars.                                  */
/**************************************************************/

void toolbars_move_gadgets(browser_data * p)
{
  BBox                      b, g1, g2;
  int                       right, gap, width;
  ObjectId                  t;
  WimpGetWindowStateBlock   s;
  _kernel_oserror         * e;

  dprintf(("TBar", "\ntoolbars_move_gadgets: Called\n"));

  /* Small fetch windows can't move their status line contents */

  if (p->small_fetch) return;

  /* Otherwise, continue as normal */

  s.window_handle = p->window_handle;
  ChkError(wimp_get_window_state(&s));

  b = s.visible_area;
  if ((b.xmax - b.xmin) < controls.minimum_convergence) b.xmax = b.xmin + controls.minimum_convergence;

  /* If the URL bar is present... */

  if (p->url_bar)
  {
    t = toolbars_get_upper(p);

    if (t)
    {
      /* If the pop-up menu gadget for the History list needs to move, move it */
      /* and resize the URL writable to maintain a fixed distance between the  */
      /* two gadgets.                                                          */

      e      = gadget_get_bbox(0, t, URLBarHistoryMenuR, &g1);  /* Get the popup's bounding box    */
      ChkError(gadget_get_bbox(0, t, URLBarWrit,  &g2)); /* Get the writable's bounding box */

      /* Where should the right hand edge of the popup be? */

      right = b.xmax - b.xmin - 4;

      /* If the popup doesn't exist, want to set up a BBox as if a zero */
      /* width popup was present.                                       */

      if (e) g1.xmin = g2.xmax, g1.ymin = 0, g1.xmax = !right, g1.ymax = 0;

      /* Gap is the distance between the right hand edge of the URL writable */
      /* and the left hand edge of the popup.                                */

      gap = g1.xmin - g2.xmax;

      /* Is this the same as it is already? If not, move / resize the gadgets. */

      if (right != g1.xmax)
      {
        if (!e)
        {
          /* Move the popup */

          width = g1.xmax - g1.xmin;

          g1.xmax = right;
          g1.xmin = right - width;

          ChkError(gadget_move_gadget(0, t, URLBarHistoryMenuR, &g1));
        }

        /* Resize the URL writable */

        g2.xmax = g1.xmin - gap;

        ChkError(gadget_move_gadget(0, t, URLBarWrit,  &g2));
      }
    }
  }

  /* If the status bar is present... */

  if (p->status_bar)
  {
    t = toolbars_get_lower(p);

    if (t)
    {
      /* As above, move the byte counter display field if need be, */
      /* and if it does move, resize the status display field.     */

      ChkError(gadget_get_bbox(0, t, StatusBarProgress, &g1));
      ChkError(gadget_get_bbox(0, t, StatusBarStatus, &g2));

      gap = g1.xmin - g2.xmax;

      right = b.xmax - b.xmin - 20;

      if (right != g1.xmax)
      {
        width = g1.xmax - g1.xmin;

        g1.xmax = right;
        g1.xmin = right - width;

        ChkError(gadget_move_gadget(0, t, StatusBarProgress, &g1));

        g2.xmax = g1.xmin - gap;

        ChkError(gadget_move_gadget(0, t, StatusBarStatus, &g2));
      }
    }
  }

  dprintf(("TBar", "toolbars_move_gadgets: Successful\n"));
}

/**************************************************************/
/* toolbars_animation_set_sprite()                            */
/*                                                            */
/* Sets the sprite in the button gadget used for the status   */
/* bar animation.                                             */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the animation.                                 */
/**************************************************************/

static _kernel_oserror * toolbars_animation_set_sprite(browser_data * b)
{
  ObjectId t;
  char     v[32];
  int      time_now;

  /* Update the current frame time */

  if (
       _swix(OS_ReadMonotonicTime,
             _OUT(0),

             &time_now)
     )
     b->current_time = 0;

  else b->current_time = time_now;

  /* Find the status bar object Id */

  t = toolbars_get_lower(b);
  if (!t) return 0;

  /* Advance the frame counter and put a validation string  */
  /* that would give a button gadget the relevant animation */
  /* sprite into v.                                         */

  b->current_frame ++;
  if (b->current_frame >= animation_frames) b->current_frame = 0;

  sprintf(v, "sa%d\0", b->current_frame);

  /* Set the validation string on the status bar animation */
  /* button icon to v, so that the new sprite is shown.    */

  return button_set_validation(0, t, StatusBarAnimAnim, v);
}

/**************************************************************/
/* toolbars_animation()                                       */
/*                                                            */
/* Advances the browser animation in the status bar by one    */
/* frame.                                                     */
/*                                                            */
/* Parameters are as for a standard Wimp event handler (this  */
/* is called on null events).                                 */
/**************************************************************/

int toolbars_animation(int eventcode, WimpPollBlock * b, IdBlock * idb, browser_data * handle)
{
  int time_now;

  /* What is the time now? */

  if (
       _swix(OS_ReadMonotonicTime,
             _OUT(0),

             &time_now)
     )
     return 0;

  /* If we have animation frames, a displayed status bar, and */
  /* enough time has passed, advance the animation.           */

  if (
       handle->status_bar   &&
       animation_frames > 0 &&
       time_now         > (handle->current_time + controls.anim_delay)
     )
     ChkError(toolbars_animation_set_sprite(handle));

  return 0;
}

/**************************************************************/
/* toolbars_animation_drift()                                 */
/*                                                            */
/* Advances the browser animation in the status bar by one    */
/* frame, until it reaches the first frame, when it           */
/* deregisters itself.                                        */
/*                                                            */
/* Parameters are as for a standard Wimp event handler (this  */
/* is called on null events).                                 */
/**************************************************************/

int toolbars_animation_drift(int eventcode, WimpPollBlock * b, IdBlock * idb, browser_data * handle)
{
  int time_now;

  /* What is the time now? */

  if (
       _swix(OS_ReadMonotonicTime,
             _OUT(0),

             &time_now)
     )
     return 0;

  if (
       handle->status_bar   &&
       animation_frames > 0 &&
       time_now         > (handle->current_time + controls.anim_delay)
     )
  {
    ChkError(toolbars_animation_set_sprite(handle));

    /* Deregister the handler if at frame 0. */

    if (handle->current_frame == 0)
    {
      deregister_null_claimant(Wimp_ENull, (WimpEventHandler *) toolbars_animation_drift, handle);
      handle->anim_drift = 0;
    }
  }

  return 0;
}

/**************************************************************/
/* toolbars_animate_slow()                                    */
/*                                                            */
/* Advances an animation in component StatusBarAnimAnim (see  */
/* Toolbars.h) in an object of ID given in void * handle      */
/* (must be cast to this to fit as a Wimp event handler) by   */
/* one frame for each complete cycle of the main status       */
/* animation (whether that is actually animating or not).     */
/*                                                            */
/* So that more than one dialogue could be up and animating   */
/* at once, the object's client handle is used to store the   */
/* current animation frame. Consequently this routine is of   */
/* no use to dialogues that need the client handle for other  */
/* reasons.                                                   */
/*                                                            */
/* Parameters are as for a standard Wimp event handler (this  */
/* is called on null events).                                 */
/**************************************************************/

int toolbars_animate_slow(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  ObjectId o = (ObjectId) handle;
  char     v[32];
  int      slow_animation_frame;

  /* Because client handles can only store one thing, in this case */
  /* the animation frame, we have no easy way of storing the time  */
  /* that the animation was last advanced by a frame. So, make the */
  /* assumption of a 1cs poll time, and use a strategy of integer  */
  /* division of frame count to get the actual frame number. The   */
  /* timing is thus not at all independent of machine load, but    */
  /* the dialogue box animations are a very low priority issue.    */

  if (toolbox_get_client_handle(0, o, (void **) &slow_animation_frame)) return 0;

  /* Advance the frame counter and put a validation string  */
  /* that would give a button gadget the relevant animation */
  /* sprite into v.                                         */

  slow_animation_frame ++;
  if (slow_animation_frame >= animation_frames * animation_frames * controls.anim_delay) slow_animation_frame = 0;

  sprintf(v, "sa%d\0", slow_animation_frame / (animation_frames * controls.anim_delay));

  /* Set the validation string on the status bar animation */
  /* button icon to v, so that the new sprite is shown.    */

  button_set_validation(0, o, StatusBarAnimAnim, v);
  toolbox_set_client_handle(0, o, (void *) slow_animation_frame);

  return 0;
}

/**************************************************************/
/* toolbars_hide_cgi()                                        */
/*                                                            */
/* This routine will look through a URL for a ? and turn it   */
/* into a terminator. This can be used to hide CGI            */
/* information from the user.                                 */
/*                                                            */
/* Parameters: Pointer to the URL, which must be writable in  */
/*             memory, as the first '?' it contains (if any)  */
/*             will be turned into a zero byte.               */
/**************************************************************/

void toolbars_hide_cgi(char * url)
{
  char * search = url;

  while (*search)
  {
    if (*search == '?')
    {
      *search = '\0';
      break;
    }

    search++;
  }
}

/**************************************************************/
/* toolbars_hide_internal()                                   */
/*                                                            */
/* When passed a pointer to an internal URL, this routine     */
/* finds the separator between the internal specifier plus    */
/* message token and the extra information in the URL, and    */
/* copies this extra data down to the start of the URL.       */
/*                                                            */
/* Parameters: Pointer to the URL, which may be altered quite */
/*             significantly; so this should be a local copy  */
/*             held by the caller to avoid corrupting any     */
/*             important full version of the URL.             */
/**************************************************************/

void toolbars_hide_internal(char * iurl)
{
  char * extra;
  int    exoff;

  exoff = urlutils_internal_extra(iurl);
  if (!exoff) return;

  extra = iurl + exoff;

  memmove(iurl, extra, strlen(extra) + 1);
}

/**************************************************************/
/* toolbars_update_status()                                   */
/*                                                            */
/* The standard external way of updating a browser window's   */
/* status bar. The given requests that a given message type   */
/* (see the definition of status_type in Toolbars.h) be used  */
/* for the status bar.                                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which wants   */
/*             the message putting in its (or its ancestor's) */
/*             status bar;                                    */
/*                                                            */
/*             Type of message to display.                    */
/**************************************************************/

_kernel_oserror * toolbars_update_status(browser_data * b, status_type type)
{
  _kernel_oserror * e;
  browser_data    * ancestor = utils_ancestor(b);
  status_content  * contents;
  int               i, found;

  dprintf(("TBar", "toolbars_update_status: Called for %p, type %d\n",b,type));

  /* Refer to the array through 'contents' - slightly more   */
  /* convenient than 'ancestor->status_contents' every time! */

  contents = ancestor->status_contents;

  /* See if the given browser has already got a message */
  /* registered with the base browser...                */

  if (contents)
  {
    #ifdef TRACE
      {
        dprintf(("TBar", "\ntoolbars_update_status:"));
        dprintf(("TBar", "\nUpdating for browser %p; old contents:\n",b));

        dprintf(("TBar", "\nEntry | b        | Message    | Decay"));
        dprintf(("TBar", "\n------+----------+------------+------\n"));

        for (i = 0; i < ancestor->nstatus; i++)
        {
          switch (contents[i].type)
          {
            default: dprintf(("Tbar", "%d     | %08X | %02d UNKNOWN | %d\n",i, (int) contents[i].b, contents[i].type, contents[i].end - contents[i].start)); break;

            case 0:  dprintf(("Tbar", "%d     | %08X | %02d Ready   | %d\n",i, (int) contents[i].b, contents[i].type, contents[i].end - contents[i].start)); break;
            case 1:  dprintf(("Tbar", "%d     | %08X | %02d Viewing | %d\n",i, (int) contents[i].b, contents[i].type, contents[i].end - contents[i].start)); break;

            case 2:  dprintf(("Tbar", "%d     | %08X | %02d Format  | %d\n",i, (int) contents[i].b, contents[i].type, contents[i].end - contents[i].start)); break;
            case 3:  dprintf(("Tbar", "%d     | %08X | %02d Process | %d\n",i, (int) contents[i].b, contents[i].type, contents[i].end - contents[i].start)); break;
            case 4:  dprintf(("Tbar", "%d     | %08X | %02d GetPics | %d\n",i, (int) contents[i].b, contents[i].type, contents[i].end - contents[i].start)); break;
            case 5:  dprintf(("Tbar", "%d     | %08X | %02d Fetch   | %d\n",i, (int) contents[i].b, contents[i].type, contents[i].end - contents[i].start)); break;

            case 6:  dprintf(("Tbar", "%d     | %08X | %02d LinkTo  | %d\n",i, (int) contents[i].b, contents[i].type, contents[i].end - contents[i].start)); break;
            case 7:  dprintf(("Tbar", "%d     | %08X | %02d Help    | %d\n",i, (int) contents[i].b, contents[i].type, contents[i].end - contents[i].start)); break;
          }
        }

        dprintf(("TBar", "\n"));
      }
    #endif

    /* Loop round all the status entries, looking for */
    /* one which matches the given browser_data.      */
    /* If found, set 'found' to the array index of    */
    /* that entry.                                    */

    found = -1;

    for (i = 0; i < ancestor->nstatus; i++)
    {
      if (contents[i].b == b)
      {
        found = i;
        break;
      }
    }
  }
  else
  {
    found = -1;

    dprintf(("TBar", "\ntoolbars_update_status:"
                     "\nUpdating for browser &%08X; this has no contents array.\n\n",

                     (int) b));
  }

  /* If not found, add an entry for this browser */

  if (found < 0)
  {
    dprintf(("TBar", "toolbars_update_status: Adding item\n"));

    e = toolbars_add_status_item(ancestor);
    if (e) return e;

    found    = ancestor->nstatus - 1;
    contents = ancestor->status_contents;

    if (contents && found >= 0)
    {
      contents[found].b     = b;
      contents[found].start = 0;
      contents[found].end   = 0;
      contents[found].type  = Toolbars_Status_NoType;
    }
  }

  /* Proceed if there's definitely an entry to proceed with... */

  if (contents && found >= 0)
  {
    dprintf(("TBar", "toolbars_update_status: Exitting through toolbars_update_specific_status\n"));

    return toolbars_update_specific_status(b, ancestor, found, type);
  }
  else
  {
    dprintf(("TBar", "toolbars_update_status: Failed, exitting quietly\n"));

    return NULL;
  }
}

/**************************************************************/
/* toolbars_update_specific_status()                          */
/*                                                            */
/* Updates the given browser's given entry in the given       */
/* ancestor's status_content array the given message type...  */
/* Messages will only be allowed to rise in priority, with    */
/* the timeouts on all messages dealing with letting things   */
/* fall back again.                                           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which owns    */
/*             the entry to be updated;                       */
/*                                                            */
/*             Pointer to the ancestor browser_data struct    */
/*             holding the status_content array;              */
/*                                                            */
/*             Index of the entry to update;                  */
/*                                                            */
/*             Message type to update it with.                */
/**************************************************************/

static _kernel_oserror * toolbars_update_specific_status(browser_data * b, browser_data * ancestor, int entry, status_type type)
{
  _kernel_oserror * e;
  status_content  * contents = ancestor->status_contents;
  int               timeout  = 0;
  int               highest;

  dprintf(("TBar", "toolbars_update_specific_status: Called for %p (ancestor %p)\n", b, ancestor));

  /* This should never happen, but be defensive anyway... Fail */
  /* if the ancestor seems to have no status_content array.    */

  if (!contents || !ancestor->nstatus)
  {
    #ifdef TRACE
      erb.errnum = Utils_Error_Custom_Normal;

      StrNCpy0(erb.errmess,
               "No status_content array in toolbars_update_specific_status")

      show_error_ret(&erb);
    #endif

    return NULL;
  }

  /* If the message type requested is lower priority */
  /* than that already in use by this browser, don't */
  /* do anything - let the timeouts handle it.       */

  if (type < contents[entry].type) return NULL;

  /* Otherwise, update the message type */

  contents[entry].type = type;

  /* Reset the timeout counter */

  e = _swix(OS_ReadMonotonicTime,
            _OUT(0),

            &contents[entry].start);

  switch (contents[entry].type)
  {
    case Toolbars_Status_NoType:
    case Toolbars_Status_Ready:
    case Toolbars_Status_Viewing:
    {
      /* For the idle cases, set all timers to zero */

      contents[entry].start = timeout = 0;
    }
    break;

    default:
    case Toolbars_Status_Formatting:
    case Toolbars_Status_Processing:
    case Toolbars_Status_GetPics:
    case Toolbars_Status_Fetching:
    case Toolbars_Status_Connected:
    case Toolbars_Status_SentReq:
    case Toolbars_Status_Responded:
    case Toolbars_Status_Redirected:
    case Toolbars_Status_Connecting:
    {
      /* For some messages, a general timeout */

      timeout = atoi(lookup_control("ShowMiscFor:50",0,0));
    }
    break;

    case Toolbars_Status_PlugIn:
    {
      /* For Plug-In messages, use the Plug-in status timeout */

      timeout = atoi(lookup_control("ShowPlugInFor:150",0,0));
    }
    break;

    case Toolbars_Status_LinkTo:
    {
      /* Specific timeout for LinkTo messages */

      timeout = atoi(lookup_control("ShowLinksFor:200",0,0));
    }
    break;

    case Toolbars_Status_Help:
    {
      /* Specific timeout for Help messages */

      timeout = atoi(lookup_control("ShowHelpFor:600",0,0));
    }
    break;
  }

  contents[entry].end = contents[entry].start + timeout;

  /* Now reflect the highest priority message of the array */

  highest = toolbars_write_status(ancestor);

  /* Work out if the timeout handler needs to be registered */
  /* or deregistered.                                       */

  switch (highest)
  {
    case Toolbars_Status_NoType:
    case Toolbars_Status_Ready:
    case Toolbars_Status_Viewing:
    {
      /* If the highest priority is an idle case and the handler is */
      /* registered, deregister it.                                 */

      if (ancestor->status_handler)
      {
        ancestor->status_handler = 0;

        deregister_null_claimant(Wimp_ENull,
                                 (WimpEventHandler *) toolbars_timeout_status,
                                 ancestor);
      }
    }
    break;

    default:
    {
      /* Otherwise, for non-idle cases, register the handler if it */
      /* isn't already present.                                    */

      if (!ancestor->status_handler)
      {
        ancestor->status_handler = 1;

        register_null_claimant(Wimp_ENull,
                               (WimpEventHandler *) toolbars_timeout_status,
                               ancestor);
      }

    }
    break;
  }

  /* Finished */

  dprintf(("TBar", "toolbars_update_specific_status: Successful\n"));

  return NULL;
}

/**************************************************************/
/* toolbars_write_status()                                    */
/*                                                            */
/* Reflects the highest priority message in a status_content  */
/* array in the status bar of the array's owner.              */
/*                                                            */
/* Called by toolbars_update_status as part of its normal     */
/* operation.                                                 */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which is an   */
/*             ancestor holding a status_content array.       */
/*                                                            */
/* Returns:    The message type that was chosen as the        */
/*             highest priority.                              */
/*                                                            */
/* Assumes:    That the ancestor browser_data pointer is not  */
/*             NULL.                                          */
/**************************************************************/

static int toolbars_write_status(browser_data * ancestor)
{
  char             new_status [Limits_StatusBarStatus];
  char             url        [Limits_StatusBarStatus];
  char           * use_status = new_status;
  int              dontappend = 0;
  int              found      = -1;
  int              i, count;
  status_type      highest;
  ObjectId         t;
  browser_data   * priority;
  status_content * contents = ancestor->status_contents;

  /* Fail if there's no status_content array */

  if (!contents || !ancestor->nstatus)
  {
    #ifdef TRACE
      erb.errnum = Utils_Error_Custom_Normal;

      StrNCpy0(erb.errmess,
               "No status_content array in toolbars_write_status")

      show_error_ret(&erb);
    #endif

    return 0;
  }

  /* Get the ID of the toolbar in which the status bar resides */

  t = toolbars_get_lower(ancestor);
  if (!t) return 0;

  /* Examine all entries for the highest priority message */

  highest = Toolbars_Status_NoType;
  count   = 0;

  for (i = 0; i < ancestor->nstatus; i++)
  {
    /* If the message for this entry is higher than the highest recorded */
    /* so far, then record this message as the highest. Reset the count  */
    /* of the number of times this message has been encountered to zero  */
    /* and remember the index into the array in 'found'.                 */

    if (contents[i].type > highest) highest = contents[i].type, count = 1, found = i;

    /* If the message for this entry is the same as the highest recorded */
    /* so far, then increment the count of the number of times the       */
    /* message has been encountered.                                     */

    else if (contents[i].type == highest) count++;
  }

  /* Now have the highest priority message in 'highest', the number of  */
  /* times it has been requested in 'count', and the index of the first */
  /* occurrence of this message in 'found'.                             */

  priority = contents[found].b;

  /* According to the highest priority message, write the new status into 'new_status' */

  switch (highest)
  {
    default:                     /* (Drop through */
    case Toolbars_Status_Ready:  /* to Viewing)   */
    case Toolbars_Status_Viewing:
    {
      char title[Limits_Title];

      *title = 0;

      /* Try to get the window's title. If this generates an error or   */
      /* is equal to the 'blank page' case, use 'Ready' for the status. */

      if (
           window_get_title(0, ancestor->self_id, title, sizeof(title), NULL) ||
           !strcmp(title, lookup_token("BlankPage:Blank page",0,0))
         )
         StrNCpy0(new_status, lookup_token("Ready:Ready",0,0))

      else
      {
        char format[Limits_StatusFormat];

        title[sizeof(title) - 1] = 0;

        StrNCpy0(format, lookup_token("Page:Viewing '%s'",0,0))
        StrNCpy0(url, title)

        url[sizeof(new_status) - strlen(format) - 1] = 0;
        sprintf(new_status, format, url);
      }

      /* Append an 'active' suffix if needed */

      if (priority->anim_handler || priority->plugin_active)
      {
        char * active = lookup_token("Actv: (active)",0,0);

        if (strlen(active) + strlen(new_status) + 1 < sizeof(new_status)) strcat(new_status, active);
      }

      /* If preceeded by a '-' don't ever append a progress counter */

      if (new_status[0] == '-') use_status++, dontappend = 1;
    }
    break;

    case Toolbars_Status_GetPics:
    {
      int images = image_count_pending(ancestor);

      if (images == 1) StrNCpy0(new_status, lookup_token("GetPic:Fetching 1 image...", 0, 0))
      else if (images)  sprintf(new_status, lookup_token("GetPics:Fetching %d images...", 0, 0), images);
      else             StrNCpy0(new_status, lookup_token("GetPic0:All current images fetched...", 0, 0));

      if (new_status[0] == '-') use_status++, dontappend = 1;
    }
    break;

    case Toolbars_Status_Fetching:   /* (Drop through  */
    case Toolbars_Status_Processing: /* to Formatting) */
    case Toolbars_Status_Connected:
    case Toolbars_Status_SentReq:
    case Toolbars_Status_Responded:
    case Toolbars_Status_Redirected:
    case Toolbars_Status_Connecting:
    case Toolbars_Status_Formatting:
    {
      char format[Limits_StatusFormat];

      /* For many occurrences, report an appropriate 'cumulative' */
      /* message; otherwise, report the one specific case.        */
      /*                                                          */
      /* If the browser has a parent - i.e. this is a frames      */
      /* document - then the 'many' equivalents are always used;  */
      /* this is to stop flickering between the 'single' and      */
      /* 'many' states during a fetch/reformat/etc.               */

      if (count > 1 || priority->real_parent)
      {
        if (highest == Toolbars_Status_Fetching)
        {
          /* This one is a little special, as we could be saving an object to disc */
          /* and the user may not have dealt with the save dialogue yet.           */

          if (priority->fetch_status == BS_DATAFETCH && !priority->save_file)
          {
            StrNCpy0(new_status, lookup_token("FetchWait:Waiting for a Save dialogue to be dealt with...", 0, 0))
          }
          else
          {
            StrNCpy0(new_status, lookup_token("FetchMany:Fetching frame contents...", 0, 0))
          }
        }

        /* Simpler cases */

        else if (highest == Toolbars_Status_Processing) StrNCpy0(new_status, lookup_token("ProcessMany:Processing frames contents...",                      0, 0))
        else if (highest == Toolbars_Status_Connected)  StrNCpy0(new_status, lookup_token("ConnectedMany:Connected to servers to fetch frames contents...", 0, 0))
        else if (highest == Toolbars_Status_SentReq)    StrNCpy0(new_status, lookup_token("SentReqMany:Sent requests to fetch frames contents...",          0, 0))
        else if (highest == Toolbars_Status_Responded)  StrNCpy0(new_status, lookup_token("RespondedMany:Responses received for frames contents...",        0, 0))
        else if (highest == Toolbars_Status_Connecting) StrNCpy0(new_status, lookup_token("ConnectingMany:Trying to connect to fetch frames contents...",   0, 0))
        else if (highest == Toolbars_Status_Redirected) StrNCpy0(new_status, lookup_token("RedirectedMany:Frame fetches are being redirected...",           0, 0))
        else                                            StrNCpy0(new_status, lookup_token("FormatMany:Formatting frames contents...",                       0, 0))
      }
      else
      {
        /* Find the URL to display, if any */

        if      (browser_fetch_url  (priority)) StrNCpy0(url, browser_fetch_url  (priority))
        else if (browser_current_url(priority)) StrNCpy0(url, browser_current_url(priority))
        else *url = 0;

        if (*url)
        {
          /* Get the Messages file token as a format string for sprintf, into */
          /* which the URL can be substituted.                                */

          if (highest == Toolbars_Status_Fetching)
          {
            if (priority->fetch_status == BS_DATAFETCH && !priority->save_file)
            {
              StrNCpy0(format, lookup_token("FetchWait:Waiting for a Save dialogue to be dealt with...", 0, 0))
            }
            else
            {
              StrNCpy0(format, lookup_token("Fetch:Fetching '%s'...", 0, 0))
            }
          }
          else if (highest == Toolbars_Status_Processing) StrNCpy0(format, lookup_token("Process:Processing '%s'...",                        0, 0))
          else if (highest == Toolbars_Status_Connected)  StrNCpy0(format, lookup_token("Connected:Connected to server to fetch '%s'...",    0, 0))
          else if (highest == Toolbars_Status_SentReq)    StrNCpy0(format, lookup_token("SentReq:Sent request to fetch '%s'...",             0, 0))
          else if (highest == Toolbars_Status_Responded)  StrNCpy0(format, lookup_token("RespondedMany:Response received for '%s'...",       0, 0))
          else if (highest == Toolbars_Status_Connecting) StrNCpy0(format, lookup_token("ConnectingMany:Trying to connect to fetch '%s'...", 0, 0))
          else if (highest == Toolbars_Status_Redirected) StrNCpy0(format, lookup_token("RedirectedMany:Redirecting to '%s'...",             0, 0))
          else                                            StrNCpy0(format, lookup_token("Format:Formatting '%s'...",                         0, 0))

          /* Possibly hide CGI information in the URL */

          #ifdef HIDE_CGI
            toolbars_hide_cgi(url);
          #endif

          /* Ensure the URL isn't too long to fit int he new_status */
          /* buffer along with the format string defined above. If  */
          /* the format string comes from a messages file we can't  */
          /* make assumptions about how many of its characters will */
          /* actually appear in the final output string after the   */
          /* sprintf call, so we must treat it as if they all will  */
          /* appear - hence the ' - 1'.                             */

          url[sizeof(new_status) - strlen(format) - 1] = 0;

          toolbars_hide_internal(url);

          /* Write the combined message into new_status */

          sprintf(new_status, format, url);
        }
        else
        {
          /* The URL is not known, so can do a direct lookup into new_status */

          if (highest == Toolbars_Status_Fetching)
          {
            if (priority->fetch_status == BS_DATAFETCH && !priority->save_file)
            {
              StrNCpy0(new_status, lookup_token("FetchWait:Waiting for a Save dialogue to be dealt with...", 0, 0))
            }
            else
            {
              StrNCpy0(new_status, lookup_token("FetchUK:Fetching web page...", 0, 0))
            }
          }
          else if (highest == Toolbars_Status_Processing) StrNCpy0(new_status, lookup_token("ProcessUK:Processing web page...",            0, 0))
          else if (highest == Toolbars_Status_Connected)  StrNCpy0(new_status, lookup_token("ConnectedUK:Connected to server...",          0, 0))
          else if (highest == Toolbars_Status_SentReq)    StrNCpy0(new_status, lookup_token("SentReqUK:Sent request for web page...",      0, 0))
          else if (highest == Toolbars_Status_Responded)  StrNCpy0(new_status, lookup_token("RespondedUK:Server response received...",     0, 0))
          else if (highest == Toolbars_Status_Connecting) StrNCpy0(new_status, lookup_token("ConnectingUK:Trying to connect to server...", 0, 0))
          else                                            StrNCpy0(new_status, lookup_token("FormatUK:Formatting web page...",             0, 0))
        }
      }

      if (new_status[0] == '-') use_status++, dontappend = 1;
    }
    break;

    case Toolbars_Status_Help:
    {
      StrNCpy0(new_status, priority->status_help);

      dontappend = 1;
    }
    break;

    case Toolbars_Status_LinkTo:
    {
      HStream * over;
      char      format[Limits_StatusFormat];
      int       allowed;
      int       dealt_with = 0;

      /* For comments on the use of the 'format' buffer, see the */
      /* code above.                                             */

      over = priority->pointer_over;

      /* If the token that the pointer is over isn't suitable for a LinkTo */
      /* message, use the keyboard selected item instead; so the pointer   */
      /* always takes priority over the keyboard.                          */

      if (
           !over ||
           (
             (
               !over->anchor  ||
               !*over->anchor
             )
             && !(over->type & (TYPE_ISMAP | TYPE_ISCLIENTMAP))
           )
         )
         over = ancestor->selected;

      /* So, do we now have a suitable token, be it from the token the */
      /* pointer was over or whatever is keyboard selected?            */

      if (
           over &&
           (
             (
               over->anchor &&
               *over->anchor
             )
             || (over->type & (TYPE_ISMAP | TYPE_ISCLIENTMAP))
           )
         )
      {
        /* Yes, so create an appropriate status message. */

        StrNCpy0(format, lookup_token("LinkTo:Link to '%s'...",0,0));

        /* If a client-side image map, must work out the URL */

        if (over->type & TYPE_ISCLIENTMAP)
        {
          char * csim_url;

          csim_return_info(priority,
                           over,
                           priority->map_x,
                           priority->map_y,
                           &csim_url,
                           NULL,
                           NULL);

          if (csim_url && *csim_url)
          {
            dealt_with = 1;

            StrNCpy0(url, csim_url)
          }
        }

        /* If a server side map and either not client side as well, */
        /* or the client side map gave us no URL, use the anchor    */
        /* instead, and append coordinate information.              */
        /*                                                          */
        /* If not server side, just use the anchor information in   */
        /* the token on its own.                                    */

        if (!dealt_with && over->anchor && *over->anchor)
        {
          StrNCpy0(url, over->anchor);

          #ifdef HIDE_CGI
            toolbars_hide_cgi(url);
          #endif

          allowed          = sizeof(new_status) - strlen(format);
          url[allowed - 1] = 0;

          toolbars_hide_internal(url);

          /* If a server-side map, want to append coordinate info. */

          if (over->type & TYPE_ISMAP)
          {
            int required = utils_number_length(priority->map_x) +
                           utils_number_length(priority->map_y) +
                           5; /* 5 = length of " (, )" */

            if (strlen(url) + required + 1 <= allowed)
            {
              char append[128];

              sprintf(append, " (%d, %d)", priority->map_x, priority->map_y);

              strcat(url, append);
            }
          }

          dealt_with = 1;
        }
      }

      /* Did we end up with something we can use in a LinkTo message? */

      if (dealt_with)
      {
        /* Yes, so compile the final message together now */

        sprintf(new_status, format, url);
        if (new_status[0] == '-') use_status++, dontappend = 1;
      }
      else
      {
        /* No suitable token, so the message is out of date; that */
        /* is, no object is selected (say) but the message is     */
        /* still on a timer. In that case, cancel it.             */

        toolbars_cancel_status(priority, highest);

        return Toolbars_Status_Ready;
      }
    }
    break;

    case Toolbars_Status_PlugIn:
    {
      StrNCpy0(new_status, priority->plugin_status ? priority->plugin_status : "");

      dontappend = 1;
    }
    break;
  }

  /* Right, finally have a message in new_status. Now */
  /* append the fetch progress, if required.          */
  /*                                                  */
  /* Any messages starting with '-' will never have a */
  /* counter appended, as dontappend will have been   */
  /* set to 1 by things checking this above.          */

  if (controls.append_status && !dontappend)
  {
    char progress[Limits_FetchProgress];
    int  add;

    toolbars_create_progress(contents[found].b, progress, sizeof(progress));

    add = 1 + 1 + (controls.use_brackets ? 2 : 0); /* (Terminating byte, plus separating space, possibly plus 2 brackets) */

    /* Only proceed if there's room for the extra text */

    if (strlen(new_status) + strlen(progress) + add <= sizeof(new_status))
    {
      /* Concatenate the extra text */

      strcat(new_status, " ");
      if (controls.use_brackets) strcat(new_status, "(");
      strcat(new_status, progress);
      if (controls.use_brackets) strcat(new_status, ")");
    }
  }

  /* Check that the string isn't the same as already */
  /* present, and if not, update the status bar. The */
  /* 'url' char array used temporarily is now free,  */
  /* with the new status line in new_status, so we   */
  /* can reuse that here.                            */

  ChkError(displayfield_get_value(0, t, StatusBarStatus, url, sizeof(url),NULL));

  if (
       strcmp(use_status, url)
     )
  {
    /* If the string has changed, display it */

    ChkError(displayfield_set_value(0,
                                    t,
                                    StatusBarStatus,
                                    use_status));

    /* Ensure the toolbar buttons are up to date in light of the new status */

    ChkError(toolbars_set_button_states(priority));
  }

  dprintf(("TBar", "toolbars_write_status: Successful, returning with message type &%08X\n", (int) priority));

  return highest;
}

/**************************************************************/
/* toolbars_cancel_status()                                   */
/*                                                            */
/* toolbars_remove_status_item is used to remove a browser    */
/* from its ancestor's array of status_content structures     */
/* because the browser is about to become invalid (e.g. be    */
/* deleted because its associated window was closed).         */
/*                                                            */
/* This function is used if an existing browser wants to      */
/* cancel a message it registered earlier, before it times    */
/* out. The message type that is being cancelled must be      */
/* stated; if the browser's entry in the status_content array */
/* does not record this type, no action will be taken.        */
/* Otherwise the message will be cancelled as asked.          */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which wants   */
/*             the message cancelling;                        */
/*                                                            */
/*             Message type that it wants to remove.          */
/**************************************************************/

_kernel_oserror * toolbars_cancel_status(browser_data * b, status_type type)
{
  browser_data    * ancestor = utils_ancestor(b);
  status_content  * contents;
  int               i, found;

  dprintf(("TBar", "toolbars_cancel_status: Called for %p, type %d\n",b,type));

  contents = ancestor->status_contents;
  if (!contents || !ancestor->nstatus)
  {
    dprintf(("TBar", "toolbars_cancel_status: Exitting - ancestor has no array\n"));

    return NULL;
  }

  /* Find the entry */

  found = -1;

  for (i = 0; i < ancestor->nstatus; i++)
  {
    if (contents[i].b == b)
    {
      found = i;
      break;
    }
  }

  /* If not found, exit */

  if (found < 0)
  {
    dprintf(("TBar", "toolbars_cancel_status: Exitting - can't find entry\n"));

    return NULL;
  }

  /* If not the given message type, exit */

  if (contents[found].type != type)
  {
    dprintf(("TBar", "toolbars_cancel_status: Exitting - entry message type %d doesn't match given type %d\n", contents[found].type, type));

    return NULL;
  }

  /* Otherwise, clear the message and restore something */
  /* more meaningful with the inference routine. To do  */
  /* this, we'll need to free any Plug-In message, if   */
  /* there was one.                                     */

  if (type == Toolbars_Status_PlugIn)
  {
    free(b->plugin_status);
    b->plugin_status = 0;
  }

  contents[found].start = 0;
  contents[found].end   = 0;
  contents[found].type  = Toolbars_Status_NoType;

  dprintf(("TBar", "toolbars_cancel_status: Exitting through toolbars_infer_status\n"));

  return toolbars_infer_status(b, ancestor, found);
}

/**************************************************************/
/* toolbars_cancel_all()                                      */
/*                                                            */
/* If a browser wants to cancel all messages it registered    */
/* earlier, except for LinkTo or Help messages, perhaps to    */
/* ensure that some message is displayed now rather than      */
/* after another times out, it should call this function. The */
/* original idea was for browsers that have just completed a  */
/* full fetch, which want to get rid of any timing out        */
/* formatting or fetching messages.                           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which wants   */
/*             the message cancelling.                        */
/**************************************************************/

_kernel_oserror * toolbars_cancel_all(browser_data * b)
{
  dprintf(("TBar", "toolbars_cancel_all: Called\n"));

  RetError(toolbars_cancel_status(b, Toolbars_Status_PlugIn));
  RetError(toolbars_cancel_status(b, Toolbars_Status_Connecting));
  RetError(toolbars_cancel_status(b, Toolbars_Status_Redirected));
  RetError(toolbars_cancel_status(b, Toolbars_Status_Responded));
  RetError(toolbars_cancel_status(b, Toolbars_Status_SentReq));
  RetError(toolbars_cancel_status(b, Toolbars_Status_Connected));
  RetError(toolbars_cancel_status(b, Toolbars_Status_Fetching));
  RetError(toolbars_cancel_status(b, Toolbars_Status_GetPics));
  RetError(toolbars_cancel_status(b, Toolbars_Status_Processing));
  RetError(toolbars_cancel_status(b, Toolbars_Status_Formatting));

  dprintf(("TBar", "toolbars_cancel_all: Successful\n"));

  return NULL;
}

/**************************************************************/
/* toolbars_timeout_status()                                  */
/*                                                            */
/* A null event handler registered and deregis- tered by      */
/* toolbars_update_specific_status, which handles checking    */
/* the 'start' and 'end' fields of the given ancestor         */
/* browser_data struct to see if any messages have expired.   */
/*                                                            */
/* toolbars_update_specific_status will only allow browsers   */
/* to register progressively higher priority messages than    */
/* previously registered - this routine allows those previous */
/* priorities to drop down.                                   */
/*                                                            */
/* Parameters are as standard for a Wimp null event handler   */
/* (handle = pointer to the ancestor browser_data structure). */
/**************************************************************/

int toolbars_timeout_status(int eventcode, WimpPollBlock * b, IdBlock * idb, browser_data * handle)
{
  browser_data   * ancestor = handle; /* Just to make things clearer */
  status_content * contents = ancestor->status_contents;
  int              i, timenow;

  /* Fail if there's no status_content array */

  if (!contents || !ancestor->nstatus)
  {
    #ifdef TRACE
      erb.errnum = Utils_Error_Custom_Normal;

      StrNCpy0(erb.errmess,
               "No status_content array in toolbars_timeout_status")

      show_error_ret(&erb);
    #endif

    return 0;
  }

  /* Go through all entries in the array */

  for (i = 0; i < ancestor->nstatus; i++)
  {
    if (contents[i].start > 0)
    {
      /* An active message that is timing out */

      _swix(OS_ReadMonotonicTime,
            _OUT(0),

            &timenow);

      if (contents[i].start != contents[i].end && timenow > contents[i].end)
      {
        /* Message has expired. Was it a Plug-In status message? */

        if (contents[i].type == Toolbars_Status_PlugIn)
        {
          free(ancestor->plugin_status);
          ancestor->plugin_status = NULL;
        }

        /* OK, set the status to 'nothing', then infer the current state */

        contents[i].start = 0;
        contents[i].end   = 0;
        contents[i].type  = Toolbars_Status_NoType;

        ChkError(toolbars_infer_status(contents[i].b, ancestor, i));
      }
    }
    else
    {
      /* Message has <= 0 in 'start' field; if non-idle, this is an expiry indicator */

      switch (contents[i].type)
      {
        case Toolbars_Status_NoType:
        case Toolbars_Status_Ready:
        case Toolbars_Status_Viewing:
        {
          /* Idle, so do nothing */

          i = i; /* Ensure compiler handles this OK... */
        }

        default:
        {
          /* Non-idle message; it has expired. Was it a Plug-In status message? */

          if (contents[i].type == Toolbars_Status_PlugIn)
          {
            free(ancestor->plugin_status);
            ancestor->plugin_status = NULL;
          }

          /* OK, set the status to 'nothing' */

          contents[i].start = 0;
          contents[i].end   = 0;
          contents[i].type  = Toolbars_Status_NoType;
        }
        break;
      }
    }
  }

  return 0;
}

/**************************************************************/
/* toolbars_return_inferred()                                 */
/*                                                            */
/* Looks at a given browser_data struct to work out what      */
/* state it is in, returning this information as a            */
/* status_type value (see Toolbars.h).                        */
/*                                                            */
/* Parameters: Pointer to the browser_data struct in          */
/*             question.                                      */
/*                                                            */
/* Returns:    Its status, as a status_type value.            */
/**************************************************************/

static status_type toolbars_return_inferred(browser_data * b)
{
  status_type type = Toolbars_Status_Ready;

  /* Work out what message should be displayed. */
  /* Since this is most often called when a     */
  /* status message expires, any messages which */
  /* should appear persistently in the status   */
  /* bar - such as Fetching or Viewing - should */
  /* be returned by this function. Otherwise,   */
  /* the message will be replaced by another    */
  /* that this function chooses.                */

  /* Is there a Plug-In status message? */

  if (b->plugin_status && *b->plugin_status)
  {
    type = Toolbars_Status_PlugIn;
  }

  /* Otherwise, is a page fetch in progress? */

  else
  {
    if (fetch_fetching(b))
    {
      /* If fetching, may in fact just be passing tokens through the fetcher */
      /* with no new actual data to get from the server. In that case want   */
      /* to give a 'processing' message; otherwise, definitely 'fetching'.   */

      if (b->fetch_status == BS_PROCESS) type = Toolbars_Status_Processing;
      else
      {
        /* Need to find out the genuine fetch status, or all of the */
        /* varied fetch information that we can get out of the      */
        /* fetchers gets collapsed to some less meaningful generic  */
        /* message by this routine.                                 */

        int s;

        if (!url_status(0, b->fetch_handle, &s, NULL, NULL))
        {
          if      (s & URL_Status_Transfer)  type = Toolbars_Status_Fetching;
          else if (s & URL_Status_Responded) type = Toolbars_Status_Responded;
          else if (s & URL_Status_SentReq)   type = Toolbars_Status_SentReq;
          else if (s & URL_Status_SentData)  type = Toolbars_Status_SentReq;
          else if (s & URL_Status_Connected) type = Toolbars_Status_Connected;
          else if (!s)                       type = Toolbars_Status_Connecting;
        }
        else type = Toolbars_Status_Fetching;
      }
    }
    else
    {
      int specimg;

      /* If not fetching pages, are we fetching images? If so, display an */
      /* appropriate message.                                             */

      specimg = image_count_specific_pending(b);

      if (specimg && image_fetching(b)) type = Toolbars_Status_GetPics;
      else
      {
        /* If not fetching images either, then may be formatting or idle. */

        if (reformat_formatting(b)) type = Toolbars_Status_Formatting;
        else                        type = Toolbars_Status_Viewing;
      }
    }
  }

  return type;
}

/**************************************************************/
/* toolbars_infer_status()                                    */
/*                                                            */
/* When a toolbar message in the status_content array of an   */
/* ancestor browser has expired, this routine is called to    */
/* work out what the current status for the owner browser     */
/* should be. The toolbar is appropriately updated.           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which owns    */
/*             the message;                                   */
/*                                                            */
/*             Pointer to a browser_data struct which is the  */
/*             above's ancestor;                              */
/*                                                            */
/*             Index into the ancestor's status_content array */
/*             for the message owner.                         */
/*                                                            */
/* Assumes:    That the ancestor pointer is not NULL.         */
/**************************************************************/

static _kernel_oserror * toolbars_infer_status(browser_data * b, browser_data * ancestor, int entry)
{
  status_content * contents = ancestor->status_contents;
  status_type      type;

  dprintf(("TBar", "toolbars_infer_status: Called for %p (ancestor %p)\n",b,ancestor));

  /* Fail if there's no status_content array */

  if (!contents || !ancestor->nstatus)
  {
    #ifdef TRACE
      erb.errnum = Utils_Error_Custom_Normal;

      StrNCpy0(erb.errmess,
               "No status_content array in toolbars_infer_status")

      show_error_ret(&erb);
    #endif

    return NULL;
  }

  /* Find the message type */

  type = toolbars_return_inferred(b);

  /* Exit through the toolbar update routine */

  dprintf(("TBar", "toolbars_infer_status: Exitting through toolbars_update_specific_status with type %d\n",type));

  return toolbars_update_specific_status(b, ancestor, entry, type);
}

/**************************************************************/
/* toolbars_add_status_item()                                 */
/*                                                            */
/* Adds an item to a given ancestor's array of status_content */
/* structures. The contents are not initialised - this is     */
/* left to the caller.                                        */
/*                                                            */
/* Parameters: Pointer to browser_data struct in which the    */
/*             addition should be made (i.e. the ancestor).   */
/*                                                            */
/* Assumes:    That the ancestor browser_data pointer is not  */
/*             NULL.                                          */
/**************************************************************/

static _kernel_oserror * toolbars_add_status_item(browser_data * ancestor)
{
  /* Increment the status counter */

  ancestor->nstatus ++;

  /* Allocate the required memory */

  return memory_set_chunk_size(ancestor, NULL, CK_STAT, ancestor->nstatus * sizeof(status_content));
}

/**************************************************************/
/* toolbars_remove_status_item()                              */
/*                                                            */
/* Removes a browser_data structure from its ancestor's array */
/* of status_content structs.                                 */
/*                                                            */
/* Typically called by windows_close_browser, so issues of    */
/* having children within the window relating to the given    */
/* browser are dealt with automatically (children would be    */
/* being closed through a function in Frames.c, with the      */
/* Windows.c function called as part of this).                */
/*                                                            */
/* Parameters: Pointer to the browser_data struct to remove   */
/*             from the array;                                */
/*                                                            */
/*             Pointer to the ancestor browser_data           */
/*             structure.                                     */
/*                                                            */
/* Assumes:    That the ancestor pointer is not NULL.         */
/**************************************************************/

_kernel_oserror * toolbars_remove_status_item(browser_data * b, browser_data * ancestor)
{
  status_content * contents = ancestor->status_contents;
  int              i, found;

  /* Can't proceed if the ancestor has no contents array */
  /* (this is fine, so TRACE builds don't give an error  */
  /* either).                                            */

  if (!contents || !ancestor->nstatus) return NULL;

  /* Find the browser's entry in the status contents array */

  found = -1;

  for (i = 0; i < ancestor->nstatus; i++)
  {
    if (contents[i].b == b)
    {
      found = i;
      break;
    }
  }

  /* If not found, exit */

  if (found < 0) return NULL;

  /* Otherwise, remove the entry */

  if (found < ancestor->nstatus - 1)
  {
    memmove(&contents[found],
            &contents[found + 1],
            (ancestor->nstatus - found - 1) * sizeof(status_content));
  }

  ancestor->nstatus--;

  return memory_set_chunk_size(ancestor, NULL, CK_STAT, ancestor->nstatus * sizeof(status_content));
}

/**************************************************************/
/* toolbars_return_act_status()                               */
/*                                                            */
/* Returns the highest status for the ancestor of a given     */
/* browser window that does not include non-active transient  */
/* items (specifically, LinkTo and Help messages).            */
/*                                                            */
/* This allows the caller to determine whether a browser and  */
/* any of its frames are fetching, for example.               */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the ancestor in question.                      */
/*                                                            */
/* Returns:    A status_type (see Toolbars.h) describing the  */
/*             ancestor's current status.                     */
/**************************************************************/

static status_type toolbars_return_act_status(browser_data * b)
{
  browser_data   * ancestor = utils_ancestor(b);
  status_type      highest  = Toolbars_Status_NoType;
  status_content * contents;
  int              i;

  if (!b) return Toolbars_Status_NoType;

  /* Find the highest item that isn't a LinkTo or Help message */

  contents = ancestor->status_contents;

  for (i = 0; i < ancestor->nstatus; i++)
  {
    if (
         contents[i].type == Toolbars_Status_LinkTo ||
         contents[i].type == Toolbars_Status_Help
       )
    {
      status_type type;

      /* Non-active status entry, so need to work out what */
      /* it would say if this message had timed out        */

      type = toolbars_return_inferred(b);

      if (type > highest) highest = type;
    }
    else
    {
      /* Otherwise, remember this status if its the highest */

      if (contents[i].type > highest) highest = contents[i].type;
    }
  }

  return highest;
}

/**************************************************************/
/* toolbars_update_progress()                                 */
/*                                                            */
/* Reflects a fetch's progress in the browser window's status */
/* bar.                                                       */
/*                                                            */
/* Parameters: A pointer to the browser_data structure        */
/*             associated with the fetch.                     */
/**************************************************************/

void toolbars_update_progress(browser_data * b)
{
  char              progress [Limits_StatusBarProgress];
  char              old      [Limits_StatusBarProgress];
  ObjectId          t;
  _kernel_oserror * e;
  browser_data    * ancestor = utils_ancestor(b);
  int               saves;

  /* May want to only update at specific intervals of time */

  if (
       controls.progress_update_delay   &&
       !
       (
         b->fetch_status == BS_IDLE    ||
         b->fetch_status == BS_PROCESS
       )
     )
  {
    int time_now;

    if (
         !_swix(OS_ReadMonotonicTime,
                _OUT(0),

                &time_now)
       )
    {
      if (time_now - ancestor->progress_updated < controls.progress_update_delay) return;

      ancestor->progress_updated = time_now;
    }
  }

  /* Find out how many file saves, if any, are in progress */

  saves = toolbars_create_progress(b, progress, sizeof(progress));

  /* Find the toolbar and try to get the old progress string */

  t = toolbars_get_lower(ancestor);
  if (!t) return;

  e = button_get_value(0, t, StatusBarProgress, old, sizeof(old), NULL);

  /* Only update the display field if the contents have */
  /* changed, to avoid flicker.                         */

  if (!e && strcmp(progress, old))
  {
    int flags;
    int colour_old, colour_new;

    /* Set the colour if required */

    if (controls.colour_progress != Controls_ColourProgress_NotAColour)
    {
      if (!button_get_flags(0, t, StatusBarProgress, &flags))
      {
        browser_data * ancestor = b->ancestor;

        if (!ancestor) ancestor = b;

        /* Remember the old colour, and set the new according  */
        /* to whether or not file saves are in progress. If    */
        /* there, use the Messages file defined colour; else   */
        /* use the colour recorded in the browser_data struct. */

        colour_old = (flags & 0x0f000000) >> 24;
        colour_new = saves ? controls.colour_progress : ancestor->progress_colour;

        if (colour_new != colour_old)
        {
          button_set_flags(0,
                           t,
                           StatusBarProgress,
                           0x0f000000,
                           colour_new << 24);
        }
      }
    }

    button_set_value(0, t, StatusBarProgress, progress);
  }
  else if (e && controls.append_status) toolbars_update_status(b, Toolbars_Status_Ready);
}

/**************************************************************/
/* toolbars_count_file_saves()                                */
/*                                                            */
/* Checks to see if any frames in a given frameset are saving */
/* out files.                                                 */
/*                                                            */
/* Parameters: Pointer to any browser_data structure in the   */
/*             frameset.                                      */
/*                                                            */
/* Returns:    The number of file saves going on in the       */
/*             parent and any children it might have.         */
/**************************************************************/

static int toolbars_count_file_saves(browser_data * b)
{
  browser_data * ancestor = b->ancestor;

  if (!ancestor) ancestor = b;

  return toolbars_count_file_saves_r(ancestor);
}

/**************************************************************/
/* toolbars_count_file_saves_r()                              */
/*                                                            */
/* Recursive back-end to toolbars_count_file_saves.           */
/*                                                            */
/* Parameters: Pointer to the ancestor browser_data struct in */
/*             the frameset.                                  */
/*                                                            */
/* Returns:    As toolbars_count_file_saves.                  */
/**************************************************************/

static int toolbars_count_file_saves_r(browser_data * b)
{
  int i, count = 0;

  if (b->nchildren)
  {
    for (i = 0; i < b->nchildren; i++)
    {
      count += toolbars_count_file_saves_r(b->children[i]);
    }
  }

  if (b->save_file) count ++;

  return count;
}

/**************************************************************/
/* toolbars_calculate_progress()                              */
/*                                                            */
/* Works out how much data has been fetched for a frameset.   */
/*                                                            */
/* If a file save is in progress, the amount of data fetched  */
/* for that file save and nothing else is returned as a       */
/* negative number (to flag that this is happening). Callers  */
/* must remember to check for this, even if only to reverse   */
/* the sign on the returned value.                            */
/*                                                            */
/* Parameters: Pointer to any browser_data struct in the      */
/*             frameset in question.                          */
/*                                                            */
/* Returns:    The amount collectively fetched, in bytes, or  */
/*             the amount fetched for a file save with its    */
/*             sign reversed (i.e. a negative number) again   */
/*             in bytes.                                      */
/**************************************************************/

static int toolbars_calculate_progress(browser_data * b)
{
  browser_data * ancestor = b->ancestor;
  int            saves    = toolbars_count_file_saves(b);

  if (!ancestor) ancestor = b;

  return toolbars_calculate_progress_r(ancestor, saves);
}

/**************************************************************/
/* toolbars_calculate_progress_r()                            */
/*                                                            */
/* Recursive back-end to toolbars_calculate_progress.         */
/*                                                            */
/* Parameters: Pointer to the ancestor browser_data struct in */
/*             the frameset;                                  */
/*                                                            */
/*             0 if no browser in the frameset is saving data */
/*             to a file, else non-zero.                      */
/*                                                            */
/* Returns:    As toolbars_calculate_progress.                */
/**************************************************************/

static int toolbars_calculate_progress_r(browser_data * b, int saves)
{
  int i, fetched = 0;

  if (b->nchildren)
  {
    int localfetched;

    /* For children, if the frameset has some file saving going on */
    /* use only negative numbers returned, i.e. report cumulative  */
    /* file sizes. Otherwise, use only positive numbers, i.e.      */
    /* report image / page source fetched data.                    */

    for (i = 0; i < b->nchildren; i++)
    {
      localfetched = toolbars_calculate_progress_r(b->children[i], saves);

      if (saves)
      {
        if (localfetched < 0) fetched += localfetched;
      }
      else
      {
        if (localfetched > 0) fetched += localfetched;
      }
    }
  }

  if (b->save_file)
  {
    /* If saving, don't want to confuse the issue with any image */
    /* fetch information or whatever. So just use the current    */
    /* output file size.                                         */

    fetched = (int) (-(ftell(b->save_file)));
  }
  else
  {
    /* Count the image data obtained so far */

    fetched += image_total_bytes_fetched(b);

    /* Add the current source store size */

    if (b->save_oldstore) fetched += b->save_oldstore;
    else if (b->source)   fetched += flex_size((flex_ptr) &b->source);
  }

  return fetched;
}

/**************************************************************/
/* toolbars_create_progress()                                 */
/*                                                            */
/* Builds a string indicating fetch progress in a given       */
/* buffer.                                                    */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the fetch;                                     */
/*                                                            */
/*             Pointer to the buffer;                         */
/*                                                            */
/*             Size of that buffer.                           */
/*                                                            */
/* Returns:    The number of file saves going on inside the   */
/*             frameset, from toolbars_count_file_saves.      */
/*                                                            */
/* Assumes:    last_updated field holds the time that the     */
/*             download started, where applicable - used to   */
/*             work out the download speed.                   */
/**************************************************************/

static int toolbars_create_progress(browser_data * b, char * buffer, int buffer_size)
{
  browser_data * ancestor   = utils_ancestor(b);
  int            saves      = 0;
  int            len        = 1; /* Start with the terminating zero byte accounted for */
  int            percentage = 0;
  int            fetched;

  fetched = toolbars_calculate_progress(ancestor);
  if (fetched < 0) fetched = -fetched, saves = toolbars_count_file_saves(b); /* If a negative number, the absolute value is the amount of data being saved to a file */

  /* Is the buffer big enough? */

  if      (fetched < 10240)    len = utils_number_length(fetched);
  else if (fetched < 10485760) len = utils_number_length((fetched + 512)    / 1024)    + 1; /* For 'K' */
  else                         len = utils_number_length((fetched + 524288) / 1048576) + 4; /* For the '.xxM' */

  if (saves) len += utils_number_length(saves) + 2;

  if (len > buffer_size)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Buffer size of %d isn't as large as required (%d) in toolbars_create_progress",
              buffer_size,
              len);

      show_error_ret(&erb);

    #endif

    return saves;
  }

  /* For single file saves, we may be able to use a percentage counter */

  if (saves == 1 && b->data_size > 0 && b->save_link)
  {
    percentage = (int) (1000 * ((float) fetched / b->data_size)); /* 1000 for 1 d.p. accuracy */

    /* If the data size was misjudged, we can exceed 100% fetched. In */
    /* that case, drop back to a byte counter, rather than sticking   */
    /* at 100%.                                                       */

    if (percentage > 1000) percentage = 0;
  }

  /* Write the amount into the buffer; '0' for <=0 bytes, a byte  */
  /* amount for less than 10K, a K amount for less than 10M, else */
  /* an amount in megabytes.                                      */

  if (saves < 2)
  {
    if (percentage)
    {
      /* Special case - if we know the data size, and we're saving an object, */
      /* then display a percentage amount fetched instead.                    */

      sprintf(buffer, "%d.%01d%%", percentage / 10, percentage % 10);
    }
    else
    {
      if      (fetched < 10000)    sprintf(buffer, "%d",    fetched);
      else if (fetched < 10000000) sprintf(buffer, "%dK",   (fetched + 512) / 1024);
      else                         sprintf(buffer, "%.2fM", ((double) fetched + 524288) / 1048576);
    }

    /* Can we give a download speed indicator? */

    if (saves == 1 && b->small_fetch)
    {
      int tdiff = b->progress_updated - b->last_updated;

      if (fetched > 0 && !b->last_updated) b->last_updated = b->progress_updated, tdiff = 0;

      if (fetched > 0 && tdiff > 0)
      {
        int          rate = (int) ((float) fetched / ((float) tdiff / 100));
        const char * append;

        if      (rate < 10000)    append = "cps";
        else if (rate < 10000000) append = "K/s", rate = (rate + 512) / 1024;
        else                      append = "M/s", rate = (rate + 524288) / 1048576;

        /* Will it fit in the buffer? Adding 4 for ", " plus terminator. */

        if (strlen(buffer) + strlen(append) + utils_number_length(rate) + 4 <= buffer_size)
        {
          /* OK, write the speed indicator in place. */

          sprintf(buffer,
                  "%s%s%d%s",
                  buffer, /* =8*P */
                  ", ",
                  rate,
                  append);
        }
      }
    }
  }
  else
  {
    if      (fetched < 10000)    sprintf(buffer, "%d: %d",    saves, fetched);
    else if (fetched < 10000000) sprintf(buffer, "%d: %dK",   saves, (fetched + 512) / 1024);
    else                         sprintf(buffer, "%d: %.1fM", saves, ((double) fetched + 524288) / 1048576);
  }

  return saves;
}

/**************************************************************/
/* toolbars_update_url()                                      */
/*                                                            */
/* Reflects the currently fetching URL in the URL bar of a    */
/* browser window.                                            */
/*                                                            */
/* Parameters: A pointer to the browser_data structure        */
/*             relevant to the window.                        */
/**************************************************************/

void toolbars_update_url(browser_data * b)
{
  char     url[Limits_URLBarWrit];
  char     cmp[sizeof(url)];
  ObjectId t;

  t = toolbars_get_upper(b);
  if (!t) return;

  if (browser_fetch_url(b))
  {
    StrNCpy0(url, browser_fetch_url(b));
  }
  else if (browser_current_url(b))
  {
    StrNCpy0(url, browser_current_url(b));
  }
  else *url = 0;

  /* If we can use URL aliases, then compare the text to put in */
  /* the bar against the Hotlist URL string. If the same, use   */
  /* an alias for the hotlist instead of the given URL.         */

  #ifdef ALIAS_URLS
  {
    char compare[sizeof(url)];

    urlutils_create_hotlist_url(compare, sizeof(compare));

    if (!strcmp(url, compare)) StrNCpy0(url, lookup_token("AtHotlist:Hotlist",0,0));
  }
  #endif

  #ifdef HIDE_CGI
    toolbars_hide_cgi(url);
  #endif

  /* For internal URLs, strip off the internal bit at the start */

  toolbars_hide_internal(url);

  /* Write the URL in only if it's different from the existing contents */

  writablefield_get_value(0, t, URLBarWrit, cmp, sizeof(cmp), NULL);
  if (strcmp(cmp, url)) writablefield_set_value(0, t, URLBarWrit, url);
}

/**************************************************************/
/* toolbars_update_dialler_time()                             */
/*                                                            */
/* Updates the dialler status display in the upper toolbar.   */
/* Should only be called if there is a Display Field          */
/* component, ID 0xF, which can take the required display     */
/* values.                                                    */
/*                                                            */
/* This shows online time. It is expected that the function   */
/* will only be called from a null event handler to update    */
/* the time regularly.                                        */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the display.                                   */
/**************************************************************/

_kernel_oserror * toolbars_update_dialler_time(browser_data * b)
{
  _kernel_oserror * e;
  ObjectId          t;
  int               status, start_time, time_now;
  char              display[Limits_URLBarDiallerStatus];
  char              compare[Limits_URLBarDiallerStatus];

  t = toolbars_get_upper(b);
  if (!t) return NULL;

  e = _swix(Dialler_Status,
            _IN(0) | _OUTR(0,1),

            Dialler_Status_ConnectTime,

            &status,
            &start_time);

  /* If the dialler isn't present, don't want to end up */
  /* with a recursive error report, so fail silently.   */

  if (e) return NULL;

  _swix(OS_ReadMonotonicTime,
        _OUT(0),

        &time_now);

  /* Only update as often as specified in the Messages file */

  if (time_now - b->dialler_last > controls.show_dstat_for)
  {
    /* If connected, must display an online time, else show offline. */

    if (status & Dialler_Connected)
    {
      int hours, minutes, seconds;

      /* Remember when this was done */

      b->dialler_last = time_now;

      /* Work out how long we've been online */

      time_now -= start_time;

      if (time_now < 0) time_now = 0;

      hours     = time_now / 360000;
      time_now -= (hours * 360000);
      minutes   = time_now / 6000;
      time_now -= (minutes * 6000);
      seconds   = (time_now / (controls.quantise * 100)) * controls.quantise;

      if (hours > 99) hours = 99;

      if (sizeof(display) >= 9) sprintf(display, "%02u:%02u:%02u\0", hours, minutes, seconds);
      else *display = 0;

      /* Get the current string into 'compare' */

      e = displayfield_get_value(0, t, URLBarDiallerStatus, compare, sizeof(compare), NULL);
      if (e) return e;
      compare[sizeof(compare) - 1] = 0;

      /* Update the display field if necessary, else exit */

      if (strcmp(display, compare))
      {
        e = displayfield_set_value(0, t, URLBarDiallerStatus, display);
        if (e) return e;
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* toolbars_update_dialler_status()                           */
/*                                                            */
/* Updates the dialler status display in the upper toolbar.   */
/* Should only be called if there is a Display Field          */
/* component, ID 0xF, which can take the required display     */
/* values.                                                    */
/*                                                            */
/* If the status is 'online', a null event handler will be    */
/* installed to call toolbars_update_dialler_time to show the */
/* online time. If the status is not 'online', that handler   */
/* will be deregistered if present.                           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the display.                                   */
/**************************************************************/

_kernel_oserror * toolbars_update_dialler_status(browser_data * b)
{
  _kernel_oserror * e;
  ObjectId          t;
  int               status;
  int               showing_time = 0;
  char              display[Limits_URLBarDiallerStatus];
  char              statstr[Limits_URLBarDiallerStatus];
  char              compare[sizeof(display)];

  t = toolbars_get_upper(b);
  if (!t) return NULL;

  memset(statstr, 0, sizeof(statstr));

  e = _swix(Dialler_Status,
            _INR(0,2) | _OUT(0),

            Dialler_Status_StatusString,
            statstr,
            sizeof(statstr),

            &status);

  /* If the dialler isn't present, don't want to end up */
  /* with a recursive error report, so fail silently.   */

  if (e) return NULL;

  statstr[sizeof(statstr) - 1] = 0;

  if (status & Dialler_StatusChanged)
  {
    /* Use the status string. Put the text in the 'tokens' messages buffer */
    /* as this is used lower down for the actual dialler status display    */
    /* string's source. To ensure that any future lookup_token calls don't */
    /* look at the 'lasttokn' buffer and think they don't need to do any   */
    /* work, must mark the contents of 'tokens' as invalid by setting      */
    /* the first char of 'lasttokn' to 0.                                  */

    *lasttokn = 0;
    StrNCpy0(tokens, statstr);
  }
  else
  {
    int info = status & Dialler_GeneralInfoMask;

    /* Get the relevant status text in the 'tokens' messages buffer. */
    /* If an item is missing from the Messages file, the lookup will */
    /* fail silently leaving '!' in the tokens buffer. This is taken */
    /* to mean 'don't show this status', and the routine will exit.  */

    switch (info)
    {
      case Dialler_ExecutingScript_Dial:     lookup_token("Dialling",  0, 0); break; /* Executing dialling script */
      case Dialler_ExecutingScript_Hangup:   lookup_token("Hangup",    0, 0); break; /* Executing hangup script   */
      case Dialler_ExecutingScript_Answer:   lookup_token("Answering", 0, 0); break; /* Answering                 */
      case Dialler_AbortedScript_Syntax:     lookup_token("SError",    0, 0); break; /* Script syntax error       */
      case Dialler_AbortedScript_Timeout:    lookup_token("Timeout",   0, 0); break; /* Timed out                 */
      case Dialler_AbortedScript_NoCarrier:  lookup_token("Carrier",   0, 0); break; /* No carrier                */
      case Dialler_AbortedScript_Error:      lookup_token("MError",    0, 0); break; /* 'ERROR' from modem        */
      case Dialler_AbortedScript_NoDialtone: lookup_token("Dialtone",  0, 0); break; /* No dialtone               */
      case Dialler_AbortedScript_Busy:       lookup_token("MBusy",     0, 0); break; /* 'BUSY' from modem         */
      case Dialler_AbortedScript_NoAnswer:   lookup_token("Answer",    0, 0); break; /* No answer                 */

      /* If there's no specific special status, are we online? */

      default:
      {
        if (status & Dialler_Connected) showing_time = 1;
        else lookup_token("Offline", 0, 0);
      }
      break;
    }
  }

  if (showing_time)
  {
    /* If we want to show online time, install the handler to do so */
    /* (if it isn't already installed).                             */

    if (!b->dialler_last)
    {
      /* dialler_last holds a timer, and if non-zero is used by window close */
      /* routines to show that the null claimant needs deregistering. It is  */
      /* unlikely, but nonetheless possible, that the window could be closed */
      /* after the handler is registered but before it is called, so the     */
      /* dialler_last field would still be zero and no deregistration would  */
      /* take place. Hence to ensure that this doesn't happen, set the field */
      /* to a (small) non-zero value for now.                                */

      b->dialler_last = 1;
      register_null_claimant(Wimp_ENull, (WimpEventHandler *) handle_dialler_display, b);
    }
  }
  else
  {
    /* Otherwise, remove the handler if it is installed */

    if (b->dialler_last) deregister_null_claimant(Wimp_ENull, (WimpEventHandler *) handle_dialler_display, b);
    b->dialler_last = 0;

    /* Copy the token contents to the display buffer and update the field */
    /* if the value has changed.                                          */

    StrNCpy0(display, tokens);

    e = displayfield_get_value(0, t, URLBarDiallerStatus, compare, sizeof(compare), NULL);
    if (e) return e;

    /* Update the display field if necessary, else exit */

    if (strcmp(display, compare))
    {
      e = displayfield_set_value(0, t, URLBarDiallerStatus, display);
      if (e) return e;
    }
  }

  /* May need to alter the label on this display, if there is one */

  {
    char label[Limits_URLBarDiallerStatusLabel];

    if (button_get_value(0, t, URLBarDiallerStatusLabel, label, sizeof(label), NULL)) return NULL;
    label[sizeof(label) - 1] = 0;

    if (!showing_time) lookup_token("DiaStatusDial:Dialler",0,0);
    else               lookup_token("DiaStatusTime:Time"   ,0,0);

    if (strcmp(label, tokens))
    {
      StrNCpy0(label, tokens);

      return button_set_value(0, t, URLBarDiallerStatusLabel, label);
    }
  }

  return NULL;
}

/**************************************************************/
/* toolbars_merged_to_status()                                */
/*                                                            */
/* If the URL writable and status lines are merged, this      */
/* ensures that the combined field is put into 'status'       */
/* display.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the field;                                     */
/*                                                            */
/*             Object ID of the toolbar the gadgets are in.   */
/*                                                            */
/* Assumes:    That the fields are indeed merged though a     */
/*             null object ID can be given.                   */
/**************************************************************/

void toolbars_merged_to_status(browser_data * b, ObjectId t)
{
  if (t)
  {
    char label[Limits_StatusBarStatusLabel];

    show_gadget(t, StatusBarStatus);
    hide_gadget(t, URLBarWrit);

    /* Update the label, if present */

    if (!button_get_value(0, t, StatusBarStatusLabel, label, sizeof(label), NULL))
    {
      label[sizeof(label) - 1] = 0;

      lookup_token("DisplayStats:Status",0,0);

      if (strcmp(label, tokens))
      {
        StrNCpy0(label, tokens);
        button_set_value(0, t, StatusBarStatusLabel, label);
      }
    }
  }
}

/**************************************************************/
/* toolbars_merged_to_url()                                   */
/*                                                            */
/* If the URL writable and status lines are merged, this      */
/* ensures that the combined field is put into 'URL entry'    */
/* display.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the field;                                     */
/*                                                            */
/*             Object ID of the toolbar the gadgets are in.   */
/*                                                            */
/* Assumes:    That the fields are indeed merged though a     */
/*             null object ID can be given.                   */
/**************************************************************/

void toolbars_merged_to_url(browser_data * b, ObjectId t)
{
  if (t)
  {
    char label[Limits_StatusBarStatusLabel];

    show_gadget(t, URLBarWrit);
    hide_gadget(t, StatusBarStatus);

    /* Update the label, if present */

    if (!button_get_value(0, t, StatusBarStatusLabel, label, sizeof(label), NULL))
    {
      label[sizeof(label) - 1] = 0;

      lookup_token("DisplayURL:URL",0,0);

      if (strcmp(label, tokens))
      {
        StrNCpy0(label, tokens);
        button_set_value(0, t, StatusBarStatusLabel, label);
      }
    }
  }
}

/**************************************************************/
/* toolbars_set_bistate_state()                               */
/*                                                            */
/* Sets a bistate button to a given state, which depends on   */
/* the type of button in use.                                 */
/*                                                            */
/* Naming conventions on the button types should dictate      */
/* which state is which, with the word order of the name      */
/* relating to the states (so for example,                    */
/* BiState_Cancel_Back would be at Cancel for state 0, and    */
/* Back for state 1).                                         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the button;                                    */
/*                                                            */
/*             Object ID of the toolbar the button is in;     */
/*                                                            */
/*             State (0 or 1) to set it to.                   */
/**************************************************************/

void toolbars_set_bistate_state(browser_data * b, ObjectId t, int state)
{
  switch (b->bistate)
  {
    case BiState_Cancel_Back:
    {
      ObjectId source;

      /* State 0 = Cancel, state 1 = Back */

      source = state ? ButtonBarBack : ButtonBarCancel;

      /* Copy the characteristics of the gadget over. */

      ChkError(copy_toolaction_info(t, source, t, ButtonBarBistate));

      b->bistate_state = state;
    }
    break;
  }
}

/**************************************************************/
/* toolbars_set_tristate_state()                              */
/*                                                            */
/* Sets a tristate button to a given state, which depends on  */
/* the type of button in use.                                 */
/*                                                            */
/* Naming conventions on the button types should dictate      */
/* which state is which, with the word order of the name      */
/* relating to the states (so for example,                    */
/* TriState_Go_GoTo_Stop would be at Go for state 0, GoTo for */
/* state 1, and Stop for state 2).                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the button;                                    */
/*                                                            */
/*             Object ID of the toolbar the button is in;     */
/*                                                            */
/*             State (0, 1 or 2) to set it to.                */
/**************************************************************/

void toolbars_set_tristate_state(browser_data * b, ObjectId t, int state)
{
  ObjectId source;

  switch (b->tristate)
  {
    case TriState_Go_GoTo_Stop:
    {
      /* State 0 = Go, 1 = GoTo, 2 = Stop */

      if (!state)          source = ButtonBarGo;
      else if (state == 1) source = ButtonBarGoTo;
      else                 source = ButtonBarStop;

      /* Copy the characteristics of the gadget over. */

      ChkError(copy_toolaction_info(t, source, t, ButtonBarTristate));

      b->tristate_state = state;
    }
    break;
  }
}

/**************************************************************/
/* toolbars_button_height()                                   */
/*                                                            */
/* Returns the button bar height for a window, or 0 if there  */
/* is no bar present. If there is both a button bar and URL   */
/* bar present the combined height is less than the height of */
/* both individual bars summed, due to an extra gap at the    */
/* edges for aesthetics. This function does not attempt to    */
/* compensate for this (see toolbars_url_height, which does). */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which holds   */
/*             the toolbars of interest.                      */
/**************************************************************/

int toolbars_button_height(const browser_data * restrict b)
{
  if (b->button_bar)
  {
    ObjectId t;
    BBox     w;

    if (b->all_in_bottom) return 0;

    t = toolbars_get_upper(b);
    if (!t) return 0;

    if (!gadget_get_bbox(0, t, ButtonBarSpacer, &w)) return (w.ymax - w.ymin);
  }

  return 0;
}

/**************************************************************/
/* toolbars_url_height()                                      */
/*                                                            */
/* Returns the URL bar height for a window, or 0 if there is  */
/* no URL bar present. If there is both a button bar and a    */
/* URL bar present the returned value will be reduced to      */
/* account for the effective overlap of the two bars, as when */
/* each is present individually there is a gap at the edges   */
/* for aesthetics.                                            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which holds   */
/*             the toolbars of interest.                      */
/**************************************************************/

int toolbars_url_height(const browser_data * restrict b)
{
  if (b->url_bar)
  {
    ObjectId t;
    BBox     w;

    if (b->all_in_bottom) return 0;

    t = toolbars_get_upper(b);
    if (!t) return 0;

    if (!gadget_get_bbox(0, t, URLBarSpacer, &w))
    {
      if (b->button_bar) return (w.ymax - w.ymin - toolbars_bar_overlap(t));
      else return (w.ymax - w.ymin);
    }
  }

  return 0;
}

/**************************************************************/
/* toolbars_status_height()                                   */
/*                                                            */
/* Returns the status bar height for a window, or 0 if there  */
/* is no status bar present.                                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct which holds   */
/*             the toolbars of interest.                      */
/**************************************************************/

int toolbars_status_height(const browser_data * restrict b)
{
  if (b->status_bar)
  {
    ObjectId t;
    BBox     w;

    if (b->all_in_top) return 0;

    t = toolbars_get_lower(b);
    if (!t) return 0;

    if (!gadget_get_bbox(0, t, StatusBarSpacer, &w)) return (w.ymax - w.ymin);
  }

  return 0;
}

/**************************************************************/
/* toolbars_set_button_states()                               */
/*                                                            */
/* Sets the button states in the button bar and URL bar of a  */
/* given browser window, greying or ungreying them according  */
/* to the browser's current state.                            */
/*                                                            */
/* This call will not return errors derived from attempts to  */
/* access non-existant gadgets; they will fail silently, to   */
/* allow more varied UI designs to work correctly.            */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the browser window.                            */
/**************************************************************/

_kernel_oserror * toolbars_set_button_states(browser_data * b)
{
  ObjectId t;

  t = toolbars_get_upper(b);

  if (!t) return NULL; /* (E.g., parents (but not ancestors) in framesets won't have toolbars) */

  if (controls.dont_grey == Controls_DontGrey_GreyAll)
  {
    /* Can only stop if there's activity of some sort */

    if (
         (b->anim_handler    && !b->anim_drift)      ||
         (b->meta_refresh_at && b->meta_refresh_url)
       )
       set_gadget_state(t, ButtonBarStop, 0);

    else set_gadget_state(t, ButtonBarStop, 1);

    /* Can only go back if we're not at the start of the history */
    /* and there's a history to go into.                         */

    if (!history_can_go_backwards(b)) set_gadget_state(t, ButtonBarBack,    1);
    else                              set_gadget_state(t, ButtonBarBack,    0);

    /* Can only go forward if we're in the history somewhere */

    if (!history_can_go_forwards(b))  set_gadget_state(t, ButtonBarForward, 1);
    else                              set_gadget_state(t, ButtonBarForward, 0);

    /* Can only view or save the document source if there is some... */

    if (!b->source)
    {
      set_gadget_state(t, ButtonBarViewSource, 1);
      set_gadget_state(t, ButtonBarSaveSource, 1);
    }
    else
    {
      set_gadget_state(t, ButtonBarViewSource, 0);
      set_gadget_state(t, ButtonBarSaveSource, 0);
    }

    /* Can only save the page as text or a Draw file, or print it, if */
    /* we have a visible line list.                                   */

    if (b->nchildren || !b->cell || !b->cell->nlines)
    {
      set_gadget_state(t, ButtonBarPrint,      1);
      set_gadget_state(t, ButtonBarSaveAsText, 1);
      set_gadget_state(t, ButtonBarSaveAsDraw, 1);
    }
    else
    {
      set_gadget_state(t, ButtonBarPrint,      0);
      set_gadget_state(t, ButtonBarSaveAsText, 0);
      set_gadget_state(t, ButtonBarSaveAsDraw, 0);
    }

    /* Only need to load images if delayed image loading is set  */
    /* in the local browser flags, or plain backgrounds are set. */

    if (
         (
           !b->show_foreground &&
           b->displayed != Display_External_Image
         )
         ||
         !b->show_background
       )
       set_gadget_state(t, ButtonBarLoadImages, 0);

    else set_gadget_state(t, ButtonBarLoadImages, 1);
  }

  if (controls.dont_grey != Controls_DontGrey_GreyNone)
  {
    /* Can only get a history menu if there's a history present. */

    if (history_empty(b)) set_gadget_state(t, URLBarHistoryMenuR, 1);
    else                  set_gadget_state(t, URLBarHistoryMenuR, 0);
  }

  /* Handle bistate buttons */

  if (b->bistate)
  {
    switch (b->bistate)
    {
      case BiState_Cancel_Back:
      {
        /* If the URL writable and status display are merged, */
        /* and the URL display is visible, then the field is  */
        /* in writable mode and the bistate should be at      */
        /* 'cancel'. Otherwise, it should be at 'back'.       */

        if (b->merged_url && !gadget_hidden(t, URLBarWrit)) toolbars_set_bistate_state(b, t, 0);
        else                                                toolbars_set_bistate_state(b, t, 1);
      }
      break;
    }
  }

  /* Handle tristate buttons */

  if (b->tristate)
  {
    switch (b->tristate)
    {
      case TriState_Go_GoTo_Stop:
      {
        /* If the URL writable and status display are merged, */
        /* and the status display is hidden, then the field   */
        /* is in writable mode and the tristate should be at  */
        /* 'go'.                                              */

        if (b->merged_url && !gadget_hidden(t, URLBarWrit)) toolbars_set_tristate_state(b, t, 0);
        else
        {
          /* If we have an animation handler, should be showing 'Stop', */
          /* else we should be at 'go to'. However, odd states can      */
          /* occur so it's wise to check with this tristate, where the  */
          /* state is very important (you can't go anywhere if it's     */
          /* stuck on Stop, for example), what the status bar says.     */

          if (
               (b->anim_handler    && !b->anim_drift)      ||
               (b->meta_refresh_at && b->meta_refresh_url)
             )
          {
            toolbars_set_tristate_state(b, t, 2); /* Stop */
          }
          else
          {
            status_type type = toolbars_return_act_status(b);

            switch (type)
            {
              default:
              case Toolbars_Status_NoType:
              case Toolbars_Status_Ready:
              case Toolbars_Status_Viewing:
              {
                toolbars_set_tristate_state(b, t, 1); /* Go To */
              }
              break;

              case Toolbars_Status_Formatting:
              case Toolbars_Status_Processing:
              case Toolbars_Status_GetPics:
              case Toolbars_Status_Connected:
              case Toolbars_Status_SentReq:
              case Toolbars_Status_Responded:
              case Toolbars_Status_Redirected:
              case Toolbars_Status_Connecting:
              case Toolbars_Status_Fetching:
              {
                toolbars_set_tristate_state(b, t, 2); /* Stop */
              }
              break;
            }
          }
        }
      }
      break;
    }
  }

  return NULL;
}

/**************************************************************/
/* toolbars_set_all_button_states()                           */
/*                                                            */
/* Sets all the button states in the toolbars of all the      */
/* browser windows currently open; that is, it greys and      */
/* ungreys them as appropriate for that browser's current     */
/* state.                                                     */
/**************************************************************/

_kernel_oserror * toolbars_set_all_button_states(void)
{
  _kernel_oserror * e;
  browser_data    * b;

  b = last_browser;

  while (b)
  {
    e = toolbars_set_button_states(b);
    if (e) return e;

    b = b->previous;
  }

  return NULL;
}
@


1.23
log
@  Load balancer pulled apart. DebugLib support. Temporary debug in place.
Detail:
  This is in the middle of some load balancer changes, but I'm checking it
  in as there's a sweeping source code change to use DebugLib. See Global.c
  for full details. Temporary debug code for the load balancer stuff is
  currently held under undocumented area "test".
Admin:
  This build now identifies itself as 2.08 i2-4 and says Pace on the about:
  page. Run for some time with no unexpected problems. Tried a mixture of
  debug levels successfully.

Version 2.08. Not tagged
@
text
@d91 2
a92 2
static ObjectId          toolbars_get_upper_backend      (browser_data * b);
static ObjectId          toolbars_get_lower_backend      (browser_data * b);
d126 1
a126 1
ObjectId toolbars_get_upper(browser_data * b)
d146 1
a146 1
static ObjectId toolbars_get_upper_backend(browser_data * b)
d192 1
a192 1
ObjectId toolbars_get_lower(browser_data * b)
d212 1
a212 1
static ObjectId toolbars_get_lower_backend(browser_data * b)
d3033 1
a3033 1
int toolbars_button_height(browser_data * b)
d3065 1
a3065 1
int toolbars_url_height(browser_data * b)
d3097 1
a3097 1
int toolbars_status_height(browser_data * b)
@


1.22
log
@
64-wide comments adopted throughout. All headers protected against multiple
inclusion. Use of <> for external headers rather than "". For libraries,
<libname/header.h> is used rather than relying on a complex include path,
where appropriate. Move towards using external URILib rather than the local
copy. Phoenix JavaScript build resources are the only up to date set
currently so don't try others; more work still required on Makefile (e.g.
getting the ROM build working, and internationalisation issues).

Version 2.08. Not tagged
@
text
@a47 5
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

d267 1
a267 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("\ntoolbars_set_size: Called with object ID %p\n",(void *) o);
  #endif
d271 1
a271 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_set_size: Parent ID is %p\n",(void *) p);
  #endif
d308 1
a308 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_set_size: Successful\n");
  #endif
d371 1
a371 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("\ntoolbars_set_presence: Called with %p\n", b);
  #endif
d398 1
a398 3
        #ifdef TRACE
          if (tl & (1u<<1)) Printf("toolbars_set_presence: Top left toolbar ID is %p\n",(void *) t);
        #endif
d410 1
a410 3
        #ifdef TRACE
          if (tl & (1u<<1)) Printf("toolbars_set_presence: Bottom left toolbar ID is %p\n",(void *) t);
        #endif
d428 1
a428 3
      #ifdef TRACE
        if (tl & (1u<<1)) Printf("toolbars_set_presence: Top left toolbar ID is %p\n",(void *) t);
      #endif
d472 1
a472 3
      #ifdef TRACE
        if (tl & (1u<<1)) Printf("toolbars_set_presence: Bottom left toolbar ID is %p\n",(void *) t);
      #endif
d502 1
a502 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("\ntoolbars_set_presence: Successful\n");
  #endif
d524 1
a524 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("\ntoolbars_move_gadgets: Called\n");
  #endif
d626 1
a626 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_move_gadgets: Successful\n");
  #endif
d889 1
a889 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_update_status: Called for %p, type %d\n",b,type);
  #endif
a901 1
      if (tl & (1u<<1))
d903 2
a904 2
        Printf("\ntoolbars_update_status:");
        Printf("\nUpdating for browser %p; old contents:\n",b);
d906 2
a907 2
        Printf("\nEntry | b        | Message    | Decay");
        Printf("\n------+----------+------------+------\n");
d913 1
a913 1
            default: Printf("%d     | %08x | %02d UNKNOWN | %d\n",i, contents[i].b, contents[i].type, contents[i].end - contents[i].start); break;
d915 2
a916 2
            case 0:  Printf("%d     | %08x | %02d Ready   | %d\n",i, contents[i].b, contents[i].type, contents[i].end - contents[i].start); break;
            case 1:  Printf("%d     | %08x | %02d Viewing | %d\n",i, contents[i].b, contents[i].type, contents[i].end - contents[i].start); break;
d918 4
a921 4
            case 2:  Printf("%d     | %08x | %02d Format  | %d\n",i, contents[i].b, contents[i].type, contents[i].end - contents[i].start); break;
            case 3:  Printf("%d     | %08x | %02d Process | %d\n",i, contents[i].b, contents[i].type, contents[i].end - contents[i].start); break;
            case 4:  Printf("%d     | %08x | %02d GetPics | %d\n",i, contents[i].b, contents[i].type, contents[i].end - contents[i].start); break;
            case 5:  Printf("%d     | %08x | %02d Fetch   | %d\n",i, contents[i].b, contents[i].type, contents[i].end - contents[i].start); break;
d923 2
a924 2
            case 6:  Printf("%d     | %08x | %02d LinkTo  | %d\n",i, contents[i].b, contents[i].type, contents[i].end - contents[i].start); break;
            case 7:  Printf("%d     | %08x | %02d Help    | %d\n",i, contents[i].b, contents[i].type, contents[i].end - contents[i].start); break;
d928 1
a928 1
        Printf("\n");
d952 4
a955 7
    #ifdef TRACE
      if (tl & (1u<<1))
      {
        Printf("\ntoolbars_update_status:");
        Printf("\nUpdating for browser %p; this has no contents array.\n\n",b);
      }
    #endif
d962 1
a962 3
    #ifdef TRACE
      if (tl & (1u<<1)) Printf("toolbars_update_status: Adding item\n");
    #endif
d983 1
a983 3
    #ifdef TRACE
      if (tl & (1u<<1)) Printf("toolbars_update_status: Exitting through toolbars_update_specific_status\n");
    #endif
d989 1
a989 3
    #ifdef TRACE
      if (tl & (1u<<1)) Printf("toolbars_update_status: Failed, exitting quietly\n");
    #endif
d1022 1
a1022 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_update_specific_status: Called for %p (ancestor %p)\n", b, ancestor);
  #endif
d1161 1
a1161 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_update_specific_status: Successful\n");
  #endif
d1637 1
a1637 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_write_status: Successful, returning with message type %d\n",priority);
  #endif
d1669 1
a1669 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_cancel_status: Called for %p, type %d\n",b,type);
  #endif
d1674 1
a1674 3
    #ifdef TRACE
      if (tl & (1u<<1)) Printf("toolbars_cancel_status: Exitting - ancestor has no array\n");
    #endif
d1696 1
a1696 3
    #ifdef TRACE
      if (tl & (1u<<1)) Printf("toolbars_cancel_status: Exitting - can't find entry\n");
    #endif
d1705 1
a1705 3
    #ifdef TRACE
      if (tl & (1u<<1)) Printf("toolbars_cancel_status: Exitting - entry message type %d doesn't match given type %d\n", contents[found].type, type);
    #endif
d1725 1
a1725 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_cancel_status: Exitting through toolbars_infer_status\n");
  #endif
d1747 1
a1747 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_cancel_all: Called\n");
  #endif
d1760 1
a1760 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_cancel_all: Successful\n");
  #endif
d1988 1
a1988 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_infer_status: Called for %p (ancestor %p)\n",b,ancestor);
  #endif
d2012 1
a2012 3
  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_infer_status: Exitting through toolbars_update_specific_status with type %d\n",type);
  #endif
@


1.21
log
@Check-in of Browse v2.06; using very small log file to try and avoid
CVS crashing. Some of the Resources may well be out of date due to CVS
locks being in place after earlier server-end core dumps, which I can't
remove myself.

I'll try and check one file in at the end with the full change log so
people know what's happened (it's reached about 16K...) - I'll make
that the TaskObey file '!All' in the top level directory. So for the
full log, look for the changes on this file.
@
text
@d15 14
a28 10
/***************************************************/
/* File   : Toolbars.c                             */
/*                                                 */
/* Purpose: Toolbar-related functions for the      */
/*          browser.                               */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 21-Nov-96: Created.                    */
/***************************************************/
d34 11
a44 2
#include "swis.h"
#include "flex.h"
d46 1
a46 7
#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "toolbox.h"
#include "window.h"
#include "gadgets.h"
d48 4
a51 1
#include "Dialler.h"
a52 1
#include "svcprint.h"
d117 13
a129 14
/*************************************************/
/* toolbars_get_upper()                          */
/*                                               */
/* Returns the object ID of the upper toolbar.   */
/* This may well not be the internal top left    */
/* toolbar of the window due to the swap_bars    */
/* flag or merged toolbars.                      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the toolbar.          */
/*                                               */
/* Returns:    Object ID of the toolbar, or NULL */
/*             for an error / no upper toolbar.  */
/*************************************************/
d137 13
a149 13
/*************************************************/
/* toolbars_get_upper_backend()                  */
/*                                               */
/* Returns the object ID of the upper toolbar.   */
/* This may well not be the internal top left    */
/* toolbar of the window due to merged toolbars. */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the toolbar.          */
/*                                               */
/* Returns:    Object ID of the toolbar, or NULL */
/*             for an error / no upper toolbar.  */
/*************************************************/
d183 13
a195 14
/*************************************************/
/* toolbars_get_lower()                          */
/*                                               */
/* Returns the object ID of the lower toolbar.   */
/* This may well not be the internal bottom      */
/* left toolbar of the window due to the         */
/* swap_bars flag or merged toolbars.            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the toolbar.          */
/*                                               */
/* Returns:    Object ID of the toolbar, or NULL */
/*             for an error / no lower toolbar.  */
/*************************************************/
d203 13
a215 14
/*************************************************/
/* toolbars_get_lower_backend()                  */
/*                                               */
/* Returns the object ID of the lower toolbar.   */
/* This may well not be the internal bottom      */
/* left toolbar of the window due to merged      */
/* toolbars.                                     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the toolbar.          */
/*                                               */
/* Returns:    Object ID of the toolbar, or NULL */
/*             for an error / no lower toolbar.  */
/*************************************************/
d249 15
a263 15
/*************************************************/
/* toolbars_set_size()                           */
/*                                               */
/* Sets the vertical visible height and scroll   */
/* position of a given toolbar.                  */
/*                                               */
/* Parameters: The object ID of the toolbar;     */
/*                                               */
/*             The visible height to set it to;  */
/*                                               */
/*             The y scroll offset to give it;   */
/*                                               */
/*             Flags - alter InternalTopLeft, or */
/*             InternalBottomLeft toolbar.       */
/*************************************************/
d322 9
a330 10
/*************************************************/
/* toolbars_find_overlap()                       */
/*                                               */
/* Finds the overlap of the height gadgets 0xd   */
/* and 0xe in the upper toolbar, recording this  */
/* in the local bar_overlap int to make future   */
/* references faster.                            */
/*                                               */
/* Parameters: The object ID of the toolbar.     */
/*************************************************/
d346 8
a353 9
/*************************************************/
/* toolbars_bar_overlap()                        */
/*                                               */
/* Returns the overlap of the height gadgets 0xd */
/* and 0xe in the upper toolbar, using a local   */
/* cached value for speed.                       */
/*                                               */
/* Parameters: The object ID of the toolbar.     */
/*************************************************/
d362 14
a375 16
/*************************************************/
/* toolbars_set_presence()                       */
/*                                               */
/* Reads the browser_data structure associated   */
/* with a given browser window object ID, and    */
/* ensures the toolbars associated with that     */
/* window match the flags set inside the data    */
/* structure.                                    */
/*                                               */
/* Parameters: A browser_data struct relevant to */
/*             the window holding the toolbars;  */
/*                                               */
/*             A flags word holding the toolbars */
/*             to alter - InternalTopLeft, or    */
/*             InternalBottomLeft.               */
/*************************************************/
d528 10
a537 11
/*************************************************/
/* toolbars_move_gadgets()                       */
/*                                               */
/* Generally called as part of some window       */
/* resize event, this function moves and/or      */
/* resizes various gadgets in various toolbars,  */
/* if the toolbars are present in the window.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the toolbars.         */
/*************************************************/
d656 9
a664 9
/*************************************************/
/* toolbars_animation_set_sprite()               */
/*                                               */
/* Sets the sprite in the button gadget used for */
/* the status bar animation.                     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the animation.        */
/*************************************************/
d704 9
a712 9
/*************************************************/
/* toolbars_animation()                          */
/*                                               */
/* Advances the browser animation in the status  */
/* bar by one frame.                             */
/*                                               */
/* Parameters are as for a standard Wimp event   */
/* handler (this is called on null events).      */
/*************************************************/
d741 10
a750 10
/*************************************************/
/* toolbars_animation_drift()                    */
/*                                               */
/* Advances the browser animation in the status  */
/* bar by one frame, until it reaches the first  */
/* frame, when it deregisters itself.            */
/*                                               */
/* Parameters are as for a standard Wimp event   */
/* handler (this is called on null events).      */
/*************************************************/
d786 18
a803 21
/*************************************************/
/* toolbars_animate_slow()                       */
/*                                               */
/* Advances an animation in component            */
/* StatusBarAnimAnim (see Toolbars.h) in an      */
/* object of ID given in void * handle (must be  */
/* cast to this to fit as a Wimp event handler)  */
/* by one frame for each complete cycle of the   */
/* main status animation (whether that is        */
/* actually animating or not).                   */
/*                                               */
/* So that more than one dialogue could be up    */
/* and animating at once, the object's client    */
/* handle is used to store the current animation */
/* frame. Consequently this routine is of no use */
/* to dialogues that need the client handle for  */
/* other reasons.                                */
/*                                               */
/* Parameters are as for a standard Wimp event   */
/* handler (this is called on null events).      */
/*************************************************/
d839 11
a849 12
/*************************************************/
/* toolbars_hide_cgi()                           */
/*                                               */
/* This routine will look through a URL for a    */
/* ? and turn it into a terminator. This can be  */
/* used to hide CGI information from the user.   */
/*                                               */
/* Parameters: Pointer to the URL, which must be */
/*             writable in memory, as the first  */
/*             '?' it contains (if any) will be  */
/*             turned into a zero byte.          */
/*************************************************/
d867 13
a879 16
/*************************************************/
/* toolbars_hide_internal()                      */
/*                                               */
/* When passed a pointer to an internal URL,     */
/* this routine finds the separator between the  */
/* internal specifier plus message token and the */
/* extra information in the URL, and copies this */
/* extra data down to the start of the URL.      */
/*                                               */
/* Parameters: Pointer to the URL, which may be  */
/*             altered quite significantly; so   */
/*             this should be a local copy held  */
/*             by the caller to avoid corrupting */
/*             any important full version of the */
/*             URL.                              */
/*************************************************/
d894 14
a907 16
/*************************************************/
/* toolbars_update_status()                      */
/*                                               */
/* The standard external way of updating a       */
/* browser window's status bar. The given        */
/* requests that a given message type (see the   */
/* definition of status_type in Toolbars.h)      */
/* be used for the status bar.                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which wants the message putting   */
/*             in its (or its ancestor's)        */
/*             status bar;                       */
/*                                               */
/*             Type of message to display.       */
/*************************************************/
d1034 19
a1052 22
/*************************************************/
/* toolbars_update_specific_status()             */
/*                                               */
/* Updates the given browser's given entry in    */
/* the given ancestor's status_content array the */
/* given message type... Messages will only be   */
/* allowed to rise in priority, with the         */
/* timeouts on all messages dealing with letting */
/* things fall back again.                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which owns the entry to be        */
/*             updated;                          */
/*                                               */
/*             Pointer to the ancestor           */
/*             browser_data struct holding the   */
/*             status_content array;             */
/*                                               */
/*             Index of the entry to update;     */
/*                                               */
/*             Message type to update it with.   */
/*************************************************/
d1209 18
a1226 20
/*************************************************/
/* toolbars_write_status()                       */
/*                                               */
/* Reflects the highest priority message in a    */
/* status_content array in the status bar of     */
/* the array's owner.                            */
/*                                               */
/* Called by toolbars_update_status as part of   */
/* its normal operation.                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which is an ancestor holding a    */
/*             status_content array.             */
/*                                               */
/* Returns:    The message type that was chosen  */
/*             as the highest priority.          */
/*                                               */
/* Assumes:    That the ancestor browser_data    */
/*             pointer is not NULL.              */
/*************************************************/
d1687 20
a1706 25
/*************************************************/
/* toolbars_cancel_status()                      */
/*                                               */
/* toolbars_remove_status_item is used to        */
/* remove a browser from its ancestor's array of */
/* status_content structures because the browser */
/* is about to become invalid (e.g. be deleted   */
/* because its associated window was closed).    */
/*                                               */
/* This function is used if an existing browser  */
/* wants to cancel a message it registered       */
/* earlier, before it times out. The message     */
/* type that is being cancelled must be stated;  */
/* if the browser's entry in the status_content  */
/* array does not record this type, no action    */
/* will be taken. Otherwise the message will be  */
/* cancelled as asked.                           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which wants the message           */
/*             cancelling;                       */
/*                                               */
/*             Message type that it wants to     */
/*             remove.                           */
/*************************************************/
d1785 14
a1798 17
/*************************************************/
/* toolbars_cancel_all()                         */
/*                                               */
/* If a browser wants to cancel all messages it  */
/* registered earlier, except for LinkTo or Help */
/* messages, perhaps to ensure that some message */
/* is displayed now rather than after another    */
/* times out, it should call this function. The  */
/* original idea was for browsers that have just */
/* completed a full fetch, which want to get rid */
/* of any timing out formatting or fetching      */
/* messages.                                     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which wants the message           */
/*             cancelling.                       */
/*************************************************/
d1824 16
a1839 19
/*************************************************/
/* toolbars_timeout_status()                     */
/*                                               */
/* A null event handler registered and deregis-  */
/* tered by toolbars_update_specific_status,     */
/* which handles checking the 'start' and 'end'  */
/* fields of the given ancestor browser_data     */
/* struct to see if any messages have expired.   */
/*                                               */
/* toolbars_update_specific_status will only     */
/* allow browsers to register progressively      */
/* higher priority messages than previously      */
/* registered - this routine allows those        */
/* previous priorities to drop down.             */
/*                                               */
/* Parameters are as standard for a Wimp null    */
/* event handler (handle = pointer to the        */
/* ancestor browser_data structure).             */
/*************************************************/
d1934 12
a1945 14
/*************************************************/
/* toolbars_return_inferred()                    */
/*                                               */
/* Looks at a given browser_data struct to work  */
/* out what state it is in, returning this       */
/* information as a status_type value (see       */
/* Toolbars.h).                                  */
/*                                               */
/* Parameters: Pointer to the browser_data       */
/*             struct in question.               */
/*                                               */
/* Returns:    Its status, as a status_type      */
/*             value.                            */
/*************************************************/
d2022 19
a2040 22
/*************************************************/
/* toolbars_infer_status()                       */
/*                                               */
/* When a toolbar message in the status_content  */
/* array of an ancestor browser has expired,     */
/* this routine is called to work out what the   */
/* current status for the owner browser should   */
/* be. The toolbar is appropriately updated.     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which owns the message;           */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             which is the above's ancestor;    */
/*                                               */
/*             Index into the ancestor's         */
/*             status_content array for the      */
/*             message owner.                    */
/*                                               */
/* Assumes:    That the ancestor pointer is not  */
/*             NULL.                             */
/*************************************************/
d2080 13
a2092 14
/*************************************************/
/* toolbars_add_status_item()                    */
/*                                               */
/* Adds an item to a given ancestor's array of   */
/* status_content structures. The contents are   */
/* not initialised - this is left to the caller. */
/*                                               */
/* Parameters: Pointer to browser_data struct in */
/*             which the addition should be made */
/*             (i.e. the ancestor).              */
/*                                               */
/* Assumes:    That the ancestor browser_data    */
/*             pointer is not NULL.              */
/*************************************************/
d2105 20
a2124 22
/*************************************************/
/* toolbars_remove_status_item()                 */
/*                                               */
/* Removes a browser_data structure from its     */
/* ancestor's array of status_content structs.   */
/*                                               */
/* Typically called by windows_close_browser, so */
/* issues of having children within the window   */
/* relating to the given browser are dealt with  */
/* automatically (children would be being closed */
/* through a function in Frames.c, with the      */
/* Windows.c function called as part of this).   */
/*                                               */
/* Parameters: Pointer to the browser_data       */
/*             struct to remove from the array;  */
/*                                               */
/*             Pointer to the ancestor           */
/*             browser_data structure.           */
/*                                               */
/* Assumes:    That the ancestor pointer is not  */
/*             NULL.                             */
/*************************************************/
d2168 16
a2183 20
/*************************************************/
/* toolbars_return_act_status()                  */
/*                                               */
/* Returns the highest status for the ancestor   */
/* of a given browser window that does not       */
/* include non-active transient items            */
/* (specifically, LinkTo and Help messages).     */
/*                                               */
/* This allows the caller to determine whether a */
/* browser and any of its frames are fetching,   */
/* for example.                                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the ancestor in       */
/*             question.                         */
/*                                               */
/* Returns:    A status_type (see Toolbars.h)    */
/*             describing the ancestor's current */
/*             status.                           */
/*************************************************/
d2225 9
a2233 10
/*************************************************/
/* toolbars_update_progress()                    */
/*                                               */
/* Reflects a fetch's progress in the browser    */
/* window's status bar.                          */
/*                                               */
/* Parameters: A pointer to the browser_data     */
/*             structure associated with the     */
/*             fetch.                            */
/*************************************************/
d2323 12
a2334 13
/*************************************************/
/* toolbars_count_file_saves()                   */
/*                                               */
/* Checks to see if any frames in a given        */
/* frameset are saving out files.                */
/*                                               */
/* Parameters: Pointer to any browser_data       */
/*             structure in the frameset.        */
/*                                               */
/* Returns:    The number of file saves going on */
/*             in the parent and any children it */
/*             might have.                       */
/*************************************************/
d2345 10
a2354 12
/*************************************************/
/* toolbars_count_file_saves_r()                 */
/*                                               */
/* Recursive back-end to                         */
/* toolbars_count_file_saves.                    */
/*                                               */
/* Parameters: Pointer to the ancestor           */
/*             browser_data struct in the        */
/*             frameset.                         */
/*                                               */
/* Returns:    As toolbars_count_file_saves.     */
/*************************************************/
d2373 19
a2391 23
/*************************************************/
/* toolbars_calculate_progress()                 */
/*                                               */
/* Works out how much data has been fetched for  */
/* a frameset.                                   */
/*                                               */
/* If a file save is in progress, the amount of  */
/* data fetched for that file save and nothing   */
/* else is returned as a negative number (to     */
/* flag that this is happening). Callers must    */
/* remember to check for this, even if only to   */
/* reverse the sign on the returned value.       */
/*                                               */
/* Parameters: Pointer to any browser_data       */
/*             struct in the frameset in         */
/*             question.                         */
/*                                               */
/* Returns:    The amount collectively fetched,  */
/*             in bytes, or the amount fetched   */
/*             for a file save with its sign     */
/*             reversed (i.e. a negative number) */
/*             again in bytes.                   */
/*************************************************/
d2403 13
a2415 16
/*************************************************/
/* toolbars_calculate_progress_r()               */
/*                                               */
/* Recursive back-end to                         */
/* toolbars_calculate_progress.                  */
/*                                               */
/* Parameters: Pointer to the ancestor           */
/*             browser_data struct in the        */
/*             frameset;                         */
/*                                               */
/*             0 if no browser in the frameset   */
/*             is saving data to a file, else    */
/*             non-zero.                         */
/*                                               */
/* Returns:    As toolbars_calculate_progress.   */
/*************************************************/
d2468 20
a2487 22
/*************************************************/
/* toolbars_create_progress()                    */
/*                                               */
/* Builds a string indicating fetch progress in  */
/* a given buffer.                               */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the fetch;            */
/*                                               */
/*             Pointer to the buffer;            */
/*                                               */
/*             Size of that buffer.              */
/*                                               */
/* Returns:    The number of file saves going on */
/*             inside the frameset, from         */
/*             toolbars_count_file_saves.        */
/*                                               */
/* Assumes:    last_updated field holds the time */
/*             that the download started, where  */
/*             applicable - used to work out the */
/*             download speed.                   */
/*************************************************/
d2602 9
a2610 9
/*************************************************/
/* toolbars_update_url()                         */
/*                                               */
/* Reflects the currently fetching URL in the    */
/* URL bar of a browser window.                  */
/*                                               */
/* Parameters: A pointer to the browser_data     */
/*             structure relevant to the window. */
/*************************************************/
d2659 15
a2673 15
/*************************************************/
/* toolbars_update_dialler_time()                */
/*                                               */
/* Updates the dialler status display in the     */
/* upper toolbar. Should only be called if there */
/* is a Display Field component, ID 0xF, which   */
/* can take the required display values.         */
/*                                               */
/* This shows online time. It is expected that   */
/* the function will only be called from a null  */
/* event handler to update the time regularly.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the display.          */
/*************************************************/
d2754 16
a2769 17
/*************************************************/
/* toolbars_update_dialler_status()              */
/*                                               */
/* Updates the dialler status display in the     */
/* upper toolbar. Should only be called if there */
/* is a Display Field component, ID 0xF, which   */
/* can take the required display values.         */
/*                                               */
/* If the status is 'online', a null event       */
/* handler will be installed to call             */
/* toolbars_update_dialler_time to show the      */
/* online time. If the status is not 'online',   */
/* that handler will be deregistered if present. */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the display.          */
/*************************************************/
d2912 15
a2926 17
/*************************************************/
/* toolbars_merged_to_status()                   */
/*                                               */
/* If the URL writable and status lines are      */
/* merged, this ensures that the combined field  */
/* is put into 'status' display.                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the field;            */
/*                                               */
/*             Object ID of the toolbar the      */
/*             gadgets are in.                   */
/*                                               */
/* Assumes:    That the fields are indeed merged */
/*             though a null object ID can be    */
/*             given.                            */
/*************************************************/
d2954 15
a2968 17
/*************************************************/
/* toolbars_merged_to_url()                      */
/*                                               */
/* If the URL writable and status lines are      */
/* merged, this ensures that the combined field  */
/* is put into 'URL entry' display.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the field;            */
/*                                               */
/*             Object ID of the toolbar the      */
/*             gadgets are in.                   */
/*                                               */
/* Assumes:    That the fields are indeed merged */
/*             though a null object ID can be    */
/*             given.                            */
/*************************************************/
d2996 19
a3014 20
/*************************************************/
/* toolbars_set_bistate_state()                  */
/*                                               */
/* Sets a bistate button to a given state, which */
/* depends on the type of button in use.         */
/*                                               */
/* Naming conventions on the button types should */
/* dictate which state is which, with the word   */
/* order of the name relating to the states (so  */
/* for example, BiState_Cancel_Back would be at  */
/* Cancel for state 0, and Back for state 1).    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the button;           */
/*                                               */
/*             Object ID of the toolbar the      */
/*             button is in;                     */
/*                                               */
/*             State (0 or 1) to set it to.      */
/*************************************************/
d3038 19
a3056 21
/*************************************************/
/* toolbars_set_tristate_state()                 */
/*                                               */
/* Sets a tristate button to a given state,      */
/* which depends on the type of button in use.   */
/*                                               */
/* Naming conventions on the button types should */
/* dictate which state is which, with the word   */
/* order of the name relating to the states (so  */
/* for example, TriState_Go_GoTo_Stop would be   */
/* at Go for state 0, GoTo for state 1, and Stop */
/* for state 2).                                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the button;           */
/*                                               */
/*             Object ID of the toolbar the      */
/*             button is in;                     */
/*                                               */
/*             State (0, 1 or 2) to set it to.   */
/*************************************************/
d3082 13
a3094 16
/*************************************************/
/* toolbars_button_height()                      */
/*                                               */
/* Returns the button bar height for a window,   */
/* or 0 if there is no bar present. If there is  */
/* both a button bar and URL bar present the     */
/* combined height is less than the height of    */
/* both individual bars summed, due to an extra  */
/* gap at the edges for aesthetics. This         */
/* function does not attempt to compensate for   */
/* this (see toolbars_url_height, which does).   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which holds the toolbars of       */
/*             interest.                         */
/*************************************************/
d3114 13
a3126 15
/*************************************************/
/* toolbars_url_height()                         */
/*                                               */
/* Returns the URL bar height for a window, or 0 */
/* if there is no URL bar present. If there is   */
/* both a button bar and a URL bar present the   */
/* returned value will be reduced to account for */
/* the effective overlap of the two bars, as     */
/* when each is present individually there is a  */
/* gap at the edges for aesthetics.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which holds the toolbars of       */
/*             interest.                         */
/*************************************************/
d3150 9
a3158 10
/*************************************************/
/* toolbars_status_height()                      */
/*                                               */
/* Returns the status bar height for a window,   */
/* or 0 if there is no status bar present.       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             which holds the toolbars of       */
/*             interest.                         */
/*************************************************/
d3178 14
a3191 16
/*************************************************/
/* toolbars_set_button_states()                  */
/*                                               */
/* Sets the button states in the button bar and  */
/* URL bar of a given browser window, greying or */
/* ungreying them according to the browser's     */
/* current state.                                */
/*                                               */
/* This call will not return errors derived from */
/* attempts to access non-existant gadgets; they */
/* will fail silently, to allow more varied UI   */
/* designs to work correctly.                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the browser window.   */
/*************************************************/
d3365 8
a3372 8
/*************************************************/
/* toolbars_set_all_button_states()              */
/*                                               */
/* Sets all the button states in the toolbars of */
/* all the browser windows currently open; that  */
/* is, it greys and ungreys them as appropriate  */
/* for that browser's current state.             */
/*************************************************/
@


1.20
log
@Programming warehouse link removed from all hotlists - the page has gone.

Some compile-time hacks in place to use MemLib, a dynamic area based
malloc replacement which shrinks its heap when possible. All builds
have these switched off at the moment. Seemed to work with just Browse,
though there would be problems with message blocks stored in dynamic
areas because of the Wimp's '&3800000' check - however, it failed when
HTMLLib was made to use it, too. Don't know why yet.

ItemInfo.[c/h] source added, with Res file additions for testbed Browse
and Phoenix.

Small fetch windows now work properly regardless of toolbar settings
in the Choices.

Reload now reloads all images too, rather than only reloading them for
as long as the main page was being fetched.

Added a simple 'Find' facility.

Realised that event handlers in eventlib are called in reverse order
of registration, so the miscellaneous event handler is now registered
first rather than last.

Multiuser code added (most only active if SINGLE_USER is undefined). As
part of this, hotlist code now knows about read-only items (done for the
Customer-style 'Resources' file, but works generally anyway).
handle_add_hotlist doesn't try to save the hotlist itself anymore (the
hotlist_add function does all that through hotlist_modified anyway).

Customer build Choices and Controls updated slightly (e.g. ClaimHelp
off, hotlist to save on quit only).

Customer build now uses Phoenix-style buttons. Sprites files which
worked at the time (but will probably be out of date now) and included
most of the original Customer-style sprites are in
'Utils.Icons.Customer'.

Choices, Messages and Res files for all builds now stripped down to only
single user items or single plus multiuser for Customer build and testbed
build. Before, all contained a few multiuser bits in at least the Choices
file if not more.

Grammatical error ("Fetching frames contents" (sic.)) corrected in
default message, Toolbars.c, and all of the Messages files.

Customer build brought back to a servicable level (including
implementation of the Find dialogue box with animation and fixing
up authorisation and 'Stop' state in the tristate). Quite a few
missing #ifndef REMOTE_HOTLIST bits from hotlist code added...

Customer build will not use <Choices$Write> or Boot:Choices for any
file finding now. UseProxy defaults to 'yes', MaxImages to 2. Res
file includes Proxy Address setting (save_save_choices() now writes
the ProxyAddress line).
@
text
@d2531 5
d2553 1
a2553 1
  else                         len = utils_number_length((fetched + 524288) / 1048576) + 1; /* For the 'M' */
d2579 1
a2579 1
    percentage = (fetched * 100) / b->data_size;
d2585 1
a2585 1
    if (percentage > 100) percentage = 0;
d2599 1
a2599 1
      sprintf(buffer, "%d%%", percentage);
d2603 36
a2638 3
      if      (fetched < 10240)    sprintf(buffer, "%d",  fetched);
      else if (fetched < 10485760) sprintf(buffer, "%dK", (fetched + 512)    / 1024);
      else                         sprintf(buffer, "%dM", (fetched + 524288) / 1048576);
d2643 3
a2645 3
    if      (fetched < 10240)    sprintf(buffer, "%d: %d",  saves, fetched);
    else if (fetched < 10485760) sprintf(buffer, "%d: %dK", saves, (fetched + 512)    / 1024);
    else                         sprintf(buffer, "%d: %dM", saves, (fetched + 524288) / 1048576);
@


1.19
log
@Check for WindowManager 3.97 and ensure Unicode$Path is set in all
!Run[D] files, don't set the Alias$@@PrintType_FF4 variable, and updated
Customer build ROM obey file variants. Various other changes to
the Run files for new module versions, updated paths to support
new positions of choices, hotlist and histories (see later), etc.

!Sprites[22] files hold small !app icons for some variants, and
an ic_browse sprite. Some variants now have a Sprites and Sprites22
file instead of just Sprites, with the former containing various
mode 12 or 15 specific sprites.

Text files dragged to the URL writable are treated as ANT URL files. This
relies on URLBarWrit (Toolbars.h) being a unique ID, which it should be,
but beware of the Hotlist and Choices numberspaces...

INPUT TYPE=BUTTON supported. Form items without a FORM tag are now shown
(as MSIE 4, but not NN 4).

'*', '-', '@@', '_' and '.' are not escaped when submitting forms now. The
Web interface to the IMDb now works.

INPUT TYPE=HIDDEN items will not affect the line height anymore - so
http://www.hotmail.com/ now has correctly aligned writable icons, for
example. Similarly, TAG_FORM and TAG_FORM_END items could push up
line height and don't anymore.

HRs with a specified pixel width will now influence the size of a table
cell (they didn't before).

BRs now checked by tagno field when the browser needs to know something
was an actual BR tag rather than just a line break signal, and by the
style bit entry when only the indication of a line break is required.

Table widths of 0 or 0% are ignored.

Trace.c updated to report height and background fields in a table_stream.

fm_putsl() writes a terminator into the string; the Forms.c routines were
calling this for displaying INPUT TYPE=PASSWORD fields using the FE_PassCode
literal string (a line of stars). This write into a read only data area
would make the debugger fault the access. A local char array is now used
instead, to get round this (note the use of var[]=literal rather than
var[sizeof(literal)]; strcpy(var, literal) due to some weird compiler bug
that copies the wrong thing into 'var' under some (undefined...)
circumstances).

Text areas don't scroll back to the top line when clicked in anymore;
single line writables don't scroll back to the left either. When
reentering a text area from 'above', the caret appears at the top line
rather than 'somewhere further down'...

ARROWS_MOVE_OUT compile time option at the top of Forms.c defines whether
you must press Tab/Shift+Tab to move between writable fields in forms or
if up/down will drop out of them, though if keyboard control is on this
is enforced (or you get trapped inside the form!).

urlutils_filetype_from_url now uses MimeMap module.

If fetcher is told a page is text, it'll check for a filename extension and
may choose to use this instead (e.g. it may find it's HTML instead). This
is to try and get around duff servers... (e.g. http://www.batalarms.co.uk/).

Save dialogues shouldn't flicker when options that don't change the
filetype are selected (before, the draggable sprite was always reset for
each selection). Noticed the erroneous setting of a static variable in
SaveFile.c by a call to this by SaveObject.c, and so added a flag to
savefile_set_filetype to deal with this - would have been possible to get
the wrong filetype sent to applications or at best the wrong filetype
sprite in the dialogue without that.

The caret shouldn't jump out of a form back to the URL writable if the page
reformats now.

Table background colours now supported (as in the colour you see in the
border space if the cellspacing is large enough; this is as in MSIE, not
as in Navigator). Drawfile output routines updated accordingly.

Corrected erroneous use of wimpt_dx() / wimpt_dy() in a couple of places
in Images.c, which meant that (say) 1x1 images didn't work correctly in
medium resolution display modes.

Now have support for save as text (component ID and event 0x12) and save
as Draw (component ID and event 0x13) buttons. Dubious conditions for
greying and ungreying the print, save source and view source buttons and
menu options sorted out as part of implementing the same for the two new
buttons; added greying out of their associated menu items in passing.

Turned kerning on in draw file objects (does mean a rather heinous
increase in file size, but this is the only way to ensure the draw file
matches the visible page).

Comments before functions in SaveDraw.c are now complete and up to date.

Image and visit histories now generate a crude hash number to speed up
searching for items. It does give a speed increase, though it's a
disappointingly small one.

Issue of left/right margins and cellpaddings sorted out. Now have
redraw_left/right_margin for finding out the basic gap you must leave.
redraw_left/right_gap then gives any extra indentation for LI, BLOCKQUOTE
or whatever. The last two can be subtracted from the display width to
get an available page width for any section of text. Note that
redraw_left_gap replaces redraw_margin. The redraw_start_x function
uses the above to work out where a line's left hand edge should be,
taking account of left/right/centre alignment. HRs have been fixed now
(they were quite broken in v1.30, I think) based on this new model and
the behaviour of MSIE/NN 4.

Fixed width of cells with no contents - cell padding values wouldn't
have worked properly as the reformatter returns 0 rather than the left
hand margin size if given no stream.

Removed FM_Absolute flags for Font_Paint (spotted by DBrown) - sets bit
2, which is reserved...?

IMG width and height in % terms now works correctly; a % of available
width (after margins and indents) or height on the main page or for
a table cell, if the image lies in one. Because of the chicken-and-egg
problem with the latter, the cell must specify a width and/or height
for things to work properly. If this is not done, you'll usually end
up with a 1:1 scaled image (as in Navigator 4, rather than ending up
with no image or even no cell (!), as in MSIE 4).

HEIGHT attribute on a TABLE tag is supported, but only in a crude
fashion; the extra height (if there is any) is distributed over the
rows in a linear fashion. This is probably all you have to do in
practice, but I haven't checked. To maintain a notion of min/max
height as well as width would of course require a great deal more
work...

If using client pull to reload a page with a fragment ('...#name')
specified, then the reload wouldn't work on the same page; it'd just
jump to the fragment position. This won't happen if b->reloading is
set now (so works in conjunction with client pull on the same page
forcing a non-cached fetch). Similarly, if POSTing to such a URL,
a fetch will proceed (both these fixes done originally for
http://jupiter.beseen.com/chat/rooms/g/1678/).

browser_inherit split to browser_inherit and browser_inherit_post_data;
the code for the latter didn't clear any post_data in the child before
copying from the parent either, and could cause flex errors (now fixed).

Res file for Ursula ('Desktop' Browse) build tweaked - bits in the
font choices dialogue renamed, and button bar rearranged to hold the
new Save As Draw button. Other builds have had Save As Draw and
Save As Text buttons added, or not, depending upon availability of
suitable sprites, required UI simplicity, etc.

Now have:

  Browse$ChoicesFile
  Browse$ControlsFile
  Browse$ChoicesSave
  Browse$ControlsSave

(the last two are new) for loading and saving of the Choices or Controls
files. If unset, <App$Dir>.Choices or <App$Dir>.Controls will be set.
E.g., you could set Browse$ChoicesFile to be:

  <App$Dir>.Choices,Choices:WWW.(app).Choices

for loading and

  <Choices$Write>.WWW.(app).Choices

for saving. (The browser never saves Controls at the moment, so the
relevant variable above isn't effectively implemented, but could be
in future). Similarly, to support asymetric loading/saving of the Hotlist,
there are HotlistSave, HistorySave and ImageHistorySave entries in Choices
to complement HotlistPath, HistoryPath and ImageHistoryPath (which are used
for loading). save_save_choices will create directories as needed to obtain
the given path (and has also been fixed in various areas that hadn't been
tested out until now; e.g. zero termination of the AppName$ChoicesFile
variable expansion...). !Run[D] files updated appropriately.

Table widthing code rewritten. Slower, but a lot better on the whole.
Still has some problems - still needs a final 'make sure nothing is
below minimum width' scan, which it should be possible to do without.
No time to fix this at present!

The reformatter will now 'glue together' an LI token followed by any
non-LI token; so a bullet point followed by an item should not be able to
have a line break inserted after the bullet because of very tight width
constraints (it could before - yuk...).

'about:' brings up a page about the browser and any Plug-Ins, as with
Navigator (for example).

URI files support titles, as per spec. version 8. Saving a current
location to the Hotlist will thus give a sensible title now (unless
you're in a frame, so there's no title to get...). Of course, v1.00
files without a title still work.

Note that NOBR is *not* supported in this build and this combined with
the new table widther may cause problems on some sites (e.g. Microsoft's
home page!).
@
text
@d1395 1
a1395 1
            StrNCpy0(new_status, lookup_token("FetchMany:Fetching frames contents...", 0, 0))
d3351 1
a3351 1
            toolbars_set_tristate_state(b, t, 0); /* Stop */
@


1.18
log
@Not all resources are up to date in this check-in, and documentation
both within source and stuff in 'Docs' is out of date or missing - I
was very pushed for time on this one... Hopefully will do another
'tidy up' check-in before close on Friday; until then, beware of
anything other than the Ursula (Desktop browser) build. Anyway...

Export As Draw done. As part of this, FONT SIZE and SUP / SUB adjustment
of font size is done in fm_token_font_info rather than fm_find_token_font.

Bullets and switches are plotted as indirected sprite items, rather than
indirected text + sprite items - this relied on being in a redraw loop to
pick the sprites up from the local pool (failed during printing).

URI files now have a LF line ending rather than CR... '*' recognised
as an empty field when loading via. RAM transfer now (only worked for
loading from disc before).

Gave placeholder bounding boxes 4 OS units more minimum extra gap
vertically and reduced horizontal addition to this value * 1.5, rather
than * 2 (see reformat_get_placeholder_size).

Background image tiling starts at ymax - h + 4, rather than ymax, so
there isn't the bottom line of pixels from the top tile always present
at the top of the window. The '+4' is for caution's sake.

Can now save a frame's HTML source, that of its parent or its ancestor,
and the same for the URI pointing to those documents - see Menus.h for
the relevant component IDs that should lead to the SaveFile dialogue.

Have hopefully fixed timeout = 0 values (i.e. 'forever') on things
like LinkTo; before, image fetches could override the state (so you'd
only ever see brief flickers of a given URL as the pointer went over
a link).

Save File dialogue will remember the state of option or radio buttons
for a given parent component origin and restore that state when the
dialogue is next opened from the same place (stops turning on saving
as a URL file also turning on 'save background images' for Draw file
export, etc.).

Use of a META tag to reload the *same* page now sets the 'reloading'
flag in the browser so that it doesn't go through a proxy - otherwise
pages which are meant to update periodically through client pull
don't work, as they keep coming out of the cache.

Can now handle images specifying just a width or height in the HTML
(other dimension is scaled accordingly, but note that the placeholder
size must still be 'dumb' until the image data comes in). An image
will now override an image history size entry for the same entry
with a different size.
@
text
@d3251 1
a3251 2
    /* Can only view source, save it, or print if there's source */
    /* present in the first place.                               */
a3256 4

// Should be able to print either way... Don't need
// the source to print, just a line list.
//      set_gadget_state(t, ButtonBarPrint, 1);
d3262 1
d3264 14
a3277 1
//      set_gadget_state(t, ButtonBarPrint, 0);
@


1.17
log
@There are a few known significant problems with this code but it's being
checked in so the Choices can be worked on. Note that Res files etc. are
not up to date across all builds. Progress is as follows...

Bug report prompted me to do this - now ignore <p> tags straight after
<li> tags, so '<ul><li><p>Some text' works as the author (or automatic
generator, more commonly) intended.

A <p> tag before a table will be acted upon now (it was ignored before).
Something like <li><p><table...> will give a line break and paragraph
space after the <li> despite the changes mentioned above, as in other browsers.
Both browsers differ from Navigator, where the table appears alongside
the <li> tag.

Multiple BR tags work as in MSIE / Navigator (they don't collapse to
zero height anymore).

For the above, line height (and so, <br><br> or <p> spacing) is now
calculated inside reformat_text_line_height, and is used with either
a token to get the text height at a given size (e.g. for general line
spacing or multiple BR tags) or NULL for normal size text (e.g. for
P spacing, though this value is in practice later scaled by 7/8ths in
reformat_check_height). Note this behaviour is exhibited by MSIE 4;
v3 gave two BRs the same spacing as one P (i.e. not font size
dependent).

Save dialogues can have an option button or couple of radios to
switch between various formats (e.g. URI or URL, sprite or original
format). See 'Docs.Notes' for more. The back-end to this is now
implemented (i.e. at the moment, save as URI or URL, save as original
image format). Note that when saving background images, a leafname
based on the original fetch URL is now offered rather than a generic
'Background'.

Internal URL scheme changed to be all lower case, so relativisation
through URL_Fetcher still makes sense... :-/

Holding down 'shift' when clicking on stop reverses the interpretation
of the Controls file 'StopWebServe' entry.

Fixed row / column count for exporting tables as text; fixed a few
bits and pieces of internal URL scheme stuff which got broken when
HTMLLib started using URL_Fetcher's relativisation.
@
text
@d1198 1
a1198 1
      if (!ancestor->status_handler && timeout > 0)
d1900 1
a1900 1
      if (timenow > contents[i].end)
d3258 4
a3261 1
      set_gadget_state(t, ButtonBarPrint, 1);
d3267 2
a3268 1
      set_gadget_state(t, ButtonBarPrint, 0);
@


1.16
log
@Fixed some glitches in the modified status bar code (e.g. status inference
wasn't working properly).

Shift+Toggle size always opened to not obscure the icon bar. If CMOS is
set to always show the icon bar, then Shift+Toggle size is meant to
reverse sense and open to absolute full size. It now does this.

!Run[D] files now require URL 0.22, HTTP 0.64, FTP 0.22, Gopher 0.08
and File 0.32.

Minor overhaul of 'Docs.Notes' (with 'Docs.User' similarly updated) to
include a few new bits and pieces.

Timeout values of 0 now mean 'forever'. Plug-in status messages now have
their own timeout setting. New Messages token 'Actv' for extra info when
a status message times out and the status line drops to 'Viewing' or
'Ready' when there is still a Busy state registered by the Plug-in.

Small Fetch windows don't become visible briefly for Plug-in fetches
when the fetch is complete (for SeeFetches:no, where these windows
should be hidden all the time).

WebServe may be controlled through the Browse front-end via.
Wimp_MAppControl reason code 4 (Wimp_MAppControl_Configure). Note the
renaming internally of 'WebServ' or 'WebServe' has been changed to
'Proxy' (with lower case equivalents where relevant); proxy name
and starting details come from the Messages file 'ProxyName' and
'ProxyComm' tokens. More in 'Docs.Notes'.

Res files updated for image history and PRE/TT font aspect ratio
choices. 'Don't expire' labels changed to 'Expire' (oops, didn't
notice the change in the development Browse's Res file when I
updated all of the others until now...).

When printing, Wimp_PlotIcon appears to ignore R4 and R5, plots
'somewhere' on the page, and tries to get the sprite from the global
pool. This latter part normally causes an error to be raised; though
on my machine I just get a corrupted error message. The Desktop font
gets lost at this point too. All have yet to be fixed; as an
interim work around, Wimp_PlotIcon objects are never drawn at all
if the global 'printing' flag is set.
@
text
@a1822 2
  _kernel_oserror * e;

@


1.15
log
@Implemented Message_PlugIn_ReshapeRequest, Message_PlugIn_Status and
Message_PlugIn_Busy. Plug-in code more robust when given invalid
browser instance handles by the plug-in.

Line spacing is now calculated on the basis of the normal style base serif
font, with all other fonts being forced into that line height. This does
mean that an unusually tall (say) sans serif font may get clipped. It
appears to be the only way to get around wildly different baseline
depths returned from the font metrics - you can't work out line spacing
based on each different font style; the line spacing will vary.

Table heighting (as opposed to widthing...) improved considerably; rowspan
can no longer cause very tall cells in odd places. Having trouble getting
rid of the single pixel breaks between vertically adjacent cells, though
I've not tried too hard. Widthing, though, seems fairly badly broken at
present... :-/

Set/clear of page_is_text flag made more robust (it looked as though there
was the potential for this to get stuck in a set state, though I've never
see the front-end behave in a manner which indicates this is the case).
The reformatter will now decrease leading if this flag is set (plain text
pages look daft with a line spacing that is OK for 'rich' text pages).
No reformatting is done if the page width changes by dragging on the
resize icon, though toggle size / full screen will still reformat even
if the contents are only text (browser needs to sort out various width
flags at this point).

Cut down on excessive redrawing when reformatting due to a change in
window dimensions is not done. If display_width hasn't changed, then no
redraw is needed. If this causes redraw problems, then whatever is
changing display_width needs investigating. It shouldn't be kludged
(basically) by forcing a redraw instead of a reformat.

TT/PRE/etc. text can now have a non-100% aspect ratio. 80-90% looks
best (ArcWeb, for example, uses 86%). New option 'TTAspect' in
the Choices files.

Debug builds link to a non-debug Unicode library now; stops stderr
being dumped to the bottom left of the screen if you've not redirected
it in the Run file.

RISC OS 3.1 seems to need more initial WimpSlot than later OS versions.
The 64 deep nested table set gives a 'No stack for trap handler' error
(which it really means in this case!) without 800K, even though 3.71
is happy with just 640K. So, the !Run file checks if Boot$OSVersion
is exactly 300, 310 or 311, and sets the WimpSlot accordingly.

!Run[D] files now require latest fetcher module versions (URL 0.21,
File 0.31, HTTP 0.58).
@
text
@a1118 2

      break;
d1120 1
a1135 2

      break;
d1137 1
d1141 1
a1141 3
      /* For Plug-In messages, use two times the general value. */

      timeout = 2 * atoi(lookup_control("ShowMiscFor:50",0,0));
d1143 1
a1143 1
      break;
d1145 1
a1151 2

      break;
d1153 1
a1159 2

      break;
d1161 1
a1189 2

      break;
d1191 1
d1198 1
a1198 1
      if (!ancestor->status_handler)
a1206 1
      break;
d1208 1
d1336 11
d1637 1
d1782 9
a1790 1
  /* more meaningful with the inference routine         */
d1904 9
a1912 1
        /* Message has expired */
d1938 9
a1946 1
          /* Non-idle message; it has expired */
d1993 1
d1995 1
a1995 1
    /* Otherwise, is a page fetch in progress? */
d1997 2
@


1.14
log
@This is an intermediate check-in to allow work on Choices for the new
table options and History choices as detailed below. Res files are not
up to date except where indicated and there are several known bugs that
will be fixed before the 'final' v1.27 is created. Any work on resources
should only be done for the testbed !Browse.

Client side image maps implemented. There is code to draw highlighted
borders in CSIM.c, but this is not wired in yet; other than that,
the implementation is functionally complete. As part of this, centralised
the fetching of a targetted URL taking into account user request of a
new view and full screen mode, in fetchpage_fetch_targetted. The forms
library now uses this too, so form buttons respond to both adjust-clicks
and TARGET attributes.

Fixed APPLET handling where '.class' isn't present in the CODE attribute.

Paragraphs squashed at the top of cells/pages - browser would insert white
space before.

Now append a ' ' to the end of History menu items to prevent the Wimp
thinking the end of entries represents a keyboard shortcut (e.g. 'Home').

Netscape's handling of 'meta http-equiv="refresh"' is to start counting
when the fetch has completed and everything else has died down. The browser
will now not start counting until the animation handler is deregistered
(so formatting is complete) to show similar behaviour (note that this
checks the main handler, not the 'idle but returning to first frame'
drift handler).

URLs from requests for fetches by Plug-Ins are now relativised.

Page width change tolerance prior to reformat upped from 16 to 32 OS
units. Hoping to provoke a loosely connected bug with this change!

TableOuter, TableInner and SeeFetches choices added to all Choices
files, with appropriate loading and saving code in Main.c and Save.c.
AuthorFTP and AuthorFSh messages added for FTP authentication, and
dialogue handling code (the component in FetchHTML.c) updated to
recognise an FTP fetch and alter the dialogue presentation
appropriately.

All Messages file version numbers taken up to 1.27 (20 Nov 1997).

Following a UseNet suggestion, Ctrl+Toggle Size will increase the window
size to fill the screen vertically only; horizontal size/positioning is
not changed.

Shift+Tab in the URL writable will cycle through alternative fetcher
protocols (from both the Controls file and checking the fetcher modules
are actually present).

Hotlist doesn't require '://' in URLs when loading HTML, just ':/' - so
'file:/' URLs now will be reloaded correctly.

History system rewritten completely. GHistSize and VHistSize options
removed, and replaced by MaxSize and ExpiryAge. Now have global history
menus with most recently visited items at the top, and local history
menus which reflect the path that forward/back buttons would take.
Browsers are robust to background expiry of the History though this is
not implemented - date expiry and size checks are carried out on
history_record only. This does mean that with two windows open one could
have the history expired underneath it whilst another fetched, though;
the code handles this and update toolbars (greying items) as necessary.
It is possible to have the history limits so tight that even one entry
will not fit and again the code copes with this, though values read
from Choices are limit checked to ensure rather more useful results!

Implemented 'Save' button in save dialogues. Remembers pathnames and just
replaces the leaf now (hard coded exceptions for <Wimp$Scrap>... and
<Wimp$ScrapDir>...) - it did before, but only if you'd typed the path
in. Not many people did, given that you couldn't press Return or click on
a Save button to use that path...

In a similar vein, files of type Data or DOS will be checked for a '/xxx'
type extension and the MimeMap module will be used to find a more meaningful
filetype. If this can be handled, the file is loaded. This only works for
files dragged to the browser - the behaviour with inline data in web pages
will depend on the File module, and similarly, if File doesn't spot what is
going on and claims that the object is data, the browser will just open a
save dialogue for it.

!RunD files taken up to 3072K WimpSlot.

Hotlist's saved HTML page title wasn't internationalised - is now. This
opened up a significant can of worms; on file write error, the file would
never be closed, and if a caller of the save or load functions passed
in a filename held in the global Messages lookup buffer then subsequent
lookups in the callees would corrupt that filename. All sorted out now.

Local (not very useful) or global (useful) histories can be saved as HTML,
which opens up the possibility of sending your history to the hotlist
by saving to it. Local and global histories can also be emptied, though
this is probably not a feature that current release Desktop browsers need.
Inheritance of local history and certain UI features is now done more or
less for all cases where one browser window spawns another, too.

Vertical alignment on images is rather less ropey than it was (e.g.
ALIGN=TOP stands half a chance of working) but is still far from perfect.
This was part of fixing a nasty little bug in Redraw.c's setting of
an image position via. image_set_token_image_position, which was making
(amongst possibly many other things) client side image maps fail.
Image update where images had large borders was affected by a similar
problem too (more cans with more worms...).

Fixed image background filler functions; two problems. When cross
referenced images were replaced by base images in a browser because the
original owner was closing down, the original owner browser would stay
registered with ImageLib. Fixed; secondly, when images were deleted from
the image array causing those above to be renumbered, images registered
with ImageLib did not have their numbers updated (this was the one that
lead to the visible drop out of background images with PNGs on the Acorn
Internet home page when there were two views of the page and the first
was closed). This is now also sorted out.
@
text
@d1141 9
d1625 7
d1815 1
a1956 2
  /*                                            */
  /* Is a page fetch in progress?               */
d1958 3
a1960 1
  if (fetch_fetching(b))
d1962 1
a1962 3
    /* If fetching, may in fact just be passing tokens through the fetcher */
    /* with no new actual data to get from the server. In that case want   */
    /* to give a 'processing' message; otherwise, definitely 'fetching'.   */
d1964 3
a1966 2
    if (b->fetch_status == BS_PROCESS) type = Toolbars_Status_Processing;
    else
d1968 3
a1970 4
      /* Need to find out the genuine fetch status, or all of the */
      /* varied fetch information that we can get out of the      */
      /* fetchers gets collapsed to some less meaningful generic  */
      /* message by this routine.                                 */
d1972 9
a1980 1
      int s;
d1982 10
a1991 8
      if (!url_status(0, b->fetch_handle, &s, NULL, NULL))
      {
        if      (s & URL_Status_Transfer)  type = Toolbars_Status_Fetching;
        else if (s & URL_Status_Responded) type = Toolbars_Status_Responded;
        else if (s & URL_Status_SentReq)   type = Toolbars_Status_SentReq;
        else if (s & URL_Status_SentData)  type = Toolbars_Status_SentReq;
        else if (s & URL_Status_Connected) type = Toolbars_Status_Connected;
        else if (!s)                       type = Toolbars_Status_Connecting;
a1992 1
      else type = Toolbars_Status_Fetching;
d1994 3
a1996 4
  }
  else
  {
    int specimg;
d1998 2
a1999 2
    /* If not fetching pages, are we fetching images? If so, display an */
    /* appropriate message.                                             */
d2001 1
a2001 1
    specimg = image_count_specific_pending(b);
d2003 4
a2006 4
    if (specimg && image_fetching(b)) type = Toolbars_Status_GetPics;
    else
    {
      /* If not fetching images either, then may be formatting or idle. */
d2008 3
a2010 2
      if (reformat_formatting(b)) type = Toolbars_Status_Formatting;
      else                        type = Toolbars_Status_Viewing;
@


1.13
log
@Sorted out Res files, including fixing position of 'bytes' label in one
of the Choices dialogues (I'd missed it out of a selection when everything
else got moved down a bit). Unfaded Enc_Chinese menu entries, made sure
text labels were wide enough for system font, changed 'Apply' on Choices
dialogue to 'Set', and added ^K to hotlist keyboard shortcut lists.
Print Setup (i.e. Print dialogue) buttons all set to 'local', so the
stupid Toolbox doesn't close the dialogue and lose the caret before I
can see if it was in there to start with...

256 colour hotlist sprites taken back to standard 16 colour versions,
since there's a significant speed penalty on slower machines. The
testbed browser still has the 256 colour versions so the designs aren't
completely lost.

Changed access settings to exported builds to wr/r - lr/r was really getting
on my nerves whenever I wanted to try something temporary out.

View source, save source and print handlers would all try to work if
there was no source to act on - despite the fact that toolbar buttons
would be greyed out form them. This is fixed.

The Navigate menu has components greyed to match the toolbar state,
when opened. It isn't kept up to date dynamically, though this shouldn't
really be a problem (reopen the submenu...). As part of this, finally
sorted out conditions for the Stop button to be greyed, or the
GoTo/Go/Stop tristate to be at 'Stop' versus 'GoTo'.

Deferred reformatting is now disabled for external image fetches.

Browser-local client pull flag removed; hitting the Stop button simply
cancels any null handlers working for it. That way, client pull switches
back on in passing at the next fetch (it was never really switched off).
So to stop client pull, hit the stop button at any point.

Done CELLPADDING attribute; cellpadding field in reformat_cell (Global.h)
is redundant since the table token is accessible from there, and so it has
been removed. CELLSPACING support also added.
@
text
@d49 1
d53 1
d1370 17
a1386 1
        if      (highest == Toolbars_Status_Fetching)   StrNCpy0(new_status, lookup_token("FetchMany:Fetching frames contents...",                          0, 0))
d1408 11
a1418 1
          if      (highest == Toolbars_Status_Fetching)   StrNCpy0(format, lookup_token("Fetch:Fetching '%s'...",                            0, 0))
d1453 11
a1463 1
          if      (highest == Toolbars_Status_Fetching)   StrNCpy0(new_status, lookup_token("FetchUK:Fetching web page...",                0, 0))
a1476 1
    case Toolbars_Status_LinkTo: /* (Drop through to Help) */
d1479 1
a1479 2
      int            filled = 0;
      HStream      * over;
d1481 45
a1525 1
      if (highest == Toolbars_Status_LinkTo)
d1527 1
a1527 2
        /* For comments on the use of the 'format' buffer, see the */
        /* code above.                                             */
d1529 1
a1529 16
        over = priority->pointer_over; /* (First take the pointer_over token...       */
                                       /*                                             */
        if (                           /*                                             */
             !over                     /*                                             */
             ||                        /*                                             */
             (                         /*                                             */
               over           &&       /* ...and if it isn't suitable, go to the      */
               !over->anchor           /* keyboard selected item, which may not be    */
             )                         /* present either...                           */
             ||                        /*                                             */
             ( over           &&       /*                                             */
               over->anchor   &&       /*                                             */
               !*over->anchor          /*                                             */
             )                         /*                                             */
           )                           /*                                             */
           over = ancestor->selected;  /* ...so pointer takes priority over keyboard) */
d1531 3
a1533 1
        if (over && over->anchor && *over->anchor)
d1535 17
a1551 1
          char format[Limits_StatusFormat];
d1553 6
a1558 1
          StrNCpy0(format, lookup_token("LinkTo:Link to '%s'...",0,0));
d1560 2
d1568 2
a1569 1
          url[sizeof(new_status) - strlen(format) - 1] = 0;
d1573 17
a1589 2
          sprintf(new_status, format, url);
          if (new_status[0] == '-') use_status++, dontappend = 1;
d1591 1
a1591 1
          filled = 1;
d1594 4
a1597 1
      else
d1599 1
a1599 3
        if (priority->status_help)
        {
          StrNCpy0(new_status, priority->status_help);
d1601 2
a1602 2
          dontappend = filled = 1;
        }
d1604 5
a1609 6
      /* If not filled, the message is out of date; that is, no  */
      /* object is selected but the message is still on a timer. */
      /* In that case, cancel it.                                */

      if (!filled)
      {
d3188 2
a3189 2
    if (!b->hnum || b->hpos == 1) set_gadget_state(t, ButtonBarBack,    1);
    else                          set_gadget_state(t, ButtonBarBack,    0);
d3193 2
a3194 2
    if (!b->hpos)                 set_gadget_state(t, ButtonBarForward, 1);
    else                          set_gadget_state(t, ButtonBarForward, 0);
d3232 2
a3233 2
    if (!b->hnum) set_gadget_state(t, URLBarHistoryMenuR,   1);
    else          set_gadget_state(t, URLBarHistoryMenuR,   0);
@


1.12
log
@Now working on source merged with Kevin Bracey's internationalisation
support. UNIFONT is undefined in the Make File for now. All Res and
Choices files updated appropriately.

Having sorted out the old Choices and Messages to form Choices, Controls
and Messages, this build has had the same cleaning up done internally.
This includes greater consistency in naming schemes and the removal of
the inconsitent choices items - e.g. Choices file entries saying 'delay
images' and 'plain backgrounds' where internally all the flags say 'show
images' and 'show backgrounds'. ChoiceDefs.h and CtrlDefs.h added to
clarify the meaning of some fields, though usage of these is not 100%
in the source (there are cases where parameters are passed through to
functions as ints, and those functions still check these against hard
coded values rather than the #define stuff).

Fetcher status return bits (connected, sent request, etc.) now reflected
in status bar. Progress during fetchs to files are reported by %, where
the size of the object is known. Exceeding 100% drops back to a byte
counter, in case the estimated size was wrong. The progress counter
may be updated after specific delays, rather than 'as often as possible',
to reduce flicker (as requested by D.Brown some time ago).

I've done a small rewrite of the fetch prioritisation scheme in FetchPage.c;
how well this performs in general use across different processor speeds
remains to be tested, but certainly it has some advantages. For each small
fetch window before the rewrite, a 4cs tight loop was entered - this gave a
noticable and substantial drain to the Desktop performance if more than one
was opened. Now, several can be up at once with little hit. The actual file
fetch is on half the priority it was before, with all others taken back
just a bit - e.g. from 20cs per poll to 15cs per poll for flat out
reformatting. You don't seem to lose much time on the format in practice,
and the Desktop feels quite a bit lighter at the same time. There's the
potential for smoother frameset loading in this scheme, too.

When Shift+Clicking on a link meant you still fetched inside the main
browser window, several fetches could occur in a frameset - one per frame.
However, now that you can only do this by clicking on a link that leads to
non-displayable data - or by turning off the small fetch windows by
setting UseSmall to 'no' in Choices - a bug where fetchpage_preprocessed
would stop such fetches as new ones were started was revealed.
The API to frames_abort_fetching has now been extended to include a
'stop file spooling too' flag, allowing a fix to be made by having
fetchpage_preprocess's calls not set this (and it doesn't check the
savelink flag is unset before proceeding, since frames_abort_fetching
does that implicitly now).

Had left the RAM transfer buffer at 16 bytes (from testing) accidentally...
Oops. Upped it to 4K. In addition, when loading data by RAM transfer,
the browser didn't notice if a RAMFetch bounced during the transfer. It
would be treated as a 'first' RAMFetch bounce, basically, and try to go to
file transfer - oops. Fixed.
@
text
@d3070 9
a3078 13
//    /* Can only stop if there's activity of some sort */
//
//    if (
//         !fetch_fetching(b)      &&
//         !reformat_formatting(b) &&
//         !image_fetching(b)
//       )
//
//       e = set_gadget_state(t, ButtonBarStop,1);
//
//    else e = set_gadget_state(t, ButtonBarStop, 0);
//
//    if (e) return e;
d3167 14
a3180 3
          status_type type = toolbars_return_act_status(b);

          switch (type)
d3182 1
a3182 8
            default:
            case Toolbars_Status_NoType:
            case Toolbars_Status_Ready:
            case Toolbars_Status_Viewing:
            {
              toolbars_set_tristate_state(b, t, 1); /* Go To */
            }
            break;
d3184 1
a3184 9
            case Toolbars_Status_Formatting:
            case Toolbars_Status_Processing:
            case Toolbars_Status_GetPics:
            case Toolbars_Status_Connected:
            case Toolbars_Status_SentReq:
            case Toolbars_Status_Responded:
            case Toolbars_Status_Redirected:
            case Toolbars_Status_Connecting:
            case Toolbars_Status_Fetching:
d3186 22
a3207 1
              toolbars_set_tristate_state(b, t, 2); /* Stop */
a3208 1
            break;
@


1.11
log
@Got the deferred reformatter working properly. It doesn't do that 'OK,
the page is fetched and reformatted, but just to annoy you, I'm going
to wait 5 seconds and then suddenly reformat the whole thing again'
trick anymore. The fetcher was calling the reformatter in a delayed
form even when the reformatter was already running, so it would carry
on past the reformat point or from below what had become and invalidated
line, and some time later, get back to the delayed reformat. Now,
reformatting is only delayed by the fetcher when the reformatter is not
running. In practice this means body text reformats as it fetches, but
large tables will show delayed reformatting - which was exactly the
intended behaviour of the feature when it was originally thought of.

fetch_token_data_address removed; it was only needed in two places,
both of which already knew when to read tp->text and when to ignore
it. Its functionality is duplicated in an 'if' involving reformat_istext,
anyway.

!Run[D] files taken back to requiring HTTP 0.33, since 0.36 introduces
many weird and wonderful problems.

Typo in Messages files, 'All current images (sic.) fetches finished' -
'images' is now 'image'.

Shift+Click saving - you could save to an application. No problem. But
the equivalent (just clicking on a link that led to an unknown datatype
and getting the save dialogue that way) didn't work. It does now.
Another problem was saving to an application that didn't support the
datatype - oops, the dialogue would close but the fetch would sit there
waiting to be told where to save. It doesn't close now (as expected).

NB, doing several simultaneous fetches to a text editor may have problems
as the editors are too clever for their own good. Despite receiving
DataLoad messages for <Wimp$Scrap> for files of different types, sizes
and datestamps, the editors can decide it's still the same file and:

Zap      - Hats off, it gets it right, almost. You do get warned 'Multiple
           copies - one on disc is newer' as everything after the first
           text loads, but they do load, and in separate windows.
StrongED - Does not load the subsequent files, so the browser gives 'Data
           transfer failed' errors and opens up Scrap. Turning off 'Don't
           load same file twice' fixes it - each file is loaded in a new
           window with no warnings. At least in the first case, you don't
           lose data, since the files are kept in Scrap.
Edit     - Each time it loads the file, it *replaces* the other one in
           memory, using the same window for each. This is the worst
           behaviour as it isn't configurable (well, I don't know of a way
           to change it...) and results in data loss as successive texts
           get trounced by the new data.

I can't see how I can fix this in the browser as it's basically silly
behaviour on behalf of the editors. Other applications which don't try
to work out if it's a new file or not are fine!

When conducting image fetches, proxying is allowed unless reloading.
When conducting page fetches, proxying was never allowed - so web cache
stuff would have been, er, interesting. It now sets X-NoProxy: in the
request header when reloading, but otherwise this is not included.

AnimSpeed is, at last, independent of browser poll speed. They used to
be tied together. Guess how the animation code used to work ;-)

'Can't handle this datatype' - deprecated now that save dialogues can be
popped up. The 'can't save objects in full screen mode' error would never
be shown due to a bug, anyway; this now replaces 'can't handle', which
has been removed from all Messages files.

RefoWait, RefoHang and RefoTime moved from Controls back to Choices.

Trying to get rid of strlen in the reformatter - it can get very slow
(e.g. strlen of 8K chunks of text, or if a 330K text file is transferred
from a text editor straight to the browser, strlen of a 330K string...).
There will be unfinished bits of code in the reformatter that may seem
unnecessary - they've just not been plugged in yet (since they don't
actually work). Don't remove them!
@
text
@d48 2
d56 2
a57 1
#include "URLUtils.h"
d111 1
a111 1
/* toolbar of the window due to the swapbars     */
d123 2
a124 2
  if (fixed.swapbars) return toolbars_get_lower_backend(b);
  else                return toolbars_get_upper_backend(b);
d179 1
a179 1
/* swapbars flag or merged toolbars.             */
d190 2
a191 2
  if (fixed.swapbars) return toolbars_get_upper_backend(b);
  else                return toolbars_get_lower_backend(b);
d286 1
a286 1
  if (!fixed.swapbars)
d450 1
a450 1
                                                             fixed.swapbars ? InternalBottomLeft : InternalTopLeft);
d456 1
a456 1
                                                                   fixed.swapbars ? InternalBottomLeft : InternalTopLeft);
d472 1
a472 1
                          fixed.swapbars ? InternalBottomLeft : InternalTopLeft);
d503 1
a503 1
  if (choices.move_gadgets > 0) toolbars_move_gadgets(b);
d558 1
a558 1
  if ((b.xmax - b.xmin) < fixed.minimum_convergence) b.xmax = b.xmin + fixed.minimum_convergence;
d731 1
a731 1
       time_now         > (handle->current_time + fixed.anim_delay)
d766 1
a766 1
       time_now         > (handle->current_time + fixed.anim_delay)
d826 1
a826 1
  if (slow_animation_frame >= animation_frames * animation_frames * fixed.anim_delay) slow_animation_frame = 0;
d828 1
a828 1
  sprintf(v, "sa%d\0", slow_animation_frame / (animation_frames * fixed.anim_delay));
d1126 5
d1349 5
d1368 8
a1375 3
        if      (highest == Toolbars_Status_Fetching)   StrNCpy0(new_status, lookup_token("FetchMany:Fetching frames contents...",    0,0))
        else if (highest == Toolbars_Status_Processing) StrNCpy0(new_status, lookup_token("ProcessMany:Processing frames contents...",0,0))
        else                                            StrNCpy0(new_status, lookup_token("FormatMany:Formatting frames contents...", 0,0))
d1390 8
a1397 3
          if      (highest == Toolbars_Status_Fetching)   StrNCpy0(format, lookup_token("Fetch:Fetching '%s'...",    0,0))
          else if (highest == Toolbars_Status_Processing) StrNCpy0(format, lookup_token("Process:Processing '%s'...",0,0))
          else                                            StrNCpy0(format, lookup_token("Format:Formatting '%s'...", 0,0))
d1425 7
a1431 3
          if      (highest == Toolbars_Status_Fetching)   StrNCpy0(new_status, lookup_token("FetchUK:Fetching web page...",    0,0))
          else if (highest == Toolbars_Status_Processing) StrNCpy0(new_status, lookup_token("ProcessUK:Processing web page...",0,0))
          else                                            StrNCpy0(new_status, lookup_token("FormatUK:Formatting web page...", 0,0))
d1520 1
a1520 1
  if (fixed.appendstatus && !dontappend)
d1527 1
a1527 1
    add = 1 + 1 + (fixed.usebrackets ? 2 : 0); /* (Terminating byte, plus separating space, possibly plus 2 brackets) */
d1536 1
a1536 1
      if (fixed.usebrackets) strcat(new_status, "(");
d1538 1
a1538 1
      if (fixed.usebrackets) strcat(new_status, ")");
d1669 43
d1828 7
d1845 20
a1864 1
    else                               type = Toolbars_Status_Fetching;
d2121 28
d2151 2
d2168 1
a2168 1
    if (fixed.colour_progress != 255)
d2182 1
a2182 1
        colour_new = saves ? fixed.colour_progress : ancestor->progress_colour;
d2197 1
a2197 1
  else if (e && fixed.appendstatus) toolbars_update_status(b, Toolbars_Status_Ready);
d2375 4
a2378 3
  browser_data * ancestor = utils_ancestor(b);
  int            saves    = 0;
  int            len      = 1; /* Start with the terminating zero byte accounted for */
d2410 13
d2429 13
a2441 3
    if      (fetched < 10240)    sprintf(buffer, "%d\0",  fetched);
    else if (fetched < 10485760) sprintf(buffer, "%dK\0", (fetched + 512)    / 1024);
    else                         sprintf(buffer, "%dM\0", (fetched + 524288) / 1048576);
d2445 3
a2447 3
    if      (fetched < 10240)    sprintf(buffer, "%d: %d\0",  saves, fetched);
    else if (fetched < 10485760) sprintf(buffer, "%d: %dK\0", saves, (fetched + 512)    / 1024);
    else                         sprintf(buffer, "%d: %dM\0", saves, (fetched + 524288) / 1048576);
d2557 1
a2557 1
  if (time_now - b->dialler_last > fixed.show_dstat_for)
d2579 1
a2579 1
      seconds   = (time_now / (fixed.quantise * 100)) * fixed.quantise;
d3068 1
a3068 1
  if (!fixed.dontgrey)
d3116 1
a3116 1
           !b->displayimages &&
d3120 1
a3120 1
         b->plainback
d3127 1
a3127 1
  if (fixed.dontgrey != 2)
d3187 5
@


1.10
log
@As warned in the last log, pretty much all event codes and component IDs
have now changed along with many of the names, to provide a consistent
name and numberspace for events and components. This also minimises
number clashes (e.g. as was, the Save File origin when opened from a
Hotlist menu with an already-used component ID). To get full details on
this, please carefully read through TBEvents.h.

Res files, Sprites files and Messages files have been updated again both
due to the above, and routine additions (e.g. message support for a few
Hotlist bits and pieces). !Run[D] files updated for FTP 0.11 and
HTTP 0.36.

In the Makefile, the Customer objects list was missing Save - must have
moved something when I should've copied it, when adding in SaveFile or
SaveObject in all probability. Now fixed. Couple of other bits and bobs
fixed in the build environment (e.g. stuff saying !Argo instead of
!Customer). Oh, and I've altered the MakeFile copy options again to the
best compromise I can come up with. Newer is turned on for everything
except !Run[D] and !RunImage, since both of those change between debug
builds - otherwise if you'd built debug and non-debug versions, it was
not possible to switch between them - one version would have the newer
timestamp and thus never get overwritten.

The default hotlist has had a few items added - that'll be about the end
of it, I think; there's more than enough stuff in there now.

Saving of the hotlist from the document menu and of URI files,
directories and selections from the hotlist menu tree is now implemented
- this new save system rocks... Oh, and you can save all images and
backgrounds as sprites.

Saving of items with Shift+Click to other applications directly now
works, and is robust. Unique Scrap filenames are used, with data load
bounces (e.g. if some pra - er, person quits the app they're sending
to) working correctly - that is, give an error, keep the file, rename
it to something safe, and open the directory it lies in. As opposed
to normal app-to-app bounces, where the scrap file is deleted (see
PRM 3-254). This means you can now look at README files in FTP
sites, say, without using a disc intermediate. Or you can send pictures
straight to ChangeFSI, fetch HTML links into editors, and so-on, and
so-on - it's all very funky. Known problems include the ambiguous
'invalid component ID' instead of 'file open' for *normal* (straight to
disc) shift+click saves, and I think I'll introduce a unique name
guarantee of some sort to stop 'file open' in the first place. Odd
that the really tricky part (app-to-app) should be least likely to
suffer from this!
@
text
@d664 13
d710 15
d727 2
a728 1
       animation_frames > 0
d748 12
d762 2
a763 1
       animation_frames > 0
d808 8
d823 1
a823 1
  if (slow_animation_frame >= animation_frames * animation_frames) slow_animation_frame = 0;
d825 1
a825 1
  sprintf(v, "sa%d\0", slow_animation_frame / animation_frames);
@


1.9
log
@First a minor warning - the various Res files are out of sync in this build.
Only the Browse resources are currently valid.

Added Utils.Icons - has a few archives inside containing the resources
(well, some of them) used to build various UI sprites for various builds.
Archived because these are unlikely to change much, and putting them on
CVS was a move to, well, archive the stuff...

SaveDBox objects vanquished and requirements in !Run[D] files removed. The
data save code fits much more neatly in amongst the data load protocol
stuff now (with the slight exception of having to split the SaveObject
source into SaveObject and SaveFile - the former handles multiple persistent
dialogues for Shift+Click on links and the like, the latter handles 'one at
a time' transient dialogues for save source and similar). Export Link is now
supported, too, and writes a 'proper' version URI file. You'll find that
double-clicking on old URI files will work as the URI handler picks them up,
whilst new version ones don't; however, dragging onto the browser will only
work with new version files. Note that support for saving and loading URL
files (ANT suite stuff) is present too, so old URI files can be typed as URL
files if you want to keep them working without modification - the URI
handler itself will hopefully support the defined URI file format soon;
double-clicking on old URI files will stop working at that point. Note
there are *lots* of changes in every Res file to support all this. This may
all seem a bit pointless to some, but the changes do in fact make it very
easy to add new save dialogues all over the place. Certainly much easier
than with the previous system, anyway. In fact, post script, image
'save as sprite' took about half an hour, which I hope proves the worth
of the new system.

Merged in newer hotlist code with support for drag cancelling with Escape
(all relevant Res files appropriately updated) and cancelling scrolling
when you've reached the window scroll limit. Had to move some of the
Wimp message handling stuff to the central Protocols source, as clashes
were occuring, and also the hotlist routines were using independent saving
code - a lot of duplicated effort. This was fair enough as at the time the
Hotlist code was written, the Save code couldn't be used in the way it is
now.

New Save Source and Print buttons on the toolbar of some builds.

Phoenix Sprites file made more efficient - the Acorn base section has been
split from the animated upper region. Browse build has a new grey fade
sprite at the back, which is less grainy than the previous one and only
uses 16 colours (with a 16 greyscale palette).

Not really a bug, bug the routine to start an image fetch for INPUT
TYPE=IMAGE forms items only did so if the src field (or equivalent, for
this tag type) was non-NULL. In fact, you should always call image_new_image
and let that handle the rest, otherwise other sections of the code will fail
as they try to obtain an image number for a given HStream and get -1 back.
This problem only generally manifested itself when loading an HTML file to
the browser straight from an application, as many src fields become NULL
when the relativisation routines find nothing to relativise to...

Authentication got broken somewhere along the line - this has been fixed
(in HTMLLib and the browser).

Ctrl+Click on a cross referenced image updates *all* copies, not just the
one with the image data attached.

Next big step: Rip up TBEvents.h and rebuild that whole approach somewhat.
To all those working on the code, my apologies but this means all Res files
will receive a very large number of alterations and there will be extensive
code changes too (mostly naming convention stuff), in more or less all
source files. I am endeavouring to ensure that the new numberspace
convention does not clash with the work being done by Kevin on
internationalisation.
@
text
@d327 2
a328 2
  if (gadget_get_bbox(0, o, URLSpacer, &url)) return 0;
  if (gadget_get_bbox(0, o, ButtonSpacer, &but)) return 0;
d462 1
a462 1
        gadget_get_bbox(0, t, URLSpacer, &w);
d569 2
a570 2
      e      = gadget_get_bbox(0, t, DisplayMenu, &g1);  /* Get the popup's bounding box    */
      ChkError(gadget_get_bbox(0, t, DisplayURL,  &g2)); /* Get the writable's bounding box */
d599 1
a599 1
          ChkError(gadget_move_gadget(0, t, DisplayMenu, &g1));
d606 1
a606 1
        ChkError(gadget_move_gadget(0, t, DisplayURL,  &g2));
d622 2
a623 2
      ChkError(gadget_get_bbox(0, t, DisplayBytes, &g1));
      ChkError(gadget_get_bbox(0, t, DisplayStats, &g2));
d636 1
a636 1
        ChkError(gadget_move_gadget(0, t, DisplayBytes, &g1));
d640 1
a640 1
        ChkError(gadget_move_gadget(0, t, DisplayStats, &g2));
d682 1
a682 1
  return button_set_validation(0, t, DisplayAnim, v);
d742 6
a747 6
/* DisplayAnim (see Toolbars.h) in an object of  */
/* ID given in void * handle (must be cast to    */
/* this to fit as a Wimp event handler) by one   */
/* frame for each complete cycle of the main     */
/* status animation (whether that is actually    */
/* animating or not).                            */
d780 1
a780 1
  button_set_validation(0, o, DisplayAnim, v);
d1180 2
a1181 2
  char             new_status [Limits_DisplayStats];
  char             url        [Limits_DisplayStats];
d1471 1
a1471 1
  ChkError(displayfield_get_value(0, t, DisplayStats, url, sizeof(url),NULL));
d1481 1
a1481 1
                                    DisplayStats,
d1968 2
a1969 2
  char              progress [Limits_DisplayBytes];
  char              old      [Limits_DisplayBytes];
d1980 1
a1980 1
  e = button_get_value(0, t, DisplayBytes, old, sizeof(old), NULL);
d1994 1
a1994 1
      if (!button_get_flags(0, t, DisplayBytes, &flags))
d2012 1
a2012 1
                           DisplayBytes,
d2019 1
a2019 1
    button_set_value(0, t, DisplayBytes, progress);
d2265 1
a2265 1
  char     url[Limits_DisplayURL];
d2306 2
a2307 2
  writablefield_get_value(0, t, DisplayURL, cmp, sizeof(cmp), NULL);
  if (strcmp(cmp, url)) writablefield_set_value(0, t, DisplayURL, url);
d2331 2
a2332 2
  char              display[Limits_DiallerStatus];
  char              compare[Limits_DiallerStatus];
d2388 1
a2388 1
      e = displayfield_get_value(0, t, DiallerStatus, compare, sizeof(compare), NULL);
d2396 1
a2396 1
        e = displayfield_set_value(0, t, DiallerStatus, display);
d2429 2
a2430 2
  char              display[Limits_DiallerStatus];
  char              statstr[Limits_DiallerStatus];
d2530 1
a2530 1
    e = displayfield_get_value(0, t, DiallerStatus, compare, sizeof(compare), NULL);
d2537 1
a2537 1
      e = displayfield_set_value(0, t, DiallerStatus, display);
d2545 1
a2545 1
    char label[Limits_DiallerLabel];
d2547 1
a2547 1
    if (button_get_value(0, t, DiallerLabel, label, sizeof(label), NULL)) return NULL;
d2557 1
a2557 1
      return button_set_value(0, t, DiallerLabel, label);
d2586 1
a2586 1
    char label[Limits_StatusLabel];
d2588 2
a2589 2
    show_gadget(t, DisplayStats);
    hide_gadget(t, DisplayURL);
d2593 1
a2593 1
    if (!button_get_value(0, t, StatusLabel, label, sizeof(label), NULL))
d2598 1
d2602 1
a2602 1
        button_set_value(0, t, StatusLabel, label);
d2630 1
a2630 1
    char label[Limits_StatusLabel];
d2632 2
a2633 2
    show_gadget(t, DisplayURL);
    hide_gadget(t, DisplayStats);
d2637 1
a2637 1
    if (!button_get_value(0, t, StatusLabel, label, sizeof(label), NULL))
d2646 1
a2646 1
        button_set_value(0, t, StatusLabel, label);
d2683 1
a2683 1
      source = state ? ButtonBack : ButtonCancel;
d2687 1
a2687 1
      ChkError(copy_toolaction_info(t, source, t, ButtonBi));
d2727 3
a2729 3
      if (!state)          source = ButtonGo;
      else if (state == 1) source = ButtonGoTo;
      else                 source = ButtonStop;
d2733 1
a2733 1
      ChkError(copy_toolaction_info(t, source, t, ButtonTri));
d2770 1
a2770 1
    if (!gadget_get_bbox(0,t,ButtonSpacer,&w)) return (w.ymax - w.ymin);
d2804 1
a2804 1
    if (!gadget_get_bbox(0,t,URLSpacer,&w))
d2837 1
a2837 1
    if (!gadget_get_bbox(0,t,StatusSpacer,&w)) return (w.ymax - w.ymin);
d2878 1
a2878 1
//       e = set_gadget_state(t, ButtonStop,1);
d2880 1
a2880 1
//    else e = set_gadget_state(t, ButtonStop, 0);
d2887 2
a2888 2
    if (!b->hnum || b->hpos == 1) set_gadget_state(t, ButtonBack,    1);
    else                          set_gadget_state(t, ButtonBack,    0);
d2892 2
a2893 2
    if (!b->hpos)                 set_gadget_state(t, ButtonForward, 1);
    else                          set_gadget_state(t, ButtonForward, 0);
d2900 3
a2902 3
      set_gadget_state(t, ButtonViewSrc, 1);
      set_gadget_state(t, ButtonSaveSrc, 1);
      set_gadget_state(t, ButtonPrint, 1);
d2906 3
a2908 3
      set_gadget_state(t, ButtonViewSrc, 0);
      set_gadget_state(t, ButtonSaveSrc, 0);
      set_gadget_state(t, ButtonPrint, 0);
d2922 1
a2922 1
       set_gadget_state(t, ButtonLoadImg, 0);
d2924 1
a2924 1
    else set_gadget_state(t, ButtonLoadImg, 1);
d2931 2
a2932 2
    if (!b->hnum) set_gadget_state(t, DisplayMenu,   1);
    else          set_gadget_state(t, DisplayMenu,   0);
d2948 1
a2948 1
        if (b->merged_url && !gadget_hidden(t, DisplayURL)) toolbars_set_bistate_state(b, t, 0);
d2968 1
a2968 1
        if (b->merged_url && !gadget_hidden(t, DisplayURL)) toolbars_set_tristate_state(b, t, 0);
@


1.8
log
@This version is being checked in because the Hotlist manager in the test
build provokes a Wimp bug. All the variant resource files are out of sync
and there are several outstanding bugs in the main code, so I'd personally
avoid this build like the plague unless you're mad enough to want to
examine the Wimp problem ;-)
@
text
@d2894 2
a2895 1
    /* Can only view source if there's source to view */
d2897 12
a2908 2
    if (!b->source)               set_gadget_state(t, ButtonViewSrc, 1);
    else                          set_gadget_state(t, ButtonViewSrc, 0);
@


1.7
log
@Very long log entry alert - but hey, beats 'Bug fixed' (sorry, Richard) ;-)

Open URL implementation more or less complete, though may undergo UI
revision at a later date to allow named frames to be targetted. Hope to use
the ideas in this code as the foundation for other general dialogues.

In token stream dump for TRACE builds, table head items were not indented
as far as they should have been - this is fixed; and manual toolbar redraw
routines have been removed. They never worked, were commented out, and
would never be used in that form anyway.

DragBox source added, but it isn't at all complete and won't work - this is
an 'in spare time' thing. We need custom drag boxes constrained to windows
for the hotlist, and unconstrained for frame border resizing... Hey ho.

Ancestor window extents match visible areas if there are frames (no more
scrolling framesets...!). Frame resizing works whilst new documents fetch
without pulling the extent down now. However, frame horizontal extents
never shrink until a reload which is nasty, and this is all due for a
rewrite. Frames border redrawing routine moved out of Redraw.c and into
Frames.c. Bug regarding the mouse rectangle and frame border widths
(rectangle was too large, so you could squash the edges) for edge-drag
frame resizes fixed.

Window width change reformat tolerance fixed; you could creep the window
width down or up forever without any reformat, and centred objects would
move but not be redrawn (thereby giving rise to subsequent redraw errors).

Filetype on objects saved through Shift+Click correct. Save Source dialogue
recognises if that source is plain text, rather than assuming HTML. A
browser that fetches a file remembers the old store size it had before the
save, so even though the data is now ditched, it reports the same amount of
data fetched afterwards (looked awful when this could, for example,
suddenly say '0' after a file save). Progress indicator is now fully aware
of one or many file saves inside a frameset and reports the number of
saves, a colon, and the cumulative saved data count, instead of reporting
the sum total of fetched data in all frames, including non-file save stuff
(note that for just 1 save, '1:' is not shown as a special case for the
most common condition). A bug related to this, where you could in fact only
do one fetch per frame*set*, has been corrected (only one fetch allowed per
frame still, this is unlikely to ever change).

Hotlist support added (D.Brown's source), with various bits of integration
and modification still in progress there. Note additions to the Messages
files. On the subject of Messages, the whole mucky business about what
goes in Messages or Choices (and a few bugs where lookup_choice was used
instead of lookup_token or vice versa) has been sorted out. Messages
contains, more or less, just that. Choices contains user configurable
stuff which generally can't mess things up too badly. A new file, Controls,
is a Messages file holding the non-user configurable choices, which can
generally make things go badly wrong if misused. A lot of these are tied
to the Res file. StrongED users can get these to automatically fold out
the various sections (EMail me for details). Sorry, but at the time of
writing, Zap doesn't do folding... =8*P

Two bugs with images. Asking for images to be shown in browser B when
browser A uses the same ones and was loaded first didn't work correctly,
and now does (a bit weird - browser A does the fetch and browser B does the
display...). Second one occurred when the background image was also used on
the page as a foreground image. This has been fixed by flagging background
images in the image_info structure, and checking this before cross
referencing. This bit also allowed the image_restart_fetches API to be
extended, so that just background or foreground images may be fetched if
they weren't already and the user asked the browser to show them. Before,
the whole lot had to be fetched together (so turning on 'display
backgrounds' will now kick off an image fetch if required, you don't
need to reload the page anymore).

Makefile copy options tweaked to be 'newer' (so if you're testing with some
temporary Choices file or something, it won't write over it at the end of
every export), and REMOTE_HOTLIST flag added for Customer builds - means
the Hotlist.c functions aren't needed; the old, hotlist-by-file method is
used. Added support for Customer build (see later), though there were very
few additions needed in practice.

Table printing fixed - in many ways it wasn't broken, it was image printing
causing the oddities ever since the global image pool was introduced (this
is, again, fixed). The 'reformat to fit page' option didn't work as coded
any more; tables store cell addresses in the HStreams, so you can't then do
a background reformat in a different browser. Hence, it now has to reformat
to the page width, print, then put the page back again, all in the actual
displayed browser. This doesn't feel as slow in use as it perhaps should,
considering what is going on... Note that a line of a defined fraction (see
Print.h) of page height will now split over page boundaries, so tall images
or tall tables don't cause problems now (aside from the obvious problem of
having the line split over a page at all!). There was a bug in the routine
to print from a given start point until 'n' pages had been filled, in that
it always filled 'n + 1' - now fixed. Finally, as part of the printing
tweaks, a new dialogue exists - PrintStyle - with a similarly named source
file added to deal with it.

Global history auto save / load done, but only to the Choices file path -
the whole browser is still strictly single user at present, with all the
extra work for a multiuser Customer environment yet to be done. This has
shown up a global history corruption problem which I haven't fixed yet.

Rationalising TBEvents.h - things are migrating out of it, and into more
appropriate sources (e.g. definitions relating to the Open URL dialogue are
going into OpenURL.h, etc.). Event codes were at one stage deliberately
diverged in numberspace from the component IDs of typical gadgets raising
the events, to avoid anyone getting confused and thinking the IDs and event
codes must match. However, this is in fact unlikely and it is much easier
to remember the fewer numbers that result from tying the two together where
possible. This has resulted in changes to event codes raised in the
following objects of all Res files: Authorise, Find, OpenURL, and
PrintStyle.

And finally - !Run[D] files for all variants updated to require the latest
toolbox and fetcher modules. All Res files updated for hotlists etc. and
sprites files updated appropriately. All Messages, Choices and Controls
files brought in sync., and an Customer build has been added (based on the
Desktop build binary with different resources).

That's all for now...
@
text
@d545 6
d2850 5
d2861 1
a2861 2
  _kernel_oserror * e;
  ObjectId          t;
d2864 2
a2865 1
  if (!t) return NULL;
d2886 2
a2887 4
    if (!b->hnum || b->hpos == 1) e = set_gadget_state(t, ButtonBack,    1);
    else                          e = set_gadget_state(t, ButtonBack,    0);

    if (e) return e;
d2891 2
a2892 4
    if (!b->hpos)                 e = set_gadget_state(t, ButtonForward, 1);
    else                          e = set_gadget_state(t, ButtonForward, 0);

    if (e) return e;
d2896 2
a2897 2
    if (!b->source)               e = set_gadget_state(t, ButtonViewSrc, 1);
    else                          e = set_gadget_state(t, ButtonViewSrc, 0);
d2899 2
a2900 1
    if (e) return e;
d2902 9
a2910 5
    /* Only need to load images if delayed image loading is set */
    /* in the local browser flags.                              */

    if (b->displayimages || b->displayed == Display_External_Image) e = set_gadget_state(t, ButtonLoadImg, 1);
    else                                                            e = set_gadget_state(t, ButtonLoadImg, 0);
d2912 1
a2912 1
    if (e) return e;
d2919 2
a2920 4
    if (!b->hnum)                 e = set_gadget_state(t, DisplayMenu,   1);
    else                          e = set_gadget_state(t, DisplayMenu,   0);

    if (e) return e;
@


1.6
log
@Updated Makefile to work better in folding text editors. More or less rewrote
Limits.h, and ensured consistent comment styling throughout all sources.
Fetch.c/h split to Fetch, FetchHTML and URLveneer. URLstat.c/h produced to
cope with this. OpenURL and Find sources created from bits in the Windows
source file that shouldn't have been there... These will get filled out
shortly. Note that a few functions in Fetch are due to be renamed and moved;
probably to Tokenutils.
@
text
@a44 1
#include "TBEvents.h"
d97 2
d100 2
a101 1
static void              toolbars_create_progress        (browser_data * b, char * buffer);
d657 1
a657 1
  char     v[10];
a670 21
  #ifdef TRACE

    {
      int len = utils_len_printf("sa%d\0", b->current_frame);

      if (len > sizeof(v))
      {
        erb.errnum = Utils_Error_Custom_Normal;
        sprintf(erb.errmess,
                "Would have overflowed sprite name string buffer in toolbars_animation_set_sprite (needed %d bytes, had %d)",
                sizeof(v),
                len);

        show_error_ret(&erb);

        return 0;
      }
    }

  #endif

d736 1
a736 1
/* DisplayAnim (see TBEvents.h) in an object of  */
d757 1
a757 1
  char     v[10];
a768 21
  #ifdef TRACE

    {
      int len = utils_len_printf("sa%d\0", slow_animation_frame / animation_frames);

      if (len > sizeof(v))
      {
        erb.errnum = Utils_Error_Custom_Normal;
        sprintf(erb.errmess,
                "Would have overflowed sprite name string buffer in toolbars_animate_slow (needed %d bytes, had %d)",
                sizeof(v),
                len);

        show_error_ret(&erb);

        return 0;
      }
    }

  #endif

d1070 1
a1070 1
      timeout = atoi(lookup_token("ShowMiscFor:50",0,0));
d1079 1
a1079 1
      timeout = atoi(lookup_choice("ShowLinksFor:200",0,0));
d1088 1
a1088 1
      timeout = atoi(lookup_token("ShowHelpFor:600",0,0));
d1442 1
a1442 1
    toolbars_create_progress(contents[found].b, progress);
d1967 1
d1969 1
a1969 1
  toolbars_create_progress(b, progress);
d1974 1
a1974 1
  e = displayfield_get_value(0, t, DisplayBytes, old, sizeof(old), NULL);
d1979 36
a2014 1
  if (!e && strcmp(progress,old)) displayfield_set_value(0, t, DisplayBytes, progress);
d2019 53
d2075 1
a2075 1
/* a given browser and any children it may have. */
d2077 10
a2086 2
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the fetch.            */
d2089 4
a2092 1
/*             in bytes.                         */
d2097 27
d2128 7
d2137 10
a2146 1
      fetched += toolbars_calculate_progress(b->children[i]);
d2150 5
a2154 1
  /* Count the image data obtained so far */
d2156 5
a2160 1
  fetched += image_total_bytes_fetched(b);
d2162 1
a2162 1
  /* Add the current source store size */
d2164 1
a2164 1
  if (b->source) fetched += flex_size((flex_ptr) &b->source);
d2166 3
a2168 7
  /* If saving, don't want to confuse the issue with any image */
  /* fetch information or whatever. So just use the current    */
  /* output file size.                                         */

// And for frames? Hmph.

  if (b->save_file) fetched = (int) (ftell(b->save_file));
d2182 1
a2182 1
/*             Pointer to the buffer.            */
d2184 5
a2188 2
/* Assumes:    That the buffer is large enough   */
/*             for the string.                   */
d2191 1
a2191 1
static void toolbars_create_progress(browser_data * b, char * buffer)
d2194 2
d2199 27
d2231 12
a2242 4
  if      (fetched < 1)        strcpy (buffer, "0");
  else if (fetched < 10240)    sprintf(buffer, "%d",   fetched);
  else if (fetched < 10485760) sprintf(buffer, "%dK", (fetched + 512)    / 1024);
  else                         sprintf(buffer, "%dM", (fetched + 524288) / 1048576);
d2244 1
a2244 1
  return;
d2591 1
a2591 1
      lookup_token("DisplayStatus:Status",0,0);
@


1.5
log
@Quite a few general source changes throughout many files to sort out swapped
toolbars. There will be more work on this shortly. svcprint.c has been
modified to allow it to output to a file in PipeFS, so TML-less machines
can still use the standard browser debug routines (albeit in a less than
elegant fashion). Comments in that source file give more details. Plus a
few more bug fixes.
@
text
@d17 1
d19 2
a20 1
/*          browser                                */
d22 2
a23 1
/* History: 21-Nov-96: Created                     */
d49 1
a49 1
#include "Fetch.h"
d90 1
d506 2
a507 1
//    ChkError(wimp_force_redraw(-1,
d643 56
d710 5
a714 23
  if ((handle->status_bar) && (animation_frames > 0))
  {
    ObjectId t;
    char     v[8];

    /* Find the status bar object Id */

    t = toolbars_get_lower(handle);
    if (!t) return 0;

    /* Advance the frame counter and put a validation string  */
    /* that would give a button gadget the relevant animation */
    /* sprite into v.                                         */

    handle->current_frame ++;
    if (handle->current_frame >= animation_frames) handle->current_frame = 0;
    sprintf(v,"sa%d",handle->current_frame);

    /* Set the validation string on the status bar animation */
    /* button icon to v, so that the new sprite is shown.    */

    button_set_validation(0,t,DisplayAnim,v);
  }
d732 4
a735 1
  if (handle->status_bar && animation_frames > 0)
d737 1
a737 25
    ObjectId t;
    char     v[8];

    /* Find the status bar object Id. If it can't be */
    /* found, deregister this handler and exit.      */

    t = toolbars_get_lower(handle);
    if (!t)
    {
      deregister_null_claimant(Wimp_ENull,(WimpEventHandler *) toolbars_animation_drift,handle);
      handle->anim_drift = 0;
    }

    /* Advance the frame counter and put a validation string  */
    /* that would give a button gadget the relevant animation */
    /* sprite into v.                                         */

    handle->current_frame ++;
    if (handle->current_frame >= animation_frames) handle->current_frame = 0;
    sprintf(v,"sa%d",handle->current_frame);

    /* Set the validation string on the status bar animation */
    /* button icon to v, so that the new sprite is shown.    */

    button_set_validation(0,t,DisplayAnim,v);
d743 1
a743 1
      deregister_null_claimant(Wimp_ENull,(WimpEventHandler *) toolbars_animation_drift,handle);
d776 1
a776 1
  char     v[8];
d787 23
a809 1
  sprintf(v, "sa%d", slow_animation_frame / animation_frames);
d920 1
a920 1
        Printf("\ntoolbars_update_status():");
d972 1
a972 1
        Printf("\ntoolbars_update_status():");
d1064 1
a1064 1
               "No status_content array in toolbars_update_specific_status()")
d1214 2
a1215 1
  char             new_status[MaxStaLen];
a1216 1
  char             url[sizeof(new_status)];
d1233 1
a1233 1
               "No status_content array in toolbars_write_status()")
d1281 1
a1281 1
      char title[MaxTiBLen + 1];
d1283 1
a1283 1
      memset(title, 0, sizeof(title));
d1289 1
a1289 1
           window_get_title(0,ancestor->self_id,title,sizeof(title),NULL) ||
d1296 3
a1298 1
        char format[50];
d1302 1
d1327 1
a1327 1
      char format[50];
d1426 1
a1426 1
          char format[50];
d1479 1
a1479 1
    char progress[30];
a1504 1
  *url = 0;
d1659 1
a1659 1
               "No status_content array in toolbars_timeout_status()")
d1816 1
a1816 1
               "No status_content array in toolbars_infer_status()")
d2002 2
a2003 1
  char              progress[MaxBytLen], old[MaxBytLen];
d2059 1
a2059 3
// What to do about this for frames...?
//
//    if (b->savefile) fetched = (int) (ftell(b->savefile));
d2061 1
a2061 1
  b->bytes_fetched = fetched;
d2074 1
d2112 1
a2112 1
  char     url[MaxUrlLen];
d2178 2
a2179 2
  char              display[MaxDiaLen];
  char              compare[sizeof(display)];
d2230 2
a2231 1
      sprintf(display, "%02u:%02u:%02u\0", hours, minutes, seconds);
d2237 1
d2276 2
a2277 2
  char              display[MaxDiaLen];
  char              statstr[MaxDiaLen];
d2392 1
a2392 1
    char label[DiaLabLen];
d2395 1
d2420 1
d2433 1
a2433 1
    char label[StaLabLen];
d2442 2
d2463 1
d2476 1
a2476 1
    char label[StaLabLen];
d2485 2
d2512 1
d2515 1
d2556 1
d2559 1
a2858 2

/*************************************************/
@


1.4
log
@Checking in mostly because its Friday... Quite a few little bug fixes
(adding up to a greater whole), which include removal of the dastardly
'invalid image number' errors that trace builds would raise from time to
time. Frame highlights are now better controlled (releaseably so).
Generally, this build represents the first genuinely promising version
of the browser for quite some time, despite the known library problems
with comment handling etc.
@
text
@d239 1
d241 1
d243 1
d259 1
a259 1
  toolbox_get_parent(0,o,&p,NULL);
d265 4
a268 1
  ChkError(toolbox_show_object(0,o,0,0,p,-1));
d272 1
a272 1
  ChkError(window_get_wimp_handle(0,o,&s.window_handle));
d275 1
a275 1
  /* Set the vertical size */
d277 10
a286 2
  s.visible_area.ymin = s.visible_area.ymax - height;
  ChkError(toolbox_show_object(0,o,1,&s.visible_area,p,-1));
d290 1
a290 2
  if (flags == 2) ChkError(window_set_tool_bars(2, p, 0, o, 0, 0)); /* Top left    */
  else            ChkError(window_set_tool_bars(1, p, o, 0, 0, 0)); /* Bottom left */
d292 4
a295 1
  /* Set the scroll position */
d298 1
a298 1
  ChkError(toolbox_show_object(0,o,1,&s.visible_area,p,-1));
d383 12
a394 2
  /* At present, if toolbars are merged to the top or bottom of the */
  /* window, presence cannot be set through this function.          */
d396 11
a406 2
  #ifdef TRACE
    if (tl & (1u<<1))
d408 11
a418 1
      if (b->all_in_top || b->all_in_bottom) Printf("toolbars_set_presence: Toolbars are fixed, exitting with no action\n",(void *) b);
a419 1
  #endif
d421 2
a422 1
  if (b->all_in_top || b->all_in_bottom) return;
d424 1
a424 1
  /* Otherwise, proceed */
d428 1
a428 1
    t = fixed.swapbars ? toolbars_get_lower(b) : toolbars_get_upper(b);
d441 1
a441 1
                                                             InternalTopLeft);
d447 1
a447 1
                                                                   InternalTopLeft);
d456 1
a456 1
        gadget_get_bbox(0,t,URLSpacer,&w);
d463 1
a463 1
                          InternalTopLeft);
d468 1
a468 1
      else toolbox_hide_object(0,t);
d474 1
a474 1
    t = fixed.swapbars ? toolbars_get_upper(b) : toolbars_get_lower(b);
d484 1
a484 1
      if (b->status_bar) ChkError(toolbox_show_object(0,t,0,NULL,o,-1));
d488 1
a488 1
      else ChkError(toolbox_hide_object(0,t));
d496 1
a496 2
/*
// */  /* Make sure that the window is completely redrawn */ /*
a507 1
*/
d2538 1
a2538 1
/* this (see toolbars_url_height(), which does). */
@


1.3
log
@Supported client pull, through a generalised handing of the META tag.
@
text
@d80 3
d102 2
a103 1
/* toolbar of the window.                        */
d114 20
d136 1
a136 1
  if (b->all_in_bottom || fixed.swapbars)
d169 2
a170 1
/* left toolbar of the window.                   */
d181 21
d204 1
a204 1
  if (b->all_in_top || fixed.swapbars)
d340 2
a341 1
/* Parameters: The browser window's object ID;   */
a345 3
/*                                               */
/* Assumes:    That the object ID really is a    */
/*             valid browser window.             */
d348 1
a348 1
void toolbars_set_presence(ObjectId o, unsigned int flags)
d350 2
a351 2
  browser_data * b;
  ObjectId       t;
d354 1
a354 1
    if (tl & (1u<<1)) Printf("\ntoolbars_set_presence: Called with object ID %p\n",(void *) o);
a356 2
  ChkError(toolbox_get_client_handle(0, o, (void *) &b));

d364 2
a365 5
  if (b->ancestor) b = b->ancestor;

  #ifdef TRACE
    if (tl & (1u<<1)) Printf("toolbars_set_presence: Browser data at %p\n",(void *) b);
  #endif
d383 1
a383 1
    t = toolbars_get_upper(b);
d429 1
a429 1
    t = toolbars_get_lower(b);
d812 1
a812 1
  browser_data    * ancestor;
a819 5
  /* Find the ancestor that the toolbars lie in */

  ancestor = b->ancestor;
  if (!ancestor) ancestor = b;

d1469 1
a1469 1
  browser_data    * ancestor;
a1476 3
  ancestor = b->ancestor;
  if (!ancestor) ancestor = b;

d1862 2
a1863 1
  browser_data   * ancestor;
a1864 1
  status_type      highest = Toolbars_Status_NoType;
a1868 3
  ancestor = b->ancestor;
  if (!ancestor) ancestor = b;

d1916 1
a1916 3
  browser_data    * ancestor = b->ancestor;

  if (!ancestor) ancestor = b;
d1994 1
a1994 1
  browser_data * ancestor = b->ancestor;
a1995 2

  if (!ancestor) ancestor = b;
@


1.2
log
@Altered dialler status reporting to be more efficient (only installs the null handler when it needs the online time)
@
text
@d2236 1
a2236 1
    if (!b->dialler_time)
d2238 9
a2246 1
      b->dialler_time = 1;
d2254 2
a2255 1
    if (b->dialler_time) deregister_null_claimant(Wimp_ENull, (WimpEventHandler *) handle_dialler_display, b);
@


1.1
log
@First commit to CVS, at version 1.16 (Customer build).
@
text
@d47 1
d2045 1
a2045 1
/* toolbars_update_dialler()                     */
d2052 4
d2060 1
a2060 1
_kernel_oserror * toolbars_update_dialler(browser_data * b)
d2065 95
a2160 1
  static int        last_called = 0;
a2196 8

    /* Setting last_called to -1 flags that a special message string is */
    /* being displayed, and starts the timer that counts down until the */
    /* Messages file configured time ('ShowDStatFor') has expired. At   */
    /* this point another display, e.g. online time, will be reverted   */
    /* to.                                                              */

    last_called = -1;
d2200 1
a2200 1
    status &= Dialler_GeneralInfoMask;
d2207 1
a2207 1
    switch (status)
d2209 10
a2218 10
      case Dialler_ExecutingScript_Dial:     lookup_token("Dialling",  0, 0); last_called = -1; break; /* Executing dialling script */
      case Dialler_ExecutingScript_Hangup:   lookup_token("Hangup",    0, 0); last_called = -1; break; /* Executing hangup script   */
      case Dialler_ExecutingScript_Answer:   lookup_token("Answering", 0, 0); last_called = -1; break; /* Answering                 */
      case Dialler_AbortedScript_Syntax:     lookup_token("SError",    0, 0); last_called = -1; break; /* Script syntax error       */
      case Dialler_AbortedScript_Timeout:    lookup_token("Timeout",   0, 0); last_called = -1; break; /* Timed out                 */
      case Dialler_AbortedScript_NoCarrier:  lookup_token("Carrier",   0, 0); last_called = -1; break; /* No carrier                */
      case Dialler_AbortedScript_Error:      lookup_token("MError",    0, 0); last_called = -1; break; /* 'ERROR' from modem        */
      case Dialler_AbortedScript_NoDialtone: lookup_token("Dialtone",  0, 0); last_called = -1; break; /* No dialtone               */
      case Dialler_AbortedScript_Busy:       lookup_token("MBusy",     0, 0); last_called = -1; break; /* 'BUSY' from modem         */
      case Dialler_AbortedScript_NoAnswer:   lookup_token("Answer",    0, 0); last_called = -1; break; /* No answer                 */
d2220 1
a2220 1
      /* If there's no specific special status, report the online time */
d2224 2
a2225 55
        e = _swix(Dialler_Status,
                  _IN(0) | _OUTR(0,1),

                  Dialler_Status_ConnectTime,

                  &status,
                  &start_time);

        /* If the dialler isn't present, don't want to end up */
        /* with a recursive error report, so fail silently.   */

        if (e) return NULL;

        _swix(OS_ReadMonotonicTime,
              _OUT(0),

              &time_now);

        /* May have to wait a while if an unusual status is being displayed, */
        /* flagged through last_called being non-zero.                       */

        if (!last_called || time_now - last_called > fixed.show_dstat_for)
        {
          /* If connected, must display an online time, else show offline. */

          if (status & Dialler_Connected)
          {
            int hours, minutes, seconds;

            last_called = 0;

            time_now -= start_time;

            if (time_now < 0) time_now = 0;

            hours     = time_now / 360000;
            time_now -= (hours * 360000);
            minutes   = time_now / 6000;
            time_now -= (minutes * 6000);
            seconds   = (time_now / (fixed.quantise * 100)) * fixed.quantise;

            if (hours > 99) hours = 99;

            *lasttokn = 0; /* Must do this or subsequent lookup_token calls could silently fail! */
            sprintf(tokens, "%02u:%02u:%02u\0", hours, minutes, seconds);

            showing_time = 1;
          }
          else lookup_token("Offline", 0, 0);
        }
        else
        {
          *lasttokn = 0; /* Must do this or subsequent lookup_token calls could silently fail! */
          strcpy(tokens, "!"); /* Force an exit if we don't want to display yet */
        }
d2231 4
a2234 4
  /* If last_called is < 0, one of the status conditions above     */
  /* was met. So want to read the monotonic time into last_called, */
  /* to allow this status message to be shown for some time before */
  /* any online time or offline message is displayed.              */
d2236 7
a2242 1
  if (last_called < 0)
d2244 1
a2244 3
    _swix(OS_ReadMonotonicTime, _OUT(0), &last_called);
    if (last_called == 0) last_called = 1; /* (...otherwise there'd be no delay!) */
  }
d2246 1
a2246 1
  /* Exit if the messages lookup appears to have failed. */
d2248 2
a2249 1
  if (!strcmp(tokens,"!")) return NULL;
d2251 1
a2251 2
  /* Copy the token contents to the display buffer and update the field */
  /* if the value has changed.                                          */
d2253 2
a2254 1
  StrNCpy0(display, tokens);
d2256 1
a2256 2
  e = displayfield_get_value(0, t, DiallerStatus, compare, sizeof(compare), NULL);
  if (e) return e;
d2258 5
a2262 6
  /* Update the display field if necessary, else exit */

  if (strcmp(display, compare))
  {
    e = displayfield_set_value(0, t, DiallerStatus, display);
    if (e) return e;
@

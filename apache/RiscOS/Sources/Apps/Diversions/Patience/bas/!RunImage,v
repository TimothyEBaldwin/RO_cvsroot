head	1.4;
access;
symbols
	Patience-0_76:1.4
	Patience-0_75:1.4
	Patience-0_74:1.3
	Patience-0_73:1.2
	Patience-0_72:1.1;
locks; strict;
comment	@# @;


1.4
date	2016.12.10.13.07.59;	author rool;	state Exp;
branches;
next	1.3;
commitid	4apbkFU5pc62grxz;

1.3
date	2014.11.22.10.41.19;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	qUWHfBBEC2PmwaZx;

1.2
date	2014.03.15.10.31.23;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	7q37W5a0iFsazMsx;

1.1
date	2014.03.15.10.25.37;	author rsprowson;	state Exp;
branches;
next	;
commitid	MncIc9JROecdxMsx;


desc
@@


1.4
log
@Style Guide compliance change
Detail:
  Changes made to Patience's main window storing to reflect Style Guide. Option is no longer in the Choices window, but accessed from the main menu. Choices dialogue and Messages file updated, and Help file edited to reflect change.
Admin:
  Submission from Chris Wraight.

Version 0.75. Tagged as 'Patience-0_75'
@
text
@REM >!Patience.!RunImage

REM Copyright 2014 Castle Technology Ltd
REM
REM Licensed under the Apache License, Version 2.0 (the "License");
REM you may not use this file except in compliance with the License.
REM You may obtain a copy of the License at
REM
REM     http://www.apache.org/licenses/LICENSE-2.0
REM
REM Unless required by applicable law or agreed to in writing, software
REM distributed under the License is distributed on an "AS IS" BASIS,
REM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
REM See the License for the specific language governing permissions and
REM limitations under the License.
REM

REM Authors: Acorn, CWraight


REM-----------------------------------------------------------------------------
REM // Initialise application and load resources //
REM-----------------------------------------------------------------------------

PROCmess_load("<Patience$Dir>.Messages")
PROCwimp_init
PROCgame_init

REM-----------------------------------------------------------------------------
REM // Poll loop //
REM-----------------------------------------------------------------------------

WHILE NOT AppQuit%
 PROCwimp_poll
ENDWHILE
SYS "Wimp_CloseDown"
PROCmess_close
END

REM-----------------------------------------------------------------------------
REM // Game //
REM-----------------------------------------------------------------------------

DEF PROCgame_init
LOCAL file%,flags%,command$,value$
REM Global variables
DIM CardSpace% 52                       :REM Array for use with pack
Deck$=STRING$(52," ")                   :REM Deck array
DeckPlace%=0                            :REM Location in Deck
DealNumber%=0                           :REM Number of cards dealt at once
DIM Table$(7)                           :REM Table columns
InPlay%=FALSE                           :REM Game is in play
Played%=0                               :REM Games played
Won%=0                                  :REM Games won
Source$=""                              :REM Source area of dragged card
Index%=0                                :REM Position of dragged card in column
DIM Suit%(3)                            :REM Suit Array
DIM Suit$(3)                            :REM Suit sprite names
Suit$(0)="club":Suit$(1)="diamond"      :REM Suit sprite names
Suit$(2)="heart":Suit$(3)="spade"       :REM Suit sprite names
Wx%=0                                   :REM Game window x origin
Wy%=0                                   :REM Game window y origin
TX%=8                                   :REM Table left edge
TY%=-66                                 :REM Table top edge
CW%=68                                  :REM Card width
CH%=88                                  :REM Card height
HH%=40                                  :REM Half card height
DX%=CW%*10                              :REM Deck coords
DY%=TY%-CH%*3                           :REM Deck coords
DP%=CW%*9                               :REM Pile coords
SX%=CW%*8                               :REM Stack coords
WorkX%=12*CW%+TX%*2                     :REM Work area width
WorkY%=18*HH%+CH%-TY%                   :REM Work area height
Option_WinX%=200                        :REM Option defaults
Option_WinY%=300                        :REM Option defaults
Option_ExtentX%=WorkX%                  :REM Option defaults
Option_ExtentY%=WorkY%                  :REM Option defaults
Option_OnlyKings%=TRUE                  :REM Option defaults
Option_RevCards%=FALSE                  :REM Options defaults
Option_NumberOver%=3                    :REM Options defaults
Option_Sound%=FALSE                     :REM Options defaults
REM Read user choices from script in Choices: (if present)
SYS "XOS_Find",%01001111,"Choices:Patience.Choices" TO file%;flags%
IF((flags% AND 1)=0) AND(file%<>0) THEN
 WHILE NOT EOF#file%
  command$=GET$#file%
  IF INSTR(command$,":") THEN
   value$=RIGHT$(command$,LEN(command$)-INSTR(command$,":"))
   command$=LEFT$(command$,INSTR(command$,":")-1)
   CASE command$ OF
    WHEN "RevCards":
     IF value$="Y" THEN Option_RevCards%=TRUE ELSE Option_RevCards%=FALSE
    WHEN "OnlyKings":
     IF value$="Y" THEN Option_OnlyKings%=TRUE ELSE Option_OnlyKings%=FALSE
    WHEN "NumberOver":
     Option_NumberOver%=VAL(value$)
    WHEN "Sound":
     IF value$="Y" THEN Option_Sound%=TRUE ELSE Option_Sound%=FALSE
   ENDCASE
  ENDIF
 ENDWHILE
 CLOSE#file%
ENDIF
REM Read window position, if stored
SYS "XOS_Find",%01001111,"Choices:Patience.WinPos" TO file%;flags%
IF((flags% AND 1)=0) AND (file%<>0) THEN
 WHILE NOT EOF#file%
  command$=GET$#file%
  IF INSTR(command$,":") THEN
   value$=RIGHT$(command$,LEN(command$)-INSTR(command$,":"))
   command$=LEFT$(command$,INSTR(command$,":")-1)
   CASE command$ OF
    WHEN "WinX":
     Option_WinX%=VAL(value$)
    WHEN "WinY":
     Option_WinY%=VAL(value$)
    WHEN "ExtentX":
     Option_ExtentX%=VAL(value$)
    WHEN "ExtentY":
     Option_ExtentY%=VAL(value$)
   ENDCASE
  ENDIF
 ENDWHILE
 CLOSE#file%
ENDIF
PROCgame_shuffle
ENDPROC

DEF PROCgame_shuffle
REM Shuffle the pack
LOCAL i%,j%,k%,n%
@@%=5
n%=RND(TIME OR &80000000)
Deck$="":k%=0
FOR i%=0 TO 3
 FOR j%=1 TO 13
  CardSpace%?k%=i%+j%*4
  k%=k%+1
 NEXT
NEXT
FOR i%=1 TO 52
 REPEAT:j%=RND(52)-1:UNTIL CardSpace%?j%
 Deck$+=CHR$(CardSpace%?j%+128)
 CardSpace%?j%=0
NEXT
FOR i%=1 TO 7
 Table$(i%)=LEFT$(Deck$,7-i%)
 Table$(i%)+=CHR$(ASCMID$(Deck$,8-i%) AND 127)
 Deck$=MID$(Deck$,9-i%)
NEXT
DeckPlace%=0:Table$=Deck$:Deck$=""
FOR i%=1 TO LEN(Table$)
 Deck$+=CHR$(ASCMID$(Table$,i%) AND 127)
NEXT
FOR i%=0 TO 3:Suit%(i%)=i%:NEXT
InPlay%=TRUE
DealNumber%=Option_NumberOver%
ENDPROC

DEF PROCgame_drawboard
REM Draw the main game board
LOCAL col%,more%,rx0%,rx1%,ry0%,ry1%,cmin%,cmax%,i%,j%
SYS "Wimp_RedrawWindow",,Block% TO more%
Wx%=Block%!4-Block%!20
Wy%=Block%!16-Block%!24
WHILE more%
 rx0%=Block%!28:rx1%=Block%!36
 ry0%=Block%!32:ry1%=Block%!40
 REM Draw background
 PROCwimp_pixtrans(SpriteArea%,"tile")
 FOR i%=rx0% TO rx1% STEP CW%
  FOR j%=ry0% TO ry1% STEP CH%
   PROCwimp_plotsprite(SpriteArea%,"tile",i%,j%,FALSE)
  NEXT
 NEXT
 REM Draw Table
 cmin%=(rx0%-(Wx%+TX%)) DIV CW%
 cmax%=(rx1%-(Wx%+TX%)) DIV CW%:IF cmax%>6 THEN cmax%=6
 IF cmin%<7 THEN
  FOR col%=cmin% TO cmax%
   PROCgame_drawcolumn(Table$(col%+1),Wx%+TX%+col%*CW%,Wy%+TY%,1)
  NEXT
 ENDIF
 REM Draw Stack
 cmin%=(rx0%-Wx%) DIV CW%-8:IF cmin%<0 THEN cmin%=0
 cmax%=(rx1%-Wx%) DIV CW%-8:IF cmax%>3 THEN cmax%=3
 IF cmax%>-1 THEN
  IF cmin%<4 THEN
   FOR col%=cmin% TO cmax%
    PROCgame_drawcard(0,Suit%(col%),Wx%+SX%+(col%*CW%),Wy%+TY%-CH%)
   NEXT
  ENDIF
 ENDIF
 REM Draw Deck
 PROCgame_drawdeck
 SYS "Wimp_GetRectangle",,Block% TO more%
ENDWHILE
ENDPROC

DEF PROCgame_drawdeck
REM Draw the Deck
IF LEN(Deck$) THEN
 IF DeckPlace%=LEN(Deck$) THEN
  PROCgame_drawnodeck(Wx%+DX%,Wy%+DY%)
 ELSE
  PROCgame_drawback(Wx%+DX%,Wy%+DY%)
 ENDIF
 IF DeckPlace%>0 THEN
  PROCgame_drawcard(0,ASCMID$(Deck$,DeckPlace%,1),Wx%+DP%,Wy%+DY%)
 ELSE
  PROCgame_drawnopile(Wx%+DP%,Wy%+DY%)
 ENDIF
ELSE
 PROCgame_drawnopile(Wx%+DP%,Wy%+DY%)
 PROCgame_drawnodeck(Wx%+DX%,Wy%+DY%)
ENDIF
ENDPROC

DEF PROCgame_drawcolumn (col$,x%,y%,start%)
REM Draw a column of cards
LOCAL i%,j%
IF LEN(col$)=0 OR start%>LEN(col$) THEN ENDPROC
IF LEN(col$)>1 THEN
 PROCwimp_pixtrans(SpriteArea%,"half")
 FOR i%=1 TO LEN(col$)-1
  IF i%>=start% THEN
   j%=ASCMID$(col$,i%)
   IF j%>127 THEN
    PROCwimp_plotsprite(SpriteArea%,"half",x%,y%-44,TRUE)
   ELSE
    PROCgame_drawcard(1,j%,x%,y%-44)
   ENDIF
  ENDIF
  y%-=HH%
 NEXT
ENDIF
y%-=CH%
j%=ASCMID$(col$,LEN(col$))
IF j%>127 THEN
 PROCgame_drawback(x%,y%)
ELSE
 PROCgame_drawcard(0,j%,x%,y%)
ENDIF
ENDPROC

DEF PROCgame_drawcard (type%,card%,x%,y%)
REM Draw a card
LOCAL sprite$
CASE type% OF
 WHEN 0:sprite$=Suit$(card% AND 3)
  IF (card%>>2)=0 THEN sprite$="s"+sprite$
 WHEN 1:sprite$="half"+Suit$(card% AND 3)
ENDCASE
PROCwimp_pixtrans(SpriteArea%,sprite$)
PROCwimp_plotsprite(SpriteArea%,sprite$,x%,y%,TRUE)
IF (card% EOR card%>>1) AND 1 THEN
 SYS SWI_FONTCOLOURS%,0,&FFFFFF00,&0000AA00,14
ELSE
 SYS SWI_FONTCOLOURS%,0,&FFFFFF00,&00000000,14
ENDIF
card%=card%>>2
IF type%=1 THEN y%-=44
SYS SWI_SETFONT%,Font%
IF (card%>1 AND card%<10) THEN SYS SWI_FONTPAINT%,Font%,STR$card%,16,x%+34,y%+54
IF card%=1 THEN SYS SWI_FONTPAINT%,Font%,"A",16,x%+32,y%+54
IF card%=10 THEN SYS SWI_FONTPAINT%,Font%,"10",16,x%+26,y%+54
IF card%=11 THEN SYS SWI_FONTPAINT%,Font%,"J",16,x%+34,y%+54
IF card%=12 THEN SYS SWI_FONTPAINT%,Font%,"Q",16,x%+30,y%+54
IF card%=13 THEN SYS SWI_FONTPAINT%,Font%,"K",16,x%+32,y%+54
ENDPROC

DEF PROCgame_drawdragcard (type%,card%,x%,y%,opaque%)
LOCAL i%,r0%,r1%,r2%,r3%,sprite$
REM Switch output to sprite and plot the card part
SYS SWI_SPRITE%,&13C,DragArea%,"drag",0 TO r0%,r1%,r2%,r3%
PROCgame_drawcard(type%,card%,x%,y%)
SYS SWI_SPRITE%,r0%,r1%,r2%,r3%
REM Choose the template from the suit
CASE type% OF
 WHEN 0:sprite$=Suit$(card% AND 3)
  IF (card%>>2)=0 THEN sprite$="s"+sprite$
 WHEN 1:sprite$="half"+Suit$(card% AND 3)
ENDCASE
REM Map all input colours to the mask opaque colour
FOR i%=0 TO 255
 PixTrans%?i%=opaque%
NEXT
REM Switch output to mask and plot the opaque pixels
SYS SWI_SPRITE%,&13D,DragArea%,"drag",0 TO r0%,r1%,r2%,r3%
PROCwimp_plotsprite(SpriteArea%,sprite$,x%,y%,TRUE)
SYS SWI_SPRITE%,r0%,r1%,r2%,r3%
ENDPROC

DEF PROCgame_drawback (x%,y%)
REM Draw a card back
PROCwimp_pixtrans(SpriteArea%,"back")
PROCwimp_plotsprite(SpriteArea%,"back",x%,y%,TRUE)
ENDPROC

DEF PROCgame_drawnodeck (x%,y%)
REM Draw the empty space where the Deck was
PROCwimp_pixtrans(SpriteArea%,"empty")
PROCwimp_plotsprite(SpriteArea%,"empty",x%,y%,FALSE)
ENDPROC

DEF PROCgame_drawnopile (x%,y%)
REM Draw the empty space where the Pile was
PROCwimp_pixtrans(SpriteArea%,"tile")
PROCwimp_plotsprite(SpriteArea%,"tile",x%,y%,FALSE)
ENDPROC

DEF PROCgame_nextcard
REM Turn the next card over from the Deck
LOCAL next$,more%,i%
IF LEN(Deck$)=0 THEN
 IF Option_Sound% THEN VDU 7
 ENDPROC
ENDIF
IF DeckPlace%=LEN(Deck$) THEN DeckPlace%=0
IF Option_RevCards% THEN
 next$=""
 FOR i%=DealNumber% TO 1 STEP-1
  next$+=MID$(Deck$,DeckPlace%+i%,1)
 NEXT
ELSE
 next$=MID$(Deck$,DeckPlace%+1,DealNumber%)
ENDIF
Deck$=LEFT$(Deck$,DeckPlace%)+next$+MID$(Deck$,DeckPlace%+DealNumber%+1)
DeckPlace%+=LEN(next$)
MID$(Deck$,DeckPlace%)=CHR$(ASCMID$(Deck$,DeckPlace%) AND 127)
more%=FNgamewin_update(DP%,DY%,DX%+CW%,DY%+CH%)
WHILE more%
 PROCgame_drawdeck
 SYS "Wimp_GetRectangle",,Block% TO more%
ENDWHILE
ENDPROC

DEF PROCgame_dragcard (source$,mx%,my%)
REM Start a card drag
LOCAL col%,height%,i%,x0%,y0%,x1%,y1%,mx%,my%,newmem%,oldmem%,val%,ncolour%
Block%!0=GameWin%
SYS "Wimp_GetWindowState",,Block%
x0%=Block%!4:y0%=Block%!8
x1%=Block%!12:y1%=Block%!16
SYS "Wimp_GetPointerInfo",,Block%
mx%=Block%!0:my%=Block%!4
IF FNgame_dragcheck(source$)=FALSE THEN
 SYS "OS_Byte",161,28 TO ,,val%
 SolidDrag%=(val% AND (1<<1))<>0
 IF SolidDrag% THEN
  REM Estimate space for biggest possible DragASprite sprite
  SYS "OS_ReadModeVariable",-1,3 TO ,,ncolour%
  CASE ncolour% OF
   WHEN 1,3,15,63,255:
    dragsize%=(((((12*HH%)+CH%)*CW%)*16)/8)+2048:REM 8bpp+8bpp mask, with palette
   OTHERWISE
    dragsize%=(((((12*HH%)+CH%)*CW%)*33)/8):REM 32bpp+1bpp mask, no palette
  ENDCASE
  dragsize%=dragsize%+16+44:REM Sprite area and sprite header
  dragsize%=(dragsize%+4095) AND NOT 4095:REM Page round up
  SYS"Wimp_SlotSize",-1,-1 TO oldmem%
  SYS"Wimp_SlotSize",oldmem%+dragsize%,-1 TO newmem%
  IF (newmem%-oldmem%) < dragsize% THEN
   REM Not enough memory to solid drag
   SYS"Wimp_SlotSize",oldmem%,-1
   SolidDrag%=FALSE
  ELSE
   REM Build the sprite up there
   DragArea%=HIMEM
  ENDIF
 ENDIF
 IF SolidDrag% THEN
  !DragArea%=dragsize%:DragArea%!8=16
  SYS SWI_SPRITE%,&109,DragArea%
  CASE source$ OF
   WHEN "P":
    PROCgame_makesprite(0,CW%,CH%)
    Block%!0=mx%-CW% DIV 2
    Block%!4=my%+CH% DIV 2
    Block%!8=mx%+CW% DIV 2
    Block%!12=my%-CH% DIV 2
   OTHERWISE:
    col%=(ASCsource$-64)-1
    height%=CH%
    IF Index%<LEN(Table$(col%+1)) THEN
     FOR i%=Index% TO LEN(Table$(col%+1))-1
      height%+=HH%
     NEXT
    ENDIF
    PROCgame_makesprite(col%+1,CW%,height%)
    Block%!0=mx%-CW% DIV 2
    Block%!4=my%+CH% DIV 2
    Block%!8=mx%+CW% DIV 2
    Block%!12=my%-(height%-CH% DIV 2)
  ENDCASE
  SYS "DragASprite_Start",80,DragArea%,"drag",Block%
  SYS SWI_SPRITE%,&119,DragArea%,"drag"
  REM Return memory as DragASprite takes a copy of sprite
  SYS"Wimp_SlotSize",oldmem%,-1
 ELSE
  Block%!0=0
  Block%!4=5
  CASE source$ OF
   WHEN "P":
    Block%!8=mx%-CW% DIV 2
    Block%!12=my%+CH% DIV 2
    Block%!16=mx%+CW% DIV 2
    Block%!20=my%-CH% DIV 2
   OTHERWISE:
    col%=(ASCsource$-64)-1
    height%=CH%
    IF Index%<LEN(Table$(col%+1)) THEN
     FOR i%=Index% TO LEN(Table$(col%+1))-1
      height%+=HH%
     NEXT
    ENDIF
    Block%!8=mx%-CW% DIV 2
    Block%!12=my%+CH% DIV 2
    Block%!16=mx%+CW% DIV 2
    Block%!20=my%-(height%-CH% DIV 2)
  ENDCASE
  Block%!24=x0%
  Block%!28=y0%
  Block%!32=x1%
  Block%!36=y1%
  SYS "Wimp_DragBox",,Block%
 ENDIF
ENDIF
ENDPROC

DEF PROC game_makesprite (c%,width%,height%)
REM Builds a sprite to be dragged
LOCAL xeig%,yeig%,mode%,r0%,r1%,r2%,r3%,ncolour%,opaque%,paletted%
LOCAL i%,j%
REM Get Mode info
SYS "OS_ReadModeVariable",-1,3 TO ,,ncolour%
SYS "OS_ReadModeVariable",-1,4 TO ,,xeig%
SYS "OS_ReadModeVariable",-1,5 TO ,,yeig%
CASE ncolour% OF
 WHEN 1,3,15,63,255:
  REM Generate 8bpp in all these cases, prefer old mode numbers
  opaque%=255:bpp%=8:paletted%=TRUE
  CASE yeig%+(xeig%<<4) OF
   WHEN &12: mode%=15
   WHEN &22: mode%=13
   WHEN &11: mode%=28
   OTHERWISE:mode%=(4<<27)+((180>>yeig%)<<14)+((180>>xeig%)<<1)+(1<<0):opaque%=1
  ENDCASE
 OTHERWISE:
  REM New sprite type with lots of colours
  mode%=(6<<27)+((180>>yeig%)<<14)+((180>>xeig%)<<1)+(1<<0):opaque%=1
ENDCASE
REM Create a sprite, give it a mask
SYS SWI_SPRITE%,&10F,DragArea%,"drag",0,width% >> xeig%,height% >> yeig%,mode%
SYS SWI_SPRITE%,&11D,DragArea%,"drag"
IF paletted% THEN SYS SWI_SPRITE%,&125,DragArea%,"drag",1
REM Start with an entirely transparent mask
SYS SWI_SPRITE%,&13D,DragArea%,"drag",0 TO r0%,r1%,r2%,r3%
SYS "OS_SetColour",1<<4,0:CLG
SYS SWI_SPRITE%,r0%,r1%,r2%,r3%
REM Plot card sprites
CASE c% OF
 WHEN 0:
  PROCgame_drawdragcard(0,ASCMID$(Deck$,DeckPlace%,1),0,0,opaque%)
 OTHERWISE:
  j%=height%
  IF Index%<LEN(Table$(c%)) THEN
   FOR i%=Index% TO LEN(Table$(c%))-1
    PROCgame_drawdragcard(1,ASCMID$(Table$(c%),i%),0,j%-44,opaque%)
    j%-=HH%
   NEXT
  ENDIF
  j%-=CH%
  PROCgame_drawdragcard(0,ASCMID$(Table$(c%),LEN(Table$(c%))),0,j%,opaque%)
ENDCASE
ENDPROC

DEF FNgame_dragcheck (type$)
REM Check to see if a drag is legal
Source$=type$
IF type$="P" THEN
 IF DeckPlace%=0 OR LEN(Deck$)=0 THEN
  IF Option_Sound% THEN VDU 7
  =TRUE
 ENDIF
ENDIF
IF type$<>"P" THEN
 IF LEN(Table$(ASCtype$-64))=0 THEN
  IF Option_Sound% THEN VDU 7
  =TRUE
 ENDIF
ENDIF
=FALSE

DEF PROCgame_dropcard (x%,y%)
REM Handle completed drags
x%=x%-Wx%:y%=y%-Wy%
IF x%>SX% AND x%<SX%+(CW%*4) AND y%>TY%-CH% AND y%<TY% THEN
 PROCgame_move("S")
ENDIF
IF x%>TX% AND x%<TX%+CW%*7 AND y%<TY% THEN
 PROCgame_move(CHR$((x%-TX%) DIV CW%+ASC"A"))
ENDIF
ENDPROC

DEF PROCgame_move (area$)
REM Move a card from one area to another
LOCAL card%,suit%,scol%,tcol%,tsuit%,len%,i%
IF Source$<>"P" THEN scol%=ASCSource$-64
tcol%=ASCarea$
IF tcol%=ASC"S" THEN
 REM Card has been dragged to the Stack
 IF Source$="P" THEN
  card%=ASCMID$(Deck$,DeckPlace%)
 ELSE
  card%=ASCMID$(Table$(scol%),LEN(Table$(scol%)))
 ENDIF
 suit%=card% AND 3
 IF card%<>Suit%(suit%)+4 THEN
  IF Option_Sound% THEN VDU 7
  ENDPROC
 ENDIF
 Suit%(suit%)=card%
 IF Source$="P" THEN
  PROCgame_removepile
 ELSE
  PROCgame_removetable(scol%,1)
 ENDIF
 PROCgame_addstack(suit%)
ELSE
 REM Card has been dragged to the Table
 IF tcol%<ASC"A" OR tcol%>ASC"G" THEN
  IF Option_Sound% THEN VDU 7
  ENDPROC
 ENDIF
 tsuit%=ASCRIGHT$(Table$(tcol%-64),1)
 len%=LEN(Table$(tcol%-64))
 IF Source$="P" THEN
  card%=ASCMID$(Deck$,DeckPlace%)
  IF FNgame_movecheck(card%,tsuit%)=0 THEN
   IF Option_Sound% THEN VDU 7
   ENDPROC
  ENDIF
  Table$(tcol%-64)+=CHR$card%
  PROCgame_removepile
 ELSE
  i%=0
  REPEAT
   i%+=1:card%=ASCMID$(Table$(scol%),i%)
  UNTIL FNgame_movecheck(card%,tsuit%) OR i%>LEN(Table$(scol%))
  IF i%>LEN(Table$(scol%)) THEN
   IF Option_Sound% THEN VDU 7
   ENDPROC
  ENDIF
  Table$(tcol%-64)+=MID$(Table$(scol%),i%)
  PROCgame_removetable(scol%,LEN(Table$(scol%))-i%+1)
 ENDIF
 PROCgame_addtable(tcol%,len%)
ENDIF
ENDPROC

DEF PROCgame_removepile
REM Remove a card from the Pile
LOCAL more%
DeckPlace%-=1
Deck$=LEFT$(Deck$,DeckPlace%)+MID$(Deck$,DeckPlace%+2)
PROCwimp_seticontext(ToolWin%,1,STR$LEN(Deck$)+FNmess_get("Left"))
more%=FNgamewin_update(DP%,DY%,DP%+CW%,DY%+CH%)
WHILE more%
 PROCgame_drawdeck
 SYS "Wimp_GetRectangle",,Block% TO more%
ENDWHILE
ENDPROC

DEF PROCgame_removetable (c%,cards%)
REM Move card(s) from a column on the Table
LOCAL oldlen%,newlen%,bottom%,top%,cx%,more%
oldlen%=LEN(Table$(c%))
newlen%=oldlen%-cards%
cx%=TX%+(c%-1)*CW%
Table$(c%)=LEFT$(Table$(c%),newlen%)
IF LEN(Table$(c%)) THEN Table$(c%)=LEFT$(Table$(c%),LEN(Table$(c%))-1)+CHR$(ASCRIGHT$(Table$(c%),1) AND 127)
more%=FNgamewin_update(cx%,TY%-(oldlen%*HH%)-CH%,cx%+CW%,TY%)
WHILE more%
 bottom%=Block%!32
 top%=Block%!32+HH%*(cards%+2)
 PROCwimp_pixtrans(SpriteArea%,"tile")
 REPEAT
  PROCwimp_plotsprite(SpriteArea%,"tile",Wx%+cx%,bottom%,FALSE)
  bottom%+=CH%
 UNTIL bottom%>top%
 IF newlen%>0 THEN PROCgame_drawcolumn(Table$(c%),Wx%+cx%,Wy%+TY%,newlen%-1)
 SYS "Wimp_GetRectangle",,Block% TO more%
 ENDWHILE
ENDPROC

DEF PROCgame_addstack (suit%)
REM Add a card to the Stack
LOCAL more%
more%=FNgamewin_update(SX%+(suit%*CW%),TY%-CH%,SX%+(suit%*CW%)+CW%,TY%)
WHILE more%
 PROCgame_drawcard(0,Suit%(suit%),Wx%+SX%+(suit%*CW%),Wy%+TY%-CH%)
 SYS "Wimp_GetRectangle",,Block% TO more%
ENDWHILE
ENDPROC

DEF PROCgame_addtable (tcol%,len%)
REM Add card(s) to a Table column
LOCAL more%
more%=FNgamewin_update(TX%+(tcol%-ASC"A")*CW%,TY%-(LEN(Table$(tcol%-64))*HH%)-CH%,TX%+(tcol%-64)*CW%,-len%*HH%)
WHILE more%
 PROCgame_drawcolumn(Table$(tcol%-64),Wx%+TX%+(tcol%-65)*CW%,Wy%+TY%,len%)
 SYS "Wimp_GetRectangle",,Block% TO more%
ENDWHILE
ENDPROC

DEF FNgame_movecheck (card%,tsuit%)
REM Check to see if a card can be moved
LOCAL s%
IF tsuit%=-1 THEN
 IF Option_OnlyKings% THEN =card% DIV 4=13 ELSE =card%<127
ENDIF
s%=(tsuit% EOR card%) AND 3
IF s%=0 OR s%=3 THEN =FALSE
=tsuit% DIV 4=card% DIV 4+1

DEF PROCgame_resign
REM Resign a game
LOCAL i%,j%
FOR i%=1 TO 7
 FOR j%=1 TO LEN(Table$(i%))
  MID$(Table$(i%),j%,1)=CHR$(ASCMID$(Table$(i%),j%,1) AND 127)
 NEXT
NEXT
InPlay%=FALSE:DealNumber%=1
SYS "Wimp_ForceRedraw",GameWin%,0,-WorkY%,WorkX%,0
ENDPROC

DEF PROCgame_newgame
REM Start a new game
LOCAL won%,i%,j%
won%=TRUE
FOR i%=1 TO 7
 IF LEN(Table$(i%)) THEN
  FOR j%=1 TO LEN(Table$(i%))
   IF ASCMID$(Table$(i%),j%)>127 THEN won%=FALSE
  NEXT
 ENDIF
NEXT
Played%+=1
IF Deck$="" AND won%=TRUE THEN Won%+=1
PROCgame_shuffle
PROCwimp_seticontext(ToolWin%,0,FNmess_get("Won")+STR$Won%+"/"+STR$Played%)
PROCwimp_seticontext(ToolWin%,1,STR$LEN(Deck$)+FNmess_get("Left"))
SYS "Wimp_ForceRedraw",GameWin%,0,-WorkY%,WorkX%,0
ENDPROC

REM-----------------------------------------------------------------------------
REM // GameWin //
REM-----------------------------------------------------------------------------

DEF PROCgamewin_init
REM Resize and initialise the Game window
Block%!0=0
Block%!4=-WorkY%
Block%!8=WorkX%
Block%!12=0
SYS "Wimp_SetExtent",GameWin%,Block%
SYS "Wimp_ResizeIcon",ToolWin%,1,WorkX%-252,-52,WorkX%,0
PROCwimp_seticontext(ToolWin%,0,FNmess_get("Won")+STR$Won%+"/"+STR$Played%)
PROCwimp_seticontext(ToolWin%,1,STR$LEN(Deck$)+FNmess_get("Left"))
ENDPROC

DEF PROCgamewin_click (x%,y%,button%)
REM Handle clicks in the game window
LOCAL mx%,my%,c$,col%,min%,hlen%
SYS "Wimp_SetCaretPosition",GameWin%,-1,0,0,1<<25
Block%!0=GameWin%
SYS "Wimp_GetWindowState",,Block%
mx%=x%-(Block%!4-Block%!20)
my%=y%-(Block%!16-Block%!24)
CASE button% OF
 WHEN MENU%:
  SYS "Wimp_GetPointerInfo",,Block%
  SYS "Wimp_CreateMenu",,MainMenu%,Block%!0-64,Block%!4
  MenuOpen%=MainMenu%
 WHEN SELECT%:
  IF mx%>=DX% AND mx%<=DX%+CW%-6 AND my%>DY% AND my%<DY%+CH% THEN
   PROCgame_nextcard
  ENDIF
  IF InPlay% THEN
   IF mx%>=DP% AND mx%<=DP%+CW%-6 AND my%>DY% AND my%<DY%+CH% THEN
    PROCgame_dragcard("P",x%,y%)
   ENDIF
   IF mx%>=TX% AND mx%<TX%+CW%*7 AND my%<TY% THEN
    col%=(mx%-TX%) DIV CW%
    hlen%=0
    IF LEN(Table$(col%+1))>1 THEN hlen%=HH%*(LEN(Table$(col%+1))-1)
    IF my%>TY%-hlen% THEN Index%=(-(my%-TY%) DIV HH%)+1
    IF my%<TY%-hlen% AND my%>TY%-hlen%-CH% THEN Index%=LEN(Table$(col%+1))
    min%=0
    REPEAT
     min%+=1
    UNTIL ASCMID$(Table$(col%+1),min%)<128
    IF Index%>=min% AND Index%<=LEN(Table$(col%+1)) THEN
     PROCgame_dragcard(CHR$((mx%-TX%) DIV CW%+ASC"A"),x%,y%)
    ENDIF
   ENDIF
  ENDIF
 WHEN ADJUST%:
  IF InPlay% THEN
   IF mx%>DP% AND mx%<DP%+CW% AND my%>DY% AND my%<DY%+CH% THEN
    IF NOT FNgame_dragcheck("P") THEN PROCgame_move("S")
   ENDIF
   IF mx%>TX% AND mx%<TX%+CW%*7 THEN
    c$=CHR$((mx%-TX%) DIV CW%+ASC"A")
    IF NOT FNgame_dragcheck(c$) THEN PROCgame_move("S")
   ENDIF
  ENDIF
ENDCASE
ENDPROC

DEF PROCgamewin_keypress (key%)
REM Handle keypresses in the main window
CASE key% OF
 WHEN &181:OSCLI "Filer_Run <Patience$Dir>.!Help"
 WHEN &182:PROCgame_newgame
 WHEN &1A2:Block%!0=GameWin%:SYS"Wimp_CloseWindow",,Block%
 WHEN &1B:PROCgame_resign
 OTHERWISE:SYS "Wimp_ProcessKey",key%
ENDCASE
ENDPROC

DEF FNgamewin_update (xmin%,ymin%,xmax%,ymax%)
REM Mark an area of the main window for redraw
!Block%=GameWin%
Block%!4=xmin%:Block%!8=ymin%
Block%!12=xmax%:Block%!16=ymax%
SYS "Wimp_UpdateWindow",,Block% TO more%
Wx%=Block%!4-Block%!20:Wy%=Block%!16-Block%!24
=more%

DEF PROCgamewin_store
REM Stores the position of the game window
LOCAL obj%,file%
SYS "XOS_File",17,"Choices:Patience" TO obj%
IF obj%=0 THEN SYS "XOS_File",8,"<Choices$Write>.Patience"
file%=OPENOUT "<Choices$Write>.Patience.WinPos"
Block%!0=GameWin%
SYS "Wimp_GetWindowState",,Block%
BPUT#file%,"WinX:"+STR$(Block%!4)
BPUT#file%,"WinY:"+STR$(Block%!8)
BPUT#file%,"ExtentX:"+STR$(Block%!12-Block%!4)
BPUT#file%,"ExtentY:"+STR$(Block%!16-Block%!8)
CLOSE#file%
ENDPROC

REM-----------------------------------------------------------------------------
REM // Choicewin //
REM-----------------------------------------------------------------------------

DEF PROCchoicewin_init (xmouse%)
REM Initialise and open Choices window
PROCwimp_selecticon(ChoiceWin%,4,Option_OnlyKings%)
PROCwimp_selecticon(ChoiceWin%,5,Option_RevCards%)
PROCwimp_selecticon(ChoiceWin%,7,Option_Sound%)
CASE Option_NumberOver% OF
 WHEN 3:PROCwimp_selecticon(ChoiceWin%,9,TRUE)
  PROCwimp_selecticon(ChoiceWin%,10,FALSE)
 WHEN 1:PROCwimp_selecticon(ChoiceWin%,9,FALSE)
  PROCwimp_selecticon(ChoiceWin%,10,TRUE)
ENDCASE
PROCwimp_openwindow(ChoiceWin%,xmouse%-220,140,xmouse%-220+594,140+540)
SYS "Wimp_SetCaretPosition",ChoiceWin%,-1,0,0,1<<25
ENDPROC

DEF PROCchoicewin_click (icon%,button%)
REM Handle Select clicks in Choices window
LOCAL obj%,file%,write$
SYS "Wimp_SetCaretPosition",ChoiceWin%,-1,0,0,1<<25
IF button%=MENU% THEN ENDPROC
CASE icon% OF
 WHEN 1:
  IF button%=SELECT% THEN
   Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
  ENDIF
 WHEN 0:
  Option_OnlyKings%=FNwimp_getselect(ChoiceWin%,4)
  Option_RevCards%=FNwimp_getselect(ChoiceWin%,5)
  Option_Sound%=FNwimp_getselect(ChoiceWin%,7)
  IF FNwimp_getselect(ChoiceWin%,9) THEN
   Option_NumberOver%=3
  ELSE
   Option_NumberOver%=1
  ENDIF
  SYS "XOS_File",17,"Choices:Patience" TO obj%
  IF obj%=0 THEN SYS "XOS_File",8,"<Choices$Write>.Patience"
  file%=OPENOUT "<Choices$Write>.Patience.Choices"
   IF Option_RevCards%=FALSE THEN write$="RevCards:N" ELSE write$="RevCards:Y"
   BPUT#file%,write$
   IF Option_OnlyKings%=FALSE THEN write$="OnlyKings:N" ELSE write$="OnlyKings:Y"
   BPUT#file%,write$
   IF Option_Sound%=FALSE THEN write$="Sound:N" ELSE write$="Sound:Y"
   BPUT#file%,write$
   BPUT#file%,"NumberOver:"+STR$Option_NumberOver%
  CLOSE#file%
  IF button%=SELECT% THEN Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
ENDCASE
ENDPROC

DEF PROCchoicewin_keypress (key%)
REM Handle keypresses in Choices window
CASE key% OF
 WHEN &D:PROCchoicewin_click(0,SELECT%):REM OK
 WHEN &1B,&1A2:PROCchoicewin_click(1,SELECT%):REM Cancel
 OTHERWISE:SYS "Wimp_ProcessKey",key%
ENDCASE
ENDPROC

REM-----------------------------------------------------------------------------
REM // Iconbar //
REM-----------------------------------------------------------------------------

DEF PROCiconbar_click (button%)
REM Handle clicks on the iconbar icon
CASE button% OF
 WHEN MENU%:
  SYS "Wimp_GetPointerInfo",,Block%
  SYS "Wimp_CreateMenu",,IconMenu%,!Block%-64,(4*44)+96
  MenuOpen%=IconMenu%
 WHEN SELECT%,ADJUST%:
  IF FirstOpen%=TRUE THEN
   PROCgamewin_init
   PROCwimp_openwindow(GameWin%,Option_WinX%,Option_WinY%,Option_WinX%+Option_ExtentX%,Option_WinY%+Option_ExtentY%)
   SYS "Wimp_SetCaretPosition",GameWin%,-1,0,0,1<<25
   FirstOpen%=FALSE
  ELSE
   PROCwimp_openwindow(GameWin%,-1,-1,-1,-1)
   SYS "Wimp_SetCaretPosition",GameWin%,-1,0,0,1<<25
  ENDIF
ENDCASE
ENDPROC

REM-----------------------------------------------------------------------------
REM // Wimp //
REM-----------------------------------------------------------------------------

DEF PROCwimp_init
REM Load Resources and initialise app
DIM Block% 255                         :REM General purpose buffer
DIM MessText% 255                      :REM Messages buffer
DIM ErrorBlock% 255                    :REM Error buffer
AppQuit%=FALSE                         :REM Quit flag
AppHandle%=0                           :REM Application handle
IconHandle%=0                          :REM Iconbar handle
DIM WindowName% 12                     :REM Buffer for Window title
DIM Factors% 15,PixTrans% 255          :REM Sprite plotting data
MenuOpen%=0                            :REM Open menu handle
FirstOpen%=TRUE                        :REM Flag for first opening of window
Font%=0                                :REM Font handle
MESSAGE_QUIT%=&0                       :REM Message constants
MESSAGE_SAVEDESKTOP%=&A                :REM Message constants
MESSAGE_MODECHANGE%=&400C1             :REM Message constants
MESSAGE_HELPREQUEST%=&502              :REM Message constants
MESSAGE_HELPREPLY%=&503                :REM Message constants
SWI_SPRITE%=&2E                        :REM SWI OS_SpriteOp
SWI_PIXTRANS%=&400ED                   :REM SWI Wimp_ReadPixTrans
SWI_GENTABLE%=&40763                   :REM SWI ColourTrans_GenerateTable
SWI_FONTCOLOURS%=&4074F                :REM SWI ColourTrans_SetFontColours
SWI_FONTPAINT%=&40086                  :REM SWI Font_Paint
SWI_SETFONT%=&4008A                    :REM SWI Font_SetFont
SELECT%=4                              :REM Mouse button constants
MENU%=2                                :REM Mouse button constants
ADJUST%=1                              :REM Mouse button constants
Iconbar%=-2                            :REM Iconbar icon handle
SolidDrag%=FALSE                       :REM CMOS Solid-drag bit set/clear
Block%!0=MESSAGE_SAVEDESKTOP%
Block%!4=MESSAGE_MODECHANGE%
Block%!8=MESSAGE_HELPREQUEST%
Block%!12=MESSAGE_HELPREPLY%
Block%!16=0
SYS "Wimp_Initialise",380,&4B534154,FNmess_get("_TaskName"),Block% TO,AppHandle%
SYS "OS_Byte",129,0,&FF TO,OSVersion%
ON ERROR PROCwimp_error
!Block%=-1:Block%!4=0:Block%!8=0:Block%!12=68:Block%!16=68
Block%!20=%11000000000010:$(Block%+24)="!"+FNmess_get("_TaskName")
SYS "Wimp_CreateIcon",,Block% TO IconHandle%
PROCwimp_sprites
WindowArea%=FNwimp_opentemplates("<Patience$Dir>.Templates")
InfoWin%=FNwimp_loadtemplate("Info",WindowArea%)
GameWin%=FNwimp_loadtemplate("Game",WindowArea%)
ChoiceWin%=FNwimp_loadtemplate("Choices",WindowArea%)
ToolWin%=FNwimp_loadtemplate("Toolbar",WindowArea%)
PROCwimp_menus
SYS "Font_FindFont",,"Homerton.Medium",12*16,12*16,0,0 TO Font%
PROCwimp_seticontext(InfoWin%,4,FNmess_get("_Version"))
ENDPROC

DEF FNwimp_opentemplates (path$)
REM Opens a Template file and creates buffer for total indirected data
LOCAL size%,largest%,next%,indarea%,indsize%,totalindsize%
SYS "Wimp_OpenTemplate",,path$
largest%=0:totalindsize%=0
$WindowName%="*"
SYS "Wimp_LoadTemplate",,0,,,,WindowName%,0 TO ,size%,indsize%,,,,next%
IF size%>largest% THEN largest%=size%
IF indsize%>0 THEN totalindsize%=totalindsize%+indsize%
WHILE next%<>0
 $WindowName%="*"
 SYS "Wimp_LoadTemplate",,0,,,,WindowName%,next% TO ,size%,indsize%,,,,next%
 IF next%<>0 THEN
  IF size%>largest% THEN largest%=size%
  IF indsize%>0 THEN totalindsize%=totalindsize%+indsize%
 ENDIF
ENDWHILE
DIM indarea% totalindsize%+16
DIM WindowBlock% largest%+16
WindowIndPtr%=indarea%
=indarea%

DEF FNwimp_loadtemplate (name$,indarea%)
REM Loads a window definition from a Template file
LOCAL indsize%
$WindowName%=name$
SYS "Wimp_LoadTemplate",,0,,,,WindowName% TO ,,indsize%
SYS "Wimp_LoadTemplate",,WindowBlock%,WindowIndPtr%,WindowIndPtr%+indsize%,-1,WindowName% TO ,,WindowIndPtr%
WindowBlock%!64=SpriteArea%
SYS "Wimp_CreateWindow",,WindowBlock% TO window%
=window%

DEF PROCwimp_sprites
REM Load application sprites
LOCAL spritefile%,spritesize%,spritepath$,dragsize%,pix%
REM Load best sprite file for mode into Sprite Area
SYS "Wimp_ReadSysInfo",2 TO pix%
spritepath$="<Patience$Dir>.Sprites"+CHR$?pix%+CHR$pix%?1
spritefile%=OPENIN spritepath$
IF spritefile%=0 THEN spritepath$="<Patience$Dir>.Sprites":spritefile%=OPENIN spritepath$
spritesize%=EXT#spritefile%+16:CLOSE#spritefile%
DIM SpriteArea% spritesize%
!SpriteArea%=spritesize%:SpriteArea%!8=16
SYS SWI_SPRITE%,&109,SpriteArea%
SYS SWI_SPRITE%,&10A,SpriteArea%,spritepath$
END=END+&8000:REM Give back unused sprite memory
ENDPROC

DEF PROCwimp_menus
REM Create menus
IconMenu%=FNwimp_makemenu(FNmess_get("_TaskName"),4)
PROCwimp_additem(IconMenu%,0,0,InfoWin%,FNmess_get("Info"))
PROCwimp_additem(IconMenu%,1,0,-1,FNmess_get("HelpIcon"))
PROCwimp_additem(IconMenu%,2,0,-1,FNmess_get("Choices"))
PROCwimp_additem(IconMenu%,3,128,-1,FNmess_get("Quit"))
MainMenu%=FNwimp_makemenu(FNmess_get("_TaskName"),4)
PROCwimp_additem(MainMenu%,0,0,-1,FNmess_get("DealHand"))
PROCwimp_additem(MainMenu%,1,2,-1,FNmess_get("Resign"))
PROCwimp_additem(MainMenu%,2,2,-1,FNmess_get("Remember"))
PROCwimp_additem(MainMenu%,3,128,-1,FNmess_get("Help"))
ENDPROC

DEF FNwimp_makemenu (title$,items%)
REM Create a menu
LOCAL buffer%,tbuffer%
DIM buffer% 28+(24*items%)
IF LEN(title$)>12 THEN
 DIM tbuffer% LEN(title$)+1
 buffer%!0=tbuffer%
 buffer%!4=0
 buffer%!8=LEN(title$)+1
 $(tbuffer%)=title$
ELSE
 $(buffer%)=title$
ENDIF
buffer%!12=&00070207
buffer%!16=80
buffer%!20=44
buffer%!24=0
=buffer%

DEF PROCwimp_additem (menu%,item%,flags%,link%,text$)
REM Add a menu item
LOCAL buffer%
menu%!(28+(item%*24))=flags%
menu%!(28+(item%*24)+4)=link%
IF LEN(text$)>12 THEN
 DIM buffer% LEN(text$)+1
 menu%!(28+(item%*24)+8)=&07000121
 menu%!(28+(item%*24)+12)=buffer%
 menu%!(28+(item%*24)+16)=0
 menu%!(28+(item%*24)+20)=LEN(text$)+1
 $(buffer%)=text$
ELSE
 menu%!(28+(item%*24)+8)=&07000021
 $(menu%+28+(item%*24)+12)=text$
ENDIF
ENDPROC

DEF PROCwimp_poll
REM Respond to Wimp events
LOCAL reason%
SYS "Wimp_Poll",1,Block% TO reason%
CASE reason% OF
 WHEN 1:PROCgame_drawboard
 WHEN 2:SYS "Wimp_OpenWindow",,Block%
 WHEN 3:SYS "Wimp_CloseWindow",,Block%
 WHEN 6:PROCwimp_click(Block%!0,Block%!4,Block%!8,Block%!12,Block%!16)
 WHEN 7:PROCwimp_dragbox
 WHEN 8:PROCwimp_keypress(Block%!0,Block%!24)
 WHEN 9:PROCwimp_menuselect(Block%)
 WHEN 17,18:PROCwimp_messages(Block%)
ENDCASE
ENDPROC

DEF PROCwimp_click (x%,y%,button%,window%,icon%)
REM Handle mouse clicks
CASE window% OF
 WHEN GameWin%:PROCgamewin_click(x%,y%,button%)
 WHEN Iconbar%:PROCiconbar_click(button%)
 WHEN ChoiceWin%:PROCchoicewin_click(icon%,button%)
ENDCASE
ENDPROC

DEF PROCwimp_dragbox
REM Handle drags ending in the main window
SYS "Wimp_GetPointerInfo",,Block%
x%=Block%!0:y%=Block%!4:window%=Block%!12
IF window%=GameWin% THEN
 IF SolidDrag% THEN
  SYS "DragASprite_Stop"
 ELSE
  SYS "Wimp_DragBox",,-1
 ENDIF
 Block%!0=GameWin%
 SYS "Wimp_GetWindowState",,Block%
 Wx%=Block%!4-Block%!20:Wy%=Block%!16-Block%!24
 PROCgame_dropcard(x%,y%)
ENDIF
ENDPROC

DEF PROCwimp_keypress (window%,key%)
REM Handle keypresses
CASE window% OF
 WHEN GameWin%:PROCgamewin_keypress(key%)
 WHEN ChoiceWin%:PROCchoicewin_keypress(key%)
ENDCASE
ENDPROC

DEF PROCwimp_menuselect (menus%)
REM Handle menu selections
SYS "Wimp_DecodeMenu",,MenuOpen%,Block%,ErrorBlock%
SYS "Wimp_GetPointerInfo",,Block%
CASE MenuOpen% OF
 WHEN MainMenu%
  CASE $(ErrorBlock%) OF
   WHEN FNmess_get("Resign"):PROCgame_resign
   WHEN FNmess_get("DealHand"):PROCgame_newgame
   WHEN FNmess_get("Remember"):PROCgamewin_store
   WHEN FNmess_get("Help"):OSCLI "Filer_Run <Patience$Dir>.!Help"
  ENDCASE
 WHEN IconMenu%:
  CASE $(ErrorBlock%) OF
   WHEN FNmess_get("HelpIcon"):OSCLI "Filer_Run <Patience$Dir>.!Help"
   WHEN FNmess_get("Choices"):PROCchoicewin_init(Block%!0)
   WHEN FNmess_get("Quit"):AppQuit%=TRUE
  ENDCASE
ENDCASE
IF Block%!8 AND 1 THEN SYS "Wimp_CreateMenu",,MenuOpen%
ENDPROC

DEF PROCwimp_messages (Block%)
REM Handle Wimp messages
LOCAL file%,len%,pix%,helptext$
CASE Block%!16 OF
 WHEN MESSAGE_HELPREQUEST%:
  helptext$=FNwimp_gethelp
  IF LEN(helptext$)>0 THEN
   Block%!0=256
   Block%!12=Block%!8
   Block%!16=MESSAGE_HELPREPLY%
   $(Block%+20)=helptext$+CHR$0
   SYS "Wimp_SendMessage",17,Block%,Block%!4
  ENDIF
 WHEN MESSAGE_QUIT%:
  AppQuit%=TRUE
 WHEN MESSAGE_SAVEDESKTOP%:
  file%=Block%!20
  SYS "XOS_ReadVarVal","Patience$Dir",Block%,256,0,3 TO ,,len%
  Block%?len%=13
  BPUT#file%,"Run "+$(Block%)
 WHEN MESSAGE_MODECHANGE%:
  SYS "Font_LoseFont",Font%
  SYS "Font_FindFont",,"Homerton.Medium",12*16,12*16,0,0 TO Font%
ENDCASE
ENDPROC

DEF PROCwimp_openwindow (window%,x%,y%,w%,h%)
REM Opens a window at a specific position
LOCAL height%
Block%!0=window%
SYS "Wimp_GetWindowState",,Block%
IF x%>-1 THEN Block%!4=x%:IF y%>-1 THEN Block%!8=y%
IF w%>-1 THEN Block%!12=w%:IF h%>-1 THEN Block%!16=h%
Block%!28=-1
CASE window% OF
 WHEN GameWin%:
  Block%!0=GameWin%
  SYS "Wimp_OpenWindow",,Block%,&4B534154,-1
  height%=Block%!16
  Block%!0=ToolWin%
  SYS "Wimp_GetWindowState",,Block%
  Block%!8=height%-60
  Block%!16=height%
  SYS "Wimp_OpenWindow",,Block%,&4B534154,GameWin%
 OTHERWISE:SYS "Wimp_OpenWindow",,Block%
ENDCASE
ENDPROC

DEF PROCwimp_seticontext (window%,icon%,text$)
REM Set the text label in an icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
$(Block%!28)=text$
Block%!8=0:Block%!12=0
SYS "Wimp_SetIconState",,Block%
ENDPROC

DEF PROCwimp_selecticon (window%,icon%,action%)
REM Selects an icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
IF action% THEN
 IF NOT(Block%!24 AND 1<<21) THEN
  Block%!8=1<<21:Block%!12=1<<21
  SYS "Wimp_SetIconState",,Block%
 ENDIF
ELSE
 IF (Block%!24 AND 1<<21) THEN
  Block%!8=0:Block%!12=1<<21
  SYS "Wimp_SetIconState",,Block%
 ENDIF
ENDIF
ENDPROC

DEF FNwimp_getselect (window%,icon%)
REM Returns TRUE if icon is selected, FALSE if not
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
IF (Block%!24 AND (1<<21)) THEN =TRUE ELSE =FALSE

DEF PROCwimp_error
REM Report fatal errors and close
IF SolidDrag% THEN
 SYS "DragASprite_Stop"
ELSE
 SYS "Wimp_DragBox",,-1
ENDIF
ErrorBlock%!0=ERR
$(ErrorBlock%+4)=REPORT$+" "+FNmess_getargs("EL",STR$ERL,"")+CHR$0
SYS "Wimp_ReportError",ErrorBlock%,1,FNmess_get("_TaskName")
END
ENDPROC

DEF PROCwimp_pixtrans (area%,name$)
REM Sets up scale factors and colour translation for sprites
LOCAL spointer%
SYS SWI_SPRITE%,&118,area%,name$ TO ,,spointer%
SYS SWI_PIXTRANS%,&200,area%,spointer%,,,,Factors%
SYS SWI_GENTABLE%,area%,spointer%,-1,-1,PixTrans%,3
ENDPROC

DEF PROCwimp_plotsprite (area%,name$,x%,y%,mask%)
REM Plots a sprite at coordinates x%,y%
LOCAL sflags%
IF OSVersion% >= &A5 THEN sflags%=16
IF mask% THEN sflags%=sflags%+8
SYS SWI_SPRITE%,&134,area%,name$,x%,y%,sflags%,Factors%,PixTrans%
ENDPROC

DEF FNwimp_gethelp
LOCAL x%,y%,text$
CASE Block%!32 OF
 WHEN -2:
  IF Block%!36=IconHandle% THEN text$=FNmess_get("H1")
 WHEN InfoWin%:
  text$=FNmess_get("H2")
 WHEN GameWin%:
  x%=Block%!20:y%=Block%!24
  ErrorBlock%!0=GameWin%
  SYS "Wimp_GetWindowState",,ErrorBlock%
  Wx%=ErrorBlock%!4:Wy%=ErrorBlock%!16
  IF x%-Wx%>DP% AND x%-Wx%<DP%+CW% AND y%-Wy%>DY% AND y%-Wy%<DY%+CH% THEN text$=FNmess_get("G1")
  IF x%-Wx%>DX% AND x%-Wx%<DX%+CW% AND y%-Wy%>DY% AND y%-Wy%<DY%+CH% THEN text$=FNmess_get("G2")
  IF x%-Wx%>SX% AND x%-Wx%<SX%+CW%*4 AND y%-Wy%>TY%-CH% AND y%-Wy%<TY% THEN text$=FNmess_get("G3")
  IF x%-Wx%>TX% AND x%-Wx%<TX%+CW%*7 AND y%-Wy%<TY% THEN text$=FNmess_get("G4")
  IF text$="" THEN text$=FNmess_get("G0")
 WHEN ChoiceWin%:
  CASE Block%!36 OF
   WHEN 0,1,4,5,7,9,10,11:
    text$=FNmess_get("C"+STR$(Block%!36))
  ENDCASE
 OTHERWISE:
  SYS "Wimp_GetMenuState",1,ErrorBlock%,Block%!32,Block%!36
  CASE MenuOpen% OF
   WHEN IconMenu%:
    text$=FNmess_get("M"+STR$(!ErrorBlock%))
   WHEN MainMenu%:
    IF ErrorBlock%!0>-1 THEN text$=FNmess_get("M"+STR$(!ErrorBlock%+4))
  ENDCASE
ENDCASE
=text$

REM-----------------------------------------------------------------------------
REM // Messages //
REM-----------------------------------------------------------------------------

DEF PROCmess_load (name$)
REM Loads Message file
LOCAL ERROR
ON ERROR LOCAL RESTORE ERROR:ERROR 3,REPORT$
SYS "MessageTrans_FileInfo",,name$
SYS "OS_Module",6,,,17+LEN(name$) TO ,,MessDesc%
$(MessDesc%+16)=name$
SYS "MessageTrans_OpenFile",MessDesc%,MessDesc%+16
ENDPROC

DEF PROCmess_close
REM Close message file and free memory
SYS "XMessageTrans_CloseFile",MessDesc%
SYS "XOS_Module",7,,MessDesc%
ENDPROC

DEF FNmess_get (tag$)
REM Retrieves a Message string from a tag
=FNmess_getargs(tag$,"","")

DEF FNmess_getargs (tag$,arg1$,arg2$)
REM Retrieves a Message string with arguments
LOCAL flags%,args%
SYS "XMessageTrans_Lookup",MessDesc%,tag$,MessText%,256,arg1$,arg2$ TO ,,,args%;flags%
IF flags% AND 1 THEN args%=0
MessText%?args%=13
=$MessText%
@


1.3
log
@Fix some minor inconsistencies
!Sprites22 were using a new mode word, when the 256 colour/no palette/mask sprites can be described by numbered mode 28. The Filer showed now sprite pre RISC OS 3.50.
The program uses Wimp_ResizeIcon and the nested form of Wimp_OpenWindow so should declare '380' to Wimp_Initialise.
The game window menu didn't line up right in system font, which requires the correct number of spaces in the messages.
The clipping box for some of the options in the Choices dialogue weren't big enough in system font.

Tested on an A5000 with Wimp 3.98 loaded.

Version 0.74. Tagged as 'Patience-0_74'
@
text
@d97 16
a120 2
    WHEN "Sound":
     IF value$="Y" THEN Option_Sound%=TRUE ELSE Option_Sound%=FALSE
d743 15
d773 1
a773 2
PROCwimp_selecticon(ChoiceWin%,11,FALSE)
PROCwimp_openwindow(ChoiceWin%,xmouse%-220,140,xmouse%-220+580,140+584)
a790 7
  IF FNwimp_getselect(ChoiceWin%,11) THEN
   Block%!0=GameWin%:SYS "Wimp_GetWindowState",,Block%
   Option_WinX%=Block%!4
   Option_WinY%=Block%!8
   Option_ExtentX%=Block%!12-Block%!4
   Option_ExtentY%=Block%!16-Block%!8
  ENDIF
a805 4
   BPUT#file%,"WinX:"+STR$Option_WinX%
   BPUT#file%,"WinY:"+STR$Option_WinY%
   BPUT#file%,"ExtentX:"+STR$Option_ExtentX%
   BPUT#file%,"ExtentY:"+STR$Option_ExtentY%
d949 1
a949 2
DIM IconMenu% 28+(24*4)
PROCwimp_makemenu(IconMenu%,FNmess_get("_TaskName"))
d954 1
a954 2
DIM MainMenu% 28+(24*3)
PROCwimp_makemenu(MainMenu%,FNmess_get("_TaskName"))
d957 2
a958 1
PROCwimp_additem(MainMenu%,2,128,-1,FNmess_get("Help"))
d961 18
a978 5
DEF PROCwimp_makemenu (menu%,title$)
REM Create a menu structure
$(menu%)=title$
menu%!12=&00070207:menu%!16=80:menu%!20=44:menu%!24=0
ENDPROC
d982 14
a995 2
menu%!(28+(item%*24))=flags%:menu%!(28+(item%*24)+4)=link%
menu%!(28+(item%*24)+8)=&07000021:$(menu%+28+(item%*24)+12)=text$
d1057 1
@


1.2
log
@Refresh of Patience diversion
Notable changes
* Clearer card sprites, especially in EX0 EY0 modes
* Solid drags of cards during game play
* Iconbar menu now style guide compliant
* Choices dialogue allows commonly changed game options to be retained
* Useful interactive help
* New application sprites
* Extended instructions
Submission from Chris Wraight.
Tested on an emulated A5000 (RISC OS 3.10) and RISC OS 5.21 on a Raspberry Pi.

Version 0.73. Tagged as 'Patience-0_73'
@
text
@d812 1
a812 1
  SYS "Wimp_CreateMenu",,IconMenu%,!Block%-64,272
d865 1
a865 1
SYS "Wimp_Initialise",310,&4B534154,FNmess_get("_TaskName"),Block% TO,AppHandle%
@


1.1
log
@Minor source reorganisation
* Tokenised BASIC moved into bas directory, and converted to text for easier diffing
* Makefile recreated
Built and briefly tested - still makes a working app.

Version 0.72. Tagged as 'Patience-0_72'
@
text
@d18 1
a18 1
ON ERROR ERROR EXT 1,REPORT$:END
d20 124
a143 125
DIM bootpath% 255
SYS"XOS_ReadVarVal","Patience$Dir",bootpath%,256,0,3 TO,,S%
bootpath%?S%=13
DIM m$(20) : REM Extra space allocated here.
REM Uses OS_Find not OPENIN so error is generated if file not found
SYS "OS_Find", 79, "<Patience$Dir>.Messages" TO A%
B%=-1:REPEAT B%+=1:m$(B%)=GET$#A%:UNTILEOF#A% OR m$(B%) = "":CLOSE#A%
END=END+10000

DIM q% 255,menudata% 255,buffer% 255:$q%="TASK"
DIM msgnums% 16
msgnums%!0 = 0
msgnums%!4 = 10
msgnums%!8 = &400C1
msgnums%!12 = 0
SYS "Wimp_Initialise", 200, !q%, m$(9), -1 TO version%
`wbcol=10:`tbcol=2:`sco=3:`mbcol=2:`wfcol=&7:`tfcol=7:`sci=1:`tbcol2=12
SYS"OS_ReadModeVariable",MODE,3 TO,,fcol%
IFfcol%=1 `wbcol=0
PROCvars
DIM errbuf% 255
DIM ind% 256
iptr% = ind%
first% = TRUE

pat%=FNcwindow
DATA Patience,&0F,`wfcol,`wbcol,0,-1024,800,0,     0,-640,800,0  ,0

b$="<Patience$Dir>.Sprites":a$=b$
SYS"XWimp_ReadSysInfo",2 TO R0;V:IF(V AND 1)=0 a$+=CHR$?R0+CHR$R0?1
S%=OPENINa$:IFS%=0 a$=b$:S%=OPENINa$
T%=EXT#S%+16:CLOSE#S%
DIM sprites% T%,factors% 15,pixtrans% 15
!sprites%=T%:sprites%!8=1
SYS spop%,&109,sprites%
SYS spop%,&10A,sprites%,a$
!q%=-1:q%!4=0:q%!8=0:q%!12=68:q%!16=68
q%!20=%11000000000010:$(q%+24)=m$(12)
SYS "Wimp_CreateIcon",,q% TO icpat%

cback%=0:kingsonly=TRUE:dealreverse=TRUE:numberover=3:@@%=5
S%=OPENIN"Choices:Patience.!Config"
IFS% THEN
 cback%=VALGET$#S%
 kingsonly=VALGET$#S%<>0
 dealreverse=VALGET$#S%<>0
 numberover=VALGET$#S%
 CLOSE#S%
ENDIF
back$="back"+STR$cback%:half$="half"+STR$cback%

DIM SPACE% 52,A$(7),S%(3),suit$(3)
N%=RND(TIME OR &80000000):PROCSHUFFLE:gamesstarted=0:gamesout=0
suit$(0)="club":suit$(1)="diamond":suit$(2)="heart":suit$(3)="spade"
END=END+2000

PROCgetmodeinfo

ON ERROR PROCerrorbox
SYS Drag,,-1:PROCgetpointer:xo%=mousex%:yo%=mousey%:open%=FALSE
REPEAT
 SYS Poll%,1,q% TO A%
 CASE A% OF
 WHEN 1 :PROCredraw_window(!q%)
 WHEN 2 :PROCopen_window(!q%,q%!4,q%!8,q%!12,q%!16,q%!20,q%!24,q%!28)
 WHEN 3 :PROCcloseawindow(!q%)
 WHEN 6 :PROCcheckmouse(!q%,q%!4,q%!8,q%!12,q%!16,q%!20)
 WHEN 7 :PROCgetpointer:X%=mousex%-bx%:Y%=mousey%-by%
 IFX%>24+9*68 IFY%<-176 IFY%>-256 WHEN
 IFX%>=8+7*68 IFY%>=-176 PROCTO(SRC$,"S"):WHEN
 IFX%<8+7*68 PROCTO(SRC$,CHR$((X%-8)DIV68+ASC"A"))
 WHEN 9 :PROCmenuselect(q%)
 WHEN 10:IF!q%=pat% PROCopen_window(!q%,q%!4,q%!8,q%!12,q%!16,q%!20+32*q%!32,q%!24+64*q%!36,q%!28)
 WHEN 17,18:PROCreceive(q%)
 ENDCASE
UNTIL FALSE

DEF PROCreceive(q%)
CASE q%!16 OF
WHEN 0:PROCfinish:END
WHEN 10:PROCdesksave
WHEN &400C1:PROCgetmodeinfo
ENDCASE
ENDPROC

DEF FNcwindow
READ A$,f%,fc%,bc%,x0%,y0%,x1%,y1%,cx0%,cy0%,cx1%,cy1%,nicons%
A$=m$(13)
=FNcreate_window(cx0%,cy0%,cx1%,cy1%,0,0,f%,fc%,bc%,x0%,y0%,x1%,y1%,&2D,A$,nicons%)

DEF PROCcheckmouse(mousex%,mousey%,b%,handle%,icon%,ob%)
IFb%AND2 THEN
 CASE handle% OF
 WHEN pat%:PROCdomenu(pat%,m$(0)+","+m$(1)+","+m$(2)+","+m$(3)+","+m$(4),m$(9))
 WHEN -2:  PROCdomenu(101,m$(5)+","+m$(6),m$(9))
 ENDCASE
 rmenuhandle%=handle%
ENDIF
IFb%AND4 THEN
 IFhandle%>-1THENPROCgetw(handle%)
 CASE handle% OF
 WHEN pat%
  X%=mousex%-bx%:Y%=mousey%-by%
  IFX%>=24+9*68 IFY%<-176 IFY%>=-256 PROCNEXT:WHEN
  IFplay IFX%>=24+8*68 IFY%<-176 IFY%>=-256 PROCFROM("P"):WHEN
  IFplay IFX%<8+7*68 PROCFROM(CHR$((X%-8)DIV68+ASC"A")):WHEN
 WHEN -2:IFopen% PROCfront(pat%) ELSE PROCreopen(pat%):open%=TRUE
 ENDCASE
ENDIF
IFb%AND1 THEN
 IFhandle%>-1THENPROCgetw(handle%)
 CASE handle% OF
 WHEN pat%
  X%=mousex%-bx%:Y%=mousey%-by%
  IFplay IFX%>=24+8*68 IFY%<-176 IFY%>=-256 IFNOTFNFROM("P") PROCTO(SRC$,"S"):WHEN
  IFplay IFX%<8+7*68 IFNOTFNFROM(CHR$((X%-8)DIV68+ASC"A")) PROCTO(SRC$,"S"):WHEN
 WHEN -2:IFopen% PROCfront(pat%) ELSE PROCreopen(pat%):open%=TRUE
 ENDCASE
ENDIF
ENDPROC

DEF PROCcloseawindow(handle%)
PROCgetw(handle%)
xo%=x0%:yo%=y0%:open%=FALSE
PROCclose_window(handle%)
d146 38
a183 2
DEF PROCfinish
SYS "Wimp_CloseDown"
d186 13
a198 11
DEF PROCdomenu(handle%,menu$,menutitle$)
LOCAL indirect%, old%
indirect% = 0
menuhandle%=handle%
menuptr%=buffer%
old% = menuptr%
i%=0
menuptr%!20=44
IF version% < 310 OR LENmenutitle$ <= 12  THEN
  $menuptr%=LEFT$(menutitle$,12)
  menuptr%!16 = (LEN(LEFT$(menutitle$,12)) + 1) * 16
d200 27
a226 30
  iptr% = ind%
  $iptr% = menutitle$
  menuptr%!0 = iptr%
  iptr% += LENmenutitle$ + 1
  menuptr%!16 = (LENmenutitle$ + 1) * 16
  indirect% = 1<<8
ENDIF
menuptr%?12=`tfcol:menuptr%?13=2:menuptr%?14=`wfcol:menuptr%?15=0
menuptr%!24=0:menuptr%+=28
REPEAT item$=FNpar(","):PROCmenuitem(item$):UNTIL item$=""
menuptr%!-24=menuptr%!-24OR&80
old%!28 = old%!28 OR indirect%
IFhandle%=101 SYS CrMenu,,buffer%,mousex%-64,96+44*2 ELSE SYS CrMenu,,buffer%,mousex%-64,mousey%+16
ENDPROC

DEF PROCmenuitem(text$)
IF text$="" ENDPROC
flg%=0:IFtext$=m$(3) flg%=kingsonly=TRUE
IFtext$=m$(4) flg%=dealreverse=TRUE
menuptr%!0=flg%AND1
menuptr%!4=-1
menuptr%!8=&07000021
IF LENtext$ > 12 THEN
  menuptr%!12 = iptr%
  menuptr%!16 = -1
  menuptr%!20 = LENtext$ + 1
  $iptr% = text$
  iptr% += LENtext$ + 1
  menuptr%!8 = menuptr%!8 OR 256 : REM Twiddle the indirect bit
  IF (LEN(text$)+1) * 16 > buffer%!16 buffer%!16 = (LEN(text$)+1) * 16
d228 1
a228 2
  $(menuptr%+12)=LEFT$(text$,12)
  IF (LEN(LEFT$(text$, 12))+1) * 16 > buffer%!16 buffer%!16 = (LEN(LEFT$(text$, 12))+1) * 16
a229 1
menuptr%+=24
d232 7
a238 31
DEF FNpar(sep$)
i1%=i%+1:i%=INSTR(menu$+sep$,sep$,i1%)
=MID$(menu$,i1%,i%-i1%)

DEF PROCmenuselect(menus%)
SYS GetP,,buffer%:adjust%=buffer%!8AND1
SYS DcMenu,,buffer%,menus%,STRING$(200," ")TO,,,a$
IF a$="" THEN ENDPROC
CASE menuhandle% OF
WHEN pat%
 CASE a$ OF
 WHEN m$(1)
  FORI%=1TO7:FORJ%=1TOLENA$(I%)
   MID$(A$(I%),J%,1)=CHR$(ASCMID$(A$(I%),J%,1)AND127):NEXT:NEXT
  PROCredraw_window(pat%):play=FALSE:dealnumber=1
 WHEN m$(0)
  gamesstarted+=1:IFPACK$=""AND FNcheckbacks gamesout+=1
  PROCSHUFFLE:PROCredraw_window(pat%)
 WHEN m$(3)
  kingsonly=NOTkingsonly
 WHEN m$(4)
  dealreverse=NOTdealreverse
 WHEN m$(2)
  cback%+=1:SYS"XOS_SpriteOp",&129,sprites%,"back"+STR$cback% TO;V
  IF(V AND1)=1 cback%=0
  back$="back"+STR$cback%:half$="half"+STR$cback%
  PROCredraw_window(pat%)
 ENDCASE
WHEN 101
 IFa$=m$(6) PROCfinish:END
 IFa$=m$(5) PROCQSave
d240 38
a277 1
IFadjust% PROCcheckmouse(0,0,2,rmenuhandle%,0,0)
d280 4
a283 11
DEF PROCQSave
LOCAL ERROR
SYS"XOS_CLI","CDIR <Choices$Write>.Patience"
ON ERROR LOCAL PROCreporterror:ENDPROC
S%=OPENOUT"<Choices$Write>.Patience.!Config"
ON ERROR LOCAL CLOSE#S%:PROCreporterror:ENDPROC
BPUT#S%,STR$cback%
BPUT#S%,STR$kingsonly
BPUT#S%,STR$dealreverse
BPUT#S%,STR$numberover
CLOSE#S%
d286 4
a289 22
DEF PROCpat
LOCAL gameswon$
WHILE more%
 ox0%=(q%!28-(bx%+8))DIV68
 ox1%=(q%!36-(bx%+8))DIV68:IFox1%>6 ox1%=6
 IFox0%<7 FORZ%=ox0%TOox1%:PROCPILE(A$(Z%+1),bx%+8+Z%*68,by%-96):NEXT
 ox0%=(q%!28-bx%-24)DIV68-7:IFox0%<0 ox0%=0
 ox1%=(q%!36-bx%-24)DIV68-7:IFox1%>3 ox1%=3
 IFox1%>-1 IFox0%<4 FORI%=ox0%TOox1%:PROCCARD(S%(I%),bx%+(7+I%)*68+24,by%-128):NEXT
 IFLENPACK$ THEN
  SYS Col%,7:MOVEbx%+9*68,by%-280:PRINTLENPACK$;
  IFPLACE=LENPACK$ PROCCARDHOLE(bx%+24+9*68,by%-256) ELSE PROCBACK(bx%+24+9*68,by%-256)
  IFPLACE>0 PROCCARD(ASCMID$(PACK$,PLACE,1),bx%+24+8*68,by%-256) ELSE PROCNOCARD(bx%+24+8*68,by%-256)
 ELSE
  PROCNOCARD(bx%+24+9*68,by%-256):PROCNOCARD(bx%+24+8*68,by%-256)
 ENDIF
REM Jiggle the position where the line is plotted depending upon its length
 gameswon$ = m$(7)+STR$gamesstarted+" "+m$(8)+STR$gamesout
 SYS Col%,7: MOVEbx%+480-((LEN(gameswon$)-16)*16),by%-580
 PRINT gameswon$
 SYS GetR%,,q% TO more%
ENDWHILE
d292 5
a296 65
DEF FNcreate_window(cx0%,cy0%,cx1%,cy1%,scx%,scy%,flags%,fc%,bc%,sx0%,sy0%,sx1%,sy1%,titlef%,title$,nicons%)
!q%=cx0%:q%!4=cy0%:q%!8=cx1%:q%!12=cy1%:q%!16=scx%:q%!20=scy%
q%!24=-1:q%!28=flags%
IFfc%=15ANDbc%=15THEN
 q%?32=15:q%?33=15:q%?34=fc%:q%?35=bc%
ELSE q%?32=`tfcol:q%?33=`tbcol:q%?34=fc%:q%?35=bc%
ENDIF
q%?36=`sco:q%?37=`sci:q%?38=`tbcol2:q%?39=0
q%!40=sx0%:q%!44=sy0%:q%!48=sx1%:q%!52=sy1%
q%!56=titlef% OR 256 : REM Make it indirect - foreign words for patience may be long!!!
q%!60=&3000      :REM work area flags
q%!64=0:q%!68=0  :REM reserved
DIM tb% LEN(title$)+1
$tb%=title$+CHR$0
q%!72=tb%
q%!76=-1
q%!80=LEN(title$)+1
q%!84=nicons%
SYS CreateW,,q% TO handle%
=handle%

DEF PROCfront(handle%)
IFhandle%=-1THENENDPROC
PROCgetw(handle%)
PROCopen_window(handle%,x0%,y0%,x1%,y1%,scx%,scy%,-1)
ENDPROC

DEF PROCpopup(handle%)
PROCgetw(handle%)
xo%=mousex%-(x0%+x1%)/2:yo%=mousey%-(y1%+64)
PROCopen_window(handle%,x0%+xo%,y0%+yo%,x1%+xo%,y1%+yo%,scx%,scy%,-1)
ENDPROC

DEF PROCreopen(handle%)
PROCgetw(handle%)
PROCopen_window(handle%,xo%,yo%,x1%-x0%+xo%,y1%-y0%+yo%,scx%,scy%,-1)
ENDPROC

DEF PROCopen_window(handle%,x0%,y0%,x1%,y1%,scx%,scy%,bhandle%)
LOCAL c%,d%,e%,f%
LOCAL mc_dx%,mc_dy%,mc_sw%,mc_sh%,scrx%,scry%
IFhandle%=-1THENENDPROC

IF first% THEN
  SYS"OS_ReadModeVariable",-1,4 TO ,,mc_dx%:mc_dx%=1<<mc_dx%
  SYS"OS_ReadModeVariable",-1,5 TO ,,mc_dy%:mc_dy%=1<<mc_dy%
  SYS"OS_ReadModeVariable",-1,11 TO ,,mc_sw%:mc_sw%+=1
  SYS"OS_ReadModeVariable",-1,12 TO ,,mc_sh%:mc_sh%+=1

  scrx%=mc_sw%*mc_dx%
  scry%=mc_sh%*mc_dy%


  q%!20 = scx%
  q%!24 = scy%

  c% = (scrx% - (q%!12 - q%!4 )) DIV 2
  d% = (scry% - (q%!8  - q%!16)) DIV 2
  e% = c%  + (q%!12 - q%!4 )
  f% = d% + (q%!8  - q%!16)

  q%!4  = c%
  q%!16 = d%
  q%!12 = e%
  q%!8  = f%
d298 13
a310 1
  first% = FALSE
d312 1
a312 3
  q%!0=handle%:q%!28=bhandle%
  q%!4=x0%:q%!8=y0%:q%!12=x1%:q%!16=y1%
  q%!20=scx%:q%!24=scy%
d314 8
a321 1
SYS OpenW,,q%
d324 91
a414 3
DEF PROCgetw(handle%)
!q%=handle%:SYS GetW,,q%
PROCinfo(q%+4):bhandle%=q%!28:flags%=q%!32
d417 45
a461 3
DEF PROCinfo(q%)
x0%=!q%:y0%=q%!4:x1%=q%!8:y1%=q%!12:scx%=q%!16:scy%=q%!20
bx%=x0%-scx%:by%=y1%-scy%
d464 26
a489 3
DEF PROCupdate(handle%,ux0%,uy0%,ux1%,uy1%)
!q%=handle%:q%!4=ux0%:q%!8=uy0%:q%!12=ux1%:q%!16=uy1%
SYS UpdateW,,q% TO more%:PROCinfo(q%+4)
d492 53
a544 6
DEF PROCredraw_window(handle%)
IFhandle%=pat% THEN
!q%=handle%
SYS RedrawW,,q% TO more%
PROCinfo(q%+4)
PROCpat
d548 11
a558 2
DEF PROCclose_window(handle%)
!q%=handle%:SYS CloseW,,q%
d561 20
a580 17
DEF PROCvars
Wimp   =(1<<18)+(3<<6)
CreateW=Wimp+1
OpenW  =Wimp+5
CloseW =Wimp+6
Poll%  =Wimp+7
RedrawW=Wimp+8
UpdateW=Wimp+9
GetR%  =Wimp+10
GetW   =Wimp+11
GetP   =Wimp+15
Drag   =Wimp+16
CrMenu =Wimp+20
DcMenu =Wimp+21
SYS "OS_SWINumberFromString",,"OS_SpriteOp" TO spop%
SYS "OS_SWINumberFromString",,"Wimp_SetColour" TO Col%
SYS "OS_SWINumberFromString",,"Wimp_ForceRedraw" TO fred%
d583 8
a590 3
DEF PROCgetpointer
SYS GetP,,q%
mousex%=!q%:mousey%=q%!4:b%=q%!8:handle%=q%!12:icon%=q%!16:ob%=q%!20
d593 8
a600 6
DEF PROCerrorbox
ON ERROR ERROR EXT 1, REPORT$:END
SYS Drag,,-1
!errbuf%=ERR:$(errbuf%+4)=REPORT$+m$(10)+STR$ERL+m$(11)+CHR$0
SYS "Wimp_ReportError",errbuf%,1,m$(9)
PROCfinish:END
d603 20
a622 11
DEF PROCSHUFFLE
PACK$=STRING$(52," "):PACK$=""
K%=0:FORI%=0TO3:FORJ%=1TO13:SPACE%?K%=I%+J%*4:K%=K%+1:NEXT:NEXT
FORI%=1TO52:REPEAT J%=RND(52)-1:UNTILSPACE%?J%
PACK$+=CHR$(SPACE%?J%+128):SPACE%?J%=0:NEXT
FORI%=1TO7:A$(I%)=LEFT$(PACK$,7-I%):A$(I%)+=CHR$(ASCMID$(PACK$,8-I%)AND127)
PACK$=MID$(PACK$,9-I%):NEXT
PLACE=0:A$=PACK$:PACK$=""
FORI%=1TOLENA$:PACK$+=CHR$(ASCMID$(A$,I%)AND127):NEXT
FORI%=0TO3:S%(I%)=I%:NEXT
play=TRUE:dealnumber=numberover
d625 8
a632 5
DEF FNcheckbacks
FORI%=1TO7
 IFLENA$(I%) THEN
  FOR J%=1TOLENA$(I%)
   IFASCMID$(A$(I%),J%)>127 THEN=FALSE
d636 71
a706 10
=TRUE

DEF PROCCARD(N%,X%,Y%)
SYS spop%,&134,sprites%,suit$(N%AND3),X%,Y%,,factors%,pixtrans%
IF(N% EOR N%>>1) AND 1 SYSCol%,11 ELSE SYSCol%,7
MOVEX%+24,Y%+72:N%=N%>>2:IFN%>1IFN%<11PRINT;N%;
IFN%=1PRINT"A";
IFN%=11PRINT"J";
IFN%=12PRINT"Q";
IFN%=13PRINT"K";
d709 9
a717 8
DEF PROCHALFCARD(N%,X%,Y%)
SYS spop%,&134,sprites%,"half"+suit$(N%AND3),X%,Y%+40,,factors%,pixtrans%
IF(N% EOR N%>>1) AND 1 SYSCol%,11 ELSE SYSCol%,7
MOVEX%+24,Y%+72:N%=N%>>2:IFN%>1IFN%<11PRINT;N%;
IFN%=1PRINT"A";
IFN%=11PRINT"J";
IFN%=12PRINT"Q";
IFN%=13PRINT"K";
d720 72
a791 2
DEF PROCBACK(X%,Y%)
SYS spop%,&134,sprites%,back$,X%,Y%,,factors%,pixtrans%
d794 7
a800 2
DEF PROCHALFBACK(X%,Y%)
SYS spop%,&134,sprites%,half$,X%,Y%+40,,factors%,pixtrans%
d803 22
a824 2
DEF PROCNOCARD(X%,Y%)
SYSCol%,`wbcol:RECTANGLE FILL X%,Y%,60,83
d827 144
a970 2
DEF PROCCARDHOLE(X%,Y%)
SYSCol%,3:RECTANGLE FILL X%,Y%,60,83
d973 7
a979 19
DEF PROCPILE(A$,X%,Y%)
IFLENA$=0 ENDPROC
LOCALI%:IFLENA$>1 THEN
FORI%=1TOLENA$-1:J%=ASCMID$(A$,I%)
IFJ%>127 PROCHALFBACK(X%,Y%) ELSE PROCHALFCARD(J%,X%,Y%)
Y%-=40:NEXT
ENDIF
J%=ASCMID$(A$,LENA$):IFJ%>127 PROCBACK(X%,Y%) ELSE PROCCARD(J%,X%,Y%)
ENDPROC

DEF PROCREMCARDS(I%,J%)
LOCALT%:T%=LENA$(I%)
A$(I%)=LEFT$(A$(I%),T%-J%)
IFLENA$(I%) A$(I%)=LEFT$(A$(I%),LENA$(I%)-1)+CHR$(ASCRIGHT$(A$(I%),1)AND127)
PROCupdate(pat%,8+(I%-1)*68,-80-T%*40,8+I%*68,40-LENA$(I%)*40)
WHILE more%
 CLG:PROCPILE(A$(I%),bx%+8+(I%-1)*68,by%-96)
 SYS GetR%,,q% TO more%
 ENDWHILE
d982 7
a988 42
DEF PROCNEXT
IFLENPACK$=0 VDU7:ENDPROC
IFPLACE=LENPACK$ PLACE=0
IFdealreverse THEN
N1$="":FORI%=dealnumber TO 1 STEP-1
N1$+=MID$(PACK$,PLACE+I%,1):NEXT
ELSE
N1$=MID$(PACK$,PLACE+1,dealnumber)
ENDIF
PACK$=LEFT$(PACK$,PLACE)+N1$+MID$(PACK$,PLACE+dealnumber+1)
PLACE+=LENN1$
MID$(PACK$,PLACE)=CHR$(ASCMID$(PACK$,PLACE)AND127)
PROCupdate(pat%,24+8*68,-256,24+10*68,-144)
PROCpat
ENDPROC

DEF PROCFROM(A$)
IFFNFROM(A$) ENDPROC
q%!20=pat%:SYS GetW,,q%+20
!q%=pat%:q%!4=5
q%!8=mousex%-30:q%!12=mousey%-40:q%!16=mousex%+30:q%!20=mousey%+40
SYS Drag,,q%
ENDPROC

DEF FNFROM(A$)
SRC$=A$:IFA$="P" IFPLACE=0 OR LENPACK$=0 VDU7:=TRUE
IFA$<>"P"IFLENA$(ASCA$-64)=0 VDU7:=TRUE
=FALSE

DEF PROCTO(A$,B$)
IFA$<>"P" A%=ASCA$-64
B%=ASCB$
IFB%=ASC"S"THEN
 IFA$="P" CARD=ASCMID$(PACK$,PLACE) ELSE CARD=ASCMID$(A$(A%),LENA$(A%))
 I%=CARD AND 3:IFCARD<>S%(I%)+4 VDU7:ENDPROC
 S%(I%)=CARD:IFA$="P" PROCREMPACK ELSE PROCREMCARDS(A%,1)
 PROCTOSTACK(I%)
ELSE
 IFB%<ASC"A"ORB%>ASC"G" VDU7:ENDPROC
 CARDT=ASCRIGHT$(A$(B%-64),1):YLEN=LENA$(B%-64):IFA$="P"THEN
  CARD=ASCMID$(PACK$,PLACE):IFFNCHK=0 VDU7:ENDPROC
  A$(B%-64)+=CHR$CARD:PROCREMPACK
d990 6
a995 10
  C%=0:D%=0:REPEAT D%+=1:CARD=ASCMID$(A$(A%),D%):UNTILFNCHK ORD%>LENA$(A%)
  IFD%>LENA$(A%) VDU7:ENDPROC
  Q%=LENA$(B%-64):A$(B%-64)+=MID$(A$(A%),D%)
  PROCREMCARDS(A%,LENA$(A%)-D%+1)
 ENDIF
 PROCupdate(pat%,8+(B%-ASC"A")*68,-120-LENA$(B%-64)*40,8+(B%-64)*68,-YLEN*40)
 WHILE more%
  PROCPILE(A$(B%-64),bx%+8+(B%-65)*68,by%-96)
  SYS GetR%,,q% TO more%
 ENDWHILE
d999 6
a1004 14
DEF PROCREMPACK
PLACE-=1:PACK$=LEFT$(PACK$,PLACE)+MID$(PACK$,PLACE+2)
PROCupdate(pat%,24+8*68,-280-32,20+10*68,-140)
WHILE more%
 CLG
 IF LENPACK$ THEN
  SYSCol%,7:MOVEbx%+9*68,by%-280:PRINTLENPACK$;
  IFPLACE=LENPACK$ PROCCARDHOLE(bx%+24+9*68,by%-256) ELSE PROCBACK(bx%+24+9*68,by%-256)
  IFPLACE>0 PROCCARD(ASCMID$(PACK$,PLACE,1),bx%+24+8*68,by%-256) ELSE PROCNOCARD(bx%+24+8*68,by%-256)
 ELSE
  PROCNOCARD(bx%+24+9*68,by%-256):PROCNOCARD(bx%+24+8*68,by%-256)
 ENDIF
 SYS GetR%,,q% TO more%
ENDWHILE
d1007 20
a1026 6
DEF FNCHK
IFCARDT=-1 THEN
IFkingsonly THEN =CARD DIV4=13 ELSE =CARD<127
ENDIF
CT=(CARDT EOR CARD)AND3:IFCT=0 OR CT=3 =FALSE
=CARDT DIV4=CARD DIV4+1
d1028 24
a1051 6
DEF PROCTOSTACK(I%)
PROCupdate(pat%,24+(7+I%)*68,-128,24+(8+I%)*68,-40)
WHILE more%
 PROCCARD(S%(I%),bx%+(7+I%)*68+24,by%-128)
 SYS GetR%,,q% TO more%
ENDWHILE
d1054 20
a1073 2
DEF PROCgetmodeinfo
SYS"Wimp_ReadPixTrans",&100,sprites%,"club",,,,factors%,pixtrans%
d1076 23
a1098 5
DEF PROCdesksave
LOCAL myref%,sender%
IF FNdeskwrite(q%!20) THEN
 sender%=q%!4:myref%=q%!8:q%!12=myref%:SYS"Wimp_SendMessage",19,q%,sender%
 PROCreporterror
d1102 67
a1168 5
DEF FNdeskwrite(H%)
LOCAL ERROR
ON ERROR LOCAL =TRUE
BPUT#H%,"Run "+$bootpath%
=FALSE
d1170 3
a1172 4
DEF PROCreporterror
!errbuf%=ERR:$(errbuf%+4)=REPORT$+CHR$0
SYS "Wimp_ReportError",errbuf%,1,m$(9)
ENDPROC
d1174 27
@


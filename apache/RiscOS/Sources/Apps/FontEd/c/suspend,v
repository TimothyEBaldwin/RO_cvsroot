head	4.3;
access;
symbols
	FontEd-0_36:4.3
	FontEd-0_35:4.3
	FontEd-0_34-moved:4.3
	Manager-3_76:4.3
	Manager-3_75:4.3
	Manager-3_74:4.3
	Manager-3_73:4.3
	Manager-3_72:4.3
	Manager-3_71:4.3
	Manager-3_70:4.3
	Manager-3_69:4.3
	Manager-3_68:4.3
	Manager-3_67:4.3
	Manager-3_66:4.3
	Manager-3_65:4.3
	Manager-3_64:4.3
	Manager-3_63:4.3
	Manager-3_62:4.2
	Manager-3_61:4.2
	Manager-3_60:4.2
	RO_5_07:4.2
	Manager-3_59:4.2
	Manager-3_58:4.2
	Manager-3_57:4.2
	Manager-3_56:4.2
	Manager-3_55:4.2
	Manager-3_54:4.2
	Manager-3_53:4.2
	Manager-3_52:4.1
	Manager-3_51:4.1
	Manager-3_50:4.1
	Manager-3_49:4.1
	dellis_autobuild_BaseSW:4.1
	Manager-3_48:4.1
	sbrodie_sedwards_16Mar2000:4.1
	dcotton_autobuild_BaseSW:4.1
	Manager-3_47:4.1
	Manager-3_46:4.1
	Manager-3_45:4.1
	Manager-3_44:4.1
	Manager-3_43:4.1
	Manager-3_42:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Manager-3_41-4_2_2_13:4.1
	Ursula_RiscPC:4.1.0.10
	Manager-3_41-4_2_2_12:4.1
	Manager-3_41-4_2_2_11:4.1
	Manager-3_41-4_2_2_10:4.1
	Manager-3_41-4_2_2_9:4.1
	Manager-3_41-4_2_2_8:4.1
	Manager-3_41-4_2_2_7:4.1
	Manager-3_41-4_2_2_6:4.1
	Manager-3_41-4_2_2_5:4.1
	Manager-3_41-4_2_2_4:4.1
	Manager-3_41-4_2_2_3:4.1
	Manager-3_41-4_2_2_2:4.1
	Manager-3_41-4_2_2_1:4.1
	NRaine:4.1.0.8
	Manager-3_41:4.1
	Ursula_merge:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	bavison_FontManager-3_40:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Manager-3_40-1_1_2_2:4.1.7.1
	smiddle_2Mar1998_Fonts16:4.1.7.1.0.4
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2009.06.11.22.02.52;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2002.02.22.13.31.53;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.44.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.44.10;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.23.16;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.54.39;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.17.19;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.3
log
@  GET and #include file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both Norcroft and GCC.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 3.62. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*  Title: > c.suspend
 */

#include "includes.h"
#include "wlink.h"
#include "misc.h"

#include "drag.h"
#include "suspend.h"
#include "loadsave.h"
#include "menu.h"
#include "redraw.h"
#include "sprites.h"
#include "scaffold.h"


static os_error * deletepathdata(Char_Block *charptr);

Path_Block *frompath, *topath;      /* input to cvpath */
Pt_Block *lastpoint;                /* output from cvpath */


/* Scan all subpaths of a character, calling subr for each line in turn.
 */

Line_Block * scanchar(Char_Block *charptr, int (*subr)(Line_Block *) )
{
  return(scancharpaths(charptr, subr, SCAN_ALL));
}


/* Scan subpaths of a character matching scantype, calling subr for each line in turn.
 *
 * This routine must attempt to check the flags associated with the character
 * being painted to ensure that the correct end points get rendered, can this be
 * obtained from the character pointer?
 */

Line_Block * scancharpaths(Char_Block *charptr, int (*subr)(Line_Block *), scan_type scantype)
{
  Pt_Block   *firstpt, *endp1,*ctrl1,*ctrl2,*endp2;
  Path_Block *subpath = charptr->nextpath;

  while (subpath != NULL)
  {
    thispath = subpath;
    ctrl2 = NULL;
    endp1 = subpath->firstpoint;
    firstpt = endp1;

    if ((firstpt->nextpt[0]==NULL || firstpt->nextpt[1]==NULL ? SCAN_SKELETON
                                                              : SCAN_OUTLINES) & scantype) {
      while (endp1 != NULL)
      {
        if ((ctrl1=endp1->nextpt[0])==ctrl2) ctrl1 = endp1->nextpt[1];
        if (ctrl1==NULL) break;

        ctrl2 = ctrl1->nextpt[0];
        endp2 = ctrl2->nextpt[1];

        { static Line_Block blk;
          blk.p[0] = endp1;
          blk.p[1] = ctrl1;
          blk.p[2] = ctrl2;
          blk.p[3] = endp2;
          if (subr(&blk)) return(&blk);
        }

        if ((endp1=endp2)==firstpt) break;  /* avoid looping */
      }
    }
    subpath = subpath->nextpath;
  }
  return(NULL);
}


Pt_Block * scnchrpt(Char_Block *charptr, int (*subr)(Pt_Block *), int flag)
{
  Pt_Block   *firstpt, *endp1,*ctrl1,*ctrl2,*endp2;
  Path_Block *subpath = charptr->nextpath;

  while (subpath != NULL)
  {
    thispath = subpath;
    ctrl2 = NULL;
    endp1 = subpath->firstpoint;
    firstpt = endp1;

    while (endp1 != NULL)
    {
      if ((ctrl1=endp1->nextpt[0])==ctrl2) ctrl1 = endp1->nextpt[1];
      if (ctrl1==NULL) break;

      ctrl2 = ctrl1->nextpt[0];
      endp2 = ctrl2->nextpt[1];

      if (subr(endp1)) return(endp1);
      if (flag)
      {
        if (subr(ctrl1)) return(ctrl1);
        if (subr(ctrl2)) return(ctrl2);
      }

      if ((endp1=endp2)==firstpt) break;  /* avoid looping */
    }
    if (endp2!=firstpt) if (subr(endp2)) return(endp2);
    subpath = subpath->nextpath;
  }
  return(NULL);
}


int validatept(Pt_Block *pt)
{
  return(pt->path!=thispath);
}


void mergepaths(Pt_Block *oldpt, Pt_Block *newpt)
{
  Path_Block *oldpath = oldpt->path,
             *newpath = newpt->path;

  convertpath(oldpath,newpath);
  if (newpath->firstpoint==newpt)       /* can't use as firstpoint */
  {
    newpath->firstpoint =
      (oldpath->firstpoint==oldpt)
      ? lastpoint
      : oldpath->firstpoint;            /* choose a free endpoint */
  }
  deletepathentry(oldpath);
}


void deletepathentry(Path_Block *path)
{
  Path_Block *subpath,
            **backpath = &thischar->nextpath;

  subpath = *backpath;
  while (subpath!=path)
  {
    if (subpath==NULL) finish("Couldn't find path!");
    backpath=&subpath->nextpath;
    subpath=subpath->nextpath;
  }
  *backpath = subpath->nextpath;
  heap_free(subpath);
}


int cvpath(Pt_Block *pt)
{
  if (pt->path==frompath) { pt->path=topath; lastpoint=pt; }
  return(false);
}


os_error * deleteallchars(Font_Block *font)
{
  register int c;
  register Char_Block *charptr;

  if (font->spritedata != NULL) {
    for (c=0;c<font->nchars;c++)
      if ((charptr=font->chars[c])!=NULL)
        charptr->sproffset = 0;
    flex_free((flex_ptr)&font->spritedata);
    font->spritedata = NULL;
  }

  e(return(e),deletechardata(font,0,font->nchars-1));

  { Wind_Link *wlk = Wind_Head.next;
    while (wlk) {
      if (wlk->type == W_FONTINDEX) {
        Font_Block *font2 = wlk->info;
        if (font2->parent == font) {
          font2->parent = NULL;                                /* remove font's reference last */
        }
      }
      wlk = wlk->next;
    }
  }
  return(NULL);
}


os_error * deletechardata(Font_Block *fontptr, unsigned int charno1, unsigned int charno2)
{
  Char_Block *charptr, *ch2;
  Wind_Link *wlk, *oldwlk;
  int i;

  for (i=charno1;i<=charno2;i++)
  {
    if ((charptr = fontptr->chars[i]) != NULL)
    {
      fontptr->chars[i] = NULL;

      /* scan windows, invalidating template refs and deleting straight refs */

      wlk = &Wind_Head;
      while (wlk->next != NULL)
      {
        oldwlk = wlk;
        wlk = wlk->next;
        switch(wlk->type)
        {
          case W_BITMAP:
          case W_SKELETON:
               if ((ch2=wlk->info)->template==charptr)
               {
                 ch2->template=NULL;
                 invalidate(wlk->wind_handle,-big,-big,big,big);
               } /* drop through */

          case W_FULL:
               if ((ch2=wlk->info)==charptr)
               {
                 deletewindlink(oldwlk,wlk);
                 wlk = oldwlk;   /* correct pointer for next time */
               }
        }
      }

      /* remove any bitmap template references */

      wlk = Wind_Head.next;
      while (wlk) {
        if (wlk->type == W_FONTINDEX) {
          Font_Block *font2 = wlk->info;
          if (font2->parent == fontptr && i < font2->nchars) {
            Char_Block *ch2 = font2->chars[i];
            if (ch2) ch2->template = NULL;            /* nullify this even if char is not displayed */
          }
        }
        wlk = wlk->next;
      }

      /* delete sprite (if any) */

      if (charptr->sproffset!=0)
      {
        erx(my_sprite_delete(fontptr,charptr->sproffset));
      }

      /* free data blocks (charblock,subpaths,points) */
      /* doesn't delete file data (done elsewhere)    */

      e(return(e),deletepathdata(charptr));   /* also deletes list of component characters */

      heap_free(charptr);
    }
  }
  return(NULL);
}


/* Convert heap path data into file format, and store in file data.
 */

os_error * suspendpathdata(Char_Block *charptr)
{
  Path_Block *subpath;

  if (charptr == NULL) return(NULL);

  if (displayed(charptr)) return(NULL);  /* can't do this if it's visible! */

  subpath = charptr->nextpath;

  if (subpath != PATH_SUSPENDED &&
      subpath != PATH_BITMAP)
  {
    charptr->template = NULL;         /* can't be needed any more */

    if (heaptrace) mytracef("savechar(%p) ...",charptr);
    e(return(e), savechar(charptr));   /* convert back into file data */
    if (heaptrace) mytracef("done\n");

    /* delete heap structure describing path (now held in file data) */

    er(deletepathdata(charptr));          /* deletes path elements and composite sections */
  }
  return(NULL);
}


os_error * deletepathdata(Char_Block *charptr)
{
  /* delete all path sections */

  if (charptr->nextpath != PATH_SUSPENDED && charptr->nextpath != PATH_BITMAP)
  {
    while (charptr->nextpath) er(deletesubpath(&charptr->nextpath));
  }

  /* delete list of composite elements (now stored in file data) */

  { register Comp_Block *comp = charptr->composites;
    charptr->composites = charptr->selcomp = NULL;
    while (comp) {
      register Comp_Block *comp2 = comp->next;
      heap_free(comp);
      comp = comp2;
    }
  }

  charptr->nextpath = PATH_SUSPENDED;

  return(NULL);
}


os_error *deletesubpath(Path_Block **head)
{
  Pt_Block   *firstpt, *prevpt, *pt, *oldpt;
  Path_Block *subpath = *head;

  prevpt = NULL;
  firstpt = pt = subpath->firstpoint;

  while (pt != NULL)
  {
    if ((pt=(oldpt=pt)->nextpt[0])==prevpt) pt=oldpt->nextpt[1];
    heap_free(prevpt=oldpt);
    if (pt==firstpt) break;  /* avoid looping */
  }

  *head = subpath->nextpath;

  heap_free(subpath);

  return(NULL);
}


#define PATH_MIN ((Path_Block *) 0x8000)

os_error *copysubpath(Path_Block *subpath, Path_Block **newpp,
                      int designsize_new, int designsize_old, int xoffset, int yoffset)
{
  Path_Block *newpath;
  Pt_Block *firstpt,*prevpt,*newprevpt,*pt;
  int next;
  Pt_Block *newpt;

  mytracef("copysubpath(%p,%p,%d,%d,%d,%d) ...",subpath,newpp,designsize_new,designsize_old,xoffset,yoffset);

  if (subpath < PATH_MIN) {
    static os_error err = { 1, "" };
    sprintf(err.errmess, "copysubpath called with invalid value (&%p)", subpath);
    return(&err);
  }

  e(return(e),getheap(Path_Block,&newpath));

  newpath->firstpoint = NULL;
  newpath->nextpath = NULL;

  pt = subpath->firstpoint;
  firstpt = pt;
  newprevpt = prevpt = NULL;

  while (pt != NULL)
  {
    e(return(e),getheap(Pt_Block,&newpt));
    *newpt = *pt;    /* copy struct */
    newpt->x = pt->x * designsize_new / designsize_old + xoffset;
    newpt->y = pt->y * designsize_new / designsize_old + yoffset;

    if (prevpt==NULL)
         newpath->firstpoint = newpt;
    else newprevpt->nextpt[next] = newpt;

    next = (pt->nextpt[0]==prevpt) ? 1 : 0;

    newpt->nextpt[1-next] = newprevpt;
    newpt->nextpt[next] = NULL;
    newpt->path = newpath;
    newprevpt = newpt;

    prevpt = pt;
    pt = pt->nextpt[next];
    if (pt==firstpt)
    {
      Pt_Block * fstpt = newpath->firstpoint;
      newpt->nextpt[next] = fstpt;
      fstpt->nextpt[(firstpt->nextpt[0]==NULL)?0:1] = newpt;
      break;
    }
  }

  *newpp = newpath;

  mytracef(" finished.\n");

  return(NULL);
}


BOOL displayed(Char_Block *charptr)
{
  Wind_Link *wlink = Wind_Head.next;

  if (charptr->sproffset==0) return(true);    /* treat as visible when scanloading characters */

  while (wlink!=NULL)
  {
    switch(wlink->type)
    {
      case W_SKELETON:
      case W_BITMAP:
           if (((Char_Block *)wlink->info)->template==charptr) return(TRUE);
           /* also drop through ... */

      case W_FULL:
           { Char_Block *chr = wlink->info;
             if (chr==charptr) return(true);
             if (chr->parent == charptr->parent) {
               Comp_Block *comp = chr->composites;
               while (comp) {
                 if (comp->charno == charptr->charno) return(TRUE);
                 comp = comp->next;
               }
             }
           }
    } /* switch */
    wlink=wlink->next;
  }
  return(false);
}


/* Move the data for charptr to the character definition (font, charno).
 * Calls copychardata(), then deletes the old character and relocates any
 * references to point to the new one.
 */

os_error *movechardata(Char_Block *charptr,Font_Block *font,int charno)
{
  if (charptr) {
    Font_Block *oldfont = charptr->parent;
    int oldcharno = charptr->charno;
    int ch;

    if (oldfont != font) returnerr("Can only move characters within a font");
    if (charptr->charno == charno) return(NULL);     /* moving to the same place! */

    er(copychardata(charptr, font, charno));         /* first copy to new position */

    for (ch=0; ch<oldfont->nchars; ch++) {           /* now relocate any references */
      Char_Block *chr = oldfont->chars[ch];
      if (ch != charptr->charno && ch != charno && chr) {
        Comp_Block *comp;
        er(unsuspendpathdata(chr));     /* make sure master data is in char_block */
        for (comp=chr->composites; comp; comp=comp->next) {
          if (comp->charno == oldcharno) comp->charno = charno;
        }
        if (chr->scaffold.basechar == oldcharno) {
          chr->scaffold.basechar = charno;
        }
        er(suspendpathdata(chr));       /* put back into file data */
      }
    }

    er(copychardata(NULL, oldfont, oldcharno));      /* finally delete the original */

  } else {
    returnerr("Attempt to move a null character - ignored");
  }

  return(NULL);
}


/* Copy the data for charptr onto the character definition (font, charno)
 * The scaffolding is copied first, to make sure that it is legal
 */

os_error * copychardata(Char_Block *charptr,Font_Block *font,int charno)
{
  Char_Block *newchardata;
  Path_Block *newpath, *subpath;
  Char_Block *oldchar = font->chars[charno];
  Char_Block *basechar = font->chars[oldchar->scaffold.basechar];
  int designsize_old, designsize_new;

  if (charno==0) returnerr("Character 0 must always be null");

  if (inbasefile(font, charno)) returnerr("Character is inherited and is therefore read-only");

  /* remove character being replaced from the scaffold tree */

  if (oldchar != NULL)
  {
    Char_Block *chr;
    int i;
    for (i=0; i<font->nchars; i++) {
      if ((chr = font->chars[i]) != NULL)
      if (chr->scaffold.basechar == charno) {
        e(return(e), copyscaffold(basechar, chr));      /* delete reference to the one we're deleting */
      }
    }

    e(return(e), savechardata(font->chars[charno], NULL, 0));   /* delete data in file */
    e(return(e), deletechardata(font, charno, charno));         /* delete data in heap */
    font->chars[charno] = NULL;
  }
  e(return(e), redrawtree(font));

  if (charptr==NULL) return(NULL);              /* char has been deleted */

  e(return(e),unsuspendpathdata(charptr));      /* convert from file -> heap format */

  e(return(e),getheap(Char_Block,&newchardata));

  *newchardata = *charptr;           /* copy all data as is first */

  newchardata->sproffset = 0;        /* no sprite yet */
  newchardata->composites = NULL;    /* copy these later */

  newchardata->parent = font;
  newchardata->charno = charno;
  newchardata->sline.p[1] = NULL;    /* no selected line */

  /* now copy the path information */

  newpath = NULL;

  if (subpath == PATH_SUSPENDED) returnerr("Character data is suspended !!!");
  if (subpath == PATH_BITMAP) returnerr("Attempt to copy bitmap character !!!");

  designsize_old = charptr->parent->filedata->designsize;
  designsize_new = font->filedata->designsize;           /* scale points to suit new designsize */

  if (bbc_inkey(-3)) heaptrace = TRUE;         /* only trace if ALT pressed */

  newpath=NULL;
  for (subpath=charptr->nextpath; subpath; subpath = subpath->nextpath) {
    Path_Block *newp;
    er(copysubpath(subpath, &newp, designsize_new, designsize_old, 0, 0));
    newp->nextpath = newpath;
    newpath = newp;
  }
  newchardata->nextpath = newpath;
  font->chars[charno] = newchardata;

  /* copy composite character blocks */

  { Comp_Block *comp = charptr->composites;
    while (comp) {
      e(return(e), makecomposite(newchardata, comp->charno,
                                 comp->xorigin * designsize_new / designsize_old,
                                 comp->yorigin * designsize_new / designsize_old));
      comp = comp->next;
    }
  }

  /* copy all scaffold lines from the source into the destination
   * we already deleted any links from the destination, so it can't be cyclic
  */
  { char * checkarray = heap_alloc(font->nchars * sizeof(char));
    int des1 = charptr->parent->filedata->designsize;
    int des2 = font->filedata->designsize;
    int i;
    os_error *err = NULL;

    if (!checkarray) returnerr("Heap full");

    for (i=0; i<font->nchars; i++) checkarray[i] = 0;
    for (i=0; i<16; i++) {
      int xchar = charptr->scaffold.xchar[i];
      int xcoord = charptr->scaffold.xcoord[i];
      int xwidth = charptr->scaffold.xwidth[i];

      if (xchar == charptr->charno) xchar = charno;   /* make local to the new char */
      if (xcoord != NULL_SCAFFOLD) {
        xcoord = xcoord * des2 / des1;
        if (xwidth < WID_LTANGENT) {
          xwidth = xwidth * des2 / des1;
          if (xwidth > WID_LTANGENT-1) xwidth = WID_LTANGENT-1;
        }
      }

      err = changescaffold(newchardata, i, xchar, xcoord, xwidth, charptr->scaffold.xlink[i], checkarray);
      if (err) break;
    }
    if (!err) err = redrawscaffold(font, checkarray);

    heap_free(checkarray);

    if (err) return(err);
  }

  /* now tidy up and reconstruct any necessary bitmaps */

  er(suspendpathdata(charptr));               /* try to save memory */
  er(updatecopies(newchardata, TRUE));

  heaptrace = FALSE;

  return(suspendpathdata(newchardata));  /* try to save memory */
}

@


4.2
log
@* Now handles new "/uXXXXX" identifiers in encoding files.
* 32-bit scaffold table support added (see Doc.BigTables)
* Occasional crash when font cache full fixed (bug introduced at same time
  as, but independently from, Unicode support).

And in FontEd:

* Nice new icon
* 3D look-and-feel
* Solid dragging
* Big table support
* Can now handle more than 15K of scaffolding
* Packing and dependencies fixed - can now reliably load and save our
  Far Eastern fonts (and they load faster, because it doesn't try to
  "correct" the packing)
* Width of font index display now adjustable
* Font index grid now drawn correctly with large fonts
* Font index bitmap generation accelerated

Version 3.53. Tagged as 'Manager-3_53'
@
text
@d18 11
a28 11
#include "h.includes"
#include "h.wlink"
#include "h.misc"

#include "h.drag"
#include "h.suspend"
#include "h.loadsave"
#include "h.menu"
#include "h.redraw"
#include "h.sprites"
#include "h.scaffold"
@


4.1
log
@Initial revision
@
text
@d49 1
a49 1
 * being painted to ensure that the correct end points get rendered, can this be 
d57 1
a57 1
      
d142 1
a142 1
    newpath->firstpoint = 
d183 1
a183 1
        charptr->sprname[0] = 0;
d259 1
a259 1
      if (charptr->sprname[0]!=0)
d261 1
a261 4
        sprite_id tempid;
        tempid.s.name = charptr->sprname;
        tempid.tag = sprite_id_name;
        erx(sprite_delete(fontptr->spritedata,&tempid));
d423 1
a423 1
  if (charptr->sprname[0]=='\0') return(true);    /* treat as visible when scanloading characters */
d537 1
a537 1
  newchardata->sprname[0] = 0;       /* no sprite yet */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

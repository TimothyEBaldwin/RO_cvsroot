head	1.7;
access;
symbols
	Chars-2_04:1.7
	Chars-2_03:1.6
	Chars-2_02:1.5
	Chars-2_01:1.4
	Chars-2_00:1.3
	Chars-1_25:1.2;
locks; strict;
comment	@# @;


1.7
date	2018.04.13.20.17.58;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	JXXtLDnVPm80VjyA;

1.6
date	2017.08.12.09.16.23;	author rool;	state Exp;
branches;
next	1.5;
commitid	vuV5N3Je4GKk6U2A;

1.5
date	2016.08.27.16.06.10;	author rool;	state Exp;
branches;
next	1.4;
commitid	DYHKaSSXSeppCXjz;

1.4
date	2016.07.30.09.06.50;	author rool;	state Exp;
branches;
next	1.3;
commitid	rJlBuyj1H1dnckgz;

1.3
date	2016.07.09.09.27.29;	author rool;	state Exp;
branches;
next	1.2;
commitid	729MTitmspnfZCdz;

1.2
date	2015.01.27.08.32.56;	author rsprowson;	state Exp;
branches;
next	1.1;
commitid	t7hBFrAm5tZPGD7y;

1.1
date	2015.01.27.08.29.56;	author rsprowson;	state Exp;
branches;
next	;
commitid	mM1wcXedGvIzFD7y;


desc
@@


1.7
log
@Fallback to system font if Wimp$Font is unset
If the configured desktop font is 0 (use Wimp$Font) but that variable is unset, use system font instead like the Wimp does rather than failing to get a font handle from Font Manager.
Refactor the extraction of configured font from CMOS using bitshift and mask future tech.

Version 2.04. Tagged as 'Chars-2_04'
@
text
@REM >!Chars.!RunImage

REM Copyright 2015 Castle Technology Ltd
REM
REM Licensed under the Apache License, Version 2.0 (the "License");
REM you may not use this file except in compliance with the License.
REM You may obtain a copy of the License at
REM
REM     http://www.apache.org/licenses/LICENSE-2.0
REM
REM Unless required by applicable law or agreed to in writing, software
REM distributed under the License is distributed on an "AS IS" BASIS,
REM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
REM See the License for the specific language governing permissions and
REM limitations under the License.
REM
REM !Chars
REM Authors: Acorn, CWraight

REM Conventions
REM ===========
REM
REM Global variables are capitalised (e.g. Block%)
REM Local variables are not (e.g. command$)
REM Constants are in all-caps (e.g. WIN_WIDTH%)
REM
REM Most global variables are defined in either
REM PROCchars_init or PROCwimp_init.


REM // Initialise application and load resources //
PROCchars_init
PROCwimp_init
IF Option_Open%=TRUE THEN PROCcharswin_firstopen

REM // Poll loop //
SYS "Wimp_DragBox",,-1
WHILE NOT AppQuit%
 PROCwimp_poll
ENDWHILE

REM // Tidy up and close //
PROCchars_tidyup


REM-----------------------------------------------------------------------------

REM // Chars //

REM-----------------------------------------------------------------------------

DEF PROCchars_init
REM Define global variables and read start-up options

ON ERROR PRINT REPORT$+" at "+STR$ERL:END

REM Constants
KEY_SHIFT%=-1                          :REM Shift key
FONT_SYSFONT%=-1                       :REM System font handle
FONT_8BITMAX%=223                      :REM Max number of 8-bit chars
FONT_UTF8MAX%=126                      :REM Max char for System Font in UTF8
FONT_SIZE%=14                          :REM Font size in points
ENC_FIXED%=0                           :REM Encoding types
ENC_VARIABLE%=1                        :REM Encoding types
ENC_DEFAULT%=2                         :REM Encoding types
CHAR_XBOX%=FONT_SIZE% * 2              :REM Width of character box
CHAR_YBOX%=FONT_SIZE% * 3.5            :REM Height of character box
WIN_TOOLBAR%=128                       :REM Height of window toolbar
WIN_SMALL%=-360                        :REM Height of smallest viewer pane
WIN_WIDTH%=926                         :REM Width of viewer pane
WIN_MARGIN%=12                         :REM Margin for window contents

REM Buffers for SWIs
DIM Block% 255                         :REM General purpose buffer
DIM ErrBlock% 255                      :REM Error buffer

REM Load application messages
PROCmsg_load("Chars:Messages")

REM Font handling
SysFont$=FNmsg_get("SysFont")          :REM System font name
DIM CharDef% 8:CharDef%!4=0            :REM Buffer for character defs
DIM EncodingBuff% 12                   :REM Buffer for encoding name
FontHandle%=0                          :REM Font handle
FontName$=""                           :REM Font name
Encoding$=""                           :REM Encoding name
Encodings%=0                           :REM Total encodings on system
Alphabet$=""                           :REM System encoding 'Alphabet'
DesktopFont$=FNchars_getdesktopfont    :REM Desktop font name

REM GUI/window redrawing
FirstOpen%=TRUE                        :REM First-time open flag
WasDown%=0:IsDown%=0                   :REM Flags to indicate Shift pressed
OldChar%=0:                            :REM Old selected character
XEig%=0:YEig%=0                        :REM Screen Eigen factors

REM Start-up options
Option_Open%=TRUE                      :REM Window auto-open flag
Option_DesktopFont%=FALSE              :REM Use Desktop font on startup

REM UCS Manager handling
UCSManager%=FNchars_getucs
IF UCSManager% THEN

 REM Global variables and storage
 FONT_INVALID%=&FFFFFFFF               :REM Invalid Unicode character
 UCSNames%=FALSE                       :REM A UCS names file can be found
 Lookup%=FALSE                         :REM Ptr to storage for Lookup table
 MaxChars%=0                           :REM Number of chars in display category
 EncPtr%=0                             :REM Pointer to UCS table in module
 MAXCATS%=12                           :REM Max Category ranges
 Categories%=VAL(FNmsg_get("CM0"))     :REM Total Categories
 Category$=""                          :REM Unicode font category
 DIM Category%(1,MAXCATS%)             :REM UCS Block Category ranges
 NameFile%=0                           :REM File desc for Charnames file

 REM If UCS names file present, open using MessageTrans
 LOCAL file$,size%,space%
 LOCAL r%,s$,p$,found%,next%,length%
 file$="Unicode:Files.Charnames"
 SYS "XOS_File",17,file$ TO obj%
 IF obj%=1 THEN
  SYS "Hourglass_On"
  SYS "MessageTrans_FileInfo",,file$ TO ,,size%
  END=HIMEM+size%
  DIM space% size%
  SYS "OS_Module",6,,,17+LENfile$ TO ,,NameFile%
  $(NameFile%+16)=file$
  SYS "MessageTrans_OpenFile",NameFile%,NameFile%+16,space%
  REM Get number of character code ranges (ie CYK glyphs)
  r%=0
  next%=0
  FOR i%=4 TO 6
   s$=STRING$(i%,"?")+"-"+STRING$(i%,"?")
   REPEAT
    SYS "MessageTrans_EnumerateTokens",NameFile%,s$,Block%,255,next% TO ,,found%,,next%
    IF found%>0 THEN r%+=1
   UNTIL found%=0
  NEXT
  REM Store the ranges for lookup
  IF r%>0 THEN
   DIM Ranges%(r%-1,1)
   r%=0
   next%=0
   FOR i%=4 TO 6
    s$=STRING$(i%,"?")+"-"+STRING$(i%,"?")
    REPEAT
     SYS "MessageTrans_EnumerateTokens",NameFile%,s$,Block%,255,next% TO ,,found%,length%,next%
     IF found%>0 THEN
      Block%?length%=13
      p$=$(Block%)
      Ranges%(r%,0)=EVAL("&"+LEFT$(p$,INSTR(p$,"-")-1))
      Ranges%(r%,1)=EVAL("&"+RIGHT$(p$,INSTR(p$,"-")-1))
      r%+=1
     ENDIF
    UNTIL found%=0
   NEXT
  ENDIF

  SYS "Hourglass_Off"
  UCSNames%=TRUE
 ENDIF

 REM Set up heap manager
 PROCheap_init
 IF HeapError% THEN PROCwimp_error(FNmsg_get("Fatal1"))
ENDIF

REM Read user choices from script in Choices
LOCAL file%,obj%,value$,command$
SYS "XOS_File",17,"Choices:Chars.Choices" TO obj%
IF obj%=1 THEN
 file%=OPENIN "Choices:Chars.Choices"
 WHILE NOT EOF#file%
  command$=GET$#file%
  IF INSTR(command$,":") THEN
   value$=RIGHT$(command$,LEN(command$)-INSTR(command$,":"))
   command$=LEFT$(command$,INSTR(command$,":")-1)
   CASE command$ OF
    WHEN "DesktopFont":
     IF value$="Yes" THEN Option_DesktopFont%=TRUE
     IF value$="No" THEN Option_DesktopFont%=FALSE
    WHEN "Open":
     IF value$="Yes" THEN Option_Open%=TRUE
     IF value$="No" THEN Option_Open%=FALSE
   ENDCASE
  ENDIF
 ENDWHILE
 CLOSE#file%
ENDIF

ENDPROC

DEF FNchars_getsysencoding
REM Returns a string with the System alphabet
LOCAL a$,e%,len%
SYS "OS_Byte",71,127 TO ,e%
SYS "OS_ServiceCall",,&43,3,e%,Block%,255 TO ,,,,,len%
Block%?len%=0
SYS "XOS_GenerateError",Block% TO a$
=a$

DEF FNchars_getdesktopfont
REM Returns a handle and name for the Desktop font
LOCAL len%,flags%,data%,dfhandle%,df$
SYS "OS_Byte",161,140 TO ,,data%
dfhandle%=(data% AND&1E)>>1:REM Extract WimpFont configuration bits
CASE dfhandle% OF
 WHEN 0:
  SYS "XOS_ReadVarVal","Wimp$Font",Block%,255,0,3 TO ,,len%;flags%
  IF(flags% AND1)=1 THEN=FNmsg_get("DF1"):REM Fall back to system font 
  Block%?len%=13:df$=$Block%
 WHEN 1,2,3,4,5,6,7,8,9,10,11,12,13,14:
  df$=FNmsg_get("DF"+STR$dfhandle%)
ENDCASE
=df$

DEF FNchars_getucs
REM Returns TRUE if the Font Manager is Unicode capable
LOCAL ver%
SYS "Font_CacheAddr" TO ver%
=ver%>340

DEF FNchars_getchar (xmouse%,ymouse%)
REM Returns a character number from mouse coordinates
LOCAL xorigin%,yorigin%,row%,col%,char%
Block%!0=CharsPane%
SYS "Wimp_GetWindowState",,Block%
xorigin%=Block%!4+WIN_MARGIN%
yorigin%=Block%!16-Block%!24-12
row%=(yorigin%-ymouse%) DIV CHAR_YBOX%
col%=(xmouse%-xorigin%) DIV CHAR_XBOX%
char%=(row%*32+col%)+32
IF char%>MaxChars%+32 THEN char%=0
IF col%>31 THEN char%=0
=char%

DEF FNchars_getinfo (char%)
REM Returns string with character info
LOCAL ucode%,text$
text$="":ucode%=0
IF char%=0 THEN =text$
CASE Encoding$ OF
 REM UTF8 Font encoding
 WHEN "UTF8":
  ucode%=FNchars_getunicode(char%)
  IF ucode%>0 THEN
   text$=RIGHT$("000"+STR$~ucode%,4)
   IF UCSNames% THEN
    text$=FNmsg_getargs("UCode",text$,FNchars_getcharname(ucode%))
   ELSE
    text$=FNmsg_get("Char")+text$
   ENDIF
   IF Alphabet$="UTF8" OR ucode%<=FONT_8BITMAX%+32 THEN
    text$+=FNmsg_get("UTrans")+STR$ucode%+")"
   ENDIF
  ENDIF
 REM System font
 WHEN "System":
  text$=FNmsg_get("Char")+STR$~char%
  IF Alphabet$<>"UTF8" OR char%<=FONT_UTF8MAX% THEN
   text$+=FNmsg_get("UTrans")+STR$char%+")"
  ENDIF
 REM 8bit Outline Font encoding
 OTHERWISE:
  IF Alphabet$="UTF8" THEN
   ucode%=EncPtr%!((char%)*4)
   IF ucode%<>FONT_INVALID% THEN
    text$=RIGHT$("000"+STR$~ucode%,4)
    IF UCSNames% THEN
     text$=FNmsg_getargs("UCode",text$,FNchars_getcharname(ucode%))
    ELSE
     text$=FNmsg_get("Char")+text$
    ENDIF
    text$+=FNmsg_get("UTrans")+STR$ucode%+")"
   ENDIF
  ELSE
   text$=FNmsg_get("Char")+STR$~char%
   text$+=FNmsg_get("UTrans")+STR$char%+")"
  ENDIF
ENDCASE
=text$

DEF FNchars_getunicode (char%)
REM Returns a Unicode code from a character number
LOCAL ucode%,ptr%,b1%,b2%,b3%
ucode%=0
char%-=32
IF char%<MaxChars% THEN
 ptr%=char%*3
 b1%=Lookup%?ptr%:ptr%+=1
 b2%=Lookup%?ptr%:ptr%+=1
 b3%=Lookup%?ptr%:ptr%+=1
 ucode%=(b1%<<16) + (b2%<<8) + b3%
ENDIF
=ucode%

DEF FNchars_getcharname (ucode%)
REM Returns a Unicode name from a Unicode code
LOCAL first%,last%,token$,name$,clean$,flags%,args%,i%
name$=""
token$=""
FOR i%=0 TO DIM(Ranges%(),1)
 IF ucode%>=Ranges%(i%,0) AND ucode%<=Ranges%(i%,1) THEN
  token$=STR$~(Ranges%(i%,0))+"-"+STR$~(Ranges%(i%,1))
 ENDIF
NEXT
IF token$="" THEN
 token$=RIGHT$("000"+STR$~ucode%,4)
ENDIF
SYS "XMessageTrans_Lookup",NameFile%,token$,Block%,255 TO ,,,args%;flags%
IF flags% AND 1 THEN =""
Block%?args%=&0D
name$=$Block%
clean$=""
FOR i%=1 TO LENname$
 IF MID$(name$,i%,1)<>"\" THEN
  clean$=clean$+MID$(name$,i%,1)
 ELSE
  i%+=1
  SYS "XMessageTrans_Lookup",NameFile%,"T"+MID$(name$,i%,1),Block%,255 TO ,,,args%;flags%
  IF flags% AND 1 THEN args%=0
  Block%?args%=&0D
  IF $Block%<>"" THEN clean$=clean$+$Block%
 ENDIF
NEXT
=clean$

DEF PROCchars_transmit (xmouse%,ymouse%)
REM Tranmits character code(s)
LOCAL char%,ucode%,utf8$,i%,c%
char%=FNchars_getchar(xmouse%,ymouse%)
IF char%>0 THEN
 CASE Alphabet$ OF

  REM UTF8 Alphabet
  WHEN "UTF8":
   CASE Encoding$ OF
    REM UTF8 Font encoding
    WHEN "UTF8":
     ucode%=FNchars_getunicode(char%)
     utf8$=FNchars_getutf8(ucode%)
     FOR i%=1 TO LEN(utf8$)
      c%=ASC(MID$(utf8$,i%,1))
      IF (c%>=&80 OR c%=0) THEN SYS "OS_Byte",138,0,0
      SYS "OS_Byte",138,0,c%
     NEXT
    REM System font
    WHEN "System":
     IF char%<=FONT_UTF8MAX% THEN SYS "Wimp_ProcessKey",char%
    REM 8bit Outline Font encoding
    OTHERWISE:
     ucode%=EncPtr%!(char%*4)
     IF ucode%<>FONT_INVALID% AND ucode%<>&7F THEN
      utf8$=FNchars_getutf8(ucode%)
      FOR i%=1 TO LEN(utf8$)
       c%=ASC(MID$(utf8$,i%,1))
       IF (c%>=&80 OR c%=0) THEN SYS "OS_Byte",138,0,0
       SYS "OS_Byte",138,0,c%
      NEXT
     ENDIF
   ENDCASE

  REM 8bit Alphabet
  OTHERWISE:
   CASE Encoding$ OF
    REM UTF Font encoding
    WHEN "UTF8":
     ucode%=FNchars_getunicode(char%)
     IF ucode%<=FONT_8BITMAX%+32 THEN SYS "Wimp_ProcessKey",ucode%
    REM 8bit font encoding
    OTHERWISE:
     SYS "Wimp_ProcessKey",char%
   ENDCASE

 ENDCASE
ENDIF
ENDPROC

DEF FNchars_getutf8 (ucode%)
REM Returns a string containing UTF8 bytes
IF ucode%<&80 THEN =CHR$(ucode%)
IF ucode%<&800 THEN =CHR$(&C0+(ucode%>>>6))+CHR$(&80+(ucode% AND &3F))
=CHR$(&E0+(ucode%>>>12))+CHR$(&80+((ucode%>>>6) AND &3F))+CHR$(&80+(ucode% AND &3F))

DEF PROCchars_changefont (font$)
REM Change the current Font
LOCAL flags%,encoding%,type%,claim%,ptr%,i%,f$
IF UCSManager% THEN
 IF Lookup% THEN PROCheap_freeblock(Lookup%):Lookup%=FALSE
ENDIF
Alphabet$=FNchars_getsysencoding
IF font$=SysFont$ THEN
 REM System Font
 FontName$=SysFont$
 FontHandle%=FONT_SYSFONT%
 Encoding$="System"
 IF Alphabet$="UTF8" THEN
  REM Set up a System font UCS Table, based on Latin1
  $(EncodingBuff%)="Latin1"+CHR$(0)
  SYS "OS_ServiceCall",,&43,1,EncodingBuff% TO ,,,,encoding%
  SYS "OS_ServiceCall",,&43,8,encoding% TO ,claim%,,,EncPtr%
 ENDIF
 MaxChars%=FONT_8BITMAX%
 PROCcharswin_update
ELSE
 REM Outline Fonts
 IF font$<>"" AND font$<>FontName$ THEN
  SYS "XFont_LoseFont",FontHandle%
  REM Strip font name of extraneous information
  IF LEFT$(font$,2)="\F" THEN font$=RIGHT$(font$,LEN(font$)-2)
  IF INSTR(font$,"\") THEN font$=LEFT$(font$,INSTR(font$,"\")-1)
  FontName$=font$
  REM Find font and investigate what encoding info it has
  SYS "XFont_FindFont",,FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
  IF flags% AND 1 THEN PROCchars_fonterror("FontErr1"):ENDPROC
  type%=FNchars_getencodingtype(FontHandle%)
  REM Select an encoding menu/default Encoding
  REM 1. If Alphabet is UTF8, always use UTF8 Encoding.
  REM 2. If Alphabet<>UTF8 and font has internal encoding file:
  REM    - use 'Glyph' Encoding on UCS Manager systems
  REM    - use 'Default' on non-UCS Manager systems
  REM 3. If Alphabet<>UTF8 and font doesn't have internal encoding:
  REM    - if font encoding is variable, set Encoding to Alphabet
  REM    - if font encoding is fixed, set Encoding to 'Default'
  IF Alphabet$="UTF8" THEN
   Encoding$="UTF8"
  ELSE
   CASE type% OF
    WHEN ENC_FIXED%:
     IF UCSManager% THEN Encoding$="Glyph" ELSE Encoding$="Default"
    WHEN ENC_VARIABLE%:
     Encoding$=Alphabet$
    WHEN ENC_DEFAULT%:
     Encoding$="Default"
   ENDCASE
  ENDIF
  REM Pre-UCS Font Managers can't attach encodings to 'fixed' fonts
  REM or to fonts without an IntMetricsX file,
  REM so we lose/restore the encoding entries
  IF NOT UCSManager% THEN
   ptr%=EncMenu%+28
   IF type%=ENC_FIXED% OR type%=ENC_DEFAULT% THEN
    ptr%!0=ptr%!0 OR (1<<7)
    ptr%!0=ptr%!0 AND NOT (1<<1)
   ELSE
    ptr%!0=ptr%!0 AND NOT (1<<7)
    ptr%!0=ptr%!0 OR (1<<1)
   ENDIF
  ENDIF
  REM If the Alphabet is UTF8 then the 'Default/Glyph' encoding won't
  REM work properly, so shade this out on the encoding menu
  ptr%=EncMenu%+28
  IF Alphabet$="UTF8" THEN
   ptr%!8=ptr%!8 OR (1<<22)
  ELSE
   ptr%!8=ptr%!8 AND NOT (1<<22)
  ENDIF
  REM On Pre-UCS Managers, an internal Encoding file with >256 entries will
  REM crash the Font Manager. If so, abort and switch to System font
  IF NOT UCSManager% AND type%=ENC_FIXED% THEN
   SYS "Font_ReadFontPrefix",FontHandle%,Block%,255
   SYS "XOS_GenerateError",Block% TO path$
   SYS "OS_File",17,path$+"Encoding" TO obj%
   IF obj%=1 THEN
    i%=0
    f$=path$+"Encoding"
    file%=OPENIN f$
     REPEAT
      IF LEFT$(GET$#file%,1)="/" THEN i%+=1
     UNTIL EOF#file% OR i%>256
     IF i%>256 THEN PROCchars_fonterror("FontErr7"):ENDPROC
    CLOSE#file%
   ENDIF
  ENDIF
  REM All checks complete: now find font again with correct encoding
  IF Encoding$="Default" THEN e$="" ELSE e$="\E"+Encoding$
  SYS "XFont_LoseFont",FontHandle%
  SYS "XFont_FindFont",,e$+"\F"+FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
  IF flags% AND 1 THEN
   REM Finding font has failed. Try again with no encoding specified
   PROCwimp_alert("FontErr3")
   Encoding$="Default"
   SYS "XFont_LoseFont",FontHandle%
   SYS "XFont_FindFont",,FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
   IF flags% AND 1 THEN PROCchars_fonterror("FontErr1"):ENDPROC
  ENDIF
  REM Set up new font and update Chars window
  CASE Encoding$ OF
   WHEN "UTF8":PROCchars_changecat(0)
   OTHERWISE:MaxChars%=FONT_8BITMAX%
  ENDCASE
  PROCcharswin_update
 ENDIF
ENDIF
ENDPROC

DEF FNchars_getencodingtype (font%)
REM Check to see if the font has:
REM 1. An IntMetrics file (no encoding data for different alphabets)
REM 2. An internal fixed encoding file (i.e. a 'symbol' font)
REM 3. Encoding data for different alphabets (IntMetric<n>)
LOCAL type%,obj%,path$
type%=ENC_VARIABLE%
REM Get path to font resource directory
SYS "Font_ReadFontPrefix",font%,Block%,255
SYS "XOS_GenerateError",Block% TO path$
REM See if the directory has an internal Encoding file
SYS "OS_File",17,path$+"Encoding" TO obj%
IF obj%=1 THEN
 type%=ENC_FIXED%
ELSE
 REM See if there's an IntMetrics file
 SYS "OS_File",17,path$+"IntMetrics" TO obj%
 IF obj%=1 THEN type%=ENC_DEFAULT%
ENDIF
=type%

DEF PROCchars_changeenc (Block%)
REM Change the current Encoding
LOCAL claim%,enc$,flags%,encoding%,e$
IF UCSManager% THEN
 IF Lookup% THEN PROCheap_freeblock(Lookup%):Lookup%=FALSE
ENDIF
SYS "Wimp_DecodeMenu",,EncMenu%,Block%,EncodingBuff%
Encoding$=$(EncodingBuff%)
IF Encoding$=FNmsg_get("UTF8") THEN Encoding$="UTF8"
IF Encoding$=FNmsg_get("Default") THEN
 IF UCSManager% THEN
  Encoding$="Glyph":e$="\E"+Encoding$
 ELSE
  Encoding$="Default":e$=""
 ENDIF
ELSE
 e$="\E"+Encoding$
ENDIF
REM Find font with encoding suffix
SYS "XFont_LoseFont",FontHandle%
SYS "XFont_FindFont",,e$+"\F"+FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
IF flags% AND 1 THEN
 REM Finding font has failed. Try again with no encoding specified
 PROCwimp_alert("FontErr3")
 Encoding$="Default"
 SYS "XFont_LoseFont",FontHandle%
 SYS "XFont_FindFont",,FontName$,FONT_SIZE%*16,FONT_SIZE%*16 TO FontHandle%;flags%
 IF flags% AND 1 THEN PROCchars_fonterror("FontErr1"):ENDPROC
ENDIF
CASE Encoding$ OF
 WHEN "UTF8":
  PROCchars_changecat(0)
 WHEN "Default","Glyph":
  MaxChars%=FONT_8BITMAX%
 OTHERWISE:
  MaxChars%=FONT_8BITMAX%
  IF Alphabet$="UTF8" THEN
   REM Get a UCS conversion table for the 8bit encoding
   $(EncodingBuff%)=Encoding$+CHR$(0)
   SYS "OS_ServiceCall",,&43,1,EncodingBuff% TO ,,,,encoding%
   SYS "OS_ServiceCall",,&43,8,encoding% TO ,claim%,,,EncPtr%
  ENDIF
ENDCASE
PROCcharswin_update
ENDPROC

DEF PROCchars_changecat (cat%)
REM Change the current Category for UTF8 display
LOCAL cat$,i%,j%,range$
cat$="CM"+STR$(cat%+1)
Category$=FNmsg_get(cat$)
IF RIGHT$(Category$,1)="*" THEN Category$=LEFT$(Category$,LEN(Category$)-1)
FOR i%=0 TO 1:FOR j%=0 TO MAXCATS%
  Category%(i%,j%)=0
NEXT:NEXT
Category%(0,0)=VAL(FNmsg_get(cat$+"-0"))
IF Category%(0,0)>MAXCATS% THEN Category%(0,0)=MAXCATS%
FOR i%=1 TO Category%(0,0)
 range$=FNmsg_get(cat$+"-"+STR$i%)
 Category%(0,i%)=EVAL("&"+LEFT$(range$,INSTR(range$,"-")-1))
 Category%(1,i%)=EVAL("&"+RIGHT$(range$,LEN(range$)-INSTR(range$,"-")))
NEXT
MaxChars%=FNchars_buildlookup
PROCcharswin_update
ENDPROC

DEF FNchars_buildlookup
REM Creates a list of Unicode character codes in a category
LOCAL chars%,total%
LOCAL code%,intcode%,next%,tcode%
SYS "Hourglass_On"
chars%=0:total%=256
code%=0:intcode%=0:next%=0
Lookup%=FNheap_newblock(total%)
IF HeapError% THEN PROCchars_fonterror("FontErr2"):=0
code%=0:intcode%=0:next%=0:ptr%=0
FOR cat%=1 TO Category%(0,0)
 code%=Category%(0,cat%)
 tcode%=Category%(1,cat%)
 REPEAT
  SYS "Font_EnumerateCharacters",FontHandle%,code% TO ,next%,intcode%
  IF intcode%>-1 THEN
   chars%+=1
   IF chars%*3 > total% THEN
    total%+=1024
    Lookup%=FNheap_resizeblock(Lookup%,1024)
    IF HeapError% THEN PROCchars_fonterror("FontErr2"):=0
   ENDIF
   Lookup%?ptr%=(code% >> 16) AND &FF:ptr%+=1
   Lookup%?ptr%=(code% >> 8) AND &FF:ptr%+=1
   Lookup%?ptr%=(code% >> 0) AND &FF:ptr%+=1
  ENDIF
  code%=next%
 UNTIL next%>tcode% OR next%=-1
 IF next%=-1 THEN cat%=Category%(0,0)
NEXT
SYS "Hourglass_Off"
=chars%

DEF PROCchars_fonterror (message$)
REM Report an error selecting a font
SYS "MessageTrans_Lookup",MessDesc%,message$,ErrBlock%+4,252,FNmsg_get("ErrApp") TO ,,,len%
ErrBlock%?(len%+4)=13:ErrBlock%!0=1
SYS "XWimp_ReportError",ErrBlock%,1,FNmsg_get("ErrApp")
SYS "Wimp_CreateMenu",-1
PROCchars_changefont(SysFont$)
ENDPROC

DEF FNchars_fonttype (font$)
REM Returns 1 if font is System font
IF font$=SysFont$ THEN =1 ELSE =font$

REM-----------------------------------------------------------------------------

REM // Charswin //

REM-----------------------------------------------------------------------------

DEF PROCcharswin_firstopen
REM Open Chars window for the first time
LOCAL x%,y%,w%,h%
CASE Option_DesktopFont% OF
 WHEN TRUE:PROCchars_changefont(DesktopFont$)
 WHEN FALSE:PROCchars_changefont(SysFont$)
ENDCASE
Block%!0=CharsWin%
SYS "Wimp_GetWindowState",,Block%
x%=Block%!4
y%=Block%!8
w%=Block%!12-Block%!4
h%=Block%!16-Block%!8
PROCwimp_openwindow(CharsWin%,x%,y%,x%+w%,y%+h%,-1)
PROCwimp_seticontext(CharsWin%,6,"")
PROCwimp_seticontext(CharsWin%,7,"")
FirstOpen%=FALSE
ENDPROC

DEF PROCcharswin_click (pane%,xmouse%,ymouse%,button%,icon%)
REM Handle mouseclicks in the main window
LOCAL i%,size%,indsize%,enc$
CASE pane% OF
 WHEN CharsPane%:
  IF button%=4 THEN PROCchars_transmit(xmouse%,ymouse%)
 WHEN CharsWin%:
  CASE icon% OF
   WHEN 1:REM Open Font popup menu
    SYS "Font_ListFonts",,0,7<<19,,0,,0 TO ,,,size%,,indsize%
    IF size%>FontBuffer% THEN PROCwimp_error(FNmsg_get("Fatal3"))
    SYS "Font_ListFonts",,FontMenu%,7<<19,size%,FontInd%,indsize%,FNchars_fonttype(FontName$)
    IF FontHandle%=FONT_SYSFONT% THEN
     PROCwimp_settick(FontMenu%,0,TRUE)
    ELSE
     PROCwimp_settick(FontMenu%,0,FALSE)
    ENDIF
    PROCwimp_openiconmenu(CharsWin%,1,FontMenu%)
   WHEN 3:REM Open Encoding popup menu
    enc$=Encoding$
    IF enc$="Default" OR enc$="Glyph" THEN enc$=FNmsg_get("Default")
    FOR i%=0 TO Encodings%-1
     PROCwimp_settick(EncMenu%,i%,FALSE)
     IF $(EncMenu%+28+(i%*24)+12)=enc$ THEN PROCwimp_settick(EncMenu%,i%,TRUE)
    NEXT
    PROCwimp_openiconmenu(CharsWin%,3,EncMenu%)
   WHEN 5:REM Open Category popup menu
    FOR i%=0 TO Categories%
     PROCwimp_settick(CatMenu%,i%,FALSE)
     IF $(CatMenu%+28+(i%*24)+12)=Category$ THEN
      PROCwimp_settick(CatMenu%,i%,TRUE)
     ENDIF
    NEXT
    PROCwimp_openiconmenu(CharsWin%,5,CatMenu%)
  ENDCASE
ENDCASE
ENDPROC

DEF PROCcharswin_update
REM Update the display window and mark for redraw
LOCAL workarea%,e$
PROCwimp_seticontext(CharsWin%,0,FontName$)
REM Update Encoding and Category
CASE Encoding$ OF
 WHEN "System":
  PROCwimp_shadeicon(CharsWin%,9,TRUE)
  PROCwimp_shadeicon(CharsWin%,2,TRUE)
  PROCwimp_shadeicon(CharsWin%,3,TRUE)
  PROCwimp_seticontext(CharsWin%,2,"")
  PROCwimp_shadeicon(CharsWin%,4,TRUE)
  PROCwimp_shadeicon(CharsWin%,5,TRUE)
  PROCwimp_shadeicon(CharsWin%,10,TRUE)
  PROCwimp_seticontext(CharsWin%,4,"")
 WHEN "UTF8":
  PROCwimp_shadeicon(CharsWin%,9,FALSE)
  PROCwimp_shadeicon(CharsWin%,2,FALSE)
  PROCwimp_shadeicon(CharsWin%,3,FALSE)
  PROCwimp_seticontext(CharsWin%,2,FNmsg_get("UTF8"))
  PROCwimp_shadeicon(CharsWin%,4,FALSE)
  PROCwimp_shadeicon(CharsWin%,5,FALSE)
  PROCwimp_shadeicon(CharsWin%,10,FALSE)
  PROCwimp_seticontext(CharsWin%,4,Category$)
 OTHERWISE:
  IF Encoding$="Glyph" OR Encoding$="Default" THEN
   e$=FNmsg_get("Default")
  ELSE
   e$=Encoding$
  ENDIF
  PROCwimp_shadeicon(CharsWin%,9,FALSE)
  PROCwimp_shadeicon(CharsWin%,2,FALSE)
  PROCwimp_shadeicon(CharsWin%,3,FALSE)
  PROCwimp_seticontext(CharsWin%,2,e$)
  PROCwimp_shadeicon(CharsWin%,4,TRUE)
  PROCwimp_shadeicon(CharsWin%,5,TRUE)
  PROCwimp_shadeicon(CharsWin%,10,TRUE)
  PROCwimp_seticontext(CharsWin%,4,"")
ENDCASE
REM Set Chars Pane work area
workarea%=-(((MaxChars% DIV 32)+1)*CHAR_YBOX%+WIN_MARGIN%)
IF workarea%>WIN_SMALL% THEN workarea%=WIN_SMALL%
Block%!0=CharsPane%
SYS "Wimp_GetWindowInfo",,Block% OR 1
Block%!24=0
SYS "Wimp_OpenWindow",,Block%
Block%!0=Block%!44:Block%!4=workarea%
Block%!8=Block%!52:Block%!12=Block%!56
SYS "Wimp_SetExtent",CharsPane%,Block%
SYS "Wimp_ForceRedraw",CharsPane%,0,WIN_SMALL%,WIN_WIDTH%+64,0
ENDPROC

DEF PROCcharswin_redraw
REM Redraw the main window
LOCAL more%
LOCAL xorigin%,yorigin%,cx%,cy%,xlimit%,ylimit%
LOCAL flags%,e%,c%,width%,shade%,fpflags%,ssflags%
LOCAL ptr%,start%,end%,b1%,b2%,b3%

REM Get window coords
SYS "Wimp_RedrawWindow",,Block% TO more%
xorigin%=Block%!4+WIN_MARGIN%-Block%!20
yorigin%=Block%!16-WIN_MARGIN%-Block%!24

REM Set up fonts
IF FontHandle%<>FONT_SYSFONT% THEN
 SYS "XFont_SetFont",FontHandle% TO ;flags%
 IF flags% AND 1 THEN PROCchars_fonterror("FontErr4"):ENDPROC
ELSE
 VDU 23,17,7,4,CHAR_XBOX%>>XEig%;CHAR_YBOX%>>YEig%;0;
ENDIF

REM Begin redraw loop
WHILE more%

 REM Set coords/variables for redrawing rectangle
 cx%=xorigin%
 cy%=yorigin%-28
 xlimit%=xorigin%+(CHAR_XBOX% * 31)
 ylimit%=Block%!32-24

 REM Handle outline fonts
 IF FontHandle%<>FONT_SYSFONT% THEN

  REM Find start and end characters to paint
  IF Encoding$="UTF8" THEN
   start%=(-Block%!24 DIV CHAR_YBOX%) * 32
   ptr%=start%*3
   cy%-=(start% DIV 32) * CHAR_YBOX%
   end%=start%+256
   IF end%>MaxChars%-1 THEN end%=MaxChars%-1
   shade%=&1000000
   IF Alphabet$<>"UTF8" THEN shade%=FONT_8BITMAX%+32
   ssflags%=&2080:fpflags%=&2010
  ELSE
   start%=0
   end%=FONT_8BITMAX%
   ssflags%=&80:fpflags%=&10
  ENDIF

  REM Start font painting loop
  SYS "Wimp_SetFontColours",,0,7
  IF end%>-1 THEN
   FOR c%=start% TO end%

    REM Find the character code and check if in transmit range
    CASE Encoding$ OF
     WHEN "UTF8":
      b1%=Lookup%?ptr%:ptr%+=1
      b2%=Lookup%?ptr%:ptr%+=1
      b3%=Lookup%?ptr%:ptr%+=1
      CharDef%!0=(b1%<<16) + (b2%<<8) + b3%
      IF CharDef%!0>shade% THEN SYS "Wimp_SetFontColours",,0,3
     OTHERWISE:
      CharDef%!0=c%+32
    ENDCASE

    REM Centre the character and paint it
    SYS "XFont_ScanString",,CharDef%,ssflags%,1000000,1000000,,,4 TO e%,,,width%;flags%
    IF flags% AND 1 THEN PROCchars_fonterror("FontErr5"):ENDPROC
    SYS "XFont_Paint",,CharDef%,fpflags%,cx%-(width% DIV 800)+(CHAR_XBOX% DIV 2),cy% TO e%;flags%
    IF flags% AND 1 THEN PROCchars_fonterror("FontErr6"):ENDPROC
    cx%+=CHAR_XBOX%
    IF cx%>xlimit% THEN cx%=xorigin%:cy%-=CHAR_YBOX%
    IF cy%<ylimit% THEN c%=end%
   NEXT
  ENDIF
 ENDIF

 REM Handle System Font
 IF FontHandle%=FONT_SYSFONT% THEN
  SYS "Wimp_SetColour",7
  IF FontHandle%=FONT_SYSFONT% THEN
   FOR c%=0 TO FONT_8BITMAX%
    MOVE cx%,cy%+24
    IF Alphabet$="UTF8" AND c%+32>FONT_UTF8MAX% THEN SYS "Wimp_SetColour",3
    IF c%+32<>127 THEN PRINT CHR$(c%+32)+" ";
    cx%+=CHAR_XBOX%
    IF cx%>xorigin%+(CHAR_XBOX% * 31) THEN cx%=xorigin%:cy%-=CHAR_YBOX%
   NEXT
  ENDIF
 ENDIF

 REM Check for more redraw rectangles
 SYS "Wimp_GetRectangle",,Block% TO more%
ENDWHILE

REM Tidy up
IF FontHandle%=FONT_SYSFONT% THEN VDU 23,17,7,4,16>>XEig%;32>>YEig%;0;
ENDPROC

DEF PROCchars_tidyup
REM Close down app
IF FontHandle%<>FONT_SYSFONT% THEN SYS "XFont_LoseFont",FontHandle%
PROCmsg_close
SYS "Wimp_CloseDown"
END
ENDPROC

REM-----------------------------------------------------------------------------

REM // Iconbar //

REM-----------------------------------------------------------------------------

DEF PROCiconbar_click (button%)
REM Handle clicks on the Iconbar icon
CASE button% OF
 WHEN 1,4:CASE FirstOpen% OF
   WHEN TRUE:PROCcharswin_firstopen
   WHEN FALSE:
    Block%!0=CharsWin%
    SYS "Wimp_GetWindowState",,Block%
    PROCwimp_openwindow(CharsWin%,Block%!4,Block%!8,Block%!12,Block%!16,-1)
  ENDCASE
 WHEN 2:SYS "Wimp_GetPointerInfo",,Block%
  SYS "Wimp_CreateMenu",,IconMenu%,!Block%-64,272
  MenuOpen%=IconMenu%
ENDCASE
ENDPROC

REM-----------------------------------------------------------------------------

REM // Choicewin //

REM-----------------------------------------------------------------------------

DEF PROCchoicewin_init
REM Initialise Choices window, open and gain focus
PROCwimp_selecticon(ChoiceWin%,4,Option_Open%)
PROCwimp_selecticon(ChoiceWin%,2,NOT Option_DesktopFont%)
PROCwimp_selecticon(ChoiceWin%,3,Option_DesktopFont%)
SYS "Wimp_GetPointerInfo",,Block%
PROCwimp_openwindow(ChoiceWin%,Block%!0-400,150,Block%!0+178,150+364,-1)
SYS "Wimp_SetCaretPosition",window%,-1,0,0,-1,-1
ENDPROC

DEF PROCchoicewin_click (icon%,button%)
REM Handle clicks in Choices window
LOCAL file%,obj%,val$
CASE icon% OF
 WHEN -1:REM Click on window - gain input focus
  SYS "Wimp_SetCaretPosition",ChoiceWin%,-1,0,0,-1,-1
 WHEN 6:REM Cancel button
  IF button%=4 THEN Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
 WHEN 5:REM Save button
  Option_Open%=FNwimp_getselect(ChoiceWin%,4)
  Option_DesktopFont%=FNwimp_getselect(ChoiceWin%,3)
  SYS "XOS_File",8,"<Choices$Write>.Chars"
  file%=OPENOUT "<Choices$Write>.Chars.Choices"
  BPUT#file%,"| Choices file for Chars"
  BPUT#file%,""
  IF Option_Open% THEN val$="Yes" ELSE val$="No"
  BPUT#file%,"Open:"+val$
  IF Option_DesktopFont% THEN val$="Yes" ELSE val$="No"
  BPUT#file%,"DesktopFont:"+val$
  CLOSE#file%
  IF button%=4 THEN Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
ENDCASE
ENDPROC

DEF FNchoicewin_keypress (key%)
REM Handle keypresses in Choices window
LOCAL taken%
taken%=TRUE
CASE key% OF
 REM Escape
 WHEN &1B:PROCchoicewin_click(6,4)
 REM Return
 WHEN &0D:PROCchoicewin_click(5,4)
 REM Ctrl-F2 to close
 WHEN &1A2:Block%!0=ChoiceWin%:SYS "Wimp_CloseWindow",,Block%
 OTHERWISE:taken%=FALSE
ENDCASE
=taken%

REM-----------------------------------------------------------------------------

REM // Wimp //

REM-----------------------------------------------------------------------------

DEF PROCwimp_init
REM Initialise the task, set wimp global variables and load resources
LOCAL size%,indsize%,counter%,ptr%
LOCAL i%,flags%,text$,utf%

REM Global variables
AppQuit%=FALSE                            :REM Application quit flag
WimpVersion%=0                            :REM Wimp version
TaskHandle%=0                             :REM Task handle
IconHandle%=0                             :REM Iconbar icon handle
Iconbar%=-2                               :REM Iconbar value
MenuOpen%=0                               :REM Handle of open menu
DIM WindowName% 12                        :REM Buffer for Window title
PollMask%=&3801                           :REM Wimp Poll Mask
FontBuffer%=0                             :REM Size needed for Font menu
MESSAGE_QUIT%=0                           :REM Message constants
MESSAGE_HELPREQUEST%=&502                 :REM Message constants
MESSAGE_HELPREPLY%=&503                   :REM Message constants
MESSAGE_MODECHANGE%=&400C1                :REM Message constants
MESSAGE_SAVEDESKTOP%=&A                   :REM Message constants

REM Initialise application
Block%!0=MESSAGE_SAVEDESKTOP%
Block%!4=MESSAGE_HELPREQUEST%
Block%!8=MESSAGE_MODECHANGE%
Block%!12=MESSAGE_QUIT%
SYS "Wimp_Initialise",310,&4B534154,FNmsg_get("_TaskName"),Block% TO WimpVersion%,TaskHandle%

REM Wimp-based Error handling
ON ERROR PROCwimp_error("")

REM Load templates
WindowArea%=FNwimp_opentemplates("Chars:Templates")
CharsPane%=FNwimp_loadtemplate("Characters",WindowArea%)
CharsWin%=FNwimp_loadtemplate("Chars",WindowArea%)
InfoWin%=FNwimp_loadtemplate("Info",WindowArea%)
ChoiceWin%=FNwimp_loadtemplate("Choices",WindowArea%)
SYS "Wimp_CloseTemplate"

REM Create iconbar icon and update version in Info
Block%!0=-1:Block%!4=0:Block%!8=0:Block%!12=68:Block%!16=68
Block%!20=&3002:$(Block%+24)=FNmsg_get("ErrApp")
SYS "Wimp_CreateIcon",,Block% TO IconHandle%
PROCwimp_seticontext(InfoWin%,4,FNmsg_get("_Version"))

REM Create Iconbar menu
DIM IconMenu% 28+(24*4)
PROCwimp_makemenu(IconMenu%,FNmsg_get("Chars"))
PROCwimp_additem(IconMenu%,0,0,InfoWin%,FNmsg_get("Info"))
PROCwimp_additem(IconMenu%,1,0,-1,FNmsg_get("Help"))
PROCwimp_additem(IconMenu%,2,0,-1,FNmsg_get("Choices"))
PROCwimp_additem(IconMenu%,3,128,-1,FNmsg_get("Quit"))

REM IF UCS Manager present, create a Categories menu
IF UCSManager% THEN
 DIM CatMenu% 28+(24*Categories%)
 PROCwimp_makemenu(CatMenu%,FNmsg_get("Cats"))
 FOR i%=1 TO Categories%
  text$=FNmsg_get("CM"+STR$i%)
  flags%=0
  IF RIGHT$(text$,1)="*" THEN flags%=2:text$=LEFT$(text$,LEN(text$)-1)
  IF i%=Categories% THEN flags%=128
  PROCwimp_additem(CatMenu%,i%-1,flags%,-1,text$)
 NEXT
ENDIF

REM Create Font menu
SYS "Font_ListFonts",,0,7<<19,,0,,0 TO ,,,size%,,indsize%
FontMenu%=FNheap_newblock(size%)
IF HeapError% THEN PROCwimp_error(FNmsg_get("Fatal2"))
FontInd%=FNheap_newblock(indsize%)
IF HeapError% THEN PROCwimp_error(FNmsg_get("Fatal2"))
FontBuffer%=size%

REM Create Encodings menu
SYS "Font_ListFonts",,0,9<<19,,0,,0 TO ,,,size%,,indsize%
DIM EncMenu% size%+24,EncInd% indsize%
PROCwimp_makemenu(EncMenu%,FNmsg_get("Encs"))
PROCwimp_additem(EncMenu%,0,2,-1,FNmsg_get("Default"))
counter%=1
ptr%=0
utf%=0
REPEAT
 SYS "Font_ListFonts",,Block%,ptr% OR (69<<16),255 TO ,,ptr%
 IF ptr%>-1 THEN
  PROCwimp_additem(EncMenu%,counter%,0,-1,$Block%)
  IF $Block%="UTF8" THEN utf%=counter%
  counter%+=1
 ENDIF
UNTIL ptr%=-1
PROCwimp_additem(EncMenu%,counter%-1,128,-1,$Block%)
Encodings%=counter%
REM If a 'UTF8' encoding exists, move it to item 1 (under
REM 'Default') and put a dotted line under it
IF utf%>0 THEN
 FOR i%=utf%-1 TO 1 STEP -1
  $(EncMenu%+28+((i%+1)*24)+12)=$(EncMenu%+28+(i%*24)+12)
 NEXT
 PROCwimp_additem(EncMenu%,1,2,-1,FNmsg_get("UTF8"))
ENDIF

REM Get mode info for font redrawing
PROCwimp_getmodeinfo
ENDPROC

DEF FNwimp_opentemplates (path$)
REM Opens a Template file and creates buffer for total indirected data
LOCAL size%,largest%,next%,indarea%,indsize%,totalindsize%
SYS "Wimp_OpenTemplate",,path$
largest%=0:totalindsize%=0
$WindowName%="*"
SYS "Wimp_LoadTemplate",,0,,,,WindowName%,0 TO ,size%,indsize%,,,,next%
IF size%>largest% THEN largest%=size%
IF indsize%>0 THEN totalindsize%=totalindsize%+indsize%
WHILE next%<>0
 $WindowName%="*"
 SYS "Wimp_LoadTemplate",,0,,,,WindowName%,next% TO ,size%,indsize%,,,,next%
 IF next%<>0 THEN
  IF size%>largest% THEN largest%=size%
  IF indsize%>0 THEN totalindsize%=totalindsize%+indsize%
 ENDIF
ENDWHILE
DIM indarea% totalindsize%+16
DIM WindowBlock% largest%+16
WindowIndPtr%=indarea%
=indarea%

DEF FNwimp_loadtemplate (name$,indarea%)
REM Loads a window definition from a Template file
LOCAL indsize%
$WindowName%=name$
SYS "Wimp_LoadTemplate",,0,,,,WindowName% TO ,,indsize%
SYS "Wimp_LoadTemplate",,WindowBlock%,WindowIndPtr%,WindowIndPtr%+indsize%,-1,WindowName% TO ,,WindowIndPtr%
WindowBlock%!64=1
SYS "Wimp_CreateWindow",,WindowBlock% TO window%
=window%

DEF PROCwimp_makemenu (menu%,title$)
REM Create a menu
$(menu%)=title$
menu%!12=&00070207:menu%!16=80:menu%!20=44:menu%!24=0
ENDPROC

DEF PROCwimp_additem (menu%,item%,flags%,link%,text$)
REM Add a menu item
menu%!(28+(item%*24))=flags%:menu%!(28+(item%*24)+4)=link%
menu%!(28+(item%*24)+8)=&07000021:$(menu%+28+(item%*24)+12)=text$
ENDPROC

DEF PROCwimp_poll
REM Main poll loop
LOCAL reason%,taken%
SYS "Wimp_Poll",PollMask%,Block% TO reason%
CASE reason% OF
 WHEN 0:PROCwimp_null
 WHEN 1:IF Block%!0=CharsPane% THEN PROCcharswin_redraw
 WHEN 2:PROCwimp_openwindow(Block%!0,Block%!4,Block%!8,Block%!12,Block%!16,Block%!28)
 WHEN 3:PROCwimp_closewindow(Block%!0)
 WHEN 4:PROCwimp_pointerleaving(Block%!0)
 WHEN 5:PROCwimp_pointerentering(Block%!0)
 WHEN 6:PROCwimp_click(Block%!0,Block%!4,Block%!8,Block%!12,Block%!16)
 WHEN 8:IF Block%!0=ChoiceWin% THEN taken%=FNchoicewin_keypress(Block%!24)
   IF NOT taken% THEN SYS "Wimp_ProcessKey",Block%!24
  ENDIF
 WHEN 9:PROCwimp_menuselect(Block%)
 WHEN 17,18:PROCwimp_messages(Block%)
ENDCASE
ENDPROC

DEF PROCwimp_null
REM Check for keypresses and pointer movements during null events
LOCAL c%,x%,y%
SYS "Wimp_GetPointerInfo",,Block%
x%=Block%!0
y%=Block%!4
c%=FNchars_getchar(x%,y%)
IF c%<>OldChar% THEN
 PROCwimp_seticontext(CharsWin%,7,FNchars_getinfo(c%))
 OldChar%=c%
ENDIF
IsDown%=INKEY KEY_SHIFT%
IF IsDown% AND NOT WasDown% THEN
 PROCchars_transmit(x%,y%)
ENDIF
WasDown%=IsDown%
ENDPROC

DEF PROCwimp_openwindow (window%,xmin%,ymin%,xmax%,ymax%,behind%)
REM Open a window
IF window%=CharsWin% THEN
 Block%!0=CharsPane%
 SYS "Wimp_GetWindowState",,Block%
 Block%!4=xmin%+WIN_MARGIN%
 Block%!8=ymax%-(WIN_TOOLBAR%-WIN_SMALL%)
 Block%!12=xmin%+WIN_MARGIN%+WIN_WIDTH%
 Block%!16=ymax%-WIN_TOOLBAR%
 Block%!28=behind%
 SYS "Wimp_OpenWindow",,Block%
ENDIF
Block%!0=window%
Block%!4=xmin%
Block%!8=ymin%
Block%!12=xmax%
Block%!16=ymax%
REMBlock%!20=xs%
REMBlock%!24=ys%
IF window%=CharsWin% THEN Block%!28=CharsPane% ELSE Block%!28=behind%
SYS "Wimp_OpenWindow",,Block%
ENDPROC

DEF PROCwimp_closewindow (window%)
REM Handle open window requests
Block%!0=window%
SYS "Wimp_CloseWindow",,Block%
IF Block%!0=CharsWin% THEN
 Block%!0=CharsPane%
 SYS "Wimp_CloseWindow",,Block%
ENDIF
ENDPROC

DEF PROCwimp_pointerleaving (window%)
REM Handle the pointer leaving CharsPane%
IF window%=CharsPane% THEN
 PollMask%=PollMask% OR (1<<0)
 PROCwimp_seticontext(CharsWin%,6,"")
 PROCwimp_seticontext(CharsWin%,7,"")
ENDIF
ENDPROC

DEF PROCwimp_pointerentering (window%)
REM Handle the pointer entering CharsPane%
IF window%=CharsPane% THEN
 PollMask%=PollMask% AND NOT (1<<0)
 WasDown%=INKEY KEY_SHIFT%
ENDIF
ENDPROC

DEF PROCwimp_click (xmouse%,ymouse%,button%,window%,icon%)
REM Handle mouse clicks
CASE window% OF
 WHEN Iconbar%:PROCiconbar_click(button%)
 WHEN ChoiceWin%:PROCchoicewin_click(icon%,button%)
 WHEN CharsPane%:PROCcharswin_click(CharsPane%,xmouse%,ymouse%,button%,icon%)
 WHEN CharsWin%:PROCcharswin_click(CharsWin%,xmouse%,ymouse%,button%,icon%)
ENDCASE
ENDPROC

DEF PROCwimp_menuselect (Block%)
REM Handle menu selections
LOCAL font$,flags%
CASE MenuOpen% OF
 WHEN IconMenu%:
  IF Block%!0=1 THEN OSCLI "Filer_Run <Chars$Dir>.!Help"
  IF Block%!0=2 THEN PROCchoicewin_init
  IF Block%!0=3 THEN AppQuit%=TRUE
 WHEN FontMenu%:
  SYS "XFont_DecodeMenu",,FontMenu%,Block%,STRING$(200,CHR$0),200 TO ,,,font$;flags%
  IF flags% AND 1 THEN font$=SysFont$
  PROCchars_changefont(font$)
 WHEN EncMenu%:
  PROCchars_changeenc(Block%)
 WHEN CatMenu%:
  PROCheap_freeblock(Lookup%)
  PROCchars_changecat(Block%!0)
ENDCASE
SYS "Wimp_GetPointerInfo",,Block%
IF Block%!8 AND 1 THEN
 CASE MenuOpen% OF
  WHEN FontMenu%:PROCcharswin_click(CharsWin%,0,0,4,1)
  WHEN CatMenu%:PROCcharswin_click(CharsWin%,0,0,4,5)
  WHEN EncMenu%:PROCcharswin_click(CharsWin%,0,0,4,3)
  OTHERWISE:SYS "Wimp_CreateMenu",,MenuOpen%,!Block%-64,Block%!4
 ENDCASE
ENDIF
ENDPROC

DEF PROCwimp_messages (Block%)
REM Handle user messages
LOCAL file%,len%,handle%,ref%,text$,char%
CASE Block%!16 OF
 WHEN MESSAGE_QUIT%:
  AppQuit%=TRUE
 WHEN MESSAGE_SAVEDESKTOP%:
  file%=Block%!20
  SYS "XOS_ReadVarVal","Chars$Dir",Block%,256,0,3 TO ,,len%
  Block%?len%=13
  BPUT#file%,"Run "+$(Block%)
 WHEN MESSAGE_MODECHANGE%:
  PROCwimp_getmodeinfo
 WHEN MESSAGE_HELPREQUEST%:
  text$="":handle%=Block%!4:ref%=Block%!8
  CASE Block%!32 OF
   WHEN CharsPane%:
    char%=FNchars_getchar(Block%!20,Block%!24)
    text$=FNmsg_getargs("CHelp",FNchars_getinfo(char%),"")
    IF INSTR(text$,")")=0 THEN text$="":REM Not key equivalent from getinfo
   WHEN CharsWin%:
    CASE Block%!36 OF
     WHEN 0,1,2,3,4,5:text$=FNmsg_get("CW"+STR$Block%!36)
    ENDCASE
   WHEN ChoiceWin%:
    CASE Block%!36 OF
     WHEN 2,3,4,5:text$=FNmsg_get("CH"+STR$Block%!36)
    ENDCASE
   WHEN -2:text$=FNmsg_get("IHelp")
  ENDCASE
  IF text$<>"" THEN
   Block%!0=((20+LENtext$+1)+3) AND NOT 3
   Block%!12=ref%
   Block%!16=MESSAGE_HELPREPLY%
   $(Block%+20)=text$:Block%?(20+LENtext$)=0
   SYS "Wimp_SendMessage",17,Block%,handle%
  ENDIF
ENDCASE
ENDPROC

DEF PROCwimp_seticontext (window%,icon%,text$)
REM Set the text label in an icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
$(Block%!28)=text$
Block%!8=0:Block%!12=0
SYS "Wimp_SetIconState",,Block%
ENDPROC

DEF PROCwimp_shadeicon (window%,icon%,action%)
REM Shades icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
CASE action% OF
 WHEN FALSE:IF (Block%!24 AND (1<<22)) THEN
   Block%!8=0:Block%!12=1<<22
   SYS "Wimp_SetIconState",,Block%
  ENDIF
 WHEN TRUE:IF NOT(Block%!24 AND (1<<22)) THEN
   Block%!8=1<<22:Block%!12=1<<22
   SYS "Wimp_SetIconState",,Block%
  ENDIF
ENDCASE
ENDPROC

DEF PROCwimp_selecticon (window%,icon%,action%)
REM Selects icon
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
CASE action% OF
 WHEN FALSE:IF (Block%!24 AND (1<<21)) THEN
   Block%!8=0:Block%!12=1<<21
   SYS "Wimp_SetIconState",,Block%
  ENDIF
 WHEN TRUE:IF NOT(Block%!24 AND (1<<21)) THEN
   Block%!8=1<<21:Block%!12=1<<21
   SYS "Wimp_SetIconState",,Block%
  ENDIF
ENDCASE
ENDPROC

DEF FNwimp_getselect (window%,icon%)
REM Returns TRUE if icon is selected, FALSE if not
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
IF (Block%!24 AND (1<<21)) THEN =TRUE ELSE =FALSE

DEF PROCwimp_openiconmenu (window%,icon%,menu%)
REM Opens a menu from a dropdown menu button
LOCAL x%,y%
Block%!0=window%
SYS "Wimp_GetWindowState",,Block%
x%=Block%!4:y%=Block%!16
Block%!0=window%:Block%!4=icon%
SYS "Wimp_GetIconState",,Block%
x%=x%+(Block%!16):y%=y%+Block%!20
SYS "Wimp_CreateMenu",,menu%,x%,y%
MenuOpen%=menu%
ENDPROC

DEF PROCwimp_settick (menu%,item%,type%)
REM Sets a menu item's tick
LOCAL menuptr%
menuptr%=menu%+28+(item%*24)
IF type%=TRUE THEN menuptr%?0=menuptr%?0 OR (1<<0)
IF type%=FALSE THEN menuptr%?0=menuptr%?0 AND NOT (1<<0)
ENDPROC

DEF PROCwimp_getmodeinfo
REM Read current screen mode information
SYS "OS_ReadModeVariable",-1,4 TO,,XEig%
SYS "OS_ReadModeVariable",-1,5 TO,,YEig%
ENDPROC

DEF PROCwimp_error (cause$)
REM Report fatal errors and close
SYS "Wimp_DragBox",,-1
!ErrBlock%=ERR
IF cause$="" THEN
 cause$=REPORT$+" at line "+STR$ERL+CHR$(13)
ELSE
 causes$=FNmsg_get(cause$)
ENDIF
$(ErrBlock%+4)=cause$
SYS "Wimp_ReportError",ErrBlock%,1,FNmsg_get("ErrApp")
PROCchars_tidyup
ENDPROC

DEF PROCwimp_alert (alert$)
REM Reports non-fatal alerts
SYS "Wimp_DragBox",,-1
!ErrBlock%=ERR
$(ErrBlock%+4)=FNmsg_get(alert$)
SYS "Wimp_ReportError",ErrBlock%,1,FNmsg_get("ErrApp")
ENDPROC

REM-----------------------------------------------------------------------------

REM // Msg //

REM-----------------------------------------------------------------------------

DEF PROCmsg_load (name$)
REM Loads Message file
LOCAL ERROR
ON ERROR LOCAL RESTORE ERROR:ERROR 3,REPORT$
DIM MessText% 255                      :REM Messages buffer
MessType%=0                            :REM Message type
MessDesc%=0
SYS "MessageTrans_FileInfo",,name$
SYS "OS_Module",6,,,17+LEN(name$) TO ,,MessDesc%
$(MessDesc%+16)=name$
SYS "MessageTrans_OpenFile",MessDesc%,MessDesc%+16
ENDPROC

DEF PROCmsg_close
REM Close message file and free memory
SYS "XMessageTrans_CloseFile",MessDesc%
SYS "XOS_Module",7,,MessDesc%
ENDPROC

DEF FNmsg_get (tag$)
REM Retrieves a Message string from a tag
=FNmsg_getargs(tag$,"","")

DEF FNmsg_getargs (tag$,arg1$,arg2$)
REM Retrieves a Message string with arguments
LOCAL flags%,args%
SYS "XMessageTrans_Lookup",MessDesc%,tag$,MessText%,255,arg1$,arg2$ TO ,,,args%;flags%
IF flags% AND 1 THEN args%=0
MessText%?args%=13
=$MessText%

REM-----------------------------------------------------------------------------

REM // Heap //

REM-----------------------------------------------------------------------------

DEF PROCheap_init
REM Initialises global variables
Heap%=0:HeapSize%=0
SYS "OS_ReadMemMapInfo" TO HeapPage%
HeapAppSize%=HIMEM-&8000
HeapError%=FALSE
ENDPROC

DEF PROCheap_newheap (size%)
REM Sets up a new heap
PROCheap_getmemory (size%,0)
IF NOT HeapError% THEN
 Heap%=HIMEM
 SYS "XOS_Heap",0,Heap%,,HeapSize%
ENDIF
ENDPROC

DEF FNheap_newblock (size%)
REM Creates a new block and returns block pointer
LOCAL pointer%,free%,newblock%
HeapError%=FALSE
IF size%=0 THEN HeapError%=TRUE
IF Heap%=0 THEN PROCheap_newheap(size%+16)
IF NOT HeapError% THEN
 SYS "XOS_Heap",1,Heap% TO ,,free%
 IF free%<size% THEN PROCheap_getmemory(size%-free%,1)
 IF NOT HeapError% THEN
  SYS "XOS_Heap",2,Heap%,,size% TO ,,pointer%
 ENDIF
ENDIF
IF HeapError% THEN newblock%=0 ELSE newblock%=pointer%
=newblock%

DEF FNheap_resizeblock (pointer%,change%)
REM Resizes a block and returns a new pointer
LOCAL flag%
HeapError%=0
REPEAT
 SYS "XOS_Heap",4,Heap%,pointer%,change% TO ,,pointer%;flag%
 IF flag% AND 1 THEN PROCheap_getmemory(HeapPage%,1)
UNTIL (flag% AND 1)=0 OR HeapError%=TRUE
IF NOT HeapError% THEN
 IF change%<0 THEN PROCheap_losememory
ENDIF
=pointer%

DEF PROCheap_getmemory (memory%,alter%)
REM Claims memory and extends WimpSlot
LOCAL new%
SYS "Wimp_SlotSize",HeapAppSize%+memory%,-1 TO new%
IF new%<HeapAppSize%+memory% THEN
 HeapError%=TRUE
 SYS "Wimp_SlotSize",HeapAppSize%,-1
ELSE
 IF alter% THEN SYS "XOS_Heap",5,Heap%,,new%-HeapAppSize%
 HeapSize%=new%+&8000-HIMEM
 HeapAppSize%=new%
ENDIF
ENDPROC

DEF FNheap_getblocksize (pointer%)
REM Returns a block's size
LOCAL size%
SYS "XOS_Heap",6,Heap%,pointer% TO ,,,size%
size%-=8
=size%

DEF PROCheap_losememory
REM Returns memory and shrinks WimpSlot
LOCAL change%,flag%
REPEAT
 SYS "XOS_Heap",5,Heap%,,-HeapPage% TO ,,,change%;flag%
 IF flag% AND 1 THEN
  SYS "XOS_Heap",5,Heap%,,change%
 ELSE
  SYS "Wimp_SlotSize",HeapAppSize%-HeapPage%,-1
  HeapAppSize%-=HeapPage%:HeapSize%-=HeapPage%
 ENDIF
UNTIL flag% AND 1
ENDPROC

DEF PROCheap_freeblock (pointer%)
REM Deletes a block and frees memory
SYS "XOS_Heap",3,Heap%,pointer%
PROCheap_losememory
ENDPROC
@


1.6
log
@Fix bug returning incorrect character based on mouse position
Detail:
  Clicking right of the last character would result in the first character on the next row being selected. Now returns nothing
Admin:
  Tested on RPCEmu 0.8.15 using RISC OS 5.23
  Submission from Alan Robertson.

Version 2.03. Tagged as 'Chars-2_03'
@
text
@d205 1
a205 2
LOCAL len%,i%,bit%,data%,dfhandle%,df$
dfhandle%=0
d207 1
a207 4
FOR i%=0 TO 3
 IF (data% AND (1<<i%+1)) THEN bit%=1 ELSE bit%=0
 dfhandle%=dfhandle%+(bit%*(2^i%))
NEXT i%
d210 2
a211 1
  SYS "OS_ReadVarVal","Wimp$Font",Block%,255,0,3 TO ,,len%
@


1.5
log
@Internationalisation and terminology changes
Detail:
  When generating the encoding menu the terms "Default" and "UTF8" were looked up via the Messages file, however the selection logic and update of the display field used hardwired English. Now, the internal variables Alphabet$ and Encoding$ are English but when required for display are always looked up.
  Now that works, use the preferred term "UTF-8" per Unicode consortium and Style Guide page 133.
Admin:
  From review of User Guide chapter.

Version 2.02. Tagged as 'Chars-2_02'
@
text
@d238 1
@


1.4
log
@Fix RAM exhaustion with many fonts, and choices inversion
Detail:
  Line 1012 - Use the heap to claim/extend space for fonts. Fixes wimpslot problem with many installed fonts.
  Line 914-916 - Invert the choices file keywords to match the variables they set.
  Minor - Remove SWI constants, since the build system (Squish) gets these from swis.h. Don't listen for MESSAGE_HELPREPLY%. Change IconHandle to an integer. Use OS_ReadModeVariable to get eigenvalues since there's only 2 it's not worth constructing a list for OS_ReadVduVariables.
Admin:
  Submission from Chris Wraight, with minor edits.

Version 2.01. Tagged as 'Chars-2_01'
@
text
@d529 1
d715 1
a715 1
  PROCwimp_seticontext(CharsWin%,2,Encoding$)
d721 5
a725 1
  IF Encoding$="Glyph" THEN e$="Default" ELSE e$=Encoding$
@


1.3
log
@Add support for selecting from Unicode fonts
Detail:
  Changed !RunImage to support working with the Unicode Font Manager, and revised !Help.
  Replacement templates, and revised Messages for the extra menus and window layout.
  As this component also features in the disc image (RO350Hook) it also degrades on earlier Font Managers.
Admin:
  Submission from Chris Wraight.
  To get the code point names while hovering with the mouse, Unicode-0_35 should be updated for the CharNames table.

Version 2.00. Tagged as 'Chars-2_00'
@
text
@a71 2
XFONT_PAINT%=&60086                    :REM SWI constants
XFONT_SCANSTR%=&600A1                  :REM SWI constants
a94 4
DIM InputVars 3*4-1,OutputVars 2*4-1   :REM Screen Eigen factors
InputVars!0=4
InputVars!4=5
InputVars!8=-1
a106 1
 FONT_ENUMCHARS%=&400A9                :REM SWI constant
d600 1
a600 1
  SYS FONT_ENUMCHARS%,FontHandle%,code% TO ,next%,intcode%
d809 1
a809 1
    SYS XFONT_SCANSTR%,,CharDef%,ssflags%,1000000,1000000,,,4 TO e%,,,width%;flags%
d811 1
a811 1
    SYS XFONT_PAINT%,,CharDef%,fpflags%,cx%-(width% DIV 800)+(CHAR_XBOX% DIV 2),cy% TO e%;flags%
d904 2
a906 2
  IF Option_DesktopFont% THEN val$="Yes" ELSE val$="No"
  BPUT#file%,"Open:"+val$
d957 2
a958 3
Block%!8=MESSAGE_HELPREPLY%
Block%!12=MESSAGE_MODECHANGE%
Block%!16=MESSAGE_QUIT%
d975 1
a975 1
SYS "Wimp_CreateIcon",,Block% TO IconHandle
d1001 4
a1004 2
DIM FontMenu% size%
DIM FontInd% indsize%
d1319 2
a1320 2
SYS "OS_ReadVduVariables",InputVars,OutputVars
XEig%=OutputVars!0:YEig%=OutputVars!4
@


1.2
log
@Fix for menu opening position
Chars took it upon itself to open the font menu at x-102,y+64 rather than x-64,y+0 like the Style Guide says.
Also fixed misreported buffer size to OS_ReadVarVal - moot since the next link uses the $ operator to pick up the string which is limited to 256 anyway.

Version 1.25. Tagged as 'Chars-1_25'
@
text
@d18 1
a18 1
REM Copyright © Acorn Computers 1989,1990,1991
d20 155
a174 1
DIM q% 255, C$(8), CharDef 8, buffer% &200
d176 116
a291 3
DIM wid% 1024 : REM added to allow centring of font chars in the grid
              : REM if curf% > -1 then each wid%!(4*i%) holds the width in millipoints of character code i.
FOR i% = 0 TO 255: wid%!i% = 0: NEXT i%
d293 13
a305 1
PROCms_load("Chars:Messages")
d307 28
a334 5
LM%=16:RM%=16:BM%=16:TM%=16
MXSP%=24:MYSP%=44
FOR X%=0 TO 31
 IF X%<=15 THEN C$(0)+=FNCH(X%,0) ELSE C$(8)+=FNCH(X%,0)
 FOR Y%=1 TO 7:C$(Y%)+=FNCH(X%,Y%):NEXT
d336 1
a336 5
R$=CHR$23+CHR$32+STRING$(8,CHR$0):C$(3)+=R$:C$(8)+=R$
font$=$sysfont%:curf%=-1
HotKey%=-1:REM Shift key
!q%=10:q%!4=&502:q%!8=&400c1:q%!12=0
SYS"Wimp_Initialise",300,&4B534154,FNms_1("Tsk",""),q% TO wimpversion%,TaskHandle
d338 46
a383 19
SYS"Wimp_OpenTemplate",,"Chars:Templates"
LOCAL ERROR
ON ERROR RESTORE ERROR:SYS"Wimp_CloseTemplate":PROCms_end:ERROR ERR, REPORT$
SYS"Wimp_LoadTemplate",,q%+4,0,0,-1,"Characters",0
RESTORE ERROR
SYS"Wimp_CloseTemplate"

DIM InputVars 3*4-1, OutputVars 2*4-1
InputVars!0=4:InputVars!4=5:InputVars!8=-1:REM XEigFactor, YEigFactor
PROCReadModeVars

q%!12=q%!4+LM%+31*MXSP%+16+RM%
q%!8=q%!16-TM%-7*MYSP%-32-BM%
SYS"Wimp_CreateWindow",,q%+4 TO WindowHandle
!q%=WindowHandle:q%!28=-1
PROCOpenWindow
Null=0:Redraw=1:Open=2:Close=3:PointerLeaving=4:PointerEntering=5:MouseChange=6
MenuSelect=9:MessageA=17:MessageB=18
PollFlags=1<<Null
a384 14
HIMEM=END+1024:END=HIMEM+8*1024:HIMEM=END+3072
menudata%=HIMEM
REPEAT
 SYS "Wimp_Poll",PollFlags,q% TO reason
 CASE reason OF
 WHEN Null: PROCCheckHotKey
 WHEN Redraw: PROCRedrawWindow
 WHEN Open: PROCOpenWindow
 WHEN Close: PROCCloseWindow
 WHEN PointerLeaving: PROCPointerLeaving
 WHEN PointerEntering: PROCPointerEntering
 WHEN MouseChange: PROCCheckMouse(!q%,q%!4,q%!8,q%!12,q%!16,q%!20)
 WHEN MenuSelect: PROCdomenu(FALSE)
 WHEN MessageA, MessageB: PROCMessage
d386 2
a387 2
UNTIL FALSE
END
d389 115
a503 5
DEFPROCCheckHotKey
IsDown%=INKEY HotKey%
IF IsDown% AND NOT WasDown% THEN
 SYS "Wimp_GetPointerInfo",,q%
 PROCDoChar
a504 1
WasDown%=IsDown%
d507 14
a520 6
DEFPROCRedrawWindow
LOCAL ch%,F%
SYS "Wimp_RedrawWindow",,q% TO flag%
IFcurf%>-1 THEN
 SYS "XFont_SetFont",curf%:SYS "Wimp_SetFontColours",,0,7 TO ;F%
 IF F% AND 1 PROCfonterror(FALSE): ENDPROC
d522 11
a532 1
 VDU23,17,7,4,MXSP%>>XEIG%;MYSP%>>YEIG%;0;
d534 5
a538 14
WHILE flag%
 StartX%=q%!4+LM%-q%!20:StartY%=q%!16-TM%-q%!24
 IFcurf%>-1 THEN
  ox0%=(q%!28-StartX%)DIVMXSP%:IFox0%>31 ox0%=31
  ox1%=(q%!36-StartX%)DIVMXSP%:IFox1%>31 ox1%=31
  FOR Y%=1 TO 7:CY%=StartY%-24-Y%*MYSP%
   IF CY%<q%!40+MYSP% AND CY%+MYSP%>=q%!32 THEN
    FORX%=ox0%TOox1%
      ch% = Y%*32+X%
      SYS "XFont_Paint",,CHR$(ch%),&14,StartX%+X%*MXSP% + MXSP%DIV2 -(wid%!(4*ch%) DIV 800),CY% TO ;F%
      IF F% AND 1 PROCfonterror : ENDPROC
    NEXT
   ENDIF
  NEXT
d540 1
a540 5
 FOR Y%=0 TO 7:CY%=StartY%-Y%*MYSP%
  IF CY%<q%!40+31 AND CY%>=q%!32 THEN
   MOVE StartX%,CY%:PRINT C$(Y%);:IF Y%=0 PRINT C$(8);
  ENDIF
 NEXT
a541 3
 SYS "Wimp_GetRectangle",,q% TO flag%
ENDWHILE
IF curf%>-1 THEN
d543 12
a554 1
 VDU23,17,7,4,16>>XEIG%;32>>YEIG%;0;
d556 77
d635 212
a846 2
DEFPROCOpenWindow
SYS"Wimp_OpenWindow",,q%
d849 5
a853 4
DEFPROCCloseWindow
IFcurf%>-1 SYS "XFont_LoseFont",curf%:curf%=-1
PROCms_end
SYS"Wimp_CloseDown"
d857 20
a876 2
DEFPROCPointerLeaving
PollFlags=PollFlags OR (1<<Null):REM No more null events
d879 14
a892 3
DEFPROCPointerEntering
PollFlags=PollFlags AND NOT (1<<Null):REM Enable null events
WasDown%=INKEY HotKey%
d895 21
a915 6
DEFPROCMessage
CASE q%!16 OF
WHEN 0:PROCCloseWindow
WHEN 10: PROCsave_desktop_state
WHEN &400C1:PROCReadModeVars
WHEN &502:PROCDoHelp
d919 117
a1035 8
DEFFNCH(X%,Y%)
C%=X%+Y%*32
IF C%<32 OR C%=127 THEN
 IF C%=127 THEN C%=ASC"?" ELSE C%=C% OR ASC"@@"
 CharDef?0=C%:SYS"OS_Word",10,CharDef
 C$=CHR$23+CHR$32
 FOR I%=1 TO 8
  C$+=CHR$(CharDef?I% EOR &FF)
d1037 128
a1164 3
 C$+=" "
ELSE
 C$=CHR$C%
d1166 1
a1166 1
=C$
d1168 5
a1172 8
DEFPROCReadModeVars
LOCAL F%
SYS"OS_ReadVduVariables",InputVars,OutputVars
XEIG%=OutputVars!0:YEIG%=OutputVars!4
IFcurf%>-1 THEN
 SYS"XFont_LoseFont",curf%
 SYS"XFont_FindFont",,a$,13*16,15*16 TO curf%; F%
 IF F% AND 1 PROCfonterror: ENDPROC
d1176 36
a1211 5
DEFPROCCheckMouse(mousex%,mousey%,b%,handle%,icon%,ob%)
IF b% AND 4 THEN
 PROCDoChar
ELSE
 IF b% AND 2 THEN PROCpopupmenu
d1215 48
a1262 10
DEF PROCpopupmenu
LOCAL A%
SYS "Hourglass_On"
SYS "Font_ListFonts",,0,7<<19,,0,,FNf(font$) TO ,,,size1%,,size2%
SYS "Wimp_SlotSize",menudata%+size1%+size2%-&8000,-1 TO A%
IF A%+&8000<menudata%+size1%+size2% THEN ERROR 224,FNms_1("MenuSpc","")
menustrings%=menudata%+size1%
SYS "Font_ListFonts",,menudata%,7<<19,size1%,menustrings%,size2%,FNf(font$)
SYS "Hourglass_Off"
A%=menudata%?12
d1264 15
a1278 1
REM $menudata% = LEFT$(FNms_1("Menu",""),12)
d1280 14
a1293 4
REM menudata%!(28+12)=sysfont%
REM menudata%!16 = FNmax(menudata%!16,FNmax(LEN$menudata%-3,LEN$sysfont%)*16+12)
REMmenudata%?12=A%
SYS "Wimp_CreateMenu",,menudata%,mousex%-64,mousey%
d1296 18
a1313 1
DEF FNmax(A%,B%) IF A%>B% THEN =A% ELSE =B%
d1315 7
a1321 1
DEF FNf(font$) IF font$=$sysfont% THEN =1 ELSE =font$
d1323 5
a1327 2
REM ** fake% = TRUE means that this call is not really in response
REM ** to a menu hit.  We assume sysfont and ignore button 3 in this case.
d1329 6
a1334 4
DEF PROCdomenu(fake%)
LOCAL i%,w%,F%
IF fake% OR !q%=0 THEN
  a$=$sysfont%
d1336 1
a1336 19
  SYS "Font_DecodeMenu",,menudata%,q%,STRING$(200,CHR$0),200 TO ,,,a$
ENDIF
IFa$<>"" AND a$<>font$ THEN
  IFcurf%>-1 SYS "XFont_LoseFont",curf%:curf%=-1
  font$=a$
  IFa$<>$sysfont% THEN
    SYS "XFont_FindFont",,a$,13*16,15*16 TO curf%; F%
    IF F% AND 1 PROCfonterror: ENDPROC
    REM set up the wid% array
    SYS "Font_SetFont",curf%:SYS "Wimp_SetFontColours",,0,7
    FOR i% = 32 TO 255
      SYS "Font_StringWidth",,CHR$(i%),1000000,1000000,-1,1 TO ,,w%
      wid%!(4*i%)=w%
    NEXT i%
  ENDIF
  SYS "Wimp_ForceRedraw",WindowHandle,0,-1024,1280,0
ENDIF
IF NOT fake% THEN
  SYS "Wimp_GetPointerInfo",,q%:IFq%?8AND1 PROCpopupmenu
d1338 62
d1402 6
a1407 4
DEFPROCDoChar
IF q%!12=WindowHandle THEN
 Char%=FNCoordsToChar(q%!0,q%!4)
 IF Char%<>-1 THEN SYS"Wimp_ProcessKey",Char%
d1411 11
a1421 8
DEFPROCDoHelp
MES$=""
HisTaskHandle%=q%!4
HisRef%=q%!8
IF q%!32=WindowHandle THEN
 Char%=FNCoordsToChar(q%!20,q%!24)
 IF Char%<>-1 THEN
  MES$=FNms_2("Help",STR$Char%,FNH(Char%))
d1423 24
d1448 3
a1450 1
  IF wimpversion%>=218 AND q%!36<>-1 THEN MES$=FNms_1("MH","")
a1451 33
q%!0=((20+LENMES$+1)+3)ANDNOT3
q%!12=HisRef%
q%!16=&503
$(q%+20)=MES$
q%?(20+LENMES$)=0
SYS"Wimp_SendMessage",MessageA,q%,HisTaskHandle%
ENDPROC

DEFFNCoordsToChar(MouseX%,MouseY%)
!q%=WindowHandle
SYS "Wimp_GetWindowState",,q%
YOff%=(q%!16-TM%-q%!24+((MYSP%-32)>>1)-MouseY%)DIV MYSP%
Char%=-1
IF YOff%>=0 AND YOff%<=7 THEN
 XOff%=(MouseX%-(q%!4+LM%-q%!20+((16-MXSP%)>>1)))DIV MXSP%
 IF XOff%>=0 AND XOff%<=31 THEN
  Char%=XOff%+YOff%*32
 ENDIF
ENDIF
=Char%

REM ** bodge alert
REM ** get here if a Font_ swi returns an error.  Force return to
REM ** system font with an error message.  We force any open menu shut
REM ** because we don't know whether to re-encode our own menu (it may
REM ** or may not be open -- can't tell!)

DEF PROCfonterror
LOCAL N$
N$=FNms_1("Tsk","")
SYS "XWimp_ReportError", FNms_1_error("FontErr","",999), 0, N$
SYS "Wimp_CreateMenu", -1
PROCdomenu(TRUE)
d1454 20
a1473 39
DEFFNH(X%)=RIGHT$("0"+STR$~X%,2)

DEF PROCms_load(name$)
SYS "MessageTrans_FileInfo",,name$
DIM ms_text% 256
SYS "OS_Module",6,,,17+LEN(name$) TO ,,ms_desc%
$(ms_desc%+16)=name$
SYS "MessageTrans_OpenFile",ms_desc%,ms_desc%+16
DIMsysfont% 28
$sysfont% = FNms_1("Font","")
ENDPROC

DEF PROCms_end
SYS "XMessageTrans_CloseFile",ms_desc%
SYS "XOS_Module",7,,ms_desc%
ENDPROC

DEF FNms_1(tag$,arg1$)
LOCAL L%
REM non-X version; let it blow out with default message if token not found
SYS "MessageTrans_Lookup",ms_desc%,tag$,ms_text%,256,arg1$ TO ,,,L%
ms_text%?L%=13
=$ms_text%

DEF FNms_2(tag$,arg1$,arg2$)
LOCAL L%
REM non-X version; let it blow out with default message if token not found
SYS "MessageTrans_Lookup",ms_desc%,tag$,ms_text%,256,arg1$,arg2$ TO ,,,L%
ms_text%?L%=13
=$ms_text%

REM returns an error block instead
DEF FNms_1_error(tag$,arg1$,errno%)
LOCAL L%
REM non-X version; let it blow out with default message if token not found
SYS "MessageTrans_Lookup",ms_desc%,tag$,ms_text%+4,252,arg1$ TO ,,,L%
ms_text%?(L%+4)=13
!ms_text% = errno%
=ms_text%
d1475 4
a1478 8
DEFPROCsave_desktop_state
LOCAL i%,l%
LOCAL ERROR
ON ERROR LOCAL q%!12=q%!8:SYS"Wimp_SendMessage",19,q%,q%!4:ENDPROC
i%=q%!20
SYS"XOS_ReadVarVal","Chars$Dir",buffer%,&200,0,3 TO ,,l%
buffer%?l%=13
BPUT#i%,"AddTinyDir "+$buffer%
a1479 1

@


1.1
log
@Reimport of source file
This is a text version of former !RunImage,ffb revision 4.1.1.1 so CVS can sensibly diff it.
Not tagged.
@
text
@d26 1
a26 1
PROCms_load("chars:messages")
d204 1
a204 1
SYS "Wimp_CreateMenu",,menudata%,mousex%-102,mousey%+64
d340 1
a340 1
SYS"XOS_ReadVarVal","Chars$Dir",buffer%,1024,0,3 TO ,,l%
@


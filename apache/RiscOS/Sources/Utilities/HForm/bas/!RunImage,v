head	4.21;
access;
symbols
	HForm-2_75:4.21
	HForm-2_74:4.20
	HForm-2_73:4.19
	HForm-2_72:4.18
	HForm-2_71:4.17
	HForm-2_70:4.16
	HForm-2_69:4.15
	HForm-2_68:4.14
	HForm-2_67:4.14
	HForm-2_66:4.13
	HForm-2_65:4.13
	HForm-2_64:4.13
	HForm-2_63:4.12
	HForm-2_62:4.12
	HForm-2_61:4.11
	HForm-2_60:4.10
	HForm-2_59:4.9
	HForm-2_58:4.8
	HForm-2_57:4.7
	HForm-2_56:4.7
	HForm-2_55:4.7
	HForm-2_54:4.6
	HForm-2_53:4.5
	HForm-2_52:4.4
	Ursula_merge:4.1.3.2.2.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.3.2.2.2
	Ursula_RiscPC:4.1.3.2.2.2.0.2
	sproven_HForm-2_51:4.1.3.2.2.3
	rthornb_UrsulaBuild-19Aug1998:4.1.3.2.2.2
	UrsulaBuild_FinalSoftload:4.1.3.2.2.2
	rthornb_UrsulaBuild-12Aug1998:4.1.3.2.2.2
	aglover_UrsulaBuild-05Aug1998:4.1.3.2.2.2
	rthornb_UrsulaBuild-29Jul1998:4.1.3.2.2.2
	rthornb_UrsulaBuild-22Jul1998:4.1.3.2.2.2
	rthornb_UrsulaBuild-15Jul1998:4.1.3.2.2.2
	rthornb_UrsulaBuild-07Jul1998:4.1.3.2.2.2
	rthornb_UrsulaBuild-17Jun1998:4.1.3.2.2.2
	rthornb_UrsulaBuild-03Jun1998:4.1.3.2.2.2
	rthornb_UrsulaBuild-27May1998:4.1.3.2.2.2
	rthornb_UrsulaBuild-21May1998:4.1.3.2.2.2
	rthornb_UrsulaBuild_01May1998:4.1.3.2.2.2
	sproven_2_50:4.1.3.2.2.2
	sproven_2_49:4.1.3.2.2.1
	Daytona:4.1.3.2.0.4
	Daytona_bp:4.1.3.2
	Ursula:4.1.3.2.0.2
	Ursula_bp:4.1.3.2
	RO_3_71:4.1.3.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	StrongARM:4.1.3;
locks; strict;
comment	@# @;


4.21
date	2017.12.09.21.39.50;	author jlee;	state Exp;
branches;
next	4.20;
commitid	zTFO3Py5z4TdogiA;

4.20
date	2017.07.06.14.43.06;	author rsprowson;	state Exp;
branches;
next	4.19;
commitid	Cc2LEqiNun876bYz;

4.19
date	2016.10.06.21.39.25;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	wtSK7JF6p291b8pz;

4.18
date	2016.02.28.21.48.10;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	pJSFASiulQMpkJWy;

4.17
date	2015.11.08.19.13.20;	author bavison;	state Exp;
branches;
next	4.16;
commitid	V7sbVRQCbURw4kIy;

4.16
date	2014.11.29.10.58.18;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	HdMUpcennrWfo40y;

4.15
date	2014.11.19.23.34.06;	author jballance;	state Exp;
branches;
next	4.14;
commitid	LKXxBmuer61sTQYx;

4.14
date	2013.10.04.20.03.09;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	z1QtjPpO6rkdW08x;

4.13
date	2013.03.29.08.42.56;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	S8LAalOrABNvfFJw;

4.12
date	2012.07.07.21.00.12;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	9fEpdWG9dDZwQFbw;

4.11
date	2012.04.22.01.32.04;	author bavison;	state Exp;
branches;
next	4.10;
commitid	ahVSjlYvQjlgPN1w;

4.10
date	2011.12.04.18.37.43;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	njUzLxvbldI40UJv;

4.9
date	2011.05.09.21.42.57;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	fCBSWIsahvscK3jv;

4.8
date	2011.02.12.21.49.00;	author jlee;	state Exp;
branches;
next	4.7;

4.7
date	2005.05.18.15.00.11;	author jballance;	state Exp;
branches;
next	4.6;

4.6
date	2003.01.21.15.42.18;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2003.01.08.13.45.15;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.06.13.36.04;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.06.13.29.51;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2002.11.06.13.25.53;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.06.04.03.57;	author nturton;	state Exp;
branches
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.3.1
date	96.11.06.04.03.57;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.06.18.07.57;	author kbracey;	state Exp;
branches
	4.1.3.2.2.1;
next	;

4.1.3.1.2.1
date	97.04.30.19.36.27;	author kbracey;	state Exp;
branches;
next	;

4.1.3.2.2.1
date	98.01.09.11.52.55;	author sproven;	state Exp;
branches;
next	4.1.3.2.2.2;

4.1.3.2.2.2
date	98.01.13.11.47.59;	author sproven;	state Exp;
branches;
next	4.1.3.2.2.3;

4.1.3.2.2.3
date	98.09.02.15.39.42;	author sproven;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.33.16;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.22.30.14;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.21
log
@Make SCSI formatting less confusing
Detail:
  bas/!RunImage - Change PROCGetDriveToUse to list SCSI devices in SCSIFS drive order, and ask for a SCSIFS drive number.
  Asking for a FS drive number makes SCSI formatting consistent with ADFS & SDFS formatting.
  Previously devices would have been listed in the order they were found by the SCSI bus enumeration code, and the code would have asked for an index into that list, without giving any indication of the SCSIFS drive numbers that are assigned to each device. Until, that is, the SCSIFS drive number is shown to the user at the final "Are you sure?" prompt, potentially resulting in confusion because in many cases the SCSIFS drive number won't match the device number assigned by HForm.
Admin:
  Tested on BB-xM with a mix of 'hard' and 'floppy' devices connected


Version 2.75. Tagged as 'HForm-2_75'
@
text
@REM >!HForm.!RunImage

REM Formatter for ST506, IDE, SCSI and SDIO discs
REM The formatter runs in one of three modes, selected at the
REM start by probing for which filing systems there are.

REM To provide internal consistency, all disc addresses are
REM represented as sector numbers - in a similar way to the
REM FileCore changes.  For backwards compatability, we can
REM convert the disc address at the last instant to be a
REM byte address.

REM Gratuitous use of an include file
#include "Global/FSNumbers.h"

ON ERROR: ON ERROR OFF: PRINT REPORT$;" at line ";ERL:END

REM Default closing status indicates a panic
*set HForm$EndStatus 1

#ifdef DEBUG
Verbose%=TRUE
#else
Verbose%=FALSE
#endif

REM Pointer into RMA, so set to zero up front for robustness on errors.
REM Also flag so we can default to English if Messages file fails.
msgs_file_desc%=0
msgs_file_open%=FALSE

ON ERROR PROCabort(REPORT$, 1)

PROCInit

PROCGetDriveToUse

PROCProbeDriveDetails

PROCGetShape

REM Check that disc not too big
IF NOT myfsisbig% THEN   
  IF (DiscSize2%<>0 OR (DiscSize% AND &E0000000)<>0) THEN
    PROCmessage_print_1("DiscSizeError",myfsname$)
    PROCfinish
  ENDIF
ENDIF
FormatFlag%=(FNChoose("Q01:","FormatOrInitChoose","FI","I")="F")
SoakStyle$=FNChoose("Q02:","SoakTestChoose","LSN", "N")
BootOpt$=FNChoose("BootOpt:","BootOptChoose","YN", "Y")

REM Determine if the Filecore version we have supports long filenames
IF FNPeekModuleVersion("FileCore")<=298 THEN
  BigDir%=FALSE
ELSE
  BigDir%=FNChoose("BigDir:","BigDirChoose","YN","Y")="Y"
ENDIF
IF NOT BigDir% THEN MaxLinkBits%=15

REM Pick a nice LFAU
IF NewMap% THEN
  Log2Alloc%=7
  IF Log2Alloc%<Log2SecSize% THEN Log2Alloc%=Log2SecSize%
  
  REM Check for sensible default
  Alloc%=2^Log2Alloc%:Log%=Log2Alloc%
  WHILE FNdoalloc(FALSE,Log%)=FALSE
    Alloc%=2^Log2Alloc%:Log%=Log2Alloc%
  ENDWHILE

  REM allocation size loop
  REPEAT
    REPEAT
      Alloc%=FNAsk("AllocUnitAsk",2^Log2Alloc%,SecSize%)
      ispow2%=(Alloc%<>0) AND ((Alloc% AND (Alloc%-1))=0)
      IF NOT ispow2% THEN PROCmessage_print_0("Pow2Alloc")
    UNTIL ispow2%
    Log%=7
    REPEAT
      Log%+=1
    UNTIL Alloc%=2^Log%
  UNTIL FNdoalloc(TRUE,Log%)
ENDIF

REM Last chance to bail out
PRINT
IF FNchoose_no_lookup("Q03:",FNmessage_lookup_2("SureChoose",myfsname$,STR$(Drive%)),"YN", "")="N" THEN PROCfinish

PROCDisableEscape
PROCMoanOp(Specify%,0,0,0)
IF FormatFlag% THEN
  PROCFormat
ENDIF
IF SoakStyle$<>"N" THEN
  SoakFlag%=(SoakStyle$="L")
  PROCVerify
ENDIF
PRINT
PROCStructure
PROCRestoreEscape

OSCLI("-"+myfsname$+"-%MOUNT :"+STR$Drive%)
OSCLI("-"+myfsname$+"-%FREE :"+STR$Drive%)
OSCLI("-"+myfsname$+"-%DISMOUNT :"+STR$Drive%)

REM All OK - return a successful status
*set HForm$EndStatus 0
PROCexit
:

REM *****************************************************************
DEF PROCInit
LOCAL DriveOffset%
LOCAL width%,sy%,ex%,ey%,fg%
LOCAL gotadfs%,gotscsifs%,infoptr%
DIM   modevar% 8

REM Opens the message file as its first action.
PROCopen_message_file("<HForm$Dir>.Messages")

VDU26,12,10,10,32:REM 2 lines down, 1 character in
width%=POS
PROCmessage_print_0("Banner")
PROCmessage_print_0("_Version")
width%=POS-width%
modevar%!0=155:REM Text foreground colour
modevar%!4=-1
SYS"OS_ReadVduVariables",modevar%,modevar%
GCOLmodevar%!0
SYS"OS_ReadModeVariable",-1,2 TO,,sy%:sy%=sy%+1
SYS"OS_ReadModeVariable",-1,4 TO,,ex%:ex%=8<<ex%
SYS"OS_ReadModeVariable",-1,5 TO,,ey%:ey%=8<<ey%
REM Draw a rectangle with half character border
RECTANGLE ex%/2,(sy%*ey%)-(ey%/2)-(2*ey%)-ey%,(width%+1)*ex%,2*ey%
PRINT''

xbit%=1<<17
autoreply$=FNreadvarval("HForm$Autoreply")

REM MaxLinkBits% sets the maximum value of idlen
REM For formatting with idlen>15, we have to allow the formatter
REM to select a larger idlen value.
IF FNPeekModuleVersion("FileCore")<=374 THEN
  MaxLinkBits%=19
ELSE
  MaxLinkBits%=21: REM no spare indirect disc address bits now
ENDIF
MaxFreeLinkBits%=15: REM maximum number of bits for a free link
MinLinkBits%=10
Log2ShareSize%=0:REM Unit of sharing
ShareSize%=1<<Log2ShareSize%:REM Sharing multiple
EndDefect%=1<<29:REM Terminator for defects up to 512MB
EndDefectBig%=1<<30:REM Terminator word for a second defect list

REM See which known filing systems are active
SYS"XOS_Module",18,"FileCore%ADFS" TO;F%
gotadfs%=(F%AND1)=0
SYS"XOS_Module",18,"FileCore%SCSI" TO;F%
gotscsifs%=(F%AND1)=0
SYS"XOS_Module",18,"FileCore%SDFS" TO;F%
gotsdfs%=(F%AND1)=0
IF(NOTgotadfs%)AND(NOTgotscsifs%)AND(NOTgotsdfs%) THEN
  PROCmessage_print_0("NoFSModule"):PROCfinish
ENDIF

availablefs$=""
IFgotadfs% availablefs$+="A"
IFgotscsifs% availablefs$+="S"
IFgotsdfs% availablefs$+="M"
IF LEN(availablefs$)>1 THEN
  REM Prompt for preferred
  IF INSTR(availablefs$,"S") defaultfs$="S" ELSE defaultfs$=LEFT$(availablefs$,1)
  chosenfs$=FNChoose("WhichFS:","WhichFS"+availablefs$,availablefs$,defaultfs$)
  gotadfs%=chosenfs$="A"
  gotscsifs%=chosenfs$="S"
  gotsdfs%=chosenfs$="M"
ENDIF

REM Now reduced to one from a list
IFgotadfs% THEN
  myfs%=fsnumber_adfs
  myfsname$="ADFS"
  myfsmodule$="ADFS"
  myfsmiscop%=&4024C
ENDIF
IFgotscsifs% THEN
  myfs%=fsnumber_SCSIFS
  myfsname$="SCSI"
  myfsmodule$="SCSIFS"
  myfsmiscop%=&4098C
ENDIF
IFgotsdfs% THEN
  myfs%=fsnumber_SDFS
  myfsname$="SDFS"
  myfsmodule$="SDFS"
  myfsmiscop%=&59049
ENDIF

REM Deduce its version
myfsversion%=FNPeekModuleVersion(myfsmodule$)

REM Filing system specific initialisation
CASE myfs% OF
  WHEN fsnumber_adfs:
    REM ADFS can have fixed number of drives or autodetected
    SYS"XOS_SWINumberFromString",,"ADFS_IDEDeviceInfo" TO;F%
    IF (F%AND1) THEN
      autodetected_ide%=FALSE
    ELSE
      autodetected_ide%=TRUE
    ENDIF

    REM Count candidates for formatting
    SYS"ADFS_Drives" TO,,HDiscs%:REM Hard only
  WHEN fsnumber_SCSIFS:
    REM Check vaguely modern
    IF myfsversion%<114 THEN
      PROCmessage_print_0("SCSIFSTooOld"):PROCfinish
    ENDIF

    REM SCSIFS with USB needs a minimum amount of RMA to mount a drive
    SYS"XOS_Module",5 TO,,,size%
    IFsize%<32*1024 THEN
      newsize%=(32*1024)-size%
      SYS"XOS_ChangeDynamicArea",1,newsize% TO;F%
      IF (F%AND1) THEN PROCmessage_print_0("NoSpareRMA"):PROCfinish
    ENDIF

    REM Count candidates for formatting
    SYS"SCSIFS_Drives" TO,F%,HDiscs%:HDiscs%+=F%:REM Hard+Floppy
  WHEN fsnumber_SDFS:
    SYS"SDFS_Drives" TO,F%,HDiscs%:HDiscs%+=F%:REM Hard+Floppy
ENDCASE

IF HDiscs%=0 PROCmessage_print_0("NoHardDiscs"):PROCfinish

REM See if sector addressing is possible
SYS xbit%+myfsmiscop%,6 TOinfoptr%
myfsisbig%=((!infoptr%)AND(1<<9))<>0
CASE myfs% OF
  WHEN fsnumber_adfs:
    IF myfsisbig% THEN
      myfsdiscop%=&4024D:REM ADFS_SectorDiscOp
    ELSE
      myfsdiscop%=&40240:REM ADFS_DiscOp
    ENDIF
  WHEN fsnumber_SCSIFS:
    IF myfsisbig% THEN
      myfsdiscop%=&4098D:REM SCSIFS_SectorDiscOp
    ELSE
      myfsdiscop%=&40980:REM SCSIFS_DiscOp
    ENDIF
  WHEN fsnumber_SDFS:
    IF myfsisbig% THEN
      myfsdiscop%=&5904A:REM SDFS_SectorDiscOp
    ELSE
      myfsdiscop%=&59040:REM SDFS_DiscOp
    ENDIF
ENDCASE

ENDPROC

REM *****************************************************************
DEF PROCGetDriveToUse

LOCAL i%,j%,k%,select%
DIM   buf% 128
DIM   Dev%(7)

CASE myfs% OF
  WHEN fsnumber_adfs:
    DriveOffset%=INSTR(autoreply$,"Drive=")
    IF (DriveOffset%<>0) THEN
      Drive%=VAL(MID$(autoreply$,DriveOffset%+6))
    ELSE
      REPEAT
        Drive%=FNAsk("DriveAskHdd",4,4)
      UNTIL Drive%>=4 AND Drive%<=7
    ENDIF
    select%=Drive%-4:REM Make 0s based
  WHEN fsnumber_SCSIFS:
    PROCmessage_print_0("DriveList")
    Dev%()=-1
    FOR i%=0 TO 31:REM For each of 8 devices on 4 SCSI cards
      SYS"XSCSI_Initialise",2,i%,buf% TO;F%
      IF ((F%AND1)=0) AND (?buf%<>&7F) THEN
        FOR k%=i% TO &FF STEP &20:REM For each of 8 LUNs in that device
          SYS"XSCSI_Initialise",2,k%,buf% TO;F%
          IF (F%AND1)=1 THEN
            k%=&100:REM Nothing attached, exit FOR
          ELSE
            REM Only consider 'Direct-access' devices
            IF ?buf%=0 THEN
              REM Only consider devices SCSIFS knows about
              SYS"SCSIFS_Partitions",1,k% TO,,j%
              IF j%>=0 AND j%<8 THEN Dev%(j%)=k%
            ENDIF
          ENDIF
        NEXT
      ENDIF 
    NEXT
    REM List out devices in SCSIFS order
    j%=TRUE
    FOR i%=0 TO 7
      k%=Dev%(i%)
      IF k%<>-1 THEN
        REM Get its human readable name
        SYS"SCSI_Initialise",3,k%,buf%,128
        PRINT "SCSI::";i%;" : ";
        SYS"OS_Write0",buf%
        SYS"OS_NewLine"
        j%=FALSE
      ENDIF
    NEXT
    IFj% THENPROCmessage_print_0("NoHardDiscs"):PROCfinish
    SCSIID%=-1
    REPEAT
      Drive%=FNAsk("DriveAskFddHdd",0,0)
      IF Drive%>=0 AND Drive%<8 THEN SCSIID%=Dev%(Drive%)
    UNTIL SCSIID%<>-1
    select%=Drive%
  WHEN fsnumber_SDFS:
    REPEAT
      Drive%=FNAsk("DriveAskFddHdd",0,0)
    UNTIL Drive%>=0 AND Drive%<=7
    select%=Drive%
ENDCASE
IF select%>=HDiscs% THEN
  PROCmessage_print_1("SillyDiscNum", STR$(HDiscs%))
  PROCfinish
ENDIF

ENDPROC
:

REM *****************************************************************
DEF PROCProbeDriveDetails

REM Selected a drive, find out what we are really dealing with here

CASE myfs% OF
  WHEN fsnumber_adfs:
    IF myfsversion% < 210 THEN
      IDE%=FALSE
    ELSE
      SYS"ADFS_ControllerType",Drive% TO DriveType%
      IF DriveType%=0 THEN
        PROCmessage_print_1("DriveNotPresent", STR$(Drive%))
        PROCfinish
      ELSE
        IF DriveType%=3 PROCmessage_print_1("DriveIsST506", STR$(Drive%))
        IF DriveType%=4 PROCmessage_print_1("DriveIsIDE", STR$(Drive%))
      ENDIF
      IDE%=DriveType%=4
    ENDIF
    IF IDE% THEN DIM IDEid% 512
    IF autodetected_ide% THEN
      REM Determine physical drive number which corresponds to logical drive
      REM First try for a newer ADFS that will tell us it directly
      SYS "XADFS_IDEDeviceInfo",2,Drive% TO ,B%,IDEdrive%,D%;F%
      IF ((F% AND1)=0) THEN
        IF (B%<>1) THEN IDEdrive%=-1
      ELSE
        REM Try for two controllers for a maximum of 4 drives
        IDEdrive%=-1
        FOR N%=0 TO 3
          SYS "XADFS_IDEDeviceInfo",0,N% TO ,B%,C%,D%;F%
          IF ((F% AND1)=0) AND (C%=Drive%) AND (B%=1) THEN
            IDEdrive%=N%*8
            N%=4
          ENDIF
        NEXT
      ENDIF
      IF IDEdrive%=-1 THEN
        fail%=TRUE
      ELSE
        REM copy the data from the device ID to a local copy of it
        FOR A%=0 TO 512-4 STEP 4
          IDEid%!A%=D%!A%
        NEXT
        fail%=FALSE
      ENDIF
    ELSE
      REM Determine whether this is IDE drive 0/1
      SYS"XADFS_ControllerType",Drive%-1 TO A%;F%
      IF ((F%AND1)=0) AND (A%=4) THEN IDEdrive%=8 ELSE IDEdrive%=0
      DIM IDEpb% 7
      IDEpb%!0=0
      IDEpb%!4=0
      IDEpb%?5=&A0+(IDEdrive%<<1)
      IDEpb%?6=&EC
      SYS"ADFS_IDEUserOp",1<<24,,IDEpb%,IDEid%,512 TO r0%,,,,r4%
      IF r0%<>0 OR r4%<>0 THEN
        fail%=TRUE
      ELSE
        fail%=FALSE
      ENDIF
    ENDIF
    IF fail% THEN
      PROCmessage_print_1("DiscIdError", STR$~(r0%))
      IDEcyls%=0:IDEheads%=0:IDEsecs%=0
    ELSE
      IDEcyls%=(IDEid%!2)AND&FFFF
      IDEheads%=(IDEid%!6)AND&FFFF
      IDEsecs%=(IDEid%!12)AND&FFFF
      IDECapacity%=IDEcyls%*IDEheads%*IDEsecs%
      IDEAddressSpace%=(IDEid%!(60*2))
      IF (((IDEid%!98)>>9)AND1)<>0 THEN IDEHasLBA%=1 ELSE IDEHasLBA%=0
      IDEname$=""
      FOR I%=27*2 TO 46*2+1
        A%=(IDEid%?(I%EOR1))
        IF (A%<32) OR (A%>=127) A%=ASC"."
        IDEname$+=CHR$(A%)
      NEXT
      IDEfirm$=""
      FOR I%=23*2 TO 26*2+1
        A%=(IDEid%?(I%EOR1))
        IF (A%<32) OR (A%>=127) A%=ASC"."
        IDEfirm$+=CHR$(A%)
      NEXT     
      PROCmessage_print_4("IDEDescription",myfsname$, STR$(Drive%), IDEname$, IDEfirm$)
      PROCmessage_print_3("IDEConfiguration", STR$(IDEcyls%), STR$(IDEheads%), STR$(IDEsecs%))
      IF IDEHasLBA%<>0 THEN
        PROCmessage_print_0("IDEHasLBA")
        IF ((IDEid%!(83*2))AND&C400)=&4400 THEN IDEHasLBA48%=1 ELSE IDEHasLBA48%=0
        IF IDEHasLBA48%<>0 THEN
          IDEAddressSpace%=(IDEid%!(100*2))
          IDEAddressSpace2%=(IDEid%!(102*2))
          IF (IDEAddressSpace% AND &E0000000) OR IDEAddressSpace2% THEN
            IDEAddressSpace%=2^29:REM 512M sectors = 256GB
          ENDIF
        ENDIF
        PROCmessage_print_1("IDELBASize", STR$(IDEAddressSpace%))
        IF IDEAddressSpace%>IDECapacity% THEN
          IDEheads%=16
          IDEcyls%=IDEAddressSpace% DIV IDEheads%
          IDEsecs%=255
          WHILE IDEcyls% MOD IDEsecs% AND IDEsecs%>63
            IDEsecs%-=1
          ENDWHILE
          IDEcyls%=IDEcyls% DIV IDEsecs%
          PROCmessage_print_3("IDEConfSuggest", STR$(IDEcyls%), STR$(IDEheads%), STR$(IDEsecs%))
        ENDIF
      ENDIF
    ENDIF
  WHEN fsnumber_SCSIFS:
    REM Determine drive info
    SYS"XSCSI_Initialise",2,SCSIID%,buf% TO;F%
    IF (F%AND1) THENPROCmessage_print_1("DriveNotPresent",STR$(Drive%)):PROCfinish
    SecSize%=buf%!12
    Cap=((buf%!8)*SecSize%)/(1024*1024)
    PROCmessage_print_1("DriveCapacity",STR$(INT(Cap+0.5)))
    IDEAddressSpace%=buf%!8
    IF (IDEAddressSpace% AND &E0000000) THEN
      IDEAddressSpace%=2^29:REM Max idlen
      Cap=(IDEAddressSpace%*SecSize%)/(1024*1024)
      PROCmessage_print_1("DriveTooLarge",STR$(INT(Cap+0.5)))
    ENDIF
    IDE%=1:REM Fool code below to use 512 sector size
    IDEHasLBA%=1
    IDEname$=""
    IDEcyls%=0
    IDEheads%=16
    IDEsecs%=63
    REPEAT
      IDEheads%+=1
      IDEcyls%=IDEAddressSpace% DIV IDEheads%
      IDEsecs%=63
      WHILE IDEcyls% MOD IDEsecs%
        IDEsecs%-=1
      ENDWHILE                                   
      IDEcyls%=IDEcyls% DIV IDEsecs%
    UNTIL((IDEcyls%<=65535) AND (IDEheads%<=255))
    REM Note the above algorithm will break down for drives above 65535*255*63 sectors = 502 GB
          
    PROCmessage_print_3("IDEConfSuggest", STR$(IDEcyls%), STR$(IDEheads%), STR$(IDEsecs%))
    EnglishMake$="OTHER"
    Cyls%=IDEcyls%:Heads%=IDEheads%:SecsPerTrk%=IDEsecs%:ParkCyl%=Cyls%+1
    InitFlag%=1:LBAFlag%=1
  WHEN fsnumber_SDFS:
    REM determine drive info
    SYS "SDFS_ReadCardInfo",0,Drive% TO ,,IDEAddressSpace%,IDEAddressSpace2%
    REM convert to sectors, cap at current FileCore limit
    IDEAddressSpace% = (IDEAddressSpace%>>>9) OR (IDEAddressSpace2%<<23)
    IDEAddressSpace2% = IDEAddressSpace2%>>>9
    IF (IDEAddressSpace% AND &E0000000) OR IDEAddressSpace2% THEN
       IDEAddressSpace%=&20000000:REM 512M sectors = 256GB
    ENDIF
    IDEname$=""
    REM Determine physical drive address which corresponds to logical drive
    SYS "XSDFS_ReadCardInfo",1,Drive% TO ,,A%;F%
    IF (F%AND1)=0 THEN
      REM Retrieve the card identity block
      DIM SDIOid% 16
      SYS "SDIO_ReadRegister",2,A%,SDIOid%
      FOR I%=13 TO 7 STEP -1
        IF (SDIOid%?I% >= 32) AND (SDIOid%?I% <> 127) THEN IDEname$+=CHR$(SDIOid%?I%)
        IF (I%=12) AND (LEN(IDEname$) > 0) THEN IDEname$+=" ":REM Gap between OEM and product names
      NEXT
      IF IDEname$ = "" THEN IDEname$=FNmessage_lookup_0("TypeOTHER")
      IDEfirm$=CHR$(48 + ((SDIOid%?6) >> 4))+"."+CHR$(48 + ((SDIOid%?6) AND&F))
      PROCmessage_print_4("IDEDescription",myfsname$, STR$(Drive%), IDEname$, IDEfirm$)
    ENDIF
    PROCmessage_print_1("DriveCapacity",STR$(INT(IDEAddressSpace%/1024/1024*512+0.5)))
    IDE%=1:REM Fool code below to use 512 sector size
    IDEHasLBA%=1
    BestWastedSectors%=(1<<31)-1
    FOR IDEsecs%=63 TO 16 STEP -1
    FOR IDEheads%=255 TO 16 STEP -1
      WastedSectors%=IDEAddressSpace% MOD (IDEsecs%*IDEheads%)
      IF WastedSectors%<BestWastedSectors% THEN
        BestIDEsecs%=IDEsecs%
        BestIDEheads%=IDEheads%
        BestWastedSectors%=WastedSectors%
      ENDIF
    NEXT,
    IDEsecs%=BestIDEsecs%
    IDEheads%=BestIDEheads%
    IDEcyls%=IDEAddressSpace% DIV (IDEsecs%*IDEheads%)
    
    PROCmessage_print_3("IDEConfSuggest", STR$(IDEcyls%), STR$(IDEheads%), STR$(IDEsecs%))
    EnglishMake$="OTHER"
    Cyls%=IDEcyls%:Heads%=IDEheads%:SecsPerTrk%=IDEsecs%:ParkCyl%=Cyls%-1
    InitFlag%=1:LBAFlag%=1
ENDCASE

MakeParams%=7
VerifyRetries%=1
DefectRetries%=5
Verify%=0
Read%=1
Write%=2
WriteTrack%=4
Restore%=6
Specify%=&F
AltDefectBit%=&10
DiscStruc%=&14

IF IDE% THEN
 Log2SecSize%=9
 LowSector%=1
ELSE
 Log2SecSize%=8
 LowSector%=0
ENDIF
SecSize%=2^Log2SecSize%
Zone0Bits%=60*8
ZoneBits%=SecSize%*8

OldMapAdd%=0
OldMapSize%=&200
DirSize%=&800

BootAdd%=&C00/SecSize%
BootSize%=&200

REM space for defects is a bootblock size (512), 
REM less 64 bytes for disc record, reserved bytes and checksum, 
REM less 16 bytes for hardware-specific parameters,
REM less 4  bytes for a end-of-space fencepost (used by *defect)
REM less 4  bytes for a terminator.

MaxDefects%=(BootSize%-64-&10-4-4)DIV4

REM If the disc is >512M bytes then we have an extra word
REM required for a terminator.  Hence we have 4 bytes less
REM for the defect list.  ie one less defect allowed

BigMaxDefects%=MaxDefects%-1

OldLWM%=&E00
FreeLink%=1
CrossCheck%=3
PROCmessage_print_0("Dismount")

AdfsDiscErr%=&108C7
MaxVerifyBad%=16
Patterns%=8
BufSize%=&40000
DIM Buf% BufSize%, DiscRec% 64+BootSize%, Defect% BootSize%, DirMark% 5, Bad%(MaxVerifyBad%),mc% 100, Pattern%(Patterns%-1)
Boot%=DiscRec%+64
BootRec%=Boot%+BootSize%-64
REM
REM DiscRec +---------+ 0
REM         |         |
REM Boot    +---------+ &40
REM         |         |
REM         |         |
REM         |         |
REM BootRec +---------+ &200
REM         |         |
REM         +---------+ &240
REM
Pattern%(2)=&FFFFFF
Pattern%(3)=&6DB6DB
Pattern%(4)=0
Pattern%(5)=&2CB2CB
Pattern%(6)=&5A5A5A
Pattern%(7)=&4D34D3
CASE myfs% OF
  WHEN fsnumber_adfs:
    SecsPerTrk%=32:Heads%=1:Cyls%=1:ParkCyl%=1
  OTHERWISE:
    REM Nothing to do
ENDCASE
IF IDE% THEN
 InitFlag%=0
 LBAFlag%=0
ELSE
 LowCurrentCyl%=1:PreCompCyl%=1
ENDIF

IF myfsisbig%
   RootDirAdd%=&400/512
ELSE
   RootDirAdd%=&400
ENDIF

Log2Alloc%=10:LinkBits%=MinLinkBits%
IF LinkBits%<=MaxFreeLinkBits% THEN FreeLinkBits%=LinkBits% ELSE FreeLinkBits%=15
IndRootDirAdd%=RootDirAdd%

REM Having SectorsPerDisc% makes various calculations for
REM DiscSize% and DiscSize2% much easier.


IF IDEHasLBA% THEN
  SectorsPerDisc%=IDEAddressSpace%
ELSE
  SectorsPerDisc%=IDECapacity%
ENDIF

DiscSize%=(SectorsPerDisc% AND ((1<<(32-Log2SecSize%))-1))<<Log2SecSize%
DiscSize2%=(SectorsPerDisc%>>(32-Log2SecSize%))
IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
  BigDisc%=TRUE
ELSE
  BigDisc%=FALSE
ENDIF

old_retries%=FNFixedDiscRetries(0)
LOCAL ERROR
ON ERROR LOCAL : ON ERROR OFF : old_retries%=FNFixedDiscRetries(old_retries%) : PROCAsm : ENDPROC
OSCLI("-"+myfsname$+"-%DISMOUNT :"+STR$Drive%)
ON ERROR OFF
old_retries%=FNFixedDiscRetries(old_retries%)
PROCAsm

ENDPROC

REM *****************************************************************
DEF PROCGetShape
LOCAL old_retries%

Formatted% = FALSE
PROCInitBootDefects
PROCInitDiscRec

old_retries%=FNFixedDiscRetries(0)
PROCMoanOp(Restore%,0,0,0)
PROCOp(Read%,BootAdd%,Boot%,BootSize%)
old_retries%=FNFixedDiscRetries(old_retries%)

IF Result%<>0 OR NOT FNGoodDefects THEN
 PROCmessage_print_0("NoValidFormat")
ELSE
 PROCOldShape
 PROCOp(Verify%,0,0,SecSize%*SecsPerTrk%)
 IF FNConfirmMake THEN Formatted% = TRUE
ENDIF
 
IF NOT Formatted% THEN
  CASE myfs% OF
    WHEN fsnumber_adfs:
      IF IDE% THEN
        IF NOT FNCompareMake THEN
          REM Drive not recognised - offer choice or custom specs.
          IF INSTR(autoreply$,"NOunknown") PROCabort(FNmessage_lookup_0("UnknownDriveType"),1)
          PROCAskMake
        ENDIF
      ELSE
        REM ST506 drives do not identify themselves .. ask the user.
        PROCAskMake
      ENDIF
    OTHERWISE:
      PROCAskMake
  ENDCASE

  FOR I%=0 TO BootSize%-1 STEP4
    Boot%!I%=0
  NEXT I%
  Boot%!0=EndDefect%
  Boot%!4=EndDefectBig%
ENDIF

PROCAskShape((NOT Formatted%) AND EnglishMake$="OTHER")

IF NOT Formatted% THEN
 PROCInitBootDefects
ENDIF 

PROCmessage_print_1("WillFormat", TransMake$)
PROCprintshape(IDE%)
PRINT
ENDPROC
:

REM *****************************************************************
DEF PROCOldShape
SecsPerTrk%=BootRec%?1
Heads%=BootRec%?2
Log2Alloc%=BootRec%?5
DiscSize%=BootRec%!&10
DiscSize2%=BootRec%!&24

IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
    BigDisc%=TRUE
ELSE
    BigDisc%=FALSE
ENDIF

SectorsPerDisc%=(DiscSize%>>>Log2SecSize%)+(DiscSize2%<<(32-Log2SecSize%))

Cyls%=SectorsPerDisc% DIV (SecsPerTrk%*Heads%)
IF myfs%=fsnumber_adfs THEN
  IF IDE% THEN
    InitFlag%=(BootRec%?-5)
    LBAFlag%=(BootRec%?-6)
  ELSE
   LowCurrentCyl%=(BootRec%!-8) AND &3FF
   PreCompCyl%=(BootRec%!-6) AND &3FF
  ENDIF
ELSE
  REM Other filing systems don''t use the hardware specific parameters. But we
  REM need to set LBAFlag% to persuade various bits of code to behave as required.
  InitFlag%=0
  LBAFlag%=1
ENDIF
IF BigDisc% THEN
    ParkCyl%=(BootRec%!-4)DIV(SecsPerTrk%*Heads%)
ELSE
    ParkCyl%=(BootRec%!-4)DIV(SecSize%*SecsPerTrk%*Heads%)
ENDIF
PROCInitDiscRec
ENDPROC
:
REM *****************************************************************
DEF PROCAskMake
CASE myfs% OF
  WHEN fsnumber_adfs:
    PROCrestoreparams(IDE%)
    Makes%=0
    I%=INSTR(autoreply$,"DriveType:")
    IF I%<>0 THEN
      I%+=LEN("DriveType:")
      Make%=EVAL(MID$(autoreply$,I%,INSTR(autoreply$,",",I%)-I%))
    ELSE
      PROCmessage_print_0("DriveDisclaim")
      REPEAT : REM list all the drive descriptions available
        READ EnglishMake$, TokenMake$
        TransMake$=FNmessage_lookup_0(TokenMake$)
        Makes%+=1
        PROCmessage_print_2("MakeMenu", RIGHT$(" "+STR$Makes%,2), TransMake$)
        FOR I%=1 TO MakeParams%
          READ A$
        NEXT I%
      UNTIL EnglishMake$="OTHER"
      PRINT 
      Make%=FNInputDec("ManufacturerDec",1,Makes%)
      PROCrestoreparams(IDE%)
    ENDIF
    I%=(Make%-1)*(MakeParams%+2)
    WHILE I%>0
      READ A$
      I%-=1
    ENDWHILE
    IF IDE% THEN
      READ EnglishMake$, TokenMake$, SecsPerTrk%, Heads%, Cyls%, InitFlag%, Dummy%, ParkCyl%, LBAFlag%
    ELSE
      READ EnglishMake$, TokenMake$, SecsPerTrk%, Heads%, Cyls%, LowCurrentCyl%, PreCompCyl%, ParkCyl%
    ENDIF
    TransMake$=FNmessage_lookup_0(TokenMake$)
  OTHERWISE:
    TransMake$="":REM No translation
ENDCASE

IF IDE% THEN
  IF (EnglishMake$="OTHER") AND (IDEcyls%<>0) THEN
    SecsPerTrk%=IDEsecs%
    Heads%=IDEheads%
    Cyls%=IDEcyls%
    InitFlag%=1
    LBAFlag%=1
    IF INSTR(autoreply$,"LBA:On")<>0 THEN
      LBAFlag%=1
    ELSE
      IF INSTR(autoreply$,"LBA:Off")<>0 THEN
        LBAFlag%=0
      ENDIF
    ENDIF
  ENDIF
ENDIF
ENDPROC
:

REM *****************************************************************
DEF FNConfirmMake
LOCAL matched%
CASE myfs% OF
  WHEN fsnumber_adfs:
    PROCrestoreparams(IDE%)
    REPEAT
      READ EnglishMake$, TokenMake$, P1%, P2%, P3%, P4%, P5%, P6%
      IF IDE% THEN
        READ P7%
        IF P7%<>0 THEN P7%=1
      ENDIF
      TransMake$=FNmessage_lookup_0(TokenMake$)
      IF EnglishMake$="OTHER" THEN
        PROCmessage_print_0("NonStandardShape")
        PROCprintshape(IDE%)
        PRINT
        =FNChoose("Q04:","RetainShapeChoose","YN","")="Y"
      ENDIF
      IF P1%<>SecsPerTrk% OR P2%<>Heads% OR P3%<>Cyls% OR P6%<>ParkCyl% THEN
        matched%=FALSE
      ELSE
        matched%=TRUE
        IF IDE% THEN
          IF P4%<>InitFlag% OR P7%<>LBAFlag% THEN matched%=FALSE
        ELSE
          IF P4%<>LowCurrentCyl% OR P5%<>PreCompCyl% THEN matched%=FALSE
        ENDIF
      ENDIF
    UNTIL matched%

    PROCmessage_print_1("StandardShape", TransMake$)

  OTHERWISE:
    TransMake$=""
    IF EnglishMake$="OTHER" THEN
      PROCmessage_print_0("NonStandardShape")
      PROCprintshape(IDE%)
      PRINT
      =FNChoose("Q04:","RetainShapeChoose","YN","")="Y"
    ENDIF
ENDCASE

PROCprintshape(IDE%)
PRINT
=FNChoose("Q05:","UseShapeChoose","YN","")="Y"
:

REM *****************************************************************
DEF PROCprintshape(itype%)
PROCmessage_print_3("PrintShape", STR$(Cyls%), STR$(Heads%), STR$(SecsPerTrk%))
IF myfs%=fsnumber_adfs THEN
  IF itype% THEN
    PROCmessage_print_3("PrintShape3IDE", STR$(ParkCyl%), STR$(InitFlag%), STR$(LBAFlag%))
  ELSE
    PROCmessage_print_3("PrintShape2ST506", STR$(ParkCyl%), STR$(LowCurrentCyl%), STR$(PreCompCyl%))
  ENDIF
ELSE
  PROCmessage_print_1("PrintShape4Generic", STR$(ParkCyl%))
ENDIF
ENDPROC
:


REM *****************************************************************
DEF FNCompareMake
PROCrestorePROD
REPEAT
 READ EnglishMake$, TokenMake$, SecsPerTrk%, Heads%, Cyls%, InitFlag%, Dummy%, ParkCyl%, LBAFlag%
 TransMake$=FNmessage_lookup_0(TokenMake$)
 IF EnglishMake$="OTHER" THEN
   PROCmessage_print_0("UnknownDriveMake")
   =FALSE
 ENDIF
UNTIL FNmatchstrings(EnglishMake$,IDEname$)
=FNChoose("Q06:","StandardShapeChoose","YN","")="Y"
:


REM *****************************************************************
DEF PROCAskShape(tailored%)

IF IDE% OR (INSTR(autoreply$,"NewMap")<>0) THEN
 NewMap%=TRUE
ELSE
 NewMap%=(FNChoose("OldOrNewMap:", "OldNewMapChoose", "ON", "N")="N")
ENDIF

IF tailored% THEN
  IF myfs%=fsnumber_adfs THEN
    IF IDE% THEN
         IF IDEHasLBA% THEN
           LBAFlag%=1
           IF INSTR(autoreply$,"LBA:On")<>0 THEN
               LBAFlag%=1
           ELSE
               IF INSTR(autoreply$,"LBA:Off")<>0 THEN
                   LBAFlag%=0
               ELSE
                   LBAFlag%=FNAsk("LBAAsk",LBAFlag%,0)
               ENDIF
           ENDIF
        ELSE
           LBAFlag%=0
        ENDIF
    ENDIF
  ELSE
    REM Other filing systems always use LBA addressing
    LBAFlag%=1
  ENDIF

    IF IDE% THEN
        REPEAT
            Heads%=FNAsk("IDEHeadsAsk",Heads%,1)
            IF Heads%>16 AND LBAFlag%=0 PROCmessage_print_0("IDEHeads16")
            IF Heads%>255 PROCmessage_print_0("Heads255")
        UNTIL Heads%<=255 AND (LBAFlag%=1 OR Heads%<=16)
    ELSE
        Heads%=FNAsk("ST506HeadsAsk",Heads%,1)
        IF Heads%>8 PROCmessage_print_0("ST506Heads8")
    ENDIF
    REPEAT
        SecsPerTrk%=FNAsk("SectorsAsk",SecsPerTrk%,1)
        IF SecsPerTrk%>255 PROCmessage_print_0("Secs255")
    UNTIL SecsPerTrk%<=255
    Cyls%=FNAsk("CylindersAsk",Cyls%,1)

  IF myfs%=fsnumber_adfs THEN
    IF IDE% THEN
        InitFlag%=FNAsk("InitAsk",InitFlag%,0)
    ELSE
        LowCurrentCyl%=FNAsk("LowCylinderAsk",LowCurrentCyl%,0)
        PreCompCyl%=FNAsk("PrecompCylinderAsk",PreCompCyl%,0)
    ENDIF
  ELSE
    REM Other filing systems don''t have this concept. Since IDE% is set for them
    REM to avoid taking ST506 code paths, we need to assign InitFlag% a value
    InitFlag%=0
  ENDIF
    ParkCyl%=FNAsk("ParkCylinderAsk",ParkCyl%,0)
ENDIF

DiscRec%?1=SecsPerTrk%
DiscRec%?2=Heads%

REM Again, calculations for DiscSize% and DiscSize2%
SectorsPerDisc%=SecsPerTrk%*Heads%*Cyls%
IF IDE% THEN
    IF IDEHasLBA% THEN IDELimit%=IDEAddressSpace% ELSE IDELimit%=IDECapacity%
       IF SectorsPerDisc%>IDELimit% THEN
           SectorsPerDisc%=IDELimit%
           Cyls%=SectorsPerDisc% DIV (SecsPerTrk%*Heads%)
           IF ParkCyl%>=Cyls% THEN ParkCyl%=Cyls%-1
       ENDIF
    ENDIF
    IF LBAFlag%=0 AND SectorsPerDisc%>16514064 PROCmessage_print_0("IDECHSMax")
ENDIF

DiscSize%=(SectorsPerDisc% AND ((1<<(32-Log2SecSize%))-1))<<Log2SecSize%
DiscSize2%=(SectorsPerDisc%>>(32-Log2SecSize%))

IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
    BigDisc%=TRUE
ELSE
    BigDisc%=FALSE
ENDIF

DiscRec%!&10=DiscSize%
DiscRec%!&24=DiscSize2%
DiscRec%?&28=Log2ShareSize%

REM If disc is large then flag this fact in disc record.
IF ((DiscSize% AND &E0000000)<>0 OR (DiscSize2%<>0)) THEN 
    DiscRec%?&29=1
ELSE
    DiscRec%?&29=0
ENDIF

FOR I%=0 TO BootSize%-4 STEP 4
 Defect%!I%=Boot%!I%
NEXT I%
Boot%!0=EndDefect%
REPEAT
    ptr%=0
    defectlist%=0
    IF BigDisc% THEN
        IF Defect%!ptr%>=EndDefect% THEN
            IF Defect%!(ptr%+4)<EndDefectBig% PROCmessage_print_0("CurrentDefects")
        ELSE
            PROCmessage_print_0("CurrentDefects")
        ENDIF
    ELSE
        IF Defect%!(ptr%)<EndDefect% PROCmessage_print_0("CurrentDefects")
    ENDIF
    WHILE ((Defect%!ptr%<EndDefect%) AND NOT BigDisc%) OR (Defect%!ptr%<EndDefectBig% AND BigDisc%)
        IF ((Defect%!ptr% AND &E0000000)=EndDefect%) THEN
            ptr%+=4
            defectlist%=1
        ELSE
            IF defectlist%=0 THEN
                defect%=Defect%!ptr%
                defect%=defect% DIV SecSize%
                sector%=(defect% MOD SecsPerTrk%) + LowSector%
                defect%=defect% DIV SecsPerTrk%
                PRINT TAB(((ptr%DIV4)MOD6)*13);"(";defect%DIVHeads%;",";defect%MODHeads%;",";sector%;")";
                ptr%=ptr%+4
            ELSE
                defect%=Defect%!ptr%
                sector%=(defect% MOD SecsPerTrk%) + LowSector%
                defect%=defect% DIV SecsPerTrk%
                PRINT TAB((((ptr%-4)DIV4)MOD6)*13);"(";defect%DIVHeads%;",";defect%MODHeads%;",";sector%;")";
                ptr%=ptr%+4
            ENDIF
        ENDIF
    ENDWHILE
    IF BigDisc% THEN
        Defects%=(ptr%DIV4)-1
    ELSE
        Defects%=ptr%DIV4
    ENDIF
    IF INSTR(autoreply$,"NOadddefects")=0 THEN
        PRINT : PRINT
        PROCmessage_print_0("DefectNoMore")
        PROCmessage_print_0("DefectAdd")
        IF NewMap% THEN
            PROCmessage_print_0("DefectAddDisc")
        ELSE
            PROCmessage_print_0("DefectAddLogical")
        ENDIF
        PROCmessage_print_0("DefectRemove")
    ENDIF
    opt$=FNChoose("Q07:","ABCDChoose","ABCD","")
    PRINT
    CASE opt$ OF
        WHEN "B","D":
            cyl%=FNInputDec("CylinderDec",0,Cyls%-1)
            head%=FNInputDec("HeadDec",0,Heads%-1)
            IF IDE% THEN
                sector%=FNInputDec("SectorDec",1,SecsPerTrk%)
            ELSE
                sector%=FNInputDec("IndexMFMDec",1-SecsPerTrk%,&10000)
                IF sector%>=0 THEN
                    sector%=sector% DIV 320
                ELSE
                    sector%=-sector%
                ENDIF
            ENDIF
            defect%=((cyl%*Heads%+head%)*SecsPerTrk%+(sector%-LowSector%))
            IF opt$="B" THEN
                PROCAddPhysDefect(defect%)
            ELSE
                PROCRemovePhysDefect(defect%)
            ENDIF
        WHEN "C":
            IF NewMap% THEN
                PROCAddPhysDefect((FNInputHex2("DiscAddrHex")))
            ELSE
                PROCmessage_print_1("DFormatDefect1",myfsname$)
                PROCmessage_print_0("DFormatDefect2")
                PROCmessage_print_0("DFormatDefect3")
                defect%=(FNInputHex("LogicalAddrHex")DIVSecSize%)
                PROCAddPhysDefect(FNLogToPhys(defect%))
            ENDIF
    ENDCASE
UNTIL LEFT$(opt$,1)="A"
FOR I%=0 TO DiscStruc%-4 STEP 4
 BootRec%!I%=DiscRec%!I%
NEXT I%
PROCInitHardDesc
ENDPROC
:
REM *****************************************************************
DEF PROCFormat
TIME=0
LOCAL I%,J%,cyl%,head%
PROCMoanOp(Specify%,0,0,0)
PROCMoanOp(Restore%,0,0,0)

PROCmessage_print_0("Formatting")
IF IDE% THEN
 FOR I%=0 TO 512-4 STEP 4:Buf%!I%=0:NEXT
 FOR I%=0 TO SecsPerTrk%-1
  Buf%?(2*I%+0)=&00  :REM format good
  Buf%?(2*I%+1)=I%+1 :REM this sector
 NEXT
ELSE
 FOR I%=0 TO 512-4 STEP 4:Buf%!I%=&077F03FF:NEXT
ENDIF
FOR cyl%=0 TO Cyls%-1
 VDU13:PRINTcyl%;
 FOR head%=0 TO Heads%-1
  IF cyl%<>0 OR head%<>0 OR NOT Formatted% THEN
   IF NOT IDE% THEN
    J%=cyl% OR (head%<<24)
    FOR I%=0 TO (SecsPerTrk%-1)*4 STEP 4:Buf%!I%=J% OR (I%<<14):NEXT
   ENDIF
   REM If its a big ADFS version then we use the big address form
   PROCOp(WriteTrack%,(cyl%*Heads%+head%)*SecsPerTrk%,Buf%,512)
   IF Result% PROCmessage_print_0("FormatError")
  ENDIF
 NEXT
NEXT
ENDPROC
:
REM *****************************************************************
DEF PROCVerify
IF SoakFlag% PROCmessage_print_0("SoakPrompt")
LOCAL add%,ptr%,sector%,head%,cyl%,defectlist%
Cycle%=1:ErrorCycle%=-100
CylSize%=SecsPerTrk%*Heads%
suspects%=0:MaxSuspects%=1000
REM Now we know a verify is needed, extend the slot for that + 32k slack
END=END+(CylSize%*SecSize%)+(5*MaxSuspects%)+&8000
DIM CylBuf% CylSize%*SecSize%+4, SusAdd%(MaxSuspects%), SusCount% MaxSuspects%
VDU 13 : PROCmessage_print_0("Verifying")
REPEAT
    IF Cycle%>1 THEN
        I%=Cycle% MOD Patterns%
        IF I%>1 THEN
            J%=Pattern%(I%)
            J%=(J%>>>1) OR ((J% AND 1)<<23)
            Pattern%(I%)=J%
        ELSE
            J%=RND(&1000000)-1
        ENDIF
        IF NOT SoakFlag% THEN 
            VDU 13
            PROCmessage_print_1("Pattern", STR$~(J%))
        ENDIF
        FOR I%=CylBuf% TO CylBuf%+CylSize% STEP 3:!I%=J%:NEXT
        ptr%=0
        defectlist%=0
        IF myfsisbig% THEN
            IF Formatted% add%=SecsPerTrk% ELSE add%=0
        ELSE
            IF Formatted% add%=SecSize%*SecsPerTrk% ELSE add%=0
        ENDIF
        REPEAT
            IF Defect%!ptr%>EndDefect% AND Defect%!ptr%<EndDefectBig% AND myfsisbig% AND BigDisc% AND defectlist%=0 THEN
                ptr%+=4
                defectlist%=1
            ENDIF
            
            CylEnd%=add% - (add% MOD CylSize%) + CylSize%
            
            IF (defectlist%=1) THEN
                REM Second defect list, no need to adjust
                defect%=Defect%!ptr%
            ELSE
                REM First defect list, have to adjust
                defect%=(Defect%!ptr%) DIV SecSize%
            ENDIF
            
            IF defect%>CylEnd% OR defect%<add% THEN
             length%=(CylEnd%-add%)*SecSize%
            ELSE
             length%=(defect%-add%)*SecSize%
            ENDIF
            
            PROCOp(Write%,add%,CylBuf%,length%)
         
            IF Result% THEN
                 IF myfsisbig% THEN
                     add%=(ErrDiscAdd% AND &1FFFFFFF)+1
                 ELSE
                     add%=((ErrDiscAdd% AND &1FFFFF00) DIV SecSize%)+1
                 ENDIF
            ELSE
                 add%+=length%
            ENDIF
            IF add%=defect% THEN add%+=1:ptr%+=4
        UNTIL add%>=SectorsPerDisc%
    ENDIF
    IF SoakFlag% PRINT ".";
    REM should start with add%=SecSize%*SecsPerTrk% since
    REM cannot not cope with error in track 0, head 0
    add%=0
    ptr%=0
    defectlist%=0
    PROCMoanOp(Restore%,0,0,0)
    REPEAT
     IF defectlist%=0 THEN
         REPEAT
             IF (Defect%!ptr% AND &E0000000)<>EndDefect% THEN
                 IF ((Defect%!ptr%)DIV SecSize%)<add% THEN
                     ptr%+=4
                 ENDIF
             ELSE
                 IF BigDisc% THEN
                     defectlist%=1
                     ptr%+=4
                 ENDIF
             ENDIF
         UNTIL defectlist%=1 OR ((Defect%!ptr%)DIV SecSize%)>=add%
     ENDIF
     
     IF defectlist%=1 THEN
         WHILE (Defect%!ptr%)<add%
             ptr%+=4
         ENDWHILE
     ENDIF
     IF defectlist%=0 THEN
         defect%=(Defect%!ptr%) DIV SecSize%
     ELSE
         defect%=Defect%!ptr%
     ENDIF
     
     IF defect%>SectorsPerDisc% THEN
      length%=SectorsPerDisc%-add%
     ELSE
      length%=defect%-add%
     ENDIF
     
     IF length%>1024 THEN length%=1024
     
     PROCOp(Verify%,add%,0,length%*SecSize%)
     
     IF Result% THEN
      IF myfsisbig% THEN
          add%=ErrDiscAdd% AND &1FFFFFFF
      ELSE
          add%=(ErrDiscAdd% AND &1FFFFF00) DIV SecSize%
      ENDIF
      Try%=0
      REPEAT
       Try%+=1
       PROCMoanOp(Restore%,0,0,0)
       PROCOp(Verify%,add%,0,SecSize%)
   REM **   PROCOp(Verify%,add%,0,SecSize%,&100)
      UNTIL Result%=0 OR Try%=5
      IF Result% Try%+=1
      sector%=add%:REM DIV SecSize%
      head%=sector% DIV SecsPerTrk%
      sector%=sector% MOD SecsPerTrk%
      cyl%=head% DIV Heads%
      head%=head% MOD Heads%
      PROCmessage_print_3("VerifyData", STR$(cyl%), STR$(head%), STR$(sector%+LowSector%))
      sus%=0
      WHILE sus%<suspects% AND SusAdd%(sus%)<>add%:sus%+=1:ENDWHILE
      IF sus%=suspects% THEN
       IF suspects%=MaxSuspects% THEN
        sus%=RND(MaxSuspects%)-1
       ELSE
        suspects%+=1
       ENDIF
       SusAdd%(sus%)=add%
       SusCount%?sus%=0
      ENDIF
      score%=2^(Try%-1)-1
      IF NOT SoakFlag% score%=score%*4
      SusCount%?sus%+=score%
#ifdef DEBUG
      IF TRUE THEN
#else
      IF (SusCount%?sus%>30) THEN
#endif
       IF SoakFlag% THEN
        PROCmessage_print_1("DefectTIME", TIME$)
       ELSE
        PROCmessage_print_0("Defect")
       ENDIF
       PROCAddPhysDefect(add%)
       ErrorCycle%=Cycle%
      ELSE
       IF SoakFlag% THEN
        TIME=0:REPEAT UNTIL TIME>500:VDU 13:PRINTSPC(78);:VDU13
       ELSE
        PROCmessage_print_1("Retries", STR$(Try%))
       ENDIF
      ENDIF
      add%=add%+1
     ELSE
      add%=add%+length%+1
     ENDIF
     IF add%>defect% THEN
      ptr%+=4
     ENDIF
    UNTIL add%>=SectorsPerDisc%
    IF SoakFlag% THEN
     REPEAT
      Key%=INKEY(0)
     UNTIL Key%=-1 OR Key%=32
     done%=(Key%=32)
    ELSE
     done%=Cycle%>ErrorCycle%+2
    ENDIF
    Cycle%+=1
    IF SoakFlag% VDU &2E
UNTIL done%
ENDPROC
:

REM *****************************************************************
DEF PROCStructure
IF NewMap% THEN
 PROCNewStructure
ELSE
 PROCOldStructure
ENDIF
ENDPROC
:

REM *****************************************************************
DEF PROCOldStructure
PROCWriteDefectList
PROCWriteOldFsMap
PROCWriteRootDir
ENDPROC
:

REM *****************************************************************
DEF FNRoundUpShare(Secs%)
IF Log2ShareSize%=0 THEN =Secs%
=((Secs%+ShareSize%-1)DIVShareSize%)*ShareSize%

REM Calculate the number of map bits required

REM *****************************************************************
DEF FNMapBits(Secs%,Lg%,Lg2SecSize%)
    LOCAL Shift%
    Shift%=Lg2SecSize%-Lg%
    IF (Shift%>0) THEN
        =Secs%<<Shift%
    ELSE
        =Secs%>>(-Shift%)
    ENDIF

REM *****************************************************************
DEF FNRoundSectors(Bits%,Lg%,Lg2SecSize%)
    LOCAL Shift%
    Shift%=Lg2SecSize%-Lg%
    IF (Shift%>0) THEN
        =Bits%>>(Shift%)
    ELSE
        =Bits%<<(-Shift%)
    ENDIF

REM *****************************************************************
DEF FNMinMapObj
  LOCAL min%, t%
  
  IF (Log2SecSize%>Log2Alloc%) THEN
    min%=1<<(Log2SecSize%-Log2Alloc%)
  ELSE
    min%=1
  ENDIF

  t%=min%

  WHILE(t%<(LinkBits%+1))
    t%+=min%
  ENDWHILE

  =t%

REM *****************************************************************
DEF FNdoalloc(Verbose%,Log%)
 Log2Alloc%=Log%
 MapBits%=FNMapBits(SectorsPerDisc%,Log2Alloc%,Log2SecSize%)
 RoundSectors%=FNRoundSectors(MapBits%,Log2Alloc%,Log2SecSize%)
 BestZones%=1 << 30      :REM init to rogue values
 BestCylOff%=1 << 30
 FOR DummySpare%=1 TO 1
 FOR SpareBits% = 4*8 TO ZoneBits%-Zone0Bits%-8*8
  PROCCalcZones
  LinkBits%=MinLinkBits%-1
  REPEAT LinkBits%+=1
   PROCCalcIds
  UNTIL Ids%<=2^LinkBits% AND LinkBits%>=(Log2SecSize%+3)
  IF SpareBits%-4*8>0 AND SpareBits%-4*8<=LinkBits% NEXT SpareBits%
  IF OddBits%>0 AND OddBits%<=LinkBits% NEXT SpareBits%
  IF LinkBits%>MaxLinkBits% THEN
   IF Verbose% THEN PROCmessage_print_0("TooSmallAlloc")
   Log2Alloc%+=1
   NEXT DummySpare%
   =FALSE  :REM restart alloc size loop
  ENDIF
  IF Zones% <= BestZones% THEN
   IF LinkBits%<=15 THEN
     IF Zones% > 127 THEN
       Log2Alloc%+=1
       NEXT DummySpare%
       =FALSE  :REM restart alloc size loop    
     ENDIF
     Crucial%=FNRoundUpShare(Zones%*2)*SecSize%+DirSize%
     IF MapZone%=0 Crucial%=BootAdd%*SecSize%+BootSize%
     IF Crucial%<Alloc%*FNMinMapObj Crucial%=Alloc%*FNMinMapObj
     IF Crucial% MOD FNGranularity<>0 Crucial%+=FNGranularity-Crucial% MOD FNGranularity
   ELSE     
     Crucial1%=FNRoundUpShare(Zones%*2)*SecSize%
     IF Crucial1%<Alloc%*FNMinMapObj Crucial1%=Alloc%*FNMinMapObj
     IF Crucial1% MOD FNGranularity<>0 Crucial1%+=FNGranularity-Crucial1% MOD FNGranularity
     
     Crucial2%=DirSize%
     IF Crucial2%<Alloc%*FNMinMapObj Crucial2%=Alloc%*FNMinMapObj
     IF Crucial2% MOD FNGranularity<>0 Crucial2%+=FNGranularity-Crucial2% MOD FNGranularity
     Crucial%=Crucial1%+Crucial2%
   ENDIF
   IF (Crucial%>((ZoneBits%-SpareBits%)<<Log2Alloc%)) THEN
     IF Verbose% THEN PROCmessage_print_0("TooSmallAlloc")
     Log2Alloc%+=1
     NEXT DummySpare%
     =FALSE  :REM restart alloc size loop    
   ENDIF
   CrucialEnd%=MapAdd%+Crucial%/SecSize%
   defectlist%=0:REM We are in the first defect list
   DefPtr%=Defect%
   REPEAT
    defect%=!DefPtr%
    DefPtr%+=4
    IF defect%>=EndDefect% AND defectlist%=0 AND BigDisc% THEN
        defect%=!DefPtr%
        DefPtr%+=4
        defectlist%=1
    ENDIF
    IF defectlist%=0 AND defect%<EndDefect% THEN defect%=defect%/SecSize%
   UNTIL defect%>=EndDefect% OR (defect%>=MapAdd% AND defect%<CrucialEnd%)
   CylOff%=MapAdd% MOD (SecsPerTrk%*Heads%)
   IF defect%>=EndDefect% AND CylOff%<BestCylOff% THEN
    BestCylOff%=CylOff%
    BestLinkBits%=LinkBits%
    BestSpare%=SpareBits%
    BestZones%=Zones%
   ENDIF
   IF BestCylOff% NEXT SpareBits%
   NEXT DummySpare%
  ELSE
   NEXT DummySpare%
  ENDIF
IF BestZones%=(1<<30) AND Verbose%=TRUE THEN PROCmessage_print_0("InvalidAllocSize"):=FALSE
=TRUE

REM *****************************************************************
DEF PROCNewStructure
LinkBits%=BestLinkBits%
IF LinkBits%<=MaxFreeLinkBits% THEN FreeLinkBits%=LinkBits% ELSE FreeLinkBits%=15
SpareBits%=BestSpare%
PROCCalcZones
PROCCalcIds
 IF LinkBits%<=15 THEN
   Crucial%=FNRoundUpShare(Zones%*2)*SecSize%+DirSize%
   IF MapZone%=0 Crucial%=BootAdd%*SecSize%+BootSize%
   IF Crucial%<Alloc%*FNMinMapObj Crucial%=Alloc%*FNMinMapObj
   IF Crucial% MOD FNGranularity<>0 Crucial%+=FNGranularity-Crucial% MOD FNGranularity
 ELSE     
   Crucial1%=FNRoundUpShare(Zones%*2)*SecSize%
   IF Crucial1%<Alloc%*FNMinMapObj Crucial1%=Alloc%*FNMinMapObj
   IF Crucial1% MOD FNGranularity<>0 Crucial1%+=FNGranularity-Crucial1% MOD FNGranularity
   
   Crucial2%=DirSize%
   IF Crucial2%<Alloc%*FNMinMapObj Crucial2%=Alloc%*FNMinMapObj
   IF Crucial2% MOD FNGranularity<>0 Crucial2%+=FNGranularity-Crucial2% MOD FNGranularity
   Crucial%=Crucial1%+Crucial2%
 ENDIF

IF MapZone%=0 THEN
 RootDirAdd%=BootAdd%+BootSize%/SecSize%
 IndRootDirAdd%=&200 + (BootAdd%*SecSize%+BootSize%) DIV SecSize% + 1
ELSE
 IF LinkBits%<=15 THEN
   RootDirAdd%=MapAdd%+FNRoundUpShare((MapLen%*2)/SecSize%)
   IndRootDirAdd%=&200+FNRoundUpShare(Zones%*2)/ShareSize%+1
 ELSE
   RootDirAdd%=MapAdd%+(Crucial1%)/SecSize%
   IndRootDirAdd%=((MapZone%*IdsPerZone%)<<8)+1
 ENDIF
ENDIF
DiscRec%?4=LinkBits%
DiscRec%?5=Log2Alloc%
IF BootOpt$="Y" THEN DiscRec%!7=2 ELSE DiscRec%!7=0
DiscRec%?8=LowSector%
DiscRec%?9=Zones%
DiscRec%?&A=SpareBits% MOD 256
DiscRec%?&B=SpareBits% DIV 256
DiscRec%!&C=IndRootDirAdd%
DiscRec%?&28=Log2ShareSize%
DiscRec%?&2a=Zones%>>8
IF BigDir% THEN
  DiscRec%!&2C=1
  DiscRec%!&30=2048
ENDIF
BootRec%!4=DiscRec%!4
BootRec%!8=DiscRec%!8
BootRec%!&C=DiscRec%!&C
BootRec%!&24=DiscRec%!&24
BootRec%!&28=DiscRec%!&28
BootRec%!&2C=DiscRec%!&2C
BootRec%!&30=DiscRec%!&30
PROCWriteDefectList
PROCWriteDOSBootSec(Buf%)
PROCmessage_print_0("CreatingMap")
FOR I%=0 TO BufSize%-1 STEP 4
 Buf%!I%=0
NEXT I%
FOR I%=0 TO 60-4 STEP 4
 Buf%!(I%+4)=DiscRec%!I%
NEXT I%
ptr%=0
DefectStart%=0
defectlist%=0
DiscEndBit%=FNDiscToMap(SectorsPerDisc%)
ZoneStart%=Buf%
ZoneWindow%=0:REM Zone number of base of the window into the map currently being built in Buf%
ZoneStartBit%=0
BootStartBit%=0
BootEndBit%=0
MapStartBit%=0
MapEndBit%=0
PROCmessage_print_0("WritingMap")
FOR zone%=0 TO Zones%-1
 !ZoneStart%=1<<(15+FreeLink%*8)
 ZoneEndBit%=ZoneStartBit%+ZoneBits%
 UsedZoneEndBit%=ZoneEndBit%-SpareBits%+4*8
 IF UsedZoneEndBit%>DiscEndBit% THEN
  UsedZoneEndBit%=DiscEndBit%
 ENDIF
 PreFree%=ZoneStartBit%+FreeLink%*8
 ZoneBit%=ZoneStartBit%+4*8
 IF zone%=0 THEN
  BootStartBit%=ZoneBit%
  ZoneBit%=ZoneBit%+Zone0Bits%
  length%=(BootAdd%*SecSize%+BootSize%) DIV Alloc%
  IF length%<FNMinMapObj length%=FNMinMapObj
  PROCWriteFragLink(ZoneBit%,2)
  PROCWriteFragLength(ZoneBit%,length%)
  ZoneBit%=ZoneBit%+length%
  BootEndBit%=ZoneBit%
 ELSE
  IF zone%=MapZone% THEN
   MapStartBit%=ZoneBit%
   IF LinkBits%<=15 THEN
    length%=Crucial% DIV Alloc%
    PROCWriteFragLink(ZoneBit%,2)
    PROCWriteFragLength(ZoneBit%,length%)
    ZoneBit%=ZoneBit%+length%
   ELSE
    length%=Crucial1% DIV Alloc%
    PROCWriteFragLink(ZoneBit%,2)
    PROCWriteFragLength(ZoneBit%,length%)
    ZoneBit%=ZoneBit%+length%
    length%=Crucial2% DIV Alloc%
    PROCWriteFragLink(ZoneBit%,IndRootDirAdd%>>8)
    PROCWriteFragLength(ZoneBit%,length%)
    ZoneBit%=ZoneBit%+length%    
   ENDIF
   MapEndBit%=ZoneBit%
  ENDIF
 ENDIF
 REPEAT
  REM All defects that do not fit are removed here
  IF ZoneBit%>DefectStart% THEN
   IF defectlist%=0 THEN
       IF Defect%!ptr%>=EndDefect% AND BigDisc% THEN
           ptr%+=4
           defectlist%=1
           DefectStart%=FNDiscToMap(Defect%!ptr%)
       ELSE
           DefectStart%=FNDiscToMap((Defect%!ptr%)/SecSize%)
       ENDIF
   ELSE
       DefectStart%=FNDiscToMap(Defect%!ptr%)
   ENDIF
   WHILE ((zone%=0 AND (DefectStart%>=BootStartBit% AND DefectStart%<BootEndBit%))) OR ((zone%=MapZone% AND (DefectStart%>=MapStartBit% AND DefectStart%<MapEndBit%)))
       IF defectlist%=0 THEN
           defectaddr$=FNhexaddr((Defect%!ptr%)/SecSize%)
       ELSE
           defectaddr$=FNhexaddr(Defect%!ptr%)
       ENDIF
       IF zone%=0 THEN
           PROCmessage_print_1("BootDefectError",defectaddr$)
       ELSE
           PROCmessage_print_1("MapDefectError",defectaddr$)
       ENDIF
       ptr%+=4
       IF defectlist%=0 THEN
           IF Defect%!ptr%>=EndDefect% THEN
               ptr%+=4
               defectlist%=1
               DefectStart%=FNDiscToMap(Defect%!ptr%)
           ELSE
               DefectStart%=FNDiscToMap((Defect%!ptr%)/SecSize%)
           ENDIF
       ELSE
           DefectStart%=FNDiscToMap(Defect%!ptr%)
       ENDIF
   ENDWHILE
   IF DefectStart%>=UsedZoneEndBit% THEN
    DefectStart%=ZoneEndBit%
   ELSE
    DefectEnd%=DefectStart%+1
    ptr%+=4
    REPEAT
     done1%=TRUE
     REPEAT
      done2%=TRUE
      IF defectlist%=1 THEN
         IF Defect%!ptr%>=EndDefect% THEN
            NextDefect%=EndDefect%
         ELSE
            NextDefect%=FNDiscToMap(Defect%!ptr%)
         ENDIF
      ELSE
          IF Defect%!ptr%>=EndDefect% THEN ptr%+=4:defectlist%=1
          IF defectlist%=1 THEN
            IF Defect%!ptr%>=EndDefect% THEN
               NextDefect%=EndDefect%
            ELSE
               NextDefect%=FNDiscToMap(Defect%!ptr%)
            ENDIF
          ELSE
            NextDefect%=FNDiscToMap((Defect%!ptr%)/SecSize%)
          ENDIF
      ENDIF
      IF NextDefect%<UsedZoneEndBit% THEN
       IF NextDefect%>ZoneEndBit%-FNMinMapObj THEN
        NextDef%=ZoneEndBit%-FNMinMapObj
       ELSE
        NextDef%=NextDefect%
       ENDIF
       IF NextDef%-DefectEnd%<FNMinMapObj THEN
        IF NextDefect%+1>DefectEnd% THEN
         DefectEnd%=NextDefect%+1
        ENDIF
        ptr%+=4
        done2%=FALSE
       ENDIF
      ENDIF
     UNTIL done2%
     IF DefectEnd%-DefectStart%<FNMinMapObj THEN
      DefectEnd%=DefectStart%+FNMinMapObj
      IF DefectEnd%>ZoneEndBit% THEN
       DefectEnd%=ZoneEndBit%
      ENDIF
      done1%=FALSE
     ENDIF
     IF DefectEnd%>ZoneEndBit%-(FNMinMapObj) AND DefectEnd%<>ZoneEndBit% THEN
      DefectEnd%=ZoneEndBit%
      done1%=FALSE
     ENDIF
     IF DefectEnd%-DefectStart%<FNMinMapObj THEN
      DefectStart%=DefectEnd%-FNMinMapObj
     ENDIF
    UNTIL done1%
   ENDIF
  ENDIF
  IF ZoneBit%>DefectStart% PROCmessage_print_0("ERROR1"):PROCfinish
  IF DefectStart%-ZoneBit% <= LinkBits% THEN DefectStart%=ZoneBit%
  IF DefectStart%>ZoneBit% THEN
   PROCWriteFreeLink(PreFree%,ZoneBit%-PreFree%)
   IF DefectStart%>=UsedZoneEndBit% THEN
    PROCWriteFreeLength(ZoneBit%,UsedZoneEndBit%-ZoneBit%)
    IF ZoneEndBit%>UsedZoneEndBit% THEN
     PROCWriteFragLink(UsedZoneEndBit%,1)
     PROCWriteFragLength(UsedZoneEndBit%,ZoneEndBit%-UsedZoneEndBit%)
    ENDIF
   ELSE
    PROCWriteFreeLength(ZoneBit%,DefectStart%-ZoneBit%)
   ENDIF
  PreFree%=ZoneBit%
  ENDIF
  IF DefectStart%<ZoneEndBit% THEN
   IF DefectEnd%>UsedZoneEndBit%-FNMinMapObj THEN
    DefectEnd%=ZoneEndBit%
   ENDIF
   PROCWriteFragLink(DefectStart%,1)
   PROCWriteFragLength(DefectStart%,DefectEnd%-DefectStart%)
   ZoneBit%=DefectEnd%
  ELSE
   ZoneBit%=ZoneEndBit%
  ENDIF
 UNTIL ZoneBit%=ZoneEndBit%
 PROCWriteFreeLink(PreFree%,0)
 IF zone%=0 THEN
  ZoneStart%?CrossCheck%=&FF
 ELSE
  ZoneStart%?CrossCheck%=0
 ENDIF
 ?ZoneStart%=FNNewMapCheck(ZoneStart%,SecSize%)
 ZoneStart%=ZoneStart%+SecSize%
 ZoneStartBit%=ZoneEndBit%
 IF (ZoneStart%=Buf%+BufSize%) OR (zone%=Zones%-1) THEN
   REM Flush out the buffer
   PROCMoanOp(Write%,MapAdd%+       ZoneWindow%,Buf%,ZoneStart%-Buf%)
   PROCMoanOp(Write%,MapAdd%+Zones%+ZoneWindow%,Buf%,ZoneStart%-Buf%)
   REM Reset for the subsequent zones
   FOR I%=0 TO BufSize%-1 STEP 4
    Buf%!I%=0
   NEXT
   ZoneStart%=Buf%
   ZoneWindow%=zone%+1
 ENDIF
NEXT zone%
PROCWriteRootDir
ENDPROC
:
REM *****************************************************************
DEF PROCCalcZones
UsedBits%=SecSize%*8-SpareBits%
WholeZones%=(MapBits%+Zone0Bits%) DIV UsedBits%
OddBits%=(MapBits%+Zone0Bits%) MOD UsedBits%
IF OddBits% Zones%=WholeZones%+1 ELSE Zones%=WholeZones%
PROCShareSize
MapZone%=Zones% DIV 2
IF MapZone%=0 THEN
     MapAdd%=0
ELSE
     IF (Alloc%>SecSize%) THEN
         MapAdd%=(UsedBits%*MapZone%-Zone0Bits%)*(Alloc% DIV SecSize%)
     ELSE
         MapAdd%=(UsedBits%*MapZone%-Zone0Bits%) DIV (SecSize% DIV Alloc%)
     ENDIF
ENDIF
MapLen%=Zones%*SecSize%
ENDPROC
:
REM *****************************************************************
DEF PROCCalcIds
IdsPerZone%=UsedBits% DIV (LinkBits%+1)
Ids%=IdsPerZone% * WholeZones% + OddBits% DIV (LinkBits%+1)
ENDPROC
:

REM discadd% is now a sector address of course

REM *****************************************************************
DEF FNDiscToMap(discadd%)
LOCAL bit%,zone%
IF discadd%>=EndDefect% THEN =EndDefect%
IF (Alloc%>SecSize%) THEN
    bit%=(discadd% DIV (Alloc% DIV SecSize%))+Zone0Bits%
ELSE
    bit%=(discadd% * (SecSize% DIV Alloc%))+Zone0Bits%
ENDIF
zone%=bit% DIV UsedBits%
bit%=bit%+(bit% DIV UsedBits%)*SpareBits%+4*8
= bit%


REM *****************************************************************
DEF PROCWriteFragLink(off%,link%)
IF link%>=2^LinkBits% PROCmessage_print_0("ERROR2"):PROCfinish
LOCAL bit%,add%,mask%,base%
base%=Buf%-(ZoneWindow%*SecSize%)
bit%=off% MOD 8
add%=base%+off% DIV 8
mask%=2^LinkBits%-1
!add%=(!add% AND NOT (mask%<<bit%)) OR link%<<bit%
ENDPROC

REM *****************************************************************
DEF PROCWriteFragLength(off%,len%)
IF len%<=LinkBits% PROCmessage_print_0("ERROR3"):PROCfinish
LOCAL base%
base%=Buf%-(ZoneWindow%*SecSize%)
off%=off%+len%-1
base%?(off%DIV8)+=2^(off%MOD8)
ENDPROC

REM *****************************************************************
DEF PROCWriteFreeLink(off%,link%)
IF link%>=2^FreeLinkBits% PROCmessage_print_0("ERROR2"):PROCfinish
LOCAL bit%,add%,mask%,base%
base%=Buf%-(ZoneWindow%*SecSize%)
bit%=off% MOD 8
add%=base%+off% DIV 8
mask%=2^FreeLinkBits%-1
!add%=(!add% AND NOT (mask%<<bit%)) OR link%<<bit%
ENDPROC

REM *****************************************************************
DEF PROCWriteFreeLength(off%,len%)
IF len%<=LinkBits% PROCmessage_print_0("ERROR3"):PROCfinish
LOCAL base%
base%=Buf%-(ZoneWindow%*SecSize%)
off%=off%+len%-1
base%?(off%DIV8)+=2^(off%MOD8)
ENDPROC

REM *****************************************************************
DEF PROCWriteDefectList
PROCmessage_print_0("WritingDefects")
ptr%=0
check%=0
WHILE Defect%!ptr%<EndDefect%
 Boot%!ptr%=Defect%!ptr%
 PROCCheckPut(Boot%!ptr%)
 ptr%=ptr%+4
ENDWHILE
check%=check% EOR (check%>>>16)
check%=(check% EOR (check%>>>8))AND &FF
Boot%!ptr%=EndDefect% OR check%

REM If we have a second defect list then do that too
IF BigDisc% THEN
    ptr%+=4
    check%=0
    WHILE Defect%!ptr%<EndDefect%
        Boot%!ptr%=Defect%!ptr%
        PROCCheckPut(Boot%!ptr%)
        ptr%=ptr%+4
    ENDWHILE
    check%=check% EOR (check%>>>16)
    check%=(check% EOR (check%>>>8))AND &FF
    Boot%!ptr%=EndDefectBig% OR check%
ENDIF

REM zero out the remainder of the defect list
WHILE ptr%<(MaxDefects%*4)
 ptr%=ptr%+4
 Boot%!ptr%=0
ENDWHILE
PROCSum(Boot%,BootSize%)
PROCMoanOp(Write%,BootAdd%,Boot%,BootSize%)
ENDPROC
:
REM *****************************************************************
DEF PROCWriteOldFsMap
PROCmessage_print_0("WritingFreeSpace")
LOCAL s%,I%
s%=OldMapSize% DIV 2
FOR I%=0 TO OldMapSize%-4 STEP 4:Buf%!I%=0:NEXT
!Buf%=OldLWM% DIV &100
Buf%!s%=(DiscSize%-OldLWM%-Defects%*SecSize%) DIV &100
!(Buf%+s%-4)=DiscSize% DIV &100
!(Buf%+OldMapSize%-5)=RND(&10000)-1
!(Buf%+OldMapSize%-2)=3
PROCSum(Buf%,s%)
PROCSum(Buf%+s%,s%)
PROCMoanOp(Write%,OldMapAdd%,Buf%,OldMapSize%)
ENDPROC
:
REM *****************************************************************
DEF PROCWriteRootDir
PROCmessage_print_0("WritingRootDir")
IF BigDir% THEN
  PROCWriteBigRootDir
ELSE
  LOCAL BF%
  FOR I%=0 TO DirSize%-4 STEP 4:Buf%!I%=0:NEXT
  IF NewMap% THEN
   $DirMark%="Hugo"
  ELSE
   $DirMark%="Hugo"
  ENDIF
  Buf%!1=!DirMark%
  BF%=Buf%+DirSize%
  IF NewMap% THEN
   BF%!-38=IndRootDirAdd%
  ELSE
   BF%!-38=IndRootDirAdd% DIV &100
  ENDIF
  BF%?-35=ASC"$"
  BF%?-16=ASC"$"
  BF%!-5=!DirMark%
  check%=0
  PROCCheckPut(!Buf%)
  PROCCheckPut(Buf%?4)
  I%=BF%-40
  WHILE I%AND3
   PROCCheckPut(?I%)
   I%=I%+1
  ENDWHILE
  WHILE I%<BF%-4
   PROCCheckPut(!I%)
   I%=I%+4
  ENDWHILE
  check%=check% EOR (check%>>>16)
  check%=(check% EOR (check%>>>8))AND &FF
  BF%?-1=check%
ENDIF
PROCMoanOp(Write%,RootDirAdd%,Buf%,DirSize%)
ENDPROC
:
REM *****************************************************************
DEF PROCWriteBigRootDir
FOR I%=0 TO DirSize%-4 STEP 4:Buf%!I%=0:NEXT
LOCAL hp%
hp%=Buf%+4
$hp%="SBPr"
hp%+=4
!hp%=1
hp%+=4
!hp%=DirSize%
hp%+=4
!hp%=0:REM no entries
hp%+=4
!hp%=0:REM space for names
hp%+=4
!hp%=IndRootDirAdd%
hp%+=4
?hp%=ASC"$"
hp%?1=13:REM the Ursula FileCore spec says this should be CR-terminated
REM there are no entries.  so just do the tail.

hp%=Buf%+DirSize%-8
$hp%="oven"
hp%+=4
!hp%=0

REM now do the check byte

check%=0
FOR I%=0 TO 28 STEP 4
  PROCCheckPut(Buf%!I%)
NEXT I%

I%=DirSize%-8

PROCCheckPut(Buf%!I%)
I%+=4
PROCCheckPut(Buf%?I%)
I%+=1
PROCCheckPut(Buf%?I%)
I%+=1
PROCCheckPut(Buf%?I%)
I%+=1

check%=check% EOR (check%>>>16)
check%=(check% EOR (check%>>>8))AND &FF
Buf%?I%=check%
ENDPROC
:
REM *****************************************************************
DEF FNLogToPhys(add%)
LOCAL ptr%
ptr%=0
WHILE add%>=(Defect%!ptr%) DIV SecSize%
 ptr%=ptr%+4
 add%=add%+SecSize%
ENDWHILE
=add%
:

REM This function used to take the defect address as a byte
REM address - this is now the sector number.

REM *****************************************************************
DEF PROCAddPhysDefect(add%)
LOCAL ptr%,ptr2%,defect%,defectlist%
REM Check defect is physically on the disc
IF (add%>=SectorsPerDisc%) THEN
    PROCmessage_print_0("DefectTooBig")
ELSE
    IF NOT BigDisc% THEN
        REM Here we have a single defect list which we adjust accordingly
        IF Defects%<MaxDefects% THEN
            WHILE ((Defect%!ptr%) DIV SecSize%)<add%
                ptr%=ptr%+4
            ENDWHILE
            defect%=(Defect%!ptr%)/SecSize%
            IF defect%=add% THEN
                PROCmessage_print_0("ExistingDefect")
            ELSE
                ptr2%=Defects%*4
                WHILE ptr2%>=ptr%
                    Defect%!(ptr2%+4)=Defect%!ptr2%
                    ptr2%=ptr2%-4
                ENDWHILE
                Defect%!ptr%=add%*SecSize%
                Defects%=Defects%+1
            ENDIF
        ELSE
            PROCmessage_print_0("FullDefectList")
        ENDIF
    ELSE
        REM Here we have a twin defect list
        IF Defects%<BigMaxDefects% THEN
            IF (add% < (EndDefect%>>>Log2SecSize%)) THEN
                REM Defect before 512M
                defectlist%=0
            ELSE
                REM Defect after 512M
                defectlist%=1
                WHILE (Defect%!ptr%<EndDefect%)
                    ptr%+=4
                ENDWHILE
                ptr%+=4
            ENDIF
            IF defectlist%=1 THEN
                WHILE (Defect%!ptr%)<add%
                    ptr%+=4
                ENDWHILE
            ELSE
                WHILE ((Defect%!ptr%)/SecSize%)<add%
                    ptr%+=4
                ENDWHILE
            ENDIF
            IF defectlist%=0 THEN
                defect%=(Defect%!ptr%)/SecSize%
            ELSE
                defect%=(Defect%!ptr%)
            ENDIF
            IF defect%=add% THEN
                PROCmessage_print_0("ExistingDefect")
            ELSE
                ptr2%=Defects%*4+4
                WHILE ptr2%>=ptr%
                    Defect%!(ptr2%+4)=Defect%!ptr2%
                    ptr2%=ptr2%-4
                ENDWHILE
                IF defectlist%=0 THEN
                    Defect%!ptr%=add%*SecSize%
                ELSE
                    Defect%!ptr%=add%
                ENDIF
                Defects%=Defects%+1
            ENDIF
        ELSE
            PROCmessage_print_0("FullDefectList")
        ENDIF
    ENDIF
ENDIF
ENDPROC
:

REM *****************************************************************
DEF PROCRemovePhysDefect(add%)
LOCAL ptr%,ptr2%,defect%,defectlist%
ptr%=0
defectlist%=1
WHILE ((Defect%!ptr%)/SecSize%)<add% AND (Defect%!ptr%<EndDefect%)
    ptr%=ptr%+4
ENDWHILE
IF Defect%!ptr%>=EndDefect% THEN
    defectlist%=2
    ptr%+=4
    WHILE (Defect%!ptr%)<add% AND (Defect%!ptr%)<EndDefect%
        ptr%=ptr%+4
    ENDWHILE
ENDIF
IF defectlist%=1 THEN
    defect%=(Defect%!ptr%)/SecSize%
ELSE
    defect%=Defect%!ptr%
ENDIF
IF defect%=add% THEN
    IF BigDisc% THEN
        WHILE ptr%<(Defects%*4+4)
            Defect%!ptr%=Defect%!(ptr%+4)
            ptr%=ptr%+4
        ENDWHILE
        Defects%=Defects%-1
    ELSE
        WHILE ptr%<Defects%*4
            Defect%!ptr%=Defect%!(ptr%+4)
            ptr%=ptr%+4
        ENDWHILE
        Defects%=Defects%-1
    ENDIF
    Defects%=Defects%-1
ELSE
     PROCmessage_print_0("MissingDefect")
ENDIF
ENDPROC
:


REM Checks the initial (byte address) defect list.

REM *****************************************************************
DEF FNGoodOldDefectList
ptr%=-4
check%=0
last%=-1
good%=TRUE
REPEAT
 ptr%=ptr%+4
 defect%=Boot%!ptr%
 IF defect%<=last% good%=FALSE
 last%=defect%
 IF defect%<EndDefect% PROCCheckPut(defect%)
UNTIL (defect% >= EndDefect%) OR NOT good%
OldDefects%=ptr%DIV4
check%=check% EOR (check%>>>16)
check%=(check% EOR (check%>>>8))AND &FF
= good% AND ((defect%AND&FF) = check%)

REM *****************************************************************
DEF FNGoodNewDefectList
ptr%=4*OldDefects%
check%=0
last%=-1
good%=TRUE
REPEAT
 ptr%=ptr%+4
 defect%=Boot%!ptr%
 IF defect%<=last% good%=FALSE
 last%=defect%
 IF defect%<EndDefectBig% PROCCheckPut(defect%)
UNTIL (defect% >= EndDefectBig%) OR NOT good%
NewDefects%=ptr%DIV4-OldDefects%-1
check%=check% EOR (check%>>>16)
check%=(check% EOR (check%>>>8))AND &FF
= good% AND ((defect%AND&FF) = check%)


REM *****************************************************************
DEF FNGoodDefects
bothgood%=FNGoodOldDefectList
REM Only check second list if disc is big enough to have it
IF (((BootRec%!&10) AND &E0000000)<>0 OR (BootRec%!&26)<>0) AND bothgood% THEN
    bothgood%=bothgood% AND FNGoodNewDefectList
ENDIF
= bothgood% AND (FNsum(Boot%,BootSize%)=Boot%?(BootSize%-1))
:


REM *****************************************************************
DEF PROCInitDiscRec
FOR I%=0 TO 64-4 STEP 4
 DiscRec%!I%=0
NEXT I%
?DiscRec%=Log2SecSize%
DiscRec%?1=SecsPerTrk%
DiscRec%?2=Heads%
DiscRec%?8=LowSector%
DiscRec%!&C=IndRootDirAdd%
DiscRec%!&10=DiscSize%
DiscRec%!&24=DiscSize2%
DiscRec%?&28=Log2ShareSize%
REM If disc is large then flag this fact in disc record.
IF ((DiscSize% AND &E0000000)<>0 OR (DiscSize2%<>0)) THEN 
    DiscRec%?&29=1
ELSE
    DiscRec%?&29=0
ENDIF
DiscRec%!&14=RND(&10000)-1

$(DiscRec%+&16)="HardDisc"+STR$Drive%

DiscRec%?&22=Drive%
ENDPROC
:

REM Initialises an empty boot block defect list.  As we do not know
REM at this point type of defect list to use, we assume a large one.

REM *****************************************************************
DEF PROCInitBootDefects
!Boot%=EndDefect%
Boot%!4=EndDefectBig%

REM We record two defect counts - one for defects in the
REM first 512M and one for defects later in the disc.

OldDefects%=0
NewDefects%=0
IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
    BigDisc%=TRUE
ELSE
    BigDisc%=FALSE
ENDIF
PROCInitHardDesc
ENDPROC
:

REM *****************************************************************
DEF PROCInitHardDesc
IF IDE% THEN
 BootRec%!-&10=0
 BootRec%!-&C=0
 IF myfs%=fsnumber_adfs THEN
  BootRec%?-5=InitFlag%
  BootRec%?-6=LBAFlag%
 ENDIF
ELSE
 BootRec%!-&10= &00000000      :REM SL xxxxxx
 BootRec%!-&C = &0D0C200A      :REM GPL2 GPL3 SH GPL1
 REM BootRec%!-&10= &16000000  slow stepping alternative
 REM BootRec%!-&C = &0D0CA80A  slow stepping alternative
 BootRec%!-8  = LowCurrentCyl% OR (PreCompCyl%<<16)
ENDIF

REM If BigDisc% then park address is a sector number
IF BigDisc% THEN
    BootRec%!-4  = SecsPerTrk%*Heads%*ParkCyl%
ELSE
    BootRec%!-4  = SecSize%*SecsPerTrk%*Heads%*ParkCyl%
ENDIF

BootRec%!-&14= &FFFFFFFF       :REM fencepost for end-of-defect-space
ENDPROC
:

REM *****************************************************************
DEF FNAsk(string$,Default%,min%)
LOCAL X,Y,reply$,value%
IF INSTR(autoreply$,"Defaults") AND Default%>=min% THEN
 =Default%
ENDIF
PRINT:VDU11
PROCmessage_print_0(string$): VDU32: X=POS: Y=VPOS
LOCAL ERROR
ON ERROR LOCAL IF ERR=17 PROCabort(REPORT$,1)
REPEAT
 PRINT TAB(X,Y);Default%;SPC3;TAB(X,Y);
 *FX 15,1
 INPUT ""reply$
 IF reply$="" THEN
  value%=Default%
 ELSE
  value%=EVAL(reply$)
 ENDIF
UNTIL value%>=min%
PRINT TAB(X,Y);value%;SPC3
=value%
:

REM *****************************************************************
DEF FNInputDec(string$,min%,max%)
LOCAL X,Y,reply$,value%
PRINT:VDU11
PROCmessage_print_2(string$,STR$(min%),STR$(max%)): X=POS: Y=VPOS
LOCAL ERROR
ON ERROR LOCAL IF ERR=17 PROCabort(REPORT$,1)
REPEAT
 PRINT TAB(X,Y);SPC12;TAB(X,Y);: INPUT ""reply$
 value%=EVAL(reply$)
UNTIL value%>=min% AND value%<=max%
= value%
:

REM *****************************************************************
DEF FNInputHex(string$)
LOCAL X,Y,reply$,value%
PRINT:VDU11
PROCmessage_print_0(string$): X=POS: Y=VPOS
LOCAL ERROR
ON ERROR LOCAL IF ERR=17 PROCabort(REPORT$,1)
PRINT TAB(X,Y);SPC12;TAB(X,Y);: INPUT ""reply$
=EVAL("&"+reply$)

REM *****************************************************************
DEF FNInputHex2(string$)
LOCAL X,Y,reply$,value%
PRINT:VDU11
PROCmessage_print_0(string$): X=POS: Y=VPOS
REMLOCAL ERROR
REMON ERROR LOCAL IF ERR=17 PROCabort(REPORT$,1)
PRINT TAB(X,Y);SPC12;TAB(X,Y);: INPUT ""reply$
=FNSectorAddr(reply$)
:

REM *****************************************************************
DEF FNSectorAddr(reply$)
LOCAL add%, add2%
add%=0
add2%=0

WHILE INSTR("abcdefABCDEF0123456789",LEFT$(reply$,1))<>0 AND LEN(reply$)<>0
    add2%=(add2%<<4)+(add%>>>28)
    add%=add%<<4
    add%=add%+EVAL("&"+LEFT$(reply$,1))
    reply$=MID$(reply$,2)
ENDWHILE
=(add%>>>Log2SecSize%)+(add2%<<(32-Log2SecSize%))

:

REM *****************************************************************
DEF FNChoose(select$, string$, opt$, default$)
=FNchoose_no_lookup(select$, FNmessage_lookup_0(string$), opt$, default$)
:

REM *****************************************************************
DEF FNchoose_no_lookup(select$,prompt$,english_opt$,english_default$)
LOCAL X,Y,reply$,start,end, opt$, default$
opt$=FNmessage_lookup_0(english_opt$)
IF english_default$<>"" THEN
  default$=MID$(opt$, INSTR(english_opt$, english_default$), 1)
ELSE
  default$=""
ENDIF
 
IF autoreply$<>"" THEN
  start = INSTR(autoreply$,select$)
  end = INSTR(autoreply$,",",start+1)
  IF end=0 THEN end = LEN(autoreply$) + 1
  IF start=0 THEN
    PROCmessage_print_2("FailedAuto", select$, prompt$)
    PROCfinish 
  ENDIF
  start+=LEN(select$)
  IF start<>end THEN
#ifdef DEBUG
    PRINTprompt$;" ";MID$(autoreply$,start,end-start)
#endif
    =MID$(autoreply$,start,end-start)
  ENDIF
ENDIF
PRINT:VDU11
PRINT prompt$;" ";: X=POS: Y=VPOS
REPEAT
 REPEAT
  PRINT TAB(X,Y);default$;SPC12;TAB(X,Y);: INPUT ""reply$
  IF reply$="" THEN reply$=default$
 UNTIL LEN(reply$)=1
 IF INSTR(opt$, reply$)=0 THEN reply$=CHR$(ASC(reply$)AND&DF)
UNTIL INSTR(opt$,reply$)
:
REM Translate option selected back to one of the token options
=MID$(english_opt$, INSTR(opt$, reply$), 1)
:

REM *****************************************************************
DEF FNreadvarval(varname$)
LOCAL varlen%, varbuf%
DIM  varbuf% 256
SYS "XOS_ReadVarVal",varname$,varbuf%,256,0,3 TO ,,varlen%
varbuf%?varlen% = 13
=$varbuf%
:


REM *****************************************************************
DEF PROCCheckPut(I%)
check%=(check% >>> 13) EOR ((check% AND (2^13-1)) << (32-13)) EOR I%
ENDPROC
:

REM *****************************************************************
DEF FNsum(base%,len%)
sum%=0:c%=0
FOR I%=len%-2 TO 0 STEP-1
sum%=sum%+base%?I%+c%
IF sum%<&100 c%=0 ELSE sum%=sum% AND &FF:c%=1
NEXT I%
=sum%
:
REM *****************************************************************
DEF PROCSum(base%,len%)
base%?(len%-1)=FNsum(base%,len%)
ENDPROC
:
REM *****************************************************************
DEF FNNewMapCheck(B%,C%)=USR(NewCheck%)
:
REM *****************************************************************
DEF PROCAsm
FOR opt%=0 TO 2 STEP 2
 P%=mc%
 [ OPT opt%
.NewCheck%
 MOV  R0,#0
 ADDS R2,R1,R2  \C=0
.loop%
 LDR  R3,[R2,#-4]!
 ADCS R0,R0,R3
 TEQS R2,R1
 BNE  loop%
 AND  R3,R3,#&FF
 SUB  R0,R0,R3
 EOR  R0,R0,R0,LSR #16
 EOR  R0,R0,R0,LSR #8
 AND  R0,R0,#&FF
 MOV  PC,R14
 ]
NEXT opt%
ENDPROC
:
REM *****************************************************************
DEF PROCDisableEscape
SYS "XOS_Byte",200,1,0 TO r0%,OldEscState%
SYS "XOS_Byte",247,%10101010,0 TO r0%,OldBreakState%
ENDPROC
:
REM *****************************************************************
DEF PROCRestoreEscape
SYS "XOS_Byte",200,OldEscState%,0
SYS "XOS_Byte",247,OldBreakState%,0
ENDPROC
:
REM *****************************************************************
REM SCSIFS rejects the Specify reason code to DiscOp. Rather than simply
REM ignoring all errors in the SCSI case, as was done previously, we filter out
REM those specific calls.

DEF PROCMoanOp(b%, C%, D%, E%)
IF b%=Specify% AND myfs%=fsnumber_SCSIFS THEN ENDPROC
IF myfsisbig% THEN
  SYS myfsdiscop%,0,b% OR AltDefectBit% OR (DiscRec%<<6),C% OR Drive%<<29,D%,E%
ELSE
  SYS myfsdiscop%,0,b% OR AltDefectBit% OR (DiscRec%<<6),(C%*SecSize%) OR Drive%<<29,D%,E%
ENDIF
ENDPROC
:

REM *****************************************************************
DEF PROCOp(b%, C%, D%, E%)
IF myfsisbig% THEN
  SYS xbit%+myfsdiscop%,0,b% OR AltDefectBit% OR (DiscRec%<<6),C% OR Drive%<<29,D%,E% TO Result%,R1%,ErrDiscAdd%
ELSE
  SYS xbit%+myfsdiscop%,0,b% OR AltDefectBit% OR (DiscRec%<<6),(C%*SecSize%) OR Drive%<<29,D%,E% TO Result%,R1%,ErrDiscAdd%
ENDIF
IF Result% THEN
 IF Verbose% THEN
  PRINT"(""";
  I%=Result%+4:WHILE ?I% VDU?I%:I%+=1:ENDWHILE
  PROCmessage_print_1("OpError", STR$~(!Result%))
 ENDIF
 IF !Result% AND (1 << 31) THEN
  PROCmessage_print_1("Error", STR$~(!Result% AND &3FFFFFFF))
  PROCfinish
 ELSE
  IF ((!Result%) AND &FF00FF)=(AdfsDiscErr% AND &FF00FF) THEN
   Result%=!Result% AND &FF : REM probably the original intention
  ELSE
   PROCmessage_print_1("Error", STR$~(!Result%)):VDU 32
   I%=4
   WHILE Result%?I%
    VDU Result%?I%
    I%=I%+1
   ENDWHILE
   PROCfinish
  ENDIF
 ENDIF
ELSE
ENDIF
ENDPROC
:

REM *****************************************************************
DEF FNmatchstrings(str1$,str2$)
LOCAL II%,JJ%,LI%,LJ%
II% = 0 : LI%=LEN(str1$)
JJ% = 0 : LJ%=LEN(str2$)
REPEAT
  REM skip spaces
  WHILE II%<LI% AND ASC(MID$(str1$,II%+1,1))=ASC(" ") : II%+=1 : ENDWHILE
  WHILE JJ%<LJ% AND ASC(MID$(str2$,JJ%+1,1))=ASC(" ") : JJ%+=1 : ENDWHILE
  IF II%<LI% AND JJ%<LJ% THEN
    IF ASC(MID$(str1$,II%+1,1))<>ASC(MID$(str2$,JJ%+1,1)) THEN
      =FALSE : REM characters differ in str1$ and str2$
    ENDIF  
  ELSE
    IF II%=LI% EOR JJ%=LJ% =FALSE : REM _only_ one string ended
  ENDIF
  IF II%<LI% II%+=1
  IF JJ%<LJ% JJ%+=1
UNTIL II%=LI% AND JJ%=LJ%
=TRUE 
:

REM basic -Report error and die
REM *****************************************************************
DEF PROCabort(why$,failcode%)
LOCAL dummy$
LOCAL ERROR
ON ERROR OFF

IF ERR=17 THEN
  PROCmessage_print_0("UserQuit")
  PROCfinish
ENDIF

IF msgs_file_open% THEN
  PROCmessage_print_2("HFormFailed", why$, STR$(ERL))
ELSE
  PRINT"HForm failed : ";why$;" at line ";ERL
ENDIF

IF INSTR(autoreply$,"NOprompts")=0 THEN
  IF msgs_file_open% THEN
    PROCmessage_print_0("PressKey")
  ELSE
    PRINT "Press Return to continue ";
  ENDIF
  INPUT ""dummy$
ENDIF
PROCfinish
ENDPROC
:

REM Unsuccessful termination - return a FAIL status and clean up
REM *****************************************************************
DEF PROCfinish
*set HForm$EndStatus 20
PROCexit
ENDPROC
:

REM tidy termination
REM *****************************************************************
DEF PROCexit
PROCclose_message_file
END
ENDPROC
:

REM *****************************************************************
DEF FNFixedDiscRetries(V%)
CASE myfs% OF
 WHEN fsnumber_adfs:
   SYS"ADFS_Retries",&FF,V% TO,,V%
 OTHERWISE:
   REM Not applicable
   V%=0
ENDCASE
=V%

REM *****************************************************************
DEF PROCrestoreparams(iface%)
IF iface% THEN
  PROCrestorePROD
ELSE 
  PROCrestoreST506 
ENDIF
ENDPROC
:

REM *****************************************************************
DEF PROCrestorePROD
RESTORE+1
ENDPROC
: 
REM Production IDE drives
REM For automatic determination of IDE drive, the printing characters in
REM the string below must *exactly* match those produced by the drives  
REM identify command. However, the 'space' character is ignored.
REM The user never sees the burnt in name - the one in the Messages file
REM is always displayed instead.
REM For comparison with previous format parameters, the drive parameter
REM lists must all be slightly different (otherwise, the drive type
REM reported will always be the FIRST matching entry)

REM Identification, name token, Sectors per track, heads, cylinders, Needs init, dummy, parking cylinder, lba flag
                                                                                          
DATA Conner Peripherals 40MB - CP3044,     TypeCP3044,     40,  4,   526, 1, 0,   525,  0
DATA Conner Peripherals 42MB - CP2044,     TypeCP2044PK,   38,  4,   548, 1, 0,   547,  0: REM Sticker says CP2044PK
DATA Conner Peripherals 63MB - CP2064,     TypeCP2064,     38,  4,   823, 1, 0,   822,  0
DATA Conner Peripherals 210MB - CFS210A,   TypeCFS210A,    38, 16,   685, 1, 0,   684,  0
DATA Conner Peripherals 270MB - CFS270A,   TypeCFS270A,    63, 14,   600, 1, 0,   599,  0
DATA Conner Peripherals 420MB - CFS420A,   TypeCFS420A,    63, 16,   826, 1, 0,   825,  0
DATA Conner Peripherals 425MB - CFS425A,   TypeCFS425A,    62, 16,   839, 1, 0,   838,  0
DATA Conner Peripherals 850MB - CFS850A,   TypeCFS850A,    63, 16,  1651, 1, 0,  1650,  1
DATA Maxtor 2B010H1,                       Type2B010H1,   189, 16,  6618, 1, 0,  6617,  1
DATA Maxtor 2B020H1,                       Type2B020H1,    63, 16, 39703, 1, 0, 39702,  1
DATA Maxtor 4D040H2,                       Type4D040H2,   252, 16, 19852, 1, 0, 19851,  1
DATA SAMSUNG SV8004H,                      TypeSV8004H,   249, 16, 39249, 1, 0, 39248,  1

DATA OTHER,                                TypeOTHER,      1,  1,      1, 1, 1,     1,  1: REM Must be last, numbers irrelevant (except must be non zero).

REM *****************************************************************
DEF PROCrestoreST506
RESTORE+1
ENDPROC
:
REM fast stepping ST506 drives
REM Manufacturer, Sectors per track, heads, cylinders, low current cylinder, precompensation cylinder, parking cylinder
DATA 20Mb Miniscribe 8425,                      Type8425,       32, 4, 615, &3FF,  128, 663
DATA 53Mb Rodime RO3065,                        TypeRO3065,     32, 7, 872, &3FF,  650, 871
DATA 20Mb Kalok KL320,                          TypeKL320,      32, 4, 615, 615,   300, 615
REM DATA 20Mb Western Digital WD362/Tandon TM362,   TypeTM362,      32, 4, 615, &3FF, &3FF, 663
DATA OTHER,                                     TypeOTHER,      32, 4, 612, &3FF,  128, 611:REM MUST BE LAST

:
REM OSS Added message file handling functions during internationalisation.
REM Note that some RMA space is claimed, because MessageTrans (in its
REM infinite wisdom) needs its 16 byte block and the filename in the RMA.
REM Thus we must be very careful to free this block up ROBUSTLY whenever
REM the program terminates. The file itself is held in application space.
:
REM *****************************************************************
DEF PROCopen_message_file(filename$)
LOCAL flags%, size%
SYS "MessageTrans_FileInfo", ,filename$ TO flags%,,size%
IF (flags% AND 1) THEN msgs_file_buf%=0 ELSE DIM msgs_file_buf% size%
SYS "OS_Module", 6,,,17+LEN(filename$) TO ,,msgs_file_desc%
$(msgs_file_desc%+16)=filename$
SYS "MessageTrans_OpenFile", msgs_file_desc%,msgs_file_desc%+16,msgs_file_buf%
msgs_file_open%=TRUE
msg_lookup_buf_size%=256
DIM msg_lookup_buf% msg_lookup_buf_size%
ENDPROC
:
REM Robust procedure - called during error handling. Report errors but
REM always continue execution.
:
REM *****************************************************************
DEF PROCclose_message_file
LOCAL flags%
LOCAL ERROR
ON ERROR OFF

IF msgs_file_open% THEN
  SYS "XMessageTrans_CloseFile", msgs_file_desc% TO r0%;flags%
  msgs_file_open%=FALSE
  IF (flags% AND 1) THEN SYS "XOS_Write0",r0%+4
ENDIF

IF msgs_file_desc% THEN
  SYS "XOS_Module", 7,,msgs_file_desc% TO r0%;flags%
  msgs_file_desc%=0
  IF (flags% AND 1) THEN SYS "XOS_Write0",r0%+4
ENDIF
ENDPROC
:
REM Procedure for lookups, with one to four parameters. Make sure there
REM are no |M s in the strings for these, or BASIC will think it is
REM the end of the string.
:
REM *****************************************************************
DEF FNmessage_lookup_0(tag$)
=FNmessage_lookup_4(tag$, "", "", "", "")
:
REM *****************************************************************
DEF FNmessage_lookup_1(tag$, arg1$)
=FNmessage_lookup_4(tag$, arg1$, "", "", "")
:
REM *****************************************************************
DEF FNmessage_lookup_2(tag$, arg1$, arg2$)
=FNmessage_lookup_4(tag$, arg1$, arg2$, "", "")
:
REM *****************************************************************
DEF FNmessage_lookup_3(tag$, arg1$, arg2$, arg3$)
=FNmessage_lookup_4(tag$, arg1$, arg2$, arg3$, "")
:
REM *****************************************************************
DEF FNmessage_lookup_4(tag$, arg1$, arg2$, arg3$, arg4$)
LOCAL len%
SYS "MessageTrans_GSLookup", msgs_file_desc%,tag$,msg_lookup_buf%,msg_lookup_buf_size%,arg1$,arg2$,arg3$,arg4$ TO ,,,len%
msg_lookup_buf%?len%=13
=$msg_lookup_buf%
:
REM Procedures for printing a looked string - cannot use PRINT as we want
REM to put |M s (char 13 - end of BASIC string) in the strings. 
:
REM *****************************************************************
DEF PROCmessage_print_0(tag$)
PROCmessage_print_4(tag$, "", "", "", "")
ENDPROC
:
REM *****************************************************************
DEF PROCmessage_print_1(tag$, arg1$)
PROCmessage_print_4(tag$, arg1$, "", "", "")
ENDPROC
:
REM *****************************************************************
DEF PROCmessage_print_2(tag$, arg1$, arg2$)
PROCmessage_print_4(tag$, arg1$, arg2$, "", "")
ENDPROC
:
REM *****************************************************************
DEF PROCmessage_print_3(tag$, arg1$, arg2$, arg3$)
PROCmessage_print_4(tag$, arg1$, arg2$, arg3$, "")
ENDPROC
:
REM *****************************************************************
DEF PROCmessage_print_4(tag$, arg1$, arg2$, arg3$, arg4$)
LOCAL len%
SYS "MessageTrans_GSLookup", msgs_file_desc%,tag$,msg_lookup_buf%,msg_lookup_buf_size%,arg1$,arg2$,arg3$,arg4$ TO ,,,len%
SYS "OS_WriteN", msg_lookup_buf%, len%
ENDPROC
:

REM *****************************************************************
REM This used to increase min% if it was less than Zones%*SecSize%, but only if
REM LinkBits% was <= 15. This makes no sense, and the LinkBits% dependency
REM suggests that during Ursula development it was questioned, but behaviour
REM for smaller discs was retained for compatibility. Instead, I argue that
REM it should be removed outright, by the following reasoning:
REM
REM If this value of min% were to apply, then we gradually increase
REM Log2ShareSize% until Zones%*SecSize% <= (253*SecSize%)<<Log2ShareSize%
REM but for LinkBits% <= 15 and 512-byte sectors (every case for which HForm
REM has ever been used), the number of zones is less than 253, so this doesn''t
REM constrain Log2ShareSize at all - it''s true even if it is 0.
REM
REM Also, the constant ought to be 255, not 253, although this doesn''t currently
REM make any difference considering that there are no ways to configure the
REM map such that the minimum fragment block is between 15*2^x and 2^(x+1) bits
REM long, unless the maximum idlen is increased - these correspond to 240 and
REM 128 share units per disc object respectively.
REM
REM We also ought to limit Log2ShareSize% to 15, since only bits 0-3 of byte 40
REM in the disc record are documented to be used for this purpose.

REM Old version
REM DEF PROCShareSize
REM     LOCAL min%, min2%
REM     min2%=Zones%*SecSize%
REM     min%=FNMinMapObj<<Log2Alloc%
REM     IF (min%<min2%) AND (LinkBits%<=15) THEN min%=min2%
REM     Log2ShareSize%=0
REM     WHILE (253*(SecSize%<<Log2ShareSize%)<min%)
REM         Log2ShareSize%+=1
REM     ENDWHILE
REM     ShareSize%=1<<Log2ShareSize%
REM ENDPROC

DEF PROCShareSize
    LOCAL min%
    min%=FNMinMapObj<<Log2Alloc%
    Log2ShareSize%=0
    WHILE (Log2ShareSize%<16) AND (255*(SecSize%<<Log2ShareSize%)<min%)
        Log2ShareSize%+=1
    ENDWHILE
    ShareSize%=1<<Log2ShareSize%
ENDPROC

REM *****************************************************************
DEF FNhexaddr(Sector%)
LOCAL high$,low$
high$=STR$~(Sector%>>>(32-Log2SecSize%))
WHILE (LEN(high$)<8)
    high$="0"+high$
ENDWHILE
low$=STR$~(Sector%<<(Log2SecSize%))
WHILE (LEN(low$)<8)
    low$="0"+low$
ENDWHILE
=high$+low$

REM *****************************************************************
DEF FNGranularity

  IF Log2SecSize%>Log2Alloc% THEN
    =1<<Log2SecSize%
  ELSE
    =1<<Log2Alloc%
  ENDIF

REM *****************************************************************
DEF FNPeekModuleVersion(mod$)
LOCAL code%,help$,help%

SYS "OS_Module",18,mod$ TO,,,code%
help$=""
help%=(code%!&14)+code%
WHILE (?help%)<>0
  help$+=CHR$?help%
  help%+=1
ENDWHILE

=INT(VAL(MID$(help$,INSTR(help$,".")-1))*100)

REM *****************************************************************
DEF PROCWriteDOSBootSec(DOSBuf%)
 LOCAL i%,brec%
 FORi%=0TO511STEP4
   DOSBuf%!i%=0
 NEXTi%

 REM Preload a basic boot sector
 DOSBuf%!&00=&00903CEB
 $(DOSBuf%+3)="Castle"+CHR$0+CHR$0
 :
 DOSBuf%!&28=&4E326000
 DOSBuf%!&2c=&414E204F
 DOSBuf%!&30=&2020454D
 DOSBuf%!&34=&20202020
 DOSBuf%!&38=&20202020
 DOSBuf%!&3c=&31FA2020
 DOSBuf%!&40=&BCD08EC0
 DOSBuf%!&44=&8EFB7C00
 DOSBuf%!&48=&0000E8D8
 DOSBuf%!&4c=&19C6835E
 DOSBuf%!&50=&FC0007BB
 DOSBuf%!&54=&74C084AC
 DOSBuf%!&58=&CD0EB406
 DOSBuf%!&5c=&30F5EB10
 DOSBuf%!&60=&CD16CDE4
 DOSBuf%!&64=&4E0A0D19
 DOSBuf%!&68=&732D6E6F
 DOSBuf%!&6c=&65747379
 DOSBuf%!&70=&6964206D
 DOSBuf%!&74=&0A0D6B73
 DOSBuf%!&78=&73657250
 DOSBuf%!&7c=&6E612073
 DOSBuf%!&80=&656B2079
 DOSBuf%!&84=&6F742079
 DOSBuf%!&88=&62657220
 DOSBuf%!&8c=&0D746F6F
 DOSBuf%!&90=&0000000A

 brec%=DOSBuf%+&b

 brec%?0  =   SecSize%         :REM Secsize lo byte
 brec%?1  =   SecSize%>>8      :REM Secsize hi byte
 brec%?2  =   0                :REM secs/cluster
 brec%?3  =   0                :REM reserved secs lo byte
 brec%?4  =   0                :REM reserved secs hi byte
 brec%?5  =   0                :REM FATS
 brec%?6  =   0                :REM Root entries lo byte
 brec%?7  =   0                :REM Root entries hi byte
 brec%?8  =   0                :REM Small Secs lo byte
 brec%?9  =   0                :REM Small Secs hi byte
 brec%?10 =   0                :REM Media Descr
 brec%?11 =   0               :REM Secs/FAT lo byte
 brec%?12 =   0               :REM Secs/FAT hi byte
 brec%?13 =   SecsPerTrk%     :REM Secs/track lo byte
 brec%?14 =   SecsPerTrk%>>8  :REM Secs/track hi byte
 brec%?15 =   Heads%          :REM Heads lo byte
 brec%?16 =   Heads%>>8       :REM Heads hi byte
 DOSBuf%!32 = ( (Cyls% * (Heads%+1) ) * SecsPerTrk%) + SecsPerTrk% -1 :REM Large disc sectors

 DOSBuf%?510=&55
 DOSBuf%?511=&aa

 REM Write it out
 PROCMoanOp(Write%,0,DOSBuf%,&200)
ENDPROC
@


4.20
log
@Increase support for formatting up to idlen of 21
Check which version of FileCore we have, and use that to pick an appropriate idlen (in a similar manner to idlen of 19 or 15 was chosen for BigDisc support).
As idlen is increased so to are the number of zones, and so to is the size of the map to hold those zones inside HForm. Rather than ballooning the map DIM again, reduce it back to its pre-Ursula size of &40000 and instead write the new map out as it is generated.
Fix for longstanding syntax error in PROCWriteOldFsMap, an errant 'p' had been added.
Changed NukeDOS, and its name, to use the existing Buf% rather than leaking a DIM of its own.

Tested with a range of 512B sector drives manually picking LFAUs to get idlen=17 to idlen=21 inclusive, then cross checking with DiscKnight 1.52.

Version 2.74. Tagged as 'HForm-2_74'
@
text
@d267 1
a267 1
LOCAL i%,j%,k%,l%,select%
d269 1
a269 1
DIM   Dev%(256)
d284 1
a284 1
    l%=0
d293 1
d295 3
a297 7
              REM Type 'Direct-access', get its human readable name
              Dev%(l%)=k%
              SYS"SCSI_Initialise",3,k%,buf%,128
              PRINT STR$~l%+" : ";
              SYS"OS_Write0",buf%
              SYS"OS_NewLine"
              l%+=1
d303 19
a321 10

    Dev%(l%)=256
    Drive%=-1
    SCSIID%=8
    IFl%=0 THENPROCmessage_print_0("NoHardDiscs"):PROCfinish
    WHILE SCSIID% > l%-1
      SCSIID%=FNAsk("DriveAskFddHdd",0,0)
    ENDWHILE
    SCSIID%=Dev%(SCSIID%)
    SYS"SCSIFS_Partitions",1,SCSIID% TO,,Drive%
@


4.19
log
@Report the SD/MMC card product name and manufacturer where available
If possible, show the OEM & product name when a card is selected for formatting, like SCSIFS and ADFS do for their drive types. Otherwise, say "OTHER".
Messages: Line up the disc capacity message.

Version 2.73. Tagged as 'HForm-2_73'
@
text
@a17 11
REM MaxLinkBits% sets the maximum value of idlen
REM For formatting with idlen>15, we have to allow the formatter
REM to select a larger idlen value.
MaxLinkBits%=19: REM allow 19 bit idlen
MaxFreeLinkBits%=15: REM maximum number of bits for a free link
MinLinkBits%=10
Log2ShareSize%=0:REM Unit of sharing
ShareSize%=1<<Log2ShareSize%:REM Sharing multiple
EndDefect%=1<<29:REM Terminator for Defects to 512MB
EndDefectBig%=1<<30:REM Terminator word for a second defect list

d141 15
d574 2
a575 1
DIM Buf% &160000, DiscRec% 64+BootSize%, Defect% BootSize%, DirMark% 5, Bad%(MaxVerifyBad%),mc% 100, Pattern%(Patterns%-1)
d1489 4
a1492 1
FOR I%=0 TO Zones%*SecSize%-4 STEP 4
a1497 2
PROCWriteDefectList
PROCmessage_print_0("CreatingMap")
d1503 1
d1509 1
d1681 11
a1692 4
PROCNukeDOS
PROCmessage_print_0("WritingMap")
PROCMoanOp(Write%,MapAdd%,Buf%,MapLen%)
PROCMoanOp(Write%,MapAdd%+MapLen%/SecSize%,Buf%,MapLen%)
d1742 2
a1743 1
LOCAL bit%,add%,mask%
d1745 1
a1745 1
add%=Buf%+off% DIV 8
d1753 2
d1756 1
a1756 1
Buf%?(off%DIV8)+=2^(off%MOD8)
d1762 2
a1763 1
LOCAL bit%,add%,mask%
d1765 1
a1765 1
add%=Buf%+off% DIV 8
d1773 2
d1776 1
a1776 1
Buf%?(off%DIV8)+=2^(off%MOD8)
d1829 1
a1829 1
PROCMoanOp(Write%,OldMapAdd%p,Buf%,OldMapSize%)
d2738 2
a2739 3
DEF PROCNukeDOS
 DIM DOSBuf% &200
 LOCAL i%,brec% 
d2745 2
a2746 3
 DOSBuf%!&00=&43903CEB
 DOSBuf%!&04=&6C747361
 DOSBuf%!&08=&00000065
d2800 1
a2800 1
 REM put it back again
@


4.18
log
@Remove Columbo-ism
HForm had an annoying habit, having asked all the questions including "are you sure you want to format the drive?", only to come back with one more thing: setting the LFAU size. To make matters worse Escape had been disabled by that point so you had no option but to enter a valid LFAU.
Move the calculation of LFAU up above the final question, so the "are you sure" really is the last chance to bail.
Other general useability improvements:
* Make the spacing of questions/defaults/questionmarks consistent across all questions, and consistent with the User Guide
* Fix "Number too large" error if a non power of 2 LFAU was chosen
* Don't offer all 3 filing system names when only 2 are present (the same prompt was used for all cases even if the FS was absent)
Administrative improvement:
* Install the disc copy in the right place from !MkInstall.

Version 2.72. Tagged as 'HForm-2_72'
@
text
@d480 15
a497 1
    IDEname$="":REM no drive shape lookup table for SDFS
@


4.17
log
@  Update for compatibility with ADFS 4
Detail:
  The physical ID by which ATA drives are addressed has been expanded in
  ADFS 4 from 2 bits to 12. ADFS 4 has a new SWI which converts from logical
  to physical drive number to avoid the awkward enumeration previously used
  by HForm. Previous versions of HForm would only detect ATA drives on
  ADFS 4 if the physical ID was 0, which is OK for single-port boards with
  no port multipliers, but was a problem for machines like Titanium.
Admin:
  Tested on a Titanium board.


Version 2.71. Tagged as 'HForm-2_71'
@
text
@d3 2
a4 3
REM Formatter for ST506 and IDE hard discs
REM for SCSI hard discs, see SCSI user guide.
REM The formatter runs in one of two modes, selected at the
d72 27
a98 1
REM Last change to bail out
d104 1
a104 1
 PROCFormat
d107 2
a108 2
 SoakFlag%=(SoakStyle$="L")
 PROCVerify
d170 1
a170 1
  chosenfs$=FNChoose("WhichFS:","WhichFSChoose",availablefs$,defaultfs$)
d524 2
d1338 1
a1338 1
DEF FNdoalloc(Verbose%)
a1415 24
Zone0Bits%=60*8
ZoneBits%=SecSize%*8
Log2Alloc%=7: REM requested by TCs ECR
IFLog2Alloc%<Log2SecSize%  Log2Alloc%=Log2SecSize%
REMIF Log2Alloc%<8 THEN Log2Alloc%=10:PROCShareSize

REM * check for sensible default
Alloc%=2^Log2Alloc%:Log%=Log2Alloc%
WHILE FNdoalloc(FALSE)=FALSE
  Alloc%=2^Log2Alloc%:Log%=Log2Alloc%
ENDWHILE

PRINT
REPEAT: REM allocation size loop
 Alloc%=FNAsk("AllocUnitAsk",2^Log2Alloc%/*SecSize%*/,SecSize%)
 Log%=7
 REPEAT
  Log%+=1
 UNTIL Alloc%=2^Log%:
 REM OR Log%=13
 REMIF Log%=13 UNTIL FALSE:REM restart alloc size loop
UNTIL FNdoalloc(TRUE)

PRINT
d2157 1
a2157 1
PROCmessage_print_0(string$): X=POS: Y=VPOS
d2231 1
a2231 1
DEF FNchoose_no_lookup(select$,String$,english_opt$,english_default$)
d2245 1
a2245 1
    PROCmessage_print_2("FailedAuto", select$, String$)
d2251 1
a2251 1
    PRINTString$;" ";MID$(autoreply$,start,end-start)
d2257 1
a2257 1
PRINT String$;: X=POS: Y=VPOS
@


4.16
log
@Be somewhat more frugal with WimpSlot and change clamp point
Over time, as HForm has been asked to format drives with more and more cyinders/heads the WimpSlot has grown too, up to 10MB from HForm-2_61. However the majority of that memory is only needed when performing the verify step as the test pattern is built in RAM in a buffer of size cylinders*sectors, at all other times the RAM requirements are much less (just enough for bits of map). Rather than a fixed WimpSlot grab in the !Run file, only the memory needed is obtained at run time using BASIC's END= construct.

In HForm-2_69 a clamp was introduced for big SCSI media, however the clamp was set incorrectly, since log2(502GB) is 30 which means the disc address would spill out of the idlen bits into bit 0 of the drive number when represented as a 32 bit disc address. Additionally, the use of BASIC's signed integers would mean any disc bigger than 1TB (2^31 sectors) wouldn't have the clamp applied.

bas/!RunImage:
 Only grab the RAM required if the soak test is enabled
 Correct the clamp (both its magnitude and signedness) to 2^29 as used 25 lines further up for IDE discs
Resources/UK/!Help:
 Reinforce that option (M) for SDFS is the memory card option.
Resources/UK/Messages
 Have 3 dots in the elipsis to match what command line verify with FileCore does.
Resources/UK/!Run:
 Reduce the WimpSlot back to 2MB, and relax the RMEnsure on UtilityModule since the fixes in HForm-2_61 mean it works on RISC OS 3.10 anyway.

Tested on a 4MB A5000 formatting a maximally sized (for its era) 512MB drive.

Version 2.70. Tagged as 'HForm-2_70'
@
text
@d325 15
a339 12
      REM Try for two controllers for a maximum of 4 drives
      IDEdrive%=-1
      FOR N%=0 TO 3
        SYS "XADFS_IDEDeviceInfo",0,N% TO ,B%,C%,D%;F%
        IF ((F% AND1)=0) AND (C%=Drive%) AND (B%=1) THEN
          IDEdrive%=N%
          REM copy the data from the device ID to a local copy of it
          FOR A%=0 TO 512-4 STEP 4
            IDEid%!A%=D%!A%
          NEXT
        ENDIF
      NEXT
d343 4
d352 1
a352 1
      IF ((F%AND1)=0) AND (A%=4) THEN IDEdrive%=1 ELSE IDEdrive%=0
d356 1
a356 1
      IDEpb%?5=&A0+(IDEdrive%<<4)
@


4.15
log
@  Minor changes to SCSIFS formatter to limit the max size of disc it'll attempt to format
  to < 65535 *255*63 sectors, which is where filecore/hform will fall over
  In practice this is around 502GB. Tested with 750GB drive. Formatted to max (502GB)
 then exercised using fsbash
JB

Version 2.69. Tagged as 'HForm-2_69'
@
text
@d1 1
a1 1
REM > !RunImage
d389 1
a389 1
            IDEAddressSpace%=&20000000:REM 512M sectors = 256GB
d413 2
a414 2
    IF(IDEAddressSpace%>(65534*255*63))THEN
      IDEAddressSpace%=(65534*255*63)
d1059 2
@


4.14
log
@Search for 'direct-access' devices based on enumerated type
HForm would try to find SCSI devices of type 'direct-access' by looking for the english text "Direct", rather than a type of 0. This change allows HForm to match devices regardless of the language spoken.
Tested briefly on OMAP3 with a SCSI-over-USB memory stick.

Version 2.67. Tagged as 'HForm-2_67'
@
text
@d413 5
@


4.13
log
@Fix for missing LBA flag formatting ADFS harddiscs outside CHS limit
Line 2111, setting up the boot record, the check for ADFS was reversed. So, any drive bigger than the "safe" CHS limit 65536*63*16 (~32G) would mount initially after running HForm but not after subsequent power cycles because the LBA flag was never set.
Tested on an 80G Maxtor drive on a Risc PC.

Version 2.64. Tagged as 'HForm-2_64'
@
text
@d256 6
a261 9
    FOR i%=0 TO 31
      FOR j%=0 TO 127 STEP 4:buf%!j%=13:NEXT
      SYS"XSCSI_Initialise",3,i%,buf%,128
      IF buf%!8<>13THEN
        FOR k%=i% TO &FF STEP &20
          REM For each of the 8 possible devices on that bus
          FOR j%=0 TO 127 STEP 4:buf%!j%=13:NEXT
          SYS"XSCSI_Initialise",3,k%,buf%,128
          IF buf%!8=13 THEN
d264 2
a265 3
            j%=buf%?13:buf%?13=13
            IF $(buf%+7)="Direct" THEN
              buf%?13=j%
d267 4
a270 1
              PRINTSTR$~(l%)+" : "+$buf%
d2311 2
a2312 2
SYS "XOS_Byte",200,1,0 TO R0,OldEscState%
SYS "XOS_Byte",247,%10101010,0 TO R0,OldBreakState%
@


4.12
log
@Fix failure to format on single controller machines
A rather weak check using ADFS_IDEDeviceInfo was being used to infer that twin IDE controllers were in use.
Infact any recent ADFS has this SWI, even if it doesn't have two controllers. The use of a non X-SWI meant it would fail ("Bad parameters") on a single controller setup.


Version 2.62. Tagged as 'HForm-2_62'
@
text
@d664 7
a670 7
IF IDE% THEN
 InitFlag%=(BootRec%?-5)
 LBAFlag%=(BootRec%?-6)
ELSE
 LowCurrentCyl%=(BootRec%!-8) AND &3FF
 PreCompCyl%=(BootRec%!-6) AND &3FF
ENDIF
d672 4
a675 4
REM Other filing systems don''t use the hardware specific parameters. But we
REM need to set LBAFlag% to persuade various bits of code to behave as required.
InitFlag%=0
LBAFlag%=1
d796 5
a800 5
IF itype% THEN
 PROCmessage_print_3("PrintShape3IDE", STR$(ParkCyl%), STR$(InitFlag%), STR$(LBAFlag%))
ELSE
 PROCmessage_print_3("PrintShape2ST506", STR$(ParkCyl%), STR$(LowCurrentCyl%), STR$(PreCompCyl%))
ENDIF
d802 1
a802 1
 PROCmessage_print_1("PrintShape4Generic", STR$(ParkCyl%))
d2111 3
a2113 3
 IF myfs%<>fsnumber_adfs THEN
 BootRec%?-5=InitFlag%
 BootRec%?-6=LBAFlag%
@


4.11
log
@  Added support for formatting SD cards; fixed a surprisingly large number of bugs
Detail:
  * No longer asks for or reports the LBA flag or drive init flag, except
    for ADFS IDE hard discs. These parameters are from the IDE version of
    the hardware-dependent information block, and are inappropriate for
    other filing systems.
  * No longer suppresses all SCSIFS DiscOp errors. It looks like the reason
    why this was done was that it generates an error for the Specify reason
    code; SCSIFS should probably implement that as a no-op instead, but for
    now I've special-cased the Specify reason code for SCSIFS.
  * The name of the root directory is now CR-terminated, rather than
    null-terminated. This is as per the specification, and is now consistent
    with every other directory on the disc, as well as the root directories
    that FileCore creates on floppy discs.
  * Rewrote calculation of the share_size parameter from the disc record.
    Previous code was a bit strange, and wasn't range-checked as required
    by the definition in PRM 5a. For more details see comment block.
  * Fixed handling of errors returned by DiscOp calls. Callers of PROCOp
    expect Result% to contain the disc error number if there was one.
    For one thing, it wasn't filing-system-agnostic (disc errors from
    any filing system other than ADFS caused program termination), and for
    another, due to what looks like some endianness confusion, Result%
    always ended up containing 0 irrespective of whether an error ocurred.
  * Fixed an edge case which created badly formatted discs which caused
    FileCore to hang (including during the free space report at the end of
    formatting). For discs with sector size 512 bytes, this affected discs
    of just less than 2 GiB in capacity. If the LFAU was chosed such that
    idlen was 15, HForm tried to create disc object 2 such that it contained
    both copies of 128 or 129 map blocks, plus the root diretory. But in
    that configuration, there is no internal disc address representation of
    the address of the root directory - due to calculation overflow, HForm
    actually initialises the disc record to say the root directory is in
    non-existent disc object 3. Now HForm refuses to create such discs.
  * Long soak tests now work again. It looks like they've been broken since
    RISC OS 3.6! With long soak tests, HForm writes a test pattern to the
    whole disc between each whole-disc verify. It does this one cylinder at
    a time, which requires a RAM buffer (containing a test pattern) of
    cylinder size. However, when various variables were converted to be
    sector addresses, the calculation of this buffer size didn't account
    for the fact, and the buffer ended up being 512x too small. With LBA
    discs, the virtual cylinder size is often very large, which resulted in
    write operations that ran not just beyond the allocated buffer, but off
    the end of the application slot, causing a data abort. For extra dumb
    points, HForm was actually using a null pointer instead of a pointer
    to the cylinder buffer it had so carefully initialised!
  * Fixed some broken error handling when closing the messages file.
  * Corrected a few misleading comments.
Admin:
  Tested on SCSIFS and SDFS. Checked only as far as the "Are you sure?" prompt
  on ADFS because I didn't really want to reformat my hard disc - but I'm
  fairly confident it should still work for IDE discs.

Version 2.61. Tagged as 'HForm-2_61'
@
text
@a177 1
    TwinIDE%=FALSE
d180 1
a180 1
      TwinIDE%=FALSE
d182 1
a182 1
      TwinIDE%=TRUE
d324 3
a326 2
    IF TwinIDE% THEN
      REM determine physical drive number which corresponds to logical drive
d329 2
a330 2
        SYS "ADFS_IDEDeviceInfo",0,N% TO ,B%,C%,D%
        IF (C%=Drive%) AND (B%=1) THEN
d335 1
a335 1
          NEXT A%
d337 1
a337 1
      NEXT N%
@


4.10
log
@Reunify SCSIForm with its older sister HForm.
Hopefully reduces confusion since the differences between them is so small, and eeks a few more months of life out of the utility.
Fixed some incorrect memory clears counting words, using !, but count in 1s.
Fixed some missing internationalisation in SCSIForm
Merged messages files.
Logic is now that if only one of ADFS or SCSIFS is present on startup that will be selected by default, if both a present then the user is prompted for which to look at the default being SCSIFS.
Version number comes from messages file, and is used in the graphical banner on startup.

Version 2.60. Tagged as 'HForm-2_60'
@
text
@d132 3
a134 1
IF(NOTgotadfs%)AND(NOTgotscsifs%) THEN
d138 5
a142 1
IFgotadfs% ANDgotscsifs% THEN
d144 5
a148 2
  gotadfs%=FNChoose("WhichFS:","WhichFSChoose","AS","S")="A"
  gotscsifs%=NOT gotadfs%
d164 6
d204 2
d226 6
d290 5
d390 1
a390 1
            IDEAddressSpace%=&20000000:REM 512MB
d429 1
d435 31
a499 1
REM less 80 bytes for later defects to be added
d541 1
a541 1
  WHEN fsnumber_SCSIFS:
d598 1
a598 6
CASE myfs% OF
  WHEN fsnumber_adfs:
    PROCMoanOp(Restore%,0,0,0)
  WHEN fsnumber_SCSIFS:
    REM Nothing to do
ENDCASE
d623 1
a623 1
    WHEN fsnumber_SCSIFS:
d663 1
d671 6
d721 1
a721 1
  WHEN fsnumber_SCSIFS:
d777 1
a777 1
  WHEN fsnumber_SCSIFS:
d795 1
d801 3
d833 1
d850 4
d871 1
d878 5
d1055 1
a1055 1
DIM CylBuf% CylSize%+4, SusAdd%(MaxSuspects%), SusCount% MaxSuspects%
d1101 1
a1101 1
            PROCOp(Write%,add%,0,length%)
d1321 5
d1841 1
d2111 1
d2114 1
d2323 4
d2328 1
d2330 1
a2330 7
  CASE myfs% OF
    WHEN fsnumber_adfs:
      REM Use ADFS_Retries as a get out
      SYS myfsdiscop%,0,b% OR AltDefectBit% OR (DiscRec%<<6),C% OR Drive%<<29,D%,E%
    WHEN fsnumber_SCSIFS:
      SYS xbit%+myfsdiscop%,0,b% OR AltDefectBit% OR (DiscRec%<<6),C% OR Drive%<<29,D%,E%
  ENDCASE
d2351 1
a2351 1
  PROCmessage_print_1("Error", STR$~(Result% AND &3FFFFFFF))
d2354 2
a2355 2
  IF ((!Result%) AND &FFFFFF)=AdfsDiscErr% THEN
   Result%=Result%?3
d2444 1
a2444 1
 WHEN fsnumber_SCSIFS:
d2535 1
a2535 1
  SYS "MessageTrans_CloseFile", msgs_file_desc% TO ;flags%
d2537 1
a2537 1
  IF (flags% AND 1) THEN REPORT
d2541 1
a2541 1
  SYS "OS_Module", 7,,msgs_file_desc% TO ;flags%
d2543 1
a2543 1
  IF (flags% AND 1) THEN REPORT
d2606 34
d2641 1
a2641 2
    LOCAL min%, min2%
    min2%=Zones%*SecSize%
a2642 1
    IF (min%<min2%) AND (LinkBits%<=15) THEN min%=min2%
d2644 1
a2644 1
    WHILE (253*(SecSize%<<Log2ShareSize%)<min%)
@


4.9
log
@Fix infinite loop introduced in 2.55.
A missing ENDPROC in the ON ERROR handler meant that a completely uninitialised drive would just keep trying to dismount (worked OK if it had previously been formatted) forever.

Version 2.59. Tagged as 'HForm-2_59'
@
text
@a2 1
REM Version and date are in Messages file, please update in there.
d4 3
a6 1
REM for SCSI hard discs, see SCSI user guide
d14 2
a15 2
REM For formatting with idlen>15, we have to allow the formatter
REM to select a larger idlen value.
a16 1
REM MaxLinkBits% sets the maximum value of idlen
d19 4
a22 1
MaxLinkBits%=19: REM allow 16 bit idlen
d25 7
d33 2
a34 7
#ifdef IsSCSIForm
REM SCSIFS with USB needs a minimum amount of RMA to mount a drive
SYS"XOS_Module",5TO,,,size%
IFsize%<32*1024THEN
  newsize%=(32*1024)-size%
  SYS"XOS_ChangeDynamicArea",1,newsize%
ENDIF
d36 1
a36 8
REM Determine if it looks like a Phoebe ADFS
  TwinIDE%=FALSE
SYS"XOS_SWINumberFromString",,"ADFS_IDEDeviceInfo" TO ;F%
IF F% AND 1 THEN
  TwinIDE%=FALSE
ELSE
  TwinIDE%=TRUE
ENDIF
a38 10
REM default closing status indicates a panic
#ifdef IsSCSIForm
*set SCSIForm$EndStatus 1
#else
*set HForm$EndStatus 1
#endif
Log2ShareSize%=0:REM Unit of sharing
ShareSize%=1<<Log2ShareSize%:REM Sharing multiple
dev%=FALSE
Verbose%=dev%
d43 1
d45 6
a50 2
VDU 26 : VDU 12
PROCInit:REM Opens the message file as its first action.
d54 6
a59 6
IF NOT BigADFS% THEN   
    REM Check that disc not too big
    IF (DiscSize2%<>0 OR (DiscSize% AND &E0000000)<>0) THEN
        PROCmessage_print_0("DiscSizeError")
        PROCfinish
    ENDIF
d66 1
a66 2

IF FNFileCoreVersion<=298 THEN
a70 2


d73 2
a74 1
IF FNchoose_no_lookup("Q03:",FNmessage_lookup_1("SureChoose", STR$(Drive%)),"YN", "")="N" PROCfinish
d89 3
a91 11
#ifdef IsSCSIForm
REM *RMREINIT SCSIFS
OSCLI("-SCSI-%MOUNT :"+STR$Drive%)
OSCLI("-SCSI-%FREE :"+STR$Drive%)
OSCLI("-SCSI-%DISMOUNT :"+STR$Drive%)
#else
REM *RMREINIT ADFS
OSCLI("-ADFS-%MOUNT :"+STR$Drive%)
OSCLI("-ADFS-%FREE :"+STR$Drive%)
OSCLI("-ADFS-%DISMOUNT :"+STR$Drive%)
#endif
a93 3
#ifdef IsSCSIForm
*set SCSIForm$EndStatus 0
#else
a94 1
#endif
d98 1
d101 5
a105 3
#ifdef IsSCSIForm
PROCopen_message_file("<SCSIForm$Dir>.Messages")
#else
d107 3
a109 1
#endif
d112 58
a169 27
PRINT ''
#ifdef IsSCSIForm
autoreply$=FNreadvarval("SCSIForm$Autoreply")
#else
autoreply$=FNreadvarval("Hform$Autoreply")
#endif
#ifdef IsSCSIForm
SYS"XOS_Module",18,"SCSIFS" TO ,,,A%;F%
IF F%AND1 PROCmessage_print_0("NoSCSIFS"):PROCfinish
#else
SYS"XOS_Module",18,"ADFS" TO ,,,A%;F%
IF F%AND1 PROCmessage_print_0("NoADFS"):PROCfinish
#endif
A%+=A%!20
WHILE (?A%<>32) AND (?A%<>9) AND (?A%<>0):A%+=1:ENDWHILE
IF ?A%=0 PROCfinish
WHILE (?A%<ASC"0") OR (?A%>ASC"9"):A%+=1:ENDWHILE
ADFSVersion%=((?A%-ASC"0")*10+(A%?2)-ASC"0")*10+(A%?3)-ASC"0"

#ifdef IsSCSIForm
IF ADFSVersion%<114 THEN PROCmessage_print_0("SCSIFSTooOld"):PROCfinish
SYS"SCSIFS_Drives" TO ,FDisks%,HDiscs%
HDiscs%+=FDisks%
#else
SYS"ADFS_Drives" TO ,,HDiscs%
#endif
IF HDiscs%<1 PROCmessage_print_0("NoHardDiscs"):PROCfinish
d171 7
a177 1
REM Find out what we are really dealing with here
d179 7
a185 1
BigADFS%=FNBigADFS
d187 19
a205 15
#ifdef IsSCSIForm

DIM mBuf% 128
DIM Dev%(256)
PRINT"SCSI Devices found:":PRINT
l%=0
FORi%=0TO31
 FORj%=0TO127STEP4:mBuf%!j%=13:NEXTj%
 SYS"XSCSI_Initialise",3,i%,mBuf%,128
 IF mBuf%!8<>13THEN
  FORk%=i%TO&ff STEP &20
    FORj%=0TO127STEP4:mBuf%!j%=13:NEXTj%
    SYS"XSCSI_Initialise",3,k%,mBuf%,128
    IF mBuf%!8=13THEN
      k%=&100
d207 1
a207 5
      IF ((mBuf%?7=&44) AND (mBuf%!8 = &63657269)) THEN
        Dev%(l%)=k%
        PRINTSTR$~(l%)+" : "+$mBuf%
        l%+=1
      ENDIF
d209 3
a211 3
  NEXTk% 
 ENDIF 
NEXT
d213 2
a214 24
Dev%(l%)=256
Drive%=-1
SCSIID%=8
IFl%=0THENPROCmessage_print_0("NoHardDiscs"):PROCfinish
WHILE SCSIID% > l%-1
 SCSIID%=FNAsk("DriveAsk",0,0)
ENDWHILE
SCSIID%=Dev%(SCSIID%)
SYS"SCSIFS_Partitions",1,SCSIID% TO,,Drive%
IF (Drive%)>HDiscs% THEN
#else
DriveOffset%=INSTR(autoreply$,"Drive=")
IF (DriveOffset%<>0) THEN
    Drive%=VAL(MID$(autoreply$,DriveOffset%+6))
ELSE
    REPEAT
         Drive%=FNAsk("DriveAsk",4,4)
    UNTIL Drive%>=4 AND Drive%<=7
ENDIF
IF (Drive%-3)>HDiscs% THEN
#endif
 PROCmessage_print_1("SillyDiscNum", STR$(HDiscs%))
 PROCfinish
ENDIF
d216 3
a218 2
#ifdef IsSCSIForm
REM Determine drive info
d220 6
a225 14
SYS"SCSI_Initialise",2,SCSIID%,mBuf%//TO;flags%
//IF (flags$AND1)THENPROCmessage_print_0("NoHardDiscs"):PROCfinish :REM.. need better message
SecSize%=mBuf%!12
Cap= (mBuf%!8)*SecSize%/1024/1024:Cap%=INT(Cap)
Rem=Cap-Cap% :IF Rem<0.5THENELSECap%+=1
PRINT "Disc capacity :";+STR$(Cap%)+"Mbytes"

IDEAddressSpace%=mBuf%!8
IDE%=1 :REM fool below to use 512 sector size
IDEHasLBA%=1
IDEname$=""
IDEcyls%=0
      IDEheads%=16
      IDEsecs%=63
d227 43
a269 20
        IDEheads%+=1
        IDEcyls%=IDEAddressSpace% DIV IDEheads%
        IDEsecs%=63
        WHILE IDEcyls% MOD IDEsecs% //AND IDEsecs%>63
          IDEsecs%-=1
        ENDWHILE                                   
        IDEcyls%=IDEcyls% DIV IDEsecs%
      UNTIL((IDEcyls%<=65535) AND (IDEheads%<=255))
      
      PROCmessage_print_3("IDEConfSuggest", STR$(IDEcyls%), STR$(IDEheads%), STR$(IDEsecs%))
EnglishMake$="OTHER"
Cyls%=IDEcyls%:Heads%=IDEheads%:SecsPerTrk%=IDEsecs%:ParkCyl%=Cyls%+1:
InitFlag%=1:LBAFlag%=1
#else
IF ADFSVersion% < 210 THEN
 IDE%=FALSE
ELSE
 SYS"ADFS_ControllerType",Drive% TO DriveType%
 IF DriveType%=0 THEN
  PROCmessage_print_1("DriveNotPresent", STR$(Drive%))
a270 5
 ELSE
  IF DriveType%=3 PROCmessage_print_1("DriveIsST506", STR$(Drive%))
  IF DriveType%=4 PROCmessage_print_1("DriveIsIDE", STR$(Drive%))
 ENDIF
 IDE%=DriveType%=4
d272 104
a375 69
IF IDE% THEN
 DIM IDEid% 512
ENDIF
 IF TwinIDE% THEN
   REM determine physical drive number which corresponds to logical drive
   IDEdrive%=-1
   FOR N%=0 TO 3
     SYS "ADFS_IDEDeviceInfo",0,N% TO ,B%,C%,D%
     IF (C%=Drive%) AND (B%=1) THEN
       IDEdrive%=N%
       REM copy the data from the device ID to a local copy of it
       FOR A%=0 TO 512-4 STEP 4
         IDEid%!A%=D%!A%
       NEXT A%
     ENDIF
   NEXT N%
   IF IDEdrive%=-1 THEN
     fail%=TRUE
   ELSE
     fail%=FALSE
   ENDIF
 ELSE
   REM Determine whether this is IDE drive 0/1
   SYS"XADFS_ControllerType",Drive%-1 TO A%;F%
   IF ((F%AND1)=0) AND (A%=4) THEN IDEdrive%=1 ELSE IDEdrive%=0
   DIM IDEpb% 7
   IDEpb%!0=0
   IDEpb%!4=0
   IDEpb%?5=&A0+(IDEdrive%<<4)
   IDEpb%?6=&EC
   SYS"ADFS_IDEUserOp",1<<24,,IDEpb%,IDEid%,512 TO r0%,,,,r4%
   IF r0%<>0 OR r4%<>0 THEN
     fail%=TRUE
   ELSE
     fail%=FALSE
   ENDIF
 ENDIF
 IF fail% THEN
  PROCmessage_print_1("DiscIdError", STR$~(r0%))
  IDEcyls%=0:IDEheads%=0:IDEsecs%=0
 ELSE
  IDEcyls%=(IDEid%!2)AND&FFFF
  IDEheads%=(IDEid%!6)AND&FFFF
  IDEsecs%=(IDEid%!12)AND&FFFF
  IDECapacity%=IDEcyls%*IDEheads%*IDEsecs%
  IDEAddressSpace%=(IDEid%!(60*2))
  IF (((IDEid%!98)>>9)AND1)<>0 THEN IDEHasLBA%=1 ELSE IDEHasLBA%=0
  IDEname$=""
  FOR I%=27*2 TO 46*2+1
   A%=(IDEid%?(I%EOR1))
   IF (A%<32) OR (A%>=127) A%=ASC"."
   IDEname$+=CHR$(A%)
  NEXT
  IDEfirm$=""
  FOR I%=23*2 TO 26*2+1
   A%=(IDEid%?(I%EOR1))
   IF (A%<32) OR (A%>=127) A%=ASC"."
   IDEfirm$+=CHR$(A%)
  NEXT
  PROCmessage_print_3("IDEDescription", STR$(Drive%), IDEname$, IDEfirm$)
  PROCmessage_print_3("IDEConfiguration", STR$(IDEcyls%), STR$(IDEheads%), STR$(IDEsecs%))
  IF IDEHasLBA%<>0 THEN
    PROCmessage_print_0("IDEHasLBA")
    IF ((IDEid%!(83*2))AND&C400)=&4400 THEN IDEHasLBA48%=1 ELSE IDEHasLBA48%=0
    IF IDEHasLBA48%<>0 THEN
      IDEAddressSpace%=(IDEid%!(100*2))
      IDEAddressSpace2%=(IDEid%!(102*2))
      IF (IDEAddressSpace% AND &E0000000) OR IDEAddressSpace2% THEN
        IDEAddressSpace%=&20000000
d378 16
a393 3
    PROCmessage_print_1("IDELBASize", STR$(IDEAddressSpace%))
    IF IDEAddressSpace%>IDECapacity% THEN
      IDEheads%=16
d395 2
a396 2
      IDEsecs%=255
      WHILE IDEcyls% MOD IDEsecs% AND IDEsecs%>63
d398 1
a398 1
      ENDWHILE
d400 8
a407 6
      PROCmessage_print_3("IDEConfSuggest", STR$(IDEcyls%), STR$(IDEheads%), STR$(IDEsecs%))
    ENDIF
  ENDIF
 ENDIF
#endif
ENDIF
a450 7
EndDefect%=1 << 29

REM EndDefect2% gives the terminator word for a second
REM defect list.

EndDefect2%=1<<30

a455 14
#ifdef IsSCSIForm
IF BigADFS% THEN
    AdfsSwi%=&4098D: REM SCSIFS_SectorDiscOp
ELSE
    AdfsSwi%=&40980: REM SCSIFS_DiscOp
ENDIF
#else
IF BigADFS% THEN
    AdfsSwi%=&4024D: REM ADFS_SectorDiscOp
ELSE
    AdfsSwi%=&40240: REM ADFS_DiscOp
ENDIF
#endif

d479 6
a484 3
#ifndef IsSCSIForm
SecsPerTrk%=32:Heads%=1:Cyls%=1:ParkCyl%=1
#endif
d492 1
a492 1
IF BigADFS%
d507 1
a507 1
   SectorsPerDisc%=IDEAddressSpace%
d509 1
a509 1
   SectorsPerDisc%=IDECapacity%
d515 1
a515 1
    BigDisc%=TRUE
d517 1
a517 1
    BigDisc%=FALSE
d520 1
a520 4

#ifndef IsSCSIForm
SYS"ADFS_Retries",&ff,0 TO ,,adfs_retries%
#endif
d522 2
a523 11
#ifdef IsSCSIForm
ON ERROR LOCAL : ON ERROR OFF : PROCAsm : ENDPROC
#else
ON ERROR LOCAL : ON ERROR OFF : SYS"ADFS_Retries",&ff,adfs_retries% : PROCAsm : ENDPROC
#endif

#ifdef IsSCSIForm
OSCLI("-SCSI-%DISMOUNT :"+STR$Drive%)
#else
OSCLI("-ADFS-%DISMOUNT :"+STR$Drive%)
#endif
d525 1
a525 3
#ifndef IsSCSIForm
SYS"ADFS_Retries",&ff,adfs_retries%
#endif
d527 1
a528 1
:
d530 3
a533 1
DEF PROCGetShape
d537 8
a544 4
#ifndef IsSCSIForm
SYS"ADFS_Retries",&ff,0 TO ,,adfs_retries%
PROCMoanOp(Restore%,0,0,0)
#endif
d546 1
a546 3
#ifndef IsSCSIForm
SYS"ADFS_Retries",&ff,adfs_retries%
#endif
d557 21
a577 19
#ifndef IsSCSIForm
 IF IDE% THEN
  IF NOT FNCompareMake THEN
   REM Drive not recognised - offer choice or custom specs.
   IF INSTR(autoreply$,"NOunknown") PROCabort(FNmessage_lookup_0("UnknownDriveType"),1)
#endif
   PROCAskMake
#ifndef IsSCSIForm
  ENDIF
 ELSE
  REM ST506 drives do not identify themselves .. ask the user.
  PROCAskMake
 ENDIF
#endif
 FOR I%=0 TO BootSize%-4
  Boot%!I%=0
 NEXT I%
 Boot%!0=EndDefect%
 Boot%!4=EndDefect2%
a585 3
#ifdef IsSCSIForm
PROCmessage_print_1("WillFormat", "")
#else
a586 1
#endif
d592 1
d624 1
d626 38
a663 27
#ifndef IsSCSIForm
PROCrestoreparams(IDE%)
Makes%=0
I%=INSTR(autoreply$,"DriveType:")
IF I%<>0 THEN
 I%+=LEN("DriveType:")
 Make%=EVAL(MID$(autoreply$,I%,INSTR(autoreply$,",",I%)-I%))
ELSE
 PROCmessage_print_0("DriveDisclaim")
 REPEAT : REM list all the drive descriptions available
  READ EnglishMake$, TokenMake$
  TransMake$=FNmessage_lookup_0(TokenMake$)
  Makes%+=1
  PROCmessage_print_2("MakeMenu", RIGHT$(" "+STR$Makes%,2), TransMake$)
  FOR I%=1 TO MakeParams%
   READ A$
  NEXT I%
 UNTIL EnglishMake$="OTHER"
 PRINT 
 Make%=FNInputDec("ManufacturerDec",1,Makes%)
 PROCrestoreparams(IDE%)
ENDIF
I%=(Make%-1)*(MakeParams%+2)
WHILE I%>0
 READ A$
 I%-=1
ENDWHILE
d665 7
a671 14
 READ EnglishMake$, TokenMake$, SecsPerTrk%, Heads%, Cyls%, InitFlag%, Dummy%, ParkCyl%, LBAFlag%
ELSE
 READ EnglishMake$, TokenMake$, SecsPerTrk%, Heads%, Cyls%, LowCurrentCyl%, PreCompCyl%, ParkCyl%
ENDIF
TransMake$=FNmessage_lookup_0(TokenMake$)
#endif
IF IDE% THEN
 IF (EnglishMake$="OTHER") AND (IDEcyls%<>0) THEN
  SecsPerTrk%=IDEsecs%
  Heads%=IDEheads%
  Cyls%=IDEcyls%
  InitFlag%=1
  LBAFlag%=1
  IF INSTR(autoreply$,"LBA:On")<>0 THEN
d673 1
a673 1
  ELSE
d675 1
a675 1
          LBAFlag%=0
d677 1
a678 1
 ENDIF
d683 1
d686 39
a724 24
#ifndef IsSCSIForm
PROCrestoreparams(IDE%)
REPEAT
READ EnglishMake$, TokenMake$, P1%, P2%, P3%, P4%, P5%, P6%
IF IDE% THEN
READ P7%
IF P7%<>0 THEN P7%=1
ENDIF
TransMake$=FNmessage_lookup_0(TokenMake$)
#endif
IF EnglishMake$="OTHER" THEN
 PROCmessage_print_0("NonStandardShape")
 PROCprintshape(IDE%)
 PRINT
 =FNChoose("Q04:","RetainShapeChoose","YN","")="Y"
ENDIF
#ifndef IsSCSIForm
matched%=TRUE
IF IDE% THEN
 IF P1%<>SecsPerTrk% OR P2%<>Heads% OR P3%<>Cyls% OR P4%<>InitFlag% OR P6%<>ParkCyl% OR P7%<>LBAFlag% THEN matched%=FALSE
ELSE
 IF P1%<>SecsPerTrk% OR P2%<>Heads% OR P3%<>Cyls% OR P4%<>LowCurrentCyl% OR P5%<>PreCompCyl% OR P6%<>ParkCyl% THEN matched%=FALSE
ENDIF
UNTIL matched%
a725 2
PROCmessage_print_1("StandardShape", TransMake$)
#endif
d731 1
d743 1
d758 1
d855 1
a855 1
            IF Defect%!(ptr%+4)<EndDefect2% PROCmessage_print_0("CurrentDefects")
d862 1
a862 1
    WHILE ((Defect%!ptr%<EndDefect%) AND NOT BigDisc%) OR (Defect%!ptr%<EndDefect2% AND BigDisc%)
d925 1
a925 1
                PROCmessage_print_0("DFormatDefect1")
d939 1
d972 1
d998 1
a998 1
        IF BigADFS% THEN
d1004 1
a1004 1
            IF Defect%!ptr%>EndDefect% AND Defect%!ptr%<EndDefect2% AND BigADFS% AND BigDisc% AND defectlist%=0 THEN
d1028 1
a1028 1
                 IF BigADFS% THEN
d1084 1
a1084 1
      IF BigADFS% THEN
d1117 5
a1121 1
      IF (SusCount%?sus%>30) OR dev% THEN
d1158 1
d1168 1
d1176 1
d1183 1
d1193 1
d1203 1
d1221 1
d1293 1
d1570 1
d1590 1
d1599 1
d1613 1
d1623 1
d1630 1
d1640 1
d1647 1
d1672 1
a1672 1
    Boot%!ptr%=EndDefect2% OR check%
d1684 1
d1700 1
d1742 1
d1790 1
d1804 1
d1835 1
a1835 1
            IF (add% < (&20000000>>>Log2SecSize%)) THEN
d1883 1
d1927 1
d1945 1
d1956 2
a1957 2
 IF defect%<EndDefect2% PROCCheckPut(defect%)
UNTIL (defect% >= EndDefect2%) OR NOT good%
d1964 1
d1975 1
d2005 1
d2008 1
a2008 1
Boot%!4=EndDefect2%
d2024 1
d2050 1
d2074 1
d2088 1
d2098 1
d2109 1
d2125 1
d2130 1
d2150 3
a2152 1
    IF dev% PRINTString$;" ";MID$(autoreply$,start,end-start)
d2170 1
d2180 1
d2186 1
d2195 1
d2200 1
d2203 1
d2226 1
d2232 1
d2238 1
d2240 8
a2247 6
IF BigADFS% THEN
#ifdef IsSCSIForm
    SYS &20000 OR AdfsSwi%, 0, b% OR AltDefectBit% OR (DiscRec%<<6), C% OR Drive%<< 29, D%, E%
#else
    SYS AdfsSwi%, 0, b% OR AltDefectBit% OR (DiscRec%<<6), C% OR Drive%<< 29, D%, E%
#endif
d2249 1
a2249 1
    SYS AdfsSwi%, 0, b% OR AltDefectBit% OR (DiscRec%<<6), (C%*SecSize%) OR Drive%<< 29, D%, E%
d2254 1
d2256 2
a2257 2
IF BigADFS% THEN
    SYS AdfsSwi% OR (1<<17), 0, b% OR AltDefectBit% OR (DiscRec%<<6), C% OR Drive%<< 29, D%, E% TO Result%, R1%, ErrDiscAdd%
d2259 1
a2259 1
    SYS AdfsSwi% OR (1<<17), 0, b% OR AltDefectBit% OR (DiscRec%<<6), (C%*SecSize%) OR Drive%<< 29, D%, E% TO Result%, R1%, ErrDiscAdd%
d2288 1
d2311 1
d2325 1
a2325 5
#ifdef IsSCSIForm
  PRINT"SCSIForm failed : ";why$;" at line ";ERL
#else
  PRINT"HFORM failed : ";why$;" at line ";ERL
#endif
d2341 1
a2342 3
#ifdef IsSCSIForm
*set SCSIForm$EndStatus 20
#else
a2343 1
#endif
d2349 1
a2354 1
#ifndef IsSCSIForm
d2356 12
d2377 1
d2394 12
a2405 1
DATA Conner Peripherals 40MB - CP3044,          TypeCP3044,     40,  4,   526, 1, 0,   525,  0
d2407 1
a2407 14
REM Note that this drive is _physically_labelled_ as CP2044PK
DATA Conner Peripherals 42MB - CP2044,          TypeCP2044PK,   38,  4,   548, 1, 0,   547,  0
DATA Conner Peripherals 63MB - CP2064,          TypeCP2064,     38,  4,   823, 1, 0,   822,  0
DATA Conner Peripherals 210MB - CFS210A,        TypeCFS210A,    38, 16,   685, 1, 0,   684,  0
DATA Conner Peripherals 270MB - CFS270A,        TypeCFS270A,    63, 14,   600, 1, 0,   599,  0
DATA Conner Peripherals 420MB - CFS420A,        TypeCFS420A,    63, 16,   826, 1, 0,   825,  0
DATA Conner Peripherals 425MB - CFS425A,        TypeCFS425A,    62, 16,   839, 1, 0,   838,  0
DATA Conner Peripherals 850MB - CFS850A,        TypeCFS850A,    63, 16,  1651, 1, 0,  1650,  1
DATA Maxtor 2B010H1,                            Type2B010H1,   189, 16,  6618, 1, 0,  6617,  1
DATA Maxtor 2B020H1,                            Type2B020H1,    63, 16, 39703, 1, 0, 39702,  1
DATA Maxtor 4D040H2,                            Type4D040H2,   252, 16, 19852, 1, 0, 19851,  1
DATA SAMSUNG SV8004H,                           TypeSV8004H,   249, 16, 39249, 1, 0, 39248,  1

DATA OTHER,                                     TypeOTHER,      1,  1,      1, 1, 1,     1,  1: REM Must be last, numbers irrelevant (except must be non zero).
d2409 1
a2421 1
#endif
d2425 1
a2425 1
REM infinit wisdom) needs its 16 byte block and the filename in the RMA.
d2429 1
d2445 1
d2468 1
d2472 1
d2476 1
d2480 1
d2484 1
d2494 1
d2499 1
d2504 1
d2509 1
d2514 1
d2522 1
a2522 15
REM This function returns TRUE if ADFS is the big version, or FALSE if
REM it is not

DEF FNBigADFS
    LOCAL Misc_InfoPtr%
    LOCAL ERROR
    ON ERROR LOCAL:RESTORE ERROR:=FALSE
#ifdef IsSCSIForm
    SYS "SCSIFS_MiscOp",6 TO Misc_InfoPtr%
#else
    SYS "ADFS_MiscOp",6 TO Misc_InfoPtr%
#endif
    RESTORE ERROR
    =((!Misc_InfoPtr%) AND (1<<9))=(1<<9)

d2535 1
d2548 1
d2557 3
a2559 3
DEF FNFileCoreVersion
LOCAL code%, help$, help%
SYS "OS_Module",18,"FileCore" TO ,,,code%
d2561 1
a2562 1

a2563 16

WHILE (?help%)<>0
  help$+=CHR$?help%
  help%+=1
ENDWHILE

=INT(VAL(MID$(help$,INSTR(help$,".")-1))*100)

DEF FNADFSVersion
LOCAL code%, help$, help%
SYS "OS_Module",18,"ADFS" TO ,,,code%

help$=""

help%=(code%!&14)+code%

d2571 1
d2576 1
a2576 1
  DOSBuf%!i%=0
d2583 1
a2611 1

d2616 17
a2632 35
// brec%?2  =   0                :REM secs/cluster
// brec%?3  =   0                :REM reserved secs lo byte
// brec%?4  =   0                :REM reserved secs hi byte
// brec%?5  =   0                :REM FATS
// brec%?6  =   0                :REM Root entries lo byte
// brec%?7  =   0                :REM Root entries hi byte
// brec%?8  =   0                :REM Small Secs lo byte
// brec%?9  =   0                :REM Small Secs hi byte
// brec%?10 =   0                :REM Media Descr
// brec%?11 =    0               :REM Secs/FAT lo byte
// brec%?12 =    0               :REM Secs/FAT hi byte
 brec%?13 =    SecsPerTrk%     :REM Secs/track lo byte
 brec%?14 =    SecsPerTrk%>>8  :REM Secs/track hi byte
 brec%?15 =    Heads%          :REM Heads lo byte
 brec%?16 =    Heads%>>8       :REM Heads hi byte
// DOSBuf%!28 = 0                :REM Hidden secs lo
 DOSBuf%!32 = ( (Cyls% * (Heads%+1) ) * SecsPerTrk%) + SecsPerTrk% -1 :REM Larg disc sectors

REM brec%=DOSBuf%+&1be
REM REM ensure no dos bootable partition 
REM brec%?&0 = &0
REM brec%?&1 = 0
REM brec%?&2 = 0
REM brec%?&3 = 0
REM brec%?&4 = &41
REM brec%?&5 = Heads%
REM brec%?&6 = SecsPerTrk% + (Cyls%>>8)
REM brec%?&7 = Cyls%
REM brec%!&8 = 0
REM brec%!&c = DOSBuf%!32
REM brec%?&10 = &0
REM brec%?&20 = &0
REM brec%?&30 = &0
REM REM Change the partition ID type to &41 .. 
 
@


4.8
log
@Fix broken HForm, fix version numbers, rewrite makefile to avoid HForm/SCSIForm mixups
Detail:
  bas/!RunImage, Makefile - Removed an errant space that was breaking HForm. Changed #defines from HForm/SCSIForm to IsHForm/IsSCSIForm to prevent system variables and other text being replaced by the preprocessor.
  Makefile, crunch/!RI_HForm,ffe, crunch/!RI_SCSIForm,ffe, crunch/!RunImage,ffe - Rewrote makefile so that the intermediate runimage files get built to seperate locations for HForm & SCSIForm. This is a workaround for the wrong runimage being used if the 'install disc' phase is re-run after performing a disc build.
  bas/!RunImage, Makefile, Resources/UK/HForm/Messages, Resources/UK/SCSIForm/Messages - Version numbers are now provided by the AwkVers script instead of being hard-coded in the messages files.
  Resources/UK/* - Deleted obsolete resource files from before HForm was able to build SCSIForm
Admin:
  Tested HForm on an Iyonix by formatting a spare drive. SCSIForm runs, but formatting is untested.
  Fixes HForm 'SWI name not known' error reported on forums: http://www.riscosopen.org/forum/forums/5/topics/556


Version 2.58. Tagged as 'HForm-2_58'
@
text
@d478 1
a478 1
ON ERROR LOCAL : ON ERROR OFF :  PROCAsm :
d480 1
a480 1
ON ERROR LOCAL : ON ERROR OFF : SYS"ADFS_Retries",&ff,adfs_retries% : PROCAsm :
@


4.7
log
@	update of HForm to build !SCSIForm to format SCSI media in
	USB Mass storage to filecore format
Detail:
        Builds either HForm or SCSIForm form relevant !Mk files.
	Also added code to ensure that when formatting filecore format
	any DOS format info is removed, and an appropriate boot sector
	installed to permit reformatting with DOS format by DOS machines.
	(this stops ambiguous usage)
Admin:
	Not exhaustively tested..
	HForm builds.. will need doublechecking before any release is made
	from this version.
	SCSIForm has been reasonably well tested.. will be released initially
	on the beta test site for further scrutiny.
	Castle added IP


Version 2.55. Not tagged
@
text
@d23 1
a23 1
#ifdef SCSIForm
d42 1
a42 1
#ifdef SCSIForm
d98 1
a98 1
#ifdef SCSIForm
d111 1
a111 1
#ifdef SCSIForm
d121 1
a121 1
#ifdef SCSIForm
d127 3
a129 1
#ifdef SCSIForm
d134 1
a134 1
#ifdef SCSIForm
d147 1
a147 1
#ifdef SCSIForm
d160 1
a160 1
#ifdef SCSIForm
d211 1
a211 1
#ifdef SCSIForm
d246 1
a246 1
 SYS"ADFS _ControllerType",Drive% TO DriveType%
d397 1
a397 1
#ifdef SCSIForm
d434 1
a434 1
#ifndef SCSIForm
d473 1
a473 1
#ifndef SCSIForm
d477 1
a477 1
#ifdef SCSIForm
d483 1
a483 1
#ifdef SCSIForm
d489 1
a489 1
#ifndef SCSIForm
d501 1
a501 1
#ifndef SCSIForm
d506 1
a506 1
#ifndef SCSIForm
d519 1
a519 1
#ifndef SCSIForm
d526 1
a526 1
#ifndef SCSIForm
d546 1
a546 1
#ifdef SCSIForm
d588 1
a588 1
#ifndef SCSIForm
d643 1
a643 1
#ifndef SCSIForm
d659 1
a659 1
#ifndef SCSIForm
d2130 1
a2130 1
#ifdef SCSIForm
d2209 1
a2209 1
#ifdef SCSIForm
d2230 1
a2230 1
#ifdef SCSIForm
d2245 1
a2245 1
#ifndef SCSIForm
d2397 1
a2397 1
#ifdef SCSIForm
@


4.6
log
@Added support for larger (128GB-256GB) IDE discs.

Version 2.54
@
text
@d17 1
d23 8
d32 1
a32 1

d39 1
d42 3
d46 1
d58 1
d60 1
d68 3
a70 3
FormatFlag%=(FNChoose("Q01:","FormatOrInitChoose","FI","")="F")
SoakStyle$=FNChoose("Q02:","SoakTestChoose","LSN", "")
BootOpt$=FNChoose("BootOpt:","BootOptChoose","YN", "")
d77 1
a77 1
  BigDir%=FNChoose("BigDir:","BigDirChoose","YN","")="Y"
d98 6
d108 1
d111 3
d115 1
d121 3
d125 1
d127 3
a129 1

d131 5
a135 1

d138 1
d144 6
d151 1
d154 1
a154 1
REM Find out what we're really dealing with here
d158 37
a202 1

d204 1
d208 33
d244 1
a244 1
 SYS"ADFS_ControllerType",Drive% TO DriveType%
d256 1
a256 1
 
d338 1
d393 1
d395 7
d407 1
d432 1
d434 1
d455 1
d461 1
a463 1

d470 2
d473 1
d475 9
a483 1
ON ERROR LOCAL : ON ERROR OFF : SYS"ADFS_Retries",&ff,adfs_retries% : PROCAsm : ENDPROC
d485 1
d487 1
d489 1
d499 1
d502 1
d504 1
d506 2
d515 1
a515 1

d517 1
d522 1
d524 1
d527 1
a527 1
  REM ST506 drives don't identify themselves .. ask the user.
d530 1
d534 2
a535 1
 PROCInitBootDefects
d539 8
d548 1
a584 1
 
d586 1
d619 1
a619 1

a633 1
  ParkCyl%=IDEcyls%-1
d641 1
d650 1
d657 1
d667 1
d1192 1
a1192 1
   defectlist%=0:REM We're in the first defect list
d1223 1
d1234 1
a1234 1
 Alloc%=FNAsk("AllocUnitAsk",2^Log2Alloc%,256)
d1238 2
a1239 1
 UNTIL Alloc%=2^Log%:REM OR Log%=13
d1488 1
d1909 1
a1909 1
REM Initialises an empty boot block defect list.  As we don't know
d1921 5
d2128 3
d2132 1
d2207 5
a2211 1
  PRINT'"HFORM failed : ";why$;" at line ";ERL
d2228 3
d2232 1
d2243 1
d2260 1
a2260 1
REM the string below must *exactly* match those produced by the drive's 
d2298 2
d2341 1
a2341 1
REM are no |M's in the strings for these, or BASIC will think it is
d2362 2
a2363 2
REM Procedures for printing a looked string - can't use PRINT as we want
REM to put |M's (char 13 - end of BASIC string) in the strings. 
d2389 1
a2389 1
REM it isn't
d2395 3
d2399 1
d2464 86
@


4.5
log
@Added support for reading the LBA size of a hard disc, and suggesting a suitable
CHS translation.

Parking address for large discs now set correctly.

A few newer Maxtor and Samsung drives added.

Version 2.53
@
text
@d11 1
a11 1
REM sector address.
d185 1
d187 2
a188 3
  IF (((IDEid%!98)>>9)AND1)<>0 THEN IDEHasLBA%=1 ELSE IDEHasLBA%=0
  FOR I%=27*2 TO 46*2 STEP 2
   A%=(IDEid%?(I%+1)) : B%=(IDEid%?I%)
a190 2
   IF (B%<32) OR (B%>=127) B%=ASC"."
   IDEname$+=CHR$(B%)
d193 2
a194 2
  FOR I%=23*2 TO 26*2 STEP 2
   A%=(IDEid%?(I%+1)) : B%=(IDEid%?I%)
a196 2
   IF (B%<32) OR (B%>=127) B%=ASC"."
   IDEfirm$+=CHR$(B%)
d202 8
@


4.4
log
@Version number check removed - now just checks for SWI availability
@
text
@d206 11
d306 1
a306 1
 LBAflag%=0
d407 1
a407 1
 LBAflag%=(BootRec%?-6)
d449 1
a449 1
 READ EnglishMake$, TokenMake$, SecsPerTrk%, Heads%, Cyls%, InitFlag%, Dummy%, ParkCyl%, LBAflag%
d479 5
a483 1
READ EnglishMake$, TokenMake$, P1%, P2%, P3%, P4%, P5%, P6%, P7%
d493 1
a493 1
 IF P1%<>SecsPerTrk% OR P2%<>Heads% OR P3%<>Cyls% OR P4%<>InitFlag% OR P6%<>ParkCyl% OR P7%<>LBAflag% ENDIF: matched%=FALSE
d495 1
a495 1
 IF P1%<>SecsPerTrk% OR P2%<>Heads% OR P3%<>Cyls% OR P4%<>LowCurrentCyl% OR P5%<>PreCompCyl% OR P6%<>ParkCyl% ENDIF: matched%=FALSE
d508 1
a508 1
 PROCmessage_print_3("PrintShape3IDE", STR$(ParkCyl%), STR$(InitFlag%), STR$(LBAflag%))
d519 1
a519 1
 READ EnglishMake$, TokenMake$, SecsPerTrk%, Heads%, Cyls%, InitFlag%, Dummy%, ParkCyl%, LBAflag%
a538 1
    SecsPerTrk%=FNAsk("SectorsAsk",SecsPerTrk%,1)
d540 1
a540 13
        REPEAT
            Heads%=FNAsk("IDEHeadsAsk",Heads%,1)
            IF Heads%>16 PROCmessage_print_0("IDEHeads16")
        UNTIL Heads%<=16
    ELSE
        Heads%=FNAsk("ST506HeadsAsk",Heads%,1)
        IF Heads%>8 PROCmessage_print_0("ST506Heads8")
    ENDIF
    Cyls%=FNAsk("CylindersAsk",Cyls%,1)

    IF IDE% THEN
        InitFlag%=FNAsk("InitAsk",InitFlag%,0)
        IF IDEHasLBA% THEN
d548 1
a548 1
                   LBAflag%=FNAsk("LBAAsk",LBAflag%,0)
d552 1
a552 1
           LBAflag%=0
d554 20
d586 9
a594 4
IF IDEHasLBA% THEN
   IF SectorsPerDisc%>IDEAddressSpace% THEN SectorsPerDisc%=IDEAddressSpace%
ELSE
   IF SectorsPerDisc%>IDECapacity% THEN SectorsPerDisc%=IDECapacity%
d1576 1
a1576 1
            IF ((add%*SecSize%) AND &E0000000)=0 AND (add%>>>(32-Log2SecSize%))=0 THEN
d1759 1
a1759 1
 BootRec%?-6=LBAflag%
d1769 1
a1769 1
IF BigDisc%
d2081 1
a2081 1
DATA Conner Peripherals 40MB - CP3044,          TypeCP3044,     40,  4,  526, 1, 0,  525,  0
d2084 11
a2094 7
DATA Conner Peripherals 42MB - CP2044,          TypeCP2044PK,   38,  4,  548, 1, 0,  547,  0
DATA Conner Peripherals 63MB - CP2064,          TypeCP2064,     38,  4,  823, 1, 0,  822,  0
DATA Conner Peripherals 210MB - CFS210A,        TypeCFS210A,    38, 16,  685, 1, 0,  684,  0
DATA Conner Peripherals 270MB - CFS270A,        TypeCFS270A,    63, 14,  600, 1, 0,  599,  0
DATA Conner Peripherals 420MB - CFS420A,        TypeCFS420A,    63, 16,  826, 1, 0,  825,  0
DATA Conner Peripherals 425MB - CFS425A,        TypeCFS425A,    62, 16,  839, 1, 0,  838,  0
DATA Conner Peripherals 850MB - CFS850A,        TypeCFS850A,    63, 16, 1651, 1, 0, 1650,  1
d2096 1
a2096 1
DATA OTHER,                                     TypeOTHER,      1,  1,  1,   1, 1,  1, 1: REM Must be last, numbers irrelevant (except must be non zero).
@


4.3
log
@Made 32-bit compatible.

ADFS version check for twin IDE availability changed to version 3.33, as
that's the current Iyonix version.
@
text
@d24 2
a25 1
IF FNADFSVersion<=332 THEN
@


4.2
log
@Ursula branch merged
@
text
@d24 1
a24 1
IF FNADFSVersion<=329 THEN
d1907 1
a1907 1
 MOVS PC,R14
@


4.1
log
@Initial revision
@
text
@d2 1
d13 17
d44 1
a44 1
IF NOT BigADFS% THEN
d54 12
a138 3
 REM Determine whether this is IDE drive 0/1
 SYS"XADFS_ControllerType",Drive%-1 TO A%;F%
 IF ((F%AND1)=0) AND (A%=4) THEN IDEdrive%=1 ELSE IDEdrive%=0
d140 36
a175 7
 DIM IDEpb% 7
 IDEpb%!0=0
 IDEpb%!4=0
 IDEpb%?5=&A0+(IDEdrive%<<4)
 IDEpb%?6=&EC
 SYS"ADFS_IDEUserOp",1<<24,,IDEpb%,IDEid%,512 TO r0%,,,,r4%
 IF r0%<>0 OR r4%<>0 THEN
d271 1
a271 1
DIM Buf% &40000, DiscRec% 64+BootSize%, Defect% BootSize%, DirMark% 5, Bad%(MaxVerifyBad%),mc% 100, Pattern%(Patterns%-1)
d305 2
a306 2
Log2Alloc%=10:LinkBits%=10
PROCShareSize
d320 1
a320 1
IF (DiscSize%>=(512*1024*1024)) OR (DiscSize2%<>0) THEN
d384 1
a384 1
IF (DiscSize%>=(512*1024*1024)) OR (DiscSize2%<>0) THEN
d390 1
a390 1
SectorsPerDisc%=(DiscSize%>>Log2SecSize%)+(DiscSize2%<<(32-Log2SecSize%))
d572 1
a572 1
IF (DiscSize%>=(512*1024*1024)) OR (DiscSize2%<>0) THEN
d802 1
d804 1
a804 1
         WHILE Defect%!ptr%<add%
d820 2
d935 17
a953 1
 PROCShareSize
d961 1
a961 1
  LinkBits%=10
d967 1
a967 1
  IF LinkBits%>15 OR Zones%>127 THEN
d974 21
a994 3
   Crucial%=FNRoundUpShare(Zones%*2)*SecSize%+DirSize%
   IF MapZone%=0 Crucial%=BootAdd%*SecSize%+BootSize%
   IF Crucial%<Alloc%*(LinkBits%+1) Crucial%=Alloc%*(LinkBits%+1)
d1026 2
a1027 3
Log2Alloc%=9: REM requested by TCs ECR
PROCShareSize
IF Log2Alloc%<8 THEN Log2Alloc%=10:PROCShareSize
d1047 1
d1051 16
a1066 4
Crucial%=FNRoundUpShare(Zones%*2)*SecSize%+DirSize%
IF MapZone%=0 Crucial%=BootAdd%*SecSize%+BootSize%
IF Crucial%<Alloc%*(LinkBits%+1) Crucial%=Alloc%*(LinkBits%+1)
IF Crucial% MOD Alloc%<>0 Crucial%+=Alloc%-Crucial% MOD Alloc%
d1071 7
a1077 2
 RootDirAdd%=MapAdd%+FNRoundUpShare((MapLen%*2)/SecSize%)
 IndRootDirAdd%=&200+FNRoundUpShare(Zones%*2)/ShareSize%+1
d1088 5
d1098 2
d1131 3
a1133 3
  IF length%<LinkBits%+1 length%=LinkBits%+1
  PROCWriteLink(ZoneBit%,2)
  PROCWriteLength(ZoneBit%,length%)
d1139 15
a1153 4
   length%=Crucial% DIV Alloc%
   PROCWriteLink(ZoneBit%,2)
   PROCWriteLength(ZoneBit%,length%)
   ZoneBit%=ZoneBit%+length%
d1223 2
a1224 2
       IF NextDefect%>ZoneEndBit%-(LinkBits%+1) THEN
        NextDef%=ZoneEndBit%-(LinkBits%+1)
d1228 1
a1228 1
       IF NextDef%-DefectEnd%<LinkBits%+1 THEN
d1237 2
a1238 2
     IF DefectEnd%-DefectStart%<LinkBits%+1 THEN
      DefectEnd%=DefectStart%+LinkBits%+1
d1244 1
a1244 1
     IF DefectEnd%>ZoneEndBit%-(LinkBits%+1) AND DefectEnd%<>ZoneEndBit% THEN
d1248 2
a1249 2
     IF DefectEnd%-DefectStart%<LinkBits%+1 THEN
      DefectStart%=DefectEnd%-(LinkBits%+1)
d1257 1
a1257 1
   PROCWriteLink(PreFree%,ZoneBit%-PreFree%)
d1259 1
a1259 1
    PROCWriteLength(ZoneBit%,UsedZoneEndBit%-ZoneBit%)
d1261 2
a1262 2
     PROCWriteLink(UsedZoneEndBit%,1)
     PROCWriteLength(UsedZoneEndBit%,ZoneEndBit%-UsedZoneEndBit%)
d1265 1
a1265 1
    PROCWriteLength(ZoneBit%,DefectStart%-ZoneBit%)
d1270 1
a1270 1
   IF DefectEnd%>UsedZoneEndBit%-(LinkBits%+1) THEN
d1273 2
a1274 2
   PROCWriteLink(DefectStart%,1)
   PROCWriteLength(DefectStart%,DefectEnd%-DefectStart%)
d1280 1
a1280 1
 PROCWriteLink(PreFree%,0)
d1301 1
d1325 2
a1326 1
IF (Alloc%>SecSize%)
d1335 2
a1336 2
:
DEF PROCWriteLink(off%,link%)
d1344 17
a1360 2
:
DEF PROCWriteLength(off%,len%)
d1365 1
a1365 1
:
d1419 2
a1420 4
LOCAL BF%
FOR I%=0 TO DirSize%-4 STEP 4:Buf%!I%=0:NEXT
IF NewMap% THEN
 $DirMark%="Hugo"
d1422 32
a1453 1
 $DirMark%="Hugo"
d1455 29
a1483 10
Buf%!1=!DirMark%
BF%=Buf%+DirSize%
IF NewMap% THEN
 BF%!-38=IndRootDirAdd%
ELSE
 BF%!-38=IndRootDirAdd% DIV &100
ENDIF
BF%?-35=ASC"$"
BF%?-16=ASC"$"
BF%!-5=!DirMark%
d1485 15
a1499 11
PROCCheckPut(!Buf%)
PROCCheckPut(Buf%?4)
I%=BF%-40
WHILE I%AND3
 PROCCheckPut(?I%)
 I%=I%+1
ENDWHILE
WHILE I%<BF%-4
 PROCCheckPut(!I%)
 I%=I%+4
ENDWHILE
d1502 1
a1502 2
BF%?-1=check%
PROCMoanOp(Write%,RootDirAdd%,Buf%,DirSize%)
d1677 1
a1677 1
IF ((BootRec%!&10)>=(512*1024*1024) OR (BootRec%!&26)<>0) AND bothgood% THEN
d2177 4
a2180 2
    LOCAL LFAU%
    LFAU%=LinkBits%<<Log2Alloc%
d2182 1
a2182 1
    WHILE (253*(SecSize%<<Log2ShareSize%)<LFAU%)
d2199 38
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d1077 5
a1081 1
          NextDefect%=FNDiscToMap(Defect%!ptr%)
d1083 10
a1092 1
          NextDefect%=FNDiscToMap((Defect%!ptr%)/SecSize%)
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d1077 5
a1081 1
          NextDefect%=FNDiscToMap(Defect%!ptr%)
d1083 10
a1092 1
          NextDefect%=FNDiscToMap((Defect%!ptr%)/SecSize%)
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.3.2
log
@Version RO_3_71 taken
@
text
@d264 1
a264 1
IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
d328 1
a328 1
IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
d334 1
a334 1
SectorsPerDisc%=(DiscSize%>>>Log2SecSize%)+(DiscSize2%<<(32-Log2SecSize%))
d516 1
a516 1
IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
d1481 1
a1481 1
IF (((BootRec%!&10) AND &E0000000)<>0 OR (BootRec%!&26)<>0) AND bothgood% THEN
d1981 2
a1982 2
    LOCAL min%
    min%=(LinkBits%+1)<<Log2Alloc%
d1984 1
a1984 1
    WHILE (253*(SecSize%<<Log2ShareSize%)<min%)
@


4.1.3.2.2.1
log
@Modified to support long filenames version of FileCore, and to support
large free space maps.
@
text
@a11 9
REM For formatting with idlen>15, we have to allow the formatter
REM to select a larger idlen value.

REM MaxLinkBits% sets the maximum value of idlen

MaxLinkBits%=19: REM allow 16 bit idlen
MaxFreeLinkBits%=15: REM maximum number of bits for a free link
MinLinkBits%=10

d26 1
a26 1
IF NOT BigADFS% THEN   
a35 4
BigDir%=FNChoose("BigDir:","BigDirChoose","YN","")="Y"

IF NOT BigDir% THEN MaxLinkBits%=15

d215 1
a215 1
DIM Buf% &160000, DiscRec% 64+BootSize%, Defect% BootSize%, DirMark% 5, Bad%(MaxVerifyBad%),mc% 100, Pattern%(Patterns%-1)
d249 1
a249 2
Log2Alloc%=10:LinkBits%=MinLinkBits%
IF LinkBits%<=MaxFreeLinkBits% THEN FreeLinkBits%=LinkBits% ELSE FreeLinkBits%=15
a745 1
     
d747 1
a747 1
         WHILE (Defect%!ptr%)<add%
a762 2
     IF length%>1024 THEN length%=1024
     
a875 17
DEF FNMinMapObj
  LOCAL min%, t%
  
  IF (Log2SecSize%>Log2Alloc%) THEN
    min%=1<<(Log2SecSize%-Log2Alloc%)
  ELSE
    min%=1
  ENDIF

  t%=min%

  WHILE(t%<(LinkBits%+1))
    t%+=min%
  ENDWHILE

  =t%

d886 1
a886 1
  LinkBits%=MinLinkBits%-1
d892 1
a892 1
  IF LinkBits%>MaxLinkBits% THEN
d899 3
a901 21
   IF LinkBits%<=15 THEN
     Crucial%=FNRoundUpShare(Zones%*2)*SecSize%+DirSize%
     IF MapZone%=0 Crucial%=BootAdd%*SecSize%+BootSize%
     IF Crucial%<Alloc%*FNMinMapObj Crucial%=Alloc%*FNMinMapObj
     IF Crucial% MOD FNGranularity<>0 Crucial%+=FNGranularity-Crucial% MOD FNGranularity
   ELSE     
     Crucial1%=FNRoundUpShare(Zones%*2)*SecSize%
     IF Crucial1%<Alloc%*FNMinMapObj Crucial1%=Alloc%*FNMinMapObj
     IF Crucial1% MOD FNGranularity<>0 Crucial1%+=FNGranularity-Crucial1% MOD FNGranularity
     
     Crucial2%=DirSize%
     IF Crucial2%<Alloc%*FNMinMapObj Crucial2%=Alloc%*FNMinMapObj
     IF Crucial2% MOD FNGranularity<>0 Crucial2%+=FNGranularity-Crucial2% MOD FNGranularity
     Crucial%=Crucial1%+Crucial2%
   ENDIF
   IF (Crucial%>((ZoneBits%-SpareBits%)<<Log2Alloc%)) THEN
     IF Verbose% THEN PROCmessage_print_0("TooSmallAlloc")
     Log2Alloc%+=1
     NEXT DummySpare%
     =FALSE  :REM restart alloc size loop    
   ENDIF
d933 1
a933 1
Log2Alloc%=7: REM requested by TCs ECR
d935 1
a935 1
REMIF Log2Alloc%<8 THEN Log2Alloc%=10:PROCShareSize
a954 1
IF LinkBits%<=MaxFreeLinkBits% THEN FreeLinkBits%=LinkBits% ELSE FreeLinkBits%=15
d958 4
a961 16
 IF LinkBits%<=15 THEN
   Crucial%=FNRoundUpShare(Zones%*2)*SecSize%+DirSize%
   IF MapZone%=0 Crucial%=BootAdd%*SecSize%+BootSize%
   IF Crucial%<Alloc%*FNMinMapObj Crucial%=Alloc%*FNMinMapObj
   IF Crucial% MOD FNGranularity<>0 Crucial%+=FNGranularity-Crucial% MOD FNGranularity
 ELSE     
   Crucial1%=FNRoundUpShare(Zones%*2)*SecSize%
   IF Crucial1%<Alloc%*FNMinMapObj Crucial1%=Alloc%*FNMinMapObj
   IF Crucial1% MOD FNGranularity<>0 Crucial1%+=FNGranularity-Crucial1% MOD FNGranularity
   
   Crucial2%=DirSize%
   IF Crucial2%<Alloc%*FNMinMapObj Crucial2%=Alloc%*FNMinMapObj
   IF Crucial2% MOD FNGranularity<>0 Crucial2%+=FNGranularity-Crucial2% MOD FNGranularity
   Crucial%=Crucial1%+Crucial2%
 ENDIF

d966 2
a967 7
 IF LinkBits%<=15 THEN
   RootDirAdd%=MapAdd%+FNRoundUpShare((MapLen%*2)/SecSize%)
   IndRootDirAdd%=&200+FNRoundUpShare(Zones%*2)/ShareSize%+1
 ELSE
   RootDirAdd%=MapAdd%+(Crucial1%)/SecSize%
   IndRootDirAdd%=((MapZone%*IdsPerZone%)<<8)+1
 ENDIF
a977 5
DiscRec%?&2a=Zones%>>8
IF BigDir% THEN
  DiscRec%!&2C=1
  DiscRec%!&30=2048
ENDIF
a982 2
BootRec%!&2C=DiscRec%!&2C
BootRec%!&30=DiscRec%!&30
d1014 3
a1016 3
  IF length%<FNMinMapObj length%=FNMinMapObj
  PROCWriteFragLink(ZoneBit%,2)
  PROCWriteFragLength(ZoneBit%,length%)
d1022 4
a1025 15
   IF LinkBits%<=15 THEN
    length%=Crucial% DIV Alloc%
    PROCWriteFragLink(ZoneBit%,2)
    PROCWriteFragLength(ZoneBit%,length%)
    ZoneBit%=ZoneBit%+length%
   ELSE
    length%=Crucial1% DIV Alloc%
    PROCWriteFragLink(ZoneBit%,2)
    PROCWriteFragLength(ZoneBit%,length%)
    ZoneBit%=ZoneBit%+length%
    length%=Crucial2% DIV Alloc%
    PROCWriteFragLink(ZoneBit%,IndRootDirAdd%>>8)
    PROCWriteFragLength(ZoneBit%,length%)
    ZoneBit%=ZoneBit%+length%    
   ENDIF
d1095 2
a1096 2
       IF NextDefect%>ZoneEndBit%-FNMinMapObj THEN
        NextDef%=ZoneEndBit%-FNMinMapObj
d1100 1
a1100 1
       IF NextDef%-DefectEnd%<FNMinMapObj THEN
d1109 2
a1110 2
     IF DefectEnd%-DefectStart%<FNMinMapObj THEN
      DefectEnd%=DefectStart%+FNMinMapObj
d1116 1
a1116 1
     IF DefectEnd%>ZoneEndBit%-(FNMinMapObj) AND DefectEnd%<>ZoneEndBit% THEN
d1120 2
a1121 2
     IF DefectEnd%-DefectStart%<FNMinMapObj THEN
      DefectStart%=DefectEnd%-FNMinMapObj
d1129 1
a1129 1
   PROCWriteFreeLink(PreFree%,ZoneBit%-PreFree%)
d1131 1
a1131 1
    PROCWriteFreeLength(ZoneBit%,UsedZoneEndBit%-ZoneBit%)
d1133 2
a1134 2
     PROCWriteFragLink(UsedZoneEndBit%,1)
     PROCWriteFragLength(UsedZoneEndBit%,ZoneEndBit%-UsedZoneEndBit%)
d1137 1
a1137 1
    PROCWriteFreeLength(ZoneBit%,DefectStart%-ZoneBit%)
d1142 1
a1142 1
   IF DefectEnd%>UsedZoneEndBit%-FNMinMapObj THEN
d1145 2
a1146 2
   PROCWriteFragLink(DefectStart%,1)
   PROCWriteFragLength(DefectStart%,DefectEnd%-DefectStart%)
d1152 1
a1152 1
 PROCWriteFreeLink(PreFree%,0)
d1196 1
a1196 2
IF discadd%>=EndDefect% THEN =EndDefect%
IF (Alloc%>SecSize%) THEN
d1205 2
a1206 2

DEF PROCWriteFragLink(off%,link%)
d1214 2
a1215 2

DEF PROCWriteFragLength(off%,len%)
d1220 1
a1220 16

DEF PROCWriteFreeLink(off%,link%)
IF link%>=2^FreeLinkBits% PROCmessage_print_0("ERROR2"):PROCfinish
LOCAL bit%,add%,mask%
bit%=off% MOD 8
add%=Buf%+off% DIV 8
mask%=2^FreeLinkBits%-1
!add%=(!add% AND NOT (mask%<<bit%)) OR link%<<bit%
ENDPROC

DEF PROCWriteFreeLength(off%,len%)
IF len%<=LinkBits% PROCmessage_print_0("ERROR3"):PROCfinish
off%=off%+len%-1
Buf%?(off%DIV8)+=2^(off%MOD8)
ENDPROC

d1274 11
a1284 2
IF BigDir% THEN
  PROCWriteBigRootDir
d1286 1
a1286 32
  LOCAL BF%
  FOR I%=0 TO DirSize%-4 STEP 4:Buf%!I%=0:NEXT
  IF NewMap% THEN
   $DirMark%="Hugo"
  ELSE
   $DirMark%="Hugo"
  ENDIF
  Buf%!1=!DirMark%
  BF%=Buf%+DirSize%
  IF NewMap% THEN
   BF%!-38=IndRootDirAdd%
  ELSE
   BF%!-38=IndRootDirAdd% DIV &100
  ENDIF
  BF%?-35=ASC"$"
  BF%?-16=ASC"$"
  BF%!-5=!DirMark%
  check%=0
  PROCCheckPut(!Buf%)
  PROCCheckPut(Buf%?4)
  I%=BF%-40
  WHILE I%AND3
   PROCCheckPut(?I%)
   I%=I%+1
  ENDWHILE
  WHILE I%<BF%-4
   PROCCheckPut(!I%)
   I%=I%+4
  ENDWHILE
  check%=check% EOR (check%>>>16)
  check%=(check% EOR (check%>>>8))AND &FF
  BF%?-1=check%
d1288 3
a1290 29
PROCMoanOp(Write%,RootDirAdd%,Buf%,DirSize%)
ENDPROC
:
DEF PROCWriteBigRootDir
FOR I%=0 TO DirSize%-4 STEP 4:Buf%!I%=0:NEXT
LOCAL hp%
hp%=Buf%+4
$hp%="SBPr"
hp%+=4
!hp%=1
hp%+=4
!hp%=DirSize%
hp%+=4
!hp%=0:REM no entries
hp%+=4
!hp%=0:REM space for names
hp%+=4
!hp%=IndRootDirAdd%
hp%+=4
?hp%=ASC"$"
REM there are no entries.  so just do the tail.

hp%=Buf%+DirSize%-8
$hp%="oven"
hp%+=4
!hp%=0

REM now do the check byte

d1292 11
a1302 15
FOR I%=0 TO 28 STEP 4
  PROCCheckPut(Buf%!I%)
NEXT I%

I%=DirSize%-8

PROCCheckPut(Buf%!I%)
I%+=4
PROCCheckPut(Buf%?I%)
I%+=1
PROCCheckPut(Buf%?I%)
I%+=1
PROCCheckPut(Buf%?I%)
I%+=1

d1305 2
a1306 1
Buf%?I%=check%
d1982 1
a1982 1
    min%=FNMinMapObj<<Log2Alloc%
a2000 8

DEF FNGranularity

  IF Log2SecSize%>Log2Alloc% THEN
    =1<<Log2SecSize%
  ELSE
    =1<<Log2Alloc%
  ENDIF
@


4.1.3.2.2.2
log
@Changed to only ask if long filenames are wanted if the version of FileCore
is higher than 2.98.
@
text
@a1 1

d45 1
a45 6

IF FNFileCoreVersion<=298 THEN
  BigDir%=FALSE
ELSE
  BigDir%=FNChoose("BigDir:","BigDirChoose","YN","")="Y"
ENDIF
a2163 15

DEF FNFileCoreVersion
LOCAL code%, help$, help%
SYS "OS_Module",18,"FileCore" TO ,,,code%

help$=""

help%=(code%!&14)+code%

WHILE (?help%)<>0
  help$+=CHR$?help%
  help%+=1
ENDWHILE

=INT(VAL(MID$(help$,INSTR(help$,".")-1))*100)
@


4.1.3.2.2.3
log
@Fixed a problem with PROCShareSize not correctly calculating the ShareSize
value on long filenames discs.

Made it support Ursula ADFS (uses ADFS's autodetect info).

Made it support upto 4 IDE drives.
@
text
@a21 8
REM Determine if it looks like a Phoebe ADFS

IF FNADFSVersion<=329 THEN
  TwinIDE%=FALSE
ELSE
  TwinIDE%=TRUE
ENDIF

a46 2
REM Determine if the Filecore version we have supports long filenames

a52 1

d128 3
d132 7
a138 36
 
 IF TwinIDE% THEN
   REM determine physical drive number which corresponds to logical drive
   IDEdrive%=-1
   FOR N%=0 TO 3
     SYS "ADFS_IDEDeviceInfo",0,N% TO ,B%,C%,D%
     IF (C%=Drive%) AND (B%=1) THEN
       IDEdrive%=N%
       REM copy the data from the device ID to a local copy of it
       FOR A%=0 TO 512-4 STEP 4
         IDEid%!A%=D%!A%
       NEXT A%
     ENDIF
   NEXT N%
   IF IDEdrive%=-1 THEN
     fail%=TRUE
   ELSE
     fail%=FALSE
   ENDIF
 ELSE
   REM Determine whether this is IDE drive 0/1
   SYS"XADFS_ControllerType",Drive%-1 TO A%;F%
   IF ((F%AND1)=0) AND (A%=4) THEN IDEdrive%=1 ELSE IDEdrive%=0
   DIM IDEpb% 7
   IDEpb%!0=0
   IDEpb%!4=0
   IDEpb%?5=&A0+(IDEdrive%<<4)
   IDEpb%?6=&EC
   SYS"ADFS_IDEUserOp",1<<24,,IDEpb%,IDEid%,512 TO r0%,,,,r4%
   IF r0%<>0 OR r4%<>0 THEN
     fail%=TRUE
   ELSE
     fail%=FALSE
   ENDIF
 ENDIF
 IF fail% THEN
d270 1
d918 1
d992 1
a1266 1
PROCShareSize
d2142 1
a2142 2
    LOCAL min%, min2%
    min2%=Zones%*SecSize%
a2143 1
    IF (min%<min2%) AND (LinkBits%<=15) THEN min%=min2%
a2173 15

help$=""

help%=(code%!&14)+code%

WHILE (?help%)<>0
  help$+=CHR$?help%
  help%+=1
ENDWHILE

=INT(VAL(MID$(help$,INSTR(help$,".")-1))*100)

DEF FNADFSVersion
LOCAL code%, help$, help%
SYS "OS_Module",18,"ADFS" TO ,,,code%
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d264 1
a264 1
IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
d328 1
a328 1
IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
d334 1
a334 1
SectorsPerDisc%=(DiscSize%>>>Log2SecSize%)+(DiscSize2%<<(32-Log2SecSize%))
d516 1
a516 1
IF ((DiscSize% AND &E0000000)<>0) OR (DiscSize2%<>0) THEN
d1481 1
a1481 1
IF (((BootRec%!&10) AND &E0000000)<>0 OR (BootRec%!&26)<>0) AND bothgood% THEN
d1981 2
a1982 2
    LOCAL min%
    min%=(LinkBits%+1)<<Log2Alloc%
d1984 1
a1984 1
    WHILE (253*(SecSize%<<Log2ShareSize%)<min%)
@

head	4.11;
access;
symbols
	BootCmds-1_49-1:4.11
	BootCmds-1_49:4.11
	BootCmds-1_48:4.11
	BootCmds-1_47:4.11
	BootCmds-1_46:4.11
	BootCmds-1_45:4.10
	BootCmds-1_44:4.10
	BootCmds-1_43:4.9
	BootCmds-1_42:4.8
	BootCmds-1_41:4.8
	BootCmds-1_40:4.8
	BootCmds-1_39:4.8
	BootCmds-1_38:4.7
	BootCmds-1_35:4.6
	RO_5_07:4.6
	BootCmds-1_34:4.6
	BootCmds-1_33:4.6
	BootCmds-1_32:4.5
	BootCmds-1_31:4.5
	BootCmds-1_30:4.5
	BootCmds-1_29:4.5
	BootCmds-1_28:4.5
	BootCmds-1_27:4.5
	BootCmds-1_26:4.4
	BootCmds-1_25:4.3
	BootCmds-1_24:4.3
	BootCmds-1_23:4.3
	BootCmds-1_22:4.3
	BootCmds-1_21:4.2
	BootCmds-1_20:4.2
	dellis_autobuild_BaseSW:4.2
	sbrodie_sedwards_16Mar2000:4.2
	BootCmds-1_19:4.2
	dcotton_autobuild_BaseSW:4.3
	nturton_BootCmds-1_17:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_BootCmds-1_17:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	2012.10.10.13.37.49;	author srevill;	state Exp;
branches;
next	4.10;
commitid	Bdyg87hxPkptlQnw;

4.10
date	2012.09.02.17.57.37;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	cqKszfsXW2ki0Ziw;

4.9
date	2012.07.21.08.00.45;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	2JhsVM55iUVc5pdw;

4.8
date	2010.04.19.10.59.20;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2008.10.11.23.59.29;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2004.09.03.16.53.15;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2002.08.05.13.16.14;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2002.07.16.13.06.09;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2001.07.20.11.29.37;	author srevill;	state Exp;
branches;
next	4.2;

4.2
date	99.11.30.11.29.39;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.03;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.03;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.26.07;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.27.42;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.11.02;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Change to the BootFX progress bar SWI call.

Version 0.06 of BootFX has a non-backwards-compatible change to the
BarUpdate SWI call. As BootCommands should be the only user right
now, that's not too bad.

Admin:

This version of BootCommands will not work correctly with versions
of BootFX older than 0.06 (the progress bar will not move).

Version 1.46. Tagged as 'BootCmds-1_46'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*main.c - Repeat *command*/

/*History

   27th Oct 1994 J R C Written
   16th Dec 1999 SAR   Rewritten to include the '-sort' switch and fill buffer in one go (if possible)
   2nd  Sep 2004 SAR   Added -STB switch to control handling of errors in pre-desktop
   20th Feb 2007 JWB   extended buffer allocation to allow up to 8 retries with extended buffer
   17th Jan 2010 TM    os_CLI_LIMIT_RO4 and usage of OS_HeapSort32
*/

/******************************************************************************
 *
 *             ...IMPORTANT NOTE TO ANYONE WORKING ON THIS CODE...
 *
 * Although the BootCommands module has a *command called "*Repeat", it actually
 * just ends up running a stand-alone application called "Repeat" which is what
 * is built from this source file. This application is installed as:
 *
 *   Resources:$.Resources.BootCmds.Repeat
 *
 * during the "export resources" phase for ROM builds. Thus, if you make edits
 * to this code, you won't see any changes in your ROM build unless you re-run
 * the export resources phase. I hope this saves someone the several hours of
 * frustration I went though...
 */

/*From CLib*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include "kernel.h"
#include "swis.h"

/*From OSLib*/
#include "messagetrans.h"
#include "os.h"
#include "osfile.h"
#include "osfscontrol.h"
#include "osgbpb.h"
#include "wimp.h"
#include "wimpspriteop.h"

/*Local*/
#include "main.h"

#ifndef BOOTFX_MAGIC_HANDLE
#define BOOTFX_MAGIC_HANDLE (0xB007CED5)
#endif

int main(void)
{
  struct
  {
    char  *prog;
    char  *command;
    char  *directory;
    osbool directories;
    osbool applications;
    osbool files;
    char  *type;
    char  *tail;
    osbool tasks;
    osbool verbose;
    osbool sort;
    osbool cont;
    char  *progress;
    char   argb [os_CLI_LIMIT_RO4 + 1];
  } argl;
  bool done_initialise = FALSE;
  bits file_type;
  os_error *error = NULL, message;
  char *tail;
  osgbpb_info_stamped *info;
  unsigned int bufclaim    = INITIALENTRYCOUNT;
  unsigned int max_buf     = bufclaim*32;
  char **membuf            = malloc((sizeof(char*)*bufclaim) + max_buf);
  char **objects           = membuf;
  char *buffer             = (char*)membuf + (sizeof(char*)*bufclaim);
  char *buf_pos            = buffer;
  unsigned int obj_pos     = 0;
  unsigned int read        = 0;
  unsigned int entries     = 0;
  unsigned int ent_sz      = 0;
  unsigned int context     = 0;
  unsigned int growth      = 0;
  unsigned int total;
  int pct_start, pct_range = -1;

  /* Check that the buffer allocation was successful */
  if (membuf == NULL)
  {
    static const os_error tmp = { error_STR_OFLO, "StrOFlo" }; /* In global messages */
    error = xmessagetrans_error_lookup(&tmp, 0, 0, 0, 0, 0, 0, 0);
    goto finish;
  }

  /* Check for the presence of the parameter string and get its start address */
  if ((error = xos_get_env(&tail, NULL, NULL)) != NULL) goto finish;

  /* Parse the parameter string (PRM 1-465) */
  if ((error = xos_read_args("prog/a,command/a,directory/a,directories/s,applications/s,files/s,type/k,tail,tasks/s,verbose/s,sort/s,continue=stb/s,progress/k",
                             tail,
                             (char *) &argl,
                             sizeof argl,
                             NULL)
      ) != NULL) goto finish;


  if (!argl.directories && !argl.applications && !argl.files && !argl.type) argl.files = (argl.directories = TRUE);

  #if 0
  /*Canonicalise the name just to see it helps matters any.*/
  if ((error = xosfscontrol_canonicalise_path(argl.directory, directory, NULL, NULL, sizeof directory, NULL)) != NULL) goto finish;
  #endif /*it doesn't. also breaks under RO200. JRC 9th Jan 1995*/

  /* If the specified directory is not actually a directory, exit */
  if (argl.type)
  {
    if ((error = xosfscontrol_file_type_from_string(argl.type, &file_type)) != NULL) goto finish;
  }

  /* Initialise this program as a WIMP task, if the -tasks switch was present */
  if (argl.tasks)
  {
    if ((error = xwimp_initialise(wimp_VERSION_RO2, "Repeat", NULL, NULL, NULL)) != NULL) goto finish;
    done_initialise = TRUE;
  }

  /* Intepret the progress start [0..99] and range [0..100] parameter */
  if (argl.progress != NULL)
  {
    unsigned int range;
    int ret = sscanf(argl.progress, "%u,%u", &pct_start, &range);

    if (ret == 2)
    {
      /* Clamp start point then clip range */
      if (pct_start > 99) pct_start = 99;
      if ((pct_start + range) > 100) range = 100 - pct_start;
      pct_range = range;
    }
  }

  /* Fill a buffer with all the directory entries, and build an array of pointers to the leafname strings */
  while (context != -1)
  {
    error = (os_error *) _swix(OS_GBPB, _INR(0,6) | _OUT(3) | _OUT(4), 12, argl.directory, buf_pos, 255, context, max_buf, 0, &read, &context);

    entries += read;
    if (error != NULL || (entries > bufclaim))
    {
      if(growth++ >= 8)  goto finish;
      /* double our buffer space */
      bufclaim       *= 2;
      max_buf         = bufclaim*32;
      if(membuf = realloc(membuf,(sizeof(char*)*bufclaim) + max_buf), !membuf) goto finish;
      buffer          = (char*)membuf + (sizeof(char*)*bufclaim);
      objects         = membuf;
      buf_pos         = buffer;
      obj_pos         = 0;
      read            = 0;
      entries         = 0;
      context         = 0;
    }
    while (read > 0)
    {
      objects[obj_pos++] = (char*)(buf_pos + 24);
      ent_sz             = (24 + strlen(buf_pos + 24) + 1 /* terminator */ + 3 /* align */) & ~3;
      max_buf           -= ent_sz;
      buf_pos           += ent_sz;
      read              -= 1;
    }
  }

  /* Perform the desired *Command on all the matching objects in the directory */
  if (entries > 0)
  {
    /* Sort the leafname pointer array */
    if (argl.sort)
    {
      error = (os_error *) _swix(OS_HeapSort32, _INR(0,2), entries, objects, 4);
      if (error != NULL) goto finish;
    }

    /* Keep the total entries - it's useful for doing the percent complete calculation */
    total = entries;

    /* Iterate through each of the directory entries in order */
    obj_pos = 0;
    while (entries-- > 0)
    {
      info = (osgbpb_info_stamped *) (objects[obj_pos++] - 24);

      if (pct_range > 0)
      {
        /* Report progress of this repeat command */
        (void) _swix(BootFX_BarUpdate, _INR(0,2), 0, BOOTFX_MAGIC_HANDLE, pct_start + ((pct_range * (total - entries)) / total));
      }

      if (
           ( info->obj_type == osfile_IS_FILE &&
             ( argl.files ||
               (argl.type && info->file_type == file_type)
             )
           )
           ||
           ( info->obj_type == osfile_IS_DIR &&
             ( argl.directories ||
               ( argl.applications && info->name [0] == '!')
             )
           )
         )
      {
        char cmd [os_CLI_LIMIT_RO4 + 1];

        /* Create the CLI string which we're going to execute */
        if (!argl.tail)
        {
          sprintf(cmd, "%s %s.%s", argl.command, argl.directory, info->name);
        }
        else
        {
          sprintf(cmd, "%s %s.%s %s", argl.command, argl.directory, info->name, argl.tail);
        }

        /* Are we doing the command as a WIMP task? */
        if (argl.tasks)
        {
          if (argl.verbose)
          {
            strcpy (message.errmess, cmd);
            (void) xwimp_report_error_by_category(&message,
                                                  wimp_ERROR_BOX_SHORT_TITLE | wimp_ERROR_BOX_NO_BEEP | wimp_ERROR_BOX_LEAVE_OPEN |
                                                  wimp_ERROR_BOX_CATEGORY_INFO << wimp_ERROR_BOX_CATEGORY_SHIFT,
                                                  "Repeat", "information", wimpspriteop_AREA, "...", NULL
                                                 );
            (void) xwimp_report_error(NULL, wimp_ERROR_BOX_CLOSE, NULL, NULL);
          }

          if ((error = xwimp_start_task(cmd, NULL)) != NULL) goto finish;
        }
        /* We're doing the command as a CLI call (eg. outside the desktop) */
        else
        {
          /* Do getenv() before system() so last error isn't "System variable 'foo' not found" */
          char *var = getenv(X_ENVVAR);

          if (argl.verbose) fprintf(stderr, "Repeat: %s\n", cmd);

          if (system(cmd) != 0)
          {
            error = (os_error *) _kernel_last_oserror();
            if (argl.cont)
            {
              /* In continue mode, we put the error message string into X$Error (assuming it's
               * not already set) and continue enumeration...
               */
              int          context = 0;
              os_var_type  vartype = os_VARTYPE_STRING;

              if (var == NULL)
              {
                (void) xos_set_var_val(X_ENVVAR,
                                       (byte *)(error->errmess),
                                       strlen(error->errmess),
                                       context,
                                       vartype,
                                       &context,
                                       &vartype);
              }
              error = NULL;
            }
            else
            {
              /* ...otherwise we break out of the enumeration and output the error */
              goto finish;
            }
          }
        }
      }
    }
  }

/* Exit label */
finish:
  if (membuf != NULL) free(membuf);

  if (done_initialise)
  {
    os_error *error1 = xwimp_close_down(NULL);
    if (error == NULL) error = error1;
  }

  if (error != NULL)
  {
    if(argl.tasks)
    {
      (void) xwimp_report_error(error, NONE, "Repeat", NULL);
    }
    else
    {
      fprintf(stderr, "Repeat: %s\n", error->errmess);
    }
    return 1;
  }
  else
  {
    return 0;
  }
}
@


4.10
log
@Add support for progress indication and 'must continue' switch
* The switch '-stb' has existed for some time but is a bit obtuse, renamed to '-continue' (though -stb is still accepted as an alias).
* Added support for BootFX module, via switch '-progress start,range' which will scale the work done and work yet to do into a percentage and pass it to the BootFX module (intended to track boot progress).
* Trimmed out old switched out repeat command code that ran in SVC mode.
* Eliminate last trace of Support011 library, was only using the control terminated version of strlen() which is in ConfigLib (now linked against).
* Const qualifiers added to command handlers.

Version 1.44. Tagged as 'BootCmds-1_44'
@
text
@d26 16
d63 4
d151 1
a151 1
    
d214 1
a214 1
        (void) _swix(BootFX_BarUpdate, _IN(0), pct_start + ((pct_range * (total - entries)) / total));
@


4.9
log
@Makefile adapted to accept CMDHELP=None
* Recreated from fragments
* No longer creates two resource areas (one for Repeat, one for messages) since RESGEN can put many files into one area
* No longer does a ResourceFS register in the ROM case - the resources phase now exports both Repeat and messages directly into the messages module
* Corrected error number for BufOFlo (was using the token number!)
* Used newly allocated error base for all other errors
* Internationalised "Can't claim memory" in Repeat
* Fixed a couple of compiler warnings

Version 1.43. Tagged as 'BootCmds-1_43'
@
text
@d51 14
a64 5
    char *prog, *command, *directory;
    osbool directories, applications, files;
    char *type, *tail;
    osbool tasks, verbose, sort, stb;
    char argb [os_CLI_LIMIT_RO4 + 1];
d71 14
a84 13
  #define INITIALENTRYCOUNT  128
  unsigned int bufclaim = INITIALENTRYCOUNT;         /* initial size .. for 128 short filename entries */
  unsigned int max_buf  = bufclaim*32;
  char **membuf         = malloc((sizeof(char*)*bufclaim) + max_buf);
  char **objects        = membuf;
  char *buffer          = (char*)membuf + (sizeof(char*)*bufclaim);
  char *buf_pos         = buffer;
  unsigned int obj_pos  = 0;
  unsigned int read     = 0;
  unsigned int entries  = 0;
  unsigned int ent_sz   = 0;
  unsigned int context  = 0;
  unsigned int growth   = 0;
d94 1
a94 1
  /* Check for the presence of the parameter string and get it's start address */
d98 1
a98 1
  if ((error = xos_read_args("prog/a,command/a,directory/a,directories/s,applications/s,files/s,type/k,tail,tasks/s,verbose/s,sort/s,stb/s",
d126 15
d182 3
d191 6
a200 1
           /*^^^^^^^^^ avoid uninitialised variable. JRC 9th Jan 1995*/
d243 1
a243 1
          char *var = getenv(main_X_ENVVAR);
d250 1
a250 6

            /* In STB mode, we put the error message string into X$Error (assuming it's
             * not already set) and continue enumeration. In non-STB mode, we break out
             * of the enumeration and output the error.
             */
            if (argl.stb != 0)
d252 3
d260 1
a260 1
                (void) xos_set_var_val(main_X_ENVVAR,
a270 1
            /* Non-STB mode: break out with an error to the exit code */
d272 1
d301 1
a301 1
    return(1);
d305 1
a305 1
    return(0);
@


4.8
log
@  A couple of bugfixes
Detail:
  * *Repeat allows for command lines up to 1024 bytes (RISC OS 4+ standard)
    rather than 256 bytes
 * Fixed crash on *Repeat -sort
 * Uses OS_HeapSort32 rather than OS_HeapSort
Admin:
  Provided by Thomas Milius

Version 1.39. Tagged as 'BootCmds-1_39'
@
text
@a26 1
#include <kernel.h>
d32 1
d36 1
a58 1
  os_error mfail = {255, "Can't claim memory"};
d63 1
a63 1
  unsigned int bufclaim = INITIALENTRYCOUNT;         /* initial size .. for 128 shortfilenamr entries */
d79 2
a80 1
    error = &mfail;
a82 1
  
d140 1
a140 1
      ent_sz             = (28 + strlen(buf_pos + 24)) & ~3;
d190 1
a190 1
        /* Are we doing the commad as a WIMP task? */
@


4.7
log
@  Merged in changes from Castle
Detail:
  Extended repeat dir enumeration buffer
  Field failures seen when too many entries in a directory
  It was set to a static buffer for 128 short filename entries.
  Now it'll retry with double the buffer up to 8 times before giving
  buffer overflow
Admin:
  Not tested. Version incremented by 3 to match Castle's version.

Version 1.38. Tagged as 'BootCmds-1_38'
@
text
@d23 1
d54 1
a54 1
    char argb [os_CLI_LIMIT + 1];
d153 1
a153 1
      error = (os_error *) _swix(OS_HeapSort, _INR(0,2), entries, *objects, 4);
d178 1
a178 1
        char cmd [os_CLI_LIMIT + 1];
@


4.6
log
@  Repeat command made more robust in handling errors in the pre-desktop
  execution mode.
Detail:
  If -stb is supplied to the repeat command (and -tasks is not), it will
  put the first error it encounters into the system variable X$Error (if
  not already set) and then continue execution as normal.
Admin:
  I also updated the CmdHelp file to reflect not only this change, but
  also the -sort switch which was added quite some time ago and to make
  the X command help a little more helpful.

Version 1.33. Tagged as 'BootCmds-1_33'
@
text
@d22 1
d61 6
a66 3
  char *objects[128];
  unsigned int max_buf  = 128*32;
  char *buffer          = malloc(max_buf);
d73 1
d76 1
a76 1
  if (buffer == NULL)
d81 1
a119 2
    if (error != NULL) goto finish;

d121 15
d138 1
a138 1
      objects[obj_pos++] = buf_pos + 24;
d152 1
a152 1
      error = (os_error *) _swix(OS_HeapSort, _INR(0,2), entries, &objects, 4);
d251 1
a251 1
  if (buffer != NULL) free(buffer);
@


4.5
log
@  Has a chance of building with cc 5.45.
Detail:
  Was defining structs for the block returned from OS_ReadArgs, but used
  bool types for switch arguments. Now that they are 1 byte wide, this was
  causing problems. Now replaced with osbool types, which should remain
  1 word wide.
Admin:
  Not tested.

Version 1.27. Tagged as 'BootCmds-1_27'
@
text
@d20 2
a21 1
   16th Dec 1999 SAR  Rewritten to include the '-sort' switch and fill buffer in one go (if possible)
d41 3
d51 1
a51 1
    osbool tasks, verbose, sort;
d81 1
a81 1
  if ((error = xos_read_args("prog/a,command/a,directory/a,directories/s,applications/s,files/s,type/k,tail,tasks/s,verbose/s,sort/s",
d186 1
d189 3
d197 27
a223 1
            goto finish;
@


4.4
log
@  Explicitly include stdbool.h because this component uses bool
Admin:
  Might help it build.


Version 1.26. Tagged as 'BootCmds-1_26'
@
text
@d45 1
a45 1
    bool directories, applications, files;
d47 1
a47 1
    bool tasks, verbose, sort;
@


4.3
log
@  Changes the Repeat sources to add -sort parameter.
Detail:
  -sort will ensure that the objects iterated over are sorted into
  ascending ASCII order before the iteration. This is important for
  FS like NFS which does not return things in order.
Admin:
  Been used for ages in STB Baselines without problems.

Version 1.22. Tagged as 'BootCmds-1_22'
@
text
@d28 1
@


4.2
log
@  Moved to srccommit.
  Fixed directory enumerators.
  Removed obsolete assembler sources.
Detail:
  s/main was the output of "cc -S c/main" :-/
Admin:
  Built.

Version 1.19. Tagged as 'BootCmds-1_19'
@
text
@d20 1
a20 1

d29 2
d39 155
a193 1
int main (void)
d195 3
a197 91
{  int context;
   struct {char *prog, *command, *directory; bool directories, applications,
         files; char *type, *tail; bool tasks, verbose;
         char argb [os_CLI_LIMIT + 1];} argl;
   osgbpb_INFO_STAMPED (os_FILE_NAME_LIMIT + 1) info;
   bool done_initialise = FALSE;
   bits file_type;
   os_error *error = NULL, message;
   char *tail;

   if ((error = xos_get_env (&tail, NULL, NULL)) != NULL)
      goto finish;

   if ((error = xos_read_args ("prog/a,command/a,directory/a,directories/s,"
         "applications/s,files/s,type/k,tail,tasks/s,verbose/s",
         tail, (char *) &argl, sizeof argl, NULL)) != NULL)
      goto finish;

   if (!argl.directories && !argl.applications && !argl.files && !argl.type)
      argl.files = argl.directories = TRUE;

   #if 0
   /*Canonicalise the name just to see it helps matters any.*/
   if ((error = xosfscontrol_canonicalise_path (argl.directory, directory,
         NULL, NULL, sizeof directory, NULL)) != NULL)
      goto finish;
   #endif /*it doesn't. also breaks under RO200. JRC 9th Jan 1995*/

   if (argl.type)
      if ((error = xosfscontrol_file_type_from_string (argl.type,
            &file_type)) != NULL)
         goto finish;

   if (argl.tasks)
   {  if ((error = xwimp_initialise (wimp_VERSION_RO2, "Repeat",
            NULL, NULL, NULL)) != NULL)
         goto finish;
      done_initialise = TRUE;
   }

   context = 0;
   while (context != osgbpb_NO_MORE)
   {  int count;
      if ((error = xosgbpb_dir_entries_info_stamped (argl.directory,
            (osgbpb_info_stamped_list *) &info, 1, context,
            sizeof info, "*", &count, &context)) != NULL)
         goto finish;
      if (!count) continue;
      if
      (  (  info.obj_type == osfile_IS_FILE &&
            (  argl.files ||
               (argl.type && info.file_type == file_type)
              /*^^^^^^^^^ avoid uninitialised variable. JRC 9th Jan 1995*/
         )  ) ||
         (  info.obj_type == osfile_IS_DIR &&
            (  argl.directories ||
               (argl.applications && info.name [0] == '!')
      )  )  )
      {  char cmd [os_CLI_LIMIT + 1];

         if (!argl.tail)
            sprintf (cmd, "%s %s.%s", argl.command, argl.directory,
                  info.name);
         else
            sprintf (cmd, "%s %s.%s %s", argl.command, argl.directory,
                  info.name, argl.tail);

         if (argl.tasks)
         {  if (argl.verbose)
            {  strcpy (message.errmess, cmd);
               (void) xwimp_report_error_by_category (&message,
                     wimp_ERROR_BOX_SHORT_TITLE | wimp_ERROR_BOX_NO_BEEP |
                     wimp_ERROR_BOX_LEAVE_OPEN |
                     wimp_ERROR_BOX_CATEGORY_INFO <<
                     wimp_ERROR_BOX_CATEGORY_SHIFT, "Repeat", "information",
                     wimpspriteop_AREA, "...", NULL);
               (void) xwimp_report_error (NULL, wimp_ERROR_BOX_CLOSE, NULL,
                     NULL);
            }

            if ((error = xwimp_start_task (cmd, NULL)) != NULL)
               goto finish;
         }
         else
         {  if (argl.verbose)
               fprintf (stderr, "Repeat: %s\n", cmd);

            if (system (cmd) != 0)
            {  error = (os_error *) _kernel_last_oserror ();
               goto finish;
   }  }  }  }
d199 22
a220 15
finish:
   if (done_initialise)
   {  os_error *error1 = xwimp_close_down (NULL);
      if (error == NULL) error = error1;
   }

   if (error != NULL)
   {  if (argl.tasks)
         (void) xwimp_report_error (error, NONE, "Repeat", NULL);
      else
         fprintf (stderr, "Repeat: %s\n", error->errmess);
      return 1;
   }
   else
      return 0;
@


4.1
log
@Initial revision
@
text
@d80 3
a82 2
   while (TRUE)
   {  if ((error = xosgbpb_dir_entries_info_stamped (argl.directory,
d84 1
a84 1
            sizeof info, "*", NULL, &context)) != NULL)
d86 1
a86 2
      if (context == osgbpb_NO_MORE) break;

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

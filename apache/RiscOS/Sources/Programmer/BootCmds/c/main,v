head	4.22;
access;
symbols
	BootCmds-1_49-1:4.22
	BootCmds-1_49:4.21
	BootCmds-1_48:4.21
	BootCmds-1_47:4.20
	BootCmds-1_46:4.20
	BootCmds-1_45:4.20
	BootCmds-1_44:4.19
	BootCmds-1_43:4.18
	BootCmds-1_42:4.17
	BootCmds-1_41:4.17
	BootCmds-1_40:4.16
	BootCmds-1_39:4.14
	BootCmds-1_38:4.13
	BootCmds-1_35:4.13
	RO_5_07:4.13
	BootCmds-1_34:4.13
	BootCmds-1_33:4.12
	BootCmds-1_32:4.12
	BootCmds-1_31:4.12
	BootCmds-1_30:4.11
	BootCmds-1_29:4.10
	BootCmds-1_28:4.9
	BootCmds-1_27:4.8
	BootCmds-1_26:4.7
	BootCmds-1_25:4.6
	BootCmds-1_24:4.5
	BootCmds-1_23:4.5
	BootCmds-1_22:4.4
	BootCmds-1_21:4.4
	BootCmds-1_20:4.3
	dellis_autobuild_BaseSW:4.3
	sbrodie_sedwards_16Mar2000:4.3
	BootCmds-1_19:4.3
	dcotton_autobuild_BaseSW:4.5
	nturton_BootCmds-1_17:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	nicke_BootCmds-1_17:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.2
	afrost_Funai01-33:4.1.7.2
	Spinner_RCA116:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	RCA_bp:4.2
	ARTtmp:4.1.7.2.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.22
date	2018.07.24.21.05.10;	author rsprowson;	state Exp;
branches;
next	4.21;
commitid	poMMxlSv1G1ATqLA;

4.21
date	2014.04.06.08.31.45;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	GWre8yCSC2KhcBvx;

4.20
date	2012.09.30.16.47.23;	author jlee;	state Exp;
branches;
next	4.19;
commitid	kTittmWgLBYqIzmw;

4.19
date	2012.09.02.17.57.37;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	cqKszfsXW2ki0Ziw;

4.18
date	2012.07.21.08.00.44;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	2JhsVM55iUVc5pdw;

4.17
date	2012.01.09.22.03.32;	author srevill;	state Exp;
branches;
next	4.16;
commitid	pf4YfOxpEWiZYxOv;

4.16
date	2011.12.12.23.45.37;	author srevill;	state Exp;
branches;
next	4.15;
commitid	NDlRYkOZnvBxrXKv;

4.15
date	2011.12.12.18.00.26;	author srevill;	state Exp;
branches;
next	4.14;
commitid	dP4OW60puOkpxVKv;

4.14
date	2010.04.19.10.59.20;	author bavison;	state Exp;
branches;
next	4.13;

4.13
date	2004.09.06.14.24.13;	author jballance;	state Exp;
branches;
next	4.12;

4.12
date	2003.03.17.21.22.24;	author rsprowson;	state Exp;
branches;
next	4.11;

4.11
date	2002.11.26.10.26.53;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2002.11.08.16.20.19;	author rsprowson;	state Exp;
branches;
next	4.9;

4.9
date	2002.10.20.11.47.58;	author rsprowson;	state Exp;
branches;
next	4.8;

4.8
date	2002.08.05.13.16.14;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2002.07.16.13.06.09;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2002.03.19.16.42.24;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2001.09.20.17.42.02;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2001.06.22.10.46.18;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	99.11.30.11.29.39;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	97.01.20.17.22.48;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.29.02;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.05.19.16.02.43;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.29.02;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.26.06;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.27.41;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.11.01;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	96.12.11.15.08.29;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.22
log
@Correct suspicious sizeof
Add the sizeof the ResourceFS terminator, rather than relying on sizeof(0) being 4.
Found by cppcheck static analysis.
Tagged as BootCmds-1_49-1 since binary unchanged.
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*main.c - entry points for BootCommands module*/

/*History

   12th Sep 1994 J R C Started
   17th Jan 2010 TM    os_CLI_LIMIT_RO4 and some constants replaced by logical name

*/

/*From CLib*/
#include <stdarg.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "kernel.h"

/*From exports*/
#include "Global/NewErrors.h"

/*From OSLib*/
#include "econet.h"
#include "macros.h"
#include "messagetrans.h"
#include "netfs.h"
#include "os.h"
#include "osargs.h"
#include "osbyte.h"
#include "osfile.h"
#include "osfscontrol.h"
#include "osfind.h"
#include "osgbpb.h"
#include "osmodule.h"
#include "resourcefs.h"
#include "wimp.h"
#include "territory.h"

/*From ConfigLib*/
#include "str.h"

/*Local*/
#include "files.h"
#include "main.h"
#include "jc_trace.h" /* avoiding name clash */

static void *Workspace;

static os_error *(*Commands [main_COMMAND_COUNT]) (const char *);

static messagetrans_control_block Control_Block;

/* A useful global buffer */
static char buffer[os_CLI_LIMIT_RO4 + 1];

static os_error *main_error_lookup (int errnum, char *token, ...)

{  va_list list;
   char *p [4];
   int i;
   os_error error_block;

   tracef ("main_error_lookup\n");

   /*Assume that 4 args are always given.*/
   va_start (list, token);
   for (i = 0; i < 4; i++) p [i] = va_arg (list, char *);
   va_end (list);

   error_block.errnum = errnum;
   strcpy (error_block.errmess, token);
   return xmessagetrans_error_lookup (&error_block, &Control_Block, NULL, 0,
         p [0], p[1], p [2], p [3]);
}

static os_error *Register (resourcefs_file *file, char *name,
                           int data_size, byte *data, bits load_addr, bits exec_addr,
                           int *size_out)

{  os_error *error = NULL;
   int fh_size, fd_size, name_len;
   resourcefs_file_header *fh;
   resourcefs_file_data *fd;

   tracef ("Register: file \"%s\", data \"%.*s\"\n" _
         name _ data_size _ data);

   name_len = strlen (name);
   fh_size  = resourcefs_SIZEOF_FILE_HEADER (ALIGN (name_len + 1));
   fd_size  = resourcefs_SIZEOF_FILE_DATA (ALIGN (data_size));

   if (file != NULL)
   {  fh = &file->header;
      fh->data_size = fh_size + fd_size;
      fh->load_addr = load_addr;
      fh->exec_addr = exec_addr;
      fh->size      = data_size;
      fh->attr      = fileswitch_ATTR_OWNER_READ | fileswitch_ATTR_OWNER_WRITE;
      strcpy (fh->name, name);

      fd = (resourcefs_file_data *) &fh->name [ALIGN (name_len + 1)];
      fd->size = data_size + 4;
      memcpy (fd->data, data, data_size);
         /*Supposed to 0-fill this.*/
   }

   if (size_out != NULL) *size_out = fh_size + fd_size;
   tracef ("-> size %d\n" _ fh_size + fd_size);

   return error;
}

static int get_nvm_size(void)

{
   _kernel_swi_regs rg;
   /* check how much to load/save */
   rg.r[0]=0;
   _kernel_swi(OS_NVMemory,&rg,&rg);
   return rg.r[0]?osbyte_CONFIGURE_CHECKSUM+1:rg.r[1];
}

/*------------------------------------------------------------------------*/
static os_error *Add_App (const char *tail)

{  struct {char *applications; char argb [os_CLI_LIMIT_RO4 + 1];} argl;
   os_error *error = NULL;
#if 0
   char *leaf_name, name [os_CLI_LIMIT_RO4 + 1], boot_name [os_CLI_LIMIT_RO4 + 1],
      help_name [os_CLI_LIMIT_RO4 + 1], run_name [os_CLI_LIMIT_RO4 + 1],
      boot_data [os_CLI_LIMIT_RO4 + 1], help_data [os_CLI_LIMIT_RO4 + 1],
      run_data [os_CLI_LIMIT_RO4 + 1], canon [os_CLI_LIMIT_RO4 + 1],
      dir_name [os_FILE_NAME_LIMIT + 1], entry [os_FILE_NAME_LIMIT + 1],
      application [os_FILE_NAME_LIMIT + 1];
#else
   char *leaf_name, *name, *boot_name, *help_name, *run_name, *boot_data,
        *help_data, *run_data, *canon, *dir_name, *entry, *application;
#endif
   int boot_type, help_type, sprites_type, resource_size, size, context, found;
   resourcefs_file_list *file_list;
   resourcefs_file *file;
   os_date_and_time *now;
   fileswitch_info_words info_words;

   tracef ("Add_App\n");
   /* Horrible, I know, but better than getting it off the SVC stack like it used to */
   name = (char *)malloc((8 * (os_CLI_LIMIT_RO4 + 1)) + (3 * (os_FILE_NAME_LIMIT + 1)));
   if (!name)
      goto finish;
   boot_name = name + (os_CLI_LIMIT_RO4 + 1);
   help_name = boot_name + (os_CLI_LIMIT_RO4 + 1);
   run_name = help_name + (os_CLI_LIMIT_RO4 + 1);
   boot_data = run_name + (os_CLI_LIMIT_RO4 + 1);
   help_data = boot_data + (os_CLI_LIMIT_RO4 + 1);
   run_data = help_data + (os_CLI_LIMIT_RO4 + 1);
   canon = run_data + (os_CLI_LIMIT_RO4 + 1);
   dir_name = canon + (os_FILE_NAME_LIMIT + 1);
   entry = dir_name + (os_FILE_NAME_LIMIT + 1);
   application = entry + (os_FILE_NAME_LIMIT + 1);

   if ((error = xos_read_args ("applications/a", tail, (char *) &argl,
         sizeof argl, NULL)) != NULL)
      goto finish;

   if ((leaf_name = strrchr (argl.applications, '.')) != NULL)
   {  sprintf (dir_name, "%.*s", leaf_name - argl.applications, argl.applications);
      leaf_name++;
   }
   else
   {  strcpy (dir_name, "@@");
      leaf_name = argl.applications;
   }

   /* This if() statement attempts to ensure we don't create app stubs with circular
    * references because the app itself is _already_ in Resources:$.Apps
    */
   error = xosfscontrol_canonicalise_path(dir_name, canon, NULL, NULL, (os_CLI_LIMIT_RO4 + 1), NULL);
   if (error)
      goto finish;
   error = xterritory_collate(-1, canon, RES_APP_PATH, 1, &context);
   if (error || context == 0)
      goto finish;

   context = 0;
   while (context != osgbpb_NO_MORE)
   {  if ((error = xosgbpb_dir_entries (dir_name, (osgbpb_string_list *) entry,
            1, context, (os_FILE_NAME_LIMIT + 1), leaf_name, &found, &context)) != NULL)
         goto finish;

      if (found == 1)
      {  tracef ("new entry is %s\n" _ entry);

         sprintf (application, "%s.%s", dir_name, entry);

         /*We must canonicalise the argument, or else the path names in
            ResourceFS won't be very much use.*/
         if ((error = xosfscontrol_canonicalise_path (application, canon, NULL, NULL, (os_CLI_LIMIT_RO4 + 1), NULL)) != NULL)
            goto finish;

         resource_size = 0;

         /*We make a !Boot file if there is already a !Boot file or a !Sprites file.*/
         sprintf (name, "%s.!Boot", canon);
         tracef ("OSFile_ReadStampedNoPath %s\n" _ name);
         if ((error = xosfile_read_stamped_no_path (name, &boot_type, NULL, NULL, NULL, NULL, NULL)) != NULL)
            goto finish;
         tracef ("boot_type %d\n" _ boot_type);

         sprintf (name, "%s.!Sprites", canon);
         tracef ("OSFile_ReadStampedNoPath %s\n" _ name);
         if ((error = xosfile_read_stamped_no_path (name,
               &sprites_type, NULL, NULL, NULL, NULL, NULL)) != NULL)
            goto finish;
         tracef ("sprites_type %d\n" _ sprites_type);

         if (boot_type != osfile_NOT_FOUND)
            sprintf (boot_data, "/%s.!Boot %%*0\n", canon);
         else if (sprites_type != osfile_NOT_FOUND)
            sprintf (boot_data, "IconSprites %s.!Sprites\n", canon);

         if (boot_type != osfile_NOT_FOUND || sprites_type != osfile_NOT_FOUND)
         {  sprintf (boot_name, "Apps.%s.%s", entry, "!Boot");
            if ((error = Register (NULL, boot_name, strlen (boot_data),
                  (byte *) boot_data, SKIP, SKIP, &size)) != NULL)
               goto finish;
            resource_size += size;
            tracef ("!Boot needs %d bytes\n" _ size);
         }

         /*We make a !Help file if there is one already.*/
         sprintf (name, "%s.!Help", canon);
         tracef ("OSFile_ReadStampedNoPath %s\n" _ name);
         if ((error = xosfile_read_stamped_no_path (name, &help_type, NULL, NULL, NULL, NULL, NULL)) != NULL)
            goto finish;
         tracef ("type %d\n" _ help_type);

         if (help_type != osfile_NOT_FOUND)
         {  sprintf (help_data, "Filer_Run %s.!Help\n", canon);
            tracef ("help_data %s, len %d\n" _ help_data _
                 strlen (help_data));

            sprintf (help_name, "Apps.%s.%s", entry, "!Help");
            tracef ("help_name %s\n" _ help_name);
            if ((error = Register (NULL, help_name, strlen (help_data),
                  (byte *) help_data, SKIP, SKIP, &size)) != NULL)
               goto finish;
            tracef ("size %d\n" _ size);
            resource_size += size;
            tracef ("!Help needs %d bytes\n" _ size);
         }

         /*We always make a !Run file.*/
         sprintf (run_data, "/%s %%*0\n", canon);
         sprintf (run_name, "Apps.%s.%s", entry, "!Run");
         tracef ("run_name %s\n" _ run_name);
         if ((error = Register (NULL, run_name, strlen (run_data), (byte *) run_data, SKIP, SKIP, &size)) != NULL)
            goto finish;
         resource_size += size;
         tracef ("!Run needs %d bytes\n" _ size);

         resource_size += sizeof (file->header.data_size); /*terminating word*/

         if ((error = xosmodule_alloc (resource_size, (void **) &file_list)) != NULL)
            goto finish;
         tracef ("allocated %d bytes at 0x%X\n" _ resource_size _ file_list);

         /*Build common load and exec addresses for everything (they're all Obey files).*/
         if ((error = xos_get_env (NULL, NULL, &now)) != NULL)
            goto finish;
         info_words AS addrs.load_addr = 0xFFF00000u | osfile_TYPE_OBEY << osfile_FILE_TYPE_SHIFT;
         memcpy (info_words AS date_and_time, *now,
               sizeof info_words AS date_and_time);

         file = &file_list->file [0]; /*just a cast*/

         /*Now fill in the real buffer.*/
         if (boot_type != osfile_NOT_FOUND || sprites_type != osfile_NOT_FOUND)
         {  if ((error = Register (file, boot_name, strlen (boot_data),
                  (byte *) boot_data, info_words AS addrs.load_addr,
                  info_words AS addrs.exec_addr, &size)) != NULL)
               goto finish;
            *(char **) &file += size;
         }

         if (help_type != osfile_NOT_FOUND)
         {  if ((error = Register (file, help_name, strlen (help_data),
                  (byte *) help_data, info_words AS addrs.load_addr,
                  info_words AS addrs.exec_addr, &size)) != NULL)
               goto finish;
            *(char **) &file += size;
         }

         if ((error = Register (file, run_name, strlen (run_data),
               (byte *) run_data, info_words AS addrs.load_addr,
               info_words AS addrs.exec_addr, &size)) != NULL)
            goto finish;
         *(char **) &file += size;

         /*Terminator.*/
         file->header.data_size = 0;

         /*And now register the whole lot.*/
         if ((error = xresourcefs_register_files (file_list)) != NULL)
            goto finish;

         tracef ("done\n");
       }
   }

finish:
   free(name);
   return error;
}
/*------------------------------------------------------------------------*/
static os_error *App_Size (const char *tail)

{  os_error *error = NULL;
   const char *cc;
   char *end;
   int move, size, size_limit;
   unsigned int value;
   byte *ram_limit;

   tracef ("App_Size\n");
   cc = tail;
   while (*cc == ' ')
      cc++;

   if ((error = xos_read_unsigned (NONE, cc, SKIP, &end, (void *) &value)) != NULL)
      goto finish;

   switch (*end)
   {  case 'm': case 'M':
         value *= 1024;
      /*fall through*/

      case 'k': case 'K':
         value *= 1024;
         end++;
      break;
   }

   if ((error = xos_get_env (NULL, &ram_limit, NULL)) != NULL)
      goto finish;
   tracef ("top of application space 0x%X\n" _ ram_limit);

   /*We want to move the R M A by the difference between the application size
      and the value specified.*/
   move = (int) (ram_limit - 0x8000) - value;
   tracef ("wanted move is %d\n" _ move);

   /*How big is the R M A now?*/
   if ((error = xos_read_dynamic_area (os_DYNAMIC_AREA_RMA,
         NULL, &size, &size_limit)) != NULL)
      goto finish;
   tracef ("R M A expansion space %d\n" _ size_limit - size);

   /*Can't move it to more than its size limit.**/
   (void) MINAB (move, size_limit - size);
   tracef ("allowed move is %d\n" _ move);

   /*We don't care if this succeeds or fails - the attempt is the thing.*/
   (void) xos_change_dynamic_area (os_DYNAMIC_AREA_RMA, move, NULL);
   tracef ("done\n");

#if TRACE
   if ((error = xos_read_dynamic_area (os_DYNAMIC_AREA_RMA,
         NULL, &size, NULL)) != NULL)
      goto finish;
   tracef ("RMA size at end 0x%X\n" _ size);
#endif

finish:
   return error;
}
/*------------------------------------------------------------------------*/
static os_error *App_Slot (const char *tail)

{  os_error *error = NULL;
   const char *cc;
   char *end;
   int move, size, size_limit, r;
   unsigned int value;
   byte *ram_limit;

   tracef ("App_Slot\n");
   cc = tail;
   while (*cc == ' ')
      cc++;

   if ((error = xos_read_unsigned (NONE, cc, SKIP, &end, (void *) &value)) != NULL)
      goto finish;

   switch (*end)
   {  case 'm': case 'M':
         value *= 1024;
      /*fall through*/

      case 'k': case 'K':
         value *= 1024;
         end++;
      break;
   }

   if ((error = xos_get_env (NULL, &ram_limit, NULL)) != NULL)
      goto finish;
   tracef ("top of application space 0x%X\n" _ ram_limit);

   /*We want to move by the difference between the application size
      and the value specified.*/
   move = (int) (ram_limit - 0x8000) - value;
   tracef ("wanted move is %d\n" _ move);

   /*What OS capabilities do we have*/
   if ((error = xos_byte (osbyte_IN_KEY, 0, 255, &r, NULL)) != NULL)
                goto finish;

   if (r >= 0xA5)
      {
      tracef ("look to the freepool\n");

      /* OS 3.50 and later juggle ram between the app slot and the free pool */
      if ((error = xos_change_dynamic_area (os_DYNAMIC_AREA_FREE_POOL, move, NULL)) != NULL)
         goto finish;
      }
   else
      {
      tracef ("look to the RMA\n");

      /* OS pre 3.50 so juggle ram between the app slot and the RMA */
      if ((error = xos_read_dynamic_area (os_DYNAMIC_AREA_RMA,
            NULL, &size, &size_limit)) != NULL)
         goto finish;
      tracef ("R M A expansion space %d\n" _ size_limit - size);

      /*Can't move it to more than its size limit.**/
      (void) MINAB (move, size_limit - size);
      tracef ("allowed move is %d\n" _ move);

      /*We don't care if this succeeds or fails - the attempt is the thing.*/
      (void) xos_change_dynamic_area (os_DYNAMIC_AREA_RMA, move, NULL);
      }

   tracef ("done\n");

#if TRACE
   if ((error = xos_read_dynamic_area (os_DYNAMIC_AREA_RMA,
         NULL, &size, NULL)) != NULL)
      goto finish;
   tracef ("RMA size at end 0x%X\n" _ size);
#endif

finish:
   return error;
}
/*------------------------------------------------------------------------*/
static os_error *Add_To_RMA (const char *tail)

{  os_error *error = NULL;
   const char *cc;
   char *end;
   unsigned int value;

   tracef ("Add_To_RMA\n");
   cc = tail;
   while (*cc == ' ')
      cc++;

   if ((error = xos_read_unsigned (NONE, cc, SKIP, &end, (void *) &value)) != NULL)
      goto finish;

   switch (*end)
   {  case 'm': case 'M':
         value *= 1024;
      /*fall through*/

      case 'k': case 'K':
         value *= 1024;
         end++;
      break;
   }

   /*Pass back any problems verbatim*/
   if ((error = xos_change_dynamic_area (os_DYNAMIC_AREA_RMA, value, NULL)) != NULL)
      goto finish;

   tracef ("done\n");

#if TRACE
   if ((error = xos_read_dynamic_area (os_DYNAMIC_AREA_RMA,
         NULL, &size, NULL)) != NULL)
      goto finish;
   tracef ("RMA size at end 0x%X\n" _ size);
#endif

finish:
   return error;
}
/*------------------------------------------------------------------------*/
static os_error *Do (const char *tail)

{  os_error *error = NULL;
   bits psr;

   tracef ("Do\n");

   if ((error = xos_gs_trans (tail, buffer, sizeof buffer, NULL,
         &psr)) != NULL)
      goto finish;

   if ((psr & _C) != NONE)
   {  error = main_error_lookup (error_BUFF_OVERFLOW, "BufOFlo");
      goto finish;
   }

   if ((error = xos_cli (buffer)) != NULL)
      goto finish;

finish:
   return error;
}
/*------------------------------------------------------------------------*/
static os_error *If_There (const char *tail)

{  os_error *error = NULL;
   const char *cc;
   int i, obj_type;

   tracef ("If_There\n");

   /*Skip leading spaces.*/
   cc = tail;
   while (*cc == ' ')
      cc++;

   /*Copy non-spaces into |s| - this is the file name.*/
   i = 0;
   while (*cc > ' ')
      buffer[i++] = *cc++;
   buffer[i] = '\0';
   tracef ("file name \"%s\"\n" _ buffer);

   /*So, is it there?*/
   /*Fix MED-3984: if this fails, behave as if the file were absent. JRC 19th
      Dec 1994*/
   if (xosfile_read_stamped_no_path (buffer, &obj_type, NULL, NULL, NULL, NULL,
         NULL) != NULL)
      obj_type = osfile_NOT_FOUND;

   /*Wizard wheeze to avoid parsing the rest of the line.*/
   sprintf (buffer, "If %d%.*s",
         obj_type != osfile_NOT_FOUND, str_len (cc), cc);
   /*Fix bizarre fault - strip trailing spaces. J R C 23rd Feb 1995*/
   for (i = strlen (buffer) - 1; buffer [i] == ' '; i--)
      buffer [i] = '\0';
   tracef ("command \"%s\"\n" _ buffer);

   if ((error = xos_cli (buffer)) != NULL)
   {  /*Fix MED-3984: if this gives a syntax error, change it to our own
         message by deliberataly causing an IfThere syntax error*/
      if (error->errnum == error_SYNTAX)
         error = xos_cli ("IfThere");
      goto finish;
   }

finish:
   return error;
}
/*--------------------------------------------------------------------*/
static os_error *Load_CMOS (const char *tail)

{  struct {char *file; char argb [os_CLI_LIMIT_RO4 + 1];} argl;
   bool done_open = FALSE;
   os_f f;
   int r, w, i, size, obj_type, bootversion = 370, fileversion, xsum, fxsum;
   bits file_type;
   os_error *error = NULL;
   const char *osversion;
   int nvmsize = get_nvm_size();

   tracef ("Load_CMOS\n");

   if ((error = xos_read_args ("file/a", tail, (char *) &argl,
         sizeof argl, NULL)) != NULL)
      goto finish;

   if ((error = xosfile_read_stamped_no_path (argl.file, &obj_type,
         NULL, NULL, &size, NULL, &file_type)) != NULL)
      goto finish;

   if (obj_type != osfile_IS_FILE)
   {  error = xosfile_make_error (argl.file, obj_type);
      goto finish;
   }

   if ((error = xosfind_openin (osfind_NO_PATH | osfind_ERROR_IF_ABSENT |
         osfind_ERROR_IF_DIR, argl.file, NULL, &f)) != NULL)
      goto finish;
   done_open = TRUE;

   if (size != 240 && size != 244 && size != (nvmsize+4))
   {
      error = main_error_lookup (ErrorBase_BootCommands + 0, "BadFile");
      goto finish; /* Not a configuration */
   }

   osversion = getenv("Boot$OSVersion");
   if (osversion != NULL)
   {
      if ((error = xos_read_unsigned (os_READ_CONTROL_TERMINATED | (os_read_unsigned_flags)10,
                                      osversion, NULL, SKIP,(bits *) &bootversion)) != NULL)
         goto finish; /* Read the os version number x100 */;
   }
      
   /* Old file formats will only be valid pre-Ursula */
   if (size == 240 && bootversion > 370)
   {
     error = main_error_lookup (ErrorBase_BootCommands + 1, "BadVer");
     goto finish;
   }
     
   /* Check the file's OS version number (if any) matches the machine */
   if (size == nvmsize+4)
   {
     if ((error = xosgbpb_read_at (f, (byte *) &fileversion, sizeof (fileversion), nvmsize, NULL)) != NULL)
        goto finish;
     if (fileversion != bootversion)
     {
       xosfind_close (f);
       error = main_error_lookup (ErrorBase_BootCommands + 1, "BadVer");
       goto finish;
     }
     if ((error = xosargs_set_ptr (f, 0)) != NULL)
        goto finish;
   }

   /* Ensure the file's checksum byte is correct */
   xsum = CMOSxseed;
   for (i = 0; i < 239; i++)
   {
   if ((error = xosgbpb_read (f, (byte *) &w, 1, NULL)) != NULL)
         /*(Note that the top 24 bits of |w| are garbage.)*/
      goto finish;
   xsum += (w & 0xFF);
   }
   /* fetch the checksum */
   if ((error = xosgbpb_read (f, (byte *) &fxsum, 1, NULL)) != NULL)
         /*(Note that the top 24 bits of |w| are garbage.)*/
      goto finish;

   if(nvmsize > 256)
   {
     /* bytes 240 to 255 are ignored */
     for (i = 240; i <= 255; i++)
     {
     if ((error = xosgbpb_read (f, (byte *) &w, 1, NULL)) != NULL)
           /*(Note that the top 24 bits of |w| are garbage.)*/
        goto finish;
     }
     for (i = 256; i < nvmsize; i++)
     {
     if ((error = xosgbpb_read (f, (byte *) &w, 1, NULL)) != NULL)
           /*(Note that the top 24 bits of |w| are garbage.)*/
        goto finish;
     xsum += (w & 0xFF);
     }
   }

   if ((xsum & 0xFF) != (fxsum & 0xFF))
   {
     xosfind_close (f);
     error = main_error_lookup (ErrorBase_BootCommands + 0, "BadFile");
     goto finish;
   }
   if ((error = xosargs_set_ptr (f, 0)) != NULL)
      goto finish;

   /* Actually load the values */
   for (i = 0; i < nvmsize; i++)
   {
      if ((error = xosgbpb_read (f, (byte *) &w, 1, NULL)) != NULL)
            /*(Note that the top 24 bits of |w| are garbage.)*/
         goto finish;

      switch (i)
      {  case osbyte_CONFIGURE_DST:
         {  /*Do not load bit 7.*/
            if((error = xos_byte (osbyte_READ_CMOS, i, SKIP, NULL, &r)) != NULL)
               goto finish;

            if ((error = xos_byte (osbyte_WRITE_CMOS, i,
                  w & ~osbyte_CONFIGURE_DST_MASK |
                  r & osbyte_CONFIGURE_DST_MASK,
                  NULL, NULL)) != NULL)
               goto finish;
            /* adjust the checksum */
            fxsum -= w&osbyte_CONFIGURE_DST_MASK;
            fxsum += r&osbyte_CONFIGURE_DST_MASK;
         }
         break;

         case osbyte_CONFIGURE_YEAR0:
         case osbyte_CONFIGURE_YEAR1:
         {
            /*Do nothing (but adjust checksum) - these are never loaded.*/
            if((error = xos_byte (osbyte_READ_CMOS, i, SKIP, NULL, &r)) != NULL)
               goto finish;
            fxsum -= w&0xff;
            fxsum += r&0xff;
         }
         break;

         default:
            if ((error = xos_byte (osbyte_WRITE_CMOS, i, w, NULL, NULL)) !=
                  NULL)
               goto finish;
         break;
      }
   }
   /* write in the checksum as recorded and amended .. */
   error = xos_byte (osbyte_WRITE_CMOS, 239, fxsum, NULL, NULL);

finish:
   if (done_open)
   {  os_error *error1 = xosfind_close (f);
      if (error == NULL) error = error1;
   }

   /*Never return an error from here - it would just mess up the boot
      sequence. J R C 23rd Aug 1995*/
   if (error != NULL) fprintf (stderr, "%s\n", error->errmess);

   return NULL;
}
/*--------------------------------------------------------------------*/
static os_error *Save_CMOS (const char *tail)

{  struct {char *file; char argb [os_CLI_LIMIT_RO4 + 1];} argl;
   bool done_open = FALSE;
   os_f f;
   int r, i;
   os_error *error = NULL;
   const char *osversion;
   int size = get_nvm_size();

   tracef ("Save_CMOS\n");

   if ((error = xos_read_args ("file/a", tail, (char *) &argl,
         sizeof argl, NULL)) != NULL)
      goto finish;

   if ((error = xosfind_openout (osfind_NO_PATH | osfind_ERROR_IF_DIR,
         argl.file, NULL, &f)) != NULL)
      goto finish; /* Check the file can be written to */
   done_open = TRUE;

   for (i = 0; i < size; i++)
   {  if ((error = xos_byte (osbyte_READ_CMOS, i, SKIP, NULL, &r)) !=
            NULL)
         goto finish;
      if ((error = xosgbpb_write (f, (byte *) &r, 1, NULL)) != NULL)
         goto finish; /* Put the byte from CMOS */
   }

   osversion = getenv("Boot$OSVersion");
   if (osversion != NULL)
      {
      /* If we can't read the variable just save the 240 byte CMOS */
      if ((error = xos_read_unsigned (os_READ_CONTROL_TERMINATED | (os_read_unsigned_flags)10,
                                      osversion, NULL, SKIP,(bits *) &r)) != NULL)
         goto finish; /* Read the os version number x100 */;
      if ((error = xosgbpb_write (f, (byte *) &r, 4, NULL)) != NULL)
         goto finish; /* Append the word to the CMOS file */
      }
   else
      {
      /* Variable not found. If we're on RISC OS 5 try computing the value manually
         This helps OMAP machines which lack CMOS widgets; unless the OS version is present the HAL won't pick up the CMOS contents */
      if ((error = xosmodule_enumerate_rom_with_info (0,-1,NULL,NULL,NULL,NULL,NULL,&r)) != NULL)
         goto finish;
      if ((r>>16) != 5) /* RISC OS 5? */
         goto finish;
      r = ((r & 0xf000) >> 12)*10 + 500; /* Drop 2nd digit from version, as per BootVars */
      if ((error = xosgbpb_write (f, (byte *) &r, 4, NULL)) != NULL)
         goto finish; /* Append the word to the CMOS file */
      }

finish:
   if (done_open)
   {  os_error *error1 = xosfind_close (f);
      error = xosfile_set_type (argl.file, osfile_TYPE_CONFIG);
      if (error == NULL) error = error1;
   }

   tracef ("Save_CMOS DONE\n");
   if (error != NULL)
      tracef ("with error %s\n" _ error->errmess);
   return error;
}
/*------------------------------------------------------------------------*/
static os_error *Repeat (const char *tail)

{  os_error *error = NULL;

   tracef ("Repeat\n");

   /*Repeat is done by running a file, since it is then running in USR mode
      and handlers work.*/
   sprintf (buffer, "Resources:$.Resources.BootCmds.Repeat %.*s",
         str_len (tail), tail);
   tracef ("/%s\n" _ buffer);
   if ((error = xosfscontrol_run (buffer)) != NULL)
      goto finish;

   #if 0
   /*Repeat is done by entering the module, since it is then running in USR mode
      and handlers work.*/
   if ((error = xosmodule_enter ("BootCommands", tail)) != NULL)
      goto finish;
   #endif

finish:
   tracef ("Repeat DONE\n");
   if (error != NULL)
      tracef ("with error %s\n" _ error->errmess);
   return error;
}
/*------------------------------------------------------------------------*/
static os_error *Safe_Logon (const char *tail)

{  struct safelogon_args {char *fs, *user, *password; char argb [os_CLI_LIMIT_RO4 + 1];} *argl;
   int station, net, context, collate;
   fileswitch_fs_no temp_fs;
   netfs_file_server_context file_server_context;
   char *end;
   bool logon_required = TRUE, found_fs, named_fs;
   os_error *error = NULL;

   tracef ("Safe_Logon\n");

   argl = malloc(sizeof(struct safelogon_args));
   if (argl == 0)
       goto finish;

   /*Fix bug: check that the temporary filing system is indeed NetFS. JRC
      16th Feb 1995*/
   if ((error = xosargs_read_temporary_fs (&temp_fs)) != NULL)
      goto finish;

   if (temp_fs == fileswitch_FS_NUMBER_NETFS)
   {  if ((error = xos_read_args ("fs/a,user/a,password", tail,
            (char *) argl, sizeof *argl, NULL)) != NULL)
         goto finish;

      tracef ("fs \"%s\"\n" _ argl->fs);
      tracef ("user \"%s\"\n" _ argl->user);
      tracef ("password \"%s\"\n" _
            argl->password != NULL? argl->password: "NULL");

      /*If the first character of the fs is not ':', we steer clear.*/
      if (argl->fs [0] == ':')
      {  argl->fs++;

         /*Station number or name?*/
         named_fs = xeconet_read_station_number (argl->fs, NULL, &station,
               &net) != NULL;
         if (named_fs)
            tracef ("fs is named \"%s\"\n" _ argl->fs);
         else
            tracef ("fs is numbered %d.%d\n" _ net _ station);

         context = 0;
         while (TRUE)
         {  if ((error = xnetfs_enumerate_fs_contexts (context,
                  &file_server_context, sizeof file_server_context, 1,
                  &context, NULL)) != NULL)
               goto finish;
            if (context == netfs_NO_MORE) break;

            /*The useful parts of this are space-terminated.*/
            if ((end = strchr (file_server_context.disc_name, ' ')) != NULL)
               *end = '\0';
            if ((end = strchr (file_server_context.user_name, ' ')) != NULL)
               *end = '\0';

            tracef ("found fs %d.%d = \"%s\", user \"%s\"\n" _
                  file_server_context.net_no _
                  file_server_context.station_no _
                  file_server_context.disc_name _
                  file_server_context.user_name);

            if (named_fs)
            {  if ((error = xterritory_collate (territory_CURRENT, argl->fs,
                     file_server_context.disc_name, territory_IGNORE_CASE,
                     &collate)) != NULL)
                  goto finish;

               found_fs = collate == 0;
            }
            else
               found_fs = file_server_context.station_no == station &&
                  file_server_context.net_no == net;

            if (found_fs)
            {  if ((error = xterritory_collate (territory_CURRENT, argl->user,
                     file_server_context.user_name, territory_IGNORE_CASE,
                     &collate)) != NULL)
                  goto finish;

               if (collate == 0)
               {  /*We have found a match, and are about to set
                     |logon_required| to FALSE. One more thing to check,
                     though: does the file server agree that we are logged
                     on? JRC 19th Dec 1994*/
                  netfs_read_user_info info;

                  sprintf (info AS request.user_name, "%s\r", argl->user);

                  tracef ("doing fs op ...\n");
                  if ((error = xnetfs_do_fs_op_to_given_fs
                        (netfs_FS_OP_READ_USER_INFO, (netfs_op *) &info,
                        strlen (info AS request.user_name), sizeof info,
                        file_server_context.station_no,
                        file_server_context.net_no, NULL, NULL)) != NULL)
                     goto finish;

                  tracef ("privilege byte 0x%X\n" _ info AS reply.privilege);
                  tracef ("station %d\n" _ info AS reply.station);
                  tracef ("net %d\n" _ info AS reply.net);

                  logon_required = FALSE;
                  break;
   }  }  }  }  }

finish:
   free(argl);
   /*Ignore errors up to this point. If there have been any, it's a safe bet
      that |logon_required| is TRUE.*/
   if (error != NULL)
      tracef ("LOGON because of error %s\n" _ error->errmess);
   error = NULL;

   /*If that user is not logged on to that file server, do it now.*/
   if (logon_required)
   {
      sprintf (buffer, "%%Logon %.*s", str_len (tail), tail);
         /*Not Net:%%Logon! JRC 17th Feb 1995*/
      error = xos_cli (buffer);
   }

   return error;
}
/*------------------------------------------------------------------------*/
static os_error *Shrink_RMA(const char *tail)

{
   os_error *error = NULL;
   int size;

   tracef("Shrink_RMA\n");

   if ((error = xos_read_dynamic_area (os_DYNAMIC_AREA_RMA,
         NULL, &size, NULL)) != NULL)
      goto finish;

   /*Ignore any errors here*/
   (void) xos_change_dynamic_area (os_DYNAMIC_AREA_RMA, -size, NULL);

   tracef ("done\n");

finish:
   return error;

   NOT_USED( tail );
}
/*------------------------------------------------------------------------*/
static os_error *Free_Pool(const char *tail)

{
   int next_size;
   os_error *err = xwimp_slot_size( -1, -1, NULL, &next_size, NULL );
   if ( err == NULL )
   {
      int app_size;
      err = xos_change_environment( 0x0E, 0, 0, 0, (void **)&app_size, NULL, NULL );
      if ( err == NULL ) err = xos_read_dynamic_area( 6, NULL, NULL, NULL );
      if ( err == NULL ) err = xos_change_dynamic_area( 6, app_size-next_size, NULL );
   }
   return err;

   NOT_USED( tail );
}
/*------------------------------------------------------------------------*/
static os_error *X (const char *tail)

{  os_error    *error   = NULL;
   int          context = 0;
   os_var_type  vartype = os_VARTYPE_STRING;

   tracef ("X\n");

   error = xos_cli(tail);
   if (error != NULL)
   {
     if (getenv(X_ENVVAR) == NULL)
     {
       error = xos_set_var_val(X_ENVVAR,
                               (byte *)(error->errmess),
                               strlen(error->errmess),
                               context,
                               vartype,
                               &context,
                               &vartype);
     }
     else
     {
       error = NULL;
     }
   }

   return error;
}

/*------------------------------------------------------------------------*/
_kernel_oserror *main_initialise (char *tail, int podule_base,
      void *workspace)

{  os_error *error = NULL;
   bool done_open_file = FALSE;
   char *message_file_name;
#ifdef STANDALONE
   bool registered_messages = FALSE;
#endif

   NOT_USED (tail)
   NOT_USED (podule_base)

   Workspace = workspace;

   if ((error = trace_initialise ("BootCommands$Trace")) != NULL)
      goto finish;

   tracef ("main_initialise\n");

   if (getenv ("BootCommands$Path") == NULL)
      message_file_name = "Resources:Resources.BootCmds.Messages";
   else
      message_file_name = "BootCommands:Messages";

#ifdef STANDALONE
   if ((error = xresourcefs_register_files (files_messages ())) != NULL)
      goto finish;
   registered_messages = TRUE;
#endif

   /*Load files.*/
   if ((error = xmessagetrans_open_file (&Control_Block, message_file_name,
         NULL)) != NULL)
      goto finish;
   done_open_file = TRUE;

   Commands [main_ADD_APP]    = &Add_App;
   Commands [main_APP_SIZE]   = &App_Size;
   Commands [main_DO]         = &Do;
   Commands [main_IF_THERE]   = &If_There;
   Commands [main_LOAD_CMOS]  = &Load_CMOS;
   Commands [main_SAVE_CMOS]  = &Save_CMOS;
   Commands [main_REPEAT]     = &Repeat;
   Commands [main_SAFE_LOGON] = &Safe_Logon;
   Commands [main_FREE_POOL]  = &Free_Pool;
   Commands [main_SHRINK_RMA] = &Shrink_RMA;
   Commands [main_ADD_TO_RMA] = &Add_To_RMA;
   Commands [main_APP_SLOT]   = &App_Slot;
   Commands [main_X]          = &X;

finish:
   if (error != NULL)
   {  tracef ("ERROR: \"%s\" (error 0x%X)\n" _ error->errmess _ error->errnum);

      if (done_open_file)
      {  os_error *error1;

         error1 = xmessagetrans_close_file (&Control_Block);
         if (error == NULL) error = error1;
      }

#ifdef STANDALONE
      if (registered_messages)
      {  os_error *error1;

         error1 = xresourcefs_deregister_files (files_messages ());
         if (error == NULL) error = error1;
      }
#endif
   }

   return (_kernel_oserror *) error;
}
/*------------------------------------------------------------------------*/
_kernel_oserror *main_terminate (bool fatal, int instance, void *workspace)

{  os_error *error = NULL;

   NOT_USED (fatal)
   NOT_USED (instance)
   NOT_USED (workspace)

   tracef ("main_terminate\n");

   if ((error = xmessagetrans_close_file (&Control_Block)) != NULL)
      goto finish;

#ifdef STANDALONE
   if ((error = xresourcefs_deregister_files (files_messages ())) != NULL)
      goto finish;
#endif

finish:
   {  os_error *error1 = trace_terminate ();
      if (error == NULL) error = error1;
   }

   return (_kernel_oserror *) error;
}
/*------------------------------------------------------------------------*/
_kernel_oserror *main_command (const char *tail, int argc, int cmd_no,
                               void *workspace)

{
   NOT_USED (argc)
   NOT_USED (workspace)

   tracef ("main_command: tail \"%.*s\"\n" _ str_len (tail) _ tail);

   return (_kernel_oserror *)(*Commands [cmd_no]) (tail);
}
/*------------------------------------------------------------------------*/
@


4.21
log
@Missing message token fix
When built with CMDHELP=None the AppSizeSyntax/AppSlotSyntax/AddToRMASyntax/IfThereSyntax tokens are not present in the messages file.
In fact, for the first 3 we don't need to manually check for trailing parameters since the CMHG definition has max-args of 1, so the OS does it for us.
For IfThereSyntax we instead manually cause an IfThere syntax error in order to get the error message (with CMDHELP=None this will come from the english text, and for internationalised versions this will be looked up for us by the kernel).
Set min-args to 1 for IfThere, this saves having to construct the *If command which we know will fail (for a start there must be no 'then'!).

Tested RAM loaded, no longer reports missing message token.

Version 1.48. Tagged as 'BootCmds-1_48'
@
text
@d275 1
a275 1
         resource_size += sizeof 0; /*terminator*/
@


4.20
log
@Make *SaveCMOS cope better if the boot sequence hasn't been run
Detail:
  c/main - If running on RISC OS 5, *SaveCMOS will now guess at the correct Boot$OSVersion value if it hasn't been set by the boot sequence.
  This makes things easier for OMAP machines which are reliant on SDCMOS; unless the version number is present in the CMOS file the HAL won't pick up the CMOS values on the next boot, so it's important for the OS to be able to determine this value for itself to prevent people getting stuck in situations where boot isn't running and they can't get fixed CMOS settings saved due to lack of Boot$OSVersion
Admin:
  Tested on Pandora


Version 1.45. Tagged as 'BootCmds-1_45'
@
text
@a356 9
   while (*end == ' ')
      end++;

   if (!('\0' <= *end && *end < ' '))
   {  tracef ("invalid terminator %d\n" _ *end);
      error = main_error_lookup (error_SYNTAX, "AppSizeSyntax");
      goto finish;
   }

a418 9
   while (*end == ' ')
      end++;

   if (!('\0' <= *end && *end < ' '))
   {  tracef ("invalid terminator %d\n" _ *end);
      error = main_error_lookup (error_SYNTAX, "AppSlotSyntax");
      goto finish;
   }

a496 9
   while (*end == ' ')
      end++;

   if (!('\0' <= *end && *end < ' '))
   {  tracef ("invalid terminator %d\n" _ *end);
      error = main_error_lookup (error_SYNTAX, "AddToRMASyntax");
      goto finish;
   }

d574 1
a574 1
         message. JRC 19th Dec 1994*/
d576 1
a576 1
         error = main_error_lookup (error_SYNTAX, "IfThereSyntax");
@


4.19
log
@Add support for progress indication and 'must continue' switch
* The switch '-stb' has existed for some time but is a bit obtuse, renamed to '-continue' (though -stb is still accepted as an alias).
* Added support for BootFX module, via switch '-progress start,range' which will scale the work done and work yet to do into a percentage and pass it to the BootFX module (intended to track boot progress).
* Trimmed out old switched out repeat command code that ran in SVC mode.
* Eliminate last trace of Support011 library, was only using the control terminated version of strlen() which is in ConfigLib (now linked against).
* Const qualifiers added to command handlers.

Version 1.44. Tagged as 'BootCmds-1_44'
@
text
@d816 12
@


4.18
log
@Makefile adapted to accept CMDHELP=None
* Recreated from fragments
* No longer creates two resource areas (one for Repeat, one for messages) since RESGEN can put many files into one area
* No longer does a ResourceFS register in the ROM case - the resources phase now exports both Repeat and messages directly into the messages module
* Corrected error number for BufOFlo (was using the token number!)
* Used newly allocated error base for all other errors
* Internationalised "Can't claim memory" in Repeat
* Fixed a couple of compiler warnings

Version 1.43. Tagged as 'BootCmds-1_43'
@
text
@d31 4
d50 1
d53 2
a54 5
/*From Support*/
#include "kernel.h"
#include "Global/NewErrors.h"
#include "riscos.h"
#include "jc_trace.h"
d59 1
a59 1
#include "run.h"
d63 1
a63 1
static os_error *(*Commands [main_COMMAND_COUNT]) (char *);
d91 2
a92 2
      int data_size, byte *data, bits load_addr, bits exec_addr,
      int *size_out)
a123 1
/*finish:*/
d126 11
d138 1
a138 2
#define RES_APP_PATH "Resources:$.Apps"
static os_error *Add_App (char *tail)
d329 1
a329 1
static os_error *App_Size (char *tail)
d332 2
a333 1
   char *cc, *end;
d400 1
a400 1
static os_error *App_Slot (char *tail)
d403 2
a404 1
   char *cc, *end;
d489 1
a489 1
static os_error *Add_To_RMA (char *tail)
d492 2
a493 1
   char *cc, *end;
d541 1
a541 1
static os_error *Do (char *tail)
d564 1
a564 1
static os_error *If_There (char *tail)
d567 1
a567 1
   char *cc;
d593 1
a593 1
         obj_type != osfile_NOT_FOUND, riscos_strlen (cc), cc);
d611 1
a611 15

/* defined here to avoid conflicts between definitions of _C with swis.h */
#undef OS_NVMemory
#define OS_NVMemory 0x00000076

static int get_nvm_size(void)
{
   _kernel_swi_regs rg;
   /* check how much to load/save */
   rg.r[0]=0;
   _kernel_swi(OS_NVMemory,&rg,&rg);
   return rg.r[0]?osbyte_CONFIGURE_CHECKSUM+1:rg.r[1];
}

static os_error *Load_CMOS (char *tail)
d777 1
a777 1
static os_error *Save_CMOS (char *tail)
d830 1
a830 1
static os_error *Repeat (char *tail)
d839 1
a839 1
         riscos_strlen (tail), tail);
d858 1
a858 1
static os_error *Safe_Logon (char *tail)
d975 1
a975 1
      sprintf (buffer, "%%Logon %.*s", riscos_strlen (tail), tail);
d983 2
a984 1
static os_error *Shrink_RMA( char *tail )
d1006 2
a1007 1
static os_error *Free_Pool( char *tail )
d1023 2
a1024 1
static os_error *X (char *tail)
d1034 1
a1034 1
     if (getenv(main_X_ENVVAR) == NULL)
d1036 1
a1036 1
       error = xos_set_var_val(main_X_ENVVAR,
d1099 1
a1099 1
   Commands [main_FREE_POOL]  = *Free_Pool;
d1155 2
a1156 4
_kernel_oserror *main_command (char *tail, int argc, int cmd_no,
      void *workspace)

{  os_error *error = NULL;
d1158 1
d1162 1
a1162 4
   tracef ("main_command: tail \"%.*s\"\n" _ riscos_strlen (tail) _ tail);

   if ((error = (*Commands [cmd_no]) (tail)) != NULL)
      goto finish;
d1164 1
a1164 2
finish:
   return (_kernel_oserror *) error;
a1165 104
#if 0
/*------------------------------------------------------------------------*/
int main (void)

{  int context;
   struct {char *prog, *command, *directory; osbool directories, applications,
         files; char *type, *tail; osbool tasks; char argb [os_CLI_LIMIT_RO4 + 1];} argl;
   osgbpb_INFO_STAMPED (FILENAME_MAX + 1) info;
   bool done_initialise = FALSE;
   bits file_type;
   char *tail;
   os_error *error = NULL;

   tracef ("main\n");

   if ((error = xos_get_env (&tail, NULL, NULL)) != NULL)
      goto finish;

   tracef ("tail %s\n" _ tail);

   malloc (1);

   if ((error = xos_read_args ("prog/a,command/a,directory/a,directories/s,"
         "applications/s,files/s,type/k,tail,tasks/s",
         tail, (char *) &argl, sizeof argl, NULL)) != NULL)
      goto finish;

   tracef ("command \"%s\"\n" _      argl.command);
   tracef ("directory \"%s\"\n" _    argl.directory);
   tracef ("directories \"%s\"\n" _  WHETHER (argl.directories));
   tracef ("applications \"%s\"\n" _ WHETHER (argl.applications));
   tracef ("files \"%s\"\n" _        WHETHER (argl.files));
   tracef ("type \"%s\"\n" _         argl.type != NULL? argl.type: "NULL");
   tracef ("tail \"%s\"\n" _         argl.tail != NULL? argl.tail: "NULL");
   tracef ("tasks \"%s\"\n" _        WHETHER (argl.tasks));

   if (!argl.directories && !argl.applications && !argl.files &&
         !argl.type)
      argl.files = argl.directories = TRUE;

   if (argl.type)
      if ((error = xosfscontrol_file_type_from_string (argl.type,
            &file_type)) != NULL)
         goto finish;

   if (argl.tasks)
   {  if ((error = xwimp_initialise (wimp_VERSION_RO2, "Repeat",
            NULL, NULL, NULL)) != NULL)
         goto finish;
      done_initialise = TRUE;
   }

   context = 0;
   while (TRUE)
   {  if ((error = xosgbpb_dir_entries_info_stamped (argl.directory,
            (osgbpb_info_stamped_list *) &info, 1, context,
            sizeof info, "*", NULL, &context)) != NULL)
         goto finish;
      if (context == osgbpb_NO_MORE) break;

      if
      (  (  info.obj_type == osfile_IS_FILE &&
            (argl.files || info.file_type == file_type)
         ) ||
         (  info.obj_type == osfile_IS_DIR &&
            (  argl.directories ||
               (argl.applications && info.name [0] == '!')
      )  )  )
      {  char cmd [os_CLI_LIMIT_RO4 + 1];

         if (!argl.tail)
            sprintf (cmd, "%s %s.%s", argl.command, argl.directory,
                  info.name);
         else
            sprintf (cmd, "%s %s.%s %s", argl.command, argl.directory,
                  info.name, argl.tail);

         if (argl.tasks)
         {  tracef (stderr, "WimpTask %s\n", cmd);

            if ((error = xwimp_start_task (cmd, NULL)) != NULL)
               goto finish;
         }
         else
         {  tracef (stderr, "\"%s\"\n", cmd);
            if ((error = run_call (cmd, Workspace)) != NULL)
               goto finish;
            tracef (stderr, "\"%s\" done\n", cmd);
   }  }  }

finish:
   if (done_initialise)
   {  os_error *error1 = xwimp_close_down (NULL);
      if (error == NULL) error = error1;
   }

   if (error != NULL)
   {  fprintf (stderr, "Repeat: %s\n", error->errmess);
      exit (1);
   }
   else
      exit (0);
}
#endif
@


4.17
log
@Yet another attempt at getting read-only booting working.

Spotted a missing part to the tweak which I made previously to this
module (canonicalising the directory name). Adding this means the
read-only boot sequence (in ResourceFS) works correctly - apart from
a final tweak in !Scrap, to be checked-in shortly.

Version 1.41. Tagged as 'BootCmds-1_41'
@
text
@a24 1
#include <kernel.h>
d49 2
d68 20
d539 1
a539 1
   {  error = main_error_lookup (os_GLOBAL_BUF_OFLO, "BufOFlo");
d643 2
a644 2
      {
      error = main_error_lookup (0, "BadFile");
d646 1
a646 1
      }
d650 1
a650 1
      {
d654 2
a655 2
      }

d658 2
a659 2
     {
     error = main_error_lookup (0, "BadVer");
d661 2
a662 2
     }

d671 1
a671 1
       error = main_error_lookup (0, "BadVer");
d713 1
a713 1
     error = main_error_lookup (0, "BadFile");
a1056 2
   bool registered_repeat = FALSE;

a1081 4
   if ((error = xresourcefs_register_files (files_repeat ())) != NULL)
      goto finish;
   registered_repeat = TRUE;

d1113 1
a1113 8
      if (registered_repeat)
      {  os_error *error1;

         error1 = xresourcefs_deregister_files (files_repeat ());
         if (error == NULL) error = error1;
      }

   #ifdef STANDALONE
d1120 1
a1120 1
   #endif
a1138 3
   if ((error = xresourcefs_deregister_files (files_repeat ())) != NULL)
      goto finish;

a1272 19
os_error *main_error_lookup (int errnum, char *token, ...)

{  va_list list;
   char *p [4];
   int i;
   os_error error_block;

   tracef ("main_error_lookup\n");

   /*Assume that 4 args are always given.*/
   va_start (list, token);
   for (i = 0; i < 4; i++) p [i] = va_arg (list, char *);
   va_end (list);

   error_block.errnum = errnum;
   strcpy (error_block.errmess, token);
   return xmessagetrans_error_lookup (&error_block, &Control_Block, NULL, 0,
         p [0], p[1], p [2], p [3]);
}
@


4.16
log
@Yes, yes - I should've tested BootCmds first...

I didn't break it, but I didn't exactly fix it either. This one works.
@
text
@d159 3
@


4.15
log
@Fix to the AddApp command.

If you attempt to AddApp an app which is already within Resources:$.Apps (but not
a subdirectory therein) it would create a stub with circular references, leading
to stack exhaustion. Fixed to take no action in this case (i.e. not to create the
stub).

Untested. Will be required for booting from ResourceFS.

Version 1.40. Tagged as 'BootCmds-1_40'
@
text
@d105 1
a105 1
#define RES_APP_PATH "Resources:$.Apps."
a155 3
   if ((error = xosfscontrol_canonicalise_path (dir_name, canon, NULL, NULL, (os_CLI_LIMIT_RO4 + 1), NULL)) != NULL)
      goto finish;

a157 3
    *
    * This might not work if the case was incorrect in the passed-in parameter because
    * canonicalising the filename irritatingly doesn't correct the case...
d159 2
a160 6
   if (strlen (canon) > strlen (RES_APP_PATH) /* The directory could be in Resources:$.Apps (dir name long enough) */
       &&
       0 == strncmp (canon, RES_APP_PATH, strlen (RES_APP_PATH)) /* It's somewhere in Resources:$.Apps (path is same) */
       &&
       NULL == strchr (canon + strlen (RES_APP_PATH), '.') /* It's not in a subdirectory (no further dots in the path) */
      )
@


4.14
log
@  A couple of bugfixes
Detail:
  * *Repeat allows for command lines up to 1024 bytes (RISC OS 4+ standard)
    rather than 256 bytes
 * Fixed crash on *Repeat -sort
 * Uses OS_HeapSort32 rather than OS_HeapSort
Admin:
  Provided by Thomas Milius

Version 1.39. Tagged as 'BootCmds-1_39'
@
text
@d105 1
d156 17
d186 1
a186 2
         if ((error = xosfscontrol_canonicalise_path (application,
               canon, NULL, NULL, (os_CLI_LIMIT_RO4 + 1), NULL)) != NULL)
d191 1
a191 2
         /*We make a !Boot file if there is already a !Boot file or a
            !Sprites file.*/
d194 1
a194 2
         if ((error = xosfile_read_stamped_no_path (name, &boot_type,
               NULL, NULL, NULL, NULL, NULL)) != NULL)
d210 1
a210 2
         if (boot_type != osfile_NOT_FOUND || sprites_type !=
               osfile_NOT_FOUND)
d222 1
a222 2
         if ((error = xosfile_read_stamped_no_path (name, &help_type,
               NULL, NULL, NULL, NULL, NULL)) != NULL)
d245 1
a245 2
         if ((error = Register (NULL, run_name, strlen (run_data),
               (byte *) run_data, SKIP, SKIP, &size)) != NULL)
d252 1
a252 2
         if ((error = xosmodule_alloc (resource_size, (void **) &file_list))
               != NULL)
d256 1
a256 2
         /*Build common load and exec addresses for everything (they're all
               Obey files).*/
d259 1
a259 2
         info_words AS addrs.load_addr = 0xFFF00000u | osfile_TYPE_OBEY <<
               osfile_FILE_TYPE_SHIFT;
d266 1
a266 2
         if (boot_type != osfile_NOT_FOUND || sprites_type !=
               osfile_NOT_FOUND)
d294 1
d296 1
a296 1
      }
d641 1
a641 1
      
d648 1
a648 1
     
d660 1
a660 1
     if ((error = xosargs_set_ptr (f, 0)) != NULL) 
d686 1
a686 1
     }   
d707 1
a707 1
   {  
d723 1
a723 1
            /* adjust the checksum */   
d725 1
a725 1
            fxsum += r&osbyte_CONFIGURE_DST_MASK;   
d736 1
a736 1
            fxsum += r&0xff;   
@


4.13
log
@   LoadCMOS and SaveCMOS commands updated to use whole of NV memory
Detail:
Admin:
  tested at castle
  castle added IP


Version 1.34. Tagged as 'BootCmds-1_34'
@
text
@d20 1
d65 1
a65 1
static char buffer[os_CLI_LIMIT + 1];
d107 1
a107 1
{  struct {char *applications; char argb [os_CLI_LIMIT + 1];} argl;
d110 4
a113 4
   char *leaf_name, name [os_CLI_LIMIT + 1], boot_name [os_CLI_LIMIT + 1],
      help_name [os_CLI_LIMIT + 1], run_name [os_CLI_LIMIT + 1],
      boot_data [os_CLI_LIMIT + 1], help_data [os_CLI_LIMIT + 1],
      run_data [os_CLI_LIMIT + 1], canon [os_CLI_LIMIT + 1],
d128 1
a128 1
   name = (char *)malloc(11 * 257);
d131 10
a140 10
   boot_name = name + 257;
   help_name = boot_name + 257;
   run_name = help_name + 257;
   boot_data = run_name + 257;
   help_data = boot_data + 257;
   run_data = help_data + 257;
   canon = run_data + 257;
   dir_name = canon + 257;
   entry = dir_name + 257;
   application = entry + 257;
d158 1
a158 1
            1, context, 257, leaf_name, &found, &context)) != NULL)
d169 1
a169 1
               canon, NULL, NULL, 257, NULL)) != NULL)
d590 1
a590 1
{  struct {char *file; char argb [os_CLI_LIMIT + 1];} argl;
d756 1
a756 1
{  struct {char *file; char argb [os_CLI_LIMIT + 1];} argl;
d837 1
a837 1
{  struct safelogon_args {char *fs, *user, *password; char argb [os_CLI_LIMIT + 1];} *argl;
d1167 1
a1167 1
         files; char *type, *tail; osbool tasks; char argb [os_CLI_LIMIT + 1];} argl;
d1229 1
a1229 1
      {  char cmd [os_CLI_LIMIT + 1];
@


4.12
log
@Filetype was being set before the file closed in *SAVECMOS.

Version 1.31. Tagged as 'BootCmds-1_31'
@
text
@d573 14
d592 1
a592 1
   int r, w, i, size, obj_type, bootversion = 370, fileversion, xsum;
d596 1
d618 1
a618 1
   if (size != 240 && size != 244)
d640 1
a640 1
   if (size == 244)
d642 1
a642 1
     if ((error = xosgbpb_read_at (f, (byte *) &fileversion, sizeof (fileversion), 240, NULL)) != NULL)
d663 2
a664 1
   if ((error = xosgbpb_read (f, (byte *) &w, 1, NULL)) != NULL)
d667 20
a686 1
   if ((xsum & 0xFF) != (w & 0xFF))
d696 1
a696 1
   for (i = 0; i < size; i++)
d705 1
a705 1
            if ((error = xos_byte (osbyte_READ_CMOS, i, SKIP, NULL, &r)) != NULL)
d709 2
a710 1
                  w & ~osbyte_CONFIGURE_DST_MASK | r & osbyte_CONFIGURE_DST_MASK,
d713 3
d721 7
a727 1
            /*Do nothing - these are never loaded.*/
d737 2
d761 1
d774 1
a774 1
   for (i = 0; i <= osbyte_CONFIGURE_CHECKSUM; i++)
@


4.11
log
@Addition of ShrinkRMA,AddToRMA,and Appslot.
Note the code for Appslot and Appsize is probably sufficiently similar
to allow Appsize to be deleted or aliased with Appslot.

Version 1.30. Tagged as 'BootCmds-1_30'
@
text
@a744 2
   error = xosfile_set_type (argl.file, osfile_TYPE_CONFIG);

d748 1
@


4.10
log
@Savecmos now appends a word representing Boot$OSVersion to the end of
the 240 byte configuration.
Loadcmos will now only load 240 byte configs on machines <= 370,and
will fault configs if the local Boot$OSVersion doesn't match that
stored at the end of the file,or if the checksum is wrong.
Most of the Loadcmos stuff is stolen from the old bootsequence util of
the same name.
Added 2 new error messages to the Messages file.

Version 1.29. Tagged as 'BootCmds-1_29'
@
text
@d364 139
d912 22
d1032 3
@


4.9
log
@Addition of SaveCMOS to complement LoadCMOS
Changes from KJB to stop the C99 compiler getting upset about BOOL

Version 1.28. Tagged as 'BootCmds-1_28'
@
text
@d439 1
a439 1
   int r, w, i, size, obj_type;
d442 1
d464 58
d523 2
a524 1
   {  if ((error = xosgbpb_read (f, (byte *) &w, 1, NULL)) != NULL)
d531 1
a531 2
            if ((error = xos_byte (osbyte_READ_CMOS, i, SKIP, NULL, &r)) !=
                  NULL)
d574 1
d594 11
@


4.8
log
@  Has a chance of building with cc 5.45.
Detail:
  Was defining structs for the block returned from OS_ReadArgs, but used
  bool types for switch arguments. Now that they are 1 byte wide, this was
  causing problems. Now replaced with osbool types, which should remain
  1 word wide.
Admin:
  Not tested.

Version 1.27. Tagged as 'BootCmds-1_27'
@
text
@d507 41
d796 1
@


4.7
log
@  Explicitly include stdbool.h because this component uses bool
Admin:
  Might help it build.


Version 1.26. Tagged as 'BootCmds-1_26'
@
text
@d841 2
a842 2
   struct {char *prog, *command, *directory; bool directories, applications,
         files; char *type, *tail; bool tasks; char argb [os_CLI_LIMIT + 1];} argl;
@


4.6
log
@  * Added 'X' as a CLI command.
Detail:
  The 'X' command has existed for a long while as a transient utility in the
  !Internet application. I have impemented it as a CLI command in this module
  to reduce FS access required to use it. Note: this version of X implements
  the extended functionality of placing any suppressed error message into the
  system variable "X$Error" (if not already set).
Admin:
  Tested on RiscPC.

Version 1.25. Tagged as 'BootCmds-1_25'
@
text
@d30 1
@


4.5
log
@  Slight improvement to the *AddApp command.
Detail:
  The !Boot and !Run files which are created in ResourceFS contain a single
  line which will run the counterpart file in the added application. This
  line should really have %*0 on the end so that any parameters passed to
  the application's !Boot and more importantly to the !Run are passed on,
  rather than being lost.
Admin:
  Tested on RO4 RiscPC.

Version 1.23. Tagged as 'BootCmds-1_23'
@
text
@d659 1
a659 1

d675 29
d757 1
@


4.4
log
@  The output value for SWI XOS_ReadUnsigned should be treated as unsigned.
Detail:
  Fails to build with OSLib 6.21 since the prototype for this function
    has been fixed.  I've changed the type of the value to unsigned
    but always cast its address to void* for this API call to preserve
    compatibility with older versions of OSLib (which are broken)
Admin:
  Built on desktop machine.


Version 1.21. Tagged as 'BootCmds-1_21'
@
text
@d189 1
a189 1
            sprintf (boot_data, "/%s.!Boot\n", canon);
d227 1
a227 1
         sprintf (run_data, "/%s\n", canon);
@


4.3
log
@  Moved to srccommit.
  Fixed directory enumerators.
  Removed obsolete assembler sources.
Detail:
  s/main was the output of "cc -S c/main" :-/
Admin:
  Built.

Version 1.19. Tagged as 'BootCmds-1_19'
@
text
@d297 2
a298 1
   int value, move, size, size_limit;
d306 1
a306 1
   if ((error = xos_read_unsigned (NONE, cc, SKIP, &end, &value)) != NULL)
@


4.2
log
@Module merged
@
text
@d154 1
a154 1
   while (TRUE)
a157 1
      if (context == osgbpb_NO_MORE) break;
@


4.2.2.1
log
@Modified to open "Resources:$...." not "Resources:..."
@
text
@d700 1
a700 1
      message_file_name = "Resources:$.Resources.BootCmds.Messages";
@


4.1
log
@Initial revision
@
text
@d49 1
a49 1
#include "trace.h"
d62 3
d87 1
a87 1
      fh->attr      = osfile_ATTR_OWNER_READ | osfile_ATTR_OWNER_WRITE;
d107 1
d114 4
d122 1
a122 1
   osfile_info_words info_words;
d125 15
d156 1
a156 1
            1, context, sizeof entry, leaf_name, &found, &context)) != NULL)
d168 1
a168 1
               canon, NULL, NULL, sizeof application, NULL)) != NULL)
d290 1
a365 1
   char buffer [os_CLI_LIMIT + 1];
d389 1
a389 1
   char s [os_CLI_LIMIT + 1], *cc;
d402 3
a404 3
      s [i++] = *cc++;
   s [i] = '\0';
   tracef ("file name \"%s\"\n" _ s);
d409 1
a409 1
   if (xosfile_read_stamped_no_path (s, &obj_type, NULL, NULL, NULL, NULL,
d414 1
a414 1
   sprintf (s, "If %d%.*s",
d417 3
a419 3
   for (i = strlen (s) - 1; s [i] == ' '; i--)
      s [i] = '\0';
   tracef ("command \"%s\"\n" _ s);
d421 1
a421 1
   if ((error = xos_cli (s)) != NULL)
d500 5
a504 1
   return error;
a509 1
   char cmd [os_CLI_LIMIT + 1];
d515 1
a515 1
   sprintf (cmd, "Resources:$.Resources.BootCmds.Repeat %.*s",
d517 2
a518 2
   tracef ("/%s\n" _ cmd);
   if ((error = xosfscontrol_run (cmd)) != NULL)
d537 3
a539 2
{  struct {char *fs, *user, *password; char argb [os_CLI_LIMIT + 1];} argl;
   int station, net, context, collate, temp_fs;
d541 1
a541 1
   char password [os_CLI_LIMIT + 1], *end;
d547 4
d556 1
a556 1
   if (temp_fs == osfscontrol_FS_NUMBER_NETFS)
d558 1
a558 1
            (char *) &argl, sizeof argl, NULL)) != NULL)
d561 2
a562 2
      tracef ("fs \"%s\"\n" _ argl.fs);
      tracef ("user \"%s\"\n" _ argl.user);
d564 1
a564 1
            argl.password != NULL? argl.password: "NULL");
d567 2
a568 2
      if (argl.fs [0] == ':')
      {  argl.fs++;
d571 1
a571 1
         named_fs = xeconet_read_station_number (argl.fs, NULL, &station,
d574 1
a574 1
            tracef ("fs is named \"%s\"\n" _ argl.fs);
d599 1
a599 1
            {  if ((error = xterritory_collate (territory_CURRENT, argl.fs,
d611 1
a611 1
            {  if ((error = xterritory_collate (territory_CURRENT, argl.user,
d623 1
a623 1
                  sprintf (info AS request.user_name, "%s\r", argl.user);
d642 1
d651 2
a652 3
   {  char cmd [os_CLI_LIMIT + 1];

      sprintf (cmd, "%%Logon %.*s", riscos_strlen (tail), tail);
d654 1
a654 1
      error = xos_cli (cmd);
d657 2
a658 2
   memset (&argl, '\0', sizeof argl);
   memset (password, '\0', sizeof password);
d660 14
a673 1
   return error;
d675 1
d727 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a630 17

static os_error *Free_Pool( char *tail )
{
   int next_size;
   os_error *err = xwimp_slot_size( -1, -1, NULL, &next_size, NULL );
   if ( err == NULL )
   {
      int app_size;
      err = xos_change_environment( 0x0E, 0, 0, 0, (void **)&app_size, NULL, NULL );
      if ( err == NULL ) err = xos_read_dynamic_area( 6, NULL, NULL, NULL );
      if ( err == NULL ) err = xos_change_dynamic_area( 6, app_size-next_size, NULL );
   }
   return err;

   NOT_USED( tail );
}

a681 1
   Commands [main_FREE_POOL]  = *Free_Pool;
@


4.1.7.2
log
@Fixed name clash with trace.h: New name jc_trace.h
@
text
@d49 1
a49 1
#include "jc_trace.h"
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a630 17

static os_error *Free_Pool( char *tail )
{
   int next_size;
   os_error *err = xwimp_slot_size( -1, -1, NULL, &next_size, NULL );
   if ( err == NULL )
   {
      int app_size;
      err = xos_change_environment( 0x0E, 0, 0, 0, (void **)&app_size, NULL, NULL );
      if ( err == NULL ) err = xos_read_dynamic_area( 6, NULL, NULL, NULL );
      if ( err == NULL ) err = xos_change_dynamic_area( 6, app_size-next_size, NULL );
   }
   return err;

   NOT_USED( tail );
}

a681 1
   Commands [main_FREE_POOL]  = *Free_Pool;
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a61 3
/* A useful global buffer */
static char buffer[os_CLI_LIMIT + 1];

d84 1
a84 1
      fh->attr      = fileswitch_ATTR_OWNER_READ | fileswitch_ATTR_OWNER_WRITE;
a103 1
#if 0
a109 4
#else
   char *leaf_name, *name, *boot_name, *help_name, *run_name, *boot_data,
        *help_data, *run_data, *canon, *dir_name, *entry, *application;
#endif
d114 1
a114 1
   fileswitch_info_words info_words;
a116 15
   /* Horrible, I know, but better than getting it off the SVC stack like it used to */
   name = (char *)malloc(11 * 257);
   if (!name)
      goto finish;
   boot_name = name + 257;
   help_name = boot_name + 257;
   run_name = help_name + 257;
   boot_data = run_name + 257;
   help_data = boot_data + 257;
   run_data = help_data + 257;
   canon = run_data + 257;
   dir_name = canon + 257;
   entry = dir_name + 257;
   application = entry + 257;

d133 1
a133 1
            1, context, 257, leaf_name, &found, &context)) != NULL)
d145 1
a145 1
               canon, NULL, NULL, 257, NULL)) != NULL)
a266 1
   free(name);
d342 1
d366 1
a366 1
   char *cc;
d379 3
a381 3
      buffer[i++] = *cc++;
   buffer[i] = '\0';
   tracef ("file name \"%s\"\n" _ buffer);
d386 1
a386 1
   if (xosfile_read_stamped_no_path (buffer, &obj_type, NULL, NULL, NULL, NULL,
d391 1
a391 1
   sprintf (buffer, "If %d%.*s",
d394 3
a396 3
   for (i = strlen (buffer) - 1; buffer [i] == ' '; i--)
      buffer [i] = '\0';
   tracef ("command \"%s\"\n" _ buffer);
d398 1
a398 1
   if ((error = xos_cli (buffer)) != NULL)
d477 1
a477 5
   /*Never return an error from here - it would just mess up the boot
      sequence. J R C 23rd Aug 1995*/
   if (error != NULL) fprintf (stderr, "%s\n", error->errmess);

   return NULL;
d483 1
d489 1
a489 1
   sprintf (buffer, "Resources:$.Resources.BootCmds.Repeat %.*s",
d491 2
a492 2
   tracef ("/%s\n" _ buffer);
   if ((error = xosfscontrol_run (buffer)) != NULL)
d511 2
a512 3
{  struct safelogon_args {char *fs, *user, *password; char argb [os_CLI_LIMIT + 1];} *argl;
   int station, net, context, collate;
   fileswitch_fs_no temp_fs;
d514 1
a514 1
   char *end;
a519 4
   argl = malloc(sizeof(struct safelogon_args));
   if (argl == 0)
       goto finish;

d525 1
a525 1
   if (temp_fs == fileswitch_FS_NUMBER_NETFS)
d527 1
a527 1
            (char *) argl, sizeof *argl, NULL)) != NULL)
d530 2
a531 2
      tracef ("fs \"%s\"\n" _ argl->fs);
      tracef ("user \"%s\"\n" _ argl->user);
d533 1
a533 1
            argl->password != NULL? argl->password: "NULL");
d536 2
a537 2
      if (argl->fs [0] == ':')
      {  argl->fs++;
d540 1
a540 1
         named_fs = xeconet_read_station_number (argl->fs, NULL, &station,
d543 1
a543 1
            tracef ("fs is named \"%s\"\n" _ argl->fs);
d568 1
a568 1
            {  if ((error = xterritory_collate (territory_CURRENT, argl->fs,
d580 1
a580 1
            {  if ((error = xterritory_collate (territory_CURRENT, argl->user,
d592 1
a592 1
                  sprintf (info AS request.user_name, "%s\r", argl->user);
a610 1
   free(argl);
d619 3
a621 2
   {
      sprintf (buffer, "%%Logon %.*s", riscos_strlen (tail), tail);
d623 1
a623 1
      error = xos_cli (buffer);
d625 3
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

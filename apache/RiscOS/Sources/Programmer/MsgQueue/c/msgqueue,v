head	1.7;
access;
symbols
	MsgQueue-0_09-1:1.7
	MsgQueue-0_09:1.7
	MsgQueue-0_08:1.7
	MsgQueue-0_07:1.6
	MsgQueue-0_06:1.6
	MsgQueue-0_05:1.6
	MsgQueue-0_04:1.5
	MsgQueue-0_03:1.4
	MsgQueue-0_02:1.3
	MsgQueue-0_01:1.2
	iniitial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2007.09.25.14.25.29;	author srevill;	state Exp;
branches;
next	1.6;

1.6
date	99.11.30.11.35.28;	author sbrodie;	state Exp;
branches;
next	1.5;

1.5
date	99.02.12.11.39.36;	author srose;	state Exp;
branches;
next	1.4;

1.4
date	99.02.03.17.06.43;	author srose;	state Exp;
branches;
next	1.3;

1.3
date	99.02.03.11.02.54;	author srose;	state Exp;
branches;
next	1.2;

1.2
date	99.02.02.11.01.44;	author srose;	state Exp;
branches;
next	1.1;

1.1
date	99.01.15.09.59.16;	author srose;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.01.15.09.59.16;	author srose;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Fixed a bug in the 'send' code.
Detail:
  Very occasionally, the send code would 'wrap' the buffer where messages
  are stored. This wrap operation meant that the message was added into the
  buffer in two parts, requiring two separate memcpy() calls. The latter
  call was incorrectly asking for the amount of free space at the head of the
  buffer, rather than the number of bytes left of message that didn't fit at
  the tail.

  The net result was that if the source message for the send call happened to
  sit at the end of some block of memory with mapped-out pages following, you
  would get a data abort. In all other cases, it was pretty harmless because
  you would simply be copying a bit of junk into the buffer that the receiver
  would never see (because the message size is still correct).
Admin:
  Tested quite a bit on STB5. Still not 100% certain that this won't leak a
  bit of buffer space when it happens. I'd have to stare at the code for a
  few more hours to understand that.

Version 0.08. Tagged as 'MsgQueue-0_08'
@
text
@/* Copyright 1999 Element 14 Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************************/
/*                                                                                  */
/*  File: msgqueue.c                                                                */
/*                                                                                  */
/*  Copyright © 1999 Element 14, The Acorn Group plc, Cambridge, England            */
/*  Documents:  MessageQueue Software Functional Specification, 1216,612/FS         */
/*              MessageQueue Detailed Software Design, 1216,612/DS                  */
/*  Development Testing: SimpleTest and Basher                                      */
/*                                                                                  */
/************************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>
#include <assert.h>

#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "utils.h"

#undef DEVELOPMENT
#undef CORRUPTION_CHECK
//#define DEVELOPMENT (1)
//#define CORRUPTION_CHECK (1)

#ifdef DEVELOPMENT
  #define memcpy_dbg(dest,src,size) {                               \
  printf("MsgQueue: copy message from &%X..&%X to &%X..&%X\n",      \
   (int)(src), (size)+(int)(src), (int)(dest), (size)+(int)(dest)); \
  memcpy((dest), (src), (size)); }
#else
  #define memcpy_dbg(dest,src,size) memcpy((dest), (src), (size))
#endif

#define TRUE 1
#define FALSE 0
#define SIZEOF_HDR 24
#define RQUEST_DYNAMIC_ALLOC (1 << 0)
#define DYNAMIC_RQUEST_HONORED (flags | (1 << 0))
#define DYNAMIC_RQUEST_NOT_HONORED ((~1) & (flags))
#define TIMESTAMP_FAILED 1
#define TIMESTAMP_OFFSET 5
#define INVALID_TIMESTAMP -1
#define NO_LIMIT 0

typedef struct
{
  unsigned int sizeof_message;
  unsigned int sender_id;
  unsigned int reserved;
  unsigned int flags;
  unsigned int message_id;
  signed int timestamp;
  char *message_data;
} Message;

struct MessageQueue
{
  int dynamic_area_num;
  ApplicationId application_id;
  unsigned int pollword;
  unsigned int queue_size;
  unsigned int q_empty;
  int last_recorded_timestamp;
  unsigned int maxsize_single_msg;
  unsigned int *head;
  unsigned int *tail;
  unsigned int *startof_dispatch;
  unsigned int *startof_freespace;
  unsigned int *buff;
};

typedef struct BlockOfQueues BlockOfQueues;

struct BlockOfQueues
{
  MessageQueue qslots[32];
  struct BlockOfQueues *next;
};

static BlockOfQueues *head = NULL;

/*
 * The register and deregister SWIs share the same mutual exclusion flag, because we
 * don't want one caller registering at the same time as another caller deregistering.
 */
static int mutex = 0;

#ifdef CORRUPTION_CHECK
static int corruption_allowance = 64;
#endif

#include "AsmUtils/irqs.h"
#define enter_critical() ((unsigned int)ensure_irqs_off())
#define restore_critical(s) (restore_irqs((int)(s)))

BlockOfQueues *findq(int *n);
unsigned int freespace_avail (MessageQueue q, unsigned int *headspace, unsigned int *tailspace);
unsigned int count_msgs (MessageQueue q, unsigned int *largest);
void report_err(char *mess,int ln);

/************************************************************************************/
/* Function:  Non re-entrant messagequeue_register()                                */
/* Behaviour: Creates a new message queue for use by the calling app'n wishing to   */
/*            receive messages.                                                     */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags. If bit 0 is set, claim memory dynamically if possible.     */
/*            Bits 1 to 31 are reserved and should be zero.                         */
/*            R1: Application identifier.                                           */
/*            R2: Total buffer space to claim for message queue.                    */
/*            R3: Maximum size for a single message (or 0 if no limit).             */
/* Returns:   error_NOT_ENOUGH_MEMORY, or NULL.  NULL can mean that the function    */
/*            completed successfully, or, the caller is not adhering to the rules   */
/*            of re-entrancy.  (This SWI is non re-entrant).  Call by reference     */
/*            returns exit registers as follows:                                    */
/*            R0: Flags. If bit 0 is set, dynamic memory request was honoured.      */
/*            Bits 1 to 31 are preserved.                                           */
/*            R1: Message queue handle.                                             */
/*            R2: Address of pollword (0 indicates no messages in the queue, otw    */
/*            contains the size of the next message to be dispatched).              */
/************************************************************************************/
extern _kernel_oserror *messagequeue_register(messagequeue_register_args *args)
{
  BlockOfQueues *current = NULL,*prev = NULL,*p = NULL;
  int blocknum = 0,old_state = 0,flags = 0,i = 0,queuesize,max_msg_size;
  _kernel_swi_regs regs;
  unsigned int *p2 = NULL;
  ApplicationId application_id;
  char str_sizecheck[12];
  MessageQueue *q;

    old_state = enter_critical();
    if (mutex)
    {
        restore_critical(old_state);
        return NULL;
    }
    mutex = 1;
    restore_critical(old_state);

    flags = args->in.flags;
    application_id = args->in.application_id;
    queuesize = args->in.total_space;
    max_msg_size = args->in.maximum_size;

    if ((max_msg_size > queuesize) || (max_msg_size == NO_LIMIT))
         max_msg_size = queuesize;

    while (queuesize % 4 != 0)
           queuesize++;

    if (queuesize < SIZEOF_HDR)
    {
        sprintf(str_sizecheck,"%d",queuesize);
        args->out.mq_handle = -1;
        args->out.pollword = NULL;
        mutex = 0;
        return make_error(error_BAD_MESSAGE_SIZE,1,str_sizecheck);
    }

    if ((max_msg_size < SIZEOF_HDR) || (max_msg_size % 4 != 0))
    {
        sprintf(str_sizecheck,"%d",max_msg_size);
        args->out.mq_handle = -1;
        args->out.pollword = NULL;
        mutex = 0;
        return make_error(error_BAD_MESSAGE_SIZE,1,str_sizecheck);
    }

    if (head == NULL)
    {
         if ((p = malloc(sizeof(BlockOfQueues))) == NULL)
         {
              args->out.mq_handle = -1;
              args->out.pollword = NULL;
              mutex = 0;
              return make_error(error_NOT_ENOUGH_MEMORY,0);
         }

         for (i = 0; i < 32; p->qslots[i].buff = NULL, i++);
         p->next = NULL;
         head = current = p;
         i = 0;
    }
    else
    {
         current = head;

         i = 0;
         while ((current->qslots[i].buff != NULL) && (p == NULL))
         {
                 for (i = 0; i < 32; i++)
                 {
                      if (current->qslots[i].buff == NULL)
                      {
                          goto spare_slot_found;
                      }
                 }

                 /*
                 Look in the next block.  If there are no more blocks to look in,
                 we need to create a new block of queue handles.
                 */

                 if (current->next == NULL)
                 {
                      if ((p = malloc(sizeof(BlockOfQueues))) == NULL)
                      {
                           args->out.mq_handle = -1;
                           args->out.pollword = NULL;
                           mutex = 0;
                           return make_error(error_NOT_ENOUGH_MEMORY,0);
                      }

                      for (i = 0; i < 32; p->qslots[i].buff = NULL, i++);
                      p->next = NULL;
                      prev = current;
                      current = p;
                 }
                 else
                 {
                      current = current->next;
                 }
                 i = 0;
                 blocknum++;
          }
    }

    spare_slot_found:  /* Now slot in a new message queue buffer. */

    if (p == NULL)
    {
        p = current;
    }

    if (flags & RQUEST_DYNAMIC_ALLOC)
    {
        regs.r[0] = regs.r[4] = regs.r[6] = regs.r[7] = 0;
        regs.r[1] = regs.r[3] = -1;

        #ifdef CORRUPTION_CHECK
        regs.r[2] = regs.r[5] = queuesize + corruption_allowance;
        #else
        regs.r[2] = regs.r[5] = queuesize;
        #endif

        regs.r[8] = (int)"MsgQ";
        if ((_kernel_swi(OS_DynamicArea,&regs,&regs)) == NULL)
        {
             p2 = (unsigned int *)regs.r[3];
             args->out.flags = DYNAMIC_RQUEST_HONORED;
             p->qslots[i].dynamic_area_num = regs.r[1];

             #ifdef DEVELOPMENT
             printf("Start of dispatch on creation: %u, 0x%x\n",(unsigned int)(p2),(unsigned int)p2);
             memset(p2,0xff,queuesize);
             #endif
        }
        else
        {
             args->out.flags = DYNAMIC_RQUEST_NOT_HONORED;
             p2 = NULL;
        }
    }

    if (p2 == NULL)
    {
        #ifdef CORRUPTION_CHECK
        if ((p2 = malloc(queuesize + corruption_allowance)) == NULL)
        #else
        if ((p2 = malloc(queuesize)) == NULL)
        #endif
        {
             if (prev != NULL)
             {
                 free(current);
             }
             mutex = 0;
             args->out.mq_handle = -1;
             args->out.pollword = NULL;
             return make_error(error_NOT_ENOUGH_MEMORY,0);
        }
        else
        {
             p->qslots[i].dynamic_area_num = -1;
        }
    }

    /* Initialise the new message queue. */

    q = &(p->qslots[i]);
    q->application_id = application_id;
    q->pollword = 0;
    q->queue_size = queuesize;
    q->q_empty = TRUE;
    q->last_recorded_timestamp = 1;
    q->head = (unsigned int *)p2;
    q->tail = (unsigned int *)((int)p2 + (int)(q->queue_size));
    q->maxsize_single_msg = max_msg_size;
    q->startof_dispatch = NULL;
    q->startof_freespace = q->head;
    args->out.mq_handle = (blocknum * 32) + i;
    args->out.pollword = &(q->pollword);

    if (prev != NULL)
    {
        prev->next = p;
    }

    current->qslots[i].buff = p2;

    #ifdef DEVELOPMENT
    printf("Queue handle %d\n",i);
    printf("head: %d, 0x%x\n",(int)q->head,(int)q->head);
    printf("tail: %d, 0x%x\n",(int)q->tail,(int)q->tail);
    #endif

    #ifdef CORRUPTION_CHECK
    memset(p2,0xff,queuesize + corruption_allowance);
    /* Corruption allowance portion should never change.  Check after */
    /* each operation and if it does change, report corruption.       */
    #endif

    mutex = 0;  /* We're finished. Allow the next caller in when it next calls. */

    return NULL;
}

/************************************************************************************/
/* Function:  Non re-entrant messagequeue_deregister()                              */
/* Behaviour: Deletes the specified message queue.  Any messages pending delivery   */
/*            are discarded.                                                        */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags (bits 0 to 31 reserved, should be zero).                    */
/*            R1: Message queue handle.                                             */
/* Returns:   error_UNKNOWN_QUEUE, or NULL.  NULL can mean that the function        */
/*            completed successfully, or, the caller is not adhering to the rules   */
/*            of re-entrancy.  (This SWI is non re-entrant).                        */
/*            Call by reference returns exit registers as follows:                  */
/*            R0: Flags.                                                            */
/*            R1: Number of messages discarded.                                     */
/* Prerequisites: MUST NOT BE CALLED FROM WITHIN AN INTERRUPT.                      */
/************************************************************************************/
extern _kernel_oserror *messagequeue_deregister(messagequeue_deregister_args *args)
{
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;
  BlockOfQueues *current;
  unsigned int *p;
  int n,old_state;

    old_state = enter_critical();
    if (mutex)
    {
       restore_critical(old_state);
       return NULL;
    }
    mutex = 1;
    restore_critical(old_state);

    n = args->in.mq_handle;
    if ((current = (findq(&n))) == NULL)
    {
         mutex = 0;
         return make_error(error_UNKNOWN_QUEUE,0);
    }

    p = current->qslots[n].buff;
    current->qslots[n].buff = NULL;

    /* From here on, we're safe if interrupted by a send or receive, since the queue
       won't be found.  (Don't want send / receive to be working with partially deallocated
       memory or altering the number of messages in the queue while we're counting).
     */

    args->out.discard_count = count_msgs(current->qslots[n],NULL);

    if (current->qslots[n].dynamic_area_num == -1)
    {
        free(p); /* Guaranteed not NULL */
    }
    else
    {
        regs.r[0] = 1;
        regs.r[1] = current->qslots[n].dynamic_area_num;
        if ((er = _kernel_swi(OS_DynamicArea,&regs,&regs)) != NULL)
        {
             report_err(er->errmess,__LINE__);
        }
    }

    mutex = 0;

    return NULL;
}

/************************************************************************************/
/* Function:  Re-entrant messagequeue_send()                                        */
/* Behaviour: Sender wants to deliver a message into the specified queue.           */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags (bits 0 to 31 reserved, should be zero).                    */
/*            R1: Message queue handle.                                             */
/*            R2: Points to the message.                                            */
/* Returns:   NULL for success, otherwise, error_BAD_MESSAGE_SIZE, error_UNKNOWN_   */
/*            QUEUE, error_MESSAGE_TOO_LARGE, or error_QUEUE_FULL.                  */
/************************************************************************************/
extern _kernel_oserror *messagequeue_send(messagequeue_send_args *args)
{
  unsigned int freespace_at_tail = 0,freespace_at_head = 0,total_freespace = 0;
  unsigned int *old_startof_freespace, msgsize;
  BlockOfQueues *current;
  MessageQueue *q;
  int timestamp,old_state,n,mq_handle;
  _kernel_oserror *e = NULL;
  _kernel_swi_regs regs;
  char str_msgsize[12];
  void *message;

  #ifdef CORRUPTION_CHECK
  _kernel_oserror ce;
  int i;
  char *p;
  #endif

    mq_handle = args->in.mq_handle;
    message = args->in.buffer;

    if (message == NULL)
    {
        return make_error(error_BAD_MESSAGE_SIZE,1,"0");
    }
    else
    {
        msgsize = *((unsigned int *)message);
        if (msgsize % 4 != 0)
        {
             sprintf(str_msgsize,"%d",msgsize);
             return make_error(error_BAD_MESSAGE_SIZE,1,str_msgsize);
        }
    }

    n = mq_handle;

    if ((current = (findq(&n))) == NULL)
    {
         return make_error(error_UNKNOWN_QUEUE,0);
    }

    q = &(current->qslots[n]);

    if (msgsize > q->maxsize_single_msg)
    {
        return make_error(error_MESSAGE_TOO_LARGE,0);
    }

    if ((e = _kernel_swi(OS_ReadMonotonicTime,&regs,&regs)) != NULL)
    {
         timestamp = TIMESTAMP_FAILED;
    }
    else
    {
         timestamp = regs.r[0];
    }

    if (timestamp == 0)
    {
        /*
         OS_Monotonic time has just been reset.  Zero is a special case for us, so reset
         timestamp to some other 'pretend' time which is close to but not equal to zero
         (e.g. 1 in pseudo terms).  It's highly unlikely we'll ever end up in this section
         of code.  A possible side effect if we did get here is that to the user, it
         might appear that they'd received a message or two out of order when really
         it's just the timestamp that's slightly out.  Unlikely to ever occur.
        */
         timestamp = 1;
    }

    old_state = enter_critical();

    total_freespace = freespace_avail(current->qslots[n],&freespace_at_head,&freespace_at_tail);

    if (msgsize > total_freespace)
    {
        if (msgsize > q->queue_size)
            return make_error(error_MESSAGE_TOO_LARGE,0);
        else
            return make_error(error_QUEUE_FULL,0);
    }

    /* Reserve space for the new message but save copying until we've exited the critical region. */

    old_startof_freespace = q->startof_freespace;

    /* Cases 1,5 (refer section 5.2, detailed design 1216,612/DS) */
    if (((q->startof_dispatch != NULL) && (q->startof_dispatch < q->startof_freespace) && (q->startof_dispatch != NULL)) ||
        ((q->startof_dispatch == NULL) && (q->startof_freespace != q->head)))
    {
          if (msgsize < (int)q->tail - (int)q->startof_freespace)
          {
              q->startof_freespace += msgsize/4;
          }
          else if (msgsize == (int)q->tail - (int)q->startof_freespace)
          {
              q->startof_freespace = q->head;
          }
          else
          {

              q->startof_freespace = (unsigned int *)((int)q->head + msgsize - (int)q->tail + (int)q->startof_freespace);
          }

          if (q->startof_dispatch == NULL)
          {
              q->startof_dispatch = old_startof_freespace;
          }
    }
    /* Cases 2,4,7 (refer section 5.2, detailed design 1216,612/DS) */
    else if (((q->startof_dispatch != NULL) && (q->startof_dispatch > q->startof_freespace)) ||
             ((q->startof_dispatch == q->head) && (q->startof_freespace > q->startof_dispatch)) ||
             ((q->startof_dispatch != NULL) && (q->startof_dispatch == q->head) && (q->startof_freespace > q->startof_dispatch)))
    {
          q->startof_freespace += msgsize/4;
    }
    /* Case 3 (refer section 5.2, 1216,612/DS) */
    else if ((q->startof_dispatch == NULL) && (q->startof_freespace == q->head))
    {
         q->startof_freespace += msgsize/4;
         q->startof_dispatch = q->head;
    }
    /* Case 6 (refer section 5.2, 1216,612/DS) */
    else if (q->startof_freespace == q->startof_dispatch)
    {
         report_err("Unexpected path of execution. startof_freespace == startof_dispatch.",__LINE__);
    }
    else
    {
         report_err("Unexpected path of execution.",__LINE__);
    }


    if (((int)old_startof_freespace + TIMESTAMP_OFFSET * 4) < (int)q->tail)
    {
        *((int *)((int)old_startof_freespace + TIMESTAMP_OFFSET * 4)) = INVALID_TIMESTAMP;
    }
    else
    {
        *((int *)((int)q->head + TIMESTAMP_OFFSET * 4 - (int)q->tail + (int)old_startof_freespace)) = INVALID_TIMESTAMP;

        #ifdef DEVELOPMENT
        printf("Wrapping ++++\n");
        printf("head: 0x%x\n",(int)q->head);
        printf("tail: 0x%x\n",(int)q->tail);
        printf("old_startof_freespace: 0x%x\n",(int)old_startof_freespace);
        printf("0x%x + %d * 4 - 0x%x + 0x%x = 0x%x\n",(int)q->head,TIMESTAMP_OFFSET, (int)q->tail,(int)old_startof_freespace,
                (int)q->head + TIMESTAMP_OFFSET * 4 - (int)q->tail + (int)old_startof_freespace);
        #endif
    }

    /* If timestamp we saved earlier is less than last recorded timestamp ... */
    if (timestamp < q->last_recorded_timestamp)
    {
         timestamp = q->last_recorded_timestamp;
    }
    else
    {
         q->last_recorded_timestamp = timestamp;
    }

    restore_critical(old_state);

    if (msgsize <= freespace_at_tail)
    {
        #ifdef DEVELOPMENT
        printf("MsgQueue: copy0\n");
        #endif
        memcpy_dbg(old_startof_freespace,message,msgsize);
    }
    else if (msgsize > (unsigned int)((int)q->tail - (int)old_startof_freespace))
    {
        #ifdef DEVELOPMENT
        if (msgsize > (freespace_at_tail + freespace_at_head))
        {
            printf("MsgQueue: ERROR free space too small for copy");
            sprintf(ce.errmess,"Free space insufficient for message size, handle: %d (head=%u tail=%u msgsz=%u)\n",
                               mq_handle,freespace_at_head,freespace_at_tail,msgsize);
            return &ce;
        }
        printf("MsgQueue: copy1\n");
        #endif
        memcpy_dbg(old_startof_freespace,message,freespace_at_tail);
        if (msgsize > freespace_at_tail)
        {
            #ifdef DEVELOPMENT
            printf("MsgQueue: copy2\n");
            #endif
            memcpy_dbg(q->head,(unsigned int *)(message) + freespace_at_tail / 4,msgsize - freespace_at_tail);
//            memcpy_dbg(q->head,(unsigned int *)(message) + freespace_at_tail / 4,freespace_at_head);
        }
    }
    else
    {
        #ifdef DEVELOPMENT
        printf("MsgQueue: copy3\n");
        #endif
        memcpy_dbg(old_startof_freespace,(unsigned int *)(message),msgsize);
    }

    /* We're ok if an interrupt happens here.  SWI_receive won't dispatch until
       it sees a valid timestamp in the message at the startof_dispatch point. */

     if (((int)old_startof_freespace + TIMESTAMP_OFFSET * 4) < (int)q->tail)
     {
         *((int *)(old_startof_freespace + TIMESTAMP_OFFSET)) = timestamp;
     }
     else
     {
         *((int *)((int)q->head + TIMESTAMP_OFFSET * 4 - (int)q->tail + (int)old_startof_freespace)) = timestamp;
     }

     #ifdef DEVELOPMENT
     printf("timestamp: 0x%x, %d\n",timestamp,timestamp);
     #endif

   /* Don't use the pollword, because it can temporarily be zero in the middle of
      a recieve (to prevent the owner of the queue receiving messages out of
      order during one particular interrupt scenario. Use q_empty flag instead. */
    old_state = enter_critical();
    if (q->q_empty == TRUE)
    {
         q->pollword = msgsize;
         q->q_empty = FALSE;
    }
    restore_critical(old_state);

    #ifdef DEVELOPMENT
    printf("start of freespace after send: %d, 0x%x\n",(int)q->startof_freespace,(int)q->startof_freespace);
    #endif

    #ifdef CORRUPTION_CHECK
    p = (char *)q->tail;
    for (i = 0; i < corruption_allowance; i++)
    {
         if (*(p+i) != 0xff)
         {
             printf("Possible corruption detected at end of send(), handle: %d, i: %d\n",mq_handle,i);
             sprintf(ce.errmess,"Possible corruption detected at end of send(), handle: %d, i: %d, value: 0x%x\n",mq_handle,i,(int)(*(p+i)));
             return &ce;
         }
    }
    #endif


    return NULL;
}

/************************************************************************************/
/* Function:  Re-entrant messagequeue_receive()                                     */
/* Behaviour: Dispatch a message from the specified queue.                          */
/* Requires:  Register arguments:                                                   */
/*            R0: Flags.  Copy as much of the message as possible, into the callers */
/*            buffer.  Then, if the bit 0 is set, discard the message from the queue*/
/*            as normal.  If bit 0 is not set, keep the message.  This gives the    */
/*            caller a chance to retry with a larger buffer.                        */
/*            Bits 1 to 31 are reserved (zero).                                     */
/*            R1: Message queue handle.                                             */
/*            R2: Ptr to buffer to receive message.                                 */
/*            R3: Size of buffer.                                                   */
/* Returns:   NULL for success, otherwise, error_UNKNOWN_QUEUE or error_QUEUE_EMPTY.*/
/*            Call by reference returns exit registers as follows:                  */
/*            R0: Flags.                                                            */
/*            R3: Decremented by size of message dispatched.                        */
/************************************************************************************/
extern _kernel_oserror *messagequeue_receive(messagequeue_receive_args *args)
{
  int buffer_too_small = 0,n,flags,sizeof_buffer;
  unsigned int messagespace_at_tail = 0,messagespace_at_head = 0,cbufsize,msgsize;
  unsigned int old_state;
  MessageQueue *q = NULL;
  BlockOfQueues *current = NULL;
  void *buffer;

  #ifdef CORRUPTION_CHECK
  int h,i;
  _kernel_oserror e;
  char *p;
  #endif

    flags = args->in.flags;
    buffer = args->in.buffer;
    sizeof_buffer = args->in.size_of_buffer;

    #ifdef CORRUPTION_CHECK
    h = args->in.mq_handle;
    #endif

    n = args->in.mq_handle;
    if ((current = (findq(&n))) == NULL)
    {
         return make_error(error_UNKNOWN_QUEUE,0);
    }

    q = &(current->qslots[n]);

    /* pollword == 0 implies we're already in the middle of dispatching a message to this caller. */
    /* If we allow the interrupt, the caller will receive messages out of order, so don't allow it.  */
    if ((q->startof_dispatch == NULL) || (q->pollword == 0))
    {
         return make_error(error_QUEUE_EMPTY,0);
    }

    msgsize = *(q->startof_dispatch);

    q->pollword = 0;

    /* Its safe to do all this outside the critical region because we're protected from a 2nd receive,
       and a send interrupt won't interfere with our space because we haven't released it yet. */
    if ((unsigned int)(q->startof_dispatch) + msgsize > (unsigned int)(q->tail))
    {
     /* Message wraps */
        messagespace_at_tail = (unsigned int)((int)q->tail - (int)q->startof_dispatch);
        messagespace_at_head = msgsize - messagespace_at_tail;
    }
    args->out.outsize = sizeof_buffer - (int)msgsize;

    cbufsize = (unsigned int)sizeof_buffer;

    if ((msgsize <= cbufsize) && (messagespace_at_head != 0))
    {
         memcpy(buffer,q->startof_dispatch,messagespace_at_tail);
         if (messagespace_at_head > 0)
         {
             memcpy((char *)buffer + messagespace_at_tail,q->head,messagespace_at_head);
         }
    }
    else if ((msgsize <= cbufsize) && (messagespace_at_head == 0))
    {
         memcpy(buffer,q->startof_dispatch,msgsize);
    }
    else
    {
        buffer_too_small = TRUE;
        if ((messagespace_at_tail == 0) && (messagespace_at_head == 0))
        {
          /* Message doesn't wrap */
             memcpy(buffer,q->startof_dispatch,cbufsize);
        }
        else
        {
          /* Message wraps */
             if (messagespace_at_tail <= cbufsize)
             {
                 memcpy(buffer,q->startof_dispatch,messagespace_at_tail);
                 cbufsize -= messagespace_at_tail;
                 if (messagespace_at_head <= cbufsize)
                 {
                     memcpy((unsigned int *)(buffer) + messagespace_at_tail / 4,q->head,messagespace_at_head);
                 }
                 else
                 {
                     memcpy((unsigned int *)(buffer) + messagespace_at_tail / 4,q->head,cbufsize);
                 }
             }
             else
             {
                  memcpy(buffer,q->startof_dispatch,cbufsize);
             }
       }
    }

    /* Only keep the message if buffer was too small and bit 0 of R1 is set,
       in which case there's nothing to do.  Otherwise, as follows. */
    if (!((buffer_too_small) && (!(flags & 1))))
    {
         old_state = enter_critical();
         if ((unsigned int)(q->startof_dispatch) + msgsize < (unsigned int)(q->tail))
         {
              q->startof_dispatch = (q->startof_dispatch) + msgsize/4;
         }
         else if ((unsigned int)(q->startof_dispatch) + msgsize == (unsigned int)(q->tail))
         {
                q->startof_dispatch = q->head;
         }
         else
         {
                 /* Message wraps */
                 q->startof_dispatch = (unsigned int *)((unsigned int)(q->head) + messagespace_at_head);
         }
         restore_critical(old_state);
    }

    old_state = enter_critical();
    if (q->startof_dispatch == q->startof_freespace)
    {
       /* Queue is completely empty. */
          q->startof_dispatch = NULL;
          q->q_empty = TRUE;
       /* (pollword's already zero) */
    }
    else
    {
          q->q_empty = FALSE;
          q->pollword = *((int *)(q->startof_dispatch)); /* size of next message */
    }
    restore_critical(old_state);

    #ifdef CORRUPTION_CHECK
    p = (char *)q->tail;
    for (i = 0; i < corruption_allowance; i++)
    {
         if (*(p+i) != 0xff)
         {
             printf("Possible corruption detected at end of receive(), handle: %d, i: %d\n",h,i);
             sprintf(e.errmess,"Possible corruption detected at end of receive(), handle: %d, i: %d, value: 0x%x\n",h,i,(int)(*(p+i)));
             return &e;
         }
    }
    #endif

    return NULL;
}

/************************************************************************************/
/* Function:  Re-entrant messagequeue_status()                                      */
/* Behaviour: Describes the status of the specified message queue.                  */
/* Requires:  Register arguments as follows.                                        */
/*            R0: flags.  (Reserved, should be zero).                               */
/*            R1: message queue handle.                                             */
/* Returns:   NULL for success, otherwise, error_UNKNOWN_QUEUE.  Call by reference  */
/*            returns exit registers as follows.                                    */
/*            R0: flags.                                                            */
/*            R1: Next message queue handle (-1 if no more).                        */
/*            R2: Application identifier.                                           */
/*            R3: Total buffer space claimed for message queue.                     */
/*            R4: Maximum size for a single message (or zero if no limit).          */
/*            R5: Number of messages currently in the queue.                        */
/*            R6: Space remaining in queue buffer.                                  */
/*            R7: Size of largest message in queue.                                 */
/************************************************************************************/
extern _kernel_oserror *messagequeue_status(messagequeue_status_args *args)
{
  unsigned int largest_message,freespace_at_tail = 0,freespace_at_head =0;
  int i,j,usr_handle,internal_index,next_usr_handle = -1;
  BlockOfQueues *current;
  MessageQueue q;

    usr_handle = args->in.mq_handle;
    internal_index = usr_handle;

    if ((current = (findq(&internal_index))) == NULL)
    {
         return make_error(error_UNKNOWN_QUEUE,0);
    }
    q = current->qslots[internal_index];

    /* Report the next message queue handle */

    i = internal_index; j = usr_handle;

    while (!((current->next == NULL) && (i == 31)))
    {
       if ((i == 31) && (current->next != NULL))
       {
            current = current->next;
            i = 0;
       }
       else
       {
            i++;
       }

       j++;

       if (current->qslots[i].buff != NULL)
       {
           next_usr_handle = j;
           break;
       }
    }

    args->out.next_mq_handle = next_usr_handle;

    /* Remaining fields */
    args->out.application_id = q.application_id;
    args->out.total_space = q.queue_size;
    args->out.maximum_size = q.maxsize_single_msg;
    args->out.count = count_msgs(q,&largest_message);
    args->out.largest_message = largest_message;
    args->out.space_remaining = freespace_avail(q,&freespace_at_head,&freespace_at_tail);

    return NULL;
}

/************************************************************************************/
/* Function:  findq()                                                               */
/* Behaviour: Sets the current block pointer and the index into the block, such     */
/*            that the current message queue can be found at current->qslots[n].    */
/* Requires:  -'n', which is the message queue handle as seen at user level.        */
/*            -'current', which can be any value on entry.                          */
/* Returns:   Returns 'current' as described, or NULL if queue not found.  Call by  */
/*            reference converts 'n' from a user level handle in the range 0..n,    */
/*            (where n has no limit), to an internal handle in the range 0..31.     */
/************************************************************************************/
BlockOfQueues *findq(int *n)
{
  BlockOfQueues *current = NULL;

    if (*n < 0)
        return NULL;

    current = head;

    while (1)
    {
        if (current == NULL)
            return NULL;

        if (*n < 32)
            break;

        *n -= 32;
        current = current->next;
    }

    if (current->qslots[*n].buff == NULL)
        return NULL;

    return current;
}

/************************************************************************************/
/* Function: count_msgs()                                                           */
/* Returns:  Count of the number of messages in the specified queue.  Call by       */
/*           reference returns the largest message in the queue.                    */
/************************************************************************************/
unsigned int count_msgs (MessageQueue q,unsigned int *largest)
{
  unsigned int msg_size,count = 0,*startof_dispatch = NULL,*startof_freespace = NULL;

    if (largest != NULL)
    {
        *largest = 0;
    }

    startof_dispatch = q.startof_dispatch;
    startof_freespace = q.startof_freespace;

    if (startof_dispatch != NULL)
    {
        while (startof_dispatch != startof_freespace)
        {
               msg_size = *(startof_dispatch);

               #ifdef DEVELOPMENT
               printf("msgsize: %d\n",(int)msg_size);
               #endif

               if (largest != NULL)
               {
                   if (msg_size > *largest)
                   {
                       *largest = msg_size;
                   }
               }

               if (((int)(startof_dispatch) + msg_size) <= (int)(q.tail))
               {
                    startof_dispatch = (unsigned int *)((unsigned int)(startof_dispatch) + msg_size);

                    if (startof_dispatch == q.tail)
                    {
                        startof_dispatch = q.head;
                    }

                    if (startof_freespace == q.tail)
                    {
                        startof_freespace = q.head;
                    }
               }
               else
               {
                    startof_dispatch = (unsigned int *)((int)startof_dispatch + msg_size - ((int)q.tail - (int)q.head));
               }

               count++;

               #ifdef DEVELOPMENT
               printf("count = %d\n",count);
               #endif
        }
    }

    return count;
}

/************************************************************************************/
/* Function: freespace_avail()                                                      */
/* Requires: 'q', which is the current message queue. 'headspace' and 'tailspace'   */
/*           are not set on entry.                                                  */
/* Returns:  Total free space available in the queue. If free space wraps round,    */
/*           call by reference returns amt of free space available at tail and head */
/*           as tailspace and headspace.                                            */
/************************************************************************************/
unsigned int freespace_avail (MessageQueue q,unsigned int *headspace, unsigned int *tailspace)
{
  unsigned int *startof_dispatch,*startof_freespace,*qtail,*qhead,total_freespace = 0;

    startof_dispatch = q.startof_dispatch;
    startof_freespace = q.startof_freespace;
    qtail = q.tail;
    qhead = q.head;

    /* Cases 1 and 8 (refer section 5.4, detailed design 1216,612/DS) */
    if ((startof_dispatch != NULL) && (startof_dispatch < startof_freespace) && (startof_dispatch != qhead))
    {
         *tailspace = (unsigned int)((int)qtail - (int)startof_freespace);
         *headspace = (unsigned int)((int)startof_dispatch - (int)qhead);
         total_freespace = *tailspace + *headspace;
    }
    /* Case 2 (refer section 5.4, detailed design 1216,612/DS) */
    else if ((startof_dispatch != NULL) && (startof_dispatch > startof_freespace))
    {
         *tailspace = *headspace = 0;
         total_freespace = (unsigned int)((int)startof_dispatch - (int)startof_freespace);
    }
    /* Case 3 (refer section 5.4, detailed design 1216,612/DS) */
    else if ((startof_dispatch == NULL) && (startof_freespace == qhead))
    {
         *tailspace = *headspace = 0;
         total_freespace = q.queue_size;
    }
    /* Cases 4 and 7 (refer section 5.4, detailed design 1216,612/DS) */
    else if (((startof_dispatch == qhead) && (startof_freespace > startof_dispatch)) ||
             ((startof_dispatch != NULL) && (startof_dispatch == qhead) && (startof_freespace > startof_dispatch)))
    {
         *tailspace = *headspace = 0;
         total_freespace = (unsigned int)((int)qtail - (int)startof_freespace);
    }
    /* Case 5 (refer section 5.4, detailed design 1216,612/DS) */
    else if ((startof_dispatch == NULL) && (startof_freespace != qhead))
    {
         *tailspace = (unsigned int)((int)qtail - (int)startof_freespace);
         *headspace = (unsigned int)((int)startof_freespace - (int)qhead);
         total_freespace = q.queue_size;
    }
    /* Cases 6, 9, and 10 (refer section 5.4, detailed design 1216,612/DS) */
    else if ((startof_freespace == startof_dispatch) ||
            ((startof_dispatch == qhead) && (startof_freespace == qtail)))
    {
         *tailspace = *headspace = 0;
         total_freespace = 0;
    }

    return total_freespace;
}

/************************************************************************************/
/* Function:  deallocate_message_queues()                                           */
/* Behaviour: Deallocates all message queues, together with base blocks holding     */
/*            the handles for these queues.                                         */
/************************************************************************************/
void deallocate_message_queues(void)
{
  _kernel_swi_regs regs;
  _kernel_oserror *er;
  BlockOfQueues *current;
  MessageQueue q;
  int i = 0;

    if (head == NULL)
    {
        return;
    }

    current = head;

    do
    {
      q = current->qslots[i];

      if (q.buff != NULL)
      {
          if (q.dynamic_area_num != -1)
          {
              regs.r[0] = 1;
              regs.r[1] = q.dynamic_area_num;
              if ((er = _kernel_swi(OS_DynamicArea,&regs,&regs)) != NULL)
              {
                   report_err(er->errmess,__LINE__);
              }
          }
          else
          {
              free(q.buff);
          }
      }

      if (i == 31)
      {
          current = current->next;
          i = 0;
      }
      else
      {
          i++;
      }

    } while (current != NULL);
}

/************************************************************************************/
/* Function:       report_err()                                                     */
/* Behaviour:      Creates and sets a system variable called with appropriate error */
/*                 diagnostics.                                                     */
/* Requires:       - 'mess', which is the error message.                            */
/*                 - 'ln', which is the line number in the file in which the error  */
/*                    occurred.                                                     */
/* Assumptions:    - 'ln' is never greater than 999999.                             */
/************************************************************************************/
void report_err(char *mess,int ln)
{
 char *str = NULL;
 _kernel_swi_regs regs;

   if ((str = calloc(strlen("Set mqerr ")+
              strlen("999999")+strlen(mess)+1,sizeof(char))) != NULL)
   {
        sprintf(str,"Set err Line:%d,Error message:%s",ln,mess);
        regs.r[0] = (int)str;
        _kernel_swi(OS_CLI,&regs,&regs);
        free(str);
   }

   #ifdef DEVELOPMENT
   printf("Error at line %d of msgqueue.c\n%s\n",__LINE__,mess);
   fflush(stdout);
   #endif
}


/************************************************************************************/
/* Function:  message_queue_info()                                                  */
/* Behaviour: Outputs status information about each active message queue.           */
/************************************************************************************/
void message_queue_info(void)
{
  BlockOfQueues *current;
  unsigned int largest_msg,dummy1 = 0,dummy2 = 0;
  MessageQueue q;
  int old_state,i = 0;

    if (head == NULL)
    {
        puts("No queues allocated");
        return;
    }

    current = head;

    puts("Q:        Message queue handle");
    puts("AppId:    Application Identifier");
    puts("Buffsize: Size of fixed length message queue (bytes)");
    puts("Maxsize:  Maximum size allowed for a single message (0 -> no limit)");
    puts("          (word units)                                             ");
    puts("Messages: Number of messages currently in the queue");
    puts("Free:     Free space available (word units)");
    puts("Largest:  Size of largest message in queue (word units)");
    puts("-------------------------------------------------------------------- ");
    puts("Q    AppId     Buffsize  Maxsize   Messages  Free      Largest ");
    puts("---------------------------------------------------------------------");

    old_state = enter_critical();

    do
    {
      if (current->qslots[i].buff != NULL)
      {
          q = current->qslots[i];

          printf("%-5d",i % 32);
          printf("%-10u",q.application_id);
          printf("%-10u",q.queue_size);
          printf("%-10u",q.maxsize_single_msg);
          printf("%-10u",count_msgs(q,&largest_msg));
          printf("%-10u",freespace_avail(q,&dummy1,&dummy2));
          printf("%-10u\n",largest_msg);
      }

      if (i == 31)
      {
          i = 0;
          current = current->next;
      }
      else
      {
          i++;
      }

    } while (current != NULL);

    putchar('\n');

    restore_critical(old_state);
}


@


1.6
log
@  Assembler code removed.
Detail:
  Imports IRQ management from AsmUtils.
  c/msgqueue modified to call ensure_irqs_off/restore_irqs instead of
    enter_critical/leave_critical.  Replacement done via macros.
Admin:
  Build RAM build.

Version 0.05. Tagged as 'MsgQueue-0_05'
@
text
@d41 11
d591 4
a594 1
        memcpy(old_startof_freespace,message,msgsize);
d598 19
a616 2
        memcpy(old_startof_freespace,message,freespace_at_tail);
        memcpy(q->head,(unsigned int *)(message) + freespace_at_tail / 4,freespace_at_head);
d620 4
a623 1
        memcpy(old_startof_freespace,(unsigned int *)(message),msgsize);
@


1.5
log
@Fixes a bug where a max message size of zero on queue registration
is a special case which means there is actually to be no limit on
the maximum size for a single message.  I'd forgotten zero is a special
case, so was rejecting the queue registration request on the grounds that
zero is an invalid max message size value.  Now fixed.

Version 0.04. Tagged as 'MsgQueue-0_04'
@
text
@d100 3
a102 2
extern unsigned int enter_critical(void);
extern void restore_critical(int old_state);
@


1.4
log
@Very minor changes in tidying up a few sections.

Version 0.03. Tagged as 'MsgQueue-0_03'
@
text
@d152 2
a153 2
    if (max_msg_size > queuesize)
        max_msg_size = queuesize;
@


1.3
log
@Fixes a bug where strange desktop errors were happening after between 5
and 10,000 (test prog) basher iterations.  In cases where a message wrapped
round the tail, and, 20 bytes of the message were at the tail, insertion of
the timestamp caused 4 bytes of data corruption.  This was down to writing
less than or equals, rather than just a less than.

Added code to check for data corruption beyond the tail.  With this enabled,
and the bug above fixed, I've seen no more overwrites.

Version 0.02. Tagged as 'MsgQueue-0_02'
@
text
@a32 1

d104 1
a104 3
_kernel_oserror * freespace_avail (MessageQueue q, unsigned int *total_freespace,
                                        unsigned int *headspace, unsigned int *tailspace,
                                        unsigned int msgsize);
d130 3
a132 3
  BlockOfQueues *current = NULL;
  int i = 0;
  BlockOfQueues *p = NULL;
d134 1
a134 6
  BlockOfQueues *prev = NULL;
  int blocknum = 0;
  int old_state = 0;
  int flags = 0;
  _kernel_swi_regs regs;
  int queuesize;
d136 1
a136 2
  ApplicationId application_id;
  int max_msg_size;
d167 1
a167 10
    if (max_msg_size < SIZEOF_HDR)
    {
        sprintf(str_sizecheck,"%d",max_msg_size);
        args->out.mq_handle = -1;
        args->out.pollword = NULL;
        mutex = 0;
        return make_error(error_BAD_MESSAGE_SIZE,1,str_sizecheck);
    }

    if (max_msg_size % 4 != 0)
d297 11
a307 10
    p->qslots[i].application_id = application_id;
    p->qslots[i].pollword = 0;
    p->qslots[i].queue_size = queuesize;
    p->qslots[i].q_empty = TRUE;
    p->qslots[i].last_recorded_timestamp = 1;
    p->qslots[i].head = (unsigned int *)p2;
    p->qslots[i].tail = (unsigned int *)((int)p2 + (int)(p->qslots[i].queue_size));
    p->qslots[i].maxsize_single_msg = max_msg_size;
    p->qslots[i].startof_dispatch = NULL;
    p->qslots[i].startof_freespace = p->qslots[i].head;
d309 1
a309 1
    args->out.pollword = &(p->qslots[i].pollword);
d320 2
a321 2
    printf("head: %d, 0x%x\n",(int)p->qslots[i].head,(int)p->qslots[i].head);
    printf("tail: %d, 0x%x\n",(int)p->qslots[i].tail,(int)p->qslots[i].tail);
d326 2
a327 2
    /* Corruption allowance portion should never change.  Check after       */
    /* each operation and if it does change, report corruption detection.   */
d356 1
a356 2
  int old_state;
  int n;
d415 3
d419 1
a419 9
  unsigned int * old_startof_freespace;
  int timestamp;
  unsigned int freespace_at_tail = 0;
  unsigned int freespace_at_head = 0;
  unsigned int total_freespace = 0;
  int old_state;
  BlockOfQueues *current;
  int n;
  unsigned int msgsize;
a422 1
  int mq_handle;
d424 1
d428 1
a428 1
  char *p
d434 5
a438 1
    if (message != NULL)
d440 2
a441 2
        msgsize = *((unsigned int *)(message));
        if ((msgsize % 4) != 0)
a446 4
    else
    {
        return make_error(error_BAD_MESSAGE_SIZE,1,"0");
    }
d486 1
a486 5
    if ((e = freespace_avail(current->qslots[n],&total_freespace,&freespace_at_head,&freespace_at_tail,msgsize))
         != NULL)
    {
         return e;
    }
d658 3
a660 6
  int buffer_too_small = 0;
  unsigned int messagespace_at_tail = 0;
  unsigned int messagespace_at_head = 0;
  unsigned int cbufsize;
  int n;
  unsigned int msgsize;
a661 1
  unsigned int old_state;
a662 1
  int flags;
d664 1
a664 1
  int sizeof_buffer;
d824 2
a825 1
  int usr_handle, internal_index;
a827 8
  int next_usr_handle = -1;
  int i,j;
  unsigned int largest_message;
  unsigned int freespace_at_tail = 0;
  unsigned int freespace_at_head =0;
  unsigned int space_remaining;

    /* Find the current message queue */
d871 1
a871 5

    /* Space remaining */
    freespace_avail(q,&space_remaining,&freespace_at_head,&freespace_at_tail,0);

    args->out.space_remaining = space_remaining;
d920 1
a920 5
  unsigned int msg_size;
  unsigned int count = 0;
  unsigned int *startof_dispatch = NULL;
  unsigned int *startof_freespace = NULL;

d980 5
a984 10
/* Requires: 'q', which is the current message queue. 'total_freespace', 'headspace'*/
/*           and 'tailspace' do not need to be set on entry, and 'msgsize', which is*/
/*           the size of the message the caller wishes to insert into the queue. If */
/*           the caller only wishes to know the total amount of free space available*/
/*           set msgsize to 0 on entry.                                             */
/* Returns:  error_MESSAGE_TOO_LARGE if 'msgsize' is greater than the total amt of  */
/*           available free space, otherwise NULL to indicate no errors.  Call by   */
/*           reference returns the total free space available in the queue, and, if */
/*           free space wraps around, returns amt of free space available at tail   */
/*           and head ends as tailspace and headspace respectively.                 */
d986 1
a986 2
_kernel_oserror * freespace_avail (MessageQueue q,unsigned int *total_freespace,
  unsigned int *headspace, unsigned int *tailspace, unsigned int msgsize)
d988 1
a988 4
  unsigned int *startof_dispatch;
  unsigned int *startof_freespace;
  unsigned int *qtail;
  unsigned int *qhead;
d1000 1
a1000 1
         *total_freespace = *tailspace + *headspace;
d1006 1
a1006 1
         *total_freespace = (unsigned int)((int)startof_dispatch - (int)startof_freespace);
d1012 1
a1012 1
         *total_freespace = q.queue_size;
d1019 1
a1019 1
         *total_freespace = (unsigned int)((int)qtail - (int)startof_freespace);
d1026 1
a1026 1
         *total_freespace = q.queue_size;
d1033 1
a1033 1
         *total_freespace = 0;
d1036 1
a1036 6
    if (msgsize > (*total_freespace))
    {
        return make_error(error_MESSAGE_TOO_LARGE,0);
    }

    return NULL;
d1130 1
a1130 1
  unsigned int largest_msg;
d1132 1
a1132 5
  int old_state;
  int i = 0;
  unsigned int freespace = 0;
  unsigned int dummy1 = 0;
  unsigned int dummy2 = 0;
d1167 1
a1167 2
          freespace_avail(q,&freespace,&dummy1,&dummy2,0);
          printf("%-10u",freespace);
@


1.2
log
@MsgQ is now in an acceptable state for integration testing to begin.

Version 0.01. Tagged as 'MsgQueue-0_01'
@
text
@d41 1
d97 4
d264 4
d269 2
d292 3
d296 1
d341 6
d448 5
d574 1
a574 1
    if (((int)old_startof_freespace + TIMESTAMP_OFFSET * 4) <= (int)q->tail)
d621 1
a621 1
     if (((int)old_startof_freespace + TIMESTAMP_OFFSET * 4) <= (int)q->tail)
d649 14
d697 5
d707 4
d820 13
@


1.1
log
@Initial revision
@
text
@d21 2
a22 1
/*              XXX: Additional design note supplements(?)                          */
d31 2
d40 24
d66 2
d70 8
a77 4
  void *head;
  void *tail;
  int *startof_despatch;
  int *startof_freespace;
d80 3
a82 1
typedef struct
d84 5
a88 3
  MessageQueue *handle;
  MessageNode *next;
} MessageNode;
a92 1
 * This would break the integrity of the list structure.
d96 9
d112 1
a112 1
/*                Bits 1 to 31 are reserved and should be zero.                     */
d116 4
a119 2
/* Returns:   NULL for success, otherwise ....                                      */
/*            Call by reference returns exit registers as follows:                  */
d121 1
a121 1
/*                Bits 1 to 31 are preserved.                                       */
d124 1
a124 1
/*                contains the size of the next message to be despatched).          */
d126 1
a126 1
_kernel_oserror *messagequeue_register(messagequeue_register_args *args,void *pw)
d128 13
a140 1
  MessageNode *current = NULL;
d142 1
a142 1
    Disable interrupts.
d145 2
a146 3
        Re-enable interrupts.
        There is already a caller executing this SWI.  It is not re-entrant, so
        return an error.  (There might be a standard error for this kind of thing).
d149 12
a160 1
    Re-enable interrupts.
d162 17
a178 1
    NB: Plan to do away with all this.  Far more efficient way of doing it.
d180 8
a187 1
    /* Allocate a new base node. */
d191 12
a202 4
        create node;
        head = current = tail = node;
        node.handle = NULL;
        node.next = NULL;
d206 56
a261 2
        current = tail;
        if (current->next != NULL)
d263 8
a270 1
            Development warning error.  Something's not right.
d274 2
a275 5
            current->next = allocate a new node;
            current = current->next;
            current->handle = NULL;
            current->next = NULL;
            tail = current;
d279 1
a279 3
    /* Create a message queue to hang off the base node. */

    if (requested dynamic allocation)
d281 15
a295 17
        current->handle = allocate dynamic area for message queue;
        If successful, current->handle points at the base of the new message queue
        and bit 0 of R0 is set to indicate that the request was honoured, otherwise,
        bit 0 of R0 must be cleared.
    }

    if (current->handle still NULL)
    {
        current->handle = allocate memory for message queue using the RMA;
        If successful, current->handle points at the base of the new message queue;
    }

    if (current->handle still NULL)
    {
        Leave things in a tidy state - deallocate node and reset pointers.
        mutex = 0;
        return error insufficient memory to set up message queue;
d300 25
a324 7
    handle->pollword = 0;
    handle->queue_size = size of queue (in bytes);
    handle->head = current->handle;
    handle->tail = current->handle + number of bytes specified in R2 (size of buffer).

    handle->startof_despatch = NULL;
    handle->startof_freespace = handle->head;
d326 1
a326 4
    Set R1 to contain the message handle;
    R2 = address of pollword;

    mutex = 0;  /* We're finished.  Allow the next caller in when it next calls. */
d328 1
d338 3
a340 1
/* Returns:   NULL for success, otherwise ....                                      */
d344 1
d346 1
a346 1
_kernel_oserror *messagequeue_deregister(messagequeue_deregister_args *args,void *pw)
d348 6
a353 2
  MessageNode *prev = NULL;
  MessageNode *current;
d355 1
a355 1
    Disable interrupts.
d358 2
a359 3
        Re-enable interrupts.
        There is already a caller executing this SWI.  It is not re-entrant, so
        return an error.
d362 1
a362 1
    Re-enable interrupts.
d364 2
a365 2
    current = head;
    if (current == NULL)
d367 2
a368 3
        mutex = 0;
        return error.  Specified message queue not found (and besides, no queues
        exist at the moment.  (Useful to know this during development and testing).
d371 9
a379 10
    do
    {  if (current->handle == message queue handle passed in thru R1)
       {
           We've found the right queue.  Break out of loop;
       }
       else
       {
           Keep on searching.  prev = current; current = current->next;
       }
    }while (current->next != NULL)
d381 1
a381 1
    if (current->handle == message queue handle passed in thru R1)
d383 1
a383 13
        /* Remove queue and associated node */
        if (prev != NULL)
        {
            prev->next = current->next;
        }
        else
        {
            head = current->next;
        }
        R1 = number of messages discarded.  (XXX: number of messages discarded = ...)
        free(current->handle);  /* Frees the message queue */
        free(current);          /* Frees the anchor node */
        current = head;         /* Current node's just been deleted.  Reset current. */
d387 6
a392 2
        mutex = 0;
        return error.  Specified message queue not found.
d396 2
d407 2
a408 1
/* Returns:   NULL for success, otherwise ...                                       */
d410 1
a410 1
_kernel_oserror *messagequeue_send(messagequeue_send_args *args)
d412 2
a413 8
  workspace *w;
  MessageNode *current;
  MessageQueue *qhandle;
  int old_startof_freespace;
  int total_freespace;
  int timestamp;
  int freespace_at_tail;
  int freespace_at_head;
d415 36
d452 1
a452 3
    qhandle = args->mq;
    if ((current = find_queue(qhandle)) == NULL)
         return error (queue not found);
d454 4
a457 1
    freespace_at_tail = freespace_at_head = 0;
d459 8
a466 3
    Start of critical section.  Do reading and updating of startof_freespace and
    startof_despatch ptrs as close together as possible, to reduce the size of the
    critical section.
d468 1
a468 2
    timestamp = get OS_Monotonic time;
    if (timestamp is zero)
d470 9
a478 6
        OS_Monotonic time has just been reset.  Zero is a special case for us, so reset
        timestamp to some other 'pretend' time which is close to but not equal to zero
        (e.g. 1 in pseudo terms).  It's highly unlikely we'll ever end up in this section
        of code.  A possible side effect if we did get here is that to the user, it
        might appear that they'd received a message or two out of order when really it's
        just the timestamp that's slightly out.
d481 7
a487 1
    Write an invalid timestamp into the message space (e.g. zero).
d489 1
a489 1
    if (size of message > freespace_avail(starts,&freespace_at_tail,&freespace_at_head))
d491 2
a492 2
        if (size of message > qhandle->queuesize)
            return Error_MessageQueue_MessageTooLarge;
d494 1
a494 1
            return Error_MessageQueue_QueueFull;
d499 44
a542 1
    if (startof_despatch == NULL) && (startof_freespace == head)
d544 1
a544 2
        old_startof_freespace = qhandle->head;
        startof_freespace += size of message;
d546 3
a548 2
    else if (((startof_despatch == NULL) && (startof_freespace != head)) ||
              (startof_freespace > startof_despatch))
d550 20
a569 5
         old_startof_freespace = qhandle->startof_freespace;
         if (size of message <= freespace_at_tail)
             startof_freespace += size of message;
         else
             startof_freespace = qhandle->head + (size of message - qhandle->tail - startof_freespace);
d573 1
a573 3
         The messages wrap round from tail to head with free space somewhere in the middle.
         old_startof_freespace = startof_freespace;
         startof_freespace += size of message;
d576 1
a576 1
    initialise timestamp portion of our reserved space to some invalid value.
d578 13
a590 1
    End of critical section.
d592 2
a593 3
    Copy message into old_startof_freespace;
    (Remember to allow for wraparound.  We already know freespace_at_tail and
     freespace_at_head).
d595 8
a602 2
    /* We're ok if an interrupt occurs here.  SWI_receive won't despatch until
       it sees a valid timestamp in the message at the startof_despatch point. */
d604 3
a606 1
    Insert timestamp;
d608 5
a612 1
    if (pollword == 0)
d614 2
a615 1
        Set it to the size of this message.
d617 5
d623 1
d628 1
a628 1
/* Behaviour: Despatch a message from the specified queue.                          */
d630 5
a634 4
/*            R0: Flags.  Bit 0 is used to determine whether we should discard the  */
/*            message from the queue if it's too big for the receiver, or whether   */
/*            we should divide it up into smaller messages to be delivered on       */
/*            subsequent calls to this routine. Bits 1 to 31 are reserved (zero).   */
d638 1
a638 1
/* Returns:   NULL for success, otherwise ...                                       */
d641 1
a641 1
/*            R3: Decremented by size of message despatched.                        */
d643 1
a643 1
_kernel_oserror *messagequeue_receive(messagequeue_receive_args *args)
d645 12
a656 1
  (re-entrant)
d658 115
a772 5
  Right at the end of this SWI, the following:-
  If there are any complete messages in the queue, set the pollword, otherwise, zero
  it.  i.e. the pollword is always zero unless there is a complete message in the
  queue.  A complete message is one that has a valid timestamp added and is ready
  for despatch.
d776 15
a790 2
/* Function:  messagequeue_status()                                                 */
/* Behaviour: */
d792 1
a792 1
_kernel_oserror *messagequeue_status(messagequeue_status_args *args)
d794 61
a854 1
  (re-entrant)
d858 8
a865 4
/* Function:  find_queue()                                                          */
/* Behaviour: Looks for the specified queue.                                        */
/* Requires:  Message handle.                                                       */
/* Returns:   Ptr to the node for the specified queue, or NULL if not found.        */
d867 1
a867 1
MessageNode *find_node(MessageQueue *mq)
d869 4
a872 2
  MessageNode *current, *prev;
  workspace *w;
d875 2
a876 1
    if (current == NULL)
d878 11
a888 1
        Queue not found (none exist).
a889 1
    }
d891 15
a905 13
    do
    {  if (current->handle == mq)
       {
           Found the right queue;
           break out of loop;
       }
       else
       {
           Keep searching.
           prev = current;
           current = current->next;
       }
    } while (current->next != NULL);
d907 1
a907 1
    if (current->handle == mq)
d909 1
a909 1
        return current;
d911 5
a915 1
    else
d917 41
a957 1
        return NULL;
d959 2
d964 57
a1020 20
/* Function:  freespace_avail()                                                     */
/* Behaviour: Determines the amt of free space available in the queue.              */
/* Returns:   Byte count of free space available.  If free space wraps around, call */
/*            by reference returns amt of free space available at tail and head     */
/*            ends as freespace_at_tail and freespace_at_head respectively.         */
/************************************************************************************/
int freespace_avail(int *startof_despatch, int *startof_freespace, int *freespace_at_tail,
  int *freespace_at_head)
{
    if (startof_despatch == NULL)
    {
        There are no messages in the queue.
        total_freespace = qhandle->queuesize;
    }
    else if (startof_freespace > startof_despatch)
    {
         Free space wraps round from tail to head.
         *freespace_at_tail = qhandle->tail - startof_freespace;
         *freespace_at_head = startof_despatch - head;
         total_freespace = *freespace_at_tail + *freespace_at_head;
d1022 3
a1024 1
    else
d1026 2
a1027 2
         The messages wrap round from tail to head, with free space somewhere in the middle.
         total_freespace = qhandle->startof_despatch - qhandle->startof_freespace;
d1030 1
a1030 1
    if (size of message > total_freespace)
d1032 1
a1032 1
        return Error_MessageQueue_MessageTooLarge;
d1035 17
a1051 1
    if (startof_despatch == NULL) && (startof_freespace != head)
d1053 1
a1053 2
        *freespace_at_tail = qhandle->tail - startof_freespace;
        *freespace_at_head = startof_freespace - qhandle->head;
d1056 1
a1056 1
    return total_freespace;
d1058 61
d1121 72
a1192 7
/*
 * Optimization reminders:
 * Anchor list - use handle passed in, instead of searching the list.  Need to think
 *               about invalid handles being passed in tho.  Alternatively,
 *             - use array blocks (cuts down on allocs and saves searching thru the list.
 *             - or use a hash table, which the above is, more or less.
 */
@


1.1.1.1
log
@Initial import.  Snapshot following review with Richard Warren (review
changes / notes included).  Review focussed mainly on checking and 
confirming validity of (pseudo) code in messagequeue_send() under various
interrupt conditions, and the best way of optimizing the registering and
deregistering of queues. 
@
text
@@

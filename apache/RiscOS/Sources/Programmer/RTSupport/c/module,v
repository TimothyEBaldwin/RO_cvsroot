head	1.13;
access;
symbols
	RTSupport-0_17-1:1.13
	RTSupport-0_17:1.13
	RTSupport-0_16:1.12
	RTSupport-0_15:1.11
	RTSupport-0_14:1.10
	RTSupport-0_13:1.9
	RTSupport-0_12:1.8
	RTSupport-0_11:1.6
	RTSupport-0_10:1.6
	RTSupport-0_09:1.6
	RTSupport-0_08:1.6
	RTSupport-0_07:1.5
	RTSupport-0_06:1.5
	RTSupport-0_05:1.4
	RTSupport-0_04:1.3
	RTSupport-0_03:1.2
	RTSupport-0_02:1.2
	RTSupport-0_01:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.13
date	2016.06.15.19.29.27;	author jlee;	state Exp;
branches;
next	1.12;
commitid	itT7BGNkit9E5Baz;

1.12
date	2016.05.02.19.21.28;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	le5smv9L8JqBsW4z;

1.11
date	2016.04.05.20.04.19;	author jlee;	state Exp;
branches;
next	1.10;
commitid	1p7UAqGTBsP4zt1z;

1.10
date	2015.10.23.19.30.22;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	UChxUqEgGQmgGgGy;

1.9
date	2015.10.07.20.37.28;	author jlee;	state Exp;
branches;
next	1.8;
commitid	N94qAJ70PFKazdEy;

1.8
date	2015.08.04.06.47.40;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	W148w3wPULGT1Vvy;

1.6
date	2012.03.22.22.45.14;	author jlee;	state Exp;
branches;
next	1.5;
commitid	LSkTzCtrWScORVXv;

1.5
date	2011.08.04.22.35.30;	author jlee;	state Exp;
branches;
next	1.4;
commitid	OqQ1DRKmkhSQefuv;

1.4
date	2009.10.22.01.04.56;	author jlee;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.27.19.29.24;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.27.15.52.04;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.12.19.55.22;	author bavison;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.01.12.19.55.22;	author bavison;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Clear the exclusive monitor when returning to pre-empted code
Detail:
  s/scheduler - Add a second variant of the PreEmptionRecovery routine, which issues a CLREX on entry. Use a workspace variable to select which routine is required (for supporting multiple CPU architectures at runtime)
  h/scheduler - Declare new symbols exported by s/scheduler
  c/module - Initialise PreEmptionRecoveryPtr with the correct value, depending on whether the CPU supports LDREX/STREX or not
Admin:
  Tested on Raspberry Pi


Version 0.17. Tagged as 'RTSupport-0_17'
@
text
@/* Copyright 2005 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*****************************************************************************
* $Id: module,v 1.12 2016/05/02 19:21:28 rsprowson Exp $
* $Name: HEAD $
*
* Author(s):  Ben Avison
* Project(s): Rhenium
*
* ----------------------------------------------------------------------------
* Copyright © 2004 Castle Technology Ltd. All rights reserved.
*
* ----------------------------------------------------------------------------
* Purpose: Module entry points and C housekeeping
*
* ----------------------------------------------------------------------------
* History: See source control system log
*
*****************************************************************************/


/*****************************************************************************
* Include header files
*****************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdio.h>
#include "kernel.h"
#include "swis.h"

#include "Global/NewErrors.h"
#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/OSRSI6.h"
#include "Global/OSMisc.h"
#include "Interface/RTSupport.h"
#include "DebugLib/DebugLib.h"

#include "debug.h"
#include "global.h"
#include "mess.h"
#include "RTSupportHdr.h"
#include "resmess.h"
#include "scheduler.h"


/*****************************************************************************
* Macros
*****************************************************************************/
#define Legacy_IRQsema ((void **)0x108)


/*****************************************************************************
* New type definitions
*****************************************************************************/

typedef struct _svcstack {
  char *ptr;
  struct _svcstack *next;
} svcstack;

/*****************************************************************************
* Constants
*****************************************************************************/
#define PAGE_SIZE 4 /* assume fixed */
#define STACK_SIZE 8
#define ROUTINES 127 /* at least 1024/STACK_SIZE - 1 */
/* There is a minimum setting due to the fact that the dynamic area must be just over 1MB to ensure we have a MB-aligned address */
#define DA_SIZE MAX(1024+STACK_SIZE+PAGE_SIZE, STACK_SIZE+STACK_SIZE+PAGE_SIZE+ROUTINES*STACK_SIZE)

#define EMERGENCY_STACKS 8 /* Keep a minimum of this many stacks allocated but unused, to ensure routines can still be registered even if we can't resize the dynamic area */


/*****************************************************************************
* File scope global variables
*****************************************************************************/
static bool static_OldKernel = false;
static void *static_MessagesBuffer;
static void *static_PriorityMessagesBuffer;
static bool static_UseSparseArea; /* True for sparse DA where SVC stacks are mapped in as-needed, false for regular DA where everything is mapped in all the time */
static uint32_t static_DANumber;
static char *static_DA;
static char *static_DAAllocPtr;
static char *static_RoutineSVCStack;
static char *static_LastStackBeforeMB;
static char *static_LastStackBeforeEnd;
static svcstack static_Stacks[ROUTINES];
static svcstack *static_FreeStacks=0; /* Stacks which aren't allocated */
static svcstack *static_EmergencyStacks=0; /* Spare stacks for when we can't change the dynamic area */
static svcstack *static_ActiveStacks=0; /* Note: don't use this list for enumerating the stack addresses of active threads. This list is only used to collect together 'free' svcstack objects, ready for re-insertion into the FreeStacks or EmergencyStacks lists upon RT_Deregister */
static int static_NumEmergency = 0; /* Number of entries in emergency list */

/*****************************************************************************
* Function prototypes - Private to this file
*****************************************************************************/
static _kernel_oserror *Register(uint32_t flags, const void *entry, uint32_t r0, uint32_t r12,
    volatile const uint32_t *pollword, uint32_t r10, uint32_t r13sys, uint32_t priority, thread_t ** restrict r_handle);
static _kernel_oserror *Deregister(uint32_t flags, thread_t *handle);
static _kernel_oserror *ChangePriority(uint32_t flags, thread_t * restrict handle, uint32_t priority, uint32_t * restrict r_priority);
static _kernel_oserror *ReadInfo(uint32_t reason, uint32_t *r_value);
static _kernel_oserror *RebalanceEmergencyList(void);


/*****************************************************************************
* Functions
*****************************************************************************/

/*****************************************************************************
* module_Initialise
*
* Initialisation code
*
* Assumptions
*  NONE
*
* Inputs
*  cmd_tail:    points to the string of arguments with which the module is invoked
*               (may be "", and is control-terminated, not zero terminated)
*  podule_base: 0              => first invocation, not from a podule
*               1 - 0x02FFFFFF => reincarnation number
*               >0x03000000    => first invocation, from a podule based at this address
*  pw:          the 'R12' value established by module initialisation
*
* Outputs
*  NONE
*
* Returns
*  NULL if initialisation succeeds; otherwise pointer to error block
*****************************************************************************/
_kernel_oserror *module_Initialise(const char *cmd_tail, int podule_base, void *pw)
{
  IGNORE(cmd_tail);
  _kernel_oserror *e = NULL;
#ifndef ROM_MODULE
  bool MessagesFileRegistered = false;
#endif
  bool MessagesOpen = false;
  bool PriorityMessagesOpen = false;
  bool DACreated = false;
  bool OnUnthreadV = false;
  bool OnTickerV = false;

  debug_initialise("RTSupport", "null:", "");
  debug_atexit();
  debug_set_taskname_prefix(false);
  debug_set_area_level_prefix(false);
  debug_set_area_pad_limit(0);
  debug_set_device(DADEBUG_OUTPUT);
  debug_set_raw_device(NULL_OUTPUT);
  debug_set_trace_device(NULL_OUTPUT);

#ifdef DEBUGLIB
  /* Set up the DADWriteC ptr used by the assembler code */
#define DADebug_GetWriteCAddress 0x531C0
  _swix(DADebug_GetWriteCAddress,_OUT(0),&asm_DADWriteC);
#endif

  /* Decide which pre-emption recovery routine to use */
  uint32_t cpuflags;
  if (_swix(OS_PlatformFeatures, _IN(0)|_OUT(0), OSPlatformFeatures_ReadCodeFeatures, &cpuflags) || !(cpuflags & CPUFlag_LoadStoreEx))
  {
    PreEmptionRecoveryPtr = PreEmptionRecovery;
  }
  else
  {
    PreEmptionRecoveryPtr = PreEmptionRecoveryCLREX;
  }

  if (getenv("RTSupport$Path") == NULL)
  {
    #define MY_PATH "Resources:$.Resources.RTSupport."
    _swix(OS_SetVarVal, _INR(0,4), "RTSupport$Path", MY_PATH, sizeof MY_PATH - 1, 0, 4);
  }
  {
#ifndef ROM_MODULE
    e = _swix(ResourceFS_RegisterFiles, _IN(0), resmess_ResourcesFiles());
  }
  if (!e)
  {
    MessagesFileRegistered = true;
#endif

    size_t MessagesSize;
    e = _swix(MessageTrans_FileInfo, _IN(1)|_OUT(2), Module_MessagesFile, &MessagesSize);
    if (!e)
    {
      static_MessagesBuffer = malloc(MessagesSize);
      if (static_MessagesBuffer == NULL)
        e = mess_MakeError(ErrorNumber_RTSupport_AllocFailed, 0);
      else
        /* Keep this cached - important because it may be needed from interrupt context */
        e = _swix(MessageTrans_OpenFile, _INR(0,2), &global_MessageFD, Module_MessagesFile, static_MessagesBuffer);
    }
  }
  if (!e)
  {
    MessagesOpen = true;
    /* Cache all the errors to avoid messagetrans lookups at runtime */
    mess_PrepareErrors(ErrorNumber_RTSupport_PollwordInUse, ErrorNumber_RTSupport_UKFlags, 0, 0);

    size_t PriorityMessagesSize;
    e = _swix(MessageTrans_FileInfo, _IN(1)|_OUT(2), "RTSupport:Priorities", &PriorityMessagesSize);
    if (!e)
    {
      static_PriorityMessagesBuffer = malloc(PriorityMessagesSize);
      if (static_PriorityMessagesBuffer == NULL)
        e = mess_MakeError(ErrorNumber_RTSupport_AllocFailed, 0);
      else
        /* Keep this cached - important because it may be needed from interrupt context */
        e = _swix(MessageTrans_OpenFile, _INR(0,2), &global_PriorityMessageFD, "RTSupport:Priorities", static_PriorityMessagesBuffer);
    }
  }
  if (!e)
  {
    PriorityMessagesOpen = true;

    /* Only a single routine on UnthreadV, please */
    if (((unsigned) podule_base) < 0x03000000 && podule_base != 0)
      e = mess_MakeError(ErrorNumber_RTSupport_DontBeSilly, 0);
  }
  if (!e)
  {
    /* Check CPU architecture version - SYS mode first available in v4 */
    uint32_t ID;
    __asm("MRC p15,0,ID,c0,c0,0");
    if ((ID & 0xF000) == 0 /* pre-ARM7 */ ||
        ((ID & 0xF000) == 0x7000 /* ARM7 */ && (ID & 0x800000) == 0 /* ARM7 v3 not v4T */ ))
      e = mess_MakeError(ErrorNumber_RTSupport_BadOS, 0);
  }
  if (!e)
  {
    /* Find IRQsema */
    if(_swix(OS_ReadSysInfo,_INR(0,2)|_OUT(2),6,0,OSRSI6_IRQsema,&IRQsema))
      IRQsema = Legacy_IRQsema;
    else if(!IRQsema)
      IRQsema = Legacy_IRQsema;
  }
  if (!e)
  {
    /* Check OS is calling UnthreadV, and cache the vector claim address in case we're */
    /* on a broken kernel */
    _swix(OS_Claim, _INR(0,2), UnthreadV, TestUnthreadV, 0);
    uint32_t t0, t1;
    _swix(OS_ReadMonotonicTime, _OUT(0), &t0);
    do
    {
      _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
    }
    while (VectorClaimAddress == 0 && t1 == t0);
    _swix(OS_Release, _INR(0,2), UnthreadV, TestUnthreadV, 0);
    if (VectorClaimAddress == 0)
      e = mess_MakeError(ErrorNumber_RTSupport_BadOS, 0);
  }
  if (!e)
  {
    /* Check for specific kernels with broken implementations of UnthreadV */
    e = _swix(OS_Byte, _INR(0,2), 0, 0, 0);
    if (strstr(e->errmess, "RISC OS 5.07") != NULL)
    {
      /* Simplest for desktop use to pretend that it's not available */
      e = mess_MakeError(ErrorNumber_RTSupport_BadOS, 0);
    }
    else
    {
      if (strstr(e->errmess, "RISC OS-STB 5.0.0") != NULL ||
          strstr(e->errmess, "RISC OS-STB 5.0.1") != NULL)
      {
        /* We'll try to manage without prioritisation for these */
        static_OldKernel = true;
      }
      /* Unfortunately some ROMs (like RISC OS 5.08 and RISC OS-STB 5.0.2) were built without the new SharedCLibrary even though it was available */
      /* See if we can soft-load it instead */
      _kernel_oscli("RMEnsure SharedCLibrary 5.51 RMLoad System:Modules.CLib");
      e = _kernel_oscli("RMEnsure SharedCLibrary 5.51 Error The RTSupport module requires SharedCLibrary 5.51 or later") >= 0 ? NULL : _kernel_last_oserror();
    }
  }
  if (!e)
  {
    /* Check if we're running on a kernel with broken OS_DynamicArea 9/10 error handling */
    int ver;
    e = _swix(OS_Module,_INR(0,2) | _OUT(6),20,0,-1,&ver);
    static_UseSparseArea = (ver >= 0x51500);
  }
  if (!e)
  {
    /* Create the dynamic area to hold the SVC stacks */
    const char *da_name;
    e = mess_LookUpDirect("DA", &da_name, NULL);
    if (!e)
    {
      if(static_UseSparseArea)
        e = _swix(OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, 0, -1, (1<<7) + (1<<10), DA_SIZE*1024, 0, 0, da_name, &static_DANumber, &static_DA);
      else
        e = _swix(OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, DA_SIZE*1024, -1, (1<<7), DA_SIZE*1024, 0, 0, da_name, &static_DANumber, &static_DA);
      if (!e)
      {
        DACreated = true;
        static_DAAllocPtr = static_DA - STACK_SIZE*1024; /* start allocating at the base of the DA */
        static_RoutineSVCStack = (char *) (((uint32_t) static_DA + PAGE_SIZE*1024 + 0xFFFFF) & 0xFFF00000) + STACK_SIZE*1024;
        static_LastStackBeforeMB = static_DA + ((static_RoutineSVCStack - static_DA - STACK_SIZE*1024 - PAGE_SIZE*1024) &~ PAGE_SIZE*1024);
        static_LastStackBeforeEnd = static_RoutineSVCStack + PAGE_SIZE*1024 + ((static_DA - static_RoutineSVCStack + DA_SIZE*1024 - PAGE_SIZE*1024) &~ PAGE_SIZE*1024);
        /* Page in the MB-aligned part of the DA */
        if(static_UseSparseArea)
          e = _swix(OS_DynamicArea, _INR(0,3), 9, static_DANumber, static_RoutineSVCStack - STACK_SIZE*1024, STACK_SIZE*1024);
        /* Fill in pointers */
        char *ptr=static_DAAllocPtr;
        for(int i=0;i<ROUTINES;i++)
        {
          ptr += STACK_SIZE*1024;
          if (ptr == static_LastStackBeforeMB) ptr = static_RoutineSVCStack + PAGE_SIZE*1024;
          static_Stacks[i].ptr = ptr;
          static_Stacks[i].next = static_FreeStacks;
          static_FreeStacks = &static_Stacks[i];
        }
        if(static_UseSparseArea)
        {
          /* Allocate the emergency stacks */
          RebalanceEmergencyList();
        }
        else
        {
          /* Keep the code simple by moving everything onto the emergency list */
          static_EmergencyStacks = static_FreeStacks;
          static_FreeStacks = NULL;
          static_NumEmergency = ROUTINES;
        }
      }
    }
  }
  if (!e)
  {

    /* Initialise workspace for scheduler */
    e = _swix(OS_ReadSysInfo, _INR(0,2)|_OUT(2), 6, 0, OSRSI6_Danger_IRQSTK, &IRQStk);
  }
  if (!e)
  {
    strcpy(ErrorBlock_PollwordInUse.errmess, mess_MakeError(ErrorNumber_RTSupport_PollwordInUse, 0)->errmess);
    ThreadTable = malloc(sizeof (*ThreadTable));
    if (ThreadTable == NULL)
      e = mess_MakeError(ErrorNumber_RTSupport_AllocFailed, 0);
  }
  if (!e)
  {
    static thread_t foreground_thread; /* leave initialised to all zeros */
    ThreadTable[0] = &foreground_thread;
    /* Finally, get on applicable vectors */
    e = _swix(OS_Claim, _INR(0,2), UnthreadV, static_OldKernel ? MyUnthreadV_OldKernel : MyUnthreadV, 0);
  }
  if (!e)
  {
    OnUnthreadV = true;
    e = _swix(OS_Claim, _INR(0,2), TickerV, tickerv_veneer, pw);
  }
  if (!e)
  {
    OnTickerV = true;
    e = _swix(OS_Claim, _INR(0,2), SeriousErrorV, asm_seriouserrorv_veneer, pw);
  }

  if (e && OnTickerV) _swix(OS_Release, _INR(0,2), TickerV, tickerv_veneer, pw);
  if (e && OnUnthreadV) _swix(OS_Release, _INR(0,2), UnthreadV, static_OldKernel ? MyUnthreadV_OldKernel : MyUnthreadV, 0);
  if (e && DACreated) _swix(OS_DynamicArea, _INR(0,1), 1, static_DANumber);
  if (e && PriorityMessagesOpen) _swix(MessageTrans_CloseFile, _IN(0), &global_PriorityMessageFD);
  if (e) free(static_PriorityMessagesBuffer);
  if (e && MessagesOpen)
  {
    mess_DiscardErrors();
    _swix(MessageTrans_CloseFile, _IN(0), &global_MessageFD);
  }
  if (e) free(static_MessagesBuffer);
#ifndef ROM_MODULE
  if (e && MessagesFileRegistered) _swix(ResourceFS_DeregisterFiles, _IN(0), resmess_ResourcesFiles());
#endif
  return e;
}

/*****************************************************************************
* module_Finalise
*
* Finalisation code
*
* Assumptions
*  NONE
*
* Inputs
*  fatal, podule, pw: the values of R10, R11 and R12 (respectively) on entry
*                     to the finalisation code
*
* Outputs
*  NONE
*
* Returns
*  NULL if finalisation succeeds; otherwise pointer to error block
*****************************************************************************/
_kernel_oserror *module_Finalise(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);
  dprintf(("","Finalising\n"));
  _swix(OS_Release, _INR(0,2), SeriousErrorV, asm_seriouserrorv_veneer, pw);
  _swix(OS_Release, _INR(0,2), TickerV, tickerv_veneer, pw);
  _swix(OS_Release, _INR(0,2), UnthreadV, static_OldKernel ? MyUnthreadV_OldKernel : MyUnthreadV, 0);
  _swix(OS_DynamicArea, _INR(0,1), 1, static_DANumber);
  _swix(MessageTrans_CloseFile, _IN(0), &global_PriorityMessageFD);
  free(static_PriorityMessagesBuffer);
  mess_DiscardErrors();
  _swix(MessageTrans_CloseFile, _IN(0), &global_MessageFD);
  free(static_MessagesBuffer);
#ifndef ROM_MODULE
  _swix(ResourceFS_DeregisterFiles, _IN(0), resmess_ResourcesFiles());
#endif
  return NULL;
}

/*****************************************************************************
* module_ServiceHandler
*
* Service call handler
*
* Assumptions
*  NONE
*
* Inputs
*  service_number: service call number
*  r:              pointer to registers on entry
*  pw:             the 'R12' value
*
* Outputs
*  r:              updated or not, as appropriate
*
* Returns
*  NOTHING
*****************************************************************************/
void module_ServiceHandler(int service_number, _kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);
  switch (service_number)
  {
    case Service_Error:
      if (((_kernel_oserror *)(r->r[0]))->errnum & 0x80000000)
      {
        /* Exception or abort error */
        bool irqs_were_disabled = _kernel_irqs_disabled();
        if (!irqs_were_disabled) _kernel_irqs_off();
        dprintf(("","Exception/abort detected, InBackground=%d\n",InBackground));
        if (InBackground) SomethingsGoneWrong();
#ifdef DEBUGLIB
        /* Disable assembler debugging */
        asm_DADWriteC = NULL;
#endif
        if (!irqs_were_disabled) _kernel_irqs_on();
      }
      break;
  }
}

/*****************************************************************************
* module_SWIHandler
*
* SWI handler
*
* Assumptions
*  NONE
*
* Inputs
*  swi_offset: offset into SWI chunk
*  r:          register block
*  pw:         the 'R12' value
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
_kernel_oserror *module_SWIHandler(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);
  _kernel_oserror *e = NULL;
  switch (swi_offset)
  {
    case RT_Register - RT_00:
      e = Register(r->r[0], (const void *) r->r[1], r->r[2], r->r[3], (volatile const uint32_t *) r->r[4], r->r[5], r->r[6], r->r[7], (thread_t **) r->r);
      break;

    case RT_Deregister - RT_00:
      e = Deregister(r->r[0], (thread_t *) r->r[1]);
      break;

    case RT_Yield - RT_00:
      e = Yield(false, (volatile uint32_t *)(r->r[1]), 0) ?
        mess_MakeError(ErrorNumber_RTSupport_CantYield, 0) : NULL;
      break;

    case RT_TimedYield - RT_00:
      e = Yield(true, (volatile uint32_t *)(r->r[1]), r->r[2]) ?
        mess_MakeError(ErrorNumber_RTSupport_CantYield, 0) : NULL;
      break;

    case RT_ChangePriority - RT_00:
      e = ChangePriority(r->r[0], (thread_t *) r->r[1], r->r[2], (uint32_t *) r->r);
      break;

    case RT_ReadInfo - RT_00:
      e = ReadInfo(r->r[0], (uint32_t *) r->r);
      break;

    default:
      e = mess_MakeError(ErrorNumber_RTSupport_UKSWI, 0);
      break;
  }
  if(e)
  {
    dprintf(("","SWI %02x returning with error %x %s\n",swi_offset,e->errnum,e->errmess));
  }
  else
  {
    dprintf(("","SWI %02x OK\n",swi_offset));
  }
  return e; 
}

/*****************************************************************************
* module_TickerVHandler
*
* TickerV handler
*
* Assumptions
*  NONE
*
* Inputs
*  r:          register block
*  pw:         the 'R12' value
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
_kernel_oserror *module_TickerVHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  /* Interrupts should already be off */
  NTicks++;
  uint32_t time;
  _swix(OS_ReadMonotonicTime, _OUT(0), &time); /* assume no error */
  uint32_t nthreads = NThreads;
  for (thread_t **ptr = (thread_t **) ThreadTable; nthreads-- > 0; ptr++)
  {
    thread_t *thread = *ptr;
    if (thread->timeout_flag && ((signed)(time - thread->timeout)) >= 0)
    {
      dprintf(("","Waking thread %08x from ticker routine\n",thread));
      thread->timeout_flag = false;
      thread->pollword = &Pollword_TimedOut;
    }
  }
  return NULL;
}

/*****************************************************************************
* module_SeriousErrorVHandler
*
* SeriousErrorV handler
*
* Assumptions
*  SeriousErrorV_Recover reason code, IRQs disabled
*
* Inputs
*  r:          register block
*  pw:         the 'R12' value
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
_kernel_oserror *module_SeriousErrorVHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  /* The OS has just reset the stacks, and is letting us know about it */
  if (InBackground) SomethingsGoneWrong();
  LastKnownIRQsema = NULL;
#ifdef DEBUGLIB
  /* Disable assembler debugging */
  asm_DADWriteC = NULL;
#endif
  return NULL;
}

/*****************************************************************************
* Register
*
* SWI RT_Register handler
*
* Assumptions
*  NONE
*
* Inputs
*  flags:      not used (r0 on entry)
*  entry:      default entry point
*  r0:         routine r0
*  r12:        routine r12
*  pollword:   default pollword
*  r10:        initial r10 for routine
*  r13sys:     initial r13_sys for routine
*  priority:   initial priority of routine (number or string pointer)
*
* Outputs
*  r_handle:   handle for created routine
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
static _kernel_oserror *Register(uint32_t flags, const void *entry, uint32_t r0, uint32_t r12,
    volatile const uint32_t *pollword, uint32_t r10, uint32_t r13sys, uint32_t priority, thread_t ** restrict r_handle)
{
  dprintf(("","RT_Register: flags %08x entry %08x r0 %08x r12 %08x pollword %08x r10 %08x r13sys %08x priority ",flags,entry,r0,r12,pollword,r10,r13sys));
  if(priority < 256u)
    dprintf(("","%d\n",priority));
  else
    dprintf(("","%s\n",(char *) priority));
  if(flags)
  {
    return mess_MakeError(ErrorNumber_RTSupport_UKFlags, 0);
  }
  _kernel_oserror *e = NULL;
  if (priority > 255u)
  {
    const char *result = NULL;
    e = _swix(MessageTrans_Lookup, _INR(0,2)|_OUT(2), &global_PriorityMessageFD, priority, 0, &result);
    if (!e) e = _swix(OS_ReadUnsigned, _INR(0,1)|_OUT(2), 0xC000000A, result, &priority);
  }
  if (e || priority == 0)
  {
    e = mess_MakeError(ErrorNumber_RTSupport_BadPriority, 0);
  }
  else
  {
    bool irqs_were_disabled = _kernel_irqs_disabled();
    if (!irqs_were_disabled) _kernel_irqs_off();
    /* Look for an address to use to store the routine's SVC stack while it is paged out */
    if (!static_EmergencyStacks)
    {
      e = RebalanceEmergencyList();
      if (!static_EmergencyStacks) /* Only fail if we still have 0 stacks - in which case RebalanceEmergenctList() will have returned an error */
      {
        if (!irqs_were_disabled) _kernel_irqs_on();
        return e;
      }
    }
    /* Grab an emergency stack, then rebalance the list
       Keeps all the allocation code in one place! */
    svcstack *stack = static_EmergencyStacks;
    static_EmergencyStacks = stack->next;
    static_NumEmergency--;
    char *ptr = stack->ptr;
    stack->next = static_ActiveStacks;
    static_ActiveStacks = stack;
    RebalanceEmergencyList();
    static_DAAllocPtr = ptr;

    thread_t *new_thread = malloc(sizeof *new_thread);
    bool thread_table_realloc_failed = false;
    if (new_thread != 0 && ThreadTableSize == NThreads)
    {
      size_t new_size = NThreads + 1;
      thread_t **new_table = realloc((void *) ThreadTable, new_size * sizeof *new_table);
      if (new_table == 0) thread_table_realloc_failed = true;
      else
      {
        ThreadTable = new_table;
        ThreadTableSize = new_size;
      }
    }
    if (new_thread == 0 || thread_table_realloc_failed)
    {
      if (!irqs_were_disabled) _kernel_irqs_on();
      free(new_thread);
      e = mess_MakeError(ErrorNumber_RTSupport_AllocFailed, 0);
    }
    else
    {
      dprintf(("","Created thread %08x\n",new_thread));
      *new_thread = (thread_t) {
        .r0 = r0,
        .r12 = r12,
        .svc_stack_base = static_RoutineSVCStack,
        .svc_stack_copy = ptr + STACK_SIZE*1024,
        .default_entry = entry,
        .default_pollword = pollword,
        .priority = priority,
        .entry = entry,
        .psr = 0x11F, /* SYS32 mode with IRQs/FIQs unmasked, then from TakeReset()
                       * in B1.9.1 of DDI0406C: async aborts masked, little endian,
                       * ARM mode, with any N/Z/C/V/Q/GE/IT flags.
                       */
        .pollword = pollword,
        .r13_svc = (uint32_t) static_RoutineSVCStack,
        .r10 = r10,
        .r13_sys = r13sys,
      };
      ThreadTable[NThreads++] = new_thread;
      switch (PriorityTable[priority].usage)
      {
        case 255: /* saturated */ break;
        case 0:
          PriorityTable[priority].last_executed = NThreads - 2; /* start here */
          if (priority != 255)
          {
            uint32_t prev_priority = 255;
            uint32_t next_priority;
            while ((next_priority = PriorityTable[prev_priority].next) > priority)
              prev_priority = next_priority;
            PriorityTable[priority].next = next_priority;
            PriorityTable[prev_priority].next = priority;
          }
          /* drop through... */
        default:
          PriorityTable[priority].usage++;
          break;
      }
      if (*pollword && priority > ThreadTable[Context]->priority)
      {
        /* It needs to pre-empt us already! */
        static const uint32_t set_pollword = -1;
        dprintf(("","RT_Register yielding to new thread %08x\n",new_thread));
        Yield(false, &set_pollword, 0);
        dprintf(("","RT_Register yield complete (thread %08x)\n",new_thread));
      }
      if (!irqs_were_disabled) _kernel_irqs_on();
      *r_handle = new_thread;
    }
  }
  return e;
}

/*****************************************************************************
* Deregister
*
* SWI RT_Deregister handler
*
* Assumptions
*  NONE
*
* Inputs
*  flags:      not used (r0 on entry)
*  handle:     handle for routine
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
static _kernel_oserror *Deregister(uint32_t flags, thread_t *handle)
{
  if(flags)
  {
    return mess_MakeError(ErrorNumber_RTSupport_UKFlags, 0);
  }
  _kernel_oserror *e = NULL;
  bool irqs_were_disabled = _kernel_irqs_disabled();
  if (!irqs_were_disabled) _kernel_irqs_off();
  dprintf(("","RT_Deregister: thread %08x\n",handle));
  uint32_t index;
  uint32_t last_index = NThreads;
  for (index = 1; index < last_index; index++)
  {
    if (ThreadTable[index] == handle) break;
  }
  if (index == last_index)
  {
    e = mess_MakeError(ErrorNumber_RTSupport_BadHandle, 0);
  }
  else
  {
    thread_t *thread = ThreadTable[index];
    /* Release the memory for the SVC stack copy */
    /* We push it onto the emergency list, then let RebalanceEmergencyList handle the rest */
    svcstack *stack = static_ActiveStacks;
    static_ActiveStacks = stack->next;
    stack->next = static_EmergencyStacks;
    stack->ptr = ((char *) thread->svc_stack_copy)-STACK_SIZE*1024;
    static_EmergencyStacks = stack;
    static_NumEmergency++;
    RebalanceEmergencyList();
    /* If it was pre-empted, patch up the IRQ stack so no attempt is made to resume it */
    bool stack_frame_needs_poking = false;
    volatile uint32_t * volatile stack_frame;
    dprintf(("","index %d Context %d *IRQsema %08x LastKnownIRQsema %08x\n",index,Context,*IRQsema,LastKnownIRQsema));
    if (thread->pollword == &Pollword_PreEmpted)
    {
      /* Thread was preempted by another thread */
      dprintf(("","Thread was preempted by another thread\n"));
      stack_frame_needs_poking = true;
      stack_frame = thread->stack_frame;
    }
    else if (index == Context && *IRQsema != LastKnownIRQsema)
    {
      /* Thread was only preempted by an IRQ (so this SWI is being called from that IRQ or a nested one) */
      /* We have to find the stack frame manually, because it didn't exist while the thread was executing */
      dprintf(("","Thread was preempted by an IRQ\n"));
      stack_frame = *IRQsema;
      while ((volatile uint32_t *) *stack_frame != LastKnownIRQsema && /* shouldn't happen, except perhaps after abort */ *stack_frame != 0)
      {
        dprintf(("","Skipping stack frame at %08x\n",stack_frame));
        stack_frame = (volatile uint32_t *) *stack_frame;
      }
      if (*stack_frame != NULL)
        stack_frame_needs_poking = true;
    }
    if (stack_frame_needs_poking)
    {
      dprintf(("","Poking stack frame at %08x\n",stack_frame));
      stack_frame[6] = 0x92; /* I32_bit | IRQ32_mode */
      stack_frame[8] = (uint32_t) ThreadResumed;
    }
    /* Sort out the priority table */
    uint32_t priority = thread->priority;
    switch (PriorityTable[priority].usage)
    {
      case 255: /* saturated */ break;
      case 1:
        if (priority != 255)
        {
          uint32_t prev_priority = 255;
          uint32_t next_priority;
          while ((next_priority = PriorityTable[prev_priority].next) > priority)
            prev_priority = next_priority;
          PriorityTable[prev_priority].next = PriorityTable[priority].next;
        }
        /* drop through... */
      default:
        PriorityTable[priority].usage--;
        break;
    }
    /* Shuffle down the later part of the thread table */
    memmove((void *) (ThreadTable + index), (void *) (ThreadTable + index + 1), (--NThreads - index) * sizeof *ThreadTable);
    /* Adjust all references to higher (or same) thread numbers */
    uint32_t original_Context = Context;
    if (original_Context >= index) Context = original_Context - 1;
    for (uint32_t priority = 255; priority != 0; priority = PriorityTable[priority].next)
    {
      if (PriorityTable[priority].last_executed >= index) PriorityTable[priority].last_executed--;
    }
    /* Free the thread structure, and finish with the current execution context if necessary */
    free(thread);
    if (original_Context == index)
    {
      dprintf(("","RT_Deregister exiting via Die() (thread %08x)\n",handle));
      Die();
      dprintf(("","RT_Deregister Die() failed (thread %08x)\n",handle));
    }
  }
  if (!irqs_were_disabled) _kernel_irqs_on();
  return e;
}

/*****************************************************************************
* ChangePriority
*
* SWI RT_ChangePriority handler
*
* Assumptions
*  NONE
*
* Inputs
*  flags:      not used (r0 on entry)
*  handle:     handle for routine
*  priority:   new priority (number or string pointer)
*
* Outputs
*  r_priority: previous priority setting (number)
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
static _kernel_oserror *ChangePriority(uint32_t flags, thread_t * restrict handle, uint32_t priority, uint32_t * restrict r_priority)
{
  if(flags)
  {
    return mess_MakeError(ErrorNumber_RTSupport_UKFlags, 0);
  }
  dprintf(("","RT_ChangePriority: handle %08x priority ",handle));
  if(priority < 256u)
    dprintf(("","%d\n",priority));
  else
    dprintf(("","%s\n",(char *) priority));

  _kernel_oserror *e = NULL;
  if (priority > 255u)
  {
    const char *result = NULL;
    e = _swix(MessageTrans_Lookup, _INR(0,2)|_OUT(2), &global_PriorityMessageFD, priority, 0, &result);
    if (!e) e = _swix(OS_ReadUnsigned, _INR(0,1)|_OUT(2), 0xC000000A, result, &priority);
  }
  if (e || (priority == 0 && handle != NULL))
  {
    e = mess_MakeError(ErrorNumber_RTSupport_BadPriority, 0);
  }
  else
  {
    bool irqs_were_disabled = _kernel_irqs_disabled();
    if (!irqs_were_disabled) _kernel_irqs_off();
    uint32_t index;
    uint32_t last_index = NThreads;
    if (handle == NULL)
    {
      handle = ThreadTable[0];
      index = 0;
    }
    else
    {
      for (index = 1; index < last_index; index++)
      {
        if (ThreadTable[index] == handle) break;
      }
    }
    if (index == last_index)
    {
      if (!irqs_were_disabled) _kernel_irqs_on();
      e = mess_MakeError(ErrorNumber_RTSupport_BadHandle, 0);
    }
    else
    {
      if (priority != handle->priority)
      {
        /* Decrement count of threads at old priority */
        switch (PriorityTable[handle->priority].usage)
        {
          case 255: /* saturated */ break;
          case 1:
            if (handle->priority != 255)
            {
              uint32_t prev_priority = 255;
              uint32_t next_priority;
              while ((next_priority = PriorityTable[prev_priority].next) > handle->priority)
                prev_priority = next_priority;
              PriorityTable[prev_priority].next = PriorityTable[handle->priority].next;
            }
            /* drop through... */
          default:
            PriorityTable[handle->priority].usage--;
            break;
        }
        /* Increment count of threads at new priority */
        switch (PriorityTable[priority].usage)
        {
          case 255: /* saturated */ break;
          case 0:
            if (priority != 255)
            {
              uint32_t prev_priority = 255;
              uint32_t next_priority;
              while ((next_priority = PriorityTable[prev_priority].next) > priority)
                prev_priority = next_priority;
              PriorityTable[priority].next = next_priority;
              PriorityTable[prev_priority].next = priority;
            }
            /* drop through... */
          default:
            PriorityTable[priority].usage++;
            break;
        }

        *r_priority = handle->priority;
        handle->priority = priority;
        /* If the routine was set to a higher priority than we are executing at, or if we are demoting ourselves, we need to yield */
        if ((Context != index && priority > Priority && *handle->pollword) ||
            (Context == index && priority < Priority))
        {
          static const uint32_t set_pollword = -1;
          dprintf(("","RT_ChangePriority yielding (%s, thread %08x)\n",(Context==index?"Demoted ourselves":"Promoted pending thread"),handle));
          Yield(false, &set_pollword, 0); /* scope here for a version that only starts scanning at current thread's priority */
          dprintf(("","RT_ChangePriority yield complete (thread %08x)\n",handle));
        }
      }
      if (!irqs_were_disabled) _kernel_irqs_on();
    }
  }
  return e;
}

/*****************************************************************************
* ReadInfo
*
* SWI RT_ReadInfo handler
*
* Assumptions
*  NONE
*
* Inputs
*  reason:     reason code
*
* Outputs
*  r_value:    value to return
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
static _kernel_oserror *ReadInfo(uint32_t reason, uint32_t *r_value)
{
  _kernel_oserror *e = NULL;
  switch (reason)
  {
    case RTReadInfo_Handle:
    {
      if (*IRQsema != LastKnownIRQsema)
        *r_value = -1;
      else if (Context == 0)
        *r_value = 0;
      else
      {
        bool irqs_were_disabled = _kernel_irqs_disabled();
        if (!irqs_were_disabled) _kernel_irqs_off();
        *r_value = (uint32_t) ThreadTable[Context];
        if (!irqs_were_disabled) _kernel_irqs_on();
      }
      break;
    }

    case RTReadInfo_Priority:
      if (*IRQsema != LastKnownIRQsema)
        *r_value = -1;
      else
        *r_value = Priority;
      break;

    case RTReadInfo_SVCStk:
      *r_value = (uint32_t) static_RoutineSVCStack;
      break;

    default:
      e = mess_MakeError(ErrorNumber_RTSupport_UKReason, 0);
      break;
  }
  return e;
}

/*****************************************************************************
* RebalanceEmergencyList
*
* Tries to make sure we have exactly EMERGENCY_STACKS in the emergency list
*
* Assumptions
*  Assumes function will not be re-entered
*
* Inputs
*  NONE
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
static _kernel_oserror *RebalanceEmergencyList(void)
{
  _kernel_oserror *e = NULL;
  svcstack *stack;
  if(!static_UseSparseArea)
  {
    /* Not much to do if we're not using a sparse area */
    if(!static_EmergencyStacks)
      return mess_MakeError(ErrorNumber_RTSupport_Exhausted, 0);
    return NULL;
  }
  while (static_NumEmergency < EMERGENCY_STACKS)
  {
    stack = static_FreeStacks;
    if(!stack)
      return mess_MakeError(ErrorNumber_RTSupport_Exhausted, 0);
    e = _swix(OS_DynamicArea,_INR(0,3),9,static_DANumber,stack->ptr,STACK_SIZE*1024);
    if(e)
      return e; /* Assume that if one alloc fails, all subsequent ones will fail */
    static_FreeStacks = stack->next;
    stack->next = static_EmergencyStacks;
    static_EmergencyStacks = stack;
    static_NumEmergency++;
  }
  while (static_NumEmergency > EMERGENCY_STACKS)
  {
    stack = static_EmergencyStacks;
    e = _swix(OS_DynamicArea,_INR(0,3),10,static_DANumber,stack->ptr,STACK_SIZE*1024);
    if(e)
      return NULL; /* Assume that an error means that no memory was moved. Also, the caller doesn't care about errors when freeing memory, so just return NULL */
    static_EmergencyStacks = stack->next;
    stack->next = static_FreeStacks;
    static_FreeStacks = stack;
    static_NumEmergency--;
  }
  return NULL;    
}

/*****************************************************************************
* END OF FILE
*****************************************************************************/
@


1.12
log
@Fix to processor identification
The expression would never match an ARM7, so attempting to softload the module on an ARMv3 era machine (no SYS mode) would not give a graceful error message.
From a tip off in https://www.riscosopen.org/forum/forums/4/topics/3990

Version 0.16. Tagged as 'RTSupport-0_16'
@
text
@d16 2
a17 2
* $Id: module,v 1.11 2016/04/05 20:04:19 jlee Exp $
* $Name:  $
d48 1
d171 11
@


1.11
log
@Listen out for SeriousErrorV_Recover
Detail:
  c/module, cmhg/RTSupportHdr, h/global, s/scheduler - Add a handler for SeriousErrorV, so we can be notified when the privileged mode stacks are being flattened. This is safer than watching out for serious errors to arrive via ErrorV, although the ErrorV approach is still necessary in order to deal with old kernels or serious error generators that don't currently use SeriousErrorV (e.g. FPASC/VFPSupport)
Admin:
  Tested on Raspberry Pi


Version 0.15. Tagged as 'RTSupport-0_15'
@
text
@d16 2
a17 2
* $Id: module,v 1.10 2015/10/23 19:30:22 rsprowson Exp $
* $Name: HEAD $
d228 1
a228 1
        ((ID & 0xF000) == 7 /* ARM7 */ && (ID & 0x800000) == 0 /* ARM7 v3 not v4T */ ))
@


1.10
log
@Leave A bit set in SPSR when creating a thread
ARM have started using the extension bits (8 to 15) of the PSR, but have given bit 8 a safe default of being set (mask asynchronous aborts).
Since the kernel doesn't handle these RTSupport will create the thread state with A=1 as it would be at reset.

Version 0.14. Tagged as 'RTSupport-0_14'
@
text
@d16 2
a17 2
* $Id: module,v 1.9 2015/10/07 20:37:28 jlee Exp $
* $Name:  $
d153 1
d356 5
d362 1
d402 1
d566 32
@


1.9
log
@Cache translated error messages
Detail:
  c/module - Make use of mess.c's error caching facility to avoid having to call MessageTrans when returning errors. Should give a bit of a performance boost when dealing with common errors (e.g. "Cannot yield in this context")
Admin:
  Tested on Raspberry Pi


Version 0.13. Tagged as 'RTSupport-0_13'
@
text
@d16 2
a17 2
* $Id: module,v 1.8 2015/08/04 06:47:40 rsprowson Exp $
* $Name: HEAD $
d660 4
a663 1
        .psr = 0x1F, /* SYS mode, IRQs/FIQs enabled */
@


1.8
log
@Simplify standalone build
Lump the Priorities in with the Messages using INSTRES_FILES.
Remame CMHG file to match the default.
Delete double message file handling code.
Build, but not tested.

Version 0.12. Tagged as 'RTSupport-0_12'
@
text
@d16 2
a17 2
* $Id: module,v 1.6 2012/03/22 22:45:14 jlee Exp $
* $Name:  $
d198 2
d360 5
a364 1
  if (e && MessagesOpen) _swix(MessageTrans_CloseFile, _IN(0), &global_MessageFD);
d400 1
@


1.6
log
@Fix some nasty bugs. Add extensive debug logging code.
Detail:
  s/scheduler - Fix PreEmptionRecovery and ThreadResumed to update LastKnownIRQsema with the new value of IRQsema
  s/scheduler - Fix SVC stack copying code to decrement both pointers instead of incrementing one and decrementing the other. Fix PreEmpt loading the wrong values for SVCStackCopy and SVCStackBase.
  s/scheduler - Fix Yielded loading Context into R2, and thus overwriting any timeout the routine specified
  c/module, hdr/RTSupport, Resources/UK/Messages - Module now errors when RTSupport SWIs are called with nonzero flags
  Makefile, c/module, h/scheduler, s/scheduler - Added lots of debugging code, based around debuglib for C code and DADebug for assembler code. Debug code toggled on/off by passing DEBUG=TRUE to makefile. PC-relative variables shifted to middle of file to keep them within LDR range when debugging enabled.
Admin:
  Tested in OMAP3 ROM on BB-xM
  Fixes issues seen when multiple RTSupport threads are in use


Version 0.08. Tagged as 'RTSupport-0_08'
@
text
@d16 2
a17 2
* $Id: module,v 1.5 2011/08/04 22:35:30 jlee Exp $
* $Name: HEAD $
d54 1
a54 1
#include "modhdr.h"
a147 1
  bool PriorityMessagesFileRegistered = false;
a180 6

    e = _swix(ResourceFS_RegisterFiles, _IN(0), resmess2_ResourcesFiles());
  }
  if (!e)
  {
    PriorityMessagesFileRegistered = true;
a360 1
  if (e && PriorityMessagesFileRegistered) _swix(ResourceFS_DeregisterFiles, _IN(0), resmess2_ResourcesFiles());
a396 1
  _swix(ResourceFS_DeregisterFiles, _IN(0), resmess2_ResourcesFiles());
@


1.5
log
@Update to work with zero page relocation
Detail:
  c/cmodule - Try using OS_ReadSysInfo 6 to find IRQsema before falling back on the legacy address
  h/scheduler - Add IRQsema pointer extern, update ThreadResumed extern to cope with it now being in a data area
  s/scheduler - Use workspace IRQsema pointer instead of hardcoded legacy address. Moved PreEmptionRecovery & ThreadResumed into data area for easier access to IRQsema ptr.
Admin:
  Tested on rev A2 BB-xM


Version 0.06. Tagged as 'RTSupport-0_06'
@
text
@d16 2
a17 2
* $Id: module,v 1.4 2009/10/22 01:04:56 jlee Exp $
* $Name:  $
d158 1
a158 1
  debug_set_area_level_prefix(true);
d164 6
d396 1
d441 1
d443 4
d475 1
d479 2
a480 1
      return Register(r->r[0], (const void *) r->r[1], r->r[2], r->r[3], (volatile const uint32_t *) r->r[4], r->r[5], r->r[6], r->r[7], (thread_t **) r->r);
d483 2
a484 1
      return Deregister(r->r[0], (thread_t *) r->r[1]);
d487 1
a487 1
      return Yield(false, (volatile uint32_t *)(r->r[1]), 0) ?
d489 1
d492 1
a492 1
      return Yield(true, (volatile uint32_t *)(r->r[1]), r->r[2]) ?
d494 1
d497 2
a498 1
      return ChangePriority(r->r[0], (thread_t *) r->r[1], r->r[2], (uint32_t *) r->r);
d501 2
a502 1
      return ReadInfo(r->r[0], (uint32_t *) r->r);
d505 2
a506 1
      return mess_MakeError(ErrorNumber_RTSupport_UKSWI, 0);
d508 9
d551 1
d586 9
a594 1
  IGNORE(flags);
d652 1
d692 1
d694 1
d723 4
a726 1
  IGNORE(flags);
d730 1
d756 1
d760 1
d768 1
d771 2
d774 1
d780 1
d814 6
a819 1
    if (original_Context == index) Die();
d846 10
a855 1
  IGNORE(flags);
d939 1
d941 1
@


1.4
log
@Fixes & improvements for RTSupport module
Detail:
  - Makefile (hopefully temporarily) modified to use "-cpu 3" setting for compiling C files, to work around internal compiler error
  - RT_Deregister fixed (in s/scheduler) to behave properly if a routine attempts to deregister itself after being entered from the foreground via RT_Yield
  - Simple test program added to test correct behaviour of RT_Deregister
  - SVC stack allocation routines rewritten to cope with the possibility that OS_DynamicArea 9/10 may be unable to move pages (e.g. RT_Deregister called while IRQSema is nonzero)
  - Stack allocation routine also attempts to deal with kernels which have broken sparse area error reporting (anything below version 5.15), by falling back on a simpler allocation scheme that doesn't resize the dynamic area.
  - Erroneous comment in s/scheduler fixed
  - Erroneous #define in h/scheduler fixed
Admin:
  Tested on RISC OS 5.15 rev C2 beagleboard, RISC OS 5.12 Iyonix
  Makefile fix "fixes" bug #218


Version 0.05. Tagged as 'RTSupport-0_05'
@
text
@d16 2
a17 2
* $Id: module,v 1.3 2005/08/27 19:29:24 bavison Exp $
* $Name: HEAD $
d47 1
d62 1
a62 1
#define IRQsema (*(void **)0x108)
d231 8
d333 1
a333 1
    e = _swix(OS_ReadSysInfo, _INR(0,2)|_OUT(2), 6, 0, 21, &IRQStk);
d717 1
a717 1
    else if (index == Context && IRQsema != LastKnownIRQsema)
d721 1
a721 1
      stack_frame = IRQsema;
d906 1
a906 1
      if (IRQsema != LastKnownIRQsema)
d921 1
a921 1
      if (IRQsema != LastKnownIRQsema)
@


1.3
log
@  Fixes some nasty bugs.
Detail:
  * First bug was that due to a careless slip-up in the very last stage of
    the process of switching to a routine (the loading of the SPSR), all
    routines were actually being entered in SYS mode with IRQs disabled. This
    was leading to horrendous interrupt latency - exactly the situation this
    module was written to avert! The most obvious reproducible symptom was
    that the real time clock ran slowly.
  * Once this was fixed, it revealed the presence of a more complicated bug:
    the module wasn't including the most-recently-executed routine along
    with the list of other routines in a non-sleeping state for a certain
    sub-set of actions. This was fixed by setting the pollword pointer to
    yet another magic address while it was executing, to minimise the
    disruption to existing code.
Admin:
  Tested with a deinterlacing routine.

Version 0.04. Tagged as 'RTSupport-0_04'
@
text
@d16 2
a17 2
* $Id: module,v 1.2 2005/01/27 15:52:04 bavison Exp $
* $Name:  $
d40 1
d68 4
d80 3
a82 1
#define DA_SIZE MIN(1024+STACK_SIZE+PAGE_SIZE, STACK_SIZE+STACK_SIZE+PAGE_SIZE+ROUTINES*STACK_SIZE)
d91 1
d98 5
a102 1

d112 1
d269 7
d281 4
a284 1
      e = _swix(OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, 0, -1, (1<<7) + (1<<10), DA_SIZE*1024, 0, 0, da_name, &static_DANumber, &static_DA);
d293 24
a316 1
        e = _swix(OS_DynamicArea, _INR(0,3), 9, static_DANumber, static_RoutineSVCStack - STACK_SIZE*1024, STACK_SIZE*1024);
d564 1
a564 3
    char *ptr = static_DAAllocPtr;
    static uint32_t page_block[3];
    do
d566 2
a567 5
      ptr += STACK_SIZE*1024;
      if (ptr == static_LastStackBeforeEnd) ptr = static_DA;
      if (ptr == static_LastStackBeforeMB) ptr = static_RoutineSVCStack + PAGE_SIZE*1024;
      if (ptr == static_LastStackBeforeEnd) ptr = static_DA;
      if (ptr == static_DAAllocPtr)
a568 1
        /* We've run out of space */
d570 25
a594 1
        return mess_MakeError(ErrorNumber_RTSupport_Exhausted, 0);
a595 1
      page_block[1] = (uint32_t) ptr;
d597 1
a597 3
    while (!_swix(OS_Memory, _INR(0,2), (1<<13) | (1<<9), page_block, 1));
    e = _swix(OS_DynamicArea, _INR(0,3), 9, static_DANumber, ptr, STACK_SIZE*1024); /* page in it */
    if (e)
d600 2
d605 17
a621 5
      static_DAAllocPtr = ptr;

      thread_t *new_thread = malloc(sizeof *new_thread);
      bool thread_table_realloc_failed = false;
      if (new_thread != 0 && ThreadTableSize == NThreads)
d623 16
a638 8
        size_t new_size = NThreads + 1;
        thread_t **new_table = realloc((void *) ThreadTable, new_size * sizeof *new_table);
        if (new_table == 0) thread_table_realloc_failed = true;
        else
        {
          ThreadTable = new_table;
          ThreadTableSize = new_size;
        }
d640 1
a640 1
      if (new_thread == 0 || thread_table_realloc_failed)
d642 3
a644 49
        if (!irqs_were_disabled) _kernel_irqs_on();
        free(new_thread);
        e = mess_MakeError(ErrorNumber_RTSupport_AllocFailed, 0);
      }
      else
      {
        *new_thread = (thread_t) {
          .r0 = r0,
          .r12 = r12,
          .svc_stack_base = static_RoutineSVCStack,
          .svc_stack_copy = ptr + STACK_SIZE*1024,
          .default_entry = entry,
          .default_pollword = pollword,
          .priority = priority,
          .entry = entry,
          .psr = 0x1F, /* SYS mode, IRQs/FIQs enabled */
          .pollword = pollword,
          .r13_svc = (uint32_t) static_RoutineSVCStack,
          .r10 = r10,
          .r13_sys = r13sys,
        };
        ThreadTable[NThreads++] = new_thread;
        switch (PriorityTable[priority].usage)
        {
          case 255: /* saturated */ break;
          case 0:
            PriorityTable[priority].last_executed = NThreads - 2; /* start here */
            if (priority != 255)
            {
              uint32_t prev_priority = 255;
              uint32_t next_priority;
              while ((next_priority = PriorityTable[prev_priority].next) > priority)
                prev_priority = next_priority;
              PriorityTable[priority].next = next_priority;
              PriorityTable[prev_priority].next = priority;
            }
            /* drop through... */
          default:
            PriorityTable[priority].usage++;
            break;
        }
        if (*pollword && priority > ThreadTable[Context]->priority)
        {
          /* It needs to pre-empt us already! */
          static const uint32_t set_pollword = -1;
          Yield(false, &set_pollword, 0);
        }
        if (!irqs_were_disabled) _kernel_irqs_on();
        *r_handle = new_thread;
d646 2
d691 8
a698 1
    _swix(OS_DynamicArea, _INR(0,3), 10, static_DANumber, thread->svc_stack_copy - STACK_SIZE*1024, STACK_SIZE*1024);
d929 54
@


1.2
log
@Fixed Makefile - resources phase was failing due to lack of a CmdHelp file.
Also fixed length calculation when setting system variable to exclude
trailing null byte (not that FileSwitch seems to mind!)

Version 0.02. Tagged as 'RTSupport-0_02'
@
text
@d16 1
a16 1
* $Id: module,v 1.1.1.1 2005/01/12 19:55:22 bavison Exp $
d654 2
d658 18
a675 2
      thread->stack_frame[6] = 0x92; /* I32_bit | IRQ32_mode */
      thread->stack_frame[8] = (uint32_t) ThreadResumed;
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
* $Id:  $
d153 1
a153 1
    _swix(OS_SetVarVal, _INR(0,4), "RTSupport$Path", MY_PATH, sizeof MY_PATH, 0, 4);
@


1.1.1.1
log
@Initial import of the RTSupport module, the real-time routine scheduler.
This has so far been demonstrated to work with a single client under
RISC OS-STB 5.0.0 and 5.0.2.
@
text
@@

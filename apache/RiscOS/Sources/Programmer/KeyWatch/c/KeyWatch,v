head	1.3;
access;
symbols
	KeyWatch-0_13:1.3
	KeyWatch-0_12:1.2
	KeyWatch-0_11:1.2
	dellis_autobuild_BaseSW:1.2
	sbrodie_sedwards_16Mar2000:1.2
	KeyWatch-0_10:1.2
	dcotton_autobuild_BaseSW:1.2
	nturton_KeyWatch-0_09:1.2
	KeyWatch-0_09:1.2
	KeyWatch-0_08-1_1_2_10:1.1.1.11
	nicke_KeyWatch-0_0_7:1.1.1.9
	hsimons_BOCA-1_2-Release:1.1.1.9
	KeyWatch-0_07-1_1_2_9:1.1.1.9
	afrost_Boca-1_2-Beta:1.1.1.8
	KeyWatch-0_06-1_1_2_8:1.1.1.8
	afrost_NC2_Generic:1.1.1.2
	KeyWatch-0_05-1_1_2_7:1.1.1.7
	KeyWatch-0_04-1_1_2_6:1.1.1.6
	KeyWatch-0_04-1_1_2_5:1.1.1.6
	KeyWatch-0_03-1_1_2_4:1.1.1.5
	KeyWatch-0_03-1_1_2_3:1.1.1.4
	KeyWatch-0_02-1_1_2_2:1.1.1.3
	Spinner_RCA116:1.1.1.1
	Spinner_B20_2:1.1.1.1
	Spinner_19_3:1.1.1.1
	Spinner_B18:1.1.1.1
	Spinner_B17:1.1.1.1
	Spinner_B15:1.1.1.1
	Spinner_B14:1.1.1.1
	Spinner_B13:1.1.1.1
	Spinner_B12:1.1.1.1
	Spinner_B10:1.1.1.1
	Spinner_B7:1.1.1.1
	ARTtmp_merge:1.1.1.1
	Spin_3Apr97:1.1.1.1
	RCA_bp:1.1
	RCA:1.1.0.2
	ARTtmp:1.1.1.1.0.2
	initial:1.1.1.1
	Spinner:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2014.10.01.07.59.18;	author rsprowson;	state Exp;
branches;
next	1.2;
commitid	Q9ifTR4HahGsitSx;

1.2
date	98.10.07.18.44.01;	author smiddle;	state Exp;
branches;
next	1.1;

1.1
date	97.03.19.11.34.03;	author scormie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.19.11.34.03;	author scormie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.09.11.09.53.10;	author rbuckley;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.02.03.15.25.15;	author smiddle;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.02.03.18.09.56;	author smiddle;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	98.02.06.17.00.27;	author smiddle;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	98.02.09.11.02.05;	author smiddle;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	98.03.20.14.55.08;	author smiddle;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	98.05.11.14.05.12;	author smiddle;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.06.05.13.57.35;	author smiddle;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.09.09.12.53.24;	author ahodgkin;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.09.28.16.46.45;	author olove;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Relocate remotedb
Somewhat academic as the debug version of this module didn't build due to not having a debug rule in the makefile and the TRACE() macro having the wrong function name.
Requires remotedb-0_12.

Version 0.13. Tagged as 'KeyWatch-0_13'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* INCLUDES */

#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "kernel.h"
#include "swis.h"

#include "tboxlibs/wimp.h"

#include "VersionNum"	/* must be before KeyWatchHd.h to avoid Module_Date clash */
#include "KeyWatchHd.h"
#include "KeyWatch.h"

#include "remotedb/remote.h"

#ifdef REMOTE_DEBUG
#define TRACE(a) remote_debug_printf a
#else
#define TRACE(a)
#endif

/* ---------------------------------------------------------------------------------------------------- */

/* CONSTANTS */
#define KW                     Module_Title

#define FALSE			0
#define TRUE			1

#define OSByte_DisableEvent	13
#define OSByte_EnableEvent	14

#define EventV			0x10
#define EventV_Input		2
#define EventV_Key		11

#define Buffer_Keyboard		0
#define Buffer_Serial_Input	1

#define EventV_Key_Up		0
#define EventV_Key_Down		1

#define KeyV			0x13
#define KeyV_DummyKeyboard	11

#define TaskModule_SendMessage	0x4D300

#define PW_TABLE_SIZE		10

#define FEATURES		0

#define KEY_TABLE_SIZE          64

#define NULL_TASK	(-1)
#define NULL_KEY	(-1)

#define NOT_USED(a)		a = a

/* ---------------------------------------------------------------------------------------------------- */

/* TYPE DEFINITIONS */

typedef struct
{
    int flags;
    int scan_code;
    int key_code;
} key_event;

typedef struct {
  int pollword; /* actual pollword */
  int used;     /* whether this entry is in use or not */
} pw_table_entry; /* individual entry of poll word table */

/* ---------------------------------------------------------------------------------------------------- */

/* GLOBALS */

static int eventv_count = 0;	/* control claiming EventV */
static int keyv_count = 0;	/* control claiming KeyV */

static pw_table_entry pollword_table[PW_TABLE_SIZE];	/* table of registered pollwords */

static key_event scan_key_table[KEY_TABLE_SIZE];	/* queue of key events */
static int scan_key_head = 0;				/* first free entry */
static int scan_key_tail = 0;				/* first used entry */

static int scan_flags = 0;				/* flags set by RegisterScan */
static int scan_task = NULL_TASK;			/* task handle passed to RegisterScan */
static int scan_shift_state = 0;			/* current shift state */
static int scan_last_down = NULL_KEY;			/* last scan that went down */
static int scan_last_key = NULL_KEY;			/* last inserted keycode */
static int scan_overflows = 0;				/* number of overflows since last poll */
static int scan_buffer_count = 0;			/* count of number of buffer event received between scans */

static int ignore_next_key = FALSE;			/* Ignore next key press - set by KeyWatch_Ignore */

#ifdef REMOTE_DEBUG
static remote_debug_session *db=NULL;
#endif

/* ---------------------------------------------------------------------------------------------------- */

static char *errors[] =
{
    "Cannot register keywatch - table full",
    "Cannot deregister keywatch - bad pollword handle",
    "KeyWatch: can't exit as tasks are registered",
    "KeyWatch: a task is already registered for key scans",
    "KeyWatch: this task is not registered for key scans"
};

#define E(a) (0x80 | (a))

#if 1

/* This is the PC-XT scan code set */
#define KEY_PRTSCR	"\xE0\x2A\xE0\x37"
#define KEY_BREAK	"\xE1\x1D\x45\xE1\x9D\xC5"

static char internal_to_ps2_code[128] =
{
    0x01, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41,				/* 0x00: Esc - F7 */
    0x42, 0x43, 0x44, 0x57, 0x58, 0x00, 0x46, 0x01,				/* 0x08: F8 - Break */
    0x29, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,				/* 0x10: ` - 7 */
    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x00, 0x0E, E(0x52),				/* 0x18: 8 - INSERT */
    E(0x47), E(0x49), 0x45, E(0x35), 0x37, 0x2B, 0x0F, 0x10,			/* 0x20: Home - Q */
    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,				/* 0x28: W - O */
    0x19, 0x1A, 0x1B, 0x2B, E(0x53), E(0x4F), E(0x51), 0x47,			/* 0x30: P - 7 */
    0x48, 0x49, 0x4A, 0x1D, 0x1E, 0x1F, 0x20, 0x21,				/* 0x38: 8 - F */
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x1C,				/* 0x40: G - ENTER */
    0x4B, 0x4C, 0x4D, 0X4E, 0x2A, 0x56, 0x2C, 0x2D,				/* 0x48: 4 - X */
    0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,				/* 0x50: C - / */
    0x36, E(0x48), 0x4F, 0x50, 0x51, 0x3A, 0x38, 0x39,				/* 0x58: Shift R - SPACE */
    E(0x38), E(0x1D), E(0x4B), E(0x50), E(0x4D), 0x52, 0x53, E(0x1C),		/* 0x60: Alt R - Enter */
    0x7E, 0x7F, E(0x5D), 0x00, 0x00, 0x00, 0x00, 0x00				/* 0x68: WinL, WinR, Menu, NoCon, Con, Kana, backslashR */
    /* note 7E and 7F above for WinL and WinR are made up but are known about by ICAClient */
};

/* Note WinL and WinR above are not the correct values, they are fakes known only by ICAClient */

#else

/* This is the AT-02 scan code set */
#define KEY_PRTSCR	"\xE0\x12\xE0\x7C"
#define KEY_BREAK	"\x14\x77\xF0\x14\xF0\x77"

static char internal_to_ps2_code[128] =
{
    0x76, 0x05, 0x06, 0x04, 0x0C, 0x03, 0x0B, 0x83,				/* Esc - F7 */
    0x0A, 0x01, 0x09, 0x78, 0x07, 0x00, 0x7E, 0x01,				/* F8 - Break */
    0x0E, 0x16, 0x1E, 0x26, 0x25, 0x2E, 0x36, 0x3D,				/* ` - 7 */
    0x3E, 0x46, 0x45, 0x4E, 0x55, 0x6A, 0x66, E(0x70),				/* 8 - INSERT */
    E(0x6C), E(0x7D), 0x77, E(0x4A), 0x7C, 0x5D, 0x0D, 0x15,			/* Home - Q */
    0x1D, 0x24, 0x2D, 0x2C, 0x35, 0x3C, 0x43, 0x44,				/* W - O */
    0x4D, 0x54, 0x5B, 0x5D, E(0x71), E(0x69), E(0x7A), 0x6C,			/* P - 7 */
    0x75, 0x7D, 0x7B, 0x14, 0x1C, 0x1B, 0x23, 0x2B,				/* 8 - F */
    0x34, 0x33, 0x3B, 0x42, 0x4B, 0x4C, 0x52, 0x5A,				/* G - ENTER */
    0x6B, 0x73, 0x74, 0x79, 0x12, 0x61, 0x1A, 0x22,				/* 4 - X */
    0x21, 0x2A, 0x32, 0x31, 0x3A, 0x41, 0x49, 0x4A,				/* C - / */
    0x59, E(0x75), 0x69, 0x72, 0x7A, 0x58, 0x11, 0x29,				/* Shift R - SPACE */
    E(0x11), E(0x14), E(0x6B), E(0x72), E(0x74), 0x70, 0x71, E(0x5A),		/* Alt R - Enter */
    E(0x1F), E(0x27), E(0x2F), 0x67, 0x64, 0x13, 0x51				/* 0x68: WinL, WinR, Menu, NoCon, Con, Kana, backslashR */
};

#endif

/* ---------------------------------------------------------------------------------------------------- */

static _kernel_oserror global_error;

static _kernel_oserror *makeerror(int errnum)
{
    global_error.errnum = errnum;
    strcpy(global_error.errmess, errors[errnum - KeyWatch_Error_BASE]);

    return &global_error;
}

/* ---------------------------------------------------------------------------------------------------- */

/* The C part of the handler */

int keyv_veneer_handler(_kernel_swi_regs *r, void *pw)
{
    int count; /* boring loop count variable */

    if ( ignore_next_key == TRUE)
    {
   	ignore_next_key = FALSE;
 	return 1; /* don't claim the vector and don't do anything else */
    }
    /* if the reason is a key press or release or dummy keyboard */
    if ( (r->r[0] == 1) || (r->r[0] == 2) || (r->r[0] == KeyV_DummyKeyboard) )
    {
	/* if it is a mouse button that has been pressed */
	if ( (r->r[1] >= 0x70) && (r->r[1] <= 0x72) )
	    return 1; /* don't claim the vector and don't do anything else */

	for (count=0; count < PW_TABLE_SIZE; count++)
	{
	    if (pollword_table[count].used)
		pollword_table[count].pollword++;
	} /* for */
    }

    return 1; /* don't claim the vector */
    NOT_USED(pw);
} /* keyv_handler */

static _kernel_oserror *kw_swi_register(void **pollword, void *pw)
{
    _kernel_oserror *e = NULL;
    int count; /* boring count variable */
    int cont=1; /* whether to continue looping */

    /* Find an empty table entry */
    for (count=0; (count < PW_TABLE_SIZE) && cont;
	 count++)
    {
	if (pollword_table[count].used == 0)
	    cont = 0;
    }

    if (cont) /* table is full */
	e = makeerror(KeyWatch_Error_TABLE_FULL);

    if (!e && keyv_count++ == 0)
	e = _swix(OS_Claim, _INR(0,2), KeyV, keyv_veneer, pw);

    if (!e)
    {
	/* count is now one past what it should be, so go back */
	count--;

	/* mark as used */
	pollword_table[count].used = 1;

	/* reset pollword */
	pollword_table[count].pollword = 0;

	/* return pollword address in r0 */
	*pollword = &(pollword_table[count].pollword);
    }

    return e;
}

static _kernel_oserror *kw_swi_deregister(void *pollword, void *pw)
{
    _kernel_oserror *e = NULL;
    int count; /* boring count variable */
    int cont=1; /* whether to continue looping */

    /* find passed pollword in table - I actually look
     * for it, rather than just add 1 to get to the
     * used field, to verify that it is actually in
     * the table, and not spurious */
    for (count=0; (count < PW_TABLE_SIZE) && cont;
	 count++)
    {
	if (pollword_table[count].used)
	{
	    if (pollword == &(pollword_table[count].pollword))
		cont=0;
	} /* if */
    } /* for */

    if (cont) /* reached the end of the table */
	e = makeerror(KeyWatch_Error_BAD_POLLWORD);

    if (!e)
    {
	/* set unused - NB count is one more than it should
	 * be so we decrement it */
	pollword_table[--count].used = 0;

	if (--keyv_count == 0)
	    e = _swix(OS_Release, _INR(0,2), KeyV, keyv_veneer, pw);
    }

    return e;
}

/* ---------------------------------------------------------------------------------------------------- */

static void update_shift(int updown, int internal_code)
{
    int key = 0;
    switch (internal_code)
    {
    case 0x3B:
	key = KeyWatch_State_LEFT_CTRL_DOWN;
	break;
    case 0x4C:
	key = KeyWatch_State_LEFT_SHIFT_DOWN;
	break;
    case 0x58:
	key = KeyWatch_State_RIGHT_SHIFT_DOWN;
	break;
    case 0x5E:
	key = KeyWatch_State_LEFT_ALT_DOWN;
	break;
    case 0x60:
	key = KeyWatch_State_RIGHT_ALT_DOWN;
	break;
    case 0x61:
	key = KeyWatch_State_RIGHT_CTRL_DOWN;
	break;
    }

    if (key)
    {
	if (updown == EventV_Key_Up)
	    scan_shift_state &= ~key;
	else
	    scan_shift_state |=  key;
    }
}

static void add_entry(int flags, int scan_code, int key_code)
{
    key_event *k;

    flags |= scan_shift_state;

    if (scan_flags & KeyWatch_RegisterScan_MESSAGE)
    {
	/* send message or register callback not sure which */
	WimpMessage msg;

	msg.hdr.size = sizeof(msg.hdr) + sizeof(key_event);
	msg.hdr.action_code = KeyWatch_00;
	msg.hdr.your_ref = 0;

	k = (key_event *)&msg.data;
	k->flags = flags;
	k->scan_code = scan_code;
	k->key_code = key_code;

	_swix(TaskModule_SendMessage, _INR(0,5), 0, &msg, scan_task, 0, 0, 0);
    }
    else
    {
	k = &scan_key_table[scan_key_head];

	k->flags = flags;
	k->scan_code = scan_code;
	k->key_code = key_code;

	/* wrap wround at end of table */
	if (++scan_key_head == KEY_TABLE_SIZE)
	    scan_key_head = 0;

	/* if we're not reading keys out quick enough then drop the oldest item */
	if (scan_key_tail == scan_key_head)
	{
	    if (++scan_key_tail == KEY_TABLE_SIZE)
	    {
		scan_key_tail = 0;
		scan_overflows++;
	    }
	}
    }
}

static void add_ps2(int flags, int code)
{
    if (code & 0x80)
    {
	add_entry(flags, 0xE0, NULL_KEY);
	code &= 0x7F;

	/* mark the data code as being part of a PS2 extended code */
	flags |= KeyWatch_Event_PS2_EXTENDED;
    }

    if (flags & KeyWatch_Event_KEY_GOING_UP)
	code |= 0x80;

    add_entry(flags, code, NULL_KEY);
}

static void key_transition(int updown, int internal_code)
{
    update_shift(updown, internal_code);

    if ((internal_code < 0x70 || (scan_flags & KeyWatch_RegisterScan_MOUSE)) &&
	(scan_flags & KeyWatch_RegisterScan_SCAN_CODES))
    {
	int flags;

	/* get base flags */
	flags = KeyWatch_Event_SCAN_CODE_VALID;
	if (updown == EventV_Key_Up)
	    flags |= KeyWatch_Event_KEY_GOING_UP;

	/* translate internal scan code if necessary */
	if (scan_flags & KeyWatch_RegisterScan_PS2)
	{
	    /* two special case keys */
	    if (internal_code == 0x0D || internal_code == 0x0F)
	    {
		const char *s = internal_code == 0x0D ? KEY_PRTSCR : KEY_BREAK;
		int c;
		while ((c = *s++) != 0)
		    add_entry(flags, c, NULL_KEY);

		/* internal_code = 0x100 + internal_to_ps2_code[internal_code]; */
		internal_code = NULL_KEY;
	    }
	    else
	    {
		internal_code = internal_to_ps2_code[internal_code & 0x7F]; /* mask bits to ensure safe lookup */

		/* if unused then ignore entirely */
		if (internal_code == 0)
		    internal_code = NULL_KEY;
		else
		    add_ps2(flags, internal_code);
	    }
	}
	else
	{
	    add_entry(flags, internal_code, NULL_KEY);
	}
    }

    /* update the last key down */
    if (updown == EventV_Key_Down)
	scan_last_down = internal_code;
}

static int key_input(int buffer_code)
{
    if (buffer_code != 0 || scan_last_key == 0)
    {
	add_entry(KeyWatch_Event_KEY_CODE_VALID |
		  (scan_last_down == NULL_KEY ? 0 : KeyWatch_Event_SCAN_CODE_VALID) |
		  (scan_last_key == 0 ? KeyWatch_Event_LAST_WAS_NUL : 0),
		  scan_last_down,
		  buffer_code);
    }

    scan_last_key = buffer_code;
    scan_last_down = NULL_KEY;

    return 1;
}

int eventv_veneer_handler(_kernel_swi_regs *r, void *pw)
{
    switch (r->r[0])
    {
    case EventV_Key:
	TRACE((db,     "key_transition: %02x %c\n", r->r[2], r->r[1] == EventV_Key_Down ? 'D' : 'U'));

	key_transition(r->r[1], r->r[2]);
	scan_buffer_count = 0;
	break;

    case EventV_Input:
	if (r->r[1] == Buffer_Keyboard)
	{
	    int key = r->r[2];

	    TRACE((db,     "buffer_input  : %02x\n", key));

	    if (scan_flags & KeyWatch_RegisterScan_BUFFER_CODES)
	    {
		/* process key */
		key_input( key );

		scan_buffer_count++;
	    }
	    else if ((scan_flags & (KeyWatch_RegisterScan_SCAN_CODES | KeyWatch_RegisterScan_PS2)) ==
		     (KeyWatch_RegisterScan_SCAN_CODES | KeyWatch_RegisterScan_PS2))
	    {
		/* auto-repeat PS/2 scan code
		 * only if we've had a key down, and a key input, and it wasn't a null character
		 */
		if (scan_last_down != NULL_KEY && scan_last_key != 0 && scan_buffer_count++ > 0)
		{
		    TRACE((db, "auto-repeat   : %d\n", scan_last_down));

		    add_ps2(KeyWatch_Event_SCAN_CODE_VALID | KeyWatch_Event_KEY_GOING_UP, scan_last_down);
		    add_ps2(KeyWatch_Event_SCAN_CODE_VALID, scan_last_down);
		}

		scan_last_key = key;
	    }

	    /* remove key from buffer */
	    if (scan_flags & KeyWatch_RegisterScan_CONSUME_BUFFER)
	    {
		int flags;

		_swix(OS_Byte, _INR(0,1) | _OUT(_FLAGS), 145, Buffer_Keyboard, &flags);

		TRACE((db, "consume_key   : %d\n", flags & _C ? 0 : 1));
	    }
	}
	break;
    }

    return 1; /* don't claim the vector */
    pw = pw;
}

/* ---------------------------------------------------------------------------------------------------- */

static _kernel_oserror *kw_swi_register_scan(int flags, int task, void *pw)
{
    _kernel_oserror *e = NULL;

    TRACE((db, "register_scan: flags %x task %x\n", flags, task));

    /* for now only one claimant at a time for simplicity */
    if (eventv_count)
	e = makeerror(KeyWatch_Error_ALREADY_REGISTERED);

    if (!e && eventv_count++ == 0)
    {
	e = _swix(OS_Claim, _INR(0,2), EventV, eventv_veneer, pw);
	if (!e) e = _swix(OS_Byte, _INR(0,1), OSByte_EnableEvent, EventV_Input);
	if (!e) e = _swix(OS_Byte, _INR(0,1), OSByte_EnableEvent, EventV_Key);
    }

    if (!e)
    {
	scan_flags = flags;
	scan_task = task;
	scan_last_key = NULL_KEY;
    }

    TRACE((db, "register_scan: returns e %x\n", e));

    return e;
}

static _kernel_oserror *kw_swi_deregister_scan(int flags, int task, void *pw)
{
    _kernel_oserror *e = NULL;

    TRACE((db, "deregister_scan: flags %x task %x\n", flags, task));

    if (scan_task != task)
	e = makeerror(KeyWatch_Error_NOT_REGISTERED);

    if (!e && --eventv_count == 0)
    {
	e = _swix(OS_Byte, _INR(0,1), OSByte_DisableEvent, EventV_Input);
	if (!e) e = _swix(OS_Byte, _INR(0,1), OSByte_DisableEvent, EventV_Key);
	if (!e) e = _swix(OS_Release, _INR(0,2), EventV, eventv_veneer, pw);
    }

    if (!e)
    {
	scan_flags = 0;
	scan_task = NULL_TASK;

	/* dispose of any pending keys */
	scan_key_head = scan_key_tail = 0;
    }

    TRACE((db, "deregister_scan: returns e %x\n", e));

    return e;
    NOT_USED(flags);
}

static _kernel_oserror *kw_swi_poll(int *pflags, int task, key_event **pbuf, int *pbuf_size, int *pnentries, int *entry_size)
{
    _kernel_oserror *e = NULL;

    //TRACE((db, "poll: task %08x buf %p bufsize %d\n", task, *pbuf, *pbuf_size));

    if (scan_task != task)
	e = makeerror(KeyWatch_Error_NOT_REGISTERED);

    if (!e)
    {
	key_event *buf = *pbuf;
	int buf_size = *pbuf_size;
	int nentries;

	if (buf == NULL)
	{
	    nentries = (scan_key_head < scan_key_tail ? KEY_TABLE_SIZE : 0) + (scan_key_head - scan_key_tail);
	    buf_size = nentries * sizeof(key_event);
	}
	else
	{
	    nentries = *pnentries;
	    while (scan_key_tail != scan_key_head && buf_size >= sizeof(key_event) && nentries > 0)
	    {
		/* write out buffer entry */
		*buf++ = scan_key_table[scan_key_tail];
		buf_size -= sizeof(key_event);
		nentries--;

		/* wrap around to the start of the table */
		if (++scan_key_tail == KEY_TABLE_SIZE)
		    scan_key_tail = 0;
	    }
	}

	*pbuf = buf;
	*pbuf_size = buf_size;
	*entry_size = sizeof(key_event);
	*pflags = scan_overflows ? KeyWatch_Poll_HAD_OVERFLOW : 0;
	*pnentries = nentries;

	if (buf)
	    scan_overflows = 0;
    }

    //TRACE((db, "poll: out          buf %p bufsize %d entry_siuze %d flags %x entries %d\n", *pbuf, *pbuf_size, *entry_size, *pflags, *pnentries));

    return e;
}

static _kernel_oserror *kw_swi_ignore(int *pflags)
{
    _kernel_oserror *e = NULL;

    ignore_next_key = TRUE;
    
    return e;
    NOT_USED(pflags);
}

/* ---------------------------------------------------------------------------------------------------- */

_kernel_oserror *kw_swi_handler(int swi_no, _kernel_swi_regs *r, void *private_word)
{
    _kernel_oserror *e = error_BAD_SWI;

    switch (swi_no)
    {
    case KeyWatch_Register - KeyWatch_00:
	e = kw_swi_register((void **)&r->r[0], private_word);
	break;

    case KeyWatch_Deregister - KeyWatch_00:
	e = kw_swi_deregister((void *)r->r[0], private_word);
	break;

    case KeyWatch_Version - KeyWatch_00:
	r->r[0] = FEATURES;
	r->r[1] = Module_VersionNumber;		/* from CMHG */
	r->r[2] = (int)Module_MinorVersion;	/* from VersionNum */
	e = NULL;
	break;

    case KeyWatch_RegisterScan - KeyWatch_00:
	e = kw_swi_register_scan(r->r[0], r->r[1], private_word);
	break;

    case KeyWatch_DeregisterScan - KeyWatch_00:
	e = kw_swi_deregister_scan(r->r[0], r->r[1], private_word);
	break;

    case KeyWatch_Poll - KeyWatch_00:
	e = kw_swi_poll(&r->r[0], r->r[1], (key_event **)&r->r[2], &r->r[3], &r->r[4], &r->r[1]);
	break;

    case KeyWatch_Ignore - KeyWatch_00:
	e = kw_swi_ignore(&r->r[0]);
	break;
    }

    return e;

} /* swi_handler */


/* Module initialisation code */

_kernel_oserror *kw_initialise(const char *cmd_tail, int podule_base, void *private_word)
{
    remote_debug_open("KeyWatch",&db);
    TRACE((db, "Module initialisation called"));

    /* Initialise poll word table */
    memset(&pollword_table[0], 0, sizeof(pollword_table[0]) * PW_TABLE_SIZE);
    memset(&scan_key_table[0], 0, sizeof(scan_key_table[0]) * KEY_TABLE_SIZE);

    return NULL;
    NOT_USED(cmd_tail);
    NOT_USED(podule_base);
    NOT_USED(private_word);
} /* kw_initialise */


/* Module exit code */

_kernel_oserror *kw_final(int fatal, int podule, void *private_word)
{
    if (keyv_count || eventv_count)
	return makeerror(KeyWatch_Error_CANT_EXIT);

    TRACE((db,"(5) finalisation"));
    remote_debug_close(db);

    return NULL;
    NOT_USED(fatal);
    NOT_USED(podule);
    NOT_USED(private_word);
} /* kw_final */

_kernel_oserror *kw_commands(const char *arg_string, int argc, int cmd_no, void *private_word)
{
    switch (cmd_no)
    {
    case CMD_KeyWatchForceClose:
	if (eventv_count)
	    (void)kw_swi_deregister_scan(0, scan_task, private_word);

	if (keyv_count)
	{
	    (void)_swix(OS_Release, _INR(0,2), KeyV, keyv_veneer, private_word);
	    keyv_count = 0;
	    memset(&pollword_table[0], 0, sizeof(pollword_table[0]) * PW_TABLE_SIZE);
	}
	break;
    }
    return NULL;
    NOT_USED(argc);
    NOT_USED(arg_string);
}

/* eof KeyWatch.c */
@


1.2
log
@Moved to trunk.
Changed the fake Windows keys from extended to plain in the PS/2
mappings. This stops strange results being seen in the ICAClient.
You must use ICAClient 0.33 or later with it now though.

Version 0.09. Tagged as 'KeyWatch-0_09'
@
text
@d30 1
a30 1
#include "debug/remote.h"
d33 1
a33 1
#define TRACE(a) debug_printf a
d115 1
a115 1
debug_session *db=NULL;
@


1.1
log
@Initial revision
@
text
@d20 1
d24 16
d41 31
d73 3
a75 9
#define  KW                     "KeyWatch"
#define  KW_SWI_CHUNK_BASE      0x4E940
#define  KW_SWI_REGISTER        0
#define  KW_SWI_DEREGISTER      1
#define  KW_ERR_BAD_SWI         0x1E6 /* same as system error */
#define  KW_ERR_TABLE_FULL      (KW_SWI_CHUNK_BASE + 1)
#define  KW_ERR_BAD_POLLWORD    (KW_SWI_CHUNK_BASE + 2)
#define  KEYV_VECT              0x13
#define  PW_TABLE_SIZE          10
d79 7
d91 2
d95 88
a182 3
static _kernel_oserror kw_error;
static int initialised=0;
static pw_table_entry pollword_table[PW_TABLE_SIZE];
d184 1
d186 1
a186 1
/* FUNCTION PROTOTYPES */
d188 7
a194 2
/* The following is brought in from CMHG */
extern int keyv_handler_entry(_kernel_swi_regs *r, void *pw);
d196 1
d200 1
a200 1
int keyv_handler(_kernel_swi_regs *r, void *pw)
d202 1
a202 1
  int count; /* boring loop count variable */
d204 18
a221 13
  /* if the reason is a key press or release */
  if ( (r->r[0] == 1) || (r->r[0] == 2) )
  {
    /* if it is a mouse button that has been pressed */
    if ( (r->r[1] >= 0x70) && (r->r[1] <= 0x72) )
      return 1; /* don't claim the vector and don't do anything else */
  } /* if */

  for (count=0; count < PW_TABLE_SIZE; count++)
  {
    if (pollword_table[count].used)
      pollword_table[count].pollword++;
  } /* for */
d223 2
a224 1
  return 1; /* don't claim the vector */
d227 129
d357 283
a639 1
_kernel_oserror *swi_handler(int swi_no, _kernel_swi_regs *r, void *private_word)
d641 1
a641 2
  int count; /* boring count variable */
  int cont=1; /* whether to continue looping */
d643 5
a647 64
  switch (swi_no)
  {
    case KW_SWI_REGISTER:
                          /* Find an empty table entry */
                          for (count=0; (count < PW_TABLE_SIZE) && cont;
                               count++)
                          {
                            if (pollword_table[count].used == 0) cont=0;
                          } /* for */

                          if (cont) /* table is full */
                          {
                            kw_error.errnum = KW_ERR_TABLE_FULL;
                            strcpy(kw_error.errmess,
                                   "Cannot register keywatch - table full");
                            return(&kw_error);
                          } /* if */

                          /* count is now one past what it should be, so go back */
                          count--;

                          /* mark as used */
                          pollword_table[count].used = 1;

                          /* reset pollword */
                          pollword_table[count].pollword = 0;

                          /* return pollword address in r0 */
                          r->r[0] = (int) &(pollword_table[count].pollword);
                          break;

    case KW_SWI_DEREGISTER:
                            /* find passed pollword in table - I actually look
                             * for it, rather than just add 1 to get to the
                             * used field, to verify that it is actually in
                             * the table, and not spurious */
                            for (count=0; (count < PW_TABLE_SIZE) && cont;
                                 count++)
                            {
                              if (pollword_table[count].used)
                              {
                                if (r->r[0] == (int) &(pollword_table[count].pollword))
                                  cont=0;
                              } /* if */
                            } /* for */

                            if (cont) /* reached the end of the table */
                            {
                              kw_error.errnum = KW_ERR_BAD_POLLWORD;
                              strcpy(kw_error.errmess,
                                   "Cannot deregister keywatch - bad pollword handle");
                              return(&kw_error);
                            } /* if */

                            /* set unused - NB count is one more than it should
                             * be so we decrement it */
                            pollword_table[--count].used = 0;

                            break;
    default:
             kw_error.errnum = KW_ERR_BAD_SWI;
             sprintf(kw_error.errmess, "Bad SWI number &%08x", swi_no);
             return(&kw_error);
  } /* switch */
d649 41
a689 1
  return NULL; /* no error */
d696 1
a696 1
_kernel_oserror *kw_initialise(char *cmd_tail, int podule_base, void *private_word)
d698 2
a699 2
    _kernel_swi_regs regs;
    _kernel_oserror *kern_err=NULL;
d703 1
a703 17

    /* OS_Claim the KeyV vector */
    regs.r[0] = KEYV_VECT;
    regs.r[1] = (int) &keyv_handler_entry;
    regs.r[2] = (int) private_word;

    kern_err=_kernel_swi(OS_Claim, &regs, &regs);

    if (kern_err)
    {
      initialised=0;
      return kern_err;
    } /* if */
    else
    {
      initialised=1;
    } /* else */
d706 3
d716 2
a717 2
  _kernel_oserror *kern_err=NULL;
  _kernel_swi_regs regs;
d719 2
a720 6
  /* Only do anything if we were initialised */
  if (initialised)
  {
    regs.r[0] = KEYV_VECT;
    regs.r[1] = (int) &keyv_handler_entry;
    regs.r[2] = (int) private_word;
d722 5
a726 1
    kern_err = _kernel_swi(OS_Release, &regs, &regs);
d728 3
a730 2
    if (kern_err) return kern_err;
    else
d732 16
a747 3
      initialised = 0;
    } /* else */
  } /* if */
d749 1
a749 2
  return NULL;
} /* kw_final */
@


1.1.1.1
log
@Initial version.

@
text
@@


1.1.1.2
log
@Only increment keywatch variable for key up/down and dummy keyboard KEYV
reason codes. KEYV_DummyKeyboard is now generated by IRHandset driver and
is used to supress the on screen keyboard.
@
text
@a32 1
#define  KEYV_DummyKeyboard	11
d61 2
a62 2
  /* if the reason is a key press or release or dummy keyboard */
  if ( (r->r[0] == 1) || (r->r[0] == 2) || (r->r[0] == KEYV_DummyKeyboard))
d67 1
d69 5
a73 6
    for (count=0; count < PW_TABLE_SIZE; count++)
    {
      if (pollword_table[count].used)
        pollword_table[count].pollword++;
    } /* for */
  }
@


1.1.1.3
log
@Whole new load of functionality to support getting a stream of scan keys.
See doc/keywatch.html for details.

Version 0.02, 1.1.2.2. Tagged as 'KeyWatch-0_02-1_1_2_2'
@
text
@a19 1

a22 8
#include "wimp.h"

#include "KeyWatchHd.h"

#include "VersionNum"

/* ---------------------------------------------------------------------------------------------------- */

d25 10
a34 61
#define KW                     Module_Title

#define KW_ERR_BAD_SWI			0x1E6 /* same as system error */

#define KW_ERR_BASE			KeyWatch_00
#define KW_ERR_TABLE_FULL		(KW_ERR_BASE + 0)
#define KW_ERR_BAD_POLLWORD		(KW_ERR_BASE + 1)
#define KW_ERR_CANT_EXIT		(KW_ERR_BASE + 2)
#define KW_ERR_ALREADY_REGISTERED	(KW_ERR_BASE + 3)
#define KW_ERR_NOT_REGISTERED		(KW_ERR_BASE + 4)

#define OSByte_DisableEvent	13
#define OSByte_EnableEvent	14

#define EventV			0x10
#define EventV_Input		2
#define EventV_Key		11

#define Buffer_Keyboard		0
#define Buffer_Serial_Input	1

#define EventV_Key_Up		0
#define EventV_Key_Down		1

#define KeyV			0x13
#define KeyV_DummyKeyboard	11

#define TaskModule_SendMessage	0x4D300

#define PW_TABLE_SIZE		10

#define FEATURES		0

#define KEY_TABLE_SIZE          64

#define KeyWatch_Event_SCAN_CODE_VALID	(1<<0)
#define KeyWatch_Event_KEY_CODE_VALID	(1<<1)
#define KeyWatch_Event_KEY_GOING_UP	(1<<2)
#define KeyWatch_Event_LAST_WAS_NUL	(1<<3)

#define KeyWatch_State_LEFT_SHIFT_DOWN	(1<<16)
#define KeyWatch_State_RIGHT_SHIFT_DOWN	(1<<17)
#define KeyWatch_State_LEFT_CTRL_DOWN	(1<<18)
#define KeyWatch_State_RIGHT_CTRL_DOWN	(1<<19)
#define KeyWatch_State_LEFT_ALT_DOWN	(1<<20)
#define KeyWatch_State_RIGHT_ALT_DOWN	(1<<21)

#define KeyWatch_RegisterScan_PS2	(1<<0)
#define KeyWatch_RegisterScan_MESSAGE	(1<<1)
#define KeyWatch_RegisterScan_MOUSE	(1<<2)

#define KeyWatch_Poll_HAD_OVERFLOW	(1<<0)

#define KeyWatch_PS2KEY_UNUSED		0x00
#define KeyWatch_PS2KEY_PRINT_SCREEN	0x81
#define KeyWatch_PS2KEY_BREAK		0x82

#define NULL_TASK	(-1)
#define NULL_KEY	(-1)

/* ---------------------------------------------------------------------------------------------------- */
a37 7
typedef struct
{
    int flags;
    int scan_code;
    int key_code;
} key_event;

a42 2
/* ---------------------------------------------------------------------------------------------------- */

d45 3
a47 8
static int eventv_count = 0;	/* control claiming EventV */
static int keyv_count = 0;	/* control claiming KeyV */

static pw_table_entry pollword_table[PW_TABLE_SIZE];	/* table of registered pollwords */

static key_event scan_key_table[KEY_TABLE_SIZE];	/* queue of key events */
static int scan_key_head = 0;				/* first free entry */
static int scan_key_tail = 0;				/* first used entry */
a48 6
static int scan_flags = 0;				/* flags set by RegisterScan */
static int scan_task = NULL_TASK;			/* task handle passed to RegisterScan */
static int scan_shift_state = 0;			/* current shift state */
static int scan_last_down = NULL_KEY;			/* last scan that went down */
static int scan_last_key = NULL_KEY;			/* last inserted keycode */
static int scan_overflows = 0;				/* number of overflows since last poll */
d50 1
a50 1
/* ---------------------------------------------------------------------------------------------------- */
d52 2
a53 47
static char *errors[] =
{
    "KeyWatch: Unknown SWI",
    "Cannot register keywatch - table full",
    "Cannot deregister keywatch - bad pollword handle",
    "KeyWatch: can't exit as tasks are registered",
    "KeyWatch: a task is already registered for key scans",
    "KeyWatch: this task is not registered for key scans"
};

#define E(a) (0x80 | (a))

static char internal_to_ps2_code[128] =
{
    0x76, 0x05, 0x06, 0x04, 0x0C, 0x03, 0x0B, 0x83,				/* Esc - F7 */
    0x0A, 0x01, 0x09, 0x78, 0x07, E(0x01), 0x7E, E(0x02),			/* F8 - Break: two secial codes */
    0x0E, 0x16, 0x1E, 0x26, 0x25, 0x2E, 0x36, 0x3D,				/* ` - 7 */
    0x3E, 0x46, 0x45, 0x4E, 0x55, 0x66, 0x0D, E(0x70),				/* 8 - INSERT */
    E(0x6C), E(0x7D), 0x77, E(0x4A), 0x7C, 0x5D, 0x0D, 0x15,			/* Home - Q */
    0x1D, 0x24, 0x2D, 0x2C, 0x35, 0x3C, 0x43, 0x44,				/* W - O */
    0x4D, 0x54, 0x5B, 0x5D, E(0x71), E(0x69), E(0x7A), 0x6C,			/* P - 7 */
    0x75, 0x7D, 0x7B, 0x14, 0x1C, 0x1B, 0x23, 0x2B,				/* 8 - F */
    0x34, 0x33, 0x3B, 0x42, 0x4B, 0x4C, 0x52, 0x5A,				/* G - ENTER */
    0x6B, 0x73, 0x74, 0x79, 0x12, 0x00, 0x1A, 0x22,				/* 4 - X */
    0x21, 0x2A, 0x32, 0x31, 0x3A, 0x41, 0x49, 0x4A,				/* C - / */
    0x59, E(0x75), 0x69, 0x72, 0x7A, 0x58, 0x11, 0x29,				/* Shift R - SPACE */
    E(0x11), E(0x14), E(0x6B), E(0x72), E(0x74), 0x70, 0x71, E(0x5A)		/* Alt R - Enter */
};

/* ---------------------------------------------------------------------------------------------------- */

static _kernel_oserror global_error;

static _kernel_oserror *makeerror(int errnum)
{
    int index;

    if (errnum == KW_ERR_BAD_SWI)
	index = 0;
    else
	index = errnum - KW_ERR_BASE + 1;
	
    global_error.errnum = errnum;
    strcpy(global_error.errmess, errors[index]);

    return &global_error;
}
a54 1
/* ---------------------------------------------------------------------------------------------------- */
d58 1
a58 22
int keyv_veneer_handler(_kernel_swi_regs *r, void *pw)
{
    int count; /* boring loop count variable */

    /* if the reason is a key press or release or dummy keyboard */
    if ( (r->r[0] == 1) || (r->r[0] == 2) || (r->r[0] == KeyV_DummyKeyboard) )
    {
	/* if it is a mouse button that has been pressed */
	if ( (r->r[1] >= 0x70) && (r->r[1] <= 0x72) )
	    return 1; /* don't claim the vector and don't do anything else */

	for (count=0; count < PW_TABLE_SIZE; count++)
	{
	    if (pollword_table[count].used)
		pollword_table[count].pollword++;
	} /* for */
    }

    return 1; /* don't claim the vector */
} /* keyv_handler */

static _kernel_oserror *kw_swi_register(void **pollword, void *pw)
d60 1
a60 22
    _kernel_oserror *e = NULL;
    int count; /* boring count variable */
    int cont=1; /* whether to continue looping */

    /* Find an empty table entry */
    for (count=0; (count < PW_TABLE_SIZE) && cont;
	 count++)
    {
	if (pollword_table[count].used == 0)
	    cont = 0;
    }
    
    if (cont) /* table is full */
	e = makeerror(KW_ERR_TABLE_FULL);

    if (!e && keyv_count++ == 0)
	e = _swix(OS_Claim, _INR(0,2), KeyV, keyv_veneer, pw);

    if (!e)
    {
	/* count is now one past what it should be, so go back */
	count--;
d62 6
a67 2
	/* mark as used */
	pollword_table[count].used = 1;
d69 1
a69 22
	/* reset pollword */
	pollword_table[count].pollword = 0;

	/* return pollword address in r0 */
	*pollword = &(pollword_table[count].pollword);
    }

    return e;
}

static _kernel_oserror *kw_swi_deregister(void *pollword, void *pw)
{
    _kernel_oserror *e = NULL;
    int count; /* boring count variable */
    int cont=1; /* whether to continue looping */

    /* find passed pollword in table - I actually look
     * for it, rather than just add 1 to get to the
     * used field, to verify that it is actually in
     * the table, and not spurious */
    for (count=0; (count < PW_TABLE_SIZE) && cont;
	 count++)
d71 2
a72 5
	if (pollword_table[count].used)
	{
	    if (pollword == &(pollword_table[count].pollword))
		cont=0;
	} /* if */
d74 1
d76 2
a77 15
    if (cont) /* reached the end of the table */
	e = makeerror(KW_ERR_BAD_POLLWORD);

    if (!e)
    {
	/* set unused - NB count is one more than it should
	 * be so we decrement it */
	pollword_table[--count].used = 0;

	if (--keyv_count == 0)
	    e = _swix(OS_Release, _INR(0,2), KeyV, keyv_veneer, pw);
    }
    
    return e;
}
a78 1
/* ---------------------------------------------------------------------------------------------------- */
d80 1
a80 1
static void update_shift(int updown, int internal_code)
d82 2
a83 224
    int key = 0;
    switch (internal_code)
    {
    case 0x3B:
	key = KeyWatch_State_LEFT_CTRL_DOWN;
	break;
    case 0x4C:
	key = KeyWatch_State_LEFT_SHIFT_DOWN;
	break;
    case 0x58:
	key = KeyWatch_State_RIGHT_SHIFT_DOWN;
	break;
    case 0x5E:
	key = KeyWatch_State_LEFT_ALT_DOWN;
	break;
    case 0x60:
	key = KeyWatch_State_RIGHT_ALT_DOWN;
	break;
    case 0x61:
	key = KeyWatch_State_RIGHT_CTRL_DOWN;
	break;
    }

    if (key)
    {
	if (updown == EventV_Key_Up)
	    scan_shift_state &= ~key;
	else
	    scan_shift_state |=  key;
    }
}

static void add_entry(int flags, int scan_code, int key_code)
{
    key_event *k;

    flags |= scan_shift_state;

    if (scan_flags & KeyWatch_RegisterScan_MESSAGE)
    {
	/* send message or register callback not sure which */
	WimpMessage msg;

	msg.hdr.size = sizeof(msg.hdr) + sizeof(key_event);
	msg.hdr.action_code = KeyWatch_00;
	msg.hdr.your_ref = 0;

	k = (key_event *)&msg.data;
	k->flags = flags;
	k->scan_code = scan_code;
	k->key_code = key_code;

	_swix(TaskModule_SendMessage, _INR(0,5), 0, &msg, scan_task, 0, 0, 0);
    }
    else
    {
	k = &scan_key_table[scan_key_head];

	k->flags = flags;
	k->scan_code = scan_code;
	k->key_code = key_code;

	/* wrap wround at end of table */
	if (++scan_key_head == KEY_TABLE_SIZE)
	    scan_key_head = 0;

	/* if we're not reading keys out quick enough then drop the oldest item */
	if (scan_key_tail == scan_key_head)
	{
	    if (++scan_key_tail == KEY_TABLE_SIZE)
	    {
		scan_key_tail = 0;
		scan_overflows++;
	    }
	}
    }
}

static void key_transition(int updown, int internal_code)
{
    update_shift(updown, internal_code);

    if (internal_code < 0x70 ||
	(scan_flags & KeyWatch_RegisterScan_MOUSE))
    {
	if (scan_flags & KeyWatch_RegisterScan_PS2)
	{
	    internal_code = internal_to_ps2_code[internal_code & 0x7F]; /* mask bits to ensure safe lookup */
	    if (internal_code == 0)
		return;
	}
	
	add_entry(KeyWatch_Event_SCAN_CODE_VALID | (updown == EventV_Key_Up ? KeyWatch_Event_KEY_GOING_UP : 0),
		  internal_code, NULL_KEY);
    }

    if (updown == EventV_Key_Down)
	scan_last_down = internal_code;
}

static int key_input(int buffer_code)
{
    if (buffer_code != 0 || scan_last_key == 0)
    {
	add_entry(KeyWatch_Event_KEY_CODE_VALID |
		  (scan_last_down == NULL_KEY ? 0 : KeyWatch_Event_SCAN_CODE_VALID) |
		  (scan_last_key == 0 ? KeyWatch_Event_LAST_WAS_NUL : 0),
		  scan_last_down,
		  buffer_code);
    }
    
    scan_last_key = buffer_code;
    scan_last_down = NULL_KEY;

    return 1;
}

int eventv_veneer_handler(_kernel_swi_regs *r, void *pw)
{
    switch (r->r[0])
    {
    case EventV_Key:
	key_transition(r->r[1], r->r[2]);
	break; 

    case EventV_Input:
	if (r->r[1] == Buffer_Keyboard)
	{
	    /* process key */
	    key_input(r->r[2]);

	    /* remove key from buffer */
	    _swix(OS_Byte, _INR(0,1), 145, Buffer_Keyboard);
	}
	break;
    }

    return 1; /* don't claim the vector */
    pw = pw;
}

/* ---------------------------------------------------------------------------------------------------- */

static _kernel_oserror *kw_swi_register_scan(int flags, int task, void *pw)
{
    _kernel_oserror *e = NULL;

    /* for now only one claimant at a time for simplicity */
    if (eventv_count)
	e = makeerror(KW_ERR_ALREADY_REGISTERED);
    
    if (!e && eventv_count++ == 0)
    {
	e = _swix(OS_Claim, _INR(0,2), EventV, eventv_veneer, pw);
	if (!e) e = _swix(OS_Byte, _INR(0,1), OSByte_EnableEvent, EventV_Input);
	if (!e) e = _swix(OS_Byte, _INR(0,1), OSByte_EnableEvent, EventV_Key);
    }

    if (!e)
    {
	scan_flags = flags;
	scan_task = task;
    }
    
    return e;
}

static _kernel_oserror *kw_swi_deregister_scan(int flags, int task, void *pw)
{
    _kernel_oserror *e = NULL;

    if (scan_task != task)
	e = makeerror(KW_ERR_NOT_REGISTERED);
    
    if (!e && --eventv_count == 0)
    {
	e = _swix(OS_Byte, _INR(0,1), OSByte_DisableEvent, EventV_Input);
	if (!e) e = _swix(OS_Byte, _INR(0,1), OSByte_DisableEvent, EventV_Key);
	if (!e) e = _swix(OS_Release, _INR(0,2), EventV, eventv_veneer, pw);
    }

    if (!e)
    {
	scan_flags = 0;
	scan_task = NULL_TASK;
    }
    
    return e;
}

static _kernel_oserror *kw_swi_poll(int *pflags, int task, key_event **pbuf, int *pbuf_size, int *entry_size)
{
    _kernel_oserror *e = NULL;

    if (scan_task != task)
	e = makeerror(KW_ERR_NOT_REGISTERED);
    
    if (!e)
    {
	key_event *buf = *pbuf;
	int buf_size = *pbuf_size;
	    
	while (scan_key_tail != scan_key_head && buf_size >= sizeof(key_event))
	{
	    /* write out buffer entry */
	    *buf++ = scan_key_table[scan_key_tail];
	    buf_size -= sizeof(key_event);

	    /* wrap around to the start of the table */
	    if (++scan_key_tail == KEY_TABLE_SIZE)
		scan_key_tail = 0;
	}

	*pbuf = buf;
	*pbuf_size = buf_size;
	*entry_size = sizeof(key_event);

	*pflags = scan_overflows ? KeyWatch_Poll_HAD_OVERFLOW : 0;
	scan_overflows = 0;
    }
    return e;
}

/* ---------------------------------------------------------------------------------------------------- */
d85 57
a141 3
_kernel_oserror *kw_swi_handler(int swi_no, _kernel_swi_regs *r, void *private_word)
{
    _kernel_oserror *e = NULL;
d143 1
a143 28
    switch (swi_no)
    {
    case KeyWatch_Register - KeyWatch_00:
	e = kw_swi_register((void **)&r->r[0], private_word);
	break;

    case KeyWatch_Deregister - KeyWatch_00:
	e = kw_swi_deregister((void *)r->r[0], private_word);
	break;

    case KeyWatch_Version - KeyWatch_00:
	r->r[0] = FEATURES;
	r->r[1] = Module_VersionNumber;		/* from CMHG */
	r->r[2] = (int)Module_MinorVersion;	/* from VersionNum */
	break;

    case KeyWatch_RegisterScan - KeyWatch_00:
	e = kw_swi_register_scan(r->r[0], r->r[1], private_word);
	break;
	
    case KeyWatch_DeregisterScan - KeyWatch_00:
	e = kw_swi_deregister_scan(r->r[0], r->r[1], private_word);
	break;

    case KeyWatch_Poll - KeyWatch_00:
	e = kw_swi_poll(&r->r[0], r->r[1], (key_event **)&r->r[2], &r->r[3], &r->r[4]);
	break;
	
d145 4
a148 3
	e = makeerror(KW_ERR_BAD_SWI);
	break;
    }
d150 1
a150 1
    return e;
d157 1
a157 1
_kernel_oserror *kw_initialise(const char *cmd_tail, int podule_base, void *private_word)
d159 3
d164 17
a180 1
    memset(&scan_key_table[0], 0, sizeof(scan_key_table[0]) * KEY_TABLE_SIZE);
d190 20
a209 3
    if (keyv_count || eventv_count)
	return makeerror(KW_ERR_CANT_EXIT);
    return NULL;
a210 2

/* eof KeyWatch.c */
@


1.1.1.4
log
@Rejigged how PS/2 codes are handled and added a few more flags to RegisterScan

Version 0.03, 1.1.2.3. Tagged as 'KeyWatch-0_03-1_1_2_3'
@
text
@d36 2
a72 1
#define KeyWatch_Event_PS2_MULTI	(1<<4)
a83 2
#define KeyWatch_RegisterScan_BUFFER_CODES	(1<<3)
#define KeyWatch_RegisterScan_SCAN_CODES	(1<<4)
d87 3
a89 2
#define KeyWatch_PS2KEY_PRINT_SCREEN	0x01
#define KeyWatch_PS2KEY_BREAK		0x02
d134 1
a143 20
#if 1
/* This is the PC-XT scan code set */
static char internal_to_ps2_code[128] =
{
    0x01, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41,				/* Esc - F7 */
    0x42, 0x43, 0x44, 0x57, 0x58, 0x01, 0x46, 0x02,				/* F8 - Break */
    0x29, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,				/* ` - 7 */
    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, E(0x52),				/* 8 - INSERT */
    E(0x47), E(0x49), 0x45, E(0x35), 0x37, 0x2B, 0x0F, 0x10,			/* Home - Q */
    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,				/* W - O */
    0x19, 0x1A, 0x1B, 0x2B, E(0x53), E(0x4F), E(0x51), 0x47,			/* P - 7 */
    0x48, 0x49, 0x4A, 0x1D, 0x1E, 0x1F, 0x20, 0x21,				/* 8 - F */
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x1C,				/* G - ENTER */
    0x4B, 0x4C, 0x4D, 0X4E, 0x2A, 0x00, 0x2C, 0x2D,				/* 4 - X */
    0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,				/* C - / */
    0x36, E(0x48), 0x4F, 0x50, 0x51, 0x3A, 0x38, 0x39,				/* Shift R - SPACE */
    E(0x38), E(0x1D), E(0x4B), E(0x50), E(0x4D), 0x52, 0x53, E(0x1C)		/* Alt R - Enter */
};
#else
/* This is the AT-02 scan code set */
d147 1
a147 1
    0x0A, 0x01, 0x09, 0x78, 0x07, 0x01, 0x7E, 0x02,				/* F8 - Break */
a159 1
#endif
d167 7
d175 1
a175 1
    strcpy(global_error.errmess, errors[errnum - KW_ERR_BASE]);
a367 8
	int flags;

	/* get base flags */
	flags = KeyWatch_Event_SCAN_CODE_VALID;
	if (updown == EventV_Key_Up)
	    flags |= KeyWatch_Event_KEY_GOING_UP;

	/* translate internal scan code if necessary */
a369 4
	    /* two special case keys need another flag set - must do before code conversion! */
	    if (internal_code == 0x0D || internal_code == 0x0F)
		flags |= KeyWatch_Event_PS2_MULTI;

a370 2

	    /* if unused then ignore entirely */
d375 2
a376 14
	if (scan_flags & KeyWatch_RegisterScan_SCAN_CODES)
	{
	    if (scan_flags & KeyWatch_RegisterScan_PS2)
	    {
		if (internal_code & 0x80)
		    add_entry(flags, 0xE0, NULL_KEY);

		add_entry(flags, (internal_code &~ 0x80) | (updown == EventV_Key_Up ? 0x80 : 0), NULL_KEY);
	    }
	    else
	    {
		add_entry(flags, internal_code, NULL_KEY);
	    }
	}
a378 1
    /* update the last key down */
d409 1
a409 2
	if (r->r[1] == Buffer_Keyboard && 
	    (scan_flags & KeyWatch_RegisterScan_BUFFER_CODES))
d484 2
a485 2

	if (buf == NULL)
d487 3
a489 14
	    buf_size -= ((scan_key_head < scan_key_tail ? KEY_TABLE_SIZE : 0) + (scan_key_head - scan_key_tail)) * sizeof(key_event);
	}
	else
	{
	    while (scan_key_tail != scan_key_head && buf_size >= sizeof(key_event))
	    {
		/* write out buffer entry */
		*buf++ = scan_key_table[scan_key_tail];
		buf_size -= sizeof(key_event);

		/* wrap around to the start of the table */
		if (++scan_key_tail == KEY_TABLE_SIZE)
		    scan_key_tail = 0;
	    }
d491 3
a493 1
	    *pbuf = buf;
d496 1
d499 1
d501 1
a501 3

	if (buf)
	    scan_overflows = 0;
d510 1
a510 1
    _kernel_oserror *e = error_BAD_SWI;
a525 1
	e = NULL;
d538 4
@


1.1.1.5
log
@Fixed some of the PS/2 codes. Changed mechanism so that the real PS/2 style
code stream is output.

Version 0.03, 1.1.2.4. Tagged as 'KeyWatch-0_03-1_1_2_4'
@
text
@a26 1
#include "KeyWatch.h"
d36 7
d67 24
a128 1
static int scan_buffer_count = 0;			/* count of number of buffer event received between scans */
a143 1

a144 3
#define KEY_PRTSCR	"\xE0\x2A\xE0\x37"
#define KEY_BREAK	"\xE1\x1D\x45\xE1\x9D\xC5"

d148 1
a148 1
    0x42, 0x43, 0x44, 0x57, 0x58, 0x00, 0x46, 0x01,				/* F8 - Break */
d150 1
a150 1
    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x00, 0x0E, E(0x52),				/* 8 - INSERT */
d156 1
a156 1
    0x4B, 0x4C, 0x4D, 0X4E, 0x2A, 0x56, 0x2C, 0x2D,				/* 4 - X */
a160 1

a161 1

a162 3
#define KEY_PRTSCR	"\xE0\x12\xE0\x7C"
#define KEY_BREAK	"\x14\x77\xF0\x14\xF0\x77"

d166 1
a166 1
    0x0A, 0x01, 0x09, 0x78, 0x07, 0x00, 0x7E, 0x01,				/* F8 - Break */
d174 1
a174 1
    0x6B, 0x73, 0x74, 0x79, 0x12, 0x61, 0x1A, 0x22,				/* 4 - X */
a178 1

d188 1
a188 1
    strcpy(global_error.errmess, errors[errnum - KeyWatch_Error_BASE]);
d233 1
a233 1
	e = makeerror(KeyWatch_Error_TABLE_FULL);
d277 1
a277 1
	e = makeerror(KeyWatch_Error_BAD_POLLWORD);
a373 14
static void add_ps2(int flags, int code)
{
    if (code & 0x80)
    {
	add_entry(flags, 0xE0, NULL_KEY);
	code &= 0x7F;
    }

    if (flags & KeyWatch_Event_KEY_GOING_UP)
	code |= 0x80;
		
    add_entry(flags, code, NULL_KEY);
}

d378 2
a379 2
    if ((internal_code < 0x70 || (scan_flags & KeyWatch_RegisterScan_MOUSE)) && 
	(scan_flags & KeyWatch_RegisterScan_SCAN_CODES))
d391 1
a391 1
	    /* two special case keys */
d393 12
d406 2
a407 4
		const char *s = internal_code == 0x0D ? KEY_PRTSCR : KEY_BREAK;
		int c;
		while ((c = *s++) != 0)
		    add_entry(flags, c, NULL_KEY);
d409 1
a409 2
		/* internal_code = 0x100 + internal_to_ps2_code[internal_code]; */
		internal_code = NULL_KEY;
d413 1
a413 7
		internal_code = internal_to_ps2_code[internal_code & 0x7F]; /* mask bits to ensure safe lookup */

		/* if unused then ignore entirely */
		if (internal_code == 0)
		    internal_code = NULL_KEY;
		else
		    add_ps2(flags, internal_code);
a415 4
	else
	{
	    add_entry(flags, internal_code, NULL_KEY);
	}
a445 1
	scan_buffer_count = 0;
d449 2
a450 1
	if (r->r[1] == Buffer_Keyboard)
d452 2
a453 7
	    if (scan_flags & KeyWatch_RegisterScan_BUFFER_CODES)
	    {
		/* process key */
		key_input(r->r[2]);
		
		/* remove key from buffer */
		_swix(OS_Byte, _INR(0,1), 145, Buffer_Keyboard);
d455 2
a456 12
		scan_buffer_count++;
	    }
	    else if ((scan_flags & (KeyWatch_RegisterScan_SCAN_CODES | KeyWatch_RegisterScan_PS2)) ==
		     (KeyWatch_RegisterScan_SCAN_CODES | KeyWatch_RegisterScan_PS2))
	    {
		/* auto-repeat PS/2 scan code */
		if (scan_last_down != NULL_KEY && scan_buffer_count++ > 0)
		{
		    add_ps2(KeyWatch_Event_SCAN_CODE_VALID | KeyWatch_Event_KEY_GOING_UP, scan_last_down);
		    add_ps2(KeyWatch_Event_SCAN_CODE_VALID, scan_last_down);
		}
	    }
d473 1
a473 1
	e = makeerror(KeyWatch_Error_ALREADY_REGISTERED);
d496 1
a496 1
	e = makeerror(KeyWatch_Error_NOT_REGISTERED);
a508 3

	/* dispose of any pending keys */
	scan_key_head = scan_key_tail = 0;
d519 1
a519 1
	e = makeerror(KeyWatch_Error_NOT_REGISTERED);
d614 1
a614 1
	return makeerror(KeyWatch_Error_CANT_EXIT);
@


1.1.1.6
log
@Changed KeyWatch_Poll API to stop allow swallowing of buffer codes even when only using
scan code events.

Version 0.04, 1.1.2.5. Tagged as 'KeyWatch-0_04-1_1_2_5'
@
text
@d453 3
a467 4

	    /* remove key from buffer */
	    if (scan_flags & KeyWatch_RegisterScan_CONSUME_BUFFER)
		_swix(OS_Byte, _INR(0,1), 145, Buffer_Keyboard);
d528 1
a528 1
static _kernel_oserror *kw_swi_poll(int *pflags, int task, key_event **pbuf, int *pbuf_size, int *pnentries, int *entry_size)
a538 1
	int nentries;
d542 1
a542 2
	    nentries = (scan_key_head < scan_key_tail ? KEY_TABLE_SIZE : 0) + (scan_key_head - scan_key_tail);
	    buf_size = nentries * sizeof(key_event);
d546 1
a546 2
	    nentries = *pnentries;
	    while (scan_key_tail != scan_key_head && buf_size >= sizeof(key_event) && nentries > 0)
a550 1
		nentries--;
d556 2
a559 1
	*pbuf = buf;
a562 1
	*pnentries = nentries;
d602 1
a602 1
	e = kw_swi_poll(&r->r[0], r->r[1], (key_event **)&r->r[2], &r->r[3], &r->r[4], &r->r[1]);
@


1.1.1.7
log
@Added KeyWatchForceClose command to clean up if a client crashes.

Version 0.05, 1.1.2.7. Tagged as 'KeyWatch-0_05-1_1_2_7'
@
text
@a25 1
#include "VersionNum"	/* must be before KeyWatchHd.h to avoid Module_Date clash */
d29 2
a63 2
#define NOT_USED(a)		a = a

a196 1
    NOT_USED(pw);
a526 1
    NOT_USED(flags);
a624 3
    NOT_USED(cmd_tail);
    NOT_USED(podule_base);
    NOT_USED(private_word);
a634 3
    NOT_USED(fatal);
    NOT_USED(podule);
    NOT_USED(private_word);
a635 21

_kernel_oserror *kw_commands(const char *arg_string, int argc, int cmd_no, void *private_word)
{
    switch (cmd_no)
    {
    case CMD_KeyWatchForceClose:
	if (eventv_count)
	    (void)kw_swi_deregister_scan(0, scan_task, private_word);
	
	if (keyv_count)
	{
	    (void)_swix(OS_Release, _INR(0,2), KeyV, keyv_veneer, private_word);
	    keyv_count = 0;
	    memset(&pollword_table[0], 0, sizeof(pollword_table[0]) * PW_TABLE_SIZE);
	}
	break;
    }
    return NULL;
    NOT_USED(argc);
    NOT_USED(arg_string);
}
@


1.1.1.8
log
@ Changed the auto-repeat detection code to ignore 0 buffer codes. This means
that keys that generate two bytes (eg pound) don't end up always generating
an auto-repeat event as soon as they are pressed.

Version 0.06, 1.1.2.8. Tagged as 'KeyWatch-0_06-1_1_2_8'
@
text
@d24 1
a24 1
#include "tboxlibs/wimp.h"
a29 8
#include "debug/remote.h"

#ifdef REMOTE_DEBUG
#define TRACE(a) debug_printf a
#else
#define TRACE(a)
#endif

a101 4
#ifdef REMOTE_DEBUG
debug_session *db=NULL;
#endif

d123 13
a135 14
    0x01, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41,				/* 0x00: Esc - F7 */
    0x42, 0x43, 0x44, 0x57, 0x58, 0x00, 0x46, 0x01,				/* 0x08: F8 - Break */
    0x29, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,				/* 0x10: ` - 7 */
    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x00, 0x0E, E(0x52),				/* 0x18: 8 - INSERT */
    E(0x47), E(0x49), 0x45, E(0x35), 0x37, 0x2B, 0x0F, 0x10,			/* 0x20: Home - Q */
    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,				/* 0x28: W - O */
    0x19, 0x1A, 0x1B, 0x2B, E(0x53), E(0x4F), E(0x51), 0x47,			/* 0x30: P - 7 */
    0x48, 0x49, 0x4A, 0x1D, 0x1E, 0x1F, 0x20, 0x21,				/* 0x38: 8 - F */
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x1C,				/* 0x40: G - ENTER */
    0x4B, 0x4C, 0x4D, 0X4E, 0x2A, 0x56, 0x2C, 0x2D,				/* 0x48: 4 - X */
    0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,				/* 0x50: C - / */
    0x36, E(0x48), 0x4F, 0x50, 0x51, 0x3A, 0x38, 0x39,				/* 0x58: Shift R - SPACE */
    E(0x38), E(0x1D), E(0x4B), E(0x50), E(0x4D), 0x52, 0x53, E(0x1C),		/* 0x60: Alt R - Enter */
    				/* 0x68: WinL, WinR, Menu, NoCon, Con, Kana, backslashR */
d149 1
a149 1
    0x3E, 0x46, 0x45, 0x4E, 0x55, 0x6A, 0x66, E(0x70),				/* 8 - INSERT */
d158 1
a158 2
    E(0x11), E(0x14), E(0x6B), E(0x72), E(0x74), 0x70, 0x71, E(0x5A),		/* Alt R - Enter */
    E(0x1F), E(0x27), E(0x2F), 0x67, 0x64, 0x13, 0x51				/* 0x68: WinL, WinR, Menu, NoCon, Con, Kana, backslashR */
a442 2
	TRACE((db,     "key_transition: %02x %c\n", r->r[2], r->r[1] == EventV_Key_Down ? 'D' : 'U'));

a449 4
	    int key = r->r[2];
	    
	    TRACE((db,     "buffer_input  : %02x\n", key));

d453 1
a453 1
		key_input( key );
d460 2
a461 4
		/* auto-repeat PS/2 scan code
		 * only if we've had a key down, and a key input, and it wasn't a null character
		 */
		if (scan_last_down != NULL_KEY && scan_last_key != 0 && scan_buffer_count++ > 0)
a462 2
		    TRACE((db, "auto-repeat   : %d\n", scan_last_down));

a465 2

		scan_last_key = key;
d470 1
a470 7
	    {
		int flags;

		_swix(OS_Byte, _INR(0,1) | _OUT(_FLAGS), 145, Buffer_Keyboard, &flags);

		TRACE((db, "consume_key   : %d\n", flags & _C ? 0 : 1));
	    }
a484 2
    TRACE((db, "register_scan: flags %x task %x\n", flags, task));

a499 1
	scan_last_key = NULL_KEY;
a501 2
    TRACE((db, "register_scan: returns e %x\n", e));

a508 2
    TRACE((db, "deregister_scan: flags %x task %x\n", flags, task));

a527 2
    TRACE((db, "deregister_scan: returns e %x\n", e));

a535 2
    //TRACE((db, "poll: task %08x buf %p bufsize %d\n", task, *pbuf, *pbuf_size));

a574 3

    //TRACE((db, "poll: out          buf %p bufsize %d entry_siuze %d flags %x entries %d\n", *pbuf, *pbuf_size, *entry_size, *pflags, *pnentries));

a622 3
    remote_debug_open("KeyWatch",&db);
    TRACE((db, "Module initialisation called"));

a639 4

    TRACE((db,"(5) finalisation"));
    remote_debug_close(db);

@


1.1.1.9
log
@Added the Windows Menu key and fake versions of the left and right Windows keys.
Added a flag to say that a byte was preceded by the PS/2 E0 extension byte.

Version 0.07, 1.1.2.9. Tagged as 'KeyWatch-0_07-1_1_2_9'
@
text
@d148 1
a148 1
    E(0x7E), E(0x7F), E(0x5D), 0x00, 0x00, 0x00, 0x00, 0x00		        /* 0x68: WinL, WinR, Menu, NoCon, Con, Kana, backslashR */
a150 2
/* Note WinL and WinR above are not the correct values, they are fakes known only by ICAClient */

a376 3

	/* mark the data code as being part of a PS2 extended code */
	flags |= KeyWatch_Event_PS2_EXTENDED;
@


1.1.1.10
log
@Inclusion of remote debug header, call to remote_debug_open and call
to remote_debug_close only happens if creating a debug build (avoids
need for debug library for non-debug versions).
@
text
@d30 2
a32 1
#include "debug/remote.h"
d674 1
a674 3
    #ifdef REMOTE_DEBUG
      remote_debug_open("KeyWatch",&db);
    #endif
d696 1
a696 3
    #ifdef REMOTE_DEBUG
      remote_debug_close(db);
    #endif
@


1.1.1.11
log
@Added a new SWI KeyWatch_Ignore which will ignore the next key press received by KeyWatch.
@
text
@d30 1
a31 2

#ifdef REMOTE_DEBUG
d40 1
a42 3
#define FALSE			0
#define TRUE			1

a108 2
static int ignore_next_key = FALSE;			/* Ignore next key press - set by KeyWatch_Ignore */

a197 5
    if ( ignore_next_key == TRUE)
    {
   	ignore_next_key = FALSE;
 	return 1; /* don't claim the vector and don't do anything else */
    }
d229 1
a229 1

d286 1
a286 1

d385 1
a385 1

d393 1
a393 1
    if ((internal_code < 0x70 || (scan_flags & KeyWatch_RegisterScan_MOUSE)) &&
d449 1
a449 1

d465 1
a465 1
	break;
d471 1
a471 1

d478 1
a478 1

d526 1
a526 1

d540 1
a540 1

d554 1
a554 1

d570 1
a570 1

d585 1
a585 1

a627 9
static _kernel_oserror *kw_swi_ignore(int *pflags)
{
    _kernel_oserror *e = NULL;

    ignore_next_key = TRUE;
    
    return e;
}

d654 1
a654 1

a661 4

    case KeyWatch_Ignore - KeyWatch_00:
	e = kw_swi_ignore(&r->r[0]);
	break;
d671 1
a671 1
_kernel_oserror *kw_initialise(char *cmd_tail, int podule_base, void *private_word)
d673 3
a675 1
    remote_debug_open("KeyWatch",&db);
d697 3
a699 1
    remote_debug_close(db);
d707 1
a707 1
_kernel_oserror *kw_commands(char *arg_string, int argc, int cmd_no, void *private_word)
d714 1
a714 1

@

head	1.28;
access;
symbols
	BASIC-1_75:1.28
	BASIC-1_74:1.28
	BASIC-1_73:1.28
	BASIC-1_72:1.28
	BASIC-1_71:1.27
	BASIC-1_70:1.27
	BASIC-1_69:1.27
	BASIC-1_68:1.27
	BASIC-1_67:1.27
	BASIC-1_66:1.26
	BASIC-1_65:1.26
	BASIC-1_64:1.26
	BASIC-1_63:1.26
	BASIC-1_62:1.26
	BASIC-1_61:1.25
	BASIC-1_60:1.25
	BASIC-1_59:1.24
	BASIC-1_58:1.23
	BASIC-1_57-pre4:1.21
	BASIC-1_57:1.22
	BASIC-1_57-pre3:1.20
	BASIC-1_57-pre2:1.19
	BASIC-1_57-pre1:1.18
	BASIC-1_56:1.17
	BASIC-1_55:1.17
	BASIC-1_54:1.17
	BASIC-1_53:1.12
	BASIC-1_52:1.12
	BASIC-1_51:1.12
	BASIC-1_50:1.12
	BASIC-1_49:1.11
	BASIC-1_48:1.11
	BASIC-1_47:1.11
	BASIC-1_46:1.11
	BASIC-1_45:1.11
	BASIC-1_44:1.11
	BASIC-1_43:1.11
	BASIC-1_42:1.11
	BASIC-1_41:1.11
	BASIC-1_40:1.11
	BASIC-1_39:1.10
	BASIC-1_37:1.10
	RO_5_07:1.10
	BASIC-1_36:1.10
	BASIC-1_35:1.10
	BASIC-1_34:1.10
	BASIC-1_33:1.9
	BASIC-1_32:1.8
	BASIC-1_31:1.7
	BASIC-1_30:1.7
	BASIC-1_29:1.6
	BASIC-1_28:1.6
	BASIC-1_27:1.6
	BASIC-1_26:1.5
	BASIC-1_25:1.4
	BASIC-1_24:1.3
	BASIC-1_23:1.1;
locks; strict;
comment	@# @;


1.28
date	2017.09.07.19.34.40;	author rsprowson;	state Exp;
branches;
next	1.27;
commitid	ulAIao6m9bYzGi6A;

1.27
date	2017.06.03.22.30.33;	author jlee;	state Exp;
branches;
next	1.26;
commitid	3Iuze3DCMuQaKYTz;

1.26
date	2016.05.28.19.06.11;	author jlee;	state Exp;
branches;
next	1.25;
commitid	ve1nDur0pc1xxh8z;

1.25
date	2015.04.14.06.56.13;	author alees;	state Exp;
branches;
next	1.24;
commitid	HlqkBsA4wuh7Gwhy;

1.24
date	2014.09.24.21.07.30;	author bavison;	state Exp;
branches;
next	1.23;
commitid	qciAFgpcX9uOSDRx;

1.23
date	2014.04.29.13.00.01;	author bavison;	state Exp;
branches;
next	1.22;
commitid	kblWeZfq7rQvWzyx;

1.22
date	2013.12.01.18.09.39;	author rsprowson;	state Exp;
branches;
next	1.21;
commitid	g83hl4RCFV1Crsfx;

1.21
date	2013.12.01.18.00.39;	author rsprowson;	state Exp;
branches;
next	1.20;
commitid	Kkz46F2OuI63nsfx;

1.20
date	2013.12.01.17.51.03;	author rsprowson;	state Exp;
branches;
next	1.19;
commitid	wLaKLb6ucJVnksfx;

1.19
date	2013.12.01.17.39.51;	author rsprowson;	state Exp;
branches;
next	1.18;
commitid	DTgfZ9WqDVpZgsfx;

1.18
date	2013.12.01.17.23.40;	author rsprowson;	state Exp;
branches;
next	1.17;
commitid	iG291GP27DoPasfx;

1.17
date	2013.04.26.23.53.33;	author bavison;	state Exp;
branches;
next	1.16;
commitid	mepEMy92GBY6olNw;

1.16
date	2013.04.26.23.50.19;	author bavison;	state Exp;
branches;
next	1.15;
commitid	5fmgResEdga1nlNw;

1.15
date	2013.04.26.23.46.54;	author bavison;	state Exp;
branches;
next	1.14;
commitid	72Ql4NVxJYJPllNw;

1.14
date	2013.04.26.23.43.14;	author bavison;	state Exp;
branches;
next	1.13;
commitid	ji1AQywLsNtAklNw;

1.13
date	2013.04.26.23.31.34;	author bavison;	state Exp;
branches;
next	1.12;
commitid	j9s7yCUXNRcyglNw;

1.12
date	2012.03.07.23.34.25;	author jlee;	state Exp;
branches;
next	1.11;
commitid	mqtCES9yyNSyC0Wv;

1.11
date	2009.04.24.00.27.15;	author srevill;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.02.19.57.21;	author bavison;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.02.19.50.02;	author bavison;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.18.12.27.18;	author kbracey;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.23.15.48.33;	author srevill;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.11.09.31.11;	author sbrodie;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.20.09.47.36;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.26.09.49.30;	author dellis;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.17.01.03.53;	author srevill;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.16.19.11.51;	author srevill;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.14.20.00.31;	author srevill;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Automatically pick the best FP model for the hosting CPU
Have BASIC V pick either BASICVFP or BASIC VI as appropriate for the current CPU, so if there's VFP hardware don't emulate everything as FPA opcodes.
The BASIC64 command (moved to BASIC V) will now automatically RMEnsure then enter the respective module. If there's something depending on the internal workings of BASIC VI and wishes to explicitly select that even when VFP is present a new command, *BASICFPA, forces BASIC VI to start.
By having BASIC V manage this selection we in effect remove the requirement to remember to RMEnsure the floating point version, which is usually either forgotten about or wrong anyway.
Compatibility wise
  RISC OS 5 includes all 3 variants (2 if no VFP) and will adopt the new logic.
  Existing RISC OS 5 stable releases have always included BASIC V and VI, so will work as before (through emulating FPA).
  Soft loaded modules inside !System will be handled by a disc based update.
Changed files
  CmdHelp: adds the new BASIC64 help/syntax message
  Basic.s: qualify the FPA version in it's startup banner
  ModHead.s: add the new selection logic, and move the 'VFP' help to be a suffix so the module names line up nicely in *Modules again
Tested in both ROM and disc based guises on ARMs with and without VFP hardware.

Version 1.72. Tagged as 'BASIC-1_72'
@
text
@; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;> Basic

   [ :DEF: VFPAssembler
VFPDataResourceFile
        = "Resources:$.Resources.BASIC.VFPData",0
        ALIGN
   ]

MODULEMAIN
        WritePSRc USR_mode,R1           ; IRQs+FIQs on, USR26/32 mode
        SWI     OS_GetEnv
      [ FPOINT=2
        MOV     R2,R1
        MOV     R0,#VFPSupport_Context_UserMode+VFPSupport_Context_AppSpace
        MOV     R1,#32
        SWI     XVFPSupport_CheckContext
        MOVVS   R0,#VFPSupport_Context_UserMode+VFPSupport_Context_AppSpace
        MOVVS   R1,#16                  ; 32 registers not available, try 16
        SWIVS   VFPSupport_CheckContext
        MOV     R6,R0
        MOV     R7,R1
        SUB     R1,R2,R0
        SUB     R1,R1,#VARS
        SUBS    R1,R1,#VFPCONTEXT+256
      |
        SUB     R1,R1,#VARS
        SUBS    R1,R1,#FREE+256
      ]
        BPL     MAIN
        ADR     R0,SEVEREERROR
        MOV     R1,#0                   ;global messages
        MOV     R2,#0                   ;internal buffer
        SWI     XMessageTrans_ErrorLookup
        SWI     OS_GenerateError
        SWI     OS_Exit
SEVEREERROR
        DCD     ErrorBase_BASIC + &FF
        DCB     "NoStore",0
        ALIGN

OSESCR  MOV     R11,R11,LSL #1
        AND     R11,R11,#&80
        MOV     R12,#VARS
        STRB    R11,[R12,#ESCFLG]
OSESCRT MOV     PC,R14
OSERRR                                 ;called by System Error Handler
        MOV     R14,#VARS
        ; Additional code to recover r12 after error IF it was saved
        LDRB    R14,[R14,#MEMM]        ;get MEMM flags
        TST     R14,#2                 ;is r12 saved flag on?
        MOV     R14,#VARS              ;get value of ARGP (again)
        LDRNE   LINE,[R14,#R12STORE]   ;yes, so safe to recover r12
        ADD     R14,R14,#STRACC        ;used for error buffer
        ADD     R14,R14,#4             ;skip PC to -> error number
        B       MSGERR
OSUPCR  CMP     R0,#256
        MOVNE   PC,R14
PUTBACKHAND
        STMFD   SP!,{R0-R3,R14}
        LDR     R1,[R12,#TRACEFILE-OLDERR] ;tracefile handle
        TEQ     R1,#0
        MOV     R0,#0
        STR     R0,[R12,#TRACEFILE-OLDERR] ;kill handle!
        SWINE   XOS_Find
      [ FPOINT=2
        LDR     R0,=VFPCONTEXT-OLDERR
        ADD     R0,R12,R0
        MOV     R1,#0
        SWI     XVFPSupport_DestroyContext
      ]
        MOV     R0,#6
        LDMIA   R12!,{R1,R2,R3}
        SWI     XOS_ChangeEnvironment
        MOV     R0,#9
        LDMIA   R12!,{R1,R2}
        SWI     XOS_ChangeEnvironment
        MOV     R0,#11
        LDMIA   R12!,{R1,R2}
        SWI     XOS_ChangeEnvironment
        MOV     R0,#16
        LDMIA   R12!,{R1,R2}
        SWI     XOS_ChangeEnvironment
        LDMFD   SP!,{R0-R3,PC}

        GBLL    ONLYEMPTY
ONLYEMPTY SETL  {FALSE}

MOVEMEMORY
        TEQ     R0,#0                   ;ignore grows (ie ok to do)
        MOVPL   PC,R14
        STMFD   SP!,{R0,R2-R8,R14}
 [ {FALSE}
        SWI     OS_WriteS
        =       "Service_Memory(",0
        MOV     R1,#VARS+STRACC
        ADD     R1,R1,#128
        MOV     R2,#128
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_WriteI+")"
        SWI     OS_NewLine
;       MOV     R1,#0
;       LDMFD   SP!,{R0,R2-R8,PC}
 ]
        MOV     ARGP,#VARS
        LDRB    R0,[ARGP,#MEMM]
        LDR     R1,[ARGP,#INSTALLLIST]
        LDR     R4,[ARGP,#MEMLIMIT]
        LDR     R5,[ARGP,#HIMEM]
        ; Change from MEMM as a byte flag x01 to a bit flag x01
        TST     R0,#1                   ;is "move memory" *bit* set?
        MOVEQ   R1,#0                   ;no
        LDMEQFD SP!,{R0,R2-R8,PC}       ;if not, refuse move
        TEQ     R1,#0                   ;any installed libraries?
        MOVNE   R1,#0                   ;no
        LDMNEFD SP!,{R0,R2-R8,PC}       ;if not, refuse move
        MOV     R0,#14
        MOV     R1,#0
        MOV     R2,#0
        MOV     R3,#0
        SWI     XOS_ChangeEnvironment   ;read end of application space
        TEQ     R1,R4                   ;are we using whole application space?
        TEQEQ   R1,R5                   ;and is HIMEM at the top of it?
        MOVNE   R1,#0
        LDMNEFD SP!,{R0,R2-R8,PC}       ;if not, not in a position to surrender memory.
        LDR     R4,[ARGP,#DIMLOCAL]     ;are there any DIM LOCALs in use?
        SUB     SP,SP,#4
        STMIA   SP,{SP}^                ;get user mode stack pointer
        TEQ     R4,#0
        MOVNE   R1,#0                   ;yes. refuse to move the stack
        LDR     R5,[SP],#4
        LDMNEFD SP!,{R0,R2-R8,PC}
        LDR     R4,[ARGP,#HIMEM]
        SUBS    R5,R4,R5                ;amount of space on stack
 [ ONLYEMPTY
        MOVNE   R1,#0
        LDMNEFD SP!,{R0,R2-R8,PC}       ;if stack not empty, refuse
 ]
        LDR     R6,[ARGP,#FSA]
        ADD     R2,R6,#1024
        ADD     R2,R2,R5                ;FSA+1024+amount of space on stack
        LDR     R14,[SP,#0]
        ADDS    R0,R1,R14               ;new end address
        MOVMI   R1,#0                   ;if end address is negative, we've wrapped below 0,
        LDMMIFD SP!,{R0,R2-R8,PC}       ; or gone higher than we cancope with
MOVEMEMORYOK
        SUB     R7,R0,#&8000            ;new slot
        CMP     R2,R0
        MOVHS   R1,#0
        LDMHSFD SP!,{R0,R2-R8,PC}       ;if going too small, refuse
        WritePSRc USR_mode,R3           ;change down to user mode (is this safe???)
;first move the stack down
 [ :LNOT:ONLYEMPTY
; code lifted from ENDCHANGE1 in Stmt
MOVEMEM1
        LDR     R3,[SP],#4
        STR     R3,[R6],#4              ;R6=FSA
        CMP     SP,R4                   ;R4=HIMEM
        BCC     MOVEMEM1
 ]
;change memory size
        SUB     R7,R0,SP                ;remember difference - how far the world moved!
        MOV     SP,R0
        STR     SP,[ARGP,#MEMLIMIT]
        STR     SP,[ARGP,#HIMEM]
;move stack back up again
 [ :LNOT:ONLYEMPTY
        LDR     R1,[ARGP,#FSA]
MOVEMEM2
        LDR     R3,[R6,#-4]!
        STR     R3,[SP,#-4]!
        CMP     R6,R1
        BHI     MOVEMEM2
;patch self references on the stack
        ADD     R4,ARGP,#LOCALARLIST-4
        LDR     R0,[ARGP,#ERRSTK]
        ADD     R0,R0,R7
        STR     R0,[ARGP,#ERRSTK]
MOVEMEMLOCALAR
        LDR     R3,[R4,#4]              ;next field
        TEQ     R3,#0
        BEQ     MOVEMEMLOCALARDONE
        ADD     R3,R3,R7                ;alter reference to stack
        STR     R3,[R4,#4]
        MOV     R4,R3
        LDR     R5,[R4,#8]              ;address of owner
        LDR     R6,[R5]
        ADD     R6,R6,R7                ;move owner's idea of where we are
        ADD     R1,R4,#16               ;check it's pointing at us
        CMP     R6,R1
        STREQ   R6,[R5]
        B       MOVEMEMLOCALAR
MOVEMEMLOCALARDONE
 ]
        SWI     OS_EnterOS
        MOV     R1,#Service_Memory      ;not claimed
        LDMFD   SP!,{R0,R2-R8,PC}

OSQUITR LDR     R1,[R12,#TRACEFILE-OLDERR] ;tracefile handle
        TEQ     R1,#0
        MOV     R0,#0
        STR     R0,[R12,#TRACEFILE-OLDERR] ;kill handle!
        SWINE   XOS_Find                   ;close
      [ FPOINT=2
        LDR     R0,=VFPCONTEXT-OLDERR
        ADD     R0,R12,R0
        MOV     R1,#0
        SWI     XVFPSupport_DestroyContext
      ]
        MOV     R0,#6
        LDMIA   R12!,{R1,R2,R3}
        SWI     XOS_ChangeEnvironment
        MOV     R0,#9
        LDMIA   R12!,{R1,R2}
        SWI     XOS_ChangeEnvironment
        MOV     R0,#11
        LDMIA   R12!,{R1,R2}
        SWI     XOS_ChangeEnvironment
        MOV     R0,#16
        LDMIA   R12!,{R1,R2}
        SWI     XOS_ChangeEnvironment
        ASSERT  OS_Exit_ABEX = OLDERR + 9*4
        LDMIA   R12!,{R1,R2}
        ADR     R0,EXITERR
        SWI     OS_Exit
MYNAME  =       "ARW!"
EXITERR DCD     ErrorBase_BASIC + &FE
        DCB     "BASIC program exceeded return code limit",0
        ALIGN
        LTORG
MAIN    MOV     ARGP,#VARS
        ;Create the SWI 0              ;MOV PC, R14 in the SWICODE data area
        ;and    then do a SYNCHRONISECODEAREAS, ranged.
        MOV     R0, #&EF000000         ;SWI 0
        LDR     R2, OSESCRT            ;A handy MOV PC,LR
        ADD     R1, ARGP, #SWICODE
        STMIA   R1,{R0,R2}
        ADD     R2, R1, #8             ;Size of SWICODE area
        MOV     R0, #1
        SWI     XOS_SynchroniseCodeAreas
 [ FPOINT=1 :LOR: FPOINT=2             ;only necessary for FPOINT=2 since we still rely on FPA for some ops
        MOV     R0,#&70000
        WFS     R0
 ]
 [ :DEF: VFPAssembler
        ; Find the VFP/NEON assembler data tables
        ; Deliberately not using X SWIs; the file should exist!
        MOV     R0,#&4F
        ADR     R1,VFPDataResourceFile
        SWI     OS_Find
        MOV     R3,R0
        MOV     R1,R0
        MOV     R0,#21
        SWI     OS_FSControl
        STR     R1,[ARGP,#VFPTABLES]
        MOV     R0,#0
        MOV     R1,R3
        SWI     OS_Find
 ]
 [ FPOINT=2
        ; Set up VFP context
        MOV     R0,#VFPSupport_Context_UserMode+VFPSupport_Context_AppSpace+VFPSupport_CreateContext_Activate
        MOV     R1,R7
        ADD     R2,ARGP,#VFPCONTEXT
        MOV     R3,#0
        SWI     VFPSupport_CreateContext
        ; Check for interesting features
        MOV     R0,#VFPSupport_Features_Misc
        SWI     XVFPSupport_Features
        ASSERT  VFPSupport_MiscFeature_VFPVectors_HW = VFPFLAG_Vectors
        ASSERT  VFPFLAG_Vectors < 4 ; if we got back an error pointer, we want the flag to be zero
        AND     R7,R0,#VFPFLAG_Vectors
        MOV     R0,#VFPSupport_Features_SystemRegs
        SWI     VFPSupport_Features ; No X bit, this reason code has been around forever
        TST     R2,#&F000
        ORRNE   R7,R7,#VFPFLAG_NEON
        STR     R7,[ARGP,#VFPFLAGS]
 ]
        ADRL    R0,MSGATLINE
        STR     R0,[ARGP,#ERRXLATE]
        ADD     R9,ARGP,#OLDERR
        MOV     R0,#6
        ADR     R1,OSERRR
        MOV     R2,#0
        ADD     R3,ARGP,#STRACC
        SWI     XOS_ChangeEnvironment
        STMIA   R9!,{R1,R2,R3}
        MOV     R0,#9
        ADR     R1,OSESCR
        MOV     R2,#0
        SWI     XOS_ChangeEnvironment
        STMIA   R9!,{R1,R2}
        MOV     R0,#11
        ADR     R1,OSQUITR
        ADD     R2,ARGP,#OLDERR
        SWI     XOS_ChangeEnvironment
        STMIA   R9!,{R1,R2}
        MOV     R0,#16
        ADR     R1,OSUPCR
        ADD     R2,ARGP,#OLDERR
        SWI     XOS_ChangeEnvironment
        STMIA   R9!,{R1,R2}
 [ FPOINT=2
        ADD     R0,ARGP,#VFPCONTEXT
        ADD     R0,R0,R6
        STR     R0,[ARGP,#FREEPTR]
 |
        ADD     R0,ARGP,#FREE          ;lomem
 ]
        STR     R0,[ARGP,#PAGE]
        SWI     OS_GetEnv
        MOV     SP,R1                  ;get himem limit
        STR     SP,[ARGP,#HIMEM]
        STR     SP,[ARGP,#MEMLIMIT]
        MOV     R0,#0
        STR     R0,[ARGP,#ERRLIN]
        STR     R0,[ARGP,#ERRNUM]
        STR     R0,[ARGP,#ESCWORD]
        STR     R0,[ARGP,#LOCALARLIST]
        STR     R0,[ARGP,#INSTALLLIST]
        STR     R0,[ARGP,#TRACEFILE]
        STR     R0,[ARGP,#TALLY]
        STR     R0,[ARGP,#DIMLOCAL]
        STRB    R0,[ARGP,#LISTOP]
        STRB    R0,[ARGP,#MEMM]
        MVN     R0,#0
        STR     R0,[ARGP,#WIDTHLOC]
        STRB    R0,[ARGP,#BYTESM]
        MOV     R0,#10
        ORR     R0,R0,#&900
        STR     R0,[ARGP,#INTVAR]      ;set @@%
        LDR     R0,[ARGP,#SEED]
        LDRB    R1,[ARGP,#SEED+4]
        ORRS    R0,R0,R1,LSL #31       ;gets bottom bit
        LDREQ   R0,MYNAME
        STREQ   R0,[ARGP,#SEED]
        ADR     R0,REPSTR
        ADD     R2,ARGP,#ERRORS
ENTRYL  LDRB    R1,[R0],#1
        STRB    R1,[R2],#1
        TEQ     R1,#0
        BNE     ENTRYL
        BL      FROMAT
        BL      SETFSA
        BL      ORDERR
        ADD     LINE,ARGP,#STRACC
        LDR     SP,[ARGP,#HIMEM]
        MOV     R0,#0
;to stop pops getting carried away
        STMFD   SP!,{R0-R9}
        STR     SP,[ARGP,#ERRSTK]
;see if there's a name waiting to be read in
        SWI     OS_GetEnv
        ADD     R3,ARGP,#CALLEDNAME
ENTRE1  LDRB    R2,[R0],#1
        STRB    R2,[R3],#1
        TEQ     R2,#0
        BEQ     CLRSTKTITLE
        CMP     R2,#" "
        BHI     ENTRE1
        MOV     R2,#0
        STRB    R2,[R3,#-1]
ENTRE2  LDRB    R2,[R0],#1
        CMP     R2,#" "
        BEQ     ENTRE2
        MOV     R9,#2                  ;set to chain
        CMP     R2,#"-"
        BEQ     ENTRYKEYW
        BL      TITLE
        TEQ     R2,#0
        BEQ     CLRSTK
        TEQ     R2,#"@@"
        BNE     ENTRYF
        MOV     R9,#0                  ;no chain
ENTRYCONT
        BL      RDHEX                  ;incore text file
        MOV     R6,R5
        TEQ     R2,#","
        BNE     BADIPHEX
        BL      RDHEX
        TEQ     R2,#0
        BNE     BADIPHEX
        CMP     R5,R6
        BLS     BADIPHEX
        MOV     R1,R6
        MOV     R7,R6
        BL      LOADFILEINCORE
ENTRYFINAL
        TST     R9,#2
        BEQ     FSASET
        LDRB    R0,[ARGP,#CALLEDNAME]
        TEQ     R0,#0
        BNE     RUNNER                 ;not QUIT so just run
 [ CHECKCRUNCH=1
        BL      CRUNCHCHK
        BEQ     RUNNER
 ]
        MOV     R0,#SAFECRUNCH
        LDR     R1,[ARGP,#PAGE]
        BL      CRUNCHROUTINE
        STR     R2,[ARGP,#TOP]
        B       RUNNER
 [ CHECKCRUNCH=1
CRUNCHCHK
        STMFD   SP!,{R0,R1,R2,R3,R4,R14}
        ADR     R0,CRUNCHSTR
        MOV     R1,#-1
        MOV     R2,#-1
        MOV     R3,#0
        MOV     R4,#0
        SWI     XOS_ReadVarVal
        TEQ     R2,#0                  ;if zero, variable DOES NOT exist (EQ status)
        LDMFD   SP!,{R0,R1,R2,R3,R4,PC}
CRUNCHSTR
        =       "BASIC$$Crunch"
        =       0
        ALIGN
 ]
TITLE   STMFD   SP!,{R0-R12,R14}
        SWI     OS_WriteS
REPSTR  =       "ARM BBC BASIC V"
 [ FPOINT=1
        =       "I (FPA)"
 ELIF FPOINT=2
        =       "I (VFP)"
 ]
        =       " (C) Acorn 1989",10,13,0
 [ RELEASEVER=0
        SWI     OS_WriteS
        =       " a ",0
        BL      PATOUT
        =       &3F,&61,&D1,&BF,&B0,&B9,&B6,&E2
        =       &00,&80,&80,&3C,&47,&C6,&CE,&78
        =       &00,&00,&1E,&33,&73,&3F,&03,&06
        =       &00,&1E,&33,&3E,&F8,&0F,&00,&00
        =       &01,&07,&0C,&38,&E0,&80,&00,&00
        =       &C0,&60,&20,&00,&00,&00,&00,&00
        SWI     OS_WriteS
        =       "prog",10,13,0
 ]
        LDR     R1,[ARGP,#HIMEM]
        LDR     R0,[ARGP,#PAGE]
        ADD     R0,R0,#4               ;to agree with value for END (=LOMEM)
        SUB     R1,R1,R0
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       10,13,"Starting with ",0
        MOV     R0,R1
        MOV     R7,#0
        BL      CARDINALPRINT
        SWI     OS_WriteS
        =       " bytes free.",10,13,0
        BL      NLINE
 |
        MOV     R0,#22
        BL      MSGPRNCXX
 ]
        LDMFD   SP!,{R0-R12,PC}
ENTRYKEYW
        BL      RDCOMCH
        CMP     R2,#"H"
        BEQ     ENTRYKEYW2
        CMP     R2,#"L"
        BEQ     ENTRYKEYW3
        CMP     R2,#"Q"
        BEQ     ENTRYKEYW4
        CMP     R2,#"C"
        BL      RDCOMCHER
        CMP     R2,#"H"
        BL      RDCOMCHER
        CMP     R2,#"A"
        BL      RDCOMCHER
        CMP     R2,#"I"
        BL      RDCOMCHER
        CMP     R2,#"N"
        BL      RDCOMCHER
        CMP     R2,#" "
        BNE     ENTRYUNK
ENTRYCHAIN
        BL      TITLE
ENTRYCHAIN1
        CMP     R2,#" "
        LDREQB  R2,[R0],#1
        BEQ     ENTRYCHAIN1
        TEQ     R2,#0
        BEQ     CLRSTK
        TEQ     R2,#"@@"
        BEQ     ENTRYCONT
ENTRYF  ADD     R4,ARGP,#STRACC
ENTRF1  STRB    R2,[R4],#1
        LDRB    R2,[R0],#1
        CMP     R2,#" "
        BHI     ENTRF1
        MOV     R5,#13
        STRB    R5,[R4],#1
;OK have set up name in STRACC. Call internals of TEXTLOAD
        BL      LOADFILEFINAL
        B       ENTRYFINAL
ENTRYKEYW4
        BL      RDCOMCH
        CMP     R2,#"U"
        BL      RDCOMCHER
        CMP     R2,#"I"
        BL      RDCOMCHER
        CMP     R2,#"T"
        BL      RDCOMCHER
        CMP     R2,#" "
        BNE     ENTRYUNK
        MOV     R1,#0                  ;set QUIT flag
        STRB    R1,[ARGP,#CALLEDNAME]
        B       ENTRYCHAIN1
ENTRYKEYW3
        BL      RDCOMCH
        CMP     R2,#"O"
        BL      RDCOMCHER
        CMP     R2,#"A"
        BL      RDCOMCHER
        CMP     R2,#"D"
        BL      RDCOMCHER
        CMP     R2,#" "
        BNE     ENTRYUNK
        MOV     R9,#0
        B       ENTRYCHAIN
ENTRYKEYW2
        BL      RDCOMCH
        CMP     R2,#"E"
        BL      RDCOMCHER
        CMP     R2,#"L"
        BL      RDCOMCHER
        CMP     R2,#"P"
        BL      RDCOMCHER
        BL      TITLE
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "$Name. -help activated (use HELP at the > prompt for more help):",10,13,0
 |
      [ FPOINT=2
        MOV     R0,#27
      |
        MOV     R0,#17+FPOINT
      ]
        BL      MSGPRNXXX
 ]
        B       ENTRYHELP
ENTRYUNK
        BL      TITLE
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "Unknown keyword.",10,13,10,13,0
        ALIGN
 |
        MOV     R0,#19
        BL      MSGPRNXXX
 ]
ENTRYHELP
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "$Name. [-chain] <filename> to run a file (text/tokenised).",10,13
        =       "$Name. -quit <filename> to run a file (text/tokenised) and quit when done.",10,13
        =       "$Name. -load <filename> to start with a file (text/tokenised).",10,13
        =       "$Name. @@xxxxxxxx,xxxxxxxx to start with in-core text/tokenised program.",10,13
        =       "$Name. -chain @@xxxxxxxx,xxxxxxxx to run in-core text/tokenised program.",10,13,0
 |
      [ FPOINT=2
        MOV     R0,#28
      |
        MOV     R0,#20+FPOINT
      ]
        BL      MSGPRNXXX
 ]
        B       FSASET
RDHEX   MOV     R5,#0
        MOV     R4,#32-4
RDHEX1  LDRB    R2,[R0],#1
        CMP     R2,#"0"
        BCC     BADIPHEX
        CMP     R2,#"9"+1
        BCC     RDHEX2
        CMP     R2,#"A"
        BCC     BADIPHEX
        CMP     R2,#"F"+1
        BCS     BADIPHEX
        SUB     R2,R2,#"A"-"9"-1
RDHEX2  AND     R2,R2,#&F
        ORR     R5,R5,R2,LSL R4
        SUBS    R4,R4,#4
        BPL     RDHEX1
        LDRB    R2,[R0],#1
        MOV     PC,R14
RDCOMCHER
        BNE     ENTRYUNK
RDCOMCH LDRB    R2,[R0],#1
        CMP     R2,#"a"
        BICCS   R2,R2,#" "
        MOV     PC,R14
NEW     BL      DONES
        BL      FROMAT
FSASET  BL      SETFSA
        B       CLRSTK
CLRSTKTITLE
        BL      TITLE
CLRSTK  MOV     ARGP,#VARS
        ADD     LINE,ARGP,#STRACC
        LDR     R0,[ARGP,#HIMEM]
        BL      POPLOCALAR
        LDR     SP,[ARGP,#HIMEM]
        MOV     R0,#0
        STMFD   SP!,{R0-R9}            ;to stop pops getting carried away
        STRB    R0,[ARGP,#MEMM]
        MVN     R0,#0
        STRB    R0,[ARGP,#BYTESM]
        STR     SP,[ARGP,#ERRSTK]
        BL      ORDERR
        LDRB    R0,[ARGP,#CALLEDNAME]
        CMP     R0,#0
        SWIEQ   OS_Exit
        BL      FLUSHCACHE
        SWI     OS_WriteI+">"
        BL      INLINE                 ;R1=STRACC
        BL      SETVAR
        BL      MATCH
        ADD     LINE,ARGP,#OUTPUT
        BL      SPTSTN
        BNE     DC
        STR     SMODE,[SP,#-4]!
        MOV     R4,R0
        BL      INSRT
        LDR     SMODE,[SP],#4
        CMP     SMODE,#&1000
        BCC     WARNC
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "Warning: unmatched ()",10,13,0
        ALIGN
 |
        MOV     R0,#0
        BL      MSGPRNXXX
 ]
WARNC   TST     SMODE,#256
        BEQ     WARNQ
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "Warning: line number too big",10,13,0
        ALIGN
 |
        MOV     R0,#1
        BL      MSGPRNXXX
 ]
WARNQ   AND     SMODE,SMODE,#255
        TEQ     SMODE,#1
        BNE     FSASET
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "Warning: unmatched """,10,13,0
        ALIGN
 |
        MOV     R0,#2
        BL      MSGPRNXXX
 ]
        B       FSASET
DC      MOV     R3,#255
        STRB    R3,[R2]                ;limit end of immmediate mode line
        CMP     R10,#TESCCOM
        BNE     DISPAT
        LDRB    R10,[LINE],#1
        CMP     R10,#TTWOCOMMLIMIT
        BCS     ERSYNT
        SUBS    R4,R10,#&8E
        BCC     ERSYNT
        LDR     R4,[PC,R4,LSL #2]
        ADD     PC,PC,R4
AJ2     *       .+4
        &       APPEND-AJ2
        &       AUTO-AJ2
        &       CRUNCH-AJ2
        &       DELETE-AJ2
        &       EDIT-AJ2
        &       HELP-AJ2
        &       LIST-AJ2
        &       LOAD-AJ2
        &       LVAR-AJ2
        &       NEW-AJ2
        &       OLD-AJ2
        &       RENUM-AJ2
        &       SAVE-AJ2
        &       TEXTLOAD-AJ2
        &       TEXTSAVE-AJ2
        &       MISTAK-AJ2             ;was TWIN
        &       MISTAK-AJ2             ;was TWINO
        &       INSTALL-AJ2
DOSTAR  MOV     R0,LINE                ;do oscli
        BL      OSCLIREGS
        MOV     R14,#3                 ;set MEMM with move & r12 flags
        STR     LINE,[ARGP,#R12STORE]  ;save r12
        STRB    R14,[ARGP,#MEMM]
        SWI     OS_CLI
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
        B       REM
GOTLTEND2
        CMP     R10,#TELSE
        BNE     ERSYNT
        BL      STORE
DATA
DEF
REM     LDRB    R10,[LINE],#1
        CMP     R10,#13
        BEQ     CRLINE
        LDRB    R10,[LINE],#1
        CMP     R10,#13
        BNE     REM
        B       CRLINE
GOTLTEND1
        CMP     R10,#13
        BNE     GOTLTEND2
        BL      STORE
        LDRB    R10,[LINE],#3
        CMP     R10,#&FF
        BEQ     CLRSTK                 ;check for program end
        LDR     R4,[ARGP,#ESCWORD]     ;check for exceptional conditions
        CMP     R4,#0
        BEQ     STMT                   ;nothing exceptional
        BL      DOEXCEPTION
        B       STMT
ENDIF
ENDCA
DONXTS  LDRB    R10,[LINE],#1
DONEXT  CMP     R10,#" "
        BEQ     DONXTS
        CMP     R10,#":"
        BEQ     STMT
        CMP     R10,#13
        BEQ     CRLINE
        CMP     R10,#TELSE
        BEQ     REM
        B       ERSYNT
MINUSBC BL      EXPR
        TEQ     TYPE,#0
        BEQ     ERTYPEINT
        RSBPL   IACC,IACC,#0
 [ FPOINT=0
        BPL     PLUSBC
        TEQ     FACC,#0
        EORNE   FSIGN,FSIGN,#&80000000
 ELIF FPOINT=1
        RSFMID  FACC,FACC,#0
 ELIF FPOINT=2
        FNEGD   FACC,FACC
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       PLUSBC
GOTLT2  CMP     R10,#"-"
        TEQCC   R10,#"+"
        BNE     MISTAK
ATGOTLT2
        LDRB    R10,[AELINE],#1
        TEQ     R10,#"="
        BNE     MISTAK
        BCS     MINUSBC
        BL      EXPR
PLUSBC  BL      AEDONE
        LDMFD   SP!,{R4,R5}
        CMP     R5,#TFPLV
        BEQ     PLUSBCFP
        BCS     PLUSBCSTRING
        BL      INTEGY
        MOV     R7,IACC
        MOV     IACC,R4
        MOV     TYPE,R5
        BL      VARIND
        ADD     IACC,IACC,R7
        BL      STOREANINT
NXT     CMP     R10,#":"
        BEQ     STMT
        CMP     R10,#13
        BNE     REM                    ;if not CR, then ELSE
CRLINE  LDRB    R10,[LINE],#3
        CMP     R10,#&FF
        BEQ     CLRSTK                 ;check for program end
        LDR     R4,[ARGP,#ESCWORD]     ;check for exceptional conditions
        CMP     R4,#0
        BEQ     STMT                   ;nothing exceptional
        BL      DOEXCEPTION
        B       STMT
PLUSBCSTRING
        CMP     R5,#256
        BCS     ARRAYPLUSBC
        TEQ     TYPE,#0
        BNE     ERTYPESTR
        ADD     R0,ARGP,#STRACC
        SUBS    R1,CLEN,R0
        BEQ     NXT                    ;nothing to be added!
        MOV     R7,R1                  ;keep additional length
        MOV     AELINE,R4              ;original address used by SPUSH
        BL      SPUSHLARGE             ;push string to be added
        MOV     IACC,AELINE            ;original address
        CMP     R5,#128                ;check source type
        BL      VARNOTNUM              ;TYPE=0 currently!
        ADD     SP,SP,#4               ;discard length on stack
        ADD     R6,ARGP,#STRACC
        SUB     R6,CLEN,R6
        ADD     R6,R7,R6               ;new length
        CMP     R6,#256
        BCS     ERLONG
PLUSBCLP
        LDRB    R6,[SP],#1
        STRB    R6,[CLEN],#1
        SUBS    R7,R7,#1
        BNE     PLUSBCLP
        ADD     SP,SP,#3
        BIC     SP,SP,#3
        MOV     R4,AELINE
        BL      STSTOR                 ;TYPE still 0
        B       NXT
PLUSBCFP

        BL      FLOATY
 [ FPOINT=0
        MOV     TYPE,R4
        BL      FTOW
        BL      F1LDA
        BL      FADDW
        BL      F1STA
 ELIF FPOINT=1
        LDFD    F1,[R4]
        ADFD    FACC,F1,FACC
        STFD    FACC,[R4]
 ELIF FPOINT=2
        FLDD    D1,[R4]
        FADDD   FACC,D1,FACC
        FPSCRCheck R14
        FSTD    FACC,[R4]
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       NXT
LETSTNOTCACHE
        MOV     AELINE,LINE
        BL      LVNOTCACHE
        BLEQ    GOTLTCREATE            ;taken if EQ (note tricky DONEXT call)
GOTLT   STMFD   SP!,{IACC,TYPE}
GOTLT1  LDRB    R10,[AELINE],#1
        CMP     R10,#" "
        BEQ     GOTLT1
        CMP     R10,#"="
        BNE     GOTLT2
        CMP     TYPE,#256
        BCC     EXPRSTORESTMT
        B       LETARRAY
LETSTCACHEARRAY
        SUB     AELINE,AELINE,#TFP
        BL      ARLOOKCACHE
        BNE     GOTLT
        B       MISTAK
LETST   AND     R1,LINE,#CACHEMASK
        ADD     R1,ARGP,R1,LSL #CACHESHIFT
        LDMIA   R1,{IACC,R1,R4,TYPE}
        CMP     R4,LINE
        BNE     LETSTNOTCACHE
        CMN     R1,#1
        ADD     AELINE,LINE,R1
        BMI     LETSTCACHEARRAY
        STMFD   SP!,{IACC,TYPE}
LETSTSPACE
        LDRB    R10,[AELINE],#1
        CMP     R10,#" "
        BEQ     LETSTSPACE
        CMP     R10,#"="
        BNE     GOTLT2                 ;cannot possibly be array stuff
EXPRSTORESTMT
        BL      EXPR
        MOV     LINE,AELINE
        CMP     R10,#":"
        BNE     GOTLTEND1
        BL      STORE
STMT    LDRB    R10,[LINE],#1
; CMP R10,#" "
; BEQ STMT
;go to value of token in R10, using r4
DISPAT  LDR     R4,[PC,R10,LSL #2]
        ADD     PC,PC,R4
AJ      *       .+4
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       CRLINE-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       STMT-AJ
        &       LETSTNOTCACHE-AJ
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       LETSTNOTCACHE-AJ       ; 24 '$'
        &       LETST-AJ               ; 25 '%'
        &       LETST-AJ               ; 26 '&'
        &       LETST-AJ               ; 27 '''
        &       LETST-AJ               ; 28 '('
        &       LETST-AJ               ; 29 ')'
        &       DOSTAR-AJ
        &       LETST-AJ               ; 2B '+'
        &       LETST-AJ               ; 2C ','
        &       LETST-AJ               ; 2D '-'
        &       LETST-AJ               ; 2E '.'
        &       LETST-AJ               ; 2F '/'
        &       LETST-AJ               ; 30 '0'
        &       LETST-AJ               ; 31 '1'
        &       LETST-AJ               ; 32 '2'
        &       LETST-AJ               ; 33 '3'
        &       LETST-AJ               ; 34 '4'
        &       LETST-AJ               ; 35 '5'
        &       LETST-AJ               ; 36 '6'
        &       LETST-AJ               ; 37 '7'
        &       LETST-AJ               ; 38 '8'
        &       LETST-AJ               ; 39 '9'
        &       STMT-AJ
        &       LETST-AJ               ; 3B ';'
        &       LETST-AJ               ; 3C '<'
        &       FNRET-AJ
        &       LETST-AJ               ; 3E '>'
        &       LETSTNOTCACHE-AJ       ; 3F '?'
        &       ASSIGNAT-AJ
        &       LETST-AJ               ; 41 'A'
        &       LETST-AJ               ; 42 'B'
        &       LETST-AJ               ; 43 'C'
        &       LETST-AJ               ; 44 'D'
        &       LETST-AJ               ; 45 'E'
        &       LETST-AJ               ; 46 'F'
        &       LETST-AJ               ; 47 'G'
        &       LETST-AJ               ; 48 'H'
        &       LETST-AJ               ; 49 'I'
        &       LETST-AJ               ; 4A 'J'
        &       LETST-AJ               ; 4B 'K'
        &       LETST-AJ               ; 4C 'L'
        &       LETST-AJ               ; 4D 'M'
        &       LETST-AJ               ; 4E 'N'
        &       LETST-AJ               ; 4F 'O'
        &       LETST-AJ               ; 50 'P'
        &       LETST-AJ               ; 51 'Q'
        &       LETST-AJ               ; 52 'R'
        &       LETST-AJ               ; 53 'S'
        &       LETST-AJ               ; 54 'T'
        &       LETST-AJ               ; 55 'U'
        &       LETST-AJ               ; 56 'V'
        &       LETST-AJ               ; 57 'W'
        &       LETST-AJ               ; 58 'X'
        &       LETST-AJ               ; 59 'Y'
        &       LETST-AJ               ; 5A 'Z'
        &       ASS-AJ                 ; 5B '['
        &       LETST-AJ               ; 5C '\\'
        &       LETST-AJ               ; 5D ']'
        &       LETST-AJ               ; 5E '^'
        &       LETST-AJ               ; 5F '_'
        &       LETST-AJ               ; 60 '`'
        &       LETST-AJ               ; 61 'a'
        &       LETST-AJ               ; 62 'b'
        &       LETST-AJ               ; 63 'c'
        &       LETST-AJ               ; 64 'd'
        &       LETST-AJ               ; 65 'e'
        &       LETST-AJ               ; 66 'f'
        &       LETST-AJ               ; 67 'g'
        &       LETST-AJ               ; 68 'h'
        &       LETST-AJ               ; 69 'i'
        &       LETST-AJ               ; 6A 'j'
        &       LETST-AJ               ; 6B 'k'
        &       LETST-AJ               ; 6C 'l'
        &       LETST-AJ               ; 6D 'm'
        &       LETST-AJ               ; 6E 'n'
        &       LETST-AJ               ; 6F 'o'
        &       LETST-AJ               ; 70 'p'
        &       LETST-AJ               ; 71 'q'
        &       LETST-AJ               ; 72 'r'
        &       LETST-AJ               ; 73 's'
        &       LETST-AJ               ; 74 't'
        &       LETST-AJ               ; 75 'u'
        &       LETST-AJ               ; 76 'v'
        &       LETST-AJ               ; 77 'w'
        &       LETST-AJ               ; 78 'x'
        &       LETST-AJ               ; 79 'y'
        &       LETST-AJ               ; 7A 'z'
        &       ERSYNT-AJ
        &       LETSTNOTCACHE-AJ       ; |
        &       ERSYNT-AJ
        &       ERSYNT-AJ
        &       OTHER-AJ
        &       ERSYNT-AJ              ; AND
        &       ERSYNT-AJ              ; DIV
        &       ERSYNT-AJ              ; EOR
        &       ERSYNT-AJ              ; MOD
        &       ERSYNT-AJ              ; OR
        &       LERROR-AJ
        &       LINEST-AJ
        &       CURSOFF-AJ
        &       ERSYNT-AJ              ; STEP
        &       ERSYNT-AJ              ; SPC
        &       ERSYNT-AJ              ; TAB
        &       REM-AJ                 ; ELSE
        &       ERSYNT-AJ              ; THEN
        &       ERSYNT-AJ              ; 8D
        &       ERSYNT-AJ              ; OPENU

        &       LPTR-AJ
        &       LPAGE-AJ
        &       LTIME-AJ
        &       LLOMEM-AJ
        &       LHIMEM-AJ

        &       ERSYNT-AJ              ; ABS
        &       ERSYNT-AJ              ; ACS
        &       ERSYNT-AJ              ; ADC
        &       ERSYNT-AJ              ; ASC
        &       ERSYNT-AJ              ; ASN
        &       ERSYNT-AJ              ; ATN
        &       ERSYNT-AJ              ; BBGET
        &       ERSYNT-AJ              ; COS
        &       ERSYNT-AJ              ; COUNT
        &       ERSYNT-AJ              ; DEG
        &       ERSYNT-AJ              ; ERL
        &       ERSYNT-AJ              ; ERR
        &       ERSYNT-AJ              ; EVAL
        &       ERSYNT-AJ              ; EXP
        &       LEXT-AJ                ; EXT
        &       ERSYNT-AJ              ; FALSE
        &       ERSYNT-AJ              ; FN
        &       ERSYNT-AJ              ; GET
        &       ERSYNT-AJ              ; INKEY
        &       ERSYNT-AJ              ; INSTR
        &       ERSYNT-AJ              ; INT
        &       ERSYNT-AJ              ; LEN
        &       ERSYNT-AJ              ; LN
        &       ERSYNT-AJ              ; LOG
        &       ERSYNT-AJ              ; NOT
        &       ERSYNT-AJ              ; OPENI
        &       ERSYNT-AJ              ; OPENO
        &       ERSYNT-AJ              ; PI
        &       ERSYNT-AJ              ; POINT
        &       ERSYNT-AJ              ; POS
        &       ERSYNT-AJ              ; RAD
        &       ERSYNT-AJ              ; RND
        &       ERSYNT-AJ              ; SGN
        &       ERSYNT-AJ              ; SIN
        &       ERSYNT-AJ              ; SQR
        &       ERSYNT-AJ              ; TAN
        &       ERSYNT-AJ              ; TO
        &       ERSYNT-AJ              ; TRUE
        &       ERSYNT-AJ              ; USR
        &       ERSYNT-AJ              ; VAL
        &       ERSYNT-AJ              ; VPOS
        &       ERSYNT-AJ              ; CHRD
        &       ERSYNT-AJ              ; GETD
        &       ERSYNT-AJ              ; INKED
        &       LLEFTD-AJ
        &       LMIDD-AJ
        &       LRIGHTD-AJ
        &       ERSYNT-AJ              ; STRD
        &       ERSYNT-AJ              ; STRND
        &       ERSYNT-AJ              ; EOF

        &       ERSYNT-AJ              ;functions disallowed
        &       ERSYNT-AJ              ;commands disallowed
        &       TWOSTMT-AJ             ;two byte statements

        &       WHEN-AJ
        &       ERSYNT-AJ              ;OF
        &       ENDCA-AJ
        &       ELSE2-AJ
        &       ENDIF-AJ
        &       ENDWH-AJ
        &       LPTR-AJ
        &       LPAGE-AJ
        &       LTIME-AJ
        &       LLOMEM-AJ
        &       LHIMEM-AJ
        &       SOUND-AJ
        &       BBPUT-AJ
        &       CALL-AJ
        &       CHAIN-AJ
        &       CLEAR-AJ
        &       CLOSE-AJ
        &       CLG-AJ
        &       CLS-AJ
        &       DATA-AJ
        &       DEF-AJ
        &       DIM-AJ
        &       DRAW-AJ
        &       END-AJ
        &       ENDPR-AJ
        &       ENVEL-AJ
        &       FOR-AJ
        &       GOSUB-AJ
        &       GOTO-AJ
        &       GCOL-AJ
        &       IF-AJ
        &       INPUT-AJ
        &       LET-AJ
        &       LOCAL-AJ
        &       MODES-AJ
        &       MOVE-AJ
        &       NEXT-AJ
        &       ON-AJ
        &       VDU-AJ
        &       PLOT-AJ
        &       PRINT-AJ
        &       PROC-AJ
        &       READ-AJ
        &       REM-AJ
        &       REPEAT-AJ
        &       REPORT-AJ
        &       RESTORE-AJ
        &       RETURN-AJ
        &       RUN-AJ
        &       STOP-AJ
        &       COLOUR-AJ
        &       TRACE-AJ
        &       UNTIL-AJ
        &       WIDTH-AJ
        &       OSCL-AJ
TWOSTMT LDRB    R10,[LINE],#1
        CMP     R10,#TTWOSTMTLIMIT
        BCS     ERSYNT
        SUBS    R4,R10,#&8E
        BCC     ERSYNT
        LDR     R4,[PC,R4,LSL #2]
        ADD     PC,PC,R4
AJ3     *       .+4
        &       CASE-AJ3
        &       CIRCLE-AJ3
        &       FILL-AJ3
        &       ORGIN-AJ3
        &       PSET-AJ3
        &       RECT-AJ3
        &       SWAP-AJ3
        &       WHILE-AJ3
        &       WAIT-AJ3
        &       DOMOUSE-AJ3
        &       QUIT-AJ3
        &       SYS-AJ3
        &       INSTALLBAD-AJ3
        &       LIBRARY-AJ3
        &       DOTINT-AJ3
        &       ELLIPSE-AJ3
        &       BEATS-AJ3
        &       TEMPO-AJ3
        &       VOICES-AJ3
        &       VOICE-AJ3
        &       STEREO-AJ3
        &       OVERLAY-AJ3

;clear text
FROMAT  MOV     R0,#13
        LDR     R1,[ARGP,#PAGE]
        STRB    R0,[R1],#1
        MOV     R0,#&FF
        STRB    R0,[R1],#1             ;post index to get value for TOP
        STR     R1,[ARGP,#TOP]
        MOV     R0,#0
        STR     R0,[ARGP,#TRCNUM]
        MOV     PC,R14
SETFSA  LDR     R0,[ARGP,#TOP]
        ADD     R0,R0,#3
        BIC     R0,R0,#3
        STR     R0,[ARGP,#LOMEM]
        STR     R0,[ARGP,#FSA]
        MOV     R6,#0
        ADD     R1,ARGP,#FREELIST
        ADD     R2,R1,#256
SETFREEL
        STR     R6,[R1],#4
        CMP     R1,R2
        BCC     SETFREEL
        MOV     R6,R14                 ;save return address
        BL      SETVAR
        MOV     R14,R6
SETVAL  ADD     R1,ARGP,#PROCPTR
        ADD     R2,R1,#(FNPTR+4-PROCPTR)
        MOV     R0,#0
        STR     R0,[ARGP,#LIBRARYLIST]
        STR     R0,[ARGP,#OVERPTR]
SETVRL  STR     R0,[R1],#4
        TEQ     R1,R2
        BNE     SETVRL
        ADD     R1,ARGP,#VCACHE
        ADD     R2,R1,#CACHESIZE*16
SETCACHE0
        STR     R0,[R1],#4
        TEQ     R1,R2
        BNE     SETCACHE0
        MOV     PC,R14
SETVAR  LDR     R0,[ARGP,#PAGE]
        STR     R0,[ARGP,#DATAP]
        MOV     PC,R14
FLUSHCACHE
        ADD     R1,ARGP,#VCACHE+CACHECHECK
        MOV     R0,#0
        ADD     R2,R1,#CACHESIZE*16
FLUSHCACHE1
        STR     R0,[R1],#16
        TEQ     R1,R2
        BNE     FLUSHCACHE1
        MOV     PC,R14
;empty any cache entry which lies in the range R4 to AELINE
;Uses R5, R6, R7 and R10
;Must preserve PSR flags
PURGECACHE
        STR     R14,[SP,#-4]!
        SavePSR R14
        MOV     R5,#0
        SUB     R10,AELINE,R4
        CMP     R10,#256
        BCS     PURGECACHEB1
;algorithm 1: kill entries that might be matched
 [ (CACHEMASK :AND: 1) = 1
;bottom bit valid
        MOV     R6,R4
PURGECACHEA1
        AND     R7,R6,#CACHEMASK
        ADD     R7,ARGP,R7,LSL #CACHESHIFT
        LDR     R10,[R7,#CACHECHECK]
        CMP     R10,R6
        STREQ   R5,[R7,#CACHECHECK]
        ADD     R6,R6,#1
        CMP     R6,AELINE
        BLE     PURGECACHEA1
 |
        BIC     R6,R4,#1
PURGECACHEA1
        AND     R7,R6,#CACHEMASK
        ADD     R7,ARGP,R7,LSL #CACHESHIFT
        LDR     R10,[R7,#CACHECHECK]
        CMP     R10,R6
        ADD     R6,R6,#1
        CMPNE   R10,R6
        STREQ   R5,[R7,#CACHECHECK]
        ADD     R6,R6,#1
        CMP     R6,AELINE
        BLE     PURGECACHEA1
 ]
        RestPSR R14,,f
        LDR     PC,[SP],#4
;algorithm 2: go through whole cache killing entries in range
PURGECACHEB1
        ADD     R6,ARGP,#VCACHE+CACHECHECK
        ADD     R7,R6,#CACHESIZE*16
PURGECACHEB2
        LDR     R10,[R6],#16
        CMP     R10,R4
        CMPCS   AELINE,R10
        STRCS   R5,[R6,#-16]
        CMP     R6,R7
        BNE     PURGECACHEB2
        RestPSR R14,,f
        LDR     PC,[SP],#4
;create error message (R14->entry in ErrorMsgs,LINE->address of statement in error)
MSG     SUB     R3,R14,PC              ;remove mode and flags
        ADD     R3,PC,R3
        SUB     R3,R3,#4               ;byte error
        ADD     R9,ARGP,#STRACC
        LDRB    R2,[R3],#1             ;move error number
        STR     R2,[R9]
        LDRB    R0,[R3],#1             ;unique error number
 [ OWNERRORS=1
        ADD     R14,R9,#4              ;copy my error message
MSGBYTE LDRB    R2,[R3],#1
        STRB    R2,[R14],#1
        CMP     R2,#0
        BNE     MSGBYTE
 |
        SUB     SP,SP,#8
        ADD     R1,SP,#1               ;gap for 'E'
        MOV     R2,#7
        SWI     XOS_ConvertCardinal1
        MOV     R14,#"E"
        STRB    R14,[R0,#-1]!
        ADD     R1,R9,#4
        MOV     R3,#252
        BL      MSGXLATE               ;lookup the foreign one
        ADD     SP,SP,#8
 ]
;make internal errors visible to Service_Error watchers
        STMFD   SP!,{R4-R5,R9}
        BL      OSCLIREGS              ;show some leg
        LDR     R1,=ErrorBase_BASIC
        LDRB    R14,[R9]
        ORR     R1,R1,R14
        STR     R1,[R9]                ;make errnum system unique
        MOV     R0,R9
        MOV     R1,#Service_Error
        SWI     XOS_ServiceCall
        STR     R14,[R9]               ;put back our errnum
        LDMFD   SP!,{R4-R5,R14}
MSGERR  MOV     ARGP,#VARS             ;cardinal error from outside world
        MOV     R7,R14                 ;keep error pointer
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]       ;clear MEMM (and r12) flags
        BL      FLUSHCACHE
      [ FPOINT=2
        ; Reset FP context
        ADD     R0,ARGP,#VFPCONTEXT
        MOV     R1,#0
        SWI     XVFPSupport_ChangeContext
        FMXR    FPSCR,R1
      ]
        MOV     R0,#&DA
        MOV     R1,#0
        MOV     R2,#0
        SWI     OS_Byte
        MOV     R0,#&7E
        SWI     OS_Byte
        MOV     R0,#0
;try to figure out where the error happened
        CMP     LINE,#AppSpaceStart    ;must be in application space
        MVNLO   R0,#0                  ;otherwise ERL:=-1
        BLO     MSG1
        SUB     LINE,LINE,#2           ;seems a good idea
        LDR     R1,[ARGP,#PAGE]        ;OK: find good base to start search
        LDR     R2,[ARGP,#LIBRARYLIST]
        BL      MSGSEARCHLIST          ;check list of LIBRARYs. May inc r1
        LDR     R2,[ARGP,#INSTALLLIST]
        BL      MSGSEARCHLIST          ;check list of INSTALLs. May inc r1
        LDR     R2,[ARGP,#OVERPTR]
        TEQ     R2,#0                  ;check list of OVERLAYs. May inc r1
        BEQ     MSG0START
        ADD     R3,R2,#12
        CMP     R3,LINE                ;test if prog start < error pos: true=CC
        CMPCC   R1,R3                  ;test if prog start > previous prog start: true=CC
        MOVCC   R1,R3                  ;keep r3 if prog start < error pos and prog start > previous start
;r1 = highest program section start (of ALL sections) below LINE ptr
;Now search from that pointer to end of that program section...
MSG0START
        MOV     AELINE,R1              ;keep pointer to start of program section
MSG0    CMP     R1,LINE                ;is this line > error line?
        BHI     MSG1                   ;yes, so go use last ERL
        LDRB    R2,[R1,#1]
        CMP     R2,#&FF                ;at end of program?
        MVNEQ   R0,#1                  ;yes, so ERL:=-2
        BEQ     MSG1
        LDRB    R0,[R1,#2]
        ADD     R0,R0,R2,LSL #8        ;r0 = line number
        LDRB    R2,[R1,#3]             ;line length
        ADD     R1,R1,R2               ;move ptr to next line
        B       MSG0
MSG1    STR     R0,[ARGP,#ERRLIN]      ;store ERL
        ADD     R1,ARGP,#ERRORS
        ADD     R4,R1,#255             ;end of error buffer
        ADR     LINE,ERRHAN            ; -> default error handler
        LDR     R0,[R7],#4
        STR     R0,[ARGP,#ERRNUM]      ;store ERR
        CMP     R0,#0                  ;is ERR = 0 ?
        LDRNE   LINE,[ARGP,#ERRORH]    ;no,  so use last error handler
        STREQ   LINE,[ARGP,#ERRORH]    ;yes, save default error handler
MSGA    LDRB    R0,[R7],#1             ;copy error message ...
        TEQ     R0,#0
        STRNEB  R0,[R1],#1             ;... to error buffer
        BNE     MSGA                   ;save error message
        LDR     R2,[ARGP,#PAGE]
        CMP     R2,AELINE
        BEQ     MSGLIBRARYDONE         ;not in a strange bit
;look for REM [>] <name> in first line of LIBRARY, INSTALL or OVERLAY
        ADD     AELINE,AELINE,#4
        BL      AESPAC
        CMP     R10,#TREM
        BNE     MSGLIBRARYDONE         ;no REM statement found
        BL      AESPAC
        CMP     R10,#">"
        BLEQ    AESPAC
        CMP     R10,#13
        BEQ     MSGLIBRARYDONE         ;empty
        BL      MSGADDONENDSPC
        MOV     R3,#"i"                ;add 'in "library name"' to error
        BL      MSGADDONEND
        MOV     R3,#"n"
        BL      MSGADDONEND
        BL      MSGADDONENDSPC
        MOV     R3,#""""
        BL      MSGADDONEND
        MOV     R3,R10
MSGLIBRARYNAME
        BL      MSGADDONEND            ;copy name of Library
        LDRB    R3,[AELINE],#1
        CMP     R3,#" "
        BCS     MSGLIBRARYNAME         ;HI if " " is end of insert
        MOV     R3,#""""
        BL      MSGADDONEND
MSGLIBRARYDONE
        STRB    R0,[R1]                ;write in last 0
; BL SETVAR                                       ;****CHANGE
        LDR     R0,[ARGP,#ERRSTK]
        LDR     R1,[ARGP,#MEMLIMIT]
        CMP     R0,R1                  ;is error stack ptr in basic mem?
        BHS     MSGSPE                 ;no, so no hope - give error
        CMP     R0,SP                  ;is error stack ptr > current sp?
        LDRLO   SP,[ARGP,#ERRSTK]      ;no, reset to last error handler
        B       MSGSP1                 ;and try to continue...
MSGSPE                                 ;raise nasty error and end
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "Attempt to use badly nested error handler (or corrupt R13).",10,13,0
        ALIGN
 |
        MOV     R0,#3
        BL      MSGPRNXXX
 ]
MSGSP2  LDR     R1,[ARGP,#HIMEM]
        SUB     R1,R1,#10*4
        STR     R1,[ARGP,#ERRSTK]
        ADR     LINE,ERRHAN
        STR     LINE,[ARGP,#ERRORH]
MSGSP1  BL      POPLOCALAR             ;clean up removed local string arrays
        LDR     SP,[ARGP,#ERRSTK]
        B       STMT                   ;continue from LINE
MSGXLATE
        STMFD   SP!,{R0-R3,R14}
        SUB     SP,SP,#4*4             ;a MessageTrans structure
        MOV     R2,#0
        STRB    R2,[R1]                ;null result by default
        ADRL    R1,Basic_MessageFile
        MOV     R0,SP
        SWI     XMessageTrans_OpenFile
        BVS     MSGXLDONE
        LDR     R1,[SP,#(4*4)+0]       ;entry R0
        LDR     R2,[SP,#(4*4)+4]       ;entry R1
        SWI     XMessageTrans_Lookup
        MOVVS   R0,SP
        SWI     XMessageTrans_CloseFile
MSGXLDONE
        ADD     SP,SP,#4*4
        LDMFD   SP!,{R0-R3,PC}
MSGADDONENDSPC
        MOV     R3,#" "
MSGADDONEND
        CMP     R1,R4
        STRCCB  R3,[R1],#1
        MOV     PC,R14
MSGSEARCHLIST                          ;check entries in LIBRARY, INSTALL or OVERLAY lists
;exit r1 = highest program section start below LINE ptr ** SO FAR **
        TEQ     R2,#0                  ;end of list
        MOVEQ   PC,R14
        ADD     R3,R2,#4               ;start of prog
        LDR     R2,[R2]                ;next link
        CMP     R3,LINE                ;test if prog start < error pos: true=CC
        CMPCC   R1,R3                  ;test if prog start > previous prog start: true=CC
        MOVCC   R1,R3                  ;keep r3 if prog start < error pos and prog start > previous start
        B       MSGSEARCHLIST
INLINE  ADD     R0,ARGP,#STRACC
        MOV     R1,#238
        MOV     R2,#" "
        MOV     R3,#255
        SWI     OS_ReadLine
        BCS     ESCAPE
        ADD     R1,ARGP,#STRACC
        B       CTALLY
NLINE   SWI     OS_NewLine
CTALLY  MOV     R2,#0
        STR     R2,[ARGP,#TALLY]
        MOV     PC,R14

ORDERR  ADR     R0,ERRHAN              ;reset error handler to use default
        STR     R0,[ARGP,#ERRORH]
        MOV     PC,R14
ERRHAN  ; TRACE OFF:
        ; IF QUIT ERROR EXT ERR,REPORT$ ELSE RESTORE:IF ERL CALL!ERRXLATE:PRINT$STRACC ELSE REPORT:PRINT
        ; END
        =       TTRACE,TOFF,":"
        =       TIF,TESCSTMT,TQUIT,TERROR,TEXT,TERR,",",TREPORT,"$"
        =       TELSE,TRESTORE,":",TIF,TERL,TCALL,"!&",:STR:(VARS+ERRXLATE):RIGHT:4,":"
        =       TPRINT,"$&",:STR:(VARS+STRACC):RIGHT:4,TELSE,TREPORT,":",TPRINT,13,0,0,0
        =       TEND,13
        ALIGN
;remove from line number in r4 to line number in r5
REMOVE  MOV     R0,R4
        STR     R14,[SP,#-4]!
        BL      FNDLNO
        MOV     R6,R1
        ADD     R0,R5,#1               ;next line plus one
        BL      FNDLNONEXT             ;continue from where we are now
        CMP     R1,R6
        LDRLS   PC,[SP],#4               ;very easy
        LDR     R0,[ARGP,#TOP]
REMOVL  LDRB    R2,[R1],#1             ;pick up a byte from high up
        STRB    R2,[R6],#1             ;put it low down
        CMP     R1,R0
        BNE     REMOVL
        STR     R6,[ARGP,#TOP]
        LDR     PC,[SP],#4
INSERT  STR     R14,[SP,#-4]!              ;insert at end of text
        LDR     R1,[ARGP,#TOP]
        SUB     R1,R1,#2               ;address of cr
        B       INSRTS
;insert the line whose number is in R4, whose first char is ptd to by LINE
INSRT   STR     R14,[SP,#-4]!
        MOV     R5,R4
        BL      REMOVE
        LDRB    R0,[LINE]
        CMP     R0,#13
        LDREQ   PC,[SP],#4
        MOV     R0,R4
        BL      FNDLNO                 ;get position to R1
        LDRB    R0,[ARGP,#LISTOP]
        TEQ     R0,#0
        BEQ     INSRTS
        BL      SPACES
        SUB     LINE,LINE,#1
INSRTS  MOV     AELINE,LINE
LENGTH  LDRB    R0,[AELINE],#1
        CMP     R0,#13
        BNE     LENGTH
        SUB     AELINE,AELINE,#1
TRALSP  LDRB    R0,[AELINE,#-1]!
        CMP     AELINE,LINE
        BLS     TRALEX
        CMP     R0,#" "
        BEQ     TRALSP
TRALEX  MOV     R0,#13
        STRB    R0,[AELINE,#1]!
        SUB     R6,AELINE,LINE         ;raw length 0..n
        ADD     R6,R6,#4               ;length as desired
        CMP     R6,#256
        BCS     ERLINELONG
        LDR     R2,[ARGP,#TOP]
        ADD     R3,R2,R6               ;calc new TOP
        STR     R3,[ARGP,#TOP]
MOVEUP  LDRB    R0,[R2,#-1]!
        STRB    R0,[R3,#-1]!
        TEQ     R2,R1
        BNE     MOVEUP
        STRB    R4,[R1,#2]
        MOV     R5,R4,LSR #8
        STRB    R5,[R1,#1]             ;lo and hi bytes of line number
        STRB    R6,[R1,#3]!            ;length
INSLP1  LDRB    R0,[LINE],#1
        STRB    R0,[R1,#1]!
        CMP     R0,#" "
        BEQ     INSLP1
        TEQ     R0,#13
        LDREQ   PC,[SP],#4
        TEQ     R0,#TELSE
        MOVEQ   R0,#TELSE2
        STREQB  R0,[R1]
INSLP2  LDRB    R0,[LINE],#1
        STRB    R0,[R1,#1]!
        TEQ     R0,#13
        BNE     INSLP2
        LDR     PC,[SP],#4
 [ RELEASEVER=0
PATOUT  SUB     R2,R14,PC
        ADD     R2,PC,R2
        SUB     R2,R2,#4
        BL      PATA
        BL      PATA
        BL      PATA
        BL      PATA
        BL      PATA
        BL      PATA
        SWI     OS_WriteI+23
        SWI     OS_WriteI+" "
        MOV     R1,#8
        BL      ZEROX                  ;8 zeroes
        MOV     PC,R2
PATA    LDR     R0,[R2],#4
        SWI     OS_WriteI+23
        SWI     OS_WriteI+" "
        SWI     OS_WriteC
        MOV     R0,R0,ROR #8
        SWI     OS_WriteC
        MOV     R0,R0,ROR #8
        SWI     OS_WriteC
        MOV     R0,R0,ROR #8
        SWI     OS_WriteC
        LDR     R0,[R2],#4
        SWI     OS_WriteC
        MOV     R0,R0,ROR #8
        SWI     OS_WriteC
        MOV     R0,R0,ROR #8
        SWI     OS_WriteC
        MOV     R0,R0,ROR #8
        SWI     OS_WriteC
        SWI     OS_WriteI+" "
        MOV     PC,R14
 ]

        LNK     fp.s
@


1.27
log
@Add "BASICVFP", a VFP version of BASIC64
Detail:
  See Doc/BASICVFP for overall design/specification
  File changes:
  - !Mk,fd7, !MkClean,fd7, !MkRom,fd7, Makefile - update build scripts to support BASICVFP target
  - Resources/UK/Messages - Add a few new messages
  - hdr/Definitions - Define BASICVFP register usage and a few utility macros
  - hdr/WorkSpace - Define BASICVFP workspace adjustments. Add a few asserts to check some workspace constraints are maintained.
  - s/* - Lots of changes to add support for BASICVFP variant of the module
Admin:
  Tested on Raspberry Pi 1/2/3, BB-xM


Version 1.67. Tagged as 'BASIC-1_67'
@
text
@d437 1
a437 1
        =       "I"
@


1.26
log
@Fix RISC OS 3.1 compatibility. Fix "Unknown keyword" error.
Detail:
  s/Basic - Fix error generation for unknown keywords on the command line; MSGPRNXXX is a function, not a SWI
  s/HelpMsgs - Take account of the fact that under RISC OS 3.1 MsgTrans doesn't support tokenised messages, and so the [1B][01] control codes being used for inserting newlines will be left in place in the message output. Passing the message on to OS_PrettyPrint allows the tokens to be expanded, but only if we pass a sensible dictionary pointer (Old code was passing in the message pointer as the dictionary pointer, resulting in recursive expansion of the message and an eventual stack overflow)
Admin:
  Tested PlingSystem build on RISC OS 3.1


Version 1.62. Tagged as 'BASIC-1_62'
@
text
@d26 14
d42 1
d79 6
d218 6
d244 1
d255 1
a255 1
 [ FPOINT=1
d274 19
d317 5
d323 1
d438 2
d551 3
d555 1
d578 3
d582 1
d759 4
d764 1
a764 1
        RSFMID  FACC,FACC,#0
d839 1
a839 1
 |
d843 7
d1336 7
@


1.25
log
@Extended assembler for ARMv6/v7 instructions
Implemented scalar (non-VFP/NEON) instructions for ARMv6/v7 and a couple of omitted ARMv5 instructions in UAL syntax.
Added documentary comments and minor performance tweaks to some existing code.
Corrected stack imbalance in handling of memory moving when local DIMs in use.
Preliminary test code for assembler instructions.

Version 1.60. Tagged as 'BASIC-1_60'
@
text
@a24 1
        NOP
a144 1
        NOP
d508 1
a508 1
        SWI     MSGPRNXXX
@


1.24
log
@  Tweaks to permit BASIC to cross-compile
Detail:
  * Changed file paths to forms that also work when cross-compiling
  * Changed case of filenames so they match on case-sensitive filing systems
  * Makefile needs to use leading tabs
  * Escaped the '$' in 'BASIC$Crunch' (squashes a warning in new version of
    objasm - unrelated to cross-compilation)
Admin:
  Cross-compiles OK with Norcroft tools, though asasm can't stomach the
  expressions BASIC uses. Checked it still builds with RISC OS Norcroft.

Version 1.59. Not tagged
@
text
@d120 1
a122 1
        LDR     R4,[ARGP,#DIMLOCAL]     ;are there any DIM LOCALs in use?
d125 1
a126 1
        LDR     R5,[SP],#4
a127 1
        MOV     R0,R0
d1251 1
a1251 1
        LDRB    R14,[R9]               
@


1.23
log
@  Tweak greeting message
Detail:
  The standard message printed when BASIC is entered as the current language
  ("ARM BBC BASIC V[I] version x.xx (C) Acorn 1989") wraps mid-year in
  40-column modes. This change avoids this problem by omiting the version
  number from the greeting.
Admin:
  Tested on a Raspberry Pi booting into MODE 7

Version 1.58. Tagged as 'BASIC-1_58'
@
text
@d379 1
a379 1
        =       "BASIC$Crunch"
d1543 1
a1543 1
        LNK     Fp.s
@


1.22
log
@Have BASIC manage its own messages
For the standalone case BASIC[64] will now register its own resources into Resources/BASIC/BASIC[64]Msgs.
For the ROM case BASIC[64] will share them in Resources/BASIC/Messages as before.
This ensures that regardless of the order of loading, and the potential that a ROM and standalone version might be mixed, both ends up seeing the messages its expecting to see.
Tested in a ROM build and softloaded on RISC OS 4.02.

Version 1.57. Tagged as 'BASIC-1_57'
@
text
@d389 1
a389 1
        =       " version $Module_FullVersion (C) Acorn 1989",10,13,0
@


1.21
log
@Fix bug misreporting ERL with external errors in immediate mode
Starting BASIC and hitting Escape would report an "Escape at line 4 billion" as the check of where an error occurred was over strict.
Previously "above PAGE and not in 1st 256 bytes of OUTPUT" now "above &8000", this only lets through a few hundred more bytes anyway.
Change unexpected ERL numbers to be -1 and -2 rather than -1 and 99999.
Tagged as BASIC-1_57-pre4.
@
text
@d17 1
a17 1
   [ :DEF: VFPAssembler :LAND: :LNOT: standalone
d234 1
a234 1
   [ :DEF: VFPAssembler :LAND: :LNOT: standalone
d248 3
a250 1
   ]        
d407 1
a407 3
        MOV     R0,#22
        SWI     XBASICTrans_Message
        LDMVCFD SP!,{R0-R12,PC}
d416 4
d495 1
a495 3
        MOV     R0,#17+FPOINT
        SWI     XBASICTrans_Message
        BVC     ENTRYHELP
d498 4
d505 1
a505 3
        MOV     R0,#19
        SWI     XBASICTrans_Message
        BVC     ENTRYHELP
d509 4
d514 1
a514 3
        MOV     R0,#20+FPOINT
        SWI     XBASICTrans_Message
        BVC     FSASET
d521 4
a543 1

a553 1

d585 1
a585 3
        MOV     R0,#0
        SWI     XBASICTrans_Message
        BVC     WARNC
d589 4
d595 1
a595 3
        MOV     R0,#1
        SWI     XBASICTrans_Message
        BVC     WARNQ
d599 4
d606 1
a606 3
        MOV     R0,#2
        SWI     XBASICTrans_Message
        BVC     FSASET
d610 4
d1222 10
a1231 24
 [ OWNERRORS=0
NOERRORMSG
        =       "No string from BASICTrans",0
        ALIGN
 ]

; Create error message
; entry r14 -> ERR (1 byte)
;              BasicTrans error number (1 byte)
;              Error message
;              x00 terminator
;       r12 (LINE) -> address of statement in error (but could be corrupt)
MSG     SUB     R3,R14,PC              ; r3 = r14 ...
        ADD     R3,PC,R3               ; ... (even if 26 bit flags)
        SUB     R3,R3,#4               ; ... now  -> Basic ERR
        ADD     R14,ARGP,#STRACC
        MOV     R1,R14
        LDRB    R2,[R3],#1             ; move error number   (ERR)
        STR     R2,[R1],#4             ; store ERR as word in STRACC
        LDRB    R0,[R3],#1             ; unique error number (BasicTrans)
 [ OWNERRORS=0
        ADR     R3,NOERRORMSG          ;error message in case of none
 ]
        ADD     R9,R14,#4              ; copy my error message to STRACC
d1233 1
a1233 1
        STRB    R2,[R9],#1
d1236 12
a1247 1
        SWI     XBASICTrans_Error      ;overwrite with foreign one
a1248 1
        MOV     R9,R14
d1357 1
a1357 3
        MOV     R0,#3
        SWI     XBASICTrans_Message
        BVC     MSGSP2
d1361 4
a1364 1

d1373 17
a1389 1

d1422 8
a1429 10

; Default error handler
ERRHAN  =       TTRACE,TOFF,":"
        =       TIF,TESCSTMT,TQUIT,TERROR,TEXT,TERR,",",TREPORT,"$",TELSE
        =       TRESTORE,":!(",THIMEM,"-4)=@@%:"
        =       TESCSTMT,TSYS,"&62c82,24,",TERL,",",TREPORT,"$",TTO,";@@%:"
        =       TIF,"(@@%",TAND,"1)=0",":@@%=!(",THIMEM,"-4):",TEND,TELSE
        =       "@@%=&900:",TREPORT,":",TIF,TERL
        =       TPRINT,""" at line """,TERL,TELSE,TPRINT,13,0,0,0
        =       "@@%=!(",THIMEM,"-4):",TEND,13
@


1.20
log
@Improvement to externally visible errors
Failing to start BASIC due to lack of memory now uses a system unique error number, and an internationalised message.
Doing QUIT<expr> where the expression exceeds the Sys$RCLimit also now uses a system unique error number.
Internal error messages (eg. "Syntax error") are now passed via Service_Error for information. As with OSCLI, some extra registers are preset with BASIC's internal state which could be useful for debuggers.
Tagged as BASIC-1_57-pre3.
@
text
@d1262 4
a1265 12
; STRB R0,[ARGP,#TRCFLG] ;disable any tracing     ;****CHANGE
        ; Check if line address is too low to be valid
        MOV     R2,LINE, ASR #8        ; borrow reg about to be changed
        ADD     R1,ARGP,#OUTPUT        ; get address of Input buffer!
        CMP     R2,R1   ,ASR #8        ; is line addr = &8200 TO &82FF?
        LDRNE   R1,[ARGP,#PAGE]        ; no, so better get PAGE
        CMPNE   LINE,R1                ;     and is line addr < page ?
        ; if line addr is < page and not &82xx, it is invalid...
        MVNLO   r0,#0                  ; set line number to -1
        STRLO   r0,[ARGP,#ERRLIN]      ; and store it
        BLO     MSG1                   ; and skip line checking code

d1286 3
a1288 3
        CMP     R2,#&FF                ; at end of program?
        LDREQ   R0,ERLhi               ; yes, so set ERL to high value
        BEQ     MSG1                   ; yes
d1294 1
a1294 4

ERLhi   DCD     99999                  ; high value for ERL

MSG1    STR     R0,[ARGP,#ERRLIN]      ; store ERL
@


1.19
log
@Non functional changes
Lined up some comments.
Changed LNK filenames to be Unix style (thing.s rather than s.thing).
Tagged as BASIC-1_57-pre2
@
text
@d31 3
d37 2
a38 2
        &       11
        =       "Not enough application memory to start $Name.",0
d217 1
a217 1
EXITERR DCD     1
d1237 13
@


1.18
log
@Redo DO32BIT portions using central macros
When 32 bitted there weren't 26/32 neutral macros around, but can use them now there are allowing one common output binary for disc based BASIC.
Some of the sneaky 26 bit code (eg. relying on address space wrapping at 64MB rather than explicitly clearing bits when computing a jump) adopt the safer 32 bit form even if that does cost 1 extra instruction.
Tagged as BASIC-1_57-pre1
@
text
@d43 1
a43 2

OSERRR                                 ; Called by System Error Handler
d46 6
a51 6
        LDRB    R14 ,[R14,#MEMM]       ; get MEMM flags
        TST     R14,#2                 ; is r12 saved flag on?
        MOV     R14,#VARS              ; get value of ARGP (again)
        LDRNE   LINE,[R14,#R12STORE]   ; yes, so safe to recover r12
        ADD     R14,R14,#STRACC        ; used for error buffer
        ADD     R14,R14,#4             ; skip PC to -> error number
a52 1

a54 1

d102 6
a107 6
        TST     R0,#1                   ; is "move memory" *bit* set?
        MOVEQ   R1,#0                   ; no
        LDMEQFD SP!,{R0,R2-R8,PC}       ; if not, refuse move
        TEQ     R1,#0                   ; any installed libraries?
        MOVNE   R1,#0                   ; no
        LDMNEFD SP!,{R0,R2-R8,PC}       ; if not, refuse move
a597 1

d625 2
a626 2
        &       MISTAK-AJ2             ; was TWIN
        &       MISTAK-AJ2             ; was TWINO
a627 1

d630 2
a631 2
        MOV     R14,#3                 ; set MEMM with move & r12 flags
        STR     LINE,[ARGP,#R12STORE]  ; save r12
a636 1

a661 1

a1110 1

a1140 1

a1143 1

a1152 1

d1237 1
a1237 1
        STRB    R14,[ARGP,#MEMM]       ; clear MEMM (and r12) flags
d1261 1
a1261 1
        BL      MSGSEARCHLIST          ; check list of LIBRARYs. May inc r1
d1263 1
a1263 1
        BL      MSGSEARCHLIST          ; check list of INSTALLs. May inc r1
d1265 1
a1265 1
        TEQ     R2,#0                  ; check list of OVERLAYs. May inc r1
d1271 2
a1272 2
; r1 = highest program section start (of ALL sections) below LINE ptr
; Now search from that pointer to end of that program section...
d1275 2
a1276 2
MSG0    CMP     R1,LINE                ; is this line > error line?
        BHI     MSG1                   ; yes, so go use last ERL
d1282 3
a1284 3
        ADD     R0,R0,R2,LSL #8        ; r0 = line number
        LDRB    R2,[R1,#3]             ; line length
        ADD     R1,R1,R2               ; move ptr to next line
d1294 5
a1298 6
        STR     R0,[ARGP,#ERRNUM]      ; store ERR
        CMP     R0,#0                  ; is ERR = 0 ?
        LDRNE   LINE,[ARGP,#ERRORH]    ; no,  so use last error handler
        STREQ   LINE,[ARGP,#ERRORH]    ; yes, save default error handler

MSGA    LDRB    R0,[R7],#1             ; copy error message ...
d1300 1
a1300 1
        STRNEB  R0,[R1],#1             ; ... to error buffer
d1304 2
a1305 3
        BEQ     MSGLIBRARYDONE         ; B if in base prog not in extra bit

; Look for REM [>] <name> in first line of LIBRARY, INSTALL or OVERLAY
d1316 1
a1316 1
        MOV     R3,#"i"                ; add 'in "library name"' to error
d1325 1
a1325 1
        BL      MSGADDONEND            ; Copy name of Library
d1336 6
a1341 8
        ; Changed code to try harder to recover r13 after error
        CMP     R0,R1                ; is error stack ptr in basic mem?
        BHS     MSGSPE               ; no, so no hope - give error
        CMP     R0,SP                ; is error stack ptr > current sp?
        LDRLO   SP,[ARGP,#ERRSTK]    ; no, reset to last error handler
        B       MSGSP1               ; and try to continue...

MSGSPE                               ; raise nasty error and end
d1354 1
a1354 1
MSGSP1  BL      POPLOCALAR            ; clean up removed local string arrays
d1356 1
a1356 1
        B       STMT                  ; continue from LINE
d1364 2
a1365 3

MSGSEARCHLIST           ; Check entries in LIBRARY, INSTALL or OVERLAY lists
; exit r1 = highest program section start below LINE ptr ** SO FAR **
a1373 1

a1381 1

d1387 1
a1387 1
ORDERR  ADR     R0,ERRHAN              ; reset error handler to use default
a1400 1

a1420 1

a1475 1

a1490 1

@


1.17
log
@  Error handling fix, part 4
Detail:
  The commands TWIN and TWINO are redundant, so have been removed and
  now give a 'Mistake' error. The tokenisation has not been changed. CALLEDNAME
  is now redundant, but the first byte is used as a QUIT flag, so it has not
  been changed. BasicTrans was also changed to remove references to TWIN, and
  say 'This command is no longer available'. Fixes line number of error when
  TWIN entered after Fix 1.
Admin:
  Changes by Martin Avison

Version 1.53. Not tagged
@
text
@d24 2
a25 8

 [ DO32BIT = 1
        MRS     R1,CPSR
        BIC     R1,R1,#&CF             ; IRQs+FIQs on, USR26/32 mode
        MSR     CPSR_c,R1
 |
        TEQP    PC,#0
 ]
d146 2
a147 9

 [ DO32BIT = 1
        MRS     R3,CPSR
        BIC     R3,R3,#&F
        MSR     CPSR_c,R3               ; change down to user mode (is this safe???)
 |
        MOV     R3,PC
        TEQP    R3,#3
 ]
a1167 2

 [ DO32BIT = 1
d1169 1
a1169 2
        MRS     R14,CPSR
 ]
d1201 1
a1201 2
 [ DO32BIT = 1
        MSR     CPSR_f,R14
a1202 4
 |
        MOVS    PC,R14
 ]

d1214 1
a1214 2
 [ DO32BIT = 1
        MSR     CPSR_f,R14
a1215 3
 |
        MOVS    PC,R14
 ]
@


1.16
log
@  Error handling fix, part 3
Detail:
  If r13 user if found to be invalid after an error, it is restored to
  the value for the last known error handler (as it was done if valid!).
Admin:
  Changes by Martin Avison

Version 1.53. Not tagged
@
text
@d642 2
a643 2
        &       TWIN-AJ2
        &       TWINO-AJ2
@


1.15
log
@  Error handling fix, part 2
Detail:
  LINE pointer r12 is saved & restored when appropriate.

  R12 must only be restored after a CALL, USR, SYS, *Commands or OSCLI aborts.
  To ensure this, the use of the MEMM flag has been changed slightly.

  Before SYS, *Commands and OSCLI are executed there is already a flag set in
  MEMM of x01, indicating that memory may be movable. This is set back to x00
  after they have successfully completed, and after an error in Stmt2.MSGERR.

  1.  The one test of MEMM (in Basic.MOVEMEMORY) was for equality with x01.
      This has been changed to test only for bit 1, not the whole byte.
  2.  Before SYS, *Commands and OSCLI the MEMM flag is now set to x03 not x01.
  3.  MEMM is now additionally set to x02 before CALLed code (also used by USR)
      and unset afterwards.
  4.  Whenever MEMM bit 1 is set, r12 is saved in R12STOR in the workspace.
  5.  In the error handling code, r12 is restored IF bit 1 is set in MEMM.

  Thus r12 can only be restored when it had just been stored, and there has
  been an error in external code. So these changes should be safe!
Admin:
  Changes by Martin Avison

Version 1.53. Not tagged
@
text
@d1374 8
a1381 3
        CMP     R1,R0                ; is error stack ptr in basic mem?
        CMPCS   R0,SP                ; is error stack ptr > current sp?
        BCS     MSGSP1               ; yes, so use current err handler
@


1.14
log
@  Error handling fix, part 1
Detail:
  The line number reported if r12 is outside program code is now -1 if
  below the program, or 99999 if above. Note that this change should not be
  required if r12 is always restored by fix 2, but there can be other cases!
Admin:
  Changes by Martin Avison

Version 1.53. Not tagged
@
text
@d52 5
d110 7
a116 4
        TEQ     R0,#1                   ;is "move memory" flag set?
        TEQEQ   R1,#0                   ;and no installed libraries?
        MOVNE   R1,#0
        LDMNEFD SP!,{R0,R2-R8,PC}       ; if not, refuse
d648 2
a649 1
        MOV     R14,#1
@


1.13
log
@  Additional comments and whitespace changes
Admin:
  Provided by Martin Avison, as part of his error handling changes in the
  following commits. This particular commit should build as binary identical
  to version 1.53.

Version 1.53. Not tagged
@
text
@d1274 11
d1306 1
d1314 2
@


1.12
log
@VFP/NEON assembler fixes and improvements
Detail:
  * Reworked to make ROM builds reference VFP/NEON assembler lookup tables held in ResourceFS instead of using local copies held in the module. Saves ~32K of ROM space due to reduced data duplication between BASIC & BASIC64.
  * Replace OPT flag magic numbers with symbols
  * Added support for VFPv4/ASIMDv2 instructions (VFMA/VFMS, VFNMA/VFNMS)
  * Updated DCFD/EQUFD to add support for .VFP and .FPA suffixes, to indicate whether VFP or FPA word order should be used
  * Added DCFH/EQUFH for storing half precision floats (in advanced half precision format)
  * Rework MSG routine to preserve R4-R7, for passing to BASICTrans as message parameters
  * Added a few new error messages (118-123) for the VFP/NEON assembler
  * Enable OWNERRORS option for standalone builds, and set DO32BIT to 0 for 26bit builds
  * Fixed VLDM/VSTM style register lists not working correctly when using commas to list the registers
  * Improved handling of VFP/NEON 8 bit immediate constants:
    - No longer possible to use #I64.<n>, #F32.<n>, #F64.<n> notation to directly specify the 8-bit encoded value for I64/F32/F64 constants, nor to force one instruction to attempt to use a constant in a format that doesn't match the .<dt> instruction suffix
    - Instead, .I64 constants can either be specified as a number (which will be converted to an integer and then zero-extended to 64 bits) or a string (which will be parsed by the 64bit version of OS_ReadUnsigned)
    - .F32 and .F64 constants should now be specified as floating point numbers which will then be correctly converted to the 8 bit encoding
    - .F32 and .F64 constants which can't be converted will result in a error message indicating the closest possible floating point number that can be encoded (but not necessarily the closest number that can be encoded; e.g. when assembling NEON instructions the assembler can automatically make use of .I32 encoding formats for some numbers)
  * Fixed instructions that have an 'imn' field (e.g. VSHR immediate) being incorrectly assembled
  * VFPLib.GenData & VFPLib.VFPLib now stored as text instead of tokenised BASIC
  Files changed:
  * Makefile, VFPLib.GenData, VFPLib.VFPLib, hdr.VFPMacros, hdr.Workspace, s.Assembler, s.Basic, s.ErrorMsgs, s.Factor, s.ModHead, s.VFP
Admin:
  Tested as softloaded module & in Iyonix ROM softload
  Requires BASICTrans 2.13 for new error messages to work properly


Version 1.50. Tagged as 'BASIC-1_50'
@
text
@d49 2
a50 1
OSERRR
d52 2
a53 2
        ADD     R14,R14,#STRACC
        ADD     R14,R14,#4
d55 1
d58 1
d84 1
a84 1
        TEQ     R0,#0                   ;ignore grows
d539 1
d550 1
d606 1
d637 1
d646 1
d672 1
d1122 1
d1153 1
d1157 1
d1167 1
d1214 1
d1237 10
a1246 3
MSG     SUB     R3,R14,PC
        ADD     R3,PC,R3
        SUB     R3,R3,#4               ;byte error
d1249 3
a1251 3
        LDRB    R2,[R3],#1             ;move error number
        STR     R2,[R1],#4
        LDRB    R0,[R3],#1             ;unique error number
d1255 1
a1255 1
        ADD     R9,R14,#4              ;copy my error message
d1264 1
a1264 1
        STRB    R14,[ARGP,#MEMM]
d1277 1
a1277 1
        BL      MSGSEARCHLIST
d1279 1
a1279 1
        BL      MSGSEARCHLIST
d1281 1
a1281 1
        TEQ     R2,#0
d1287 2
d1291 2
a1292 2
MSG0    CMP     R1,LINE
        BHI     MSG1
d1294 2
a1295 2
        CMP     R2,#&FF
        BEQ     MSG1
d1297 3
a1299 3
        ADD     R0,R0,R2,LSL #8
        LDRB    R2,[R1,#3]
        ADD     R1,R1,R2
d1301 2
a1302 1
MSG1    STR     R0,[ARGP,#ERRLIN]
d1304 2
a1305 2
        ADD     R4,R1,#255             ;end of buffer
        ADR     LINE,ERRHAN
d1307 6
a1312 5
        STR     R0,[ARGP,#ERRNUM]
        CMP     R0,#0
        LDRNE   LINE,[ARGP,#ERRORH]
        STREQ   LINE,[ARGP,#ERRORH]
MSGA    LDRB    R0,[R7],#1
d1314 1
a1314 1
        STRNEB  R0,[R1],#1
d1318 3
a1320 1
        BEQ     MSGLIBRARYDONE         ;not in a strange bit
d1331 1
a1331 1
        MOV     R3,#"i"
d1340 1
a1340 1
        BL      MSGADDONEND
d1351 3
a1353 3
        CMP     R1,R0
        CMPCS   R0,SP
        BCS     MSGSP1
d1360 1
d1366 1
a1366 1
MSGSP1  BL      POPLOCALAR
d1368 2
a1369 1
        B       STMT
d1376 3
a1378 1
MSGSEARCHLIST
d1387 1
d1396 1
d1401 2
a1402 1
ORDERR  ADR     R0,ERRHAN
d1405 2
d1416 1
d1437 1
d1493 1
d1509 1
@


1.11
log
@Lots of code improvements but no changes to the built binary.

This update replaces lots of hard-wired definitions of things such as SWI
names with the ones from the main exports in the build environment. It
should build a binary-identical module to the previous revision.

Author: Rob Sprowson

Version 1.40. Tagged as 'BASIC-1_40'
@
text
@d17 6
d236 15
d1223 3
a1225 3
MSG     SUB     R4,R14,PC
        ADD     R4,PC,R4
        SUB     R4,R4,#4               ;byte error
d1228 1
a1228 1
        LDRB    R2,[R4],#1             ;move error number
d1230 1
a1230 1
        LDRB    R0,[R4],#1             ;unique error number
d1232 1
a1232 1
        ADR     R4,NOERRORMSG          ;error message in case of none
d1234 3
a1236 3
        ADD     R5,R14,#4              ;copy my error message
MSGBYTE LDRB    R2,[R4],#1
        STRB    R2,[R5],#1
@


1.10
log
@Bugfix: the TITLE routine was stacking and unstacking R13. This is defined
as UNPREDICTABLE in the ARM ARM, and while it seems to have been harmless on
older ARMs, the XScale corrupts R13 - in this case, it was always loaded with
the value &80F0. This meant that you couldn't load untokenised BASIC programs
via the *BASIC command because TOP was already above the bottom of the stack!
Also optimised a non-aligned data copy routine a little bit.

Version 1.34. Tagged as 'BASIC-1_34'
@
text
@a15 175
                                ^       0
WRITEC                          #       1
WRITES                          #       1
WRITE0                          #       1
NEWLINE                         #       1
READC                           #       1
CLI                             #       1
BYTE                            #       1
WORD                            #       1
FILE                            #       1
ARGS                            #       1
BGET                            #       1
BPUT                            #       1
MULTIPLE                        #       1
OPEN                            #       1
READLINE                        #       1
CONTROL                         #       1
GETENV                          #       1
EXIT                            #       1
SETENV                          #       1
INTON                           #       1
INTOFF                          #       1
CALLBACK                        #       1
ENTERSWI                        #       1
BREAKPT                         #       1
BREAKCT                         #       1
UNUSEDSWI                       #       1
SETMEMC                         #       1
SETCALLBACK                     #       1
MOUSE                           #       1                      ;<-
HEAP                            #       1
MODULE                          #       1
CLAIM                           #       1
RELEASE                         #       1
READUNSIGNED                    #       1
GENERATEEVENT                   #       1
READVARVAL                      #       1
SETVARVAL                       #       1
GSINIT                          #       1
GSREAD                          #       1
GSTRANS                         #       1
BINARYTODECIMAL                 #       1
FSCONTROL                       #       1
CHANGEDYNAMICAREA               #       1
GENERATEERROR                   #       1
READESCAPESTATE                 #       1
EVALUATEEXPRESSION              #       1
SPRITEOP                        #       1
READPALETTE                     #       1
SERVICECALL                     #       1
READVDUVARIABLES                #       1
READPOINT                       #       1
UPCALL                          #       1
CALLAVECTOR                     #       1
READMODEVARIABLE                #       1
REMOVECURSORS                   #       1
RESTORECURSORS                  #       1
SWINUMBERTOSTRING               #       1
SWINUMBERFROMSTRING             #       1

SOUNDSWIBASE                    *       &40140
SOUNDCONFIGURE                  *       SOUNDSWIBASE
SOUNDENABLE                     *       SOUNDSWIBASE+1
SOUNDSTEREO                     *       SOUNDSWIBASE+2

SOUNDCONTROL                    *       SOUNDSWIBASE+&40+6
SOUNDVOICE                      *       SOUNDSWIBASE+&40+10

SOUNDEVENTQSCHEDULE             *       SOUNDSWIBASE+&80+1
SOUNDEVENTTEMPO                 *       SOUNDSWIBASE+&80+5
SOUNDEVENTQBEAT                 *       SOUNDSWIBASE+&80+6

XOSPLOT                         *       &20045
XOSSYNCHRONISECODEAREAS         *       &2006E
WRITEN                          *       &46
SETCOLOUR                       *       &61
SCREENMODE                      *       &65
XSCREENMODE                     *       &20065
WIMPSLOT                        *       &400EC
COLOURTRANSSETGCOL              *       &40743
COLOURTRANSSETTEXTCOLOUR        *       &40761
OSCHANGEENV                     *       &20040
BASICTrans_HELP                 *       &62C80
BASICTrans_Error                *       &62C81
BASICTrans_Message              *       &62C82
Territory_ReadCalendarInformation *     &4305F

WRITEI                          *       256

;allocation relative to vars/ARGP
                                ^       -&700
ERRORS                          #       256
STRACC                          #       256
OUTPUT                          #       512
FREELIST                        #       256                    ;one word for sizes 4..252(3,4,5) bytes
PROCPTR                         #       4
VARPTR                          #       4*("z"+1-"A")          ;arranged s.t. 4*(ch-"@@") is right
FNTEMPLOC                       *       PROCPTR+4*("["-"@@")    ;4 words for the secret use of FN/PROC
;these four words must be zero for lvar to work!
RECPTR                          #       4
FNPTR                           #       4
DATAP                           #       4
TALLY                           #       4
WIDTHLOC                        #       4                      ;immediately before intvar
INTVAR                          #       4*27                   ;-&100 from ARGP
ASSPC                           *       4*("P"-"@@")+INTVAR
PAGE                            #       4                      ;ALWAYS immediately after INTVAR
TOP                             #       4
FSA                             #       4
LOMEM                           #       4
HIMEM                           #       4
ERRNUM                          #       4
ERRORH                          #       4
ERRSTK                          #       4
ERRLIN                          #       4
ESCWORD                         #       4
ESCFLG                          *       ESCWORD
TRCFLG                          *       ESCWORD+1
TRCNUM                          #       4
TRACEFILE                       #       4
LOCALARLIST                     #       4
INSTALLLIST                     #       4
LIBRARYLIST                     #       4
OVERPTR                         #       4                      ;pointer to array of overlay information
MEMLIMIT                        #       4
OLDERR                          #       4*9
SWICODE                         #       8
OS_Exit_ABEX                    *       SWICODE
OS_Exit_RetCode                 *       SWICODE+4
DIMLOCAL                        #       4                      ;pointer to head of DIM LOCAL list
SEED                            #       5
LISTOP                          #       1
BYTESM                          #       1
MEMM                            #       1
; <- Insert new bits here
CALLEDNAME                      #       0-(MEMM+1)             ;needs to be /at least/ one byte for -quit flag

 [ FP=0
CACHESIZE                       *       128
CACHEMASK                       *       2_11111110
CACHESHIFT                      *       3
CACHECHECK                      *       4*2                    ;address where check value held
 |
CACHESIZE                       *       256
CACHEMASK                       *       2_11111111
CACHESHIFT                      *       4
CACHECHECK                      *       4*2                    ;address where check value held
 ]

VCACHE                          #       CACHESIZE*16
FREE                            #       0                      ;start of everything else

; BASIC's stack structure [SP,SP+4,SP+8...]:
;
; GOSUB.RETURN       is TRETURN, ADDR
; REPEAT.UNTIL       is TUNTIL, ADDR
; WHILE.ENDWHILE     is TENDWH, block start ADDR, expr start ADDR
; integer FOR.NEXT   is TNEXT, varaddr, ADDR, step, limit
; fp FOR.NEXT        is TFOR, varaddr, ADDR, step (8), limit (8)
; FN                 is n words on stack, the bottom being TFN
; PROC               is n words on stack, the bottom being TPROC
; LOCAL A(X)         is 256+{4,5,128}, linklist, address, numbytes, arraylist
; LOCAL ERROR        is TERROR, !ERRSTK, !ERRORH
; DIM var LOCAL expr is TDIM, bytes (rounded upto whole multiple of 4), linklist (going up the stack)
;
; BASIC VCache structure:
;
; variable   IACC, MOVEBY, CHECK, TYPE
; number     IACC, MOVEBY, CHECK, TYPE
; GOTO       R1,   MOVEBY, CHECK
; THENline   R1,         , CHECK
; FN/PROC    IACC, MOVEBY, CHECK, ( or not

CFLAG                           *       &20000000
SAFECRUNCH                      *       15
d26 1
a26 1
        SWI     GETENV
d31 2
a32 2
        SWI     GENERATEERROR
        SWI     EXIT
a36 27
 [ FP=0
FACC    RN      R0
FACCX   RN      R1
FGRD    RN      R2
FSIGN   RN      R3
FWACC   RN      R4
FWACCX  RN      R5
FWGRD   RN      R6
FWSIGN  RN      R7
 |
FACC    FN      0
F1      FN      1
F2      FN      2
F7      FN      7
 ]
IACC    RN      R0                     ;pointer to some data (i.e. a variable's value)
CLEN    RN      R2                     ;actually contains STRACC+CLEN
ARGP    RN      R8                     ;workspace pointer
TYPE    RN      R9                     ;type of a variable/expression
AELINE  RN      R11                    ;pointer to some interesting part of the current line
LINE    RN      R12                    ;pointer to the current position in the program (i.e. for errors)
SP      RN      R13                    ;stack pointer
SOURCE  RN      R1
DEST    RN      R2
MODE    RN      R3
CONSTA  RN      R4                     ;0 for none, tconst for allowed
SMODE   RN      R5
a37 55
; Types...
TINTEGER                        *       &40000000              ;string TYPE is 0
TFP                             *       &80000000
TEFP                            *       &20000000
 [ FP=0
TFPLV                           *       5
 |
TFPLV                           *       8
 ]
;pull and junk n items from stack
        MACRO
$L      PULLJ   $N
$L      ADD     SP,SP,#4*$N
        MEND
;allow space for n items from stack
        MACRO
$L      PUSHJ   $N
$L      SUB     SP,SP,#4*$N
        MEND
;load misaligned word using 2 other registers $DEST MUST BE < $W2
;$DEST may be $ADDR
        MACRO
$L      LOAD    $DEST,$ADDR,$W1,$W2
$L      BIC     $W2,$ADDR,#3
        AND     $W1,$ADDR,#3
        LDMIA   $W2,{$DEST,$W2}
        MOVS    $W1,$W1,LSL #3
        MOVNE   $DEST,$DEST,LSR $W1
        RSBNE   $W1,$W1,#32
        ORRNE   $DEST,$DEST,$W2,LSL $W1
        MEND
 [ FP=0
;save fp acc to address in TYPE [Format 2 only]
        MACRO
$L      FSTA    $ADDR
$L      ORR     FGRD,FSIGN,FACCX
        STMIA   $ADDR,{FACC,FGRD}
        MEND
        MACRO
$L      FPUSH
$L      ORR     FGRD,FSIGN,FACCX
        STMFD   SP!,{FACC,FGRD}
        MEND
        MACRO
$L      FLDA    $ADDR
$L      LDMIA   $ADDR,{FACC,FACCX}
        AND     FSIGN,FACCX,#&80000000
        AND     FACCX,FACCX,#255
        MEND
 |
        MACRO
$L      FPUSH
$L      STFD    FACC,[SP,#-8]!
        MEND
 ]
d56 1
a56 1
        SWINE   OPEN+&20000            ;XOSCLOSE
d59 1
a59 1
        SWI     OSCHANGEENV
d62 1
a62 1
        SWI     OSCHANGEENV
d65 1
a65 1
        SWI     OSCHANGEENV
d68 1
a68 1
        SWI     OSCHANGEENV
d78 2
a79 2
 [ 1=0
        SWI     WRITES
d84 4
a87 4
        SWI     &DC
        SWI     WRITE0
        SWI     WRITEI+")"
        SWI     NEWLINE
d99 1
a99 1
        LDMNEFD SP!,{R0,R2-R8,PC} ; if not, refuse
d104 1
a104 1
        SWI     OSCHANGEENV             ;read end of application space
d187 1
a187 1
        SWI     ENTERSWI
d195 1
a195 1
        SWINE   OPEN+&20000            ;XOSCLOSE
d198 1
a198 1
        SWI     OSCHANGEENV
d201 1
a201 1
        SWI     OSCHANGEENV
d204 1
a204 1
        SWI     OSCHANGEENV
d207 1
a207 1
        SWI     OSCHANGEENV
d211 1
a211 1
        SWI     EXIT
d225 2
a226 2
        SWI     XOSSYNCHRONISECODEAREAS
 [ FP=1
d235 1
a235 1
        SWI     OSCHANGEENV
d240 1
a240 1
        SWI     OSCHANGEENV
d245 1
a245 1
        SWI     OSCHANGEENV
d250 1
a250 1
        SWI     OSCHANGEENV
d254 1
a254 1
        SWI     GETENV
d296 1
a296 1
        SWI     GETENV
d354 1
a354 1
        SWI     READVARVAL+&20000
d363 1
a363 1
        SWI     WRITES
d365 1
a365 1
 [ FP=1
d368 1
a368 1
        =       " version $Version (C) Acorn 1989",10,13,0
d370 1
a370 1
        SWI     WRITES
d379 1
a379 1
        SWI     WRITES
d387 1
a387 1
        SWI     BASICTrans_Message
d389 1
a389 1
        SWI     WRITES
d394 1
a394 1
        SWI     WRITES
d472 2
a473 2
        MOV     R0,#17+FP
        SWI     BASICTrans_Message
d475 1
a475 1
        SWI     WRITES
d481 1
a481 1
        SWI     BASICTrans_Message
d483 1
a483 1
        SWI     WRITES
d487 2
a488 2
        MOV     R0,#20+FP
        SWI     BASICTrans_Message
d490 1
a490 1
        SWI     WRITES
d541 1
a541 1
        SWIEQ   EXIT
d543 1
a543 1
        SWI     WRITEI+">"
d557 1
a557 1
        SWI     BASICTrans_Message
d559 1
a559 1
        SWI     WRITES
d565 1
a565 1
        SWI     BASICTrans_Message
d567 1
a567 1
        SWI     WRITES
d574 1
a574 1
        SWI     BASICTrans_Message
d576 1
a576 1
        SWI     WRITES
d614 1
a614 1
        SWI     CLI
d659 1
a659 1
 [ FP=0
d733 1
a733 1
 [ FP=0
d1218 1
a1218 1
        SWI     BASICTrans_Error       ;overwrite with foreign one
d1227 1
a1227 1
        SWI     BYTE
d1229 1
a1229 1
        SWI     BYTE
d1307 1
a1307 1
        SWI     BASICTrans_Message
d1309 1
a1309 1
        SWI     WRITES
d1339 1
a1339 1
        SWI     READLINE
d1343 1
a1343 1
NLINE   SWI     NEWLINE
d1444 2
a1445 2
        SWI     WRITEI+23
        SWI     WRITEI+" "
d1450 3
a1452 3
        SWI     WRITEI+23
        SWI     WRITEI+" "
        SWI     WRITEC
d1454 1
a1454 1
        SWI     WRITEC
d1456 1
a1456 1
        SWI     WRITEC
d1458 1
a1458 1
        SWI     WRITEC
d1460 1
a1460 1
        SWI     WRITEC
d1462 1
a1462 1
        SWI     WRITEC
d1464 1
a1464 1
        SWI     WRITEC
d1466 2
a1467 2
        SWI     WRITEC
        SWI     WRITEI+" "
a1469 189
                                ^       &7F                    ;single byte tokens
TOTHER                          #       1
TAND                            #       1                      ;expression binary operators
TDIV                            #       1
TEOR                            #       1
TMOD                            #       1
TOR                             #       1

TERROR                          #       1                      ;miscellaneous words
TLINE                           #       1
TOFF                            #       1
TSTEP                           #       1
TSPC                            #       1
TTAB                            #       1
TELSE                           #       1
TTHEN                           #       1

TCONST                          #       1                      ;(8D)

TOPENU                          #       1

TPTR                            #       1                      ;polymorphics as functions
TPAGE                           #       1
TTIME                           #       1
TLOMEM                          #       1
THIMEM                          #       1
TABS                            #       1                      ;expression class of unary operators
TACS                            #       1
TADC                            #       1
TASC                            #       1
TASN                            #       1
TATN                            #       1
TBGET                           #       1
TCOS                            #       1
TCOUNT                          #       1
TDEG                            #       1
TERL                            #       1
TERR                            #       1
TEVAL                           #       1
TEXP                            #       1
TEXT                            #       1
TFALSE                          #       1
TFN                             #       1
TGET                            #       1
TINKEY                          #       1
TINSTR                          #       1
TINT                            #       1
TLEN                            #       1
TLN                             #       1
TLOG                            #       1
TNOT                            #       1
TOPENI                          #       1
TOPENO                          #       1
TPI                             #       1
TPOINT                          #       1
TPOS                            #       1
TRAD                            #       1
TRND                            #       1
TSGN                            #       1
TSIN                            #       1
TSQR                            #       1
TTAN                            #       1
TTO                             #       1
TTRUE                           #       1
TUSR                            #       1
TVAL                            #       1
TVPOS                           #       1
TCHRD                           #       1                      ;string expression class of unary operators
TGETD                           #       1
TINKED                          #       1
TLEFTD                          #       1
TMIDD                           #       1
TRIGHTD                         #       1
TSTRD                           #       1
TSTRND                          #       1
TEOF                            #       1

TESCFN                          #       1                      ;Escape for Functions
TESCCOM                         #       1                      ;Escape for Commands
TESCSTMT                        #       1                      ;Escape for Statements

TWHEN                           #       1                      ;statements
TOF                             #       1
TENDCA                          #       1
TELSE2                          #       1
TENDIF                          #       1
TENDWH                          #       1

TPTR2                           #       1                      ;polymorphic again
TPAGE2                          #       1
TTIME2                          #       1
TLOMM2                          #       1
THIMM2                          #       1

TBEEP                           #       1
TBPUT                           #       1
TCALL                           #       1
TCHAIN                          #       1
TCLEAR                          #       1
TCLOSE                          #       1
TCLG                            #       1
TCLS                            #       1
TDATA                           #       1
TDEF                            #       1
TDIM                            #       1
TDRAW                           #       1
TEND                            #       1
TENDPR                          #       1
TENVEL                          #       1
TFOR                            #       1
TGOSUB                          #       1
TGOTO                           #       1
TGRAPH                          #       1
TIF                             #       1
TINPUT                          #       1
TLET                            #       1
TLOCAL                          #       1
TMODE                           #       1
TMOVE                           #       1
TNEXT                           #       1
TON                             #       1
TVDU                            #       1
TPLOT                           #       1
TPRINT                          #       1
TPROC                           #       1
TREAD                           #       1
TREM                            #       1
TREPEAT                         #       1
TREPORT                         #       1
TRESTORE                        #       1
TRETURN                         #       1
TRUN                            #       1
TSTOP                           #       1
TTEXT                           #       1
TTRACE                          #       1
TUNTIL                          #       1
TWIDTH                          #       1
TOSCL                           #       1                      ;this must be <=&FF (!)

                                ^       &8E                    ;Two byte function tokens
TSUM                            #       1
TBEAT                           #       1
TTWOFUNCLIMIT                   #       0

                                ^       &8E                    ;Two byte Statement tokens
TCASE                           #       1
TCIRCLE                         #       1
TFILL                           #       1
TORGIN                          #       1
TPSET                           #       1
TRECT                           #       1
TSWAP                           #       1
TWHILE                          #       1
TWAIT                           #       1
TMOUSE                          #       1
TQUIT                           #       1
TSYS                            #       1
TINSTALLBAD                     #       1                      ;a silly blunder
TLIBRARY                        #       1
TTINT                           #       1
TELLIPSE                        #       1
TBEATS                          #       1
TTEMPO                          #       1
TVOICES                         #       1
TVOICE                          #       1
TSTEREO                         #       1
TOVERLAY                        #       1
TTWOSTMTLIMIT                   #       0

                                ^       &8E                    ;Two byte Command tokens
TAPPEND                         #       1
TAUTO                           #       1
TCRUNCH                         #       1
TDELET                          #       1
TEDIT                           #       1
THELP                           #       1
TLIST                           #       1
TLOAD                           #       1
TLVAR                           #       1
TNEW                            #       1
TOLD                            #       1
TRENUM                          #       1
TSAVE                           #       1
TTEXTLOAD                       #       1
TTEXTSAVE                       #       1
TTWIN                           #       1
TTWINO                          #       1
TINSTALL                        #       1
TTWOCOMMLIMIT                   #       0
@


1.9
log
@New version from Kevin: appears to be fixes for top-bit-set addresses.
This is the version included in release 5.00 of the OS.

Version 1.33. Tagged as 'BASIC-1_33'
@
text
@d619 1
a619 1
TITLE   STMFD   SP!,{R0-R14}
d645 1
a645 1
        LDMVCFD SP!,{R0-R13,PC}
d654 1
a654 1
        LDMFD   SP!,{R0-R13,PC}
@


1.8
log
@Fixed a couple of >64M address problems.

Version 1.32. Tagged as 'BASIC-1_32'
@
text
@d1016 1
a1016 1
        BIC     AELINE,AELINE,#TFP
d1025 2
a1026 1
        ADDS    AELINE,LINE,R1
@


1.7
log
@  * Performance tweaks.
  * Comments added.
  * Added DIM LOCAL.
Detail:
  * All of the 408 instances of pushes and pops of a single register
    (i.e. "LDMIA SP!,{PC}") have been replaced with an LDR/STR equivalent,
    which provides a small performance boost on StrongARM-like processors.
  * Some obscure bits of the source have had comments added.
  * The new DIM LOCAL statement has been added:

    Syntax: DIM <numeric variable> LOCAL <numeric expression>

    DIM LOCAL allocates space from the BASIC stack rather than from the
    heap. This means that the space allocated is automatically freed on
    exit from the PROC or FN in which it was claimed.

    As with all LOCAL statements, it must appear in a PROC or FN definition
    and cannot appear inside a structure which uses the stack (i.e. NEXT)
    or after a LOCAL ERROR.

    Much like the manner in which "DIM foo% -1" returns the value of FSA
    without allocating space, "DIM foo% LOCAL -1" returns the value of SP
    at the time of the request, without allocating any space from the stack.
    This can be useful in computing the free space between the top of the
    BASIC heap and the bottom of the stack. Of course, the stack is used by
    BASIC while interpreting the program, so the contents of memory below
    foo% should always be treated as undefined.

    One caveat of using DIM LOCAL is that the stack cannot be moved while
    there are DIM LOCALs defined. END= will return an error and any
    Service_Memory calls will be claimed for the duration of the DIM LOCAL.
Admin:
  Builds and tested on RiscPC.
  Requires BASICTrans-2_06.

Version 1.30. Tagged as 'BASIC-1_30'
@
text
@d1458 3
a1460 1
MSG     BIC     R4,R14,#&FC000000      ;byte error
d1691 3
a1693 1
PATOUT  BIC     R2,R14,#&FC000003
@


1.6
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 1.27. Tagged as 'BASIC-1_27'
@
text
@d145 1
d150 2
a151 2

CALLEDNAME                      #       0-(MEMM+1)
a165 1

a166 8
;GOSUB.RETURN is TRETURN, ADDR
;REPEAT.UNTIL is TUNTIL, ADDR
;WHILE.ENDWHILE is TENDWH, block start ADDR, expr start ADDR
;integer FOR.NEXT is TNEXT, varaddr, ADDR, step, limit
;fp FOR.NEXT is TFOR, varaddr, ADDR, step (8), limit (8)
;FN is n words on stack, the bottom being TFN
;PROC is n words on stack, the bottom being TPROC
;LOCAL A(X) is 256+{4,5,128}, linklist, address, numbytes, arraylist
d168 20
a187 6
;Cache structure:
;variable   IACC, MOVEBY, CHECK, TYPE
;number     IACC, MOVEBY, CHECK, TYPE
;GOTO       R1,   MOVEBY, CHECK
;THENline   R1,         , CHECK
;FN/PROC    IACC, MOVEBY, CHECK, ( or not
d227 1
a227 1
IACC    RN      R0
d229 5
a233 5
ARGP    RN      R8
TYPE    RN      R9
AELINE  RN      R11
LINE    RN      R12
SP      RN      R13
d240 1
d368 4
a371 1
        MOV     R0,R0
d374 1
d523 1
d807 1
a807 1
        STMFD   SP!,{SMODE}
d810 1
a810 1
        LDMFD   SP!,{SMODE}
d1396 1
a1396 1
        STMFD   SP!,{R14}
d1432 1
a1432 1
        LDMFD   SP!,{PC}
d1449 1
a1449 1
        LDMFD   SP!,{PC}
d1615 1
a1615 1
        STMFD   SP!,{R14}
d1621 1
a1621 1
        LDMLSFD SP!,{PC}               ;very easy
d1628 2
a1629 2
        LDMFD   SP!,{PC}
INSERT  STMFD   SP!,{R14}              ;insert at end of text
d1634 1
a1634 1
INSRT   STMFD   SP!,{R14}
d1639 1
a1639 1
        LDMEQFD SP!,{PC}
d1679 1
a1679 1
        LDMEQFD SP!,{PC}
d1687 1
a1687 1
        LDMFD   SP!,{PC}
@


1.5
log
@* New forms of MODE, COLOUR and GCOL added.
* VDU can now be used as a function to read VDU variables.
* Will surrender application memory for MODE changes etc.

See Doc.Changes for full info.

Version 1.26. Tagged as 'BASIC-1_26'
@
text
@d189 1
a189 1
        MRS     ,R1,CPSR
d191 1
a191 1
        MSR     ,CPSR_c,R1
d383 1
a383 1
        MRS    ,R3,CPSR
d385 1
a385 1
        MSR    ,CPSR_c,R3               ; change down to user mode (is this safe???)
d1127 1
a1127 1
        &       LETST-AJ               ; 5C '\'
d1385 1
a1385 1
        MRS     ,R14,CPSR
d1419 1
a1419 1
        MSR     ,CPSR_f,R14
d1436 1
a1436 1
        MSR     ,CPSR_f,R14
d1900 1
a1900 1
        LNK     s.Fp
@


1.4
log
@  Fixed bug in Exit handler

Detail:
  The new addition which allows an exit code to be passed using the syntax
"QUIT <expression>" was incorrectly assuming it had access to the workspace
via ARGP when it didn't, this caused a data abort when issuing *quit from
BASIC, or in fact when any program called from BASIC called it's exit
handler.

  It turned out that the required parameters for OS_Exit were already being
pointed to by R12, so a simple LDMIA was sufficient.

Admin:
  Tested on a RiscPC



Version 1.25. Tagged as 'BASIC-1_25'
@
text
@d91 1
d93 1
d148 1
d150 1
a150 1
CALLEDNAME                      #       0-(BYTESM+1)
d320 117
d513 1
d779 1
d857 2
d860 2
d1463 2
@


1.3
log
@Guess who left some debugging in there...
@
text
@d334 2
a335 2
        LDR     R1,[ARGP,#OS_Exit_ABEX]
        LDR     R2,[ARGP,#OS_Exit_RetCode]
@


1.2
log
@  Some bug fixes and a few new features.
Detail:
  * ALIGN will now force any unused bytes to zero when assembling at
    both P% and O%. This is better than leaving possibly uninitialised
    memory behind (makes diffs very difficult).

  * The assembler now correctly recognises the new 'LR' special variable
    when the L is lower-case.

  * The assembler also has the 'SP' (13) special variable defined.

  * TRACE PROC (and the identical TRACE FN) now flushes the VCACHE when
    it is encountered.

  * TRACE ENDPROC has been implemented to allow the output of 'ENDPROC'
    and 'ENDFN' in the trace output whenever a procedure or function is
    exited. This complements the TRACE PROC/FN functionality.

  * QUIT <expression> has been added to allow a return code to be passed
    back to the called when BASIC exits. This is the /only/ sensible way
    for a BASIC program to set Sys$ReturnCode on exit (others get trashed
    when BASIC removes it's environment handlers).
Admin:
  Tested on a StrongARM RiscPC.

  Some of the reformatting from the last checkin has been improved.

  s.ModuleAB and s.ModuleAB64 have been renamed to s.BASIC105 and
  s.BASIC64 respectively. This will help with the new Brodie Make-o-
  Matik(tm) Makefiles.

Version 1.24. Tagged as 'BASIC-1_24'
@
text
@d1320 1
a1320 9
MSG

 STMFD SP!,{R0-R12,R14}
 SWI XOS_WriteS
 DCB "MSG",10,13,0
 ALIGN
 LDMFD SP!,{R0-R12,R14}

        BIC     R4,R14,#&FC000000      ;byte error
a1329 7

 STMFD SP!,{R0-R12,R14}
 SWI XOS_WriteS
 DCB "MSGBYTE",10,13,0
 ALIGN
 LDMFD SP!,{R0-R12,R14}

d1335 1
a1335 9
MSGERR

 STMFD SP!,{R0-R12,R14}
 SWI XOS_WriteS
 DCB "MSGERR",10,13,0
 ALIGN
 LDMFD SP!,{R0-R12,R14}

        MOV     ARGP,#VARS             ;cardinal error from outside world
a1359 7

 STMFD SP!,{R0-R12,R14}
 SWI XOS_WriteS
 DCB "MSGSTART",10,13,0
 ALIGN
 LDMFD SP!,{R0-R12,R14}

d1426 1
a1426 9
MSGSP2

 STMFD SP!,{R0-R12,R14}
 SWI XOS_WriteS
 DCB "MSGSP2",10,13,0
 ALIGN
 LDMFD SP!,{R0-R12,R14}

        LDR     R1,[ARGP,#HIMEM]
d1431 1
a1431 9
MSGSP1

 STMFD SP!,{R0-R12,R14}
 SWI XOS_WriteS
 DCB "MSGSP1",10,13,0
 ALIGN
 LDMFD SP!,{R0-R12,R14}

        BL      POPLOCALAR
@


1.1
log
@  Improved BASIC build structure. No code change.
Detail:
  Makefile strips dependencies during the clean phase.

  Sources moved into an 's' directory.

  All sources reformatted into a more readable layout.
Admin:
  Builds binary-identical versions of BASIC and BASIC64 modules to
  version 1.22

Version 1.23. Tagged as 'BASIC-1_23'
@
text
@d16 1
a16 1
        ^       0
d99 1
a99 1
Territory_ReadCalendarInformation                               *       &4305F
d104 1
a104 1
        ^       -&700
a139 1
 [ STRONGARM = 1
d141 2
a142 1
 ]
d233 1
d334 3
d339 3
a342 1
 [ STRONGARM = 1
a351 1
 ]
d714 1
a714 1
AJ2                             *       .+4
d908 1
a908 1
AJ                              *       .+4
d945 6
a950 6
        &       LETSTNOTCACHE-AJ       ; 24
        &       LETST-AJ               ; 25
        &       LETST-AJ               ; 26
        &       LETST-AJ               ; 27
        &       LETST-AJ               ; 28
        &       LETST-AJ               ; 29
d952 15
a966 15
        &       LETST-AJ               ; 2B
        &       LETST-AJ               ; 2C
        &       LETST-AJ               ; 2D
        &       LETST-AJ               ; 2E
        &       LETST-AJ               ; 2F
        &       LETST-AJ               ; 30
        &       LETST-AJ               ; 31
        &       LETST-AJ               ; 32
        &       LETST-AJ               ; 33
        &       LETST-AJ               ; 34
        &       LETST-AJ               ; 35
        &       LETST-AJ               ; 36
        &       LETST-AJ               ; 37
        &       LETST-AJ               ; 38
        &       LETST-AJ               ; 39
d968 2
a969 2
        &       LETST-AJ               ; 3B
        &       LETST-AJ               ; 3C
d971 2
a972 2
        &       LETST-AJ               ; 3E
        &       LETSTNOTCACHE-AJ       ; 3F
d974 58
a1031 58
        &       LETST-AJ               ; 41
        &       LETST-AJ               ; 42
        &       LETST-AJ               ; 43
        &       LETST-AJ               ; 44
        &       LETST-AJ               ; 45
        &       LETST-AJ               ; 46
        &       LETST-AJ               ; 47
        &       LETST-AJ               ; 48
        &       LETST-AJ               ; 49
        &       LETST-AJ               ; 4A
        &       LETST-AJ               ; 4B
        &       LETST-AJ               ; 4C
        &       LETST-AJ               ; 4D
        &       LETST-AJ               ; 4E
        &       LETST-AJ               ; 4F
        &       LETST-AJ               ; 50
        &       LETST-AJ               ; 51
        &       LETST-AJ               ; 52
        &       LETST-AJ               ; 53
        &       LETST-AJ               ; 54
        &       LETST-AJ               ; 55
        &       LETST-AJ               ; 56
        &       LETST-AJ               ; 57
        &       LETST-AJ               ; 58
        &       LETST-AJ               ; 59
        &       LETST-AJ               ; 5A
        &       ASS-AJ                 ; 5B
        &       LETST-AJ               ; 5C
        &       LETST-AJ               ; 5D
        &       LETST-AJ               ; 5E
        &       LETST-AJ               ; 5F
        &       LETST-AJ               ; 60
        &       LETST-AJ               ; 61
        &       LETST-AJ               ; 62
        &       LETST-AJ               ; 63
        &       LETST-AJ               ; 64
        &       LETST-AJ               ; 65
        &       LETST-AJ               ; 66
        &       LETST-AJ               ; 67
        &       LETST-AJ               ; 68
        &       LETST-AJ               ; 69
        &       LETST-AJ               ; 6A
        &       LETST-AJ               ; 6B
        &       LETST-AJ               ; 6C
        &       LETST-AJ               ; 6D
        &       LETST-AJ               ; 6E
        &       LETST-AJ               ; 6F
        &       LETST-AJ               ; 70
        &       LETST-AJ               ; 71
        &       LETST-AJ               ; 72
        &       LETST-AJ               ; 73
        &       LETST-AJ               ; 74
        &       LETST-AJ               ; 75
        &       LETST-AJ               ; 76
        &       LETST-AJ               ; 77
        &       LETST-AJ               ; 78
        &       LETST-AJ               ; 79
        &       LETST-AJ               ; 7A
d1176 1
a1176 1
AJ3                             *       .+4
d1320 9
a1328 1
MSG     BIC     R4,R14,#&FC000000      ;byte error
d1338 7
d1350 9
a1358 1
MSGERR  MOV     ARGP,#VARS             ;cardinal error from outside world
d1383 7
d1456 9
a1464 1
MSGSP2  LDR     R1,[ARGP,#HIMEM]
d1469 9
a1477 1
MSGSP1  BL      POPLOCALAR
d1628 1
a1628 1
        ^       &7F                    ;single byte tokens
d1767 1
a1767 1
        ^       &8E                    ;Two byte function tokens
d1772 1
a1772 1
        ^       &8E                    ;Two byte Statement tokens
d1797 1
a1797 1
        ^       &8E                    ;Two byte Command tokens
@


head	1.9;
access;
symbols
	BASIC-1_75:1.9
	BASIC-1_74:1.9
	BASIC-1_73:1.9
	BASIC-1_72:1.9
	BASIC-1_71:1.9
	BASIC-1_70:1.9
	BASIC-1_69:1.9
	BASIC-1_68:1.9
	BASIC-1_67:1.9
	BASIC-1_66:1.8
	BASIC-1_65:1.7
	BASIC-1_64:1.6
	BASIC-1_63:1.5
	BASIC-1_62:1.5
	BASIC-1_61:1.5
	BASIC-1_60:1.5
	BASIC-1_59:1.5
	BASIC-1_58:1.5
	BASIC-1_57-pre4:1.5
	BASIC-1_57:1.5
	BASIC-1_57-pre3:1.5
	BASIC-1_57-pre2:1.5
	BASIC-1_57-pre1:1.5
	BASIC-1_56:1.4
	BASIC-1_55:1.4
	BASIC-1_54:1.4
	BASIC-1_53:1.4
	BASIC-1_52:1.4
	BASIC-1_51:1.4
	BASIC-1_50:1.4
	BASIC-1_49:1.4
	BASIC-1_48:1.4
	BASIC-1_47:1.4
	BASIC-1_46:1.4
	BASIC-1_45:1.4
	BASIC-1_44:1.4
	BASIC-1_43:1.4
	BASIC-1_42:1.4
	BASIC-1_41:1.4
	BASIC-1_40:1.4
	BASIC-1_39:1.3
	BASIC-1_37:1.3
	RO_5_07:1.3
	BASIC-1_36:1.3
	BASIC-1_35:1.3
	BASIC-1_34:1.3
	BASIC-1_33:1.3
	BASIC-1_32:1.3
	BASIC-1_31:1.3
	BASIC-1_30:1.3
	BASIC-1_29:1.2
	BASIC-1_28:1.2
	BASIC-1_27:1.2
	BASIC-1_26:1.1
	BASIC-1_25:1.1
	BASIC-1_24:1.1
	BASIC-1_23:1.1;
locks; strict;
comment	@# @;


1.9
date	2017.06.03.22.30.34;	author jlee;	state Exp;
branches;
next	1.8;
commitid	3Iuze3DCMuQaKYTz;

1.8
date	2017.04.13.21.51.01;	author jlee;	state Exp;
branches;
next	1.7;
commitid	ZJzmjWTA1gDlaqNz;

1.7
date	2017.03.30.21.47.23;	author jlee;	state Exp;
branches;
next	1.6;
commitid	lqoHPvfEgWn0BCLz;

1.6
date	2017.03.04.18.00.30;	author jlee;	state Exp;
branches;
next	1.5;
commitid	hnxezA9QYnbYagIz;

1.5
date	2013.12.01.17.23.40;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	iG291GP27DoPasfx;

1.4
date	2009.04.24.00.27.16;	author srevill;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.23.15.48.34;	author srevill;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.09.31.12;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.14.20.00.32;	author srevill;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Add "BASICVFP", a VFP version of BASIC64
Detail:
  See Doc/BASICVFP for overall design/specification
  File changes:
  - !Mk,fd7, !MkClean,fd7, !MkRom,fd7, Makefile - update build scripts to support BASICVFP target
  - Resources/UK/Messages - Add a few new messages
  - hdr/Definitions - Define BASICVFP register usage and a few utility macros
  - hdr/WorkSpace - Define BASICVFP workspace adjustments. Add a few asserts to check some workspace constraints are maintained.
  - s/* - Lots of changes to add support for BASICVFP variant of the module
Admin:
  Tested on Raspberry Pi 1/2/3, BB-xM


Version 1.67. Tagged as 'BASIC-1_67'
@
text
@; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;> fp2

 [ FPOINT=0
COSOP   STR     R14,[SP,#-4]!
        B       COS1
 ]
COS     STR     R14,[SP,#-4]!
        BL      FACTOR
        BLPL    FLOATQ
 [ FPOINT=0
COS1    CMP     FACCX,#&98
        BCS     FRNGQQ
        MOV     R10,#0
        MOV     FSIGN,#0
        FPUSH                          ;stack |X|
        ADR     TYPE,HALFPI
        BL      FADD
        BL      FRANGE
        BLMI    FCLR
        BL      INTRND
        TST     FACC,#1
        EORNE   R10,R10,#&80000000
        BL      IFLT
        MOV     FWSIGN,#&80000000
        MOV     FWACC,#&80000000
        MOV     FWACCX,#&80
        BL      FADDW
        B       SINCOMMON
 ELIF FPOINT=1
        COSD    FACC,FACC
        MOVS    TYPE,#TFP
        LDR     PC,[SP],#4
 ELIF FPOINT=2
        FPAop   COSD
        MOVS    TYPE,#TFP
        LDR     PC,[SP],#4
 |
        ! 1, "Unknown FPOINT setting"
 ]
 [ FPOINT=0
SINOP   STR     R14,[SP,#-4]!
        B       SIN1
 ]
SIN     ROUT
        STR     R14,[SP,#-4]!
        BL      FACTOR
        BLPL    FLOATQ
 [ FPOINT=0
SIN1    CMP     FACCX,#&98
        BCS     FRNGQQ
        MOV     R10,FSIGN
        MOV     FSIGN,#0
        FPUSH                          ;stack |X|
        BL      FRANGE
        BLMI    FCLR
        BL      INTRND
        TST     FACC,#1
        EORNE   R10,R10,#&80000000
        TEQ     FACC,#0
        BEQ     %20
        BL      IFLT
;
; STMFD SP!,{FACC,FSIGN,FACCX}
; ADR TYPE,HPIHI
; BL FMUL
; ADD TYPE,SP,#3*4+4 ;input value
; BL FADD
; FSTA TYPE
; LDMFD SP!,{FACC,FSIGN,FACCX}
; ADR TYPE,HPILO
; BL FMUL
; ADD TYPE,SP,#4 ;input value
; BL FADD
;
; Here follows DJS's disgusting code to multiply FACC by pi
;  = (2^0) + (2^-1) + (2^-4) + (2^-7) + (2^-11) - (2^-18) - (2^-20)
;    + (2^-22) + (2^-24) + (2^-26) + (2^-30) + (2^-34) + (2^-38)
;    - (2^-40) - (2^-42) + (2^-44) - (2^-49)
SINCOMMON
        MOV     FGRD,FACC,LSR #2
        ADD     FGRD,FGRD,FACC,LSR #6
        SUB     FGRD,FGRD,FACC,LSR #8
        SUB     FGRD,FGRD,FACC,LSR #10
        ADD     FGRD,FGRD,FACC,LSR #12
        SUB     FGRD,FGRD,FACC,LSR #17
        MOV     FWACC,#0
        ADDS    FGRD,FGRD,FACC,LSL #31
        ADC     FWACC,FWACC,FACC,LSR #1
        ADDS    FGRD,FGRD,FACC,LSL #28
        ADC     FWACC,FWACC,FACC,LSR #4
        ADDS    FGRD,FGRD,FACC,LSL #25
        ADC     FWACC,FWACC,FACC,LSR #7
        ADDS    FGRD,FGRD,FACC,LSL #21
        ADC     FWACC,FWACC,FACC,LSR #11
        SUBS    FGRD,FGRD,FACC,LSL #14
        SBC     FWACC,FWACC,FACC,LSR #18
        SUBS    FGRD,FGRD,FACC,LSL #12
        SBC     FWACC,FWACC,FACC,LSR #20
        ADDS    FGRD,FGRD,FACC,LSL #10
        ADC     FWACC,FWACC,FACC,LSR #22
        ADDS    FGRD,FGRD,FACC,LSL #8
        ADC     FWACC,FWACC,FACC,LSR #24
        ADDS    FGRD,FGRD,FACC,LSL #6
        ADC     FWACC,FWACC,FACC,LSR #26
        ADDS    FGRD,FGRD,FACC,LSL #2
        ADC     FWACC,FWACC,FACC,LSR #30
        ADDS    FACC,FACC,FWACC
        ADDCS   FACCX,FACCX,#1         ;Re-normalise
        MOVCS   FGRD,FGRD,LSR #1
        ORRCS   FGRD,FGRD,FACC,LSL #31
        MOVCS   FACC,FACC,RRX
        ADD     FACCX,FACCX,#1
;
; No overflow/underflow possible. Rounding not wanted because both
; parts of result are going to be subtracted from value on stack
;
        EOR     FSIGN,FSIGN,#&80000000 ;Negate to do subtraction (not 0-0 situation)
        MOV     TYPE,SP                ;input value
        STMFD   SP!,{FGRD,FSIGN,FACCX}
        BL      FADD
        FSTA    TYPE
        LDMFD   SP!,{FGRD,FSIGN,FACCX} ;Recover guard word
        SUB     FACCX,FACCX,#32
        MOVS    FACC,FGRD
        BEQ     %20
10      SUBPL   FACCX,FACCX,#1         ;Re-normalise - NB expected to be faster than
        MOVPLS  FACC,FACC,LSL #1       ;binary chop method in this environment
        BPL     %10
        TEQ     FACCX,#0
        BMI     %20
        MOV     TYPE,SP
        BL      FADD                   ;result of first addition
        FSTA    TYPE
        B       %30
20
        FLDA    SP                     ;input value
30      CMP     FACCX,#&71
        BCC     ENDSIN
        BL      FSQR
        FPUSH                          ;stack g, f
        ADR     TYPE,SINR5
        BL      FMUL
        ADR     TYPE,SINR4
        BL      FADD
        MOV     TYPE,SP
        BL      FMUL
        ADR     TYPE,SINR3
        BL      FADD
        MOV     TYPE,SP
        BL      FMUL
        ADR     TYPE,SINR2
        BL      FADD
        MOV     TYPE,SP
        BL      FMUL
        ADR     TYPE,SINR1
        BL      FADD
        MOV     TYPE,SP
        BL      FMUL
        ADD     SP,SP,#8
        MOV     TYPE,SP
        BL      FMUL
        BL      FADD
ENDSIN  ADD     SP,SP,#8
        EOR     FSIGN,FSIGN,R10
 ELIF FPOINT=1
        SIND    FACC,FACC
 ELIF FPOINT=2
        FPAop   SIND
 |
        ! 1, "Unknown FPOINT setting"
 ]
        MOVS    TYPE,#TFP
        LDR     PC,[SP],#4
 [ FPOINT=0
SINR5   DCD     &CD070C7F
        =       &67,0,0,&80            ;-.2386834640601E-7
SINR4   DCD     &B8B5D27E
        =       &6E,0,0,0              ;.2752397106775E-5
SINR3   DCD     &D00BD47F
        =       &74,0,0,&80            ;-.1984083282313E-3
SINR2   DCD     &888885BA
        =       &7A,0,0,0              ;.8333330720556E-2
SINR1   DCD     &AAAAAAA1
        =       &7E,0,0,&80            ;-.16666666608836
 ]
ATN     STR     R14,[SP,#-4]!
        BL      FACTOR
        BLPL    FLOATQ
 [ FPOINT=0
        STR     FSIGN,[SP,#-4]!            ;stack sign
        MOV     FSIGN,#0               ;force +ve
        MOV     R10,#0
        CMP     FACCX,#&81
        CMPEQ   FACC,#&80000001
        BCC     FATNA
        BL      FRECIP
        MOV     R10,#2
FATNA   CMP     FACCX,#&7F             ;test if greater than .2679491924
        CMPEQ   FACC,#&89000000
        CMPEQ   FACC,#&00300000
        CMPEQ   FACC,#&0000A200
        CMPEQ   FACC,#&000000F5
        BCC     FATNB
        FPUSH                          ;stack f
        ADR     TYPE,ATNCONST1
        BL      FMUL
        MOV     FWACC,#&80000000
        MOV     FWACCX,#&81
        MOV     FWSIGN,#&80000000
        BL      FADDW
        FPUSH                          ;stack top, f
        ADD     TYPE,SP,#8
        FLDA    TYPE
        ADR     TYPE,ATNCONST1
        BL      FADD
        MOV     TYPE,SP
        BL      FXDIV
        ADD     SP,SP,#16
        ADD     R10,R10,#1
FATNB   CMP     FACCX,#&71
        BCC     FATNC                  ;very small number
        FPUSH                          ;stack f, sign, link
        BL      FSQR
        FPUSH                          ;stack g, f etc.
        ADR     TYPE,ATNP1
        BL      FMUL
        ADR     TYPE,ATNP0
        BL      FADD
        MOV     TYPE,SP
        BL      FMUL
        FPUSH                          ;stack q*P(q), g, f etc.
        ADD     TYPE,SP,#8
        FLDA    TYPE
        ADR     TYPE,ATNQ1
        BL      FADD
        ADD     TYPE,SP,#8
        BL      FMUL
        ADR     TYPE,ATNQ0
        BL      FADD
        MOV     TYPE,SP
        BL      FXDIV
        ADD     TYPE,SP,#16
        BL      FMUL
        BL      FADD
        ADD     SP,SP,#24
FATNC   CMP     R10,#1
        EORHI   FSIGN,FSIGN,#&80000000
        BCC     FATND
        CMP     R10,#2
        ADRLT   TYPE,SIXTHPI
        ADREQ   TYPE,HALFPI
        ADRHI   TYPE,THIRDPI
        BL      FADD
FATND   LDMFD   SP!,{R4,R14}
        CMP     R4,#0
        EORNE   FSIGN,FSIGN,#&80000000
        TEQ     FACC,#0
        MOVEQ   FSIGN,#0
        MOVS    TYPE,#TFP
        MOV     PC,R14
 ELIF FPOINT=1
        ATND    FACC,FACC
        B       FSINSTK
 ELIF FPOINT=2
        FPAop   ATND
        B       FSINSTK
 |
        ! 1, "Unknown FPOINT setting"
 ]
 [ FPOINT=0
ATNCONST1
        DCD     &DDB3D743
        =       &81,0,0,0              ;SQR3=1.732050807568877
ATNP1   DCD     &B853ADF8
        =       &80,0,0,&80            ;-.720026848898
ATNP0   DCD     &B854A78A
        =       &81,0,0,&80            ;-1.44008344874
ATNQ1   DCD     &98123BF0
        =       &83,0,0,0              ;4.75222584599
ATNQ0   DCD     &8A3F7DBF
        =       &83,0,0,0              ;4.32025038919
; Here follows DJS's disgusting code to multiply FACC by 1/pi
;  = A2F9836E hex      (exponent 7F)
;  = (2^-1) + (2^-3) + (2^-6) - (2^-8) - (2^-13) + (2^-15) - (2^-17)
;    + (2^-22) - (2^-25) - (2^-28) - (2^-31)
FRANGE  MOV     FWGRD,FACC,LSL #30
        MOV     FWACC,FACC,LSR #2
        ADDS    FWGRD,FWGRD,FACC,LSL #27
        ADC     FWACC,FWACC,FACC,LSR #5
        SUBS    FWGRD,FWGRD,FACC,LSL #25
        SBC     FWACC,FWACC,FACC,LSR #7
        SUBS    FWGRD,FWGRD,FACC,LSL #20
        SBC     FWACC,FWACC,FACC,LSR #12
        ADDS    FWGRD,FWGRD,FACC,LSL #18
        ADC     FWACC,FWACC,FACC,LSR #14
        SUBS    FWGRD,FWGRD,FACC,LSL #16
        SBC     FWACC,FWACC,FACC,LSR #16
        ADDS    FWGRD,FWGRD,FACC,LSL #11
        ADC     FWACC,FWACC,FACC,LSR #21
        SUBS    FWGRD,FWGRD,FACC,LSL #8
        SBC     FWACC,FWACC,FACC,LSR #24
        SUBS    FWGRD,FWGRD,FACC,LSL #5
        SBC     FWACC,FWACC,FACC,LSR #27
        SUBS    FWGRD,FWGRD,FACC,LSL #2
        SBC     FWACC,FWACC,FACC,LSR #30
        ADDS    FACC,FACC,FWACC
        SUBCC   FACCX,FACCX,#1         ;Adjust exponent or re-normalise
        MOVCS   FWGRD,FWGRD,LSR #1
        ORRCS   FWGRD,FWGRD,FACC,LSL #31
        MOVCS   FACC,FACC,RRX
        CMP     FWGRD,#&80000000       ;Round correctly
        BICEQ   FACC,FACC,#1
        ADDCSS  FACC,FACC,#1
        MOVCS   FACC,FACC,RRX
        ADDCS   FACCX,FACCX,#1
        SUB     FACCX,FACCX,#1
        TEQ     FACCX,#0               ;Handle underflow (overflow is impossible)
        MOV     PC,R14
 ]
;convert fp acc to a string in stracc
;using format given by word in R4, returns with TYPE 1 after last char
;
; IEEE 754-2008 gives a handy reference for the maximum number of significant
; decimal digits that are required for displaying a binary floating point
; number at sufficient precision to allow it to be accurately read back in:
;   Pmin(bf) = 1+ceiling(p*log10(2))
; where p is the number of significant bits (i.e. p == number of bits used for
; storing mantissa + 1)
; This gives base values of 11 and 17, however BASIC64 has historically used 18
; so we'll stick with that for now.
 [ FPOINT=0
MAXDIGS                         *       11
 |
MAXDIGS                         *       18
 ]
;format 0: General format nnnn.nnn fixes maximum number of digits [or use 1]
;format 1: Exponent format n.nnEnn fixes number of digits
;format 2: Fixed format nnnnnn.nnn fixes number of digits after . [or use 1]
FMAT    RN      R5                     ;Format number
FDIGS   RN      R4                     ;(no harm the way currently written)
FPRTDX  RN      R7                     ;Decimal exponent
FPRTWN  RN      R6                     ;Work register
FCONFP  TEQ     R5,#0
        BNE     FCONHX
        MOV     FMAT,R4,LSR #16
        AND     FMAT,FMAT,#&7F
        TST     R4,#&800000
        MOV     FDIGS,R4,LSR #8
        AND     FDIGS,FDIGS,#255
        ORREQ   FDIGS,FDIGS,#&2e000000
        ORRNE   FDIGS,FDIGS,#&2c000000 ;put in . or ,
        CMP     FMAT,#3
        MOVCS   FMAT,#0                ;if unknown format use 0
        AND     R7,FDIGS,#255
        CMP     R7,#MAXDIGS+1
        BICCS   FDIGS,FDIGS,#255
        ORRCS   FDIGS,FDIGS,#MAXDIGS   ;if too high number of digs use 10/18
        TST     FDIGS,#255
        BNE     FCONA
        TEQ     FMAT,#2
        ORRNE   FDIGS,FDIGS,#MAXDIGS   ;if not in format 2 use maximum digits instead of 0
FCONA   STMFD   SP!,{FDIGS,R14}        ;May need fdigs again
        BL      FLOATY
     [ FPOINT=2
        FACCtoFPA
        STFP    F0,[SP,#-12]!
        LDMFD   SP!,{R0,R1,R2}
     ELIF FPOINT=1
        STFP    FACC,[SP,#-12]!
        LDMFD   SP!,{R0,R1,R2}
     ELIF FPOINT=0
        BL      FACCtoBCD
     |
        ! 1, "Unknown FPOINT setting"
     ]
        ADD     TYPE,ARGP,#STRACC
        TEQ     R0,#0
        MOVMI   R6,#"-"
        STRMIB  R6,[TYPE],#1

        ; Get the exponent into FPRTDX
        AND     FPRTDX,R0,#&F:SHL:20
        AND     LR,R0,#&F:SHL:16
        ADD     FPRTDX,FPRTDX,FPRTDX,LSR #2
        ADD     FPRTDX,LR,FPRTDX,LSR #1
        AND     LR,R0,#&F:SHL:12
        ADD     FPRTDX,FPRTDX,FPRTDX,LSR #2
        ADD     FPRTDX,LR,FPRTDX,LSR #1
        TST     R0,#1:SHL:30
        MOV     FPRTDX,FPRTDX,LSR #12
        RSBNE   FPRTDX,FPRTDX,#0

        MOV     R0,R0,LSL #20
        MOVS    R0,R0,LSR #20
        ORREQS  LR,R2,R1
        BNE     FPRTA
        TEQ     FMAT,#0
        MOVEQ   R6,#"0"
        STREQB  R6,[TYPE],#1
        LDMEQFD SP!,{R6,PC}            ;discard fdigs and return for 0 in G format
        TEQ     FMAT,#1
        BEQ     FPRTH
        B       FPRTZR
FPRTA
FPRTF   LDR     FDIGS,[SP]             ;stacked fdigs
        CMP     FMAT,#2
        BNE     FPRTFH
        AND     R6,FDIGS,#255
        ADCS    R6,R6,FPRTDX           ;fix up precision by adding exponent digit count
        BMI     FPRTZR
        CMP     R6,#MAXDIGS+1          ;how many digits?
        MOVCS   R6,#MAXDIGS
        MOVCS   FMAT,#0                ;treat as G10 format if unreasonable
        BIC     FDIGS,FDIGS,#255
        ORR     FDIGS,FDIGS,R6
FPRTFH  Push    "r0"
        Push    "r1"
        Push    "r2"
        ; Round to R1 sig figures
        AND     R1,FDIGS,#255
        MOV     R1,R1,LSL #2
        RSB     R1,R1,#18*4
        MOV     R2,#0
12
        LDRB    R0,[SP,R2,LSR #3]
        MOV     R0,R0,ROR #4
        TST     R2,#4
        MOVNE   R0,R0,ROR #4
        CMP     R1,R2
        BLO     %FT15
        CMPEQ   R0,#5:SHL:28
        BIC     R0,R0,#&F:SHL:28
        B       %FT20
15
        CMP     R0,#9:SHL:28
        BICCS   R0,R0,#&F:SHL:28
        ADDCC   R0,R0,#1:SHL:28
20
        MOV     R0,R0,ROR #28
        TST     R2,#4
        MOVNE   R0,R0,ROR #28
        STRB    R0,[SP,R2,LSR #3]
        BCC     %FT30
        ; Move on to next digit
        CMP     R2,#18*4
        ADDNE   R2,R2,#4
        BNE     %BT12
        ; Ran out of digits!
        MOV     R0,#1
        STRB    R0,[SP,R2,LSR #3]
        ADD     FPRTDX,FPRTDX,#1
        Pull    "r2"
        Pull    "r1"
        Pull    "r0"
        B       FPRTF
30
        Pull    "r2"
        Pull    "r1"
        Pull    "r0"
        TST     FDIGS,#255
        BNE     FPRTH
FPRTZR  LDR     FDIGS,[SP]
        ADD     FDIGS,FDIGS,#1
        MOV     R0,#0
        MOV     R1,#0
        MOV     R2,#0
        MOV     FPRTDX,#0
FPRTH   MOV     FPRTWN,#1
        TEQ     FMAT,#1
        BEQ     FPRTK
        TEQ     FPRTDX,#0
        BMI     FPRTKK
        AND     LR,FDIGS,#255
        CMP     FPRTDX,LR
        BCS     FPRTK
        ADD     FPRTWN,FPRTDX,#1
        MOV     FPRTDX,#0
        B       FPRTK
FPRTKK  TEQ     FMAT,#2
        BEQ     FPRTKL
        CMN     FPRTDX,#1
        CMNNE   FPRTDX,#2
        BNE     FPRTK
FPRTKL  MOV     FPRTWN,FDIGS,LSR #24   ;get . or ,
        STRB    FPRTWN,[TYPE,#1]       ;store "0." in string (interestingly!)
        MOV     FPRTWN,#"0"
        STRB    FPRTWN,[TYPE],#2       ;put the zero at the beginning and then skip the .
FPRTKM  ADDS    FPRTDX,FPRTDX,#1
        STRNEB  FPRTWN,[TYPE],#1       ;put in 0 if ne 0
        BNE     FPRTKM                 ;round again
        MOV     FPRTWN,#&80
FPRTK   MOV     LR,R0,LSR #8
        ORR     LR,LR,#"0"
        STRB    LR,[TYPE],#1
        ; Shift in the next digit
        MOV     R0,R0,LSL #4
        ORR     R0,R0,R1,LSR #28
        MOV     R1,R1,LSL #4
        BIC     R0,R0,#&F000
        ORR     R1,R1,R2,LSR #28
        MOV     R2,R2,LSL #4
        SUBS    FPRTWN,FPRTWN,#1
        MOVEQ   LR,FDIGS,LSR #24
        STREQB  LR,[TYPE],#1
        SUB     FDIGS,FDIGS,#1
        TST     FDIGS,#255
        BNE     FPRTK
        TEQ     FMAT,#1
        BEQ     FPRTTX
        TEQ     FMAT,#2
        BEQ     FPRTTY
FPRTTZ  LDRB    LR,[TYPE,#-1]!
        CMP     LR,#"0"
        BEQ     FPRTTZ
        CMP     LR,FDIGS,LSR #24
        ADDNE   TYPE,TYPE,#1
FPRTTY  TEQ     FPRTDX,#0
        BEQ     FPRTX
FPRTTX  MOV     LR,#"E"
        STRB    LR,[TYPE],#1
        ADDS    FPRTWN,FPRTDX,#0
        MOVMI   LR,#"-"
        STRMIB  LR,[TYPE],#1
        RSBMI   FPRTWN,FPRTWN,#0
        MOV     LR,#"0"
 [ FPOINT<>0
IPRTB   SUBS    FPRTWN,FPRTWN,#100
        ADDCS   LR,LR,#1
        BCS     IPRTB
        TEQ     LR,#"0"
        STRNEB  LR,[TYPE],#1
        ADD     FPRTWN,FPRTWN,#100
        MOV     LR,#"0"
        ORRNE   LR,LR,#256
 ]
IPRTA   SUBS    FPRTWN,FPRTWN,#10
        ADDCS   LR,LR,#1
        BCS     IPRTA
        TEQ     LR,#"0"
        STRNEB  LR,[TYPE],#1
        ADD     FPRTWN,FPRTWN,#"0"+10
        STRB    FPRTWN,[TYPE],#1
        TEQ     FMAT,#0
        BEQ     FPRTX
        MOV     R3,#" "
        TEQ     FPRTDX,#0
        STRPLB  R3,[TYPE],#1
 [ FPOINT<>0
        TST     LR,#256
        STREQB  R3,[TYPE],#1
 ]
        TEQ     LR,#"0"
        STREQB  R3,[TYPE],#1
FPRTX   LDMFD   SP!,{FDIGS,PC}
 [ FPOINT=0
; In: FACC = 5-byte float
; Out: R0-R2 = FPA format packed decimal
;      R3,R6-R7,R9 corrupt
; Although packed decimal has room for 19 digits, we only calculate to a precision of 16, to keep things within two registers (and the accuracy of anything beyond digit 11 is questionable anyway)
; Note that no rounding is performed when the mantissa grows to over 16 decimal digits in length; the result is truncated
FACCtoBCD       ROUT
        AND     FSIGN,FSIGN,#&80000000
        STMFD   R13!,{FSIGN,FDIGS,FMAT,LR}
        MOV     R2,#0 ; Digits 0-7
        MOV     R3,#0 ; Digits 8-15
        MOVS    R4,FACC
        BEQ     %FT90
        ; Convert FACC to BCD
        ADR     R5,tens
        MOV     R7,#0
        MOV     R9,#&80000000
        LDR     R6,[R5],#4
10
        CMP     R0,R6
        ADDHS   R3,R3,R9,LSR #3
        ADDHS   R2,R2,R7
        BEQ     %FT20
        SUBHI   R0,R0,R6
        BHI     %BT10
        MOVS    R9,R9,LSR #4
        MOV     R7,R7,RRX
        MOV     R7,R7,LSR #3
        LDR     R6,[R5],#4
        B       %BT10
20
        MOV     R4,#9 ; Decimal exponent
        SUBS    R1,R1,#129+31
        LDR     R9,=&88888888
        LDRGT   R7,=&33333333
        BGT     %FT50
        BEQ     %FT90
        MOV     R7,R9,LSR #3 ; &11111111
        ; Divide BCD number by two
30
        AND     R0,R3,R7
        BIC     R3,R3,R7
        MOVS    R0,R0,LSR #1
        MOV     R3,R3,LSR #1
        ORR     R0,R0,R0,LSR #2
        ADD     R3,R3,R0,LSR #1

        AND     R0,R2,R7
        BIC     R2,R2,R7
        MOV     R0,R0,RRX
        MOV     R2,R2,LSR #1
        ORR     R0,R0,R0,LSR #2
        ADD     R2,R2,R0,LSR #1

        ; Shift left one digit to keep first digit non-zero
        TST     R3,#&F0000000
        SUBEQ   R4,R4,#1
        MOVEQ   R3,R3,LSL #4
        ORREQ   R3,R3,R2,LSR #28
        MOVEQ   R2,R2,LSL #4

        ADDS    R1,R1,#1
        BNE     %BT30
        B       %FT90

        ; Multiply BCD number by two
50
        ADD     R2,R2,R7
        MVN     R0,R2
        AND     R0,R0,R9
        MOVS    R2,R2,LSL #1
        ORR     R0,R0,R0,LSR #1
        SUB     R2,R2,R0,LSR #1

        ADD     R3,R3,R7
        MVN     R0,R3
        AND     R0,R0,R9
        ADCS    R3,R3,R3
        ORR     R0,R0,R0,LSR #1
        SUB     R3,R3,R0,LSR #1

        ; Shift right one digit if we overflowed
        MOVCS   R2,R2,LSR #4
        ORRCS   R2,R2,R3,LSL #28
        MOVCS   R3,R3,LSR #4
        ORRCS   R3,R3,#&10000000
        ADDCS   R4,R4,#1

        SUBS    R1,R1,#1
        BNE     %BT50
        ; Now convert to STFP format
90
        LDR     R0,[R13],#4
        MOV     R1,R3,LSL #12
        ORR     R0,R0,R3,LSR #32-12
        ORR     R1,R1,R2,LSR #32-12
        MOV     R2,R2,LSL #12
        CMP     R4,#0
        ORRLT   R0,R0,#1:SHL:30
        RSBLT   R4,R4,#0
        BEQ     %FT99
        ; Convert exponent to BCD, noddy approach
91
        CMP     R4,#100
        SUBHS   R4,R4,#100
        ADDHS   R0,R0,#1:SHL:20
        BHI     %BT91
92
        CMP     R4,#10
        SUBHS   R4,R4,#10
        ADDHS   R0,R0,#1:SHL:16
        BHI     %BT92
        ADD     R0,R0,R4,LSL #12
99
        LDMFD   R13!,{FDIGS,FMAT,PC}
tens
        DCD 1000000000
        DCD 100000000
        DCD 10000000
        DCD 1000000
        DCD 100000
        DCD 10000
        DCD 1000
        DCD 100
        DCD 10
        DCD 1
;40 bit FACC:=FACC*10
;uses only FWGRD
FTENFX  MOV     FWGRD,FACC,ASL #30
        ORR     FWGRD,FWGRD,FGRD,LSR #2 ;concoct new guard
        ADDS    FGRD,FGRD,FWGRD        ;add facc,fgrd>>2 to facc,fgrd
        ADCS    FACC,FACC,FACC,LSR #2  ;carry in from previous ADD, out from this ADC
        ADD     FACCX,FACCX,#3         ;increase faccx by 3
        MOVCC   PC,R14                 ;exit if no renorm
FTENFA
        STR     R14,[SP,#-4]!
        SavePSR R14
        ADD     FACCX,FACCX,#1         ;renormalise if required
        MOVS    FACC,FACC,RRX
        MOV     FGRD,FGRD,RRX
        RestPSR R14,,f                 ;restore callers state
        LDR     PC,[SP],#4
;40 bit FACC:=FACC/10
;uses only FWGRD
FTENFQ  STR     R14,[SP,#-4]!
        TSTS    FACC,FACC,LSR #1       ;set carry out from facc
        ADDS    FGRD,FGRD,FGRD,RRX     ;add facc,fgrd>>1 to facc,fgrd
        ADCS    FACC,FACC,FACC,LSR #1
        SUB     FACCX,FACCX,#4         ;decrease faccx by 4
        BLCS    FTENFA
        MOV     FWGRD,FACC,ASL #28
        ORR     FWGRD,FWGRD,FGRD,LSR #4 ;concoct new guard
        ADDS    FGRD,FGRD,FWGRD        ;add facc,fgrd>>4 to facc,fgrd
        ADCS    FACC,FACC,FACC,LSR #4  ;carry in from previous ADD, out from this ADC
        BLCS    FTENFA
        MOV     FWGRD,FACC,ASL #24
        ORR     FWGRD,FWGRD,FGRD,LSR #8
        ADDS    FGRD,FGRD,FWGRD        ;add facc,fgrd>>8 to facc,fgrd
        ADCS    FACC,FACC,FACC,LSR #8
        BLCS    FTENFA
        MOV     FWGRD,FACC,ASL #16
        ORR     FWGRD,FWGRD,FGRD,LSR #16
        ADDS    FGRD,FGRD,FWGRD        ;add facc,fgrd>>16 to facc,fgrd
        ADCS    FACC,FACC,FACC,LSR #16
        BLCS    FTENFA
        ORR     FGRD,FGRD,#1           ;perturb system slightly!
        ADDS    FGRD,FGRD,FACC         ;add facc,fgrd>>32 to facc,fgrd
        ADCS    FACC,FACC,#0
        BLCS    FTENFA
        LDR     PC,[SP],#4
 ]
;convert to hex string
FCONHX  STR     R14,[SP,#-4]!
        BL      INTEGY
        ADD     TYPE,ARGP,#STRACC
        MOV     R2,#32-4
        MOV     R3,#0                  ;lzb
FCONH1  MOV     R1,IACC,LSR R2
        AND     R1,R1,#15
        CMP     R1,#9
        ORRLS   R1,R1,#"0"
        ADDHI   R1,R1,#"A"-10
        TEQ     R2,#0                  ;last time?
        MOVEQ   R3,#1
        TEQ     R3,#0
        CMPEQ   R1,#"0"
        MOVNE   R3,#1
        STRNEB  R1,[TYPE],#1
        SUBS    R2,R2,#4
        BPL     FCONH1
        LDR     PC,[SP],#4
FRDDXX  MOVS    TYPE,#TINTEGER         ;clear carry: nothing read
        MOV     PC,R14
;read constant from aeline: exit with aeline ready for next load of character
FREAD   CMP     R10,#"."
 [ FPOINT=0
        MOV     FACC,#0
        MOV     FGRD,#0
        MOV     FSIGN,#0               ;convenient flag for decimal pt
        MOV     FWACCX,#0              ;decimal exponent
        BEQ     FRDDDD
        SUB     R10,R10,#"0"
        CMP     R10,#9
        BHI     FRDDXX                 ;if <0 or >9
        MOV     FGRD,R10,LSL #24
        LDRB    R10,[AELINE],#1
        SUBS    FACCX,R10,#"0"
        BCC     FRDDDP
        CMP     FACCX,#9
        BHI     FRDDD
        MOV     FACCX,FACCX,LSL #24
        ADD     FGRD,FGRD,FGRD,LSL #2
        ADD     FGRD,FACCX,FGRD,LSL #1
FRDDC   LDRB    R10,[AELINE],#1
FRDDDP  CMP     R10,#"."
        BEQ     FRDDDD
FRDDD   CMP     R10,#"E"
        BEQ     FRDDEX                 ;start of exponent
        SUB     R10,R10,#"0"
        CMP     R10,#9
        BHI     FRDDQ                  ;end of number
        CMP     FACC,#&18000000        ;see how large it is
        TEQ     FSIGN,#0               ;both branches need "If after ."
        BCS     FRDDE
        SUBNE   FWACCX,FWACCX,#1       ;if after "." dec exp
        ADDS    FGRD,FGRD,FGRD
        ADC     FACC,FACC,FACC
        MOV     FACCX,FGRD,LSR #30
        ORR     FACCX,FACCX,FACC,LSL #2
        ADDS    FGRD,FGRD,FGRD,LSL #2
        ADC     FACC,FACC,FACCX
        ADDS    FGRD,FGRD,R10,LSL #24
        ADC     FACC,FACC,#0
        B       FRDDC
FRDDE   ADDEQ   FWACCX,FWACCX,#1       ;ignore if after "." else increase exponent
        B       FRDDC
FRDDDD  EORS    FSIGN,FSIGN,#1         ;seen "." before ?/set seen now
        BNE     FRDDC                  ;more chars
        EOR     FSIGN,FSIGN,#1         ;reset seen
        B       FRDDQ                  ;second one is end of number
FRDDEX  MOV     FWSIGN,R14
        BL      FRDEXP
        MOV     R14,FWSIGN
        ADD     FWACCX,FWACCX,FWGRD
FRDDQ   SUB     AELINE,AELINE,#1
        ORRS    FACCX,FWACCX,FSIGN
        BEQ     FRINT                  ;no exponent, no decimal so possible integer
FRFP    MOV     FWSIGN,R14
        ORRS    FACCX,FGRD,FACC
        BEQ     FRDDZZ
        MOV     FACCX,#&A8
        TEQ     FACC,#0
        BLPL    FNRMA
        TEQ     FWACCX,#0
        BEQ     FRDDZ
        BMI     FRDDM
FRDDP   BL      FTENFX
        SUBS    FWACCX,FWACCX,#1
        BNE     FRDDP
        B       FRDDZ
FRDDM   BL      FTENFQ
        ADDS    FWACCX,FWACCX,#1
        BNE     FRDDM
FRDDZ   BL      FTIDY
FRDDZZ  MOV     TYPE,#TFP
        MOV     FSIGN,#0
        SUBS    TYPE,TYPE,#0           ;set carry and status flags
        MOV     PC,FWSIGN              ;return
FRINT   CMP     FACC,#&800000
        BCS     FRFP                   ;too large to represent as integer
        MOV     FACC,FACC,LSL #8
        ORR     FACC,FACC,FGRD,LSR #32-8
        MOV     TYPE,#TINTEGER
        SUBS    TYPE,TYPE,#0           ;set carry and status flags
        MOV     PC,R14
FRDEXP  LDRB    R10,[AELINE],#1
        CMP     R10,#"-"
        BEQ     FRDEXM
        CMP     R10,#"+"
        BNE     FRDEXA
FRDEXB  LDRB    R10,[AELINE],#1
FRDEXA  CMP     R10,#"9"
        BHI     FRDEXQ
        SUBS    R10,R10,#"0"
        BCC     FRDEXQ
        MOV     FWGRD,R10
        LDRB    R10,[AELINE],#1
        CMP     R10,#"9"
        BHI     FRDEXX
        SUBS    R10,R10,#"0"
        ADDCS   AELINE,AELINE,#1
        ADDCS   FWGRD,FWGRD,FWGRD,LSL #2
        ADDCS   FWGRD,R10,FWGRD,LSL #1
FRDEXX  MOV     PC,R14
FRDEXQ  MOV     FWGRD,#0
        MOV     PC,R14
FRDEXM  STR     R14,[SP,#-4]!
        BL      FRDEXB
        RSB     FWGRD,FWGRD,#0
        LDR     PC,[SP],#4
 |
        MOV     IACC,#0                ;32 bit mantissa low
        SUB     R3,AELINE,#1           ;remember first digit
        BEQ     FRDDOT                 ;starts with a .
        SUB     R10,R10,#"0"
        CMP     R10,#9
        BHI     FRDDXX                 ;if <0 or >9
        MOV     IACC,R10               ;first character
        LDRB    R10,[AELINE],#1
        SUBS    R1,R10,#"0"
        BCC     FRDDDP                 ;could be .
        CMP     R1,#9
        BHI     FRDDD
        ADD     IACC,IACC,IACC,LSL #2
        ADD     IACC,R1,IACC,LSL #1    ;mult by 10 and add next char
FRDDC   LDRB    R10,[AELINE],#1
FRDDDP  CMP     R10,#"."
        BEQ     FRDDOT
FRDDD   CMP     R10,#"E"
        BEQ     FRDINTEX               ;start of exponent
        SUB     R10,R10,#"0"
        CMP     R10,#9
        BHI     FRDINTQ                ;end of number
        ADD     IACC,IACC,IACC,LSL #2
        ADD     IACC,R10,IACC,LSL #1   ;mult by 10 and add next char
        CMP     IACC,#&0CC00000        ;see how large it is
        BCC     FRDDC
        B       FRDRANGE
FRDINTQ SUB     AELINE,AELINE,#1
        MOV     TYPE,#TINTEGER
        SUBS    TYPE,TYPE,#0           ;set carry and status flags
        MOV     PC,R14
FRDDOT
FRDINTEX
FRDRANGE
        ; OK, we have a floating point number to read in
        ; To ensure accuracy, we will read in the value as packed decimal and convert to float via LDFP
        ; (old routine relied on extended precision math for accuracy with FPA, but with VFP the best we have available is double precision)
        ; This routine is also a lot faster than the old one (esp. with FPEmulator), due to only executing a single FP instruction
        MOV     AELINE,R3
        MOV     IACC,#0
        MOV     R3,#0
        MOV     R5,#0
        ASSERT  IACC<R3
        Push    "IACC,R3,R5"
        MOV     R3,#8                  ;bit index into packed value
        ; R5 used as exponent
        ; IACC used as "dot seen" flag
        ; Skip leading zeros
FRDFP0
        LDRB    R10,[AELINE],#1
        SUBS    R10,R10,#"0"
        SUBEQ   R5,R5,IACC             ;decrement exponent if leading zeros after dot
        BEQ     FRDFP0
        CMP     R10,#"."-"0"
        BEQ     FRDFPDOT
FRDFPDIG
        ; Process digits
        CMP     R10,#9
        BHI     FRDFPNOTDIG
        CMP     R3,#3*32
        BHS     FRDFPEXPINC
        AND     TYPE,R3,#4
        LDRB    R7,[SP,R3,LSR #3]
        ORR     R7,R7,R10,LSL TYPE
        STRB    R7,[SP,R3,LSR #3]
        TST     R3,#31
        SUB     R3,R3,#4
        ADDEQ   R3,R3,#64
FRDFPEXPINC
        ; Increment exponent if this wasn't the first digit, and we haven't seen the dot
        CMP     R3,#4
        CMPNE   IACC,#1
        ADDNE   R5,R5,#1
FRDFPNEXTDIG
        LDRB    R10,[AELINE],#1
        SUB     R10,R10,#"0"
        B       FRDFPDIG
FRDFPNOTDIG
        CMP     R10,#"."-"0"
        BEQ     FRDFPDOT
        CMP     R10,#"E"-"0"
        BEQ     FRDFPEXP
        MOVS    R7,R5
        LDRNE   R3,[SP]
        RSBMI   R7,R7,#0
        EORMI   R3,R3,#1:SHL:30
        BNE     FRDFPEXPBIN1           ;set exponent
FRDFPDONE
      [ FPOINT=1
        LDFP    FACC,[SP],#12
        MVFD    FACC,FACC              ;Ensure result is rounded to double precision
      |
        LDFP    F0,[SP],#12
        FPAtoFACC
      ]
        MOV     TYPE,#TFP
        SUB     AELINE,AELINE,#1
        SUBS    TYPE,TYPE,#0           ;set carry and status flags
        MOV     PC,R14                 ;return
FRDFPDOT
        CMP     IACC,#0
        BNE     FRDFPDONE
        MOV     IACC,#1
        CMP     R3,#8
        MOVEQ   R5,#-1
        BEQ     FRDFP0                 ;continue with leading zeros
        B       FRDFPNEXTDIG
FRDFPEXP
        ; Read sign
        LDRB    R10,[AELINE],#1
        CMP     R10,#"-"
        LDR     R3,[SP]
        RSBEQ   R5,R5,#0
        EOREQ   R3,R3,#1:SHL:30        ;Flip exponent sign
        CMPNE   R10,#"+"
        ; Read up to three digits, including leading zeros
        LDREQB  R10,[AELINE],#1
        CMP     R5,#0
        SUB     R7,R10,#"0"
        BNE     FRDFPEXPBIN
        ; No correction to apply, so read as BCD
        CMP     R7,#9
        BHI     FRDFPDONE
        LDRLSB  R10,[AELINE],#1
        SUBLS   R10,R10,#"0"
        CMPLS   R10,#9
        ORRLS   R7,R10,R7,LSL #4       ;read as BCD
        LDRLSB  R10,[AELINE],#1
        SUBLS   R10,R10,#"0"
        CMPLS   R10,#9
        ORRLS   R7,R10,R7,LSL #4       ;read as BCD
        ADDLS   AELINE,AELINE,#1       ;+1 so -1 in FRDFPDONE is OK
        ORR     R3,R3,R7,LSL #12
        STR     R3,[SP]
        B       FRDFPDONE
FRDFPEXPBIN
        ; Read three digits and add to R5
        CMP     R7,#9
        MOVHI   R7,#0
        LDRLSB  R10,[AELINE],#1
        SUBLS   R10,R10,#"0"
        CMPLS   R10,#9
        ADDLS   R7,R7,R7,LSL #2
        ADDLS   R7,R10,R7,LSL #1       ;*10
        LDRLSB  R10,[AELINE],#1
        SUBLS   R10,R10,#"0"
        CMPLS   R10,#9
        ADDLS   R7,R7,R7,LSL #2
        ADDLS   AELINE,AELINE,#1       ;+1 so -1 in FRDFPDONE is OK
        ADDLS   R7,R10,R7,LSL #1       ;*10
        ADDS    R7,R7,R5
        RSBMI   R7,R7,#0
        EORMI   R3,R3,#1:SHL:30        ;Flip exponent sign
        ; Convert R7 to BCD, noddy approach
        ; Max exponent we can get is E999 + ~250 leading zeros
        CMP     R7,#1000
        SUBHS   R7,R7,#1000
        ADDHS   R3,R3,#1:SHL:24
FRDFPEXPBIN1
        CMP     R7,#100
        SUBHS   R7,R7,#100
        ADDHS   R3,R3,#1:SHL:20
        BHS     FRDFPEXPBIN1
FRDFPEXPBIN2
        CMP     R7,#10
        SUBHS   R7,R7,#10
        ADDHS   R3,R3,#1:SHL:16
        BHS     FRDFPEXPBIN2
        ADD     R3,R3,R7,LSL #12
        STR     R3,[SP]
        B       FRDFPDONE
 ]
        LNK     Expr.s
@


1.8
log
@Restore old number formatting logic
Detail:
  The BASIC64 number formatting code was found to be significantly different to the BASIC105 formatting code, and a potential source of compatibility issues due to the various bugs and quirks it seemed to contain
  To resolve this, the BASIC105 number formatting code has been resurrected and adapted to allow it to be used by both BASIC105 and BASIC64
  The formatting code still uses BCD internally, so accuracy will be the same as BASIC 1.65. It's just the formatting discrepancies (for both BASIC versions) which will have been affected.
  MAXDIGS has also been revised again; the +2 is no longer required (was a BASIC64 quirk), so BASIC105 is down to 11 (up from 10 in pre-1.65 versions) and BASIC64 has reverted to the historic value of 18 (which is technically one more than necessary)
  File changes:
  s/fp2 - Updated as described above
  Tests/Math/AtPercent,ffb - New test program which compares the E/F/G number formatting code against a (BASIC105-style) reference model for the number formatting implemented in BASIC
Admin:
  Tested on Raspberry Pi
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/4/topics/9199


Version 1.66. Tagged as 'BASIC-1_66'
@
text
@d43 1
a43 1
 |
d47 6
d179 4
d184 1
a184 1
        SIND    FACC,FACC
d275 1
a275 1
 |
d278 5
d378 5
a382 1
     [ FPOINT=1
d385 2
d388 1
a388 1
        BL      FACCtoBCD
d958 1
d961 4
@


1.7
log
@Increase accuracy of 5-byte float to string conversion
Detail:
  This change rewrites the BASIC105 version of the FCONA routine so that it converts the value to FPA packed decimal format, with ~16 decimal digits of accuracy. To avoid adding an FPA dependency to BASIC105 this is done via a new, custom routine.
  Apart from improving the accuracy of the result, converting to packed decimal allows the rest of the function body to be shared with the BASIC64 variant of the routine.
  File changes:
  s/fp2 - Updated as above. New FACCtoBCD function added to perform the BCD/packed decimal conversion. MAXDIGS for BASIC105 increased to 11+2. Minor FRDFPEXPBIN optimisation.
Admin:
  Tested on BB-xM
  Although the new FCONA implementation is known not to be fully accurate, testing with Test.Math.Decimal shows a marked improvement over the previous implementation, with ~100m random float -> string -> float conversions being performed without any loss of accuracy


Version 1.65. Tagged as 'BASIC-1_65'
@
text
@d328 2
a329 3
; This gives base values of 11 and 17, however we add two extra digits on top
; to cope with the leading zeros that 'G' format might add (0.0XXXX) before it
; switches to 'E' format.
d331 1
a331 1
MAXDIGS                         *       11 + 2
d333 1
a333 1
MAXDIGS                         *       17 + 2
d340 2
d373 26
a398 30
        STR     TYPE,[SP,#-4]!
        MOV     R3,R0,LSR #12
        AND     R6,R3,#&FF0
        AND     R3,R3,#15
        CMP     R6,#&10
        ADDEQ   R3,R3,#10
        MOVHI   R3,#0
        AND     R7,FDIGS,#255
        CMP     R3,R7                  ;maximum number of digits!
        MOVCS   R3,#0
        CMP     FMAT,#0
        BNE     FPRTFA
        CMP     R3,#3
        BCS     FPRTFA
        CMP     R3,#0
        TSTNE   R0,#TINTEGER
        BEQ     FPRTFA
        MOV     R7,R3
        MOV     R6,#0
        MOV     R3,#1
        BL      FPRTNIBBLEDOT          ;0.
        CMP     R7,#2
        MOV     R6,#0
        BLEQ    FPRTNIBBLE
        BIC     R0,R0,#&F000           ;remove 1 or 2
        B       FPRTFGO
FPRTFA  TST     R0,#TINTEGER
        MOVNE   R3,#0
        CMP     FMAT,#1
        MOVEQ   R3,#0
d401 100
a500 57
        ADC     FDIGS,FDIGS,R3         ;fix up precision
        AND     R7,FDIGS,#255
        CMP     R7,#MAXDIGS+1          ;how many digits?
        BICCS   FDIGS,FDIGS,#255
        ORRCS   FDIGS,FDIGS,#MAXDIGS
        MOVCS   FMAT,#0                ;treat as G18 format if unreasonable
FPRTFH
;subtract from exponent
        MOV     R7,R3
        CMP     R3,#10
        SUBCS   R0,R0,#1 :SHL: 16
        SUBCS   R7,R7,#10
        SUB     R0,R0,R7,LSL #12
        ADD     R3,R3,#1
FPRTFGO MOV     R6,R0,LSR #8
        BL      FPRTNIBBLEDOT
        MOV     R7,R0
        BL      FPRTBYTE
        MOV     R7,R1,LSR #24
        BL      FPRTBYTE
        MOV     R7,R1,LSR #16
        BL      FPRTBYTE
        MOV     R7,R1,LSR #8
        BL      FPRTBYTE
        MOV     R7,R1
        BL      FPRTBYTE
        MOV     R7,R2,LSR #24
        BL      FPRTBYTE
        MOV     R7,R2,LSR #16
        BL      FPRTBYTE
        MOV     R7,R2,LSR #8
        BL      FPRTBYTE
      [ FPOINT <> 0 ; Last two digits known to be zero for FPOINT=0
        MOV     R7,R2
        BL      FPRTBYTE
      ]
        ; For rounding to work we must make sure we have more digits in the
        ; buffer than MAXDIGS. So just add an extra zero.
        MOV     R6,#0
        BL      FPRTNIBBLEDOT
        LDR     R2,[SP],#4             ;Recover stashed buffer ptr (could just use ARGP,#STRACC again??)
        AND     R7,FDIGS,#255
        ADD     TYPE,R2,R7
        ADD     TYPE,TYPE,#1           ;. must be somewhere
        ADD     R6,TYPE,#1             ;round position
        MOV     R3,#5
FPRTRND CMP     R2,R6                  ;reached the first digit?
        BLEQ    FPRTRNDPANIC           ;yes: number has another digit!
        LDRB    R7,[R6,#-1]!
        CMP     R7,FDIGS,LSR #24       ;check for ./,
        BEQ     FPRTRND                ;don't round the ./, (!)
        ADD     R7,R7,R3               ;add the round value
        CMP     R7,#"9"+1              ;is there a carry?
        MOVCS   R3,#1                  ;yes: propogate up
        SUBCS   R7,R7,#10              ;yes: and reduce back to digit
        STRB    R7,[R6]                ;put rounded number back
        BCS     FPRTRND                ;go round again if carry
d505 2
a506 2
FPRTTZ  LDRB    R6,[TYPE,#-1]!         ;remove trailing 0s
        CMP     R6,#"0"
d508 28
a535 19
        CMP     R6,FDIGS,LSR #24       ;stopped at ./,?
        ADDNE   TYPE,TYPE,#1           ;if didn't put back the character (else remove ./,)
FPRTTY  MOV     R7,R0,LSR #12
        ORR     R6,R7,R7,LSR #4
        ANDS    R6,R6,#255
        BEQ     FPRTNOEXPNT
FPRTTX  MOV     R6,#"E"
        STRB    R6,[TYPE],#1
        TST     R0,#TINTEGER
        MOVNE   R6,#"-"
        STRNEB  R6,[TYPE],#1
        MOV     R6,R0,LSR #20
        ANDS    R6,R6,#15
        BLNE    FPRTNIBBLE
        MOV     R6,R0,LSR #16
        ANDEQS  R6,R6,#15
        BLNE    FPRTNIBBLE
        MOV     R6,R0,LSR #12
        BL      FPRTNIBBLE
d537 11
a547 48
        BEQ     FPRTNOEXPNT
        MOV     R6,#" "
        TST     R0,#TINTEGER
        STREQB  R6,[TYPE],#1
      [ FPOINT <> 0                    ;1 less char of exponent padding for 5-byte
        TST     R0,#&F00000
        STREQB  R6,[TYPE],#1
        TSTEQ   R0,#&F0000
      |
        TST     R0,#&F0000
      ]
        STREQB  R6,[TYPE],#1
FPRTNOEXPNT
        LDMFD   SP!,{FDIGS,PC}
FPRTRNDPANIC
        MOV     R6,TYPE
FPRTRNDPANICCOPY
        LDRB    R7,[R6,#-1]
        STRB    R7,[R6],#-1
        CMP     R6,R2
        BNE     FPRTRNDPANICCOPY
        MOV     R7,#"0"
        STRB    R7,[R6]
        ADD     R6,R2,#1
        ADD     TYPE,TYPE,#1
        MOV     PC,R14
FPRTBYTE
        MOV     R6,R7,LSR #4
        AND     R6,R6,#15
        ADD     R6,R6,#&30
        STRB    R6,[TYPE],#1
        SUBS    R3,R3,#1
        MOVEQ   R6,FDIGS,LSR #24
        STREQB  R6,[TYPE],#1
        MOV     R6,R7
FPRTNIBBLEDOT
        AND     R6,R6,#15
        ADD     R6,R6,#&30
        STRB    R6,[TYPE],#1
        SUBS    R3,R3,#1
        MOVEQ   R6,FDIGS,LSR #24
        STREQB  R6,[TYPE],#1
        MOV     PC,R14
FPRTNIBBLE
        AND     R6,R6,#15
        ADD     R6,R6,#&30
        STRB    R6,[TYPE],#1
        MOV     PC,R14
@


1.6
log
@Fixes and improvements
Detail:
  s/Expr - Clean up some confusing code relating to l-value address offsets in LOOKU5. The old code looked like it contained a bug for BASIC64 (two TEQs back-to-back), but the situations LOOKU5 is called in meant it was fine and the TEQs were actually unnecessary.
  s/HelpMsgs - Fix MSGPRNXXX and friends corrupting R1. Was causing LVAR to crash/malfunction when listing functions/procedures.
  s/Stmt2 - Fix rotated ellipses being completely broken in BASIC64. Looks like this has been broken forever (bug appears to be present in BASIC64 1.05, as supplied with RISC OS 3)
  s/fp2 - Increase MAXDIGS by one for BASIC64, to allow for accurate float -> string conversion for numbers of the form 0.0XXXX when using G format.
  s/fp2 - Rewrite BASIC64's string -> float conversion code. Although the old code was believed to be sufficiently accurate, excessive use of FPA instructions made it rather slow, and a poor fit for any future VFP version of BASIC (the code relied on extended precision for accuracy, which VFP lacks). The new version converts to packed decimal and then relies on FPEmulator to perform the decimal -> float conversion via LDFP (to mirror float -> string conversion via STFP). The reduction in FP instructions makes it many times faster than the original ("Decimal" test runs 5x faster)
  Tests/CALL,ffb, Tests/Math/Array,ffb, Tests/Math/Decimal,ffb, Tests/Math/ELLIPSE,ffb - Add a handful of new test programs.
Admin:
  Tested on BB-xM


Version 1.64. Tagged as 'BASIC-1_64'
@
text
@d332 1
a332 1
MAXDIGS                         *       10 ; There are some accuracy issues to resolve before we can sensibly use 11 + 2, so stick with historic value of 10
d339 1
a339 1
FMAT    RN      R5
a340 2
FPRTDX  RN      R7
FPRTWN  RN      R6
d360 1
a360 2
FCONA   MOV     FPRTDX,#0
        STMFD   SP!,{FDIGS,R14}        ;May need fdigs again
d362 6
a368 202
 [ FPOINT=0
        CMP     FACC,#0
        BNE     FPRTA
        TEQ     FMAT,#0
        MOVEQ   R6,#"0"
        STREQB  R6,[TYPE],#1
        LDMEQFD SP!,{R6,PC}            ;discard fdigs and return for 0 in E format
        TEQ     FMAT,#1
        BEQ     FPRTH
        B       FPRTZR
FPRTA   MOV     FGRD,#0
        TEQ     FSIGN,#0
        MOVMI   FSIGN,#"-"
        STRMIB  FSIGN,[TYPE],#1
        MOVMI   FSIGN,#0
FPRTC   CMP     FACCX,#&81
        BCS     FPRTD
        BL      FTENFX
        SUB     FPRTDX,FPRTDX,#1
        B       FPRTC
FPRTD   CMP     FACCX,#&84
        BCC     FPRTF
        BNE     FPRTE
        CMP     FACC,#&A0000000
        BCC     FPRTF
FPRTE   BL      FTENFQ
        ADD     FPRTDX,FPRTDX,#1
        B       FPRTC
FPRTEE  BL      FONE
        ADD     FPRTDX,FPRTDX,#1
        B       FPRTC
;table of round up constant values
FPRTROUNDTAB
        &       &A0000000
        &       &00000083
        &       &00000000
        &       &00000000
        &       &80000000
        &       &00000080
        &       &00000000
        &       &00000000
        &       &CCCCCCCC
        &       &0000007C
        &       &CCCCCCCD
        &       &00000000
        &       &A3D70A3D
        &       &00000079
        &       &70A3D707
        &       &00000000
        &       &83126E97
        &       &00000076
        &       &8D4FDF38
        &       &00000000
        &       &D1B71758
        &       &00000072
        &       &E2196525
        &       &00000000
        &       &A7C5AC47
        &       &0000006F
        &       &1B47841B
        &       &00000000
        &       &8637BD05
        &       &0000006C
        &       &AF6C69AE
        &       &00000000
        &       &D6BF94D5
        &       &00000068
        &       &E57A42AE
        &       &00000000
        &       &ABCC7711
        &       &00000065
        &       &8461CEEF
        &       &00000000
        &       &89705F41
        &       &00000062
        &       &36B4A589
        &       &00000000
FPRTF   LDR     FDIGS,[SP]             ;stacked fdigs
        CMP     FMAT,#2
        BNE     FPRTFH
        AND     R6,FDIGS,#255
        ADCS    R6,R6,FPRTDX           ;fix up precision by adding exponent digit count
        BMI     FPRTZR
        CMP     R6,#MAXDIGS+1          ;how many digits?
        MOVCS   R6,#MAXDIGS
        MOVCS   FMAT,#0                ;treat as G10 format if unreasonable
        BIC     FDIGS,FDIGS,#255
        ORR     FDIGS,FDIGS,R6
FPRTFH  STMFD   SP!,{FMAT,FPRTDX,FDIGS,FACC,FGRD,FSIGN,FACCX} ;facc stuff closest
 [ {FALSE}
;code to compute round up constants if FTENFQ precision changes
        MOV     FACC,#&A0000000
        MOV     FACCX,#&83
        MOV     FGRD,#0
        MOV     FSIGN,#0               ;5 to acc
        BL      FSHOW
        ANDS    FWACCX,FDIGS,#255
        BEQ     FPRTGJ
FPRTGG  BL      FTENFQ
        BL      FSHOW
        SUBS    FWACCX,FWACCX,#1
        BNE     FPRTGG
 |
        ADR     FACC,FPRTROUNDTAB
        AND     R7,FDIGS,#255
        ADD     FACC,FACC,R7,LSL #4
        LDMIA   FACC,{FACC,FACCX,FGRD,FSIGN}
 ]
FPRTGJ  LDMFD   SP!,{FWACCX,FWSIGN,FWGRD,FWACC} ;since facc stuff was closest
        BL      FADDW1
FPRTFF  CMP     FACCX,#&84
        BLCC    FTENFA
        BCC     FPRTFF                 ;note that this relies on ftenfa preserving C on exit
        LDMFD   SP!,{FDIGS,FPRTDX,FMAT}
        CMP     FACC,#&A0000000
        BCS     FPRTEE                 ;see if unnormalised: fix up if so
        TST     FDIGS,#255
        BNE     FPRTH
FPRTZR  LDR     FDIGS,[SP]
        ADD     FDIGS,FDIGS,#1
        BL      FCLR
        MOV     FPRTDX,#0
FPRTH   MOV     FPRTWN,#1
        TEQ     FMAT,#1
        BEQ     FPRTK
        TEQ     FPRTDX,#0
        BMI     FPRTKK
        AND     FSIGN,FDIGS,#255
        CMP     FPRTDX,FSIGN
        BCS     FPRTK
        ADD     FPRTWN,FPRTDX,#1
        MOV     FPRTDX,#0
        B       FPRTK
FPRTKK  TEQ     FMAT,#2
        BEQ     FPRTKL
        CMN     FPRTDX,#1
        CMNNE   FPRTDX,#2
        BNE     FPRTK
FPRTKL  MOV     FPRTWN,FDIGS,LSR #24   ;get . or ,
        STRB    FPRTWN,[TYPE,#1]       ;store "0." in string (interestingly!)
        MOV     FPRTWN,#"0"
        STRB    FPRTWN,[TYPE],#2       ;put the zero at the beginning and then skip the .
FPRTKM  ADDS    FPRTDX,FPRTDX,#1
        STRNEB  FPRTWN,[TYPE],#1       ;put in 0 if ne 0
        BNE     FPRTKM                 ;round again
        MOV     FPRTWN,#&80
FPRTK   MOV     FSIGN,FACC,LSR #32-4
        ORR     FSIGN,FSIGN,#"0"
        STRB    FSIGN,[TYPE],#1
        BIC     FACC,FACC,#&F0000000
        ADDS    FGRD,FGRD,FGRD         ;40 bit mantissa * 10.0
        ADC     FACC,FACC,FACC
        MOV     FSIGN,FGRD,LSR #32-2
        ORR     FSIGN,FSIGN,FACC,LSL #2
        ADDS    FGRD,FGRD,FGRD,LSL #2
        ADCS    FACC,FACC,FSIGN
        SUBS    FPRTWN,FPRTWN,#1
        MOVEQ   FSIGN,FDIGS,LSR #24
        STREQB  FSIGN,[TYPE],#1
        SUB     FDIGS,FDIGS,#1
        TST     FDIGS,#255
        BNE     FPRTK
        TEQ     FMAT,#1
        BEQ     FPRTTX
        TEQ     FMAT,#2
        BEQ     FPRTTY
FPRTTZ  LDRB    FSIGN,[TYPE,#-1]!
        CMP     FSIGN,#"0"
        BEQ     FPRTTZ
        CMP     FSIGN,FDIGS,LSR #24
        ADDNE   TYPE,TYPE,#1
FPRTTY  TEQ     FPRTDX,#0
        BEQ     FPRTX
FPRTTX  MOV     FSIGN,#"E"
        STRB    FSIGN,[TYPE],#1
        ADDS    FPRTWN,FPRTDX,#0
        MOVMI   FSIGN,#"-"
        STRMIB  FSIGN,[TYPE],#1
        RSBMI   FPRTWN,FPRTWN,#0
        MOV     FSIGN,#"0"
IPRTA   SUBS    FPRTWN,FPRTWN,#10
        ADDCS   FSIGN,FSIGN,#1
        BCS     IPRTA
        TEQ     FSIGN,#"0"
        STRNEB  FSIGN,[TYPE],#1
        ADD     FPRTWN,FPRTWN,#"0"+10
        STRB    FPRTWN,[TYPE],#1
        TEQ     FMAT,#0
        BEQ     FPRTX
        MOV     FGRD,#" "
        TEQ     FPRTDX,#0
        STRPLB  FGRD,[TYPE],#1
        TEQ     FSIGN,#"0"
        STREQB  FGRD,[TYPE],#1
FPRTX   LDMFD   SP!,{FDIGS,PC}
 |
;format 0: General format nnnn.nnn fixes maximum number of digits [or use 1]
;format 1: Exponent format n.nnEnn fixes number of digits
;format 2: Fixed format nnnnnn.nnn fixes number of digits after . [or use 1]
;FDIGS=R4, FMAT=R5
        STFP    FACC,[SP,#-12]!
        LDMFD   SP,{R0,R1,R2}
d436 1
d439 1
d444 1
a444 1
        LDR     R2,[SP],#4
d492 1
d496 3
a500 1
        ADD     SP,SP,#12
a535 1
 ]
d537 125
d1000 1
a1000 4
FRDFPEXPBIN3
        SUBS    R7,R7,#1
        ADDHS   R3,R3,#1:SHL:12
        BHS     FRDFPEXPBIN3
@


1.5
log
@Redo DO32BIT portions using central macros
When 32 bitted there weren't 26/32 neutral macros around, but can use them now there are allowing one common output binary for disc based BASIC.
Some of the sneaky 26 bit code (eg. relying on address space wrapping at 64MB rather than explicitly clearing bits when computing a jump) adopt the safer 32 bit form even if that does cost 1 extra instruction.
Tagged as BASIC-1_57-pre1
@
text
@d321 10
d332 1
a332 1
MAXDIGS                         *       10
d334 1
a334 1
MAXDIGS                         *       18
d637 4
d908 1
a908 2
        MOV     R3,#0                  ;dot not seen
        MOV     R5,#0                  ;decimal exponent
d938 2
a939 1
FRDDOT  MOV     R3,#1                  ;seen dot
d941 20
a960 4
        FLTE    FACC,IACC              ;mantissa now floated
        MOV     R7,R14
FRDFP   LDRB    R10,[AELINE],#1
        CMP     R10,#"."
d962 20
a981 2
        CMP     R10,#"E"
        BEQ     FRDFPEX                ;start of exponent
d983 14
a996 29
        CMP     R10,#9
        BHI     FRDFPDQ                ;end of number
        MUFE    FACC,FACC,#10
        TEQ     R3,#0                  ;test to see if seen .
        FLTE    F1,R10
        SUBNE   R5,R5,#1               ;if after "." dec exp
        ADFE    FACC,FACC,F1           ;mult by 10 and add next char
        B       FRDFP
FRDFPDOT
        EORS    R3,R3,#1               ;test to see if dot seen/set it
        BNE     FRDFP
        B       FRDFPDQ                ;second . is end of number (already FP)
FRDINTEX
        FLTE    FACC,IACC
        MOV     R7,R14
FRDFPEX BL      FRDEXP
        ADD     R5,R5,R6               ;add read exponent to decimal place one
FRDFPDQ SUB     AELINE,AELINE,#1
        TEQ     R5,#0
        BEQ     FRDDZ
        BMI     FRDDM
FRDDP   MUFE    FACC,FACC,#10
        SUBS    R5,R5,#1
        BNE     FRDDP
        B       FRDDZ
FRDDM   DVFE    FACC,FACC,#10
        ADDS    R5,R5,#1
        BNE     FRDDM
FRDDZ   MVFD    FACC,FACC
d998 1
d1000 12
a1011 2
        MOV     PC,R7                  ;return
FRDEXP  LDRB    R10,[AELINE],#1
d1013 63
a1075 30
        BEQ     FRDEXM
        CMP     R10,#"+"
        BNE     FRDEXA
FRDEXB  LDRB    R10,[AELINE],#1
FRDEXA  CMP     R10,#"9"
        BHI     FRDEXQ
        SUBS    R10,R10,#"0"
        BCC     FRDEXQ
        MOV     R6,R10
        LDRB    R10,[AELINE],#1
        CMP     R10,#"9"
        BHI     FRDEXX
        SUBS    R10,R10,#"0"
        BCC     FRDEXX
        ADD     R6,R6,R6,LSL #2
        ADD     R6,R10,R6,LSL #1
        LDRB    R10,[AELINE],#1
        CMP     R10,#"9"
        BHI     FRDEXX
        SUBS    R10,R10,#"0"
        ADDCS   AELINE,AELINE,#1
        ADDCS   R6,R6,R6,LSL #2
        ADDCS   R6,R10,R6,LSL #1
FRDEXX  MOV     PC,R14
FRDEXQ  MOV     R6,#0
        MOV     PC,R14
FRDEXM  STR     R14,[SP,#-4]!
        BL      FRDEXB
        RSB     R6,R6,#0
        LDR     PC,[SP],#4
@


1.4
log
@Lots of code improvements but no changes to the built binary.

This update replaces lots of hard-wired definitions of things such as SWI
names with the ones from the main exports in the build environment. It
should build a binary-identical module to the previous revision.

Author: Rob Sprowson

Version 1.40. Tagged as 'BASIC-1_40'
@
text
@a726 1
 [ DO32BIT = 1
d728 1
a728 2
        MRS     R14,CPSR
 ]
d732 1
a732 2
 [ DO32BIT = 1
        MSR     CPSR_f,R14
a733 3
 |
        MOVS    PC,R14                 ;restore callers state
 ]
@


1.3
log
@  * Performance tweaks.
  * Comments added.
  * Added DIM LOCAL.
Detail:
  * All of the 408 instances of pushes and pops of a single register
    (i.e. "LDMIA SP!,{PC}") have been replaced with an LDR/STR equivalent,
    which provides a small performance boost on StrongARM-like processors.
  * Some obscure bits of the source have had comments added.
  * The new DIM LOCAL statement has been added:

    Syntax: DIM <numeric variable> LOCAL <numeric expression>

    DIM LOCAL allocates space from the BASIC stack rather than from the
    heap. This means that the space allocated is automatically freed on
    exit from the PROC or FN in which it was claimed.

    As with all LOCAL statements, it must appear in a PROC or FN definition
    and cannot appear inside a structure which uses the stack (i.e. NEXT)
    or after a LOCAL ERROR.

    Much like the manner in which "DIM foo% -1" returns the value of FSA
    without allocating space, "DIM foo% LOCAL -1" returns the value of SP
    at the time of the request, without allocating any space from the stack.
    This can be useful in computing the free space between the top of the
    BASIC heap and the bottom of the stack. Of course, the stack is used by
    BASIC while interpreting the program, so the contents of memory below
    foo% should always be treated as undefined.

    One caveat of using DIM LOCAL is that the stack cannot be moved while
    there are DIM LOCALs defined. END= will return an error and any
    Service_Memory calls will be claimed for the duration of the DIM LOCAL.
Admin:
  Builds and tested on RiscPC.
  Requires BASICTrans-2_06.

Version 1.30. Tagged as 'BASIC-1_30'
@
text
@d15 3
a17 2
; > fp2
 [ FP=0
d24 1
a24 1
 [ FP=0
d48 1
a48 1
 [ FP=0
d56 1
a56 1
 [ FP=0
d178 1
a178 1
 [ FP=0
d193 1
a193 1
 [ FP=0
d269 1
a269 1
 [ FP=0
d321 1
a321 1
 [ FP=0
d356 1
a356 1
 [ FP=0
d445 1
a445 1
 [ 1=0
d717 1
a717 1
 [ FP=0
d793 1
a793 1
 [ FP=0
d1006 1
a1006 1
        LNK     s.Expr
@


1.2
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 1.27. Tagged as 'BASIC-1_27'
@
text
@d17 1
a17 1
COSOP   STMFD   SP!,{R14}
d20 1
a20 1
COS     STMFD   SP!,{R14}
d45 1
a45 1
        LDMFD   SP!,{PC}
d48 1
a48 1
SINOP   STMFD   SP!,{R14}
d52 1
a52 1
        STMFD   SP!,{R14}
d176 1
a176 1
        LDMFD   SP!,{PC}
d189 1
a189 1
ATN     STMFD   SP!,{R14}
d193 1
a193 1
        STMFD   SP!,{FSIGN}            ;stack sign
d560 1
a560 1
        STMFD   SP!,{TYPE}
d626 1
a626 1
        LDMFD   SP!,{R2}
d727 1
a727 1
        STMFD   SP!,{R14}
d735 1
a735 1
        LDMFD   SP!,{PC}
d741 1
a741 1
FTENFQ  STMFD   SP!,{R14}
d766 1
a766 1
        LDMFD   SP!,{PC}
d769 1
a769 1
FCONHX  STMFD   SP!,{R14}
d787 1
a787 1
        LDMFD   SP!,{PC}
d893 1
a893 1
FRDEXM  STMFD   SP!,{R14}
d896 1
a896 1
        LDMFD   SP!,{PC}
d1000 1
a1000 1
FRDEXM  STMFD   SP!,{R14}
d1003 1
a1003 1
        LDMFD   SP!,{PC}
@


1.1
log
@  Improved BASIC build structure. No code change.
Detail:
  Makefile strips dependencies during the clean phase.

  Sources moved into an 's' directory.

  All sources reformatted into a more readable layout.
Admin:
  Builds binary-identical versions of BASIC and BASIC64 modules to
  version 1.22

Version 1.23. Tagged as 'BASIC-1_23'
@
text
@d728 1
a728 1
        MRS     ,R14,CPSR
d734 1
a734 1
        MSR     ,CPSR_f,R14
@


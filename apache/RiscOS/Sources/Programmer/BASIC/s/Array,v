head	1.11;
access;
symbols
	BASIC-1_75:1.11
	BASIC-1_74:1.11
	BASIC-1_73:1.11
	BASIC-1_72:1.10
	BASIC-1_71:1.10
	BASIC-1_70:1.10
	BASIC-1_69:1.10
	BASIC-1_68:1.9
	BASIC-1_67:1.9
	BASIC-1_66:1.8
	BASIC-1_65:1.8
	BASIC-1_64:1.8
	BASIC-1_63:1.8
	BASIC-1_62:1.8
	BASIC-1_61:1.8
	BASIC-1_60:1.8
	BASIC-1_59:1.8
	BASIC-1_58:1.8
	BASIC-1_57-pre4:1.8
	BASIC-1_57:1.8
	BASIC-1_57-pre3:1.8
	BASIC-1_57-pre2:1.8
	BASIC-1_57-pre1:1.7
	BASIC-1_56:1.7
	BASIC-1_55:1.7
	BASIC-1_54:1.7
	BASIC-1_53:1.7
	BASIC-1_52:1.7
	BASIC-1_51:1.7
	BASIC-1_50:1.7
	BASIC-1_49:1.7
	BASIC-1_48:1.7
	BASIC-1_47:1.7
	BASIC-1_46:1.7
	BASIC-1_45:1.6
	BASIC-1_44:1.5
	BASIC-1_43:1.5
	BASIC-1_42:1.4
	BASIC-1_41:1.4
	BASIC-1_40:1.4
	BASIC-1_39:1.3
	BASIC-1_37:1.3
	RO_5_07:1.3
	BASIC-1_36:1.3
	BASIC-1_35:1.3
	BASIC-1_34:1.2
	BASIC-1_33:1.2
	BASIC-1_32:1.2
	BASIC-1_31:1.2
	BASIC-1_30:1.2
	BASIC-1_29:1.1
	BASIC-1_28:1.1
	BASIC-1_27:1.1
	BASIC-1_26:1.1
	BASIC-1_25:1.1
	BASIC-1_24:1.1
	BASIC-1_23:1.1;
locks; strict;
comment	@# @;


1.11
date	2017.09.18.21.19.03;	author jlee;	state Exp;
branches;
next	1.10;
commitid	u9VOjCk1jnCuUI7A;

1.10
date	2017.07.21.20.13.17;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	V7IfTaEXKPJ9r80A;

1.9
date	2017.06.03.22.30.33;	author jlee;	state Exp;
branches;
next	1.8;
commitid	3Iuze3DCMuQaKYTz;

1.8
date	2013.12.01.17.39.51;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	DTgfZ9WqDVpZgsfx;

1.7
date	2011.09.28.08.23.27;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	5JO6nnQo1VYVKeBv;

1.6
date	2011.09.24.14.56.27;	author jlee;	state Exp;
branches;
next	1.5;
commitid	9jCYb6wAmHSH3LAv;

1.5
date	2009.05.17.02.31.53;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.24.00.27.15;	author srevill;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.03.18.27.21;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.23.15.48.33;	author srevill;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.14.20.00.31;	author srevill;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Adjust VFP error handling
Detail:
  s/ErrorMsgs - Give the VFP "invalid operation" error a more useful error number, and correct the embedded text to match what's in the Resources file. Add VFPExcetion_SQRT, to allow "negative root" errors to be generated by FSQRTD error checks.
  hdr/Definitions - Update FPSCRCheck macro to allow alternate error handlers to be specified
  s/Array, s/Factor - Update FSQRTD error checks to use VFPException_SQRT, so that they say "negative root" instead of "invalid operation"
Admin:
  Tested on Raspberry Pi


Version 1.73. Tagged as 'BASIC-1_73'
@
text
@; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;> Array Operations

        ; Macros to implement integer & NEON integer vector operations
        ; Common requirements:
        ; * AELINE contains the non-zero vector/array length
 [ FPOINT=2
        ; * D0-D15 are corruptible (Q0-Q7)
        ; * ARGP is valid
 ]
        ; * R2,R3,R14 is corruptible

        ; $src1 and $src2 are both vectors
        MACRO
        IntVectorVectorOp $op, $dest, $src1, $src2
        ASSERT  $src1 != $dest
        ASSERT  $src2 != $dest
 [ FPOINT=2
        CMP     AELINE,#8
        BLO     %FT60
        ; Vector length is reasonable, use NEON if possible
        LDR     R14,[ARGP,#VFPFLAGS]
        TST     R14,#VFPFLAG_NEON
        BEQ     %F60
        ARM
        ; Prime the vector loop
        VLDMIA  $src1!,{Q0}
        VLDMIA  $src2!,{Q1}
        SUB     AELINE,AELINE,#4
10
        V$op..S32 Q0,Q0,Q1
        SUBS    AELINE,AELINE,#4
        VLDMIAHS $src1!,{Q2}
        VLDMIAHS $src2!,{Q3}
        VSTMIA  $dest!,{Q0}
        BLO     %FT50
        V$op..S32 Q2,Q2,Q3
        SUBS    AELINE,AELINE,#4
        VLDMIAHS $src1!,{Q0}
        VLDMIAHS $src2!,{Q1}
        VSTMIA  $dest!,{Q2}
        BHS     %BT10
50
        ADDS    AELINE,AELINE,#4
        BEQ     %FT90
        CODE32
 ]
60
        LDR     R3,[$src1],#4
        LDR     R2,[$src2],#4
        $op     R2,R3,R2
        STR     R2,[$dest],#4
        SUBS    AELINE,AELINE,#1
        BNE     %BT60
90
        MEND

        ; $src is a vector
        ; $scalar is a scalar value
        MACRO
        IntVectorScalarOp $op, $dest, $src, $scalar
        ASSERT  $src != $dest
 [ FPOINT=2
        CMP     AELINE,#8
        BLO     %FT60
        ; Vector length is reasonable, use NEON if possible
        LDR     R14,[ARGP,#VFPFLAGS]
        TST     R14,#VFPFLAG_NEON
        BEQ     %F60
        ARM
        ; Prime the vector loop
        VLDMIA  $src!,{Q1}
        SUB     AELINE,AELINE,#4
        VDUP.32 Q0,$scalar ; Not all ops support a scalar 2nd arg, so just convert to vector
10
        V$op..S32 Q1,Q1,Q0
        SUBS    AELINE,AELINE,#4
        VLDMIAHS $src!,{Q2}
        VSTMIA  $dest!,{Q1}
        BLO     %FT50
        V$op..S32 Q2,Q2,Q0
        SUBS    AELINE,AELINE,#4
        VLDMIAHS $src!,{Q1}
        VSTMIA  $dest!,{Q2}
        BHS     %BT10
50
        ADDS    AELINE,AELINE,#4
        BEQ     %FT90
        CODE32
 ]
60
        LDR     R2,[$src],#4
        $op     R2,R2,$scalar
        STR     R2,[$dest],#4
        SUBS    AELINE,AELINE,#1
        BNE     %BT60
90
        MEND

        ; $src is a vector
        ; $scalar is a scalar value
        MACRO
        IntScalarVectorOp $op, $dest, $scalar, $src
        ASSERT  $src != $dest
 [ FPOINT=2
        CMP     AELINE,#8
        BLO     %FT60
        ; Vector length is reasonable, use NEON if possible
        LDR     R14,[ARGP,#VFPFLAGS]
        TST     R14,#VFPFLAG_NEON
        BEQ     %F60
        ARM
        ; Prime the vector loop
        VLDMIA  $src!,{Q1}
        SUB     AELINE,AELINE,#4
        VDUP.32 Q0,$scalar
10
        V$op..S32 Q1,Q0,Q1
        SUBS    AELINE,AELINE,#4
        VLDMIAHS $src!,{Q2}
        VSTMIA  $dest!,{Q1}
        BLO     %FT50
        V$op..S32 Q2,Q0,Q2
        SUBS    AELINE,AELINE,#4
        VLDMIAHS $src!,{Q1}
        VSTMIA  $dest!,{Q2}
        BHS     %BT10
50
        ADDS    AELINE,AELINE,#4
        BEQ     %FT90
        CODE32
 ]
60
        LDR     R2,[$src],#4
        $op     R2,$scalar,R2
        STR     R2,[$dest],#4
        SUBS    AELINE,AELINE,#1
        BNE     %BT60
90
        MEND

        ; $src is a vector
        ; dest (IACC) is a scalar
        ; IACC assumed to be zero on entry
        ; $op of ADD calculates sum of vector, MLA calculates sum-of-squares
        MACRO
        IntSumOp $op, $src, $len
        ASSERT  "$op" = "ADD" :LOR: "$op" = "MLA"
 [ FPOINT=2
        CMP     $len,#8
        BLO     %FT60
        ; Vector length is reasonable, do a vector op if possible
        LDR     R14,[ARGP,#VFPFLAGS]
        TST     R14,#VFPFLAG_NEON
        BEQ     %FT60
        ARM
        ; Prime the vector loop
        SUB     $len,$len,#8
        VLDMIA  $src!,{Q0}
      [ "$op" = "MLA"
        VMUL.S32 Q0,Q0,Q0
      ]
10
        VLDMIA $src!,{Q1}
        SUBS    $len,$len,#4
      [ "$op" = "ADD"
        VADD.S32 Q0,Q0,Q1
      |
        VMLA.S32 Q0,Q1,Q1
      ]
        VLDMIAHS $src!,{Q2}
        BLO     %FT50
        SUBS    $len,$len,#4
      [ "$op" = "ADD"
        VADD.S32 Q0,Q0,Q2
      |
        VMLA.S32 Q0,Q2,Q2
      ]
        BHS     %BT10
50
        ; Sum Q0 into IACC
        VPADD.S32 D0,D0,D1 ; S0=S0+S1, S1=S2+S3
        VPADD.S32 D0,D0,D0 ; S0,S1=S0+S1+S2+S3
        ADDS    $len,$len,#4
        VMOV.32 IACC,D0[0]
        BEQ     %FT90
        CODE32
 ]
60
        LDR     R14,[$src],#4
        SUBS    $len,$len,#1
      [ "$op" = "ADD"
        ADD     IACC,IACC,R14
      |
        MLA     IACC,R14,R14,IACC
      ]
        BNE     %BT60
90
        MEND        

 [ FPOINT=2
        ; Macros to implement VFP vector operations
        ; Common requirements:
        ; * AELINE contains the non-zero vector/array length
        ; * D0-D15, R14 are corruptible
        ; * ARGP is valid

        ; $src1 and $src2 are both vectors
        ; $op must be a vector-capable instruction
        MACRO
        VFPVectorVectorOp $op, $dest, $src1, $src2
        ASSERT  $src1 != $dest
        ASSERT  $src2 != $dest
        CMP     AELINE,#8
        BLO     %FT60
        ; Vector length is reasonable, do a vector op if possible
        LDR     R14,[ARGP,#VFPFLAGS]
        TST     R14,#VFPFLAG_Vectors
        BEQ     %FT60
        MOV     R14,#3:SHL:FPSCR_LEN_SHIFT
        FMXR    FPSCR,R14
        ; Prime the vector loop
        FLDMIAD $src1!,{D0-D3}
        FLDMIAD $src2!,{D4-D7}
        SUB     AELINE,AELINE,#4
        $op     D4,D0,D4
10
        SUBS    AELINE,AELINE,#4
        FLDMIADHS $src1!,{D8-D11}
        FLDMIADHS $src2!,{D12-D15}
        $op.HS  D8,D8,D12
        FSTMIAD $dest!,{D4-D7}
        BLO     %FT50
        SUBS    AELINE,AELINE,#4
        FLDMIADHS $src1!,{D0-D3}
        FLDMIADHS $src2!,{D4-D7}
        $op.HS  D4,D0,D4
        FSTMIAD $dest!,{D8-D11}
        BHS     %BT10
50
        MOV     R14,#0
        ADDS    AELINE,AELINE,#4
        FMXR    FPSCR,R14
        BEQ     %FT90
60
        FLDD    FACC,[$src1],#8
        FLDD    D1,[$src2],#8
        $op     FACC,FACC,D1
        FSTD    FACC,[$dest],#8
        SUBS    AELINE,AELINE,#1
        BNE     %BT60
90
        FPSCRCheck R14
        MEND

        ; $src is a vector
        ; $scalar is a scalar value, located in a scalar VFP register bank
        ; $op must be a vector-capable instruction
        MACRO
        VFPVectorScalarOp $op, $dest, $src, $scalar
        ASSERT  $src != $dest
        CMP     AELINE,#8
        BLO     %FT60
        ; Vector length is reasonable, do a vector op if possible
        LDR     R14,[ARGP,#VFPFLAGS]
        TST     R14,#VFPFLAG_Vectors
        BEQ     %FT60
        MOV     R14,#3:SHL:FPSCR_LEN_SHIFT
        FMXR    FPSCR,R14
        ; Prime the vector loop
        FLDMIAD $src!,{D4-D7}
        SUB     AELINE,AELINE,#4
        $op     D4,D4,$scalar
10
        SUBS    AELINE,AELINE,#4
        FLDMIADHS $src!,{D8-D11}
        $op.HS  D8,D8,$scalar
        FSTMIAD $dest!,{D4-D7}
        BLO     %FT50
        SUBS    AELINE,AELINE,#4
        FLDMIADHS $src!,{D4-D7}
        $op.HS  D4,D4,$scalar
        FSTMIAD $dest!,{D8-D11}
        BHS     %BT10
50
        MOV     R14,#0
        ADDS    AELINE,AELINE,#4
        FMXR    FPSCR,R14
        BEQ     %FT90
60
        FLDD    D4,[$src],#8
        $op     D4,D4,$scalar
        FSTD    D4,[$dest],#8
        SUBS    AELINE,AELINE,#1
        BNE     %BT60
90
        FPSCRCheck R14
        MEND

        ; $src is a vector
        ; $scalar is a scalar value, located in a scalar VFP register bank
        ; $op must be a vector-capable instruction
        MACRO
        VFPScalarVectorOp $op, $dest, $scalar, $src
        ASSERT  $src != $dest
        CMP     AELINE,#8
        BLO     %FT60
        ; Vector length is reasonable, do a vector op if possible
        LDR     R14,[ARGP,#VFPFLAGS]
        TST     R14,#VFPFLAG_Vectors
        BEQ     %FT60
        MOV     R14,#3:SHL:FPSCR_LEN_SHIFT
        FMXR    FPSCR,R14
        ; Prime the vector loop
        FLDMIAD $src!,{D4-D7}        
        SUB     AELINE,AELINE,#4
        FCPYD   D12,$scalar ; Replicate $scalar to a vector (n.b. doesn't necessarily have to be a vector bank)
        $op     D4,D12,D4
10
        SUBS    AELINE,AELINE,#4
        FLDMIADHS $src!,{D8-D11}
        $op.HS  D8,D12,D8
        FSTMIAD $dest!,{D4-D7}
        BLO     %FT50
        SUBS    AELINE,AELINE,#4
        FLDMIADHS $src!,{D4-D7}
        $op.HS  D4,D12,D4
        FSTMIAD $dest!,{D8-D11}
        BHS     %BT10
50
        MOV     R14,#0
        ADDS    AELINE,AELINE,#4
        FMXR    FPSCR,R14
        BEQ     %FT90
60
        FLDD    D4,[$src],#8
        $op     D4,$scalar,D4
        FSTD    D4,[$dest],#8
        SUBS    AELINE,AELINE,#1
        BNE     %BT60
90
        FPSCRCheck R14
        MEND

        ; $src is a vector
        ; dest (FACC) is a scalar
        ; Does not check for exceptions
        ; $op of FADDD calculates sum of vector, FMACD calculates sum-of-squares
        MACRO
        VFPSumOp $op, $src, $len
        ASSERT  "$op" = "FADDD" :LOR: "$op" = "FMACD"
        CMP     $len,#8
        FLDD    FACC,=0
        BLO     %FT60
        ; Vector length is reasonable, do a vector op if possible
        LDR     R14,[ARGP,#VFPFLAGS]
        TST     R14,#VFPFLAG_Vectors
        BEQ     %FT60
        MOV     R14,#3:SHL:FPSCR_LEN_SHIFT
        FMXR    FPSCR,R14
        ; Prime the vector loop
        SUB     $len,$len,#8
        FLDMIAD $src!,{D4-D7}
      [ "$op" = "FMACD"
        FMULD   D4,D4,D4
      ]
10
        FLDMIAD $src!,{D8-D11}
        SUBS    $len,$len,#4
      [ "$op" = "FADDD"
        FADDD   D4,D4,D8
      |
        FMACD   D4,D8,D8
      ]
        FLDMIADHS $src!,{D12-D15}
      [ "$op" = "FADDD"
        FADDDHS D4,D4,D12
      |
        FMACDHS D4,D12,D12
      ]
        SUBHSS  $len,$len,#4
        BHS     %BT10
        MOV     R14,#0
        ADDS    $len,$len,#4
        FMXR    FPSCR,R14
        ; Sum D4-D7 into FACC
        FADDD   D4,D4,D5
        FADDD   FACC,D6,D7
        FADDD   FACC,FACC,D4
        BEQ     %FT90
60
        FLDD    D1,[$src],#8
        SUBS    $len,$len,#1
      [ "$op" = "FADDD"
        FADDD   FACC,FACC,D1
      |
        FMACD   FACC,D1,D1
      ]
        BNE     %BT60
90
        MEND        
 ]

LETARRAY
        LDRB    R10,[AELINE],#1
        CMP     R10,#" "
        BEQ     LETARRAY
        CMP     R10,#"-"
        BEQ     ARRAYNEGATE
        STR     AELINE,[SP,#-4]!
        RSBS    R0,R10,#"9"
        CMPCS   R10,#"."
        BCS     ARRAYFACT
        BL      LVCONT
        BEQ     ARRAYFACT
        ADD     SP,SP,#4
        CMP     TYPE,#256
        BCC     ARRAYFACTLV
        BL      AESPAC
        CMP     R10,#"+"
        CMPNE   R10,#"-"
        CMPNE   R10,#"*"
        CMPNE   R10,#"/"
        CMPNE   R10,#"."
        BEQ     ARRAYBINARY
        BL      AEDONE
        LDMFD   SP!,{R4,R5}            ;copy an array to another one
        CMP     TYPE,R5
        BNE     ERTYPEARRAYB
        LDR     R6,[IACC]
        LDR     R4,[R4]
        CMP     R6,#16
        CMPCS   R4,#16
        BCC     ERARRZ
ARRAYARRAYASSIGNSIZE
        LDR     R5,[R4],#4
        LDR     R7,[R6],#4
        CMP     R5,R7
        BNE     ERTYPEARRAYC
        CMP     R5,#0
        BNE     ARRAYARRAYASSIGNSIZE
        LDR     AELINE,[R4],#4         ;total number of elements
        ADD     R6,R6,#4
        SUB     TYPE,TYPE,#256
        CMP     TYPE,#TFPLV
        BHI     ARRAYARRAYASSIGNSTRING
 [ FPOINT=0
        ADDEQ   AELINE,AELINE,AELINE,LSL #2
        ADDEQ   AELINE,AELINE,#3
        BICEQ   AELINE,AELINE,#3
 |
        MOVEQ   AELINE,AELINE,LSL #3
 ]
        MOVNE   AELINE,AELINE,LSL #2   ;calculate number of bytes to copy
ARRAYARRAYASSIGNCOPY
        SUBS    AELINE,AELINE,#16
        LDMHSIA R6!,{R0,R1,R2,R3}
        STMHSIA R4!,{R0,R1,R2,R3}
        BHI     ARRAYARRAYASSIGNCOPY
        BEQ     NXT
        CMN     AELINE,#8
        LDRLO   R0,[R6],#4
        STRLO   R0,[R4],#4
        LDMEQIA R6!,{R0,R1}
        STMEQIA R4!,{R0,R1}
        LDMHIIA R6!,{R0,R2,R3}
        STMHIIA R4!,{R0,R2,R3}
        B       NXT
ARRAYARRAYASSIGNSTRING
        MOV     TYPE,R6                ;source
ARRAYARRAYASSIGNSTRING1
        LDW     R3,TYPE,R6,R7
        LDRB    R2,[TYPE,#4]
        ADD     TYPE,TYPE,#5
        ADD     R2,R2,R3
        BL      STSTORE
        ADD     R4,R4,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYARRAYASSIGNSTRING1
        B       NXT
ARRAYBINARY
        STMFD   SP!,{IACC,TYPE,R10}
        STR     AELINE,[SP,#-4]!
        BL      AESPAC
        RSBS    R0,R10,#"9"
        CMPCS   R10,#"."
        BCS     ARRAYBINARYCONST
        BL      LVCONT
        BEQ     ARRAYBINARYCONST
        ADD     SP,SP,#4
        BL      AEDONES
        CMP     TYPE,#256
        BCC     ARRAYBINARYCONSTLV
        LDMFD   SP!,{R1,R2,R3,R4,R5}   ;R1,2=LV1,TYPE; R3=OP; R4,5=LV0,TYPE
        CMP     TYPE,R2
        CMPEQ   R2,R5
        BNE     ERTYPEARRAYB
        LDR     IACC,[IACC]
        LDR     R1,[R1]
        LDR     R4,[R4]
        CMP     IACC,#16
        CMPCS   R1,#16
        CMPCS   R4,#16
        BCC     ERARRZ                 ;if any array undimensioned
        CMP     R3,#"."
        BEQ     MATRIXMULTIPLY
ARRAYBINARYSIZE
        LDR     R2,[IACC],#4
        LDR     R5,[R1],#4
        LDR     R6,[R4],#4
        CMP     R2,R5
        CMPEQ   R5,R6
        BNE     ERTYPEARRAYC
        CMP     R6,#0
        BNE     ARRAYBINARYSIZE
        LDR     AELINE,[R4],#4         ;number of items
        ADD     IACC,IACC,#4
        ADD     R1,R1,#4
        SUB     TYPE,TYPE,#256
        CMP     R3,#"-"
        BEQ     ARRAYBINARYSUB
        CMP     R3,#"*"
        BEQ     ARRAYBINARYMUL
        CMP     R3,#"/"
        BEQ     ARRAYBINARYDIV
        CMP     TYPE,#TFPLV
        BEQ     ARRAYBINARYADDFP
        BCS     ARRAYBINARYADDSTRING
        IntVectorVectorOp ADD,R4,IACC,R1
        B       NXT
ARRAYBINARYADDFP

 [ FPOINT=0
        STMFD   SP!,{R8,R10}           ;save pointers
        MOV     R10,R4
        MOV     R8,R1
        MOV     TYPE,R0
ARRAYBINARYADDFP1
        BL      F1LDA
        ADD     R7,TYPE,#5
        MOV     TYPE,R8
        MOV     R8,R7
        BL      F1ADD
        ADD     TYPE,TYPE,#5
        MOV     R4,R10
        BL      F1STABYR4
        ADD     R10,R10,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYADDFP1
        LDMFD   SP!,{R8,R10}
 ELIF FPOINT=1
        LDFD    FACC,[IACC],#8
        LDFD    F1,[R1],#8
        ADFD    FACC,FACC,F1
        STFD    FACC,[R4],#8
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYADDFP
 ELIF FPOINT=2
        VFPVectorVectorOp FADDD,R4,IACC,R1
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       NXT
ARRAYBINARYADDSTRING
        STMFD   SP!,{R0,R10}
        MOV     R10,R1
ARRAYBINARYADDSTRING1
        MOV     IACC,R10
        BL      VARSTR
        ADD     R10,R10,#5
        LDR     IACC,[SP]
        ADD     R1,IACC,#5
        STR     R1,[SP]
        LDRB    R5,[IACC,#4]
        TEQ     R5,#0
        BEQ     ARRAYBINARYADDSTRING3
        LDW     IACC,IACC,R1,R3
        ADD     R6,CLEN,R5
        ADD     R1,ARGP,#STRACC+256
        CMP     R6,R1
        BCS     ERLONG
ARRAYADDBINARYSTRING2
        LDRB    R1,[IACC],#1
        STRB    R1,[CLEN],#1
        SUBS    R5,R5,#1
        BNE     ARRAYADDBINARYSTRING2
ARRAYBINARYADDSTRING3
        ADD     R3,ARGP,#STRACC
        BL      STSTORE
        ADD     R4,R4,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYADDSTRING1
        LDMFD   SP!,{R0,R10}
        B       NXT
ARRAYBINARYSUB
        CMP     TYPE,#TFPLV
        BEQ     ARRAYBINARYSUBFP
        BCS     ERTYPEARRAYB
        IntVectorVectorOp SUB,R4,R1,IACC
        B       NXT
ARRAYBINARYSUBFP

 [ FPOINT=0
        STMFD   SP!,{R8,R10}           ;save pointers
        MOV     R10,R4
        MOV     R8,R1
        MOV     TYPE,R0
ARRAYBINARYSUBFP1
        BL      F1LDA
        ADD     R4,TYPE,#5
        MOV     TYPE,R8
        MOV     R8,R4
        BL      F1XSUB
        ADD     R4,TYPE,#5
        MOV     TYPE,R10
        BL      F1STA
        MOV     TYPE,R8
        MOV     R8,R4
        ADD     R10,R10,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYSUBFP1
        LDMFD   SP!,{R8,R10}
 ELIF FPOINT=1
        LDFD    FACC,[IACC],#8
        LDFD    F1,[R1],#8
        SUFD    FACC,F1,FACC
        STFD    FACC,[R4],#8
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYSUBFP
 ELIF FPOINT=2
        VFPVectorVectorOp FSUBD,R4,R1,IACC
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       NXT
ARRAYBINARYMUL
        CMP     TYPE,#TFPLV
        BEQ     ARRAYBINARYMULFP
        BCS     ERTYPEARRAYB
        IntVectorVectorOp MUL,R4,R1,IACC
        B       NXT
ARRAYBINARYMULFP

 [ FPOINT=0
        STMFD   SP!,{R8,R10}           ;save pointers
        MOV     R10,R4
        MOV     R8,R1
        MOV     TYPE,R0
ARRAYBINARYMULFP1
        BL      F1LDA
        ADD     R7,TYPE,#5
        MOV     TYPE,R8
        MOV     R8,R7
        BL      F1MUL
        ADD     TYPE,TYPE,#5
        MOV     R4,R10
        BL      F1STABYR4
        ADD     R10,R10,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYMULFP1
        LDMFD   SP!,{R8,R10}
 ELIF FPOINT=1
        LDFD    FACC,[IACC],#8
        LDFD    F1,[R1],#8
        MUFD    FACC,F1,FACC
        STFD    FACC,[R4],#8
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYMULFP
 ELIF FPOINT=2
        VFPVectorVectorOp FMULD,R4,R1,IACC
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       NXT
ARRAYBINARYDIV
        CMP     TYPE,#TFPLV
        BEQ     ARRAYBINARYDIVFP
        BCS     ERTYPEARRAYB
ARRAYBINARYDIVINT
        LDR     R3,[IACC],#4
        LDR     R2,[R1],#4
        BL      ARRAYINTDIV
        STR     TYPE,[R4],#4
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYDIVINT
        B       NXT
ARRAYBINARYDIVFP

 [ FPOINT=0
        STMFD   SP!,{R8,R10}           ;save pointers
        MOV     R10,R4
        MOV     R8,R1
        MOV     TYPE,R0
ARRAYBINARYDIVFP1
        BL      F1LDA
        ADD     R4,TYPE,#5
        MOV     TYPE,R8
        MOV     R8,R4
        BL      F1XDIV
        ADD     R4,TYPE,#5
        MOV     TYPE,R10
        BL      F1STA
        MOV     TYPE,R8
        MOV     R8,R4
        ADD     R10,R10,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYDIVFP1
        LDMFD   SP!,{R8,R10}
 ELIF FPOINT=1
        LDFD    FACC,[IACC],#8
        LDFD    F1,[R1],#8
        DVFD    FACC,F1,FACC
        STFD    FACC,[R4],#8
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYDIVFP
 ELIF FPOINT=2
        VFPVectorVectorOp FDIVD,R4,R1,IACC        
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       NXT
ARRAYPLUSBC
        MOV     R6,#"+"
        MOV     R7,R4
        MOV     AELINE,R5
        B       ARRAYBINARYCONST1
ARRAYBINARYCONSTLV
        BL      VARIND
        B       ARRAYBINARYCONSTRV
ARRAYBINARYCONST
        LDR     AELINE,[SP],#4
        BL      FACTOR
        BL      AEDONES
;A()         =B()     op   C%
;sp+12,sp+16 =sp,sp+4 sp+8 in acc
ARRAYBINARYCONSTRV
        LDMFD   SP!,{R4,R5,R6,R7,AELINE}
        CMP     R6,#"-"
        BNE     ARRAYBINARYCONST1
        TEQ     TYPE,#0
        BEQ     ERTYPEARRAYB
        RSBPL   IACC,IACC,#0
 [ FPOINT=0
        EORMI   FSIGN,FSIGN,#&80000000
        TEQ     FACC,#0
        MOVEQ   FSIGN,#0
 ELIF FPOINT=1
        RSFMID  FACC,FACC,#0
 ELIF FPOINT=2
        FNEGD   FACC,FACC
 |
        ! 1, "Unknown FPOINT setting"
 ]
        MOV     R6,#"+"
ARRAYBINARYCONST1
        CMP     R6,#"+"
        CMPEQ   R5,#256+128
        BEQ     ARRAYBINARYCONST2
        CMP     TYPE,#0
        BEQ     ERTYPEINT
        BL      PUSHTYPE
        STR     TYPE,[SP,#-4]!
        MOV     IACC,R4
        MOV     TYPE,R5
        MOV     R4,R7
        MOV     R5,AELINE
        MOV     R7,R6
        SUB     R1,TYPE,#256
        CMP     R7,#"/"
        BNE     ARRAYCONSTBINARY1
        CMP     R5,TYPE
        BNE     ERTYPEARRAYB
        LDR     R6,[IACC]
        LDR     R4,[R4]
        CMP     R6,#16
        CMPCS   R4,#16
        BCC     ERARRZ
ARRAYBINARYCONSTDIV1
        LDR     R5,[R4],#4
        LDR     R2,[R6],#4
        CMP     R5,R2
        BNE     ERTYPEARRAYC
        CMP     R5,#0
        BNE     ARRAYBINARYCONSTDIV1
        LDR     AELINE,[R4],#4         ;total number of elements
        ADD     R6,R6,#4
        CMP     R1,#TFPLV
        BHI     ERTYPEARRAY
        BEQ     ARRAYBINARYCONSTDIVFP
        BL      PULLTYPE
        BL      INTEGY
ARRAYBINARYCONSTDIVINT
        LDR     R2,[R6],#4
        MOV     R3,R0
        BL      ARRAYINTDIV
        STR     TYPE,[R4],#4
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYCONSTDIVINT
        B       NXT
ARRAYBINARYCONSTDIVFP
        BL      PULLTYPE
        BL      FLOATY
        STMFD   SP!,{R8,R10}
        MOV     R10,R4                 ;D
        MOV     R8,R6                  ;S
 [ FPOINT=0
        BL      FPUSH
        TEQ     FACC,#0
 ELIF FPOINT=1
        CMF     FACC,#0
 ELIF FPOINT=2
        FCMPZD  FACC
        FMRX    PC, FPSCR
 |
        ! 1, "Unknown FPOINT setting"
 ]
        BEQ     ZDIVOR
 [ FPOINT=0
ARRAYBINARYCONSTDIVFP1
        MOV     TYPE,R8
        ADD     R8,R8,#5
        BL      F1LDA
        BEQ     ARRAYBINARYCONSTDIVFP2
        BL      FTOW
        FLDA    SP
        BL      FDIVA
ARRAYBINARYCONSTDIVFP2
        MOV     TYPE,R10
        BL      F1STA
        ADD     R10,R10,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYCONSTDIVFP1
 ELIF FPOINT=1
ARRAYBINARYCONSTDIVFP1
        LDFD    F1,[R8],#8
        DVFD    F1,F1,FACC
        STFD    F1,[R10],#8
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYCONSTDIVFP1
 ELIF FPOINT=2
        VFPVectorScalarOp FDIVD,R10,R8,FACC
 |
        ! 1, "Unknown FPOINT setting"
 ]
 [ FPOINT=0
        LDMFD   SP!,{R0,R1,R8,R10}
 |
        LDMFD   SP!,{R8,R10}
 ]
        B       NXT
ARRAYBINARYCONST2
        CMP     R5,AELINE
        BNE     ERTYPEARRAYB
        CMP     TYPE,#0
        BNE     ERTYPESTR
        LDR     R6,[R4]
        BL      SPUSH
        LDR     R4,[R7]
        CMP     R4,#16
        CMPCS   R6,#16
        BCC     ERARRZ
ARRAYBINARYCONSTSIZE
        LDR     R5,[R4],#4
        LDR     R2,[R6],#4
        CMP     R5,R2
        BNE     ERTYPEARRAYC
        CMP     R5,#0
        BNE     ARRAYBINARYCONSTSIZE
        LDR     AELINE,[R4],#4         ;total number of elements
        ADD     R6,R6,#4
        STR     R10,[SP,#-4]!              ;add constant string to string array
        MOV     R10,R6
ARRAYBINARYCONSTADDSTRING1
        MOV     IACC,R10
        BL      VARSTR
        ADD     R3,ARGP,#STRACC
        LDR     R5,[SP,#4]
        SUBS    R1,R5,R3
        BEQ     ARRAYBINARYCONSTADDSTRING3
        ADD     R6,R1,CLEN
        ADD     R5,ARGP,#STRACC+256
        CMP     R6,R5
        BCS     ERLONG
        ADD     R6,SP,#8
ARRAYBINARYCONSTADDSTRING2
        LDRB    R5,[R6],#1
        STRB    R5,[CLEN],#1
        SUBS    R1,R1,#1
        BNE     ARRAYBINARYCONSTADDSTRING2
ARRAYBINARYCONSTADDSTRING3
        BL      STSTORE
        ADD     R4,R4,#5
        ADD     R10,R10,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYCONSTADDSTRING1
        LDR     R10,[SP],#4
        BL      SPULL
        B       NXT
ARRAYNEGATE
        STR     AELINE,[SP,#-4]!
        BL      AESPAC
        RSBS    R0,R10,#"9"
        CMPCS   R10,#"."
        BCS     ARRAYFACT
        BL      LVCONT
        BEQ     ARRAYFACT
        ADD     SP,SP,#4
        SUBS    R1,TYPE,#256
        BCS     ARRAYZEROMINUS
        BL      VARIND
        BEQ     ERTYPEINT
        RSBPL   IACC,IACC,#0           ;negate integer
        BPL     ARRAYFACTRV
 [ FPOINT=0
        TEQ     FACC,#0
        EORNE   FSIGN,FSIGN,#&80000000 ;negate floating point
 ELIF FPOINT=1
        RSFD    FACC,FACC,#0
 ELIF FPOINT=2
        FNEGD   FACC,FACC
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       ARRAYFACTRV
ARRAYFACTLV
        BL      VARIND
        B       ARRAYFACTRV
ARRAYFACT
        LDR     AELINE,[SP],#4
        SUB     AELINE,AELINE,#1
        BL      FACTOR
ARRAYFACTRV
        BL      AESPAC
        CMP     R10,#"+"
        CMPNE   R10,#"-"
        CMPNE   R10,#"*"
        CMPNE   R10,#"/"
        BEQ     ARRAYCONSTBINARY
        LDMFD   SP!,{R4,R5}            ;assign constant to an array
        LDR     R4,[R4]
        CMP     R4,#16
        BCC     ERARRZ
ARRAYCONSTASSIGN1
        LDR     R6,[R4],#4
        CMP     R6,#0
        BNE     ARRAYCONSTASSIGN1
        SUB     R5,R5,#256
        CMP     R10,#","
        BEQ     ARRAYCONSTS
        BL      AEDONE
        LDR     AELINE,[R4],#4         ;aeline=number of elements, r4=base
        CMP     R5,#TFPLV
        BHI     ARRAYCONSTASSIGNSTRING
        BEQ     ARRAYCONSTASSIGNFP
        BL      INTEGY                 ;make sure of INT
        MOV     R5,AELINE,LSL #2       ;number of bytes
        BL      INITIALISERAM
        B       NXT
ARRAYCONSTASSIGNFP
        BL      FLOATY                 ;make sure of FP
 [ FPOINT=0
        BIC     FACC,FACC,#&80000000
        ORR     FACC,FACC,FSIGN        ;fsign only 0 or &80000000!
        ORR     FACCX,FACCX,FACC,LSL #8
        MOV     R2,FACC,LSR #24
        ORR     R2,R2,FACCX,LSL #8
        MOV     R3,FACC,LSR #16
        ORR     R3,R3,FACCX,LSL #16
        MOV     R5,FACC,LSR #8
        ORR     R5,R5,FACCX,LSL #24
ARRAYCONSTASSIGNFP1
        SUBS    AELINE,AELINE,#4
        STMHSIA R4!,{FACC,FACCX,R2,R3,R5} ;write four values
        BHI     ARRAYCONSTASSIGNFP1
        BEQ     NXT                    ;zero left
        CMN     AELINE,#2
        STMLOIA R4!,{FACC,FACCX}       ;first one
        STMEQIA R4!,{FACC,FACCX,R2}    ;first two
        STMHIIA R4!,{FACC,FACCX,R2,R3} ;first three
 |
        FPUSH
        LDMFD   SP,{R0,R1}
        LDMFD   SP!,{R2,R3}
ARRAYCONSTASSIGNFP1
        SUBS    AELINE,AELINE,#2
        STMHSIA R4!,{R0,R1,R2,R3}      ;write two values
        BHI     ARRAYCONSTASSIGNFP1
        STMNEIA R4!,{R0,R1}            ;last one
 ]
        B       NXT
ARRAYCONSTASSIGNSTRING
        CMP     TYPE,#0
        BNE     ERTYPESTR
        ADD     R3,ARGP,#STRACC
ARRAYCONSTASSIGNSTRING1
        BL      STSTORE
        ADD     R4,R4,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTASSIGNSTRING1
        B       NXT
;r4 pointer to destination array, r5 type
ARRAYCONSTS
        LDR     R6,[R4],#4             ;number of elements max
ARRAYCONSTS1
        SUBS    R6,R6,#1
        BMI     ERRSUB
        STMFD   SP!,{R4,R5,R6}
        BL      STOREA                 ;store current value
        BL      EXPR                   ;get next one
        LDMFD   SP!,{R4,R5,R6}
        CMP     R5,#128
        ADDCC   R4,R4,R5               ;add size if type 4, 5/8
        ADDCS   R4,R4,#5               ;else if type 128 then size 5
        CMP     R10,#","
        BEQ     ARRAYCONSTS1
        BL      AEDONE
        SUBS    R6,R6,#1
        BMI     ERRSUB
        BL      STOREA
        B       NXT
ARRAYZEROMINUS
        BL      AEDONES
        MOV     R2,#TINTEGER
        MOV     R3,#0
        LDMFD   SP!,{R4,R5}
        STMFD   SP!,{R2,R3}
        MOV     R7,#"-"
        B       ARRAYCONSTBINARY1
ARRAYCONSTBINARY
        LDMFD   SP!,{R6,R7}
        BL      PUSHTYPE
        STR     TYPE,[SP,#-4]!
        STMFD   SP!,{R6,R7,R10}
        BL      LVBLNK
        BEQ     ERTYPEARRAY
        SUBS    R1,TYPE,#256
        BCC     ERTYPEARRAY
        BL      AEDONES
        LDMFD   SP!,{R4,R5,R7}
;A()      =B%              op C()
;facc,type=pushed on stack r7 r4,r5
ARRAYCONSTBINARY1
        CMP     R5,TYPE
        BNE     ERTYPEARRAYB
        LDR     R6,[IACC]
        LDR     R4,[R4]
        CMP     R6,#16
        CMPCS   R4,#16
        BCC     ERARRZ
ARRAYCONSTBINARYSIZE
        LDR     R5,[R4],#4
        LDR     R2,[R6],#4
        CMP     R5,R2
        BNE     ERTYPEARRAYC
        CMP     R5,#0
        BNE     ARRAYCONSTBINARYSIZE
        LDR     AELINE,[R4],#4         ;total number of elements
        ADD     R6,R6,#4
        CMP     R7,#"-"
        BEQ     ARRAYCONSTBINARYMINUS
        CMP     R7,#"*"
        BEQ     ARRAYCONSTBINARYMUL
        CMP     R7,#"/"
        BEQ     ARRAYCONSTBINARYDIV
        CMP     R7,#"."
        BEQ     ERTYPEARRAY
        CMP     R1,#TFPLV
        BHI     ARRAYCONSTBINARYADDSTRING
        BEQ     ARRAYCONSTBINARYADDFP
        BL      PULLTYPE
        BL      INTEGY
        IntVectorScalarOp ADD,R4,R6,R0
        B       NXT
ARRAYCONSTBINARYADDFP
        BL      PULLTYPE
        BL      FLOATY
 [ FPOINT=0
        STMFD   SP!,{R8,R10}
        MOV     R10,R4                 ;D
        MOV     R8,R6                  ;S
        BL      FPUSH
ARRAYCONSTBINARYADDFP1
        MOV     TYPE,R8
        ADD     R8,R8,#5
        BL      F1LDA
        MOV     TYPE,SP
        BL      FADD
        MOV     TYPE,R10
        ADD     R10,R10,#5
        BL      F1STA
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYADDFP1
        LDMFD   SP!,{R0,R1,R8,R10}
 ELIF FPOINT=1
ARRAYCONSTBINARYADDFP1
        LDFD    F1,[R6],#8
        ADFD    F1,F1,FACC
        STFD    F1,[R4],#8
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYADDFP1
 ELIF FPOINT=2
        VFPVectorScalarOp FADDD,R4,R6,FACC
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       NXT
ARRAYCONSTBINARYADDSTRING
        BL      PULLTYPE
        STMFD   SP!,{CLEN,R10}
        ADD     R3,ARGP,#STRACC
        MOV     R10,R6
ARRAYCONSTBINARYADDSTRING1
        LDR     CLEN,[SP]
        LDRB    R5,[R10,#4]
        TEQ     R5,#0
        BEQ     ARRAYCONSTBINARYADDSTRING3
        LDW     R0,R10,R6,R7
        ADD     R6,CLEN,R5
        ADD     R1,ARGP,#STRACC+256
        CMP     R6,R1
        BCS     ERLONG
ARRAYCONSTBINARYADDSTRING2
        LDRB    R1,[R0],#1
        STRB    R1,[CLEN],#1
        SUBS    R5,R5,#1
        BNE     ARRAYCONSTBINARYADDSTRING2
ARRAYCONSTBINARYADDSTRING3
        BL      STSTORE
        ADD     R4,R4,#5
        ADD     R10,R10,#5
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYADDSTRING1
        LDMFD   SP!,{CLEN,R10}
        B       NXT
ARRAYCONSTBINARYMINUS
        CMP     R1,#TFPLV
        BHI     ERTYPEARRAY
        BEQ     ARRAYCONSTBINARYMINUSFP
        BL      PULLTYPE
        BL      INTEGY
        IntScalarVectorOp SUB,R4,R0,R6
        B       NXT
ARRAYCONSTBINARYMINUSFP
        BL      PULLTYPE
        BL      FLOATY
 [ FPOINT=0
        STMFD   SP!,{R8,R10}
        MOV     R10,R4                 ;D
        MOV     R8,R6                  ;S
        BL      FPUSH
ARRAYCONSTBINARYMINUSFP1
        MOV     TYPE,R8
        ADD     R8,R8,#5
        BL      F1LDA
        MOV     TYPE,SP
        BL      FXSUB
        MOV     TYPE,R10
        ADD     R10,R10,#5
        BL      F1STA
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYMINUSFP1
        LDMFD   SP!,{R0,R1,R8,R10}
 ELIF FPOINT=1
ARRAYCONSTBINARYMINUSFP1
        LDFD    F1,[R6],#8
        SUFD    F1,FACC,F1
        STFD    F1,[R4],#8
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYMINUSFP1
 ELIF FPOINT=2
        VFPScalarVectorOp FSUBD,R4,FACC,R6
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       NXT
ARRAYCONSTBINARYMUL
        CMP     R1,#TFPLV
        BHI     ERTYPEARRAY
        BEQ     ARRAYCONSTBINARYMULFP
        BL      PULLTYPE
        BL      INTEGY
        IntScalarVectorOp MUL,R4,R0,R6
        B       NXT
ARRAYCONSTBINARYMULFP
        BL      PULLTYPE
        BL      FLOATY
 [ FPOINT=0
        STMFD   SP!,{R8,R10}
        MOV     R10,R4                 ;D
        MOV     R8,R6                  ;S
        BL      FPUSH
ARRAYCONSTBINARYMULFP1
        MOV     TYPE,R8
        ADD     R8,R8,#5
        BL      F1LDA
        MOV     TYPE,SP
        BL      FMUL
        MOV     TYPE,R10
        ADD     R10,R10,#5
        BL      F1STA
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYMULFP1
        LDMFD   SP!,{R0,R1,R8,R10}
 ELIF FPOINT=1
ARRAYCONSTBINARYMULFP1
        LDFD    F1,[R6],#8
        MUFD    F1,FACC,F1
        STFD    F1,[R4],#8
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYMULFP1
 ELIF FPOINT=2
        VFPVectorScalarOp FMULD,R4,R6,FACC
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       NXT
ARRAYCONSTBINARYDIV
        CMP     R1,#TFPLV
        BHI     ERTYPEARRAY
        BEQ     ARRAYCONSTBINARYDIVFP
        BL      PULLTYPE
        BL      INTEGY
ARRAYCONSTBINARYDIVINT
        LDR     R3,[R6],#4
        MOV     R2,R0
        BL      ARRAYINTDIV
        STR     TYPE,[R4],#4
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYDIVINT
        B       NXT
ARRAYCONSTBINARYDIVFP
        BL      PULLTYPE
        BL      FLOATY
 [ FPOINT=0
        STMFD   SP!,{R8,R10}
        MOV     R10,R4                 ;D
        MOV     R8,R6                  ;S
        BL      FPUSH
ARRAYCONSTBINARYDIVFP1
        MOV     TYPE,R8
        ADD     R8,R8,#5
        BL      F1LDA
        MOV     TYPE,SP
        BL      FXDIV
        MOV     TYPE,R10
        ADD     R10,R10,#5
        BL      F1STA
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYDIVFP1
        LDMFD   SP!,{R0,R1,R8,R10}
 ELIF FPOINT=1
ARRAYCONSTBINARYDIVFP1
        LDFD    F1,[R6],#8
        DVFD    F1,FACC,F1
        STFD    F1,[R4],#8
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYDIVFP1
 ELIF FPOINT=2
        VFPScalarVectorOp FDIVD,R4,FACC,R6
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       NXT
; TYPE=R2 DIV R3. Uses r5,r7 also
ARRAYINTDIV
        EOR     R5,R2,R3
        MOVS    R2,R2
        RSBMI   R2,R2,#0
        MOVS    R3,R3
        BEQ     ZDIVOR
        RSBMI   R3,R3,#0
        MOV     R7,R3
        CMP     R7,R2,LSR #1
ARRAYINTDIV1
        MOVLS   R7,R7,LSL #1
        CMPLS   R7,R2,LSR #1
        BLS     ARRAYINTDIV1
        MOV     TYPE,#0
ARRAYINTDIV2
        CMP     R2,R7
        SUBCS   R2,R2,R7
        ADC     TYPE,TYPE,TYPE
        MOV     R7,R7,LSR #1
        CMP     R7,R3
        BCS     ARRAYINTDIV2
        TEQ     R5,#0
        RSBMI   TYPE,TYPE,#0
        MOV     PC,R14
;A(LIMI,LIMK)=B(LIMI,LIMJ).C(LIMJ,LIMK)
;R0=[LVC], R1=[LVB], R4=[LVA], TYPE=TYPE!
MATRIXMULTIPLY
        SUB     TYPE,TYPE,#256
        CMP     TYPE,#128
        BCS     ERTYPEARRAYB
        CMP     R4,R1
        CMPNE   R4,R0
        BNE     MATRIXMULTIPLYNOCOPY
;as a kindness, copy the destination to free space if it is the same as either
;of the sources. Issue whacky error message if this is not possible.
        MOV     R5,R4
        MOV     R6,R4
MATRIXMULTIPLYDESTSIZE
        LDR     R7,[R6],#4
        TEQ     R7,#0
        BNE     MATRIXMULTIPLYDESTSIZE
        LDR     R7,[R6],#4
        CMP     TYPE,#4
        MOVEQ   R7,R7,LSL #2
 [ FPOINT=0
        ADDNE   R7,R7,R7,LSL #2        ;number of bytes to move
 |
        MOVNE   R7,R7,LSL #3
 ]
        SUB     R6,R6,R5
        ADD     R7,R7,R6
        LDR     R6,[ARGP,#FSA]
        ADD     R2,R6,R7
        ADD     R2,R2,#1024
        CMP     R2,SP
        BCS     ERMATMULSPACE
MATRIXMULTIPLYCOPY
        LDR     R2,[R5],#4
        STR     R2,[R6],#4
        SUBS    R7,R7,#4
        BCS     MATRIXMULTIPLYCOPY
;set any identical source pointers to the copy
        CMP     R4,R1
        LDREQ   R1,[ARGP,#FSA]
        CMP     R4,R0
        LDREQ   R0,[ARGP,#FSA]
MATRIXMULTIPLYNOCOPY
        STMFD   SP!,{R8,R10}           ;more temporary registers
        LDR     R2,[R4],#4             ;ALIMI
        LDR     R3,[R1],#4             ;BLIMI
        LDR     R5,[R0],#4             ;CLIMJ
        LDR     R6,[R4],#4             ;ALIMK
        LDR     R7,[R1],#4             ;BLIMJ
        LDR     R10,[R0],#4            ;CLIMK
        CMP     R6,#0
        BEQ     VECTORMULTIPLY
        CMP     R2,R3                  ;test LIMI
        CMPEQ   R7,R5                  ;test LIMJ
        CMPEQ   R6,R10                 ;test LIMK
        LDR     R3,[R4],#8             ;load 0 and skip number of items
        CMPEQ   R3,#0
        LDR     R3,[R1],#8
        CMPEQ   R3,#0
        LDR     R3,[R0],#8
        CMPEQ   R3,#0
        BNE     ERTYPEARRAYC
MATRIXMULTIPLYMAIN
        CMP     TYPE,#TFPLV
;at this instant r3,r7,r8,r9,r10,r11,r14 are free
;r4=base of dest; r1=base of left source; r0=base of right source
;r2=LIMI; r5=LIMJ; r6=LIMK
        BEQ     MATRIXMULTIPLYFP
        STR     R0,[SP,#-4]!           ;matrix multiply for integers: save r source base
        MOV     R6,R6,LSL #2           ;LIMK=LIMK*4
;main loop over i
MATRIXMULTIPLYINT1
        LDR     R0,[SP]                ;reload r source base
        MOV     R11,R6                 ;loop count: LIMK*4
;outer loop over k
MATRIXMULTIPLYINT2
        MOV     R3,#0                  ;result
        MOV     R14,R1                 ;l source
        MOV     R7,R0                  ;r source
        MOV     R8,R5                  ;loop count: LIMJ
;inner loop over j
MATRIXMULTIPLYINT3
        LDR     R9,[R14],#4            ;inner copy of l source
        LDR     R10,[R7],R6            ;step inner copy of r source by LIMK*4
        MLA     R3,R9,R10,R3
        SUBS    R8,R8,#1
        BNE     MATRIXMULTIPLYINT3
        STR     R3,[R4],#4             ;step destination
        ADD     R0,R0,#4               ;step outer r source
        SUBS    R11,R11,#4
        BNE     MATRIXMULTIPLYINT2
        ADD     R1,R1,R5,LSL #2        ;step l source by LIMJ*4
        SUBS    R2,R2,#1               ;decrement LIMI directly in main loop
        BNE     MATRIXMULTIPLYINT1
        LDMFD   SP!,{R0,R8,R10}
        B       NXT
MATRIXMULTIPLYFP

 [ FPOINT=0
        ADD     R5,R5,R5,LSL #2        ;LIMJ'=LIMJ*5
        STMFD   SP!,{R0,R1,R2,R4,R5}
        SUB     SP,SP,#8
;SP+0 = r source base
;SP+4 = outer loop counter
;SP+8 = r source base (original)
;SP+12= l source base
;SP+16= LIMI
;SP+20= dest base
;SP+24= LIMJ*5
        ADD     R11,R6,R6,LSL #2       ;LIMK'=LIMK*5
;main loop over i
MATRIXMULTIPLYFP1
        LDR     R0,[SP,#8]             ;reload r source base
        STR     R0,[SP]
        STR     R11,[SP,#4]            ;loop count: LIMK*5
;outer loop over k
MATRIXMULTIPLYFP2
        BL      FCLR                   ;result
        LDR     R10,[SP,#12]           ;l source
        LDR     TYPE,[SP]              ;r source
        LDR     R8,[SP,#24]            ;loop count: LIMJ*5
;inner loop over j
MATRIXMULTIPLYFP3
        STMFD   SP!,{R0-R3}            ;save accumulated value
        MOV     R4,TYPE
        MOV     TYPE,R10
        ADD     R10,R10,#5             ;step inner copy of l source
        BL      F1LDA
        MOV     TYPE,R4
        BL      F1MUL
        ADD     TYPE,TYPE,R11          ;step inner copy of r source by LIMK*5
        LDMFD   SP!,{R4-R7}
        BL      FADDW
        SUBS    R8,R8,#5
        BNE     MATRIXMULTIPLYFP3
        LDR     TYPE,[SP,#20]
        BL      F1STA
        ADD     TYPE,TYPE,#5
        STR     TYPE,[SP,#20]          ;step destination
        LDR     R0,[SP]
        ADD     R0,R0,#5
        STR     R0,[SP]                ;step outer r source
        LDR     R0,[SP,#4]
        SUBS    R0,R0,#5
        STRNE   R0,[SP,#4]
        BNE     MATRIXMULTIPLYFP2
        LDR     R0,[SP,#12]
        LDR     R1,[SP,#24]
        ADD     R0,R0,R1               ;step l source by LIMJ*5
        STR     R0,[SP,#12]
        LDR     R0,[SP,#16]
        SUBS    R0,R0,#1
        STRNE   R0,[SP,#16]            ;decrement LIMI directly in main loop
        BNE     MATRIXMULTIPLYFP1
        ADD     SP,SP,#7*4
 ELIF FPOINT=1
        MOV     R6,R6,LSL #3           ;LIMK=LIMK*8
;main loop over i
MATRIXMULTIPLYFP1
        MOV     R10,R0                 ;reload r source base
        MOV     R11,R6                 ;loop count: LIMK*8
;outer loop over k
MATRIXMULTIPLYFP2
        MVFD    FACC,#0                ;result
        MOV     R14,R1                 ;l source
        MOV     R7,R10                 ;r source
        MOV     R8,R5                  ;loop count: LIMJ
;inner loop over j
MATRIXMULTIPLYFP3
        LDFD    F1,[R14],#8            ;inner copy of l source
        LDFD    F2,[R7]
        MUFD    F1,F1,F2
        ADD     R7,R7,R6               ;step inner copy of r source by LIMK*8
        SUBS    R8,R8,#1
        ADFD    FACC,FACC,F1
        BNE     MATRIXMULTIPLYFP3
        STFD    FACC,[R4],#8           ;step destination
        ADD     R10,R10,#8             ;step outer r source
        SUBS    R11,R11,#8
        BNE     MATRIXMULTIPLYFP2
        ADD     R1,R1,R5,LSL #3        ;step l source by LIMJ*8
        SUBS    R2,R2,#1               ;decrement LIMI directly in main loop
        BNE     MATRIXMULTIPLYFP1
 ELIF FPOINT=2
        ; TODO vectorise
        MOV     R6,R6,LSL #3           ;LIMK=LIMK*8
;main loop over i
MATRIXMULTIPLYFP1
        MOV     R10,R0                 ;reload r source base
        MOV     R11,R6                 ;loop count: LIMK*8
;outer loop over k
MATRIXMULTIPLYFP2
        FLDD    FACC,=0                ;result
        MOV     R14,R1                 ;l source
        MOV     R7,R10                 ;r source
        MOV     R8,R5                  ;loop count: LIMJ
;inner loop over j
MATRIXMULTIPLYFP3
        FLDD    D1,[R14],#8            ;inner copy of l source
        FLDD    D2,[R7]
        ADD     R7,R7,R6               ;step inner copy of r source by LIMK*8
        SUBS    R8,R8,#1
        FMACD   FACC,D1,D2
        BNE     MATRIXMULTIPLYFP3
        FSTD    FACC,[R4],#8           ;step destination
        ADD     R10,R10,#8             ;step outer r source
        SUBS    R11,R11,#8
        BNE     MATRIXMULTIPLYFP2
        ADD     R1,R1,R5,LSL #3        ;step l source by LIMJ*8
        SUBS    R2,R2,#1               ;decrement LIMI directly in main loop
        BNE     MATRIXMULTIPLYFP1
        FPSCRCheck R14
 |
        ! 1, "Unknown FPOINT setting"
 ]
        LDMFD   SP!,{R8,R10}
        B       NXT
VECTORMULTIPLY
        ADD     R4,R4,#4               ;skip number of elements
        CMP     R7,#0
        BEQ     VECTORROWMULTIPLY
        CMP     R2,R3
        CMPEQ   R5,R7
        LDR     R6,[R1],#8
        CMPEQ   R6,#0
        BNE     ERTYPEARRAYC
        ADD     R0,R0,#4
        MOV     R6,#1                  ;LIMK=1
        B       MATRIXMULTIPLYMAIN
VECTORROWMULTIPLY
        CMP     R2,R10
        CMPEQ   R3,R5
        LDR     R6,[R0],#8
        CMPEQ   R6,#0
        BNE     ERTYPEARRAYC
        ADD     R1,R1,#4
        MOV     R5,R3                  ;move LIMJ
        MOV     R6,R10                 ;move LIMK
        MOV     R2,#1                  ;LIMI=1
        B       MATRIXMULTIPLYMAIN
;and the functions
SUM     STR     R14,[SP,#-4]!
        LDRB    R10,[AELINE],#1
        CMP     R10,#TLEN
        BEQ     SUMLEN
        BL      READARRAYFACTOR1
        SUBS    R1,TYPE,#256
        BCC     ERARRY
        BL      GETARRAYSIZE
        CMP     R1,#TFPLV
 [ FPOINT=0
        BL      FCLR
 ]
        BEQ     SUMFP
        BHI     SUMSTRING
 [ FPOINT<>0
        MOV     IACC,#0
 ]
SUMINT
        IntSumOp ADD,TYPE,R10
        B       PSINSTK
 [ FPOINT=0
SUMFP   BL      F1ADD
        ADD     TYPE,TYPE,#5
        SUBS    R10,R10,#1
        BNE     SUMFP
 ELIF FPOINT=1
SUMFP   MVFD    FACC,#0
SUMFP1  LDFD    F1,[TYPE],#8
        ADFD    FACC,FACC,F1
        SUBS    R10,R10,#1
        BNE     SUMFP1
 ELIF FPOINT=2
SUMFP
        VFPSumOp FADDD,TYPE,R10
        FPSCRCheck R14
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       FSINSTK
SUMSTRING
        ADD     CLEN,ARGP,#STRACC
        ADD     R7,CLEN,#256
SUMSTRING1
        LDRB    R0,[TYPE,#4]
        TEQ     R0,#0
        BEQ     SUMSTRING3
        ADD     R5,CLEN,R0
        CMP     R5,R7
        BCS     ERLONG
        LDW     R1,TYPE,R4,R5
SUMSTRING2
        LDRB    R3,[R1],#1
        STRB    R3,[CLEN],#1
        SUBS    R0,R0,#1
        BNE     SUMSTRING2
SUMSTRING3
        ADD     TYPE,TYPE,#5
        SUBS    R10,R10,#1
        BNE     SUMSTRING1
        MOVS    TYPE,#0
        LDR     PC,[SP],#4
SUMLEN  BL      READARRAYFACTOR
        CMP     TYPE,#256+128
        BNE     ERTYPESTRINGARRAY
        BL      GETARRAYSIZE
        MOV     IACC,#0
SUMLEN3 LDRB    R1,[TYPE,#4]
        ADD     TYPE,TYPE,#5
        ADD     IACC,IACC,R1
        SUBS    R10,R10,#1
        BNE     SUMLEN3
        B       PSINSTK
MODULUS STR     R14,[SP,#-4]!
        BL      READARRAYFACTOR
        SUBS    R1,TYPE,#256
        BCC     ERARRY
        BL      GETARRAYSIZE
        CMP     R1,#TFPLV
 [ FPOINT=0
        BL      FCLR
 ]
        BEQ     MODULUSFP
        BHI     ERTYPENUMARRAY
 [ FPOINT<>0
        MOV     IACC,#0
 ]
MODULUSINT
        IntSumOp MLA,TYPE,R10
 [ FPOINT=0
        BL      IFLT
        BL      FSQRT
 ELIF FPOINT=1
        FLTD    FACC,IACC
        SQTD    FACC,FACC
 ELIF FPOINT=2
        ASSERT  FACC = 0
        FMSR    S0,IACC
        FSITOD  FACC,S0
        FSQRTD  FACC,FACC
        FPSCRCheck R14,_SQRT
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       FSINSTK
MODULUSFP

 [ FPOINT=0
        STMFD   SP!,{R0-R3}
        BL      F1LDA
        BL      FSQR
        LDMFD   SP!,{R4-R7}
        BL      FADDW
        ADD     TYPE,TYPE,#5
        SUBS    R10,R10,#1
        BNE     MODULUSFP
        BL      FSQRT
 ELIF FPOINT=1
        MVFD    FACC,#0
MODULUSFP1
        LDFD    F1,[TYPE],#8
        MUFD    F1,F1,F1
        SUBS    R10,R10,#1
        ADFD    FACC,FACC,F1
        BNE     MODULUSFP1
        SQTD    FACC,FACC
 ELIF FPOINT=2
        VFPSumOp FMACD,TYPE,R10
        FPSCRCheck R14
        FSQRTD  FACC,FACC
        FPSCRCheck R14,_SQRT 
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       FSINSTK
;support
READARRAYFACTOR
        LDRB    R10,[AELINE],#1
READARRAYFACTOR1
        STR     R14,[SP,#-4]!
        CMP     R10,#"("
        BNE     READARRAYFACTOR2
        BL      LVBLNK
        BEQ     ERARRY
        BL      AESPAC
        CMP     R10,#")"
        LDREQ   PC,[SP],#4
        B       ERBRA
READARRAYFACTOR2
        SUB     AELINE,AELINE,#1
        BL      LVBLNK
        LDRNE   PC,[SP],#4
        B       ERARRY
GETARRAYSIZE
        LDR     TYPE,[IACC]
        CMP     TYPE,#16
        BCC     ERARRZ
GETARRAYSIZE1
        LDR     R6,[TYPE],#4
        CMP     R6,#0
        BNE     GETARRAYSIZE1
        LDR     R10,[TYPE],#4
        MOV     PC,R14

        LNK     Assembler.s
@


1.10
log
@Avoid unpredictable behaviour on old ARMs
Swapped IntVectorVectorOp order of $op registers to avoid Rd=Rm being unpredictable for MUL.
@
text
@d1642 1
a1642 1
        FPSCRCheck R14
d1670 1
d1672 1
a1672 1
        FPSCRCheck R14
@


1.9
log
@Add "BASICVFP", a VFP version of BASIC64
Detail:
  See Doc/BASICVFP for overall design/specification
  File changes:
  - !Mk,fd7, !MkClean,fd7, !MkRom,fd7, Makefile - update build scripts to support BASICVFP target
  - Resources/UK/Messages - Add a few new messages
  - hdr/Definitions - Define BASICVFP register usage and a few utility macros
  - hdr/WorkSpace - Define BASICVFP workspace adjustments. Add a few asserts to check some workspace constraints are maintained.
  - s/* - Lots of changes to add support for BASICVFP variant of the module
Admin:
  Tested on Raspberry Pi 1/2/3, BB-xM


Version 1.67. Tagged as 'BASIC-1_67'
@
text
@d62 3
a64 3
        LDR     R2,[$src1],#4
        LDR     R3,[$src2],#4
        $op     R2,R2,R3
@


1.8
log
@Non functional changes
Lined up some comments.
Changed LNK filenames to be Unix style (thing.s rather than s.thing).
Tagged as BASIC-1_57-pre2
@
text
@d17 400
d542 1
a542 7
ARRAYBINARYADDINT
        LDR     R2,[IACC],#4
        LDR     R3,[R1],#4
        ADD     R2,R2,R3
        STR     R2,[R4],#4
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYADDINT
d564 1
a564 1
 |
d571 4
d612 1
a612 7
ARRAYBINARYSUBINT
        LDR     R2,[IACC],#4
        LDR     R3,[R1],#4
        SUB     R2,R3,R2
        STR     R2,[R4],#4
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYSUBINT
d636 1
a636 1
 |
d643 4
d653 1
a653 7
ARRAYBINARYMULINT
        LDR     R2,[IACC],#4
        LDR     R3,[R1],#4
        MUL     R2,R3,R2
        STR     R2,[R4],#4
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYBINARYMULINT
d675 1
a675 1
 |
d682 4
d722 1
a722 1
 |
d729 4
d760 4
d765 1
a765 1
        RSFMID  FACC,FACC,#0
d822 5
d828 1
a828 1
        CMF     FACC,#0
d844 3
a846 1
 |
a850 1
 ]
d853 5
d930 4
d935 1
a935 1
        RSFD    FACC,FACC,#0
d994 1
a994 1
        STFD    FACC,[SP,#-8]!
d1085 1
a1085 6
ARRAYCONSTBINARYADDINT
        LDR     R1,[R6],#4
        ADD     R1,R1,R0
        STR     R1,[R4],#4
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYADDINT
d1107 1
a1107 1
 |
d1114 4
d1154 1
a1154 6
ARRAYCONSTBINARYMINUSINT
        LDR     R1,[R6],#4
        SUB     R1,R0,R1
        STR     R1,[R4],#4
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYMINUSINT
d1176 1
a1176 1
 |
d1183 4
d1195 1
a1195 6
ARRAYCONSTBINARYMULINT
        LDR     R1,[R6],#4
        MUL     R1,R0,R1
        STR     R1,[R4],#4
        SUBS    AELINE,AELINE,#1
        BNE     ARRAYCONSTBINARYMULINT
d1217 1
a1217 1
 |
d1224 4
d1264 1
a1264 1
 |
d1271 4
d1457 1
a1457 1
 |
d1485 31
d1557 1
a1557 1
 [ FPOINT=1
d1560 2
a1561 4
SUMINT  LDR     R1,[TYPE],#4
        ADD     IACC,IACC,R1
        SUBS    R10,R10,#1
        BNE     SUMINT
d1568 1
a1568 1
 |
d1574 6
d1626 1
a1626 1
 [ FPOINT=1
d1630 1
a1630 5
        LDR     R1,[TYPE],#4
        MUL     R2,R1,R1
        ADD     IACC,IACC,R2
        SUBS    R10,R10,#1
        BNE     MODULUSINT
d1634 1
a1634 1
 |
d1637 8
d1659 1
a1659 1
 |
d1668 6
@


1.7
log
@Remove post increment.
In s/Array line 956 revision 1.5 the LDMFD was swapped for an LDR but the original didn't have writeback so the LDR shouldn't post increment.

Version 1.46. Tagged as 'BASIC-1_46'
@
text
@d1242 1
a1242 1
        LNK     s.Assembler
@


1.6
log
@Fix objasm 4 warnings. Enable use of CLZ in math code.
Detail:
  s/Array, s/Funct, s/Stmt - Use LDR/STR instead of LDM/STM when only one register is to be transferred
  s/fp - Use Hdr:CPU.Arch to determine whether CLZ can be used in the IFLT routine
Admin:
  Tested on rev A2 BB-xM


Version 1.45. Tagged as 'BASIC-1_45'
@
text
@d952 1
a952 1
        STR     R0,[SP,#-4]!               ;matrix multiply for integers: save r source base
d956 1
a956 1
        LDR     R0,[SP],#4             ;reload r source base
@


1.5
log
@  Unaligned load optimisations
Detail:
  * Uses global LDW macro instead of locally-defined LOAD macro (or longhand
    implementations)
  * Some other cases of unaligned loads for v6+ added in places that didn't
    lend themselves to the LDW macro
  * 5-byte (FP) load operation now macroised - the macro skips the unnecessary
    BIC when assembling only for pre-v6 CPUs, or uses unaligned loads for
    v6+ CPUs (unless NoUnaligned global flag is set)
Admin:
  Tested on a rev B7 beagleboard.

Version 1.43. Tagged as 'BASIC-1_43'
@
text
@d75 2
a76 2
        LDMLOIA R6!,{R0}
        STMLOIA R4!,{R0}
d956 1
a956 1
        LDMFD   SP,{R0}                ;reload r source base
@


1.4
log
@Lots of code improvements but no changes to the built binary.

This update replaces lots of hard-wired definitions of things such as SWI
names with the ones from the main exports in the build environment. It
should build a binary-identical module to the previous revision.

Author: Rob Sprowson

Version 1.40. Tagged as 'BASIC-1_40'
@
text
@d85 1
a85 1
        LOAD    R3,TYPE,R6,R7
d192 1
a192 1
        LOAD    IACC,IACC,R1,R3
d714 1
a714 1
        LOAD    R0,R10,R6,R7
d1139 1
a1139 1
        LOAD    R1,TYPE,R4,R5
@


1.3
log
@* In BASIC64, A() = B() / C now works - this specific case failed due to
  a stack imbalance.
* Keywords that take tokenised line numbers no longer cause number
  tokenisation if they appear on the right. This fixes BPUT#TRACE,32
* STRT/LDRT now enforce post-indexing. LDRT R0,[R1] generates correct code,
  and LDRT R0,[R1,#0] will be faulted.

Version 1.35. Tagged as 'BASIC-1_35'
@
text
@d16 1
d60 1
a60 1
 [ FP=0
d152 1
a152 1
 [ FP=0
d224 1
a224 1
 [ FP=0
d267 1
a267 1
 [ FP=0
d308 1
a308 1
 [ FP=0
d358 1
a358 1
 [ FP=0
d417 1
a417 1
 [ FP=0
d424 1
a424 1
 [ FP=0
d445 1
a445 1
 [ FP=0
d514 1
a514 1
 [ FP=0
d557 1
a557 1
 [ FP=0
d678 1
a678 1
 [ FP=0
d748 1
a748 1
 [ FP=0
d790 1
a790 1
 [ FP=0
d833 1
a833 1
 [ FP=0
d904 1
a904 1
 [ FP=0
d982 1
a982 1
 [ FP=0
d1103 1
a1103 1
 [ FP=0
d1108 1
a1108 1
 [ FP=1
d1116 1
a1116 1
 [ FP=0
d1168 1
a1168 1
 [ FP=0
d1173 1
a1173 1
 [ FP=1
d1182 1
a1182 1
 [ FP=0
d1192 1
a1192 1
 [ FP=0
d1241 1
@


1.2
log
@  * Performance tweaks.
  * Comments added.
  * Added DIM LOCAL.
Detail:
  * All of the 408 instances of pushes and pops of a single register
    (i.e. "LDMIA SP!,{PC}") have been replaced with an LDR/STR equivalent,
    which provides a small performance boost on StrongARM-like processors.
  * Some obscure bits of the source have had comments added.
  * The new DIM LOCAL statement has been added:

    Syntax: DIM <numeric variable> LOCAL <numeric expression>

    DIM LOCAL allocates space from the BASIC stack rather than from the
    heap. This means that the space allocated is automatically freed on
    exit from the PROC or FN in which it was claimed.

    As with all LOCAL statements, it must appear in a PROC or FN definition
    and cannot appear inside a structure which uses the stack (i.e. NEXT)
    or after a LOCAL ERROR.

    Much like the manner in which "DIM foo% -1" returns the value of FSA
    without allocating space, "DIM foo% LOCAL -1" returns the value of SP
    at the time of the request, without allocating any space from the stack.
    This can be useful in computing the free space between the top of the
    BASIC heap and the bottom of the stack. Of course, the stack is used by
    BASIC while interpreting the program, so the contents of memory below
    foo% should always be treated as undefined.

    One caveat of using DIM LOCAL is that the stack cannot be moved while
    there are DIM LOCALs defined. END= will return an error and any
    Service_Memory calls will be claimed for the duration of the DIM LOCAL.
Admin:
  Builds and tested on RiscPC.
  Requires BASICTrans-2_06.

Version 1.30. Tagged as 'BASIC-1_30'
@
text
@d438 1
a438 1
        LDFD    F1,[R8]
d440 1
a440 1
        STFD    F1,[R8],#8
d444 1
d446 3
@


1.1
log
@  Improved BASIC build structure. No code change.
Detail:
  Makefile strips dependencies during the clean phase.

  Sources moved into an 's' directory.

  All sources reformatted into a more readable layout.
Admin:
  Builds binary-identical versions of BASIC and BASIC64 modules to
  version 1.22

Version 1.23. Tagged as 'BASIC-1_23'
@
text
@d22 1
a22 1
        STMFD   SP!,{AELINE}
d95 1
a95 1
        STMFD   SP!,{AELINE}
d345 1
a345 1
        LDMFD   SP!,{AELINE}
d372 1
a372 1
        STMFD   SP!,{TYPE}
d466 1
a466 1
        STMFD   SP!,{R10}              ;add constant string to string array
d491 1
a491 1
        LDMFD   SP!,{R10}
d495 1
a495 1
        STMFD   SP!,{AELINE}
d520 1
a520 1
        LDMFD   SP!,{AELINE}
d623 1
a623 1
        STMFD   SP!,{TYPE}
d947 1
a947 1
        STMFD   SP!,{R0}               ;matrix multiply for integers: save r source base
d1089 1
a1089 1
SUM     STMFD   SP!,{R14}
d1145 1
a1145 1
        LDMFD   SP!,{PC}
d1157 1
a1157 1
MODULUS STMFD   SP!,{R14}
d1212 1
a1212 1
        STMFD   SP!,{R14}
d1219 1
a1219 1
        LDMEQFD SP!,{PC}
d1224 1
a1224 1
        LDMNEFD SP!,{PC}
@


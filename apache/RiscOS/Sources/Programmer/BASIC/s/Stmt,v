head	1.10;
access;
symbols
	BASIC-1_75:1.10
	BASIC-1_74:1.10
	BASIC-1_73:1.10
	BASIC-1_72:1.10
	BASIC-1_71:1.10
	BASIC-1_70:1.10
	BASIC-1_69:1.10
	BASIC-1_68:1.10
	BASIC-1_67:1.10
	BASIC-1_66:1.9
	BASIC-1_65:1.9
	BASIC-1_64:1.9
	BASIC-1_63:1.9
	BASIC-1_62:1.9
	BASIC-1_61:1.9
	BASIC-1_60:1.9
	BASIC-1_59:1.9
	BASIC-1_58:1.9
	BASIC-1_57-pre4:1.9
	BASIC-1_57:1.9
	BASIC-1_57-pre3:1.9
	BASIC-1_57-pre2:1.9
	BASIC-1_57-pre1:1.9
	BASIC-1_56:1.8
	BASIC-1_55:1.8
	BASIC-1_54:1.8
	BASIC-1_53:1.8
	BASIC-1_52:1.8
	BASIC-1_51:1.8
	BASIC-1_50:1.8
	BASIC-1_49:1.8
	BASIC-1_48:1.8
	BASIC-1_47:1.8
	BASIC-1_46:1.8
	BASIC-1_45:1.8
	BASIC-1_44:1.7
	BASIC-1_43:1.7
	BASIC-1_42:1.6
	BASIC-1_41:1.6
	BASIC-1_40:1.6
	BASIC-1_39:1.5
	BASIC-1_37:1.5
	RO_5_07:1.5
	BASIC-1_36:1.5
	BASIC-1_35:1.5
	BASIC-1_34:1.5
	BASIC-1_33:1.5
	BASIC-1_32:1.4
	BASIC-1_31:1.4
	BASIC-1_30:1.3
	BASIC-1_29:1.2
	BASIC-1_28:1.2
	BASIC-1_27:1.2
	BASIC-1_26:1.2
	BASIC-1_25:1.2
	BASIC-1_24:1.2
	BASIC-1_23:1.1;
locks; strict;
comment	@# @;


1.10
date	2017.06.03.22.30.34;	author jlee;	state Exp;
branches;
next	1.9;
commitid	3Iuze3DCMuQaKYTz;

1.9
date	2013.12.01.17.23.40;	author rsprowson;	state Exp;
branches;
next	1.8;
commitid	iG291GP27DoPasfx;

1.8
date	2011.09.24.14.56.27;	author jlee;	state Exp;
branches;
next	1.7;
commitid	9jCYb6wAmHSH3LAv;

1.7
date	2009.05.17.02.31.55;	author bavison;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.24.00.27.16;	author srevill;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.02.19.50.02;	author bavison;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.17.11.03.56;	author srevill;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.23.15.48.33;	author srevill;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.16.19.11.52;	author srevill;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.14.20.00.32;	author srevill;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Add "BASICVFP", a VFP version of BASIC64
Detail:
  See Doc/BASICVFP for overall design/specification
  File changes:
  - !Mk,fd7, !MkClean,fd7, !MkRom,fd7, Makefile - update build scripts to support BASICVFP target
  - Resources/UK/Messages - Add a few new messages
  - hdr/Definitions - Define BASICVFP register usage and a few utility macros
  - hdr/WorkSpace - Define BASICVFP workspace adjustments. Add a few asserts to check some workspace constraints are maintained.
  - s/* - Lots of changes to add support for BASICVFP variant of the module
Admin:
  Tested on Raspberry Pi 1/2/3, BB-xM


Version 1.67. Tagged as 'BASIC-1_67'
@
text
@; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;> Stmt

CASE    ROUT
        BL      AEEXPR
        TEQ     R10,#TOF
        BNE     ERCASE1
        LDRB    R10,[AELINE],#1
        TEQ     R10,#13
        BNE     ERCASE
        TEQ     TYPE,#0
        BLNE    FLOATZ
        BL      PUSHTYPE
        STR     TYPE,[SP,#-4]!
        SUB     R7,AELINE,#1
        MVN     R6,#0                  ;count of nesting depth: will see OF, so start at -1
        B       %02
06      CMP     R4,#TENDCA
        SUBEQ   R6,R6,#1
02      LDRB    R4,[R7,#1]
        CMP     R4,#&FF
        BCS     NOENDC
        LDRB    R4,[R7,#-1]
        CMP     R4,#TOF
        ADDEQ   R6,R6,#1
        ADD     R5,R7,#4
        LDRB    R10,[R7,#3]
        ADD     R7,R7,R10
04      LDRB    R4,[R5],#1
        TEQ     R4,#" "
        BEQ     %04
        TEQ     R6,#0
        BNE     %06
        CMP     R4,#TENDCA
        TEQNE   R4,#TWHEN
        TEQNE   R4,#TOTHER
        BNE     %02
        MOV     LINE,R5
        BCS     ENDCAS
        TEQ     R4,#TOTHER
        BEQ     CASEEL
CASEWH  STR     R7,[SP,#-4]!               ;rqd if go back to %00
        BL      AEEXPR
        LDR     R7,[SP],#4
        MOV     LINE,AELINE
        LDMFD   SP,{R4,R5,R6}
        TEQ     R4,#0
        BEQ     CASES
        TEQ     TYPE,#0
        BEQ     ERTYPEINT
 [ FPOINT=0
        BLPL    IFLT
        ORR     FGRD,FSIGN,FACCX
        TEQ     FACC,R5
        TEQEQ   FGRD,R6
 ELIF FPOINT=1
        LDFD    F1,[SP,#4]
        FLTPLD  FACC,IACC
        CMF     FACC,F1
 ELIF FPOINT=2
        FLDD    D1,[SP,#4]
        ASSERT  FACC = 0
        FMSRPL  S0,IACC
        FSITODPL FACC,S0
        FCMPD   FACC,D1
        FMRX    PC,FPSCR
 |
        ! 1, "Unknown FPOINT setting"
 ]
        BEQ     CASEEQ
CASENE  TEQ     R10,#","
        BEQ     CASEWH
        TEQ     R10,#":"
        TEQNE   R10,#13
        BNE     ERSYNT
        MOV     R6,#0
        B       %02
CASES   TEQ     TYPE,#0
        BNE     ERTYPESTR
        TEQ     CLEN,R5
        BNE     CASENE
        ADD     R0,ARGP,#STRACC
        TEQ     CLEN,R0
        BEQ     CASEEQ
        ADD     R1,SP,#8
80      LDRB    R4,[R1],#1
        LDRB    R5,[R0],#1
        TEQ     R4,R5
        BNE     CASENE
        TEQ     R0,CLEN
        BNE     %80
CASEEQ  BL      PULLTYPE
        TEQ     R10,#":"
        TEQNE   R10,#13
        BEQ     DONEXT
        TEQ     R10,#","
        BNE     ERSYNT
        MOV     R0,#0
90      LDRB    R10,[LINE],#1
        TEQ     R10,#""""
        EOREQ   R0,R0,#1
        TEQ     R10,#13
        BEQ     DONEXT
        TEQ     R0,#0
        BNE     %90
        TEQ     R10,#":"
        BNE     %90
        B       DONEXT
CASEEL  BL      PULLTYPE
        B       STMT
ENDCAS  BL      PULLTYPE
        B       DONXTS
;hit WHEN and OTHERWISE implies going to ENDCASE at current level
OTHER
WHEN    ROUT
        LDRB    R10,[LINE],#1
        TEQ     R10,#13
        BNE     WHEN
        SUB     R2,LINE,#1
        MOV     R3,#1
00      LDRB    R0,[R2,#1]
        CMP     R0,#&FF
        BCS     NOENDC
        LDRB    R0,[R2,#-1]
        CMP     R0,#TOF
        ADDEQ   R3,R3,#1               ;increase level if see OF at end of line
        ADD     R1,R2,#4
        LDRB    R0,[R2,#3]
        ADD     R2,R2,R0
02      LDRB    R0,[R1],#1
        TEQ     R0,#" "
        BEQ     %02
        TEQ     R0,#TENDCA             ;decrease level if see ENDCASE at start of line
        BNE     %00
        SUBS    R3,R3,#1
        BNE     %00
        MOV     LINE,R1
        B       DONXTS
CHAIN   BL      LOADER
        B       RUNNER
CLEAR   BL      DONES
        BL      SETFSA
        B       NXT
DIMSPA  SUB     LINE,LINE,#1           ;because of SPACES returning ptr /after/ first non-space char
        BL      CRAELV                 ;create an LV. EQ means failed.
        ;IACC is the ptr to the value (or SIB)
        ;TYPE is 0 byte, 4 int, 5 FP, 129 $(), 128 string. Array ref is type+256
        BEQ     BADDIM
        CMP     TYPE,#TFPLV+1
        BHS     ERTYPENUM              ;error if var is not numeric
DIMSPA2 LDRB    R10, [AELINE],#1       ;skip any spaces before the LOCAL or expression
        TEQ     R10, #" "
        BEQ     DIMSPA2
        TEQ     R10, #TLOCAL           ;is there a LOCAL token?
        LDREQ   R4, [SP]
        SUBNE   AELINE,AELINE,#1       ;no. do the normal DIM from the heap
        BNE     DIMHEAP
        TEQ     R4, #TPROC             ;yes. are we in a PROC/FN (and not a FOR, etc)?
        TEQNE   R4, #TFN
        BNE     ERRNLC                 ;no. return an error
        STMFD   SP!,{IACC,TYPE}        ;push the variable's details
        BL      EXPR                   ;evaluate the expression at AELINE into
        BL      INTEGY                 ;force the expression to integer (error if not correct type)
        ADDS    R7,IACC,#1             ;R7 = result+1. Check if -ve (in this case, DIM p% LOCAL -1 will give p%=SP)
        ADDMI   SP,SP,#8
        BMI     BADDIMSIGN             ;it is. return an error
        LDR     IACC,[ARGP,#FSA]       ;load the free pointer
        ADD     R7,R7,#3               ;round to whole number of words
        BIC     R7,R7,#3
        LDMFD   SP!,{R4,R5}            ;pull the stacked LV details into R4,R5
        ADD     IACC,R7,IACC           ;add bytes to claim onto the free pointer
        ADD     IACC,IACC,#512         ;generous allocation of free space below stack
        CMP     IACC,SP                ;will the claim leave much room in for our stack/heap?
        BHI     BADDIMSIZE             ;no. return an error
        SUB     IACC,SP,R7             ;block is claimed from the stack
        ADD     IACC,IACC,#12          ;three words at top of block are the PROC/FN status (moved below if claim OK)
        STR     R7,[SP,#-4]!           ;push the block size
        BL      STOREA                 ;store thing, may yet fail
        LDR     R6,[SP],#4             ;recover our DIM details
        TEQ     R6,#0                  ;was the claim for zero (i.e. -1 to read SP) bytes?
        BEQ     DIMNXT                 ;yes. move on to the next part of the DIM
        LDR     R7,[ARGP,#DIMLOCAL]    ;load DIM LOCAL list pointer
        LDMFD   SP!,{R0,R3,R4}         ;load PROC/FN status words
        MOV     R5,#TDIM               ;magic marker!
        SUB     SP,SP,R6               ;claim block from stack
        ; Stack...
        ;   SP+24.. = n claimed bytes
        ;   SP+20   = pointer to next DIM LOCAL (may be zero)
        ;   SP+16   = number of bytes claimed (n)
        ;   SP+12   = TDIM
        ;   SP+8    = LINE for PROC/FN
        ;   SP+4    = AELINE for PROC/FN
        ;   SP      = TPROC or TFN
        STMFD   SP!,{R0,R3,R4,R5,R6,R7};push the stuff onto the stack
        ADD     R0,SP,#12
        STR     R0,[ARGP,#DIMLOCAL]    ;store this as head of DIM LOCAL list
        B       DIMNXT                 ;move on to the next part of the DIM
DIMHEAP STMFD   SP!,{IACC,TYPE}        ;push the LV details
        BL      EXPR                   ;evaluate the expression at AELINE into
        BL      INTEGY                 ;force the expression to integer (error if not correct type)
        ADD     R7,IACC,#1             ;R7 = result+1
        LDR     IACC,[ARGP,#FSA]       ;read free pointer into IACC
        LDMFD   SP!,{R4,R5}            ;pull the stacked LV details into R4,R5
        STMFD   SP!,{IACC,R7}          ;push the new DIM details {free ptr,bytes}
        BL      STOREA                 ;store thing, may yet fail
        LDMFD   SP!,{IACC,R7}          ;recover our DIM details
        TEQ     R7,#0                  ;was the size -ve? (DIM p% -1 gives p%=FSA and FSA is unchanged)
        BMI     BADDIMSIGN             ;yes. return an error
        ADD     R7,R7,#3               ;round to a whole number of words
        BIC     R7,R7,#3               ;...
        ADD     R7,IACC,R7             ;R7 is now the new position of FSA if we claim the block
        ADD     R6,R7,#512             ;generous allocation of free space below stack
        CMP     R6,SP                  ;will the claim leave much room in for our stack?
        BCS     BADDIMSIZE             ;no. return an error
        STR     R7,[ARGP,#FSA]         ;yes. claim the memory
DIMNXT  MOV     LINE,AELINE            ;is there another item to DIM?
        CMP     R10,#","               ;...
        BNE     DONEXT                 ;no. move on to the next statement
; *************************************
; *
; * Entry point for a DIM statement
; *
DIM     BL      SPACES                 ;skip spaces, place non-space char in R10. LINE = ptr to char /after/ R10
        MOV     R0,R10                 ;move non-space char into R0
        BL      WORDCQ                 ;is the char in ['A'-'Z','a'-'z','0'-'9']? CS if yes
        CMPCS   R10,#"A"               ;if yes, is char a digit?
        BCC     BADDIM                 ;taken if WORDCQ failed, or if '0'-'9'
; now have first char of item in R10 as rqd
        MOV     TYPE,#TFPLV            ;TYPE = real
        MOV     AELINE,LINE            ;scan to the end of the identifier
DIMNO   LDRB    R0,[AELINE],#1
        BL      WORDCQ
        BCS     DIMNO                  ;AELINE = ptr to char after identifier
        CMP     R0,#"("                ;is this the subscripts?
        BEQ     DIMVAR                 ;yes
        CMP     R0,#"%"                ;no. is this an integer array?
        MOVEQ   TYPE,#4                ;yes
        CMPNE   R0,#"$"                ;no. is this a string array?
        BNE     DIMSPA                 ;no. this is a DIM blk size. do it...
        CMP     TYPE,#TFPLV
        MOVEQ   TYPE,#128
        LDRB    R0,[AELINE],#1
        CMP     R0,#"("
        BNE     DIMSPA
DIMVAR  MOV     R4,LINE
        LDRB    R3,[R4],#1             ;arrays always 2 or more chars
        STR     TYPE,[SP,#-4]!         ;size of actual array elements
        BL      LOOKUP
        BNE     DIMVA2                 ;does not exist: easy!
        ADD     IACC,IACC,#3
        BIC     IACC,IACC,#3
        LDR     R3,[IACC]
        CMP     R3,#16
        BCC     DIMVA3
        B       ERNDIM                 ;if it does exist then it must be null
DIMVA2  MOV     TYPE,#4                ;creates null pointer to rest of array
        BL      CREATE                 ;lvalue in facc
        MOV     R3,#0
DIMVA3  ADD     CLEN,ARGP,#STRACC      ;subscript list built in STRACC
        LDR     TYPE,[SP],#4           ;get original type from stack
        MOV     R1,#1                  ;count of entries
        STR     IACC,[SP,#-4]!         ;save l value
RDLOOP  STMFD   SP!,{R1,R3,TYPE}       ;allocation place, number of entries, type
        BL      SPUSH
        BL      EXPR
        BL      INTEGY
        CMP     IACC,#&1000000
        BCS     BADDIMSUB              ;also removes negative numbers
        ADD     R7,IACC,#1
        BL      SPULL
        LDMFD   SP!,{R1,R3,TYPE}
        STR     R7,[CLEN],#4           ;add to subscript list
        MOV     R4,#0
RDLOOM  MOVS    R7,R7,LSR #1
        ADDCS   R4,R4,R1
        CMP     R4,#&1000000           ;2^24
        ADDCCS  R1,R1,R1               ;add if above compare ok
        BCS     DIMRAM                 ;either r1 overflow or r4>2^24
        TEQ     R7,#0
        BNE     RDLOOM
        MOV     R1,R4                  ;multiplied pair of numbers
        CMP     R10,#","
        BEQ     RDLOOP
        CMP     R10,#")"
        BNE     BADDIMLIST
        TEQ     TYPE,#4                ;test type
        MOVEQ   R5,R1,LSL #2           ;if integer than number of bytes is 4* number of entries
        ADDNE   R5,R1,R1,LSL #2        ;if real/string then 5*
 [ FPOINT=1 :LOR: FPOINT=2
        TEQ     TYPE,#8
        MOVEQ   R5,R1,LSL #3
 ]
        ADD     R5,R5,#3
        BIC     R5,R5,#3               ;number of bytes rounded to words
        ADD     IACC,ARGP,#STRACC
        SUB     IACC,CLEN,IACC
        ADD     IACC,IACC,#8
        ADD     IACC,IACC,R5
        LDR     R4,[ARGP,#FSA]
        ADD     R7,R4,IACC
        ADD     R6,R7,#1024            ;plus generous allowance
        CMP     R6,SP
        BCS     DIMRAM
        LDR     R6,[SP],#4             ;address to alter
        CMP     R3,#1
        SUBEQ   SP,SP,IACC
        MOVEQ   R4,SP
        STREQ   IACC,[SP,#-4]!
        STREQ   R6,[SP,#-4]!
        ADDEQ   IACC,TYPE,#256
        LDREQ   R7,[ARGP,#LOCALARLIST]
        STMEQFD SP!,{IACC,R7}
        STREQ   SP,[ARGP,#LOCALARLIST]
        STRNE   R7,[ARGP,#FSA]
        STR     R4,[R6]                ;update pointer
        ADD     R7,ARGP,#STRACC
DIMCOPY LDR     IACC,[R7],#4
        STR     IACC,[R4],#4
        CMP     R7,CLEN
        BCC     DIMCOPY
        MOV     IACC,#0
        STR     IACC,[R4],#4           ;terminate list
        STR     R1,[R4],#4             ;put in the number of entries
        BL      INITIALISERAM
        BL      AESPAC
        B       DIMNXT
;R0 word to save
;R4 base address
;R5 number of bytes
INITIALISERAM
        MOV     R1,R0
        MOV     R2,R0
        MOV     R3,R0
INITIALISERAM1
        SUBS    R5,R5,#16
        STMHSIA R4!,{R0,R1,R2,R3}
        BHI     INITIALISERAM1
        MOVEQ   PC,R14
        CMN     R5,#8
        STRLO   R0,[R4],#4
        STMEQIA R4!,{R0,R1}
        STMHIIA R4!,{R0,R2,R3}
        MOV     PC,R14
END     BL      SPACES
        CMP     R10,#"="
        BEQ     ENDCHANGE
        BL      DONE
        BL      ENDER
        B       CLRSTK
ENDCHANGE
        LDR     R0,[ARGP,#DIMLOCAL]    ;are there any DIM locals in force?
        TEQ     R0,#0
        BNE     ERMVSTK
        BL      AEEXDN
        SUB     R7,R0,#&8000           ;subtract start of world
        LDR     R4,[ARGP,#HIMEM]
        SUB     R5,R4,SP               ;amount of space on stack
        LDR     R6,[ARGP,#FSA]
        ADD     R2,R6,#1024
        ADD     R2,R2,R5               ;FSA+1024+amount of space on stack
        CMP     R2,R0
        BCS     ERREND
;first move the stack down
ENDCHANGE1
        LDR     R3,[SP],#4
        STR     R3,[R6],#4             ;R6=FSA
        CMP     SP,R4                  ;R4=HIMEM
        BCC     ENDCHANGE1
;change memory size
        MOV     R0,R7
        MOV     R1,#-1
        SWI     Wimp_SlotSize
        ADD     R0,R0,#&8000           ;add start of world
        SUB     R7,R0,SP               ;remember difference - how far the world moved!
        MOV     SP,R0
        STR     SP,[ARGP,#MEMLIMIT]
        STR     SP,[ARGP,#HIMEM]
;move stack back up again
        LDR     R1,[ARGP,#FSA]
ENDCHANGE2
        LDR     R3,[R6,#-4]!
        STR     R3,[SP,#-4]!
        CMP     R6,R1
        BHI     ENDCHANGE2
;patch self references on the stack
        ADD     R4,ARGP,#LOCALARLIST-4
        LDR     R0,[ARGP,#ERRSTK]
        ADD     R0,R0,R7
        STR     R0,[ARGP,#ERRSTK]
        MOV     R0,#0                  ;false: no error in local realloc
        STR     R0,[ARGP,#INSTALLLIST] ;kill installed libraries
ENDCHANGELOCALAR
        LDR     R3,[R4,#4]             ;next field
        TEQ     R3,#0
        BEQ     ENDCHANGELOCALARDONE
        ADD     R3,R3,R7               ;alter reference to stack
        STR     R3,[R4,#4]
        MOV     R4,R3
        LDR     R5,[R4,#8]             ;address of owner
        LDR     R6,[R5]
        ADD     R6,R6,R7               ;move owner's idea of where we are
        ADD     R1,R4,#16              ;check its pointing at us
        CMP     R6,R1
        STREQ   R6,[R5]
        MOVNE   R0,#1                  ;remember error
        B       ENDCHANGELOCALAR
ENDCHANGELOCALARDONE
        TEQ     R0,#0
        BEQ     NXT
        B       ERRENDARRAYREF
ENDPR   BL      DONES
ENDPRA  LDR     R4,[SP],#4
        TEQ     R4,#TPROC
        BNE     ENDPRP
        BL      ENDTRC
        MOV     TYPE,#TINTEGER
        BL      GTARGS
        SUB     SP,SP,#4
        CMP     LINE,AELINE
        MOVCC   LINE,AELINE
        B       DONXTS
ENDPRP  SUB     SP,SP,#4
        BL      POPA
        BEQ     ENDPRA
        B       ENDPRE
ENDWH   LDR     R4,[ARGP,#ESCWORD]
        CMP     R4,#0
        BLNE    DOEXCEPTION
        BL      DONES
        B       ENDWHM
ENDWHP  BL      POPA
        BNE     ERWHIL
ENDWHM  LDR     R4,[SP]
        CMP     R4,#TENDWH
        BNE     ENDWHP
        LDR     AELINE,[SP,#8]         ;get expression pointer
        STR     R10,[SP,#-4]!          ;preserve next character
        BL      EXPR
        TEQ     TYPE,#0
        BEQ     ERTYPEINT
        BLMI    SFIX
        LDR     R10,[SP],#4
        CMP     IACC,#0
        LDRNE   LINE,[SP,#4]           ;restart
        BNE     STMT
        PULLJ   3
        B       NXT                    ;R10 ok!
ENVEL   SUB     SP,SP,#16
        MOV     R1,#0
        MOV     AELINE,LINE
ENVELP  STR     R1,[SP,#-4]!
        BL      INTEXC
        LDR     R1,[SP],#4
        STRB    IACC,[SP,R1]
        ADD     R1,R1,#1
        CMP     R1,#13
        BNE     ENVELP
        BL      EXPRDN
        STRB    IACC,[SP,#13]
        MOV     R1,SP
        MOV     R0,#OsWord_DefineSoundEnvelope
        SWI     OS_Word
        ADD     SP,SP,#16
        B       NXT
FOR     BL      CRAELV
        BEQ     FORCV
        CMP     TYPE,#TFPLV+1
        BCS     FORCV
        STMFD   SP!,{IACC,TYPE}        ;for STORE
        BL      AESPAC
        CMP     R10,#"="
        BNE     MISSEQFOR
        BL      EXPR
        CMP     R10,#TTO
        BNE     FORTO
        BL      STORE                  ;start
        CMP     R5,#TFPLV              ;type of assignment
        BEQ     FFOR
        MOV     R0,#TNEXT              ;integer FOR
        MOV     R6,#1                  ;possible STEP
        STMFD   SP!,{R0,R4,R5,R6,R7}   ;TNEXT got, VAR got, ADDR, STEP got if 1, LIMIT
        BL      EXPR
        BL      INTEGY
        STR     IACC,[SP,#4*4]         ;write limit onto stack
        CMP     R10,#TSTEP
        BNE     FORSTW
        BL      EXPR
        BL      INTEGY
        TEQ     IACC,#0
        BEQ     FORSTEP
        STR     IACC,[SP,#3*4]         ;write new step size onto stack
FORSTW  BL      AEDONE
        SUB     LINE,LINE,#1
        BL      MUNGLE
        STR     LINE,[SP,#2*4]         ;write restart position onto stack
        B       STMT
FFOR    MOV     R0,#TFOR               ;floating point FOR
        STMFD   SP!,{R0,R4,R5,R6,R7,R8,R9} ;TFOR got, VAR got, ADDR, STEP(8), LIMIT(8)
        BL      EXPR
        BL      FLOATY
 [ FPOINT=0
        ADD     TYPE,SP,#20
        FSTA    TYPE                   ;write limit into stack
        BL      FONE
 ELIF FPOINT=1
        STFD    FACC,[SP,#20]
        MVFD    FACC,#1
 ELIF FPOINT=2
        FSTD    FACC,[SP,#20]
        FLDD    FACC,=1
 |
        ! 1, "Unknown FPOINT setting"
 ]
        CMP     R10,#TSTEP
        BNE     FORSTA
        BL      EXPR
        BL      FLOATY
 [ FPOINT=0
        TEQ     FACC,#0
 ELIF FPOINT=1
        CMF     FACC,#0
 ELIF FPOINT=2
        FCMPZD  FACC
        FMRX    PC,FPSCR
 |
        ! 1, "Unknown FPOINT setting"
 ]
        BEQ     FORSTEP
FORSTA
 [ FPOINT=0
        ADD     TYPE,SP,#12            ;step offset on stack
        FSTA    TYPE
 ELIF FPOINT=1
        STFD    FACC,[SP,#12]
 ELIF FPOINT=2
        FSTD    FACC,[SP,#12]
 |
        ! 1, "Unknown FPOINT setting"
 ]
        B       FORSTW
        LTORG
GOSUB   LDR     R4,[ARGP,#ESCWORD]
        CMP     R4,#0
        BLNE    DOEXCEPTION
        BL      GOFACT
        BL      DONES
        MOV     R0,#TRETURN
        STMFD   SP!,{LINE,R0}
        ADD     LINE,R1,#4
        LDR     R0,[ARGP,#FSA]
        ADD     R0,R0,#1024
        CMP     R0,SP
        BCC     STMT
        B       ERDEEPNEST
GOTO    LDR     R4,[ARGP,#ESCWORD]
        CMP     R4,#0
        BLNE    DOEXCEPTION
        BL      GOFACT
        BL      DONES
        ADD     LINE,R1,#4
        B       STMT
GOFACT  AND     R1,LINE,#CACHEMASK
        ADD     R1,ARGP,R1,LSL #CACHESHIFT
        LDMIA   R1,{R1,R2,R4}
        CMP     R4,LINE
        ADDEQ   LINE,LINE,R2
        MOVEQ   PC,R14
        STR     R14,[SP,#-4]!
        MOV     AELINE,LINE
        BL      SPTSTN
        BEQ     GOTOT2
        SUB     AELINE,LINE,#1
        BL      EXPR
        BL      INTEGY
        CMP     IACC,#65280
        BCS     NOLINE
        SUB     LINE,AELINE,#1
        BL      FNDLNO
        LDRCS   PC,[SP],#4
        B       NOLINE
GOTOT2  BL      FNDLNO
        BCC     NOLINE
        AND     R3,AELINE,#CACHEMASK
        ADD     R3,ARGP,R3,LSL #CACHESHIFT
        SUB     R2,LINE,AELINE
        STMIA   R3,{R1,R2,AELINE}
        LDR     PC,[SP],#4
;Address of cr before line in R1 of FACC. cs if found
FNDLNO  LDR     R1,[ARGP,#PAGE]
FNDLNONEXT
        AND     R3,IACC,#255           ;continue position (R1 points to cr already)
        B       SIGHT
LOOKR   LDRB    R2,[R1,#3]
        ADD     R1,R1,R2
SIGHT   LDRB    R2,[R1,#1]
        CMP     R2,IACC,LSR #8
        BCC     LOOKR
        LDREQB  R2,[R1,#2]
        CMPEQ   R2,R3
        BCC     LOOKR
        MOVEQ   PC,R14                 ;cs if found
        CLC                            ;return cc
        MOV     PC,R14
IF      BL      AEEXPR
        TEQ     TYPE,#0
        BEQ     ERTYPEINT
        BLMI    SFIX
        MOV     LINE,AELINE
        CMP     IACC,#0
        BEQ     ELSE
        CMP     R10,#TTHEN
        BNE     DISPAT
THENLN  LDRB    R10,[LINE],#1
        CMP     R10,#" "
        BEQ     THENLN
        CMP     R10,#TCONST
        BNE     DISPAT
        LDR     R4,[ARGP,#ESCWORD]
        CMP     R4,#0
        BLNE    DOEXCEPTION
        AND     R1,LINE,#CACHEMASK
        ADD     R1,ARGP,R1,LSL #CACHESHIFT
        LDMIA   R1,{R1,R2,R4}
        CMP     R4,LINE
        ADDEQ   LINE,R1,#4
        BEQ     STMT
        BL      SPGETN
        BL      FNDLNO
        BCC     NOLINE
        SUB     R4,LINE,#3
        AND     R3,R4,#CACHEMASK
        ADD     R3,ARGP,R3,LSL #CACHESHIFT
        STMIA   R3,{R1,R2,R4}
        ADD     LINE,R1,#4
        B       STMT
ELSE    TEQ     R10,#13
        BEQ     CRLINE
        TEQ     R10,#TELSE
        BEQ     THENLN
        TEQ     R10,#TTHEN             ;check to see if block structured
        BEQ     ELSEBLK
ELSELP  LDRB    R10,[LINE],#1
        CMP     R10,#13
        BEQ     CRLINE
ELSELP1 CMP     R10,#TELSE
        BEQ     THENLN
        LDRB    R10,[LINE],#1
        CMP     R10,#13
        BEQ     CRLINE
        CMP     R10,#TELSE
        BNE     ELSELP
        B       THENLN
ELSEBLK ROUT
        LDRB    R10,[LINE],#1
        TEQ     R10,#13                ;trailing spaces were stripped when the line was entered
        BNE     ELSELP1                ;not a block structured one
        SUB     R2,LINE,#1             ;address of CR
        MOV     R3,#0                  ;count of nested block ifs
        B       %01
00      LDRB    R0,[R2,#3]
        ADD     R2,R2,R0
01      LDRB    R0,[R2,#1]
        CMP     R0,#&FF
        BCS     NOENDI
        LDRB    R0,[R2,#-1]            ;check end of line for block if
        CMP     R0,#TTHEN
        ADDEQ   R3,R3,#1               ;increment counter if present
        ADD     R1,R2,#4
02      LDRB    R0,[R1],#1
        TEQ     R0,#" "
        BEQ     %02
        CMP     R0,#TENDIF
        SUBEQS  R3,R3,#1               ;found ENDIF so decrement count
        MOVEQ   LINE,R1
        BEQ     ENDIF                  ;found end of block with no else
        CMP     R0,#TELSE2
        BNE     %00
        TEQ     R3,#1
        BNE     %00
        MOV     LINE,R1
        B       STMT                   ;found suitable else in block
; block ELSE statement
ELSE2   ROUT
        LDRB    R10,[LINE],#1
        TEQ     R10,#13
        BNE     ELSE2
        MOV     R3,#0
        SUB     R2,LINE,#1             ;r2 points to CR
        B       %01
00      LDRB    R0,[R2,#3]
        ADD     R2,R2,R0
01      LDRB    R0,[R2,#1]
        CMP     R0,#&FF
        BCS     NOENDI
        LDRB    R0,[R2,#-1]
        CMP     R0,#TTHEN
        ADDEQ   R3,R3,#1
        ADD     R1,R2,#4
02      LDRB    R0,[R1],#1
        TEQ     R0,#" "
        BEQ     %02
        TEQ     R0,#TENDIF
        BNE     %00
        SUBS    R3,R3,#1
        BPL     %00
        MOV     LINE,R1
        B       DONXTS
INPUT   BL      SPACES
        CMP     R10,#"#"
        BEQ     INPUTH
        MOV     R4,#&40
        MOV     R5,#0
        CMP     R10,#TLINE
        MOVNE   R4,#0
        SUBNE   LINE,LINE,#1
INPLP   BL      SPACES
        BL      PRSPEL
        ORRNE   R4,R4,#&80
        BNE     INPHP
INPLO   BL      SPACES
        BL      PRSPEL
        BEQ     INPLO
        MOV     R5,#0
        BIC     R4,R4,#&80
INPHP   CMP     R10,#","
        CMPNE   R10,#";"
        BEQ     INPLP
        SUB     LINE,LINE,#1
        STMFD   SP!,{R4,R5}
        BL      CRAELV
        LDMFD   SP!,{R4,R5}
        BEQ     DONXTS
        MOV     LINE,AELINE
        STMFD   SP!,{IACC,TYPE}
        TST     R4,#&40
        BNE     INGET
        TEQ     R5,#0
        BNE     INGOT
INGET   TST     R4,#&80
        SWINE   OS_WriteI+"?"
        BL      INLINE
        SUB     CLEN,R1,#1
INLEN   LDRB    R0,[CLEN,#1]!
        CMP     R0,#13
        BNE     INLEN
        BIC     R4,R4,#&80
        TST     R4,#&40
        BNE     INGETB
        ADD     R5,ARGP,#STRACC
INGOT   MOV     AELINE,R5
        BL      DATAST
        LDRB    R0,[CLEN]
        CMP     R0,#13
        MOV     R0,#","
        STRNEB  R0,[CLEN]
INTERM  LDRB    R10,[AELINE],#1
        CMP     R10,#","
        BEQ     INGETC
        CMP     R10,#13
        BNE     INTERM
        MOV     AELINE,#0
INGETC  MOV     R5,AELINE
INGETB  LDMFD   SP!,{IACC,TYPE}
        STMFD   SP!,{R4,R5}
        STMFD   SP!,{IACC,TYPE}
        CMP     TYPE,#128
        MOVCS   TYPE,#0
        BLCC    VALSTR
        BL      STORE
        LDMFD   SP!,{R4,R5}
        B       INPLP
LET     BL      AELV
        BNE     GOTLT
        BCS     ERSYNT
        MOV     R0,AELINE
LET1    LDRB    R7,[R0],#1
        CMP     R7,#" "
        BEQ     LET1
        CMP     R7,#"="
        BNE     MISSEQ
        BL      CREATE
        B       GOTLT
LOCALERROR
        BL      DONES
        LDR     R1,[ARGP,#ERRSTK]
        LDR     R2,[ARGP,#ERRORH]
        MOV     R0,#TERROR
        STMFD   SP!,{R0,R1,R2}
        B       NXT
LOCALDATA
        BL      DONES
        LDR     R1,[ARGP,#DATAP]
        MOV     R0,#TDATA
        STMFD   SP!,{R0,R1}
        B       NXT
; *************************************
; *
; * Entry point for a LOCAL statement
; *
LOCAL   BL      SPACES                 ;skip spaces
        CMP     R10,#TERROR            ;is this LOCAL ERROR ?
        BEQ     LOCALERROR             ;yes. do it
        CMP     R10,#TDATA             ;no. is this LOCAL DATA ?
        BEQ     LOCALDATA              ;yes. do it
        LDR     R0,[SP]                ;check that we are in the body of a PROC or FN
        TEQ     R0,#TPROC              ;DEFinition and not inside any structure (like
        TEQNE   R0,#TFN                ;a FOR loop) which uses the stack...
        BNE     ERRNLC                 ;oops, return an error
        SUB     LINE,LINE,#1           ;because of SPACES returning ptr /after/ first non-space char
LOCALP  BL      CRAELV                 ;create an LV (EQ = failed)
        BEQ     DONXTS                 ;failed, do the next statement
        MOV     LINE,AELINE            ;LINE=ptr to after the variable
        LDMFD   SP!,{R5,R6,R7}         ;pull some stuff from the stack...
        ;R5=PROC/FN token
        ;R6=AELINE for first statement in routine
        ;R7=LINE for first statement in routine
        MOV     R10,IACC               ;R10=value
        MOV     AELINE,TYPE            ;AELINE=type
        CMP     TYPE,#256              ;what is the type of the identifier to make local?
        BCS     LOCALARRAY             ;array.
        BL      VARIND                 ;return the L-value for this identifier
        BL      PUSHTYPE               ;push the value of this identifier onto the stack
        STMFD   SP!,{R10,AELINE}       ;push the L-value for this identifier
        STMFD   SP!,{R5,R6,R7}         ;push the PROC/FN status stuff back onto the stack
        MOV     R0,#0                  ;initialise the new local variable
        CMP     AELINE,#128
        BEQ     LOCALZS
        BCS     LOCALZR
LOCALZN STRB    R0,[R10],#1
        SUBS    AELINE,AELINE,#1
        BHI     LOCALZN
        B       LOCALZ
LOCALARRAY
        LDR     R1,[IACC]
        MOV     R2,#4
        STR     R1,[SP,#-4]!
        STMFD   SP!,{IACC,R2}
        STMFD   SP!,{R5,R6,R7}
        MOV     R1,#1
        STR     R1,[IACC]
        B       LOCALZ
LOCALZR MOV     R0,#13
        STRB    R0,[R10]
        B       LOCALZ
LOCALZS MOV     CLEN,R3                ;0 length string somewhere
        MOV     R4,R10
        BL      STSTORE
LOCALZ  BL      SPACES
        CMP     R10,#","
        BEQ     LOCALP
        B       DONEXT
NEXT    LDR     R4,[ARGP,#ESCWORD]
        CMP     R4,#0
        BLNE    DOEXCEPTION
        MOV     AELINE,LINE
NEXTBLNK
        LDRB    R10,[AELINE],#1
        CMP     R10,#" "
        BEQ     NEXTBLNK
        CMP     R10,#"!"
        CMPNE   R10,#"?"
        BCC     NEXM1                  ;ignore : and CR
        AND     R1,AELINE,#CACHEMASK
        ADD     R1,ARGP,R1,LSL #CACHESHIFT
        LDMIA   R1,{IACC,R1,R4,TYPE}
        CMP     R4,AELINE
        BNE     NEXTVBNOTCACHE
        CMN     R1,#1
        ADD     AELINE,AELINE,R1
        BPL     STRIPA
        SUB     AELINE,AELINE,#TFP     ;array element
        BL      ARLOOKCACHE
        BNE     STRIPA
        B       NEXM1
NEXTVBNOTCACHE
        BL      LVNOTCACHE
        BNE     STRIPA
        BCC     ERSYNT
NEXM1   LDMFD   SP,{R4,R5}
        TEQ     R4,#TNEXT
        BEQ     NOCHKI
        TEQ     R4,#TFOR
        BEQ     FNEXT
        BL      POPA
        BEQ     NEXM1
        B       ERNEXT
STRIPA  CMP     TYPE,#128
        BCS     ERSYNT
        MOV     LINE,AELINE            ;update pointer (something there!)
        LDMFD   SP,{R4,R5}
        TEQ     R4,#TNEXT
        BEQ     NEXSI
        TEQ     R4,#TFOR
        BNE     ERNEXT
        TEQ     IACC,R5
        BEQ     FNEXT
NEXP2   BL      POP
        BNE     NEXTER
        LDMFD   SP,{R4,R5}
        TEQ     R4,#TFOR
        BEQ     NEXSF
        TEQ     R4,#TNEXT
        BNE     NEXTER
NEXSI   TEQ     IACC,R5
        BNE     NEXP2
NOCHKI  LDMFD   SP,{R3,R4,R5,R6,R7}
      [ NoARMv6 :LOR: NoUnaligned
        ANDS    R2,R4,#3
        BNE     SLONXT                 ;bottom 2 bits not zero so slower
      ]
        LDR     IACC,[R4]              ;get contents
        ADDS    IACC,IACC,R6           ;add step
        BVS     INXTPL
        STR     IACC,[R4]              ;write back
INXTPR  TEQ     R6,#0                  ;test sign of step
        BMI     INXTCH
        CMP     IACC,R7                ;test if ascending loop
INXTMT  MOVLE   LINE,R5                ;if <= continue
        BLE     STMT
INXTPL  PULLJ   5
NEXTEX  BL      SPACES
        CMP     R10,#","
        BEQ     NEXT
        B       DONEXT
INXTCH  CMP     R7,IACC                ;test if descending loop
        B       INXTMT
      [ NoARMv6 :LOR: NoUnaligned
SLONXT  LDW     IACC,R4,R1,R2
        ADDS    IACC,IACC,R6
        BLVC    STORER0MISAL
        BVC     INXTPR
        B       INXTPL
      ]
NEXSF   TEQ     IACC,R5
        BNE     NEXP2
FNEXT
 [ FPOINT=0
        LOAD5   FACC,FACCX,R5,FGRD,FSIGN
        AND     FSIGN,FACC,#&80000000
        ORRNE   FACC,FACC,#&80000000
        ADD     TYPE,SP,#12            ;address of step
        LDMIA   TYPE,{FWACC,FWACCX}
        AND     FWSIGN,FWACCX,#&80000000
        AND     FWACCX,FWACCX,#255
        TEQ     FWACC,#0
        BLNE    FADDW
        LDR     TYPE,[SP,#4]
        BL      F1STA
        ADD     TYPE,SP,#20            ;address of limit
        TEQ     FWSIGN,#0              ;fadd did not hurt this value (sign of step)
        BMI     FNEXTA
        BL      FNEXCM
        LDRGE   LINE,[SP,#8]
        BGE     STMT
        PULLJ   7
        B       NEXTEX
FNEXTA  BL      FNEXCM
        LDRLE   LINE,[SP,#8]
        BLE     STMT
        PULLJ   7
        B       NEXTEX
FNEXCM  LDMIA   TYPE,{FWACC,FWACCX}
        AND     FWSIGN,FWACCX,#&80000000
        CMP     FWSIGN,FSIGN           ;only top bits!!!!
        MOVNE   PC,R14                 ;easy
        AND     FWACCX,FWACCX,#255
        TEQ     FSIGN,#0
        BMI     FNEXCP
        CMP     FWACCX,FACCX
        MOVNE   PC,R14
        CMP     FWACC,FACC
        MOV     PC,R14
FNEXCP  CMP     FACCX,FWACCX
        MOVNE   PC,R14
        CMP     FACC,FWACC
        MOV     PC,R14
 ELIF FPOINT=1
        LDFD    FACC,[R5]
        LDFD    F1,[SP,#12]            ;step
        CMF     F1,#0
        ADFD    FACC,F1,FACC
        STFD    FACC,[R5]
        LDFD    F1,[SP,#20]            ;limit
        BMI     FNEXTA
        CMF     FACC,F1
        LDRLE   LINE,[SP,#8]
        BLE     STMT
        PULLJ   7
        B       NEXTEX
FNEXTA  CMF     FACC,F1
        LDRGE   LINE,[SP,#8]
        BGE     STMT
        PULLJ   7
        B       NEXTEX
 ELIF FPOINT=2
        FLDD    FACC,[R5]
        FLDD    D1,[SP,#12]            ;step
        FCMPZD  D1
        FADDD   FACC,D1,FACC
        FSTD    FACC,[R5]
        FMRX    PC,FPSCR
        FLDD    D1,[SP,#20]            ;limit
        BMI     FNEXTA
        FCMPD   FACC,D1
        FMRX    PC,FPSCR
        LDRLE   LINE,[SP,#8]
        BLE     STMT
        PULLJ   7
        B       NEXTEX
FNEXTA  FCMPD   FACC,D1
        FMRX    PC,FPSCR
        LDRGE   LINE,[SP,#8]
        BGE     STMT
        PULLJ   7
        B       NEXTEX
 |
        ! 1, "Unknown FPOINT setting"
 ]
ON      BL      SPACES
        CMP     R10,#TERROR
        BEQ     ONERR
        CMP     R10,#TELSE
        CMPNE   R10,#":"
        CMPNE   R10,#13
        BEQ     CURSON                 ;cursor on/off in Command
        SUB     AELINE,LINE,#1
        BL      EXPR
        BL      INTEGY
        CMP     R10,#TGOTO
        CMPNE   R10,#TGOSUB
        CMPNE   R10,#TPROC
        BNE     ONER
        CMP     R10,#TPROC
        SUBEQ   AELINE,AELINE,#1
        SUBS    IACC,IACC,#1
        BCC     ONRGA
        BEQ     ONGOT
        MOV     R4,#0
ONSRCH  LDRB    R1,[AELINE],#1
        CMP     R1,#13
        CMPNE   R1,#TELSE
        BEQ     ONRG
        CMP     R1,#"("
        ADDEQ   R4,R4,#1
        CMP     R1,#")"
        SUBEQ   R4,R4,#1
        TEQ     R4,#0
        BNE     ONSRCH
        CMP     R1,#":"
        BEQ     ONRGA
        CMP     R1,#","
        BNE     ONSRCH
        SUBS    IACC,IACC,#1
        BNE     ONSRCH
ONGOT   CMP     R10,#TGOSUB
        BEQ     ONGOSB
        CMP     R10,#TPROC
        BEQ     ONPROC
        MOV     LINE,AELINE
        BL      GOFACT
        ADD     LINE,R1,#4
        B       STMT
ONGOSB  MOV     LINE,AELINE
        BL      GOFACT
        BL      ONSKIP
        MOV     R0,#TRETURN
        STMFD   SP!,{LINE,R0}
        ADD     LINE,R1,#4
        B       STMT
ONPROC  LDRB    R1,[AELINE],#1
        CMP     R1,#" "
        BEQ     ONPROC
        CMP     R1,#TPROC
        BNE     ONER
        BL      ONSKIP
        SUB     LINE,LINE,#1
        LDR     R1,[ARGP,#PROCPTR]
        B       FNBODY
ONSKIP  MOV     LINE,AELINE
ONSKPA  LDRB    R2,[LINE],#1
        CMP     R2,#13
        CMPNE   R2,#":"
        BNE     ONSKPA
        MOV     PC,R14
ONRGA   LDRB    R1,[AELINE],#1
        CMP     R1,#13
        CMPNE   R1,#TELSE
        BNE     ONRGA
ONRG    CMP     R1,#13
        BEQ     ONRGER
        MOV     LINE,AELINE
        B       THENLN
ONERR   BL      SPACES
        CMP     R10,#TOFF
        BEQ     ONERRF
        CMP     R10,#TLOCAL
        SUBNE   LINE,LINE,#1
        STREQ   SP,[ARGP,#ERRSTK]
        STR     LINE,[ARGP,#ERRORH]
        B       REM
ONERRF  BL      DONES
        BL      ORDERR
        B       NXT
RESTOREERROR
        BL      DONES
        LDR     R0,[SP],#4
        CMP     R0,#TERROR
        BNE     ONERRX
        LDMFD   SP!,{R1,R2}
        STR     R1,[ARGP,#ERRSTK]
        STR     R2,[ARGP,#ERRORH]
        B       NXT
RESTOREDATA
        BL      DONES
        LDR     R0,[SP],#4
        CMP     R0,#TDATA
        BNE     ERRDATASTACK
        LDR     R1,[SP],#4
        STR     R1,[ARGP,#DATAP]
        B       NXT
PRINT   BL      SPACES
        CMP     R10,#"#"
        BEQ     PRINTH
        SUB     LINE,LINE,#1
        B       STRTPR
PRCOMM  LDRB    R0,[ARGP,#INTVAR]
        TEQ     R0,#0
        BEQ     STRTPR
        LDR     R1,[ARGP,#TALLY]
        MOVS    R2,R1
        BEQ     STRTPR
        MOV     R3,R0
PRCOML1 MOVS    R3,R3,LSL #1
        CMPCC   R3,R1
        BCC     PRCOML1
        MOV     R3,R3,ROR #1
PRCOML2 SUBS    R1,R1,R3
        BEQ     STRTPR
        SUBCSS  R1,R1,R3
        BEQ     STRTPR
        ADDCC   R1,R1,R3
        MOV     R3,R3,LSR #1
        CMP     R3,R0
        BCS     PRCOML2
        RSB     R0,R1,R0
        BL      SPCSWC
STRTPR  LDRB    R4,[ARGP,#INTVAR]      ;prints
        MOV     R5,#0                  ;printf
ENDPRI  BL      SPACES
        CMP     R10,#":"
        CMPNE   R10,#13
        CMPNE   R10,#TELSE
        BNE     CONTPR
        BL      NLINE
        B       NXT
PRFUNY  MOV     R4,#0
        MOV     R5,#0
        BL      SPACES
        CMP     R10,#":"
        CMPNE   R10,#13
        CMPNE   R10,#TELSE
        BEQ     NXT
CONTPR  CMP     R10,#"~"
        MOVEQ   R5,#1                  ;print in hex
        BEQ     ENDPRI
        CMP     R10,#","
        BEQ     PRCOMM
        CMP     R10,#";"
        BEQ     PRFUNY
        BL      PRSPEC
        BEQ     ENDPRI
        STMFD   SP!,{R4,R5}
        SUB     AELINE,LINE,#1
        BL      EXPR
        LDMFD   SP!,{R4,R5}
        SUB     LINE,AELINE,#1
        TEQ     TYPE,#0
        BEQ     PRINTA
        STMFD   SP!,{R4,R5}
        LDR     R4,[ARGP,#INTVAR]      ;@@%; r5 already has hex t/f
        BL      FCONFP
        MOV     CLEN,TYPE
        LDMFD   SP!,{R4,R5}
        ADD     R0,ARGP,#STRACC
        SUB     TYPE,TYPE,R0
        SUBS    R0,R4,TYPE
        BLHI    SPCSWC
PRINTA  BL      PRINTS
        B       ENDPRI
PRINTS  ADD     R1,ARGP,#STRACC
        TEQ     R1,CLEN
        MOVEQ   PC,R14
        LDR     R0,[ARGP,#WIDTHLOC]
        CMN     R0,#1
        BNE     PRLOP2
        ADD     R0,ARGP,#STRACC
        SUB     R1,CLEN,R0
        SWI     OS_WriteN
        LDR     R0,[ARGP,#TALLY]
        ADD     R0,R0,R1
        STR     R0,[ARGP,#TALLY]
        MOV     PC,R14
PRLOP2  STMFD   SP!,{R7,R14}
        MOV     R7,#0
PRLOP3  LDRB    R0,[R1],#1
        BL      CHOUT
        TEQ     R1,CLEN
        BNE     PRLOP3
        LDMFD   SP!,{R7,R14}
        MOV     PC,R14
PRSPEL  CMP     R10,#""""
        BNE     PRSPEC
        STMFD   SP!,{R4,R5,R14}
        MOV     AELINE,LINE
        BL      QSTR
        MOV     LINE,AELINE
        BL      PRINTS
        B       PRSPEX
PRSPEC  CMP     R10,#"'"
        BEQ     NLINE                  ;EQ if anything found and done
        CMP     R10,#TTAB
        BEQ     TAB
        CMP     R10,#TSPC
        MOVNE   PC,R14
        STMFD   SP!,{R4,R5,R14}        ;SPC N
        BL      AEEXPR
        SUB     LINE,AELINE,#1
        BL      INTEGY
PRSPEY  BL      SPCSWC
PRSPEX  CMP     R0,R0
        LDMFD   SP!,{R4,R5,PC}
TAB     STMFD   SP!,{R4,R5,R14}
        BL      AEEXPR
        BL      INTEGY
        CMP     R10,#","
        BEQ     TAB2
        CMP     R10,#")"
        BNE     ERBRA
        MOV     LINE,AELINE
        LDR     R1,[ARGP,#TALLY]
        SUBS    R1,IACC,R1
        BEQ     PRSPEX
        MOVCS   IACC,R1
        BLCC    NLINE
        B       PRSPEY
TAB2    STR     IACC,[SP,#-4]!
        BL      BRA
        BL      INTEGZ
        SWI     OS_WriteI+31
        MOV     R1,IACC
        LDR     IACC,[SP],#4
        SWI     OS_WriteC
        MOV     R0,R1
        SWI     OS_WriteC
        MOV     LINE,AELINE
        B       PRSPEX
PROC    MOV     AELINE,LINE            ;AELINE -> start of identifier
        LDR     R1,[ARGP,#PROCPTR]     ;base of look-up table for PROC identifiers
        B       FNBODY
READEN  BL      STORE
        STR     AELINE,[ARGP,#DATAP]
READS   BL      SPACES
        CMP     R10,#","
        BNE     DONEXT
READ    BL      CRAELV
        BEQ     READS
        MOV     LINE,AELINE
        CMP     TYPE,#128
        BCS     READST
        BL      DATAIT
        STMFD   SP!,{IACC,TYPE}
        BL      EXPR
        SUB     AELINE,AELINE,#1
        B       READEN
READST  BL      DATAIT
        STMFD   SP!,{IACC,TYPE}
        BL      DATAST
        B       READEN
DATAIT  LDR     AELINE,[ARGP,#DATAP]
DATAA1  LDRB    R10,[AELINE],#1
        CMP     R10,#" "
        BEQ     DATAA1
        CMP     R10,#","
        MOVEQ   PC,R14
        CMP     R10,#13
        BNE     DATAA1
DATAA2  LDRB    R10,[AELINE]
        CMP     R10,#&FF
        BCS     DATAOT
        LDRB    R10,[AELINE,#2]
        ADD     R4,AELINE,R10          ;R4 1 on from next cr
        ADD     AELINE,AELINE,#3       ;first char
DATAA3  LDRB    R10,[AELINE],#1
        CMP     R10,#" "
        BEQ     DATAA3
        CMP     R10,#TDATA
        MOVEQ   PC,R14
        MOV     AELINE,R4
        B       DATAA2
REPEAT  BL      MUNGLE
        MOV     R0,#TUNTIL
        STMFD   SP!,{R0,LINE}
        B       STMT
REPORT  BL      DONES
        BL      NLINE
        ADD     R4,ARGP,#ERRORS
        MOV     R7,#0
REPORTLOP
        LDRB    R0,[R4],#1
        CMP     R0,#0
        BEQ     NXT
        BL      CHOUT
        B       REPORTLOP
RESTORE BL      SPACES
        CMP     R10,#TERROR
        BEQ     RESTOREERROR
        CMP     R10,#TDATA
        BEQ     RESTOREDATA
        LDR     R1,[ARGP,#PAGE]
        CMP     R10,#"+"
        BEQ     RESTOREREL
        CMP     R10,#":"
        CMPNE   R10,#13
        CMPNE   R10,#TELSE
        BEQ     RESDON
        SUB     LINE,LINE,#1
        BL      GOFACT
        BL      DONES
RESDON  STR     R1,[ARGP,#DATAP]
        B       NXT
RESTOREREL
        BL      AEEXDN
        SUB     R1,LINE,#2
RESTOREREL1
        LDRB    R2,[R1],#1
        CMP     R2,#13
        BNE     RESTOREREL1
        LDRB    R2,[R1],#1
        ADD     R1,R1,#2
        CMP     R2,#&FF
        BEQ     NOLINE
        SUBS    R0,R0,#1
        BGT     RESTOREREL1
        SUB     R1,R1,#4
        B       RESDON
RETURN  BL      DONES
RETURNA LDMFD   SP!,{R4,R5}
        CMP     R4,#TRETURN
        LDREQB  R10,[R5,#-1]           ;get original character of statement end
        MOVEQ   LINE,R5
        BEQ     NXT
        SUB     SP,SP,#8
        BL      POPA
        BEQ     RETURNA
        B       ERGOSB
;Pop one of REPEAT.UNTIL, FOR.NEXT, WHILE.ENDWHILE, LOCAL ERROR, LOCAL DATA
;NE signals no pop possible
;will use r4,r6,r7
POP     LDR     R4,[SP]
;entry with object in R4
POPA    TEQ     R4,#TUNTIL
        ADDEQ   SP,SP,#8
        MOVEQ   PC,R14
        TEQ     R4,#TENDWH
        ADDEQ   SP,SP,#12
        MOVEQ   PC,R14
        TEQ     R4,#TNEXT
        ADDEQ   SP,SP,#20
        MOVEQ   PC,R14
        TEQ     R4,#TFOR
        ADDEQ   SP,SP,#28
        MOVEQ   PC,R14
        TEQ     R4,#TERROR
        LDMEQFD SP!,{R4,R6,R7}
        STREQ   R6,[ARGP,#ERRSTK]
        STREQ   R7,[ARGP,#ERRORH]
        MOVEQ   PC,R14
        TEQ     R4,#TDATA
        LDMEQFD SP!,{R4,R6}
        STREQ   R6,[ARGP,#DATAP]
        MOVEQ   PC,R14
        SUBS    R6,R4,#256
        MOVCC   PC,R14                 ;signals NE
        CMP     R6,#4
        CMPNE   R6,#TFPLV
        CMPNE   R6,#128
        MOVNE   PC,R14                 ;check valid arrays
        LDMFD   SP!,{R4,R6,R7}
        STR     R6,[ARGP,#LOCALARLIST]
        MOV     R6,#0
        STR     R6,[R7]                ;undim it!
        CMP     R4,#256+128
        BNE     POPA2
        MOV     R6,R14
        ADD     R7,SP,#4
        BL      CLRSTRARRAY
        MOV     R14,R6
POPA2   LDR     R6,[SP],#4
        ADD     SP,SP,R6
        MOVS    R6,#0                  ;signal POP was possible
        MOV     PC,R14
;The stack is about to be moved up from SP to R0. Any local arrays in this
;area must be removed from the list set to undimensioned.
;The list first three elements are type, next, address
;use r4,r5,r6. r0 preserved.
POPLOCALAR
        ADD     R4,ARGP,#LOCALARLIST-4
        LDR     R5,[ARGP,#DIMLOCAL]    ;pop all the DIM LOCALs from the vanishing bit of stack
        TEQ     R5,#0
        CMPNE   R0,R5
        BLS     POPLOCALAR1            ;LS=(NOT C OR Z) i.e. skip when R5=0 or R0<=R5
POPDIMS LDR     R5,[R5,#8]             ;load next pointer
        TEQ     R5,#0
        CMPNE   R0,R5
        BHI     POPDIMS                ;HI=(C AND NOT Z) i.e. stop when R5=0 or R5>=R0
        STR     R5,[ARGP,#DIMLOCAL]
POPLOCALAR1
        LDR     R4,[R4,#4]             ;get next field
        TEQ     R4,#0                  ;reached end of list?
        BEQ     POPLOCALAREND
        CMP     R4,R0                  ;reached end of interesting bit?
        BCS     POPLOCALAREND
        LDR     R5,[R4]
        SUBS    R5,R5,#256
        BCC     ERCATASLIST
        CMP     R5,#4
        CMPNE   R5,#TFPLV
        CMPNE   R5,#128
        BNE     ERCATASLIST
        CMP     R5,#128
        BNE     POPLOCALAR2
        STMFD   SP!,{R7,R14}
        ADD     R7,R4,#16              ;purge array on stack
        BL      CLRSTRARRAY
        LDMFD   SP!,{R7,R14}
POPLOCALAR2
        LDR     R5,[R4,#8]
        MOV     R6,#0                  ;set to undimensioned
        STR     R6,[R5]
        B       POPLOCALAR1
POPLOCALAREND
        STR     R4,[ARGP,#LOCALARLIST] ;finished, so truncate list
        MOV     PC,R14

;clear string array so that all space is back on heap. Entry with R7 as
;address of array. Uses/destroys no registers
CLRSTRARRAY
        STMFD   SP!,{R0-R7,AELINE,R14}
CLRSTRARR1
        LDR     R4,[R7],#4
        CMP     R4,#0
        BNE     CLRSTRARR1
        ADD     R4,R7,#4
        LDR     AELINE,[R7]
        MOV     R2,R3
CLRSTRARR2
        BL      STSTORE
        ADD     R4,R4,#5
        SUBS    AELINE,AELINE,#1
        BNE     CLRSTRARR2
        LDMFD   SP!,{R0-R7,AELINE,PC}
RUN     BL      DONES
RUNNER  BL      SETFSA
        BL      ORDERR
        LDR     LINE,[ARGP,#PAGE]
        LDR     R0,[ARGP,#HIMEM]
        BL      POPLOCALAR
        LDR     SP,[ARGP,#HIMEM]
        MOV     R0,#0
        STMFD   SP!,{R0-R9}
        B       STMT
BEATS   BL      AEEXDN
        SWI     Sound_QBeat
        B       NXT
VOICES  BL      AEEXDN
        MOV     R1,#0
        MOV     R2,#0
        MOV     R3,#0
        MOV     R4,#0
        SWI     Sound_Configure
        B       NXT
VOICE   BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      EXPR
        TEQ     TYPE,#0
        BNE     ERTYPESTR
        BL      AEDONE
        LDR     R0,[SP],#4
        ADD     R1,ARGP,#STRACC
        MOV     R4,#0
        STRB    R4,[CLEN]
        SWI     Sound_AttachNamedVoice
        B       NXT
TEMPO   BL      AEEXDN
        SWI     Sound_QTempo
        B       NXT
STEREO  BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        MOV     R1,IACC
        LDR     R0,[SP],#4
        SWI     Sound_Stereo
        B       NXT
SOUND   BL      SPACES
        CMP     R10,#TOFF
        BEQ     SOUNDOFF
        EORS    R10,R10,#TON
        BEQ     SOUNDON
        SUB     AELINE,LINE,#1
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        MOV     IACC,IACC,LSL #16
        LDR     R1,[SP],#4
        MOV     R1,R1,LSL #16
        ORR     IACC,IACC,R1,LSR #16
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        LDMFD   SP!,{R1,R2}
        MOV     IACC,IACC,LSL #16
        MOV     R1,R1,LSL #16
        ORR     R3,IACC,R1,LSR #16
        CMP     R10,#","
        BNE     SOUNDFOUR
        STMFD   SP!,{R2,R3}
        BL      EXPRDN                 ;time parameter in R0 as required
        MOV     R1,#0
        LDMFD   SP!,{R2,R3}
        SWI     Sound_QSchedule
        B       NXT
SOUNDFOUR
        BL      AEDONE
        ADD     R1,ARGP,#STRACC
        STMIA   R1,{R2,R3}
        MOV     R0,#OsWord_GenerateSound
        SWI     OS_Word
        B       NXT
SOUNDOFF
        MOV     R0,#1
        B       SOUNDENABLEON
SOUNDON MOV     R0,#2
SOUNDENABLEON
        BL      DONES
        SWI     Sound_Enable
        B       NXT
STOP    BL      DONES
        B       ERSTOP
SWAP    BL      AELV
        BEQ     FACERR
        BL      AESPAC
        TEQ     R10,#","
        BNE     ERCOMM
        STMFD   SP!,{IACC,TYPE}
        BL      LVBLNK
        BEQ     FACERR
        MOV     LINE,AELINE
        BL      DONES
        LDMFD   SP!,{R4,R5}
        CMP     TYPE,#256
        BCS     SWAPAR1
        CMP     TYPE,#128
        BCC     SWAP1
SWAP2   STMFD   SP!,{R4,R5}            ;lv1
        STMFD   SP!,{IACC,TYPE}        ;lv2
        MOV     AELINE,SP
        BL      VARIND                 ;of lv2
        BL      PUSHTYPE               ;value of lv2
        STR     TYPE,[SP,#-4]!
        LDR     IACC,[AELINE,#8]
        LDR     TYPE,[AELINE,#12]
        BL      VARIND                 ;value of lv1
        LDMFD   AELINE!,{R4,R5}        ;lv2
        BL      STOREA                 ;lv2=(lv1)
        BL      PULLTYPE               ;(lv2)
        MOV     SP,AELINE
        BL      STORE                  ;lv1=(lv2)
        B       NXT
SWAP1   TEQ     TYPE,R5
        BNE     SWAP2
SWAP1A  LDRB    R1,[IACC]              ;swap 1,4,5/8 bytes for types 0,4,5/8
        LDRB    R2,[R4]
        STRB    R1,[R4],#1
        STRB    R2,[IACC],#1
        SUBS    R5,R5,#1
        BHI     SWAP1A
        B       NXT
SWAPAR1 CMP     R5,#256
        BCC     SWAP2
        CMP     TYPE,R5
        BNE     ERTYPESWAP
        LDR     R1,[IACC]              ;swap pointers to arrays
        LDR     R2,[R4]
        STR     R1,[R4]
        STR     R2,[IACC]
        B       NXT
TRACE   BL      SPACES
        TEQ     R10,#TTO
        BEQ     TRACETO
        TEQ     R10,#TCLOSE
        BEQ     TRACECLOSE
        LDR     R4,[ARGP,#TRCNUM]
        BIC     R4,R4,#TINTEGER        ;clear step bit
        MOV     R5,#&80                ;trcflg to be on after this...
        TEQ     R10,#TSTEP
        ORREQ   R4,R4,#TINTEGER
        BLEQ    SPACES
        CMP     R10,#TPROC
        CMPNE   R10,#TFN
        ORREQ   IACC,R4,#TFP           ;turn on proc/fn trace
        BEQ     TRSET1
        CMP     R10,#TENDPR
        ORREQ   IACC,R4,#TEFP
        BEQ     TRSET1
        BIC     R4,R4,#&FF             ;clear any existing line number
        BIC     R4,R4,#&FF00
        CMP     R10,#TCONST            ;constant number?
        BEQ     TRSET2
        CMPNE   R10,#TON               ;on anyway
        ORREQ   IACC,R4,#&FF00         ;big enough number
        BEQ     TRSET1
        EORS    IACC,R10,#TOFF
        BNE     TRNUMB
        MOV     R5,#0
TRSET1  BL      DONES
        ;
        ; We must flush the cache (and stop using it) while TRACE PROC/FN
        ; is on because we cannot output a PROC/FN name when a cache hit
        ; happens. PROC/FN calls are no longer placed into the cache while
        ; TRACE PROC/FN is active.
        ;
        TST     IACC,#TFP
        BEQ     TRSET
        STMFD   SP!,{R0-R2}
        BL      FLUSHCACHE
        LDMFD   SP!,{R0-R2}
        ;
        ; TRCNUM word has:
        ;   b31: trace proc/fn
        ;   b30: trace step
        ;   B29: trace endproc/fn exit
        ;   b15-0: trace max line number
        ;
TRSET   STR     IACC,[ARGP,#TRCNUM]
        STRB    R5,[ARGP,#TRCFLG]
        B       NXT
TRSET2  BL      SPGETN
        ADD     IACC,IACC,R4
        B       TRSET1
TRNUMB  STMFD   SP!,{R4,R5}
        SUB     LINE,LINE,#1
        BL      AEEXDN
        LDMFD   SP!,{R4,R5}
        ADD     IACC,IACC,R4
        B       TRSET
TRACETO BL      AEEXPR
        BL      OSSTRI
        BL      AEDONE
        LDR     R1,[ARGP,#TRACEFILE]
        TEQ     R1,#0
        MOV     R0,#0
        STR     R0,[ARGP,#TRACEFILE]   ;kill handle!
        SWINE   OS_Find
        ADD     R1,ARGP,#STRACC
        MOV     R0,#&80
        SWI     OS_Find
        STR     R0,[ARGP,#TRACEFILE]
        CMP     R0,#0
        MOV     R0,#&12                ;set type
        MOV     R2,#&FF
        ORR     R2,R2,#&F00
        SWINE   XOS_File
        SWIEQ   OS_File
        B       NXT
TRACECLOSE
        BL      DONES
        LDR     R1,[ARGP,#TRACEFILE]
        TEQ     R1,#0
        MOV     R0,#0
        STR     R0,[ARGP,#TRACEFILE]   ;kill handle!
        SWINE   OS_Find
        B       NXT
UNTIL   BL      AEEXDN
        LDR     R4,[ARGP,#ESCWORD]
        CMP     R4,#0
        BLNE    DOEXCEPTION
UNTILM  LDR     R4,[SP]
        CMP     R4,#TUNTIL
        BNE     UNTILP
        TEQ     IACC,#0
        LDREQ   LINE,[SP,#4]
        BEQ     STMT
        PULLJ   2
        B       NXT
UNTILP  BL      POPA
        BEQ     UNTILM
        B       ERREPT
WIDTH   BL      AEEXDN
        SUB     IACC,IACC,#1
        STR     IACC,[ARGP,#WIDTHLOC]
        B       NXT
WHILE   BL      SPACES
        SUB     AELINE,LINE,#1
        STR     AELINE,[SP,#-4]!       ;pointer to expression
        BL      EXPR
        BL      INTEGY
        SUB     LINE,AELINE,#1
        CMP     IACC,#0
        BEQ     EWHILE
        BL      MUNGLE
        MOV     R0,#TENDWH
        STMFD   SP!,{R0,LINE}          ;token, start of block
        B       STMT
EWHILX  LDRB    R10,[LINE],#1
        CMP     R10,#&FF
        BCS     CLRSTK
        ADD     LINE,LINE,#2
EWHILE  MOV     R1,#0                  ;inside strings. Facc (WHILE loop cnt) already 0
EWHILP  LDRB    R10,[LINE],#1
        CMP     R10,#13
        BEQ     EWHILX
        CMP     R10,#""""
        EOREQ   R1,R1,#1
        TEQ     R1,#0
        BNE     EWHILP
        CMP     R10,#TDATA
        CMPNE   R10,#TREM
        MOVEQ   R1,#4
        BEQ     EWHILP
        CMP     R10,#TWHILE
        ADDEQ   IACC,IACC,#1
        CMP     R10,#TENDWH
        SUBEQ   IACC,IACC,#1
        BNE     EWHILP
        CMN     IACC,#1
        BNE     EWHILP
        PULLJ   1
        BL      DONES
        B       NXT
        
        LNK     Stmt2.s
@


1.9
log
@Redo DO32BIT portions using central macros
When 32 bitted there weren't 26/32 neutral macros around, but can use them now there are allowing one common output binary for disc based BASIC.
Some of the sneaky 26 bit code (eg. relying on address space wrapping at 64MB rather than explicitly clearing bits when computing a jump) adopt the safer 32 bit form even if that does cost 1 extra instruction.
Tagged as BASIC-1_57-pre1
@
text
@d69 1
a69 1
 |
d73 9
d302 1
a302 1
 [ FPOINT=1
d518 1
a518 1
 |
d521 5
d533 5
d539 1
a539 1
        CMF     FACC,#0
d546 4
d551 1
a551 1
        STFD    FACC,[SP,#12]
d554 1
d990 1
a990 1
 |
d1008 23
@


1.8
log
@Fix objasm 4 warnings. Enable use of CLZ in math code.
Detail:
  s/Array, s/Funct, s/Stmt - Use LDR/STR instead of LDM/STM when only one register is to be transferred
  s/fp - Use Hdr:CPU.Arch to determine whether CLZ can be used in the IFLT routine
Admin:
  Tested on rev A2 BB-xM


Version 1.45. Tagged as 'BASIC-1_45'
@
text
@d591 1
a591 2
 [ DO32BIT = 1
        CMN     PC,#0                  ;return cc
a592 3
 |
        BICS    PC,R14,#C_Flag         ;return cc
 ]
@


1.7
log
@  Unaligned load optimisations
Detail:
  * Uses global LDW macro instead of locally-defined LOAD macro (or longhand
    implementations)
  * Some other cases of unaligned loads for v6+ added in places that didn't
    lend themselves to the LDW macro
  * 5-byte (FP) load operation now macroised - the macro skips the unnecessary
    BIC when assembling only for pre-v6 CPUs, or uses unaligned loads for
    v6+ CPUs (unless NoUnaligned global flag is set)
Admin:
  Tested on a rev B7 beagleboard.

Version 1.43. Tagged as 'BASIC-1_43'
@
text
@d344 1
a344 1
        STMLOIA R4!,{R0}
@


1.6
log
@Lots of code improvements but no changes to the built binary.

This update replaces lots of hard-wired definitions of things such as SWI
names with the ones from the main exports in the build environment. It
should build a binary-identical module to the previous revision.

Author: Rob Sprowson

Version 1.40. Tagged as 'BASIC-1_40'
@
text
@d900 1
d903 1
d920 2
a921 6
SLONXT  BIC     R3,R4,#3
        LDMIA   R3,{IACC,R1}
        MOV     R2,R2,LSL #3
        MOV     IACC,IACC,LSR R2
        RSB     R2,R2,#32
        ORR     IACC,IACC,R1,LSL R2
d926 1
d931 1
a931 8
        BIC     FGRD,R5,#3
        LDMFD   FGRD,{FACC,FACCX}
        AND     FGRD,R5,#3
        MOVS    FGRD,FGRD,LSL #3
        MOVNE   FACC,FACC,LSR FGRD
        RSBNE   FSIGN,FGRD,#32
        ORRNE   FACC,FACC,FACCX,LSL FSIGN
        MOVNE   FACCX,FACCX,LSR FGRD
a932 2
        ANDS    FACCX,FACCX,#255
        TEQEQ   FACC,#0
@


1.5
log
@New version from Kevin: appears to be fixes for top-bit-set addresses.
This is the version included in release 5.00 of the OS.

Version 1.33. Tagged as 'BASIC-1_33'
@
text
@d16 1
d64 1
a64 1
 [       FP=0
d293 1
a293 1
 [       FP=1
d376 1
a376 1
        SWI     WIMPSLOT
d465 2
a466 2
        MOV     R0,#8
        SWI     WORD
d505 1
a505 1
 [       FP=0
d517 1
a517 1
 [       FP=0
d524 1
a524 1
 [       FP=0
d591 1
a591 1
 [       DO32BIT = 1
d595 1
a595 1
        BICS    PC,R14,#CFLAG          ;return cc
d733 1
a733 1
        SWINE   WRITEI+"?"
d931 1
a931 1
 [       FP=0
d1178 1
a1178 1
        SWI     WRITEN
d1229 1
a1229 1
        SWI     WRITEI+31
d1232 1
a1232 1
        SWI     WRITEC
d1234 1
a1234 1
        SWI     WRITEC
d1453 1
a1453 1
        SWI     SOUNDEVENTQBEAT
d1460 1
a1460 1
        SWI     SOUNDCONFIGURE
d1472 1
a1472 1
        SWI     SOUNDVOICE
d1475 1
a1475 1
        SWI     SOUNDEVENTTEMPO
d1482 1
a1482 1
        SWI     SOUNDSTEREO
d1512 1
a1512 1
        SWI     SOUNDEVENTQSCHEDULE
d1518 2
a1519 2
        MOV     R0,#7
        SWI     WORD
d1527 1
a1527 1
        SWI     SOUNDENABLE
d1645 1
a1645 1
        SWINE   OPEN
d1648 1
a1648 1
        SWI     OPEN
d1654 2
a1655 2
        SWINE   FILE+&20000
        SWIEQ   FILE
d1663 1
a1663 1
        SWINE   OPEN
d1722 2
a1723 1
        LNK     s.Stmt2
@


1.4
log
@  Fixed bug spotted on csa.programmer in BASIC CASE statements.
Detail:
  The expression evaluation in the BASIC WHEN statement had an omission
  where it could skip past a syntax error without generating any error.

  For example, "WHEN (R%>>25) AND 1)=1 : do something" would not return
  an error because the expression is complete and evaluated upto the
  "AND 1". Once this is found to not match the condition of the CASE,
  BASIC searches forwards for the next ",", "WHEN", "OTHERWISE" or
  "ENDCASE", skipping over the ")=1" part.

  I've changed this so that, after the expression is evaluated and found
  to not match, BASIC already checks to see if the next char is a ",". If
  not, we check for a ":" or CR before scanning forwards. Any other char
  is a syntax error.
Admin:
  Tested on a set-top box.

Version 1.31. Tagged as 'BASIC-1_31'
@
text
@d860 2
a861 1
        ADDS    AELINE,AELINE,R1
d863 1
a863 1
        BIC     AELINE,AELINE,#TFP     ;array element
@


1.3
log
@  * Performance tweaks.
  * Comments added.
  * Added DIM LOCAL.
Detail:
  * All of the 408 instances of pushes and pops of a single register
    (i.e. "LDMIA SP!,{PC}") have been replaced with an LDR/STR equivalent,
    which provides a small performance boost on StrongARM-like processors.
  * Some obscure bits of the source have had comments added.
  * The new DIM LOCAL statement has been added:

    Syntax: DIM <numeric variable> LOCAL <numeric expression>

    DIM LOCAL allocates space from the BASIC stack rather than from the
    heap. This means that the space allocated is automatically freed on
    exit from the PROC or FN in which it was claimed.

    As with all LOCAL statements, it must appear in a PROC or FN definition
    and cannot appear inside a structure which uses the stack (i.e. NEXT)
    or after a LOCAL ERROR.

    Much like the manner in which "DIM foo% -1" returns the value of FSA
    without allocating space, "DIM foo% LOCAL -1" returns the value of SP
    at the time of the request, without allocating any space from the stack.
    This can be useful in computing the free space between the top of the
    BASIC heap and the bottom of the stack. Of course, the stack is used by
    BASIC while interpreting the program, so the contents of memory below
    foo% should always be treated as undefined.

    One caveat of using DIM LOCAL is that the stack cannot be moved while
    there are DIM LOCALs defined. END= will return an error and any
    Service_Memory calls will be claimed for the duration of the DIM LOCAL.
Admin:
  Builds and tested on RiscPC.
  Requires BASICTrans-2_06.

Version 1.30. Tagged as 'BASIC-1_30'
@
text
@d76 3
@


1.2
log
@  Some bug fixes and a few new features.
Detail:
  * ALIGN will now force any unused bytes to zero when assembling at
    both P% and O%. This is better than leaving possibly uninitialised
    memory behind (makes diffs very difficult).

  * The assembler now correctly recognises the new 'LR' special variable
    when the L is lower-case.

  * The assembler also has the 'SP' (13) special variable defined.

  * TRACE PROC (and the identical TRACE FN) now flushes the VCACHE when
    it is encountered.

  * TRACE ENDPROC has been implemented to allow the output of 'ENDPROC'
    and 'ENDFN' in the trace output whenever a procedure or function is
    exited. This complements the TRACE PROC/FN functionality.

  * QUIT <expression> has been added to allow a return code to be passed
    back to the called when BASIC exits. This is the /only/ sensible way
    for a BASIC program to set Sys$ReturnCode on exit (others get trashed
    when BASIC removes it's environment handlers).
Admin:
  Tested on a StrongARM RiscPC.

  Some of the reformatting from the last checkin has been improved.

  s.ModuleAB and s.ModuleAB64 have been renamed to s.BASIC105 and
  s.BASIC64 respectively. This will help with the new Brodie Make-o-
  Matik(tm) Makefiles.

Version 1.24. Tagged as 'BASIC-1_24'
@
text
@d26 1
a26 1
        STMFD   SP!,{TYPE}
d54 1
a54 1
CASEWH  STMFD   SP!,{R7}               ;rqd if go back to %00
d56 1
a56 1
        LDMFD   SP!,{R7}
d144 4
a147 2
DIMSPA  SUB     LINE,LINE,#1           ;because of Spaces
        BL      CRAELV
d150 55
a204 8
        BCS     ERTYPENUM
        STMFD   SP!,{IACC,TYPE}
        BL      EXPR
        BL      INTEGY
        ADD     R7,IACC,#1
        LDR     IACC,[ARGP,#FSA]
        LDMFD   SP!,{R4,R5}
        STMFD   SP!,{IACC,R7}
d206 6
a211 6
        LDMFD   SP!,{IACC,R7}
        TEQ     R7,#0
        BMI     BADDIMSIGN
        ADD     R7,R7,#3
        BIC     R7,R7,#3
        ADD     R7,IACC,R7
d213 18
a230 14
        CMP     R6,SP
        BCS     BADDIMSIZE
        STR     R7,[ARGP,#FSA]
DIMNXT  MOV     LINE,AELINE
        CMP     R10,#","
        BNE     DONEXT
DIM     BL      SPACES
        MOV     R0,R10
        BL      WORDCQ
        CMPCS   R10,#"A"
        BCC     BADDIM                 ;taken if WORDCQ failed, or if 0-9
;now have first char of item in R10 as rqd
        MOV     TYPE,#TFPLV
        MOV     AELINE,LINE
d233 7
a239 7
        BCS     DIMNO
        CMP     R0,#"("
        BEQ     DIMVAR
        CMP     R0,#"%"
        MOVEQ   TYPE,#4
        CMPNE   R0,#"$"
        BNE     DIMSPA
d247 1
a247 1
        STMFD   SP!,{TYPE}             ;size of actual array elements
d260 1
a260 1
        LDMFD   SP!,{TYPE}             ;get original type from stack
d262 1
a262 1
        STMFD   SP!,{IACC}             ;save l value
d304 1
a304 1
        LDMFD   SP!,{R6}               ;address to alter
d308 2
a309 2
        STMEQFD SP!,{IACC}
        STMEQFD SP!,{R6}
d351 3
d412 1
a412 1
ENDPRA  LDMFD   SP!,{R4}
d437 1
a437 1
        STMFD   SP!,{R10}              ;preserve next character
d442 1
a442 1
        LDMFD   SP!,{R10}
d451 1
a451 1
ENVELP  STMFD   SP!,{R1}
d453 1
a453 1
        LDMFD   SP!,{R1}
d553 1
a553 1
        STMFD   SP!,{R14}
d564 1
a564 1
        LDMCSFD SP!,{PC}
d572 1
a572 1
        LDMFD   SP!,{PC}
d785 30
a814 23
LOCAL   BL      SPACES
        CMP     R10,#TERROR
        BEQ     LOCALERROR
        CMP     R10,#TDATA
        BEQ     LOCALDATA
        LDR     R0,[SP]
        TEQ     R0,#TPROC
        TEQNE   R0,#TFN
        BNE     ERRNLC
        SUB     LINE,LINE,#1
LOCALP  BL      CRAELV
        BEQ     DONXTS
        MOV     LINE,AELINE
        LDMFD   SP!,{R5,R6,R7}
        MOV     R10,IACC
        MOV     AELINE,TYPE
        CMP     TYPE,#256
        BCS     LOCALARRAY
        BL      VARIND
        BL      PUSHTYPE
        STMFD   SP!,{R10,AELINE}
        STMFD   SP!,{R5,R6,R7}
        MOV     R0,#0
d825 1
a825 1
        STMFD   SP!,{R1}
d1081 1
a1081 1
        LDMFD   SP!,{R0}
d1090 1
a1090 1
        LDMFD   SP!,{R0}
d1093 1
a1093 1
        LDMFD   SP!,{R1}
d1221 1
a1221 1
TAB2    STMFD   SP!,{IACC}
d1226 1
a1226 1
        LDMFD   SP!,{IACC}
d1232 2
a1233 2
PROC    MOV     AELINE,LINE
        LDR     R1,[ARGP,#PROCPTR]
d1373 1
a1373 1
POPA2   LDMFD   SP!,{R6}
d1383 9
d1458 1
a1458 1
        STMFD   SP!,{IACC}
d1463 1
a1463 1
        LDMFD   SP!,{R0}
d1473 1
a1473 1
        STMFD   SP!,{IACC}
d1476 1
a1476 1
        LDMFD   SP!,{R0}
d1486 1
a1486 1
        STMFD   SP!,{IACC}
d1489 1
a1489 1
        LDMFD   SP!,{R1}
d1492 1
a1492 1
        STMFD   SP!,{IACC}
d1494 1
a1494 1
        STMFD   SP!,{IACC}
d1546 1
a1546 1
        STMFD   SP!,{TYPE}
d1681 1
a1681 1
        STMFD   SP!,{AELINE}           ;pointer to expression
@


1.1
log
@  Improved BASIC build structure. No code change.
Detail:
  Makefile strips dependencies during the clean phase.

  Sources moved into an 's' directory.

  All sources reformatted into a more readable layout.
Admin:
  Builds binary-identical versions of BASIC and BASIC64 modules to
  version 1.22

Version 1.23. Tagged as 'BASIC-1_23'
@
text
@a277 1

a281 1

a297 1

a308 1

a324 1

a336 1

a351 1

d359 1
a364 5

        ;
        ;       CHECK TRACE FLAGS
        ;

a365 5

        ;
        ;       ENDPROC
        ;

a519 1

a716 1

a723 1

a759 1

a782 1

a800 1

a1016 1

a1025 1

a1220 1

a1243 1

a1246 1

a1318 1

a1320 1

a1339 1

a1344 1

d1347 1
a1350 1

a1352 1

a1359 1

a1437 1

a1444 1

a1448 1

d1517 3
d1531 18
a1548 3
;TRCNUM word has: b31: trace proc/fn
;                 b30: trace step
;                 b15-0: trace max line number
a1580 1

@


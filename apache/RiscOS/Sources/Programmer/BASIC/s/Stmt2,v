head	1.18;
access;
symbols
	BASIC-1_75:1.18
	BASIC-1_74:1.18
	BASIC-1_73:1.18
	BASIC-1_72:1.18
	BASIC-1_71:1.18
	BASIC-1_70:1.18
	BASIC-1_69:1.17
	BASIC-1_68:1.17
	BASIC-1_67:1.17
	BASIC-1_66:1.16
	BASIC-1_65:1.16
	BASIC-1_64:1.16
	BASIC-1_63:1.15
	BASIC-1_62:1.15
	BASIC-1_61:1.15
	BASIC-1_60:1.15
	BASIC-1_59:1.15
	BASIC-1_58:1.15
	BASIC-1_57-pre4:1.14
	BASIC-1_57:1.15
	BASIC-1_57-pre3:1.14
	BASIC-1_57-pre2:1.14
	BASIC-1_57-pre1:1.13
	BASIC-1_56:1.12
	BASIC-1_55:1.12
	BASIC-1_54:1.12
	BASIC-1_53:1.10
	BASIC-1_52:1.10
	BASIC-1_51:1.9
	BASIC-1_50:1.9
	BASIC-1_49:1.9
	BASIC-1_48:1.9
	BASIC-1_47:1.9
	BASIC-1_46:1.9
	BASIC-1_45:1.9
	BASIC-1_44:1.9
	BASIC-1_43:1.8
	BASIC-1_42:1.7
	BASIC-1_41:1.7
	BASIC-1_40:1.7
	BASIC-1_39:1.6
	BASIC-1_37:1.6
	RO_5_07:1.6
	BASIC-1_36:1.6
	BASIC-1_35:1.5
	BASIC-1_34:1.5
	BASIC-1_33:1.5
	BASIC-1_32:1.5
	BASIC-1_31:1.5
	BASIC-1_30:1.5
	BASIC-1_29:1.4
	BASIC-1_28:1.4
	BASIC-1_27:1.4
	BASIC-1_26:1.3
	BASIC-1_25:1.2
	BASIC-1_24:1.2
	BASIC-1_23:1.1;
locks; strict;
comment	@# @;


1.18
date	2017.07.22.21.51.02;	author jlee;	state Exp;
branches;
next	1.17;
commitid	CDYQ0yZDiBs2Xg0A;

1.17
date	2017.06.03.22.30.34;	author jlee;	state Exp;
branches;
next	1.16;
commitid	3Iuze3DCMuQaKYTz;

1.16
date	2017.03.04.18.00.30;	author jlee;	state Exp;
branches;
next	1.15;
commitid	hnxezA9QYnbYagIz;

1.15
date	2013.12.01.18.09.40;	author rsprowson;	state Exp;
branches;
next	1.14;
commitid	g83hl4RCFV1Crsfx;

1.14
date	2013.12.01.17.39.52;	author rsprowson;	state Exp;
branches;
next	1.13;
commitid	DTgfZ9WqDVpZgsfx;

1.13
date	2013.12.01.17.23.40;	author rsprowson;	state Exp;
branches;
next	1.12;
commitid	iG291GP27DoPasfx;

1.12
date	2013.04.26.23.46.54;	author bavison;	state Exp;
branches;
next	1.11;
commitid	72Ql4NVxJYJPllNw;

1.11
date	2013.04.26.23.31.34;	author bavison;	state Exp;
branches;
next	1.10;
commitid	j9s7yCUXNRcyglNw;

1.10
date	2012.07.09.00.38.20;	author jlee;	state Exp;
branches;
next	1.9;
commitid	YRf5ENCfqz9o1Pbw;

1.9
date	2009.06.16.00.05.23;	author bavison;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.17.02.31.55;	author bavison;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.24.00.27.16;	author srevill;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.21.17.21.09;	author mhobbs;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.23.15.48.34;	author srevill;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.09.31.11;	author sbrodie;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.20.09.47.36;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.16.19.11.52;	author srevill;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.14.20.00.32;	author srevill;	state Exp;
branches;
next	;


desc
@@


1.18
log
@MODE improvements
Detail:
  1. MODE <string> now uses OS_ScreenMode 15 rather than *WimpMode, to avoid programs which use it (likely unintentionally) altering the Wimp mode or having to worry about preserving it
  2. If OS_ScreenMode 15 isn't supported, use our own mode string parsing code that provides a similar level of functionality to the host system's *WimpMode
  3. For all MODE variants which use OS_ScreenMode, detect any "SWI not known" error and replace it with "Bad MODE" (under the assumption the user is running pre-OS 3.5)
  4. Add a new variant, MODE <x>,<y>,<modeflags>,<ncolour>,<log2bpp>[,<hz>] to allow specification of the three parameters necessary for selecting the new screen modes introduced by RISC OS Select/5
  Files: Resources/UK/CmdHelp, Resources/UK/Messages, s/ErrorMsgs, s/ModHead, s/Stmt2
Admin:
  Tested on RISC OS 3.1, 3.7, and latest 5.23


Version 1.70. Tagged as 'BASIC-1_70'
@
text
@; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;> Stmt2 poly, graphics, file io, mos emulator

;statements (of the poly variety)
LERROR  BL      SPACES
        CMP     R10,#TEXT
        BEQ     LERROREXT
        SUB     LINE,LINE,#1
        BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      EXPR
        TEQ     TYPE,#0
        BNE     ERTYPESTR
        BL      AEDONE
        LDR     R7,[SP],#4
        MOV     R0,#0
        STRB    R0,[CLEN],#1           ;0 at end of string
        BL      SPUSH
        STR     R7,[SP]
        MOV     R14,SP
        B       MSGERR
LERROREXT
        BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      EXPR
        TEQ     TYPE,#0
        BNE     ERTYPESTR
        BL      AEDONE
        LDR     R7,[SP],#4
        MOV     R0,#0
        STRB    R0,[CLEN],#1           ;0 at end of string
        BL      SPUSH
        STR     R7,[SP]
        ADD     R12,ARGP,#OLDERR
        BL      PUTBACKHAND
        MOV     R2,#42
        STRB    R2,[ARGP,#CALLEDNAME]
        MOV     R0,SP
        SWI     OS_GenerateError
        SWI     OS_Exit
LPAGE   BL      EQAEEX
        ADD     IACC,IACC,#3
        BIC     IACC,IACC,#3
      [ FPOINT=2
        LDR     R1,[ARGP,#FREEPTR]
      |
        ADD     R1,ARGP,#FREE
      ]
        CMP     IACC,R1
        BCC     LPAGEOUT
;;;;; CMP IACC,#&3400000
        CMP     IACC,#&1800000         ;warning changed
        BCS     LPAGEROM
        LDR     R1,[ARGP,#MEMLIMIT]
        CMP     IACC,R1
        STRCC   IACC,[ARGP,#PAGE]
        BCC     NXT
LPAGEOUT
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "Out of range value assigned to PAGE",10,13,0
 |
        MOV     R0,#4
        BL      MSGPRNXXX
 ]
        B       NXT
LPAGEROM
        STR     IACC,[ARGP,#PAGE]
      [ FPOINT=2
        LDR     IACC,[ARGP,#FREEPTR]
      |
        ADD     IACC,ARGP,#FREE
      ]
        B       LLOMEMROM
LTIME   LDRB    R10,[LINE]
        CMP     R10,#"$"
        BEQ     LTIMED
        BL      EQAEEX
        ADD     R1,ARGP,#STRACC
        STR     IACC,[R1]
        MOV     R0,#0
        STR     R0,[R1,#4]
        MOV     R0,#OsWord_WriteSystemClock
        SWI     OS_Word                ;set time
 [ {FALSE}
        SWI     OS_Word                ;time now
        LDR     FACC,[R1]
        SUB     FACC,FACC,R4           ;what the offset has to be
        STR     FACC,[ARGP,#TIMEOF]
 ]
        B       NXT
LTIMED  ADD     LINE,LINE,#1
        BL      SPACES
        CMP     R10,#"="
        BNE     MISSEQ
        BL      AEEXPR
        TEQ     TYPE,#0
        BNE     ERTYPESTR
        BL      AEDONE
        STRB    TYPE,[CLEN]            ; terminate the string
        ADD     R1,ARGP,#STRACC
        SUB     R0,CLEN,R1
        ;       no! can't just use length - must be reason code. let's deduce what reason code
        ;       by looking at length: length<=8 => time (reason 8),
        ;       else length<=maximum date length => date (reason 15),
        ;       else => date+time (reason 24).
        CMP     R0,#8
        MOVLS   R0,#8
        BLS     LTIMED1
        STMFD   SP!,{R0-R2}
        LDR     R2,[ARGP,#FSA]
        MOV     R1,R2                  ; dummy
        MOV     R0,#-1
        SWI     Territory_ReadCalendarInformation
        ;       date format is "%w3,%dy %m3 %ce%yr": max length is 7+max length of %w3,%dy and %m3
        MOV     R7,#7
        LDR     R0,[R2,#24]
        ADD     R7,R7,R0
        LDR     R0,[R2,#28]
        ADD     R7,R7,R0
        LDR     R0,[R2,#40]
        ADD     R7,R7,R0
        LDMFD   SP!,{R0-R2}
        CMP     R0,R7
        MOVLS   R0,#15
        MOVHI   R0,#24
LTIMED1
        STRB    R0,[R1,#-1]!
        MOV     R0,#OsWord_WriteRealTimeClock
        SWI     OS_Word
        B       NXT
LLOMEM  BL      EQAEEX
LLOMEMROM
        ADD     IACC,IACC,#3
        BIC     IACC,IACC,#3
      [ FPOINT=2
        LDR     R1,[ARGP,#FREEPTR]
      |
        ADD     R1,ARGP,#FREE
      ]
        CMP     IACC,R1
        BCC     LLOMEMOUT
        LDR     R1,[ARGP,#MEMLIMIT]
        CMP     IACC,R1
        BCS     LLOMEMOUT
        STR     IACC,[ARGP,#LOMEM]
        STR     IACC,[ARGP,#FSA]
        MOV     R0,#0
        STR     R0,[ARGP,#FREELIST]
        BL      SETVAL
        B       NXT
LLOMEMOUT
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "Out of range value assigned to LOMEM",10,13,0
 |
        MOV     R0,#5
        BL      MSGPRNXXX
 ]
        B       NXT
LHIMEM  BL      EQAEEX
        BIC     IACC,IACC,#3
      [ FPOINT=2
        LDR     R1,[ARGP,#FREEPTR]
      |
        ADD     R1,ARGP,#FREE
      ]
        CMP     IACC,R1
        BCC     LHIMEMOUT
        LDR     R1,[ARGP,#MEMLIMIT]
        CMP     IACC,R1
        BHI     LHIMEMOUT
        STR     IACC,[ARGP,#HIMEM]
        BL      POPLOCALAR
        LDR     SP,[ARGP,#HIMEM]
        MOV     R0,#0
        STMFD   SP!,{R0-R9}            ;stack stop
        STR     SP,[ARGP,#ERRSTK]
        B       NXT
LHIMEMOUT
 [ OWNERRORS=1
        SWI     OS_WriteS
        =       "Out of range value assigned to HIMEM",10,13,0
 |
        MOV     R0,#6
        BL      MSGPRNXXX
 ]
        B       NXT
LLEFTD  BL      AELV
        BEQ     FACERR
        CMP     TYPE,#128
        BNE     ERTYPESTRING
        STR     IACC,[SP,#-4]!
        MOV     IACC,#1
        STR     IACC,[SP,#-4]!
        BL      AESPAC
        MOV     IACC,#255
        CMP     R10,#","
        BNE     LMIDD1
        BL      EXPR
        BL      INTEGY
        B       LMIDD1
LMIDD   BL      AELV
        BEQ     FACERR
        CMP     TYPE,#128
        BNE     ERTYPESTRING
        BL      AESPAC
        CMP     R10,#","
        BNE     ERCOMM
        STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        STR     IACC,[SP,#-4]!
        MOV     R0,#255
        CMP     R10,#","
        BNE     LMIDD1
        BL      EXPR
        BL      INTEGY
LMIDD1  STR     IACC,[SP,#-4]!
        CMP     R10,#")"
        BNE     ERBRA
        BL      AESPAC
        CMP     R10,#"="
        BNE     MISSEQ
        BL      EXPR
        TEQ     TYPE,#0
        BNE     ERTYPESTR
        BL      AEDONE
        LDMFD   SP!,{R4,R5,R6}
        ADD     R1,ARGP,#STRACC
        CMP     CLEN,R1
        BEQ     NXT                    ;no right string
;R4 is max length, R5 is start position, R6 is pointer to string block
LRIGHTD2
        LDW     IACC,R6,R1,R7
        SUB     R1,R5,#1
        CMP     R1,#255
        MOVCS   R5,#1
        LDRB    R1,[R6,#4]             ;get length
        CMP     R5,R1
        BHI     NXT
        ADD     R1,IACC,R1
        ADD     R7,IACC,R5
        SUB     R7,R7,#1               ;start address
        ADD     R3,ARGP,#STRACC
LMIDD2  LDRB    R5,[R3],#1
        STRB    R5,[R7],#1
        TEQ     R3,CLEN
        BEQ     NXT                    ;exhausted right string
        CMP     R7,R1
        BCS     NXT                    ;exhausted left string
        SUBS    R4,R4,#1
        BHI     LMIDD2
        B       NXT
LRIGHTD BL      AELV
        BEQ     FACERR
        CMP     TYPE,#128
        BNE     ERTYPESTRING
        STR     IACC,[SP,#-4]!
        BL      AESPAC
        MOV     IACC,#255
        CMP     R10,#","
        BNE     LRIGHTD1
        BL      EXPR
        BL      INTEGY
LRIGHTD1
        STR     IACC,[SP,#-4]!
        CMP     R10,#")"
        BNE     ERBRA
        BL      AESPAC
        CMP     R10,#"="
        BNE     MISSEQ
        BL      EXPR
        TEQ     TYPE,#0
        BNE     ERTYPESTR
        BL      AEDONE
        LDMFD   SP!,{R4,R6}
        ADD     R1,ARGP,#STRACC
        SUBS    R0,CLEN,R1             ;length of rightside
        BEQ     NXT                    ;no right string
        CMP     R4,R0
        MOVCS   R4,R0
        LDRB    R5,[R6,#4]
        SUBS    R5,R5,R4
        ADD     R5,R5,#1
        BCS     LRIGHTD2
        B       NXT
ASSIGNAT
        LDRB    R10,[LINE],#1
        CMP     R10,#"%"
        BNE     ERSYNT
        LDRB    R10,[LINE],#1
        CMP     R10,#"("
        BEQ     ERSYNT
        CMP     R10,#" "
        BLEQ    SPACES
        CMP     R10,#"-"
        TEQCC   R10,#"+"
        MOVEQ   R5,#4
        ADDEQ   R4,ARGP,#INTVAR
        STMEQFD SP!,{R4,R5}
        MOVEQ   AELINE,LINE
        BEQ     ATGOTLT2
        CMP     R10,#"="
        BNE     MISSEQ
        BL      AEEXPR
        BL      AEDONE
        TEQ     TYPE,#0
        BEQ     ASSIGNATSTRING
        BLMI    INTEGB
        STR     IACC,[ARGP,#INTVAR]
        B       NXT
ASSIGNATSTRING
        STRB    TYPE,[CLEN],#1         ;write trailing null
        ADD     R4,ARGP,#STRACC
        LDRB    R5,[R4],#1
        CMP     R5,#"+"
        MOVEQ   R0,#1
        MOVNE   R0,#0
        STRB    R0,[ARGP,#INTVAR+3]    ;set/clear STR$ flag
        LDREQB  R5,[R4],#1
        BIC     R6,R5,#&20             ;clear case bit
        LDRB    R0,[ARGP,#INTVAR+2]    ;format and "," bit
        ORR     R0,R0,#3               ;set to max+1
        CMP     R6,#"G"
        SUBEQ   R0,R0,#1
        CMPNE   R6,#"E"
        SUBEQ   R0,R0,#1
        CMPNE   R6,#"F"
        SUBEQ   R0,R0,#1
        STREQB  R0,[ARGP,#INTVAR+2]    ;format ("," bit unchanged)
        LDREQB  R5,[R4],#1
        CMP     R5,#"."
        CMPNE   R5,#","
        BEQ     ASSIGNATDOT
        BL      READNUM
        BCC     NXT                    ;read garbage!
        STRB    R0,[ARGP,#INTVAR]      ;field width
        CMP     R5,#"."
        CMPNE   R5,#","
        BNE     NXT
ASSIGNATDOT
        LDRB    R0,[ARGP,#INTVAR+2]
        BIC     R0,R0,#&80             ;clear "," bit
        CMP     R5,#","
        ORREQ   R0,R0,#&80             ;set "," bit
        STRB    R0,[ARGP,#INTVAR+2]
        LDRB    R5,[R4],#1
        BL      READNUM
        STRCSB  R0,[ARGP,#INTVAR+1]
        B       NXT
;read unsigned number, carry set if OK
READNUM CMP     R5,#"0"
        MOVCC   PC,R14
        CMP     R5,#"9"+1
        BHI     READNUMCCLEAR
        AND     R0,R5,#&F
READNUMDIG
        LDRB    R5,[R4],#1
        SUBS    R6,R5,#"0"
        BCC     READNUMCSET
        CMP     R5,#"9"+1
        ADDCC   R0,R0,R0,LSL #2
        ADDCC   R0,R6,R0,LSL #1        ;smode*2+r0
        BCC     READNUMDIG
        MOV     PC,R14                 ;carry set
READNUMCCLEAR
        CLC
        MOV     PC,R14
READNUMCSET
        SEC
        MOV     PC,R14
; graphics
CLG     MOV     R0,#16
        B       CLSA
CLS     MOV     R0,#12
CLSA    BL      DONES
        SWI     OS_WriteC
        BL      CTALLY
        B       NXT
CIRCLE  MOV     R0,#&95
        MOV     R1,#&9D
        BL      CHECKFILL
        STR     IACC,[SP,#-4]!
        BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        LDMFD   SP!,{R3,R4,TYPE}
        ADD     R5,R4,IACC
        MOV     R0,#4
        MOV     R1,R4
        MOV     R2,R3
        BL      DOPLOT                 ;move x,y
        MOV     R0,TYPE
        MOV     R1,R5
        BL      DOPLOT                 ;plot q,x+w,y
        B       NXT
CHECKFILL
        STR     R14,[SP,#-4]!
        BL      SPACES
        CMP     R10,#TESCSTMT
        BNE     CHECKFILL1
        LDRB    R10,[LINE],#1
        TEQ     R10,#TFILL
        MOVEQ   R0,R1
        LDREQ   PC,[SP],#4
        SUB     LINE,LINE,#1
CHECKFILL1
        SUB     LINE,LINE,#1
        LDR     PC,[SP],#4
COLOUR  BL      SPACES
        TEQ     R10,#TOF
        TEQNE   R10,#TON
        BEQ     COLOUROFON
        SUB     AELINE,LINE,#1
        BL      EXPR
        BL      INTEGY
        CMP     R10,#TESCSTMT
        BEQ     COLOURTINT
        TEQ     R10,#","
        BEQ     PALETTE
        BL      AEDONE
        SWI     OS_WriteI+17
        SWI     OS_WriteC
        B       NXT
COLOURTINT
        LDRB    R10,[AELINE],#1
        CMP     R10,#TTINT
        BNE     ERSYNT
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        MOV     R1,IACC
        LDR     IACC,[SP],#4
        SWI     OS_WriteI+17
        SWI     OS_WriteC
        MOV     IACC,IACC,LSR #7
        AND     IACC,IACC,#1
        B       TINTEND
PALETTE STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        TEQ     R10,#","
        BEQ     PALETTE4
        BL      AEDONE
        MOV     R1,IACC
        LDR     IACC,[SP],#4
        SWI     OS_WriteI+19
        SWI     OS_WriteC
        MOV     IACC,R1
        BL      WRITEG
        MOV     IACC,R1,LSR #16
        BL      WRITEG
        B       NXT
PALETTE4
        STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        TEQ     R10,#","
        BNE     COLOUR3
        STR     IACC,[SP,#-4]!
 [ {FALSE}
        BL      EXPRDN
 |
        BL      EXPR
        BL      INTEGY
        TEQ     R10,#","
        BEQ     PALETTE5
        BL      AEDONE
 ]
        MOV     R6,#16
PROGPAL MOV     R5,IACC
        SWI     OS_WriteI+19
        LDMFD   SP!,{R1,R2,R3}
        MOV     IACC,R3
        SWI     OS_WriteC
        MOV     IACC,R6
        SWI     OS_WriteC
        MOV     IACC,R2
        SWI     OS_WriteC
        MOV     IACC,R1
        SWI     OS_WriteC
        MOV     IACC,R5
        SWI     OS_WriteC
        B       NXT
PALETTE5
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        LDMFD   SP!,{R1-R4}
        AND     R2,R2,#&FF
        MOV     R2,R2,LSL #16           ; green
        AND     IACC,IACC,#&FF
        ORR     R2,R2,IACC              ; +supremacy
        AND     R1,R1,#&FF
        ORR     R2,R2,R1,LSL #24        ; +blue
        AND     R3,R3,#&FF
        ORR     R2,R2,R3,LSL #8         ; +red
        AND     R0,R4,#&FF              ; colour number
        MOV     R1,#16
        MOV     R4,#paletteV_Set
        MOV     R9,#PaletteV
        SWI     OS_CallAVector
        B       NXT
COLOUR3 LDMFD   SP!,{R1,R2}
        MOV     R14,#0                  ; terminator
        STR     R14,[SP,#-4]!
        SUB     SP,SP,#12               ; 3 dummies
        MOV     R4,#TOF
        STMFD   SP!,{R0,R1,R2,R4}       ; b,g,r,OF
        B       COLOUROFON3LPN
COLOUROFON
        MOV     R14,#0
        STMFD   SP!,{R11,R14}           ; dummy,terminator
        MOV     AELINE,LINE
COLOUROFONLP
        STR     R10,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        LDR     R5,[SP,#8]
        LDR     R4,[SP,#0]
        TEQ     R10,#","
        TEQEQ   R5,#0
        BEQ     COLOUROFON3
        STR     IACC,[SP,#-4]!
        TEQ     R4,#TOF
        TEQEQ   R10,#TON
        BEQ     COLOUROFONLP
        BL      AEDONE
DOCOLOUROFON
        LDMFD   SP!,{R1,R4}
        TEQ     R4,#0
        BEQ     NXT
        TEQ     R4,#TON
        MOVEQ   R0,#&50
        MOVNE   R0,#&40
        SWI     OS_SetColour
        B       DOCOLOUROFON
COLOUROFON3
        SUB     SP,SP,#4                ; another dummy
        STR     R4,[SP,#-4]!
COLOUROFON3LP
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        STR     IACC,[SP,#-4]!
        LDR     R4,[SP,#12]
COLOUROFON3LPN
        TEQ     R10,#TON
        TEQEQ   R4,#TOF
        BNE     DOCOLOUROFON3DN
        STR     R10,[SP,#-4]!
        BL      INTEXC
        B       COLOUROFON3LP
DOCOLOUROFON3DN
        BL      AEDONE
DOCOLOUROFON3
        LDMFD   SP!,{R0,R1,R2,R4}
        TEQ     R4,#0
        BEQ     NXT
        AND     R0,R0,#255              ;blue
        AND     R1,R1,#255              ;green
        AND     R2,R2,#255              ;red
        ORR     R1,R2,R1,LSL #8
        ORR     R0,R1,R0,LSL #16
        MOV     R0,R0,LSL #8
        TEQ     R4,#TON
        MOVEQ   R3,#&80
        MOVNE   R3,#0
        SWI     ColourTrans_SetTextColour
        B       DOCOLOUROFON3
CURSON  SWI     OS_WriteS
        =       23,1,1,0
        MOV     R1,#7
        BL      ZEROX
        B       NXT
CURSOFF BL      DONES
        SWI     OS_WriteS
        =       23,1,0,0
        MOV     R1,#8
        BL      ZEROX
        B       NXT
DRAW    MOV     IACC,#5
        B       PLOTER
ELLIPSE MOV     R0,#&C5
        MOV     R1,#&CD
        BL      CHECKFILL
        STR     IACC,[SP,#-4]!
        BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        CMP     R10,#","
        BEQ     ELLIPSEANGLE
        BL      AEDONE
        LDMFD   SP!,{R5,R6,R7,TYPE}
        MOV     R3,R0
        MOV     R4,#0
        B       ELLIPSEDO
ELLIPSEANGLE
        BL      IFLT
        BL      FPUSH                  ;min
;min, maj%, y org%, x org%, FILL%
        BL      EXPR
        BL      FLOATY
        BL      AEDONE
        BL      FPUSH                  ;ang
; Convert to OS_Plot commands using the following algorithm:
; cos = COS(angle)
; sin = SIN(angle)
; slicet = min*maj
; temp = (min*cos)^2
; temp2 = (maj*sin)^2
; maxy = SQR(temp+temp2)
; slicew = slicet/maxy
; sheart = cos*sin*((maj^2)-(min^2))
; shearx = sheart/maxy
; MOVE x,y
; MOVE x+slicew,y
; PLOT XXX,x+shearx,y+maxy
 [ FPOINT=0
;ang, min, maj%, y org%, x org%, FILL%
        STR     R10,[SP,#-4]!
        BL      SINOP
        LDR     R10,[SP],#4
        BL      FPUSH
;sinang, ang, min, maj%, y org%, x org%, FILL%
        ADD     TYPE,SP,#8
        FLDA    TYPE
        STR     R10,[SP,#-4]!
        BL      COSOP
        LDR     R10,[SP],#4
        ADD     TYPE,SP,#8
        FSTA    TYPE
;sinang, cosang, min, maj%, y org%, x org%, FILL%
        LDR     FACC,[SP,#24]          ;maj%
        BL      IFLT
        BL      FPUSH                  ;maj
;maj, sin, cos, min, maj%, y org%, x org%, FILL%
        ADD     TYPE,SP,#24            ;min
        BL      FMUL
        BL      FPUSH
;slicet, maj, sin, cos, min, maj%, y org%, x org%, FILL%
        ADD     TYPE,SP,#32            ;min
        FLDA    TYPE
        ADD     TYPE,SP,#24            ;cos
        BL      FMUL
        BL      FSQR                   ;(min*cos)^2
        BL      FPUSH
;temp, slicet, maj, sin, cos, min, maj%, y org%, x org%, FILL%
        ADD     TYPE,SP,#16            ;maj
        FLDA    TYPE
        ADD     TYPE,SP,#24            ;sin
        BL      FMUL
        BL      FSQR                   ;(maj*sin)^2
        MOV     TYPE,SP                ;(min*cos)^2
        BL      FADD
        BL      FSQRT
        FSTA    TYPE                   ;maxy
;maxy, slicet, maj, sin, cos, min, maj%, y org%, x org%, FILL%
        ADD     TYPE,SP,#8             ;slicet
        BL      FXDIV
        BL      SFIX
        STR     IACC,[SP,#48]          ;slicew%
;maxy, slicet, maj, sin, cos, min, slicew%, y org%, x org%, FILL%
        ADD     TYPE,SP,#16            ;maj
        FLDA    TYPE
        BL      FSQR
        FSTA    TYPE
        ADD     TYPE,SP,#40            ;min
        FLDA    TYPE
        BL      FSQR
        ADD     TYPE,SP,#16            ;maj^2
        BL      FXSUB
        ADD     TYPE,SP,#24            ;sin
        BL      FMUL
        ADD     TYPE,SP,#32            ;cos
        BL      FMUL
        ADD     TYPE,SP,#8
        FSTA    TYPE
;maxy, sheart, maj^2, sin, cos, min, slicew%, y org%, x org%, FILL%
        FLDA    SP                     ;maxy
        ADD     TYPE,SP,#8             ;sheart
        BL      FXDIV
        BL      SFIX
        STR     FACC,[SP,#44]          ;shearx%
        BL      FPULL
;sheart, maj^2, sin, cos, junk%, shearx%, slicew%, y org%, x org%, FILL%
        BL      SFIX
 ELIF FPOINT=1
;ang, min, maj%, y org%, x org%, FILL%
        SIND    F1,FACC
        STFD    F1,[SP,#-8]!
;sinang, ang, min, maj%, y org%, x org%, FILL%
        COSD    F1,FACC
        STFD    F1,[SP,#8]
;sinang, cosang, min, maj%, y org%, x org%, FILL%
        LDR     IACC,[SP,#24]          ;maj%
        BL      IFLT
        FPUSH                          ;maj
;maj, sin, cos, min, maj%, y org%, x org%, FILL%
        LDFD    F1,[SP,#24]            ;min
        MUFD    FACC,F1,FACC
        FPUSH
;slicet, maj, sin, cos, min, maj%, y org%, x org%, FILL%
        LDFD    F2,[SP,#24]            ;cos
        MUFD    F2,F2,F1               ;min*cos
        MUFD    F2,F2,F2               ;(min*cos)^2
        STFD    F2,[SP,#-8]!
;temp, slicet, maj, sin, cos, min, maj%, y org%, x org%, FILL%
        LDFD    F1,[SP,#16]            ;maj
        LDFD    FACC,[SP,#24]          ;sin
        MUFD    FACC,F1,FACC           ;maj*sin
        MUFD    FACC,FACC,FACC         ;(maj*sin)^2
        ADFD    FACC,FACC,F2           ;(min*cos)^2+(maj*sin)^2
        SQTD    FACC,FACC
        STFD    FACC,[SP]              ;maxy
;maxy, slicet, maj, sin, cos, min, maj%, y org%, x org%, FILL%
        LDFD    F2,[SP,#8]             ;slicet
        DVFD    F2,F2,FACC             ;slicet/maxy
        FIXZ    IACC,F2
        STR     IACC,[SP,#48]          ;slicew%
;maxy, slicet, maj, sin, cos, min, slicew%, y org%, x org%, FILL%
        MUFD    F1,F1,F1               ;maj^2
        LDFD    F2,[SP,#40]            ;min
        MUFD    F2,F2,F2               ;min^2
        SUFD    F2,F1,F2               ;maj^2-min^2
        LDFD    F1,[SP,#24]            ;sin
        MUFD    F2,F1,F2
        LDFD    F1,[SP,#32]            ;cos
        MUFD    F2,F1,F2
        STFD    F2,[SP,#8]
;maxy, sheart, maj, sin, cos, min, slicew%, y org%, x org%, FILL%
        DVFD    FACC,F2,FACC           ;sheart/maxy
        BL      SFIX
        STR     IACC,[SP,#44]          ;shearx%
        BL      FPULL
;sheart, maj, sin, cos, junk%, shearx%, slicew%, y org%, x org%, FILL%
        BL      SFIX
 ELIF FPOINT=2
;ang, min, maj%, y org%, x org%, FILL%
        FACCtoFPA
        ! 0, "TODO native SIND, COSD"
        COSD    F1,F0
        SUB     SP,SP,#4
        STFD    F1,[SP]
        LDR     IACC,[SP],#4
        STR     IACC,[SP,#4]
;cosang, min, maj%, y org%, x org%, FILL%
        SIND    F1,F0
        SUB     SP,SP,#4
        STFD    F1,[SP,#-8]!
        LDR     IACC,[SP],#4
        STR     IACC,[SP,#4]
;sinang, cosang, min, maj%, y org%, x org%, FILL%
        LDR     IACC,[SP,#24]          ;maj%
        BL      IFLT
        FPUSH                          ;maj
;maj, sin, cos, min, maj%, y org%, x org%, FILL%
        FLDD    D1,[SP,#24]            ;min
        FMULD   FACC,D1,FACC
        FPUSH
;slicet, maj, sin, cos, min, maj%, y org%, x org%, FILL%
        FLDD    D2,[SP,#24]            ;cos
        FMULD   D2,D2,D1               ;min*cos
        FMULD   D2,D2,D2               ;(min*cos)^2
        FSTD    D2,[SP,#-8]!
;temp, slicet, maj, sin, cos, min, maj%, y org%, x org%, FILL%
        FLDD    D1,[SP,#16]            ;maj
        FLDD    FACC,[SP,#24]          ;sin
        FMULD   FACC,D1,FACC           ;maj*sin
        FMULD   FACC,FACC,FACC         ;(maj*sin)^2
        FADDD   FACC,FACC,D2           ;(min*cos)^2+(maj*sin)^2
        FSQRTD  FACC,FACC
        FSTD    FACC,[SP]              ;maxy
;maxy, slicet, maj, sin, cos, min, maj%, y org%, x org%, FILL%
        FLDD    D2,[SP,#8]             ;slicet
        FDIVD   D2,D2,FACC             ;slicet/maxy
        FTOSIZD S4,D2
        FSTS    S4,[SP,#48]            ;slicew%
;maxy, slicet, maj, sin, cos, min, slicew%, y org%, x org%, FILL%
        FMULD   D1,D1,D1               ;maj^2
        FLDD    D2,[SP,#40]            ;min
        FMULD   D2,D2,D2               ;min^2
        FSUBD   D2,D1,D2               ;maj^2-min^2
        FLDD    D1,[SP,#24]            ;sin
        FMULD   D2,D1,D2
        FLDD    D1,[SP,#32]            ;cos
        FMULD   D2,D1,D2
        FSTD    D2,[SP,#8]
;maxy, sheart, maj, sin, cos, min, slicew%, y org%, x org%, FILL%
        FDIVD   FACC,D2,FACC           ;sheart/maxy
        BL      SFIX
        STR     IACC,[SP,#44]          ;shearx%
        BL      FPULL
;sheart, maj, sin, cos, junk%, shearx%, slicew%, y org%, x org%, FILL%
        BL      SFIX
        FPSCRCheck R14
 |
        ! 1, "Unknown FPOINT setting"
 ]
        STR     IACC,[SP,#32]!
;maxy%, shearx%, slicew%, y org%, x org%, FILL%
        LDMFD   SP!,{R3,R4,R5,R6,R7,TYPE}
ELLIPSEDO
        MOV     R0,#4
        MOV     R1,R7
        MOV     R2,R6
        BL      DOPLOT                 ;move x,y
        MOV     R0,#4
        ADD     R1,R5,R7
        BL      DOPLOT                 ;move x+slicew,y
        MOV     R0,TYPE
        ADD     R1,R4,R7
        ADD     R2,R3,R6
        BL      DOPLOT                 ;plot type,x+shearx,y+maxy
        B       NXT
FILL    MOV     IACC,#&85
        B       PLOTER
GCOL    BL      SPACES
        TEQ     R10,#TOF
        TEQNE   R10,#TON
        BEQ     GCOLOFON
        SUB     AELINE,LINE,#1
        BL      EXPR
        BL      INTEGY
        CMP     R10,#","
        BEQ     GCOL2
        MOV     R1,IACC
        MOV     R0,#0                  ;pretend we read two
        CMP     R10,#TESCSTMT
        BNE     DOGCOL
GCOLTINT
        LDRB    R10,[AELINE],#1
        CMP     R10,#TTINT
        BNE     ERSYNT
        STMFD   SP!,{R0,R1}
        BL      EXPRDN
        MOV     R1,IACC
        LDMFD   SP!,{R0,R2}
        SWI     OS_WriteI+18
        SWI     OS_WriteC
        MOV     R0,R2
        SWI     OS_WriteC
        TST     R0,#128
        MOVEQ   R0,#2
        MOVNE   R0,#3
        B       TINTEND
GCOL2   STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        CMP     R10,#","
        BEQ     GCOL3
        MOV     R1,IACC
        LDR     IACC,[SP],#4
        CMP     R10,#TESCSTMT
        BEQ     GCOLTINT
DOGCOL  BL      AEDONE
        SWI     OS_WriteI+18
        SWI     OS_WriteC
        MOV     IACC,R1
        SWI     OS_WriteC
        B       NXT
GCOL3   LDR     R1,[SP],#4
        MOV     R14,#0
        STR     R14,[SP,#-4]!
        SUB     SP,SP,#16
        MOV     R4,#"O"                 ; magic "old" indicator
        STMFD   SP!,{R1,R4}
        B       GCOLOFON3LP
GCOLOFON
        MOV     R14,#0
        STMFD   SP!,{R11,R12,R14}       ; dummy,dummy,terminator
        MOV     AELINE,LINE
GCOLOFONLP
        STR     R10,[SP,#-4]!           ; Remember OF/ON
        BL      EXPR
        BL      INTEGY
        TEQ     R10,#","
        MOVNE   R1,#0
        STMNEFD SP!,{R0,R1}
        BNE     GCOLOFONLPN
        STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        LDR     R5,[SP,#16]
        TEQ     R10,#","
        TEQEQ   R5,#0
        BEQ     GCOLOFON3
        STR     IACC,[SP,#-4]!
GCOLOFONLPN
        LDR     R4,[SP,#8]
        TEQ     R10,#TON
        TEQEQ   R4,#TOF
        BEQ     GCOLOFONLP
        BL      AEDONE
DOGCOLOFON
        LDMFD   SP!,{R1,R2,R4}
        AND     R0,R2,#&F
        TEQ     R4,#0
        BEQ     NXT
        TEQ     R4,#TON
        ORREQ   R0,R0,#&10
        SWI     OS_SetColour
        B       DOGCOLOFON
GCOLOFON3
        LDMFD   SP,{R1,R4}              ; recover A,OF/ON
        STMFD   SP!,{R1,R4}             ; repush, two lower
GCOLOFON3LP
        STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        TEQ     R10,#","
        LDMNEFD SP!,{R1,R2}
        MOVNE   R4,#0
        STMNEFD SP!,{R0,R1,R2,R4}
        BNE     GCOLOFON3LPN
        STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        STR     IACC,[SP,#-4]!
GCOLOFON3LPN
        LDR     R5,[SP,#16]
        TEQ     R5,#TOF
        TEQNE   R5,#"O"
        TEQEQ   R10,#TON
        BNE     DOGCOLOFON3DN
        STR     R10,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        B       GCOLOFON3LP
DOGCOLOFON3DN
        BL      AEDONE
DOGCOLOFON3
        LDMFD   SP!,{R0-R2,R4,R5}
        TEQ     R5,#0
        BEQ     NXT
        TEQ     R5,#"O"
        ANDNE   R4,R4,#15
        MOVNE   R3,#256                 ;dither
        ORREQ   R3,R4,#256
        ANDEQ   R4,R4,#255
        TEQ     R5,#TON
        ORREQ   R3,R3,#128
        AND     R2,R2,#255
        AND     R1,R1,#255
        AND     R0,R0,#255
        ORR     R0,R2,R0,LSL #16
        ORR     R0,R0,R1,LSL #8
        MOV     R0,R0,LSL #8
        SWI     ColourTrans_SetGCOL
        B       DOGCOLOFON3
LINEST  BL      SPACES
        TEQ     R10,#TINPUT
        MOVEQ   R5,#0
        MOVEQ   R4,#&40
        BEQ     INPLP
        SUB     LINE,LINE,#1
        BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        LDMFD   SP!,{R4,R5,R6}
        MOV     R3,IACC                ;r3: y2, r4: x2, r5: y, r6: x
        MOV     R0,#4
        MOV     R1,R6
        MOV     R2,R5
        BL      DOPLOT                 ;move x,y
        MOV     R0,#5
        MOV     R1,R4
        MOV     R2,R3
        BL      DOPLOT                 ;draw x2,y2
        B       NXT
MODES
        ; We have several forms of the MODE statement to deal with:
        ;
        ; MODE <n>                     (<n> <  256)   -> VDU 22
        ; MODE <n>                     (<n> >= 256)   -> OS_ScreenMode 0
        ; MODE <string>                               -> OS_ScreenMode 15
        ; MODE <x>,<y>,<bpp>[,<hz>]                   -> OS_ScreenMode 0
        ; MODE <x>,<y>,<flags>,<ncol>,<l2bpp>[,<hz>]  -> OS_ScreenMode 0
        ;
        ; The first three cases can be dealt with in a fairly straightforward
        ; manner. However the last two are a bit trickier because we want to
        ; validate <bpp>, but we won't know if it's <bpp> or <flags> until we've
        ; read the full sequence of parameters.
        MOV     AELINE,LINE
        BL      EXPR
        MOV     LINE,AELINE
        TEQ     TYPE,#0
        BEQ     MODESTRING              ; MODE <string>
        BLMI    INTEGB                  ; error
        TEQ     R10,#","
        BEQ     MODESD                  ; One of the parameterised cases
        BL      DONE
        CMP     R0,#256                 ; One of the MODE <n> cases
        MOVCS   R1,R0
        BCS     MODESELECTORBLOCK
        MOV     R14,#1
        STRB    R14,[ARGP,#MEMM]
        SWI     OS_WriteI+22
        SWI     OS_WriteC
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
MODEGOOD
        BL      CTALLY
        B       NXT
MODESD  MOV     R1,#1
        STR     R1,[SP,#-(ModeSelector_ModeVars+8)]! ; Core parameters plus ModeFlags & NColour
        STR     IACC,[SP,#ModeSelector_XRes]
        BL      INTEXC
        STR     IACC,[SP,#ModeSelector_YRes]
        BL      EXPR
        BL      INTEGY
        STR     IACC,[SP,#ModeSelector_ModeVars] ; depth or ModeFlags
        ; Look for optional hz (1st variant), or NColour (2nd variant)
        TEQ     R10,#","
        MOVNE   IACC,#-1
        BNE     MODESD_BPP
        BL      EXPR
        BL      INTEGY
        TEQ     R10,#","
        BNE     MODESD_BPP
        ; <x>,<y>,<flags>,<ncol>,<l2bpp>[,<hz>] variant
        STR     IACC,[SP,#ModeSelector_ModeVars+4] ; NColour
        BL      EXPR
        BL      INTEGY
        STR     IACC,[SP,#ModeSelector_PixelDepth] ; Log2BPP
        TEQ     R10,#","
        MOVNE   IACC,#-1
        BNE     MODESD_FL_NC_L2
        BL      EXPR
        BL      INTEGY
MODESD_FL_NC_L2 ; <x>,<y>,<flags>,<ncol>,<l2bpp>[,<hz>] variant
        STR     IACC,[SP,#ModeSelector_FrameRate]
        BL      AEDONE
        ADD     R1,ARGP,#STRACC
        ASSERT  ModeSelector_ModeVars = 20
        LDMIA   SP!,{R3-R7}
        STMIA   R1!,{R3-R7}
        MOV     R2,#VduExt_ModeFlags
        LDMIA   SP!,{R3,R5}
        MOV     R4,#VduExt_NColour
        MOV     R6,#-1
        STMIA   R1,{R2-R6}
        ADD     R1,ARGP,#STRACC
        B       MODESELECTORBLOCK

MODESD_BPP ; <x>,<y>,<bpp>[,<hz>] variant
        STR     IACC,[SP,#ModeSelector_FrameRate]
        LDR     IACC,[SP,#ModeSelector_ModeVars] ; recover bpp/depth value
        MOV     R1,#0
        ADR     R2,MODEBPPTAB
MODESDFINDBPP
        LDRB    R3,[R2,R1]
        TEQ     R3,#0
        BEQ     ERBPP
        TEQ     IACC,R3
        ADDNE   R1,R1,#1
        BNE     MODESDFINDBPP
        STR     R1,[SP,#ModeSelector_PixelDepth] ; depth index (not true Log2BPP yet)
        BL      AEDONE
        ADD     R1,ARGP,#STRACC         ; clear stack to allow memory reclaim
        ASSERT  ModeSelector_ModeVars = 20
        LDMIA   SP!,{R3-R7}             ; flg,X,Y,D,F (R6:=D)
        ADD     SP,SP,#8                ; Junk the two extra words we reserved for the 2nd variant of the command
        STMIA   R1,{R3-R7}
        MOV     R2,#ModeFlag_FullPalette
        MOV     R3,#VduExt_NColour
        MOV     R4,#255
        MOV     R5,#-1
        ADD     R14,R1,#ModeSelector_ModeVars+4
        STMIA   R14,{R2-R5}             ; Write the extra params needed for depth index 4
        CMP     R6,#4                   ; depth index 4 == 8bpp
        MOVLO   R14,R6                  ; depth < 4 maps directly to log2bpp
        SUBHS   R14,R6,#1               ; depth > 4 needs offset
        MOVEQ   R2,#VduExt_ModeFlags    ; also depth 4 needs extra mode variables
        MOVNE   R2,#-1
        STR     R14,[R1,#ModeSelector_PixelDepth]
        STR     R2,[R1,#ModeSelector_ModeVars]
MODESELECTORBLOCK
        MOV     R14,#1
        STRB    R14,[ARGP,#MEMM]
        MOV     R0,#ScreenModeReason_SelectMode
        SWI     XOS_ScreenMode
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
        BVC     MODEGOOD
MODESELECTORBLOCKERR
        ; If we get back "SWI not known", substitute with "Bad MODE" (user running pre-OS 3.5)
        LDR     R1,[R0]
        SUB     R1,R1,#256
        CMP     R1,#ErrorNumber_NoSuchSWI-256
        SWINE   OS_GenerateError
        B       ERBADMODE
MODEBPPTAB
        =       1,2,4,6,8,16,32,0
        ALIGN

MODESTRING ; MODE <string>
        MOV     R0,#0
        STRB    R0,[CLEN]
        MOV     R14,#1
        STRB    R14,[ARGP,#MEMM]
        ADD     R1,ARGP,#STRACC
        MOV     R0,#ScreenModeReason_SelectModeByString
  [ :LNOT: standalone ; Only include mode string parser for standalone builds (minor space saver)
        SWI     OS_ScreenMode
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
        B       MODEGOOD
  |
        SWI     XOS_ScreenMode
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
        BVC     MODEGOOD
        ; If we get back "SWI not known", substitute with "Bad MODE" (user running pre-OS 3.5)
        LDR     R2,[R0]
        SUB     R2,R2,#256
        CMP     R2,#ErrorNumber_NoSuchSWI-256
        BEQ     ERBADMODE
        ; If we got "bad reason code", try parsing the mode string manually (user running pre- Select / 5.21)
        CMP     R2,#ErrorNumber_ScreenModeBadReason-256
        CMPNE   R2,#-256                ; ScreenModeBadReason error was only introduced in RISC OS 5.20, previous kernels (3.X / 5.X lineage) just used error number zero
        SWINE   OS_GenerateError
        ; The following mode string parsing code has been borrowed from the
        ; Wimp. It doesn't support all the parameters that a modern kernel will,
        ; but an old kernel isn't likely to support any of the newer features
        ; anyway, so only supporting a subset here shouldn't result in any major
        ; problems.
        ; Also note that since we're emulating OS_ScreenMode 15, we use the
        ; default kernel palettes instead of the Wimp ones.
        MOV     R7,SP
        ; use R4-R6 for xres,yres,bpp, R3 frame rate
        MOV     R4,#-1
        MOV     R5,#-1
        MOV     R6,#-1                  ; must specify these
        MOV     R3,#-1
        Push    "R4"                    ; Selector block terminator
scan_for_param  ROUT
        LDRB    R0,[R1],#1
        CMP     R0,#32
        BLO     scan_ended
        BEQ     scan_for_param
        CMP     R0,#","
        BEQ     scan_for_param
        ; Check that a suspiciously large number of parameters haven't been pushed onto the stack (avoid STRACC overflow later on)
        SUB     R14,R7,SP
        CMP     R14,#200
        BHI     ERBADMODE
        ASCII_UpperCase R0,R14          ; this is safe
        CMP     R0,#"E"
        BEQ     get_eig_factors
        CMP     R0,#"X"
        BEQ     get_xres
        CMP     R0,#"Y"
        BEQ     get_yres
        CMP     R0,#"C"
        BEQ     get_colours
        CMP     R0,#"G"
        BEQ     get_greys
        CMP     R0,#"F"
        BEQ     get_frame
; oh dear, user error
bad_param_exit
        B       ERBADMODE
get_eig_factors
        LDRB    R0,[R1],#1
        ASCII_UpperCase R0,R14
        CMP     R0,#"X"                  ; only EX EY allowed
        MOVEQ   R0,#VduExt_XEigFactor
        CMP     R0,#"Y"
        MOVEQ   R0,#VduExt_YEigFactor
        CMPNE   R0,#VduExt_XEigFactor
        BNE     bad_param_exit
        Push    "R0"
        MOV     R0,#&2000000a           ; base 10
        MOV     R2,#3                   ; only allow 0-3 (note OS can cope with 4)
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        Pull    "R0"
        Push    "R0,R2"
        B       scan_for_param

get_xres
        CMP     R4,#-1
        BNE     bad_param_exit                  ; only one x allowed
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R4,R2
        B       scan_for_param

get_yres
        CMP     R5,#-1
        BNE     bad_param_exit                  ; only one y allowed
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R5,R2
        B       scan_for_param

get_frame
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R3,R2
        B       scan_for_param

get_colours
        CMP     R6,#-1
        BNE     bad_param_exit                  ; only one C or G allowed
; only 2,4,16,64,256,32T,32K,16M are valid
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R0,#-1
        CMP     R2,#2
        MOVEQ   R0,#0                           ; 1bpp
        CMP     R2,#4
        MOVEQ   R0,#1                           ; 2bpp
        CMP     R2,#256
        MOVEQ   R0,#VduExt_NColour
        MOVEQ   R2,#255
        Push    "R0,R2",EQ                      ; select full 256 colours
        MOVEQ   R0,#VduExt_ModeFlags
        MOVEQ   R2,#ModeFlag_FullPalette
        Push    "R0,R2",EQ                      ; select full 256 colours
        CMPNE   R2,#64
        MOVEQ   R0,#3                           ; 8bpp
        CMP     R0,#-1
        MOVNE   R6,R0
        BNE     scan_for_param
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R2,#16
        BNE     %FT05
        CMP     R0,#"M"
        ADDEQ   R1,R1,#1
        MOVEQ   R6,#5                           ; 32bpp (16M)
        MOVNE   R6,#2                           ; 4bpp  (16)
        B       scan_for_param
5
        CMP     R2,#32
        BNE     bad_param_exit
        ; must be either T or K
        CMP     R0,#"T"
        CMPNE   R0,#"K"
        BNE     bad_param_exit
        ADD     R1,R1,#1                        ; move it along
        MOV     R6,#4                           ; 16bpp
        B       scan_for_param

get_greys
        CMP     R6,#-1
        BNE     bad_param_exit                  ; only one C or G allowed
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        CMP     R2,#16
        MOV     R6,#3+128                       ; 8bpp (+128 makes the palette get hit later)
        MOVEQ   R6,#2+128                       ; 4bpp
        CMPNE   R2,#256
        CMPNE   R2,#4
        CMPNE   R2,#2
        BNE     bad_param_exit
        CMP     R2,#4
        MOVEQ   R6,#1+128
        CMP     R2,#2
        MOVEQ   R6,#0                           ; no palette munging so not +128
        CMP     R2,#256
        MOVEQ   R0,#VduExt_NColour
        MOVEQ   R2,#255
        Push    "R0,R2",EQ                      ; must be set for 256 greys
        MOVEQ   R0,#VduExt_ModeFlags
        MOVEQ   R2,#ModeFlag_FullPalette
        Push    "R0,R2",EQ                      ; must be set for 256 greys

        B       scan_for_param

scan_ended
        CMP     R4,#-1
        CMPNE   R5,#-1
        CMPNE   R6,#-1
        BEQ     bad_param_exit          ; all must be supplied
        ; Construct the full selector block within STRACC (overwrites the string)
        ADD     R1,ARGP,#STRACC
        MOV     R0,#1
        BIC     R14,R6,#128             ; clear the greys flag
        STMIA   R1!,{R0,R4-R5,R14}      ; flags, xres, yres, bpp
        STR     R3,[R1],#4              ; frame rate
        ; There'll also be some values on the stack (guaranteed at least one)
10
        Pull    "R0"
        CMP     SP,R7
        STR     R0,[R1],#4
        BNE     %BT10
        ADD     R1,ARGP,#STRACC
        MOV     R14,#1
        STRB    R14,[ARGP,#MEMM]
        MOV     R0,#ScreenModeReason_SelectMode
        SWI     XOS_ScreenMode
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
        BVS     MODESELECTORBLOCKERR
        ; If the OS doesn't support OS_ScreenMode 15, there's a good chance it won't support the greyscale palette option either, so implement it ourselves
        TST     R6,#128
        BEQ     MODEGOOD
        CMP     R6,#128+2
        MOVGT   R4,#&01                 ; 8bpp
        MOVEQ   R4,#&11                 ; 4bpp
        MOVLT   R4,#&55                 ; 2bpp
        MOV     R3,#16<<8
        MOV     R6,#0
        MOV     R0,#OsWord_WritePalette
20
        ORR     R5,R3,R6,LSL #16
        ORR     R5,R5,R6,LSL #24
        STMIA   R1,{R5,R6}
        SWI     OS_Word
        ADD     R3,R3,#1                ; Next palette index
        ADD     R6,R6,R4                ; Next greyscale value
        CMP     R6,#256
        BLT     %BT20
        ; 16 colour modes will have colour 7 as the default colour, override it to 15
        CMP     R4,#&11
        ADREQ   R0,%FT30
        MOVEQ   R1,#5
        SWIEQ   OS_WriteN
        B       MODEGOOD
30
        = 17,15,18,0,15
        ALIGN
  ] ; standalone
        LTORG
        
DOMOUSE BL      SPACES
        CMP     R10,#TTEXT
        BEQ     DOMOUSECOLOUR
        CMP     R10,#TON
        BEQ     DOMOUSEON
        CMP     R10,#TOFF
        BEQ     DOMOUSEOFF
        CMP     R10,#TTO
        BEQ     DOMOUSETO
        CMP     R10,#TSTEP
        BEQ     DOMOUSESTEP
        CMP     R10,#TESCSTMT
        BEQ     DOMOUSERECT
        SUB     LINE,LINE,#1
        BL      CRAELV
        BEQ     ERMOUS
        CMP     TYPE,#128
        BCS     ERMOUS
        STMFD   SP!,{IACC,TYPE}
        MOV     LINE,AELINE
        BL      SPACES
        CMP     R10,#","
        BNE     ERCOMM
        BL      CRAELV
        BEQ     ERMOUS
        CMP     TYPE,#128
        BCS     ERMOUS
        STMFD   SP!,{IACC,TYPE}
        MOV     LINE,AELINE
        BL      SPACES
        CMP     R10,#","
        BNE     ERCOMM
        BL      CRAELV
        BEQ     ERMOUS
        CMP     TYPE,#128
        BCS     ERMOUS
        MOV     LINE,AELINE
        BL      SPACES
        CMP     R10,#","
        BEQ     MOUSEFOUR
        BL      DONE
        STMFD   SP!,{IACC,TYPE}
        SWI     OS_Mouse
        MOV     R6,R0
        MOV     R7,R1
        MOV     IACC,R2
DOMOUSESTORE
        MOV     TYPE,#TINTEGER
        BL      STORE                  ;store switches in last one
        MOV     IACC,R7
        MOV     TYPE,#TINTEGER
        BL      STORE                  ;store y
        MOV     IACC,R6
        MOV     TYPE,#TINTEGER
        BL      STORE                  ;store x
        B       NXT
MOUSEFOUR
        STMFD   SP!,{IACC,TYPE}
        BL      CRAELV
        BEQ     ERMOUS
        CMP     TYPE,#128
        BCS     ERMOUS
        MOV     LINE,AELINE
        BL      DONES
        STMFD   SP!,{IACC,TYPE}
        SWI     OS_Mouse
        MOV     R6,R0
        MOV     R7,R1
        MOV     AELINE,R2
        MOV     R0,R3
        MOV     TYPE,#TINTEGER
        BL      STORE
        MOV     IACC,AELINE
        B       DOMOUSESTORE
DOMOUSERECT
        LDRB    R10,[LINE],#1
        CMP     R10,#TRECT
        BNE     ERSYNT
        BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        LDMFD   SP!,{R1,R2,R3}
        ADD     R4,R2,R0
        ADD     R5,R1,R3
;R3 XLO,R2 YLO,R5 XHI,R4 YHI
        MOV     R0,#&FF
        ORR     R0,R0,#&FF00
        AND     R3,R3,R0
        ORR     R2,R3,R2,LSL #16
        AND     R5,R5,R0
        ORR     R3,R5,R4,LSL #16
        ADD     R1,ARGP,#STRACC
        ADD     R1,R1,#3
        MOV     R0,#1
        STRB    R0,[R1]
        STR     R2,[R1,#1]
        STR     R3,[R1,#5]
        MOV     R0,#OsWord_DefinePointerAndMouse
        SWI     OS_Word
        B       NXT
DOMOUSESTEP
        BL      AEEXPR
        BL      INTEGY
        AND     R1,IACC,#&FF
        CMP     R10,#","
        BNE     DOMOUSESTEP1
        STR     IACC,[SP,#-4]!
        BL      EXPR
        BL      INTEGY
        AND     R1,IACC,#&FF
        LDR     IACC,[SP],#4
DOMOUSESTEP1
        BL      AEDONE
        MOV     IACC,IACC,LSL #8
        AND     IACC,IACC,#&FF00
        ORR     IACC,IACC,#2
        ORR     IACC,IACC,R1,LSL #16
        ADD     R1,ARGP,#STRACC
        STR     IACC,[R1]
        MOV     R0,#OsWord_DefinePointerAndMouse
        SWI     OS_Word
        B       NXT
DOMOUSETO
        BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        LDR     R1,[SP],#4
        STR     IACC,[SP,#-4]!
        MOV     R1,R1,LSL #16
        ORR     R1,R1,#&300
        STR     R1,[SP,#-4]!
        ADD     R1,SP,#1
        MOV     R0,#OsWord_DefinePointerAndMouse
        SWI     OS_Word
        ADD     SP,SP,#8
        B       NXT
DOMOUSEOFF
        MOV     IACC,#0
        BL      DONES
        B       DOMOUSEON1
DOMOUSEON
        MOV     IACC,#1
        BL      SPACES
        CMP     R10,#":"
        CMPNE   R10,#13
        CMPNE   R10,#TELSE
        BEQ     DOMOUSEON1
        SUB     LINE,LINE,#1
        BL      AEEXDN
DOMOUSEON1
        MOV     R1,IACC
        MOV     R0,#106
        SWI     OS_Byte
        B       NXT
DOMOUSECOLOUR
        BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        MOV     R6,#25
        B       PROGPAL
MOVE    MOV     IACC,#4
PLOTER  BL      SPACES
PLOTER1 CMP     R10,#"B"
        SUBNE   LINE,LINE,#1
        BNE     PLOTER2
        LDRB    R10,[LINE],#1
        CMP     R10,#"Y"
        SUBEQ   IACC,IACC,#4
        SUBNE   LINE,LINE,#2
        B       PLOTER2
ORGIN   BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        SWI     OS_WriteI+29
        MOV     R3,IACC
        LDR     R0,[SP],#4               ;X
        BL      WRITEG
        MOV     R0,R3
        BL      WRITEG
        B       NXT
PLOT    BL      INTEXA
        MOV     LINE,AELINE
PLOTER2 STR     IACC,[SP,#-4]!
        BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        LDMFD   SP!,{R3,R4}            ;X,TYPE
        MOV     R2,IACC
        MOV     R0,R4
PLOTACT MOV     R1,R3                  ;action in R0, Y in R2, X in R3
        BL      DOPLOT
        B       NXT
PSET    BL      SPACES
        MOV     IACC,#&45
        CMP     R10,#TTO
        BNE     PLOTER1
        BL      INTEXA                 ;point to
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        LDR     R1,[SP],#4
        STR     IACC,[SP,#-4]!
        MOV     R1,R1,LSL #16
        ORR     R1,R1,#&500
        STR     R1,[SP,#-4]!
        ADD     R1,SP,#1
        MOV     R0,#OsWord_DefinePointerAndMouse
        SWI     OS_Word
        ADD     SP,SP,#8
        B       NXT
RECT    MOV     R0,#0
        MOV     R1,#&65
        BL      CHECKFILL
        STR     IACC,[SP,#-4]!
        BL      INTEXA
        STR     IACC,[SP,#-4]!             ;X
        BL      INTEXC
        STR     IACC,[SP,#-4]!             ;Y
        BL      EXPR
        BL      INTEGY
        STR     IACC,[SP,#-4]!             ;W
        CMP     R10,#","
        BNE     RECTSIMPLE
        BL      EXPR
        BL      INTEGY
RECTSIMPLE
        LDMFD   SP!,{R3,R4,R5}
        ADD     R3,R5,R3               ;X+W
        ADD     R6,R4,IACC             ;Y+H
        CMP     R10,#TTO
        BEQ     RECTMOVE
        BL      AEDONE
        MOV     R0,#4
        MOV     R1,R5
        MOV     R2,R4
        BL      DOPLOT                 ;move x,y
        LDR     R0,[SP],#4
        TEQ     R0,#0
        MOVNE   R2,R6
        BNE     PLOTACT                ;plot &65,x+w,y+h
        MOV     R0,#13
        MOV     R1,R3
        BL      DOPLOT                 ;'draw' x+w,y
        MOV     R0,#13
        MOV     R2,R6
        BL      DOPLOT                 ;'draw' x+w,y+h
        MOV     R0,#13
        MOV     R1,R5
        BL      DOPLOT                 ;'draw' x,y+h
        MOV     R0,#13
        MOV     R2,R4
        BL      DOPLOT                 ;'draw' x,y
        B       NXT
RECTMOVE
        STMFD   SP!,{R3,R4,R5,R6}      ;x2, y, x, y2
        BL      INTEXC
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        LDMFD   SP!,{R3,R4,R5,R6,R7,TYPE}
        MOV     AELINE,IACC
; r3: x3, r4: x2, r5: y, r6: x, r7: y2, TYPE: type, AELINE: y3
        MOV     R0,#4
        MOV     R1,R6
        MOV     R2,R5
        BL      DOPLOT                 ;move x,y
        MOV     R0,#4
        MOV     R1,R4
        MOV     R2,R7
        BL      DOPLOT                 ;move x2,y2
        TEQ     TYPE,#0
        MOVEQ   R0,#&BE
        MOVNE   R0,#&BD
        MOV     R1,R3
        MOV     R2,AELINE
        BL      DOPLOT                 ;plot q,x3,y3
        B       NXT
DOTINT  BL      INTEXA
        STR     IACC,[SP,#-4]!
        BL      EXPRDN
        MOV     R1,IACC
        LDR     IACC,[SP],#4
;TINT R0,R1
TINTEND SWI     OS_WriteI+23
        SWI     OS_WriteI+17
        SWI     OS_WriteC
        MOV     IACC,R1
        SWI     OS_WriteC
        MOV     R1,#6
        BL      ZEROX
        B       NXT
VDUP    MOV     IACC,IACC,LSR #8
        SWI     OS_WriteC
VDU     BL      SPACES
VDUL    CMP     R10,#":"
        BEQ     NXT
        CMP     R10,#13
        BEQ     NXT
        CMP     R10,#TELSE
        BEQ     NXT
        SUB     AELINE,LINE,#1
        BL      EXPR
        MOV     LINE,AELINE
        BL      INTEGY
        SWI     OS_WriteC
        CMP     R10,#","
        BEQ     VDU
        CMP     R10,#";"
        BEQ     VDUP
        CMP     R10,#"|"
        BNE     VDUL
        MOV     R1,#9
        BL      ZEROX
        B       VDU
WAIT    BL      DONES
        MOV     R0,#19
        SWI     OS_Byte
        B       NXT
;plot r0,r1,r2: destroys R0
DOPLOT  SWI     XOS_Plot
        MOVVC   PC,R14
        SWI     OS_GenerateError
;write lo byte, high byte
WRITEG  SWI     OS_WriteC
        MOV     R0,R0,LSR #8
        SWI     OS_WriteC
        MOV     PC,R14
;write R1 zeroes
ZEROX   MOV     R0,#0
ZEROX1  SWI     OS_WriteC
        SUBS    R1,R1,#1
        BGT     ZEROX1
        MOV     PC,R14
;overlay
OVERLAY BL      AELV
        BEQ     ERARRY
        CMP     TYPE,#256+128
        BNE     ERTYPESTRINGARRAY
        LDR     TYPE,[IACC]
        CMP     TYPE,#16
        BCC     ERARRZ
        BL      AEDONES
        BL      GETARRAYSIZE1
        MOV     AELINE,TYPE
        MOV     R6,TYPE
        MOV     R7,#0                  ;maximum size used
OVERLAYSIZES
        MOV     IACC,R6
        BL      VARSTR
        SUB     R4,CLEN,ARGP
        SUBS    R4,R4,#STRACC
        BEQ     OVERLAYSIZES1
        MOV     R0,#13
        STRB    R0,[CLEN]
        BL      OSFILEINFOSTRACC
        CMP     R0,#1
        BNE     OVERLAYSIZES1
        CMP     R4,R7
        MOVCS   R7,R4
OVERLAYSIZES1
        ADD     R6,R6,#5
        SUBS    R10,R10,#1
        BNE     OVERLAYSIZES
        ADD     R7,R7,#3
        BIC     R7,R7,#3
        LDR     R4,[ARGP,#FSA]
        ADD     R6,R4,#12              ;3 words of data: Array Base, current overlay and size
        ADD     R6,R6,R7
        ADD     R5,R6,#1024
        CMP     R5,SP
        BCS     BADDIMSIZE
        LDR     R0,[ARGP,#OVERPTR]
        TEQ     R0,#0
        MOV     R0,#0
        STRNE   R0,[ARGP,#PROCPTR]     ;forget all procedures or functions in case they are
        STRNE   R0,[ARGP,#FNPTR]       ;overlays already (if overlays existed!).
        STR     R6,[ARGP,#FSA]
        STR     R4,[ARGP,#OVERPTR]     ;overlay pointer
        STR     AELINE,[R4]            ;Base of array: [,#-4] has size of array
        MVN     R0,#0
        STR     R0,[R4,#4]             ;current overlay (-1=none)
        STR     R7,[R4,#8]             ;total size allowed for overlayed program
        LDRB    R10,[LINE,#-1]
        B       NXT
;file io
LEXT    MOV     R0,#3
        B       LPTRA
LPTR    MOV     R0,#1
LPTRA   STR     R0,[SP,#-4]!
        BL      AECHAN
        STR     IACC,[SP,#-4]!
        MOV     LINE,AELINE
        BL      EQAEEX
        MOV     R2,IACC
        LDR     R1,[SP],#4
        LDR     R0,[SP],#4
        SWI     OS_Args
        B       NXT
BBPUT   BL      AECHAN
        BL      AESPAC
        CMP     R10,#","
        BNE     ERCOMM
        STR     R1,[SP,#-4]!
        BL      EXPR
        TEQ     TYPE,#0
        BEQ     BBPUT1
        BLMI    INTEGB
        BL      AEDONE
        LDR     R1,[SP],#4
        SWI     OS_BPut
        B       NXT
BBPUT1  TEQ     R10,#";"
        MOVNE   R0,#10
        STRNEB  R0,[CLEN],#1
        BLEQ    AESPAC
        BL      AEDONE
        MOV     R5,CLEN
        MOV     R0,#2
        LDR     R1,[SP],#4
        ADD     R2,ARGP,#STRACC
        SUBS    R3,R5,R2
        SWINE   OS_GBPB
        B       NXT
CLOSE   BL      AECHAN
        BL      AESPAC
        BL      AEDONE
        MOV     R0,#0
        SWI     OS_Find
        B       NXT
INPUTH  MOV     AELINE,LINE
        BL      CHANNL
        STR     IACC,[SP,#-4]!             ;save channel as TOS
INPHLP  MOV     LINE,AELINE
        BL      SPACES
        CMP     R10,#","
        BNE     INPHEX
        BL      CRAELV
        BEQ     ERSYNT
        MOV     R4,IACC
        MOV     R5,TYPE
        LDR     R1,[SP]                ;channel
ENDOFFILE
        SWI     OS_BGet
        BCS     ENDOFFILE
        CMP     R5,#128
        BCC     INPHNO                 ;branch if input to number
        MOVS    TYPE,R0,LSL #24
        BNE     ERTYPESTR              ;wanted string
        SWI     OS_BGet
        TEQ     R0,#0
        ADD     CLEN,ARGP,#STRACC
        ADD     CLEN,CLEN,R0
        BEQ     INPHSS
        MOV     R3,R0
        MOV     R6,CLEN
INPHSL  SWI     OS_BGet
        STRB    R0,[R6,#-1]!
        SUBS    R3,R3,#1
        BNE     INPHSL
        B       INPHSS
INPHNO  MOVS    TYPE,R0,LSL #24
        BEQ     ERTYPEINT              ;wanted number
        BMI     INPHNF                 ;read floating
        SWI     OS_BGet
        MOV     R2,R0,LSL #24
        SWI     OS_BGet
        ORR     R2,R2,R0,LSL #16
        SWI     OS_BGet
        ORR     R2,R2,R0,LSL #8
        SWI     OS_BGet
        ORR     R0,R2,R0
INPHSS  BL      STOREA
        B       INPHLP
INPHNF  CMP     R0,#&88                ;new FP?
        MOVEQ   R3,#8                  ;yes
        MOVNE   R3,#5                  ;no
        ADD     TYPE,ARGP,#STRACC
        MOV     R2,#0
INPHFP  SWI     OS_BGet
        STRB    R0,[TYPE,R2]
        ADD     R2,R2,#1
        CMP     R2,R3
        BNE     INPHFP
        CMP     R3,#8
        BEQ     INPHFP8
 [ FPOINT=0
        LDMIA   TYPE,{FACC,FACCX}
        AND     FSIGN,FACC,#&80000000
        ANDS    FACCX,FACCX,#255
        TEQEQ   FACC,#0
        ORRNE   FACC,FACC,#&80000000
 |
        LDMIA   TYPE,{IACC,R1}
        ANDS    R1,R1,#255
        AND     R2,IACC,#TFP
        TEQEQ   IACC,#0
        ORRNE   IACC,IACC,#TFP
        SUB     R1,R1,#&82             ;remove 5 byte bias
        ADD     R1,R1,#&400            ;add D format bias
        ORR     R2,R2,R1,LSL #20
        MOV     R1,#0
        BL      FCONVERT2              ;either MI or EQ, so quicker
 ]
        MOV     TYPE,#TFP
        B       INPHSS
INPHFP8
 [ FPOINT=0
        LDMIA   TYPE,{FGRD,TYPE}
        AND     FSIGN,FGRD,#TFP
        MOV     FACCX,FGRD,LSR #20
        BIC     FACCX,FACCX,#&800
        SUB     FACCX,FACCX,#&400
        ADD     FACCX,FACCX,#&82
        MOVS    FACC,FGRD,LSL #11
        ORRS    FACC,FACC,TYPE,LSR #21
        TEQEQ   FACCX,#0
        ORRNE   FACC,FACC,#TFP
        TEQ     FACCX,#0
        MOVMI   FACCX,#0
        MOVMI   FACC,#0
        CMP     FACCX,#256
        MOVCS   FACCX,#255
        MVNCS   FACC,#0
 ELIF FPOINT=1
        LDFD    FACC,[TYPE]
 ELIF FPOINT=2
        ASSERT  FACC = 0
        FLDS    S1, [TYPE]
        FLDS    S0, [TYPE, #4]
 |
        ! 1, "Unknown FPOINT setting"
 ]
        MOV     TYPE,#TFP
        B       INPHSS
PRTHEX  MOV     LINE,AELINE
INPHEX  ADD     SP,SP,#4               ;remove thing
        B       DONEXT
PRINTH  MOV     AELINE,LINE
        BL      CHANNL
        STR     IACC,[SP,#-4]!             ;save handle
        BL      AESPAC
PRTHLP  CMP     R10,#","
        BNE     PRTHEX
        BL      EXPR
 [ FPOINT=0
        BL      FTOW                   ;move r0,r1,r3 to r4,r5,r7
        MOV     R0,TYPE,LSR #24
        LDR     R1,[SP]
        SWI     OS_BPut
        TEQ     TYPE,#0
        BEQ     PRTHS
        BMI     PRTHF
 |
        MOV     R4,IACC
        TEQ     TYPE,#0
        BMI     PRTHF
        MOV     R0,TYPE,LSR #24
        LDR     R1,[SP]
        SWI     OS_BPut
        TEQ     TYPE,#0
        BEQ     PRTHS
 ]
        MOV     R0,R4,LSR #24
        SWI     OS_BPut
        MOV     R0,R4,LSR #16
        SWI     OS_BPut
        MOV     R0,R4,LSR #8
        SWI     OS_BPut
        MOV     R0,R4
        SWI     OS_BPut
        B       PRTHLP
PRTHS   ADD     R3,ARGP,#STRACC
        SUB     R0,CLEN,R3
        SWI     OS_BPut
        TEQ     R0,#0
        BEQ     PRTHLP
PRTHSL  LDRB    R0,[CLEN,#-1]!
        SWI     OS_BPut
        TEQ     CLEN,R3
        BNE     PRTHSL
        B       PRTHLP
 [ FPOINT=0
PRTHF   ADD     TYPE,ARGP,#STRACC
        BL      FWTOA
        BL      F1STA
        ADD     CLEN,TYPE,#5
 ELIF FPOINT=1
PRTHF   MOV     R0,#&88
        LDR     R1,[SP]
        SWI     OS_BPut
        ADD     TYPE,ARGP,#STRACC
        STFD    FACC,[TYPE]
        ADD     CLEN,TYPE,#8
 ELIF FPOINT=2
PRTHF   MOV     R0,#&88
        LDR     R1,[SP]
        SWI     OS_BPut
        ADD     TYPE,ARGP,#STRACC
        ASSERT  FACC = 0
        FSTS    S1,[TYPE]
        FSTS    S0,[TYPE,#4]
        ADD     CLEN,TYPE,#8
 |
        ! 1, "Unknown FPOINT setting"
 ]
        LDR     R1,[SP]
PRTHFL  LDRB    R0,[TYPE],#1
        SWI     OS_BPut
        TEQ     TYPE,CLEN
        BNE     PRTHFL
        B       PRTHLP
LIBRARY BL      LIBSUB
        LDR     R3,[ARGP,#LIBRARYLIST]
        STR     R2,[ARGP,#LIBRARYLIST] ;link in at list head
        STR     R3,[R2],#4
 [ CHECKCRUNCH=1
        BL      CRUNCHCHK
        BEQ     NOLIBCRUNCH
 ]
        MOV     R0,#SAFECRUNCH
        MOV     R1,R2
        STR     R10,[SP,#-4]!
        BL      CRUNCHROUTINE
        ADD     R2,R2,#3
        BIC     R2,R2,#3
        STR     R2,[ARGP,#FSA]
        LDR     R10,[SP],#4
        B       NXT
 [ CHECKCRUNCH=1
NOLIBCRUNCH
        ADD     R2,R2,R4
        STR     R2,[ARGP,#FSA]
        B       NXT
 ]
;load library to heap top: return length in R4
LIBSUB  STR     R14,[SP,#-4]!
        BL      AEEXPR
        BL      OSSTRI
        BL      AEDONE
        BL      OSFILEINFO
        CMP     R0,#1
        BNE     LIBSUB1
        ADD     R4,R4,#3
        BIC     R4,R4,#3
        LDR     R2,[ARGP,#FSA]
        ADD     R0,R2,#4
        ADD     R3,R0,R4
        ADD     R3,R3,#1024
        CMP     R3,SP
        BCS     NOLIBROOM
LIBSUB1 STMFD   SP!,{R0,R2,R4}
        ADD     R2,R2,#4
        BL      OSFILELOAD
        LDMFD   SP!,{R0,R2,R4}
LIBTOP  LDRB    R1,[R0]
        CMP     R1,#13
        BNE     BADPRO1
        LDRB    R1,[R0,#1]
        CMP     R1,#&FF
        LDREQ   PC,[SP],#4
        LDRB    R1,[R0,#3]
        CMP     R1,#4
        ADDCS   R0,R0,R1
        BCS     LIBTOP
        B       BADPRO1
OSCL    BL      AEEXPR                 ;handle *command from Basic
        BL      OSSTRI
        BL      AEDONE
        ADD     R0,ARGP,#STRACC
        BL      OSCLIREGS
        MOV     R14,#3                 ;set   MEMM bit  and r12 bit
        STR     LINE,[ARGP,#R12STORE]  ;save r12
        STRB    R14,[ARGP,#MEMM]
        SWI     OS_CLI
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
        B       NXT
; flag: use offset instead of absolute pointer for SYS pop -
; slower, but allows SWIs to grab memory through Service_Memory
        GBLL    SYSRELSTK
SYSRELSTK SETL  {TRUE}
SYSNAME ADD     R1,ARGP,#STRACC        ;convert SWI name to number
        MOV     R0,#0
        STRB    R0,[CLEN]
        SWI     OS_SWINumberFromString
        B       SYSGOTSWINUMB
SYS0STRING
        MOV     R0,#0
        STRB    R0,[CLEN],#1
        LDR     R7,[ARGP,#FSA]         ;stack contains R4,R0-R9 params,stack pointer/size,SWI no
        LDMFD   SP!,{R0,R4,R5,R6}
        STMIA   R7!,{R0,R4,R5,R6}
        LDMFD   SP!,{R0,R4,R5,R6}
        STMIA   R7!,{R0,R4,R5,R6}
        LDMFD   SP!,{R0,R3,R4,R5,R6}
        STMIA   R7!,{R0,R3,R4,R5,R6}   ;move 13 words from stack to free memory
 [ SYSRELSTK
        MOV     R6,SP
 ]
        BL      SPUSH
 [ SYSRELSTK
        SUB     R14,R6,SP
 ]
        LDMDB   R7!,{R0,R3,R4,R5,R6}    ;move 13 words back from free memory
 [ SYSRELSTK
        ADD     R5,R5,R14               ;incrementing stack usage count
 ]
        STMFD   SP!,{R0,R3,R4,R5,R6}
        LDMDB   R7!,{R0,R4,R5,R6}
        STMFD   SP!,{R0,R4,R5,R6}
        LDMDB   R7!,{R0,R4,R5,R6}
        STMFD   SP!,{R0,R4,R5,R6}
        ADD     IACC,SP,#12*4+4+4      ;12 words on stack plus string length plus R4
        B       SYS0PUSH
SYS     BL      AEEXPR                 ;handle SYS keyword
        TEQ     TYPE,#0
        BEQ     SYSNAME
        BLMI    SFIX
SYSGOTSWINUMB
 [ SYSRELSTK
        MOV     TYPE,#8                ;initial SP in R9/TYPE
 |
        MOV     TYPE,SP                ;initial SP in R9/TYPE
 ]
        STR     IACC,[SP,#-4]!         ;save action
        MOV     R4,#0
        MOV     R5,#0
        MOV     R6,#0
        MOV     R7,#0
        STMFD   SP!,{R4-R7,R9}         ;R9=TYPE
        STMFD   SP!,{R4-R7}
        STMFD   SP!,{R4,R5}            ;save 10 register holes and old sp
        CMP     R10,#","
        BNE     SYSCALL
;note R4 (SYS register index) already 0
SYS0    CMP     R4,#10
        BCS     ERSYSINPUTS
SYS0SPACES
        LDRB    R10,[AELINE],#1
        CMP     R10,#" "
        BEQ     SYS0SPACES
        CMP     R10,#","
        BEQ     SYS0END
        STR     R4,[SP,#-4]!
        SUB     AELINE,AELINE,#1
        BL      EXPR
        TEQ     TYPE,#0
        BEQ     SYS0STRING
        BLMI    SFIX
SYS0PUSH
        LDR     R4,[SP],#4
        STR     IACC,[SP,R4,LSL #2]
SYS0END ADD     R4,R4,#1
        CMP     R10,#","
        BEQ     SYS0
SYSCALL MOV     LINE,AELINE
        ADD     AELINE,ARGP,#SWICODE
        LDR     R5,[SP,#11*4]
 [ SYSRELSTK
        LDR     R4,[SP,#10*4]
        TEQ     R4,#8
 |
        LDR     R4,[SP,#10*4]
        SUB     R4,R4,SP
        TEQ     R4,#8
 ]
        MOVEQ   R14,#3                 ;set   MEMM bit  and r12 bit
        MOVNE   R14,#2                 ;clear MEMM bit, set r12 bit
        STRB    R14,[ARGP,#MEMM]       ;and store it
        STR     LINE,[ARGP,#R12STORE]  ;save r12
        CMP     R10,#TTO
        BIC     R5,R5,#&FF000000
        ORR     R5,R5,#&EF000000       ;SWI like what's already there :-)
        STR     R5,[ARGP,#SWICODE]
        BEQ     SYSCALLTO
        BL      DONE
        LDMFD   SP!,{R0-R9}            ;get parameters from stack
        MOV     R14,PC
        MOV     PC,AELINE              ;go execute SWI...
                                       ;...and return here
 [ SYSRELSTK
        LDR     R14,[SP]
        MOV     ARGP,#VARS
        ADD     SP,SP,R14
 |
        MOV     ARGP,#VARS
        LDR     SP,[SP]                ;pop stack and continue
 ]
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
        B       NXT
SYSCALLTO                              ;SYS with TO parameters
        LDMFD   SP!,{R0-R9}            ;get parameters from stack
        MOV     R14,PC
        MOV     PC,AELINE              ;go execute SWI...
                                       ;...and return here
        SavePSR R14
        STMFD   SP!,{R0-R9,R14}        ;write parameters back to stack
        MOV     ARGP,#VARS
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
        MOV     R7,#0
SYS1    CMP     R7,#10
        BCS     ERSYSOUTPUTS
        STR     R7,[SP,#-4]!
        BL      CRAELV
        LDR     R7,[SP],#4
        BEQ     SYS1COMMA
        MOV     R4,IACC
        MOV     R5,TYPE
        LDR     IACC,[SP,R7,LSL #2]
        MOV     TYPE,#TINTEGER
        CMP     R5,#128
        BCC     SYS1END
        MOV     TYPE,#0
        ADD     CLEN,ARGP,#STRACC
        ADD     R3,CLEN,#256
        MOVS    R1,IACC
SYS1STRING
        LDRNEB  R1,[IACC],#1
        STRB    R1,[CLEN],#1
        TEQ     CLEN,R3
        TEQNE   R1,#13
        TEQNE   R1,#0
        TEQNE   R1,#10
        BNE     SYS1STRING
        TEQ     CLEN,R3
        SUBEQ   CLEN,CLEN,#255
        SUB     CLEN,CLEN,#1
SYS1END STR     R7,[SP,#-4]!
        BL      STOREA
        LDR     R7,[SP],#4
SYS1ENDA
        ADD     R7,R7,#1
        MOV     LINE,AELINE
SYS1SPACES
        LDRB    R10,[LINE],#1
        CMP     R10,#" "
        BEQ     SYS1SPACES
        CMP     R10,#","
        BEQ     SYS1
        CMP     R10,#";"
        BNE     SYSEXIT
        BL      CRAELV
        BEQ     ERSYNT
        MOV     R4,IACC
        MOV     R5,TYPE
        LDR     IACC,[SP,#10*4]        ;psr for flags
        MOV     TYPE,#TINTEGER
        MOV     IACC,IACC,LSR #28      ;nzcv
        BL      STOREA
        MOV     LINE,AELINE
        BL      SPACES
SYSEXIT
 [ SYSRELSTK
        LDR     R14,[SP,#11*4]!
        ADD     SP,SP,R14
 |
        LDR     SP,[SP,#11*4]          ;recover old SP
 ]
        B       DONEXT
SYS1COMMA
        BL      SPACES
        CMP     R10,#","
        CMPNE   R10,#";"
        SUBEQ   AELINE,LINE,#1
        BEQ     SYS1ENDA
        B       ERSYNT
CALL    BL      AEEXPR                 ;handle CALL and USR keywords
        BL      INTEGY
        CMP     R10,#","
        BEQ     CALLARM
        BL      AEDONE
        MOV     TYPE,IACC
 [ FPOINT=0
        BL      EMUMOS
        BNE     NXT
 ]
        MOV     R4,TYPE
        MOV     R5,#0
        B       CALLARMGO
CALLARM MOV     R4,IACC
        MOV     R5,#0
CALLARMPARM
        STMFD   SP!,{R4,R5}
        MOV     LINE,AELINE
        BL      CRAELV
        BEQ     ERSYNT
        LDMFD   SP!,{R4,R5}
        ADD     R5,R5,#1
        STMFD   SP!,{IACC,TYPE}
        BL      AESPAC
        CMP     R10,#","
        BEQ     CALLARMPARM
        BL      AEDONE
;Go to ARM code
CALLARMGO
        BL      CALLARMROUT
        B       NXT
CALLARMROUT                            ;call routines for CALL and USR
        MOV     TYPE,SP                ;pointer to list of lvs
        STMFD   SP!,{R4,R5,ARGP,AELINE,LINE,R10,R14}
        STR     LINE,[ARGP,#R12STORE]  ;store r12
        MOV     R10,#2                 ;set MEMM bit for r12
        STRB    R10,[ARGP,#MEMM]       ;and store it
        MOV     R10,R5                 ;number
        ADD     R11,ARGP,#STRACC
        ADDS    R0,ARGP,#INTVAR+4
        LDMIA   R0,{R0-R7}             ;A%-H%
        ADR     R14,CALL2
        LDR     PC,[SP],#4               ;go there!
OSCLIREGS
        ADR     R5,CALL2
        MOV     R4,SP
        MOV     R3,LINE
        MOV     R2,ARGP
        LDR     R1,[R5,#-4]
        MOV     PC,R14
;enter user with:
;r8  points to basic's ARGP workspace
;r9  pointer to list of lvs
;r10 number of lvs
;r11 STRACC
;r12 LINE
;r13 points to FD stack
;r14 link back to ab
CALL2REAL                              ; Return after CALL and USR
        LDMIA   SP!,{R5,ARGP,AELINE,LINE,R10}  ; omit r14 for now
        MOV     R14,#0                 ;unset all MEMM flags
        STRB    R14,[ARGP,#MEMM]       ;and store flags
        LDR     R14,[SP],#4            ;now restore r14
        ADD     SP,SP,R5,LSL #3        ;pop stack by two words per parameter
        MOVVC   PC,R14
        MOV     R14,R0
        B       MSGERR
        DCD     &BA51C005
CALL2   B       CALL2REAL              ;0th entry in table is return address
;words offset from ARGP
        &       STRACC
        &       PAGE
        &       TOP
        &       LOMEM
        &       HIMEM
        &       MEMLIMIT
        &       FSA
        &       TALLY
        &       TRACEFILE
        &       ESCWORD
        &       WIDTHLOC
;internal basic routines
        B       VARIND
        B       STOREA
        B       STSTORE
        B       EXTLVBLNK
        B       CREATE
        B       EXTEXPR
        B       CLIENTMATCH
        B       TOKENADDR
        &       0
 [ FPOINT=0
        &       9
        B       F1STA
        B       F1LDA
        B       F1ADD
        B       F1XSUB
        B       F1MUL
        B       F1XDIV
        B       FLOATB
        B       INTEGB
        B       FSQRT
 ]
;special EXPR routine to deal with cache
EXTEXPR STMFD   SP!,{AELINE,R14}
        BL      EXPR
        LDR     R4,[SP],#4
        BL      PURGECACHE
        TEQ     TYPE,#0
        LDR     PC,[SP],#4
;special LVBLNK routine to deal with cache
EXTLVBLNK
        STMFD   SP!,{AELINE,R14}
        BL      LVBLNK
        ADDEQ   SP,SP,#4
        LDRNE   R4,[SP],#4
        BLNE    PURGECACHE
        LDR     PC,[SP],#4
 [ FPOINT=0
;MOS emulation of r9 call
EMUMOS  MOV     R7,R9,LSR #8
        TEQ     R7,#&FF
        BNE     NOTMOS
        AND     R7,R9,#&FF
        TEQ     R7,#&E0
        BEQ     MOSRDCH
        LDR     R0,[ARGP,#INTVAR+4]
;'A' only
        TEQ     R7,#&EE
        BEQ     MOSWRCH
        TEQ     R7,#&E7
        BEQ     MOSNEWL
        TEQ     R7,#&E3
        BEQ     MOSASCI
        LDR     R1,[ARGP,#INTVAR+("X"-"@@")*4]
        LDR     R2,[ARGP,#INTVAR+("Y"-"@@")*4]
;'A X Y' only
        TEQ     R7,#&F4
        BEQ     MOSBYTE
        TEQ     R7,#&D7
        BEQ     MOSBGET
        TEQ     R7,#&D4
        BEQ     MOSBPUT
;'A address'
        CMP     R1,#256
        ORRCC   R1,R1,R2,LSL #8
        TEQ     R7,#&F1
        BEQ     MOSWORD
        TEQ     R7,#&F7
        BEQ     MOSCLI
        TEQ     R7,#&DD
        BEQ     MOSFILE
        TEQ     R7,#&DA
        BEQ     MOSARGS
        TEQ     R7,#&D1
        BEQ     MOSGBPB
        TEQ     R7,#&CE
        BNE     NOTMOS
        SWI     OS_Find
        B       RETMOS
MOSGBPB MOV     R7,R1
        MOV     R5,#12
MOSGP1  LDRB    R4,[R7,R5]
        STRB    R4,[SP,#-1]!
        SUBS    R5,R5,#1
        BNE     MOSGP1
        LDRB    R1,[R7]
        LDMFD   SP!,{R2,R3,R4}
        SWI     OS_GBPB
        STMFD   SP!,{R2,R3,R4}
        MOV     R5,#1
MOSGP2  LDRB    R4,[SP],#1
        STRB    R4,[R7,R5]
        ADD     R5,R5,#1
        TEQ     R5,#13
        BNE     MOSGP2
        B       RETMOS
MOSBPUT MOV     R1,R2
        SWI     OS_BPut
        B       RETMOS
MOSBGET MOV     R1,R2
        SWI     OS_BGet
        B       RETMOS
MOSARGS MOV     R1,R2
        SWI     OS_Args
        B       RETMOS
MOSFILE MOV     R7,R1
        MOV     R5,#17
MOSFL1  LDRB    R4,[R7,R5]
        STRB    R4,[SP,#-1]!
        SUB     R5,R5,#1
        CMP     R5,#1
        BNE     MOSFL1
        LDRB    R2,[R7,#1]
        LDRB    R1,[R7]
        ORR     R1,R1,R2,LSL #8
        LDMFD   SP!,{R2,R3,R4,R5}
        SWI     OS_File
        STMFD   SP!,{R2,R3,R4,R5}
        MOV     R5,#2
MOSFL2  LDRB    R4,[SP],#1
        STRB    R4,[R7,R5]
        ADD     R5,R5,#1
        TEQ     R5,#18
        BNE     MOSFL2
        B       RETMOS
MOSRDCH SWI     OS_ReadC
        B       RETMOS
MOSNEWL SWI     OS_NewLine
        B       RETMOS
MOSASCI TEQ     R0,#13
        SWIEQ   OS_WriteI+10
MOSWRCH SWI     OS_WriteC
        B       RETMOS
MOSWORD SWI     OS_Word
        B       RETMOS
MOSBYTE SWI     OS_Byte
        B       RETMOS
MOSCLI  MOV     R0,R1
        SWI     OS_CLI
RETMOS  AND     R0,R0,#&FF
        AND     R1,R1,#&FF
        AND     R2,R2,#&FF
        ORR     R0,R0,R1,LSL #8
        ORR     R0,R0,R2,LSL #16
        ORRCS   R0,R0,#&1000000
        MOVS    TYPE,#TINTEGER
        MOV     PC,R14
NOTMOS  MOVS    R0,#0
        MOV     PC,R14
 ]

QUIT    BL      SPACES
        CMP     R10,#":"
        CMPNE   R10,#13
        SWIEQ   OS_Exit                ;exit here if not QUIT <expression>
        SUB     AELINE,LINE,#1
        BL      EXPRDN
        LDR     R1,ABEX
        MOV     R2,IACC
        ; Store the return code and magic flags for OSQUITR in 's.Basic'
        STR     R1,[ARGP,#OS_Exit_ABEX]
        STR     R2,[ARGP,#OS_Exit_RetCode]
        SWI     OS_Exit
ABEX    DCB     "ABEX"

MUNGIG  LDRB    R10,[LINE],#1
        CMP     R10,#13
        BNE     MUNGIG
MUNGNL  LDRB    R10,[LINE],#1
        ADD     LINE,LINE,#2
        CMP     R10,#&FF
        BNE     MUNGLE1
        SUB     LINE,LINE,#4
        MOV     PC,R14                 ;exit with pointer to the cr
MUNGLE  LDR     R10,[ARGP,#ESCWORD]
        TST     R10,#&8000
        BNE     MUNGLESLOW
MUNGLE1 LDRB    R10,[LINE],#1
        CMP     R10,#" "
        CMPNE   R10,#":"
        BEQ     MUNGLE1
        CMP     R10,#13
        BEQ     MUNGNL
        CMP     R10,#TELSE
        CMPNE   R10,#TREM
        CMPNE   R10,#TDEF
        CMPNE   R10,#TDATA
        BEQ     MUNGIG
        SUB     LINE,LINE,#1
MUNGLESLOW
        LDR     R10,[ARGP,#FSA]
        ADD     R10,R10,#1024
        CMP     R10,SP
        MOVCC   PC,R14
        B       ERDEEPNEST
;process exceptional condition
;entry with r4 as the controller
;must not destroy r0 or UNTIL will not work
DOEXCEPTION
        TST     R4,#&80                ;check for escape itself
        BNE     ESCAPE
        TST     R4,#&8000
        BNE     DOTRACE
        MOV     R4,#0
        STR     R4,[ARGP,#ESCWORD]
        B       EREXCEPT
DOTRACE LDRB    R4,[LINE,#-4]
        CMP     R4,#13
        MOVNE   PC,R14                 ;not at a place where number can be shown
        LDR     R5,[ARGP,#TRCNUM]      ;check for trace type
        BICS    R4,R5,#&FF000000       ;quick check for 0...
        MOVEQ   PC,R14                 ;if trcnum 0 then no line number trace
        LDRB    R4,[LINE,#-3]
        LDRB    R6,[LINE,#-2]
        ADD     R4,R6,R4,LSL #8
        BIC     R6,R5,#&FF000000       ;clear extra bits
        CMP     R4,R6
        MOVGT   PC,R14                 ;tracing numbers but not in range
        STMFD   SP!,{R0,R7,R14}
        MOV     R0,R4
        LDR     TYPE,[ARGP,#TRACEFILE]
        CMP     TYPE,#0
        MOVNE   TYPE,#&8000            ;sets TYPE for chout in posite
        MOV     R7,#128                ;sets R7 for chout in posite
        BLEQ    TRCSTART
        BL      POSITE                 ;output number
        BL      TRCEND
        LDMFD   SP!,{R0,R7,PC}
;store system
STORE   LDMFD   SP!,{R4,R5}
STOREA  CMP     R5,#TFPLV
        BHI     STSTOR
        BEQ     FPSTOR
        TEQ     TYPE,#0
        BEQ     ERTYPEINT
 [ FPOINT=0
        BMI     STOREINT1
STOREANINT
        CMP     R5,#4
        BNE     BYTSTO
      [ :LNOT: (NoARMv6 :LOR: NoUnaligned)
        STR     IACC,[R4]
        MOV     PC,R14
      |
        TST     R4,#3
        STREQ   IACC,[R4]
        MOVEQ   PC,R14
STORER0MISAL
        MOV     R1,IACC,LSR #8
        STRB    R1,[R4,#1]
        MOV     R1,IACC,LSR #16
        STRB    R1,[R4,#2]
        MOV     R1,IACC,LSR #24
        STRB    R1,[R4,#3]
      ]
BYTSTO  STRB    IACC,[R4]
        MOV     PC,R14
STOREINT1
        SUBS    FACCX,FACCX,#&80       ;subtract bias
        MOVLS   FACC,#0
        BLS     STOREINT0              ;branch if too small
        RSBS    FACCX,FACCX,#32        ;decide whether possible
        BLS     STOREINT2              ;too large (but check carefully for maximum negative integer)
        MOV     FACC,FACC,LSR FACCX    ;shift by exponent
        TEQ     FSIGN,#0               ;check sign
        RSBMI   FACC,FACC,#0           ;negate
STOREINT0
        CMP     R5,#4
        BNE     BYTSTO
      [ NoARMv6 :LOR: NoUnaligned
        TST     R4,#3
        STREQ   IACC,[R4]
        MOVEQ   PC,R14
        STRB    IACC,[R4]
        MOV     R2,IACC,LSR #8
        STRB    R2,[R4,#1]
        MOV     R2,IACC,LSR #16
        STRB    R2,[R4,#2]
        MOV     R2,IACC,LSR #24
        STRB    R2,[R4,#3]
      |
        STR     IACC,[R4]
      ]
        MOV     PC,R14
STOREINT2
        BNE     FOVR                   ;modulus greater than 2^32
        TEQ     FSIGN,#0
        BPL     FOVR                   ;positive
        CMP     FACC,#TFP
        BEQ     STOREINT0              ;-2^31
        B       FOVR
 |
   [ FPOINT=1
        FIXMIZ  IACC,FACC
   |
        BPL     STOREANINT
        ASSERT  FACC = 0
        FTOSIZD S0,FACC
        FPSCRCheck IACC
        FMRS    IACC,S0
   ]
STOREANINT
        CMP     R5,#4
        BNE     BYTSTO
      [ :LNOT: (NoARMv6 :LOR: NoUnaligned)
        STR     IACC,[R4]
        MOV     PC,R14
      |
        TST     R4,#3
        STREQ   IACC,[R4]
        MOVEQ   PC,R14
STORER0MISAL
        MOV     R1,IACC,LSR #8
        STRB    R1,[R4,#1]
        MOV     R1,IACC,LSR #16
        STRB    R1,[R4,#2]
        MOV     R1,IACC,LSR #24
        STRB    R1,[R4,#3]
      ]
BYTSTO  STRB    IACC,[R4]
        MOV     PC,R14
 ]

FPSTOR  TEQ     TYPE,#0
        BPL     FPSTOR1
 [ FPOINT=0
F1STABYR4
        BIC     FGRD,FACC,#&80000000
        ORR     FGRD,FGRD,FSIGN        ;fsign only 0 or &80000000!
      [ NoARMv6 :LOR: NoUnaligned
        TST     R4,#2
        BNE     FPSTORA2
        STRB    FACCX,[R4,#4]
        TST     R4,#1
        STREQ   FGRD,[R4]
        MOVEQ   PC,R14
        LDRB    FSIGN,[R4,#-1]
        ORR     FSIGN,FSIGN,FGRD,LSL #8
        STR     FSIGN,[R4,#-1]
        MOV     FSIGN,FGRD,LSR #24
        STRB    FSIGN,[R4,#3]
        MOV     PC,R14
FPSTORA21
        MOV     R14,TYPE
FPSTORA2
        STRB    FGRD,[R4]
        MOV     FGRD,FGRD,LSR #8
        ORR     FGRD,FGRD,FACCX,LSL #24
        TST     R4,#1
        STRNE   FGRD,[R4,#1]
        MOVNE   PC,R14
        STRB    FGRD,[R4,#1]
        MOV     FGRD,FGRD,LSR #8
        LDRB    FSIGN,[R4,#5]
        ORR     FSIGN,FGRD,FSIGN,LSL #24
        STR     FSIGN,[R4,#2]
      |
        STR     FGRD,[R4] ; unaligned store
        STRB    FACCX,[R4,#4]
      ]
 ELIF FPOINT=1
        STFD    FACC,[R4]
 ELIF FPOINT=2
        FSTD    FACC,[R4]
 |
        ! 1, "Unknown FPOINT setting"
 ]
        MOV     PC,R14
FPSTOR1 BEQ     ERTYPEINT
 [ FPOINT=0
        MOV     TYPE,R14
        BL      IFLT
        BIC     FGRD,FACC,#&80000000
        ORR     FGRD,FGRD,FSIGN        ;fsign only 0 or &80000000!
      [ NoARMv6 :LOR: NoUnaligned
        TST     R4,#2
        BNE     FPSTORA21
        STRB    FACCX,[R4,#4]
        TST     R4,#1
        STREQ   FGRD,[R4]
        MOVEQ   PC,TYPE
        LDRB    FSIGN,[R4,#-1]
        ORR     FSIGN,FSIGN,FGRD,LSL #8
        STR     FSIGN,[R4,#-1]
        MOV     FSIGN,FGRD,LSR #24
        STRB    FSIGN,[R4,#3]
      |
        STR     FGRD,[R4] ; unaligned store
        STRB    FACCX,[R4,#4]
      ]
        MOV     PC,TYPE
 ELIF FPOINT=1
        FLTD    FACC,IACC
        STFD    FACC,[R4]
        MOV     PC,R14
 ELIF FPOINT=2
        ASSERT  FACC = 0
        FMSR    S0,IACC
        FSITOD  FACC,S0
        FSTD    FACC,[R4]
        MOV     PC,R14
 ]

STSTOR  CMP     R5,#256
        BCS     ERVARAR
        TEQ     TYPE,#0
        BNE     ERTYPESTR
        CMP     R5,#128
        BNE     ROPSTOR
        ADD     R3,ARGP,#STRACC
;store string, doing reallocate
;r4: address of string information block (preserved)
;r2/clen: length of string (address of end) (preserved)
;r3: address of start of string (preserved)
;uses r0,r1,r5,r6,r7
STSTORE LDW     IACC,R4,R5,R1          ;entry from function return and local
        LDRB    R1,[R4,#4]             ;get current length
        ADD     R1,R1,#3
        BIC     R1,R1,#3               ;round current length to words
        SUB     R5,CLEN,R3
        ADD     R5,R5,#3
        BIC     R5,R5,#3               ;r5=length required (OR 0)
        CMP     R5,R1
        BEQ     ALLOCY                 ;no need to fiddle with allocation
CONTIGUITY                      *       2
;0 BASIC 1.02 contiguity check
;1 entirely omitted check
;2 contiguity check but no extending allocation
 [ CONTIGUITY=0
        LDR     R6,[ARGP,#FSA]         ;get free space pointer
        ADD     R7,R1,IACC             ;compute end of current string area
        TEQ     R7,R6                  ;does end of current string match free space?
        BEQ     ALLOCEXTEND            ;yes, so just add/subtract a few words
        ADD     R6,ARGP,#FREELIST-4
 ]
 [ CONTIGUITY=2
        LDR     R6,[ARGP,#FSA]         ;get free space pointer
        ADD     R7,R1,IACC             ;compute end of current string area
        TEQ     R7,R6                  ;does end of current string match free space?
        ADD     R6,ARGP,#FREELIST-4
        STREQ   IACC,[ARGP,#FSA]       ;yes, so reduce free space pointer
        BEQ     REALLOCATE2
 ]
 [ CONTIGUITY=1
        ADD     R6,ARGP,#FREELIST-4
 ]
        CMP     R1,#0
        BEQ     REALLOCATE             ;no size to deallocate
;Deallocate the old chunk to the right free list: all possible chunk sizes
;live on their own free list, i.e. one list for sizes 4..256 so that
;reallocation does not involve searching. Also the minimum allocation size is
;one word since entries in the free lists do not need to have the sizes.
COAL                            *       0                      ;coalesce deallocates if 1
FOAL                            *       0                      ;fragment allocates if 1
 [ COAL=1
;Try a small amount of coalescing by checking the top of each list in the
;range 4 to 256-i.

;R0 block addr; R1 block len (words); R2 byte len of new string; R3 addr of new
;R4 sib addr; R5 new len (words); R6 freelists; r7 null
        RSBS    R5,R1,#256
        BEQ     COALESCEZ              ;largest block won't coalesce with anything
        ADD     R1,R1,FACC             ;block end address
COALESCE
        LDR     R7,[R6,R5]
        CMP     R1,R7                  ;end of block = start of entry?
        BEQ     COALESCES
        ADD     R7,R7,R5               ;end of entry
        CMP     FACC,R7                ;= start of block?
        BEQ     COALESCEE
        SUBS    R5,R5,#4
        BEQ     COALESCEX
        LDR     R7,[R6,R5]
        CMP     R1,R7                  ;end of block = start of entry?
        BEQ     COALESCES
        ADD     R7,R7,R5               ;end of entry
        CMP     FACC,R7                ;= start of block?
        BEQ     COALESCEE
        SUBS    R5,R5,#4
        BNE     COALESCE
COALESCEX
        SUB     R1,R1,FACC             ;failed to coalesce: recompute dull freelist entry
 ]
COALESCEZ
        LDR     R7,[R6,R1]             ;deallocate old block by inserting at head of list
;free list has pointer to next or 0
        STR     IACC,[R6,R1]           ;point list to me
        STR     R7,[IACC]              ;point me to rest of list
 [ COAL=1
        SUB     R5,CLEN,R3
        ADD     R5,R5,#3
REALLOCATE2
        BICS    R5,R5,#3               ;recomputed r5
 |
REALLOCATE2
        TEQ     R5,#0
 ]
        BEQ     STSTEX                 ;no size to reallocate for
;reallocate by looking at free list sizes >= R5
REALLOCATE
        LDR     IACC,[R6,R5]
        TEQ     IACC,#0
        LDRNE   R1,[IACC]
        STRNE   R1,[R6,R5]             ;unlink the found block
        BNE     ALLOCOLDQ              ;something on the right list!!!
 [ FOAL=1
        MOV     R7,R5
        MOV     R1,R5
        CMP     R1,#8
        MOVCC   R1,#8
        ADD     R7,R7,R1
        CMP     R7,#256
        BCS     REALLOCATE2
REALLOCATE1
        LDR     FACC,[R6,R7]
        TEQ     FACC,#0
        BNE     ALLOCOLD               ;something on a list!!!
        ADD     R7,R7,#4
        CMP     R7,#256
        BCC     REALLOCATE1
REALLOCATE2
        MOV     R7,#256
        LDR     FACC,[R6,R7]
        TEQ     FACC,#0
        BNE     ALLOCOLD               ;something on biggest list!!!
 ]
        LDR     IACC,[ARGP,#FSA]       ;allocate brand new space
        ADD     R1,IACC,R5
        ADD     R5,R1,#512
        CMP     R5,SP
        STRCC   R1,[ARGP,#FSA]         ;update free space used
        BCC     ALLOCOLDQ
        MOV     R1,#0                  ;won't fit - but have deallocated old string!
        STRB    R1,[R4,#4]             ;mark length as zero....
        B       ALLOCR
 [ COAL=1
COALESCES
        SUB     R1,R1,FACC             ;block length
        LDR     R7,[R7]
        ADD     R1,R1,R5               ;total length to deallocate
        STR     R7,[R6,R5]             ;unlink coalesce-ee
        B       COALESCEZ
COALESCEE
        SUB     FACC,R7,R5             ;replace start of block by start of entry
        LDR     R7,[FACC]
        SUB     R1,R1,FACC             ;total length to deallocate
        STR     R7,[R6,R5]             ;unlink coalesce-ee
        B       COALESCEZ
 ]
 [ CONTIGUITY=0
ALLOCEXTEND
        ADD     R1,FACC,R5
        ADD     R5,R1,#512
        CMP     R5,SP
        STRCC   R1,[ARGP,#FSA]         ;update free space used
        BCC     ALLOCX                 ;ok
        B       ALLOCR
 ]
 [ FOAL=1
ALLOCOLD
        LDR     R1,[FACC]
        STR     R1,[R6,R7]             ;unlink the found block
        SUBS    R7,R7,R5               ;calculate remainder left unused
        LDRNE   R1,[R6,R7]             ;if any remainder, access correct list
        STRNE   R1,[R5,FACC]!          ;attach to tail of block
        STRNE   R5,[R6,R7]             ;insert tail of block address into correct list
 ]
ALLOCOLDQ
      [ NoARMv6 :LOR: NoUnaligned
        STRB    IACC,[R4]
        MOV     R1,IACC,LSR #8
        STRB    R1,[R4,#1]
        MOV     R1,IACC,LSR #16
        STRB    R1,[R4,#2]
        MOV     R1,IACC,LSR #24
        STRB    R1,[R4,#3]             ;new address
      |
        STR     IACC,[R4]
      ]
ALLOCX  MOV     R1,R3
        SUB     R5,CLEN,R3
        STRB    R5,[R4,#4]             ;write new length
STSTMV  LDR     R5,[R1],#4
        STR     R5,[IACC],#4
        CMP     R1,CLEN
        MOVCS   PC,R14
        LDR     R5,[R1],#4
        STR     R5,[IACC],#4
        CMP     R1,CLEN
        BCC     STSTMV
        MOV     PC,R14
STSTEX  SUB     R0,CLEN,R3
        STRB    R0,[R4,#4]             ;write new length
        MOV     PC,R14
ALLOCY  CMP     R5,#0
        BNE     ALLOCX
; STRB R5,[R4,#4] if R5 zero, R1 must have been 0 already!
        MOV     PC,R14
ROPSTOR CMP     R4,#&8000
        BCC     ERDOLL
        ADD     R0,ARGP,#STRACC
        TEQ     R0,CLEN
        BEQ     ROPSTX
ROPMOV  LDRB    R1,[R0],#1
        STRB    R1,[R4],#1
        TEQ     R0,CLEN
        BNE     ROPMOV
ROPSTX  MOV     R1,#13
        STRB    R1,[R4],#1
        MOV     PC,R14

        LNK     Array.s
@


1.17
log
@Add "BASICVFP", a VFP version of BASIC64
Detail:
  See Doc/BASICVFP for overall design/specification
  File changes:
  - !Mk,fd7, !MkClean,fd7, !MkRom,fd7, Makefile - update build scripts to support BASICVFP target
  - Resources/UK/Messages - Add a few new messages
  - hdr/Definitions - Define BASICVFP register usage and a few utility macros
  - hdr/WorkSpace - Define BASICVFP workspace adjustments. Add a few asserts to check some workspace constraints are maintained.
  - s/* - Lots of changes to add support for BASICVFP variant of the module
Admin:
  Tested on Raspberry Pi 1/2/3, BB-xM


Version 1.67. Tagged as 'BASIC-1_67'
@
text
@d997 14
a1010 1
MODES   MOV     AELINE,LINE
d1014 2
a1015 2
        BEQ     MODESTRING
        BLMI    INTEGB
d1017 1
a1017 1
        BEQ     MODESD
d1019 3
a1021 2
        CMP     R0,#256
        BCS     MODESS
d1028 1
a1028 9
        BL      CTALLY
        B       NXT
MODESS  MOV     R1,R0
        MOV     R14,#1
        STRB    R14,[ARGP,#MEMM]
        MOV     R0,#0
        SWI     OS_ScreenMode
        MOV     R14,#0
        STRB    R14,[ARGP,#MEMM]
d1032 2
a1033 2
        STR     R1,[SP,#-20]!
        STR     IACC,[SP,#4]            ; X
d1035 14
a1048 1
        STR     IACC,[SP,#8]            ; Y
d1051 24
d1084 1
a1084 8
        STR     R1,[SP,#12]             ; D
        TEQ     R10,#","
        MOVNE   IACC,#-1
        BNE     MODESDNOFRAME
        BL      EXPR
        BL      INTEGY
MODESDNOFRAME
        STR     IACC,[SP,#16]           ; F
d1087 1
d1089 1
d1091 2
a1092 2
        MOV     R2,#128
        MOV     R3,#3
d1095 6
a1100 6
        ADD     R14,R1,#24
        STMIA   R14,{R2-R5}
        CMP     R6,#4
        MOVLO   R14,R6
        SUBHS   R14,R6,#1
        MOVEQ   R2,#0
d1102 3
a1104 2
        STR     R14,[R1,#12]
        STR     R2,[R1,#20]
d1107 2
a1108 2
        MOV     R0,#0
        SWI     OS_ScreenMode
d1111 8
a1118 2
        BL      CTALLY
        B       NXT
d1122 3
a1124 2
MODESTRING
        MOV     R0,#10
d1126 172
a1297 4
        ADD     R0,ARGP,#STRACC
        MOV     R1,#9
        ADR     R2,WIMPMODETEXT
MODESTRINGLOOP
d1299 18
a1316 4
        LDRB    R3,[R2,#-1]!
        STRB    R3,[R0,#-1]!
        SUBS    R1,R1,#1
        BNE     MODESTRINGLOOP
d1319 2
a1320 1
        SWI     OS_CLI
d1323 28
a1350 5
        BL      CTALLY
        B       NXT
        =       "WimpMode "
WIMPMODETEXT

d1352 3
@


1.16
log
@Fixes and improvements
Detail:
  s/Expr - Clean up some confusing code relating to l-value address offsets in LOOKU5. The old code looked like it contained a bug for BASIC64 (two TEQs back-to-back), but the situations LOOKU5 is called in meant it was fine and the TEQs were actually unnecessary.
  s/HelpMsgs - Fix MSGPRNXXX and friends corrupting R1. Was causing LVAR to crash/malfunction when listing functions/procedures.
  s/Stmt2 - Fix rotated ellipses being completely broken in BASIC64. Looks like this has been broken forever (bug appears to be present in BASIC64 1.05, as supplied with RISC OS 3)
  s/fp2 - Increase MAXDIGS by one for BASIC64, to allow for accurate float -> string conversion for numbers of the form 0.0XXXX when using G format.
  s/fp2 - Rewrite BASIC64's string -> float conversion code. Although the old code was believed to be sufficiently accurate, excessive use of FPA instructions made it rather slow, and a poor fit for any future VFP version of BASIC (the code relied on extended precision for accuracy, which VFP lacks). The new version converts to packed decimal and then relies on FPEmulator to perform the decimal -> float conversion via LDFP (to mirror float -> string conversion via STFP). The reduction in FP instructions makes it many times faster than the original ("Decimal" test runs 5x faster)
  Tests/CALL,ffb, Tests/Math/Array,ffb, Tests/Math/Decimal,ffb, Tests/Math/ELLIPSE,ffb - Add a handful of new test programs.
Admin:
  Tested on BB-xM


Version 1.64. Tagged as 'BASIC-1_64'
@
text
@d57 3
d61 1
d82 3
d86 1
d149 3
d153 1
d176 3
d180 1
d709 1
a709 1
 |
d759 61
d1629 6
d1636 1
a1636 1
        LDFD    FACC,[TYPE]
d1692 1
a1692 1
 |
d1699 11
d2347 1
d2349 7
d2415 4
d2420 1
a2420 1
        STFD    FACC,[R4]
d2446 1
a2446 1
 |
d2450 6
@


1.15
log
@Have BASIC manage its own messages
For the standalone case BASIC[64] will now register its own resources into Resources/BASIC/BASIC[64]Msgs.
For the ROM case BASIC[64] will share them in Resources/BASIC/Messages as before.
This ensures that regardless of the order of loading, and the potential that a ROM and standalone version might be mixed, both ends up seeing the messages its expecting to see.
Tested in a ROM build and softloaded on RISC OS 4.02.

Version 1.57. Tagged as 'BASIC-1_57'
@
text
@d611 13
d736 2
a737 2
;maxy, sheart, maj^2, sin, cos, min, slicew%, y org%, x org%, FILL%
        DVFD    FACC,FACC,F2           ;maxy/sheart
d741 1
a741 1
;sheart, maj^2, sin, cos, junk%, shearx%, slicew%, y org%, x org%, FILL%
@


1.14
log
@Non functional changes
Lined up some comments.
Changed LNK filenames to be Unix style (thing.s rather than s.thing).
Tagged as BASIC-1_57-pre2
@
text
@d68 1
a68 3
        MOV     R0,#4
        SWI     XBASICTrans_Message
        BVC     NXT
d71 4
d154 1
a154 3
        MOV     R0,#5
        SWI     XBASICTrans_Message
        BVC     NXT
d157 4
d178 1
a178 3
        MOV     R0,#6
        SWI     XBASICTrans_Message
        BVC     NXT
d181 4
@


1.13
log
@Redo DO32BIT portions using central macros
When 32 bitted there weren't 26/32 neutral macros around, but can use them now there are allowing one common output binary for disc based BASIC.
Some of the sneaky 26 bit code (eg. relying on address space wrapping at 64MB rather than explicitly clearing bits when computing a jump) adopt the safer 32 bit form even if that does cost 1 extra instruction.
Tagged as BASIC-1_57-pre1
@
text
@d1658 1
a1658 2

OSCL    BL      AEEXPR                 ; handle *command from Basic
d1663 2
a1664 2
        MOV     R14,#3                 ; set   MEMM bit  and r12 bit
        STR     LINE,[ARGP,#R12STORE]  ; save r12
a1669 1

d1674 1
a1674 1
SYSNAME ADD     R1,ARGP,#STRACC        ; convert SWI name to number
a1678 1

d1707 1
a1707 2

SYS     BL      AEEXPR                 ; Handle SYS keyword
d1759 4
a1762 4
        MOVEQ   R14,#3                 ; set   MEMM bit  and r12 bit
        MOVNE   R14,#2                 ; clear MEMM bit, set r12 bit
        STRB    R14,[ARGP,#MEMM]       ; and store it
        STR     LINE,[ARGP,#R12STORE]  ; save r12
d1771 2
a1772 2
        MOV     PC,AELINE              ; go execute SWI ...
                                       ; ... and return here
d1784 1
a1784 2

SYSCALLTO                              ; SYS with TO parameters
d1787 2
a1788 2
        MOV     PC,AELINE              ; go execute SWI ...
                                       ; ... and return here
d1861 1
a1861 2

CALL    BL      AEEXPR                 ; Handle CALL and USR keywords
d1892 1
a1892 2

CALLARMROUT                            ; call routines for CALL and USR
d1895 3
a1897 3
        STR     LINE,[ARGP,#R12STORE]  ; store r12
        MOV     R10,#2                 ; set MEMM bit for r12
        STRB    R10,[ARGP,#MEMM]       ; and store it
a1903 1

a1910 1

d1921 3
a1923 3
        MOV     r14,#0                 ; unset all MEMM flags
        STRB    r14,[ARGP,#MEMM]       ; and store flags
        LDR     r14,[r13],#4           ; now restore r14
@


1.12
log
@  Error handling fix, part 2
Detail:
  LINE pointer r12 is saved & restored when appropriate.

  R12 must only be restored after a CALL, USR, SYS, *Commands or OSCLI aborts.
  To ensure this, the use of the MEMM flag has been changed slightly.

  Before SYS, *Commands and OSCLI are executed there is already a flag set in
  MEMM of x01, indicating that memory may be movable. This is set back to x00
  after they have successfully completed, and after an error in Stmt2.MSGERR.

  1.  The one test of MEMM (in Basic.MOVEMEMORY) was for equality with x01.
      This has been changed to test only for bit 1, not the whole byte.
  2.  Before SYS, *Commands and OSCLI the MEMM flag is now set to x03 not x01.
  3.  MEMM is now additionally set to x02 before CALLed code (also used by USR)
      and unset afterwards.
  4.  Whenever MEMM bit 1 is set, r12 is saved in R12STOR in the workspace.
  5.  In the error handling code, r12 is restored IF bit 1 is set in MEMM.

  Thus r12 can only be restored when it had just been stored, and there has
  been an error in external code. So these changes should be safe!
Admin:
  Changes by Martin Avison

Version 1.53. Not tagged
@
text
@a343 1
 [ DO32BIT = 1
d359 1
a359 2

        CMN     PC,#0
d362 1
a362 2

        CMP     PC,#0
a363 16
 |
READNUM CMP     R5,#"0"
        MOVCC   PC,R14
        CMP     R5,#"9"+1
        BICHIS  PC,R14,#C_Flag
        AND     R0,R5,#&F
READNUMDIG
        LDRB    R5,[R4],#1
        SUBS    R6,R5,#"0"
        ORRCCS  PC,R14,#C_Flag
        CMP     R5,#"9"+1
        ADDCC   R0,R0,R0,LSL #2
        ADDCC   R0,R6,R0,LSL #1        ;smode*2+r0
        BCC     READNUMDIG
 ]

d1794 1
a1794 2
 [ DO32BIT = 1
        MRS     R14,CPSR
a1795 3
 |
        STMFD   SP!,{R0-R9,PC}         ;write parameters back to stack
 ]
d1845 1
a1845 1
        LDR     IACC,[SP,#10*4]
d1847 1
a1847 1
        MOV     IACC,IACC,LSR #28
a1934 1
 [ DO32BIT = 1
a1935 3
 |
        BIC     R14,R0,#&FC000003
 ]
a1936 1

a2145 1

@


1.11
log
@  Additional comments and whitespace changes
Admin:
  Provided by Martin Avison, as part of his error handling changes in the
  following commits. This particular commit should build as binary identical
  to version 1.53.

Version 1.53. Not tagged
@
text
@d1683 2
a1684 1
        MOV     R14,#1
d1782 4
a1785 2
        MOVEQ   R14,#1
        STREQB  R14,[ARGP,#MEMM]
d1925 3
d1952 4
a1955 1
        LDMFD   SP!,{R5,ARGP,AELINE,LINE,R10,R14}
@


1.10
log
@Protect against reading null pointers when using the output of a SWI to fill a string
Detail:
  s/Stmt2 - Code around SYS1STRING now treats null pointers returned by SWIs as being null strings. This protects against a crash if the user expects a SWI to return a string but it decides not to (e.g. due to an error)
Admin:
  Tested on BB-xM with high processor vectors


Version 1.52. Tagged as 'BASIC-1_52'
@
text
@d1677 2
a1678 1
OSCL    BL      AEEXPR
d1689 1
d1694 1
a1694 1
SYSNAME ADD     R1,ARGP,#STRACC
d1699 1
d1728 2
a1729 1
SYS     BL      AEEXPR
d1791 2
a1792 1
        MOV     PC,AELINE
d1804 2
a1805 1
SYSCALLTO
d1808 2
a1809 1
        MOV     PC,AELINE
d1886 2
a1887 1
CALL    BL      AEEXPR
d1918 2
a1919 1
CALLARMROUT
d1928 1
d1936 1
d1945 1
a1945 1
CALL2REAL
d1955 1
d2165 1
@


1.9
log
@  Speed improvements on ARMv6 or later
Detail:
  s.Assembler line 1861: incorrect LDR of 1-byte variable BYTESM. Only bit 2
    of value tested, so no ill effects other than inefficiency on ARMv6.
  s.Stmt2 and s.fp: optimised stores of 5-byte floating-point values to use
    unaligned STR on ARMv6 or later.
  Added ENTRY directive to permit building of GPA debug listing.
Admin:
  Builds but untested.

Version 1.44. Tagged as 'BASIC-1_44'
@
text
@d1828 1
d1830 1
a1830 1
        LDRB    R1,[IACC],#1
@


1.8
log
@  Unaligned load optimisations
Detail:
  * Uses global LDW macro instead of locally-defined LOAD macro (or longhand
    implementations)
  * Some other cases of unaligned loads for v6+ added in places that didn't
    lend themselves to the LDW macro
  * 5-byte (FP) load operation now macroised - the macro skips the unnecessary
    BIC when assembling only for pre-v6 CPUs, or uses unaligned loads for
    v6+ CPUs (unless NoUnaligned global flag is set)
Admin:
  Tested on a rev B7 beagleboard.

Version 1.43. Tagged as 'BASIC-1_43'
@
text
@d2271 1
d2278 1
a2289 3
 |
        STFD    FACC,[R4]
 ]
a2290 1
 [ FPOINT=0
d2305 7
a2312 1
 ]
d2319 1
d2331 4
d2341 1
@


1.7
log
@Lots of code improvements but no changes to the built binary.

This update replaces lots of hard-wired definitions of things such as SWI
names with the ones from the main exports in the build environment. It
should build a binary-identical module to the previous revision.

Author: Rob Sprowson

Version 1.40. Tagged as 'BASIC-1_40'
@
text
@d226 1
a226 1
        LOAD    IACC,R6,R1,R7
d2197 4
d2211 1
d2226 1
d2237 3
d2253 4
d2267 1
d2344 1
a2344 1
STSTORE LOAD    IACC,R4,R5,R1          ;entry from function return and local
d2497 1
d2505 3
@


1.6
log
@  Added a new variant of COLOUR command
Detail:
  Check HELP text in BASICTrans
Admin:
  Updated from Kev's machine.

Version 1.36. Tagged as 'BASIC-1_36'
@
text
@d16 1
d52 2
a53 2
        SWI     GENERATEERROR
        SWI     EXIT
d69 1
a69 1
        SWI     BASICTrans_Message
d71 1
a71 1
        SWI     WRITES
d86 4
a89 4
        MOV     R0,#2
        SWI     WORD                   ;set time
 [ 1=0
        SWI     WORD                   ;time now
d132 2
a133 2
        MOV     R0,#15
        SWI     WORD
d153 1
a153 1
        SWI     BASICTrans_Message
d155 1
a155 1
        SWI     WRITES
d175 1
a175 1
        SWI     BASICTrans_Message
d177 1
a177 1
        SWI     WRITES
d371 1
a371 1
        BICHIS  PC,R14,#CFLAG
d376 1
a376 1
        ORRCCS  PC,R14,#CFLAG
d388 1
a388 1
        SWI     WRITEC
d435 2
a436 2
        SWI     WRITEI+17
        SWI     WRITEC
d446 2
a447 2
        SWI     WRITEI+17
        SWI     WRITEC
d459 2
a460 2
        SWI     WRITEI+19
        SWI     WRITEC
d484 1
a484 1
        SWI     WRITEI+19
d487 1
a487 1
        SWI     WRITEC
d489 1
a489 1
        SWI     WRITEC
d491 1
a491 1
        SWI     WRITEC
d493 1
a493 1
        SWI     WRITEC
d495 1
a495 1
        SWI     WRITEC
d513 1
a513 1
        SWI     CALLAVECTOR
d547 1
a547 1
        SWI     SETCOLOUR
d582 1
a582 1
        SWI     COLOURTRANSSETTEXTCOLOUR
d584 1
a584 1
CURSON  SWI     WRITES
d590 1
a590 1
        SWI     WRITES
d624 1
a624 1
 [ FP=0
d783 2
a784 2
        SWI     WRITEI+18
        SWI     WRITEC
d786 1
a786 1
        SWI     WRITEC
d801 2
a802 2
        SWI     WRITEI+18
        SWI     WRITEC
d804 1
a804 1
        SWI     WRITEC
d846 1
a846 1
        SWI     SETCOLOUR
d894 1
a894 1
        SWI     COLOURTRANSSETGCOL
d933 2
a934 2
        SWI     WRITEI+22
        SWI     WRITEC
d943 1
a943 1
        SWI     SCREENMODE
d992 1
a992 1
        SWI     SCREENMODE
d1014 1
a1014 1
        SWI     CLI
d1065 1
a1065 1
        SWI     MOUSE
d1088 1
a1088 1
        SWI     MOUSE
d1124 2
a1125 2
        MOV     R0,#&15
        SWI     WORD
d1146 2
a1147 2
        MOV     R0,#&15
        SWI     WORD
d1159 2
a1160 2
        MOV     R0,#&15
        SWI     WORD
d1179 1
a1179 1
        SWI     BYTE
d1204 1
a1204 1
        SWI     WRITEI+29
d1236 2
a1237 2
        MOV     R0,#&15
        SWI     WORD
d1312 3
a1314 3
TINTEND SWI     WRITEI+23
        SWI     WRITEI+17
        SWI     WRITEC
d1316 1
a1316 1
        SWI     WRITEC
d1321 1
a1321 1
        SWI     WRITEC
d1333 1
a1333 1
        SWI     WRITEC
d1345 1
a1345 1
        SWI     BYTE
d1348 1
a1348 1
DOPLOT  SWI     XOSPLOT
d1350 1
a1350 1
        SWI     GENERATEERROR
d1352 1
a1352 1
WRITEG  SWI     WRITEC
d1354 1
a1354 1
        SWI     WRITEC
d1358 1
a1358 1
ZEROX1  SWI     WRITEC
d1425 1
a1425 1
        SWI     ARGS
d1438 1
a1438 1
        SWI     BPUT
d1450 1
a1450 1
        SWINE   MULTIPLE
d1456 1
a1456 1
        SWI     OPEN
d1471 1
a1471 1
        SWI     BGET
d1477 1
a1477 1
        SWI     BGET
d1484 1
a1484 1
INPHSL  SWI     BGET
d1492 1
a1492 1
        SWI     BGET
d1494 1
a1494 1
        SWI     BGET
d1496 1
a1496 1
        SWI     BGET
d1498 1
a1498 1
        SWI     BGET
d1507 1
a1507 1
INPHFP  SWI     BGET
d1514 1
a1514 1
 [ FP=0
d1535 1
a1535 1
 [ FP=0
d1567 1
a1567 1
 [ FP=0
d1571 1
a1571 1
        SWI     BPUT
d1581 1
a1581 1
        SWI     BPUT
d1586 1
a1586 1
        SWI     BPUT
d1588 1
a1588 1
        SWI     BPUT
d1590 1
a1590 1
        SWI     BPUT
d1592 1
a1592 1
        SWI     BPUT
d1596 1
a1596 1
        SWI     BPUT
d1600 1
a1600 1
        SWI     BPUT
d1604 1
a1604 1
 [ FP=0
d1612 1
a1612 1
        SWI     BPUT
d1619 1
a1619 1
        SWI     BPUT
d1684 1
a1684 1
        SWI     CLI
d1695 1
a1695 1
        SWI     SWINUMBERFROMSTRING
d1781 1
a1781 1
        ORR     R5,R5,#&EF000000	      ;SWI like what's already there :-)
d1884 1
a1884 1
 [ FP=0
d1967 1
a1967 1
 [ FP=0
d1994 1
a1994 1
 [ FP=0
d2034 1
a2034 1
        SWI     OPEN                   ;osfind
d2044 1
a2044 1
        SWI     MULTIPLE
d2054 1
a2054 1
        SWI     BPUT
d2057 1
a2057 1
        SWI     BGET
d2060 1
a2060 1
        SWI     ARGS
d2073 1
a2073 1
        SWI     FILE
d2082 1
a2082 1
MOSRDCH SWI     READC
d2084 1
a2084 1
MOSNEWL SWI     NEWLINE
d2087 2
a2088 2
        SWIEQ   WRITEI+10
MOSWRCH SWI     WRITEC
d2090 1
a2090 1
MOSWORD SWI     WORD
d2092 1
a2092 1
MOSBYTE SWI     BYTE
d2095 1
a2095 1
        SWI     CLI
d2111 1
a2111 1
        SWIEQ   EXIT                   ;exit here if not QUIT <expression>
d2119 1
a2119 1
        SWI     EXIT
d2192 1
a2192 1
 [ FP=0
d2259 1
a2259 1
 [ FP=0
d2278 1
a2278 1
 [ FP=0
d2296 1
a2296 1
 [ FP=0
d2521 2
a2522 1
        LNK     s.Array
@


1.5
log
@  * Performance tweaks.
  * Comments added.
  * Added DIM LOCAL.
Detail:
  * All of the 408 instances of pushes and pops of a single register
    (i.e. "LDMIA SP!,{PC}") have been replaced with an LDR/STR equivalent,
    which provides a small performance boost on StrongARM-like processors.
  * Some obscure bits of the source have had comments added.
  * The new DIM LOCAL statement has been added:

    Syntax: DIM <numeric variable> LOCAL <numeric expression>

    DIM LOCAL allocates space from the BASIC stack rather than from the
    heap. This means that the space allocated is automatically freed on
    exit from the PROC or FN in which it was claimed.

    As with all LOCAL statements, it must appear in a PROC or FN definition
    and cannot appear inside a structure which uses the stack (i.e. NEXT)
    or after a LOCAL ERROR.

    Much like the manner in which "DIM foo% -1" returns the value of FSA
    without allocating space, "DIM foo% LOCAL -1" returns the value of SP
    at the time of the request, without allocating any space from the stack.
    This can be useful in computing the free space between the top of the
    BASIC heap and the bottom of the stack. Of course, the stack is used by
    BASIC while interpreting the program, so the contents of memory below
    foo% should always be treated as undefined.

    One caveat of using DIM LOCAL is that the stack cannot be moved while
    there are DIM LOCALs defined. END= will return an error and any
    Service_Memory calls will be claimed for the duration of the DIM LOCAL.
Admin:
  Builds and tested on RiscPC.
  Requires BASICTrans-2_06.

Version 1.30. Tagged as 'BASIC-1_30'
@
text
@d472 1
d474 7
d495 18
@


1.4
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.72 or later.
  Requires BuildSys 3.09 or later.
  Requires Env 0.65 or later.

Version 1.27. Tagged as 'BASIC-1_27'
@
text
@d22 1
a22 1
        STMFD   SP!,{IACC}
d27 1
a27 1
        LDMFD   SP!,{R7}
d36 1
a36 1
        STMFD   SP!,{IACC}
d41 1
a41 1
        LDMFD   SP!,{R7}
d183 1
a183 1
        STMFD   SP!,{IACC}
d185 1
a185 1
        STMFD   SP!,{IACC}
d200 1
a200 1
        STMFD   SP!,{IACC}
d203 1
a203 1
        STMFD   SP!,{IACC}
d209 1
a209 1
LMIDD1  STMFD   SP!,{IACC}
d249 1
a249 1
        STMFD   SP!,{IACC}
d257 1
a257 1
        STMFD   SP!,{IACC}
d393 1
a393 1
        STMFD   SP!,{IACC}
d395 1
a395 1
        STMFD   SP!,{IACC}
d397 1
a397 1
        STMFD   SP!,{IACC}
d410 1
a410 1
        STMFD   SP!,{R14}
d417 1
a417 1
        LDMEQFD SP!,{PC}
d421 1
a421 1
        LDMFD   SP!,{PC}
d441 1
a441 1
        STMFD   SP!,{IACC}
d444 1
a444 1
        LDMFD   SP!,{IACC}
d450 1
a450 1
PALETTE STMFD   SP!,{IACC}
d457 1
a457 1
        LDMFD   SP!,{IACC}
d466 1
a466 1
        STMFD   SP!,{IACC}
d471 1
a471 1
        STMFD   SP!,{IACC}
d573 1
a573 1
        STMFD   SP!,{IACC}
d575 1
a575 1
        STMFD   SP!,{IACC}
d577 1
a577 1
        STMFD   SP!,{IACC}
d579 1
a579 1
        STMFD   SP!,{IACC}
d599 1
a599 1
        STMFD   SP!,{R10}
d601 1
a601 1
        LDMFD   SP!,{R10}
d606 1
a606 1
        STMFD   SP!,{R10}
d608 1
a608 1
        LDMFD   SP!,{R10}
d697 1
a697 1
        FIXDZ   IACC,F2
d764 1
a764 1
GCOL2   STMFD   SP!,{IACC}
d770 1
a770 1
        LDMFD   SP!,{IACC}
d876 1
a876 1
        STMFD   SP!,{IACC}
d878 1
a878 1
        STMFD   SP!,{IACC}
d880 1
a880 1
        STMFD   SP!,{IACC}
d1075 1
a1075 1
        STMFD   SP!,{IACC}
d1077 1
a1077 1
        STMFD   SP!,{IACC}
d1079 1
a1079 1
        STMFD   SP!,{IACC}
d1106 1
a1106 1
        STMFD   SP!,{IACC}
d1110 1
a1110 1
        LDMFD   SP!,{IACC}
d1124 1
a1124 1
        STMFD   SP!,{IACC}
d1126 2
a1127 2
        LDMFD   SP!,{R1}
        STMFD   SP!,{IACC}
d1130 1
a1130 1
        STMFD   SP!,{R1}
d1156 1
a1156 1
        STMFD   SP!,{IACC}
d1158 1
a1158 1
        STMFD   SP!,{IACC}
d1160 1
a1160 1
        STMFD   SP!,{IACC}
d1175 1
a1175 1
        STMFD   SP!,{IACC}
d1179 1
a1179 1
        LDMFD   SP!,{R0}               ;X
d1186 1
a1186 1
PLOTER2 STMFD   SP!,{IACC}
d1188 1
a1188 1
        STMFD   SP!,{IACC}
d1201 1
a1201 1
        STMFD   SP!,{IACC}
d1203 2
a1204 2
        LDMFD   SP!,{R1}
        STMFD   SP!,{IACC}
d1207 1
a1207 1
        STMFD   SP!,{R1}
d1216 1
a1216 1
        STMFD   SP!,{IACC}
d1218 1
a1218 1
        STMFD   SP!,{IACC}             ;X
d1220 1
a1220 1
        STMFD   SP!,{IACC}             ;Y
d1223 1
a1223 1
        STMFD   SP!,{IACC}             ;W
d1239 1
a1239 1
        LDMFD   SP!,{R0}
d1259 1
a1259 1
        STMFD   SP!,{IACC}
d1280 1
a1280 1
        STMFD   SP!,{IACC}
d1283 1
a1283 1
        LDMFD   SP!,{IACC}
d1390 1
a1390 1
LPTRA   STMFD   SP!,{R0}
d1392 1
a1392 1
        STMFD   SP!,{IACC}
d1396 2
a1397 2
        LDMFD   SP!,{R1}
        LDMFD   SP!,{R0}
d1404 1
a1404 1
        STMFD   SP!,{R1}
d1410 1
a1410 1
        LDMFD   SP!,{R1}
d1420 1
a1420 1
        LDMFD   SP!,{R1}
d1433 1
a1433 1
        STMFD   SP!,{IACC}             ;save channel as TOS
d1535 1
a1535 1
        STMFD   SP!,{IACC}             ;save handle
d1606 1
a1606 1
        STMFD   SP!,{R10}
d1611 1
a1611 1
        LDMFD   SP!,{R10}
d1620 1
a1620 1
LIBSUB  STMFD   SP!,{R14}
d1644 1
a1644 1
        LDMEQFD SP!,{PC}
d1788 1
a1788 1
        STMFD   SP!,{R7}
d1790 1
a1790 1
        LDMFD   SP!,{R7}
d1890 1
a1890 1
        LDMFD   SP!,{PC}               ;go there!
d1955 1
a1955 1
        LDMFD   SP!,{R4}
d1958 1
a1958 1
        LDMFD   SP!,{PC}
d1964 1
a1964 1
        LDMNEFD SP!,{R4}
d1966 1
a1966 1
        LDMFD   SP!,{PC}
d2213 1
a2213 1
        FIXMIDZ IACC,FACC
@


1.3
log
@* New forms of MODE, COLOUR and GCOL added.
* VDU can now be used as a function to read VDU variables.
* Will surrender application memory for MODE changes etc.

See Doc.Changes for full info.

Version 1.26. Tagged as 'BASIC-1_26'
@
text
@d1777 1
a1777 1
        MRS     ,R14,CPSR
@


1.2
log
@  Some bug fixes and a few new features.
Detail:
  * ALIGN will now force any unused bytes to zero when assembling at
    both P% and O%. This is better than leaving possibly uninitialised
    memory behind (makes diffs very difficult).

  * The assembler now correctly recognises the new 'LR' special variable
    when the L is lower-case.

  * The assembler also has the 'SP' (13) special variable defined.

  * TRACE PROC (and the identical TRACE FN) now flushes the VCACHE when
    it is encountered.

  * TRACE ENDPROC has been implemented to allow the output of 'ENDPROC'
    and 'ENDFN' in the trace output whenever a procedure or function is
    exited. This complements the TRACE PROC/FN functionality.

  * QUIT <expression> has been added to allow a return code to be passed
    back to the called when BASIC exits. This is the /only/ sensible way
    for a BASIC program to set Sys$ReturnCode on exit (others get trashed
    when BASIC removes it's environment handlers).
Admin:
  Tested on a StrongARM RiscPC.

  Some of the reformatting from the last checkin has been improved.

  s.ModuleAB and s.ModuleAB64 have been renamed to s.BASIC105 and
  s.BASIC64 respectively. This will help with the new Brodie Make-o-
  Matik(tm) Makefiles.

Version 1.24. Tagged as 'BASIC-1_24'
@
text
@d387 1
a388 1
        SWI     WRITEC
d422 6
a427 1
COLOUR  BL      AEEXPR
d488 61
a548 5
COLOUR3 BL      AEDONE
        LDMFD   SP!,{R1,R2}
        AND     R0,R0,#255             ;blue
        AND     R1,R1,#255             ;green
        AND     R2,R2,#255             ;red
d552 3
a554 1
        MOV     R3,#0
d556 1
a556 1
        B       NXT
d735 6
a740 1
GCOL    BL      AEEXPR
d779 47
a825 1
GCOL3   STMFD   SP!,{IACC}
d828 21
a848 2
        CMP     R10,#","
        BEQ     GCOL4
d850 11
a860 12
;GCOL r,g,b: b in IACC, g, r on stack
        LDMFD   SP!,{R1,R2}
        MOV     R3,#256                ;dither
        MOV     R4,#0                  ;store action
        B       GCOLCTRANS
GCOL4   STMFD   SP!,{IACC}
        BL      EXPRDN
;GCOL a,r,g,b: b in IACC, g, r, a on stack
        LDMFD   SP!,{R1,R2,R3}
        AND     R4,R3,#255             ;GCOL action
        ORR     R3,R3,#256             ;dither
GCOLCTRANS
d868 1
a868 1
        B       NXT
a895 1
        BL      DONE
d899 3
a901 1
        BL      CTALLY
d904 2
d908 3
d913 51
d966 3
d970 3
d985 2
d988 3
d1655 2
d1658 2
d1661 4
d1673 1
a1673 1
        LDR     R7,[ARGP,#FSA]
d1678 5
a1682 2
        LDMFD   SP!,{R0,R4,R5,R6}
        STMIA   R7!,{R0,R4,R5,R6}      ;move 12 words from stack to free memory
d1684 8
a1691 2
        LDMDB   R7!,{R0,R4,R5,R6}      ;move 12 words back from free memory
        STMFD   SP!,{R0,R4,R5,R6}
d1696 1
a1696 1
        ADD     IACC,SP,#11*4+4+4      ;11 words on stack plus string length plus R4
d1703 3
d1707 2
a1708 1
        STMFD   SP!,{IACC}             ;save action
d1727 1
a1727 1
        STMFD   SP!,{R4}
d1734 1
a1734 1
        LDMFD   SP!,{R4}
a1739 1
 [ STRONGARM = 1
d1741 12
a1752 2
        LDR     R4,[SP,#10*4]          ;old sp
        LDR     R5,[R4,#-4]            ;SWI call value
a1755 12
 |
        ADD     AELINE,ARGP,#STRACC
        LDR     R4,[SP,#10*4]          ;old sp
        LDR     R5,[R4,#-4]            ;SWI call value
        BIC     R5,R5,#&FF000000
        LDR     R6,SYSDATA
        ORR     R6,R6,R5
        STR     R6,[AELINE]
        LDR     R6,SYSDATA+4
        STR     R6,[AELINE,#4]
 ]
        CMP     R10,#TTO
d1761 5
d1768 3
d1783 2
d1812 1
a1812 1
SYS1END STMFD   SP!,{R7}
d1814 1
a1814 1
        LDMFD   SP!,{R7}
d1831 1
a1832 1
        MOV     TYPE,#TINTEGER
d1836 7
a1842 1
SYSEXIT LDR     SP,[SP,#11*4]          ;recover old SP
a1850 4
 [ STRONGARM = 0
SYSDATA SWI     0
        MOV     PC,R14
 ]
@


1.1
log
@  Improved BASIC build structure. No code change.
Detail:
  Makefile strips dependencies during the clean phase.

  Sources moved into an 's' directory.

  All sources reformatted into a more readable layout.
Admin:
  Builds binary-identical versions of BASIC and BASIC64 modules to
  version 1.22

Version 1.23. Tagged as 'BASIC-1_23'
@
text
@d1850 12
a1861 1
QUIT    BL      DONES
d1863 2
@


head	4.6;
access;
symbols
	HdrSrc-2_77:4.6
	HdrSrc-2_76:4.6
	HdrSrc-2_75:4.6
	HdrSrc-2_74:4.6
	HdrSrc-2_73:4.6
	HdrSrc-2_72:4.6
	HdrSrc-2_71:4.6
	HdrSrc-2_70:4.6
	HdrSrc-2_69:4.6
	HdrSrc-2_68:4.6
	HdrSrc-2_67:4.6
	HdrSrc-2_66:4.6
	HdrSrc-2_65:4.6
	HdrSrc-2_64:4.6
	HdrSrc-2_63:4.6
	HdrSrc-2_62:4.6
	HdrSrc-2_61:4.6
	HdrSrc-2_60:4.6
	HdrSrc-2_59:4.6
	HdrSrc-2_58:4.6
	HdrSrc-2_57:4.6
	HdrSrc-2_56:4.6
	HdrSrc-2_55:4.6
	HdrSrc-2_54:4.6
	HdrSrc-2_53:4.6
	HdrSrc-2_52:4.6
	HdrSrc-2_51:4.6
	HdrSrc-2_50:4.6
	HdrSrc-2_49:4.6
	HdrSrc-2_48:4.6
	HdrSrc-2_47:4.6
	HdrSrc-2_46-4_247_2_1:4.6
	XCompile:4.6.0.2
	XCompile_bp:4.6
	HdrSrc-2_46:4.6
	HdrSrc-2_45:4.6
	HdrSrc-2_44:4.6
	HdrSrc-2_43:4.6
	HdrSrc-2_42:4.5
	HdrSrc-2_41:4.5
	HdrSrc-2_40-1:4.5
	HdrSrc-2_40:4.5
	HdrSrc-2_39:4.5
	HdrSrc-2_38:4.5
	HdrSrc-2_37:4.5
	HdrSrc-2_36:4.5
	HdrSrc-2_35:4.5
	HdrSrc-2_34:4.5
	HdrSrc-2_33:4.5
	HdrSrc-2_32:4.5
	HdrSrc-2_31:4.5
	HdrSrc-2_30:4.5
	HdrSrc-2_29:4.5
	HdrSrc-2_28:4.5
	HdrSrc-2_27:4.5
	HdrSrc-2_26:4.5
	HdrSrc-2_25:4.5
	HdrSrc-2_24:4.5
	HdrSrc-2_23:4.5
	HdrSrc-2_22:4.5
	HdrSrc-2_21:4.5
	HdrSrc-2_20:4.5
	HdrSrc-2_19:4.5
	HdrSrc-2_18:4.5
	HdrSrc-2_17:4.5
	HdrSrc-2_16:4.5
	HdrSrc-2_15:4.5
	HdrSrc-2_14:4.5
	HdrSrc-2_13:4.5
	HdrSrc-2_12:4.5
	HdrSrc-2_11:4.5
	HdrSrc-2_10:4.5
	HdrSrc-2_09:4.5
	HdrSrc-2_08:4.5
	HdrSrc-2_07:4.5
	HdrSrc-2_06:4.5
	HdrSrc-2_05:4.5
	HdrSrc-2_04:4.5
	HdrSrc-2_03:4.5
	HdrSrc-2_02:4.5
	HdrSrc-2_01:4.5
	HdrSrc-2_00:4.5
	HdrSrc-1_99:4.5
	HdrSrc-1_98:4.5
	HdrSrc-1_97:4.5
	HdrSrc-1_96:4.5
	HdrSrc-1_95:4.5
	HdrSrc-1_94:4.5
	HdrSrc-1_93:4.5
	HdrSrc-1_92:4.5
	HdrSrc-1_91:4.5
	HdrSrc-1_90:4.5
	HdrSrc-1_89:4.5
	HdrSrc-1_88:4.5
	HdrSrc-1_87:4.5
	HdrSrc-1_86:4.5
	HdrSrc-1_85:4.5
	HdrSrc-1_84:4.4
	HdrSrc-1_83:4.4
	HdrSrc-1_82:4.4
	HdrSrc-1_81:4.4
	HdrSrc-1_80:4.4
	HdrSrc-1_79:4.4
	HdrSrc-1_78:4.4
	HdrSrc-1_77:4.4
	HdrSrc-1_76:4.4
	Cortex_merge:4.4
	HdrSrc-1_62-4_162_2_15:4.4
	HdrSrc-1_75:4.4
	HdrSrc-1_62-4_162_2_14:4.4
	HdrSrc-1_74:4.4
	HdrSrc-1_62-4_162_2_13:4.4
	HdrSrc-1_62-4_162_2_12:4.4
	HdrSrc-1_73:4.4
	HdrSrc-1_72:4.4
	HdrSrc-1_62-4_162_2_11:4.4
	HdrSrc-1_62-4_162_2_10:4.4
	HdrSrc-1_71:4.4
	HdrSrc-1_70:4.4
	HdrSrc-1_69:4.4
	Cortex_bp:4.4
	HdrSrc-1_62-4_162_2_9:4.4
	HdrSrc-1_62-4_162_2_8:4.4
	HdrSrc-1_68:4.4
	HdrSrc-1_62-4_162_2_7:4.4
	HdrSrc-1_62-4_162_2_6:4.4
	HdrSrc-1_62-4_162_2_5:4.4
	HdrSrc-1_62-4_162_2_4:4.4
	HdrSrc-1_67:4.4
	HdrSrc-1_66:4.4
	HdrSrc-1_62-4_162_2_3:4.4
	HdrSrc-1_65:4.4
	HdrSrc-1_64:4.4
	HdrSrc-1_63:4.4
	HdrSrc-1_62-4_162_2_2:4.4
	HdrSrc-1_62-4_162_2_1:4.4
	Cortex:4.4.0.2
	HdrSrc-1_62:4.4
	HdrSrc-1_61:4.4
	HdrSrc-1_60:4.4
	HdrSrc-1_59:4.4
	HdrSrc-1_58:4.4
	HdrSrc-1_57:4.4
	HdrSrc-1_56:4.4
	HdrSrc-1_55:4.4
	HdrSrc-1_54:4.4
	HdrSrc-1_53:4.4
	HdrSrc-1_52:4.4
	HdrSrc-1_51:4.4
	HdrSrc-1_50:4.4
	HdrSrc-1_49:4.4
	HdrSrc-1_48:4.4
	HdrSrc-1_47:4.4
	RO_5_07:4.4
	HdrSrc-1_46:4.4
	HdrSrc-1_45:4.4
	HdrSrc-1_44:4.4
	HdrSrc-1_43:4.4
	HdrSrc-1_42:4.3
	HdrSrc-1_41:4.3
	HdrSrc-1_40:4.3
	HdrSrc-1_39:4.3
	HdrSrc-1_38:4.3
	HdrSrc-1_37:4.3
	HdrSrc-1_36:4.3
	HdrSrc-1_35:4.3
	HdrSrc-1_34:4.2
	HdrSrc-1_33:4.2
	HdrSrc-1_32:4.2
	HdrSrc-1_31:4.2
	HdrSrc-1_30:4.2
	HdrSrc-1_29:4.2
	HdrSrc-1_28:4.2
	HdrSrc-1_27:4.2
	HdrSrc-1_26:4.2
	HdrSrc-1_25:4.2
	HdrSrc-1_24:4.2
	HdrSrc-1_23:4.2
	HdrSrc-1_22:4.2
	HdrSrc-1_21:4.2
	HdrSrc-1_20:4.2
	HdrSrc-1_19:4.2
	HdrSrc-1_18:4.2
	HdrSrc-1_17:4.2
	HdrSrc-1_16:4.2
	HdrSrc-1_15:4.2
	HdrSrc-1_14:4.2
	HdrSrc-1_13:4.2
	HdrSrc-1_12:4.2
	HdrSrc-1_11:4.2
	HdrSrc-0_71-4_72_2_2:4.1
	HdrSrc-1_10:4.2
	HdrSrc-1_09:4.2
	HdrSrc-1_08:4.2
	HdrSrc-1_07:4.2
	HdrSrc-1_06:4.2
	HdrSrc-1_05:4.2
	dellis_autobuild_BaseSW:4.2
	HdrSrc-1_04:4.2
	HdrSrc-1_03:4.2
	HdrSrc-1_02:4.2
	HdrSrc-1_00:4.2
	HdrSrc-0_99:4.2
	HdrSrc-0_71-4_72_2_1:4.1
	Lazarus_Z11:4.1.0.12
	HdrSrc-0_98:4.2
	HdrSrc-0_97:4.2
	HdrSrc-0_95:4.2
	HdrSrc-0_94:4.2
	HdrSrc-0_93:4.2
	HdrSrc-0_92:4.2
	HdrSrc-0_91:4.2
	HdrSrc-0_90:4.2
	HdrSrc-0_89:4.2
	HdrSrc-0_88:4.2
	HdrSrc-0_87:4.2
	HdrSrc-0_86:4.2
	HdrSrc-0_85:4.1
	HdrSrc-0_84:4.1
	HdrSrc-0_83:4.1
	HdrSrc-0_82:4.1
	HdrSrc-0_81:4.1
	HdrSrc-0_80:4.1
	HdrSrc-0_79:4.1
	HdrSrc-0_78:4.1
	HdrSrc-0_77:4.1
	sbrodie_sedwards_16Mar2000:4.1
	HdrSrc-0_76:4.1
	HdrSrc-0_75:4.1
	HdrSrc-0_74:4.1
	HdrSrc-0_73:4.1
	HdrSrc-0_72:4.1
	HdrSrc-0_71:4.1
	HdrSrc-0_70:4.1
	HdrSrc-0_69:4.1
	HdrSrc-0_68:4.1
	HdrSrc-0_67:4.1
	HdrSrc-0_66:4.1
	HdrSrc-0_65:4.1
	HdrSrc-0_64:4.1
	kbracey_32bit_merge:4.1
	HdrSrc-0_63:4.1
	HdrSrc-0_57-4_58_2_9:4.1
	HdrSrc-0_57-4_58_2_8:4.1
	HdrSrc-0_57-4_58_2_7:4.1
	HdrSrc-0_57-4_58_2_6:4.1
	HdrSrc-0_57-4_58_2_5:4.1
	HdrSrc-0_57-4_58_2_4:4.1
	HdrSrc-0_57-4_58_2_3:4.1
	HdrSrc-0_62:4.1
	HdrSrc-0_61:4.1
	HdrSrc-0_60:4.1
	HdrSrc-0_57-4_58_2_2:4.1
	HdrSrc-0_59:4.1
	HdrSrc-0_58:4.1
	HdrSrc-0_57-4_58_2_1:4.1
	kbracey_32bit:4.1.0.10
	HdrSrc-0_57:4.1
	HdrSrc-0_56:4.1
	HdrSrc-0_55:4.1
	HdrSrc-0_54:4.1
	HdrSrc-0_53:4.1
	HdrSrc-0_52:4.1
	HdrSrc-0_51:4.1
	HdrSrc-0_50:4.1
	HdrSrc-0_49:4.1
	HdrSrc-0_48:4.1
	HdrSrc-0_47:4.1
	HdrSrc-0_46:4.1
	HdrSrc-0_45:4.1
	HdrSrc-0_44:4.1
	HdrSrc-0_43:4.1
	HdrSrc-0_42:4.1
	dcotton_autobuild_BaseSW:4.2
	HdrSrc-0_41:4.1
	HdrSrc-0_39:4.1
	HdrSrc-0_38:4.1
	HdrSrc-0_37:4.1
	HdrSrc-0_36:4.1
	HdrSrc-0_35:4.1
	HdrSrc-0_34:4.1
	HdrSrc-0_33:4.1
	HdrSrc-0_32:4.1
	HdrSrc-0_31:4.1
	Ursula_RiscPC_merge:4.1
	HdrSrc-0_30:4.1
	HdrSrc-0_29:4.1
	Ursula_merge:4.1
	HdrSrc-0_28:4.1
	HdrSrc-0_27:4.1
	HdrSrc-0_26:4.1
	HdrSrc-0_25:4.1
	HdrSrc-0_24:4.1
	HdrSrc-0_23:4.1
	HdrSrc-0_22:4.1
	HdrSrc-0_21:4.1
	HdrSrc-0_20:4.1
	HdrSrc-0_19:4.1
	nturton_HdrSrc-0_11:4.1
	HdrSrc-0_18:4.1
	HdrSrc-0_17:4.1
	HdrSrc-0_16:4.1
	HdrSrc-0_15:4.1
	HdrSrc-0_14:4.1
	HdrSrc-0_13:4.1
	HdrSrc-0_12:4.1
	HdrSrc-0_11:4.1
	HdrSrc-0_10:4.1
	HdrSrc-0_09:4.1
	HdrSrc-0_08:4.1
	HdrSrc-0_07:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	HdrSrc-0_06:4.1
	HdrSrc-0_05:4.1
	HdrSrc-0_04:4.1
	HdrSrc-0_03:4.1
	HdrSrc-0_02:4.1
	HdrSrc-0_01:4.1
	nicke_HdrSrc_21_9_98:4.1
	nicke_HdrSrc_21_8_98:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	afrost_NC2_Generic:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2014.06.29.10.29.11;	author jlee;	state Exp;
branches;
next	4.5;
commitid	2ZTRsoFns3cd9pGx;

4.5
date	2011.06.22.00.29.07;	author jlee;	state Exp;
branches;
next	4.4;
commitid	Gfvl8k23Ad0whBov;

4.4
date	2004.05.06.17.26.03;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2002.10.29.21.42.05;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.18.13.14.52;	author bavison;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.21.22;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.21.22;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.36.45;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.35.49;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.32.24;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Add DADebug support to Hdr:Debug
Detail:
  hdr/Debug - Added DADebug support. Doesn't cache the DADebug WriteC pointer in memory anywhere, so can safely be used from a ROM module or if DADebug is loaded/unloaded.
Admin:
  Tested on BB-xM


Version 2.43. Tagged as 'HdrSrc-2_43'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    Debugging routines and macros => &.Hdr.Debug

OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Name  Description
; ----       ----  -----------
; 23-Nov-87  SKS   Added $routine to DREG
; 11-Feb-88  SKS   Added integer printing code
; 19-Feb-88  SKS   Make $nonewline consistent
; 11-Mar-88  SKS   Added DSTRING macro, tweaked others
; 18-Mar-88  SKS   Fixed Tutu_PrintString
; 27-Apr-88  SKS   Fixed DLINE wrt. inversing, DSTRING wrt. r14_svc
; 27-Apr-88  SKS   Fixed DSTRING wrt. r14_svc properly (wrong offset before !)
; 05-May-88  SKS   Fixed DSTRING to give address in invalids
; 10-May-88  SKS   Added Host_Debug so you can switch to Host debug much easier
; 22-Jun-88  SKS   Error trapping for $cc field
; 20-Jul-88  SKS   Fixed DLINE with no arg
; 20-Aug-91  JSR   Add Debug_MaybeIRQ and rewrite to be robust in this mode.
; 19-Aug-92  BC    Added 'Char' mode for printing out a single character
; 26-Nov-93  BC    Removed address validity checking (for Medusa)
; 15-Dec-93  BC    Added all the code and Macros for TML debugging
; 24-Jan-94  BC    Changed macro name InsertHostDebugRoutines to avoid clashing
; 31-Aug-94  SMC   Added file debugging.
; 20-Sep-94  SMC   Added DebugIt module support.
; 18-May-00  BJGA  32-bit compatible.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Use of hdr.Debug: r13 MUST be a FD stack pointer. Do not use otherwise

;       GET     &.Hdr.Debug

; ... defs, etc ...

;       InsertDebugRoutines             ; ensure this is after module header !
;                                       ; conventional to have this just before
;       END
;
; These are the controlling logicals which are provided:
; Debug_MaybeIRQ     -  Set to true to protect against LR_SVC corruptions from SWI calling
; Host_Debug         -  Set to true to send output to the tube
;                       Note that this done by InsertTMLInitialisation
; HostDebugViaTML    -  Set to true to use TML to send debug stream to host
;                       Note that this done by InsertTMLInitialisation
; Debug_File         -  Set to "<filename>" to send debug stream to the specified file
;                       (Host_Debug must be set to false).
; Debug_Module       -  Set to true to use DebugItModule.
; Debug_DADebug      -  Set to true to use DADebug
;
; When using TML it is necessary to initialise the TML code.  To do this the MACRO
; InsertTMLInitialisation must be invoked in the module initialisation code, it assumes
; a valid stack in R13, it preserves all registers EXCEPT R0 if an error occurs.  The
; flags are undefined except V which indicates the error status in the usual way.  If
; the TML hardware is installed in an Expansion card, rather than in the Econet slot
; then the Podule number should be given as an argument to InsertTMLInitialisation.
; Note that InsertTMLInitialisation must be invoked before InsertDebugRoutines.
;
; These are the MACROs provided:
; DREG  <reg>,"string",cc,type  Output reg in 8-digit hex, prefixed by
;                               string (or " " if absent), with newline
;                               absent (,cc present). type specifies alternative
;                               output format: Integer, Nibble, Byte, Word, LongWord,
;                               ByteLine, LongLine, Char
; BREG  <reg>[,"string"[,cc]]   As DREG, but 2-digit hex.
; DLINE ["string"[,cc[,inv]]]   As DREG/BREG without the register. inv<>""
;                               indicates should be inverse video (Tube).
; DSTRING <reg>[,"string"[,cc]] As DREG, but output as a string. NULL
;                               pointer catered for.

                GBLL    Host_Debug
Host_Debug      SETL    False

                GBLL    HostDebugViaTML
HostDebugViaTML SETL    False

                GBLL    Debug_MaybeIRQ
Debug_MaybeIRQ  SETL    False

                GBLS    Debug_File
Debug_File      SETS    ""

                GBLL    Debug_Module
Debug_Module    SETL    False

                GBLL    Debug_DADebug
Debug_DADebug   SETL    False

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Routines for starting and ending debug routines
; Ensure enough stashed so that flags, r0 and lr may be used by debugging routines
; without worry. r1 is set to $reg

        MACRO
$label  DStartDRoutine  $reg
$label  Push    "r0,r1,r2,lr"
  [ :LNOT: ("$reg" = "")
    [ $reg = r13
        ADD     r1, r13, #16
    |
      [ :LNOT: ($reg = r1)
        MOV     r1, $reg
      ]
    ]
  ]
        mymrs  ,r2, CPSR
  [ Debug_MaybeIRQ
        TST     r2, #2_11100
        ORREQ   lr, r2, #SVC_mode   ;   26-bit systems change to SVC_26
        BICNE   lr, r2, #M32_bits   ; \ 32-bit systems change to SVC_32
        ORRNE   lr, lr, #SVC32_mode ; /
        mymsr  ,CPSR_c, lr
        Push    "lr"
  ]
        MEND

        MACRO
$label  DEndDRoutine
$label
  [ Debug_MaybeIRQ
        Pull    "lr"
  ]
        mymsr  ,CPSR_cxsf, r2
        Pull    "r0,r1,r2,lr"
        MEND

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Output a single character
;
; Trashes r0, flags and SVC_lr

; eg. DWriteI F
;     DWriteI " "

        MACRO
$label  DWriteI $char,$cc
  [ Host_Debug :LOR: Debug_DADebug
$label  MOV$cc  r0, #"$char"
    [ HostDebugViaTML :LOR: Debug_DADebug
        BL$cc   TML_WriteC
    |
        SWI$cc  XHostFS_WriteC
    ]
  |
    [ "$Debug_File"<>""
$label  MOV$cc  r0, #"$char"
        BL$cc   File_WriteC
    |
      [ Debug_Module
$label  MOV$cc  r0, #"$char"
        SWI$cc  XDebugIt_WriteC
      |
$label  SWI$cc  XOS_WriteI+"$char"
      ]
    ]
  ]
        MEND

        MACRO
$label  DWriteC $cc
  [ Host_Debug :LOR: Debug_DADebug
    [ HostDebugViaTML :LOR: Debug_DADebug
$label  BL$cc   TML_WriteC
    |
$label  SWI$cc  XHostFS_WriteC
    ]
  |
    [ "$Debug_File"<>""
$label  BL$cc   File_WriteC
    |
      [ Debug_Module
$label  SWI$cc  XDebugIt_WriteC
      |
$label  SWI$cc  XOS_WriteC
      ]
    ]
  ]
        MEND

        MACRO
$label  DNewLine $cc
  [ Host_Debug :LOR: Debug_Module :LOR: Debug_DADebug
$label  BL$cc   Tutu_NewLine
  |
    [ "$Debug_File"<>""
$label  BL$cc   File_NewLine
    |
$label  SWI$cc  XOS_NewLine
    ]
  ]
        MEND

        MACRO
$label  DWrite0 $cc
  [ Host_Debug :LOR: "$Debug_File"<>"" :LOR: Debug_Module :LOR: Debug_DADebug
$label  BL$cc   Tutu_Write0
  |
$label  SWI$cc  XOS_Write0
  ]
        MEND

        MACRO
$label  DWriteN $cc
  [ Host_Debug :LOR: "$Debug_File"<>"" :LOR: Debug_Module :LOR: Debug_DADebug
$label  BL$cc   Tutu_WriteN
  |
$label  SWI$cc  XOS_WriteN
  ]
        MEND


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Output a literal string. Outputs " " if no string specified.
;
; Trashes flags and SVC_lr

; eg. DWriteS "Hello world"

        MACRO
$label  DWriteS $string
  [ "$string" = ""
$label  DWriteI " "
  |
    [ Host_Debug :LOR: "$Debug_File"<>"" :LOR: Debug_Module :LOR: Debug_DADebug
$label  BL      Tutu_WriteS
    |
$label  SWI     XOS_WriteS
    ]
        DCB     "$string",0
        ALIGN
  ]
        MEND



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Output a register with optional string, preserving all state in all modes

; eg. DREG r0,"register zero is "
;     DREG r1,"r1 is ",cc
;     DREG r2,,,Integer
;     DREG r0,,cc
;     DREG r0,,,Word
;     DREG r1,"Thing is ",,Byte
;     DREG r7,"Character received is ",,Char

        MACRO
$label  DREG    $reg, $string, $cc, $routine
$label  DStartDRoutine $reg
        DWriteS "$string"

  [ "$cc" = ""
    [ "$routine" <> ""
        BL      Tutu_$routine
        DNewLine
    |
        BL      Tutu_LongLine
    ]
  |
    [ "$cc" <> "cc"
        ! 1,"Error in DREG with 'cc': '$cc' used instead"
        MEXIT
    ]
    [ "$routine" <> ""
        BL      Tutu_$routine
    |
        BL      Tutu_LongWord
    ]
  ]
        DEndDRoutine
        MEND


        MACRO
$label  BREG    $reg, $string, $cc
$label  DStartDRoutine $reg
        DWriteS "$string"

  [ "$cc" = ""
        BL      Tutu_ByteLine
  |
    [ "$cc" <> "cc"
        ! 1,"Error in BREG with 'cc': '$cc' used instead"
        MEXIT
    ]
        BL      Tutu_Byte
  ]

        DEndDRoutine
        MEND

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Output a string, preserving all state in all modes

        MACRO
$label  DLINE   $string, $cc, $inverse
$label  DStartDRoutine

  [ "$string" <> ""
    [ "$inverse" <> ""
        BL      Tutu_DoInverse
    ]
        DWriteS "$string"
    [ "$cc" = ""
      [ "$inverse" = ""
        DNewLine
      ]
    |
      [ "$cc" <> "cc"
        ! 1,"Error in DLINE with 'cc': '$cc' used instead"
        MEXIT
      ]
    ]
  |
    [ "$cc" = ""
        DNewLine
    ]
  ]
  [ "$inverse" <> ""
        BL      Tutu_DoInverse
    [ "$cc" = ""
        DNewLine
    |
      [ "$cc" <> "cc"
        ! 1,"Error in DLINE with 'cc': '$cc' used instead"
        MEXIT
      ]
    ]
  ]
        DEndDRoutine
        MEND


        MACRO
$label  DSTRING $reg, $string, $cc
$label  DStartDRoutine $reg
        DWriteS "$string.'"
        BL      Tutu_PrintString
        DWriteI "'"
  [ "$cc" = ""
        DNewLine
  |
    [ "$cc" <> "cc"
        ! 1,"Error in DSTRING with 'cc': '$cc' used instead"
        MEXIT
    ]
  ]
        DEndDRoutine
        MEND

        GBLS     DProc_RegList

        MACRO
$label  DEntryS $reglist
        ALIGN
DProc_RegList SETS "$reglist"
 [ "$label" <> ""
$label  ROUT
 ]
 [ "$DProc_RegList" = ""
        STR     lr, [sp, #-4]!
 |
        Push    "$DProc_RegList, lr"
 ]
 [ :LNOT:No32bitCode
        MRS     lr, CPSR
        STR     lr, [sp, #-4]!
 ]
        MEND

        MACRO
$label  DExitS  $cond,$fields
$label
 [ :LNOT:No32bitCode
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000000 :EOR: Cond_$cond + ((%FT01 - (. + 8))/4)
  ]
        LDR     lr, [sp], #4
 [ "$fields"=""
        MSR     CPSR_f, lr
 |
        MSR     CPSR_$fields, lr
 ]
 [ "$DProc_RegList" = ""
        LDR     pc, [sp], #4
 |
        Pull    "$DProc_RegList, pc"
 ]
01
 |
 ; 26-bit version
 [ "$DProc_RegList" = ""
        Pull    pc,$cond,^
 |
        Pull    "$DProc_RegList, pc",$cond,^
 ]
 ]
        MEND

        MACRO
        InsertDebugRoutines
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Tutu's infamous debugging routines

Tutu_LongLine
        DEntryS
        BL      Tutu_LongWord
        DNewLine
        DExitS  , cxsf

Tutu_ByteLine
        DEntryS
        BL      Tutu_Byte
        DNewLine
        DExitS  , cxsf

Tutu_LongWord
        DEntryS "r1"
        MOV     r1, r1, ROR #16
        BL      Tutu_Word
        MOV     r1, r1, ROR #32-16
        BL      Tutu_Word
        DExitS  , cxsf

Tutu_Word
        DEntryS "r1"
        MOV     r1, r1, ROR #8
        BL      Tutu_Byte
        MOV     r1, r1, ROR #32-8
        BL      Tutu_Byte
        DExitS  , cxsf

Tutu_Byte
        DEntryS "r1"
        MOV     r1, r1, ROR #4
        BL      Tutu_Nibble
        MOV     r1, r1, ROR #32-4
        BL      Tutu_Nibble
        DExitS  , cxsf

Tutu_Char
        DEntryS "r1"
        DWriteI "'"
        MOV     r0, r1
        DWriteC
        DWriteI "'"
        DExitS  , cxsf

Tutu_Nibble
        DEntryS
        AND     r0, r1, #15
        CMP     r0, #10
        ADDCC   r0, r0, #"0"
        ADDCS   r0, r0, #"A"-10
        DWriteC
        DExitS  , cxsf

Tutu_Integer
        DEntryS "r0-r2"
        SUB     r13, r13, #16
        MOV     r0, r1
        MOV     r1, r13
        MOV     r2, #16
        SWI     XOS_ConvertInteger4
        DWrite0 VC
        ADD     r13, r13, #16
        DExitS  , cxsf


Tutu_DoInverse
        DEntryS "r0, r1"
        ADR     r0, Tutu_InverseString
        MOV     r1, #?Tutu_InverseString
        DWriteN
        DExitS  , cxsf

  [ Host_Debug :LOR: "$Debug_File"<>"" :LOR: Debug_Module :LOR: Debug_DADebug
        InsertHostCompatibleDebugRoutines
  ]

Tutu_InverseString      DCB     23,17,5,0,0,0,0,0,0,0
Tutu_BadString          DCB     "--- Invalid Address ---", 0
Tutu_NullString         DCB     "<Null>", 0
                        ALIGN

Tutu_PrintString
        DEntryS "r0, r1"

        CMP     r1, #0
        ADREQ   r1, Tutu_NullString

10      LDRB    r0, [r1], #1
        CMP     r0, #32
        DExitS  CC, cxsf
        DWriteC
        BVC     %BT10
        DExitS  , cxsf

20      LDRB    r0, [r1], #1
        CMP     r0, #32
        BCC     %FT30
        DWriteC
        BVC     %BT20
        DExitS  , cxsf

30
        DWriteI " "
        DWriteI "(", VC
        LDRVC   r1, [sp, #4]
        BLVC    Tutu_LongWord
        DWriteI ")", VC
        DExitS  , cxsf
        MEND

        MACRO
        InsertHostCompatibleDebugRoutines

Tutu_WriteS ROUT
        Push    "r1,r2"
        mymrs  ,r2, CPSR
        TST     r2, #2_11100         ; if on a 26-bit system
        BICEQ   lr, lr, #ARM_CC_Mask ; knock out PSR bits
        MOV     r1, lr
        B       %FT20
10
        DWriteC
20
        LDRB    r0, [r1], #1
        TEQ     r0, #0
        BNE     %BT10

        ADD     lr, r1, #3
        BIC     lr, lr, #3
        mymsr  ,CPSR_cxsf, r2
        Pull    "r1,r2"
        MOV     pc, lr

  [ "$Debug_File"=""
Tutu_NewLine ROUT
        DEntryS
        MOV     r0, #13
        DWriteC
        MOV     r0, #10
        DWriteC
        DExitS  , cxsf
  ]

Tutu_Write0 ROUT
        DEntryS "r1"
        MOV     r1, r0
        B       %FT20
10
        DWriteC
20
        LDRB    r0, [r1], #1
        TEQ     r0, #0
        BNE     %BT10
        DExitS  , cxsf

Tutu_WriteN ROUT
        DEntryS "r1,r2"
        ADD     r1, r0, r1
        MOV     r2, r0
        B       %FT20
10
        LDRB    r0, [r2], #1
        DWriteC
20
        CMP     r2, r1
        BLO     %BT10
        DExitS  , cxsf

    [ HostDebugViaTML
TML_WriteC      ROUT
        DEntryS "r11"
        LDR     r11, =TML_BaseAddr
10
        LDRB    r14, TML_TxStatus
        TST     r14, #1
        BEQ     %BT10
        STRB    r0, TML_TxData
        DExitS  , cxsf

        LTORG
    ]

    [ "$Debug_File"<>""
File_WriteC
        DEntryS "r1"
        LDR     r1, Debug_FileHandle
        CMP     r1, #0
        BLEQ    Debug_OpenFile
        SWIVC   XOS_BPut
        DExitS  , cxsf

File_NewLine
        DEntryS "r1"
        MOV     r0, #10
        DWriteC
        MOV     r0, #0                  ; Close file after each new line.
        LDR     r1, Debug_FileHandle
        SWI     XOS_Find
        STR     r0, Debug_FileHandle
        DExitS  , cxsf

Debug_OpenFile
        DEntryS "r0,r2"
        MOV     r0, #&CF                ; Open existing file.
        ADR     r1, Debug_FileName
        SWI     XOS_Find
        MOVVS   r0, #&8F                ; If it doesn't exist then create it.
        SWIVS   XOS_Find
        MOVVC   r1, r0                  ; Read it's extent.
        MOVVC   r0, #2
        SWIVC   XOS_Args
        MOVVC   r0, #1                  ; Set file pointer so we append to it.
        SWIVC   XOS_Args
        STRVC   r1, Debug_FileHandle    ; File opened successfully.
        DExitS  , cxsf                  ; Return r1=file handle.

Debug_FileHandle        DCD     0
Debug_FileName          DCB     "$Debug_File",0
                        ALIGN
    ]

    [ Debug_DADebug
TML_WriteC      ROUT
        DEntryS "r0,r1"
        SWI     &731C0 ; XDADebug_GetWriteCAddress
        MOVVS   r0,#0
        MOVS    r1,r0
        LDRNE   r0,[r13,#4]
        MOVNE   lr,pc
        MOVNE   pc,r1
        DExitS  , cxsf
    ]
        MEND

; End of the debug routines
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        MACRO
$label  InsertTMLInitialisation $slot
  [  "$slot" = "0"                      ; Podule0
TML_BaseAddr    * &3340000+&3000
  |
    [  "$slot" = "1"                    ; Podule1
TML_BaseAddr    * &3344000+&3000
    |
      [  "$slot" = "2"                  ; Podule2
TML_BaseAddr    * &3348000+&3000
      |
        [  "$slot" = "3"                ; Podule3
TML_BaseAddr    * &334C000+&3000
        |                               ; Econet
TML_BaseAddr    * &33A0000
        ]
      ]
    ]
  ]
                ^       0, r11
TML_RxData      #       4
TML_TxData      #       4
TML_Control     #       4
TML_TxStatus    #       4

Host_Debug      SETL    True
HostDebugViaTML SETL    True

$label  Push    "r1-r2, r11, lr"
        mymrs  ,r2, CPSR
  [ Debug_MaybeIRQ
        TST     r2, #2_11100
        ORREQ   lr, r2, #SVC_mode   ;   26-bit systems change to SVC_26
        BICNE   lr, r2, #M32_bits   ; \ 32-bit systems change to SVC_32
        ORRNE   lr, lr, #SVC32_mode ; /
        mymsr  ,CPSR_c, lr
        Push    "lr"
  ]
        LDR     r11, =TML_BaseAddr
        MOV     r1, #2
        STRB    r1, TML_Control         ; Reset
        MOV     r14, #&FF00             ; Delay
10
        STRB    r1, TML_RxData
        SUBS    r14, r14, #1
        BGT     %BT10
        LDRB    r1, TML_Control         ; Check booted hardware OK
        TEQ     r1, #&FF
        BNE     %FT20
        ADR     r0, BadHardWare
        SETV
        B       %20

BadHardWare
        DCD     0
        DCB     "TML hardware not found",0
        ALIGN

        LTORG

20
  [ Debug_MaybeIRQ
        Pull    "lr"
  ]
        mymsr  ,CPSR_cxsf, r2
        Pull    "r1-r2, r11, lr"
        MEND

        OPT     OldOpt
        END
@


4.5
log
@Fix InsertTMLInitialisation macro
Detail:
  hdr/Debug - Corrected a bad use of mymrs from within the InsertTMLInitialisation macro
Admin:
  Macro compiles OK, but is untested


Version 1.85. Tagged as 'HdrSrc-1_85'
@
text
@d66 1
d103 3
d154 1
a154 1
  [ Host_Debug
d156 1
a156 1
    [ HostDebugViaTML
d178 2
a179 2
  [ Host_Debug
    [ HostDebugViaTML
d199 1
a199 1
  [ Host_Debug :LOR: Debug_Module
d212 1
a212 1
  [ Host_Debug :LOR: "$Debug_File"<>"" :LOR: Debug_Module
d221 1
a221 1
  [ Host_Debug :LOR: "$Debug_File"<>"" :LOR: Debug_Module
d241 1
a241 1
    [ Host_Debug :LOR: "$Debug_File"<>"" :LOR: Debug_Module
d495 1
a495 1
  [ Host_Debug :LOR: "$Debug_File"<>"" :LOR: Debug_Module
d643 12
@


4.4
log
@* Added new PaletteV reason codes.
* Changed Hdr:Debug not to rely on Hdr:Proc (to prevent some macro clashes).
* Added Hdr:Machine.STB5

Version 1.43. Tagged as 'HdrSrc-1_43'
@
text
@d673 1
a673 1
        mymrs   r2, CPSR
@


4.3
log
@Addition (manually at present) of new allocations requested from AMG.
Addition of Tungsten machine and Iyonix user interface.
New 1024k ROM image size.

Version 1.35. Tagged as 'HdrSrc-1_35'
@
text
@d364 50
d420 1
a420 1
        EntryS
d423 1
a423 1
        EXITS   , cxsf
d426 1
a426 1
        EntryS
d429 1
a429 1
        EXITS   , cxsf
d432 1
a432 1
        EntryS  "r1"
d437 1
a437 1
        EXITS   , cxsf
d440 1
a440 1
        EntryS  "r1"
d445 1
a445 1
        EXITS   , cxsf
d448 1
a448 1
        EntryS  "r1"
d453 1
a453 1
        EXITS   , cxsf
d456 1
a456 1
        EntryS  "r1"
d461 1
a461 1
        EXITS   , cxsf
d464 1
a464 1
        EntryS
d470 1
a470 1
        EXITS   , cxsf
d473 1
a473 1
        EntryS  "r0-r2"
d481 1
a481 1
        EXITS   , cxsf
d485 1
a485 1
        EntryS  "r0, r1"
d489 1
a489 1
        EXITS   , cxsf
d501 1
a501 1
        EntryS  "r0, r1"
d508 1
a508 1
        EXITS   CC, cxsf
d511 1
a511 1
        EXITS   , cxsf
d518 1
a518 1
        EXITS   , cxsf
d526 1
a526 1
        EXITS   , cxsf
d554 1
a554 1
        EntryS
d559 1
a559 1
        EXITS   , cxsf
d563 1
a563 1
        EntryS  "r1"
d572 1
a572 1
        EXITS   , cxsf
d575 1
a575 1
        EntryS  "r1,r2"
d585 1
a585 1
        EXITS   , cxsf
d589 1
a589 1
        EntryS  "r11"
d596 1
a596 1
        EXITS   , cxsf
d603 1
a603 1
        EntryS  "r1"
d608 1
a608 1
        EXITS   , cxsf
d611 1
a611 1
        EntryS  "r1"
d618 1
a618 1
        EXITS   , cxsf
d621 1
a621 1
        EntryS  "r0,r2"
d633 1
a633 1
        EXITS   , cxsf                  ; Return r1=file handle.
@


4.2
log
@Hdr:Debug made 32-bit compatible.
Hdr:NdrDebug made fully 32-bit compatible (only change is to the code switched
    using the debug_nullterminatedstrings variable).

Version 0.86. Tagged as 'HdrSrc-0_86'
@
text
@d487 1
@


4.1
log
@Initial revision
@
text
@d44 1
d119 1
a119 1
        MOV     r2, pc
d121 5
a125 3
        ORR     lr, r2, #SVC_mode
        TEQP    lr, #0
        NOP
d136 1
a136 4
        TEQP    r2, #0
  [ Debug_MaybeIRQ
        NOP
  ]
d153 1
a153 1
        BL$cc   TML_WriteC   
d370 1
a370 1
        Push    "lr"      ; Get round LDM ^ bug in 3um ARM, XOS errors
d373 1
a373 1
        Pull    "pc",,^
d376 1
a376 1
        Push    "lr"      ; Get round LDM ^ bug in 3um ARM, XOS errors
d379 1
a379 1
        Pull    "pc",,^
d382 1
a382 1
        Push    "r1, lr"
d387 1
a387 1
        Pull    "r1, pc",,^
d390 1
a390 1
        Push    "r1, lr"
d395 1
a395 1
        Pull    "r1, pc",,^
d398 1
a398 1
        Push    "r1, lr"
d403 1
a403 1
        Pull    "r1, pc",,^
d406 1
a406 1
        Push    "r1, lr"
d411 1
a411 1
        Pull    "r1, pc",,^
d414 1
a414 1
        Push    "lr"
d420 1
a420 1
        Pull    "pc",,^
d423 1
a423 1
        Push    "r0-r2, lr"
d431 1
a431 1
        Pull    "r0-r2, pc",,^
d435 1
a435 1
        Push    "r0, r1, lr"
d439 1
a439 1
        Pull    "r0, r1, pc",,^
d451 1
a451 6
        Push    "r0, r1, lr"

  [ False ; Causes problems on Medusa
        TST     r1, #&FC000000          ; Trying to cause address exception ?
        ADRNE   r1, Tutu_BadString
        BNE     %FT20
a452 5
        CMP     r1, #&02000000          ; Or abort, or stiffo ?
        RSBCSS  r14, r1, #&03800000
        ADRCS   r1, Tutu_BadString
        BCS     %FT20
  ]
d458 1
a458 1
        Pull    "r0, r1, pc",CC,^
d461 1
a461 1
        Pull    "r0, r1, pc",,^
d468 1
a468 1
        Pull    "r0, r1, pc",,^
d476 1
a476 1
        Pull    "r0, r1, pc",,^
d483 4
a486 2
        Push    "r1,lr"
        BIC     r1, lr, #ARM_CC_Mask
d495 5
a499 6
        LDR     lr, [sp, #4]
        AND     lr, lr, #ARM_CC_Mask
        ADD     r0, r1, #3
        BIC     r0, r0, #3
        LDR     r1, [sp], #8
        ORRS    pc, lr, r0
d503 1
a503 1
        Push    "lr"
d508 1
a508 1
        Pull    "pc",,^
d512 1
a512 1
        Push    "r1,lr"
d521 1
a521 1
        Pull    "r1,pc",,^
d524 1
a524 1
        Push    "r1,r2,lr"
d534 1
a534 1
        Pull    "r1,r2,pc",,^
d538 1
a538 1
        Push    "r11, lr"
d545 1
a545 1
        Pull    "r11, pc",,^
d552 1
a552 1
        Push    "r1,lr"
d557 1
a557 1
        Pull    "r1,pc",,^
d560 1
a560 1
        Push    "r1,lr"
d567 2
a568 2
        Pull    "r1,pc",,^
        
d570 1
a570 1
        Push    "r0,r2,lr"
d582 1
a582 1
        Pull    "r0,r2,pc"              ; Return r1=file handle.
d622 1
a622 1
        MOV     r2, pc
d624 5
a628 3
        ORR     lr, r2, #SVC_mode
        TEQP    lr, #0
        NOP
a655 4
        TEQP    r2, #0
        NOP
  |
        TEQP    r2, #0
d657 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.15;
access;
symbols
	HdrSrc-2_77:4.15
	HdrSrc-2_76:4.15
	HdrSrc-2_75:4.15
	HdrSrc-2_74:4.15
	HdrSrc-2_73:4.15
	HdrSrc-2_72:4.15
	HdrSrc-2_71:4.15
	HdrSrc-2_70:4.15
	HdrSrc-2_69:4.15
	HdrSrc-2_68:4.15
	HdrSrc-2_67:4.15
	HdrSrc-2_66:4.15
	HdrSrc-2_65:4.15
	HdrSrc-2_64:4.14
	HdrSrc-2_63:4.14
	HdrSrc-2_62:4.13
	HdrSrc-2_61:4.13
	HdrSrc-2_60:4.13
	HdrSrc-2_59:4.13
	HdrSrc-2_58:4.13
	HdrSrc-2_57:4.13
	HdrSrc-2_56:4.13
	HdrSrc-2_55:4.13
	HdrSrc-2_54:4.13
	HdrSrc-2_53:4.13
	HdrSrc-2_52:4.13
	HdrSrc-2_51:4.13
	HdrSrc-2_50:4.13
	HdrSrc-2_49:4.13
	HdrSrc-2_48:4.13
	HdrSrc-2_47:4.13
	HdrSrc-2_46-4_247_2_1:4.13.2.1
	XCompile:4.13.0.2
	XCompile_bp:4.13
	HdrSrc-2_46:4.13
	HdrSrc-2_45:4.13
	HdrSrc-2_44:4.13
	HdrSrc-2_43:4.13
	HdrSrc-2_42:4.13
	HdrSrc-2_41:4.13
	HdrSrc-2_40-1:4.13
	HdrSrc-2_40:4.13
	HdrSrc-2_39:4.13
	HdrSrc-2_38:4.13
	HdrSrc-2_37:4.13
	HdrSrc-2_36:4.13
	HdrSrc-2_35:4.13
	HdrSrc-2_34:4.13
	HdrSrc-2_33:4.13
	HdrSrc-2_32:4.13
	HdrSrc-2_31:4.13
	HdrSrc-2_30:4.13
	HdrSrc-2_29:4.13
	HdrSrc-2_28:4.13
	HdrSrc-2_27:4.13
	HdrSrc-2_26:4.13
	HdrSrc-2_25:4.12
	HdrSrc-2_24:4.11
	HdrSrc-2_23:4.11
	HdrSrc-2_22:4.11
	HdrSrc-2_21:4.11
	HdrSrc-2_20:4.11
	HdrSrc-2_19:4.11
	HdrSrc-2_18:4.11
	HdrSrc-2_17:4.11
	HdrSrc-2_16:4.11
	HdrSrc-2_15:4.11
	HdrSrc-2_14:4.11
	HdrSrc-2_13:4.11
	HdrSrc-2_12:4.11
	HdrSrc-2_11:4.11
	HdrSrc-2_10:4.11
	HdrSrc-2_09:4.11
	HdrSrc-2_08:4.11
	HdrSrc-2_07:4.11
	HdrSrc-2_06:4.11
	HdrSrc-2_05:4.11
	HdrSrc-2_04:4.11
	HdrSrc-2_03:4.11
	HdrSrc-2_02:4.11
	HdrSrc-2_01:4.11
	HdrSrc-2_00:4.11
	HdrSrc-1_99:4.11
	HdrSrc-1_98:4.11
	HdrSrc-1_97:4.11
	HdrSrc-1_96:4.11
	HdrSrc-1_95:4.11
	HdrSrc-1_94:4.11
	HdrSrc-1_93:4.11
	HdrSrc-1_92:4.11
	HdrSrc-1_91:4.11
	HdrSrc-1_90:4.11
	HdrSrc-1_89:4.11
	HdrSrc-1_88:4.11
	HdrSrc-1_87:4.11
	HdrSrc-1_86:4.11
	HdrSrc-1_85:4.11
	HdrSrc-1_84:4.11
	HdrSrc-1_83:4.11
	HdrSrc-1_82:4.11
	HdrSrc-1_81:4.11
	HdrSrc-1_80:4.11
	HdrSrc-1_79:4.11
	HdrSrc-1_78:4.11
	HdrSrc-1_77:4.11
	HdrSrc-1_76:4.11
	Cortex_merge:4.11
	HdrSrc-1_62-4_162_2_15:4.11
	HdrSrc-1_75:4.11
	HdrSrc-1_62-4_162_2_14:4.11
	HdrSrc-1_74:4.11
	HdrSrc-1_62-4_162_2_13:4.11
	HdrSrc-1_62-4_162_2_12:4.11
	HdrSrc-1_73:4.11
	HdrSrc-1_72:4.11
	HdrSrc-1_62-4_162_2_11:4.11
	HdrSrc-1_62-4_162_2_10:4.11
	HdrSrc-1_71:4.11
	HdrSrc-1_70:4.11
	HdrSrc-1_69:4.11
	Cortex_bp:4.11
	HdrSrc-1_62-4_162_2_9:4.11
	HdrSrc-1_62-4_162_2_8:4.11
	HdrSrc-1_68:4.11
	HdrSrc-1_62-4_162_2_7:4.11
	HdrSrc-1_62-4_162_2_6:4.11
	HdrSrc-1_62-4_162_2_5:4.11
	HdrSrc-1_62-4_162_2_4:4.11
	HdrSrc-1_67:4.11
	HdrSrc-1_66:4.11
	HdrSrc-1_62-4_162_2_3:4.11
	HdrSrc-1_65:4.11
	HdrSrc-1_64:4.11
	HdrSrc-1_63:4.11
	HdrSrc-1_62-4_162_2_2:4.11
	HdrSrc-1_62-4_162_2_1:4.11
	Cortex:4.11.0.2
	HdrSrc-1_62:4.11
	HdrSrc-1_61:4.11
	HdrSrc-1_60:4.11
	HdrSrc-1_59:4.11
	HdrSrc-1_58:4.11
	HdrSrc-1_57:4.11
	HdrSrc-1_56:4.11
	HdrSrc-1_55:4.11
	HdrSrc-1_54:4.11
	HdrSrc-1_53:4.11
	HdrSrc-1_52:4.11
	HdrSrc-1_51:4.11
	HdrSrc-1_50:4.11
	HdrSrc-1_49:4.11
	HdrSrc-1_48:4.11
	HdrSrc-1_47:4.11
	RO_5_07:4.11
	HdrSrc-1_46:4.11
	HdrSrc-1_45:4.11
	HdrSrc-1_44:4.11
	HdrSrc-1_43:4.11
	HdrSrc-1_42:4.11
	HdrSrc-1_41:4.11
	HdrSrc-1_40:4.11
	HdrSrc-1_39:4.11
	HdrSrc-1_38:4.11
	HdrSrc-1_37:4.11
	HdrSrc-1_36:4.11
	HdrSrc-1_35:4.11
	HdrSrc-1_34:4.11
	HdrSrc-1_33:4.11
	HdrSrc-1_32:4.11
	HdrSrc-1_31:4.11
	HdrSrc-1_30:4.11
	HdrSrc-1_29:4.11
	HdrSrc-1_28:4.11
	HdrSrc-1_27:4.11
	HdrSrc-1_26:4.11
	HdrSrc-1_25:4.11
	HdrSrc-1_24:4.11
	HdrSrc-1_23:4.11
	HdrSrc-1_22:4.10
	HdrSrc-1_21:4.10
	HdrSrc-1_20:4.10
	HdrSrc-1_19:4.10
	HdrSrc-1_18:4.10
	HdrSrc-1_17:4.10
	HdrSrc-1_16:4.10
	HdrSrc-1_15:4.10
	HdrSrc-1_14:4.10
	HdrSrc-1_13:4.10
	HdrSrc-1_12:4.10
	HdrSrc-1_11:4.10
	HdrSrc-0_71-4_72_2_2:4.4
	HdrSrc-1_10:4.10
	HdrSrc-1_09:4.10
	HdrSrc-1_08:4.9
	HdrSrc-1_07:4.9
	HdrSrc-1_06:4.9
	HdrSrc-1_05:4.9
	dellis_autobuild_BaseSW:4.9
	HdrSrc-1_04:4.9
	HdrSrc-1_03:4.9
	HdrSrc-1_02:4.9
	HdrSrc-1_00:4.9
	HdrSrc-0_99:4.9
	HdrSrc-0_71-4_72_2_1:4.4
	Lazarus_Z11:4.4.0.2
	HdrSrc-0_98:4.9
	HdrSrc-0_97:4.9
	HdrSrc-0_95:4.9
	HdrSrc-0_94:4.9
	HdrSrc-0_93:4.9
	HdrSrc-0_92:4.9
	HdrSrc-0_91:4.9
	HdrSrc-0_90:4.9
	HdrSrc-0_89:4.9
	HdrSrc-0_88:4.9
	HdrSrc-0_87:4.8
	HdrSrc-0_86:4.8
	HdrSrc-0_85:4.8
	HdrSrc-0_84:4.7
	HdrSrc-0_83:4.6
	HdrSrc-0_82:4.5
	HdrSrc-0_81:4.5
	HdrSrc-0_80:4.5
	HdrSrc-0_79:4.5
	HdrSrc-0_78:4.4
	HdrSrc-0_77:4.4
	sbrodie_sedwards_16Mar2000:4.4
	HdrSrc-0_76:4.4
	HdrSrc-0_75:4.4
	HdrSrc-0_74:4.4
	HdrSrc-0_73:4.4
	HdrSrc-0_72:4.4
	HdrSrc-0_71:4.4
	HdrSrc-0_70:4.3
	HdrSrc-0_69:4.3
	HdrSrc-0_68:4.3
	HdrSrc-0_67:4.3
	HdrSrc-0_66:4.3
	HdrSrc-0_65:4.3
	HdrSrc-0_64:4.2
	kbracey_32bit_merge:4.1.10.6
	HdrSrc-0_63:4.2
	HdrSrc-0_57-4_58_2_9:4.1.10.6
	HdrSrc-0_57-4_58_2_8:4.1.10.6
	HdrSrc-0_57-4_58_2_7:4.1.10.5
	HdrSrc-0_57-4_58_2_6:4.1.10.5
	HdrSrc-0_57-4_58_2_5:4.1.10.4
	HdrSrc-0_57-4_58_2_4:4.1.10.3
	HdrSrc-0_57-4_58_2_3:4.1.10.3
	HdrSrc-0_62:4.1
	HdrSrc-0_61:4.1
	HdrSrc-0_60:4.1
	HdrSrc-0_57-4_58_2_2:4.1.10.2
	HdrSrc-0_59:4.1
	HdrSrc-0_58:4.1
	HdrSrc-0_57-4_58_2_1:4.1.10.1
	kbracey_32bit:4.1.0.10
	HdrSrc-0_57:4.1
	HdrSrc-0_56:4.1
	HdrSrc-0_55:4.1
	HdrSrc-0_54:4.1
	HdrSrc-0_53:4.1
	HdrSrc-0_52:4.1
	HdrSrc-0_51:4.1
	HdrSrc-0_50:4.1
	HdrSrc-0_49:4.1
	HdrSrc-0_48:4.1
	HdrSrc-0_47:4.1
	HdrSrc-0_46:4.1
	HdrSrc-0_45:4.1
	HdrSrc-0_44:4.1
	HdrSrc-0_43:4.1
	HdrSrc-0_42:4.1
	dcotton_autobuild_BaseSW:4.11
	HdrSrc-0_41:4.1
	HdrSrc-0_39:4.1
	HdrSrc-0_38:4.1
	HdrSrc-0_37:4.1
	HdrSrc-0_36:4.1
	HdrSrc-0_35:4.1
	HdrSrc-0_34:4.1
	HdrSrc-0_33:4.1
	HdrSrc-0_32:4.1
	HdrSrc-0_31:4.1
	Ursula_RiscPC_merge:4.1
	HdrSrc-0_30:4.1
	HdrSrc-0_29:4.1
	Ursula_merge:4.1
	HdrSrc-0_28:4.1
	HdrSrc-0_27:4.1
	HdrSrc-0_26:4.1
	HdrSrc-0_25:4.1
	HdrSrc-0_24:4.1
	HdrSrc-0_23:4.1
	HdrSrc-0_22:4.1
	HdrSrc-0_21:4.1
	HdrSrc-0_20:4.1
	HdrSrc-0_19:4.1
	nturton_HdrSrc-0_11:4.1
	HdrSrc-0_18:4.1
	HdrSrc-0_17:4.1
	HdrSrc-0_16:4.1
	HdrSrc-0_15:4.1
	HdrSrc-0_14:4.1
	HdrSrc-0_13:4.1
	HdrSrc-0_12:4.1
	HdrSrc-0_11:4.1
	HdrSrc-0_10:4.1
	HdrSrc-0_09:4.1
	HdrSrc-0_08:4.1
	HdrSrc-0_07:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	HdrSrc-0_06:4.1
	HdrSrc-0_05:4.1
	HdrSrc-0_04:4.1
	HdrSrc-0_03:4.1
	HdrSrc-0_02:4.1
	HdrSrc-0_01:4.1
	nicke_HdrSrc_21_9_98:4.1
	nicke_HdrSrc_21_8_98:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	afrost_NC2_Generic:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2016.06.12.18.54.02;	author jlee;	state Exp;
branches;
next	4.14;
commitid	fXRc9eBUrhZtZcaz;

4.14
date	2016.05.28.18.30.08;	author jlee;	state Exp;
branches;
next	4.13;
commitid	DbPnp2msZ7Galh8z;

4.13
date	2013.03.23.20.11.15;	author bavison;	state Exp;
branches
	4.13.2.1;
next	4.12;
commitid	uzJEZhKdPyLAfXIw;

4.12
date	2013.03.23.19.48.37;	author bavison;	state Exp;
branches;
next	4.11;
commitid	MZKqQOCl4XZP7XIw;

4.11
date	2001.05.11.20.04.49;	author bavison;	state Exp;
branches;
next	4.10;

4.10
date	2000.11.16.10.52.43;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	2000.06.01.10.56.00;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	2000.05.17.14.49.59;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2000.05.17.13.12.45;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2000.05.15.09.06.40;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.04.04.10.04.01;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.01.26.13.53.09;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.12.09.16.30.00;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.11.26.14.32.29;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.21.26;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.10.1;
next	;

4.13.2.1
date	2014.09.24.20.51.15;	author bavison;	state Exp;
branches;
next	;
commitid	FLu4L8VxkYPcNDRx;

4.1.1.1
date	96.11.05.09.21.26;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.37.05;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.36.46;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.32.46;	author nturton;	state Exp;
branches;
next	;

4.1.10.1
date	99.11.05.13.17.07;	author kbracey;	state Exp;
branches;
next	4.1.10.2;

4.1.10.2
date	99.11.10.13.33.16;	author kbracey;	state Exp;
branches;
next	4.1.10.3;

4.1.10.3
date	99.11.19.21.38.11;	author sbrodie;	state Exp;
branches;
next	4.1.10.4;

4.1.10.4
date	99.11.22.12.59.12;	author sbrodie;	state Exp;
branches;
next	4.1.10.5;

4.1.10.5
date	99.11.23.17.26.34;	author kbracey;	state Exp;
branches;
next	4.1.10.6;

4.1.10.6
date	99.11.26.10.30.03;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.15
log
@Add new PSR manipulation macros, optimised for 32bit machines
Detail:
  Many of our existing PSR manipulation macros (specifically, ones used for changing mode or controlling interrupts) are based around the code sequences you'd typically use on a 26bit system. Although this has worked well in terms of producing a 32bit version of the OS, it's also left us with macros that can be sub-optimal for 32bit machines, or are inconvenient to use due to the potential of corrupting other PSR flags
  This change adds a new set of macros which are designed and optimised for 32bit-only targets, but can still fall back to 26/32bit neutral or 26bit-only configurations
  hdr/CPU/Generic32:
  - Add the new macros (SEI, CLI, SetModeSEI, SetModeCLI & variants).
  - Improve existing SetMode macro to add 26bit compatibility, and to add an extra optimisation for pre-ARMv6 (emit single MSR if IRQ state is known)
  - Improve SCPSR to allow the source mode to be any 32bit mode
  - Fix conditional 26bit/32bit neutral SCPSR - the 32bit check TEQ corrupts NZCV so we can't do conditional execution on $cond after it (and we've already branched on the opposite condition anyway)
  - Fix 26bit/32bit neutral SCPSR to preserve NZCV when following the MSR code path
  - Make CLRPSR and SETPSR just call through to SCPSR - in terms of output the first two have no advantages over SCPSR
  - Update WritePSRc documentation to reflect that it can now be used in any (non-USR) source mode
  hdr/CPU/Generic26:
  - Update WritePSRc documentation to match Generic32
Admin:
  Tested on Raspberry Pi
  Output of new macros manually checked for various machine types (RPi, Tungsten, All, 26)


Version 2.65. Tagged as 'HdrSrc-2_65'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    Generic CPU Specific Definitions

OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

 [ :LNOT: :DEF: Included_Hdr_CPU_Generic26
        GBLL    Included_Hdr_CPU_Generic26
Included_Hdr_CPU_Generic26 SETL {TRUE}

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************
;
; Date       Name          Description
; ----       ----          -----------
; 13-Jul-93  JRoach        Created
; 30-Jun-94  AMcC          Restore OPT
; 05-Nov-99  KBracey       Keep an eye on No26bitCode flag

 [ :LNOT: :DEF: Included_Hdr_Machine_Machine
        GET     Hdr:Machine.<Machine>
 ]

        ; Standard register names

r0      RN      0
R0      RN      r0
r1      RN      1
R1      RN      r1
r2      RN      2
R2      RN      r2
r3      RN      3
R3      RN      r3
r4      RN      4
R4      RN      r4
r5      RN      5
R5      RN      r5
r6      RN      6
R6      RN      r6
r7      RN      7
R7      RN      r7
r8      RN      8
R8      RN      r8
r9      RN      9
R9      RN      r9
r10     RN      10
R10     RN      r10
r11     RN      11
R11     RN      r11
r12     RN      12
R12     RN      r12
r13     RN      13
R13     RN      r13
r14     RN      14
R14     RN      r14
r15     RN      15
R15     RN      r15


        ; Special names for the banked registers

r13_usr RN      13
r14_usr RN      14

r8_fiq  RN      8
r9_fiq  RN      9
r10_fiq RN      10
r11_fiq RN      11
r12_fiq RN      12
r13_fiq RN      13
r14_fiq RN      14

r13_irq RN      13
r14_irq RN      14

r13_svc RN      13
r14_svc RN      14


        ; Standard register synonyms

lr      RN      r14                     ; Link Register
LR      RN      r14
lr_usr  RN      r14_usr
lr_fiq  RN      r14_fiq
lr_irq  RN      r14_irq
lr_svc  RN      r14_svc
link    RN      r14
LINK    RN      r14

pc      RN      r15                     ; Program Counter
PC      RN      r15

 [ :LNOT: No26bitCode
psr     RN      r15                     ; Processor Status Register
PSR     RN      r15
 ]


        ; Registers for the ARM Procedure Calling Standard

sl      RN      10
SL      RN      10
fp      RN      11
FP      RN      11
IP      RN      12
ip      RN      12


        ; Condition code symbols

Cond_EQ *       0  :SHL: 28
Cond_NE *       1  :SHL: 28
Cond_CS *       2  :SHL: 28
Cond_HS * Cond_CS
Cond_CC *       3  :SHL: 28
Cond_LO * Cond_CC
Cond_MI *       4  :SHL: 28
Cond_PL *       5  :SHL: 28
Cond_VS *       6  :SHL: 28
Cond_VC *       7  :SHL: 28
Cond_HI *       8  :SHL: 28
Cond_LS *       9  :SHL: 28
Cond_GE *       10 :SHL: 28
Cond_LT *       11 :SHL: 28
Cond_GT *       12 :SHL: 28
Cond_LE *       13 :SHL: 28
Cond_AL *       14 :SHL: 28
Cond_   * Cond_AL
Cond_NV *       15 :SHL: 28

        ; Flag position specifiers for the PSR

N_bit_number    *       31
Z_bit_number    *       30
C_bit_number    *       29
V_bit_number    *       28
I_bit_number    *       27
F_bit_number    *       26


        ; Flag value specifiers for the PSR

N_bit           *       1 :SHL: N_bit_number
Z_bit           *       1 :SHL: Z_bit_number
C_bit           *       1 :SHL: C_bit_number
V_bit           *       1 :SHL: V_bit_number
I_bit           *       1 :SHL: I_bit_number
F_bit           *       1 :SHL: F_bit_number
M_bits          *       2_11


        ; Processor mode values for the PSR

USR_mode        *      2_00
FIQ_mode        *      2_01
IRQ_mode        *      2_10
SVC_mode        *      2_11

ARM_CC_Mask     *   &FC000003           ; Processor condition flags + mode bits


        ; Co_processor number allocations

                        ^       0
ARMCoProc_Reserved      #       1       ;  0, Reserved by Acorn
ARMCoProc_FPU           #       1       ;  1, All floating point systems
ARMCoProc_FPUextra      #       1       ;  2, For extra FP instructions
ARMCoProc_3             #       1       ;  3,
ARMCoProc_4             #       1       ;  4,
ARMCoProc_5             #       1       ;  5,
ARMCoProc_6             #       1       ;  6,
ARMCoProc_OMBRA         #       1       ;  7, Olivetti/Acorn 80x86
ARMCoProc_TestHardware  #       1       ;  8, Acorn
ARMCoProc_9             #       1       ;  9,
ARMCoProc_10            #       1       ; 10,
ARMCoProc_11            #       1       ; 11,
ARMCoProc_12            #       1       ; 12,
ARMCoProc_13            #       1       ; 13,
ARMCoProc_14            #       1       ; 14,
ARMCoProc_CacheControl  #       1       ; 15, Part of the ARM3 CPU


        ; 26 bit processor specific macro definitions

; ************************************************************
; ***  BSR - Branch to subroutine saving R14 on the stack  ***
; ************************************************************
        MACRO
$label  BSR     $dest
$label  Push    R14
        BL      $dest
        Pull    R14
        MEND

 [ No32bitCode
; ************************************************
; ***  CLC - Clear carry flag - will set nzcv  ***
; ************************************************
        MACRO
$label  CLC     $cond
$label  CMN$cond pc, #0
        MEND

; ***********************************************
; ***  CLRPSR - Clear bits in PSR from the    ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  CLRPSR  $bits, $regtmp, $cond, $oldpsr
$label
        [ "$oldpsr" <> ""
        MOV$cond   $oldpsr, pc
        ]
        MVN$cond   $regtmp, #$bits
        TST$cond.P $regtmp, pc
        MEND

; **************************************************
; *** CLRV - Clear overflow flag - will set nzCv ***
; **************************************************
        MACRO
$label  CLRV    $cond
$label  CMP$cond pc, #0
        MEND

; **********************************************************************************
; ***  PHPSEI - Disable IRQs, saving an old interrupt state indicator in a       ***
; ***  register, default R14.  Note that this code preserves the C and V flags.  ***
; **********************************************************************************
        MACRO
$label  PHPSEI  $register=R14, $regtmp  ; (we don't use regtmp, 32-bit one does)
        LCLS    usereg
  [     "$register" = ""
usereg  SETS    "R14"
  |
usereg  SETS    "$register"
  ]
$label  MOV     $usereg, #I_bit
        TST     $usereg, PC             ; is I_bit set ?
        TEQEQP  $usereg, PC             ; no, then set it (and $register = I_bit)
        MOVNE   $usereg, #0             ; yes, then leave alone (and $register = 0)
        MEND

; **************************************************************************
; ***  PLP - Restore IRQ state from the indicator in a register (set up  ***
; ***  by PHPSEI).  Note that this code preserves the C and V flags.     ***
; **************************************************************************
        MACRO
$label  PLP     $register=R14
        LCLS    usereg
  [     "$register" = ""
usereg  SETS    "R14"
  |
usereg  SETS    "$register"
  ]
$label  TEQP    $usereg, PC
        MEND
 ]

; ****************
; ***  RETURN  ***
; ****************
        MACRO
$label  RETURN  $cond
$label  MOV$cond pc, lr
        MEND

; *****************
; ***  RETURNS  ***
; *****************
        MACRO
$label  RETURNS $cond, $nowarn
 [ "$nowarn"=""
 ! 0, "RETURNS macro indicates possible 32-bit incompatibility", 1
 ]
$label  MOV$cond.S pc, lr
        MEND

 [ No32bitCode
; ******************
; ***  RETURNVC  ***
; ******************
        MACRO
$label  RETURNVC  $cond
$label  BIC$cond.S pc, lr, #V_bit
        MEND

; ******************
; ***  RETURNVS  ***
; ******************
        MACRO
$label  RETURNVS  $cond
$label  ORR$cond.S pc, lr, #V_bit
        MEND

; ****************************************************
; ***  SavePSR - Save the PSR in a register, to be ***
; ***  restored later using RestorePSR             ***
; ****************************************************
        MACRO
$label  SavePSR  $reg, $cond
$label  MOV$cond $reg, pc
        MEND

; ****************************************************
; ***  RestPSR - Restore the PSR from a register   ***
; ***  set up by SavePSR                           ***
; ***  $fields may be set to "f" if the PSR fields ***
; ***  c,x,s do not need restoring, which will     ***
; ***  save a few cycles on newer ARMs (but the    ***
; ***  No32bitCode version of the macro will set   ***
; ***  the c field anyway). Values other than "f", ***
; ***  "cf", "fc" and unset are deprecated for     ***
; ***  compatibility with No32bitCode.             ***
; ****************************************************
        MACRO
$label  RestPSR    $reg, $cond, $fields
  [ "$fields"<>"" :LAND: "$fields"<>"cf" :LAND: "$fields"<>"fc" :LAND: "$fields"<>"f"
        !       0, "Unpredictable behaviour due to deprecated RestPSR fields parameter"
  ]
$label  TEQ$cond.P pc, $reg
  [ NoARMa :LAND: "$fields"<>"f"
        ; Assume mode may be changing, emit NOP for ARM2
        ! 0, "RestPSR inserting NOP for ARM2 TEQP bug", 1
        NOP
  ]
        MEND

; ****************************************************
; ***  SCPSR - Set and clear bits in PSR from the  ***
; ***  masks $set, $clr, using register $regtmp    ***
; ****************************************************
        MACRO
$label  SCPSR   $set, $clr, $regtmp, $cond, $oldpsr
        LCLS    srcreg
        [ "$oldpsr"=""
srcreg  SETS    "$regtmp"
        |
srcreg  SETS    "$oldpsr"
        ]
        [ (($set) :AND: ($clr)) <> 0
        ! 1, "Attempt to simultaneously set and clear a bit in SCPSR"
        ]
$label
    [ (($set) :OR: ($clr)) = ARM_CC_Mask
      [ "$oldpsr" <> ""
        MOV$cond   $oldpsr, pc
      ]
        TEQ$cond.P pc, #$set            ; All change, so skip the clear operation
    |
        MOV$cond   $srcreg, pc
        ORR$cond   $regtmp, $srcreg, #($set) :OR: ($clr)
        TEQ$cond.P $regtmp, #$clr
    ]
    [ NoARMa :LAND: ((($set) :OR: ($clr)) :AND: M_bits) <> 0
        ! 0, "SCPSR inserting NOP for ARM2 TEQP bug", 1
        NOP
    ]
        MEND

; **********************************************
; ***  SEC - Set carry flag - will set nzCv  ***
; **********************************************
        MACRO
$label  SEC     $cond
$label  CMP$cond pc, #0
        MEND

; ************************************************
; ***  SETPSR - Set bits in PSR from the mask  ***
; ***  in $bits, using register $regtmp        ***
; ************************************************
        MACRO
$label  SETPSR  $bits, $regtmp, $cond, $oldpsr
        LCLS    srcreg
        [ "$oldpsr"=""
srcreg  SETS    "$regtmp"
        |
srcreg  SETS    "$oldpsr"
        ]
$label  MOV$cond   $srcreg, pc
        ORR$cond   $regtmp, $srcreg, #$bits
        TEQ$cond.P $regtmp, #0
    [ NoARMa :LAND: (($bits) :AND: M_bits) <> 0
        ! 0, "SETPSR inserting NOP for ARM2 TEQP bug", 1
        NOP
    ]
        MEND

; **************************************************
; ***  SETV - Set overflow flag - will set NzcV  ***
; **************************************************
        MACRO
$label  SETV    $cond
$label  CMP$cond pc, #&80000000
        MEND

; ***********************************************
; ***  TOGPSR - Toggle bits in PSR from the   ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  TOGPSR  $bits, $regtmp, $cond, $oldpsr
        LCLS    srcreg
        [ "$oldpsr"=""
srcreg  SETS    "$regtmp"
        |
srcreg  SETS    "$oldpsr"
        ]
$label  MOV$cond   $srcreg, pc
        TEQ$cond.P $srcreg, #$bits
    [ NoARMa :LAND: (($bits) :AND: M_bits) <> 0
        ! 0, "TOGPSR inserting NOP for ARM2 TEQP bug", 1
        NOP
    ]
        MEND

; ***********************************************
; ***  TOGPSRR - Toggle bits in PSR from the  ***
; ***  mask in $regtog, using reg $regtmp     ***
; ***********************************************
        MACRO
$label  TOGPSRR $regtog, $regtmp, $cond, $oldpsr, $fields
        [ "$oldpsr"<>""
$label  MOV$cond   $oldpsr, pc
        TEQ$cond.P $regtog, pc
        |
$label  TEQ$cond.P $regtog, pc
        ]
    [ NoARMa
        ! 0, "TOGPSRR inserting NOP for ARM2 TEQP bug", 1
        NOP
    ]
        MEND

; ***************************************************
; ***  WritePSRc - Set the PSR control bits to    ***
; ***  an absolute value.                         ***
; ***  Sets I,F,M[0:3], corrupts NZVC.            ***
; ***  Preserves 32-bitness. Ignored in USR mode. ***
; ***  PSR is specified as 26bit form, so only    ***
; ***  USR/IRQ/FIQ/SVC can be used as dest mode,  ***
; ***  but source can be any non-USR mode         ***
; ***  (M[2:3] will be cleared)                   ***
; ***  Use instead of TEQP PC,#$value             ***
; ***************************************************
        MACRO
$label  WritePSRc $value, $regtmp, $cond, $oldpsr
      [ ($value :AND::NOT: (I_bit+F_bit+SVC_mode)) <> 0
        ! 1, "Illegal flags for WritePSRc"
      ]
$label
 [ "$oldpsr" <> ""
        SavePSR $oldpsr, $cond
 ]
        TEQ$cond.P PC, #$value
    [ NoARMa
        ! 0, "WritePSRc inserting NOP for ARM2 TEQP bug", 1
        NOP
    ]
        MEND

 ] ; No32bitCode

; *************************************************
; ***  RemovePSRFromReg - remove PSR bits from  ***
; ***  a PC (or register holding a PC, eg. lr)  ***
; ***  Preserves all PSR bits                   ***
; *************************************************
        MACRO
$label  RemovePSRFromReg $pcr, $tmp, $dest
        ; If $dest is supplied, it denotes an alternative target
        ; register from $pcr.  $dest and $tmp may be the same register.
        ;
        ; MRS is safe as it is a NOP if the processor doesn't understand it. The code
        ; takes bit 4 of the CPSR (always set in 32-bit modes, always clear in 26-bit
        ; modes), shifts it to the bottom bit and inverts it, then shifts it to the
        ; top bit so it can use ASR to duplicate it into 8 bits, and then ROR#30 to
        ; turn it into &FC000003 if you are in a 26-bit bit, 0 if you are in 32-bit
        ; mode. This value can be BIC'ed with lr to strip the PSR bits if they are
        ; there, or be a NOP if they are not.
        ;
        ; Must be in a known mode (currently USR26,USR32,IRQ26,IRQ32,FIQ26,FIQ32,
        ; SVC26,SVC32,ABT32,UND32,SYS32) - future modes may have bit 4 clear, yet
        ; they won't be 26-bit.
        ASSERT (1 :SHL: 4) = (USR32_mode - USR26_mode)
$label
        LCLS    dst
        [ "$dest" <> ""
dst SETS "$dest"
        |
dst SETS "$pcr"
        ]
        [ No32bitCode
        BIC     $dst, $pcr, #ARM_CC_Mask  ; 32-bit OK: inside No32bitCode macro
        |
        [ No26bitCode
        [ $dst <> $pcr
        MOV     $dst, $pcr
        ]
        |
        [ NoARMv3
        MOV     $tmp, #0
        ]
        MRS     $tmp, CPSR
        MVN     $tmp, $tmp, LSR #4        ; bit 0 set in *26, clear in *32
        MOV     $tmp, $tmp, LSL #31       ; shift to top bit
        MOV     $tmp, $tmp, ASR #7        ; duplicate to top 8 bits
        BIC     $dst, $pcr, $tmp, ROR #30 ; remove PSR bits if in 26-bit mode
        ]
        ]
        MEND


 ] ; :LNOT: :DEF: Included_Hdr_CPU_Generic26

        OPT     OldOpt
        END

@


4.14
log
@Add new "26" machine type. Simplify ARM2 support.
Detail:
  hdr/Machine/26, hdr/Machine/Machine - Add new "26" machine type, which targets all 26 bit machines/OS versions (running only in 26 bit mode)
  hdr/CPU/Arch - Use ELIF to avoid bracket spam. Remove duplicate CortexA7 case.
  hdr/CPU/Generic26 - Add NOPs to PSR manipulation macros in order to make them ARM2-safe (Generic32 macros are already structured to have suitable NOPs when generating 32bit-neutral code, so it makes sense for Generic26 to take care of ARM2 as well). This removes the need for components which use these macros to insert any manual NOPs, whether for the StrongARM MSR bug or the ARM2 TEQP bug.
  hdr/CPU/Generic32 - Flag the StrongARM MSR NOP diagnostic message as a warning, so the line number can be included in the output, so developers can more easily investigate the issue.
Admin:
  Tested with PlingSystem build


Version 2.63. Tagged as 'HdrSrc-2_63'
@
text
@d451 11
a461 9
; *************************************************
; ***  WritePSRc - Set the PSR control bits to  ***
; ***  an absolute value.                       ***
; ***  Sets I,F,M[0:1], corrupts NZVC.          ***
; ***  Preserves 32-bitness.                    ***
; ***  Only use in IRQ26/32,FIQ26/32,SVC26/32   ***
; ***  Ignored in USR modes, illegal in others  ***
; ***  Use instead of TEQP PC,#$value           ***
; *************************************************
@


4.13
log
@  Second of a two-part update of HdrSrc.
Detail:
  Hdr:System:
  * Hdr:CPU.Arch added to the list of header files included here. This is
    because it's now needed by Hdr:CPU.Generic*.
  Hdr:CPU.Generic*:
  * Reintroduced ARMv2 compatibility to many macros. Should allow a new
    universal boot sequence to be constructed.
  * SCPSR in Generic26 optimised in cases where no PSR bits are preserved.
  * RemovePSRFromReg optimised for 32bit-only builds - becomes a no-op.
  Hdr:Machine.Machine:
  * Reordering of braces so that symbol "HAL" doesn't have to be defined -
    useful for disc builds, which target both HAL and non-HAL machines, so
    the symbol is undefined.
  * Added some comments and an assert about No26bitCode and No32bitCode.
Admin:
  Update originally from Rob Sprowson, bugfixes and additions and split into
  two parts by me.

Version 2.26. Tagged as 'HdrSrc-2_26'
@
text
@d337 5
d370 4
d399 4
d427 4
d445 4
d465 1
d469 5
a473 1
$label  TEQ$cond.P PC, #$value
@


4.13.2.1
log
@  Cross-compile version of HdrSrc
Detail:
  Mostly a question of changing directory separators and removing reliance
  upon path variables and system variable expansion. One day, when all
  components use the shared makefiles (or at least use the necessary -pd and
  -i switches to objasm), we will be able to switch over to using this
  version for all builds. In the meantime, I have created a new branch for
  the HdrSrc component, called XCompile, to store these changes. The downside
  is the fact that we'll now have to maintain unrelated changes on both
  branches until they can be merged.
Admin:
  Tested by cross-assembling the BASIC module.

Version 2.46, 4.247.2.1. Tagged as 'HdrSrc-2_46-4_247_2_1'
@
text
@d35 1
a35 1
        GET     Machine/$Machine
@


4.12
log
@  First of a two-part update of Hdr:CPU.Generic*
Detail:
  Changes split into two parts to make the diffs readable. In this part:
  * Simplified the inclusion of Hdr:Machine.<Machine> - all current builds
    require a new enough version of objasm that the bug with GET directives
    inside conditionals appears to no longer apply.
  * A number of macros used to have large switches of almost-identical code
    depending upon whether an optional register was defined or not - these
    are now simplified by using a local variable to hold the register.
  * RETURNS is no longer wrapped in :LNOT: No26bitCode, since it could still
    be useful for exception return, non-transient callback handlers etc.
    However, its presence is still a warning sign for non-32-bit-compatible
    code, so it emits a warning unless you add an extra argument to indicate
    that you've vetted that the code is 32-bit safe.
  * Operator precedence bug fixed in SCPSR from Generic32 copied across to
    Generic26 (applies if bits to set/clear were given as expressions).
  * Conflicting set and clear bits in SCPSR now produce an error in both
    Generic26 and Generic32 (previously was only a warning in Generic26).
  * Added the same flag bit check in WritePSRc in Generic26 as already
    existed in Generic32.
  * Some comments reformatted for consistency.
  * Uses of mymrs replaced with MRS, and unconditional or flag-only uses of
    mymsr macro replaced with MSR (other ones remain to deal with the
    StrongARM bug).
  * RETURNVC and RETURNVS no longer accept NV condition code.
  * Removed BKPT macro (now implemented natively in objasm).
Admin:
  Update originally from Rob Sprowson, bugfixed and split into two parts by me.

Version 2.25. Tagged as 'HdrSrc-2_25'
@
text
@d354 8
a361 1
$label  MOV$cond   $srcreg, pc
d364 1
d484 8
d498 1
@


4.11
log
@  Some maintenance of Hdr:CPU.GenericXX.
Detail:
  * Added register definitions for the new registers in those wacky new ARM2
    chips, r8_fiq and r9_fiq.
  * Added abort and undefined mode register definitions using the ARM ARM
    standardised suffix of _abt and _und (previously we only had _abort and
    _undef versions).
  * Added some sanity checking of the fields parameter to the RestPSR macro,
    to help warn the unwary of the effect of compiling No32bitCode.
Admin:
  Changes appear to function as desired. Debug builds of MPEGDriver actually
  require those extra register definitions.

Version 1.23. Tagged as 'HdrSrc-1_23'
@
text
@d17 7
a33 1
       GBLS     CPU26_GetMachine
d35 1
a35 3
CPU26_GetMachine SETS "GET Hdr:Machine.<Machine>"
 |
CPU26_GetMachine SETS ""
a36 8
       $CPU26_GetMachine

OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

 [ :LNOT: :DEF: Included_Hdr_CPU_Generic26
        GBLL    Included_Hdr_CPU_Generic26
Included_Hdr_CPU_Generic26 SETL {TRUE}
d246 2
a247 1
$label  PHPSEI  $register, $regtmp      ; (we don't use regtmp, 32-bit one does)
d249 1
a249 4
$label  MOV     R14, #I_bit
        TST     R14, PC                 ; is I_bit set ?
        TEQEQP  R14, PC                 ; no, then set it (and R14 = I_bit)
        MOVNE   R14, #0                 ; yes, then leave alone (and R14=0)
d251 1
a251 4
$label  MOV     $register, #I_bit
        TST     $register, PC           ; is I_bit set ?
        TEQEQP  $register, PC           ; no, then set it (and $reg. = I_bit)
        MOVNE   $register, #0           ; yes, then leave alone (and R14=0)
d253 4
d265 1
d267 1
a267 1
$label  TEQP    R14, PC
d269 1
a269 1
$label  TEQP    $register, PC
d271 1
a282 1
 [ :LNOT: No26bitCode
d287 4
a290 1
$label  RETURNS $cond
a292 1
 ]
d322 1
a322 1
; ***  set up by SavePSR                           ***
d351 2
a352 2
        [ ($set :AND: $clr) <> 0
        ! 0, "Attempt to simultaneously set and clear a bit in SCPSR"
d433 3
a440 1
 ]
d442 7
d451 1
a451 3
        ; This macro masks out the PSR bits from a pc (or register holding a pc -
        ; eg. lr). It does so only in 26-bit modes, and is required to not affect
        ; any PSR flags.  If $dest is supplied, it denotes an alternative target
d474 1
a474 1
        BIC     $dst, $pcr, #&FC000003    ; 32-bit OK: inside No32bitCode macro
@


4.10
log
@Hdr:CPU.Generic26 adjusted to not mess up listing state.
Extra errors added for OS_Hardware.
Hdr:Machine.Machine flag changes for "M_32" build.

Version 1.09. Tagged as 'HdrSrc-1_09'
@
text
@d83 2
d325 7
d335 3
@


4.9
log
@  Added TOGPSRR macro
Detail:
  TOGPSRR does the same as TOGPSR except that the bits to toggle
    are held in a register.
  Hdr:Sprite contains declarations that are mistranslated by Hdr2H 1.1.
    Hdr2H has been updated to handle these declarations and is first
    present in RiscOS/Library 0.45.
Admin:
  Required by DualSerial 0.24 and later.
  Requires Library 0.45 to export a correct C version of Hdr:Sprite

Version 0.88. Tagged as 'HdrSrc-0_88'
@
text
@a16 3
OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

d34 3
@


4.8
log
@Fixed a bit more.

Version 0.85. Tagged as 'HdrSrc-0_85'
@
text
@d398 14
@


4.7
log
@* Fixed 32-bit macros broken by $oldpsr extension to SCPSR.
* Added $oldpsr extension to SETPSR, CLRPSR and TOGPSR.
* Removed reliance on ObjAsm default macro parameters in $oldpsr extension.
* Replaced SavePSR macro calls with literal mrs instructions in 32-bit macros.

Version 0.84. Tagged as 'HdrSrc-0_84'
@
text
@d228 1
a228 1
        [ $oldpsr<>""
@


4.6
log
@  SavePSR functionality incorporated into some other macros.
Detail:
  Improved some of the PSR wiggling macros with an optional extra
    register into which to save the old PSR.  Saves an extra MRS
    instruction in some cases.
  Some macros changed to invoke SavePSR macro instead of having a copy
    of the macro body.
Admin:
  Required by ScrBlank 2.30.

Version 0.83. Tagged as 'HdrSrc-0_83'
@
text
@d226 6
a231 2
$label  CLRPSR  $bits, $regtmp, $cond
$label  MVN$cond   $regtmp, #$bits
d334 7
a340 1
$label  SCPSR   $set, $clr, $regtmp, $cond, $oldpsr=$regtmp
d344 2
a345 2
$label  MOV$cond   $oldpsr, pc
        ORR$cond   $regtmp, $oldpsr, #($set) :OR: ($clr)
d362 9
a370 3
$label  SETPSR  $bits, $regtmp, $cond
$label  MOV$cond   $regtmp, pc
        ORR$cond   $regtmp, $regtmp, #$bits
d387 9
a395 3
$label  TOGPSR  $bits, $regtmp, $cond
$label  MOV$cond   $regtmp, pc
        TEQ$cond.P $regtmp, #$bits
@


4.5
log
@More 32-bit tweaks. Some assembler macros extended to accept condition codes
and PSR flag subset specifiers.
CPU.FPA header file added.

Version 0.79. Tagged as 'HdrSrc-0_79'
@
text
@d330 1
a330 1
$label  SCPSR   $set, $clr, $regtmp, $cond
d334 2
a335 2
$label  MOV$cond   $regtmp, pc
        ORR$cond   $regtmp, $regtmp, #($set) :OR: ($clr)
d386 4
a389 1
$label  WritePSRc $value, $regtmp, $cond
d436 1
@


4.4
log
@Added new option "POSTFlashesFrontPanelLEDs" so we can turn it off for
Lazarus.
Minor optimisation to RemovePSRFromReg macro.

Version 0.71. Tagged as 'HdrSrc-0_71'
@
text
@d387 1
a387 1
$label  TEQ$cond.P     PC, #$value
@


4.3
log
@  26-bit version of WritePSRc macro was missing the third parameter
Detail:
  The 32-bit version of WritePSRc takes an optional third parameter
    which is the condition code to embed in the instruction.
    The 26-bit mode version now takes the same parameters, thus
    allowing Sound2 (SoundScheduler) to build.
Admin:
  Tested in Phoebe and 32 machine builds of Sound2.
  Required by SoundScheduler 1.25 and later (Sound2-1_25)

Version 0.65. Tagged as 'HdrSrc-0_65'
@
text
@d405 4
a419 3
        [ :LNOT: No26bitCode              ; No point wasting an instruction
        MOV     $tmp, #0
        ]
@


4.2
log
@  Merge of 32-bit capable macros to trunk.
Detail:
  The 26-bit and 32-bit capable macros have been added.
  Header files choose which set of macros to use based on <Machine>.
  If you want the new macros, include "Hdr:APCS.<APCS>" in addition
    to the usual inclusions at the top of assembler files.
  Choices are based on the settings of macros No32bitCode and
    No26bitCode.  By default, all existing machines define these
    as {TRUE} and {FALSE} respectively.  This yields the same macros
    as before (tested in Customer F 5 build) and should yield code which
    functions on RISC OS 3.1.  Any other combination of settings is
    untested at this time.
  New assembler code should use the macros FunctionEntry, Return et al
    to ensure that they build correctly.
  New assembler code should be written to not require flag preservation
    across internal function calls and to not assume it on external
    function calls where it is possible to do so.  DO NOT simply replace
    "MOVS pc, lr" with "MOV pc, lr" as this doesn't work properly.
    Replace "MOVS pc, lr" with "Return ,LinkNotStacked"
  Do not write code which simply masks out &FC000003 from pc or some kind
    or pc originated value (eg. on r14 to attempt to remove the PSR flags
    from it.  Use the RemovePSRFromReg macro instead.
Admin:
  Tested with Customer F 5 build.
  Requires FPEmulator 4.11
  Requires Portable 0.65 (or Portable75 0.04)
  Required by any new or modified assembler code in future, pretty much.
    Such components may not necessarily specify a dependency on this
    or any other later version of HdrSrc.

Version 0.63. Tagged as 'HdrSrc-0_63'
@
text
@d386 2
a387 2
$label  WritePSRc $value, $regtmp
$label  TEQP     PC, #$value
@


4.1
log
@Initial revision
@
text
@d28 13
d110 1
d113 1
d126 22
d166 1
d185 4
a188 4
ARMCoProc_3             #       1       ;  3, 
ARMCoProc_4             #       1       ;  4, 
ARMCoProc_5             #       1       ;  5, 
ARMCoProc_6             #       1       ;  6, 
d191 6
a196 6
ARMCoProc_9             #       1       ;  9, 
ARMCoProc_10            #       1       ; 10, 
ARMCoProc_11            #       1       ; 11, 
ARMCoProc_12            #       1       ; 12, 
ARMCoProc_13            #       1       ; 13, 
ARMCoProc_14            #       1       ; 14, 
d212 1
d244 1
a244 1
$label  PHPSEI  $register
d263 1
a263 1
$label  PLP     $register
d270 1
d280 1
d288 36
d331 3
d375 54
@


4.1.10.1
log
@First attempt at 32-bit support.

Version 0.57, 4.58.2.1. Tagged as 'HdrSrc-0_57-4_58_2_1'
@
text
@a27 9
; 05-Nov-99  KBracey       Keep an eye on No26bitCode flag

       GBLS     CPU26_GetMachine
 [ :LNOT: :DEF: Included_Hdr_Machine_Machine
CPU26_GetMachine SETS "GET Hdr:Machine.<Machine>"
 |
CPU26_GetMachine SETS ""
 ]
       $CPU26_GetMachine
a96 1
 [ :LNOT: No26bitCode
a98 1
 ]
a110 22
        ; Condition code symbols

Cond_EQ *       0  :SHL: 28
Cond_NE *       1  :SHL: 28
Cond_CS *       2  :SHL: 28
Cond_HS * Cond_CS
Cond_CC *       3  :SHL: 28
Cond_LO * Cond_CC
Cond_MI *       4  :SHL: 28
Cond_PL *       5  :SHL: 28
Cond_VS *       6  :SHL: 28
Cond_VC *       7  :SHL: 28
Cond_HI *       8  :SHL: 28
Cond_LS *       9  :SHL: 28
Cond_GE *       10 :SHL: 28
Cond_LT *       11 :SHL: 28
Cond_GT *       12 :SHL: 28
Cond_LE *       13 :SHL: 28
Cond_AL *       14 :SHL: 28
Cond_   * Cond_AL
Cond_NV *       15 :SHL: 28

d147 4
a150 4
ARMCoProc_3             #       1       ;  3,
ARMCoProc_4             #       1       ;  4,
ARMCoProc_5             #       1       ;  5,
ARMCoProc_6             #       1       ;  6,
d153 6
a158 6
ARMCoProc_9             #       1       ;  9,
ARMCoProc_10            #       1       ; 10,
ARMCoProc_11            #       1       ; 11,
ARMCoProc_12            #       1       ; 12,
ARMCoProc_13            #       1       ; 13,
ARMCoProc_14            #       1       ; 14,
d179 1
a179 1
$label  CMN$cond pc, #0         ; pc can be anything (26 or 32)
a181 1
 [ No32bitCode
a190 1
 ]
d197 1
a197 1
$label  CMP$cond pc, #0         ; pc can be anything (26 or 32)
a199 1
 [ No32bitCode
d205 2
a206 2
$label  PHPSEI  $register, $regtmp      ; (we don't use regtmp, 32-bit one does)
  [ $register = " = ""
d224 1
a224 1
$label  PLP     $register=R14
a230 1
 ]
a239 1
 [ :LNOT: No26bitCode
a246 1
 ]
a247 1
 [ No32bitCode
a257 1
 ]
d264 1
a264 1
$label  CMP$cond pc, #0         ; pc can be anything (26 or 32)
a266 1
 [ No32bitCode
a276 1
 ]
a279 1
; ***  Please supply a known positive register.  ***
d282 2
a283 12
$label  SETV    $cond, $register
$label
  [ "$register" = ""
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000001 :EOR: Cond_$cond
  ]
        CMPVC   pc, #&80000000  ; handle +ve pc
        CMNVC   pc, #&80000000  ; and -ve pc
  |
        CMP$cond $register, #&80000000
  ]
a285 1
 [ No32bitCode
a294 1
 ]
@


4.1.10.2
log
@More macros added to Hdr:Proc and Hdr:CPU.
msr macro now understands _cxsf form.
APCS macros now available in Hdr:APCS.<APCS>

Version 0.57, 4.58.2.2. Tagged as 'HdrSrc-0_57-4_58_2_2'
@
text
@d208 1
a208 1
; ***  CLC - Clear carry flag - will set ?zcv  ***
d228 1
a228 1
; *** CLRV - Clear overflow flag - will set ?zCv ***
a287 34
; ******************
; ***  RETURNVC  ***
; ******************
        MACRO
$label  RETURNVC  $cond
$label  BIC$cond.S pc, lr, #V_bit
        MEND

; ******************
; ***  RETURNVS  ***
; ******************
        MACRO
$label  RETURNVS  $cond
$label  ORR$cond.S pc, lr, #V_bit
        MEND

; ****************************************************
; ***  SavePSR - Save the PSR in a register, to be ***
; ***  restored later using RestorePSR             ***
; ****************************************************
        MACRO
$label  SavePSR  $reg, $cond
$label  MOV$cond $reg, pc
        MEND

; ****************************************************
; ***  RestPSR - Restore the PSR from a register   ***
; ***  set up by SavePSR                           ***
; ****************************************************
        MACRO
$label  RestPSR    $reg, $cond
$label  TEP$cond.P pc, $reg
        MEND

a293 3
        [ ($set :AND: $clr) <> 0
        ! 0, "Attempt to simultaneously set and clear a bit in SCPSR"
        ]
d301 1
a301 1
; ***  SEC - Set carry flag - will set ?zCv  ***
d322 1
a322 1
; ***  SETV - Set overflow flag - will set ?zcV  ***
a348 14
        MEND

; *************************************************
; ***  WritePSRc - Set the PSR control bits to  ***
; ***  an absolute value.                       ***
; ***  Sets I,F,M[0:1], corrupts NZVC.          ***
; ***  Preserves 32-bitness.                    ***
; ***  Only use in IRQ26/32,FIQ26/32,SVC26/32   ***
; ***  Ignored in USR modes, illegal in others  ***
; ***  Use instead of TEQP PC,#0 etc            ***
; *************************************************
        MACRO
$label  WritePSRc $value, $regtmp
$label  TEQP     PC, #$value
@


4.1.10.3
log
@  Typo fix
Detail:
  TEP instruction corrected to TEQ
Admin:
  RISC_OSLib now builds in 26-bit configuration again.


Version 0.57, 4.58.2.3. Tagged as 'HdrSrc-0_57-4_58_2_3'
@
text
@d319 1
a319 1
$label  TEQ$cond.P pc, $reg
@


4.1.10.4
log
@  RemovePSRFromReg macro added.
  Assertion added to Return to catch wrong values for $Base
Detail:
  RemovePSRFromReg $pcr, $tmp, $dest
    This macro removes the PSR bits from register $pcr, storing
    the result in $dest (defaults to $pcr).  Macro does not
    affect any PSR flags.  Code will execute in any currently
    defined 26 or 32 bit processor mode.
Admin:
  Required by the SharedCLibrary.

Version 0.57, 4.58.2.5. Tagged as 'HdrSrc-0_57-4_58_2_5'
@
text
@a402 37
        MACRO
$label  RemovePSRFromReg $pcr, $tmp, $dest
        ; This macro masks out the PSR bits from a pc (or register holding a pc -
        ; eg. lr). It does so only in 26-bit modes, and is required to not affect
        ; any PSR flags.  If $dest is supplied, it denotes an alternative target
        ; register from $pcr.  $dest and $tmp may be the same register.
        ;
        ; MRS is safe as it is a NOP if the processor doesn't understand it. The code
        ; takes bit 4 of the CPSR (always set in 32-bit modes, always clear in 26-bit
        ; modes), shifts it to the bottom bit and inverts it, then shifts it to the
        ; top bit so it can use ASR to duplicate it into 8 bits, and then ROR#30 to
        ; turn it into &FC000003 if you are in a 26-bit bit, 0 if you are in 32-bit
        ; mode. This value can be BIC'ed with lr to strip the PSR bits if they are
        ; there, or be a NOP if they are not.
        ASSERT (1 :SHL: 4) = (USR32_mode - USR26_mode)
$label
        LCLS    dst
        [ "$dest" <> ""
dst SETS "$dest"
        |
dst SETS "$pcr"
        ]
        [ No32bitCode
        BIC     $pcr, $pcr, #&FC000003    ; 32-bit OK: inside No32bitCode macro
        |
        [ :LNOT: No26bitCode              ; No point wasting an instruction
        MOV     $tmp, #0
        ]
        MRS     $tmp, CPSR
        MVN     $tmp, $tmp, LSR #4        ; bit 0 set in *26, clear in *32
        MOV     $tmp, $tmp, LSL #31       ; shift to top bit
        MOV     $tmp, $tmp, ASR #7        ; duplicate to top 8 bits
        BIC     $dst, $pcr, $tmp, ROR #30 ; remove PSR bits if in 26-bit mode
        ]
        MEND


@


4.1.10.5
log
@Lots of exciting 32-bit stuff. Try it at your peril.

Version 0.57, 4.58.2.6. Tagged as 'HdrSrc-0_57-4_58_2_6'
@
text
@a37 4
 [ :LNOT: :DEF: Included_Hdr_CPU_Generic26
        GBLL    Included_Hdr_CPU_Generic26
Included_Hdr_CPU_Generic26 SETL {TRUE}

a161 1
M_bits          *       2_11
a206 1
 [ No32bitCode
d208 1
a208 1
; ***  CLC - Clear carry flag - will set nzcv  ***
d212 1
a212 1
$label  CMN$cond pc, #0
d215 1
d225 1
d228 1
a228 1
; *** CLRV - Clear overflow flag - will set nzCv ***
d232 1
a232 1
$label  CMP$cond pc, #0
d235 1
d318 1
a318 1
$label  RestPSR    $reg, $cond, $fields
d335 1
d338 1
a338 1
; ***  SEC - Set carry flag - will set nzCv  ***
d342 1
a342 1
$label  CMP$cond pc, #0
d345 1
d356 1
d359 2
a360 1
; ***  SETV - Set overflow flag - will set NzcV  ***
d363 12
a374 2
$label  SETV    $cond
$label  CMP$cond pc, #&80000000
d377 1
d395 1
a395 1
; ***  Use instead of TEQP PC,#$value           ***
a438 2

 ] ; :LNOT: :DEF: Included_Hdr_CPU_Generic26
@


4.1.10.6
log
@  Fixed PHPSEI macro for 26-bit builds
  Imported toolbox/window swi chunk changes from trunk.
Admin:
  Tested.

Version 0.57, 4.58.2.8. Tagged as 'HdrSrc-0_57-4_58_2_8'
@
text
@d245 1
a245 1
  [     "$register" = ""
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.23;
access;
symbols
	HdrSrc-2_77:4.23
	HdrSrc-2_76:4.23
	HdrSrc-2_75:4.23
	HdrSrc-2_74:4.23
	HdrSrc-2_73:4.23
	HdrSrc-2_72:4.23
	HdrSrc-2_71:4.23
	HdrSrc-2_70:4.23
	HdrSrc-2_69:4.23
	HdrSrc-2_68:4.23
	HdrSrc-2_67:4.23
	HdrSrc-2_66:4.23
	HdrSrc-2_65:4.22
	HdrSrc-2_64:4.21
	HdrSrc-2_63:4.21
	HdrSrc-2_62:4.20
	HdrSrc-2_61:4.20
	HdrSrc-2_60:4.20
	HdrSrc-2_59:4.19
	HdrSrc-2_58:4.19
	HdrSrc-2_57:4.19
	HdrSrc-2_56:4.19
	HdrSrc-2_55:4.18
	HdrSrc-2_54:4.18
	HdrSrc-2_53:4.18
	HdrSrc-2_52:4.18
	HdrSrc-2_51:4.18
	HdrSrc-2_50:4.18
	HdrSrc-2_49:4.18
	HdrSrc-2_48:4.18
	HdrSrc-2_47:4.18
	HdrSrc-2_46-4_247_2_1:4.18.2.1
	XCompile:4.18.0.2
	XCompile_bp:4.18
	HdrSrc-2_46:4.18
	HdrSrc-2_45:4.18
	HdrSrc-2_44:4.18
	HdrSrc-2_43:4.18
	HdrSrc-2_42:4.18
	HdrSrc-2_41:4.18
	HdrSrc-2_40-1:4.18
	HdrSrc-2_40:4.18
	HdrSrc-2_39:4.18
	HdrSrc-2_38:4.18
	HdrSrc-2_37:4.18
	HdrSrc-2_36:4.18
	HdrSrc-2_35:4.18
	HdrSrc-2_34:4.18
	HdrSrc-2_33:4.18
	HdrSrc-2_32:4.18
	HdrSrc-2_31:4.17
	HdrSrc-2_30:4.17
	HdrSrc-2_29:4.17
	HdrSrc-2_28:4.17
	HdrSrc-2_27:4.16
	HdrSrc-2_26:4.16
	HdrSrc-2_25:4.15
	HdrSrc-2_24:4.14
	HdrSrc-2_23:4.14
	HdrSrc-2_22:4.14
	HdrSrc-2_21:4.14
	HdrSrc-2_20:4.14
	HdrSrc-2_19:4.14
	HdrSrc-2_18:4.14
	HdrSrc-2_17:4.14
	HdrSrc-2_16:4.14
	HdrSrc-2_15:4.14
	HdrSrc-2_14:4.14
	HdrSrc-2_13:4.14
	HdrSrc-2_12:4.14
	HdrSrc-2_11:4.14
	HdrSrc-2_10:4.14
	HdrSrc-2_09:4.14
	HdrSrc-2_08:4.14
	HdrSrc-2_07:4.14
	HdrSrc-2_06:4.14
	HdrSrc-2_05:4.14
	HdrSrc-2_04:4.14
	HdrSrc-2_03:4.14
	HdrSrc-2_02:4.14
	HdrSrc-2_01:4.14
	HdrSrc-2_00:4.14
	HdrSrc-1_99:4.14
	HdrSrc-1_98:4.14
	HdrSrc-1_97:4.14
	HdrSrc-1_96:4.14
	HdrSrc-1_95:4.13
	HdrSrc-1_94:4.13
	HdrSrc-1_93:4.13
	HdrSrc-1_92:4.13
	HdrSrc-1_91:4.13
	HdrSrc-1_90:4.13
	HdrSrc-1_89:4.13
	HdrSrc-1_88:4.13
	HdrSrc-1_87:4.13
	HdrSrc-1_86:4.13
	HdrSrc-1_85:4.13
	HdrSrc-1_84:4.13
	HdrSrc-1_83:4.13
	HdrSrc-1_82:4.13
	HdrSrc-1_81:4.13
	HdrSrc-1_80:4.13
	HdrSrc-1_79:4.13
	HdrSrc-1_78:4.13
	HdrSrc-1_77:4.13
	HdrSrc-1_76:4.13
	Cortex_merge:4.12.2.1
	HdrSrc-1_62-4_162_2_15:4.12.2.1
	HdrSrc-1_75:4.13
	HdrSrc-1_62-4_162_2_14:4.12.2.1
	HdrSrc-1_74:4.13
	HdrSrc-1_62-4_162_2_13:4.12.2.1
	HdrSrc-1_62-4_162_2_12:4.12.2.1
	HdrSrc-1_73:4.13
	HdrSrc-1_72:4.13
	HdrSrc-1_62-4_162_2_11:4.12.2.1
	HdrSrc-1_62-4_162_2_10:4.12.2.1
	HdrSrc-1_71:4.13
	HdrSrc-1_70:4.13
	HdrSrc-1_69:4.13
	Cortex_bp:4.13
	HdrSrc-1_62-4_162_2_9:4.12.2.1
	HdrSrc-1_62-4_162_2_8:4.12.2.1
	HdrSrc-1_68:4.13
	HdrSrc-1_62-4_162_2_7:4.12.2.1
	HdrSrc-1_62-4_162_2_6:4.12
	HdrSrc-1_62-4_162_2_5:4.12
	HdrSrc-1_62-4_162_2_4:4.12
	HdrSrc-1_67:4.12
	HdrSrc-1_66:4.12
	HdrSrc-1_62-4_162_2_3:4.12
	HdrSrc-1_65:4.12
	HdrSrc-1_64:4.12
	HdrSrc-1_63:4.12
	HdrSrc-1_62-4_162_2_2:4.12
	HdrSrc-1_62-4_162_2_1:4.12
	Cortex:4.12.0.2
	HdrSrc-1_62:4.12
	HdrSrc-1_61:4.12
	HdrSrc-1_60:4.12
	HdrSrc-1_59:4.12
	HdrSrc-1_58:4.12
	HdrSrc-1_57:4.12
	HdrSrc-1_56:4.12
	HdrSrc-1_55:4.12
	HdrSrc-1_54:4.12
	HdrSrc-1_53:4.12
	HdrSrc-1_52:4.12
	HdrSrc-1_51:4.12
	HdrSrc-1_50:4.12
	HdrSrc-1_49:4.12
	HdrSrc-1_48:4.12
	HdrSrc-1_47:4.12
	RO_5_07:4.12
	HdrSrc-1_46:4.12
	HdrSrc-1_45:4.12
	HdrSrc-1_44:4.12
	HdrSrc-1_43:4.12
	HdrSrc-1_42:4.12
	HdrSrc-1_41:4.12
	HdrSrc-1_40:4.12
	HdrSrc-1_39:4.12
	HdrSrc-1_38:4.12
	HdrSrc-1_37:4.12
	HdrSrc-1_36:4.12
	HdrSrc-1_35:4.12
	HdrSrc-1_34:4.11
	HdrSrc-1_33:4.11
	HdrSrc-1_32:4.11
	HdrSrc-1_31:4.11
	HdrSrc-1_30:4.11
	HdrSrc-1_29:4.11
	HdrSrc-1_28:4.11
	HdrSrc-1_27:4.11
	HdrSrc-1_26:4.11
	HdrSrc-1_25:4.11
	HdrSrc-1_24:4.11
	HdrSrc-1_23:4.11
	HdrSrc-1_22:4.10
	HdrSrc-1_21:4.10
	HdrSrc-1_20:4.10
	HdrSrc-1_19:4.10
	HdrSrc-1_18:4.10
	HdrSrc-1_17:4.10
	HdrSrc-1_16:4.10
	HdrSrc-1_15:4.10
	HdrSrc-1_14:4.10
	HdrSrc-1_13:4.10
	HdrSrc-1_12:4.10
	HdrSrc-1_11:4.10
	HdrSrc-0_71-4_72_2_2:4.3
	HdrSrc-1_10:4.10
	HdrSrc-1_09:4.10
	HdrSrc-1_08:4.10
	HdrSrc-1_07:4.10
	HdrSrc-1_06:4.10
	HdrSrc-1_05:4.10
	dellis_autobuild_BaseSW:4.9
	HdrSrc-1_04:4.9
	HdrSrc-1_03:4.9
	HdrSrc-1_02:4.8
	HdrSrc-1_00:4.8
	HdrSrc-0_99:4.8
	HdrSrc-0_71-4_72_2_1:4.3
	Lazarus_Z11:4.3.0.2
	HdrSrc-0_98:4.8
	HdrSrc-0_97:4.8
	HdrSrc-0_95:4.8
	HdrSrc-0_94:4.8
	HdrSrc-0_93:4.8
	HdrSrc-0_92:4.8
	HdrSrc-0_91:4.8
	HdrSrc-0_90:4.7
	HdrSrc-0_89:4.7
	HdrSrc-0_88:4.7
	HdrSrc-0_87:4.6
	HdrSrc-0_86:4.6
	HdrSrc-0_85:4.6
	HdrSrc-0_84:4.6
	HdrSrc-0_83:4.5
	HdrSrc-0_82:4.4
	HdrSrc-0_81:4.4
	HdrSrc-0_80:4.4
	HdrSrc-0_79:4.4
	HdrSrc-0_78:4.3
	HdrSrc-0_77:4.3
	sbrodie_sedwards_16Mar2000:4.3
	HdrSrc-0_76:4.3
	HdrSrc-0_75:4.3
	HdrSrc-0_74:4.3
	HdrSrc-0_73:4.3
	HdrSrc-0_72:4.3
	HdrSrc-0_71:4.3
	HdrSrc-0_70:4.3
	HdrSrc-0_69:4.3
	HdrSrc-0_68:4.3
	HdrSrc-0_67:4.3
	HdrSrc-0_66:4.3
	HdrSrc-0_65:4.3
	HdrSrc-0_64:4.3
	dcotton_autobuild_BaseSW:4.11
	kbracey_32bit_merge:1.1.2.3
	HdrSrc-0_63:4.1
	HdrSrc-0_57-4_58_2_9:1.1.2.3
	HdrSrc-0_57-4_58_2_8:1.1.2.3
	HdrSrc-0_57-4_58_2_7:1.1.2.3
	HdrSrc-0_57-4_58_2_6:1.1.2.3
	HdrSrc-0_57-4_58_2_5:1.1.2.2
	HdrSrc-0_57-4_58_2_4:1.1.2.2
	HdrSrc-0_57-4_58_2_3:1.1.2.2
	HdrSrc-0_57-4_58_2_2:1.1.2.2
	HdrSrc-0_57-4_58_2_1:1.1.2.1
	kbracey_32bit:1.1.0.2;
locks; strict;
comment	@# @;


4.23
date	2016.06.18.16.15.18;	author jlee;	state Exp;
branches;
next	4.22;
commitid	KnW2lBg1giR3VXaz;

4.22
date	2016.06.12.18.54.03;	author jlee;	state Exp;
branches;
next	4.21;
commitid	fXRc9eBUrhZtZcaz;

4.21
date	2016.05.28.18.30.08;	author jlee;	state Exp;
branches;
next	4.20;
commitid	DbPnp2msZ7Galh8z;

4.20
date	2016.05.08.16.25.10;	author jlee;	state Exp;
branches;
next	4.19;
commitid	o12utUQUbjo8iH5z;

4.19
date	2015.11.08.17.37.43;	author bavison;	state Exp;
branches;
next	4.18;
commitid	svJ6GMCC0esJxjIy;

4.18
date	2013.08.24.14.32.36;	author bavison;	state Exp;
branches
	4.18.2.1;
next	4.17;
commitid	zC4VA8xkeDowqI2x;

4.17
date	2013.04.29.00.12.26;	author bavison;	state Exp;
branches;
next	4.16;
commitid	FGmTNPGYzScBqBNw;

4.16
date	2013.03.23.20.11.15;	author bavison;	state Exp;
branches;
next	4.15;
commitid	uzJEZhKdPyLAfXIw;

4.15
date	2013.03.23.19.48.37;	author bavison;	state Exp;
branches;
next	4.14;
commitid	MZKqQOCl4XZP7XIw;

4.14
date	2012.02.16.22.34.18;	author jlee;	state Exp;
branches;
next	4.13;
commitid	fpxZyNEbOuZOVqTv;

4.13
date	2009.05.17.01.01.33;	author bavison;	state Exp;
branches;
next	4.12;

4.12
date	2002.10.29.21.42.06;	author rsprowson;	state Exp;
branches
	4.12.2.1;
next	4.11;

4.11
date	2001.05.11.20.04.49;	author bavison;	state Exp;
branches;
next	4.10;

4.10
date	2000.10.18.11.29.13;	author sbrodie;	state Exp;
branches;
next	4.9;

4.9
date	2000.09.15.11.15.44;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2000.07.11.09.17.51;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2000.06.01.10.56.00;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2000.05.17.13.12.46;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2000.05.15.09.06.40;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.04.04.10.04.01;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.12.02.13.06.43;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.12.02.13.03.30;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	99.11.26.14.32.30;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	99.11.05.13.17.08;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

4.18.2.1
date	2014.09.24.20.51.15;	author bavison;	state Exp;
branches;
next	;
commitid	FLu4L8VxkYPcNDRx;

4.12.2.1
date	2009.05.17.01.03.41;	author bavison;	state Exp;
branches;
next	;

1.1.2.1
date	99.11.05.13.17.08;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	99.11.10.13.33.19;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	99.11.23.17.26.35;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.23
log
@Fix SetMode macro
Detail:
  hdr/CPU/Generic32 - Copy-paste error led to wrong variable name in a conditional block
Admin:
  Tested on Raspberry Pi, Iyonix


Version 2.66. Tagged as 'HdrSrc-2_66'
@
text
@; Copyright 1999 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    Generic 32-bit CPU Specific Definitions

OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

 [ :LNOT: :DEF: Included_Hdr_CPU_Generic32
        GBLL    Included_Hdr_CPU_Generic32
Included_Hdr_CPU_Generic32 SETL {TRUE}

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************
;
; Date       Name          Description
; ----       ----          -----------
; 05-Nov-99  KBracey       Moved from ARM600.
;                          32-bit versions of Generic26 macros created.

 [ :LNOT: :DEF: Included_Hdr_Machine_Machine
        GET     Hdr:Machine.<Machine>
 ]

; 32-bit PSR transfer macros

; New positions of bits in 32-bit PSR

Q32_bit *       1 :SHL: 27
IT32_bits *     &0600FC00
J32_bit *       1 :SHL: 24
GE3_bit *       1 :SHL: 19
GE2_bit *       1 :SHL: 18
GE1_bit *       1 :SHL: 17
GE0_bit *       1 :SHL: 16
GE32_bits *     2_1111 :SHL: 16
E32_bit *       1 :SHL: 9
A32_bit *       1 :SHL: 8
I32_bit *       1 :SHL: 7
F32_bit *       1 :SHL: 6
T32_bit *       1 :SHL: 5
M32_bits *      2_11111

IF32_26Shift *  26-6

; Processor mode numbers

USR26_mode      *       2_00000
FIQ26_mode      *       2_00001
IRQ26_mode      *       2_00010
SVC26_mode      *       2_00011
USR32_mode      *       2_10000
FIQ32_mode      *       2_10001
IRQ32_mode      *       2_10010
SVC32_mode      *       2_10011
MON32_mode      *       2_10110
ABT32_mode      *       2_10111
HYP32_mode      *       2_11010
UND32_mode      *       2_11011
SYS32_mode      *       2_11111

; New register names

r13_mon         RN      13
r14_mon         RN      14
lr_mon          RN      14

r13_abort       RN      13
r14_abort       RN      14
lr_abort        RN      14

r13_abt         RN      13
r14_abt         RN      14
lr_abt          RN      14

r13_undef       RN      13
r14_undef       RN      14
lr_undef        RN      14

r13_und         RN      13
r14_und         RN      14
lr_und          RN      14

        GBLA    CPU32_bits
        GBLA    CPU32_set
        GBLA    CPU32_clr

; ***************************************************
; ***  IFto32 - Convert I/F/IF/FI string to       ***
; ***  I32_bit+F32_bit flags in variable psr32    ***
; ***************************************************
        MACRO
$psr32  IFto32 $if
        LCLS   upper
upper   SETS   :UPPERCASE: "$if"
      [ "$upper" = "I"
$psr32  SETA   I32_bit
      ELIF "$upper" = "F"
$psr32  SETA   F32_bit
      ELIF "$upper" = "IF" :LOR: "$upper" = "FI"
$psr32  SETA   I32_bit+F32_bit
      |
        ! 1, "Unsupported interrupt flags"
      ]              
        MEND

 [ :LNOT: No32bitCode

        ; 32 bit versions of the macros in Generic26

; ***************************************************
; ***  PSRto32 - Convert a PSR constant to a      ***
; ***  32-bit PSR value in variable psr32         ***
; ***  Shifts I and F into their 32-bit positions ***
; ***************************************************
        MACRO
$psr32  PSRto32 $psr
        [ (($psr) :AND: (:NOT: ARM_CC_Mask)) <> 0
	! 1, "Illegal PSR bits"
        ]
$psr32  SETA    (($psr) :AND: :NOT: (I_bit:OR:F_bit)) :OR: ((($psr) :AND: (I_bit:OR:F_bit)) :SHR: IF32_26Shift)
        MEND

; ************************************************
; ***  CLC - Clear carry flag - will set nzcv  ***
; ************************************************
        MACRO
$label  CLC     $cond
    [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT01                   ; Go round when $cond-itional
      ]
        CMN     pc, #0                  ; CLC in 26 bit modes
        MSR     CPSR_f, #0              ; ARMv3+ does CLC, NOP on ARMv2
01
    |
$label  MSR$cond CPSR_f, #0
    ]
        MEND

; ***********************************************
; ***  CLRPSR - Clear bits in PSR from the    ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  CLRPSR  $bits, $regtmp, $cond, $oldpsr
$label  SCPSR   0, $bits, $regtmp, $cond, $oldpsr
        MEND

; **************************************************
; *** CLRV - Clear overflow flag - will set nzCv ***
; **************************************************
        MACRO
$label  CLRV    $cond
    [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT01                   ; Go round when $cond-itional
      ]
        CMP     pc, #0                  ; CLRV in 26 bit modes
        MSR     CPSR_f, #C_bit          ; ARMv3+ does CLRV, NOP on ARMv2
01
    |
$label  MSR$cond CPSR_f, #C_bit
    ]
        MEND

; **********************************************************************************
; ***  PHPSEI - Disable IRQs, saving an old interrupt state indicator in a       ***
; ***  register, default R14.  Note that this code preserves the C and V flags.  ***
; ***  Don't have to supply regtmp, but if you do, we save an instruction.       ***
; **********************************************************************************
        MACRO
$label  PHPSEI  $register=R14, $regtmp
        LCLS    usereg
  [ "$register" = ""
usereg  SETS    "R14"
  |
usereg  SETS    "$register"
  ]
$label
      [ NoARMv3
        TEQ     pc, pc                         ; Can only PHPSEI in non user mode
        BEQ     %FT01
        MOV     $usereg, #I_bit
        TST     $usereg, PC                    ; is I_bit set ?
        TEQEQP  $usereg, PC                    ; no, then set it (and $register = I_bit)
        MOVNE   $usereg, #0                    ; yes, then leave alone (and $register = 0)
        B       %FT02
01
      ]
  [ :LNOT: NoARMv6
        ; CPS is quicker than MSR
        ; If there's a high probability of IRQs already being disabled, we can
        ; save even more time by branching over the CPS. But for now assume IRQs
        ; will mostly be on.
        MRS     $usereg, CPSR
        CPSID   i
  ELIF "$regtmp" = "" :LOR: StrongARM_MSR_bug
        MRS     $usereg, CPSR
        TST     $usereg, #I32_bit              ; is I32_bit set?
        ORREQ   $usereg, $usereg, #I32_bit     ; no, then set it
        mymsr   EQ, CPSR_c, $usereg, , safe
        BICEQ   $usereg, $usereg, #I32_bit     ; $register contains original PSR
  |
        MRS     $usereg, CPSR
        TST     $usereg, #I32_bit              ; is I32_bit set?
        ORREQ   $regtmp, $usereg, #I32_bit     ; no, then set it
        mymsr   EQ, CPSR_c, $regtmp            ; $register contains original PSR
  ]
02
        MEND

; **************************************************************************
; ***  PLP - Restore IRQ state from the indicator in a register (set up  ***
; ***  by PHPSEI).  Note that this code preserves the C and V flags.     ***
; **************************************************************************
        MACRO
$label  PLP     $register=R14
        LCLS    usereg
  [ "$register" = ""
usereg  SETS    "R14"
  |
usereg  SETS    "$register"
  ]
      [ NoARMv3
$label  TEQ     pc, pc                         ; Can only PLP in non user mode
        mymsr   EQ, CPSR_c, $usereg, , unsafe  ; Is a NOP pre ARMv3
        TEQNEP  $usereg, PC
        NOP
      |
$label  MSR     CPSR_c, $usereg
      ]
        MEND

; ******************
; ***  RETURNVC  ***
; ******************
        MACRO
$label  RETURNVC  $cond
$label
 [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT01                   ; Go round when $cond-itional
      ]
        TEQ     r0, r0                  ; Incase in user mode
        TEQ     pc, pc
        BICNES  pc, lr, #V_bit
        MSR     CPSR_f, #0
        MOV     pc, lr
01
 |
  [ "$cond" = "NV"
        ! 1, "Deprecated use of NV condition code in RETURNVC"
  ]
  [ "$cond" = "VC"
        MOVVC   pc, lr
  ]
  [ "$cond" = "NE" :LOR: "$cond"="CC" :LOR: "$cond"="LO" :LOR: "$cond"="PL" :LOR: "$cond"="LS" :LOR: "$cond"="GE" :LOR: "$cond"="GT" :LOR: "$cond"="AL" :LOR: "$cond"=""
        MSR$cond CPSR_f, #0
        MOV$cond pc, lr
  ]
  [ "$cond" = "EQ" :LOR: "$cond"="CS" :LOR: "$cond"="HS" :LOR: "$cond"="MI" :LOR: "$cond"="LT" :LOR: "$cond"="LE"
        MSR$cond CPSR_f, #N_bit + Z_bit + C_bit
        MOV$cond pc, lr
  ]
  [ "$cond" = "HI"
        MSR$cond CPSR_f, #C_bit
        MOV$cond pc, lr
  ]
  [ "$cond" = "VS"
        BVC     %FT01                   ; Skip on opposite condition
        MSR     CPSR_f, #0
        MOV     pc, lr
01
  ]
 ]
        MEND

; ******************
; ***  RETURNVS  ***
; ******************
        MACRO
$label  RETURNVS  $cond
$label
 [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT01                   ; Go round when $cond-itional
      ]
        TEQ     r0, r0                  ; Incase in user mode
        TEQ     pc, pc
        ORRNES  pc, lr, #V_bit
        MSR     CPSR_f, #V_bit
        MOV     pc, lr
01
 |
  [ "$cond" = "NV"
        ! 1, "Deprecated use of NV condition code in RETURNVC"
  ]
  [ "$cond" = "VS"
        MOVVS   pc, lr
  ]
  [ "$cond" = "NE" :LOR: "$cond"="CC" :LOR: "$cond"="LO" :LOR: "$cond"="PL" :LOR: "$cond"="LS" :LOR: "$cond"="AL" :LOR: "$cond"=""
        MSR$cond CPSR_f, #V_bit         ; Condition is still satisfied
        MOV$cond pc, lr
  ]
  [ "$cond" = "EQ" :LOR: "$cond"="CS" :LOR: "$cond"="HS" :LOR: "$cond"="MI" :LOR: "$cond"="GE" :LOR: "$cond"="LE"
        MSR$cond CPSR_f, #N_bit + Z_bit + C_bit + V_bit
        MOV$cond pc, lr
  ]
  [ "$cond" = "HI" :LOR: "$cond"="LT"
        MSR$cond CPSR_f, #C_bit + V_bit
        MOV$cond pc, lr
  ]
  [ "$cond" = "GT"
        MSR$cond CPSR_f, #N_bit + V_bit
        MOV$cond pc, lr
  ]
  [ "$cond" = "VC"
        BVS     %FT01                   ; Skip on opposite condition
        MSR     CPSR_f, #V_bit
        MOV     pc, lr
01
  ]
 ]
        MEND

; ****************************************************
; ***  SCPSR - Set and clear bits in PSR from the  ***
; ***  masks $set, $clr, using register $regtmp    ***
; ****************************************************
        MACRO
$label  SCPSR   $set, $clr, $regtmp, $cond, $oldpsr
        LCLS    srcreg
CPU32_set PSRto32 $set
CPU32_clr PSRto32 $clr
      [ :LNOT: No32bitCode :LAND: ((CPU32_set :OR: CPU32_clr) :AND: 3) <> 0
        ; If 32bit modes are supported and we're changing mode, make sure we clear bits 2 and 3 of the mode so we can safely switch from ABT/UND/SYS to SVC/IRQ/etc.
CPU32_clr SETA CPU32_clr :OR: 12
      ]
        [ "$oldpsr"=""
srcreg  SETS    "$regtmp"
        |
srcreg  SETS    "$oldpsr"
        ]
        [ (($set) :AND: ($clr)) <> 0
        ! 1, "Attempt to simultaneously set and clear a bit in SCPSR"
        ]
 [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT02                   ; Go round when $cond-itional
      ]
        MOV     $srcreg, pc             ; Snapshot 26-bit PSR
        MRS     $srcreg, CPSR           ; Snapshot 32-bit PSR, or NOP pre ARMv3
        TEQ     r0, r0                  ; Set Z
        MSR     CPSR_f, #0              ; Clear Z if ARMv3 or later
        BNE     %FT01
      [ (($set) :OR: ($clr)) = ARM_CC_Mask
        TEQP    pc, #$set               ; All change, so skip the clear operation
      |
        ORR     $regtmp, $srcreg, #($set) :OR: ($clr)
        TEQP    $regtmp, #$clr
      ]
        B       %FT02
01
      [ (CPU32_set :AND: &F0000000) <> 0 :LAND: (CPU32_set :AND: &F0) <> 0
        ORR     $regtmp, $srcreg, #CPU32_set :AND: &F0000000
        ORR     $regtmp, $regtmp, #CPU32_set :AND: &0FFFFFFF
srcreg  SETS "$regtmp"
      |
        [ CPU32_set <> 0
        ORR     $regtmp, $srcreg, #CPU32_set
srcreg  SETS "$regtmp"
        ]
      ]
      [ (CPU32_clr :AND: &F0000000) <> 0 :LAND: (CPU32_clr :AND: &F0) <> 0
        BIC     $regtmp, $srcreg, #CPU32_clr :AND: &F0000000
        BIC     $regtmp, $regtmp, #CPU32_clr :AND: &0FFFFFFF
srcreg  SETS "$regtmp"
      |
        [ CPU32_clr <> 0
        BIC     $regtmp, $srcreg, #CPU32_clr
srcreg  SETS "$regtmp"
        ]
      ]
        somemsr AL, CPSR, $srcreg, CPU32_set:OR:CPU32_clr:OR:&F0000000
02
 |
$label  MRS$cond $srcreg, CPSR
 [ (CPU32_set :AND: &F0000000) <> 0 :LAND: (CPU32_set :AND: &F0) <> 0
        ORR$cond $regtmp, $srcreg, #CPU32_set :AND: &F0000000
        ORR$cond $regtmp, $regtmp, #CPU32_set :AND: &0FFFFFFF
srcreg  SETS "$regtmp"
 |
 [ CPU32_set <> 0
        ORR$cond $regtmp, $srcreg, #CPU32_set
srcreg  SETS "$regtmp"
 ]
 ]
 [ (CPU32_clr :AND: &F0000000) <> 0 :LAND: (CPU32_clr :AND: &F0) <> 0
        BIC$cond $regtmp, $srcreg, #CPU32_clr :AND: &F0000000
        BIC$cond $regtmp, $regtmp, #CPU32_clr :AND: &0FFFFFFF
srcreg  SETS "$regtmp"
 |
 [ CPU32_clr <> 0
        BIC$cond $regtmp, $srcreg, #CPU32_clr
srcreg  SETS "$regtmp"
 ]
 ]
        somemsr  $cond, CPSR,$srcreg, CPU32_set:OR:CPU32_clr, unsafe
 ]
        MEND

; ****************************************************
; ***  SavePSR - Save the PSR in a register, to be ***
; ***  restored later using RestPSR                ***
; ****************************************************
        MACRO
$label  SavePSR $reg, $cond
      [ NoARMv3
$label  MOV$cond $reg, pc               ; Benign on ARMv3+
        MRS$cond $reg, CPSR             ; NOP prior to ARMv3
      |
$label  MRS$cond $reg, CPSR
      ]
        MEND

; ****************************************************
; ***  RestPSR - Restore the PSR from a register   ***
; ***  set up by SavePSR                           ***
; ***  $fields may be set to "f" if the PSR fields ***
; ***  c,x,s do not need restoring, which will     ***
; ***  save a few cycles on newer ARMs (but the    ***
; ***  No32bitCode version of the macro will set   ***
; ***  the c field anyway). Values other than "f", ***
; ***  "cf", "fc" and unset are deprecated for     ***
; ***  compatibility with No32bitCode.             ***
; ****************************************************
        MACRO
$label  RestPSR $reg, $cond, $fields
        LCLS    field
  [ "$fields"="" :LOR: "$fields"="cf" :LOR: "$fields"="fc"
field   SETS    "cf"
  |
  [ "$fields"="f"
field   SETS    "f"
  |
        !       0, "Unpredictable behaviour due to deprecated RestPSR fields parameter"
field   SETS    "$fields"
  ]
  ]
    [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT02                   ; Go round when $cond-itional
      ]
        ; The save sequences for CLRPSR, SCPSR, SETPSR, TOGPSR, TOGPSRR
        ; and WritePSRc are arranged such that the saved value prefers the one from MRS.
        ; 26 bit mode pre ARMv3 => saved value is the pc
        ; 26 bit mode ARMv3/ARMv4 => saved value is from the CPSR
        ; 32 bit mode => saved value is from the CPSR
        ; So we want to know if MSR/MRS is supported rather than if running in 32 bit mode
        TEQ     r0, r0                  ; Set Z
        MSR     CPSR_f, #0              ; Clear Z (if MSR supported)
        BNE     %FT01
        TEQP    pc, $reg                ; Let the following MSR be the NOP
01
        MSR     CPSR_cf, $reg
02
    |
$label  mymsr   $cond, CPSR_$field, $reg, , unsafe
    ]
        MEND

; **********************************************
; ***  SEC - Set carry flag - will set nzCv  ***
; **********************************************
        MACRO
$label  SEC     $cond
    [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT01                   ; Go round when $cond-itional
      ]
        CMP     pc, #0                  ; SEC in 26 bit modes
        MSR     CPSR_f, #C_bit          ; ARMv3+ does SEC, NOP on ARMv2
01
    |
$label  MSR$cond CPSR_f, #C_bit
    ]
        MEND

; ************************************************
; ***  SETPSR - Set bits in PSR from the mask  ***
; ***  in $bits, using register $regtmp        ***
; ************************************************
        MACRO
$label  SETPSR  $bits, $regtmp, $cond, $oldpsr
$label  SCPSR   $bits, 0, $regtmp, $cond, $oldpsr
        MEND

; **************************************************
; ***  SETV - Set overflow flag - will set NzcV  ***
; **************************************************
        MACRO
$label  SETV    $cond
    [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT01                   ; Go round when $cond-itional
      ]
        CMP     pc, #&80000000          ; SETV in 26 bit modes
        MSR     CPSR_f, #N_bit+V_bit    ; ARMv3+ does SETV, NOP on ARMv2
01
    |
$label  MSR$cond CPSR_f, #N_bit+V_bit
    ]
        MEND

; *********************************************************
; ***  TOGPSR - Toggle bits in PSR from the            ***
; ***  immediate mask in $bits, using register $regtmp  ***
; *********************************************************
        MACRO
$label  TOGPSR  $bits, $regtmp, $cond, $oldpsr
        LCLS    srcreg
        [ "$oldpsr"=""
srcreg  SETS    "$regtmp"
        |
srcreg  SETS    "$oldpsr"
        ]
CPU32_bits PSRto32 $bits                ; Map to 32 bit PSR
    [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT02                   ; Go round when $cond-itional
      ]
        MOV     $srcreg, pc             ; Snapshot 26-bit PSR
        MRS     $srcreg, CPSR           ; Snapshot 32-bit PSR, or NOP pre ARMv3
        TEQ     r0, r0                  ; Set Z
        MSR     CPSR_f, #0              ; Clear Z if ARMv3 or later
        BNE     %FT01
        TEQP    $srcreg, #$bits
        B       %FT02
01
        EOR     $regtmp, $srcreg, #CPU32_bits
        somemsr AL, CPSR, $regtmp, CPU32_bits
02
    |
$label  MRS$cond $srcreg, CPSR
        EOR$cond $regtmp, $srcreg, #CPU32_bits
        somemsr $cond, CPSR, $regtmp, CPU32_bits, unsafe
    ]
        MEND

; ************************************************
; ***  TOGPSRR - Toggle bits in PSR from the   ***
; ***  mask in $regtog, using register $regtmp ***
; ************************************************
        MACRO
$label  TOGPSRR $regtog, $regtmp, $cond, $oldpsr, $fields
        LCLS    srcreg
        LCLS    field
        [ "$fields"=""
field   SETS    "cxsf"
        |
field   SETS    "$fields"
        ]
        [ "$oldpsr"=""
srcreg  SETS    "$regtmp"
        |
srcreg  SETS    "$oldpsr"
        ]
    [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT02                   ; Go round when $cond-itional
      ]
        MOV     $srcreg, pc             ; Snapshot 26-bit PSR
        MRS     $srcreg, CPSR           ; Snapshot 32-bit PSR, or NOP pre ARMv3
        TEQ     r0, r0                  ; Set Z
        MSR     CPSR_f, #0              ; Clear Z if ARMv3 or later
        BNE     %FT01
        TEQP    $regtog, $srcreg
        B       %FT02
01
        EOR     $regtmp, $srcreg, $regtog
        MSR     CPSR_$field, $regtmp
02
    |
$label  MRS$cond $srcreg, CPSR
        EOR$cond $regtmp, $srcreg, $regtog
        mymsr    $cond, CPSR_$field, $regtmp, , unsafe
    ]
        MEND

; ***************************************************
; ***  WritePSRc - Set the PSR control bits to    ***
; ***  an absolute value.                         ***
; ***  Sets I,F,M[0:3], corrupts NZVC.            ***
; ***  Preserves 32-bitness. Ignored in USR mode. ***
; ***  PSR is specified as 26bit form, so only    ***
; ***  USR/IRQ/FIQ/SVC can be used as dest mode,  ***
; ***  but source can be any non-USR mode         ***
; ***  (M[2:3] will be cleared)                   ***
; ***  Use instead of TEQP PC,#$value             ***
; ***************************************************
        MACRO
$label  WritePSRc $value, $regtmp, $cond, $oldpsr
        [ ($value :AND::NOT: (I_bit+F_bit+SVC_mode)) <> 0
        ! 1, "Illegal flags for WritePSRc"
        ]
   [ No26bitCode
        ; We only care about 32bit (non-thumb) processor modes
        ; Write the PSR directly to avoid unnecessary bloat from SCPSR
$label
CPU32_bits PSRto32 $value
      [ "$oldpsr" <> ""
        MRS$cond $oldpsr, CPSR
      ]
     [ NoARMv6 :LOR: ((CPU32_bits :AND: (I32_bit+F32_bit)) <> 0) :LOR: (("$cond" <> "") :LAND: ("$cond" <> "AL"))
        MSR$cond CPSR_c, #CPU32_bits :OR: USR32_mode
      [ "$cond" <> "" :LAND: "$cond" <> "AL" :LAND: StrongARM_MSR_bug
        NOP
      ]
     |
        ; CPS is faster than CPSR_c, but is limited in that if I+F are being set they must take the same value
        CPSIE if, #(CPU32_bits :AND: M32_bits) :OR: USR32_mode
     ]
   |
$label  SCPSR   $value, (I_bit+F_bit+SVC_mode):EOR:($value), $regtmp, $cond, $oldpsr
   ]
        MEND

 ] ; :LNOT: No32bitCode

; ****************************************************
; *** mrs/msr - Lowercase funny names for aasm.    ***
; *** Due for retirement, aasm is redundant now.   ***
;*****************************************************
        MACRO
$label  mrs     $cond, $rd, $psrs
$label  MRS$cond $rd, $psrs
        MEND

        MACRO
$label  msr     $cond, $psrl, $op2a, $op2b
$label  mymsr   $cond, $psrl, $op2a, $op2b
        MEND

; ***************************************************
; *** somemsr - Set some fields of the PSR from   ***
; *** $op, according to $mask. The mask should    ***
; *** indicate which bits have been modified.     ***
; *** This saves us writing the control field,    ***
; *** when it hasn't been modified, for example,  ***
; *** saving 2 cycles on some processors.         ***
; ***************************************************
        MACRO
$label  somemsr $cond, $psr, $op, $mask, $sabug
        LCLS    s
s       SETS    "$psr._"
 [ (($mask) :AND: &FF) <> 0
s       SETS    s:CC:"c"
 ]
 [ (($mask) :AND: &FF00) <> 0
s       SETS    s:CC:"x"
 ]
 [ (($mask) :AND: &FF0000) <> 0
s       SETS    s:CC:"s"
 ]
 [ (($mask) :AND: &FF000000) <> 0
s       SETS    s:CC:"f"
 ]
$label  mymsr   $cond, $s, $op, , $sabug
        MEND

; ****************************************************
; *** mymrs - Perform an MRS operation.            ***
; *** Due for retirement, objasm supports MRS now. ***
;*****************************************************
        MACRO
$label  mymrs   $cond, $rd, $psrs
$label
        LCLA    psrtype
psrtype SETA    -1
 [ "$psrs" = "CPSR_all" :LOR: "$psrs" = "SPSR_all"
        !       0, "Deprecated form of PSR field specifier used (use no suffix)"
 ]
 [ "$psrs" = "CPSR" :LOR: "$psrs" = "CPSR_all"
psrtype SETA    0 :SHL: 22
 ]
 [ "$psrs" = "SPSR" :LOR: "$psrs" = "SPSR_all"
psrtype SETA    1 :SHL: 22
 ]
        ASSERT  psrtype <> -1
        ASSERT  $rd <> 15
        DCI     Cond_$cond :OR: 2_00000001000011110000000000000000 :OR: psrtype :OR: ($rd :SHL: 12)
        MEND

; ****************************************************
; *** mymsr - Perform an MSR operation.            ***
; *** If $sabug is set to "safe", it's assumed the ***
; *** code around this operation is sufficiently   ***
; *** protected against the StrongARM conditional  ***
; *** MSR CPSR_c bug.                              ***
; *** If $sabug is set to "unsafe", a NOP will     ***
; *** automatically be inserted when generating an ***
; *** MSR that could trigger the bug (and we're    ***
; *** targeting a StrongARM machine type).         ***
; *** If $sabug is left unset, a warning and a NOP ***
; *** will be produced whenever a dangerous MSR is ***
; *** requested (if we're targeting StrongARM)     ***
; ****************************************************
        MACRO
$label  mymsr   $cond, $psrl, $op2a, $op2b, $sabug
$label
        LCLA    psrtype
        LCLS    op2as
        LCLA    op
        LCLA    shift
        LCLS    s
s       SETS    "$psrl"
 [ s:RIGHT:4 = "_ctl" :LOR: s:RIGHT:4 = "_flg"
        !       0, "Deprecated form of PSR field specifier used (use _cxsf)"
s       SETS    s:LEFT:(:LEN:s-2)
 ]
 [ s:RIGHT:4 = "_all"
        !       0, "Deprecated form of PSR field specifier used (use _cxsf)"
s       SETS    s:LEFT:(:LEN:s-3) :CC: "cf"
 ]
 [ s:RIGHT:3 = "PSR"
        !       0, "Deprecated form of PSR field specifier used (use _cxsf)"
s       SETS    s:CC:"_cf"
 ]
psrtype SETA    0
 [ s:RIGHT:1 = "f"
psrtype SETA    psrtype :OR: (1:SHL:19)
s       SETS    s :LEFT: (:LEN:s-1)
 ]
 [ s:RIGHT:1 = "s"
psrtype SETA    psrtype :OR: (1:SHL:18)
s       SETS    s :LEFT: (:LEN:s-1)
 ]
 [ s:RIGHT:1 = "x"
psrtype SETA    psrtype :OR: (1:SHL:17)
s       SETS    s :LEFT: (:LEN:s-1)
 ]
 [ s:RIGHT:1 = "c"
psrtype SETA    psrtype :OR: (1:SHL:16)
s       SETS    s :LEFT: (:LEN:s-1)
 ]
        ASSERT  s = "CPSR_" :LOR: s = "SPSR_"
 [ s = "SPSR_"
psrtype SETA    psrtype :OR: (1:SHL:22)
 |
psrtype SETA    psrtype :OR: (0:SHL:22)
 ]
 [ (psrtype :AND: (15:SHL:16)) = 0
        ! 0, "MSR that sets no fields"
 ]
 [ ("$op2a" :LEFT: 1) = "#"
 ; Immediate operand

op2as   SETS    "$op2a" :RIGHT: ((:LEN: "$op2a")-1)
op      SETA    $op2as

  [ "$op2b" = ""
  ; Rotate not specified in immediate operand
shift   SETA    0
        WHILE   (op :AND: &FFFFFF00)<>0 :LAND: shift<16
op      SETA    ((op:SHR:30):AND:3):OR:(op:SHL:2)
shift   SETA    shift + 1
        WEND
        ASSERT  (op :AND: &FFFFFF00)=0
  |
  ; Rotate of immediate operand specified explicitly
        ASSERT  (($op2b):AND:&FFFFFFE1)=0
shift   SETA    ($opt2b):SHR:1
  ]
op      SETA    (shift :SHL: 8) :OR: op :OR: (1:SHL:25)
 |

 ; Not an immediate operand
  [ "$op2b" = ""
  ; Unshifted register
op      SETA    ($op2a) :OR: (0:SHL:25)
  |
        ! 1, "Shifted register not yet implemented in this macro!"
  ]
 ]
        DCI     Cond_$cond :OR: 2_00000001001000001111000000000000 :OR: op :OR: psrtype
     [ StrongARM_MSR_bug :LAND: "$sabug" <> "safe" :LAND: "$cond" <> "AL" :LAND: "$cond" <> "" :LAND: ((psrtype :AND: &410000) = &10000)
      [ "$sabug" <> "unsafe"
        ! 0, "mymsr inserting NOP for StrongARM MSR CPSR_c bug", 1
      ]
        NOP
     ]
        MEND

; This next group of macros (SetMode, SExx, CLxx, and combinations) are
; optimised for 32bit architectures:
;
; * 32bit-only processor modes (e.g. SYS) are fully supported
; * Except for the T bit (assumed to be 0), only the indicated PSR fields will be touched (e.g. NZCV always preserved)
; * They assemble down to one instruction (CPS or MRS) wherever possible
;   * Due to the limits of CPS this means they're all unconditional
;   * For the one-instruction MRS form you'll have to provide 'hints' for the current mode/IF bits. But even though you're specifying the mode + interrupt flags, these macros are still better than WritePSRc (for ARMv6+)
; * When building 26/32bit neutral or 26bit-only versions:
;   * The saved PSR will be the CPSR if MRS supported, else it's a saved PC (same rules as SavePSR, WritePSRc, etc.)
;   * The SetMode macros will preserve the 32bit-ness of the host, unless asked to switch into a 32bit-only mode (e.g. SYS)
;
; Note the side-effects of SEI/SEF/CLI/CLF. The macros assume that if IRQ state
; is being altered, FIQs are enabled, and if FIQ state is being altered, IRQs
; are disabled. This is based on the premise that it's unsafe/unreliable to
; have FIQs disabled while IRQs are enabled (RISC OS generally assumes FIQs are
; enabled, so if you have FIQs disabled but IRQs enabled it would be easy for
; an IRQ handler to come along and do something which enables FIQs).

; ****************************************************
; *** SetMode - sets processor mode to constant    ***
; *** value newmode using register regtmp as a     ***
; *** temporary.                                   ***
; *** If $irqs is provided it's expected to be the ***
; *** current I32+F32 flags                        ***
; *** $regtmp only required if 26bit support       ***
; *** required, or no $irqs provided.              ***
; ****************************************************
        MACRO
        SetMode $newmode, $regtmp, $oldpsr, $irqs
    [ :LNOT: NoARMv6
      [ "$oldpsr"<>""
        MRS     $oldpsr, CPSR
      ]
        CPS     #$newmode
    ELIF No26bitCode :LOR: ($newmode > SVC32_mode)
      [ "$oldpsr"<>""
        MRS     $oldpsr, CPSR
      ]
      [ "$irqs" <> ""
        MSR     CPSR_c, #$newmode + $irqs
      ELIF "$oldpsr"=""
        MRS     $regtmp, CPSR
        BIC     $regtmp, $regtmp, #M32_bits
        ORR     $regtmp, $regtmp, #$newmode
        MSR     CPSR_c, $regtmp
      |
        BIC     $regtmp, $oldpsr, #M32_bits
        ORR     $regtmp, $regtmp, #$newmode
        MSR     CPSR_c, $regtmp
      ]
    |
        ; Use SCPSR for 26/32bit-friendly PSR manipulation
        SCPSR   ($newmode :AND: 3), ($newmode :AND: 3) :EOR: 3, $regtmp, , $oldpsr
    ]
        MEND

; *************************************************
; *** SEI  - Disable IRQs, may enable FIQs      ***
; *** SEF  - Disable FIQs, may disable IRQs     ***
; *** SEIF - Disable IRQs+FIQs                  ***
; *** If $mode is provided (preferred) then it  ***
; *** must be the current 32bit processor mode. ***
; *** $regtmp only required if 26bit support    ***
; *** required, or no $mode provided.           ***
; *************************************************
        MACRO
        SE$op   $mode, $regtmp, $oldpsr
CPU32_bits IFto32 $op
    [ :LNOT: NoARMv6
      [ "$oldpsr" <> ""
        MRS     $oldpsr, CPSR
      ]
        CPSID   $op
    ELIF ("$mode" <> "") :LAND: (No26bitCode :LOR: (($mode + 0) > SVC32_mode))
      [ "$oldpsr" <> ""
        MRS     $oldpsr, CPSR
      ]
        MSR     CPSR_c, #$mode+(CPU32_bits :OR: I32_bit)
    |
        ; Use SETPSR for 26/32bit-friendly PSR manipulation
        SETPSR  CPU32_bits :SHL: IF32_26Shift, $regtmp, , $oldpsr
    ]
        MEND

; *************************************************
; *** CLI  - Enable IRQs, may enable FIQs       ***
; *** CLF  - Enable FIQs, may disable IRQs      ***
; *** CLIF - Enable IRQs+FIQs                   ***
; *** If $mode is provided (preferred) then it  ***
; *** must be the current 32bit processor mode. ***
; *** $regtmp only required if 26bit support    ***
; *** required, or no $mode provided.           ***
; *************************************************
        MACRO
        CL$op   $mode, $regtmp, $oldpsr
CPU32_bits IFto32 $op
    [ :LNOT: NoARMv6
      [ "$oldpsr" <> ""
        MRS     $oldpsr, CPSR
      ]
        CPSIE   $op
    ELIF ("$mode" <> "") :LAND: (No26bitCode :LOR: (($mode + 0) > SVC32_mode))
      [ "$oldpsr" <> ""
        MRS     $oldpsr, CPSR
      ]
        MSR     CPSR_c, #$mode+I32_bit+F32_bit-(CPU32_bits :OR: F32_bit)
    |
        ; Use CLRPSR for 26/32bit-friendly PSR manipulation
        CLRPSR  CPU32_bits :SHL: IF32_26Shift, $regtmp, , $oldpsr
    ]
        MEND

; ***************************************************************
; *** SetModeSEI  - Set mode + disable IRQs, may enable FIQs  ***
; *** SetModeSEF  - Set mode + disable FIQs, may disable IRQs ***
; *** SetModeSEIF - Set mode + disable IRQs+FIQs              ***
; *** $regtmp only required if 26bit support required         ***
; ***************************************************************
        MACRO
        SetModeSE$op   $mode, $regtmp, $oldpsr
CPU32_bits IFto32 $op
    [ :LNOT: NoARMv6
      [ "$oldpsr" <> ""
        MRS     $oldpsr, CPSR
      ]
        CPSID   $op, #$mode
    ELIF No26bitCode :LOR: ($mode > SVC32_mode)
      [ "$oldpsr" <> ""
        MRS     $oldpsr, CPSR
      ]
        MSR     CPSR_c, #$mode+(CPU32_bits :OR: I32_bit)
    |
        LCLA    clear_bits
        LCLA    set_bits
set_bits   SETA ($mode :AND: 3) + (CPU32_bits :SHL: IF32_26Shift)
clear_bits SETA 3 :AND: :NOT: set_bits
        SCPSR   &$set_bits, &$clear_bits, $regtmp, , $oldpsr
    ]
        MEND

; **************************************************************
; *** SetModeCLI  - Set mode + enable IRQs, may enable FIQs  ***
; *** SetModeCLF  - Set mode + enable FIQs, may disable IRQs ***
; *** SetModeCLIF - Set mode + enable IRQs+FIQs              ***
; *** $regtmp only required if 26bit support required        ***
; **************************************************************
        MACRO
        SetModeCL$op   $mode, $regtmp, $oldpsr
CPU32_bits IFto32 $op
    [ :LNOT: NoARMv6
      [ "$oldpsr" <> ""
        MRS     $oldpsr, CPSR
      ]
        CPSIE   $op, #$mode
    ELIF No26bitCode :LOR: ($mode > SVC32_mode)
      [ "$oldpsr" <> ""
        MRS     $oldpsr, CPSR
      ]
        MSR     CPSR_c, #$mode+I32_bit+F32_bit-(CPU32_bits :OR: F32_bit)
    |
        LCLA    clear_bits
        LCLA    set_bits
set_bits   SETA $mode :AND: 3
clear_bits SETA (3 :AND: :NOT: set_bits) + (CPU32_bits :SHL: IF32_26Shift)
        SCPSR   &$set_bits, &$clear_bits, $regtmp, , $oldpsr
    ]
        MEND

 ] ; :LNOT: :DEF: Included_Hdr_CPU_Generic32

        OPT     OldOpt
        END
@


4.22
log
@Add new PSR manipulation macros, optimised for 32bit machines
Detail:
  Many of our existing PSR manipulation macros (specifically, ones used for changing mode or controlling interrupts) are based around the code sequences you'd typically use on a 26bit system. Although this has worked well in terms of producing a 32bit version of the OS, it's also left us with macros that can be sub-optimal for 32bit machines, or are inconvenient to use due to the potential of corrupting other PSR flags
  This change adds a new set of macros which are designed and optimised for 32bit-only targets, but can still fall back to 26/32bit neutral or 26bit-only configurations
  hdr/CPU/Generic32:
  - Add the new macros (SEI, CLI, SetModeSEI, SetModeCLI & variants).
  - Improve existing SetMode macro to add 26bit compatibility, and to add an extra optimisation for pre-ARMv6 (emit single MSR if IRQ state is known)
  - Improve SCPSR to allow the source mode to be any 32bit mode
  - Fix conditional 26bit/32bit neutral SCPSR - the 32bit check TEQ corrupts NZCV so we can't do conditional execution on $cond after it (and we've already branched on the opposite condition anyway)
  - Fix 26bit/32bit neutral SCPSR to preserve NZCV when following the MSR code path
  - Make CLRPSR and SETPSR just call through to SCPSR - in terms of output the first two have no advantages over SCPSR
  - Update WritePSRc documentation to reflect that it can now be used in any (non-USR) source mode
  hdr/CPU/Generic26:
  - Update WritePSRc documentation to match Generic32
Admin:
  Tested on Raspberry Pi
  Output of new macros manually checked for various machine types (RPi, Tungsten, All, 26)


Version 2.65. Tagged as 'HdrSrc-2_65'
@
text
@d872 1
a872 1
    ELIF No26bitCode :LOR: ($mode > SVC32_mode)
@


4.21
log
@Add new "26" machine type. Simplify ARM2 support.
Detail:
  hdr/Machine/26, hdr/Machine/Machine - Add new "26" machine type, which targets all 26 bit machines/OS versions (running only in 26 bit mode)
  hdr/CPU/Arch - Use ELIF to avoid bracket spam. Remove duplicate CortexA7 case.
  hdr/CPU/Generic26 - Add NOPs to PSR manipulation macros in order to make them ARM2-safe (Generic32 macros are already structured to have suitable NOPs when generating 32bit-neutral code, so it makes sense for Generic26 to take care of ARM2 as well). This removes the need for components which use these macros to insert any manual NOPs, whether for the StrongARM MSR bug or the ARM2 TEQP bug.
  hdr/CPU/Generic32 - Flag the StrongARM MSR NOP diagnostic message as a warning, so the line number can be included in the output, so developers can more easily investigate the issue.
Admin:
  Tested with PlingSystem build


Version 2.63. Tagged as 'HdrSrc-2_63'
@
text
@d96 23
a122 4
        GBLA    CPU32_bits
        GBLA    CPU32_set
        GBLA    CPU32_clr

d162 1
a162 43
	LCLS	srcreg
        [ "$oldpsr"=""
srcreg  SETS    "$regtmp"
        |
srcreg  SETS    "$oldpsr"
        ]
CPU32_bits PSRto32 $bits                ; Map to 32 bit PSR
    [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT02                   ; Go round when $cond-itional
      ]
        MOV     $srcreg, pc             ; Snapshot 26-bit PSR
        MRS     $srcreg, CPSR           ; Snapshot 32-bit PSR, or NOP pre ARMv3
        TEQ     r0, r0                  ; Set Z
        MSR     CPSR_f, #0              ; Clear Z if ARMv3 or later
        BNE     %FT01
        BIC     $regtmp, $srcreg, #$bits
        TEQP    $regtmp, #0
        B       %FT02
01
      [ (CPU32_bits :AND: &F0000000) <> 0 :LAND: (CPU32_bits :AND: &F0) <> 0
        ; Can't be expressed as a single ARM immediate constant
        BIC     $regtmp, $srcreg, #CPU32_bits :AND: &F0000000
        BIC     $regtmp, $regtmp, #CPU32_bits :AND: &0FFFFFFF
      |
        BIC     $regtmp, $srcreg, #CPU32_bits
      ]
        somemsr AL, CPSR, $regtmp, CPU32_bits
02
    |
$label  MRS$cond $srcreg, CPSR
        [ (CPU32_bits :AND: &F0000000) <> 0 :LAND: (CPU32_bits :AND: &F0) <> 0
        ; Can't be expressed as a single ARM immediate constant
        BIC$cond $regtmp, $srcreg, #CPU32_bits :AND: &F0000000
        BIC$cond $regtmp, $regtmp, #CPU32_bits :AND: &0FFFFFFF
        |
        BIC$cond $regtmp, $srcreg, #CPU32_bits
        ]
        somemsr $cond, CPSR, $regtmp, CPU32_bits, unsafe
    ]
d360 4
d385 1
a385 1
        TEQ$cond.P pc, #$set            ; All change, so skip the clear operation
d387 2
a388 2
        ORR$cond   $regtmp, $srcreg, #($set) :OR: ($clr)
        TEQ$cond.P $regtmp, #$clr
d393 2
a394 2
        ORR$cond $regtmp, $srcreg, #CPU32_set :AND: &F0000000
        ORR$cond $regtmp, $regtmp, #CPU32_set :AND: &0FFFFFFF
d398 1
a398 1
        ORR$cond $regtmp, $srcreg, #CPU32_set
d403 2
a404 2
        BIC$cond $regtmp, $srcreg, #CPU32_clr :AND: &F0000000
        BIC$cond $regtmp, $regtmp, #CPU32_clr :AND: &0FFFFFFF
d408 1
a408 1
        BIC$cond $regtmp, $srcreg, #CPU32_clr
d412 1
a412 1
        somemsr  $cond, CPSR, $srcreg, CPU32_set:OR:CPU32_clr, unsafe
d529 1
a529 43
        LCLS    srcreg
        [ "$oldpsr"=""
srcreg  SETS    "$regtmp"
        |
srcreg  SETS    "$oldpsr"
        ]
CPU32_bits PSRto32 $bits                ; Map to 32 bit PSR
    [ NoARMv3
$label
      [ "$cond"<>"" :LAND: "$cond"<>"AL"
        LCLS    rcc
rcc     SETS    :REVERSE_CC:"$cond"
        B$rcc   %FT02                   ; Go round when $cond-itional
      ]
        MOV     $srcreg, pc             ; Snapshot 26-bit PSR
        MRS     $srcreg, CPSR           ; Snapshot 32-bit PSR, or NOP pre ARMv3
        TEQ     r0, r0                  ; Set Z
        MSR     CPSR_f, #0              ; Clear Z if ARMv3 or later
        BNE     %FT01
        ORR     $regtmp, $srcreg, #$bits
        TEQP    $regtmp, #0
        B       %FT02
01
      [ (CPU32_bits :AND: &F0000000) <> 0 :LAND: (CPU32_bits :AND: &F0) <> 0
        ; Can't be expressed as a single ARM immediate constant
        ORR     $regtmp, $srcreg, #CPU32_bits :AND: &F0000000
        ORR     $regtmp, $regtmp, #CPU32_bits :AND: &0FFFFFFF
      |
        ORR     $regtmp, $srcreg, #CPU32_bits
      ]
        somemsr AL, CPSR, $regtmp, CPU32_bits
02
    |
$label  MRS$cond $srcreg, CPSR
        [ (CPU32_bits :AND: &F0000000) <> 0 :LAND: (CPU32_bits :AND: &F0) <> 0
        ; Can't be expressed as a single ARM immediate constant
        ORR$cond $regtmp, $srcreg, #CPU32_bits :AND: &F0000000
        ORR$cond $regtmp, $regtmp, #CPU32_bits :AND: &0FFFFFFF
        |
        ORR$cond $regtmp, $srcreg, #CPU32_bits
        ]
        somemsr $cond, CPSR, $regtmp, CPU32_bits, unsafe
    ]
d633 11
a643 9
; *************************************************
; ***  WritePSRc - Set the PSR control bits to  ***
; ***  an absolute value.                       ***
; ***  Sets I,F,M[0:1], corrupts NZVC.          ***
; ***  Preserves 32-bitness.                    ***
; ***  Only use in IRQ26/32,FIQ26/32,SVC26/32   ***
; ***  Ignored in USR modes, illegal in others  ***
; ***  Use instead of TEQP PC,#$value           ***
; *************************************************
d837 19
d860 4
d866 13
a878 3
        SetMode $newmode, $regtmp, $oldpsr
    [ NoARMv6
      [ "$oldpsr"=""
a883 1
        MRS     $oldpsr, CPSR
d886 1
a886 1
        MSR      CPSR_c, $regtmp
d889 105
a993 1
      [ "$oldpsr"<>""
d996 7
a1002 1
        CPS     #$newmode
@


4.20
log
@Optimise DivRem and PSR manipulation macros
Detail:
  hdr/Macros - DivRem is now able to use UDIV when building for architectures that support it. A "norem" option is also available, to allow the remainder calculation to be skipped if it's not needed (since we don't get it for free when using UDIV).
  hdr/CPU/Generic32 - PHPSEI, WritePSRc and SetMode now use the ARMv6 CPS instruction where possible, delivering performance gains compared to the equivalent MSR. Where CPS isn't used, WritePSRc now attempts to emit a single MSR instead of the 4 instructions generated by the SCPSR macro.
Admin:
  Tested on Cortex-A15
  PSR manipulation macros trialed on a few different CPU architectures to arrive at the conclusion that CPS is as good or better than MSR


Version 2.60. Tagged as 'HdrSrc-2_60'
@
text
@d890 1
a890 1
        ! 0, "mymsr inserting NOP for StrongARM MSR CPSR_c bug"
@


4.19
log
@  Add a symbol definition for HYP mode
Detail:
  This is the mode used for hypervisor exceptions in ARMv7VE and later.


Version 2.56. Tagged as 'HdrSrc-2_56'
@
text
@d232 8
a239 1
  [ "$regtmp" = "" :LOR: StrongARM_MSR_bug
d708 18
d727 1
d903 1
d915 6
@


4.18
log
@  Workaround StrongARM bug in PLP macro
Detail:
  Conditional MSR bug applied to the version of PLP that's used when both
  pre-ARMv3 and 32-bit compatibility is required (e.g. disc builds).
Admin:
  Spotted by Sprow

Version 2.32. Tagged as 'HdrSrc-2_32'
@
text
@d70 1
@


4.18.2.1
log
@  Cross-compile version of HdrSrc
Detail:
  Mostly a question of changing directory separators and removing reliance
  upon path variables and system variable expansion. One day, when all
  components use the shared makefiles (or at least use the necessary -pd and
  -i switches to objasm), we will be able to switch over to using this
  version for all builds. In the meantime, I have created a new branch for
  the HdrSrc component, called XCompile, to store these changes. The downside
  is the fact that we'll now have to maintain unrelated changes on both
  branches until they can be merged.
Admin:
  Tested by cross-assembling the BASIC module.

Version 2.46, 4.247.2.1. Tagged as 'HdrSrc-2_46-4_247_2_1'
@
text
@d34 1
a34 1
        GET     Machine/$Machine
@


4.17
log
@  Bugfix to macros in Hdr:CPU.Generic32
Detail:
  A number of these macros, when build targeting all CPUs (e.g. in disc builds)
  only worked correctly if a register was specified to leave the original
  PSR state in.
Admin:
  Untested, but no risk to ROM builds.

Version 2.28. Tagged as 'HdrSrc-2_28'
@
text
@d260 1
a260 1
        mymsr   EQ, CPSR_c, $usereg, , safe    ; Is a NOP pre ARMv3
@


4.16
log
@  Second of a two-part update of HdrSrc.
Detail:
  Hdr:System:
  * Hdr:CPU.Arch added to the list of header files included here. This is
    because it's now needed by Hdr:CPU.Generic*.
  Hdr:CPU.Generic*:
  * Reintroduced ARMv2 compatibility to many macros. Should allow a new
    universal boot sequence to be constructed.
  * SCPSR in Generic26 optimised in cases where no PSR bits are preserved.
  * RemovePSRFromReg optimised for 32bit-only builds - becomes a no-op.
  Hdr:Machine.Machine:
  * Reordering of braces so that symbol "HAL" doesn't have to be defined -
    useful for disc builds, which target both HAL and non-HAL machines, so
    the symbol is undefined.
  * Added some comments and an assert about No26bitCode and No32bitCode.
Admin:
  Update originally from Rob Sprowson, bugfixes and additions and split into
  two parts by me.

Version 2.26. Tagged as 'HdrSrc-2_26'
@
text
@d156 1
a156 2
        MOV     $srcreg, #T32_bit       ; Invalid CPSR setting detects if MRS is a NOP
        MOV     $regtmp, pc             ; Snapshot 26-bit PSR
d158 4
a161 6
        TEQ     $srcreg, #T32_bit
        BNE     %FT01                   ; Branch because Z flag might be in $bits
      [ "$oldpsr" <> ""
        MOV     $srcreg, $regtmp
      ]
        BIC     $regtmp, $regtmp, #$bits
d390 1
a390 2
        MOV     $srcreg, #T32_bit       ; Invalid CPSR setting detects if MRS is a NOP
        MOV     $regtmp, pc             ; Snapshot 26-bit PSR
d392 3
a394 5
        TEQ     $srcreg, #T32_bit
        BNE     %FT01                   ; Branch because Z flag might be in $bits
      [ "$oldpsr" <> ""
        MOV     $srcreg, $regtmp
      ]
d398 1
a398 1
        ORR$cond   $regtmp, $regtmp, #($set) :OR: ($clr)
d554 1
a554 2
        MOV     $srcreg, #T32_bit       ; Invalid CPSR setting detects if MRS is a NOP
        MOV     $regtmp, pc             ; Snapshot 26-bit PSR
d556 4
a559 6
        TEQ     $srcreg, #T32_bit
        BNE     %FT01                   ; Branch because Z flag might be in $bits
      [ "$oldpsr" <> ""
        MOV     $srcreg, $regtmp
      ]
        ORR     $regtmp, $regtmp, #$bits
d625 1
a625 2
        MOV     $srcreg, #T32_bit       ; Invalid CPSR setting detects if MRS is a NOP
        MOV     $regtmp, pc             ; Snapshot 26-bit PSR
d627 4
a630 6
        TEQ     $srcreg, #T32_bit
        BNE     %FT01                   ; Branch because Z flag might be in $bits
      [ "$oldpsr" <> ""
        MOV     $srcreg, $regtmp
      ]
        TEQP    $regtmp, #$bits
d668 1
a668 2
        MOV     $srcreg, #T32_bit       ; Invalid CPSR setting detects if MRS is a NOP
        MOV     $regtmp, pc             ; Snapshot 26-bit PSR
d670 4
a673 6
        TEQ     $srcreg, #T32_bit
        BNE     %FT01                   ; Branch because Z flag might be in $bits
      [ "$oldpsr" <> ""
        MOV     $srcreg, $regtmp
      ]
        TEQP    $regtog, $regtmp
@


4.15
log
@  First of a two-part update of Hdr:CPU.Generic*
Detail:
  Changes split into two parts to make the diffs readable. In this part:
  * Simplified the inclusion of Hdr:Machine.<Machine> - all current builds
    require a new enough version of objasm that the bug with GET directives
    inside conditionals appears to no longer apply.
  * A number of macros used to have large switches of almost-identical code
    depending upon whether an optional register was defined or not - these
    are now simplified by using a local variable to hold the register.
  * RETURNS is no longer wrapped in :LNOT: No26bitCode, since it could still
    be useful for exception return, non-transient callback handlers etc.
    However, its presence is still a warning sign for non-32-bit-compatible
    code, so it emits a warning unless you add an extra argument to indicate
    that you've vetted that the code is 32-bit safe.
  * Operator precedence bug fixed in SCPSR from Generic32 copied across to
    Generic26 (applies if bits to set/clear were given as expressions).
  * Conflicting set and clear bits in SCPSR now produce an error in both
    Generic26 and Generic32 (previously was only a warning in Generic26).
  * Added the same flag bit check in WritePSRc in Generic26 as already
    existed in Generic32.
  * Some comments reformatted for consistency.
  * Uses of mymrs replaced with MRS, and unconditional or flag-only uses of
    mymsr macro replaced with MSR (other ones remain to deal with the
    StrongARM bug).
  * RETURNVC and RETURNVS no longer accept NV condition code.
  * Removed BKPT macro (now implemented natively in objasm).
Admin:
  Update originally from Rob Sprowson, bugfixed and split into two parts by me.

Version 2.25. Tagged as 'HdrSrc-2_25'
@
text
@d121 11
d133 1
d149 29
d187 1
d195 11
d207 1
d224 10
d246 1
d261 6
d268 1
d277 14
d315 1
d324 14
d366 1
d386 46
d454 1
d463 4
d468 1
d495 21
d517 1
d525 11
d537 1
d553 29
d591 1
d599 11
d611 1
d627 22
d652 1
d673 22
d698 1
@


4.14
log
@Add protection against StrongARM conditional MSR CPSR_c bug
Detail:
  hdr/Machine/Machine - Add new StrongARM_MSR_bug global that's TRUE when we're targeting a StrongARM-compatible machine type.
  Corrected No26bitCode and No32bitCode comments to say that it's all about whether we're supporting 26/32bit processor modes, not about whether we're targetting 26/32bit only processors
  hdr/CPU/Generic32 - Modify macros to protect against StrongARM MSR bug where appropriate.
Admin:
  Tested with IOMD softload on StrongARM RiscPC.
  Fixes issue with Maestro crashing due to MSR bug creating a stack imbalance in SoundScheduler.


Version 1.96. Tagged as 'HdrSrc-1_96'
@
text
@d121 1
a121 1
$label  mymsr   $cond, CPSR_f, #0
d136 2
a137 2
$label  mymrs   $cond, $srcreg, CPSR
CPU32_bits  PSRto32 $bits
d139 1
d153 1
a153 1
$label  mymsr   $cond, CPSR_f, #C_bit
d163 1
d165 1
a165 6
  [     "$regtmp" = "" :LOR: StrongARM_MSR_bug
$label  mymrs   AL, R14, CPSR
        TST     R14, #I32_bit                  ; is I32_bit set?
        ORREQ   R14, R14, #I32_bit             ; no, then set it
        mymsr   EQ, CPSR_c, R14, , safe
        BICEQ   R14, R14, #I32_bit             ; $reg contains original PSR
d167 1
a167 4
$label  mymrs   AL, R14, CPSR
        TST     R14, #I32_bit                  ; is I32_bit set?
        ORREQ   $regtmp, R14, #I32_bit         ; no, then set it
        mymsr   EQ, CPSR_c, $regtmp            ; $reg contains original PSR
d169 7
d177 4
a180 12
  [     "$regtmp" = "" :LOR: StrongARM_MSR_bug
$label  mymrs   AL, $register, CPSR
        TST     $register, #I32_bit            ; is I32_bit set?
        ORREQ   $register, $register, #I32_bit ; no, then set it
        mymsr   EQ, CPSR_c, $register, , safe
        BICEQ   $register, $register, #I32_bit ; $reg contains original PSR
  |
$label  mymrs   AL, $register, CPSR
        TST     $register, #I32_bit            ; is I32_bit set?
        ORREQ   $regtmp, $register, #I32_bit   ; no, then set it
        mymsr   EQ, CPSR_c, $regtmp            ; $reg contains original PSR
  ]
d190 1
d192 1
a192 1
$label  mymsr   AL, CPSR_c, R14
d194 1
a194 1
$label  mymsr   AL, CPSR_c, $register
d196 1
d205 3
a207 1
01
d211 2
a212 2
  [ "$cond" = "NE" :LOR: "$cond"="CC" :LOR: "$cond"="LO" :LOR: "$cond"="PL" :LOR: "$cond"="LS" :LOR: "$cond"="GE" :LOR: "$cond"="GT" :LOR: "$cond"="AL" :LOR: "$cond"="" :LOR: "$cond"="NV"
        mymsr    $cond, CPSR_f, #0
d216 1
a216 1
        mymsr    $cond, CPSR_f, #N_bit + Z_bit + C_bit
d220 1
a220 1
        mymsr    $cond, CPSR_f, #C_bit
d223 3
a225 4
  [ . - %BT01 = 0
        ; branch over on opposite condition
        DCI     &1A000001 :EOR: Cond_$cond
        mymsr  ,CPSR_f, #0
d227 1
d237 3
a239 1
01
d243 2
a244 2
  [ "$cond" = "NE" :LOR: "$cond"="CC" :LOR: "$cond"="LO" :LOR: "$cond"="PL" :LOR: "$cond"="LS" :LOR: "$cond"="AL" :LOR: "$cond"="" :LOR: "$cond"="NV"
        mymsr    $cond, CPSR_f, #V_bit
d248 1
a248 1
        mymsr    $cond, CPSR_f, #N_bit + Z_bit + C_bit + V_bit
d252 1
a252 1
        mymsr    $cond, CPSR_f, #C_bit + V_bit
d256 1
a256 1
        mymsr    $cond, CPSR_f, #N_bit + V_bit
d259 3
a261 4
  [ . - %BT01 = 0
        ; branch over on opposite condition
        DCD     &1A000001 :EOR: Cond_$cond
        mymsr  ,CPSR_f, #V_bit
d263 1
d274 2
a280 1
$label  mymrs   $cond, $srcreg, CPSR
d284 1
a284 2
CPU32_set PSRto32 $set
CPU32_clr PSRto32 $clr
d314 1
a314 1
$label  mymrs   $cond, $reg, CPSR
d319 1
a319 1
; ***  set up by SavePSR                          ***
d349 1
a349 1
$label  mymsr   $cond, CPSR_f, #C_bit
d364 2
a365 2
$label  mymrs   $cond, $srcreg, CPSR
CPU32_bits PSRto32 $bits
d367 1
d381 1
a381 1
$label  mymsr   $cond, CPSR_f, #N_bit+V_bit
d384 4
a387 4
; ***********************************************
; ***  TOGPSR - Toggle bits in PSR from the   ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
d396 2
a397 2
$label  mymrs   $cond, $srcreg, CPSR
CPU32_bits PSRto32 $bits
d402 4
a405 4
; ***********************************************
; ***  TOGPSRR - Toggle bits in PSR from the  ***
; ***  mask in $regtog, using reg $regtmp     ***
; ***********************************************
d420 1
a420 1
$label  mymrs    $cond, $srcreg, CPSR
d444 4
a447 1
; Original AAsm macros
d450 1
a450 1
$label  mymrs   $cond, $rd, $psrs
a457 1

d485 4
a488 1
; Funny names for ObjAsm compatibility
d608 5
a612 8
; SetMode newmode, reg1, regoldpsr
;
; Sets processor mode to constant value newmode
; using register reg1 as a temporary.
; If regoldpsr is specified, then this register
; on exit holds the old PSR before the mode change
; reg1 on exit always holds the new PSR after the mode change

d614 12
a625 22
        SetMode $newmode, $reg1, $regoldpsr
 [ "$regoldpsr"=""
        mymrs   AL, $reg1, CPSR
        BIC     $reg1, $reg1, #&1F
        ORR     $reg1, $reg1, #$newmode
        mymsr   AL, CPSR_c, $reg1
 |
        mymrs   AL, $regoldpsr, CPSR
        BIC     $reg1, $regoldpsr, #&1F
        ORR     $reg1, $reg1, #$newmode
        mymsr   AL, CPSR_c, $reg1
 ]
        MEND

; Assembly of the ARMv5 BKPT instruction

        MACRO
$lbl    BKPT    $val
        [ $val < 0 :LOR: $val > &FFFF
        ! 0, "immediate value out of range"
        ]
        DCI     &E1200070 + ((($val) :SHR: 4) :SHL: 8) + (($val) :AND: &F)
@


4.13
log
@  Updates to Hdr:CPU.Generic32
Detail:
  Added definitions of new CPSR bits and moitor mode in newer ARM cores
Admin:
  Used in OMAP3 builds, but needs to be on the trunk because the Debugger
  module will use the definitions in other builds.

Version 1.68. Tagged as 'HdrSrc-1_68'
@
text
@d33 4
d144 1
a144 1
        somemsr $cond, CPSR, $regtmp, CPU32_bits
d163 1
a163 1
  [     "$regtmp" = ""
d167 1
a167 1
        mymsr   EQ, CPSR_c, R14
d176 1
a176 1
  [     "$regtmp" = ""
d180 1
a180 1
        mymsr   EQ, CPSR_c, $register
d228 1
a228 1
        DCD     &1A000001 :EOR: Cond_$cond
d306 1
a306 1
        somemsr  $cond, CPSR,$srcreg, CPU32_set:OR:CPU32_clr
d342 1
a342 1
$label  mymsr   $cond, CPSR_$field, $reg
d373 1
a373 1
        somemsr $cond, CPSR, $regtmp, CPU32_bits
d399 1
a399 1
        somemsr $cond, CPSR, $regtmp, CPU32_bits
d422 1
a422 1
        mymsr    $cond, CPSR_$field, $regtmp
d465 1
a465 1
$label  somemsr $cond, $psr, $op, $mask
d480 1
a480 1
$label  mymsr   $cond, $s, $op
d500 1
a500 1
        &       Cond_$cond :OR: 2_00000001000011110000000000000000 :OR: psrtype :OR: ($rd :SHL: 12)
d503 14
d518 1
a518 1
$label  mymsr   $cond, $psrl, $op2a, $op2b
d594 7
a600 1
        &       Cond_$cond :OR: 2_00000001001000001111000000000000 :OR: op :OR: psrtype
d633 1
a633 1
        DCD     &E1200070 + ((($val) :SHR: 4) :SHL: 8) + (($val) :AND: &F)
@


4.12
log
@Addition (manually at present) of new allocations requested from AMG.
Addition of Tungsten machine and Iyonix user interface.
New 1024k ROM image size.

Version 1.35. Tagged as 'HdrSrc-1_35'
@
text
@d38 9
d64 1
d71 4
@


4.12.2.1
log
@Merged trunk version 1.68 to branch Cortex

Version 1.62, 4.162.2.7. Tagged as 'HdrSrc-1_62-4_162_2_7'
@
text
@a37 9
IT32_bits *     &0600FC00
J32_bit *       1 :SHL: 24
GE3_bit *       1 :SHL: 19
GE2_bit *       1 :SHL: 18
GE1_bit *       1 :SHL: 17
GE0_bit *       1 :SHL: 16
GE32_bits *     2_1111 :SHL: 16
E32_bit *       1 :SHL: 9
A32_bit *       1 :SHL: 8
a54 1
MON32_mode      *       2_10110
a60 4
r13_mon         RN      13
r14_mon         RN      14
lr_mon          RN      14

@


4.11
log
@  Some maintenance of Hdr:CPU.GenericXX.
Detail:
  * Added register definitions for the new registers in those wacky new ARM2
    chips, r8_fiq and r9_fiq.
  * Added abort and undefined mode register definitions using the ARM ARM
    standardised suffix of _abt and _und (previously we only had _abort and
    _undef versions).
  * Added some sanity checking of the fields parameter to the RestPSR macro,
    to help warn the unwary of the effect of compiling No32bitCode.
Admin:
  Changes appear to function as desired. Debug builds of MPEGDriver actually
  require those extra register definitions.

Version 1.23. Tagged as 'HdrSrc-1_23'
@
text
@d37 1
d41 1
a41 1
M32_bits *	2_11111
@


4.10
log
@  Fixed typo in TOGPSRR macro.
Detail:
  $regtop instead of $regtmp meant that 32-bit builds would fail to
    assemble correctly.
Admin:
  Required by PDModules 4.45 and later

Version 1.05. Tagged as 'HdrSrc-1_05'
@
text
@d64 4
d72 4
d302 7
d312 3
a314 2
  [ "$fields"=""
$label  mymsr   $cond, CPSR_cf, $reg
d316 6
a321 1
$label  mymsr   $cond, CPSR_$fields, $reg
d323 1
@


4.9
log
@* Optimised conditional RETURNVS and RETURNVC macros.
* Added new flags and bits to Hdr:MEMM.ARM600.
* Added "HAL" switch in Hdr:Machine.Machine. True only for my prototype M_32.

Version 1.03. Tagged as 'HdrSrc-1_03'
@
text
@d381 1
a381 1
        mymsr    $cond, CPSR_$field, $regtop
@


4.8
log
@SETPSR and CLRPSR were broken in their 32-bit form when storing the old PSR.

Macro for assembly of new BKPT instruction added (useful for the emulator).

Version 0.91. Tagged as 'HdrSrc-0_91'
@
text
@d183 1
d186 14
a199 2
  |
   [ "$cond" <> "AL" :LAND: "$cond" <> ""
a201 1
   ]
d213 1
d216 18
a233 2
  |
   [ "$cond" <> "AL" :LAND: "$cond" <> ""
a235 1
   ]
@


4.7
log
@  Added TOGPSRR macro
Detail:
  TOGPSRR does the same as TOGPSR except that the bits to toggle
    are held in a register.
  Hdr:Sprite contains declarations that are mistranslated by Hdr2H 1.1.
    Hdr2H has been updated to handle these declarations and is first
    present in RiscOS/Library 0.45.
Admin:
  Required by DualSerial 0.24 and later.
  Requires Library 0.45 to export a correct C version of Hdr:Sprite

Version 0.88. Tagged as 'HdrSrc-0_88'
@
text
@d115 1
a115 1
        BIC$cond $regtmp, $regtmp, #CPU32_bits
d302 1
a302 1
        ORR$cond $regtmp, $regtmp, #CPU32_bits
d535 10
@


4.6
log
@* Fixed 32-bit macros broken by $oldpsr extension to SCPSR.
* Added $oldpsr extension to SETPSR, CLRPSR and TOGPSR.
* Removed reliance on ObjAsm default macro parameters in $oldpsr extension.
* Replaced SavePSR macro calls with literal mrs instructions in 32-bit macros.

Version 0.84. Tagged as 'HdrSrc-0_84'
@
text
@d321 1
a321 1
	LCLS	srcreg
d331 23
@


4.5
log
@  SavePSR functionality incorporated into some other macros.
Detail:
  Improved some of the PSR wiggling macros with an optional extra
    register into which to save the old PSR.  Saves an extra MRS
    instruction in some cases.
  Some macros changed to invoke SavePSR macro instead of having a copy
    of the macro body.
Admin:
  Required by ScrBlank 2.30.

Version 0.83. Tagged as 'HdrSrc-0_83'
@
text
@d102 8
a109 2
$label  CLRPSR  $bits, $regtmp, $cond=AL
$label  SavePSR $regtmp, $cond
d112 1
a112 1
        BIC$cond $regtmp, $regtmp, #CPU32_bits :AND: &F0000000
d225 1
a225 1
$label  SavePSR $srcreg, $cond
d251 1
a251 1
        somemsr  $cond, CPSR, $srcreg, CPU32_set:OR:CPU32_clr
d256 1
a256 1
; ***  restored later using RestorePSR             ***
d289 8
a296 2
$label  SETPSR  $bits, $regtmp, $cond=AL
$label  SavePSR $regtmp, $code
d299 1
a299 1
        ORR$cond $regtmp, $regtmp, #CPU32_bits :AND: &F0000000
d320 8
a327 2
$label  TOGPSR  $bits, $regtmp, $cond=AL
$label  mymrs   $cond, $regtmp, CPSR
d329 1
a329 1
        EOR$cond $regtmp, $regtmp, #CPU32_bits
@


4.4
log
@More 32-bit tweaks. Some assembler macros extended to accept condition codes
and PSR flag subset specifiers.
CPU.FPA header file added.

Version 0.79. Tagged as 'HdrSrc-0_79'
@
text
@d103 1
a103 1
$label  mymrs   $cond, $regtmp, CPSR
d212 8
a219 2
$label  SCPSR   $set, $clr, $regtmp, $cond
$label  mymrs   $cond, $regtmp, CPSR
d226 1
a226 1
        ORR$cond $regtmp, $regtmp, #CPU32_set :AND: &F0000000
d228 1
d231 2
a232 1
        ORR$cond $regtmp, $regtmp, #CPU32_set
d236 1
a236 1
        BIC$cond $regtmp, $regtmp, #CPU32_clr :AND: &F0000000
d238 1
d241 2
a242 1
        BIC$cond $regtmp, $regtmp, #CPU32_clr
d245 1
a245 1
        somemsr  $cond, CPSR, $regtmp, CPU32_set:OR:CPU32_clr
d284 1
a284 1
$label  mymrs   $cond, $regtmp, CPSR
d325 1
a325 1
$label  WritePSRc $value, $regtmp, $cond
d329 1
a329 1
$label  SCPSR   $value, (I_bit+F_bit+SVC_mode):EOR:($value), $regtmp, $cond
@


4.3
log
@Wrong file committed - now fixed
@
text
@d177 4
a180 1
  [ "$cond" <> "AL" :LAND: "$cond" <> "" :LAND: "$cond" <> "VC"
d183 3
a186 4
  [ "$cond" <> "VC"
        CMP     pc, #0
  ]
        MOV     pc, lr
d195 4
a198 1
  [ "$cond" <> "AL" :LAND: "$cond" <> "" :LAND: "$cond" <> "VS"
d200 4
a203 5
        DCD     &1A000002 :EOR: Cond_$cond
  ]
  [ "$cond" <> "VS"
        CMPVC   pc, #&80000000  ; handle +ve pc
        CMNVC   pc, #&80000000  ; and -ve pc
a204 1
        MOV$cond pc, lr
@


4.2
log
@  "RETURNVS VS" and "RETURNVC VC" now assemble to single instructions
    in the 32-bit code case.
Detail:
  Pointless jumping over the generated code or inserting conditional
    instructions which will never be executed.
@
text
@d201 1
a201 1
        MOV     pc, lr
@


4.1
log
@  Merge of 32-bit capable macros to trunk.
Detail:
  The 26-bit and 32-bit capable macros have been added.
  Header files choose which set of macros to use based on <Machine>.
  If you want the new macros, include "Hdr:APCS.<APCS>" in addition
    to the usual inclusions at the top of assembler files.
  Choices are based on the settings of macros No32bitCode and
    No26bitCode.  By default, all existing machines define these
    as {TRUE} and {FALSE} respectively.  This yields the same macros
    as before (tested in Customer F 5 build) and should yield code which
    functions on RISC OS 3.1.  Any other combination of settings is
    untested at this time.
  New assembler code should use the macros FunctionEntry, Return et al
    to ensure that they build correctly.
  New assembler code should be written to not require flag preservation
    across internal function calls and to not assume it on external
    function calls where it is possible to do so.  DO NOT simply replace
    "MOVS pc, lr" with "MOV pc, lr" as this doesn't work properly.
    Replace "MOVS pc, lr" with "Return ,LinkNotStacked"
  Do not write code which simply masks out &FC000003 from pc or some kind
    or pc originated value (eg. on r14 to attempt to remove the PSR flags
    from it.  Use the RemovePSRFromReg macro instead.
Admin:
  Tested with Customer F 5 build.
  Requires FPEmulator 4.11
  Requires Portable 0.65 (or Portable75 0.04)
  Required by any new or modified assembler code in future, pretty much.
    Such components may not necessarily specify a dependency on this
    or any other later version of HdrSrc.

Version 0.63. Tagged as 'HdrSrc-0_63'
@
text
@d177 1
a177 1
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
d181 1
d183 1
d193 1
a193 1
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
d197 1
d200 1
@


1.1
log
@file Generic32 was initially added on branch kbracey_32bit.
@
text
@d1 482
@


1.1.2.1
log
@First attempt at 32-bit support.

Version 0.57, 4.58.2.1. Tagged as 'HdrSrc-0_57-4_58_2_1'
@
text
@a0 289
; Copyright 1999 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    Generic 32-bit CPU Specific Definitions

OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List

 [ :LNOT: :DEF: Included_Hdr_CPU_Generic32
        GBLL    Included_Hdr_CPU_Generic32
Included_Hdr_CPU_Generic32 SETL {TRUE}

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************
;
; Date       Name          Description
; ----       ----          -----------
; 05-Nov-99  KBracey       Moved from ARM600.
;                          32-bit versions of Generic26 macros created.

; 32-bit PSR transfer macros

; New positions of I and F bits in 32-bit PSR

I32_bit *       1 :SHL: 7
F32_bit *       1 :SHL: 6
IF32_26Shift *  26-6

; And the Thumb bit

T32_bit *       1 :SHL: 5

; Processor mode numbers

USR26_mode      *       2_00000
FIQ26_mode      *       2_00001
IRQ26_mode      *       2_00010
SVC26_mode      *       2_00011
USR32_mode      *       2_10000
FIQ32_mode      *       2_10001
IRQ32_mode      *       2_10010
SVC32_mode      *       2_10011
ABT32_mode      *       2_10111
UND32_mode      *       2_11011
SYS32_mode      *       2_11111

; New register names

r13_abort       RN      13
r14_abort       RN      14
lr_abort        RN      14

r13_undef       RN      13
r14_undef       RN      14
lr_undef        RN      14

 [ :LNOT: No32bitCode

        ; 32 bit versions of the macros in Generic26

        GBLA    CPU32_bits
        GBLA    CPU32_set
        GBLA    CPU32_clr

; ***************************************************
; ***  PSRto32 - Convert a PSR constant to a      ***
; ***  32-bit PSR value in variable psr32         ***
; ***  Shifts I and F into their 32-bit positions ***
; ***************************************************
        MACRO
$psr32  PSRto32 $psr
$psr32  SETA    (($psr) :AND: :NOT: (I_bit:OR:F_bit)) :OR: ((($psr) :AND: (I_bit:OR:F_bit)) :SHR: IF32_26Shift)
        MEND

; ***********************************************
; ***  CLRPSR - Clear bits in PSR from the    ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  CLRPSR  $bits, $regtmp, $cond
$label  mrs     $cond, $regtmp, CPSR
CPU32_bits  PSRto32 $bits
        BIC$cond $regtmp, $regtmp, #CPU32_bits
        msr     $cond, CPSR_cf, $regtmp
        MEND

; **********************************************************************************
; ***  PHPSEI - Disable IRQs, saving an old interrupt state indicator in a       ***
; ***  register, default R14.  Note that this code preserves the C and V flags.  ***
; ***  Don't have to supply regtmp, but if you do, we save an instruction.       ***
; **********************************************************************************
        MACRO
$label  PHPSEI  $register=R14, $regtmp
  [ "$register" = ""
  [     "$regtmp" = ""
$label  mrs     AL, R14, CPSR
        TST     R14, #I32_bit                  ; is I32_bit set?
        ORREQ   R14, R14, #I32_bit             ; no, then set it
        msr     EQ, CPSR_c, R14
        BICEQ   R14, R14, #I32_bit             ; $reg contains original PSR
  |
$label  mrs     AL, R14, CPSR
        TST     R14, #I32_bit                  ; is I32_bit set?
        ORREQ   $regtmp, R14, #I32_bit         ; no, then set it
        msr     EQ, CPSR_c, $regtmp            ; $reg contains original PSR
  ]
  |
  [     "$regtmp" = ""
$label  mrs     AL, $register, CPSR
        TST     $register, #I32_bit            ; is I32_bit set?
        ORREQ   $register, $register, #I32_bit ; no, then set it
        msr     EQ, CPSR_c, $register
        BICEQ   $register, $register, #I32_bit ; $reg contains original PSR
  |
$label  mrs     AL, $register, CPSR
        TST     $register, #I32_bit            ; is I32_bit set?
        ORREQ   $regtmp, $register, #I32_bit   ; no, then set it
        msr     EQ, CPSR_c, $regtmp            ; $reg contains original PSR
  ]
  ]
        MEND

; **************************************************************************
; ***  PLP - Restore IRQ state from the indicator in a register (set up  ***
; ***  by PHPSEI).  Note that this code preserves the C and V flags.     ***
; **************************************************************************
        MACRO
$label  PLP     $register=R14
  [ "$register" = ""
$label  msr     AL, CPSR_c, R14
  |
$label  msr     AL, CPSR_c, $register
  ]
        MEND

; ****************************************************
; ***  SCPSR - Set and clear bits in PSR from the  ***
; ***  masks $set, $clr, using register $regtmp    ***
; ****************************************************
        MACRO
$label  SCPSR   $set, $clr, $regtmp, $cond
$label  mrs     $cond, $regtmp, CPSR
CPU32_set PSRto32 $set
CPU32_clr PSRto32 $clr
        ORR$cond $regtmp, $regtmp, #CPU32_set
        BIC$cond $regtmp, $regtmp, #CPU32_clr
        msr     $cond, CPSR_cf, $regtmp
        MEND

; ************************************************
; ***  SETPSR - Set bits in PSR from the mask  ***
; ***  in $bits, using register $regtmp        ***
; ************************************************
        MACRO
$label  SETPSR  $bits, $regtmp, $cond
$label  mrs     $cond, $regtmp, CPSR
CPU32_bits PSRto32 $bits
        ORR$cond $regtmp, $regtmp, #CPU32_bits
        msr     $cond, CPSR_cf, $regtmp
        MEND

; ***********************************************
; ***  TOGPSR - Toggle bits in PSR from the   ***
; ***  mask in $bits, using register $regtmp  ***
; ***********************************************
        MACRO
$label  TOGPSR  $bits, $regtmp, $cond
$label  mrs     $cond, $regtmp, CPSR
CPU32_bits PSRto32 $bits
        EOR$cond $regtmp, $regtmp, #CPU32_bits
        msr     $cond, CPSR_cf, $regtmp
        MEND


        MACRO
        mrs     $cond, $rd, $psrs
        LCLA    psrtype
psrtype SETA    -1
 [ "$psrs" = "CPSR" :LOR: "$psrs" = "CPSR_all"
psrtype SETA    0 :SHL: 22
 ]
 [ "$psrs" = "SPSR" :LOR: "$psrs" = "SPSR_all"
psrtype SETA    1 :SHL: 22
 ]
        ASSERT  psrtype <> -1
        ASSERT  $rd <> 15
        &       Cond_$cond :OR: 2_00000001000011110000000000000000 :OR: psrtype :OR: ($rd :SHL: 12)
        MEND

        MACRO
        msr     $cond, $psrl, $op2a, $op2b
        LCLA    psrtype
        LCLS    op2as
        LCLA    op
        LCLA    shift
psrtype SETA    -1
 [ "$psrl" = "CPSR" :LOR: "$psrl" = "CPSR_all" :LOR: "$psrl" = "CPSR_cf"
psrtype SETA    (0:SHL:22) :OR: (1:SHL:19) :OR: (1:SHL:16)
 ]
 [ "$psrl" = "CPSR_flg" :LOR: "$psrl" = "CPSR_f"
psrtype SETA    (0:SHL:22) :OR: (1:SHL:19) :OR: (0:SHL:16)
 ]
 [ "$psrl" = "CPSR_ctl" :LOR: "$psrl" = "CPSR_c"
psrtype SETA    (0:SHL:22) :OR: (0:SHL:19) :OR: (1:SHL:16)
 ]
 [ "$psrl" = "SPSR" :LOR: "$psrl" = "SPSR_all" :LOR: "$psrl" = "SPSR_cf"
psrtype SETA    (1:SHL:22) :OR: (1:SHL:19) :OR: (1:SHL:16)
 ]
 [ "$psrl" = "SPSR_flg" :LOR: "$psrl" = "SPSR_f"
psrtype SETA    (1:SHL:22) :OR: (1:SHL:19) :OR: (0:SHL:16)
 ]
 [ "$psrl" = "SPSR_ctl" :LOR: "$psrl" = "SPSR_c"
psrtype SETA    (1:SHL:22) :OR: (0:SHL:19) :OR: (1:SHL:16)
 ]
        ASSERT  psrtype <> -1
 [ ("$op2a" :LEFT: 1) = "#"
 ; Immediate operand

op2as   SETS    "$op2a" :RIGHT: ((:LEN: "$op2a")-1)
op      SETA    $op2as

  [ "$op2b" = ""
  ; Rotate not specified in immediate operand
shift   SETA    0
        WHILE   (op :AND: &FFFFFF00)<>0 :LAND: shift<16
op      SETA    ((op:SHR:30):AND:3):OR:(op:SHL:2)
shift   SETA    shift + 1
        WEND
        ASSERT  (op :AND: &FFFFFF00)=0
  |
  ; Rotate of immediate operand specified explicitly
        ASSERT  (($op2b):AND:&FFFFFFE1)=0
shift   SETA    ($opt2b):SHR:1
  ]
op      SETA    (shift :SHL: 8) :OR: op :OR: (1:SHL:25)
 |

 ; Not an immediate operand
  [ "$op2b" = ""
  ; Unshifted register
op      SETA    ($op2a) :OR: (0:SHL:25)
  |
        ! 1, "Shifted register not yet implemented in this macro!"
  ]
 ]
        &       Cond_$cond :OR: 2_00000001001000001111000000000000 :OR: op :OR: psrtype
        MEND

; SetMode newmode, reg1, regoldpsr
;
; Sets processor mode to constant value newmode
; using register reg1 as a temporary.
; If regoldpsr is specified, then this register
; on exit holds the old PSR before the mode change
; reg1 on exit always holds the new PSR after the mode change

        MACRO
        SetMode $newmode, $reg1, $regoldpsr
 [ "$regoldpsr"=""
        mrs     AL, $reg1, CPSR
        BIC     $reg1, $reg1, #&1F
        ORR     $reg1, $reg1, #$newmode
        msr     AL, CPSR_c, $reg1
 |
        mrs     AL, $regoldpsr, CPSR
        BIC     $reg1, $regoldpsr, #&1F
        ORR     $reg1, $reg1, #$newmode
        msr     AL, CPSR_c, $reg1
 ]
        MEND

 ] ; :LNOT: No32bitCode

 ] ; :LNOT: :DEF: Included_Hdr_CPU_Generic32

        OPT     OldOpt
        END
@


1.1.2.2
log
@More macros added to Hdr:Proc and Hdr:CPU.
msr macro now understands _cxsf form.
APCS macros now available in Hdr:APCS.<APCS>

Version 0.57, 4.58.2.2. Tagged as 'HdrSrc-0_57-4_58_2_2'
@
text
@d92 2
a93 2
$label  CLRPSR  $bits, $regtmp, $cond=AL
$label  mymrs   $cond, $regtmp, CPSR
d96 1
a96 1
        somemsr $cond, CPSR_cf, $regtmp, CPU32_bits
d108 1
a108 1
$label  mymrs   AL, R14, CPSR
d111 1
a111 1
        mymsr   EQ, CPSR_c, R14
d114 1
a114 1
$label  mymrs   AL, R14, CPSR
d117 1
a117 1
        mymsr   EQ, CPSR_c, $regtmp            ; $reg contains original PSR
d121 1
a121 1
$label  mymrs   AL, $register, CPSR
d124 1
a124 1
        mymsr   EQ, CPSR_c, $register
d127 1
a127 1
$label  mymrs   AL, $register, CPSR
d130 1
a130 1
        mymsr   EQ, CPSR_c, $regtmp            ; $reg contains original PSR
d142 1
a142 1
$label  mymsr   AL, CPSR_c, R14
d144 1
a144 1
$label  mymsr   AL, CPSR_c, $register
a147 29
; ******************
; ***  RETURNVC  ***
; ******************
        MACRO
$label  RETURNVC  $cond
$label
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000001 :EOR: Cond_$cond
  ]
        CMP     pc, #0
        MOV     pc, lr
        MEND

; ******************
; ***  RETURNVS  ***
; ******************
        MACRO
$label  RETURNVS  $cond
$label
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000002 :EOR: Cond_$cond
  ]
        CMPVC   pc, #&80000000  ; handle +ve pc
        CMNVC   pc, #&80000000  ; and -ve pc
        MOV     pc, lr
        MEND

d154 1
a154 4
$label  mymrs   $cond, $regtmp, CPSR
        [ ($set :AND: $clr) <> 0
        ! 0, "Attempt to simultaneously set and clear a bit in SCPSR"
        ]
a156 1
 [ CPU32_set <> 0
a157 2
 ]
 [ CPU32_clr <> 0
d159 1
a159 20
 ]
        somemsr  $cond, CPSR_cf, $regtmp, CPU32_set:OR:CPU32_clr
        MEND

; ****************************************************
; ***  SavePSR - Save the PSR in a register, to be ***
; ***  restored later using RestorePSR             ***
; ****************************************************
        MACRO
$label  SavePSR $reg, $cond
$label  mymrs   $cond, $reg, CPSR
        MEND

; ****************************************************
; ***  RestPSR - Restore the PSR from a register   ***
; ***  set up by SavePSR                          ***
; ****************************************************
        MACRO
$label  RestPSR $reg, $cond
$label  mymsr   $cond, CPSR_cf, $reg
d167 2
a168 2
$label  SETPSR  $bits, $regtmp, $cond=AL
$label  mymrs   $cond, $regtmp, CPSR
d171 1
a171 1
        somemsr $cond, CPSR_cf, $regtmp, CPU32_bits
d179 2
a180 2
$label  TOGPSR  $bits, $regtmp, $cond=AL
$label  mymrs   $cond, $regtmp, CPSR
d183 1
a183 1
        somemsr $cond, CPSR_cf, $regtmp, CPU32_bits
a185 16
; *************************************************
; ***  WritePSRc - Set the PSR control bits to  ***
; ***  an absolute value.                       ***
; ***  Sets I,F,M[0:1], corrupts NZVC.          ***
; ***  Preserves 32-bitness.                    ***
; ***  Only use in IRQ26/32,FIQ26/32,SVC26/32   ***
; ***  Ignored in USR modes, illegal in others  ***
; ***  Use instead of TEQP PC,#0 etc            ***
; *************************************************
        MACRO
$label  WritePSRc $bits, $regtmp
        [ $bits :AND::NOT: (I_bit+F_bit+SVC_mode) <> 0
	! 1, "Illegal flags for WritePSRc"
        ]
$label  SCPSR   $bits, (I_bit+F_bit+SVC_mode):EOR:($bits), $regtmp, AL
        MEND
a186 1
; Original AAsm macros
a188 39
        mymrs   $cond, $rd, $psrs
        MEND

        MACRO
        msr     $cond, $psrl, $op2a, $op2b
        mymsr   $cond, $psrl, $op2a, $op2b
        MEND


; ***************************************************
; *** somemsr - Set some fields of the PSR from   ***
; *** $op, according to $mask. The mask should    ***
; *** indicate which bits have been modified.     ***
; *** This saves us writing the control field,    ***
; *** when it hasn't been modified, for example,  ***
; *** saving 2 cycles on some processors.         ***
; ***************************************************
        MACRO
$label  somemsr $cond, $psr, $op, $mask
        LCLS    s
s       SETS    "$psr._"
 [ $mask :AND: &FF <> 0
s       SETS    s:CC:"c"
 ]
 [ $mask :AND: &FF00 <> 0
s       SETS    s:CC:"x"
 ]
 [ $mask :AND: &FF0000 <> 0
s       SETS    s:CC:"s"
 ]
 [ $mask :AND: &FF000000 <> 0
s       SETS    s:CC:"f"
 ]
$label  mymsr   $cond, $psr, $op
        MEND

; Funny names for ObjAsm compatibility
        MACRO
        mymrs   $cond, $rd, $psrs
d203 1
a203 1
        mymsr   $cond, $psrl, $op2a, $op2b
d208 3
a210 4
        LCLS    s
s       SETS    "$psrl"
 [ s:RIGHT:4 = "_ctl" :LOR: s:RIGHT:4 = "_flg"
s       SETS    s:LEFT:(:LEN:s-2)
d212 2
a213 2
 [ s:RIGHT:4 = "_all"
s       SETS    s:LEFT:(:LEN:s-3) :CC: "cf"
d215 2
a216 2
 [ s:RIGHT:3 = "PSR"
s       SETS    s:CC:"_cf"
d218 2
a219 5
        ASSERT  s:LEFT:5 = "CPSR_" :LOR: s:LEFT:5 = "SPSR_"
 [ s:LEFT:5 = "SPSR_"
psrtype SETA    (1:SHL:22)
|
psrtype SETA    (0:SHL:22)
d221 2
a222 5
s       SETS    s :RIGHT: (:LEN:s-5)

 [ s:LEFT:1 = "c"
psrtype SETA    psrtype :OR: (1:SHL:16)
s       SETS    s :RIGHT: (:LEN:s-1)
d224 2
a225 15
 [ s:LEFT:1 = "x"
psrtype SETA    psrtype :OR: (1:SHL:17)
s       SETS    s :RIGHT: (:LEN:s-1)
 ]
 [ s:LEFT:1 = "s"
psrtype SETA    psrtype :OR: (1:SHL:18)
s       SETS    s :RIGHT: (:LEN:s-1)
 ]
 [ s:LEFT:1 = "f"
psrtype SETA    psrtype :OR: (1:SHL:19)
s       SETS    s :RIGHT: (:LEN:s-1)
 ]
        ASSERT  s = ""
 [ (psrtype :AND: (15:SHL:16)) = 0
        ! 0, "MSR that sets no fields"
d227 1
d272 1
a272 1
        mymrs   AL, $reg1, CPSR
d275 1
a275 1
        mymsr   AL, CPSR_c, $reg1
d277 1
a277 1
        mymrs   AL, $regoldpsr, CPSR
d280 1
a280 1
        mymsr   AL, CPSR_c, $reg1
@


1.1.2.3
log
@Lots of exciting 32-bit stuff. Try it at your peril.

Version 0.57, 4.58.2.6. Tagged as 'HdrSrc-0_57-4_58_2_6'
@
text
@d35 1
a35 1
; New positions of bits in 32-bit PSR
d39 4
a43 3
M32_bits *	2_11111

IF32_26Shift *  26-6
a83 3
        [ (($psr) :AND: (:NOT: ARM_CC_Mask)) <> 0
	! 1, "Illegal PSR bits"
        ]
a86 8
; ************************************************
; ***  CLC - Clear carry flag - will set nzcv  ***
; ************************************************
        MACRO
$label  CLC     $cond
$label  mymsr   $cond, CPSR_f, #0
        MEND

a94 4
        [ (CPU32_bits :AND: &F0000000) <> 0 :LAND: (CPU32_bits :AND: &F0) <> 0
        BIC$cond $regtmp, $regtmp, #CPU32_bits :AND: &F0000000
        BIC$cond $regtmp, $regtmp, #CPU32_bits :AND: &0FFFFFFF
        |
d96 1
a96 10
        ]
        somemsr $cond, CPSR, $regtmp, CPU32_bits
        MEND

; **************************************************
; *** CLRV - Clear overflow flag - will set nzCv ***
; **************************************************
        MACRO
$label  CLRV    $cond
$label  mymsr   $cond, CPSR_f, #C_bit
d184 2
a185 2
        [ (($set) :AND: ($clr)) <> 0
        ! 1, "Attempt to simultaneously set and clear a bit in SCPSR"
a188 4
 [ (CPU32_set :AND: &F0000000) <> 0 :LAND: (CPU32_set :AND: &F0) <> 0
        ORR$cond $regtmp, $regtmp, #CPU32_set :AND: &F0000000
        ORR$cond $regtmp, $regtmp, #CPU32_set :AND: &0FFFFFFF
 |
a191 5
 ]
 [ (CPU32_clr :AND: &F0000000) <> 0 :LAND: (CPU32_clr :AND: &F0) <> 0
        BIC$cond $regtmp, $regtmp, #CPU32_clr :AND: &F0000000
        BIC$cond $regtmp, $regtmp, #CPU32_clr :AND: &0FFFFFFF
 |
d195 1
a195 2
 ]
        somemsr  $cond, CPSR, $regtmp, CPU32_set:OR:CPU32_clr
d212 1
a212 2
$label  RestPSR $reg, $cond, $fields
  [ "$fields"=""
a213 11
  |
$label  mymsr   $cond, CPSR_$fields, $reg
  ]
        MEND

; **********************************************
; ***  SEC - Set carry flag - will set nzCv  ***
; **********************************************
        MACRO
$label  SEC     $cond
$label  mymsr   $cond, CPSR_f, #C_bit
a223 4
        [ (CPU32_bits :AND: &F0000000) <> 0 :LAND: (CPU32_bits :AND: &F0) <> 0
        ORR$cond $regtmp, $regtmp, #CPU32_bits :AND: &F0000000
        ORR$cond $regtmp, $regtmp, #CPU32_bits :AND: &0FFFFFFF
        |
d225 1
a225 10
        ]
        somemsr $cond, CPSR, $regtmp, CPU32_bits
        MEND

; **************************************************
; ***  SETV - Set overflow flag - will set NzcV  ***
; **************************************************
        MACRO
$label  SETV    $cond
$label  mymsr   $cond, CPSR_f, #N_bit+V_bit
d237 1
a237 1
        somemsr $cond, CPSR, $regtmp, CPU32_bits
d247 1
a247 1
; ***  Use instead of TEQP PC,#$value           ***
d250 3
a252 3
$label  WritePSRc $value, $regtmp, $cond
        [ ($value :AND::NOT: (I_bit+F_bit+SVC_mode)) <> 0
        ! 1, "Illegal flags for WritePSRc"
d254 1
a254 1
$label  SCPSR   $value, (I_bit+F_bit+SVC_mode):EOR:($value), $regtmp, $cond
a256 2
 ] ; :LNOT: No32bitCode

d259 2
a260 2
$label  mrs     $cond, $rd, $psrs
$label  mymrs   $cond, $rd, $psrs
d264 2
a265 2
$label  msr     $cond, $psrl, $op2a, $op2b
$label  mymsr   $cond, $psrl, $op2a, $op2b
d281 1
a281 1
 [ (($mask) :AND: &FF) <> 0
d284 1
a284 1
 [ (($mask) :AND: &FF00) <> 0
d287 1
a287 1
 [ (($mask) :AND: &FF0000) <> 0
d290 1
a290 1
 [ (($mask) :AND: &FF000000) <> 0
d293 1
a293 1
$label  mymsr   $cond, $s, $op
d298 1
a298 2
$label  mymrs   $cond, $rd, $psrs
$label
a300 3
 [ "$psrs" = "CPSR_all" :LOR: "$psrs" = "SPSR_all"
        !       0, "Deprecated form of PSR field specifier used (use no suffix)"
 ]
d313 1
a313 2
$label  mymsr   $cond, $psrl, $op2a, $op2b
$label
a320 1
        !       0, "Deprecated form of PSR field specifier used (use _cxsf)"
a323 1
        !       0, "Deprecated form of PSR field specifier used (use _cxsf)"
a326 1
        !       0, "Deprecated form of PSR field specifier used (use _cxsf)"
d329 5
a333 4
psrtype SETA    0
 [ s:RIGHT:1 = "f"
psrtype SETA    psrtype :OR: (1:SHL:19)
s       SETS    s :LEFT: (:LEN:s-1)
d335 5
a339 3
 [ s:RIGHT:1 = "s"
psrtype SETA    psrtype :OR: (1:SHL:18)
s       SETS    s :LEFT: (:LEN:s-1)
d341 1
a341 1
 [ s:RIGHT:1 = "x"
d343 1
a343 1
s       SETS    s :LEFT: (:LEN:s-1)
d345 3
a347 3
 [ s:RIGHT:1 = "c"
psrtype SETA    psrtype :OR: (1:SHL:16)
s       SETS    s :LEFT: (:LEN:s-1)
d349 3
a351 5
        ASSERT  s = "CPSR_" :LOR: s = "SPSR_"
 [ s = "SPSR_"
psrtype SETA    psrtype :OR: (1:SHL:22)
 |
psrtype SETA    psrtype :OR: (0:SHL:22)
d353 1
d412 2
@



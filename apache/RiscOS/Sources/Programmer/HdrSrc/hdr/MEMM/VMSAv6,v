head	4.6;
access;
symbols
	HdrSrc-2_77:4.6
	HdrSrc-2_76:4.6
	HdrSrc-2_75:4.6
	HdrSrc-2_74:4.6
	HdrSrc-2_73:4.6
	HdrSrc-2_72:4.6
	HdrSrc-2_71:4.6
	HdrSrc-2_70:4.6
	HdrSrc-2_69:4.6
	HdrSrc-2_68:4.5
	HdrSrc-2_67:4.5
	HdrSrc-2_66:4.5
	HdrSrc-2_65:4.5
	HdrSrc-2_64:4.5
	HdrSrc-2_63:4.5
	HdrSrc-2_62:4.5
	HdrSrc-2_61:4.5
	HdrSrc-2_60:4.5
	HdrSrc-2_59:4.5
	HdrSrc-2_58:4.5
	HdrSrc-2_57:4.5
	HdrSrc-2_56:4.5
	HdrSrc-2_55:4.5
	HdrSrc-2_54:4.5
	HdrSrc-2_53:4.5
	HdrSrc-2_52:4.5
	HdrSrc-2_51:4.4
	HdrSrc-2_50:4.4
	HdrSrc-2_49:4.4
	HdrSrc-2_48:4.4
	HdrSrc-2_47:4.4
	HdrSrc-2_46-4_247_2_1:4.4
	XCompile:4.4.0.2
	XCompile_bp:4.4
	HdrSrc-2_46:4.4
	HdrSrc-2_45:4.4
	HdrSrc-2_44:4.4
	HdrSrc-2_43:4.4
	HdrSrc-2_42:4.4
	HdrSrc-2_41:4.4
	HdrSrc-2_40-1:4.4
	HdrSrc-2_40:4.4
	HdrSrc-2_39:4.4
	HdrSrc-2_38:4.4
	HdrSrc-2_37:4.4
	HdrSrc-2_36:4.4
	HdrSrc-2_35:4.4
	HdrSrc-2_34:4.4
	HdrSrc-2_33:4.4
	HdrSrc-2_32:4.4
	HdrSrc-2_31:4.4
	HdrSrc-2_30:4.4
	HdrSrc-2_29:4.4
	HdrSrc-2_28:4.4
	HdrSrc-2_27:4.4
	HdrSrc-2_26:4.4
	HdrSrc-2_25:4.4
	HdrSrc-2_24:4.4
	HdrSrc-2_23:4.4
	HdrSrc-2_22:4.4
	HdrSrc-2_21:4.4
	HdrSrc-2_20:4.4
	HdrSrc-2_19:4.4
	HdrSrc-2_18:4.4
	HdrSrc-2_17:4.4
	HdrSrc-2_16:4.4
	HdrSrc-2_15:4.4
	HdrSrc-2_14:4.4
	HdrSrc-2_13:4.4
	HdrSrc-2_12:4.4
	HdrSrc-2_11:4.4
	HdrSrc-2_10:4.4
	HdrSrc-2_09:4.4
	HdrSrc-2_08:4.4
	HdrSrc-2_07:4.4
	HdrSrc-2_06:4.3
	HdrSrc-2_05:4.3
	HdrSrc-2_04:4.3
	HdrSrc-2_03:4.3
	HdrSrc-2_02:4.3
	HdrSrc-2_01:4.3
	HdrSrc-2_00:4.3
	HdrSrc-1_99:4.3
	HdrSrc-1_98:4.3
	HdrSrc-1_97:4.3
	HdrSrc-1_96:4.3
	HdrSrc-1_95:4.3
	HdrSrc-1_94:4.3
	HdrSrc-1_93:4.3
	HdrSrc-1_92:4.3
	HdrSrc-1_91:4.3
	HdrSrc-1_90:4.3
	HdrSrc-1_89:4.3
	HdrSrc-1_88:4.3
	HdrSrc-1_87:4.3
	HdrSrc-1_86:4.3
	HdrSrc-1_85:4.3
	HdrSrc-1_84:4.3
	HdrSrc-1_83:4.2
	HdrSrc-1_82:4.2
	HdrSrc-1_81:4.2
	HdrSrc-1_80:4.1
	HdrSrc-1_79:4.1
	HdrSrc-1_78:4.1
	HdrSrc-1_77:4.1
	HdrSrc-1_76:4.1
	Cortex_merge:1.1.2.2
	HdrSrc-1_62-4_162_2_15:1.1.2.2
	HdrSrc-1_62-4_162_2_14:1.1.2.2
	HdrSrc-1_62-4_162_2_13:1.1.2.2
	HdrSrc-1_62-4_162_2_12:1.1.2.2
	HdrSrc-1_62-4_162_2_11:1.1.2.2
	HdrSrc-1_62-4_162_2_10:1.1.2.2
	HdrSrc-1_62-4_162_2_9:1.1.2.2
	HdrSrc-1_62-4_162_2_8:1.1.2.2
	HdrSrc-1_62-4_162_2_7:1.1.2.2
	HdrSrc-1_62-4_162_2_6:1.1.2.2
	HdrSrc-1_62-4_162_2_5:1.1.2.1
	HdrSrc-1_62-4_162_2_4:1.1.2.1
	HdrSrc-1_62-4_162_2_3:1.1.2.1
	HdrSrc-1_62-4_162_2_2:1.1.2.1
	Cortex:1.1.0.2;
locks; strict;
comment	@# @;


4.6
date	2016.08.02.19.43.34;	author jlee;	state Exp;
branches;
next	4.5;
commitid	eReGNStCxetPCLgz;

4.5
date	2015.08.05.21.24.43;	author jlee;	state Exp;
branches;
next	4.4;
commitid	yqXiAzo49p8WQ7wy;

4.4
date	2012.05.14.19.01.24;	author bavison;	state Exp;
branches;
next	4.3;
commitid	leUAY5ZgoiipVI4w;

4.3
date	2011.06.08.23.13.22;	author jlee;	state Exp;
branches;
next	4.2;
commitid	jHOBXW9tOfbrhVmv;

4.2
date	2011.05.22.19.53.25;	author jlee;	state Exp;
branches;
next	4.1;
commitid	bqq0FgvX0hzHIIkv;

4.1
date	2011.01.15.22.29.58;	author jlee;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.06.23.06.46;	author jlee;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2009.03.06.23.06.46;	author jlee;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2009.05.09.19.36.59;	author jlee;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Update VMSAv6 page table definitions
Detail:
  hdr/MEMM/VMSAv6 - Add AP_PROM for the "privileged mode ROM" permission. Define the shareable bit for L1 page table entries.
Admin:
  Tested on Raspberry Pi


Version 2.69. Tagged as 'HdrSrc-2_69'
@
text
@; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > hdr:VMSAv6

; ********************
; *** Changes List ***
; ********************

; 18-Feb-09 JL  Created, using ARM600 as basis.

; Access privilege bits
; These comprise the AP and APX bits, which are luckily always in the same location relative to each other

AP_ROM  *       2_100010        ; user read-only,  svc read-only
AP_None *       2_000001        ; user no access,  svc read/write
AP_Read *       2_000010        ; user read-only,  svc read/write
AP_Full *       2_000011        ; user read/write, svc read/write
AP_PROM *       2_100001        ; user no access,  svc read-only

L1_APShift *     10        ; value to shift AP_ values by for L1 entry
L2_APShift *     4         ; value to shift AP_ values by for L2 entry

L1_APMult  * 1 :SHL: L1_APShift  ; value to multiply AP_ values by for L1 entry
L2_APMult  * 1 :SHL: L2_APShift  ; value to multiply AP_ values by for L2 entry
L2X_APMult * L2_APMult

L1_AP     *     2_100011 * L1_APMult ; masks for AP fields
L2_AP     *     2_100011 * L2_APMult

L1_DomainShift *   5            ; lowest bit position in L1 entry for domain number

L1_Fault *      4_0             ; translation fault specifier in L1 entry
L1_Page *       4_1             ; coarse page specifier in L1 entry
L1_Section *    4_2             ; section specifier in L1 entry
; supersections not supported ATM


L2_Fault *      4_0             ; translation fault specifier in L2 entry
L2_LargePage *  4_1             ; large page specifier in L2 entry
L2_SmallPage *  4_2             ; (extended) small page specifier in L2 entry
L2_ExtPage   *  L2_SmallPage

L1_TEXShift *   12
L1_TEX  *       2_111 :SHL: 12  ; Type Extension bits
L1_C    *       1 :SHL: 3       ; cacheable
L1_B    *       1 :SHL: 2       ; bufferable
L1_S    *       1 :SHL: 16      ; shareable
L1_nG   *       1 :SHL: 17      ; 1=entry associated with ASID, 0=global
L1_XN   *       1 :SHL: 4       ; eXecute Never

L2L_TEXShift *  12              ; For large pages
L2_TEXShift *   6               ; For extended small pages
L2L_TEX *       2_111 :SHL: 12  ; Type Extension bits (large pages)
L2_TEX  *       2_111 :SHL: 6   ; Type Extension bits (tiny and extended pages)
L2_C    *       1 :SHL: 3       ; cacheable  bit in level 2 entry
L2_B    *       1 :SHL: 2       ; bufferable --------""----------
L2_S    *       1 :SHL: 10      ; shareable
L2_nG   *       1 :SHL: 11      ; 1=entry associated with ASID, 0=global
L2L_XN  *       1 :SHL: 15      ; eXecute Never for large pages
L2_XN   *       1               ; eXecute Never for extended small pages

; CP15 control register bits
; Retaining MMUC_* naming for compatability with existing code

; Validity: 5 = ARMv5 or older, 6=ARMv6, K=ARMv6K, 7=ARMv7, !=Warning, bit reused
MMUC_M  *  1 :SHL: 0  ; 567 MMU enable
MMUC_A  *  1 :SHL: 1  ; 567 Alignment fault enable
MMUC_C  *  1 :SHL: 2  ; 567 Cache enable (or Data cache enable)
MMUC_W  *  1 :SHL: 3  ; 56  Write buffer enable
MMUC_P  *  1 :SHL: 4  ; 5   32-bit program space enable
MMUC_D  *  1 :SHL: 5  ; 5   32-bit data space enable
MMUC_L  *  1 :SHL: 6  ; 5   Late abort mode enable
MMUC_B  *  1 :SHL: 7  ; 56  Big-endian mode enable
MMUC_S  *  1 :SHL: 8  ; 5   S-mode enable
MMUC_R  *  1 :SHL: 9  ; 5   R-mode enable (ARM7 or later)
MMUC_F  *  1 :SHL: 10 ; 5!! Coprocessor frequency bit (ARM700 only)
MMUC_SW *  1 :SHL: 10 ; !!7 SWP/SWPB enable (ARMv7MP)
MMUC_Z  *  1 :SHL: 11 ; 567 Branch predictor enable
MMUC_I  *  1 :SHL: 12 ; 567 Instruction cache enable
MMUC_V  *  1 :SHL: 13 ; 567 High exception vectors
MMUC_RR *  1 :SHL: 14 ; 567 Round-robin/alternate cache replacement strategy
MMUC_L4 *  1 :SHL: 15 ; 56  Disable ARMv5 "load Thumb state with PC" behaviour
MMUC_HA *  1 :SHL: 17 ;  K7 Hardware access flag enable
MMUC_FI *  1 :SHL: 21 ;  67 Fast interrupt configuration enable
MMUC_U  *  1 :SHL: 22 ;  6  Unaligned data access operation
MMUC_XP *  1 :SHL: 23 ;  6  Extended page table config
MMUC_VE *  1 :SHL: 24 ;  6  Vectored interrupts
MMUC_EE *  1 :SHL: 25 ;  67 Exception Endian bit
MMUC_L2 *  1 :SHL: 26 ;  6  L2 unified cache enable
MMUC_NMFI * 1:SHL: 27 ;  67 Non-maskable FIQ (read-only)
MMUC_TRE * 1 :SHL: 28 ;  K7 TEX remap enable
MMUC_AFE * 1 :SHL: 29 ;  K7 Access Flag Enable (AP[0] remap)
MMUC_nF *  1 :SHL: 30 ; 5!! not FastBus (ie separate CPUCLK from MEMCLK)
MMUC_TE *  1 :SHL: 30 ; !67 Exceptions handled in Thumb mode
MMUC_iA *  1 :SHL: 31 ; 5   Asynchronous

; ARM600 MMU coprocessor number

Arm600Cop CP      15

; ARM600 coprocessor registers

CR_Dummy        CN      0
CR_ID           CN      0       ; read-only
CR_Control      CN      1       ; read/write
CR_TTabBase     CN      2       ; read/write
CR_Domains      CN      3       ; read/write
CR_FaultStatus  CN      5       ; read
CR_FaultAddress CN      6       ; read

; Cache size ID register fields

CCSIDR_WT_pos               * 31
CCSIDR_WT_mask              * 1:SHL:CCSIDR_WT_pos
CCSIDR_WB_pos               * 30
CCSIDR_WB_mask              * 1:SHL:CCSIDR_WB_pos
CCSIDR_RA_pos               * 29
CCSIDR_RA_mask              * 1:SHL:CCSIDR_RA_pos
CCSIDR_WA_pos               * 28
CCSIDR_WA_mask              * 1:SHL:CCSIDR_WA_pos
CCSIDR_NumSets_pos          * 13
CCSIDR_NumSets_mask         * &7FFF:SHL:CCSIDR_NumSets_pos
CCSIDR_Associativity_pos    * 3
CCSIDR_Associativity_mask   * &3FF:SHL:CCSIDR_Associativity_pos
CCSIDR_LineSize_pos         * 0
CCSIDR_LineSize_mask        * 7:SHL:CCSIDR_LineSize_pos

; Cache type register fields (ARMv6 register format)
; NOTE - need to be kept in sync with hdr.MEMM.ARM600!

CT_ctype_pos    *       25
CT_ctype_mask   *       &F:SHL:CT_ctype_pos
CT_S_pos        *       24
CT_S            *       1:SHL:CT_S_pos
CT_Dsize_pos    *       12
CT_Dsize_mask   *       &FFF:SHL:CT_Dsize_pos
CT_Isize_pos    *       0
CT_Isize_mask   *       &FFF:SHL:CT_Isize_pos

CT_ctype_WT     *       0       ; write-through cache
CT_ctype_WB_Crd *       1       ; write-back, clean by reading data
CT_ctype_WB_CR7 *       2       ; write-back, clean with register 7
CT_ctype_WB_Cal_LD  *   5       ; write-back, clean by allocating data, lockdown (?)
CT_ctype_WB_CR7_LDd *   5       ; write-back, clean with register 7, lockdown (format D)
CT_ctype_WB_CR7_LDa *   6       ; write-back, clean with register 7, lockdown (format A)
CT_ctype_WB_CR7_LDb *   7       ; write-back, clean with register 7, lockdown (format B)
CT_ctype_WB_CR7_Lx  *   8       ; write-back, clean with register 7, multiple cache levels
CT_ctype_WB_CR7_LDc *  14       ; write-back, clean with register 7, lockdown (format C)

CT_P_pos        *       11
CT_P            *       1:SHL:CT_P_pos
CT_size_pos     *       6
CT_size_mask    *       7:SHL:CT_size_pos
CT_assoc_pos    *       3
CT_assoc_mask   *       7:SHL:CT_assoc_pos
CT_M_pos        *       2
CT_M            *       1:SHL:CT_M_pos
CT_len_pos      *       0
CT_len_mask     *       3:SHL:CT_len_pos

CT_size_512     *       0
CT_size_1K      *       1
CT_size_2K      *       2
CT_size_4K      *       3
CT_size_8K      *       4
CT_size_16K     *       5
CT_size_32K     *       6
CT_size_64K     *       7
CT_size_128K    *       8
CT_size_768     *       0
CT_size_1536    *       1
CT_size_3K      *       2
CT_size_6K      *       3
CT_size_12K     *       4
CT_size_24K     *       5
CT_size_48K     *       6
CT_size_96K     *       7
CT_size_192K    *       8

CT_assoc_1      *       0
CT_assoc_2      *       1
CT_assoc_4      *       2
CT_assoc_8      *       3
CT_assoc_16     *       4
CT_assoc_32     *       5
CT_assoc_64     *       6
CT_assoc_128    *       7
CT_assoc_0      *       0
CT_assoc_3      *       1
CT_assoc_6      *       2
CT_assoc_12     *       3
CT_assoc_24     *       4
CT_assoc_48     *       5
CT_assoc_96     *       6
CT_assoc_192    *       7

CT_len_2        *       0
CT_len_4        *       1
CT_len_8        *       2
CT_len_16       *       3

CT_M_512        *       0
CT_M_1K         *       0
CT_M_2K         *       0
CT_M_4K         *       0
CT_M_8K         *       0
CT_M_16K        *       0
CT_M_32K        *       0
CT_M_64K        *       0
CT_M_128K       *       0
CT_M_768        *       1
CT_M_1536       *       1
CT_M_3K         *       1
CT_M_6K         *       1
CT_M_12K        *       1
CT_M_24K        *       1
CT_M_48K        *       1
CT_M_96K        *       1
CT_M_192K       *       1



        MACRO
        SetCop  $reg, $cop, $rm, $op2, $cc
      [ "$op2" = ""
        MCR$cc  Arm600Cop, 0, $reg, $cop, CR_Dummy
      |
        MCR$cc  Arm600Cop, 0, $reg, $cop, $rm, $op2
      ]
        MEND

        MACRO
        ReadCop $reg, $cop, $rm, $op2, $cc
      [ "$op2" = ""
        MRC$cc  Arm600Cop, 0, $reg, $cop, CR_Dummy
      |
        MRC$cc  Arm600Cop, 0, $reg, $cop, $rm, $op2
      ]
        MEND


        END
@


4.5
log
@Update VMSAv6 definitions
Detail:
  hdr/MEMM/VMSAv6 - Remove XScale-specific L1_X, L2_X, L2L_X flags. Add L2_S flag. Add definitions for the cache size ID register fields.
Admin:
  Tested on ARM11, Cortex-A7, -A8, -A9, -A15


Version 2.52. Tagged as 'HdrSrc-2_52'
@
text
@d30 1
d59 1
@


4.4
log
@  Added definitions for the ARMv6 extensions to the CP15 cache type register
Detail:
  This allows the cache properties of CPUs like the ARM1176JZF-S (as featured
  in the Raspberry Pi) to be correctly determined
Admin:
  Tested in a Raspberry Pi build

Version 2.07. Tagged as 'HdrSrc-2_07'
@
text
@a59 1
L1_X    *       1 :SHL: 12      ; XScale - modifies meaning of C and B bits (is TEX bit 0)
d67 1
a70 2
L2L_X   *       1 :SHL: 12      ; XScale - modifies meaning of C and B bits (large pages) (is TEX bit 0)
L2_X    *       1 :SHL: 6       ; XScale - modifies meaning of C and B bits (tiny and extended pages) (is TEX bit 0)
d121 18
a138 1
; Cache type register fields
@


4.3
log
@Update VMSAv6 system control register info
Detail:
  hdr/MEMM/VMSAv6 - Updated the system control register info to accurately reflect which bits work on ARMv6. Added missing SW, HA, FI definitions.
Admin:
  Tested on rev A2 BB-xM


Version 1.84. Tagged as 'HdrSrc-1_84'
@
text
@d138 2
a139 1
CT_ctype_WB_Cal_LD  *   5	; write-back, clean by allocating data, lockdown (?)
d142 2
a143 1
CT_ctype_WB_CR7_Lx *  8       ; write-back, clean with register 7, multiple cache levels
d145 2
d164 1
d173 1
d205 1
d214 1
@


4.2
log
@Add HALSize support. Fix TEX definitions in VMSAv6 MMU file.
Detail:
  Makefile - Now uses the HALSize environment variable to select which HALSize file to export
  hdr/HALSize/64K, hdr/HALSize/96K, hdr/HALSize/128K - HALSize files for 64K, 96K, 128K HAL sizes
  hdr/MEMM/VMSAv6 - Fix the incorrect TEX definitions that were corrupting the page permissions and resulting in ROM pages being writeable.
Admin:
  Tested on rev A2 BB-xM.
  Needs latest Env folder.


Version 1.81. Tagged as 'HdrSrc-1_81'
@
text
@d77 4
a80 4
; Validity: 5 = ARMv5 or older, 6=ARMv6, C=Cortex, !=Warning, bit reused
MMUC_M  *  1 :SHL: 0  ; 56C MMU enable
MMUC_A  *  1 :SHL: 1  ; 56C Alignment fault enable
MMUC_C  *  1 :SHL: 2  ; 56C Cache enable (or Data cache enable)
d88 9
a96 6
MMUC_F  *  1 :SHL: 10 ; 5   Coprocessor frequency bit (ARM700 only)
MMUC_Z  *  1 :SHL: 11 ; 56C Branch predictor enable
MMUC_I  *  1 :SHL: 12 ; 56C Instruction cache enable
MMUC_V  *  1 :SHL: 13 ; 56C High exception vectors
MMUC_RR *  1 :SHL: 14 ; 56  Round-robin/alternate cache replacement strategy
MMUC_L4 *  1 :SHL: 15 ; 5   Disable ARMv5 "load Thumb state with PC" behaviour
d100 1
a100 1
MMUC_EE *  1 :SHL: 25 ;  6C Exception Endian bit
d102 3
a104 3
MMUC_NMFI * 1:SHL: 27 ;   C Non-maskable FIQ (read-only)
MMUC_TRE * 1 :SHL: 28 ;   C TEX remap enable
MMUC_AFE * 1 :SHL: 29 ;   C Access Flag Enable (AP[0] remap)
d106 1
a106 1
MMUC_TE *  1 :SHL: 30 ; !!C Exceptions handled in Thumb mode
@


4.1
log
@Merge Cortex branch of HdrSrc into trunk
Detail:
  This should merge all of the Cortex HdrSrc changes into the trunk, so we don't have to worry about OMAP builds breaking each time the trunk HdrSrc changes
Admin:
  Untested!


Version 1.76. Tagged as 'HdrSrc-1_76'
@
text
@d55 1
a55 1
L1_TEX  *       2_1111 :SHL: 12 ; Type Extension bits
d64 2
a65 2
L2L_TEX *       2_1111 :SHL: 12 ; Type Extension bits (large pages)
L2_TEX  *       2_1111 :SHL: 6  ; Type Extension bits (tiny and extended pages)
@


1.1
log
@file VMSAv6 was initially added on branch Cortex.
@
text
@d1 226
@


1.1.2.1
log
@Add support for VMSAv6 MMU architecture
Detail:
  Makefile - add hdr.MEMM.VMSAv6
  hdr.MEMM.VMSAv6 - Definitions for VMSAv6 page table structure and ARMv6/v7 CP15 flags
Admin:
  Tested with appropriate RISC OS kernel under qemu-omap3 and rev B6 beagleboard


Version 1.62, 4.162.2.2. Tagged as 'HdrSrc-1_62-4_162_2_2'
@
text
@a0 217
; Copyright 2009 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > hdr:VMSAv6

; ********************
; *** Changes List ***
; ********************

; 18-Feb-09 JL  Created, using ARM600 as basis.

; Access privilege bits
; These comprise the AP and APX bits, which are luckily always in the same location relative to each other

AP_ROM  *       2_100010        ; user read-only,  svc read-only
AP_None *       2_000001        ; user no access,  svc read/write
AP_Read *       2_000010        ; user read-only,  svc read/write
AP_Full *       2_000011        ; user read/write, svc read/write

L1_APShift *     10        ; value to shift AP_ values by for L1 entry
L2_APShift *     4         ; value to shift AP_ values by for L2 entry

L1_APMult  * 1 :SHL: L1_APShift  ; value to multiply AP_ values by for L1 entry
L2_APMult  * 1 :SHL: L2_APShift  ; value to multiply AP_ values by for L2 entry
L2X_APMult * L2_APMult

L1_AP     *     2_100011 * L1_APMult ; masks for AP fields
L2_AP     *     2_100011 * L2_APMult

L1_DomainShift *   5            ; lowest bit position in L1 entry for domain number

L1_Fault *      4_0             ; translation fault specifier in L1 entry
L1_Page *       4_1             ; coarse page specifier in L1 entry
L1_Section *    4_2             ; section specifier in L1 entry
; supersections not supported ATM


L2_Fault *      4_0             ; translation fault specifier in L2 entry
L2_LargePage *  4_1             ; large page specifier in L2 entry
L2_SmallPage *  4_2             ; (extended) small page specifier in L2 entry
L2_ExtPage   *  L2_SmallPage

L1_TEXShift *   12
L1_TEX  *       2_1111 :SHL: 12 ; Type Extension bits
L1_C    *       1 :SHL: 3       ; cacheable
L1_B    *       1 :SHL: 2       ; bufferable
L1_nG   *       1 :SHL: 17      ; 1=entry associated with ASID, 0=global
L1_XN   *       1 :SHL: 4       ; eXecute Never
L1_X    *       1 :SHL: 12      ; XScale - modifies meaning of C and B bits (is TEX bit 0)

L2L_TEXShift *  12              ; For large pages
L2_TEXShift *   6               ; For extended small pages
L2L_TEX *       2_1111 :SHL: 12 ; Type Extension bits (large pages)
L2_TEX  *       2_1111 :SHL: 6  ; Type Extension bits (tiny and extended pages)
L2_C    *       1 :SHL: 3       ; cacheable  bit in level 2 entry
L2_B    *       1 :SHL: 2       ; bufferable --------""----------
L2_nG   *       1 :SHL: 11      ; 1=entry associated with ASID, 0=global
L2L_XN  *       1 :SHL: 15      ; eXecute Never for large pages
L2_XN   *       1               ; eXecute Never for extended small pages
L2L_X   *       1 :SHL: 12      ; XScale - modifies meaning of C and B bits (large pages) (is TEX bit 0)
L2_X    *       1 :SHL: 6       ; XScale - modifies meaning of C and B bits (tiny and extended pages) (is TEX bit 0)

; CP15 control register bits
; Retaining MMUC_* naming for compatability with existing code

; Validity: 5 = ARMv5 or older, 6=ARMv6, C=Cortex, !=Warning, bit reused
MMUC_M  *  1 :SHL: 0  ; 56C MMU enable
MMUC_A  *  1 :SHL: 1  ; 56C Alignment fault enable
MMUC_C  *  1 :SHL: 2  ; 56C Cache enable (or Data cache enable)
MMUC_W  *  1 :SHL: 3  ; 56  Write buffer enable
MMUC_P  *  1 :SHL: 4  ; 5   32-bit program space enable
MMUC_D  *  1 :SHL: 5  ; 5   32-bit data space enable
MMUC_L  *  1 :SHL: 6  ; 5   Late abort mode enable
MMUC_B  *  1 :SHL: 7  ; 56  Big-endian mode enable
MMUC_S  *  1 :SHL: 8  ; 5   S-mode enable
MMUC_R  *  1 :SHL: 9  ; 5   R-mode enable (ARM7 or later)
MMUC_F  *  1 :SHL: 10 ; 5   Coprocessor frequency bit (ARM700 only)
MMUC_Z  *  1 :SHL: 11 ; 56C Branch predictor enable
MMUC_I  *  1 :SHL: 12 ; 56C Instruction cache enable
MMUC_V  *  1 :SHL: 13 ; 56C High exception vectors
MMUC_RR *  1 :SHL: 14 ; 56  Round-robin/alternate cache replacement strategy
MMUC_L4 *  1 :SHL: 15 ; 5   Disable ARMv5 "load Thumb state with PC" behaviour
MMUC_U  *  1 :SHL: 22 ;  6  Unaligned data access operation
MMUC_XP *  1 :SHL: 23 ;  6  Extended page table config
MMUC_VE *  1 :SHL: 24 ;  6  Vectored interrupts
MMUC_EE *  1 :SHL: 25 ;  6C Exception Endian bit
MMUC_L2 *  1 :SHL: 26 ;  6  L2 unified cache enable
MMUC_NMFI * 1:SHL: 27 ;   C Non-maskable FIQ (read-only)
MMUC_TRE * 1 :SHL: 28 ;   C TEX remap enable
MMUC_AFE * 1 :SHL: 29 ;   C Access Flag Enable (AP[0] remap)
MMUC_nF *  1 :SHL: 30 ; 5!! not FastBus (ie separate CPUCLK from MEMCLK)
MMUC_TE *  1 :SHL: 30 ; !!C Exceptions handled in Thumb mode
MMUC_iA *  1 :SHL: 31 ; 5   Asynchronous

; ARM600 MMU coprocessor number

Arm600Cop CP      15

; ARM600 coprocessor registers

CR_ID           CN      0       ; read-only
CR_Control      CN      1       ; read/write
CR_TTabBase     CN      2       ; read/write
CR_Domains      CN      3       ; read/write
CR_FaultStatus  CN      5       ; read
CR_FaultAddress CN      6       ; read

; Cache type register fields
; NOTE - need to be kept in sync with hdr.MEMM.ARM600!

CT_ctype_pos    *       25
CT_ctype_mask   *       &F:SHL:CT_ctype_pos
CT_S_pos        *       24
CT_S            *       1:SHL:CT_S_pos
CT_Dsize_pos    *       12
CT_Dsize_mask   *       &FFF:SHL:CT_Dsize_pos
CT_Isize_pos    *       0
CT_Isize_mask   *       &FFF:SHL:CT_Isize_pos

CT_ctype_WT     *       0       ; write-through cache
CT_ctype_WB_Crd *       1       ; write-back, clean by reading data
CT_ctype_WB_CR7 *       2       ; write-back, clean with register 7
CT_ctype_WB_Cal_LD  *   5	; write-back, clean by allocating data, lockdown (?)
CT_ctype_WB_CR7_LDa *   6       ; write-back, clean with register 7, lockdown (format A)
CT_ctype_WB_CR7_LDb *   7       ; write-back, clean with register 7, lockdown (format B)
CT_ctype_WB_CR7_Lx *  8       ; write-back, clean with register 7, multiple cache levels

CT_size_pos     *       6
CT_size_mask    *       7:SHL:CT_size_pos
CT_assoc_pos    *       3
CT_assoc_mask   *       7:SHL:CT_assoc_pos
CT_M_pos        *       2
CT_M            *       1:SHL:CT_M_pos
CT_len_pos      *       0
CT_len_mask     *       3:SHL:CT_len_pos

CT_size_512     *       0
CT_size_1K      *       1
CT_size_2K      *       2
CT_size_4K      *       3
CT_size_8K      *       4
CT_size_16K     *       5
CT_size_32K     *       6
CT_size_64K     *       7
CT_size_768     *       0
CT_size_1536    *       1
CT_size_3K      *       2
CT_size_6K      *       3
CT_size_12K     *       4
CT_size_24K     *       5
CT_size_48K     *       6
CT_size_96K     *       7

CT_assoc_1      *       0
CT_assoc_2      *       1
CT_assoc_4      *       2
CT_assoc_8      *       3
CT_assoc_16     *       4
CT_assoc_32     *       5
CT_assoc_64     *       6
CT_assoc_128    *       7
CT_assoc_0      *       0
CT_assoc_3      *       1
CT_assoc_6      *       2
CT_assoc_12     *       3
CT_assoc_24     *       4
CT_assoc_48     *       5
CT_assoc_96     *       6
CT_assoc_192    *       7

CT_len_2        *       0
CT_len_4        *       1
CT_len_8        *       2
CT_len_16       *       3

CT_M_512        *       0
CT_M_1K         *       0
CT_M_2K         *       0
CT_M_4K         *       0
CT_M_8K         *       0
CT_M_16K        *       0
CT_M_32K        *       0
CT_M_64K        *       0
CT_M_768        *       1
CT_M_1536       *       1
CT_M_3K         *       1
CT_M_6K         *       1
CT_M_12K        *       1
CT_M_24K        *       1
CT_M_48K        *       1
CT_M_96K        *       1



        MACRO
        SetCop  $reg, $cop, $rm, $op2, $cc
        MCR$cc  Arm600Cop, 0, $reg, $cop, $rm, $op2
        MEND

        MACRO
        ReadCop $reg, $cop, $rm, $op2, $cc
        MRC$cc  Arm600Cop, 0, $reg, $cop, $rm, $op2
        MEND


        END
@


1.1.2.2
log
@Fix SetCop and ReadCop macros to work correctly if no op2 is given
Detail:
  hdr/MEMM/VMSAv6 - Fix SetCop and ReadCop to be compatible with original ARM600 versions
Admin:
  Tested on rev C2 beagleboard.


Version 1.62, 4.162.2.6. Tagged as 'HdrSrc-1_62-4_162_2_6'
@
text
@a111 1
CR_Dummy        CN      0
a207 3
      [ "$op2" = ""
        MCR$cc  Arm600Cop, 0, $reg, $cop, CR_Dummy
      |
a208 1
      ]
a212 3
      [ "$op2" = ""
        MRC$cc  Arm600Cop, 0, $reg, $cop, CR_Dummy
      |
a213 1
      ]
@



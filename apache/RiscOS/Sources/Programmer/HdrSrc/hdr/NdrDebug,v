head	4.9;
access;
symbols
	HdrSrc-2_77:4.9
	HdrSrc-2_76:4.9
	HdrSrc-2_75:4.9
	HdrSrc-2_74:4.9
	HdrSrc-2_73:4.9
	HdrSrc-2_72:4.9
	HdrSrc-2_71:4.9
	HdrSrc-2_70:4.9
	HdrSrc-2_69:4.9
	HdrSrc-2_68:4.9
	HdrSrc-2_67:4.9
	HdrSrc-2_66:4.9
	HdrSrc-2_65:4.9
	HdrSrc-2_64:4.9
	HdrSrc-2_63:4.9
	HdrSrc-2_62:4.9
	HdrSrc-2_61:4.9
	HdrSrc-2_60:4.9
	HdrSrc-2_59:4.9
	HdrSrc-2_58:4.9
	HdrSrc-2_57:4.9
	HdrSrc-2_56:4.9
	HdrSrc-2_55:4.9
	HdrSrc-2_54:4.9
	HdrSrc-2_53:4.9
	HdrSrc-2_52:4.9
	HdrSrc-2_51:4.9
	HdrSrc-2_50:4.9
	HdrSrc-2_49:4.9
	HdrSrc-2_48:4.9
	HdrSrc-2_47:4.9
	HdrSrc-2_46-4_247_2_1:4.9
	XCompile:4.9.0.2
	XCompile_bp:4.9
	HdrSrc-2_46:4.9
	HdrSrc-2_45:4.9
	HdrSrc-2_44:4.9
	HdrSrc-2_43:4.9
	HdrSrc-2_42:4.9
	HdrSrc-2_41:4.9
	HdrSrc-2_40-1:4.9
	HdrSrc-2_40:4.9
	HdrSrc-2_39:4.9
	HdrSrc-2_38:4.9
	HdrSrc-2_37:4.9
	HdrSrc-2_36:4.9
	HdrSrc-2_35:4.9
	HdrSrc-2_34:4.9
	HdrSrc-2_33:4.9
	HdrSrc-2_32:4.9
	HdrSrc-2_31:4.9
	HdrSrc-2_30:4.9
	HdrSrc-2_29:4.9
	HdrSrc-2_28:4.9
	HdrSrc-2_27:4.9
	HdrSrc-2_26:4.9
	HdrSrc-2_25:4.9
	HdrSrc-2_24:4.9
	HdrSrc-2_23:4.9
	HdrSrc-2_22:4.9
	HdrSrc-2_21:4.9
	HdrSrc-2_20:4.9
	HdrSrc-2_19:4.9
	HdrSrc-2_18:4.9
	HdrSrc-2_17:4.9
	HdrSrc-2_16:4.9
	HdrSrc-2_15:4.9
	HdrSrc-2_14:4.9
	HdrSrc-2_13:4.9
	HdrSrc-2_12:4.9
	HdrSrc-2_11:4.9
	HdrSrc-2_10:4.9
	HdrSrc-2_09:4.9
	HdrSrc-2_08:4.9
	HdrSrc-2_07:4.7
	HdrSrc-2_06:4.7
	HdrSrc-2_05:4.7
	HdrSrc-2_04:4.7
	HdrSrc-2_03:4.7
	HdrSrc-2_02:4.7
	HdrSrc-2_01:4.7
	HdrSrc-2_00:4.7
	HdrSrc-1_99:4.7
	HdrSrc-1_98:4.7
	HdrSrc-1_97:4.7
	HdrSrc-1_96:4.7
	HdrSrc-1_95:4.7
	HdrSrc-1_94:4.7
	HdrSrc-1_93:4.7
	HdrSrc-1_92:4.7
	HdrSrc-1_91:4.7
	HdrSrc-1_90:4.7
	HdrSrc-1_89:4.7
	HdrSrc-1_88:4.7
	HdrSrc-1_87:4.7
	HdrSrc-1_86:4.7
	HdrSrc-1_85:4.7
	HdrSrc-1_84:4.7
	HdrSrc-1_83:4.7
	HdrSrc-1_82:4.7
	HdrSrc-1_81:4.7
	HdrSrc-1_80:4.7
	HdrSrc-1_79:4.7
	HdrSrc-1_78:4.7
	HdrSrc-1_77:4.7
	HdrSrc-1_76:4.7
	Cortex_merge:4.7
	HdrSrc-1_62-4_162_2_15:4.7
	HdrSrc-1_75:4.7
	HdrSrc-1_62-4_162_2_14:4.7
	HdrSrc-1_74:4.7
	HdrSrc-1_62-4_162_2_13:4.7
	HdrSrc-1_62-4_162_2_12:4.7
	HdrSrc-1_73:4.7
	HdrSrc-1_72:4.7
	HdrSrc-1_62-4_162_2_11:4.7
	HdrSrc-1_62-4_162_2_10:4.7
	HdrSrc-1_71:4.7
	HdrSrc-1_70:4.7
	HdrSrc-1_69:4.7
	Cortex_bp:4.7
	HdrSrc-1_62-4_162_2_9:4.7
	HdrSrc-1_62-4_162_2_8:4.7
	HdrSrc-1_68:4.7
	HdrSrc-1_62-4_162_2_7:4.7
	HdrSrc-1_62-4_162_2_6:4.7
	HdrSrc-1_62-4_162_2_5:4.7
	HdrSrc-1_62-4_162_2_4:4.7
	HdrSrc-1_67:4.7
	HdrSrc-1_66:4.7
	HdrSrc-1_62-4_162_2_3:4.7
	HdrSrc-1_65:4.7
	HdrSrc-1_64:4.7
	HdrSrc-1_63:4.7
	HdrSrc-1_62-4_162_2_2:4.7
	HdrSrc-1_62-4_162_2_1:4.7
	Cortex:4.7.0.2
	HdrSrc-1_62:4.7
	HdrSrc-1_61:4.7
	HdrSrc-1_60:4.7
	HdrSrc-1_59:4.7
	HdrSrc-1_58:4.7
	HdrSrc-1_57:4.7
	HdrSrc-1_56:4.7
	HdrSrc-1_55:4.7
	HdrSrc-1_54:4.7
	HdrSrc-1_53:4.7
	HdrSrc-1_52:4.7
	HdrSrc-1_51:4.7
	HdrSrc-1_50:4.7
	HdrSrc-1_49:4.7
	HdrSrc-1_48:4.7
	HdrSrc-1_47:4.7
	RO_5_07:4.7
	HdrSrc-1_46:4.7
	HdrSrc-1_45:4.7
	HdrSrc-1_44:4.7
	HdrSrc-1_43:4.7
	HdrSrc-1_42:4.7
	HdrSrc-1_41:4.7
	HdrSrc-1_40:4.7
	HdrSrc-1_39:4.7
	HdrSrc-1_38:4.7
	HdrSrc-1_37:4.7
	HdrSrc-1_36:4.7
	HdrSrc-1_35:4.7
	HdrSrc-1_34:4.7
	HdrSrc-1_33:4.7
	HdrSrc-1_32:4.7
	HdrSrc-1_31:4.7
	HdrSrc-1_30:4.7
	HdrSrc-1_29:4.7
	HdrSrc-1_28:4.7
	HdrSrc-1_27:4.7
	HdrSrc-1_26:4.7
	HdrSrc-1_25:4.7
	HdrSrc-1_24:4.7
	HdrSrc-1_23:4.7
	HdrSrc-1_22:4.7
	HdrSrc-1_21:4.7
	HdrSrc-1_20:4.7
	HdrSrc-1_19:4.7
	HdrSrc-1_18:4.7
	HdrSrc-1_17:4.7
	HdrSrc-1_16:4.7
	HdrSrc-1_15:4.7
	HdrSrc-1_14:4.7
	HdrSrc-1_13:4.7
	HdrSrc-1_12:4.7
	HdrSrc-1_11:4.7
	HdrSrc-0_71-4_72_2_2:4.4
	HdrSrc-1_10:4.7
	HdrSrc-1_09:4.7
	HdrSrc-1_08:4.7
	HdrSrc-1_07:4.7
	HdrSrc-1_06:4.7
	HdrSrc-1_05:4.7
	dellis_autobuild_BaseSW:4.7
	HdrSrc-1_04:4.7
	HdrSrc-1_03:4.6
	HdrSrc-1_02:4.6
	HdrSrc-1_00:4.6
	HdrSrc-0_99:4.6
	HdrSrc-0_71-4_72_2_1:4.4
	Lazarus_Z11:4.4.0.4
	HdrSrc-0_98:4.6
	HdrSrc-0_97:4.6
	HdrSrc-0_95:4.6
	HdrSrc-0_94:4.6
	HdrSrc-0_93:4.6
	HdrSrc-0_92:4.6
	HdrSrc-0_91:4.6
	HdrSrc-0_90:4.6
	HdrSrc-0_89:4.6
	HdrSrc-0_88:4.6
	HdrSrc-0_87:4.6
	HdrSrc-0_86:4.6
	HdrSrc-0_85:4.5
	HdrSrc-0_84:4.5
	HdrSrc-0_83:4.5
	HdrSrc-0_82:4.5
	HdrSrc-0_81:4.5
	HdrSrc-0_80:4.5
	HdrSrc-0_79:4.5
	HdrSrc-0_78:4.4
	HdrSrc-0_77:4.4
	sbrodie_sedwards_16Mar2000:4.4
	HdrSrc-0_76:4.4
	HdrSrc-0_75:4.4
	HdrSrc-0_74:4.4
	HdrSrc-0_73:4.4
	HdrSrc-0_72:4.4
	HdrSrc-0_71:4.4
	HdrSrc-0_70:4.4
	HdrSrc-0_69:4.4
	HdrSrc-0_68:4.4
	HdrSrc-0_67:4.4
	HdrSrc-0_66:4.4
	HdrSrc-0_65:4.4
	HdrSrc-0_64:4.4
	kbracey_32bit_merge:4.4
	HdrSrc-0_63:4.4
	HdrSrc-0_57-4_58_2_9:4.4
	HdrSrc-0_57-4_58_2_8:4.4
	HdrSrc-0_57-4_58_2_7:4.4
	HdrSrc-0_57-4_58_2_6:4.4
	HdrSrc-0_57-4_58_2_5:4.4
	HdrSrc-0_57-4_58_2_4:4.4
	HdrSrc-0_57-4_58_2_3:4.4
	HdrSrc-0_62:4.4
	HdrSrc-0_61:4.4
	HdrSrc-0_60:4.4
	HdrSrc-0_57-4_58_2_2:4.4
	HdrSrc-0_59:4.4
	HdrSrc-0_58:4.4
	HdrSrc-0_57-4_58_2_1:4.4
	kbracey_32bit:4.4.0.2
	HdrSrc-0_57:4.4
	HdrSrc-0_56:4.4
	HdrSrc-0_55:4.4
	HdrSrc-0_54:4.4
	HdrSrc-0_53:4.4
	HdrSrc-0_52:4.4
	HdrSrc-0_51:4.4
	HdrSrc-0_50:4.4
	HdrSrc-0_49:4.4
	HdrSrc-0_48:4.4
	HdrSrc-0_47:4.4
	HdrSrc-0_46:4.4
	HdrSrc-0_45:4.4
	HdrSrc-0_44:4.4
	HdrSrc-0_43:4.4
	HdrSrc-0_42:4.4
	dcotton_autobuild_BaseSW:4.7
	HdrSrc-0_41:4.4
	HdrSrc-0_39:4.4
	HdrSrc-0_38:4.4
	HdrSrc-0_37:4.4
	HdrSrc-0_36:4.4
	HdrSrc-0_35:4.4
	HdrSrc-0_34:4.4
	HdrSrc-0_33:4.4
	HdrSrc-0_32:4.4
	HdrSrc-0_31:4.4
	Ursula_RiscPC_merge:4.2.4.1
	HdrSrc-0_30:4.4
	HdrSrc-0_29:4.4
	Ursula_merge:4.2.4.1
	HdrSrc-0_28:4.4
	HdrSrc-0_27:4.4
	HdrSrc-0_26:4.4
	HdrSrc-0_25:4.4
	HdrSrc-0_24:4.4
	HdrSrc-0_23:4.4
	HdrSrc-0_22:4.4
	HdrSrc-0_21:4.4
	HdrSrc-0_20:4.4
	HdrSrc-0_19:4.2
	nturton_HdrSrc-0_11:4.2
	HdrSrc-0_18:4.2
	HdrSrc-0_17:4.2
	HdrSrc-0_16:4.2
	HdrSrc-0_15:4.2
	HdrSrc-0_14:4.2
	HdrSrc-0_13:4.2
	HdrSrc-0_12:4.2
	HdrSrc-0_11:4.2
	HdrSrc-0_10:4.2
	HdrSrc-0_09:4.2
	HdrSrc-0_08:4.2
	HdrSrc-0_07:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.4.1
	Ursula_RiscPC:4.2.4.1.0.2
	HdrSrc-0_06:4.2
	HdrSrc-0_05:4.2
	HdrSrc-0_04:4.2
	HdrSrc-0_03:4.2
	HdrSrc-0_02:4.2
	HdrSrc-0_01:4.2
	nicke_HdrSrc_21_9_98:4.2
	nicke_HdrSrc_21_8_98:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.2.4.1
	UrsulaBuild_FinalSoftload:4.2.4.1
	rthornb_UrsulaBuild-12Aug1998:4.2.4.1
	aglover_UrsulaBuild-05Aug1998:4.2.4.1
	rthornb_UrsulaBuild-29Jul1998:4.2.4.1
	rthornb_UrsulaBuild-22Jul1998:4.2.4.1
	rthornb_UrsulaBuild-15Jul1998:4.2.4.1
	rthornb_UrsulaBuild-07Jul1998:4.2.4.1
	rthornb_UrsulaBuild-17Jun1998:4.2.4.1
	afrost_NC2_Generic:4.1
	rthornb_UrsulaBuild-03Jun1998:4.2.4.1
	rthornb_UrsulaBuild-27May1998:4.2.4.1
	rthornb_UrsulaBuild-21May1998:4.2.4.1
	rthornb_UrsulaBuild_01May1998:4.2.4.1
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Spin_merge_16May97:4.1.7.1
	Daytona:4.2.0.2
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.4
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_merge:4.1.7.2
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2012.05.29.12.53.24;	author bavison;	state Exp;
branches;
next	4.8;
commitid	pYwyWGQF2CfgpC6w;

4.8
date	2012.05.27.19.57.37;	author bavison;	state Exp;
branches;
next	4.7;
commitid	6rpbovOQutiNOo6w;

4.7
date	2000.09.21.11.23.22;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2000.05.18.13.14.52;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2000.04.04.10.04.00;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.05.28.11.42.30;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	99.05.24.15.33.37;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	97.05.16.11.42.35;	author kbracey;	state Exp;
branches
	4.2.4.1;
next	4.1;

4.1
date	96.11.05.09.21.24;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.4.1
date	98.02.05.12.30.45;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.21.24;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.36.54;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.36.08;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.32.34;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.04.30.17.58.14;	author scormie;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Removed some unwanted CR characters from headers.
Retagged as 'HdrSrc-2_08'

Version 2.08. Not tagged
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > &.Hdr.NdrDebug
;

OldOpt	SETA	{OPT}
	OPT	OptNoList+OptNoP1List

; ***********************************
; ***	C h a n g e	L i s t	***
; ***********************************

; Date	Name	Description
; ----	----	-----------
;
; 25-Sep-89	NDR	First version written
;  3-May-90	NDR	File debugging added
; 30-Aug-90	NDR	Changed so if file can't be opened, no debugging is output
;  1-Nov-90	NDR	Neil_NewLine flushes data to file
;  6-Nov-90	NDR	Neil_NewLine also puts out end-of-file marker and resets PTR
;  2-Jan-91	NDR	Ensure Debug macro still works if V set on entry
;  3-Jan-91	NDR	Ensure debug_flush deals correctly when no debug output
;  4-Jan-91	NDR	Preserve R2 in Neil_Write0 and Neil_Newline
; 10-Apr-91	OSS	Changed all macros, particularly InsertNDRDebugRoutines,
;			to not put any code in if the debug flag is not set. This
;			is because too many modules are messing things up and
;			are putting debugging code into the ROM!
; 10-Feb-93	BC	Restored OPT correctly
; 27-Apr-93	AMG	Changed the macros to use HostFS SWIs instead of OS_CLI.
;			This stops scratchspace corruption which was affecting
;			Colourtrans_SelectTable debug calls. Added logic flag
;			to allow assembling ColourTrans with the previous version
;			to raise an error.
; 14-Jul-93	SAH	Print *NULL* if DebugS is given a 0 pointer.
;  2-Aug-93	SAH	Increased number of parameters to 10
;  2-Aug-93	SAH	Added conditional versions (DebugIf, DebugaIf, DebugSIf)
; 13-Oct-93	AMG	Merge the two copies of NdrDebug together, and remove
;			the one from hdr - ATTENTION: NdrDebug lives in hdr2 !!!
; 20-Sep-94	SMC	Added support for DebugIt module (set debug_module to true,
;			hostvdu should be false).
; 17-Apr-97	JRC	If debug_file is set, it is a file name which is opened,
;			written to and closed in each call to Debug. Even better
;			than debug_flush!
; 15-Jan-98     KJB     Added support for PDebug module (set pdebug_module to true,
;			hostvdu should be false).
; 21-May-99	BJGA	Added support for debugging null-terminated strings:
;			top-bit-clear characters (other than CR and LF) are effectively
;			reverse-GSTrans'd (set debug_nullterminatedstrings to true).
;			Also added support for DADebug module (set daddebug_module true).
;			hostvdu is now defined, and set false, if not yet defined.
;			Debug_Open and Debug_Close only generate code in cases where the
;			output mechanism needs it, so they no longer need to be
;			bracketed conditionally in the source code.
; 28-May-99	BJGA	Added debug_irqsafe option, which converts a 32-bit number to a
;			string itself, without calling OS_ConvertHex8
; 04-Apr-00	KJB	Made 32-bit compatible (except a few options, which will generate
;			warnings)
; 05-Apr-00     BJGA    debug_nullterminatedstrings also made 32-bit compatible;
;                       32-bit compatibility now complete
; 14-Aug-00     BJGA    Now outputs the value of r13 correctly; No32BitCode-unset variant
;                       now objasm-compatible (uses mymrs macros rather than mrs macros)

	GBLL	debug
	GBLL	debug_flush
	GBLS	debug_file
	GBLL	true
	GBLL	false

; New logical variable for use in sources which suffer from scratchspace
; corruption caused by older version of this header calling OS_CLI instead
; of HostFS by SWI directly. Set it to {FALSE} before incorporating this
; header file to ensure that the new header file is in use. You may also
; need to add a GET for hdr:HostFS

	GBLL	debug_noscratchspace
debug_noscratchspace	SETL	{TRUE}

 [ :LNOT: :DEF: hostvdu
	GBLL	hostvdu				; Use HostFS
hostvdu		SETL	{FALSE}
 ]
	GBLL	debug_module			; Use DebugIt module
debug_module	SETL	{FALSE}

	GBLL	pdebug_module			; Use PDebug module
pdebug_module	SETL	{FALSE}

	GBLL	dadebug_module			; Use DADebug module
dadebug_module	SETL	{FALSE}

	GBLL	debug_nullterminatedstrings	; Print control characters in strings
debug_nullterminatedstrings	SETL	{FALSE}

	GBLL	debug_irqsafe			; Emulate SWI OS_ConvertHex8
debug_irqsafe	SETL	{FALSE}

true		SETL	1=1
false		SETL	1=0

debug_flush	SETL	false	; default - can be altered before InsertNDRDebugRoutines
debug_file	SETS	""	; default - can be altered before InsertNDRDebugRoutines

; NB: All s preserve the flags and all registers.
;	However, they do require the stack to be set up.

	MACRO
$lab	Debug_Open	$filename
$lab
	[ debug :LAND: :LNOT: hostvdu :LAND: :LNOT: debug_module :LAND: :LNOT: pdebug_module
	[	dadebug_module	; this doesn't use $filename
	Push	"R0, LR"
	SWI	&731C0		; XDADebug_GetWriteCAddress
	MOVVS	R0, #0
	ADRL	LR, dadebug_writec
	STR	R0, [LR]
	CLRV
	Pull	"R0, LR"
	|
	[	debug_file = ""
	Push	"R1, LR"
	ADR	R1, %FT00
	BL	Neil_OpenFile
	B	%FT01
00
	DCB	"$filename", 0
	ALIGN
01
	Pull	"R1, LR"
	|
	Debug	"", "------------------------------------------------------------"
	]
	]
	]
	MEND

	MACRO
$lab	Debug_Close
$lab
	[ debug :LAND: :LNOT: hostvdu :LAND: :LNOT: debug_module :LAND: :LNOT: pdebug_module
	[ dadebug_module
	Push	"LR"
	MOV	LR, #0
	STR	LR, dadebug_writec
	Pull	"LR"
	|
	[ debug_file = ""
	Push	"LR"
	BL	Neil_CloseFile
	Pull	"LR"
	]
	]
	]
	MEND

	MACRO
	Debug1	$dbg, $string
	[	debug$dbg
	Debug	$dbg, "$string"
	]
	MEND

	MACRO
	Debug2	$dbg, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug$dbg
	Debug	$dbg, "", $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	]
	MEND

	MACRO
	Debug2a	$dbg, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug$dbg
	Debuga	$dbg, "", $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	]
	MEND

	MACRO
	DebugS	$dbg, $string, $reg, $max
	[	debug:LAND:debug$dbg
        [ No32bitCode
	Push	"R0-R12, LR, PC"
        |
        SUB     sp, sp, #4
	Push	"R0-R12, LR"
        mymrs  ,LR, CPSR
        STR     LR, [sp, #14*4]
        ]

	[	debug_file <> ""
	ADR	R1, %FT10
	BL	Neil_OpenFile
	B	%FT11
10
	DCB	"$debug_file", 0
	ALIGN
11
	]
	[	hostvdu
	BL	Neil_HostVdu
	]

	MOV	r0, pc
	BL	Neil_ConvertHex8

	ADR	R0, %FT00
	BL	Neil_Write0
	B	%FT01
00
	DCB	": $dbg, $string", 0
02
	DCB	"*NULL*", 0
	ALIGN
01
	MOV	R0, #" "
	BL	Neil_WriteC
	MOV	R0, #"'"
	BL	Neil_WriteC
	[	$reg > sp
	LDR	R0, [sp, #:INDEX:$reg * 4 - 4]	; R13 is not stacked
	|
	LDR	R0, [sp, #:INDEX:$reg * 4]
	]

	TEQ	R0, #0
	ADREQ	R0, %BT02

	[	"$max"=""
	BL	Neil_Write0
	|
	MOV	R2, #$max
	BL	Neil_Write0_R2max
	]
	MOV	R0, #"'"
	BL	Neil_WriteC
	BL	Neil_NewLine
	[	hostvdu
	BL	Neil_TubeVdu
	]

	[	debug_file <> ""
	BL	Neil_CloseFile
	]
	Pull	"R0-R12"
	LDR	LR, [sp, #4]
        RestPSR LR,,f                   ; restore flags
	LDR	LR, [sp], #8		; correct stack
	]
	MEND

	MACRO
	Debug	$dbg, $string, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug:LAND:debug$dbg
        [ No32bitCode
	Push	"R0-R12, LR, PC"
        |
        SUB     sp, sp, #4
	Push	"R0-R12, LR"
        mymrs  ,LR, CPSR
        STR     LR, [sp, #14*4]
        ]

	[	debug_file <> ""
	ADR	R1, %FT10
	BL	Neil_OpenFile
	B	%FT11
10
	DCB	"$debug_file", 0
	ALIGN
11
	]
	[	hostvdu
	BL	Neil_HostVdu
	]

	MOV	r0, pc
	BL	Neil_ConvertHex8

	ADR	R0, %FT00
	BL	Neil_Write0
	B	%FT01
00
	DCB	": $dbg, $string", 0
	ALIGN
01
	[	"$p1"<>""
	Dreg	$p1
	]
	[	"$p2"<>""
	Dreg	$p2
	]
	[	"$p3"<>""
	Dreg	$p3
	]
	[	"$p4"<>""
	Dreg	$p4
	]
	[	"$p5"<>""
	Dreg	$p5
	]
	[	"$p6"<>""
	Dreg	$p6
	]
	[	"$p7"<>""
	Dreg	$p7
	]
	[	"$p8"<>""
	Dreg	$p8
	]
	[	"$p9"<>""
	Dreg	$p9
	]
	[	"$p10"<>""
	Dreg	$p10
	]
	BL	Neil_NewLine
	[	hostvdu
	BL	Neil_TubeVdu
	]

	[	debug_file <> ""
	BL	Neil_CloseFile
	]

	Pull	"R0-R12"
	LDR	LR, [sp, #4]
        RestPSR LR,,f                   ; restore flags
	LDR	LR, [sp], #8		; correct stack
	]
	MEND

	MACRO
	Debuga	$dbg, $string, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug:LAND:debug$dbg
        [ No32bitCode
	Push	"R0-R12, LR, PC"
        |
        SUB     sp, sp, #4
	Push	"R0-R12, LR"
        mymrs  ,LR, CPSR
        STR     LR, [sp, #14*4]
        ]

	[	hostvdu
	BL	Neil_HostVdu
	]
	ADR	R0, %FT00
	BL	Neil_Write0
	B	%FT01
00
	DCB	"$string", 0
	ALIGN
01
	[	"$p1"<>""
	Dreg	$p1
	]
	[	"$p2"<>""
	Dreg	$p2
	]
	[	"$p3"<>""
	Dreg	$p3
	]
	[	"$p4"<>""
	Dreg	$p4
	]
	[	"$p5"<>""
	Dreg	$p5
	]
	[	"$p6"<>""
	Dreg	$p6
	]
	[	"$p7"<>""
	Dreg	$p7
	]
	[	"$p8"<>""
	Dreg	$p8
	]
	[	"$p9"<>""
	Dreg	$p9
	]
	[	"$p10"<>""
	Dreg	$p10
	]
	[	hostvdu
	BL	Neil_TubeVdu
	]
	Pull	"R0-R12"
	LDR	LR, [sp, #4]
        RestPSR LR,,f                   ; restore flags
	LDR	LR, [sp], #8		; correct stack
	]
	MEND

	MACRO
	Dreg	$reg
	[	debug
	[	"$reg":LEFT:1 = "#"
	LCLS	locn
locn	SETS	"$reg":RIGHT:(:LEN:"$reg"-1)
	[	:BASE:($locn) = sp
	LDR	R0, $locn + 15*4		; allow for 15 stacked registers
	|
	LDR	R0, $locn
	]
	|
	[	$reg > sp
	LDR	R0, [sp, #:INDEX:$reg * 4 - 4]	; R13 is not stacked
	|
	[       $reg = sp
	ADD	R0, sp, #15*4
	|
	LDR	R0, [sp, #:INDEX:$reg * 4]
	]
	]
	]
	BL	Neil_ConvertHex8
	]	; End debug
	MEND

	MACRO
$lab	DebugE	$dbg, $mess
	[	debug:LAND:debug$dbg
$lab	BVC	%ft0
	ADD	R0, R0, #4
	DebugS	$dbg, "$mess", R0
	SUB	R0, R0, #4
0
	]
	MEND
; Conditional versions of some of the above macros

	MACRO
$lab	DebugSIf	$cond, $dbg, $string, $reg, $max
	[	debug:LAND:debug$dbg
$lab	B$cond	%FT99
	B	%FT98
99
	DebugS	$dbg, "$string", "$reg", "$max"
98
	]
	MEND

	MACRO
$lab	DebugaIf	$cond, $dbg, $string, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug:LAND:debug$dbg
$lab	B$cond	%FT99
	B	%FT98
99
	Debuga	$dbg, "$string", $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	]
	MEND

	MACRO
$lab	DebugIf	$cond, $dbg, $string, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug:LAND:debug$dbg
$lab	B$cond	%FT99
	B	%FT98
99
	Debug	$dbg, "$string", $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
98
	]
	MEND

	MACRO
	InsertNDRDebugRoutines
	[	debug

Neil_ConvertHex8			; prints number in R0
	Push	"R0, LR"
;
	MOV	R0, #" "
	BL	Neil_WriteC
	[ debug_irqsafe
	Pull	"R1"
	MOV	R2, #8
01	MOV	R0, R1, LSR#28
	CMP	R0, #10
	ADDCC	R0, R0, #48
	ADDCS	R0, R0, #55
	BL	Neil_WriteC
	MOV	R1, R1, LSL#4
	SUBS	R2, R2, #1
	BNE	%BT01
	|
	Pull	"R0"
	SUB	sp, sp, #12
	MOV	R1, sp
	MOV	R2, #9			; includes room for terminator
	SWI	XOS_ConvertHex8
	ADDVS	R0, R0, #4		; print error message if there was one
	BL	Neil_Write0
	ADD	sp, sp, #12
	]
;
	Pull	"PC"

	[	hostvdu
Neil_HostVdu
        EntryS

	SWI	XHostFS_HostVdu
	SWI	XOS_WriteI+4		; VDU 4 mode in case no HostVdu

        EXITS

Neil_TubeVdu
        EntryS

	SWI	XHostFS_TubeVdu

        EXITS
	]

Neil_Write0
        EntryS  "R2"
	MOV	R2, #&10000000	; no limit on string length
	BL	Neil_Write0_R2max
        EXITS

Neil_Write0_R2max
        EntryS  "R0"
	MOV	R1, R0		; R1 -> string, R2 = max length (unsigned)
01	LDRB	R0, [R1], #1
	[	debug_nullterminatedstrings
	CMP	R0, #1
	|
	CMP	R0, #32		; terminate on any ctrl-char
	]
	SUBCSS	R2, R2, #1
	BLCS	Neil_WriteC
	BCS	%BT01
02
        EXITS

Neil_WriteC
	[	pdebug_module
        EntryS  "R0-R2"
	|
        EntryS  "R0, R1"
	]
	[	debug_nullterminatedstrings
	CMN	R0, #0		; clear C
	TEQ	R0, #""""	; TEQ without shift preserves C
	TEQNE	R0, #"|"
	TEQNE   R0, #"<"
	EOREQ	R0, R0, #"@@"	; these characters don't need converting when prefixed by "|"
	TEQNE	R0, #127
	CMPNE	R0, #32		; CS if >= Space, except ", |, < and Delete
	TEQ	R0, #0
	TEQNE	R0, #10
	TEQNE	R0, #13
	CMPEQ	R0, #0		; now also CS if R0 was 0, 10 or 13
	EORCC	R1, R0, #"@@"	; if non line-end control character, generate escaped character
	MOVCC	R0, #"|"	; and prefix with "|"
	BLCC	%FT01		; preserves flags, fortunately
	MOVCC   R0, R1
	B       %FT02
01
        ALTENTRY
02
	]
	LDR	R1, Neil_FileHandle
	CMP	R1, #0		; 0 => writec, -1 => none, >0 => file
	[	debug_module
	SWIEQ	XDebugIt_WriteC
	|
	[	pdebug_module
	MOVEQ	R0,#0
        ADDEQ   R1,R13,#Proc_RegOffset ; yuck :)
	MOVEQ	R2,#1
	SWIEQ	&6F900		; XPDebugM_Send
	|
	[	dadebug_module
	BGT	%FT01
	LDR	LR, dadebug_writec
	CMP	LR, #0		; undefined?
	BEQ	%FT01
	MOV	LR, PC
	LDR	PC, dadebug_writec
	CMP	R0, R0		; ensure not GT
01
	|
	SWIEQ	XOS_WriteC
	]
	]
	]
	SWIGT	XOS_BPut
        EXITS

Neil_NewLine
	ROUT
        EntryS  "R0-R2"
	LDR	R14, Neil_FileHandle
	CMP	R14, #0
	MOVEQ	R0, #13		 ; only write CR if not to a file
	BLEQ	Neil_WriteC
	MOV	R0, #10
	BL	Neil_WriteC
	[	debug_flush
	LDR	R1, Neil_FileHandle	; ensure bytes to the media after each line
	CMP	R1, #0
	BLE	%FT00
	MOV	R0, #"E"
	BL	Neil_WriteC
	MOV	R0, #"O"
	BL	Neil_WriteC
	MOV	R0, #"F"
	BL	Neil_WriteC
	MOV	R0, #255		; ensure bytes to media
	SWI	XOS_Args
	MOV	R0, #0			; read PTR in R2
	SWI	XOS_Args
	SUB	R2, R2, #3
	MOV	R0, #1			; write PTR in R2
	SWI	XOS_Args
00
	]
        EXITS

Neil_OpenFile
	ROUT
        Entry   "R0-R2"
	MOV	r0, #-1
	STR	r0, Neil_FileHandle	; -1 => no file debugging

	MOV	r0, #&C7		; open for update
	SWI	XOS_Find
        EXIT    VS
	TEQ	r0, #0			; object exists?
	BEQ	%20

	;File found---get the extent
	MOV	r1, r0			; file handle
	MOV	r0, #2			; read extent
	SWI	XOS_Args
        EXIT    VS
	;r2 = extent

	;Set the pointer to the extent
	MOV	r0, #1			; write ptr
	;r1 still has file handle
	;r2 still has extent
	SWI	XOS_Args
        EXIT    VS
	B	%30

20	;File not found---open a new one for output
	MOV	r0, #&87		; open for output
	SWI	XOS_Find
        EXIT    VS
	;r0 = file handle
	;r1 -> file name

	;Make it a text file
	Push	"r0"
	MOV	r0, #18
	MOV	r2, #&FF
	ORR	r2, r2, #&F00		; file type text
	SWI	XOS_File
	Pull	"r1"
        EXIT    VS

30	STR	r1, Neil_FileHandle
        EXIT

Neil_CloseFile
	ROUT
        EntryS  "R0-R1"
	MOV	R0, #0			; close file
	LDR	R1, Neil_FileHandle
	CMP	R1, #0
	STRGT	R0, Neil_FileHandle	; back to writec debugging
	SWIGT	XOS_Find
        EXITS

Neil_FileHandle	DCD	0		; default state => writec debugging

	[	dadebug_module
dadebug_writec	DCD	0		; workspace to hold routine pointer
	]

	]	; End debug

	MEND

	OPT	OldOpt

	END
@


4.8
log
@  Miscellaneous changes
Detail:
  * Hdr:CMOS gains bit definitions for byte &10 (from allocations master copy)
  * Hdr:NdrDebug changed to avoid assembler warnings about push of LR+PC
    (at least for :LNOT: No32bitCode case)
Admin:
  Changes received from Rob Sprowson

Version 2.08. Tagged as 'HdrSrc-2_08'
@
text
@d191 1
a191 1
        [ No32bitCode
d193 3
a195 3
        |
        SUB     sp, sp, #4
	Push	"R0-R12, LR"
d264 1
a264 1
        [ No32bitCode
d266 3
a268 3
        |
        SUB     sp, sp, #4
	Push	"R0-R12, LR"
d345 1
a345 1
        [ No32bitCode
d347 3
a349 3
        |
        SUB     sp, sp, #4
	Push	"R0-R12, LR"
d353 1
a353 1

@


4.7
log
@  A couple of changes to the NdrDebug header.
Detail:
  * Debug macros can now be used to output the value of r13 (previously, the
    value of r14 was erroneously output instead).
  * Switched from using mrs macros to mymrs macros, so builds with the
    No32BitCode flag unset are now objasm-compatible.
Admin:
  Has been used in a debugging session, and debug routines worked as expected.

Version 1.04. Tagged as 'HdrSrc-1_04'
@
text
@d191 1
d193 3
a195 1
        [ :LNOT:No32bitCode
d264 1
d266 3
a268 1
        [ :LNOT:No32bitCode
d345 1
d347 3
a349 1
        [ :LNOT:No32bitCode
d353 1
@


4.6
log
@Hdr:Debug made 32-bit compatible.
Hdr:NdrDebug made fully 32-bit compatible (only change is to the code switched
    using the debug_nullterminatedstrings variable).

Version 0.86. Tagged as 'HdrSrc-0_86'
@
text
@d72 2
d193 1
a193 1
        mrs    ,LR, CPSR
d263 1
a263 1
        mrs    ,LR, CPSR
d341 1
a341 1
        mrs    ,LR, CPSR
d409 3
d413 1
@


4.5
log
@More 32-bit tweaks. Some assembler macros extended to accept condition codes
and PSR flag subset specifiers.
CPU.FPA header file added.

Version 0.79. Tagged as 'HdrSrc-0_79'
@
text
@d70 2
d530 5
a535 1
        !       1, "Not 32-bit safe!"
d547 1
a547 2
	EORCC	R0, R0, #"@@"	; if non line-end control character, generate escaped character
	Push	"R0, LR", CC
d550 2
a551 1
	Pull	"R0, LR", CC
d553 2
a554 5
	]
	[	pdebug_module
        EntryS  "R0-R2"
	|
        EntryS  "R0, R1"
@


4.4
log
@Added debug_irqsafe option, which converts a 32-bit number to a	string itself,
without calling OS_ConvertHex8.

Retagged as HdrSrc-0_20.
@
text
@d68 2
d188 4
d249 1
a249 1
	TEQP	LR, #0			; restore flags
d258 4
d327 1
a327 1
	TEQP	LR, #0			; restore flags
d336 4
d385 1
a385 1
	TEQP	LR, #0			; restore flags
d491 1
a491 1
	Push	"LR"
d496 1
a496 1
	Pull	"PC", , ^
d499 1
a499 1
	Push	"LR"
d503 1
a503 1
	Pull	"PC", , ^
d507 1
a507 1
	Push	"R2, LR"
d510 1
a510 1
	Pull	"R2, PC", , ^
d513 1
a513 1
	Push	"R0, LR"
d525 1
a525 1
	Pull	"R0, PC", , ^
d529 1
d549 1
a549 1
	Push	"R0-R2, LR"
d551 1
a551 1
	Push	"R0, R1, LR"
d560 1
a560 1
	MOVEQ	R1,R13		; yuck :)
d579 1
a579 5
	[	pdebug_module
	Pull	"R0-R2, PC", , ^
	|
	Pull	"R0, R1, PC", , ^
	]
d583 1
a583 1
	Push	"R0-R2, LR"
d609 1
a609 1
	Pull	"R0-R2, PC", , ^
d613 1
a613 1
	Push	"R0-R2, LR"
d619 1
a619 1
	Pull	"R0-R2, PC", VS
d627 1
a627 1
	Pull	"R0-R2, PC", VS
d635 1
a635 1
	Pull	"R0-R2, PC", VS
d641 1
a641 1
	Pull	"R0-R2, PC", VS
d652 1
a652 1
	Pull	"R0-R2, PC", VS
d655 1
a655 1
	Pull	"R0-R2, PC",, ^
d659 1
a659 1
	Push	"R0-R1, LR"
d665 1
a665 1
	Pull	"R0-R1, PC", , ^
@


4.3
log
@Updated Hdr:NdrDebug:
* folded in Ursula branch (support for PDebug module);
* added support for control characters within strings (eg control sequences in
  strings to be passed to Font_Paint);
* added support for DADebug module;
* made debug method-independent code easier to write by making the Debug_Open
  and Debug_Close macros do nothing when module output is selected, and by
  predefining the hostvdu variable as false if it's not yet defined.

Version 0.20. Tagged as 'HdrSrc-0_20'
@
text
@d66 2
d85 1
a85 1
	GBLL	hostvdu
d88 1
a88 1
	GBLL	debug_module
d91 1
a91 1
	GBLL	pdebug_module
d94 1
a94 1
	GBLL	dadebug_module
d97 1
a97 1
	GBLL	debug_nullterminatedstrings
d100 3
d451 12
d471 1
@


4.2
log
@Spinner branch merged
@
text
@d36 1
a36 1
; 10-Apr-91	OSS	Changed all macros, particularly InsertNDRDebugRoutines, 
d51 1
a51 1
; 20-Sep-94	SMC	Added support for DebugIt module (set debug_module to true, 
d53 1
a53 1
; 17-Apr-97	JRC	If debug_file is set, it is a file name which is opened, 
d56 10
d82 4
d89 9
d110 10
a119 1
	[	debug
d134 1
d140 8
a147 1
	[ debug :LAND: debug_file = ""
d152 2
d484 3
d488 1
d496 22
d519 1
d525 16
d543 2
d546 3
d550 1
d592 1
a592 1
	BEQ	%20			
d639 4
@


4.2.4.1
log
@Added support for PDebugM module
@
text
@d36 1
a36 1
; 10-Apr-91	OSS	Changed all macros, particularly InsertNDRDebugRoutines,
d51 1
a51 1
; 20-Sep-94	SMC	Added support for DebugIt module (set debug_module to true,
d53 1
a53 1
; 17-Apr-97	JRC	If debug_file is set, it is a file name which is opened,
a55 2
; 15-Jan-98     KJB     Added support for PDebug module (set pdebug_module to true,
;			hostvdu should be false).
a74 3
	GBLL	pdebug_module
pdebug_module	SETL	{FALSE}

a449 3
	[	pdebug_module
	Push	"R0-R2, LR"
	|
a450 1
	]
a455 6
        [ 	pdebug_module
        MOVEQ	R0,#0
	MOVEQ	R1,R13		; yuck :)
	MOVEQ	R2,#1
	SWIEQ	&6F900		; XPDebugM_Send
	|
a456 1
        ]
a458 3
	[	pdebug_module
	Pull	"R0-R2, PC", , ^
	|
a459 1
	]
d501 1
a501 1
	BEQ	%20
@


4.1
log
@Initial revision
@
text
@d18 2
a19 2
OldOpt  SETA    {OPT}
        OPT     OptNoList+OptNoP1List
d22 1
a22 1
; ***    C h a n g e   L i s t    ***
d25 2
a26 28
; Date       Name  Description
; ----       ----  -----------
;
; 25-Sep-89  NDR   First version written
;  3-May-90  NDR   File debugging added
; 30-Aug-90  NDR   Changed so if file can't be opened, no debugging is output
;  1-Nov-90  NDR   Neil_NewLine flushes data to file
;  6-Nov-90  NDR   Neil_NewLine also puts out end-of-file marker and resets PTR
;  2-Jan-91  NDR   Ensure Debug macro still works if V set on entry
;  3-Jan-91  NDR   Ensure debug_flush deals correctly when no debug output
;  4-Jan-91  NDR   Preserve R2 in Neil_Write0 and Neil_Newline
; 10-Apr-91  OSS   Changed all macros, particularly InsertNDRDebugRoutines,
;                  to not put any code in if the debug flag is not set. This
;                  is because too many modules are messing things up and
;                  are putting debugging code into the ROM!
; 10-Feb-93  BC    Restored OPT correctly
; 27-Apr-93  AMG   Changed the macros to use HostFS SWIs instead of OS_CLI.
;                  This stops scratchspace corruption which was affecting
;                  Colourtrans_SelectTable debug calls. Added logic flag
;                  to allow assembling ColourTrans with the previous version
;                  to raise an error.
; 14-Jul-93  SAH   Print *NULL* if DebugS is given a 0 pointer.
;  2-Aug-93  SAH   Increased number of parameters to 10
;  2-Aug-93  SAH   Added conditional versions (DebugIf, DebugaIf, DebugSIf)
; 13-Oct-93  AMG   Merge the two copies of NdrDebug together, and remove
;                  the one from hdr - ATTENTION: NdrDebug lives in hdr2 !!!
; 20-Sep-94  SMC   Added support for DebugIt module (set debug_module to true,
;                  hostvdu should be false).
d28 34
a62 5
        GBLL    debug
        GBLL    debug_flush
        GBLL    true
        GBLL    false
           
d69 2
a70 5
        GBLL    debug_noscratchspace
debug_noscratchspace SETL {TRUE}

        GBLL    debug_module
debug_module    SETL    {FALSE}
d72 2
a73 2
true    SETL    1=1
false   SETL    1=0
d75 2
a76 1
debug_flush     SETL    false   ; default - can be altered before InsertNDRDebugRoutines
d78 2
d82 1
a82 1
;     However, they do require the stack to be set up.
d84 2
a85 2
        MACRO
$lab    Debug_Open $filename
d87 6
a92 5
      [ debug
        Push    "R1,LR"
        ADR     R1, %FT00
        BL      Neil_OpenFile
        B       %FT01
d94 2
a95 2
        DCB     "$filename", 0
        ALIGN
d97 6
a102 3
        Pull    "R1,LR"
      ]
        MEND
d104 2
a105 2
        MACRO
$lab    Debug_Close
d107 52
a158 38
      [ debug
        Push    "LR"
        BL      Neil_CloseFile
        Pull    "LR"
      ]
        MEND

        MACRO
        Debug1  $dbg,$string
      [ debug$dbg
        Debug   $dbg,"$string"
      ]
        MEND

        MACRO
        Debug2  $dbg,$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
      [ debug$dbg
        Debug   $dbg,"",$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
      ]
        MEND

        MACRO
        Debug2a $dbg,$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
      [ debug$dbg
        Debuga  $dbg,"",$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
      ]
        MEND

        MACRO
        DebugS  $dbg,$string,$reg,$max
      [ debug:LAND:debug$dbg
        Push    "R0-R12,LR,PC"
      [ hostvdu
        BL      Neil_HostVdu
      ]
        ADR     R0, %FT00
        BL      Neil_Write0
        B       %FT01
d160 1
a160 1
        DCB     "$string",0
d162 2
a163 2
        DCB     "*NULL*",0
        ALIGN
d165 60
a224 40
        MOV     R0,#"'"
        BL      Neil_WriteC
      [ $reg > sp
        LDR     R0,[sp,#:INDEX:$reg * 4 - 4]    ; R13 is not stacked
      |
        LDR     R0,[sp,#:INDEX:$reg * 4]
      ]

        TEQ     R0, #0
        ADREQ   R0, %BT02

      [ "$max"=""
        BL      Neil_Write0
      |
        MOV     R2,#$max
        BL      Neil_Write0_R2max
      ]
        MOV     R0,#"'"
        BL      Neil_WriteC
        BL      Neil_NewLine
      [ hostvdu
        BL      Neil_TubeVdu
      ]
        Pull    "R0-R12"
        LDR     LR,[sp,#4]
        TEQP    LR,#0                   ; restore flags
        LDR     LR,[sp],#8              ; correct stack
      ]
        MEND

        MACRO
        Debug   $dbg,$string,$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
      [ debug:LAND:debug$dbg
        Push    "R0-R12,LR,PC"
      [ hostvdu
        BL      Neil_HostVdu
      ]
        ADR     R0, %FT00
        BL      Neil_Write0
        B       %FT01
d226 2
a227 2
        DCB     "$string",0
        ALIGN
d229 56
a284 51
      [ "$p1"<>""
        Dreg    $p1
      ]
      [ "$p2"<>""
        Dreg    $p2
      ]
      [ "$p3"<>""
        Dreg    $p3
      ]
      [ "$p4"<>""
        Dreg    $p4
      ]
      [ "$p5"<>""
        Dreg    $p5
      ]
      [ "$p6"<>""
        Dreg    $p6
      ]
      [ "$p7"<>""
        Dreg    $p7
      ]
      [ "$p8"<>""
        Dreg    $p8
      ]
      [ "$p9"<>""
        Dreg    $p9
      ]
      [ "$p10"<>""
        Dreg    $p10
      ]
        BL      Neil_NewLine
      [ hostvdu
        BL      Neil_TubeVdu
      ]
        Pull    "R0-R12"
        LDR     LR,[sp,#4]
        TEQP    LR,#0                   ; restore flags
        LDR     LR,[sp],#8              ; correct stack
      ]
        MEND

        MACRO
        Debuga  $dbg,$string,$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
      [ debug:LAND:debug$dbg
        Push    "R0-R12,LR,PC"
      [ hostvdu
        BL      Neil_HostVdu
      ]
        ADR     R0, %FT00
        BL      Neil_Write0
        B       %FT01
d286 2
a287 2
        DCB     "$string",0
        ALIGN
d289 69
a357 69
      [ "$p1"<>""
        Dreg    $p1
      ]
      [ "$p2"<>""
        Dreg    $p2
      ]
      [ "$p3"<>""
        Dreg    $p3
      ]
      [ "$p4"<>""
        Dreg    $p4
      ]
      [ "$p5"<>""
        Dreg    $p5
      ]
      [ "$p6"<>""
        Dreg    $p6
      ]
      [ "$p7"<>""
        Dreg    $p7
      ]
      [ "$p8"<>""
        Dreg    $p8
      ]
      [ "$p9"<>""
        Dreg    $p9
      ]
      [ "$p10"<>""
        Dreg    $p10
      ]
      [ hostvdu
        BL      Neil_TubeVdu
      ]
        Pull    "R0-R12"
        LDR     LR,[sp,#4]
        TEQP    LR,#0                   ; restore flags
        LDR     LR,[sp],#8              ; correct stack
      ]
        MEND

        MACRO
        Dreg    $reg
 [ debug
     [ "$reg":LEFT:1 = "#"
        LCLS    locn
locn    SETS    "$reg":RIGHT:(:LEN:"$reg"-1)
      [ :BASE:($locn) = sp
        LDR     R0,$locn + 15*4         ; allow for 15 stacked registers
      |
        LDR     R0,$locn
      ]
     |
      [ $reg > sp
        LDR     R0,[sp,#:INDEX:$reg * 4 - 4]    ; R13 is not stacked
      |
        LDR     R0,[sp,#:INDEX:$reg * 4]
      ]
     ]
        BL      Neil_ConvertHex8
 ] ; End debug
        MEND

        MACRO
$lab    DebugE  $dbg,$mess
      [ debug:LAND:debug$dbg
$lab    BVC     %ft0
        ADD     R0,R0,#4
        DebugS  $dbg,"$mess",R0
        SUB     R0,R0,#4
d359 2
a360 2
      ]
        MEND
d363 5
a367 5
        MACRO
$lab    DebugSIf $cond,$dbg,$string,$reg,$max
      [ debug:LAND:debug$dbg
$lab    B$cond  %FT99
        B       %FT98
d369 1
a369 1
        DebugS  $dbg,"$string","$reg","$max"
d371 2
a372 2
      ]
        MEND
d374 5
a378 5
        MACRO
$lab    DebugaIf  $cond,$dbg,$string,$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
      [ debug:LAND:debug$dbg
$lab    B$cond  %FT99
        B       %FT98
d380 9
a388 9
        Debuga  $dbg,"$string",$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
      ]
        MEND

        MACRO
$lab    DebugIf $cond,$dbg,$string,$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
      [ debug:LAND:debug$dbg
$lab    B$cond  %FT99
        B       %FT98
d390 1
a390 1
        Debug   $dbg,"$string",$p1,$p2,$p3,$p4,$p5,$p6,$p7,$p8,$p9,$p10
d392 2
a393 2
      ]
        MEND
d395 3
a397 3
        MACRO
        InsertNDRDebugRoutines
 [ debug
d399 2
a400 2
Neil_ConvertHex8                        ; prints number in R0
        Push    "R0,LR"
d402 10
a411 10
        MOV     R0, #" "
        BL      Neil_WriteC
        Pull    "R0"
        SUB     sp,sp,#12
        MOV     R1,sp
        MOV     R2,#9                   ; includes room for terminator
        SWI     XOS_ConvertHex8
        ADDVS   R0,R0,#4                ; print error message if there was one
        BL      Neil_Write0
        ADD     sp,sp,#12
d413 1
a413 1
        Pull    "PC"
d415 1
a415 1
      [ hostvdu
d417 1
a417 1
        Push    "LR"
d419 2
a420 2
        SWI     XHostFS_HostVdu
        SWI     XOS_WriteI+4              ; VDU 4 mode in case no HostVdu
d422 1
a422 1
        Pull    "PC",,^
d425 1
a425 1
        Push    "LR"
d427 1
a427 1
        SWI     XHostFS_TubeVdu
d429 2
a430 2
        Pull    "PC",,^
      ]
d433 4
a436 4
        Push    "R2,LR"
        MOV     R2,#&10000000   ; no limit on string length
        BL      Neil_Write0_R2max
        Pull    "R2,PC",,^
d439 7
a445 7
        Push    "R0,LR"
        MOV     R1,R0           ; R1 -> string, R2 = max length (unsigned)
01      LDRB    R0,[R1],#1
        CMP     R0,#32          ; terminate on any ctrl-char
        SUBCSS  R2,R2,#1
        BLCS    Neil_WriteC
        BCS     %BT01
d447 1
a447 1
        Pull    "R0,PC",,^
d450 10
a459 10
        Push    "R0,R1,LR"
        LDR     R1, Neil_FileHandle
        CMP     R1, #0          ; 0 => writec, -1 => none, >0 => file
      [ debug_module
        SWIEQ   XDebugIt_WriteC
      |
        SWIEQ   XOS_WriteC
      ]
        SWIGT   XOS_BPut
        Pull    "R0,R1,PC",,^
d462 25
a486 24
        Push    "R0-R2,LR"
        LDR     R14, Neil_FileHandle
        CMP     R14, #0
        MOVEQ   R0, #13                 ; only write CR if not to a file
        BLEQ    Neil_WriteC
        MOV     R0, #10
        BL      Neil_WriteC
      [ debug_flush
        LDR     R1, Neil_FileHandle     ; ensure bytes to the media after each line
        CMP     R1, #0
        BLE     %FT00
        MOV     R0, #"E"
        BL      Neil_WriteC
        MOV     R0, #"O"
        BL      Neil_WriteC
        MOV     R0, #"F"
        BL      Neil_WriteC
        MOV     R0, #255                ; ensure bytes to media
        SWI     XOS_Args
        MOV     R0, #0                  ; read PTR in R2
        SWI     XOS_Args
        SUB     R2,R2,#3
        MOV     R0, #1                  ; write PTR in R2
        SWI     XOS_Args
d488 2
a489 2
      ]
        Pull    "R0-R2,PC",,^
d492 44
a535 6
        Push    "R0-R1,LR"
        MOV     R0, #&8C                ; open for output
        SWI     XOS_Find                ; should warn you!
        MOVVS   R0,#-1                  ; -1 => no file debugging
        STR     R0, Neil_FileHandle
        Pull    "R0-R1,PC",,^
d538 8
a545 7
        Push    "R0-R1,LR"
        MOV     R0, #0                  ; close file
        LDR     R1, Neil_FileHandle
        CMP     R1, #0
        STRGT   R0, Neil_FileHandle     ; back to writec debugging
        SWIGT   XOS_Find
        Pull    "R0-R1,PC",,^
d547 1
a547 1
Neil_FileHandle DCD     0               ; default state => writec debugging
d549 1
a549 1
 ] ; End debug
d551 1
a551 1
        MEND
d553 1
a553 1
        OPT     OldOpt
d555 1
a555 1
        END
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@   Added new GBLS 'debug_file:' if set, then it is a file name, which is
opened, written to and closed for each call to Debug, DebugS, DebugE etc.
@
text
@d18 2
a19 2
OldOpt	SETA	{OPT}
	OPT	OptNoList+OptNoP1List
d22 1
a22 1
; ***	C h a n g e	L i s t	***
d25 28
a52 2
; Date	Name	Description
; ----	----	-----------
a53 34
; 25-Sep-89	NDR	First version written
;  3-May-90	NDR	File debugging added
; 30-Aug-90	NDR	Changed so if file can't be opened, no debugging is output
;  1-Nov-90	NDR	Neil_NewLine flushes data to file
;  6-Nov-90	NDR	Neil_NewLine also puts out end-of-file marker and resets PTR
;  2-Jan-91	NDR	Ensure Debug macro still works if V set on entry
;  3-Jan-91	NDR	Ensure debug_flush deals correctly when no debug output
;  4-Jan-91	NDR	Preserve R2 in Neil_Write0 and Neil_Newline
; 10-Apr-91	OSS	Changed all macros, particularly InsertNDRDebugRoutines, 
;			to not put any code in if the debug flag is not set. This
;			is because too many modules are messing things up and
;			are putting debugging code into the ROM!
; 10-Feb-93	BC	Restored OPT correctly
; 27-Apr-93	AMG	Changed the macros to use HostFS SWIs instead of OS_CLI.
;			This stops scratchspace corruption which was affecting
;			Colourtrans_SelectTable debug calls. Added logic flag
;			to allow assembling ColourTrans with the previous version
;			to raise an error.
; 14-Jul-93	SAH	Print *NULL* if DebugS is given a 0 pointer.
;  2-Aug-93	SAH	Increased number of parameters to 10
;  2-Aug-93	SAH	Added conditional versions (DebugIf, DebugaIf, DebugSIf)
; 13-Oct-93	AMG	Merge the two copies of NdrDebug together, and remove
;			the one from hdr - ATTENTION: NdrDebug lives in hdr2 !!!
; 20-Sep-94	SMC	Added support for DebugIt module (set debug_module to true, 
;			hostvdu should be false).
; 17-Apr-97	JRC	If debug_file is set, it is a file name which is opened, 
;			written to and closed in each call to Debug. Even better
;			than debug_flush!

	GBLL	debug
	GBLL	debug_flush
	GBLS	debug_file
	GBLL	true
	GBLL	false
d55 5
d66 5
a70 2
	GBLL	debug_noscratchspace
debug_noscratchspace	SETL	{TRUE}
d72 2
a73 2
	GBLL	debug_module
debug_module	SETL	{FALSE}
d75 1
a75 2
true		SETL	1=1
false		SETL	1=0
a76 2
debug_flush	SETL	false	; default - can be altered before InsertNDRDebugRoutines
debug_file	SETS	""	; default - can be altered before InsertNDRDebugRoutines
d79 1
a79 1
;	However, they do require the stack to be set up.
d81 2
a82 2
	MACRO
$lab	Debug_Open	$filename
d84 5
a88 6
	[	debug
	[	debug_file = ""
	Push	"R1, LR"
	ADR	R1, %FT00
	BL	Neil_OpenFile
	B	%FT01
d90 2
a91 2
	DCB	"$filename", 0
	ALIGN
d93 3
a95 6
	Pull	"R1, LR"
	|
	Debug	"", "------------------------------------------------------------"
	]
	]
	MEND
d97 2
a98 2
	MACRO
$lab	Debug_Close
d100 38
a137 52
	[ debug :LAND: debug_file = ""
	Push	"LR"
	BL	Neil_CloseFile
	Pull	"LR"
	]
	MEND

	MACRO
	Debug1	$dbg, $string
	[	debug$dbg
	Debug	$dbg, "$string"
	]
	MEND

	MACRO
	Debug2	$dbg, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug$dbg
	Debug	$dbg, "", $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	]
	MEND

	MACRO
	Debug2a	$dbg, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug$dbg
	Debuga	$dbg, "", $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	]
	MEND

	MACRO
	DebugS	$dbg, $string, $reg, $max
	[	debug:LAND:debug$dbg
	Push	"R0-R12, LR, PC"

	[	debug_file <> ""
	ADR	R1, %FT10
	BL	Neil_OpenFile
	B	%FT11
10
	DCB	"$debug_file", 0
	ALIGN
11
	]
	[	hostvdu
	BL	Neil_HostVdu
	]

	MOV	r0, pc
	BL	Neil_ConvertHex8

	ADR	R0, %FT00
	BL	Neil_Write0
	B	%FT01
d139 1
a139 1
	DCB	": $dbg, $string", 0
d141 2
a142 2
	DCB	"*NULL*", 0
	ALIGN
d144 40
a183 60
	MOV	R0, #" "
	BL	Neil_WriteC
	MOV	R0, #"'"
	BL	Neil_WriteC
	[	$reg > sp
	LDR	R0, [sp, #:INDEX:$reg * 4 - 4]	; R13 is not stacked
	|
	LDR	R0, [sp, #:INDEX:$reg * 4]
	]

	TEQ	R0, #0
	ADREQ	R0, %BT02

	[	"$max"=""
	BL	Neil_Write0
	|
	MOV	R2, #$max
	BL	Neil_Write0_R2max
	]
	MOV	R0, #"'"
	BL	Neil_WriteC
	BL	Neil_NewLine
	[	hostvdu
	BL	Neil_TubeVdu
	]

	[	debug_file <> ""
	BL	Neil_CloseFile
	]
	Pull	"R0-R12"
	LDR	LR, [sp, #4]
	TEQP	LR, #0			; restore flags
	LDR	LR, [sp], #8		; correct stack
	]
	MEND

	MACRO
	Debug	$dbg, $string, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug:LAND:debug$dbg
	Push	"R0-R12, LR, PC"

	[	debug_file <> ""
	ADR	R1, %FT10
	BL	Neil_OpenFile
	B	%FT11
10
	DCB	"$debug_file", 0
	ALIGN
11
	]
	[	hostvdu
	BL	Neil_HostVdu
	]

	MOV	r0, pc
	BL	Neil_ConvertHex8

	ADR	R0, %FT00
	BL	Neil_Write0
	B	%FT01
d185 2
a186 2
	DCB	": $dbg, $string", 0
	ALIGN
d188 51
a238 56
	[	"$p1"<>""
	Dreg	$p1
	]
	[	"$p2"<>""
	Dreg	$p2
	]
	[	"$p3"<>""
	Dreg	$p3
	]
	[	"$p4"<>""
	Dreg	$p4
	]
	[	"$p5"<>""
	Dreg	$p5
	]
	[	"$p6"<>""
	Dreg	$p6
	]
	[	"$p7"<>""
	Dreg	$p7
	]
	[	"$p8"<>""
	Dreg	$p8
	]
	[	"$p9"<>""
	Dreg	$p9
	]
	[	"$p10"<>""
	Dreg	$p10
	]
	BL	Neil_NewLine
	[	hostvdu
	BL	Neil_TubeVdu
	]

	[	debug_file <> ""
	BL	Neil_CloseFile
	]

	Pull	"R0-R12"
	LDR	LR, [sp, #4]
	TEQP	LR, #0			; restore flags
	LDR	LR, [sp], #8		; correct stack
	]
	MEND

	MACRO
	Debuga	$dbg, $string, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug:LAND:debug$dbg
	Push	"R0-R12, LR, PC"
	[	hostvdu
	BL	Neil_HostVdu
	]
	ADR	R0, %FT00
	BL	Neil_Write0
	B	%FT01
d240 2
a241 2
	DCB	"$string", 0
	ALIGN
d243 69
a311 69
	[	"$p1"<>""
	Dreg	$p1
	]
	[	"$p2"<>""
	Dreg	$p2
	]
	[	"$p3"<>""
	Dreg	$p3
	]
	[	"$p4"<>""
	Dreg	$p4
	]
	[	"$p5"<>""
	Dreg	$p5
	]
	[	"$p6"<>""
	Dreg	$p6
	]
	[	"$p7"<>""
	Dreg	$p7
	]
	[	"$p8"<>""
	Dreg	$p8
	]
	[	"$p9"<>""
	Dreg	$p9
	]
	[	"$p10"<>""
	Dreg	$p10
	]
	[	hostvdu
	BL	Neil_TubeVdu
	]
	Pull	"R0-R12"
	LDR	LR, [sp, #4]
	TEQP	LR, #0			; restore flags
	LDR	LR, [sp], #8		; correct stack
	]
	MEND

	MACRO
	Dreg	$reg
	[	debug
	[	"$reg":LEFT:1 = "#"
	LCLS	locn
locn	SETS	"$reg":RIGHT:(:LEN:"$reg"-1)
	[	:BASE:($locn) = sp
	LDR	R0, $locn + 15*4		; allow for 15 stacked registers
	|
	LDR	R0, $locn
	]
	|
	[	$reg > sp
	LDR	R0, [sp, #:INDEX:$reg * 4 - 4]	; R13 is not stacked
	|
	LDR	R0, [sp, #:INDEX:$reg * 4]
	]
	]
	BL	Neil_ConvertHex8
	]	; End debug
	MEND

	MACRO
$lab	DebugE	$dbg, $mess
	[	debug:LAND:debug$dbg
$lab	BVC	%ft0
	ADD	R0, R0, #4
	DebugS	$dbg, "$mess", R0
	SUB	R0, R0, #4
d313 2
a314 2
	]
	MEND
d317 5
a321 5
	MACRO
$lab	DebugSIf	$cond, $dbg, $string, $reg, $max
	[	debug:LAND:debug$dbg
$lab	B$cond	%FT99
	B	%FT98
d323 1
a323 1
	DebugS	$dbg, "$string", "$reg", "$max"
d325 2
a326 2
	]
	MEND
d328 5
a332 5
	MACRO
$lab	DebugaIf	$cond, $dbg, $string, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug:LAND:debug$dbg
$lab	B$cond	%FT99
	B	%FT98
d334 9
a342 9
	Debuga	$dbg, "$string", $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	]
	MEND

	MACRO
$lab	DebugIf	$cond, $dbg, $string, $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
	[	debug:LAND:debug$dbg
$lab	B$cond	%FT99
	B	%FT98
d344 1
a344 1
	Debug	$dbg, "$string", $p1, $p2, $p3, $p4, $p5, $p6, $p7, $p8, $p9, $p10
d346 2
a347 2
	]
	MEND
d349 3
a351 3
	MACRO
	InsertNDRDebugRoutines
	[	debug
d353 2
a354 2
Neil_ConvertHex8			; prints number in R0
	Push	"R0, LR"
d356 10
a365 10
	MOV	R0, #" "
	BL	Neil_WriteC
	Pull	"R0"
	SUB	sp, sp, #12
	MOV	R1, sp
	MOV	R2, #9			; includes room for terminator
	SWI	XOS_ConvertHex8
	ADDVS	R0, R0, #4		; print error message if there was one
	BL	Neil_Write0
	ADD	sp, sp, #12
d367 1
a367 1
	Pull	"PC"
d369 1
a369 1
	[	hostvdu
d371 1
a371 1
	Push	"LR"
d373 2
a374 2
	SWI	XHostFS_HostVdu
	SWI	XOS_WriteI+4		; VDU 4 mode in case no HostVdu
d376 1
a376 1
	Pull	"PC", , ^
d379 1
a379 1
	Push	"LR"
d381 1
a381 1
	SWI	XHostFS_TubeVdu
d383 2
a384 2
	Pull	"PC", , ^
	]
d387 4
a390 4
	Push	"R2, LR"
	MOV	R2, #&10000000	; no limit on string length
	BL	Neil_Write0_R2max
	Pull	"R2, PC", , ^
d393 7
a399 7
	Push	"R0, LR"
	MOV	R1, R0		; R1 -> string, R2 = max length (unsigned)
01	LDRB	R0, [R1], #1
	CMP	R0, #32		; terminate on any ctrl-char
	SUBCSS	R2, R2, #1
	BLCS	Neil_WriteC
	BCS	%BT01
d401 1
a401 1
	Pull	"R0, PC", , ^
d404 10
a413 10
	Push	"R0, R1, LR"
	LDR	R1, Neil_FileHandle
	CMP	R1, #0		; 0 => writec, -1 => none, >0 => file
	[	debug_module
	SWIEQ	XDebugIt_WriteC
	|
	SWIEQ	XOS_WriteC
	]
	SWIGT	XOS_BPut
	Pull	"R0, R1, PC", , ^
d416 24
a439 25
	ROUT
	Push	"R0-R2, LR"
	LDR	R14, Neil_FileHandle
	CMP	R14, #0
	MOVEQ	R0, #13		 ; only write CR if not to a file
	BLEQ	Neil_WriteC
	MOV	R0, #10
	BL	Neil_WriteC
	[	debug_flush
	LDR	R1, Neil_FileHandle	; ensure bytes to the media after each line
	CMP	R1, #0
	BLE	%FT00
	MOV	R0, #"E"
	BL	Neil_WriteC
	MOV	R0, #"O"
	BL	Neil_WriteC
	MOV	R0, #"F"
	BL	Neil_WriteC
	MOV	R0, #255		; ensure bytes to media
	SWI	XOS_Args
	MOV	R0, #0			; read PTR in R2
	SWI	XOS_Args
	SUB	R2, R2, #3
	MOV	R0, #1			; write PTR in R2
	SWI	XOS_Args
d441 2
a442 2
	]
	Pull	"R0-R2, PC", , ^
d445 6
a450 44
	ROUT
	Push	"R0-R2, LR"
	MOV	r0, #-1
	STR	r0, Neil_FileHandle	; -1 => no file debugging

	MOV	r0, #&C7		; open for update
	SWI	XOS_Find
	Pull	"R0-R2, PC", VS
	TEQ	r0, #0			; object exists?
	BEQ	%20			

	;File found---get the extent
	MOV	r1, r0			; file handle
	MOV	r0, #2			; read extent
	SWI	XOS_Args
	Pull	"R0-R2, PC", VS
	;r2 = extent

	;Set the pointer to the extent
	MOV	r0, #1			; write ptr
	;r1 still has file handle
	;r2 still has extent
	SWI	XOS_Args
	Pull	"R0-R2, PC", VS
	B	%30

20	;File not found---open a new one for output
	MOV	r0, #&87		; open for output
	SWI	XOS_Find
	Pull	"R0-R2, PC", VS
	;r0 = file handle
	;r1 -> file name

	;Make it a text file
	Push	"r0"
	MOV	r0, #18
	MOV	r2, #&FF
	ORR	r2, r2, #&F00		; file type text
	SWI	XOS_File
	Pull	"r1"
	Pull	"R0-R2, PC", VS

30	STR	r1, Neil_FileHandle
	Pull	"R0-R2, PC",, ^
d453 7
a459 8
	ROUT
	Push	"R0-R1, LR"
	MOV	R0, #0			; close file
	LDR	R1, Neil_FileHandle
	CMP	R1, #0
	STRGT	R0, Neil_FileHandle	; back to writec debugging
	SWIGT	XOS_Find
	Pull	"R0-R1, PC", , ^
d461 1
a461 1
Neil_FileHandle	DCD	0		; default state => writec debugging
d463 1
a463 1
	]	; End debug
d465 1
a465 1
	MEND
d467 1
a467 1
	OPT	OldOpt
d469 1
a469 1
	END
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

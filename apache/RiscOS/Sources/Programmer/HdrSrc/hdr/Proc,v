head	4.6;
access;
symbols
	HdrSrc-2_77:4.6
	HdrSrc-2_76:4.6
	HdrSrc-2_75:4.6
	HdrSrc-2_74:4.6
	HdrSrc-2_73:4.6
	HdrSrc-2_72:4.6
	HdrSrc-2_71:4.6
	HdrSrc-2_70:4.6
	HdrSrc-2_69:4.6
	HdrSrc-2_68:4.6
	HdrSrc-2_67:4.6
	HdrSrc-2_66:4.6
	HdrSrc-2_65:4.6
	HdrSrc-2_64:4.6
	HdrSrc-2_63:4.6
	HdrSrc-2_62:4.6
	HdrSrc-2_61:4.6
	HdrSrc-2_60:4.6
	HdrSrc-2_59:4.6
	HdrSrc-2_58:4.6
	HdrSrc-2_57:4.6
	HdrSrc-2_56:4.6
	HdrSrc-2_55:4.6
	HdrSrc-2_54:4.6
	HdrSrc-2_53:4.6
	HdrSrc-2_52:4.6
	HdrSrc-2_51:4.6
	HdrSrc-2_50:4.6
	HdrSrc-2_49:4.6
	HdrSrc-2_48:4.6
	HdrSrc-2_47:4.6
	HdrSrc-2_46-4_247_2_1:4.6.2.1
	XCompile:4.6.0.2
	XCompile_bp:4.6
	HdrSrc-2_46:4.6
	HdrSrc-2_45:4.6
	HdrSrc-2_44:4.6
	HdrSrc-2_43:4.6
	HdrSrc-2_42:4.6
	HdrSrc-2_41:4.6
	HdrSrc-2_40-1:4.6
	HdrSrc-2_40:4.6
	HdrSrc-2_39:4.6
	HdrSrc-2_38:4.6
	HdrSrc-2_37:4.6
	HdrSrc-2_36:4.6
	HdrSrc-2_35:4.6
	HdrSrc-2_34:4.6
	HdrSrc-2_33:4.6
	HdrSrc-2_32:4.6
	HdrSrc-2_31:4.6
	HdrSrc-2_30:4.6
	HdrSrc-2_29:4.6
	HdrSrc-2_28:4.6
	HdrSrc-2_27:4.6
	HdrSrc-2_26:4.6
	HdrSrc-2_25:4.6
	HdrSrc-2_24:4.6
	HdrSrc-2_23:4.6
	HdrSrc-2_22:4.6
	HdrSrc-2_21:4.6
	HdrSrc-2_20:4.6
	HdrSrc-2_19:4.6
	HdrSrc-2_18:4.6
	HdrSrc-2_17:4.6
	HdrSrc-2_16:4.6
	HdrSrc-2_15:4.6
	HdrSrc-2_14:4.6
	HdrSrc-2_13:4.6
	HdrSrc-2_12:4.6
	HdrSrc-2_11:4.6
	HdrSrc-2_10:4.6
	HdrSrc-2_09:4.6
	HdrSrc-2_08:4.6
	HdrSrc-2_07:4.6
	HdrSrc-2_06:4.6
	HdrSrc-2_05:4.6
	HdrSrc-2_04:4.6
	HdrSrc-2_03:4.6
	HdrSrc-2_02:4.6
	HdrSrc-2_01:4.6
	HdrSrc-2_00:4.6
	HdrSrc-1_99:4.6
	HdrSrc-1_98:4.6
	HdrSrc-1_97:4.6
	HdrSrc-1_96:4.6
	HdrSrc-1_95:4.6
	HdrSrc-1_94:4.6
	HdrSrc-1_93:4.6
	HdrSrc-1_92:4.6
	HdrSrc-1_91:4.6
	HdrSrc-1_90:4.6
	HdrSrc-1_89:4.6
	HdrSrc-1_88:4.6
	HdrSrc-1_87:4.6
	HdrSrc-1_86:4.6
	HdrSrc-1_85:4.6
	HdrSrc-1_84:4.6
	HdrSrc-1_83:4.6
	HdrSrc-1_82:4.6
	HdrSrc-1_81:4.6
	HdrSrc-1_80:4.6
	HdrSrc-1_79:4.6
	HdrSrc-1_78:4.6
	HdrSrc-1_77:4.6
	HdrSrc-1_76:4.6
	Cortex_merge:4.5.2.1
	HdrSrc-1_62-4_162_2_15:4.5.2.1
	HdrSrc-1_75:4.6
	HdrSrc-1_62-4_162_2_14:4.5.2.1
	HdrSrc-1_74:4.6
	HdrSrc-1_62-4_162_2_13:4.5.2.1
	HdrSrc-1_62-4_162_2_12:4.5.2.1
	HdrSrc-1_73:4.6
	HdrSrc-1_72:4.6
	HdrSrc-1_62-4_162_2_11:4.5.2.1
	HdrSrc-1_62-4_162_2_10:4.5.2.1
	HdrSrc-1_71:4.6
	HdrSrc-1_70:4.5
	HdrSrc-1_69:4.5
	Cortex_bp:4.5
	HdrSrc-1_62-4_162_2_9:4.5
	HdrSrc-1_62-4_162_2_8:4.5
	HdrSrc-1_68:4.5
	HdrSrc-1_62-4_162_2_7:4.5
	HdrSrc-1_62-4_162_2_6:4.5
	HdrSrc-1_62-4_162_2_5:4.5
	HdrSrc-1_62-4_162_2_4:4.5
	HdrSrc-1_67:4.5
	HdrSrc-1_66:4.5
	HdrSrc-1_62-4_162_2_3:4.5
	HdrSrc-1_65:4.5
	HdrSrc-1_64:4.5
	HdrSrc-1_63:4.5
	HdrSrc-1_62-4_162_2_2:4.5
	HdrSrc-1_62-4_162_2_1:4.5
	Cortex:4.5.0.2
	HdrSrc-1_62:4.5
	HdrSrc-1_61:4.5
	HdrSrc-1_60:4.5
	HdrSrc-1_59:4.5
	HdrSrc-1_58:4.5
	HdrSrc-1_57:4.5
	HdrSrc-1_56:4.5
	HdrSrc-1_55:4.5
	HdrSrc-1_54:4.5
	HdrSrc-1_53:4.5
	HdrSrc-1_52:4.5
	HdrSrc-1_51:4.5
	HdrSrc-1_50:4.5
	HdrSrc-1_49:4.5
	HdrSrc-1_48:4.5
	HdrSrc-1_47:4.5
	RO_5_07:4.5
	HdrSrc-1_46:4.5
	HdrSrc-1_45:4.5
	HdrSrc-1_44:4.5
	HdrSrc-1_43:4.5
	HdrSrc-1_42:4.5
	HdrSrc-1_41:4.5
	HdrSrc-1_40:4.5
	HdrSrc-1_39:4.5
	HdrSrc-1_38:4.5
	HdrSrc-1_37:4.5
	HdrSrc-1_36:4.5
	HdrSrc-1_35:4.5
	HdrSrc-1_34:4.5
	HdrSrc-1_33:4.5
	HdrSrc-1_32:4.5
	HdrSrc-1_31:4.5
	HdrSrc-1_30:4.5
	HdrSrc-1_29:4.5
	HdrSrc-1_28:4.5
	HdrSrc-1_27:4.5
	HdrSrc-1_26:4.5
	HdrSrc-1_25:4.5
	HdrSrc-1_24:4.5
	HdrSrc-1_23:4.5
	HdrSrc-1_22:4.5
	HdrSrc-1_21:4.5
	HdrSrc-1_20:4.5
	HdrSrc-1_19:4.5
	HdrSrc-1_18:4.5
	HdrSrc-1_17:4.5
	HdrSrc-1_16:4.5
	HdrSrc-1_15:4.5
	HdrSrc-1_14:4.4
	HdrSrc-1_13:4.4
	HdrSrc-1_12:4.4
	HdrSrc-1_11:4.4
	HdrSrc-0_71-4_72_2_2:4.3
	HdrSrc-1_10:4.4
	HdrSrc-1_09:4.4
	HdrSrc-1_08:4.4
	HdrSrc-1_07:4.4
	HdrSrc-1_06:4.4
	HdrSrc-1_05:4.4
	dellis_autobuild_BaseSW:4.4
	HdrSrc-1_04:4.4
	HdrSrc-1_03:4.4
	HdrSrc-1_02:4.4
	HdrSrc-1_00:4.4
	HdrSrc-0_99:4.4
	HdrSrc-0_71-4_72_2_1:4.3
	Lazarus_Z11:4.3.0.2
	HdrSrc-0_98:4.4
	HdrSrc-0_97:4.4
	HdrSrc-0_95:4.4
	HdrSrc-0_94:4.4
	HdrSrc-0_93:4.4
	HdrSrc-0_92:4.4
	HdrSrc-0_91:4.4
	HdrSrc-0_90:4.4
	HdrSrc-0_89:4.4
	HdrSrc-0_88:4.4
	HdrSrc-0_87:4.4
	HdrSrc-0_86:4.4
	HdrSrc-0_85:4.4
	HdrSrc-0_84:4.4
	HdrSrc-0_83:4.4
	HdrSrc-0_82:4.4
	HdrSrc-0_81:4.4
	HdrSrc-0_80:4.4
	HdrSrc-0_79:4.4
	HdrSrc-0_78:4.3
	HdrSrc-0_77:4.3
	sbrodie_sedwards_16Mar2000:4.3
	HdrSrc-0_76:4.3
	HdrSrc-0_75:4.3
	HdrSrc-0_74:4.3
	HdrSrc-0_73:4.3
	HdrSrc-0_72:4.3
	HdrSrc-0_71:4.3
	HdrSrc-0_70:4.3
	HdrSrc-0_69:4.3
	HdrSrc-0_68:4.3
	HdrSrc-0_67:4.3
	HdrSrc-0_66:4.3
	HdrSrc-0_65:4.2
	HdrSrc-0_64:4.2
	kbracey_32bit_merge:4.1.10.3
	HdrSrc-0_63:4.2
	HdrSrc-0_57-4_58_2_9:4.1.10.3
	HdrSrc-0_57-4_58_2_8:4.1.10.3
	HdrSrc-0_57-4_58_2_7:4.1.10.3
	HdrSrc-0_57-4_58_2_6:4.1.10.3
	HdrSrc-0_57-4_58_2_5:4.1.10.2
	HdrSrc-0_57-4_58_2_4:4.1.10.2
	HdrSrc-0_57-4_58_2_3:4.1.10.2
	HdrSrc-0_62:4.1
	HdrSrc-0_61:4.1
	HdrSrc-0_60:4.1
	HdrSrc-0_57-4_58_2_2:4.1.10.2
	HdrSrc-0_59:4.1
	HdrSrc-0_58:4.1
	HdrSrc-0_57-4_58_2_1:4.1.10.1
	kbracey_32bit:4.1.0.10
	HdrSrc-0_57:4.1
	HdrSrc-0_56:4.1
	HdrSrc-0_55:4.1
	HdrSrc-0_54:4.1
	HdrSrc-0_53:4.1
	HdrSrc-0_52:4.1
	HdrSrc-0_51:4.1
	HdrSrc-0_50:4.1
	HdrSrc-0_49:4.1
	HdrSrc-0_48:4.1
	HdrSrc-0_47:4.1
	HdrSrc-0_46:4.1
	HdrSrc-0_45:4.1
	HdrSrc-0_44:4.1
	HdrSrc-0_43:4.1
	HdrSrc-0_42:4.1
	dcotton_autobuild_BaseSW:4.5
	HdrSrc-0_41:4.1
	HdrSrc-0_39:4.1
	HdrSrc-0_38:4.1
	HdrSrc-0_37:4.1
	HdrSrc-0_36:4.1
	HdrSrc-0_35:4.1
	HdrSrc-0_34:4.1
	HdrSrc-0_33:4.1
	HdrSrc-0_32:4.1
	HdrSrc-0_31:4.1
	Ursula_RiscPC_merge:4.1
	HdrSrc-0_30:4.1
	HdrSrc-0_29:4.1
	Ursula_merge:4.1
	HdrSrc-0_28:4.1
	HdrSrc-0_27:4.1
	HdrSrc-0_26:4.1
	HdrSrc-0_25:4.1
	HdrSrc-0_24:4.1
	HdrSrc-0_23:4.1
	HdrSrc-0_22:4.1
	HdrSrc-0_21:4.1
	HdrSrc-0_20:4.1
	HdrSrc-0_19:4.1
	nturton_HdrSrc-0_11:4.1
	HdrSrc-0_18:4.1
	HdrSrc-0_17:4.1
	HdrSrc-0_16:4.1
	HdrSrc-0_15:4.1
	HdrSrc-0_14:4.1
	HdrSrc-0_13:4.1
	HdrSrc-0_12:4.1
	HdrSrc-0_11:4.1
	HdrSrc-0_10:4.1
	HdrSrc-0_09:4.1
	HdrSrc-0_08:4.1
	HdrSrc-0_07:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	HdrSrc-0_06:4.1
	HdrSrc-0_05:4.1
	HdrSrc-0_04:4.1
	HdrSrc-0_03:4.1
	HdrSrc-0_02:4.1
	HdrSrc-0_01:4.1
	nicke_HdrSrc_21_9_98:4.1
	nicke_HdrSrc_21_8_98:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	afrost_NC2_Generic:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2009.07.03.14.05.41;	author srevill;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2001.01.25.12.31.32;	author bavison;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	2000.04.04.10.04.00;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.12.14.16.30.19;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.11.26.14.32.24;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.21.24;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.10.1;
next	;

4.6.2.1
date	2014.09.24.20.51.11;	author bavison;	state Exp;
branches;
next	;
commitid	FLu4L8VxkYPcNDRx;

4.5.2.1
date	2009.07.07.21.32.38;	author jlee;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.21.24;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.36.57;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.36.13;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.32.37;	author nturton;	state Exp;
branches;
next	;

4.1.10.1
date	99.11.05.13.17.06;	author kbracey;	state Exp;
branches;
next	4.1.10.2;

4.1.10.2
date	99.11.10.13.33.03;	author kbracey;	state Exp;
branches;
next	4.1.10.3;

4.1.10.3
date	99.11.23.17.26.33;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.6
log
@  Added FRAMLDR/FRAMSTR macros
Detail:
  These macros allow easy access to registers pushed on the stack during the Entry macro.
This is simpler than the previous method of "LDR     r1, [sp, #Proc_LocalStack + 1*4]" because the new macros will calculate the correct offset even if non-continuous regs are used, and will also trap attempts to access regs that weren't pushed onto the stack.

  The FRAMSTR macro can be used to alter the values that will be returned on EXIT.
Admin:
  Tested by looking at produced code in Zap
Notes:
  Changes by James Lampard.

Version 1.71. Tagged as 'HdrSrc-1_71'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

       SUBT     Useful procedure entry/exit macros => &.Hdr.Proc

OldOpt SETA     {OPT}
       OPT      OptNoList+OptNoP1List

       GBLS     Proc_RegList    ; Which registers to preserve
       GBLA     Proc_LocalStack ; And any ADJSP on entry/exit for local vars
       GBLL     Proc_SavedCPSR  ; CPSR was preserved
       GBLA     Proc_RegOffset  ; Offset of first register on stack

       GBLL     Proc_Debug      ; Whether to dump procedure name in image
Proc_Debug SETL {FALSE}

       GBLS     Proc_GetMachine
 [ :LNOT: :DEF: Included_Hdr_Machine_Machine
Proc_GetMachine SETS "GET Hdr:Machine.<Machine>"
 |
Proc_GetMachine SETS ""
 ]
       $Proc_GetMachine

       GBLS     Proc_GetCPU26
 [ :LNOT: :DEF: Included_Hdr_CPU_Generic26
Proc_GetCPU26 SETS "GET Hdr:CPU.Generic26"
 |
Proc_GetCPU26 SETS ""
 ]
        $Proc_GetCPU26

       GBLS     Proc_GetCPU32
 [ :LNOT: :DEF: Included_Hdr_CPU_Generic32
Proc_GetCPU32 SETS "GET Hdr:CPU.Generic32"
 |
Proc_GetCPU32 SETS ""
 ]
        $Proc_GetCPU32



; *****************************************************************************
; *** Keep a note of local stack and register use at the routine entry      ***
; *** point so that an exit may be effected anywhere in the body without    ***
; *** remembering how many (and which) registers to destack and ADJSP.      ***
; *** Also ensures that the code entry label is word-aligned.               ***
; *****************************************************************************
        MACRO
$label  ENTRY   $reglist,$framesize
        ALIGN
Proc_RegList SETS "$reglist"
 [ "$framesize" = ""
Proc_LocalStack SETA 0
 |
Proc_LocalStack SETA $framesize
 ]
Proc_SavedCPSR SETL {FALSE}
Proc_RegOffset SETA Proc_LocalStack
 [ "$label" <> ""
  [ Proc_Debug
        B       $label
        DCB     "$label", 0
        ALIGN
  ]
$label  ROUT
 ]
 [ "$Proc_RegList" = ""
        Push    lr
 |
        Push    "$Proc_RegList, lr"
 ]
 [ Proc_LocalStack <> 0
        SUB     sp, sp, #Proc_LocalStack
 ]
        MEND

; *****************************************************************************
; *** Keep a note of local stack and register use at the routine entry      ***
; *** point so that an exit may be effected anywhere in the body without    ***
; *** remembering how many (and which) registers to destack and ADJSP.      ***
; *** Also ensures that the code entry label is word-aligned.               ***
; *** This is a copy of the above macro for objasm use.                     ***
; *****************************************************************************
        MACRO
$label  Entry   $reglist,$framesize
        ALIGN
Proc_RegList SETS "$reglist"
 [ "$framesize" = ""
Proc_LocalStack SETA 0
 |
Proc_LocalStack SETA $framesize
 ]
Proc_SavedCPSR SETL {FALSE}
Proc_RegOffset SETA Proc_LocalStack
 [ "$label" <> ""
  [ Proc_Debug
        B       $label
        DCB     "$label", 0
        ALIGN
  ]
$label  ROUT
 ]
 [ "$Proc_RegList" = ""
        STR     lr, [sp, #-4]!
 |
        Push    "$Proc_RegList, lr"
 ]
 [ Proc_LocalStack <> 0
        SUB     sp, sp, #Proc_LocalStack
 ]
        MEND

; *****************************************************************************
; *** Keep a note of local stack and register use at the routine entry      ***
; *** point so that an exit may be effected anywhere in the body without    ***
; *** remembering how many (and which) registers to destack and ADJSP.      ***
; *** Also ensures that the code entry label is word-aligned.               ***
; *** You must use this macro if you want to use EXITS in 32-bit mode.      ***
; *****************************************************************************
        MACRO
$label  EntryS  $reglist,$framesize
        ALIGN
 [ No32bitCode
$label  Entry   "$reglist",$framesize
 |
Proc_RegList SETS "$reglist"
 [ "$framesize" = ""
Proc_LocalStack SETA 0
 |
Proc_LocalStack SETA $framesize
 ]
Proc_SavedCPSR SETL {TRUE}
Proc_RegOffset SETA Proc_LocalStack + 4
 [ "$label" <> ""
  [ Proc_Debug
        B       $label
        DCB     "$label", 0
        ALIGN
  ]
$label  ROUT
 ]
 [ "$Proc_RegList" = ""
        STR     lr, [sp, #-4]!
 |
        Push    "$Proc_RegList, lr"
 ]
        mymrs   AL, lr, CPSR
        STR     lr, [sp, #-4]!
 [ Proc_LocalStack <> 0
        SUB     sp, sp, #Proc_LocalStack
 ]
 ]
        MEND


; *****************************************************************************
; *** Another entry point so we can use the same routine body. NOROUT also  ***
; *** Stacks the same registers as does the corresponding ENTRY macro       ***
; *****************************************************************************
        MACRO
$label  ALTENTRY
        ALIGN
 [ "$label" <> ""
  [ Proc_Debug
        B       $label
        DCB     "$label", 0
        ALIGN
  ]
$label ; NOROUT
 ]
 [ "$Proc_RegList" = ""
        STR     lr, [sp, #-4]!
 |
        Push    "$Proc_RegList, lr"
 ]
 [ Proc_SavedCPSR
        mymrs   AL, lr, CPSR
        STR     lr, [sp, #-4]!
 ]
 [ Proc_LocalStack <> 0
        SUB     sp, sp, #Proc_LocalStack
 ]
        MEND

; *****************************************************************************
; *** Exit procedure, restore stack and saved registers to values on entry  ***
; *****************************************************************************
        MACRO
$label  EXIT    $cond
$label
 [ Proc_SavedCPSR
        ADD$cond sp, sp, #Proc_LocalStack + 4
 |
 [ Proc_LocalStack <> 0
        ADD$cond sp, sp, #Proc_LocalStack
 ]
 ]
 [ "$Proc_RegList" = ""
        LDR$cond pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc",$cond
 ]
        MEND

; *****************************************************************************
; *** Exit procedure : restore stack and saved registers + psr to values on ***
; *** entry. No longer copes with 3um ARM bug fix (world is 2um'ised)       ***
; *****************************************************************************
        MACRO
$label  EXITS   $cond,$fields
$label
 [ Proc_SavedCPSR
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000000 :EOR: Cond_$cond + ((%FT01 - (. + 8))/4)
  ]
 [ Proc_LocalStack <> 0
        ADD     sp, sp, #Proc_LocalStack
 ]
        LDR     lr, [sp], #4
 [ "$fields"=""
        mymsr  ,CPSR_f, lr
 |
        mymsr  ,CPSR_$fields, lr
 ]
 [ "$Proc_RegList" = ""
        LDR     pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc"
 ]
01
 |
 ; 26-bit version
 [ No26bitCode
        ! 1, "EXITS without EntryS"
 ]
 [ Proc_LocalStack <> 0
        ADD$cond sp, sp, #Proc_LocalStack
 ]
 [ "$Proc_RegList" = ""
        Pull    pc,$cond,^
 |
        Pull    "$Proc_RegList, pc",$cond,^
 ]
 ]
        MEND

; *****************************************************************************
; *** Exit procedure : restore stack and saved registers + psr (except V)   ***
; *** to values on entry. Return with V unaltered from current state.       ***
; *****************************************************************************
        MACRO
$label  EXITV   $fields
$label
 [ Proc_LocalStack <> 0
        ADD     sp, sp, #Proc_LocalStack
 ]
 [ Proc_SavedCPSR
        LDR     lr, [sp], #4
        BICVC   lr, lr, #V_bit
        ORRVS   lr, lr, #V_bit
 [ "$fields"=""
        mymsr  ,CPSR_f, lr
 |
        mymsr  ,CPSR_$fields, lr
 ]
 [ "$Proc_RegList" = ""
        LDR     pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc"
 ]
 |
 [ No26bitCode
        ! 1, "EXITV without EntryS"
 ]
 [ "$Proc_RegList" = ""
        LDR     lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr"
 ]
        BICVCS  pc, lr, #V_bit
        ORRVSS  pc, lr, #V_bit
 ]
        MEND

; *****************************************************************************
; *** Exit procedure : restore stack and saved registers + psr (except V)   ***
; *** to values on entry. Return with V clear.                              ***
; *****************************************************************************
        MACRO
$label  EXITVC  $fields
$label
 [ Proc_LocalStack <> 0
        ADD     sp, sp, #Proc_LocalStack
 ]
 [ Proc_SavedCPSR
        LDR     lr, [sp], #4
        BIC     lr, lr, #V_bit
 [ "$fields"=""
        mymsr  ,CPSR_f, lr
 |
        mymsr  ,CPSR_$fields, lr
 ]
 [ "$Proc_RegList" = ""
        LDR     pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc"
 ]
 |
 [ No26bitCode
        ! 1, "EXITV without EntryS"
 ]
 [ "$Proc_RegList" = ""
        LDR     lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr"
 ]
        BICS    pc, lr, #V_bit
 ]
        MEND

; *****************************************************************************
; *** Exit procedure : restore stack and saved registers + psr (except V)   ***
; *** to values on entry. Return with V set.                                ***
; *****************************************************************************
        MACRO
$label  EXITVS  $fields
$label
 [ Proc_LocalStack <> 0
        ADD     sp, sp, #Proc_LocalStack
 ]
 [ Proc_SavedCPSR
        LDR     lr, [sp], #4
        ORR     lr, lr, #V_bit
 [ "$fields"=""
        mymsr  ,CPSR_f, lr
 |
        mymsr  ,CPSR_$fields, lr
 ]
 [ "$Proc_RegList" = ""
        LDR     pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc"
 ]
 |
 [ No26bitCode
        ! 1, "EXITV without EntryS"
 ]
 [ "$Proc_RegList" = ""
        LDR     lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr"
 ]
        ORRS    pc, lr, #V_bit
 ]
        MEND

; *****************************************************************************
; *** Restore stack and saved registers, lr to values on entry to procedure ***
; *****************************************************************************
        MACRO
$label  PullEnv $cond
$label
 [ Proc_RegOffset <> 0
        ADD$cond sp, sp, #Proc_RegOffset
 ]
 [ "$Proc_RegList" = ""
        LDR$cond lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr", $cond
 ]
        MEND

; *****************************************************************************
; *** Restore stack and saved registers, lr and CPSR to values on entry to  ***
; *** procedure                                                             ***
; *****************************************************************************
        MACRO
$label  PullEnvS $cond,$fields
$label
 [ Proc_SavedCPSR
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000000 :EOR: Cond_$cond + ((%FT01 - (. + 8))/4)
  ]
 [ Proc_LocalStack <> 0
        ADD     sp, sp, #Proc_LocalStack
 ]
        LDR     lr, [sp], #4
 [ "$fields"=""
        mymsr  ,CPSR_f, lr
 |
        mymsr  ,CPSR_$fields, lr
 ]
 [ "$Proc_RegList" = ""
        LDR     lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr"
 ]
01
 |
; 26-bit form
 [ Proc_LocalStack <> 0
        ADD$cond sp, sp, #Proc_LocalStack
 ]
 [ "$Proc_RegList" = ""
        LDR$cond lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr", $cond
 ]
 ]
        MEND

; *****************************************************************************


; *****************************************************************************
; *** FRAMLDR/FRAMSTR macros                                                ***
; *** That let you access the register values stacked on Entry              ***
; *** to replace LDR     r1, [sp, #Proc_LocalStack + 1*4]                   ***
; ***                                                                       ***
; *** The new macros allow non-continuous regs to be used, and will generate***
; *** an error if you try to access a register not stored on the stack      ***
; ***                                                                       ***
; *** FRAMLDR r0         load r0 stored on stack frame by Entry macro       ***
; *** FRAMLDR r5,CS      load r5 from stack frame if CS                     ***
; *** FRAMLDR r0,,r8     load r8 on stack frame into r0                     ***
; *** FRAMLDR r0,HI,r10  load r10 on stack frame into r0 if HI              ***
; ***                                                                       ***
; *** A particularly useful way of using this macro is:                     ***
; *** FRAMSTR r8,,r0     change r0 value that will be restored on EXIT      ***
; *** ...more code                                                          ***
; *** EXIT                                                                  ***
; *****************************************************************************

        GBLA Fram_SpecRegOffset  ;offset to load/store particular reg
        GBLS Fram_RegStr
        GBLS Fram_CopyRegs
        GBLS Fram_LowRegStr

        MACRO
        FRAMSPL $origvar,$newvar,$sep

$newvar SETS ""
        WHILE (($origvar):CC:" ":LEFT:1 <> "$sep"):LAND:($origvar >"")
$newvar SETS $newvar:CC:($origvar:LEFT:1)
 [ ($origvar >"")
$origvar SETS $origvar:RIGHT:(:LEN:$origvar-1)
 ]

        WEND
        ;skip remaining seperator
 [ ($origvar >"")
$origvar SETS $origvar:RIGHT:(:LEN:$origvar-1)
 ]

        MEND

        MACRO
        FRAMCOM $dstreg,$framereg
        LCLA actframe
        LCLA counter

actframe SETA $dstreg
 [ "$framereg" <>""
actframe SETA $framereg
 ]

        LCLA regmask
Fram_CopyRegs SETS Proc_RegList
        WHILE Fram_CopyRegs > ""

        FRAMSPL "Fram_CopyRegs","Fram_RegStr",","

        ;regno =r0-r8 or a single reg r5
        LCLA lowreg
        LCLA highreg

        FRAMSPL "Fram_RegStr","Fram_LowRegStr","-"
lowreg  SETA $Fram_LowRegStr
 [ Fram_RegStr =""
highreg SETA lowreg
 |
highreg SETA $Fram_RegStr
 ]

        ;set bits between lowreg and highreg in our mask
        WHILE lowreg <=highreg
regmask SETA regmask:OR:(1:SHL:lowreg)
lowreg  SETA lowreg +1
        WEND

        WEND

        ;calculate Fram_SpecRegOffset using regmask
Fram_SpecRegOffset SETA 0
        LCLA counter

        WHILE counter <actframe
 [ (regmask:AND:(1:SHL:counter)) >0
Fram_SpecRegOffset SETA Fram_SpecRegOffset+4
 ]
counter SETA counter +1
        WEND

 [ (regmask:AND:(1:SHL:counter)) =0
        LCLS tempstr
  [ actframe >9
actframe SETA actframe -10
tempstr SETS "1"
  ]
        !       1,"r$tempstr":CC:("$actframe":RIGHT:1):CC:" not in frame!"
 ]

        MEND

        MACRO
$label  FRAMLDR $dstreg,$cond,$framereg
$label  FRAMCOM $dstreg,$framereg
        LDR$cond $dstreg,[sp ,#Proc_RegOffset +Fram_SpecRegOffset]
        MEND

        MACRO
$label  FRAMSTR $dstreg,$cond,$framereg
$label  FRAMCOM $dstreg,$framereg
        STR$cond $dstreg,[sp ,#Proc_RegOffset +Fram_SpecRegOffset]
        MEND
; *****************************************************************************

        OPT     OldOpt
        END
@


4.6.2.1
log
@  Cross-compile version of HdrSrc
Detail:
  Mostly a question of changing directory separators and removing reliance
  upon path variables and system variable expansion. One day, when all
  components use the shared makefiles (or at least use the necessary -pd and
  -i switches to objasm), we will be able to switch over to using this
  version for all builds. In the meantime, I have created a new branch for
  the HdrSrc component, called XCompile, to store these changes. The downside
  is the fact that we'll now have to maintain unrelated changes on both
  branches until they can be merged.
Admin:
  Tested by cross-assembling the BASIC module.

Version 2.46, 4.247.2.1. Tagged as 'HdrSrc-2_46-4_247_2_1'
@
text
@d31 1
a31 1
Proc_GetMachine SETS "GET Machine/$Machine"
d39 1
a39 1
Proc_GetCPU26 SETS "GET CPU/Generic26"
d47 1
a47 1
Proc_GetCPU32 SETS "GET CPU/Generic32"
@


4.5
log
@  Made Hdr:Proc compatible with OSLib assembler headers.
Detail:
  OSLib defines "True" and "False" as integer variables, but Hdr:Symbols
  defines them as logical ones. Hdr:Proc assigned "True" and "False" to
  logical variables, so there was no way that it could be used with any
  component that used any OSLib or even DefMod-generated headers. Hdr:Proc
  now uses the unambiguous "{TRUE}" and "{FALSE}" symbols.
Admin:
  Required by SoundFileExtMSADPCM 0.06.

Version 1.15. Tagged as 'HdrSrc-1_15'
@
text
@d429 114
@


4.5.2.1
log
@Add FRAMLDR/FRAMSTR to Cortex branch of HdrSrc
Detail:
  hdr/Proc - updated to version in main branch, containing the FRAMLDR/FRAMSTR macros required for compiling the latest version of the Filer
Admin:
  Tested on rev C2 beagleboard


Version 1.62, 4.162.2.10. Tagged as 'HdrSrc-1_62-4_162_2_10'
@
text
@a428 114

; *****************************************************************************
; *** FRAMLDR/FRAMSTR macros                                                ***
; *** That let you access the register values stacked on Entry              ***
; *** to replace LDR     r1, [sp, #Proc_LocalStack + 1*4]                   ***
; ***                                                                       ***
; *** The new macros allow non-continuous regs to be used, and will generate***
; *** an error if you try to access a register not stored on the stack      ***
; ***                                                                       ***
; *** FRAMLDR r0         load r0 stored on stack frame by Entry macro       ***
; *** FRAMLDR r5,CS      load r5 from stack frame if CS                     ***
; *** FRAMLDR r0,,r8     load r8 on stack frame into r0                     ***
; *** FRAMLDR r0,HI,r10  load r10 on stack frame into r0 if HI              ***
; ***                                                                       ***
; *** A particularly useful way of using this macro is:                     ***
; *** FRAMSTR r8,,r0     change r0 value that will be restored on EXIT      ***
; *** ...more code                                                          ***
; *** EXIT                                                                  ***
; *****************************************************************************

        GBLA Fram_SpecRegOffset  ;offset to load/store particular reg
        GBLS Fram_RegStr
        GBLS Fram_CopyRegs
        GBLS Fram_LowRegStr

        MACRO
        FRAMSPL $origvar,$newvar,$sep

$newvar SETS ""
        WHILE (($origvar):CC:" ":LEFT:1 <> "$sep"):LAND:($origvar >"")
$newvar SETS $newvar:CC:($origvar:LEFT:1)
 [ ($origvar >"")
$origvar SETS $origvar:RIGHT:(:LEN:$origvar-1)
 ]

        WEND
        ;skip remaining seperator
 [ ($origvar >"")
$origvar SETS $origvar:RIGHT:(:LEN:$origvar-1)
 ]

        MEND

        MACRO
        FRAMCOM $dstreg,$framereg
        LCLA actframe
        LCLA counter

actframe SETA $dstreg
 [ "$framereg" <>""
actframe SETA $framereg
 ]

        LCLA regmask
Fram_CopyRegs SETS Proc_RegList
        WHILE Fram_CopyRegs > ""

        FRAMSPL "Fram_CopyRegs","Fram_RegStr",","

        ;regno =r0-r8 or a single reg r5
        LCLA lowreg
        LCLA highreg

        FRAMSPL "Fram_RegStr","Fram_LowRegStr","-"
lowreg  SETA $Fram_LowRegStr
 [ Fram_RegStr =""
highreg SETA lowreg
 |
highreg SETA $Fram_RegStr
 ]

        ;set bits between lowreg and highreg in our mask
        WHILE lowreg <=highreg
regmask SETA regmask:OR:(1:SHL:lowreg)
lowreg  SETA lowreg +1
        WEND

        WEND

        ;calculate Fram_SpecRegOffset using regmask
Fram_SpecRegOffset SETA 0
        LCLA counter

        WHILE counter <actframe
 [ (regmask:AND:(1:SHL:counter)) >0
Fram_SpecRegOffset SETA Fram_SpecRegOffset+4
 ]
counter SETA counter +1
        WEND

 [ (regmask:AND:(1:SHL:counter)) =0
        LCLS tempstr
  [ actframe >9
actframe SETA actframe -10
tempstr SETS "1"
  ]
        !       1,"r$tempstr":CC:("$actframe":RIGHT:1):CC:" not in frame!"
 ]

        MEND

        MACRO
$label  FRAMLDR $dstreg,$cond,$framereg
$label  FRAMCOM $dstreg,$framereg
        LDR$cond $dstreg,[sp ,#Proc_RegOffset +Fram_SpecRegOffset]
        MEND

        MACRO
$label  FRAMSTR $dstreg,$cond,$framereg
$label  FRAMCOM $dstreg,$framereg
        STR$cond $dstreg,[sp ,#Proc_RegOffset +Fram_SpecRegOffset]
        MEND
; *****************************************************************************

@


4.4
log
@More 32-bit tweaks. Some assembler macros extended to accept condition codes
and PSR flag subset specifiers.
CPU.FPA header file added.

Version 0.79. Tagged as 'HdrSrc-0_79'
@
text
@d27 1
a27 1
Proc_Debug SETL False
d70 1
a70 1
Proc_SavedCPSR SETL False
d106 1
a106 1
Proc_SavedCPSR SETL False
d145 1
a145 1
Proc_SavedCPSR SETL True
@


4.3
log
@  Added some missing quotes on the 26-bit version of EntryS
Detail:
  This stops the errors occurring in 26-bit builds when the EntryS
    macro is invoked without quotes around the register list.
Admin:
  Fixes problems with the latest ARM module not building.


Version 0.66. Tagged as 'HdrSrc-0_66'
@
text
@d223 1
a223 1
$label  EXITS   $cond
d234 5
a238 1
        mymsr  , CPSR_cf, lr
d266 1
a266 1
$label  EXITV
d275 5
a279 1
        mymsr   AL, CPSR_cf, lr
d304 1
a304 1
$label  EXITVC
d312 5
a316 1
        mymsr   AL, CPSR_cf, lr
d340 1
a340 1
$label  EXITVS
d348 5
a352 1
        mymsr   AL, CPSR_cf, lr
d392 1
a392 1
$label  PullEnvS $cond
d403 5
a407 1
        mymsr  ,CPSR_cf, lr
@


4.2
log
@  Merge of 32-bit capable macros to trunk.
Detail:
  The 26-bit and 32-bit capable macros have been added.
  Header files choose which set of macros to use based on <Machine>.
  If you want the new macros, include "Hdr:APCS.<APCS>" in addition
    to the usual inclusions at the top of assembler files.
  Choices are based on the settings of macros No32bitCode and
    No26bitCode.  By default, all existing machines define these
    as {TRUE} and {FALSE} respectively.  This yields the same macros
    as before (tested in Customer F 5 build) and should yield code which
    functions on RISC OS 3.1.  Any other combination of settings is
    untested at this time.
  New assembler code should use the macros FunctionEntry, Return et al
    to ensure that they build correctly.
  New assembler code should be written to not require flag preservation
    across internal function calls and to not assume it on external
    function calls where it is possible to do so.  DO NOT simply replace
    "MOVS pc, lr" with "MOV pc, lr" as this doesn't work properly.
    Replace "MOVS pc, lr" with "Return ,LinkNotStacked"
  Do not write code which simply masks out &FC000003 from pc or some kind
    or pc originated value (eg. on r14 to attempt to remove the PSR flags
    from it.  Use the RemovePSRFromReg macro instead.
Admin:
  Tested with Customer F 5 build.
  Requires FPEmulator 4.11
  Requires Portable 0.65 (or Portable75 0.04)
  Required by any new or modified assembler code in future, pretty much.
    Such components may not necessarily specify a dependency on this
    or any other later version of HdrSrc.

Version 0.63. Tagged as 'HdrSrc-0_63'
@
text
@d137 1
a137 1
$label  Entry   $reglist,$framesize
@


4.1
log
@Initial revision
@
text
@d15 1
d23 2
d29 26
d70 2
d106 41
d156 1
a156 1
        Push    lr
d160 2
d165 1
d168 1
d185 1
a185 1
        Push    lr
d189 4
d204 3
d210 1
d212 1
a212 1
        Pull    pc,$cond
d225 21
d254 99
d361 35
d400 1
a400 1
        Pull    lr, $cond
d403 1
@


4.1.10.1
log
@First attempt at 32-bit support.

Version 0.57, 4.58.2.1. Tagged as 'HdrSrc-0_57-4_58_2_1'
@
text
@a21 1
       GBLL     Proc_SavedCPSR  ; CPSR was preserved
a25 18
       GBLS     Proc_GetMachine
 [ :LNOT: :DEF: Included_Hdr_Machine_Machine
Proc_GetMachine SETS "GET Hdr:Machine.<Machine>"
 |
Proc_GetMachine SETS ""
 ]
       $Proc_GetMachine

       GBLS     Proc_GetCPU32
 [ :LNOT: :DEF: Included_Hdr_CPU_Generic32
Proc_GetCPU32 SETS "GET Hdr:CPU.Generic32"
 |
Proc_GetCPU32 SETS ""
 ]
        $Proc_GetCPU32



a40 1
Proc_SavedCPSR SETL False
a74 1
Proc_SavedCPSR SETL False
d84 1
a84 39
        STR     lr, [sp, #-4]!
 |
        Push    "$Proc_RegList, lr"
 ]
 [ Proc_LocalStack <> 0
        SUB     sp, sp, #Proc_LocalStack
 ]
        MEND

; *****************************************************************************
; *** Keep a note of local stack and register use at the routine entry      ***
; *** point so that an exit may be effected anywhere in the body without    ***
; *** remembering how many (and which) registers to destack and ADJSP.      ***
; *** Also ensures that the code entry label is word-aligned.               ***
; *** You must use this macro if you want to use EXITS in 32-bit mode.      ***
; *****************************************************************************
        MACRO
$label  EntryS  $reglist,$framesize
        ALIGN
 [ No32bitCode
$label  Entry   $reglist,$framesize
 |
Proc_RegList SETS "$reglist"
 [ "$framesize" = ""
Proc_LocalStack SETA 0
 |
Proc_LocalStack SETA $framesize
 ]
Proc_SavedCPSR SETL True
 [ "$label" <> ""
  [ Proc_Debug
        B       $label
        DCB     "$label", 0
        ALIGN
  ]
$label  ROUT
 ]
 [ "$Proc_RegList" = ""
        STR     lr, [sp, #-4]!
a87 2
        mrs     AL, lr, CPSR
        STR     lr, [sp, #-4]!
a90 1
 ]
a92 1

d109 1
a109 1
        STR     lr, [sp, #-4]!
a112 4
 [ Proc_SavedCPSR
        mrs     AL, lr, CPSR
        STR     lr, [sp, #-4]!
 ]
a123 3
 [ Proc_SavedCPSR
        ADD$cond sp, sp, #Proc_LocalStack + 4
 |
a126 1
 ]
d128 1
a128 1
        LDR$cond pc, [sp], #4
a143 12
 [ Proc_SavedCPSR
        LDR$cond lr, [sp], #4
        msr     $cond, CPSR_all, lr
 [ "$Proc_RegList" = ""
        LDR$cond pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc",$cond
 ]
 |
 [ No26bitCode
        ! 1, "EXITS without EntryS"
 ]
a148 35
 ]
        MEND

; *****************************************************************************
; *** Exit procedure : restore stack and saved registers + psr (except V)   ***
; *** to values on entry.                                                   ***
; *****************************************************************************
        MACRO
$label  EXITV
$label
 [ Proc_LocalStack <> 0
        ADD     sp, sp, #Proc_LocalStack
 ]
 [ Proc_SavedCPSR
        LDR     lr, [sp], #4
        BICVC   lr, lr, #V_bit
        ORRVS   lr, lr, #V_bit
        msr     AL, CPSR_all, lr
 [ "$Proc_RegList" = ""
        LDR     pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc"
 ]
 |
 [ No26bitCode
        ! 1, "EXITV without EntryS"
 ]
 [ "$Proc_RegList" = ""
        LDR     lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr"
 ]
        BICVCS  pc, lr, #V_bit
        ORRVSS  pc, lr, #V_bit
 ]
a156 3
 [ Proc_SavedCPSR
        ADD$cond sp, sp, #Proc_LocalStack + 4
 |
a159 22
 ]
 [ "$Proc_RegList" = ""
        LDR$cond lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr", $cond
 ]
        MEND

; *****************************************************************************
; *** Restore stack and saved registers, lr and CPSR to values on entry to  ***
; *** procedure                                                             ***
; *****************************************************************************
        MACRO
$label  PullEnvS $cond
$label
 [ Proc_LocalStack <> 0
        ADD$cond sp, sp, #Proc_LocalStack
 ]
 [ Proc_SavedCPSR
        LDR$cond lr, [sp], #4
        msr     $cond, CPSR_all, lr
 ]
d161 1
a161 1
        LDR$cond lr, [sp], #4
@


4.1.10.2
log
@More macros added to Hdr:Proc and Hdr:CPU.
msr macro now understands _cxsf form.
APCS macros now available in Hdr:APCS.<APCS>

Version 0.57, 4.58.2.2. Tagged as 'HdrSrc-0_57-4_58_2_2'
@
text
@a0 15
; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

a22 1
       GBLA     Proc_RegOffset  ; Offset of first register on stack
a42 8
       GBLS     Proc_GetAPCS
 [ :LNOT: :DEF: Included_Hdr_APCS
Proc_GetAPCS SETS "GET Hdr:APCS.<APCS>"
 |
Proc_GetAPCS SETS ""
 ]
        $Proc_GetAPCS

a60 1
Proc_RegOffset SETA Proc_LocalStack
a95 1
Proc_RegOffset SETA Proc_LocalStack
a133 1
Proc_RegOffset SETA Proc_LocalStack + 4
d147 1
a147 1
        mymrs   AL, lr, CPSR
d177 1
a177 1
        mymrs   AL, lr, CPSR
a205 28
; *** Exit procedure, restore stack and saved registers to values on entry. ***
; *** Restore PSR if APCS-R in force.                                       ***
; *****************************************************************************
        MACRO
$label  EXITAPCS $cond
$label
 [ Proc_SavedCPSR
        ! 1, "Don't use EntryS with EXITAPCS"
 ]
 [ Proc_LocalStack <> 0
        ADD$cond sp, sp, #Proc_LocalStack
 ]
 [ APCS = "APCS-R"
 [ "$Proc_RegList" = ""
        Pull    "pc",$cond,^
 |
        Pull    "$Proc_RegList, pc",$cond,^
 ]
 |
 [ "$Proc_RegList" = ""
        LDR$cond pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc",$cond
 ]
 ]
        MEND

; *****************************************************************************
d217 1
a217 1
        mymsr   $cond, CPSR_all, lr
d237 1
a237 1
; *** to values on entry. Return with V unaltered from current state.       ***
d249 1
a249 1
        mymsr   AL, CPSR_all, lr
d270 1
a270 2
; *** Exit procedure : restore stack and saved registers + psr (except V)   ***
; *** to values on entry. Return with V clear.                              ***
d273 1
a273 1
$label  EXITVC
a274 3
 [ Proc_LocalStack <> 0
        ADD     sp, sp, #Proc_LocalStack
 ]
d276 1
a276 14
        LDR     lr, [sp], #4
        BIC     lr, lr, #V_bit
        mymsr   AL, CPSR_all, lr
 [ "$Proc_RegList" = ""
        LDR     pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc"
 ]
 |
 [ No26bitCode
        ! 1, "EXITV without EntryS"
 ]
 [ "$Proc_RegList" = ""
        LDR     lr, [sp], #4
a277 13
        Pull    "$Proc_RegList, lr"
 ]
        BICS    pc, lr, #V_bit
 ]
        MEND

; *****************************************************************************
; *** Exit procedure : restore stack and saved registers + psr (except V)   ***
; *** to values on entry. Return with V set.                                ***
; *****************************************************************************
        MACRO
$label  EXITVS
$label
d279 1
a279 1
        ADD     sp, sp, #Proc_LocalStack
a280 30
 [ Proc_SavedCPSR
        LDR     lr, [sp], #4
        ORR     lr, lr, #V_bit
        mymsr   AL, CPSR_all, lr
 [ "$Proc_RegList" = ""
        LDR     pc, [sp], #4
 |
        Pull    "$Proc_RegList, pc"
 ]
 |
 [ No26bitCode
        ! 1, "EXITV without EntryS"
 ]
 [ "$Proc_RegList" = ""
        LDR     lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr"
 ]
        ORRS    pc, lr, #V_bit
 ]
        MEND

; *****************************************************************************
; *** Restore stack and saved registers, lr to values on entry to procedure ***
; *****************************************************************************
        MACRO
$label  PullEnv $cond
$label
 [ Proc_RegOffset <> 0
        ADD$cond sp, sp, #Proc_RegOffset
d301 1
a301 1
        mymsr   $cond, CPSR_all, lr
@


4.1.10.3
log
@Lots of exciting 32-bit stuff. Try it at your peril.

Version 0.57, 4.58.2.6. Tagged as 'HdrSrc-0_57-4_58_2_6'
@
text
@a36 8
       GBLS     Proc_GetCPU26
 [ :LNOT: :DEF: Included_Hdr_CPU_Generic26
Proc_GetCPU26 SETS "GET Hdr:CPU.Generic26"
 |
Proc_GetCPU26 SETS ""
 ]
        $Proc_GetCPU26

d45 8
d219 28
a252 5
 [ Proc_SavedCPSR
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000000 :EOR: Cond_$cond + ((%FT01 - (. + 8))/4)
  ]
d254 1
a254 1
        ADD     sp, sp, #Proc_LocalStack
d256 3
a258 2
        LDR     lr, [sp], #4
        mymsr  , CPSR_cf, lr
d260 1
a260 1
        LDR     pc, [sp], #4
d262 1
a262 1
        Pull    "$Proc_RegList, pc"
a263 1
01
a264 1
 ; 26-bit version
a267 3
 [ Proc_LocalStack <> 0
        ADD$cond sp, sp, #Proc_LocalStack
 ]
d290 1
a290 1
        mymsr   AL, CPSR_cf, lr
d323 1
a323 1
        mymsr   AL, CPSR_cf, lr
d355 1
a355 1
        mymsr   AL, CPSR_cf, lr
a396 5
 [ Proc_SavedCPSR
  [ "$cond" <> "AL" :LAND: "$cond" <> ""
        ; branch over on opposite condition
        DCD     &1A000000 :EOR: Cond_$cond + ((%FT01 - (. + 8))/4)
  ]
d398 1
a398 1
        ADD     sp, sp, #Proc_LocalStack
d400 3
a402 12
        LDR     lr, [sp], #4
        mymsr  ,CPSR_cf, lr
 [ "$Proc_RegList" = ""
        LDR     lr, [sp], #4
 |
        Pull    "$Proc_RegList, lr"
 ]
01
 |
; 26-bit form
 [ Proc_LocalStack <> 0
        ADD$cond sp, sp, #Proc_LocalStack
a407 1
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

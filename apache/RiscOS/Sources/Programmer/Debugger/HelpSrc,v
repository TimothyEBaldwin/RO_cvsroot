head	4.7;
access;
symbols
	Debugger-2_02-1:4.7
	Debugger-2_02:4.7
	Debugger-2_01:4.7
	Debugger-2_00:4.7
	Debugger-1_99:4.7
	Debugger-1_98:4.7
	Debugger-1_97:4.7
	Debugger-1_96:4.7
	Debugger-1_95:4.7
	Debugger-1_94:4.7
	Debugger-1_93:4.7
	Debugger-1_92:4.7
	Debugger-1_91:4.7
	Debugger-1_90:4.7
	Debugger-1_89:4.6
	Debugger-1_88:4.6
	Debugger-1_87:4.6
	Debugger-1_86:4.6
	Debugger-1_85:4.5
	Debugger-1_84:4.5
	Debugger-1_83:4.5
	Debugger-1_82:4.5
	Debugger-1_81:4.5
	Debugger-1_80:4.5
	Debugger-1_79:4.5
	Debugger-1_78:4.5
	RO_5_07:4.5
	Debugger-1_77:4.5
	Debugger-1_76:4.5
	Debugger-1_75:4.5
	Debugger-1_74:4.5
	Debugger-1_73:4.5
	Debugger-1_72:4.4
	Debugger-1_71:4.4
	Debugger-1_70:4.4
	Debugger-1_68:4.4
	Debugger-1_67:4.4
	Debugger-1_66:4.4
	Debugger-1_65:4.4
	Debugger-1_64:4.4
	Debugger-1_63:4.4
	dellis_autobuild_BaseSW:4.4
	Debugger-1_62:4.4
	Debugger-1_61:4.3
	Debugger-1_60:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.5
	Debugger-1_59:4.2
	Debugger-1_58:4.2
	dcotton_debugger_MPTBuild_14Apr1999:4.2
	dcotton_debugger_MPTInitialBuild:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.6
	Debugger-1_57:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2015.07.22.07.38.19;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	1DzdVXPZmoHlJfuy;

4.6
date	2014.02.08.15.46.54;	author jlee;	state Exp;
branches;
next	4.5;
commitid	WRCgbSfWiPsdrjox;

4.5
date	2001.05.01.14.14.00;	author mstephen;	state Exp;
branches;
next	4.4;

4.4
date	2000.09.08.14.12.34;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.02.15.58.40;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.09.06.10.49;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.50.01;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.50.01;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.19.05;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.05.17;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.36.44;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Add *Where to debugger's armoury
Largely inspired/ripped off from the DebugTools module, but using OS_DynamicArea 20 for the bulk of area searching. The address to lookup goes through the usual parser for Debugger commands so can be a hex address/register/implied exception PC if no arguments given.
Removed limited lookup from *ShowRegs command; this wasn't especially useful being hardwired to PC since only data aborts have a valid PC, normally the other registers are more interesting.
Fix miscapitalisation of ShowVFPRegs syntax (presumably to avoid it using Token0) by adding a DictTokens directive, since the syntax is used by code in the module which doesn't work with Token0.
Split German messages out into CmdHelp/Messages.

Tested in an IOMD ROM build with various edge cases.

Version 1.90. Tagged as 'Debugger-1_90'
@
text
@        SUBT    > <wini>arm.Debugger.HelpSrc

 [ International_Help = 0
BreakClr_Help
        =       "*",TokenEscapeChar,Token0
        =       " removes the breakpoint at the specified address."
        =       " If no address is given then all breakpoints are removed."
        =       13
BreakClr_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       " [<addr|reg>]", 0

BreakList_Help
        =       "*",TokenEscapeChar,Token0
        =       " lists all the currently set breakpoints."
        =       13
BreakList_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       "", 0

BreakSet_Help
        =       "*",TokenEscapeChar,Token0
        =       " sets a breakpoint at the given address."
        =       13
BreakSet_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       " <addr|reg>", 0

Continue_Help
        =       "*",TokenEscapeChar,Token0
        =       " restarts execution from the breakpoint saved state."
        =       13
Continue_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       "", 0

Debug_Help
        =       "*",TokenEscapeChar,Token0
        =       " gives access to debugging facilities."
        =       13
Debug_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       "", 0

InitStore_Help
        =       "*",TokenEscapeChar,Token0
        =       " fills user memory with the specified data,"
        =       " or the value &E7FFFFFF (an illegal ARM instruction) if no"
        =       " parameter is given."
        =       13
InitStore_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       " [<data|reg>]", 0

Memory_Help
        =       "*",TokenEscapeChar,Token0
        =       " displays the values in the memory in ARM words."
        =       13
Memory_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       " [P] [B] <addr1|reg1> [[+|-] <addr2|reg2> [+ <addr3|reg3>]]", 0

MemoryA_Help
        =       "*",TokenEscapeChar,Token0
        =       " displays and alters the memory contents in bytes or words."
        =       13
MemoryA_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       " [P] [B] <addr|reg1> [<data|reg2>]", 0

MemoryI_Help
        =       "*",TokenEscapeChar,Token0
        =       " disassembles ARM or Thumb instructions."
        =       13
MemoryI_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       " [P] [T] <addr1|reg1> [[+|-] <addr2|reg2> [+ <addr3|reg3>]]", 0

ShowRegs_Help
        =       "*",TokenEscapeChar,Token0
        =       " displays the stored ARM registers."
        =       13
ShowRegs_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       "", 0

ShowFPRegs_Help
        =       "*",TokenEscapeChar,Token0
        =       " displays the stored FPA registers."
        =       13
ShowFPRegs_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       "", 0

ShowVFPRegs_Help
        =       "*",TokenEscapeChar,Token0
        =       " displays the contents of a VFP/NEON context. The command can"
        =       " show the contents of a context at a specific address, the"
        =       " current context, or the exception context (default)."
        =       13
ShowVFPRegs_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       " [A <addr>|C|E|]", 0

Where_Help
        =       "*",TokenEscapeChar,Token0
        =       " describes the region in memory of an address or register."
        =       13
Where_Syntax
        =       "Syntax: *",TokenEscapeChar,Token0
        =       " [<addr|reg>]", 0
 |
BreakClr_Help           DCB     "HDBGBCL", 0
BreakClr_Syntax         DCB     "SDBGBCL", 0

BreakList_Help          DCB     "HDBGBLS", 0
BreakList_Syntax        DCB     "SDBGBLS", 0

BreakSet_Help           DCB     "HDBGBST", 0
BreakSet_Syntax         DCB     "SDBGBST", 0

Continue_Help           DCB     "HDBGCNT", 0
Continue_Syntax         DCB     "SDBGCNT", 0

Debug_Help              DCB     "HDBGDBG", 0
Debug_Syntax            DCB     "SDBGDBG", 0

InitStore_Help          DCB     "HDBGINS", 0
InitStore_Syntax        DCB     "SDBGINS", 0

Memory_Help             DCB     "HDBGMEM", 0
Memory_Syntax           DCB     "SDBGMEM", 0

MemoryA_Help            DCB     "HDBGMMA", 0
MemoryA_Syntax          DCB     "SDBGMMA", 0

MemoryI_Help            DCB     "HDBGMMI", 0
MemoryI_Syntax          DCB     "SDBGMMI", 0

ShowRegs_Help           DCB     "HDBGSHR", 0
ShowRegs_Syntax         DCB     "SDBGSHR", 0

ShowFPRegs_Help         DCB     "HDBGSFR", 0
ShowFPRegs_Syntax       DCB     "SDBGSFR", 0

ShowVFPRegs_Help        DCB     "HDBGSVR", 0
ShowVFPRegs_Syntax      DCB     "SDBGSVR", 0

Where_Help              DCB     "HDBGWHR", 0
Where_Syntax            DCB     "SDBGWHR", 0
 ]

        ALIGN

        END
@


4.6
log
@Add *ShowVFPRegs command
Detail:
  This adds support for the *ShowVFPRegs command, which is basically VFP equivalent of *ShowFPRegs. However unlike *ShowFPRegs it allows for any arbitrary VFP context to be viewed, not just the last context that caused an exception:
  *ShowVFPRegs [E] for showing the exception context
  *ShowVFPRegs A <address> for showing a context at a specific address
  *ShowVFPRegs C for showing the current context
  File changes:
  - HelpSrc, Resources/UK/CmdHelp - Added *ShowVFPRegs help text
  - Resources/Germany/Messages, Resources/UK/Messages - New message tokens for *ShowVFPRegs output
  - s/Debugger - *ShowVFPRegs implementation
  - actions/ARMv7_VFP - VPUSH or VPOP of >16 singleword registers were incorrectly being flagged as unpredictable; it's only the doubleword version which should have that restriction.
Admin:
  Tested on Raspberry Pi
  German messages are in need of translation


Version 1.86. Tagged as 'Debugger-1_86'
@
text
@d104 8
d148 3
@


4.5
log
@memory, memorya and memoryi commands support p option,
which specifies physical rather than logical addresses
only functional with kernel that support OS_Memory 14 and 15

Version 1.72. Not tagged
@
text
@d94 10
d137 3
@


4.4
log
@* Disassembly of VFP instruction set added.
* Changed invalid instruction to &E7FFFFFF (as per ARM
  recommendation that &E7FxxxFx should be used)
* Branch disassembly changed - when running on a
  26-bit systems, branch instructions in the lower
  64M will be wrapped within 64M, but branches
  above 64M will not.
* PC-relative LDRH family instructions calculated
  target address incorrectly.

Version 1.62. Tagged as 'Debugger-1_62'
@
text
@d61 1
a61 1
        =       " [B] <addr1|reg1> [[+|-] <addr2|reg2> [+ <addr3|reg3>]]", 0
d69 1
a69 1
        =       " [B] <addr|reg1> [<data|reg2>]", 0
d77 1
a77 1
        =       " [T] <addr1|reg1> [[+|-] <addr2|reg2> [+ <addr3|reg3>]]", 0
@


4.3
log
@* 32-bit compatibility added.
* New *ShowFPRegs command.
* Added ARMv5 instructions (BLX, CLZ, BKPT, CDP2 et al)
* Handling of instruction extension space adjusted as per ARMv4.
* Fixed some Thumb instructions.
* Added "info" form of LDC and STC.
* NV condition code is now undefined, except for the new instructions using
  it.

Version 1.60. Tagged as 'Debugger-1_60'
@
text
@d48 1
a48 1
        =       " or the value &E6000010 (an illegal ARM instruction) if no"
@


4.2
log
@Lots of bug fixes and extra warnings. Source code tidied.
Thumb disassembly added.
@
text
@d86 8
d124 3
@


4.1
log
@Initial revision
@
text
@d73 1
a73 1
        =       " disassembles ARM instructions."
d77 1
a77 1
        =       " <addr1|reg1> [[+|-] <addr2|reg2> [+ <addr3|reg3>]]", 0
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.40;
access;
symbols
	Debugger-2_02-1:4.40
	Debugger-2_02:4.40
	Debugger-2_01:4.40
	Debugger-2_00:4.40
	Debugger-1_99:4.39
	Debugger-1_98:4.39
	Debugger-1_97:4.38
	Debugger-1_96:4.37
	Debugger-1_95:4.36
	Debugger-1_94:4.35
	Debugger-1_93:4.34
	Debugger-1_92:4.34
	Debugger-1_91:4.33
	Debugger-1_90:4.33
	Debugger-1_89:4.32
	Debugger-1_88:4.31
	Debugger-1_87:4.30
	Debugger-1_86:4.30
	Debugger-1_85:4.29
	Debugger-1_84:4.28
	Debugger-1_83:4.27
	Debugger-1_82:4.26
	Debugger-1_81:4.25
	Debugger-1_80:4.24
	Debugger-1_79:4.23
	Debugger-1_78:4.22
	RO_5_07:4.21
	Debugger-1_77:4.21
	Debugger-1_76:4.20
	Debugger-1_75:4.19
	Debugger-1_74:4.18
	Debugger-1_73:4.18
	Debugger-1_72:4.16
	Debugger-1_71:4.15
	Debugger-1_70:4.14
	Debugger-1_68:4.13
	Debugger-1_67:4.12
	Debugger-1_66:4.11
	Debugger-1_65:4.10
	Debugger-1_64:4.9
	Debugger-1_63:4.8
	dellis_autobuild_BaseSW:4.7
	Debugger-1_62:4.7
	Debugger-1_61:4.6
	Debugger-1_60:4.5
	sbrodie_sedwards_16Mar2000:4.4
	dcotton_autobuild_BaseSW:4.18
	Debugger-1_59:4.4
	Debugger-1_58:4.4
	dcotton_debugger_MPTBuild_14Apr1999:4.4
	dcotton_debugger_MPTInitialBuild:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.3
	Ursula_RiscPC:4.3.2.3.0.2
	Debugger-1_57:4.4
	rthornb_UrsulaBuild-19Aug1998:4.3.2.3
	UrsulaBuild_FinalSoftload:4.3.2.3
	rthornb_UrsulaBuild-12Aug1998:4.3.2.3
	aglover_UrsulaBuild-05Aug1998:4.3.2.3
	rthornb_UrsulaBuild-29Jul1998:4.3.2.3
	rthornb_UrsulaBuild-22Jul1998:4.3.2.3
	rthornb_UrsulaBuild-15Jul1998:4.3.2.3
	rthornb_UrsulaBuild-07Jul1998:4.3.2.3
	rthornb_UrsulaBuild-17Jun1998:4.3.2.3
	rthornb_UrsulaBuild-03Jun1998:4.3.2.3
	rthornb_UrsulaBuild-27May1998:4.3.2.3
	rthornb_UrsulaBuild-21May1998:4.3.2.3
	rthornb_UrsulaBuild_01May1998:4.3.2.2
	afrost_NC2_Generic:4.1.7.1
	afrost_Funai01-33:4.1.7.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula:4.3.0.2
	Ursula_bp:4.3
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.2
	ARTtmp:4.1.7.1.0.2
	RCA:4.2.0.4
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.40
date	2017.08.15.19.22.27;	author rsprowson;	state Exp;
branches;
next	4.39;
commitid	h1UikBohUqHfml3A;

4.39
date	2016.11.11.22.58.16;	author rsprowson;	state Exp;
branches;
next	4.38;
commitid	qeQW0pSFnTogsLtz;

4.38
date	2016.11.11.22.40.00;	author rsprowson;	state Exp;
branches;
next	4.37;
commitid	WFdnDSqoAtC2mLtz;

4.37
date	2016.07.24.12.21.07;	author rsprowson;	state Exp;
branches;
next	4.36;
commitid	mSZ9mJJrJxsYszfz;

4.36
date	2016.07.24.10.56.44;	author rsprowson;	state Exp;
branches;
next	4.35;
commitid	l1PQigueRnt10zfz;

4.35
date	2016.06.11.09.51.10;	author rsprowson;	state Exp;
branches;
next	4.34;
commitid	BcfYDtHjQWGb12az;

4.34
date	2016.04.05.20.41.32;	author jlee;	state Exp;
branches;
next	4.33;
commitid	xIAY2HYlqbqLLt1z;

4.33
date	2015.07.22.07.38.29;	author rsprowson;	state Exp;
branches;
next	4.32;
commitid	1DzdVXPZmoHlJfuy;

4.32
date	2015.02.08.22.28.35;	author jlee;	state Exp;
branches;
next	4.31;

4.31
date	2015.01.21.20.57.35;	author jballance;	state Exp;
branches;
next	4.30;

4.30
date	2014.02.08.15.47.04;	author jlee;	state Exp;
branches;
next	4.29;
commitid	WRCgbSfWiPsdrjox;

4.29
date	2013.11.28.01.29.29;	author jlee;	state Exp;
branches;
next	4.28;
commitid	STgm4PaoUxPr0Zex;

4.28
date	2013.10.19.16.54.58;	author rsprowson;	state Exp;
branches;
next	4.27;
commitid	OeaVkZCy9wwHpV9x;

4.27
date	2011.09.24.15.00.49;	author jlee;	state Exp;
branches;
next	4.26;
commitid	UAzTXKfyHcwc5LAv;

4.26
date	2011.08.04.22.18.31;	author jlee;	state Exp;
branches;
next	4.25;
commitid	VlFUy51myBu19fuv;

4.25
date	2010.03.22.01.09.50;	author jlee;	state Exp;
branches;
next	4.24;

4.24
date	2010.01.30.18.53.12;	author jlee;	state Exp;
branches;
next	4.23;

4.23
date	2009.06.26.00.57.32;	author bavison;	state Exp;
branches;
next	4.22;

4.22
date	2009.05.17.02.51.46;	author bavison;	state Exp;
branches;
next	4.21;

4.21
date	2004.07.30.13.32.33;	author kbracey;	state Exp;
branches;
next	4.20;

4.20
date	2002.12.03.21.28.03;	author bavison;	state Exp;
branches;
next	4.19;

4.19
date	2002.12.03.17.50.14;	author bavison;	state Exp;
branches;
next	4.18;

4.18
date	2001.05.10.16.47.22;	author kbracey;	state Exp;
branches;
next	4.17;

4.17
date	2001.05.01.14.14.02;	author mstephen;	state Exp;
branches;
next	4.16;

4.16
date	2001.04.30.10.53.56;	author srevill;	state Exp;
branches;
next	4.15;

4.15
date	2001.04.18.12.22.34;	author kbracey;	state Exp;
branches;
next	4.14;

4.14
date	2001.03.21.15.52.56;	author srevill;	state Exp;
branches;
next	4.13;

4.13
date	2001.03.21.14.04.31;	author srevill;	state Exp;
branches;
next	4.12;

4.12
date	2001.02.15.14.37.40;	author kbracey;	state Exp;
branches;
next	4.11;

4.11
date	2001.02.14.10.41.29;	author srevill;	state Exp;
branches;
next	4.10;

4.10
date	2001.02.08.14.48.51;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	2001.01.31.14.06.09;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2001.01.30.23.24.27;	author srevill;	state Exp;
branches;
next	4.7;

4.7
date	2000.09.08.14.12.34;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2000.07.11.09.20.51;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2000.05.02.15.58.42;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.09.21.10.51.47;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.05.09.06.11.01;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.17.44.24;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.50.06;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	97.05.19.23.51.26;	author kbracey;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	98.03.27.10.42.24;	author kbracey;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	98.05.08.13.05.23;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.50.06;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.03.19.50;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.13.05.30;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.36.55;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.40
log
@When there's no VFP don't offer ShowVFPRegs
It just gives a bad SWI error since VFPSupport is missing. In practice this is IOMD and Tungsten platforms, at least in the absence of a VFPEmulator.

Version 2.00. Tagged as 'Debugger-2_00'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     > Debugger.s.Debugger - ARM/RISC OS debugger (principally for machine code)

; Authors:      Roger Wilson (Brazil version)
;               Andrew F. Powis (Arthur version)
;               Stuart K. Swales (Arthur fixes/enhancements)
;               Tim Dobson (Adjusting headers, ARM600 variant)
;               Alan Glover (fixes/enhancements, ARM6/ARM7 instructions)
;               William Turner (StrongARM compatibility)
;               Kevin Bracey (ARMv4+5, Thumb, fixes/enhancements, 32-bit)
;               Steve Revill (Slight changes to ADR and SWI disassembly)
;               Ben Avison (halfword, doubleword and unaligned word support)

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:PublicWS
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:EnvNumbers
        GET     Hdr:Proc
        GET     Hdr:VduExt
        GET     Hdr:Tokens
        GET     Hdr:MsgTrans
        GET     Hdr:FPEmulator
        GET     Hdr:ResourceFS
        GET     Hdr:OsBytes
        GET     Hdr:CPU.FPA
        GET     Hdr:CPU.Arch
        GET     Hdr:OSRSI6
        GET     Hdr:VFPSupport
        GET     Hdr:HighFSI
        GET     Hdr:FileTypes
        GET     Hdr:OSMisc
        GET     Hdr:HALEntries

        GET     Hdr:Debugger
        GET     hdr.ExcDump

        GET     VersionASM

        GET     Hdr:Debug

                GBLL    debug
debug           SETL    {FALSE}

                GBLL    StrongARM
StrongARM       SETL    {TRUE}

                GBLL    WarnSArev2
WarnSArev2      SETL    {FALSE}         ; Warn about hitting the SA revision 2 STM^ bug

                GBLL    WarnARMv5
WarnARMv5       SETL    {TRUE}          ; Indicate ARMv5 or later instructions

                GBLL    WarnARMv5E
WarnARMv5E      SETL    {TRUE}          ; Indicate ARMv5E or later instructions

                GBLL    WarnXScaleDSP
WarnXScaleDSP   SETL    {TRUE}          ; Indicate XScale DSP instructions

                GBLL    WarnARMv6
WarnARMv6       SETL    {TRUE}          ; Indicate ARMv6 or later instructions

                GBLL    WarnARMv6K
WarnARMv6K      SETL    {TRUE}          ; Indicate ARMv6K or later instructions

                GBLL    WarnARMv6T2
WarnARMv6T2     SETL    {TRUE}          ; Indicate ARMv6T2 or later instructions

                GBLL    WarnARMv7
WarnARMv7       SETL    {TRUE}          ; Indicate ARMv7 or later instructions

                GBLL    WarnARMv7VE
WarnARMv7VE     SETL    {TRUE}          ; Indicate ARMv7VE or later instructions

                GBLL    WarnARMv7MP
WarnARMv7MP     SETL    {TRUE}          ; Indicate ARMv7MP or later instructions

                GBLL    WarnARMv8
WarnARMv8       SETL    {TRUE}          ; Indicate ARMv8 or later instructions

                GBLL    Thumbv6
Thumbv6         SETL    {FALSE}         ; Thumb v6 (incomplete)

                GBLL    CirrusDSP
CirrusDSP       SETL    {FALSE}         ; Cirrus' Maverick Crunch (incomplete)

                GBLL    Piccolo
Piccolo         SETL    {FALSE}         ; ARM's 16 bit DSP (incomplete)

                GBLL    XScaleDSP
XScaleDSP       SETL    {TRUE}          ; XScale multimedia extensions

                GBLL    UseCVFPNEON
UseCVFPNEON     SETL    {TRUE}          ; Use the C VFP/NEON disassembler

 [ :LNOT: :DEF: international_help
                GBLL    international_help
international_help SETL {TRUE}          ; Default to RISC OS 3.60+ internationalisation
 ]

 [ :LNOT: :DEF: standalone
                GBLL    standalone
standalone      SETL    {FALSE}
 ]


; Continue not up to much

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Debug global workspace

                ^       0, wp

; Breakpoint code section - keep layout same as RelocatedCode section

nbreakpoints    *       16

BreakCodeStart  #       nbreakpoints*8  ; Breakpoint entry code segments
                #       4*6             ; Save other registers before JMP
BreakCodeEnd    #       0               ; End of copied area

; Areas accessed pc relative by relocated breakpoint code

TrapStore       #       4               ; Store for breakpoint id
Registers       #       4*17            ; Register dump area
pc_register     *       Registers + 4*15 ; dumped pc
psr_register    *       Registers + 4*16 ; dumped psr
r12Store        #       4               ; r12 for breakpoint code
JumpStore       #       4               ; address of breakpoint code in ROM

Breaklist       #       nbreakpoints*8  ; List of addresses, old data

OldExceptionDumpArea #  4               ; Old exception register dump area

WindowWidth     #       4
BytesPerLine    #       4

Mistake         #       4               ;potential error number

OldAddress      #       4               ;address of last instruction
OldThumbAddress #       4               ;address of last Thumb instruction
OldThumbInst    #       4               ; last Thumb instruction disassembled
PhysAddrWrd     #       4

MessageFile_Block #     16              ; File handle for MessageTrans
MessageFile_Open  #     4               ; Opened message file flag

SysIs32bit      #       1               ; non-zero if on a 32-bit system
                #       3

ptr_DebuggerSpace #     4
MOVPCInstr      #       4

; SAR
DisOpts         #       4               ; Disassembler options
DisOpt_APCS     *       2_1             ; Use APCS register names (when set)
DisOpt_v6       *       2_10            ; Use 'v6' rather than 'sb'
DisOpt_v7       *       2_100           ; Use 'v7' rather than 'sl'
DisOpt_v8       *       2_1000          ; Use 'v8' rather than 'fp'
DisOpt_sp       *       2_10000         ; Use 'SP' rather than 'R13'
DisOpt_lr       *       2_100000        ; Use 'LR' rather than 'R14'
DisRegLabels    *       @@               ; Pointers to register name strings
DisReg_R0       #       4
DisReg_R1       #       4
DisReg_R2       #       4
DisReg_R3       #       4
DisReg_R4       #       4
DisReg_R5       #       4
DisReg_R6       #       4
DisReg_R7       #       4
DisReg_R8       #       4
DisReg_R9       #       4
DisReg_R10      #       4
DisReg_R11      #       4
DisReg_R12      #       4
DisReg_R13      #       4
DisReg_R14      #       4
DisReg_R15      #       4
DisReg_F        #       1               ; Prefix char for FP registers
DisReg_C        #       1               ; Prefix char for Co-pro registers
                #       1
                #       1

 [ UseCVFPNEON
CRelocOffset    #       4               ; Relocation offset used by C code
 ]

DumpBuffer      #       4
DumpBufferLen   #       4
ExceptionBusy   #       4               ; Tracks state of exception dump code to avoid re-entry:
                                        ; 0 -> idle
                                        ; 1 -> stage 1 busy
                                        ; 2 -> stage 2 busy
ROMDebugSymbols #       4
ROMBaseAddr     #       4
DumpOptions     #       4
DumpOption_HAL_Raw        * 1
DumpOption_HAL_Annotated  * 2
DumpOption_File_Raw       * 4
DumpOption_File_Annotated * 8
DumpOption_Collect        * 16          ; Collect but don't report
DumpOptions_Default       * 0           ; Default options to use on module init
DumpOptionsStr  #       44              ; Big enough for longest string

StringBuffer    #       160             ; Temp string buffer. Big enough to
                                        ; hold a disassembled instruction
                                        ; and a full register set + three instrs
 ASSERT (?StringBuffer :AND: 2_11)=0
TotalSpace      *       :INDEX: @@

; List of mistakes

                ^       1
Mistake_PlingHat #      1
Mistake_Banked  #       1
Mistake_SWICDP  #       1
Mistake_MUL     #       1
Mistake_R15shift #      1
Mistake_R15     #       1
Mistake_PCwriteback #   1
Mistake_BytePC  #       1
Mistake_StorePC #       1
Mistake_Unpred  #       1
Mistake_RdRn    #       1
Mistake_RmRn    #       1
Mistake_RdLoRdHi #      1
Mistake_RdLoRm  #       1
Mistake_RdHiRm  #       1
Mistake_Rninlist #      1
Mistake_RdRm    #       1
Mistake_STMHat  #       1
Mistake_ARMv5   #       1
Mistake_ARMv5E  #       1
Mistake_ARMv6   #       1
Mistake_ARMv6K  #       1
Mistake_ARMv6T2 #       1
Mistake_ARMv7   #       1
Mistake_ARMv7VE #       1
Mistake_ARMv7MP #       1
Mistake_BaseOdd #       1
Mistake_XScaleDSP #     1
Mistake_ARMv8   #       1

                ^       -1
Potential_SWICDP #      -1
Potential_Banked #      -1
Potential_Banked_Next # -1
Potential_SWICDP_Next # -1

; Overlaid workspace

ExeBufLen       *       4+4+4+?Registers

                ^       :INDEX: StringBuffer, wp
CoreBuffer      #       16              ; Enough for a line of bytes
 ASSERT ?StringBuffer >= ?CoreBuffer

                ^       :INDEX: StringBuffer, wp
ExecuteBuffer   #       ExeBufLen
 ASSERT ?StringBuffer >= ?ExecuteBuffer

; Internal flags
Command_64bitData *     1 :SHL: 0

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Useful constants

TAB             *       9
LF              *       10
CR              *       13
space           *       " "
quote           *       """"
colon           *       ":"
delete          *       &7F
ampersand       *       "&"

; Useful macros

; AddChar - Add a character (possibly conditionally) to the disassembly
;           eg  AddChar "B",NE
        MACRO
        AddChar   $c,$cond
        MOV$cond  R10,#"$c"
        STR$cond.B R10,[R0],#1
        MEND

; AddStr - Add a string (possibly conditionally) to the disassembly,
;          optionally adding the ARM condition field - eg
;              AddStr BX_string,,conds
        MACRO
        AddStr  $c,$cond,$conds,$two
        ADR$cond R10,$c
        [ "$conds" <> ""
          BL$cond  SaveStringConditions$two
        |
          BL$cond  SaveString
        ]
        MEND

; TestBit - check to see if a bit is set, and add one of two characters
;           depending on that bit. Needn't add a character in both
;           or indeed either case; exits with Z bit set appropriately.
;              eg    TestBit 24,"L"
        MACRO
        TestBit $bit,$set,$unset
        TSTS    R4,#1:SHL:$bit
        [ "$set" <> "" :LAND: "$unset" <> ""
        MOVEQ   R10,#"$unset"
        MOVNE   R10,#"$set"
        STRB    R10,[R0],#1
        |
          [ "$set" <> ""
          AddChar "$set",NE
          ]
          [ "$unset" <> ""
          AddChar "$unset",EQ
          ]
        ]
        MEND

; TestStr - check to see if a bit is set, and add one of two strings
;           depending on that bit. Needn't add a string in both
;           cases. Optionally add the ARM condition field. eg
;                  TestStr 20,Ldr,Str,conds
        MACRO
        TestStr $bit,$set,$unset,$conds,$two
        TSTS    R4,#1:SHL:$bit
        [ "$set" <> "" :LAND: "$unset" <> ""
        ADREQ   R10,$unset
        ADRNE   R10,$set
          [ "$conds" <> ""
          BL    SaveStringConditions$two
          |
          BL    SaveString
          ]
        |
          [ "$set" <> ""
          AddStr   $set,NE,$conds
          ]
          [ "$unset" <> ""
          AddStr   $unset,EQ,$conds
          ]
        ]
        MEND

ARM_Addr_Mask * &FC000000 ; local mask to avoid knocking off byte offsets

        AREA    |!|, CODE, READONLY, PIC

        ENTRY

Module_BaseAddr

        DCD     0
        DCD     Debug_Init - Module_BaseAddr
        DCD     Debug_Die - Module_BaseAddr
        DCD     Debug_Service - Module_BaseAddr
        DCD     Debug_Title - Module_BaseAddr
        DCD     Debug_HelpStr - Module_BaseAddr
        DCD     Debug_HC_Table - Module_BaseAddr
        DCD     Module_SWISystemBase + DebuggerSWI * Module_SWIChunkSize
        DCD     Debug_SWI_Code - Module_BaseAddr
        DCD     Debug_SWI_Name - Module_BaseAddr
        DCD     0
 [ international_help
        DCD     message_filename - Module_BaseAddr
 |
        DCD     0
 ]
 [ :LNOT: No32bitCode
        DCD     Debug_Flags - Module_BaseAddr
 ]

Debug_Title ; share with
Debug_SWI_Name
        DCB     "Debugger", 0           ; SWI class
        DCB     "Disassemble", 0        ; +0
        DCB     "DisassembleThumb", 0   ; +1
        DCB     0

Debug_HelpStr
        DCB     "Debugger", TAB, "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        DCB     " $Module_MinorVersion"
 ]
        DCB     0
        ALIGN

 [ :LNOT: No32bitCode
Debug_Flags
        DCD     ModuleFlag_32bit
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Debug_Init Entry

        IMPORT  __RelocCode
        BL      __RelocCode

        LDR     r2, [r12]               ; Hard or soft init ?
        TEQ     r2, #0
        BNE     %FT00

; Hard init

        LDR     r3, =TotalSpace         ; Claim module workspace
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS                      ; 'No room' good enough error

        STR     r2, [r12]

00      MOV     wp, r2


        ADRL    r0, RelocatedCodeStart  ; fwd ref
        MOV     r3, #BreakCodeEnd - BreakCodeStart
01      SUBS    r3, r3, #4              ; Move breakpoint code to RAM
        LDRPL   r1, [r0, r3]
        STRPL   r1, [r2, r3]
        BPL     %BT01

 [ StrongARM
        MOV     r0, #1
        MOV     r1, r2
        ADD     r2, r1, #(nbreakpoints*8)
        SWI     XOS_SynchroniseCodeAreas
 ]

        ADRL    r14, BreakTrap          ; Address of breakpoint code in ROM
        STR     r14, JumpStore          ; fwd ref
        STR     wp, r12Store            ; A good idea to initialise it

        ADR     r1, Breaklist           ; Clear breakpoint list
        MOV     r3, #nbreakpoints
        MOV     r14, #-1
10      STR     r14, [r1], #8           ; Only need to zap address field
        SUBS    r3, r3, #1
        BNE     %BT10

        ADR     r1, Registers           ; Clear register dump area
        MOV     r3, #17
        MOV     r14, #0
        STR     r14, MessageFile_Open
        STR     r14, ROMDebugSymbols
        STR     r14, ROMBaseAddr
20      STR     r14, [r1], #4
        SUBS    r3, r3, #1
        BNE     %BT20

        MOV     r0, #ExceptionDumpArea  ; Change exception register dump area
        ADR     r1, Registers
        SWI     XOS_ChangeEnvironment
        STRVC   r1, OldExceptionDumpArea

        EXIT    VS

    [ UseCVFPNEON
        ADR     R3, Module_BaseAddr
        IMPORT  |!$$Base|
        LDR     R0, =|!$$Base|
        SUB     R3, R3, R0              ;Calculate relocation offset. Should be zero for ROM builds, but calculate anyway just in case we've been manually loaded or something.
        STR     R3, CRelocOffset
    ]

        MOV     r3, #0
        STR     R3, Mistake
        STR     R3, OldAddress          ;Init vars for dodgy code detection
        STR     R3, OldThumbAddress
        STR     R3, OldThumbInst
        STR     R3, PhysAddrWrd
        MRS     R3, CPSR
        ANDS    R3, R3, #2_11100        ; non-zero if in a 32-bit mode
        STRB    R3, SysIs32bit
        BEQ     %FT40

; Find DebuggerSpace

        MOV     R0, #6
        MOV     R1, #0
        MOV     R2, #OSRSI6_DebuggerSpace
        SWI     XOS_ReadSysInfo
        MOVVS   R2, #0
        CMP     R2, #0
        LDREQ   R2, =Legacy_DebuggerSpace
        STR     R2, ptr_DebuggerSpace
        ASSERT  nbreakpoints*8 <= ?Legacy_DebuggerSpace

; Calculate MOVPCInstr
; This whole section could do with some checks to make sure DebuggerSpace and DebuggerSpace_Size are acceptable

        LDR     R0, ptr_DebuggerSpace
        MOV     R1, #32 ; ROR amount
        LDR     R2, =&E3A0F000 ; MOV PC,#0
25
        CMP     R0, #256
        MOVHS   R0, R0, LSR #2
        SUBHS   R1, R1, #2
        BHS     %BT25

        ORR     R2, R2, R0
        ORR     R2, R2, R1, LSL #7
        STR     R2, MOVPCInstr

; MakeBranch modifies MOVPCInstr by just adding the breakpoint number * 2
; So 2 :ROR: R1 is the number of bytes between each branch

        MOV     R3, #2
        MOV     R3, R3, ROR R1

; Fill in the zero page branch table

        LDR     R4, ptr_DebuggerSpace
        ASSERT  nbreakpoints = 16
        ADD     R0, R4, R3, LSL #4
        LDR     R1, =&E51FF004          ; LDR PC,[PC,#-4]
        ADR     R2, BreakCodeStart + (nbreakpoints-1)*8
30      SUB     R0, R0, R3
        STMIA   R0, {R1, R2}
        SUB     R2, R2, #8
        CMP     R0, R4
        BHI     %BT30

 [ StrongARM
        MOV     r1, r0
        MOV     r0, #1
        ASSERT  nbreakpoints = 16
        ADD     r2, r1, r3, LSL #4
        SWI     XOS_SynchroniseCodeAreas
        CLRV
 ]

; 

40
        ; Find ROM
        MOV     r0, #ModHandReason_LookupName
        ADRL    r1, Where_UMod
        SWI     XOS_Module
        BVS     %FT42
        MOV     r4, r3, LSR #20
        MOV     r4, r4, LSL #20
        STR     r4, ROMBaseAddr

        ; Find ROM debug symbols
        MOV     r0, #15
        MOV     r1, #0
41
        SWI     XOS_ReadSysInfo
        MOVVS   r1, #0
        CMP     r1, #0
        BEQ     %FT42
        CMP     r2, #ExtROMFooter_DebugSymbols
        CMPEQ   r3, #4
        BNE     %BT41
        LDW     r0, r1, r2, r3
        ADD     r0, r0, r4
        STR     r0, ROMDebugSymbols
42

        ; SAR
        MOV     R3, #0
        STR     R3, DisOpts
        BL      create_codevar
        BL      init_codevar

	[ standalone
	BLVC    declareresourcefsfiles
	]

        MOV     R3, #DumpOptions_Default
        STR     R3, DumpOptions
        BLVC    ExcDump_CodeVar_Init
      [ DumpOptions_Default <> 0
        BLVC    ExcDump_Init
      ]

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    no registers trashable

        ALIGN
Debug_ServiceTable
        DCD     0
        DCD     Debug_ServiceBody - Module_BaseAddr
        DCD     Service_Reset                   ; &27
      [ standalone
        DCD     Service_ResourceFSStarting      ; &60
      ]
        DCD     0

        DCD     Debug_ServiceTable - Module_BaseAddr
Debug_Service ROUT
        MOV     r0, r0
        TEQ     r1, #Service_Reset
      [ standalone
	TEQNE   R1,#Service_ResourceFSStarting
      ]
        MOVNE   pc, lr

Debug_ServiceBody
      [ standalone
        TEQ     R1,#Service_ResourceFSStarting
        BEQ     serviceresourcefsstarting
      ]
        Entry   "r0, r1"
        LDR     wp, [r12]
        MOV     r0, #ExceptionDumpArea          ; Set exception dump area
        ADR     r1, Registers
        SWI     XOS_ChangeEnvironment
        STRVC   r1, OldExceptionDumpArea
        EXIT

      [ standalone
; ResourceFS has been reloaded - redeclare resource files
; In    R2 -> address to call
;       R3 -> workspace for ResourceFS module

serviceresourcefsstarting
        Push    "R0,LR"
        BL      Resources
        MOV     LR,PC                   ; LR -> return address
        MOV     PC,R2                   ; R2 -> address to call
        Pull    "R0,PC"
      ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable

Debug_Die Entry

        LDR     wp, [r12]

        BL      ExcDump_CodeVar_Shutdown

        BL      SwapAllBreakpoints      ; Be nice

        MOV     r0, #ExceptionDumpArea  ; Restore old exception dump area
        MOV     r1, #0                  ; if current one is us
        SWI     XOS_ChangeEnvironment
        ADR     r14, Registers
        TEQS    r14, r1
        MOVEQ   r0, #ExceptionDumpArea
        LDREQ   r1, OldExceptionDumpArea
        SWIEQ   XOS_ChangeEnvironment
        LDR     r0, MessageFile_Open
        TEQS    r0, #0
        ADRNE   r0, MessageFile_Block
        SWINE   XMessageTrans_CloseFile
        MOV     r0, #0
        STR     r0, MessageFile_Open

        ; SAR
        BL      destroy_codevar

      [ standalone
        BL      Resources
        SWI     XResourceFS_DeregisterFiles ; ignore errors
      ]

        CLRV
        EXIT                            ; Don't refuse to die

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;                        (No. of Parameters)
Debug_HC_Table ; Name       Max  Min Flags

      [ international_help
ihflag  * International_Help
      |
ihflag  * 0
      ]
        Command BreakClr,    1,   0, ihflag
        Command BreakList,   0,   0, ihflag
        Command BreakSet,    1,   1, ihflag
        Command Continue,    0,   0, ihflag
        Command Debug,       0,   0, ihflag
        Command InitStore,   1,   0, ihflag
        Command Memory,      5,   1, ihflag ; P B R + R
        Command MemoryA,     4,   1, ihflag ; P B R V
        Command MemoryI,     7,   1, ihflag ; P T A +/- B + C
        Command ShowRegs,    0,   0, ihflag
        Command ShowFPRegs,  0,   0, ihflag
      [ SupportARMV
        Command ShowVFPRegs, 2,   0, ihflag
      ]
        Command Where,       1,   0, ihflag
        DCB     0                       ; end of table

        GET     TokHelpSrc
        ALIGN

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Debug_SWI_Code Entry "r9"

        LDR     wp, [r12]
        TEQ     R11,#0
        BEQ     swi00
        TEQ     R11,#1
        BEQ     swi01

        ADR     R0,ErrorBlock_ModuleBadSWI
        BL      CopyErrorP1

        EXIT

        MakeInternatErrorBlock ModuleBadSWI,,BadSWI

swi00
        LDR     R14,Mistake

        CMPS    R14,#Potential_Banked_Next  ;potential error if a banked access occurs (after LDM)
        MOVEQ   R14,#Potential_Banked
        CMPS    R14,#Potential_SWICDP_Next  ;potential error if a SWI occurs (after coproc)
        MOVEQ   R14,#Potential_SWICDP

        STR     R14,Mistake

        MOV     R9, R1
        BL      Instruction

        LDR     R14,Mistake

        CMPS    R14,#Potential_Banked
        CMPNES  R14,#Potential_SWICDP
        MOVEQ   R14,#0

        STREQ   R14,Mistake

        EXIT

swi01
        MOV     R9,R1
        BL      ThumbInstruction

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Memory_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGMEM", 0
        ALIGN


Memory_Code Entry "r6-r11",8

        MOV     R6,#"B"
        BL      MemoryCommon

        ADR     r2, Memory_Error
        MOV     r10, #0 ; arguments can only be 32-bit
        BL      GetCommandParms
        BLVS    CopyErrorR2
        EXIT    VS

        TST     r8, #secondparm
        ADDEQ   r7, r9, #256            ; [no second parameter]

        TEQS    r7, r9                  ; If same, ensure we do one byte/word
        ADDEQ   r7, r7, r6

        BL      SwapAllBreakpoints

        MOV     r0, #VduExt_WindowWidth
        MOV     r1, #-1
        Push    "r0, r1"
        MOV     r0, sp
        MOV     r1, sp
        SWI     XOS_ReadVduVariables
        Pull    "r0, r1"
        STR     r0, WindowWidth

        CMPS    r0, #8+2+3*32+3+1*32
        MOVHS   r14, #32
        MOVLO   r14, #16
        STR     r14, BytesPerLine

        MOV     r11, #0                 ; Force header on first row

05 ; Loop displaying memory

        SWI     XOS_ReadEscapeState
        BCS     %FT95

        TST     r11, #15
        BLEQ    MemoryHeader

        BLVC    DisplayHexWord_R9       ; address

        SWIVC   XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        BVS     %FT90

        LDR     r8, BytesPerLine
        TST     r6, #&C
        MOVNE   r8, r8, LSR #2          ; words or double-words per line
        TST     r6, #&A
        MOVNE   r8, r8, LSR #1          ; half-words or double-words per line

        MOV     r0, r9

10
        CMP     r6, #8
        BEQ     %FT25
        CMP     r6, #2
        BHI     %FT20
        BEQ     %FT15

        MOV     r2, #8-4                ; byte

        SWI     XOS_WriteI+space        ; Display byte
        BVS     %FT90

        CMP     r0, r7
        BCS     %FT50                   ; [ended, so blank. DO NOT READ BYTE]

        Push    "r1"
        BL      do_readB
        MOV     r10, r1
        ADD     r0, r0, #1
        Pull    "r1"
        B       %FA30

15      MOV     r2, #16-4

        SWI     XOS_WriteI+space
        SWIVC   XOS_WriteI+space
        BVS     %FT90

        CMP     r0, r7
        BCS     %FT50                   ; [ended, so blank. DO NOT READ HWORD]

        Push    "r1"
        BL      do_readH
        MOV     r10, r1
        ADD     r0, r0, #2
        Pull    "r1"
        B       %FA30

20
        MOV     r2, #32-4
        SWI     XOS_WriteS              ; Display word
        DCB     "    ", 0
        ALIGN
        BVS     %FT90

        CMP     r0, r7
        BCS     %FT50                   ; [ended, so blank. DO NOT READ WORD]

        Push    "r1"
        BL      do_readW
        MOV     r10, r1
        ADD     r0, r0, #4
        Pull    "r1"
        B       %FA30

25      MOV     r2, #64-4

        SWI     XOS_WriteS              ; Display word
        DCB     "        ", 0
        ALIGN
        BVS     %FT90

        CMP     r0, r7
        BCS     %FT50                   ; [ended, so blank. DO NOT READ DWORD]

        Push    "r1"
        ADD     r1, sp, #4
        BL      do_readD
        MOV     r10, r1
        ADD     r0, r0, #8
        Pull    "r1"

30      BLVC    DisplayHex
        B       %FA60


50      BLVC    Blank                   ; Output r2 spaces

60      BVS     %FT90

        SUBS    r8, r8, #1              ; Loop if not done whole line
        BNE     %BT10                   ; Even if ended in middle, were padding

        BL      SpaceColonSpace
        BVS     %FT90

        SUB     r2, r7, r9              ; nchars to print this row

        LDR     r14, BytesPerLine
        CMP     r2, r14
        MOVHS   r2, r14

        CMPS    r2, #0                  ; VClear
        BLNE    DisplayCharacters
        SWIVC   XOS_NewLine
        BVS     %FT90

        ADD     r11, r11, #1            ; Another line gone by

        LDR     r14, BytesPerLine
        ADD     r9, r9, r14             ; More bytes per line done

        CMPS    r9, r7
        BLO     %BT05


90      BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90

; in all these cases, if the OS_Memory call fails, we assume
; the system is an IOMD-based non-HAL system, where the 512MB
; of physical address space is mapped in at &80000000.

; in: r0 = address, r1 -> buffer to hold (double-word) data
do_readD ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        BNE     %FT50
        LDRD    r2, [r0]         ;read to r2,r3
        STMIA   r1, {r2,r3}
        Pull    "r0-r3, pc"
50
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     lr, [sp, #4]
        LDRD    r0, [r2]         ;read from logical mapping into r0,r1
        STMIA   lr, {r0,r1}
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r1, r2, #0       ;clear V
        Pull    "r0-r3, pc"

; in: r0 = address, out: r1 = (word) data
do_readW ROUT
        Push    "r0,r2-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        LDREQ   r1, [r0]
        Pull    "r0,r2-r3, pc",EQ
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     r2, [r2]         ;read from logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r1, r2, #0       ;clear V
        Pull    "r0,r2-r3, pc"

; in: r0 = address, out: r1 = (half-word) data
do_readH ROUT
        Push    "r0,r2-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        BNE     %FT50
        LDRH    r1, [r0]
        Pull    "r0,r2-r3, pc"
50
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDRH    r2, [r2]         ;read from logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r1, r2, #0       ;clear V
        Pull    "r0,r2-r3, pc"

; in: r0 = address, out: r1 = (byte) data
do_readB ROUT
        Push    "r0,r2-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        LDREQB  r1, [r0]
        Pull    "r0,r2-r3, pc",EQ
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDRB    r2, [r2]         ;read from logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r1, r2, #0       ;clear V
        Pull    "r0,r2-r3, pc"

; in: r0 = address, r1 -> buffer holding (double-word) data
do_writeD ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        BNE     %FT50
        LDMIA   r1, {r2,r3}
        STRD    r2, [r0]         ;write from r2,r3
        Pull    "r0-r3, pc"
50
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     lr, [sp, #4]
        LDMIA   lr, {r0,r1}
        STRD    r0, [r2]         ;store from r0,r1 into logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r0, r0, #0       ;clear V
        Pull    "r0-r3, pc"

; in: r0 = address, r1 = (word) data
do_writeW ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        STREQ   r1, [r0]
        Pull    "r0-r3, pc",EQ
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     r1, [sp, #4]
        STR     r1, [r2]         ;write to logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r0, r0, #0       ;clear V
        Pull    "r0-r3, pc"

; in: r0 = address, r1 = (half-word) data
do_writeH ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        BNE     %FT50
        STRH    r1, [r0]
        Pull    "r0-r3, pc"
50
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     r1, [sp, #4]
        STRH    r1, [r2]         ;write to logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r0, r0, #0       ;clear V
        Pull    "r0-r3, pc"

; in: r0 = address, r1 = (byte) data
do_writeB ROUT
        Push    "r0-r3, r14"
        LDR     r14, PhysAddrWrd
        TEQ     r14, #0
        STREQB  r1, [r0]
        Pull    "r0-r3, pc",EQ
        MOV     r1, r0
        MOV     r0, #14
        SWI     XOS_Memory       ;access physical address
        BICVS   r2, r1, #&E0000000
        ORRVS   r2, r2, #&80000000
        LDR     r1, [sp, #4]
        STRB    r1, [r2]         ;write to logical mapping
        MOVVC   r0, #15
        MOVVC   r1, r3
        SWIVC   XOS_Memory       ;release physical address
        ADDS    r0, r0, #0       ;clear V
        Pull    "r0-r3, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SpaceColonSpace Entry

        SWI     XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        SWIVC   XOS_WriteI+space
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryHeader Entry

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M22", 0                ; "Address  :"
        ALIGN
        EXIT    VS

        ; Use the system control register to check whether we're using rotated or unaligned loads. Safer than attempting an actual unaligned load, because alignment faults may be turned on!
        ; Unfortunately, in ARMv5 and below, any unused bits of the system control register have undefined values.
        ; So we must first check if we're on ARMv6/v7 (where the 'U' bit was first introduced), and then check if the bit is set :(
        MRC     p15,0,r0,c0,c0,0
        ANDS    lr, r0, #&0000F000 ; EQ = ARM 3/6
        TEQNE   lr, #&00007000 ; EQ = ARM 7
        BEQ     %FT40 ; Old CPU, so must be rotated load
        AND     lr, r0, #&000F0000 ; Get architecture number
        TEQ     lr, #&00070000 ; ARMv6?
        TEQNE   lr, #&000F0000 ; ARMv7+?
        BNE     %FT40 ; Old CPU, so must be rotated load
        MRC     p15, 0, r0, c1, c0, 0
        TST     r0, #1:SHL:22 ; 'U' bit
        BEQ     %FT40                   ; pre-ARMv6 style rotated load
                                        ; else ARMv7-style unaligned load
        CMP     r6, #4
        ADRHI   r0, DoubleWords_Unaligned
        ADREQ   r0, Words_Unaligned
        CMP     r6, #2
        ADREQ   r0, HalfWords_Unaligned
        ADRLO   r0, Bytes
        ADR     lr, %FT70
        MOV     pc, r0
40
        CMP     r6, #4
        ADRHI   r0, DoubleWords
        ADREQ   r0, Words
        CMP     r6, #2
        ADREQ   r0, HalfWords
        ADRLO   r0, Bytes
        ADR     lr, %FT70
        MOV     pc, r0
70
        BL      SpaceColonSpace
        EXIT    VS

        LDR     r14, BytesPerLine       ; Doing in 32 ?
        CMPS    r14, #32
        ADREQ   r0, %FT85
        SWIEQ   XOS_Write0

        ADRVC   r0, %FT80
        BLVC    message_write0
        MOVVC   r11, #0
        SWIVC   XOS_NewLine
        EXIT

80
        DCB     "M23"                   ; "   ASCII Data"

85
        DCB     "        ", 0           ; Otherwise centre in field of 32
;                01234567

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9
; As of ARMv7, non-word-aligned loads will abort, but maybe that will change in future?

DoubleWords_Unaligned Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #16
        ADR     r10, Unaligned_Header+46-16

10      SWI     XOS_WriteS
        DCB     "        ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        SUBVC   r0, r10, r9, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #8

        SUBS    r11, r11, #8
        BNE     %BT10
        EXIT

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9

Words_Unaligned Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #8
        ADR     r10, Unaligned_Header+46-8

10      SWI     XOS_WriteS
        DCB     "    ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        SUBVC   r0, r10, r9, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #4

        SUBS    r11, r11, #4
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9

HalfWords_Unaligned Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #4
        ADR     r10, Unaligned_Header+46-4

10      SWI     XOS_WriteS
        DCB     "  ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        SUBVC   r0, r10, r9, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #2

        SUBS    r11, r11, #2
        BNE     %BT10
        EXIT


Unaligned_Header
        DCB     " 6 5 4 3 2 1 0 F E D C B A 9 8 7 6 5 4 3 2 1 0"
        ALIGN
        
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9
; Behaviour if non-half-word aligned is unpredictable
; XScale seems to ignore bit 0 of the address, so let's reflect that

HalfWords Entry "r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #4
        ADR     r10, Unaligned_Header+46-4

10      SWI     XOS_WriteS
        DCB     "  ", 0
        ALIGN
        ANDVC   r9, r9, #&F
        BICVC   r0, r9, #1
        SUBVC   r0, r10, r0, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #2

        SUBS    r11, r11, #2
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9
; Behaviour if non-word- or non-double-word- (on an implementation-defined basis) aligned is unpredictable
; XScale seems to ignore the bottom two address bits and fails to carry from bit 2 to 3, so let's reflect that

DoubleWords Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #16
        TST     r9, #4
        ADREQ   r10, Unaligned_Header+46-16
        ADRNE   r10, BrokenXScale_Header+32-16

10      SWI     XOS_WriteS
        DCB     "        ", 0
        ALIGN
        ANDVC   r0, r9, #8
        SUBVC   r0, r10, r0, LSL #1
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #8

        SUBS    r11, r11, #8
        BNE     %BT10
        EXIT

BrokenXScale_Header
        DCB     " F E D C F E D C 7 6 5 4 7 6 5 4"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print header in right order dependent on r9

Words Entry "r1, r9, r10, r11"

        LDR     r11, BytesPerLine
        MOV     r1, #8
        ADR     r10, Words_Header+14-8

10      SWI     XOS_WriteS
        DCB     "    ", 0
        ALIGN
        ANDVC   r0, r9, #3
        SUBVC   r0, r10, r0, LSL #1
        ANDVC   lr, r9, #&C
        ADDVC   r0, r0, lr, LSL #2
        SWIVC   XOS_WriteN
        EXIT    VS

        ADD     r9, r9, #4

        SUBS    r11, r11, #4
        BNE     %BT10
        EXIT

Words_Header
        DCB     " 2 1 0 3 2 1 0", 0, 0
        DCB     " 6 5 4 7 6 5 4", 0, 0
        DCB     " A 9 8 B A 9 8", 0, 0
        DCB     " E D C F E D C", 0, 0

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Count from r9 to r9+15 modulo 16 along the top

Bytes Entry "r9, r10, r11"

        LDR     r11, BytesPerLine

10      SWI     XOS_WriteI+space
        SWI     XOS_WriteI+space
        MOVVC   r2, #4-4
        ANDVC   r10, r9, #&F
        BLVC    DisplayHex
        EXIT    VS

        ADD     r9, r9, #1

        SUBS    r11, r11, #1
        BNE     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Fill remaining space with 1 + r2/4 blanks

; In    r2 = number of blanks to go (multiple of 4)

Blank Entry

10      SWI     XOS_WriteI+space
        EXIT    VS

        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; in    r12 to be indirected
;       r0 -> string
;       r6 = character to check for

; Out   r1 -> string
;       r6 = 1, 2, 4 or 8 if r6 = 'B' on entry, else r6 = 1 or 4 depending on whether 'r6' present
;       any matching flag is skipped
;       r0 corrupt

MemoryCommon Entry

        LDR     wp, [r12]

        MOV     r1, r0

        MOV     r0, #0
        STR     r0, PhysAddrWrd
        BL      MemoryPhys

        BL      SkipSpaces              ; check for 'r6',space
        TEQ     r6, #'B'
        BNE     %FT20
        TEQ     r0, #'B'
        TEQNE   r0, #'b'
        MOVEQ   r6, #1
        TEQ     r0, #'H'
        TEQNE   r0, #'h'
        MOVEQ   r6, #2
        TEQ     r0, #'D'
        TEQNE   r0, #'d'
        MOVEQ   r6, #8
        TEQNE   r6, #2
        TEQNE   r6, #1
        B       %FT25
20      TEQ     r0, r6                  ; Check upper case
        ADDNE   r6, r6, #"a"-"A"
        TEQNE   r0, r6                  ; Check lower case
        MOVEQ   r6, #1
25      ; Valid character must also be followed by space
        LDREQB  r0, [r1, #1]
        TEQEQ   r0, #space
        ADDEQ   r1, r1, #2              ; skip flag character and space if match
        MOVNE   r6, #4                  ; default to 4 in case of no match

        LDR     r0, PhysAddrWrd
        TEQ     r0, #0
        BLEQ    MemoryPhys

        EXIT

;if we see we are doing a physical access, do cache flush to minimise
;possible confusion for user (eg. looking at memory via physical address
;that could otherwise be seen as different to view via logical address,
;if writeback data cache)
;
MemoryPhys ROUT
        ; check for 'P',space,
        Push    "r0, r14"
        BL      SkipSpaces
        TEQ     r0, #"p"
        TEQNE   r0, #"P"
        LDREQB  r0, [r1, #1]
        TEQEQ   r0, #space
        Pull    "r0, pc",NE
        MOV     r0, #1
        STR     r0, PhysAddrWrd
        ADD     r1, r1, #2
        MOV     r0, #&80000001   ; flush cache(s)
        SWI     XOS_MMUControl
        Pull    "r0, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryA_Code Entry "r6-r11", 8+8

        MOV     R6,#"B"
        BL      MemoryCommon

        ADR     r2, MemoryA_Error
        TEQ     r6, #8
        MOVNE   r10, #0
        MOVEQ   r10, #Command_64bitData
        ADD     r11, sp, #8
        BL      GetCommandParms
        EXIT    VS

        TST     r8, #&FF00              ; had operator ?
        BNE     %FT99                   ; [not permitted here]

        BL      SwapAllBreakpoints

        TST     r8, #secondparm
        BEQ     Interactive             ; [no second parameter]

; Simple command, not interactive

        CMP     r6, #8
        BEQ     mai_doubleword
        CMP     r6, #2
        BLO     mai_byte
        BEQ     mai_halfword

mai_word
        MOV     r2, #32-4
        Push    "r1"
        MOV     r0, r9
        BL      do_readW
        MOV     r4, r1
        MOV     r1, r7
        BL      do_writeW
        BL      do_readW
        MOV     r5, r1
        ADR     r0, %FT40
        Pull    "r1"
        B       mai_cont

mai_doubleword
        MOV     r2, #64-4
        MOV     r4, sp     ; buffer for old value
        ADD     r5, sp, #8 ; buffer for new value
        Push    "r1"
        MOV     r1, r4
        MOV     r0, r9
        BL      do_readD
        MOV     r1, r5
        BL      do_writeD
        BL      do_readD
        ADR     r0, %FT43
        Pull    "r1"
        B       mai_cont

mai_halfword
        MOV     r2, #16-4
        Push    "r1"
        MOV     r0, r9
        BL      do_readH
        MOV     r4, r1
        MOV     r1, r7
        BL      do_writeH
        BL      do_readH
        MOV     r5, r1
        ADR     r0, %FT42
        Pull    "r1"
        B       mai_cont

mai_byte
        MOV     r2, #8-4
        Push    "r1"
        MOV     r0, r9
        BL      do_readB
        MOV     r4, r1
        MOV     r1, r7
        BL      do_writeB
        BL      do_readB
        MOV     r5, r1
        ADR     r0, %FT41
        Pull    "r1"
mai_cont
        BL      message_write0

        BLVC    DisplayHexWord_R9

        ADRVC   r0, %FT44
        BLVC    message_write0

        MOVVC   r10, r4
        BLVC    DisplayHex

        ADRVC   r0, %FT45
        BLVC    message_write0

        MOVVC   r10, r5
        BLVC    DisplayHex

        SWIVC   XOS_NewLine

        BL      SwapAllBreakpoints
        EXIT

40
        DCB     "M24", 0                ; "Word at &"
41
        DCB     "M25", 0                ; "Byte at &"
42
        DCB     "M75", 0                ; "Half-word at &"
43
        DCB     "M76", 0                ; "Double-word at &"
44
        DCB     "M26", 0                ; " was &"
45
        DCB     "M27", 0                ; " altered to &"
        ALIGN

99      ADR     r0, MemoryA_Error
        BL      CopyError
        EXIT


MemoryA_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGMMA", 0
        ALIGN

; .............................................................................

Interactive ROUT

        SUB     sp, sp, #256            ; Use buffer on stack
        MOV     r8, r6                  ; 1 or 4, initial step +ve

10
        CMPS    r8, #0
        MOVGE   r0, #"+"
        MOVLT   r0, #"-"
        SWI     XOS_WriteC
        SWIVC   XOS_WriteI+space

        BLVC    DisplayHexWord_R9

        BLVC    MarkPC

        BVS     %FT90
        Push    "r0, r1"
        MOV     r0, r9
        ADR     lr, %FT20             ; they don't return using MOVS
        ADD     r1, sp, #8+256        ; buffer for old value if dword
        CMP     r6, #4
        BHI     do_readD
        BEQ     do_readW
        CMP     r6, #2
        BEQ     do_readH
        BLO     do_readB
20
        MOV     r10, r1
        Pull    "r0, r1"
        MOVVC   r2, r6
        BLVC    DisplayCharacters

        BLVC    MarkBreakpoints

        BVS     %FT90
        CMP     r6, #4
        MOVHI   r2, #64-4
        MOVEQ   r2, #32-4
        CMP     r6, #2
        MOVEQ   r2, #16-4
        MOVLO   r2, #8-4
        BLVC    DisplayHex

        SWIVC   XOS_WriteI+space
        SWIVC   XOS_WriteI+colon
        SWIVC   XOS_WriteI+space

        BVS     %FT90
        CMP     r6, #4
        BEQ     %FT40                   ; Disassemble ARM
        CMP     r6, #2
        BNE     %FT50                   ; Don't disassemble for bytes or double-words
                                        ; Else disassemble Thumb
        Push    "r1"
        MOV     r0, r9
        BL      do_readH
        MOV     r0, r1
        Pull    "r1"
        MOVVC   r1, r9
        SWIVC   XDebugger_DisassembleThumb
        MOVVC   r0, r1
        SWIVC   XOS_Write0
        B       %FT50
40

        BVS     %FT48
        Push    "r1"
        MOV     r0, r9
        BL      do_readW
        MOV     r0, r1
        Pull    "r1"
48
        MOVVC   r1, r9
        SWIVC   XDebugger_Disassemble
        MOVVC   r0, r1
        SWIVC   XOS_Write0

50      SWIVC   XOS_NewLine
        ADRVC   r0, %FT96
        BLVC    message_write0

        MOVVC   r0, sp
        MOVVC   r1, #255
        MOVVC   r2, #space
        MOVVC   r3, #&FF
        SWIVC   XOS_ReadLine
        BVS     %FT90
        BCS     %FT95

        MOV     r1, sp
        BL      SkipSpaces
        ADDCC   r9, r9, r8              ; No parm, just advance in current dirn
        MOVCC   r7,r9

        BCC     %BT10

        TEQ     r0, #"+"
        MOVEQ   r8, r6                  ; Change to +ve step
        BEQ     %BT10

        TEQ     r0, #"-"
        RSBEQ   r8, r6, #0              ; Change to -ve step
        BEQ     %BT10

        CMP     r0, #"."                ; End interactive
        BEQ     %FT90                   ; VClear

        ADR     r0, ErrorBlock_Debug_InvalidValue
        BL      CopyError
        Push    "r8"
        CMP     r6, #8
        MOVEQ   r10, #Command_64bitData ; r11 should still be set up from entry to MemoryA_Code
        MOVNE   r10, #0
        BL      ReadOneParm             ; r7 := parm, r8 state
        Pull    "r8"
        BVS     %FT90

        CMP     r6, #8
        BEQ     int_doubleword
        CMP     r6, #2
        BLO     int_byte
        BEQ     int_halfword

int_word
        Push    "r0, r1"
        MOV     r0, r9
        MOV     r1, r7
        BL      do_writeW
        BL      do_readW
        MOV     r10, r1
        Pull    "r0, r1"
        MOV     r2, #32-4
        B       %FT70

int_doubleword
        Push    "r0, r1"
        MOV     r0, r9
        ADD     r1, sp, #8+256+8      ; buffer for new value
        BL      do_writeD
        BL      do_readD
        MOV     r10, r1
        Pull    "r0, r1"
        MOV     r2, #64-4
        B       %FT70

int_halfword
        Push    "r0, r1"
        MOV     r0, r9
        MOV     r1, r7
        BL      do_writeH
        BL      do_readH
        MOV     r10, r1
        Pull    "r0, r1"
        MOV     r2, #16-4
        B       %FT70

int_byte
        Push    "r0, r1"
        MOV     r0, r9
        MOV     r1, r7
        BL      do_writeB
        BL      do_readB
        MOV     r10, r1
        Pull    "r0, r1"
        MOV     r2, #8-4
70

        SWI     XOS_WriteS
        DCB     "                  . ", 0
        ALIGN

        BLVC    DisplayHex
        SWIVC   XOS_NewLine
        BVC     %BT10


90      ADD     sp, sp, #256
        BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90


        MakeInternatErrorBlock Debug_InvalidValue, NOALIGN, M46

96
        DCB     "M29", 0                ; "  Enter new value : "
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakSet_Code Entry "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        MOV     r10, #0 ; arguments can only be 32-bit
        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #parmfollowed
        BNE     BreakSetError0

        LDRB    r4, SysIs32bit
        BIC     r7, r7, #3              ; Can only set at word address
        TEQ     r4, #0
        BNE     %FT05

        CMP     r7, #&04000000          ; Can only set in bottom 64M (has to
                                        ; construct a branch)
        BHS     BreakSetError1

05      ADR     r4, Breaklist           ; Check for breakpoint already in list
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        TEQ     r1, r7
        BEQ     %FT40                   ; [already allocated, but ensure there]
        SUBS    r3, r3, #8              ; each breakpoint entry is 8 bytes
        BPL     %BT10

        MOV     r3, #(nbreakpoints-1)*8 ; Allocate breakpoint
20      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BEQ     %FT30                   ; [free slot found]
        SUBS    r3, r3, #8
        BPL     %BT20

        ADR     r0, ErrorBlock_Debug_NoRoom
        BL      CopyError
        B       %FA90


30 ; Store breakpoint address and old contents, r3 = breakpoint number*8

        MOV     r1, r7
        STR     r1, [r4, r3]            ; breakpoint address
        LDR     r0, [r1]
        ADD     r14, r4, #4
        STR     r0, [r14, r3]           ; old data

40 ; Place branch at breakpoint address, r3 = breakpoint number*8, r1 valid

        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        ADREQ   r0, BreakCodeStart
        ADDEQ   r0, r0, r3              ; each code entry is 8 bytes too
        BLEQ    MakeBranch
        BLNE    MakeMOVPC
        STR     r2, [r1]
 [ StrongARM
        ;Do the IMB thingy here, for the replaced instruction
        MOV     r0, #1          ;Ranged IMB
        MOV     r2, r1
        SWI     XOS_SynchroniseCodeAreas
 ]
        EXIT


BreakSetError0
        ADR     r0, BreakSet_Error
        BL      CopyError

90      EXIT


BreakSetError1
        ADR     r0, ErrorBlock_Debug_BadBreakpoint
        BL      CopyError
        B       %BA90


BreakSet_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGBST", 0
        ALIGN

        MakeInternatErrorBlock Debug_NoRoom,,M48
        MakeInternatErrorBlock Debug_BadBreakpoint,,M50

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakList_Code Entry "r6-r11"

        LDR     wp, [r12]

        ADR     r4, Breaklist           ; Any breakpoints to display ?
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BNE     %FT20                   ; [yes, starting at r3]
        SUBS    r3, r3, #8
        BPL     %BT10

        BL      message_writes
        DCB     "M31", 0                ; "No breakpoints set"
        SWIVC   XOS_NewLine
        ALIGN
        EXIT


20 ; Display list

        BL      message_writes
        DCB     "M32", 0                ; "Address     Old data"
        ALIGN
        SWIVC   XOS_NewLine
        EXIT    VS

30      CMP     r1, #-1
        BEQ     %FT60                   ; [no breakpoint entry here]

        MOV     r10, r1
        BL      DisplayHexWord          ; r10 = breakpoint address
        EXIT    VS

        SWI     XOS_WriteS
        DCB     "    ", 0
        ALIGN

        ADDVC   r14, r4, #4
        LDRVC   r10, [r14, r3]
        BLVC    DisplayHexWord          ; r10 = old data
        EXIT    VS

        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        ADREQ   r0, BreakCodeStart      ; Check still B debugger
        ADDEQ   r0, r0, r3              ; each code entry is 8 bytes too
        BLEQ    MakeBranch              ; r1 from up there
        BLNE    MakeMOVPC
        LDR     r14, [r1]
        TEQS    r14, r2
        BEQ     %FT50                   ; [breakpoint present and correct]

        MOV     r14, #-1                ; Clear faulty breakpoint entry
        STR     r14, [r4, r3]           ; Only need to zap address field

        BL      message_writes
        DCB     "M33", 0 ; No newline   ; " : bad breakpoint; cleared."
        ALIGN

50      SWIVC   XOS_NewLine
        EXIT    VS

60      SUBS    r3, r3, #8
        LDRPL   r1, [r4, r3]
        BPL     %BT30

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BreakClr_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGBCL", 0
        ALIGN


BreakClr_Code Entry "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        ADR     r0, BreakClr_Error
        MOV     r10, #0 ; arguments can only be 32-bit
        BL      ReadOneParm             ; r7 := parm, r8 state
        BLVS    CopyError
        EXIT    VS

        LDRB    r4, SysIs32bit
        TEQ     r4, #0
        BICEQ   r7, r7, #ARM_CC_Mask    ; Can only set at word address in 64M

        ADR     r4, Breaklist
        MOV     r3, #(nbreakpoints-1)*8

        TST     r8, #hasparm
        BEQ     %FT50                   ; [no parm, so prompt]

; Clear particular breakpoint

10      LDR     r1, [r4, r3]
        TEQS    r1, r7
        BEQ     %FT20                   ; [found]
        SUBS    r3, r3, #8
        BPL     %BT10

        ADR     r0, ErrorBlock_Debug_BreakNotFound
        BL      CopyError
        EXIT


20      BL      ClearBreakpoint         ; uses r1,r3,r4
        EXIT


50 ; Clear all breakpoints

        BL      message_writes
        DCB     "M35", 0                ; "Clear all breakpoints? [Y/N]"
        ALIGN

        SWIVC   XOS_Confirm             ; So sexy, huh ? Returns lowercase char
        EXIT    VS
        BLCS    AckEscape
        SWIVC   XOS_NewLine
        EXIT    VS

        ;TEQ     r0, #"y"
        EXIT    NE                      ; [anything else -> go home]


60      LDR     r1, [r4, r3]
        CMP     r1, #-1
        BLNE    ClearBreakpoint         ; uses r1,r3,r4

        SUBS    r3, r3, #8
        BPL     %BT60

        BL      message_writes
        DCB     "M36", 0                ; "All breakpoints cleared"
        ALIGN
        SWIVC   XOS_NewLine
        EXIT


        MakeInternatErrorBlock Debug_BreakNotFound,,M45

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = breakpoint address
;       r3 = breakpoint number*8
;       r4 -> Breaklist

ClearBreakpoint Entry "r0-r2, r10"

        MOV     r14, #-1                ; Always clear breakpoint entry
        STR     r14, [r4, r3]           ; Only need to zap address field

        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        ADREQ   r0, BreakCodeStart      ; Check that breakpoint was valid
        ADDEQ   r0, r0, r3              ; Each code entry is 8 bytes too
        BLEQ    MakeBranch
        BLNE    MakeMOVPC
        LDR     r14, [r1]
        TEQS    r14, r2
        ADDEQ   r14, r4, #4             ; breakpoint was good, so put data back
        LDREQ   r14, [r14, r3]
        STREQ   r14, [r1]
 [ StrongARM
        ;Do the IMB thingy here
        MOV     r0, #1                  ;Ranged IMB
        MOV     r2, r1
        SWI     XOS_SynchroniseCodeAreas
 ]
        EXIT    EQ

        BL      message_writes
        DCB     "M37", 0                ; "Bad breakpoint at &"
        ALIGN
        MOVVC   r10, r1
;        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS
        BL      message_writes
        DCB     "M38", 0                ; "; cleared."
        ALIGN
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Continue_Code Entry "r6-r11"

        LDR     wp, [r12]

        LDRB    r4, SysIs32bit
        TEQ     r4, #0

        LDR     r14, pc_register        ; Get pc from exception dump
        BICEQ   r14, r14, #ARM_CC_Mask

        ADR     r4, Breaklist           ; Check breakpoint list for pc
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        TEQS    r1, r14
        MOVEQ   r5, #0                  ; [found]
        BEQ     %FT20
        SUBS    r3, r3, #8
        BPL     %BT10

 [ debug
 DLINE "Not continuing from any of current breakpoints"
 ]
        ADR     r0, Registers
        B       %FT90                   ; Continue with this state



20 ; Check branch at breakpoint

        LDRB    r0, SysIs32bit
        TEQ     r0, #0

        ADREQ   r0, BreakCodeStart
        ADDEQ   r0, r0, r3
        BLEQ    MakeBranch
        BLNE    MakeMOVPC
        LDR     r14, [r1]
        TEQ     r14, r2
        BNE     ContinueError1          ; [not kosher]

        BL      message_writes
        DCB     "M39", 0                ; "Continue from breakpoint set at &"
        ALIGN

        MOVVC   r10, r1
;        BICVC   R10,R10,#ARM_CC_Mask
        BLVC    DisplayHexWord
        EXIT    VS

        SWI     XOS_NewLine
        EXIT    VS
        BL      message_writes
        DCB     "M40", 0                ; "Execute out of line? [Y/N] "
        ALIGN

        SWIVC   XOS_Confirm             ; So sexy, huh ? Returns lowercase char
        EXIT    VS                      ; (which for Internationalisation's sake
        BLCS    AckEscape               ; we now ignore, and use the Carry flag
        SWIVC   XOS_NewLine             ; return instead!)
        EXIT    VS

        ;TEQ     r0, #"y"
        EXIT    NE

; Execute instruction out-of-line

        Push    "r1, r3, r4"
        ADR     r8, ExecuteBuffer+12
        ADR     r9, Registers
        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        LDMIA   r9!, {r0-r7}            ; Get + Store first 8 registers
        STMIA   r8!, {r0-r7}
        LDMIA   r9!, {r0-r6}            ; Get next 7 registers
        LDREQ   r14, pc_register
        ANDEQ   r14, r14, #ARM_CC_Mask
        ADR     r7, ExecuteBuffer
        ORREQ   r7, r7, r14             ; dumped pc -> ExecBuffer +mode +flags
        STMIA   r8!, {r0-r7}
        LDRNE   r0, [r9, #4]            ; do CPSR for 32-bit
        STRNE   r0, [r8]
        Pull    "r1, r3, r4"

; See if we can do any better for pc relatives in this version

        ADR     r8, ExecuteBuffer
        ADD     r14, r4, #4
        LDR     r14, [r14, r3]          ; Copy instruction(old data)into buffer
 [ debug
 DREG r14,"Instruction to execute out of line is "
 ]
        AND     r0, r14, #&0F000000     ; If it's a Bxx, correct for new loc'n
        TEQ     r0,      #&0A000000
        LDREQB  r0, SysIs32bit
        TEQEQ   r0, #0                  ; only works for 26-bit, probably
        MOVEQ   r0, r14, LSL #8
        ADDEQ   r0, r0, r1, LSL #6      ; r0 = destination of branch-8
 [ debug
 BNE %FT00
 MOV r0, r0, LSR #6
 DREG r0,"continuing a branch, destination-8 = "
 MOV r0, r0, LSL #6
00
 ]
        SUBEQ   r0, r0, r8, LSL #6
        ANDEQ   r2, r14, #&FF000000     ; Copy condition codes + instruction
        ORREQ   r14, r2, r0, LSR #8     ; Munge back together
 [ debug
 BNE %FT00
 DREG r14,"replacing instruction with "
00
 ]
        STR     r14, ExecuteBuffer

        LDR     r14, =&E51FF004         ; LDR PC,[PC,#-4]
        STR     r14, ExecuteBuffer+4
        ADD     r14, r1, #4             ; address of next instruction in
        STR     r14, ExecuteBuffer+8    ; real program
 [ StrongARM
        ;Best IMB the ExecuteBuffer here
        MOV     r0, #1                  ; Guess what? It's a ranged sync
        ADR     r1, ExecuteBuffer
        ADD     r2, r1, #ExeBufLen
        SWI     XOS_SynchroniseCodeAreas
 ]
        ADR     r0, ExecuteBuffer+12    ; and drop into ...


90 ; Nice simple continuation. r0 -> register state to continue with

 [ :LNOT: No26bitCode
        LDRB    r14, SysIs32bit
        TEQ     r14, #0
        BNE     Continue32

        LDR     r14_svc, [r0, #15*4]
        ANDS    r14_svc, r14_svc, #SVC_mode
        BEQ     %FT95                   ; [user mode harder]

        TEQP    r14_svc, #F_bit + I_bit ; Enter correct mode, ints off
        NOP
        LDMIA   r0, {r0-pc}^            ; Restore int state, r0 never banked


95      MOV     r14_svc, r0
        LDMIA   r14_svc, {r0-r12, r13_usr, r14_usr}^
        NOP
        LDR     r14_svc, [r14_svc, #15*4]
        MOVS    pc, r14_svc             ; Jump to instruction in right mode
 ]

Continue32

        LDR     r14_svc, [r0, #16*4]
        TST     r14_svc, #2_01111
        BEQ     %FT97                   ; [user mode harder]

        TST     r14_svc, #2_11100
        ORREQ   r1, r14_svc, #&10+F32_bit+I32_bit ; convert 26-bit modes to 32-bit form
        ORRNE   r1, r14_svc, #F32_bit+I32_bit ; otherwise, just ints off
        MSR     CPSR_c, r1              ; Enter correct mode, ints off
        MSR     SPSR_cxsf, r14_svc      ; Set up SPSR ready for return
        LDMIA   r0, {r0-pc}^            ; Restore int state, r0 never banked

97
        MRS     r14_svc, CPSR
        ORR     r14_svc, r14_svc, #I32_bit
        MSR     CPSR_c, r14_svc         ; IRQs off for SPSR use

        LDR     r14_svc, [r0, #16*4]
        MSR     SPSR_cxsf, r14_svc      ; Set up SPSR ready for return

        MOV     r14_svc, r0
        LDMIA   r14_svc, {r0-r12, r13_usr, r14_usr}^
        NOP
        LDR     r14_svc, [r14_svc, #15*4]
        MOVS    pc, r14_svc             ; Jump to instruction in right mode



ContinueError1
        MOV     r14, #-1
        STR     r14, [r4, r3]           ; Only need to zap address field
        BL      message_writes
        DCB     "M41", 0                ; "Bad breakpoint at &"
        ALIGN
        MOVVC   r10, r1
        BLVC    DisplayHexWord
        EXIT    VS
        BL      message_writes
        DCB     "M42", 0                ; "; cleared."
        ALIGN
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Debug_Code

        LDR     wp, [r12]

; .............................................................................

Debug_Code_Common Entry "r6-r11"

10
        BL      message_writes
        DCB     "M43", 0                ; "Debug*"
        ALIGN

        ADRVC   r0, StringBuffer
        MOVVC   r1, #?StringBuffer-1
        MOVVC   r2, #space
        MOVVC   r3, #255
        SWIVC   XOS_ReadLine
        EXIT    VS
        BCS     %FT50

        SWIVC   XOS_CLI

40      BLVS    PrintError
        B       %BT10

50      BL      AckEscape

        TEQ     r1, #0                  ; Any chars read ?
        EXIT    EQ                      ; VSet, return error

        SWI     XOS_NewLine             ; Need to print a NewLine as we
        SETV                            ; didn't terminate the Iine with CR/LF
        B       %BT40

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

AckEscape Entry "r1, r2"

        MOV     r0, #OsByte_AcknowledgeEscape
        SWI     XOS_Byte

        ADRVC   r0, ErrorBlock_Escape
        BLVC    CopyError
        EXIT

        MakeInternatErrorBlock Escape,,Escape

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PrintError Entry

        ADD     r0, r0, #4
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r10 = number to be displayed
;       r2 = starting bit position

; Out   r0 corrupt if error

DisplayHex Entry "r0, r2"

        CMP     r2, #32
        BHS     %FT20
10      MOV     r0, r10, LSR r2
        AND     r0, r0, #15
        CMPS    r0, #9
        ORRLS   r0, r0, #"0"
        ADDHI   r0, r0, #"A"-10
        SWI     XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS

        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

20      ; 9 or more digits to display, so we must have received a buffer pointer in r10 instead
        Push    "r10"
        LDR     r10, [r10, #4] ; MSW first
        SUB     r2, r2, #32
        BL      DisplayHex
        LDRVC   r10, [sp]
        LDRVC   r10, [r10] ; then LSW
        MOVVC   r2, #28
        BLVC    DisplayHex
        Pull    "r10"
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Out   r10 corrupt

DisplayHexWord_R9

        MOV     r10, r9

; .............................................................................

DisplayHexWord Entry "r2"

        MOV     r2, #32-4
        BL      DisplayHex
        EXIT

; .............................................................................

DisplayHexHalfword Entry "r2"

        MOV     r2, #16-4
        BL      DisplayHex
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r9 -> core
;       r2 = number of chars to print
;       r6 = access size

; Out   VS: r0 -> error
;       VC: all preserved

DisplayCharacters Entry "r0-r2, r4-r5, r9", 8  ; "r0-r3, r9"

        ADD     r2, r9, r2
10
        MOV     r0, r9
        MOV     r1, sp
        CMP     r6, #8
        ADREQ   lr, %FT14
        BEQ     do_readD
        CMP     r6, #2
        ADR     lr, %FT15
        BLO     do_readB
        BEQ     do_readH
        BHI     do_readW
        
14      LDMIA   r1, {r1,r5}
15      ADD     r9, r9, r6
        MOV     r4, r1
        MOV     r1, r6
20      AND     r0, r4, #&FF
        CMPS    r0, #delete
        CMPNES  r0, #space-1
        MOVLS   r0, #"."
        SWI     XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        TEQ     r1, #5
        MOVEQ   r4, r5
        MOVNE   r4, r4, LSR #8
        SUBS    r1, r1, #1
        BNE     %BT20

        CMP     r9, r2
        BLO     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r4, r5 = data to display
;       r6 = number of chars to print (1-8)

; Out   VS: r0 -> error
;       VC: all preserved

DisplayCharactersR ALTENTRY
        MOV     r9, #0
        MOV     r2, r6
        B       %BT15

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r8 = number to display

DisplayDecimalNumber Entry "r0-r2"

        SUB     sp, sp, #16
        MOV     r0, r8
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_BinaryToDecimal

        ADD     r2, r2, r1
10      LDRB    r0, [r1], #1
        SWI     XOS_WriteC
        BVS     %FT90
        CMPS    r1, r2
        BLT     %BT10

90      ADD     sp, sp, #16
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r9 = address to consider

MarkBreakpoints Entry "r2, r3"

        ADR     r2, Breaklist
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r14, [r2, r3]
        TEQS    r14, r9
        MOVEQ   r0, #"*"                ; [found]
        BEQ     %FT50
        SUBS    r3, r3, #8
        BPL     %BT10
        MOV     r0, #":"                ; [not found]

50      SWI     XOS_WriteI+space
        SWIVC   XOS_WriteC
        SWIVC   XOS_WriteI+space
        EXIT

; .............................................................................

MarkPC ALTENTRY

        LDRB    r0, SysIs32bit
        LDR     r14, pc_register
        TEQ     r0, #0
        BICEQ   r14, r14, #ARM_CC_Mask
        TEQS    r14, r9
        MOVEQ   r0, #"<"                ; [found]
        MOVNE   r0, #":"                ; [not found]

        B       %BT50                   ; Share some code

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Swap old data back into core, remembering our branches

SwapAllBreakpoints EntryS "r1-r5"

        ADR     r4, Breaklist
        ADD     r5, r4, #4              ; r5 -> old data list to index on
        MOV     r3, #(nbreakpoints-1)*8
10      LDR     r1, [r4, r3]
        CMP     r1, #-1
        LDRNE   r2,  [r1]               ; Get our branch
        LDRNE   r14, [r5, r3]           ; Get old data
        STRNE   r2,  [r5, r3]
        STRNE   r14, [r1]
        SUBS    r3, r3, #8
        BPL     %BT10
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Code to be relocated into RAM at initialise time

RelocatedCodeStart ROUT

        GBLA    count
count   SETA    0
        WHILE   count < nbreakpoints
        STR     r14, Registers_ROM+14*4 ; Dump current r14 directly
        BL      ClaimBreak              ; pc relative, into RAM code really
count   SETA    count + 1
        WEND

ClaimBreak
        STR     r14, TrapStore_ROM      ; Save id of breakpoint
        ADR     r14, Registers_ROM
        STMIA   r14, {r0-r12}           ; Save registers 0 to 13 in dump area
        STR     r13, [r14, #13*4]       ; R13 saved seperately due to STM {sp} deprecation :(
        LDR     wp, r12Store_ROM
        LDR     pc, JumpStore_ROM       ; Jump to debugger with correct wp

RelocatedCodeEnd ; End of relocated code - next instruction is a patched branch
                 ; to the debugger

 ASSERT RelocatedCodeEnd-RelocatedCodeStart = BreakCodeEnd-BreakCodeStart

TrapStore_ROM   *       (TrapStore - BreakCodeStart) + RelocatedCodeStart
Registers_ROM   *       (Registers - BreakCodeStart) + RelocatedCodeStart
r12Store_ROM    *       (r12Store  - BreakCodeStart) + RelocatedCodeStart
JumpStore_ROM   *       (JumpStore - BreakCodeStart) + RelocatedCodeStart

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; A breakpoint has been hit

BreakTrap ROUT
        MOV     r4, #0
        MRS     r4, CPSR
        TST     r4, #2_11100
        BNE     BreakTrap32

        SWI     XOS_EnterOS             ; And why not too!

        LDR     r1, TrapStore
        AND     r3, r1, #ARM_CC_Mask    ; Save mode and flags
        BIC     r1, r1, #ARM_CC_Mask
        ADR     r0, BreakCodeStart      ; Calculate Breakpoint number we hit
        SUB     r0, r1, r0
        SUB     r0, r0, #8
        ADR     r1, Breaklist
        LDR     r10, [r1, r0]

        LDRB    r2, SysIs32bit
        TEQ     r2, #0

        ORREQ   r10, r10, r3            ; recombine pc+psr for a 26-bit dump
        STREQ   r10, pc_register

        STRNE   r10, pc_register        ; separate pc+psr for a 32-bit dump
        STRNE   r4, psr_register

        BIC     R10,R10,#ARM_CC_Mask

BreakTrapCommonExit
        BL      message_writes
        DCB     "M44", 0
        ALIGN

        BLVC    DisplayHexWord          ; Tee hee, nowhere to go if VS! <<<
        SWIVC   XOS_NewLine

        BLVC    ShowRegs_Code_Common
        BLVC    Debug_Code_Common

        SWI     XOS_NewLine
        SWI     XOS_Exit


; When we're hit in a 32-bit mode
BreakTrap32

        SWI     XOS_EnterOS             ; And why not too!

        LDR     r1, TrapStore
        ADR     r0, BreakCodeStart      ; Calculate Breakpoint number we hit
        SUB     r0, r1, r0
        SUB     r0, r0, #8
        ADR     r1, Breaklist
        LDR     r10, [r1, r0]

        LDRB    r2, SysIs32bit
        TEQ     r2, #0

        BICEQ   r2, r10, #ARM_CC_Mask   ; keep r10 whole for message
        ANDEQ   r4, r4, #ARM_CC_Mask    ; although we can't put it in the dump
        ORREQ   r2, r2, r4
        STREQ   r2, pc_register         ; combine pc+psr for a 26-bit dump

        STRNE   r10, pc_register        ; separate pc+psr for a 32-bit dump
        STRNE   r4, psr_register

        B       BreakTrapCommonExit


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> string
;       r2 -> error to generate if naff syntax (ie. no p1, trailing op or junk)

GetCommandParms_R0

        MOV     r1, r0

; .............................................................................
; In    r1 -> string
;       r2 -> error to generate if naff syntax (ie. no p1, trailing op or junk)
;       r10 = flags: Command_64bitData => arg2 (if present) must be returned in buffer
;       r11 = buffer to hold 64-bit arg2 data if found

; Decodes string of form <addr|reg> [[+|-] <addr|reg>]

; Out   r9 = parm1
;       r8 = parm state
;       r7 = parm2

hasparm         *       2_001
parmfollowed    *       2_010
secondparm      *       2_100

; a         -> a, X
; a b       -> a, b
; a + b     -> a, a+b
; a - b     -> a-b, a
; a + b + c -> a+b, a+b+c
; a - b + c -> a-b, a-b+c

GetCommandParms Entry "r2"

 [ debug
 DSTRING r1, "Command tail "
        BL      %FT00
 DREG r9, "p1 ",cc
 DREG r7, " p2 ",cc
 DREG r8, " state ",,Byte
        EXIT

00
        Entry
 ]

        MOV     r10, r10, LSL #1        ; only the last parameter can be 64-bit
        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #hasparm
        BEQ     %FT99                   ; [no parm1, so it's bad news]

        MOV     r9, r7                  ; r9 := parm1

        TST     r8, #parmfollowed
        EXIT    EQ                      ; [no parm2]

        ORR     r8, r8, #secondparm

        TEQ     r0, #"+"
        TEQNE   r0, #"-"
        BNE     %FT50

        ORR     r8, r8, r0, LSL #8      ; has '+' or '-', so skip it
        ADD     r1, r1, #1

50
        MOV     r10, r10, LSR #1        ; restore the Command_64bitData flag if appropriate
        BL      ReadParm                ; r7 := parm2
        EXIT    VS

        TST     r8, #hasparm            ; [no second parm when there should be]
        BEQ     %FT99                   ; [ie. after operator]

        MOVS    r14, r8, LSR #8
        BEQ     %FT80                   ; [no operator]

        TEQ     r14, #"+"               ; addition ?
        ADDEQ   r7, r9, r7              ; -> a, a+b
        SUBNE   r14, r9, r7             ; subtraction then
        MOVNE   r7, r9
        MOVNE   r9, r14                 ; -> a-b, a

        TST     r8, #parmfollowed
        EXIT    EQ                      ; [no second operator]

        TEQ     r0, #"+"                ; so we can *mi base -offset1 +offset2
        BNE     %FT99                   ;        or *mi base +offset1 +offset2

        Push    "r7, r14"               ; save r7, first operator
        ADD     r1, r1, #1              ; skip '+'
        BL      ReadParm                ; r7 := parm3
        Pull    "r1, r14"
        EXIT    VS

        TEQ     r14, #"+"               ; it does work, honest ...
        MOVEQ   r9, r1                  ; a, a+b -> a+b, a+b+c
        ADD     r7, r9, r7              ; a-b, a -> a-b, a-b+c

                                        ; and fall into ...

80      TST     r8, #parmfollowed
        EXIT    EQ                      ; [no trailing non-blank muck]


99      LDR     r0, [sp]
        SETV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string
;       r10 = flags: Command_64bitData => arg2 (if present) must be returned in buffer
;       r11 = buffer to hold 64-bit arg2 data if found

; Out   r7 = value of parm
;       r8 = parm state
;       r0 = next ~space char

ReadFirstParm ROUT

        MOV     r8, #0                  ; nowt so far

; .............................................................................

ReadParm Entry "r2"

 [ debug
 DSTRING r1, "ReadParm "
        BL      %FT00
 DREG r7, "parm ",cc
 DREG r8, ", state "
        EXIT

00
        Entry
 ]
        BIC     r8, r8, #hasparm + parmfollowed ; in all cases

        BL      SkipSpaces
        EXIT    LO

        ORR     r0, r0, #&20            ; Cheap and nasty lowercase

        TEQ     r0, #"r"
        BEQ     %FT50                   ; register

        LDRB    r7, SysIs32bit

        TEQ     r0, #"p"
        BNE     %FT20
        MOV     r0, #"c"                ; Expect 'c'
        TEQ     r7, #0
        LDR     r7, pc_register
        BICEQ   r7, r7, #ARM_CC_Mask    ; knock off psr bits for "pc" but not for "r15"
        B       %FT60

20      TEQ     r0, #"l"
        BNE     %FT30
        MOV     r0, #"r"                ; Expect 'r'
        TEQ     r7, #0
        LDR     r7, Registers + 14*4
        BICEQ   r7, r7, #ARM_CC_Mask    ; knock off psr bits for "lr" but not for "r14"
        B       %FT60

30      TEQ     r0, #"s"
        MOVEQ   r0, #"p"                ; Expect 'p'
        LDREQ   r7, Registers + 13*4
        BEQ     %FT60

        TEQ     r0, #"w"
        MOVEQ   r0, #"p"                ; Expect 'p'
        LDREQ   r7, Registers + 12*4
        BEQ     %FT60


40
        TST     r10, #Command_64bitData
        BNE     %FA47
        MOV     r0, #16                 ; allow any term, read hex
        SWI     XOS_ReadUnsigned
        MOVVC   r7, r2

45      EXIT    VS

        BL      SkipSpaces
        ORR     r8, r8, #hasparm
        ORRCS   r8, r8, #parmfollowed
        EXIT

47      Push    "r1,r3,r4"
        MOV     r0, #16
        ORR     r0, r0, #1 :SHL: 28
        LDR     r4, =&45444957
        SWI     XOS_ReadUnsigned        ; do a 64-bit read to r2,r3
        TST     r4, #1 :SHL: 28         ; old OS with no 64-bit read?
        MOVEQ   r0, #16
        LDREQ   r1, [sp]
        MOVEQ   r3, #0
        SWIEQ   XOS_ReadUnsigned        ; then try again, reading a 32-bit number
        STMIA   r11, {r2,r3}
        MOV     r7, #0
        ADD     sp, sp, #4
        Pull    "r3,r4"
        B       %BA45


50      ADD     r1, r1, #1
        MOV     r0, #(2_001 :SHL: 29) + 10 ; allow any term, read decimal, rest
        MOV     r2, #15
        SWI     XOS_ReadUnsigned

        ADRVC   r14, Registers
        LDRVC   r7, [r14, r2, LSL #2]   ; load register n from dump
        TST     r10, #Command_64bitData
        MOV     lr, #0
        STMNEIA r11, {r7,lr}
        B       %BA45


60      LDRB    r14, [r1, #1]
        ORR     r14, r14, #&20          ; Cheap and nasty lowercase
        TEQ     r14, r0                 ; Expected ?
        BNE     %BT40                   ; give error from ReadUnsniged

        TST     r10, #Command_64bitData
        MOV     lr, #0
        STMNEIA r11, {r7,lr}
        ADD     r1, r1, #2              ; skip 'pc'
        B       %BA45                   ; and skip spaces

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string
;       r0 -> error to generate if parmfollowed
;       r10 = flags: Command_64bitData => arg2 (if present) must be returned in buffer
;       r11 = buffer to hold 64-bit arg2 data if found

; Out   r7, r8 from ReadFirstParm

ReadOneParm Entry "r0"

        BL      ReadFirstParm           ; r7 := parm
        EXIT    VS

        TST     r8, #parmfollowed
        LDRNE   r0, [sp]
        SETV    NE
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string

; Out   r0 = first non-space char
;       flags from CMP r0, #space for eol detection. (LO -> r0 = CtrlChar)

SkipSpaces ROUT

10      LDRB    r0, [r1], #1
        CMPS    r0, #space
        BEQ     %BT10
        SUB     r1, r1, #1      ; Leave r1 -> ~space
        MOV     pc, lr          ; r0 = first ~space

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = branch destination
;       r1 = branch location (ie. where it is executed)

; Out   r2 = branch instruction

MakeBranch ROUT

        SUB     r2, r0, r1
        SUB     r2, r2, #8
        MOV     r2, r2, ASR #2
        BIC     r2, r2, #&FF000000
        ORR     r2, r2, #&EA000000      ; BAL instruction
 [ debug
 DREG r0,"Branch instruction to get to ",cc
 DREG r1," from ",cc
 DREG r2," is "
 ]
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r3 = breakpoint number*8

; Out   r2 = instruction
MakeMOVPC ROUT
        LDR     r2, MOVPCInstr
        ADD     r2, r2, r3, LSR #2
        MOV     pc, lr


lookup_r10 Entry r0-r7
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r10
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r10, r2
        EXIT

message_writes
        Entry   r0-r7
        SUB     r0, lr, pc              ; processor independent
        ADD     r0, pc, r0              ; extraction of pc from lr
        SUB     r0, r0, #4
        MOV     r2, r0
10      LDRB    r1, [r2], #1
        TEQS    r1, #0
        BNE     %B10
        SUB     r2, r2, r0
        ADD     r2, r2, #3
        BIC     r2, r2, #3
        ADD     lr, lr, r2
        STR     lr, [sp, #8 * 4]
        B       message_write0_tail

message_write0 Entry r0-r7
message_write0_tail
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMPS    r0, #32
        SWIHS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        EXIT

CopyErrorP1 Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        ADRL    R4,Debug_Title
        B       CopyError0

CopyErrorR2
        MOV     R0,R2

CopyError Entry r1-r7
        BL      open_messagefile
        EXIT    VS
        MOV     R4, #0
CopyError0
        ADR     R1, MessageFile_Block
        ADR     R2, StringBuffer
        MOV     R3, #?StringBuffer
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.Debugger.Messages", 0

        ALIGN

open_messagefile Entry r0-r2
        LDR     r0, MessageFile_Open
        CMPS    r0, #0                  ; clears V
        EXIT    NE
        ADR     R0, MessageFile_Block
        ADR     R1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    [ SupportARMV 
ShowVFPRegs_Code ROUT

        Entry

        LDR     wp, [r12]

        ; Check arguments
        MOV     r1, r0
        BL      SkipSpaces
        BLO     %FT50

        ADD     r1, r1, #1
        LDRB    r2, [r1], #1
        BIC     r0, r0, #32
        CMP     r2, #32
        BGT     %FT99
        TEQ     r0, #"A"                ; A -> at
        BEQ     %FT10
        TEQ     r0, #"E"                ; E -> exception
        BEQ     %FT50
        TEQ     r0, #"C"                ; C -> current
        BNE     %FT99
        SWI     XVFPSupport_ActiveContext
        MOVVC   r1, r0
        BLVC    ShowThisVFPContext
        EXIT

10
        ; Show context at specific address
        BL      SkipSpaces
        BLO     %FT99
        MOV     r0, #16
        SWI     XOS_ReadUnsigned
        MOVVC   r0, r2
        MOVVC   r1, r2
        BLVC    ShowThisVFPContext
        EXIT

50
        ; Show exception context
        MOV     r0, #VFPSupport_ExceptionDump_GetDump+VFPSupport_ExceptionDump_GetContext
        SWI     XVFPSupport_ExceptionDump
        EXIT    VS
        MOV     r2, r0                  ; Remember in case of error
        BL      ShowThisVFPContext
        ; Preseve any error over free call
        SavePSR r3
        MOV     r4, r0
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        RestPSR r3
        MOV     r0, r4
        EXIT

99      ADR     r0, ShowVFPRegs_Error
        BL      CopyError
        EXIT


ShowVFPRegs_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGSVR", 0
        ALIGN


ShowThisVFPContext ROUT
        ; r0 = context
        ; r1 = address to say it came from
        Entry   "r6-r11"

        MOV     r6, r0
        
        BL      message_writes
        DCB     "V00", 0                ; "VFP context &"
        ALIGN

        MOVVC   r10, r1
        BLVC    DisplayHexWord
        SWIVC   XOS_NewLine

        MOVVC   r1, #VFPSupport_ExamineContext_Serialise
        SWIVC   XVFPSupport_ExamineContext
        EXIT    VS

        MOV     r11, r1

        BL      message_writes
        DCB     "V01", 0                ; "Context flags &"
        ALIGN
        MOVVC   r10, r0
        BLVC    DisplayHexWord
        SWIVC   XOS_NewLine
        EXIT    VS

        ; Parse the dump descriptor block
10
        LDR     r0, [r3], #4
        CMP     r0, #-1
        EXIT    EQ
        MOV     r4, r0, LSR #16
        BIC     r0, r0, r4, LSL #16
        CMP     r0, #VFPSupport_Field_FPSCR
        BEQ     %FT20
        CMP     r0, #VFPSupport_Field_FPEXC
        BEQ     %FT30
        CMP     r0, #VFPSupport_Field_FPINST
        ADREQ   r0, fpinst
        BEQ     %FT40
        CMP     r0, #VFPSupport_Field_FPINST2
        ADREQ   r0, fpinst2
        BEQ     %FT40
        CMP     r0, #VFPSupport_Field_FSTMX
        BEQ     %FT50
        CMP     r0, #VFPSupport_Field_RegDump
        BEQ     %FT60
        ; Some unknown field - skip it
        B       %BT10

20
        ; FPSCR display
        ADREQ   r0, FPSCRList
        SWI     XOS_Write0
        LDRVC   r10, [r6, r4]
        BLVC    DisplayHexWord
        EXIT    VS
        MOV     r4, r0
        BL      ShowVFPFlags
        EXIT    VS

        ; Show rounding mode
        ANDVC   r0, r10, #FPSCR_RMODE_MASK
        ADRVC   r1, RMODEList
        ADDVC   r0, r1, r0, LSR #FPSCR_RMODE_SHIFT-2
        BLVC    message_write0
        EXIT    VS
        ; Show vector length & stride
        BL      message_writes
        DCB     "V09", 0                ; "Vector length "
        ALIGN
        EXIT    VS
      [ NoARMT2
        AND     r0, r10, #FPSCR_LEN_MASK
        MOV     r0, r0, LSR #FPSCR_LEN_SHIFT
      |
        ASSERT  FPSCR_LEN_MASK = (7<<FPSCR_LEN_SHIFT)
        UBFX    r0, r10, #FPSCR_LEN_SHIFT, #3
      ]
        AND     r1, r10, #FPSCR_STRIDE_MASK
        ; The only valid encodings are 0 and 3, corresponding to stride 1 and 2
        MOVS    r1, r1, LSR #FPSCR_STRIDE_SHIFT
        TEQNE   r1, #3
        BNE     %FT25
        ; Nonzero stride with zero length is invalid
        TEQ     r1, #3
        TEQEQ   r0, #0
        BEQ     %FT25
        ; Nonzero stride with length field > 3 is invalid
        CMP     r1, #0
        CMPHI   r0, #3
        BHI     %FT25
        ; For double precision operations a nonzero stride with length field > 1 is invalid, but we can't check for that as we don't know what the user's doing
        ADD     r0, r0, #"1"            ; Convert to actual length
        SWI     XOS_WriteC
        EXIT    VS
        BL      message_writes
        DCB     "V10", 0                ; " stride "
        ALIGN
        EORVC   r0, r1, #1+"0"          ; 0 -> "1", 3 -> "2"
        SWIVC   XOS_WriteC
        SWIVC   XOS_WriteI+","

24
        ; Remainder can be handled by ShowVFPFlags
        BLVC    ShowVFPFlags
        BVC     %BT10
        EXIT

25
        BL      message_writes
        DCB     "V02", 0
        ALIGN
        B       %BT24

30
        ; FPEXC display
        ADREQ   r0, FPEXCList
        SWI     XOS_Write0
        LDRVC   r10, [r6, r4]
        BLVC    DisplayHexWord
        EXIT    VS
        MOV     r4, r0
        BL      ShowVFPFlags
        EXIT    VS

        ; Show remaining iterations, but only if field is valid
        ; DEX+VV set or EX set
        TST     r10, #FPEXC_DEX
        TSTNE   r10, #FPEXC_VV
        TSTEQ   r10, #FPEXC_EX
        BEQ     %FT35

        BL      message_writes
        DCB     "V11", 0                ; "Remaining iterations: "
        ALIGN
      [ NoARMT2
        AND     r0, r10, #FPEXC_VECITR_MASK
        MOV     r0, r0, LSR #FPEXC_VECITR_SHIFT
      |
        ASSERT  FPEXC_VECITR_MASK = 7<<FPEXC_VECITR_SHIFT
        UBFX    r0, r10, #FPEXC_VECITR_SHIFT, #3
      ]
        ADD     r0, r0, #"1"
        ASSERT  ("0" :AND: 8)=0
        BIC     r0, r0, #8
        SWI     XOS_WriteC
        SWIVC   XOS_NewLine
        EXIT    VS

35
        BL      ShowVFPFlags
        BVC     %BT10
        EXIT        

40
        SWI     XOS_Write0
        LDRVC   r10, [r6, r4]
        BLVC    DisplayHexWord
        SWIVC   XOS_WriteI+32
        ; The contents of the FPINST registers should be instructions, so let's
        ; be useful and show the disassembly
        MOVVC   r0, r10
        MOVVC   r1, #0
        SWIVC   XDebugger_Disassemble
        MOVVC   r0, r1
        SWIVC   XOS_Write0
        SWIVC   XOS_NewLine
        BVC     %BT10
        EXIT

50
        BL      message_writes
        DCB     "V03", 0                ; "FSTMX format word = "
        ALIGN
        LDRVC   r10, [r6, r4]
        BLVC    DisplayHexWord
        SWIVC   XOS_NewLine
        BVC     %BT10
        EXIT

60
        BL      message_writes
        DCB     "M17", 0
        ALIGN
        ADDVC   r10, r6, r4
        BLVC    DisplayHexWord
        EXIT    VS
        BL      message_writes
        DCB     "M18", 0
        ALIGN
        EXIT    VS
        ; Display register dump as doubleword registers, two columns 
        MOV     r0, #0
        MOV     r1, r10
61
        SWI     XOS_NewLine
62
        EXIT    VS
        CMP     r0, r11
        BNE     %FT63
        TST     r0, #1
        SWINE   XOS_NewLine
        EXIT    VS
        B       %BT10
63
        SWI     XOS_WriteI+"D"
        MOVVC   r8, r0
        BLVC    DisplayDecimalNumber
        EXIT    VS
        CMP     r0, #10
        SWILT   XOS_WriteI+32
        EXIT    VS
        SWI     XOS_WriteS
        DCB     " = &", 0
        ALIGN
        LDR     r10, [r1, #4]
        BL      DisplayHexWord
        LDR     r10, [r1], #8
        BLVC    DisplayHexWord
        EXIT    VS
        ADD     r0, r0, #1
        TST     r0, #1
        BEQ     %BT61
        SWI     XOS_WriteI+32
        B       %BT62

ShowVFPFlags    ROUT
        ; In: R4 -> flags list
        ;     R10 = value
        ; Out: R0 = corrupt or error
        ;      R4 updated
        Entry   "r1,r2,r8"
        MOV     r1, #1
10
        LDRB    r2, [r4], #1
        TEQ     r2, #255
        EXIT    EQ
        TEQ     r2, #254
        BEQ     %FT30
        TEQ     r2, #253
        BEQ     %FT40
20
        LDRB    r0, [r4], #1
        TEQ     r0, #0
        BEQ     %BT10
        TST     r10, r1, LSL r2
        ORREQ   r0, r0, #32
        SWI     XOS_WriteC
        BVC     %BT20
        EXIT

30
        MOV     r0, r4
        BL      message_write0
        ADDVC   r4, r4, #4
        BVC     %BT10
        EXIT

40
        SWI     XOS_NewLine
        BVC     %BT10
        EXIT

        MACRO
        VFPRegBit $bits, $name
        LCLA    bit
        LCLA    mask
mask    SETA    $bits
count   SETA    0
        WHILE   (mask :AND: 1)=0 :LAND: (mask > 0)
mask    SETA    mask :SHR: 1
count   SETA    count + 1
        WEND
        DCB     count
        DCB     "$name"
        DCB     0
        MEND                

FPSCRList
        DCB "FPSCR = ", 0
        DCB 254, "V12", 0 ; "Flags:"
        VFPRegBit FPSCR_N, " N"
        VFPRegBit FPSCR_Z, "Z"
        VFPRegBit FPSCR_C, "C"
        VFPRegBit FPSCR_V, "V"
        VFPRegBit FPSCR_QC, "Q"
        DCB 253
        DCB 254, "V13", 0 ; "Options: "
        DCB 255
        
        VFPRegBit FPSCR_AHP, " AHP"
        VFPRegBit FPSCR_DN, " DN"
        VFPRegBit FPSCR_FZ, " FZ"
        DCB 253
        DCB 254, "V14", 0 ; "Enabled exceptions:"
        VFPRegBit FPSCR_IDE, " ID"
        VFPRegBit FPSCR_IXE, " IX"
        VFPRegBit FPSCR_UFE, " UF"
        VFPRegBit FPSCR_OFE, " OF"
        VFPRegBit FPSCR_DZE, " DZ"
        VFPRegBit FPSCR_IOE, " IO"
        DCB 253
        DCB 254, "V15", 0 ; "Cumulative exceptions:"
        VFPRegBit FPSCR_IDC, " ID"
        VFPRegBit FPSCR_IXC, " IX"
        VFPRegBit FPSCR_UFC, " UF"
        VFPRegBit FPSCR_OFC, " OF"
        VFPRegBit FPSCR_DZC, " DZ"
        VFPRegBit FPSCR_IOC, " IO"
        DCB 253
        DCB 255
        ALIGN

FPEXCList
        DCB "FPEXC = ", 0
        DCB 254, "V12", 0 ; "Flags:"
        VFPRegBit FPEXC_EX, " EX"
        VFPRegBit FPEXC_EN, " EN"
        VFPRegBit FPEXC_DEX, " DEX"
        VFPRegBit FPEXC_FP2V, " FP2V"
        VFPRegBit FPEXC_VV, " VV"
        VFPRegBit FPEXC_TFV, " TFV"
        DCB 253
        DCB 255

        DCB 254, "V16", 0 ; "Pending/potential exceptions:"
        VFPRegBit FPEXC_IDF, " ID"
        VFPRegBit FPEXC_IXF, " IX"
        VFPRegBit FPEXC_UFF, " UF"
        VFPRegBit FPEXC_OFF, " OF"
        VFPRegBit FPEXC_DZF, " DZ"
        VFPRegBit FPEXC_IOF, " IO"
        DCB 253
        DCB 255
        ALIGN

RMODEList
        DCB "V04", 0
        DCB "V05", 0
        DCB "V06", 0
        DCB "V07", 0
        ALIGN

fpinst  DCB "FPINST  = ", 0
        ALIGN
fpinst2 DCB "FPINST2 = ", 0
        ALIGN
    ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Where_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGWHR", 0

Where_UMod
        DCB     "UtilityModule", 0
        ALIGN

Where_Code Entry "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        ADR     r0, Where_Error
        MOV     r10, #0                 ; arguments can only be 32-bit
        BL      ReadOneParm             ; r7 := parm, r8 state
        BLVS    CopyError
        EXIT    VS

        TST     r8, #hasparm
        LDREQ   r7, pc_register         ; Use exception PC if no parms
        LDREQB  r0, SysIs32bit
        TEQEQ   r0, #0
        BICEQ   r7, r7, #ARM_CC_Mask

        BL      message_writes
        DCB     "M15", 0                ; "Address &"
        ALIGN

        MOVVC   r10, r7
        BLVC    DisplayHexWord
        SWIVC   XOS_WriteI+space
        EXIT    VS

        BL      Where_Util
        EXIT    VS

        CMP     r7, #-1
        BNE     %FT85
        ; Say "is <somewhere vague>"
        BL      message_write0
        B       %FT88
85
        ; Say "is at offset &xx in <some area> 'detail'"
        ; => r0 -> area name token
        ;    r7 = offset
        ;    r8 -> detail string
        BL      message_writes
        DCB     "M21", 0
        ALIGN
        MOVVC   r10, r7
        BLVC    DisplayHexWord
        SWIVC   OS_WriteI+space
        BLVC    message_write0
        TEQ     r8, #0                  ; NULL details? V preserved
        BEQ     %FT88

        SWIVC   OS_WriteI+space
        SWIVC   OS_WriteI+"'"
        MOVVC   r0, r8
        SWIVC   OS_Write0
        SWIVC   OS_WriteI+"'"
88
        SWIVC   OS_NewLine
        EXIT


; In:
; r7 = address
; Out:
; r0 -> area name token
; r7 = offset
; r8 -> detail string
; offset is -1 if unsure of location
Where_Util      ROUT
        Entry "r1-r6,r9-r11"
        MOV     r8, #0                  ; No details

        ; Applications sometimes go pop
        MOV     r0, #-1
        SWI     XOS_ReadDynamicArea
        ADD     r2, r2, r0
        CMP     r7, r0
        CMPCS   r2, r7
        SUBHI   r7, r7, r0              ; Offset
        ADRHI   r0, Where_AppSlot       ; In the app slot
        BHI     %FT85

        ; Anything in the MB below UtilityModule is Kernel (might include HAL)
        MOV     r0, #ModHandReason_LookupName
        ADR     r1, Where_UMod
        SWI     XOS_Module
        MOV     r9, r3, LSR #20
        CMP     r7, r9, LSL #20
        CMPCS   r3, r7
        SUBHI   r7, r7, r9, LSL #20
        ADRHI   r0, Where_Kernel        ; In the kernel
        BHI     %FT85

        ; Scan the module chain
        MOV     r1, #0
        MOV     r2, #0
10
        MOV     r0, #ModHandReason_GetNames
        SWI     XOS_Module
        BVS     %FT20

        LDR     r0, [r3, #-4]           ; Load the module size word
        SUB     r0, r0, #4              ; Size word includes itself. Remove that.
        ADD     r0, r3, r0
        CMP     r7, r3
        CMPCS   r0, r7
        ADRHI   r0, Where_Module        ; Is within that module
        SUBHI   r7, r7, r3              ; Offset
        LDRHI   r8, [r3, #Module_TitleStr] 
        ADDHI   r8, r8, r3              ; Detail
        BHI     %FT85
        B       %BT10
20
        ; Perhaps in ROM in a gap not occupied by a module
        MOV     r3, #8
        ORR     r0, r3, #3:SHL:8        ; ROM
        SWI     XOS_Memory
        TEQ     r1, #0
        ORREQ   r0, r3, #5:SHL:8        ; else Soft ROM
        SWIEQ   XOS_Memory

        MUL     r3, r1, r2              ; Amount of ROM
        ADD     r3, r3, r9, LSL #20     ; End of ROM
        CMP     r7, r9, LSL #20
        CMPCS   r3, r7
        SUBHI   r7, r7, r9, LSL #20
        ADRHI   r0, Where_ROM           ; Somewhere in ROM
        BHI     %FT85
30
        ; Dynamic and system areas
        MOV     r0, #20                 ; If this subreason's not supported then
        MOV     r1, r7                  ; it's just a more vague report
        SWI     XOS_DynamicArea
        BVS     %FT40

        CMP     r0, #1                  ; Dynamic area or system area?
        BHI     %FT40

        ADREQ   r0, Where_SysWksp       ; In some system workspace
        BEQ     %FT80

        MOV     r10, r7
        MOV     r0, #2
        SWI     XOS_DynamicArea
        EXIT    VS

        SUB     r7, r10, r3             ; Offset
                                        ; Detail in r8 already
        ADR     r0, Where_DynArea       ; In a dynamic area
        B       %FT85
40
        ; Does is exist at all?
        MOV     r0, r7
        ADD     r1, r7, #4
        SWI     XOS_ValidateAddress
        ADRCS   r0, Where_NotMapped     ; C set, is not RAM
        ADRCC   r0, Where_Unknown       ; Somewhere, but not sure where
80
        MOV     r7, #-1
        MOV     r8, #0
85
        EXIT

Where_Unknown   DCB     "M28", 0 ; vague
Where_NotMapped DCB     "M30", 0 ; vague
Where_ROM       DCB     "M34", 0 ; offset
Where_Module    DCB     "M47", 0 ; offset+detail
Where_AppSlot   DCB     "M88", 0 ; offset
Where_DynArea   DCB     "M89", 0 ; offset+detail
Where_Kernel    DCB     "M95", 0 ; offset
Where_SysWksp   DCB     "M96", 0 ; vague
        ALIGN

; In:
; r0 = address
; r1 -> result buffer (area name, offset, detail string)
        EXPORT  Where_Util_FromC
Where_Util_FromC ROUT
        Entry   "r1,r7,r8,r10"
        SUB     r12, sl, #:INDEX:CRelocOffset
        MOV     r7, r0
        BL      Where_Util
        ADDVS   r0, r0, #4
        MOVVS   r7, #-1
        MOVVS   r8, #0
        FRAMLDR r1
        BVS     %FT50
        MOVS    r10, r0
        BEQ     %FT50
        BL      lookup_r10
        ADDVS   r10, r0, #4 
        MOV     r0, r10
50        
        STMIA   r1, {r0,r7,r8}
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


        LTORG

      [ standalone
declareresourcefsfiles
        Entry "r0"

        BL      Resources
        SWI     XResourceFS_RegisterFiles   ; ignore errors
        CLRV
        EXIT

        IMPORT  Resources
      ]

 [ debug
        InsertDebugRoutines
 ]

        GET     ARM.s
        GET     ARMv6.s
        GET     FP.s
      [ UseCVFPNEON
        GET     CGlue.s
      |
        GET     VFP.s
      ]
        GET     CirrusDSP.s
        GET     Piccolo.s
        GET     XScaleDSP.s
        GET     Thumb.s
        GET     CodeVar.s
        GET     ExceptionDump.s

        END
@


4.39
log
@Add ARMv8 AArch32 disassembly
Opcodes for CRC32/HLT/SEVL/LDA/STL/LDAEX/STLEX and DMB/DSB options.
Makefile:
  Add ARMv8_AArch32 actions and encodings to dis2.
actions/ARMv7,dis2.h:
  Extend the DMS/DSB decoding to warn about ARMv8 specific ones (previously undefined)
ARM.s/ARMv6.s:
  Slot in decode.
CGlue.s/Debugger.s/Messages
  New token for "ARMv8 or later" warnings.

Tested by brute force all 256M instructions in NV space and 256M conditionals, comparing the output against dis2.
Currently missing the new VFP and SIMD opcodes.

Version 1.98. Tagged as 'Debugger-1_98'
@
text
@d705 1
d707 1
d3003 1
d3420 1
@


4.38
log
@Add XScale DSP disassembly
Three instructions, MIA/MAR/MRA, 14 years late.

Version 1.97. Tagged as 'Debugger-1_97'
@
text
@d96 3
d260 1
@


4.37
log
@Split 6k line source file
Move the disassembler bits out of the main debugger module.
Built, but not tested.

Version 1.95. Not tagged
@
text
@d75 3
d97 1
a97 1
Thumbv6         SETL    {TRUE}          ; Don't do Thumbv6 yet until complete
d100 7
a106 1
CirrusDSP       SETL    {FALSE}
d256 1
d3647 3
@


4.36
log
@Build fix
Module_Title->Module_TitleStr from Kernel-5_54.

Version 1.95. Tagged as 'Debugger-1_95'
@
text
@a26 202
; 1.18  SKS     Fixed disassembly of #xx,yy operands
; 1.19  SKS     Fixed disassembly of LSR #32, ASR #32
;               Comment where LDR pc relative comes from
; 1.20  SKS     Fixed fp/coproc disassembly, memoryi/memorya parameters
; 1.21  SKS     Fixed *debug response wrt ESCape
; 1.22  SKS     Fixed memory wrt wrapping at 64M

; ---- Released for Arthur 2.00 ----

; 1.22  TMD 22-Nov-89    Fixed source to assemble again with new headers,
;                        and with new AAsm which objects to DCD rel.sym.
;                        (shouldn't affect object file)
;
; 1.23  AMG 30-Oct-90    Various fixes/enhancements
;                        1. ADR made from ADD/SUB Rn,R15,#nn
;                        2. SWP/SWPB now recognised, with >ARM2 warning
;                        3. LDR/STR and LDF/STF now decode PC relative addressing
;                           in the instruction, not the comment field
;                        4. MRC/MCR to CP15 (ie ARM3 control) are commented
;                        5. Comment position moved in for longer comments
;                        6. Silly code detection and indication added...
;                           a) NV condition code
;                           b) SWI following a CDP
;                           c) MUL Rx,Rx or MUL R15,Rx
;                           d) LDM/STM with ^ and !
;                           e) LDM with ^ - bank switches
;                           f) Use of R8-R14 after a xxxP instruction
; 1.24  ENevill ??-Mar-91
;                        Text extraction, untested I think - AMG
;
; 1.25  AMG 11-Mar-91    Fixed disassembly of ADD rd,R15,rm as an ADR
;                        Change OS_Confirm usage to use EQ flag, not ASCII Y
;
; **** Version 1.24 and 1.25 have not been tested, though the bug fix
;      in 1.25 has been checked using 1.23's source.
;
; 1.26  AMG 12-Mar-91    Altered wacky shift coding to give
;                        ADD R0,R0,#0,ROR #24 instead of
;                        ADD R0,R0,#0,24 which confuses people
;
; **** This version is also untested, but changes made have been checked
;      with 1.23's source again
;
; 1.27  ECN 15-Mar-91    Internationalised
; 1.27  ECN 08-Apr-91    Fixed logic of MCR/MRC disassembly.
;                        Bit 20 = 0 => MCR, = 1 => MRC
;                        Internal ARM datasheet is wrong wrt MCR/MRC
;                        VLSI datasheet and assemblers are correct
; 1.27  ECN 19-Apr-91    Fixed "Enter new value" message in MemoryA

; 1.28  AMG 25-Apr-91    Corrected 'use ! and ^' message in messages file.
;                        Added BadSWI error for unused SWIs and associated
;                          message
;
; 1.29  AMG 10-May-91    Used mask &FC000000 instead of &FC000003 to force
;                        LDR/STR into addressing range since it was
;                          messing up LDRB R0,[PC,#1] disassembly
;
; 1.30  AMG 23-May-91    Use global Bad SWI message.
;                        Sort out Message Token not found for bad syntax
;                          to MEMORYI & MEMORY
;
; 1.31  amg 31-May-91    Change invalid instruction used by InitStore to
;                          &E6000010 - which is still invalid - the old
;                          one, &E1000090, is now a SWP instruction!
;                        Added new FPA  URD and NRM instructions
;
; 1.32  amg 05-Jun-91    Added new FPA  LFM/SFM instructions. While in that
;                          area also fixed a bug where coproc offsets were
;                          treated as a 12 bit number, not an 8 bit one.
;
; 1.33  amg 21-Jun-91    Bugfix: Use Global copy of 'Escape' error message
;
; 1.34  amg 18-Jul-91    Tidy up internationalisation to save some space.
;
; 1.36  ECN 07-Aug-91    Inserted NOP after LDM forcing user bank followed
;                        by access to banked register.
;
; 1.37  amg 26-Nov-91    RP-0512 (hang accessing &3000000 - empty IO slot)
;                        Add address validation as below
;                        &0000000-&1ffffff - Use OS_ValidateAddress
;                        &2000000-&2ffffff - No checks (always present)
;                        &3000000-&33fffff - No access (I/O areas)
;                        &3400000-&3ffffff - Read access only (ROMs)
;                                              (writes=VIDC or MEMC)
;                        MEMORYA will trap interactive mode going into
;                        a read-only/no access area too.
;
; 1.38  amg 24-Jan-92    Repaired non-interactive MEMORYA (RP-0970)
;
; 1.39  amg 13-Apr-92    Revert fix of Rp-0512 to a switchable flag,
;                        off by default

; ---- Released for RISC OS 3.10 ----

; 1.40  TMD 27-Jul-92    Added variant for ARM600 which doesn't wrap
;                        addresses at 64M
;
; 1.41  ECN 10-Aug-93    Internationalised help/syntax messages
;
; 1.42  TMD 27-Oct-93    Fixed bug MED-00167 - coprocessor data transfers to
;                        PC-relative address were disassembled wrong.
; 1.43  TMD 01-Dec-93    Fixed bug MED-01490 - couldn't set breakpoints
;                         above 32MB (eg in RMA!).
; 1.44  amg 23-Jan-94    Catch up on new ARM6/7 opcodes: MRS, MSR, MULL, MLAL and
;                         check conformance with FPA10 spec. Tighten up tests
;                         for MUL/MULL/SWP - now insist b7:b4=2_1001
;                        Add national switch to override internationalised help/syntax

; ---- Released for RISC OS 3.60 ----

; 1.46  WT  07-Feb-96    Made StrongARM compatible (breakpoint code breaks IDcache)
; 1.48  KJB 04-Jun-96    Added ARMv4 instructions (BX, LDR[H|SH|SB], STRH)
;                        SWP wasn't being disassembled
;                        CP15 comments amended to ARMv4
;                        ARM3 warning removed from SWP (after all, MRS,
;                          MULL etc don't have warnings!)

; ---- Released for RISC OS 3.70 ----

; 1.49  KJB 07-Oct-96    Operation code of MRC, MCR was shown times 2.
;                        FLT was showing wrong dest reg, with registers
;                          shown in wrong order.
;                        WFC etc were showing precision.
;                        Unknown FP opcodes now shown as normal coprocessor
;                          operations.
;                        LDC/STC (and FP derivatives) didn't detect
;                          post-indexing with no writeback. Now reported as
;                          undefined instructions.
;                        UMULLEQS no longer pushes registers into the
;                          comment field.
;                        MSR/MRS now specified as described in ARM
;                          Architecture Reference 4.
; 1.50  KJB 10-Oct-96    Lots of warnings added.
;                        More FP opcodes tightened up.
;                        PC-relative load/store with writeback no longer
;                         shown as simple ADR.
;                        Thumb disassembly added.
; 1.51  KJB 29-Oct-96    Bugs introduced by 1.49 and 1.50 fixed.
;                        Warnings added to the LDRH family to match LDC and LDR.
;                        Warning about StrongARM STM^ bug added.
;                        Source code tidied up and simplified with macros.
; 1.52  KJB 06-Nov-96    More bug fixes.
;                        StrongARM warning revised following Digital guidelines.
; 1.53  KJB 11-Nov-96    SWI called checkreg for no apparent reason.
;                        Stopped Addr26 screwing up Thumb disassembly.
;                        Set Addr26 to True.
; 1.54  KJB 27-Mar-98    Test for post-indexed LDRH etc with W set didn't work.
;                        Service call table added.
; 1.55  KJB 08-May-98    Made Addr26 flag only affect disassembly of BL
;                        and use of lr and pc. Addresses are not wrapped
;                        to 64M. This makes sense for our 32-bit ARM in 26-bit
;                        mode.
; 1.57-1.59              Build changes only.
; 1.60  KJB 20-Apr-00    32-bit compatibility added.
;                        New *ShowFPRegs command.
;                        Added ARMv5 instructions (BLX, CLZ, BKPT, CDP2 et al)
;                        Handling of instruction extension space adjusted as
;                        per ARMv4.
;                        Fixed some Thumb instructions.
;                        Added "info" form of LDC and STC
;                        NV condition code is now undefined, except for the
;                        new instructions using it.
; 1.61  KJB 11-Jul-00    ARMv5 warning now shown reliably.
; 1.62  KJB 08-Sep-00    Changed invalid instruction to &E7FFFFFF (as per ARM
;                        recommendation that &E7FxxxFx should be used)
;                        Branch disassembly changed - when running on a
;                        26-bit systems, branch instructions in the lower
;                        64M will be wrapped within 64M, but branches
;                        above 64M will not.
;                        Disassembly of VFP instruction set added.
;                        PC-relative LDRH family instructions calculated
;                        target address incorrectly.
; 1.63  SAR 30-Jan-01    ADDS Rd,PC,#imm (and SUBS) no longer map to ADR.
;                        Unknown SWIs, such as 'User' and 'OS_Undefind' are now
;                        disassembled as 'SWI &num'.
; 1.64  KJB 31-Jan-01    Added ARMv5TE instructions.
;                        Corrected Thumb high ADD/CMP/MOV.
; 1.65  KJB 08-Feb-01    Breakpoints now work on 32-bit systems - it got
;                        confused over which breakpoint was hit.
;                        *MemoryI T now disassembles 24 instructions by default
;                        rather than 48.
; 1.67  KJB 15-Feb-01    QADD etc "corrected" to have operands in Rm,Rn order.
; 1.68  SAR 21-Mar-01    Unknown SWIs displayed as hex.
; 1.70  SAR 21-Mar-01    Wacky shift coding changed back to #0,24 to match
;                        ARM documentation.
; 1.71  KJB 18-Apr-01    Fixed and tidied *ShowFPRegs - in particular will work
;                        correctly with 26-bit FPEmulators.
; 1.72  SAR 28-Apr-01    Introduced the Disassemble$Options code variable to
;                        control various alternatives for disassembly. In
;                        particular, the register name output can now be in
;                        APCS mode(s).
;       MJS 05-May-01    Added P flag to *MemoryX commands to access physical
;                        addresses.
; 1.73  KJB 10-May-01    Fixed warnings on SWP.
;                        Changes to message files to correct syntax errors.
;                        *MemoryX P works on IOMD-based systems if OS_Memory 13
;                        fails.
;                        Changed to use ObjAsm.
;
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

a700 6
; In    r0 = instruction to disassemble
;       r1 = address to disassemble relative to (bug in 1.00 debug did relative
;                                                to module base only !)

; Out   r1 -> core containing string
;       r2 = length of string excluding 0 terminator
d705 1
a705 1
        TEQ     R11,#0 ;only one SWI
d738 1
a738 1
        EXIT                           ; Preserve flags
a747 2851
checkreg
        Entry
        LDR     R14,Mistake
        CMP     R14,#Potential_Banked
        MOVEQ   R14,#Mistake_Banked
        STR     R14,Mistake
        EXIT


; In    r0 = instruction to disassemble
;       r9 = where it is

; Out   r1 -> core containing string
;       r2 = length of string including 0
;       r10,r11 corrupt

Instruction Entry "r0, r3-r9"

        SUB     R4, R9, #4
        LDR     R5, OldAddress
        TEQS    R4, R5
        MOV     R4, #0
        STRNE   R4, Mistake         ;not going in sequence, so forget context
        STR     R9, OldAddress      ;save for next time

        MOV     r4, r0

        ADR     r0, StringBuffer        ; Always build into temp buffer

 [ debug
        MOV     r14, #0                 ; zap buffer
        MOV     r3, #?StringBuffer-4
00      STR     r14, [r0, r3]
        SUBS    r3, r3, #4
        BPL     %BT00
 ]

        ADDS    r14, r4, #1:SHL:28      ;  C := unconditional space
        MOV     r3, r4, LSR #24         ; r3 := primary instruction nibble
        AND     r3, r3, #2_00001111     ; remove condition codes
        BCS     %FT10

        ; arrive here with cccc xxxx xxxx xxxx xxxx xxxx xxxx xxxx
        ; (cccc != 1111)
        TEQS    r3, #&0F
        BEQ     Swi                     ; [software interrupt = 0F]

        CMP     r3, #&0C
        BHS     Coprocessor             ; [coproc 0C..0E]

        CMP     r3, #&0A
        BHS     Branch                  ; [branch = 0A..0B]

        CMP     r3, #&08
        BHS     LdmStm                  ; [load/store multiple = 08,09]

        CMP     r3, #&04
        BHS     LdrStr                  ; [load/store register = 04..07]

        B       DataProcessing          ; [data processing = 00..03]
10
        ; arrive here with 1111 xxxx xxxx xxxx xxxx xxxx xxxx xxxx
        TEQS    r3, #&0F
        BEQ     Undefined               ; [undefined = 0F]

        CMP     r3, #&0E
        BEQ     Co_Operations           ; [coprocessor = 0E]

        CMP     r3, #&0C
        BHS     Co_Transfer             ; [coprocessor = 0C,0D]

        CMP     r3, #&0A
        BHS     BLX_offset              ; [BLX = 0A,0B]

        CMP     r3, #&08                
        BHS     Srs_Or_Rfe              ; [SRS or RFE = 08,09]

        CMP     r3, #&04
        BHS     Preload                 ; [preload = 04..07]

        CMP     r3, #&02
      [ UseCVFPNEON
        BHS     ASIMD                   ; [ASIMD data processing = 02,03]
      |
        BHS     Undefined
      ]

        CMP     r3, #&01
        BEQ     ControlExtension_uncond ; [CPS & SETEND = 01]
        ; Fall through...

; .............................................................................

Undefined
        MOV     r14, #0                 ; Undefined can't have a mistake :)
        STR     r14, Mistake

        ADR     r0, StringBuffer        ; Reset pointer
        ADR     r10, Unknown
        BL      lookup_r10

; .............................................................................
; In    r0 -> buffer to be terminated. registers stacked as for entry
;       r10 -> string to be appended first

SaveStringEnd

        BL      SaveString

; .............................................................................
; In    r0 -> buffer to be terminated. registers stacked as for entry

; Out   r1 -> completed buffer
;       r2 = length of buffer

InstructionEnd

        BL      TestMistakes

        MOV     r14, #0
        STRB    r14, [r0]

        ADR     r1, StringBuffer
        SUBS    r2, r0, r1              ; Clears V flag

        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Software interrupt

        ; arrive here with cccc 1111 xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 1111 nnnn nnnn nnnn nnnn nnnn nnnn
        ;
        ; SWI{cond} <number|name>
        ;
        ; where cccc = condition
        ;       nnnn = number

Swi     LDR     R10, Mistake
        CMP     R10, #Potential_SWICDP
        MOVEQ   R10, #Mistake_SWICDP
        STREQ   R10, Mistake

        AddStr  Swi_Instruction,,conds

        BL      Tab

        MOV     r1, r0
        ADR     r2, StringBuffer+?StringBuffer
        SUB     r2, r2, r1
        BIC     r0, r4, #&FF000000      ; Mask out SWI<cc>
        SWI     XOS_SWINumberToString   ; This may give error (eg. Buffer over)
        BVS     InstructionEnd
        MOV     R3, #24
        BL      unknown_swis
        ADD     r0, r1, r2
        B       InstructionEnd

; Compare the string against 'User' and 'OS_Unknown' with or without the leading 'X'. If
; it matches, dump the SWI number as a string with a preceding '&' into the buffer instead.
;
; Entry...
;   R0 - SWI number
;   R1 - pointer to string
;   R2 - offset to last char of string
;   R3 - number of bits to print in SWI number
; Exit...
;   R0 - corrupted
;   R1 - preserved
;   R2 - offset to last char of string (may be different)
;   R3 - preserved
;   R8 - corrupted
;
unknown_swis
        Entry
        ; Ensure all bytes after the SWI name string up to the next word boundary are zero
        MOV     R14, #0
        ADD     R8, R1, R2
unk_swi_align
        TST     R8, #2_11
        STRNEB  R14, [R8], #1
        BNE     unk_swi_align
        ; Compare this SWI name string against some pre-defined unknown SWI name strings
        ADR     R8, str_user
        BL      strcmp
        ADRNE   R8, str_xuser
        BLNE    strcmp
        ADRNE   R8, str_os_undefined
        BLNE    strcmp
        ADRNE   R8, str_xos_undefined
        BLNE    strcmp
        BEQ     unk_swi_replace
        SUB     R2,R2,#1                ; Adjust to avoid taking the zero byte
        EXIT
        ; Replace the SWI name string with the SWI number decoded as hexadecimal
unk_swi_replace
        MOV     R8, R0
        MOV     R0, R1
        SUB     R2, R3, #4
        BL      StoreHex
        SUB     R2, R0, R1              ; Convert end pointer back to offset
        EXIT

; Compare two word-aligned strings. They *must* be padded with zero or more null bytes after
; the terminator (which must also be null) up to the word boundary.
;
; Entry...
;   R1    - pointer to first string
;   R8    - pointer to second string
; Exit...
;   R1    - preserved
;   R8    - corrupted
;   flags - EQ=match, NE=don't match
strcmp
        Entry   "R0, R1"
strcmp_loop
        LDR     R0, [R1], #4
        LDR     R14, [R8], #4
        TEQ     R0, R14
        BNE     strcmp_exit             ; Conditional Pull is bad on newer ARMs, branch instead
        TST     R0, #&FF000000
        BNE     strcmp_loop
strcmp_exit
        EXIT

        ; Some SWI names indicating that a SWI number was not recognised (in length order)
str_user
        DCB     "User", 0
        ALIGN
str_xuser
        DCB     "XUser", 0
        ALIGN
str_os_undefined
        DCB     "OS_Undefined", 0
        ALIGN
str_xos_undefined
        DCB     "XOS_Undefined", 0
        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Branch, Branch and Link

        ; arrive here with cccc 101x xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 101l oooo oooo oooo oooo oooo oooo
        ;
        ; B{L}{cond} address
        ;
        ; where cccc = condition
        ;          l = Link
        ;          o = 24-bit signed offset (in words)

Branch ROUT

        AddChar "B"
        TestBit 24,"L"

        BL      Conditions

        BL      Tab

        MOV     r4, r4, ASL #8          ; shift offset up to top
BranchCommon
        LDRB    r2, SysIs32bit

        ADD     r8, r9, r4, ASR #6
        ADD     r8, r8, #8              ; pc + 8

        TST     r9, #ARM_Addr_Mask      ; if in bottom 64M, and system is 26 bit
        TEQEQ   r2, #0                  ; then...
        BICEQ   r8, r8, #ARM_Addr_Mask  ; Wrap in 64MByte space for 26-bit
        BEQ     BranchLdrStrCommon

; Check no wrap for 32-bit. Wrap detected by one address being < &10000000
; and one being >= &80000000.

        TST     r8, #&F0000000
        TSTNE   r9, #&F0000000
        BNE     BranchLdrStrCommon      ; EQ if one of the addresses is < &10000000

        ORRS    r2, r8, r9              ; MI if one of the addresses is >= &80000000

        MOVMI   r2, #Mistake_Unpred     ; must have wrapped
        STRMI   r2, Mistake

BranchLdrStrCommon
        MOV     r2, #32-4                 ; (keeping byte offsets)
        BL      StoreHex

        B       InstructionEnd

Unknown DCB     "M00", 0                ; "Undefined instruction"
Swi_Instruction
        DCB     "SWI", 0
Ldm     DCB     "LDM", 0
Stm     DCB     "STM", 0
W_Back  DCB     "!,{", 0
        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load and store multiple

        ; arrive here with cccc 100x xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 100p uswl nnnn rrrr rrrr rrrr rrrr
        ;
        ; <LDM|STM>{cond}<I|D><A|B> Rn{!},register list{^}
        ;
        ; where cccc = condition
        ;          p = Pre-indexing/~Post-indexing
        ;          u = Up/~Down
        ;          s = the ^ bit (transfer user registers, or restore PSR)
        ;          w = Writeback
        ;          l = Load/~Store
        ;       nnnn = Rn
        ;       rrrr = register list
LdmStm ROUT

        ANDS    R5, R4, #&7F00
        BLNE    checkreg                ; error if R8-R14 in list

        ;test for silly conditions - ldm/stm ! and ^ with R15 not in list is bad,
        ;and LDM ^ with R15 not in the list is a deferred bank error

        TestBit 15
        BNE     notbad                  ; R15 in list

        TestBit 22
        BEQ     notbad                  ; not forcing user

        ;case 1 - ! too
        TestBit 21
        MOVNE   r10, #Mistake_PlingHat
        STRNE   r10, Mistake
        BNE     notbad2                 ; don't bother with next test

        ;case 2 - LDM
        TestBit 20
        MOVNE   r10,#Potential_Banked_Next
        STRNE   r10,Mistake
        BNE     notbad2                 ; don't bother with next test

notbad
        ;case 3 - Rn in list with writeback
        TestBit 21
        BEQ     notbad3
        MOV     r10, r4, LSR #16
        AND     r10, r10, #2_1111
        MOV     r14, #1
        MOV     r14, r14, LSL r10
        TSTS    r4, r14
        BEQ     notbad3
        TestBit 20                      ; If it's an STM
        SUBEQ   r14, r14, #1
        TSTEQS  r4, r14                 ; and Rn is lowest in list, then it's okay
        MOVNE   r10,#Mistake_Rninlist
        STRNE   r10,Mistake
        BNE     notbad2

notbad3
        ;case 4 - storing PC
        AND     r14, r4, #1 :SHL: 20 :OR: 1 :SHL: 15
        TEQ     r14, #1 :SHL: 15
        BNE     notbad2
        ; okay, we're storing PC, but complaining about APCS would be boring.
        ; Therefore don't bother whinging about STMFD R13!,{[any R0-R9],R11,R12,R14,PC}
        AND     r14, r4, #2_1111 :SHL: 21
        TEQ     r14, #2_1001 :SHL: 21           ; Check FD, !, and no ^
        ANDEQ   r14, r4, #2_1111 :SHL: 16
        TEQEQ   r14, #13 :SHL: 16               ; Check R13
        ANDEQ   r14, r4, #2_1111110000000000
        TEQEQ   r14,     #2_1101100000000000
        MOVNE   r10,#Mistake_StorePC
        STRNE   r10,Mistake

notbad2
        TestStr 20,Ldm,Stm,conds        ; Load/~Store bit

        TestBit 23,"I","D"              ; Up/~Down bit

        TestBit 24,"B","A"              ; Pre/~Post bit

        MOV     r5, r4, LSR #16         ; Rn
        AND     r5, r5, #2_1111
        TEQS    r5, #15
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake
        BL      Tab_Dis_Register

        TST     r4, #1 :SHL: 21         ; Writeback bit
        ADR     r10, W_Back
        ADDEQ   r10, r10, #1            ; just do ',{'
        BL      SaveString

; Register list

        MOV     r5, #0          ; Current register
 [ WarnSArev2
        MOV     r7, #0          ; Total registers
 ]
        MOV     r8, #0          ; Registers in current group

RegList ADD     r2, r5, #1
        TST     r2, r4, LSR r2
        BCC     Next

        TEQ     r8, #0
        BLNE    AddComma

        BL      Dis_Register
        ADD     r5, r5, #1
 [ WarnSArev2
        ADD     r7, r7, #1
 ]
        TEQS    r5, #16
        BEQ     Xxm_End

        ADD     r2, r5, #1
        TSTS    r2, r4, LSR r2
        MOV     r8, #1
        BCC     Next                    ; If next reg not done, loop

Count   ADD     r8, r8, #1
        ADD     r5, r5, #1              ; Count registers
        TEQS    r5, #16
        BEQ     Group

        ADD     r2, r5, #1
        TSTS    r2, r4, LSR r2
        BCS     Count

; Group or single register

Group   MOV     r6, #","
        CMPS    r8, #3
        MOVHS   r6, #"-"
        STRB    r6, [r0], #1

        SUB     r5, r5, #1
        BL      Dis_Register
 [ WarnSArev2
        ADD     r7, r7, r8
        SUB     r7, r7, #1
 ]

Next    ADD     r5, r5, #1
        TEQS    r5, #16
        BNE     RegList

Xxm_End
        AddChar "}"                     ; end register list

        TestBit 22,"^"                  ; '^' bit

        [ WarnSArev2
        BEQ     InstructionEnd          ; It's not ^
        TestBit 20
        BNE     InstructionEnd          ; It's not a store

        ; If we have more than 1 register in a STM user bank,
        ; then it may fail on early StrongARMs
        CMPS    r7, #1
        MOVHI   r10, #Mistake_STMHat
        STRHI   r10, Mistake
        ]

        B       InstructionEnd

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load or store register

LdrStr  ROUT
        ; Load and Store Word or Byte
        ; arrive here with cccc 01xx xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 010p ubwl nnnn dddd iiii iiii iiii
        ;        or        cccc 011p ubwl nnnn dddd rrrr rtt0 mmmm
        ;
        ; <LDR|STR>{cond}{B}    Rd,[Rn,#offset]{!}
        ;                       Rd,[Rn,{+|-}Rm{,shift}]{!}
        ; <LDR|STR>{cond}{B}{T} Rd,[Rn],#offset
        ;                       Rd,[Rn],{+|-}Rm{,shift}
        ; where cccc = condition
        ;          p = Pre-indexed/~Post-indexed
        ;          u = Up/~Down
        ;          b = Byte/~Word
        ;          w = Writeback (or T bit if post-indexed)
        ;          l = Load/~Store
        ;       nnnn = Rn
        ;       dddd = Rd
        ;      rrrrr = shift amount
        ;         tt = shift type (LSL, LSR, ASR or ROR)
        ;       mmmm = Rm
        ;       iiii = 12-bit unsigned immediate offset

        ; Not totally clear which order these tests should be in, but it
        ; doesn't matter for the time being - this restriction applies to
        ; both LDR and PLD.
        TST     r4, #1 :SHL: 25         ; If Rm and shift and trying Rs
        TSTNE   r4, #1 :SHL: 4          ; then that was xxR Rd,[Rn,Rm,SHF Rs]
        BNE     UndefinedExtension      ; but ARM2 doesn't do that anymore

        TestStr 20,Ldr,Str,conds        ; Load/~Store bit

        MOV     r5, r4, LSR #12         ; Rd
        AND     r5, r5, #2_1111

        TST     r4, #1 :SHL: 22         ; Byte/~Word bit
        BEQ     %FT01

        AddChar "B"
        TEQS    r5, #15
        MOVEQ   r10, #Mistake_BytePC
        STREQ   r10, Mistake
        BEQ     %FT03

1       TEQS    r5, #15
        TSTEQS  r4, #1 :SHL: 20
        MOVEQ   r10, #Mistake_StorePC
        STREQ   r10, Mistake

3       AND     r10, r4, #2_1001 :SHL: 21
        TEQS    r10,     #2_0001 :SHL: 21 ; postincrement with writeback ?
        AddChar "T",EQ                    ; -> T(ranslate)

        BL      Tab_Dis_Register        ; uses r5 from above

        ; Check for writeback LDR/STR with Rd=Rn
        AND     r10, r4, #2_1001 :SHL: 21
        TEQS    r10, #2_1000 :SHL: 21
        BEQ     %FT10                   ; if not writeback, okay

      [ {FALSE}                         ; ARM ARM says nothing about zero
        TestBit 25                      ; offset OK, and it isn't entirely
        BNE     %FT05                   ; logical - KJB
        MOVS    r14, r4, LSL #32-12
        BEQ     %FT10                   ; zero offset, so okay
      ]

5       AND     r14, r4, #2_1111 :SHL: 12
        AND     r10, r4, #2_1111 :SHL: 16
        TEQS    r10, r14, LSL #4
        MOVEQ   r10, #Mistake_RdRn
        STREQ   r10, Mistake

        ; Check for post-indexed LDR/STR with Rm=Rn
10      AND     r14, r4, #2_11000 :SHL: 21
        TEQS    r14, #2_10000 :SHL: 21
        BNE     %FT20
        AND     r14, r4, #2_1111 :SHL: 16
        AND     r10, r4, #2_1111
        TEQS    r10, r14, LSR #16
        MOVEQ   r10, #Mistake_RmRn
        STREQ   r10, Mistake

20
DataTransfer_Common ; for CPDT - address part similar to LDR/STR (no reg index)
        AddChar ","

DataTransfer_Common_NoComma

        ;from 1.23, show resultant LDR/STR Rx,[R15,#nnn] address directly

        MOV     R5,R4,LSR #16
        AND     R5,R5,#15
        TEQ     R5,#15
        BNE     not_rel

        TestBit 21                      ; Writeback bit set?
        MOVNE   r10, #Mistake_PCwriteback
        STRNE   r10, Mistake
        TST     r4, #2_1001 :SHL: 24    ; or post-indexed LDR/STR? (can have post-indexed CPDT without writeback)
        MOVEQ   r10, #Mistake_PCwriteback
        STREQ   r10, Mistake

        ; if immediate offset, pre-indexed, no writeback then it's PC-relative
        AND     r14,R4,#2_11001 :SHL: 21
        TEQS    r14,#2_01000 :SHL: 21
        BNE     not_rel

        MOV     R8,R4,LSL #32-12
        MOV     R8,R8,LSR #32-12

; offset in LDC/STC instructions is a word offset

        TestBit 27                      ; if a coproc data transfer
        MOVNE   r8, r8, LSL #2          ; then multiply offset by 4

        TestBit 23                      ; Up/~Down bit
        SUBEQ   r8, r9, r8              ; Form offset from required address
        ADDNE   r8, r9, r8

        ADD     r8, r8, #8
        B       BranchLdrStrCommon

not_rel
        AddChar "["

        MOV     r5, r4, LSR #16         ; Rn
        BL      Dis_Register

        TestStr 24,Close_B+1,Close_B    ; Pre/~Post bit - just ',' else '],'

        TestBit 25                      ; Shift/~Immediate bit
        BNE     %FT90

; Immediate offset

        AND     r14, r4, #2_1111001 :SHL: 21 ; post-indexed CPDT, no writeback?
        TEQ     r14, #2_1100000 :SHL: 21
        BEQ     CPDT_info

        AddChar "#"

        TestBit 23,,"-"                 ; Up/~Down bit

        MOV     r8, r4, LSL #32-12
        MOV     r8, r8, LSR #32-12      ; r4 & 0x0FFF
        TestBit 27
        MOVNE   r8, r8, LSL #2          ; Word offset if coprocessor
        BL      StoreDecimal

80
        TestBit 24,"]"                 ; Pre/~Post bit
                                       ; [preincrement, so close]

        AND     r10, r4, #2_1001 :SHL: 21
        TEQS    r10,     #2_1001 :SHL: 21 ; preincrement with writeback ?
        AddChar "!",EQ

        B       InstructionEnd

; CPDT info form
CPDT_info
        AddChar "{"
        AND     r8, r4, #&FF
        BL      StoreDecimal
        AddChar "}"
        B       InstructionEnd


; Register offset
90
        TestBit 23,,"-"                 ; Up/~Down bit

        MOV     r5, r4                  ; Rm
        BL      Dis_Register

        BL      ShiftField

        B       %BT80

Ldr     DCB     "LDR", 0
Str     DCB     "STR", 0
Open_B  DCB     ",[", 0
Close_B DCB     "],", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Mull    DCB     "MULL",0
        ALIGN
Mlal    DCB     "MLAL",0
        ALIGN
Mul     DCB     "MUL", 0
Mla     DCB     "MLA", 0
aswp    DCB     "SWP", 0

UndefinedDataProcessing ROUT
        ; Arrive here with cccc 000x xxxx xxxx xxxx xxxx 1xx1 xxxx

        TSTS    R4,#2_11:SHL:5
        TSTEQS  R4,#2_1:SHL:24
        BNE     LoadStoreExtension

ArithmeticExtension
        ; Arrive here with cccc 0000 oooo xxxx xxxx xxxx 1001 xxxx
        AND     R5,R4,#2_1111:SHL:20
        CMP     R5,#2_1000:SHL:20
        BHS     mul_long                ; opcode 8-15 = long multiply

        CMP     R5,#2_0110:SHL:20
        BHI     Undefined               ; opcode 7 = undefined
        BEQ     mul_sub                 ; opcode 6 = multiply with subtract

        CMP     R5,#2_0100:SHL:20
        BHI     Undefined               ; opcode 5 = undefined
        BEQ     maal                    ; opcode 4 = long multiply accumulate accumulate

        ; Multiply + Multiply-with-Accumulate
        ; Arrive here with cccc 0000 00xx xxxx xxxx xxxx 1001 xxxx
        ; Format is        cccc 0000 00as dddd nnnn ssss 1001 mmmm
        ;
        ; MUL{cond}{S} Rd,Rm,Rs
        ; MLA{cond}{S} Rd,Rm,Rs,Rn
        ;
        ; where cccc = condition
        ;          a = Accumulate
        ;          s = Set flags
        ;       dddd = Rd
        ;       nnnn = Rn
        ;       ssss = Rs
        ;       mmmm = Rm

        TestStr 21,Mla,Mul,conds        ; Accumulate bit

        TestBit 20,"S"                  ; Update flags bit

        MOV     r5, r4, LSR #16         ; Rd
        BL      Tab_Dis_Register

        AND     R5,R4,#15               ; Rm
        MOV     R10, R4, LSR #16
        AND     R10,R10,#15
        MOV     R8, R4, LSR #12
        AND     R8, R8, #15
        MOV     R9, R4, LSR #8
        AND     R9, R9, #15

        TEQS    R5, R10
        MOVEQ   R14, #Mistake_RdRm
        STREQ   R14, Mistake

        TEQS    R10, #15
        TEQNES  R8, #15
        TEQNES  R9, #15
        TEQNES  R5, #15
        MOVEQ   R14, #Mistake_R15
        STREQ   R14, Mistake

        BL      Comma_Dis_Register

        MOV     r5, r4, LSR #8          ; Rs
        BL      Comma_Dis_Register

        TestBit 21                      ; MLA has extra operand
        MOVNE   r5, r4, LSR #12         ; Rn
        BLNE    Comma_Dis_Register
        BNE     InstructionEnd

        TST     r4, #2_1111:SHL:12      ; Check Rn=R0 for MUL
        BNE     Undefined

        B       InstructionEnd

mul_long
        ; Multiply long + Multiply-with-Accumulate long
        ; Arrive here with cccc 0000 1xxx xxxx xxxx xxxx 1001 xxxx
        ; Format is        cccc 0000 1uas hhhh llll ssss 1001 mmmm
        ;
        ; <U|S><MULL|MLAL>{cond}{S} RdLo,RdHi,Rm,Rs
        ;
        ; where cccc = condition
        ;          u = Signed/~Unsigned
        ;          a = Accumulate
        ;          s = Set flags
        ;       hhhh = RdHi
        ;       llll = RdLo
        ;       ssss = Rs
        ;       mmmm = Rm

        ;deal with signed/unsigned
        TestBit 22,"S","U"

        ;note: the accumulate works differently here to MUL/MLA
        ;on an accumulating multiply you get Rd+=Rm * Rs, otherwise
        ;you get Rd==Rm * Rs, so wheras MLA uses one more register
        ;than MUL both MULL/MLAL use four registers.

        TestStr 21,Mlal,Mull,conds      ; Accumulate bit

        TestBit 20,"S"                  ; Update flags bit

        ; This stupid opcode can be too long. Will hardly ever happen
        ; so don't increase the tab width (might break some programs).
        ; Instead, just push the registers over one space.
        BL      TabOrPushOver

        MOV     r5, r4, LSR #12         ; RdLo
        AND     r6, r5, #2_1111
        BL      Dis_Register

        MOV     r5, r4, LSR #16         ; RdHi
        AND     r7, r5, #2_1111
        BL      Comma_Dis_Register

        MOV     r5, r4                  ; Rm
        AND     r8, r5, #2_1111
        BL      Comma_Dis_Register

        MOV     r5, r4, LSR #8          ; Rs
        AND     r9, r5, #2_1111
        BL      Comma_Dis_Register

        ; Can't use R15 as any register, unpredictable
        ; if RdLo=RdHi or RdLo=Rm or RdHi=Rm
        LDR     r14, Mistake
        TEQS    r7, r8
        MOVEQ   r14, #Mistake_RdHiRm
        TEQS    r6, r8
        MOVEQ   r14, #Mistake_RdLoRm
        TEQS    r6, r7
        MOVEQ   r14, #Mistake_RdLoRdHi
        TEQS    r6, #15
        TEQNES  r7, #15
        TEQNES  r8, #15
        TEQNES  r9, #15
        MOVEQ   r14, #Mistake_R15
        STR     r14, Mistake

        B       InstructionEnd

swp_type
        ; arrive here with cccc 0001 xxxx xxxx xxxx xxxx 1001 xxxx
        TestBit 23
        BNE     LdrexStrex

swp
        ; Swap register/memory
        ; arrive here with cccc 0001 0xxx xxxx xxxx xxxx 1001 xxxx
        ; format is        cccc 0001 0b00 nnnn dddd 0000 1001 mmmm
        ;
        ; SWP{cond}{B} Rd,Rm,[Rn]
        ;
        ; where cccc = condition
        ;          b = Byte/~Word
        ;       nnnn = Rn
        ;       dddd = Rd
        ;       mmmm = Rm

        TSTS    R4,#2_1111 :SHL: 8
        BNE     Undefined

        TST     R4,#2_11 :SHL: 20
        BNE     Undefined

        AddStr  aswp,,conds
        TestBit 22,"B"

        MOV     r9,r4,LSR #16
        AND     r9,r9,#2_1111           ; Rn

        MOV     R5,R4,LSR #12
        AND     r5,r5,#2_1111           ; Rd
        ; Rd=Rn -> unpredictable
        TEQS    r5,r9
        MOVEQ   r14,#Mistake_RdRn
        STREQ   r14,Mistake
        ; Rd/Rn=R15 -> unpredictable
        TEQS    r5,#15
        TEQNES  r9,#15
        MOVEQ   r14,#Mistake_R15
        STREQ   r14,Mistake
        BL      Tab_Dis_Register

        AND     R5,R4,#2_1111           ; Rm
        ; Rm=Rn -> unpredictable
        TEQS    r5,r9
        MOVEQ   r14,#Mistake_RmRn
        STREQ   r14,Mistake
SwpCommon1
        ; Rm=R15 -> unpredictable
        TEQS    r5,#15
        MOVEQ   r14,#Mistake_R15
        STREQ   r14,Mistake
        BL      Comma_Dis_Register
SwpCommon2
        AddStr  Open_B
        MOV     r5,r9                   ; Rn
        BL      Dis_Register
        AddChar "]"
        B       InstructionEnd

LoadStoreExtension
        ; Arrive here with cccc 000p xxxx xxxx xxxx xxxx 1oo1 xxxx
        ; (poo != 000)
        TSTS    r4, #2_11:SHL:5
        BEQ     swp_type

LdrStrH ; Load and Store Halfword/Doubleword or Load Signed Byte
        ; arrive here with cccc 000x xxxx xxxx xxxx xxxx 1nn1 xxxx
        ; (nn != 00)
        ; format is        cccc 000p uiwl nnnn dddd aaaa 1sh1 bbbb
        ;
        ; LDR{cond}<H|SH|SB|D> Rd,[Rn,<#offset|Rm>]{!}
        ;                      Rd,[Rn],<#offset|Rm>
        ; STR{cond}<H|D>       Rd,[Rn,<#offset|Rm>]{!}
        ;                      Rd,[Rn],<#offset|Rm>
        ; where cccc = condition
        ;          p = Pre-indexed/~Post-indexed
        ;          u = Up/~Down
        ;          i = Immediate/~Register offset
        ;          w = Writeback (must be zero if post-indexed)
        ;          l = Load/~Store
        ;       nnnn = Rn
        ;       dddd = Rd
        ;       aaaa = immediate offset high nibble (if i==1), else 0
        ;          s = Signed/~Unsigned halfword
        ;          h = Halfword/~Signed byte
        ;       bbbb = immediate offset low nibble (if i==1), else Rm

        ; cccc 000x x0xx xxxx xxxx nnnn 1xx1 xxxx is undefined if any of
        ; nnnn are 1.
        TSTS    r4, #1:SHL:22           ; Immediate/~Register offset
        BNE     %F5
        TSTS    r4, #&00000F00
        BNE     Undefined
5
        TSTS    r4, #1:SHL:20           ; Load/~Store
        BNE     %F20
        AND     r5, r4, #&000000F0
        TEQS    r5, #&000000B0
        BEQ     %F20

        ; STRSB or STRSH - actually LDRD+STRD
        TestStr 5,Str,Ldr,conds
        AddChar "D"
        TestBit 12                      ; Must be even-numbered register
        BNE     Undefined

        [ WarnARMv5E
        MOV     r14, #Mistake_ARMv5E
        STR     r14, Mistake
        ]

        AND     r10, r4, #15:SHL:12     ; r10 = Rd << 12

        ; Check for Rd/Rd+1=Rn with writeback
        AND     r14, r4, #2_10010:SHL:20
        TEQS    r14, #2_10000:SHL:20
        BEQ     %F15

        AND     r14, r4, #14:SHL:16
        TEQ     r14, r10, LSL #4
        MOVEQ   r14, #Mistake_RdRn
        STREQ   r14, Mistake

15      ; Check for LDRD with Rd/Rd+1=Rm
        TSTS    r4, #1:SHL:5            ; H clear => LDRD
        TSTEQS  r4, #1:SHL:22           ; I clear => [Rd,Rm]
        ANDEQ   r14, r4, #14
        TEQEQS  r14, r10, LSR #12
        MOVEQ   r14, #Mistake_RdRm
        STREQ   r14, Mistake

        ; Check for LDRD/STRD of R14+PC
        TEQ     r10, #14:SHL:12
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake

        B       %F22

20
        TestStr 20,Ldr,Str,conds
        TestBit 6,"S"
        TestBit 5,"H","B"
        AND     r5, r4, #1:SHL:24 :OR: 1:SHL:21
        TEQS    r5, #1:SHL:21           ; Post-indexed with W set => translated
        BNE     %FT22
        [ WarnARMv6T2
        MOV     r14, #Mistake_ARMv6T2
        STR     r14, Mistake            ; No warnings evaluated in this code path yet
        ]
        AddChar "T"                     ; LDRHT/LDRSBT/LDRSHT/STRHT
        
22      MOV     r5, r4, LSR #12
        BL      TabOrPushOver           ; LDRccSBT & LDRccSHT spill over
        BL      Dis_Register

        ; Check we're not storing/loading PC
        TEQS    r5, #15
        MOVEQ   r10, #Mistake_R15
        STREQ   r10, Mistake
        BEQ     %FT30

        ;
        ; Check for Rd=Rn with writeback
        ;
        AND     r10, r4, #2_10010:SHL:20        ; If pre-indexed and no writeback, then OK
        TEQS    r10, #2_10000:SHL:20
        BEQ     %FT30
        AND     r10, r4, #&F:SHL:16             ; If Rd <> Rn then OK
        TEQS    r5, r10, LSR #16
        BNE     %FT30
      [ {FALSE}
        TSTS    r4, #1:SHL:22                   ; If a register offset, then fail
        BEQ     %FT25
        TSTS    r4, #&F
        TSTEQS  r4, #&F00
        BEQ     %FT30                           ; If an immediate offset of 0, then OK
      ]

25      MOV     r10, #Mistake_RdRn
        STR     r10, Mistake

30      MOV     r5, r4, LSR #16
        AND     r5, r5, #&F
        TEQS    r5, #15
        BNE     not_ldrh_rel

        ;
        ; Check for PC-writeback
        ;
        AND     r10, r4, #2_10010:SHL:20
        TEQS    r10, #2_10000:SHL:20
        MOVNE   r10, #Mistake_PCwriteback
        STRNE   r10, Mistake

        ANDEQ   r10, r4, #2_10110:SHL:20        ; Check P,I and W bits
        TEQEQS  r10, #2_10100:SHL:20            ; Must be pre-indexed,immediate,no writeback
        BNE     not_ldrh_rel

        ; show resultant [LD|ST]R[H|SH|SB] Rd,[PC,#nn] address directly

        AddChar ","
        AND     r8,  r4, #&0000000F
        AND     r10, r4, #&00000F00
        ORR     r8, r8, r10, LSR #4
        TSTS    r4, #1:SHL:23           ; Up/~Down bit
        SUBEQ   r8, r9, r8
        ADDNE   r8, r9, r8
        ADD     r8, r8, #8
        B       BranchLdrStrCommon


not_ldrh_rel

        AddStr  Open_B                  ; ",["

        BL      Dis_Register

        TSTS    r4, #1:SHL:24           ; Pre/~Post bit
        ADRL    r10, Close_B
        ADDNE   r10, r10, #1            ; just ',' else '],'
        BL      SaveString
        TSTS    r4, #1:SHL:22           ; Immediate/~Register bit
        BEQ     ldrstrh_reg

        AddChar "#"
        TestBit 23,,"-"                 ; Up/~Down bit

        AND     r8,  r4, #&0000000F
        AND     r10, r4, #&00000F00
        ORR     r8, r8, r10, LSR #4
        BL      StoreDecimal
        B       %F50

ldrstrh_reg
        TestBit 23,,"-"                 ; Up/~Down bit
        AND     r5, r4, #&F
        BL      Dis_Register

        ; Check for Rm=Rn in register post-indexed case
        AND     r6, r4, #&F :SHL: 16
        TEQS    r5, r6, LSR #16
        TSTEQS  r4, #1:SHL:24
        MOVEQ   r6, #Mistake_RmRn
        STREQ   r6, Mistake

50      TSTS    r4, #1:SHL:24           ; Pre/~Post bit
        BEQ     InstructionEnd

        AddChar "]"

        TestBit 21,"!"                  ; Writeback bit
        B       InstructionEnd

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Preload ROUT
        ; Preload
        ; arrive here with 1111 01xx xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        1111 010h uw01 nnnn 1111 iiii iiii iiii
        ;        or        1111 011h uw01 nnnn 1111 rrrr rtt0 mmmm
        ;
        ; PL<D|I><W> [Rn,#offset]
        ;            [Rn,{+|-}Rm{,shift}]
        ;
        ; where    h = PLD/~PLI hint
        ;          u = Up/~Down
        ;          w = Read/~Write intent
        ;       nnnn = Rn
        ;      rrrrr = shift amount
        ;         tt = shift type (LSL, LSR, ASR or ROR)
        ;       mmmm = Rm
        ;       iiii = 12-bit unsigned immediate offset

      [ UseCVFPNEON
        TestBit 20
        BEQ     ASIMD                   ; ASIMD element or structure load/store
      ]

        LDR     r14, =&F57FF0           ; Bits 8-31 of a group of 16 unconditionals
        TEQ     r14, r4, LSR #8
        BEQ     Maintenance_uncond

        TST     r4, #1:SHL:25
        TSTNE   r4, #1:SHL:4            ; Register form needs bit 4 clear
        BNE     Undefined

        TestBit 24
        [ WarnARMv5E
        MOVNE   r14, #Mistake_ARMv5E
        ]
        [ WarnARMv7
        MOVEQ   r14, #Mistake_ARMv7
        ]
        [ WarnARMv5E :LOR: WarnARMv7
        STR     r14, Mistake
        ]

        AddStr  Pload
        TestBit 24, "D", "I"
        TestBit 22
        AddChar "W",EQ
        [ WarnARMv7MP
        MOVEQ   r14, #Mistake_ARMv7MP
        STREQ   r14, Mistake
        ]
        BL      Tab      ; huw01
        AND     r5, r4, #2_10011:SHL:20
        TEQ     r5,     #2_10001:SHL:20 ; PLD
        TEQNE   r5,     #2_00001:SHL:20 ; PLI
        ORREQ   r4, r4, #1:SHL:24       ; Sidestep PC writeback warning
        ANDEQ   r5, r4, #2_1111:SHL:12
        TEQEQ   r5, #2_1111:SHL:12
        BEQ     DataTransfer_Common_NoComma
        B       Undefined

Pload   DCB     "PL", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data processing opcodes

        ; Arrive here with cccc 00xx xxxx xxxx xxxx xxxx xxxx xxxx
        ; Format is        cccc 000o ooos nnnn dddd rrrr rtt0 mmmm
        ;                  cccc 000o ooos nnnn dddd ssss 0tt1 mmmm
        ;                  cccc 001o ooos nnnn dddd rrrr iiii iiii
        ;
        ; <data op>{cond}{S} Rd,Rn,op2    (0-7,12,14: AND,EOR,SUB,RSB,ADD,ADC,SBC,RSC,ORR,BIC)
        ; <data op>{cond}{S} Rd,op2       (13,15: MOV,MVN)
        ; <compare>{cond}{P} Rn,op2       (8-11: TST,TEQ,CMP,CMN)
        ;
        ;        op2 = #imm
        ;              Rm{,<LSL|LSR|ASR|ROR> <#imm|Rs>}
        ;              Rm,RRX
        ;
        ; where cccc = condition
        ;       oooo = operation
        ;          s = Set flags (required for comparisons)
        ;       nnnn = Rn (0 if not used, 15 signals P flag on compares)
        ;       dddd = Rd (0 if not used)
        ;      rrrrr = rotate/shift amount
        ;         tt = shift type (LSL,LSR,ASR,ROR) (RRX encoded by ROR #0)
        ;   iiiiiiii = immediate
        ;       mmmm = Rm
DataProcessing ROUT

        LDR     r3, =&02000090          ; Data processing op with bit 4 set
        AND     r3, r4, r3              ; -> shift by Rs, but bit 7 set, so
        TEQS    r3, #&90                ; is not defined
        BEQ     UndefinedDataProcessing ; MUL/MLA in here too (and SWP from 1.23)
                                        ; (and MULL/MLAL from 1.44)
                                        ; (and LDRH etc from 1.48)

        MOV     r6, r4, LSR #21         ; r6 := dp opcode
        AND     r6, r6, #2_1111
;Version 1.25 bug fix - only apply ADR to immediate operands
        ;If ADD or SUB, and Rn=15 then call it ADR instead
        TEQS    R6,#2
        TEQNES  R6,#4
        BNE     notADR ;not ADD/SUB

        MOV     R5,R4,LSR #16
        AND     R5,R5,#15
        TEQS    R5,#15
        BNE     notADR ;Rn not R15

        TST     r4, #1 :SHL: 20
        BNE     notADR ;S bit set - not ADR

        TestBit 25                      ; I bit
        BNE     isADR
notADR
        AND     r5, r4, #2_11001 :SHL: 20
        TEQS    r5, #2_10000 :SHL: 20           ; Check for opcodes 8-11 with S clear
        BEQ     ControlExtension

        ADR     r10, OpcTAB
        ADD     r10, r10, r6, LSL #2

        BL      SaveStringConditions

        MOV     r5, r4, LSR #12         ; Rd
        CMP     r6, #&08                ; TEQ,TST,CMP,CMN
        RSBHSS  r14, r6, #&0B
        BLO     %FT10

        ANDS    r5, r5, #2_1111         ; If Rd = pc then xxxP
        BEQ     %FT05
        TEQ     r5, #15
        BNE     Undefined               ; Otherwise check Rd=R0
        AddChar "P"
        MOV     R10, #Potential_Banked_Next
        STR     R10, Mistake            ; potential bank access error

5       BL      Tab
        B       %FT20

10
        TestBit 20,"S"                  ; Update flags bit

        BL      Tab_Dis_Register

        BL      AddComma

        TEQ     r6, #13                 ; MOV
        TEQNE   r6, #15                 ; MVN
        BNE     %FT20
        TSTS    r4, #2_1111 :SHL: 16    ; Check that Rn=R0
        BNE     Undefined
        B       Operand_2

20      MOV     r5, r4, LSR #16         ; Rn
        BL      Dis_Register
        BL      AddComma

Operand_2
        TestBit 25                      ; Immediate bit
        BNE     Immediate

        MOV     r5, r4                  ; Rm
        BL      Dis_Register

        BL      ShiftField
        B       InstructionEnd


Immediate
        AddChar "#"

        MOV     r2, r4, LSR #7
        AND     r2, r2, #2_11110        ; Yes, I really do mean 30, see the book
        AND     r8, r4, #2_11111111
        MOV     r8, r8, ROR r2

        MOVS    r14, r8, LSR #8         ; Does value fit in LSB
        BNE     %FT10
        TEQ     r2, #0                  ; but have a non-zero shift ?
        BNE     WackyShift
10

;Testing for weird shifts, ie representable numbers as <data><no shift> but are in fact <data><shift>
;removed

        CMPS    r8, #10
        BLO     Rem_Number              ; If really simple, just display number
                                        ; ie. 0..9 unambiguous

        MOV     r2, #8-4                ; default is byte
        CMPS    r8, #&100
        MOVHS   r2, #16-4               ; then halfword
        CMPS    r8, #&10000
        MOVHS   r2, #32-4               ; then fullword
        BL      StoreHex

        CMPS    r8, #8192               ; If really big, don't comment on it
        BHS     InstructionEnd          ; May have VSet from CMP!

        BL      Tab                     ; Will also insert '; '

        AddChar "="


Rem_Character
        CMPS    r8, #delete
        CMPNES  r8, #space-1
        BLS     Rem_Number

        CMPS    r8, #&100
        BHS     Rem_Number

        MOV     r10, #quote
        STRB    r10, [r0], #1
        STRB    r8,  [r0], #1
        STRB    r10, [r0], #1
        B       InstructionEnd


Rem_Number
        BL      StoreDecimal
        B       InstructionEnd

;ADR pseudo-op - display address being created instead of the ADD/SUB

isADR
        AddStr  AdrTAB,,conds
        MOV     R5, R4, LSR #12
        BL      Tab_Dis_Register
        BL      AddComma
        MOV     R2, R4, LSR #7
        AND     R2, R2, #2_11110
        AND     R8, R4, #2_11111111
        MOV     r8, r8, ROR r2
        TEQS    R6, #2
        SUBEQ   R8, R9, R8
        ADDNE   R8, R8, R9
        ADD     R8, R8, #8
        MOV     R2, #32-4
        BL      StoreHex
        B       InstructionEnd

CPSR_or_SPSR
        TestBit 22
        ADREQ   R10,cpsr_tab
        ADRNE   R10,spsr_tab
        B       SaveString

ControlExtension
        ; arrive here with cccc 00i1 0xx0 xxxx xxxx xxxx rxxs xxxx
        ; (irs != 011)
        ;
        ; This was simple when it was just MRS and MSR, but
        ; ARMv5 and 5E have made it much harder. The approach we
        ; take is to first split between register and immediate,
        ; then split the register form up by bits 4:7.

        TestBit 25
        BNE     ControlExtension_immediate

        ANDS    r5, r4, #2_1111 :SHL: 4         ; 0 = MRS/MSR
        BEQ     MRS_MSR_reg

        CMP     r5, #2_0011 :SHL: 4             ; 1,2,3 = CLZ/BX
        BLS     CLZ_BX_type

        TEQ     r5, #2_0101 :SHL: 4             ; 5 = QADD etc
        BEQ     SaturatingArithmetic

        TEQ     r5, #2_0110 :SHL: 4             ; 6 = ERET
        BEQ     is_ERET

        TEQ     r5, #2_0111 :SHL: 4             ; 7 = BKPT, HVC, SMI
        BEQ     MonitorCalls

        CMP     r5, #2_1000 :SHL: 4             ; 2,4 undefined
        BLO     Undefined

        TST     r5, #2_0001 :SHL: 4             ; 8,10,12,14 = SMUL etc
        BEQ     Mul16

        B       Undefined                       ; 9,11,13,15 undefined

ControlExtension_immediate
        ; arrive here with cccc 0011 0xx0 xxxx xxxx xxxx xxxx xxxx
        TST     r4, #2_1011:SHL:20
        BEQ     Move_imm16

        LDR     r3, =1:SHL:21 + 2_1111:SHL:12
        AND     r5, r4, r3
        TEQ     r5, r3
        BNE     Undefined
        TST     r4, #2_01001111:SHL:16
        BNE     MSR_immediate
        B       Hints

MRS_MSR_reg
        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 0000 xxxx
        TestBit 21
        BNE     MSR_reg

is_MRS  ; arrive here with cccc 0001 0x00 xxxx xxxx xxxx 0000 xxxx
        ;
        ; format is        cccc 0001 0r00 1111 dddd 0000 0000 0000
        ;
        ; MRS{cond} Rd, <CPSR|SPSR>
        ; where cccc = condition
        ;          r = 1 for SPSR, 0 for CPSR
        MOVS    r5, r4, LSL #20            ; bottom 12 bits should be 0
        BEQ     %FT10
        TEQ     r5, #2_10:SHL:(8+20)
        TEQNE   r5, #2_11:SHL:(8+20)
        BEQ     MRS_banked
        B       Undefined
10
        AND     r14, r4, #2_1111 :SHL: 16  ; bits 16-19 should be 1
        TEQS    r14, #2_1111 :SHL: 16
        BNE     Undefined

        AddStr  MrsTAB,,conds
        MOV     r5, r4, LSR #12
        BL      Tab_Dis_Register           ; Rd
        BL      AddComma
        BL      CPSR_or_SPSR
        B       InstructionEnd

OpcTAB  DCB     "AND",0
        DCB     "EOR",0
SubTAB  DCB     "SUB",0
        DCB     "RSB",0
AddTAB  DCB     "ADD",0
        DCB     "ADC",0
        DCB     "SBC",0
        DCB     "RSC",0
        DCB     "TST",0
        DCB     "TEQ",0
        DCB     "CMP",0
        DCB     "CMN",0
        DCB     "ORR",0
        DCB     "MOV",0
        DCB     "BIC",0
        DCB     "MVN",0

cpsr_tab DCB    "CPSR",0
spsr_tab DCB    "SPSR",0
BxTAB   DCB     "BX", 0
BxjTAB  DCB     "BXJ",0
        ALIGN

AdrTAB  DCB     "ADR",0
        ALIGN

MSR_reg ; arrive here with cccc 0001 0x10 xxxx xxxx xxxx 0000 xxxx
        TST     r4, #2_11111111:SHL:4 ; if register, bits 4-11 must be 0
        BEQ     %FT01
        AND     r5, r4, #2_11111110:SHL:8
        TEQ     r5, #2_11110010:SHL:8
        BEQ     MSR_banked
        B       Undefined

MSR_immediate
01      ; arrive here with cccc 0001 0x10 xxxx xxxx 0000 0000 xxxx
        ;               or cccc 0011 0x10 xxxx 1111 xxxx xxxx xxxx
        ;
        ; format is        cccc 0001 0r10 fsxc 1111 0000 0000 mmmm
        ;        or        cccc 0011 0r10 fsxc 1111 rrrr iiii iiii
        ; MSR{cond} <CPSR|SPSR>_<fields>, Rm
        ; MSR{cond} <CPSR|SPSR>_<fields>, #imm
        ;
        ; where cccc = condition
        ;          r = 1 for SPSR, 0 for CPSR
        ;       fsxc = field mask bits
        ;       rrrr = rotate amount (/2)
        ;       iiii = immediate
        ;       mmmm = Rm
05      ADR     r10, MsrTAB
        BL      SaveStringConditions
        BL      Tab
        BL      CPSR_or_SPSR
        AddChar "_"
        TestBit 16,"c"
        TestBit 17,"x"
        TestBit 18,"s"
        TestBit 19,"f"
        BL      AddComma
        B       Operand_2

CLZ_BX_type
        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 00xx xxxx
        TestBit 22
        BNE     is_CLZ

is_BX   ; arrive here with cccc 0001 00x0 xxxx xxxx xxxx 00la xxxx  (la != 00)
        ;
        ; format is        cccc 0001 0010 1111 1111 1111 00l1 mmmm
        ;
        ; B{L}X{cond} Rm
        ;
        ; where cccc = condition
        ;          l = Link
        ;       mmmm = Rm
        LDR     r3, =&002FFF00
        AND     r5, r4, r3
        TEQ     r5, r3
        BNE     Undefined

        TestBit 4
        BEQ     is_BXJ

        TestStr 5,BlxTAB,BxTAB,conds
        AND     R5,R4,#2_1111
        BL      Tab_Dis_Register

        [ WarnARMv5
        TestBit 5
        MOVNE   r10, #Mistake_ARMv5
        STRNE   r10, Mistake
        ]

        B       InstructionEnd

is_BXJ  ; arrive here with cccc 0001 0010 1111 1111 1111 0010 xxxx
        ; format is        cccc 0001 0010 1111 1111 1111 0010 mmmm
        ;
        ; BXJ{cond}   Rm
        ;
        ; where cccc = condition
        ;       mmmm = Rm
        AddStr  BxjTAB,,conds
        AND     R5,R4,#2_1111
        BL      Tab_Dis_Register
        B       InstructionEnd

BLX_offset
        ; arrive here with 1111 101x xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        1111 101h oooo oooo oooo oooo oooo oooo
        ;
        ; BLX address
        ;
        ; where    h = bit 1 of offset
        ;          o = signed offset (bits 25-2)
        [ WarnARMv5
        MOV     r10, #Mistake_ARMv5
        STR     r10, Mistake
        ]

        ADR     r10, BlxTAB
        BL      SaveString
        BL      Tab

        MOVS    r4, r4, ASL #8          ; shift offset up to top (bit 1 into C)
        ADDCS   r4, r4, #1 :SHL: 7      ; put bit 1 underneath
        B       BranchCommon


is_CLZ  ; arrive here with cccc 0001 01x0 xxxx xxxx xxxx 00xx xxxx
        ;
        ; format is        cccc 0001 0110 1111 dddd 1111 0001 mmmm
        ;
        ; CLZ{cond} Rd, Rm
        ;
        ; where cccc = condition
        ;       dddd = Rd
        ;       mmmm = Rm
        LDR     r3, =&002F0F10
        TestBit 5
        BNE     Undefined
        AND     r5, r4, r3
        TEQ     r5, r3
        BNE     Undefined

        [ WarnARMv5
        MOV     r10, #Mistake_ARMv5
        STR     r10, Mistake
        ]

        ADR     r10, ClzTAB
        BL      SaveStringConditions
        MOV     r5, r4, LSR #12
        BL      Tab_Dis_Register
        MOV     r5, r4
        BL      Comma_Dis_Register
        B       InstructionEnd

MonitorCalls
        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 0111 xxxx
        ;
        ; format is        cccc 0001 0oo0 xxxx xxxx xxxx 0111 xxxx
        ;
        ; where oo = op per DDI 0406C, A5.2.12
        ANDS    r5, r4, #2_11:SHL:21
        BEQ     Undefined               ; 00 undefined still

        TEQ     r5, #2_11:SHL:21
        BEQ     is_SMC                  ; 11 (SMC)
        ; Fall through                  ; 01 (BKPT) and 10 (HVC)

BKPT_or_HVC
        ; arrive here with cccc 0001 0qq0 xxxx xxxx xxxx 0111 xxxx
        ; (qq != 00, qq != 11)
        ;
        ; format is        1110 0001 0qq0 nnnn nnnn nnnn 0111 nnnn
        ;
        ; BKPT <number>
        ; HVI  <number>
        ;
        ; where nnnn = number
        ;         qq = qualifier (01 = BKPT, 10 = HVC)
        AND     r5, r4, #2_1111:SHL:28
        TEQ     r5, #2_1110:SHL:28
        BNE     Undefined               ; Note conditional is unpredictable

        TestBit 22
        [ WarnARMv5
        MOVEQ   r10, #Mistake_ARMv5
        ]
        [ WarnARMv7VE
        MOVNE   r10, #Mistake_ARMv7VE
        ]
        [ WarnARMv5 :LOR: WarnARMv7VE
        STR     r10, Mistake
        ]

        TestStr 22,HvcTAB,BkptTAB
        BL      Tab

        MOV     r8, r4, LSR #8
        MOV     r8, r8, LSL #20
        AND     r5, r4, #2_1111
        ORR     r8, r5, r8, LSR #16
        MOV     r2, #16-4
        BL      StoreHex
        B       InstructionEnd

BkptTAB DCB     "BKPT",0
HvcTAB  DCB     "HVI",0
        ALIGN
        
SaturatingArithmetic
        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 0101 xxxx
        ; format is        cccc 0001 0ds0 nnnn dddd 0000 0101 mmmm
        ;
        ; Q{D}<ADD|SUB>{cond} Rd, Rm, Rn
        ;
        ; where cccc = condition
        ;          d = Double
        ;          s = Subtract/~Add
        ;       nnnn = Rn
        ;       dddd = Rd
        ;       mmmm = Rm

        TST     r4, #2_1111:SHL:8
        BNE     Undefined

        [ WarnARMv5E
        MOV     r14, #Mistake_ARMv5E
        STR     r14, Mistake
        ]

        AND     r14, r4, #15:SHL:16
        TEQ     r14, #15:SHL:16
        ANDNE   r14, r4, #15:SHL:12
        TEQNE   r14, #15:SHL:12
        ANDNE   r14, r4, #15
        TEQNE   r14, #15
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake

        AddChar "Q"
        TestBit 22,"D"
        TestStr 21,SubTAB,AddTAB,conds
        MOV     r5, r4, LSR #12
        BL      Tab_Dis_Register
        MOV     r5, r4
        BL      Comma_Dis_Register
        MOV     r5, r4, LSR #16
        BL      Comma_Dis_Register
        B       InstructionEnd

Mul16   ROUT
        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 1xx0 xxxx
        ; format is        cccc 0001 0oo0 dddd nnnn ssss 1yx0 mmmm
        ;
        ; SMLA<B|T><B|T>{cond}  Rd, Rm, Rs, Rn       op = 0
        ; SMLAW<B|T>{cond}      Rd, Rm, Rs, Rn       op = 1, x = 0
        ; SMULW<B|T>{cond}      Rd, Rm, Rs           op = 1, x = 1
        ; SMLAL<B|T><B|T>{cond} RdLo, RdHi, Rm, Rs   op = 2
        ; SMUL<B|T><B|T>{cond}  Rd, Rm, Rs           op = 3
        ;
        ; where cccc = condition
        ;         oo = operation
        ;       dddd = Rd or RdHi
        ;       nnnn = Rn or RdLo
        ;       ssss = Rs
        ;          y = Top/~Bottom of Rs
        ;          x = Top/~Bottom of Rm
        ;       mmmm = Rm

        AND     r7, r4, #2_11:SHL:21    ; r7 = oo (<< 21)
        TestBit 5
        ORRNE   r6, r7, #1:SHL:20       ; r6 = oox (<< 20)
        MOVEQ   r6, r7
        ADR     r10, Mul16TAB
        ADD     r10, r10, r6, LSR #17
        SUB     r10, r10, r6, LSR #20   ; r10 = Mul16TAB + 7 * oox
        BL      SaveString
        TestBit 6,"T","B"
        BL      Conditions

        TEQ     r6, #2_011:SHL:20
        TEQNE   r7, #2_11 :SHL:21
        BNE     %FT10
        TST     r4, #2_1111:SHL:12      ; Check Rn field is 0 for SMUL
        BNE     Undefined
10
        [ WarnARMv5E
        MOV     r14, #Mistake_ARMv5E
        STR     r14, Mistake
        ]

        BL      TabOrPushOver

        TEQ     r7, #2_10 :SHL:21       ; EQ if SMLAL
        BNE     %FT15

        MOV     r5, r4, LSR #12
        AND     r8, r5, #15
        BL      Dis_Register            ; RdLo
        MOV     r5, r4, LSR #16
        AND     r9, r5, #15
        BL      Comma_Dis_Register      ; RdHi

        TEQ     r8, r9
        MOVEQ   r14, #Mistake_RdLoRdHi
        STREQ   r14, Mistake
        B       %FT17

15      MOV     r5, r4, LSR #16
        BL      Dis_Register            ; Rd

17      MOV     r5, r4
        BL      Comma_Dis_Register      ; Rm
        MOV     r5, r4, LSR #8
        BL      Comma_Dis_Register      ; Rs

        CMP     r6, #2_010:SHL:20
        MOVLS   r5, r4, LSR #12
        BLLS    Comma_Dis_Register      ; Rn

        AND     r14, r4, #15:SHL:16
        TEQ     r14, #15:SHL:16
        ANDNE   r14, r4, #15:SHL:12
        TEQNE   r14, #15:SHL:12
        ANDNE   r14, r4, #15:SHL:8
        TEQNE   r14, #15:SHL:8
        ANDNE   r14, r4, #15
        TEQNE   r14, #15
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake

        B       InstructionEnd


MrsTAB  DCB     "MRS",0
MsrTAB  DCB     "MSR",0
BlxTAB  DCB     "BLX",0
ClzTAB  DCB     "CLZ",0
Mul16TAB
        DCB     "SMLAB",0,0
        DCB     "SMLAT",0,0
        DCB     "SMLAW",0,0
        DCB     "SMULW",0,0
        DCB     "SMLALB",0
        DCB     "SMLALT",0
        DCB     "SMULB",0,0
        DCB     "SMULT",0
        ALIGN

Ldc     DCB     "LDC", 0
Stc     DCB     "STC", 0
Cdp     DCB     "CDP", 0
Mcr     DCB     "MCR", 0
Mrc     DCB     "MRC", 0
Cp      DCB     "CP", 0
Mcrr    DCB     "MCRR", 0
Mrrc    DCB     "MRRC", 0

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Coprocessor
        ; Coprocessor operations
        ; arrive here with cccc 11nn xxxx xxxx xxxx xxxx xxxx xxxx
        ; with nn <> 11

        MOV     r2, r4, LSR #28         ; No currently known coprocessors use "2" opcodes
        TEQ     r2, #15
        BEQ     Coprocessor_NotFP

        AND     r2, r4, #2_1111 :SHL: 8 ; r2 := CP# << 8

        TEQS    r2, #1 :SHL: 8
        BEQ     Floating_Point          ; [Floating Point coprocessor]

        TEQS    r2, #2 :SHL: 8
        BEQ     New_FPA                 ;new FPA

        TEQS    r2, #10 :SHL: 8
        TEQNES  r2, #11 :SHL: 8
        BEQ     VFP

 [ CirrusDSP
        CMPS    r2, #4 :SHL: 8
        BLO     Coprocessor_NotFP
        CMPS    r2, #6 :SHL: 8
        BLS     CirrusDSPInstruction
 ]

Coprocessor_NotFP

; Currently unknown coprocessor

        TEQS    r3, #&0E
        BEQ     Co_Operations

Co_Transfer

        ; arrive here with cccc 110x xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 110p unwl nnnn dddd #### iiii iiii
        ;
        ; <LDC|STC>{cond}{L} CP#,Cd,[Rn,#imm]{!}
        ;                    CP#,Cd,[Rn],#imm
        ;                    CP#,Cd,[Rn],{info}
        ; <LDC|STC>2{L}      ...
        ;
        ; where cccc = condition
        ;          p = Pre-indexed/~Post-indexed
        ;          u = Up/~Down
        ;          n = Transfer length
        ;          w = Writeback
        ;          l = Load/~Store
        ;       nnnn = Rn
        ;       dddd = Cd
        ;       #### = CP#
        ;       iiii = immediate offset (in words), or info (puw = 010)

; Coprocessor Data Transfer (CPDT)

        TST     r4, #2_1101 :SHL: 21
        BEQ     CoprocessorExtension    ; Post-indexed, down, no writeback

        TestStr 20,Ldc,Stc,conds,2      ; Load/~Store bit

        TestBit 22,"L"                  ; Length bit

        BL      Tab_CPN                 ; CP#

        MOV     r5, r4, LSR #12         ; CRd
        BL      Dis_C_Register

CPDT_Common                             ; FP entry point from below

        BIC     r3, r3, #2_1000         ; Make like a normal data transfer
                                        ; 0C,0D -> 04,05 (STC,LDC -> STR,LDR)
        BIC     r4, r4, #&00000F00      ; Clear CP# field
        B       DataTransfer_Common

CoprocessorExtension
        ; arrive here with cccc 1100 0x0x xxxx xxxx xxxx xxxx xxxx
        TestBit 22
        BEQ     Undefined

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Coprocessor Double Register Transfer (CPRRT)

CPRRT
        ; arrive here with cccc 1100 010x xxxx xxxx xxxx xxxx xxxx
        ; format is        cccc 1100 010l nnnn dddd #### oooo mmmm
        ;
        ; <MCRR|MRRC>{cond} CP#,op,Rd,Rn,Cm
        ; <MCRR|MRRC>2      CP#,op,Rd,Rn,Cm
        ;
        ; where cccc = cond
        ;          l = Load/~Store (ie load from coprocessor)
        ;       nnnn = Rn
        ;       dddd = Rd
        ;       #### = CP#
        ;       oooo = operation
        ;       mmmm = Cm

        [ WarnARMv5E
        MOV     r14, #Mistake_ARMv5E
        STR     r14, Mistake
        ]
        TestStr 20,Mrrc,Mcrr,conds,2
        CMP     r4, #2_1111:SHL:28
        [ WarnARMv6
        MOVCS   r14, #Mistake_ARMv6
        |
        MOVCS   r14, #0                 ; Splat the default ARMv5 '2' warning
        ]
        STRCS   r14, Mistake
        BL      Tab_CPN
        MOV     r8, r4, LSR #4
        AND     r8, r8, #2_1111
        BL      StoreDecimal
        BL      AddComma
        BL      Dis_RdRn
        BL      AddComma
        MOV     r5, r4
        BL      Dis_C_Register
        B       InstructionEnd

; Disassemble Rd and Rn for CPRRT instructions
Dis_RdRn Entry
50      MOV     r5, r4, LSR #12
        AND     r6, r5, #2_1111
        BL      Dis_Register
        MOV     r5, r4, LSR #16
        AND     r7, r5, #2_1111
        BL      Comma_Dis_Register
        TestBit 20
        BEQ     %FT10
        TEQ     r6, r7
        MOVEQ   r14, #Mistake_RdRn
        STREQ   r14, Mistake
10      TEQ     r6, #15
        TEQNE   r7, #15
        MOVEQ   r14, #Mistake_R15
        STREQ   r14, Mistake
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Co_Operations

        ; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxxx xxxx

        TestBit 4               ; Transfer/~Operation bit
        BNE     Co_Transfers

; Coprocessor Data Operation (CPDO)
        ; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxx0 xxxx
        ; format is        cccc 1110 oooo nnnn dddd #### iii0 mmmm
        ;
        ; CDP{cond} CP#,op,Cd,Cn,Cm{,info}
        ; CDP2      CP#,op,Cd,Cn,Cm{,info}
        ;
        ; where cccc = cond
        ;       oooo = operation
        ;       nnnn = Cn
        ;       dddd = Cd
        ;       #### = CP#
        ;        iii = info
        ;       mmmm = Cm

        MOV     R10, #Potential_SWICDP_Next ;deferred warning in case SWI next
        STR     R10, Mistake

        AddStr  Cdp,,conds,2

        BL      Tab_CPN                 ; CP#

        MOV     r8, r4, LSR #20         ; CPOpc
        AND     r8, r8, #2_1111         ; All of nibble for CPDO
        BL      StoreDecimal_Comma

        MOV     r5, r4, LSR #12         ; CRd
        BL      Dis_C_Register_Comma

CPRT_CPDO_Common

        MOV     r5, r4, LSR #16         ; CRn
        BL      Dis_C_Register_Comma

        MOV     r5, r4                  ; CRm
        BL      Dis_C_Register

        MOV     r8, r4, LSR #5          ; CP
        ANDS    r8, r8, #2_111          ; non-zero ?
        BLNE    AddComma
        BLNE    StoreDecimal

        ;if MRC/MCR check for system control coprocessor and comment accordingly

        TestBit 4                       ; Transfer/~Operation bit
        BEQ     InstructionEnd

        AND     R5,R4,#&F00
        TEQS    R5,#&F00
        BNE     InstructionEnd          ; Not CP15

        AND     R5,R4,#&F0000
        TEQS    R5,#&40000
        BEQ     InstructionEnd
        CMPS    R5,#&80000
        BHI     InstructionEnd

        BL      Tab

        ADR     R10,msgtable
        ADD     R10,R10,R5,LSR #14
        BL      lookup_r10
        B       SaveStringEnd


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Coprocessor Register Transfer (CPRT)

Co_Transfers
        ; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxx1 xxxx
        ; format is        cccc 1110 oool nnnn dddd #### iii1 mmmm
        ;
        ; <MCR|MRC>{cond} CP#,op,Rd,Cn,Cm{,info}
        ; <MCR|MRC>2      CP#,op,Rd,Cn,Cm{,info}
        ;
        ; where cccc = cond
        ;        ooo = operation
        ;          l = Load/~Store (ie load from coprocessor)
        ;       nnnn = Cn
        ;       dddd = Rd
        ;       #### = CP#
        ;        iii = info
        ;       mmmm = Cm

        TestStr 20,Mrc,Mcr,conds,2      ; Load/~Store bit

        BL      Tab_CPN                 ; CP#

        MOV     r8, r4, LSR #21         ; CPOpc
        AND     r8, r8, #2_111          ; Only three bits for CPRT
        BL      StoreDecimal_Comma

        MOV     r5, r4, LSR #12         ; Rd (ARM register)
        BL      Dis_Register
        BL      AddComma

        B       CPRT_CPDO_Common

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Tab_CPN Entry

        BL      Tab

        AddStr  Cp

        MOV     r8, r4, LSR #8
        AND     r8, r8, #2_1111
        BL      StoreDecimal_Comma      ; CP#
        EXIT

        LTORG

msgtable
msg0    = "M02",0       ; CP15,C0 : ARMv4 ID
msg1    = "M03",0       ; CP15,C1 : ARMv4 Control
msg2    = "M04",0       ; CP15,C2 : ARMv4 Translation Table
msg3    = "M05",0       ; CP15,C3 : ARMv4 Domain Access Control
msg4    = "M08",0       ; CP15,C4 : ARMv4 - Bad register
msg5    = "M06",0       ; CP15,C5 : ARMv4 Fault Status
msg6    = "M07",0       ; CP15,C6 : ARMv4 Fault Address
msg7    = "M51",0       ; CP15,C7 : ARMv4 Cache Operations
msg8    = "M52",0       ; CP15,C8 : ARMv4 TLB Operations


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

WackyShift
        AND     r8, r4, #&FF            ; Get unrotated byte back
        MOV     r2, #8-4                ; Display unrotated byte,decimal rotate
        BL      StoreHex

        AddChar ","

        MOV     r8, r4, LSR #7          ; Extract shift part again
        AND     r8, r8, #30
        B       Rem_Number

ShiftField ROUT

        MOV     r2, r4, LSR #4
        ANDS    r2, r2, #&FF            ; LSL #0 -> no shift at all
        MOVEQ   pc, lr

        Entry

        TEQ     r2, #2_00000110         ; ROR #0 -> RRX
        BEQ     %FT80

        AND     r1, r2, #2_00000110     ; Each is 6 chars long
        ADR     r10, ShiftTypes
        ADD     r10, r10, r1, LSL #1
        ADD     r10, r10, r1
        BL      SaveString

        TST     r2, #2_00000001
        BNE     %FT50                   ; [, SHF Rs]

; Shift number

        AddChar "#"

        MOVS    r8, r2, LSR #3          ; LSR #0 -> LSR #32
        MOVEQ   r8, #32                 ; ASR #0 -> ASR #32
        BL      StoreDecimal
        EXIT

50 ; Shift register

        MOV     r5, r2, LSR #4          ; Rs

        AND     r5, r5, #2_1111
        TEQS    r5, #15
        MOVEQ   r14, #Mistake_R15shift
        STREQ   r14, Mistake

        BL      Dis_Register
        EXIT


80      ADR     r10, %FT90              ; RRX
        BL      SaveString
        EXIT

90
        DCB     ",RRX", 0

ShiftTypes
        DCB     ",LSL ", 0              ; 00x
        DCB     ",LSR ", 0              ; 01x
        DCB     ",ASR ", 0              ; 02x
        DCB     ",ROR ", 0              ; 03x

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r5 = fp register

Dis_F_Register EntryS "r2"

        LDRB    r10, DisReg_F
        AND     r5, r5, #2_111          ; Only 8 FP registers
;       MOV     r10, #"F"
        B       %FT20

; .............................................................................

Dis_C_Register ALTENTRY

        LDRB    r10, DisReg_C
;        MOV     r10, #"C"
;        B       %FT20

; .............................................................................
; In    r5 = register number
;       r10 = first character

20      STRB    r10, [r0], #1
        AND     r5, r5, #2_1111
        ADD     r2, r5, #"0"
        CMPS    r5, #10
        AddChar "1",HS
        SUBHS   r2, r2, #10
        STRB    r2, [r0], #1
        EXITS

; .............................................................................

Comma_Dis_Register ALTENTRY

        BL      AddComma
        B       %FT50

; .............................................................................

Tab_Dis_Register ALTENTRY

        BL      Tab
        B       %FT50

; .............................................................................

; In    r5 = register number (in bottom 4 bits, rest can be garbage)
; Out   r5 = register number (correctly masked)
;       r2, r10 corrupted

Dis_Register ALTENTRY

50      AND     R5, R5, #2_1111
;        TEQ     r5, #15
;        BEQ     Dis_pc

        CMP      R5,#8
        BLHS     checkreg

        ADD     R14, R12, #:INDEX: DisRegLabels
        LDR     R14, [R14, R5, LSL #2]
        LDR     R14, [R14]

;       MOV     R14, #"R"
;       ORR     R14, R14, #"1" :SHL: 8
;       ORR     R14, R14, #"4" :SHL: 16

        STRB    R14, [R0], #1
        MOV     R14, R14, LSR #8
        STRB    R14, [R0], #1
        MOVS    R14, R14, LSR #8
        STRNEB  R14, [R0], #1
        EXITS

; .............................................................................

;Dis_pc
;       AddStr  pc_Reg
;        EXITS
;
;
;pc_Reg  DCB     "PC", 0
;        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r10 -> string, 0 to copy into buffer
;       r0 -> current buffer position

; Out   r0 ++, r10++

SaveString EntryS

10      LDRB    r14, [r10], #1
        CMPS    r14, #32
        STRHSB  r14, [r0], #1
        BHS     %BT10
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r4 = instruction

; Out   r0++ with condition codes appended

Conditions EntryS "r1, r10"

10      MOV     r1, r4, LSR #28
        CMPS    r1, #14
        EXITS   HS                      ; 14 = AL (no code printed)
                                        ; 15 was NV, now decoded upfront
        ADRLO   r10, CondSym
        ADDLO   r1, r10, r1, LSL #1
        LDRLOB  r10, [r1], #1
        STRLOB  r10, [r0], #1
        LDRLOB  r10, [r1], #1
        STRLOB  r10, [r0], #1
        EXITS

CondSym DCB     "EQ"                    ; 0
        DCB     "NE"                    ; 1
        DCB     "CS"                    ; 2
        DCB     "CC"                    ; 3
        DCB     "MI"                    ; 4
        DCB     "PL"                    ; 5
        DCB     "VS"                    ; 6
        DCB     "VC"                    ; 7

        DCB     "HI"                    ; 8
        DCB     "LS"                    ; 9
        DCB     "GE"                    ; 10
        DCB     "LT"                    ; 11
        DCB     "GT"                    ; 12
        DCB     "LE"                    ; 13

        ALIGN

; .............................................................................

SaveStringConditions ALTENTRY

        BL      SaveString
        B       %BT10

; .............................................................................

SaveStringConditions2 ALTENTRY

        BL      SaveString
        CMP     r4, #2_1111:SHL:28      ; Condition 'NV' => '2'
        BCC     %BT10
        [ WarnARMv5
        LDR     r10, Mistake
        CMP     r10, #0
        MOVLE   r10, #Mistake_ARMv5
        STRLE   r10, Mistake
        ]
        AddChar "2"
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Pad with spaces to operand field or comment field

Tab Entry

10      ADR     r1, StringBuffer
        SUB     r1, r0, r1
15      MOV     r14, #space
        STRB    r14, [r0], #1
        TEQS    r1, #7
        EXIT    EQ
        CMPS    r1, #25 ;new exit position for longer comments
        BLO     %BT10

        ADR     r10, Rem
        BL      SaveString
        EXIT

TabOrPushOver
        ALTENTRY
        ADR     r1, StringBuffer
        SUB     r1, r0, r1
        CMPS    r1, #8
        BLO     %BT15
        AddChar " "
        EXIT




Rem     DCB     " ; ", 0
        ALIGN

TestMistakes
        Entry   "r5"
        LDR     R5,Mistake
        CMPS    R5,#1
        BLT     exitM

        BL      Tab
        MOV     R10,#0
        STR     R10,Mistake
        ADR     R10,Silly
        SUB     R5,R5,#1
        ADD     R10,R10,R5,LSL #2
;        LDR     R5,[R5]
;        ADD     R10,R10,R5
        BL      lookup_r10
        BL      SaveString
exitM
        EXIT

Silly
        =       "M10",0         ; ! and ^
        =       "M11",0         ; Not R8-R14
        =       "M12",0         ; SWI after CDP
        =       "M13",0         ; Rd=Rm or Rd=R15
        =       "M53",0         ; Shift by R15
        =       "M54",0         ; Not R15
        =       "M55",0         ; PC writeback
        =       "M56",0         ; Byte load/store of PC
        =       "M57",0         ; May store PC+8 or PC+12
        =       "M58",0         ; Unpredictable
        =       "M59",0         ; Rd=Rn
        =       "M60",0         ; Rm=Rn
        =       "M61",0         ; RdLo=RdHi
        =       "M62",0         ; RdLo=Rm
        =       "M63",0         ; RdHi=Rm
        =       "M64",0         ; Rn in list
        =       "M66",0         ; Rd=Rm
        =       "M67",0         ; Only 1 reg on SA-110 rev 2
        =       "A00",0         ; ARMv5 or later
        =       "A01",0         ; ARMv5E or later
        =       "A02",0         ; ARMv6 or later
        =       "A03",0         ; ARMv6K or later
        =       "A04",0         ; ARMv6T2 or later
        =       "A05",0         ; ARMv7 or later
        =       "A15",0         ; ARMv7VE or later
        =       "A16",0         ; ARMv7MP or later
        =       "M49",0         ; Odd base of pair
        
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> buffer
;       r2 = bit position to start at
;       r8 = value to store in hex

; Out   r0 ++

StoreHex Entry "r2"

        AddChar "&"

10      MOV     r14, r8, LSR r2
        AND     r14, r14, #15
        CMPS    r14, #9
        ORRLS   r14, r14, #"0"
        ADDHI   r14, r14, #"A"-10
        STRB    r14, [r0], #1
        SUBS    r2, r2, #4
        BPL     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> current buffer position
;       r8 = value to store in decimal

; Out   r0++

StoreDecimal EntryS "r1-r2, r4"

        SUB     sp, sp, #16
        MOV     r4, r0

        MOV     r0, r8
        MOV     r1, sp
        MOV     r2, #16                 ; Can't get an error with this much
        SWI     XOS_BinaryToDecimal     ; r2 := length of number

        MOV     r0, r4
10      SUBS    r2, r2, #1
        LDRPLB  r14, [r1], #1
        STRPLB  r14, [r0], #1
        BNE     %BT10

        ADD     sp, sp, #16
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

StoreCommaHash_Decimal Entry

        BL      AddCommaHash
        BL      StoreDecimal
        EXIT

StoreDecimal_Comma Entry

        BL      StoreDecimal
        B       %FT50

;..............................................................................
; In    r0 -> output buffer
; Out   comma appended, r0++, flags preserved

AddComma ALTENTRY

50
        AddChar ","
        EXIT

;..............................................................................
; In    r0 -> output buffer
; Out   comma & hash appended, r0++, flags preserved

AddCommaHash

        AddChar ","
        AddChar "#"
        MOV     pc, lr

; .............................................................................

Dis_C_Register_Comma ALTENTRY

        BL      Dis_C_Register
        B       %BT50

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MemoryI_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGMMI", 0
        ALIGN


MemoryI_Code Entry "r6-r11"

        MOV     R6,#"T"
        BL      MemoryCommon
        TEQS    R6,#1
        MOVEQ   R6,#2

        ADR     r2, MemoryI_Error
        MOV     r10, #0 ; arguments can only be 32-bit
        BL      GetCommandParms
        BLVS    CopyErrorR2
        EXIT    VS

        TST     r8, #secondparm
        ADDEQ   r7, r9, r6, LSL #4      ; r7 = r9 + r6 * 24
        ADDEQ   r7, r7, r6, LSL #3

        TEQ     r6, #4

        BICEQ   r9, r9, #3              ; ensure word aligned
        BICEQ   r7, r7, #3
        BICNE   r9, r9, #1              ; ensure halfword aligned
        BICNE   r7, r7, #1

        TEQS    r9, r7                  ; If same, ensure we do one word
        ADDEQ   r7, r7, r6

        BL      SwapAllBreakpoints

10 ; Loop doing disassembly until ESCape or ended

        SWI     XOS_ReadEscapeState
        BCS     %FT95

        BL      DisplayHexWord_R9       ; Display address

        BLVC    MarkPC
        EXIT    VS

        TEQ     r6, #4
        BNE     %FT40

        ; ARM disassembly

        MOV     r0, r9
        BL      do_readW

        MOV     r4, r1
        BL      DisplayCharactersR      ; Display R6 chars contained in R4
        EXIT    VS

        SWI     XOS_WriteS
        DCB     " : ", 0
        ALIGN
        EXIT    VS

        MOV     r10, r1
        BL      DisplayHexWord
        BLVC    MarkBreakpoints
        MOVVC   r0, r1
        MOVVC   r1, r9
        SWIVC   XDebugger_Disassemble
        B       %FT55

40      ; Thumb disassembly
        ; This code will probably want updating once we can decode all the new 32bit encodings
 [ NoARMv5
        ; We may be running on a machine without LDRH, or without proper support for it (e.g. RiscPC)
        ; To avoid alignment faults on ARMv6+, load an aligned word and shift it ourselves
        BIC     r0, r9, #2
        BL      do_readW
        TST     r9, #2
        MOVNE   r1, r1, LSR #16
 |
        ; ARMv5+, safe to LDRH
        MOV     r0, r9
        BL      do_readH
 ]

        MOV     r4, r1
        BL      DisplayCharactersR      ; Display R6 chars contained in R4
        EXIT    VS

        SWI     XOS_WriteS
        DCB     " : ", 0
        ALIGN
        EXIT    VS

        MOV     r10, r1
        BL      DisplayHexHalfword        
        BLVC    MarkBreakpoints
        MOVVC   r0, r1
        MOVVC   r1, r9
        SWIVC   XDebugger_DisassembleThumb

55      MOVVC   r0, r1

        SWIVC   XOS_Write0
        SWIVC   XOS_NewLine
        EXIT    VS

        ADD     r9, r9, r6

        TEQS    r9, r7
        BNE     %BT10


90      BL      SwapAllBreakpoints
        EXIT

95      BL      AckEscape
        B       %BT90

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

InitStore_Error
        DCD     ErrorNumber_Syntax
        DCB     "SDBGINS", 0
        ALIGN


InitStore_Code Entry "r6-r11"

        LDR     wp, [r12]

        MOV     r1, r0
        ADR     r0, InitStore_Error
        MOV     r10, #0 ; arguments can only be 32-bit
        BL      ReadOneParm             ; r7 := parm, r8 state
        BLVS    CopyError
        EXIT    VS

        TST     r8, #hasparm
        LDREQ   r7, =&E7FFFFFF          ; A nice invalid instruction
        SWI     XOS_GetEnv              ; r1 -> end of user memory

        MOV     r14, #AppSpaceStart
10      TEQ     r14, r1                 ; Might have zero apl space
        STRNE   r7, [r14], #4
        BNE     %BT10

        BL      message_writes
        DCB     "M16", 0                ; "Store inititalised to &"
        ALIGN

        MOVVC   r10, r7
        BLVC    DisplayHexWord
        SWIVC   XOS_NewLine
        EXIT

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ShowRegs_Code

        LDR     wp, [r12]

; .............................................................................

ShowRegs_Code_Common Entry "r6-r11"

        BL      message_writes        ; Display address of register dump
        DCB     "M17", 0              ; "Register dump (stored at &)
        ALIGN

        ADRVC   r10, Registers
        BLVC    DisplayHexWord
        EXIT    VS

        BL      message_writes
        DCB     "M18", 0              ; ") is:"
        ALIGN
        EXIT    VS

        MOV     r4, #0
        ADR     r11, Registers

10 ; Display dumped registers

        TST     r4, #3
        SWIEQ   XOS_NewLine
        EXIT    VS

        SWINE   XOS_WriteI+space

        SWIVC   XOS_WriteI+"R"

        MOVVC   r8, r4
        BLVC    DisplayDecimalNumber
        EXIT    VS

        CMPS    r4, #10
        SWILO   XOS_WriteI+space
        EXIT    VS

        SWI     XOS_WriteS
        DCB     " = ", 0
        ALIGN

        LDRVC   r10, [r11, r4, LSL #2]
        BLVC    DisplayHexWord
        EXIT    VS

        ADD     r4, r4, #1
        TEQS    r4, #16
        BNE     %BT10

        SWI     XOS_NewLine
        EXIT    VS

; Display processor mode (r10 = dumped pc at end of loop)

; Check whether we're 26 or 32 bit
        LDRB    r0, SysIs32bit
        TEQ     r0, #0
        BEQ     ShowRegs_Mode_26

        BL      message_writes
        DCB     "M19", 0                ; "Mode "
        ALIGN

        LDRVC   r10, [r11, #4*16]       ; get saved PSR

        ANDVC   r2, r10, #2_11111       ; Mask with M[4:0] bits
        ADRVC   r0, ARM32_Modes
        ADDVC   r0, r0, r2, LSL #2
        ADDVC   r0, r0, r2, LSL #1
        SWIVC   XOS_Write0
        EXIT    VS

        BL      message_writes
        DCB     "M20", 0                ; " flags set: "
        ALIGN

        MOVVC   r0, #"N"
        MOVVC   r1, #N_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"Z"
        MOVVC   r1, #Z_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"C"
        MOVVC   r1, #C_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"V"
        MOVVC   r1, #V_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"Q"
        MOVVC   r1, #Q32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"J"
        MOVVC   r1, #J32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"G"
        MOVVC   r1, #GE3_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"G"
        MOVVC   r1, #GE2_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"G"
        MOVVC   r1, #GE1_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"G"
        MOVVC   r1, #GE0_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"E"
        MOVVC   r1, #E32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"A"
        MOVVC   r1, #A32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"I"
        MOVVC   r1, #I32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"F"
        MOVVC   r1, #F32_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"T"
        MOVVC   r1, #T32_bit
        BLVC    DoFlagBit
        EXIT    VS

        BL      message_writes
        DCB     "M14", 0                ; "   PSR = "
        BLVC    DisplayHexWord

        SWIVC   XOS_NewLine
        EXIT

ShowRegs_Mode_26

        BL      message_writes
        DCB     "M19", 0                ; "Mode "
        ALIGN

        ANDVC   r2, r10, #2_11          ; Mask with M[1:0] bits
        ADRVC   r0, ARM_Modes
        ADDVC   r0, r0, r2, LSL #2
        SWIVC   XOS_Write0
        EXIT    VS

        BL      message_writes
        DCB     "M20", 0                ; " flags set: "
        ALIGN

        MOVVC   r0, #"N"
        MOVVC   r1, #N_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"Z"
        MOVVC   r1, #Z_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"C"
        MOVVC   r1, #C_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"V"
        MOVVC   r1, #V_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"I"
        MOVVC   r1, #I_bit
        BLVC    DoFlagBit

        MOVVC   r0, #"F"
        MOVVC   r1, #F_bit
        BLVC    DoFlagBit

        SWIVC   XOS_NewLine
        EXIT


ARM_Modes
        DCB     "USR", 0
        DCB     "FIQ", 0
        DCB     "IRQ", 0
        DCB     "SVC", 0

ARM32_Modes
        DCB     "USR26", 0
        DCB     "FIQ26", 0
        DCB     "IRQ26", 0
        DCB     "SVC26", 0
        DCB     "00100", 0
        DCB     "00101", 0
        DCB     "00110", 0
        DCB     "00111", 0
        DCB     "01000", 0
        DCB     "01001", 0
        DCB     "01010", 0
        DCB     "01011", 0
        DCB     "01100", 0
        DCB     "01101", 0
        DCB     "01110", 0
        DCB     "01111", 0
        DCB     "USR32", 0
        DCB     "FIQ32", 0
        DCB     "IRQ32", 0
        DCB     "SVC32", 0
        DCB     "10100", 0
        DCB     "10101", 0
        DCB     "MON32", 0
        DCB     "ABT32", 0
        DCB     "11000", 0
        DCB     "11001", 0
        DCB     "11010", 0
        DCB     "UND32", 0
        DCB     "11100", 0
        DCB     "11101", 0
        DCB     "11110", 0
        DCB     "SYS32", 0
        ALIGN

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = flag bit to test
;       r10 = psr
;       r0 = uppercase char to print if set

; Out   char printed uppercase or lowercase, r0 corrupt

DoFlagBit Entry

        TST     r1, r10
        ORREQ   r0, r0, #&20            ; Cheap lowercase, known values input
        SWI     XOS_WriteC
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

d3629 1
@


4.35
log
@ARMv6/v7 disassembly accuracy improvements, ARMv7MP ARMv7VE additions
ARMv6.s
  Add missing conditionals on DBG.
  Add ERET (v7VE).
  Add MRS/MSR banked (v7VE), and its funky encoding of the banked register.
  Check bit 22 of SRS/RFE properly, otherwise some undefined instructions get wrongly decoded as SRS/RFE.
CGlue.s
  Use prefix 'A' for arch warnings, so they can be kept together in the messages file.
Debugger.s:
  Around line 990, refactor up front decoding to pick out NV instruction space like the ARM ARM says to do. This makes subsequent decoding much simpler to follow, and removes lots of backdoor checks on bits 28-31 scattered later on in the decode - fixes problem with CPS #mode being wrong when bit 4 set.
  Add HVI (v7MP). Note this is a made up pre-UAL form of HVC (cf. SWI->SVC, SMI->SMC) for now.
  Add PLDW (v7VE).
  Put back flags preservation on Conditions routine, otherwise TestStr preserves flags if no conditions are wanted, but doesn't if they are - was causing some of the Saturates family to be misclassified as undefined.
Test/V6V7tests
  Add samples of each of the extra instructions.
Resources/UK/Messages, Resources/Germany/Messages
  Messages files updated.
Tested with 'testbed' over the 256M EQ condition code, plus 256M NV condition code, with no unexplained mismatches.

Version 1.94. Tagged as 'Debugger-1_94'
@
text
@d6579 1
a6579 1
        LDRHI   r8, [r3, #Module_Title] 
@


4.34
log
@Add exception dump generation and processing facilities
Detail:
  This set of changes adds support for the following features:
  * A new code system variable, Debugger$DumpOptions, to control whether exception/crash dumps are collected from SeriousErrorV and where they should be output
  * Dump output can be in raw (binary) or annotated (text) form.
  * Annotated form provides detailed annotation of the stack(s), detecting certain constructs such as SWI invocations, IRQsema frames, CMHG veneers, APCS stack frame chains, and most forms of assembler function calls. The output isn't as easy to understand as a proper stack backtrace would be, but the low-level nature allows it to cope with corrupt or partially-overwritten stack frames, and avoids making invasive changes to components in order to make them backtrace-friendly
  * Stack annotation is able to make use of embedded ROM debug symbols (to be supported by romlinker 0.06) and Norcroft-style embedded function names in order to provide function-level location information for most ROM components and applications
  * System variables Debugger$RawFile and Debugger$AnnotatedFile to specify where to save raw and annotated exception dumps (preliminary, approach may change in future)
  * As well as supporting saving to file, the exception dumps can also be sent to the HAL via HAL_DebugTX, or if a program is driving SeriousErrorV directly it can use SeriousErrorV_CustomReport to have it fed to a custom callback function
  The code is structured in such a way that the core dump annotation code can potentially be built into a standalone application to allow offline processing of dumps (offline application not part of this checkin)
  File changes:
  c/exc, h/exc - Core code for producing the annotated exception dumps
  hdr/ExcDump - Header detailing the format of the binary dump
  s/ExceptionDump - Code variable and SeriousErrorV handling. Several support calls (used by c/exc) are also implemented here, in order to separate the dump processing from any interrogation of the originating machine
  Makefile - Updated for c/exc inclusion, and C header generation from hdr/ExcDump
  Resources/UK/Messages, Resources/Germany/Messages - New messages used by exception dump code
  c/support - Add a strcmp implementation, and extend vsprintf to be vsnprintf. Add support for string width format specifier.
  s/Debugger - Workspace definitions and init/shutdown hooks for exception dump code. Refactor *Where so that the locate logic is separate from the message output logic, to allow the locate logic to be used by the exception dump code.
Admin:
  Tested on Raspberry Pi
  German messages in need of translation


Version 1.92. Tagged as 'Debugger-1_92'
@
text
@d289 6
d446 2
d993 1
a994 7
      [ UseCVFPNEON
        TEQ     r3, #2_11110100
        TSTEQ   r4, #1:SHL:20
        TEQNE   r3, #2_11110010
        TEQNE   r3, #2_11110011
        BEQ     ASIMD                   ; All the unconditional ASIMD instructions
      ]
d996 4
d1015 31
a1045 1
        B       DataProcessing          ; [data processing = 00.03]
a1210 4
        MOV     r14, r4, LSR #28        ; if "NV" condition code
        TEQ     r14, #15
        BEQ     BLX_offset              ; then it's BLX

a1274 3
        CMP     R4, #2_1111:SHL:28      ; 'NV' condition code
        BCS     Srs_Or_Rfe              ; means something else

a1457 4
        MOV     r14, r4, LSR #28
        TEQ     r14, #15
        BEQ     Preload

a1615 50
Preload ROUT
        ; Preload
        ; arrive here with 1111 01xx xxxx xxxx xxxx xxxx xxxx xxxx
        ; format is        1111 010h u101 nnnn 1111 iiii iiii iiii
        ;        or        1111 011h u101 nnnn 1111 rrrr rtt0 mmmm
        ;
        ; PL<D|I> [Rn,#offset]
        ;         [Rn,{+|-}Rm{,shift}]
        ;
        ; where    h = PLD/~PLI hint
        ;          u = Up/~Down
        ;       nnnn = Rn
        ;      rrrrr = shift amount
        ;         tt = shift type (LSL, LSR, ASR or ROR)
        ;       mmmm = Rm
        ;       iiii = 12-bit unsigned immediate offset

        LDR     r14, =&F57FF0           ; Bits 8-31 of a group of 16 unconditionals
        TEQ     r14, r4, LSR #8
        BEQ     Maintenance_uncond

      [ WarnARMv5E :LOR: WarnARMv7
        TestBit 24
        [ WarnARMv5E
        MOVNE   r14, #Mistake_ARMv5E
        |
        MOVNE   r14, #0
        ]
        [ WarnARMv7
        MOVEQ   r14, #Mistake_ARMv7
        |
        MOVEQ   r14, #0
        ]
        STR     r14, Mistake
      ]

        AddStr  Pload
        TestBit 24, "D", "I"
        BL      Tab
        AND     r5, r4, #2_10111:SHL:20
        TEQ     r5, #2_10101:SHL:20
        TEQNE   r5, #2_00101:SHL:20     ; PLI
        ORREQ   r4, r4, #1:SHL:24       ; Sidestep PC writeback warning
        ANDEQ   r5, r4, #2_1111:SHL:12
        TEQEQ   r5, #2_1111:SHL:12
        BEQ     DataTransfer_Common_NoComma
        B       Undefined

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

a1622 1
Pload   DCB     "PL", 0
d2023 64
a2283 4
        MOV     r5, r4, LSR #28
        TEQ     r5, #15
        BEQ     ControlExtension_uncond

d2296 5
a2300 2
        TEQ     r5, #2_0111 :SHL: 4             ; 7 = BKPT
        BEQ     is_BKPT
d2302 1
a2302 1
        CMP     r5, #2_1000 :SHL: 4             ; 2,4,6 undefined
d2320 1
a2320 1
        BNE     is_MSR
d2326 1
a2326 1
        BNE     is_MSR
d2336 6
a2341 1
        BNE     Undefined
d2377 1
a2377 1
BkptTAB DCB     "BKPT",0
d2379 7
a2385 1
        ALIGN
d2387 2
a2388 1
is_MSR  ; arrive here with cccc 0001 0x10 xxxx xxxx xxxx 0000 xxxx
a2401 10
        TestBit 25                    ; if register, bits 4-11 must be 0
        BNE     %FT01

        TST     r4, #2_11111111 :SHL: 4
        BNE     Undefined

01      AND     r10, r4, #2_1111 :SHL: 12
        TEQ     r10, #2_1111 :SHL: 12
        BNE     Undefined

d2511 16
a2526 1
is_BKPT ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 0111 xxxx
d2528 1
a2528 1
        ; format is        1110 0001 0010 nnnn nnnn nnnn 0111 nnnn
d2530 2
a2531 1
        ; BKPT <number>     (note conditional not permitted)
d2534 1
a2534 7
        AND     r5, r4, #2_11:SHL:21
        TEQ     r5, #2_11:SHL:21
        BEQ     is_SMI

        TEQ     r5, #2_01:SHL:21
        BNE     Undefined

d2537 1
a2537 1
        BNE     Undefined
d2539 1
d2541 6
a2546 1
        MOV     r10, #Mistake_ARMv5
d2550 1
a2550 2
        ADR     r10, BkptTAB
        BL      SaveString
d2561 4
d3169 1
a3169 1
Conditions Entry "r1, r10"
d3173 3
a3175 2
        EXIT    EQ                      ; 14 = AL (no code printed)
        ADRLO   r10, CondSym            ; 15 was NV, now undefined
d3181 1
a3181 4
        EXIT    LO
        PullEnv
        B       Undefined

d3222 1
a3222 1
        EXIT
d3295 8
a3302 6
        =       "M68",0         ; ARMv5 or later
        =       "M69",0         ; ARMv5E or later
        =       "M70",0         ; ARMv6 or later
        =       "M71",0         ; ARMv6K or later
        =       "M72",0         ; ARMv6T2 or later
        =       "M73",0         ; ARMv7 or later
@


4.33
log
@Add *Where to debugger's armoury
Largely inspired/ripped off from the DebugTools module, but using OS_DynamicArea 20 for the bulk of area searching. The address to lookup goes through the usual parser for Debugger commands so can be a hex address/register/implied exception PC if no arguments given.
Removed limited lookup from *ShowRegs command; this wasn't especially useful being hardwired to PC since only data aborts have a valid PC, normally the other registers are more interesting.
Fix miscapitalisation of ShowVFPRegs syntax (presumably to avoid it using Token0) by adding a DictTokens directive, since the syntax is used by code in the module which doesn't work with Token0.
Split German messages out into CmdHelp/Messages.

Tested in an IOMD ROM build with various edge cases.

Version 1.90. Tagged as 'Debugger-1_90'
@
text
@d250 4
d256 1
d390 17
d645 2
d736 25
d771 7
d835 2
d2334 1
a2631 1
AdrTAB  DCB     "ADR",0
a6430 1
        MOV     r8, #0                  ; No details
d6441 44
d6571 2
a6572 3
        ; Say "is <somewhere vague>"
        BL      message_write0
        B       %FT88
d6574 1
a6574 13
        ; Say "is at offset &xx in <some area> 'detail'"
        ; => r0 -> area name token
        ;    r7 = offset
        ;    r8 -> detail string
        BL      message_writes
        DCB     "M21", 0
        ALIGN
        MOVVC   r10, r7
        BLVC    DisplayHexWord
        SWIVC   OS_WriteI+space
        BLVC    message_write0
        TEQ     r8, #0                  ; NULL details? V preserved
        BEQ     %FT88
d6576 31
a6606 7
        SWIVC   OS_WriteI+space
        SWIVC   OS_WriteI+"'"
        MOVVC   r0, r8
        SWIVC   OS_Write0
        SWIVC   OS_WriteI+"'"
88
        SWIVC   OS_NewLine
a6608 10
Where_Unknown   DCB     "M28", 0
Where_NotMapped DCB     "M30", 0
Where_ROM       DCB     "M34", 0
Where_Module    DCB     "M47", 0
Where_AppSlot   DCB     "M88", 0
Where_DynArea   DCB     "M89", 0
Where_Kernel    DCB     "M95", 0
Where_SysWksp   DCB     "M96", 0
        ALIGN        

d6639 1
@


4.32
log
@Fix annotation of FPSCR LEN & STRIDE fields
Detail:
  s/Debugger - Fix some broken logic in *ShowVFPRegs that was causing the FPSCR vector length fields to be reported incorrectly if vector stride was enabled
Admin:
  Tested on Raspberry Pi


Version 1.89. Tagged as 'Debugger-1_89'
@
text
@a25 1
;               John Ballance (module location added to showregs command output)
d828 1
a3405 2
UserMemStart  * &8000

d3421 1
a3421 1
        MOV     r14, #UserMemStart
d3584 1
a3585 4

; display module title if available
	BLVC	ModuleWhere

d3629 1
a3630 2
; display module title if available
	BLVC	ModuleWhere
a3631 38
        EXIT
; wp already setup
ModuleWhere
        Entry	"r0 - r3, r10"
        adr	r10, Registers
        ldr	r10, [r10, #15<<2] ; get PC
        mov	r1, #0
        mov	r2, #0
MW1
	mov	r0, #ModHandReason_GetNames
	swi	XOS_Module
	bvs	MW2
        subs    r0, r10, r3      ; check address still ahead of us
        blt     MW2              ; no .. gone too far
        ldr     r4, [r3,#-4]     ; get module rma length
        cmp     r0, r4           ; check if in this module
        bgt     MW1		 ; no.. still ahead of us
; got the module address
        BL      message_writes
        DCB     "M96", 0         ; "At offset "
        ALIGN
        mov	r10, r0          ; offset
        bl      DisplayHexWord
        BL      message_writes
        DCB     "M97", 0         ; " in module "
        ALIGN
        ldr	r0, [r3, #16]	 ; module name pointer
        add	r0, r0, r3
        swi     XOS_Write0
        b	MW3
; not in a module
MW2
        BL      message_writes
        DCB     "M95", 0                ; "Not in a module"
        ALIGN
MW3
        swi     XOS_NewLine
	EXIT
d6349 160
d6528 2
a6529 2
        GET     s.ARMv6
        GET     s.FP
d6531 1
a6531 1
        GET     s.CGlue
d6533 1
a6533 1
        GET     s.VFP
d6535 2
a6536 2
        GET     s.Thumb
        GET     s.CodeVar
@


4.31
log
@  Added module name and offset to *ShowRegs command
Detail:
  *Showregs now indicated module name and offset if address is
  in a module
Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 1.88. Tagged as 'Debugger-1_88'
@
text
@d6126 4
a6129 4
        ; Nonzero stride with nonzero length is invalid
        TEQ     r1, #0
        TEQNE   r0, #0
        BNE     %FT25
@


4.30
log
@Add *ShowVFPRegs command
Detail:
  This adds support for the *ShowVFPRegs command, which is basically VFP equivalent of *ShowFPRegs. However unlike *ShowFPRegs it allows for any arbitrary VFP context to be viewed, not just the last context that caused an exception:
  *ShowVFPRegs [E] for showing the exception context
  *ShowVFPRegs A <address> for showing a context at a specific address
  *ShowVFPRegs C for showing the current context
  File changes:
  - HelpSrc, Resources/UK/CmdHelp - Added *ShowVFPRegs help text
  - Resources/Germany/Messages, Resources/UK/Messages - New message tokens for *ShowVFPRegs output
  - s/Debugger - *ShowVFPRegs implementation
  - actions/ARMv7_VFP - VPUSH or VPOP of >16 singleword registers were incorrectly being flagged as unpredictable; it's only the doubleword version which should have that restriction.
Admin:
  Tested on Raspberry Pi
  German messages are in need of translation


Version 1.86. Tagged as 'Debugger-1_86'
@
text
@d26 1
d3586 4
a3590 1
        SWIVC   XOS_NewLine
a3633 1
        EXIT
d3635 2
d3638 38
@


4.29
log
@Add a new, machine-generated VFP/NEON disassembler. Fix some ARMv6/v7 disassembly bugs.
Detail:
  This change adds up-to-date VFP & NEON disassembly to the module, by way of a partially machine-generated disassembler written in C.
  It's also possible to build a standalone disassembler utility (dubbed 'dis2') which is 100% C and has support for all ARM instructions (including some obscure stuff the assembler disassembler currently lacks, e.g. XScale DSP instructions). One day this may completely replace the assembler disassembler, but at the moment it's a bit bulky and probably has a few bugs left to squash. The disassembler is also fairly flexible, supporting various output formatting options.

  Main changes:
  - Makefile - Rewritten to switch over to using the CModule makefile fragment instead of AAsmModule, to allow the C code to be included in the component. Also added 'dis2' as an alternative component to build as.
  - Resources/UK/Messages, Resources/Germany/Messages - Updated with new disassembler messages
  - s/Debugger - Add new UseCVFPNEON switch to allow control over whether the module builds with the C VFP/NEON disassembler or the original assembler VFP disassembler
  - s/CGlue - Glue code used with the C disassembler to bridge the gap between the assembler world and the C world
  - actions/* - A set of decgen action files describing what to do for each instruction the new disassembler supports. These are basically just blocks of C code - although they need to match up with the encoding names in Library/Misc/decgen/encodings
  - cache/* - Folder for decgen to cache decision trees in. Building the decision tree for the disassembler is currently a lengthy process, but caching the trees reduces the build time to a fraction of the full time.
  - c/head - Stub C file that decgen prepends to the code it generates
  - c/main - main frontend for the standalone version of the disassembler
  - c/support - Reimplementation of the standard C library functions required for the disassembler. This allows us to avoid a runtime dependency on the shared C library, and also allows us to deal with control-terminated strings from messagetrans where relevant. For convenience this file also has the main entry point that's called from assembler.
  - c/util - Utility code for outputting various forms of instruction, decoding immediate constants, etc.
  - h/dis2 - Header file for the C code
  - Test/c/testbed - Simple C testbed app to allow the output of dis2 to be compared against the Debugger module and decaof
  - !MkDis2,fd7 - Script to allow easy building of the standalone 'dis2' disassembler
  Bugfixes:
  - s/ARMv6 - Change 'ROR#' to 'ROR #' for UXTAB, etc. disassembly. Fix bitfield extract & clear instructions to detect unpredictable/invalid bitfield definitions
  Misc other changes:
  - s/* - Source files updated so s/Debugger contains a list of GETs instead of each source file LNK'ing to the next
Admin:
  Tested in ROM form on BB-xM, and as softload on Iyonix
  German messages are in need of translation
  Requires Library-1_65 and BuildSys-6_34


Version 1.85. Tagged as 'Debugger-1_85'
@
text
@d249 1
d766 1
a766 1
        ADRL    R0,resourcefsfiles
d800 1
a800 1
        ADRL    R0,resourcefsfiles
d827 1
d5931 419
d6357 1
a6357 1
        ADR     R0,resourcefsfiles
d6362 1
a6362 3
resourcefsfiles
	ResourceFile	$MergedMsgs, Resources.Debugger.Messages
	DCD	0
@


4.28
log
@Add in disassembly of ARMv6 and ARMv7 instruction sets
The debugger had some embryonic ARMv6 knowhow, switched out due to being incomplete.
Enabling and finishing off ARMv6, then adding ARMv6K, ARMv6T2, ARMv6 security extensions, and ARMv7.
That just leaves
 - ARMv7MP (multiprocessor extensions: PLDW)
 - ARMv7VE (virtualisation extensions: ERET, MRS copro, MSR copro)
 - Advanced SIMD (probably worth thinking about)
 - Thumb2 (questionable why Thumb is supported at all as the tools & OS don't use it)
The syntax follows the pre UAL spirit for the new instructions (cf. ADDCCS versus ADDSCC).
Removed binary V6test binary, replaced with more comprehensive v6/v7 source.
Tested softloaded inspecting the output in StrongEd.

Version 1.84. Tagged as 'Debugger-1_84'
@
text
@d289 3
d380 4
d523 3
a525 1
        AREA    |Debugger$$Code|, CODE, READONLY, PIC
d574 3
d633 8
d925 7
d5950 11
a5960 1
        LNK     s.ARMv6
@


4.27
log
@Fix objasm 4 warnings. Fix breakclr <addr> when addr is >=64M
Detail:
  s/Debugger - Tweaked a few LDM/STM instructions to fix some objasm 4 warnings. Disabled some 26bit code in 32bit configs to avoid more warnings. Fix BreakClr to work on 32bit systems if the breakpoint address is >=64M.
Admin:
  Tested on rev A2 BB-xM


Version 1.83. Tagged as 'Debugger-1_83'
@
text
@d245 1
d257 1
a257 4
debug           SETL    False

                GBLL    national
national        SETL    False
d260 1
a260 1
StrongARM       SETL    True
d263 1
a263 1
WarnSArev2      SETL    False           ; Warn about hitting the SA revision 2 STM^ bug
d266 1
a266 1
WarnARMv5       SETL    True            ; Indicate ARMv5 or later instructions
d269 1
a269 1
WarnARMv5E      SETL    True
d272 7
a278 1
WarnARMv6       SETL    True            ; Indicate ARMv6 or later instructions
d280 5
a284 2
                GBLL    ARMv6
ARMv6           SETL    False           ; Don't do ARMv6 yet until complete
d287 6
a292 1
CirrusDSP       SETL    False
d296 1
a296 1
standalone      SETL    False
d407 4
d531 1
a531 1
 [ International_Help <> 0
d788 1
d790 16
a805 28
Debug_HC_Table ; Name       Max  Min

        [ national
        Command BreakClr,    1,   0,
        Command BreakList,   0,   0,
        Command BreakSet,    1,   1,
        Command Continue,    0,   0,
        Command Debug,       0,   0,
        Command InitStore,   1,   0,
        Command Memory,      5,   1,; P B R + R
        Command MemoryA,     4,   1,; P B R V
        Command MemoryI,     7,   1,; P T A +/- B + C
        Command ShowRegs,    0,   0,
        Command ShowFPRegs,  0,   0,
        |
        Command BreakClr,    1,   0, International_Help
        Command BreakList,   0,   0, International_Help
        Command BreakSet,    1,   1, International_Help
        Command Continue,    0,   0, International_Help
        Command Debug,       0,   0, International_Help
        Command InitStore,   1,   0, International_Help
        Command Memory,      5,   1, International_Help     ; P B R + R
        Command MemoryA,     4,   1, International_Help     ; P B R V
        Command MemoryI,     7,   1, International_Help     ; P T A +/- B + C
        Command ShowRegs,    0,   0, International_Help
        Command ShowFPRegs,  0,   0, International_Help
        ]

d896 1
a896 1
 [ debug :LAND: True
d1155 3
d1159 1
a1159 1
        BLNE    checkreg        ;error if R8-R14 in list
d1165 1
a1165 1
        BNE     notbad ;R15 in list
d1168 1
a1168 1
        BEQ     notbad ;not forcing user
d1174 1
a1174 1
        BNE     notbad2 ;don't bother with next test
d1180 1
a1180 1
        BNE     notbad2 ; don't bother with next test
d1192 1
a1192 1
        TestBit 20                              ; If it's an STM
d1194 1
a1194 1
        TSTEQS  r4, r14                         ; and Rn is lowest in list, then it's okay
a1338 1
        [ ARMv6
a1339 3
        |
        BNE     Undefined               ; but ARM2 doesn't do that anymore
        ]
d1495 8
d1506 2
a1507 2
        ; format is        1111 0101 u101 nnnn 1111 iiii iiii iiii
        ;        or        1111 0111 u101 nnnn 1111 rrrr rtt0 mmmm
d1509 2
a1510 2
        ; PLD [Rn,#offset]
        ;     [Rn,{+|-}Rm{,shift}]
d1512 2
a1513 1
        ; where    u = Up/~Down
d1520 6
d1527 9
a1535 1
        MOV     r14, #Mistake_ARMv5E
d1537 1
a1537 1
        ]
d1539 2
a1540 1
        AddStr  Pld
d1544 2
a1550 1

d1560 1
a1560 5
Ldr     DCB     "LDR", 0
Str     DCB     "STR", 0
Open_B  DCB     ",[", 0
Close_B DCB     "],", 0
Pld     DCB     "PLD", 0
d1575 4
d1580 2
a1581 6
        [ ARMv6
        BEQ     maal                    ; opcode 4 = long multiply accumulatee accumulate
        BHI     Undefined               ; opcode 5-7 undefined
        |
        BHS     Undefined               ; opcode 4-7 undefined
        ]
a1708 1
 [ ARMv6
a1709 3
 |
        BNE     Undefined
 ]
d1795 1
a1795 1
        ; cccc 000x x0xx xxxx xxxx nnnn 1xx1 xxx is undefined if any of
d1801 1
a1801 5

5       AND     r5, r4, #1:SHL:24 :OR: 1:SHL:21
        TEQS    r5, #1:SHL:21           ; Check for post-indexed with W set (illegal)
        BEQ     Undefined

d1850 9
a1858 1

d1860 2
a1861 1
        BL      Tab_Dis_Register
a2157 1
        [ ARMv6
a2160 1
        ]
d2187 3
d2193 4
a2196 2
        BEQ     is_MSR
        B       Undefined
d2391 3
d2396 1
d2631 1
a2631 1
        BEQ     CoprocessorExtension     ; Post-indexed, down, no writeback
d2662 1
d2676 8
a2683 2

        TestStr 20,Mrrc,Mcrr,conds
d3069 2
a3070 3
        MOV     r14, r4, LSR #28
        TEQ     r14, #15
        BNE     %BT10
d3154 5
a3158 1

d3209 6
a3221 1

d3230 10
d5201 1
a5201 1
        MOV     r0, #&7E
@


4.26
log
@Update to work with zero page relocation
Detail:
  s/Debugger - Try reading DebuggerSpace location using OS_ReadSysInfo 6 before falling back on legacy address. Compute appropriate MOV PC,DebuggerSpace instruction instead of using hard-coded one.
Admin:
  Tested on rev A2 BB-xM


Version 1.82. Tagged as 'Debugger-1_82'
@
text
@d300 1
a300 1
                #       4*5             ; Save other registers before JMP
d863 1
a863 1
        STMFD   R13!,{R14}
d865 1
a865 1
        CMPS    R14,#Potential_Banked
d868 1
a868 1
        LDMFD   R13!,{R15}
d4804 3
a4806 1
        BIC     r7, r7, #ARM_CC_Mask    ; Can only set at word address in 64M
d5037 1
d5056 1
d5364 2
a5365 1
        STMIA   r14, {r0-r13}           ; Save registers 0 to 13 in dump area
@


4.25
log
@Rework *memoryi implementation to avoid alignment faults during Thumb disassembly on ARMv6+
Detail:
  s/Debugger - Reworked MemoryI_Code:
  * Avoid alignment faults when disassembling Thumb instructions by using LDRH or LDR-and-shift depending on compile-time architecture
  * Split ARM & Thumb disassembly into two seperate paths to (perhaps) increase readability
  * Cleaned up the code so it only reads each memory location once
Admin:
  Tested on rev C2 beagleboard.
  Current thumb disassembler looks like it could do with a bit of an overhaul when full support for the 32bit encodings is added.
  *memoryi code could also be made a bit nicer if we don't mind thumb disassembly failing if attempted on a CPU that can't (reliably) LDRH.


Version 1.81. Tagged as 'Debugger-1_81'
@
text
@d247 1
d332 3
d616 34
d652 3
a654 2
        ASSERT  nbreakpoints*8 <= ?DebuggerSpace
        MOV     R0, #DebuggerSpace + nbreakpoints*8
d657 2
a658 1
30      STMDB   R0!, {R1, R2}
d660 1
a660 1
        CMP     R0, #DebuggerSpace
d664 1
d666 2
a667 2
        MOV     r1, #DebuggerSpace
        ADD     r2, r1, #(nbreakpoints)*8-4
d672 2
d5734 1
a5734 2
        ASSERT  DebuggerSpace < &400
        LDR     r2, =&E3A0FF00 + (DebuggerSpace :SHR: 2)
@


4.24
log
@Fix code to be fully aware of 64bit parameter flags, fix accidental alignment exceptions on ARMv6/v7
Detail:
  s/Debugger - All code which calls ReadOneParm, ReadParm, etc. now correctly sets r10 to the correct value depending on whether they want to parse 64bit numbers or not. This was the cause of *InitStore malfunctioning and (presumably) trashing whatever R11 pointed to (bug #232)
  Also fixed MemoryHeader causing an unintentional alignment exception when testing if rotated or unaligned loads are in use. The CP15 registers are now interrogated instead.
Admin:
  Tested on rev C2 beagleoard. *Memory with unaligned addresses no longer aborts, and *InitStore <val> now uses the correct value, and seems to no longer trash memory
  Fixes bug #232


Version 1.80. Tagged as 'Debugger-1_80'
@
text
@d246 1
d3179 1
a3179 1
        BNE     %FT05
a3180 3
        ADD     r7, r7, r6

05
d3191 6
d3198 5
a3202 2
        MOVVC   r2, r6                  ; Display characters at address
        BLVC    DisplayCharacters
a3207 1

a3209 3
        Push    "r0, r1"
        MOV     r0, r9
        BL      do_readW
d3211 6
a3216 1
        Pull    "r0, r1"
d3218 14
a3231 5
        TEQS    r6, #4
        BNE     %F40
        BL      DisplayHexWord
        B       %F45
40      BL      DisplayHexHalfword
d3233 3
a3235 1
45      BLVC    MarkBreakpoints
d3237 3
d3242 7
a3248 11
        Push    "r1"
        MOV     r0, r9
        BL      do_readW
        MOV     r0, r1
        Pull    "r1"
        MOV     r1, r9
        TEQS    r6, #4
        BNE     %F50
        SWI     XDebugger_Disassemble
        B       %F55
50      SWI     XDebugger_DisassembleThumb
d5217 12
@


4.23
log
@  Now has a standalone build variant
Detail:
  Debugger now handles registering and deregistering its messages file with
  ResourceFS when you build a RAM (standalone) variant. This obsoletes the
  DbgMess module.
Admin:
  Tested briefly

Version 1.79. Tagged as 'Debugger-1_79'
@
text
@d3265 1
d3912 13
a3924 2
        LDR     r0, %FT50+1             ; try an unaligned load
        TEQ     r0, #0
a3943 2
50
        DCD     0, -1
d4570 1
d4738 1
d5484 2
d5606 2
@


4.22
log
@  Changes to make Debugger more useful on ARMv6/v7
Detail:
  * Added knowledge of the ARMv5TEJ / ARMv6 CPSR flags J, GE[3:0], E and A,
    plus Monitor mode
  * *Memory, *Memory H, *MemoryA and *MemoryA H can now access unaligned
    addresses; the header line in unaligned cases adapts depending on whether
    the CPU natively rotates or does unaligned loads
  * Added *Memory D and *MemoryA D for accessing 64-bit words using LDRD / STRD
  * Removed check for 32-bit mode before doing LDRH - this is nonsensial now
    that there are 32-bit builds for IOMD-class machines. I've decided to let
    it attempt LDRH even on platforms where it might not work or might be an
    undefined instruction - this gets us "closer to the metal", and it's not
    like *Memory couldn't already throw exceptions in normal use
  * Removed redundant clauses of a few build options, it was getting
    impractical to maintain the alternate build variants
Admin:
  Tested on rev B7 beagleboard. Requires an updated kernel in order to be
  able to specify 64-bit values on the command line or interactively (but
  even on older kernels you can enter a value less than 2^32 to *MemoryA D)

Version 1.78. Tagged as 'Debugger-1_78'
@
text
@d244 1
d280 5
d637 4
d650 4
a653 1
        DCD     Service_Reset
d660 3
d666 4
d678 13
d718 5
d5754 14
@


4.21
log
@Modified ASCII display in *Memory etc to read memory using the same access
size as the main output. This helps with some hardware registers that only
support, say, word-sized accesses. Note that the memory locations are still
read a second time for the ASCII display, so it's still not ideal for
read-sensitive hardware.

Added some ARMv6 support to disassembly, but this is incomplete and switched
out at the moment.

Version 1.77. Tagged as 'Debugger-1_77'
@
text
@d25 1
a272 3
                GBLL    Thumb
Thumb           SETL    True

a275 3
                GBLL    PhysAddr             ; allow physical address spec in *memory etc.
PhysAddr        SETL    {TRUE} :LAND: Thumb

a278 3
                GBLL    HalfWord        ; 'H' switch to *Memory[A]
HalfWord        SETL    True

a313 1
 [ Thumb
a315 2
 ]
 [ PhysAddr
a316 1
 ]
d403 3
a516 1
 [ Thumb
a517 1
 ]
a596 1
        [ Thumb
a598 2
        ]
        [ PhysAddr
a599 1
        ]
a699 1
 [ PhysAddr
a702 9
 |
        Command Memory,      4,   1,; B R + R
        Command MemoryA,     3,   1,; B R V
   [ Thumb
        Command MemoryI,     6,   1,; T A +/- B + C
   |
        Command MemoryI,     5,   1,; A +/- B + C
   ]
 ]
a711 1
 [ PhysAddr
a714 9
 |
        Command Memory,      4,   1, International_Help     ; B R + R
        Command MemoryA,     3,   1, International_Help     ; B R V
   [ Thumb
        Command MemoryI,     6,   1, International_Help     ; T A +/- B + C
   |
        Command MemoryI,     5,   1, International_Help     ; A +/- B + C
   ]
 ]
a738 1
 [ Thumb
a740 1
 ]
a771 1
 [ Thumb
a776 1
 ]
a3116 1
 [ Thumb
a3120 3
 |
        LDR     wp, [r12]
 ]
d3123 1
a3123 1
 [ Thumb
a3124 3
 |
        BL      GetCommandParms_R0
 ]
a3128 1
 [ Thumb
a3130 3
 |
        ADDEQ   r7, r9, #4*24
 ]
a3131 1
 [ Thumb
a3137 4
 |
        BIC     r9, r9, #3              ; ensure word aligned
        BIC     r7, r7, #3
 ]
a3155 1
 [ Thumb
a3156 4
 |
        MOVVC   r2, #4                  ; Display characters at address
        MOVVC   r6, #4
 ]
a3165 1
 [ PhysAddr
a3170 3
 |
        LDR     r10, [r9]               ; Display word at address
 ]
a3171 1
 [ Thumb
a3173 1
 ]
a3174 1
 [ Thumb
a3176 1
 ]
a3181 1
 [ PhysAddr
a3186 3
 |
        LDR     r0, [r9]                ; Display instruction at address
 ]
a3187 1
 [ Thumb
a3189 1
 ]
a3190 1
 [ Thumb
a3192 1
 ]
a3198 1
 [ Thumb
a3199 3
 |
        ADD     r9, r9, #4
 ]
d3354 28
d3475 1
a3475 1
        DCB     "10110", 0
d3511 1
a3511 1
Memory_Code Entry "r6-r11"
a3512 1
 [ Thumb
a3513 1
 ]
d3517 1
a3524 11
 [ HalfWord
        SUB     r6, r6, #1
        BIC     r9, r9, r6              ; Round down by appropriate amount
        BIC     r7, r7, r6
        ADD     r6, r6, #1
 |
        TEQS    r6, #4                  ; Round down if words
        BICEQ   r9, r9, #3
        BICEQ   r7, r7, #3
 ]

d3561 4
a3564 8
 [ HalfWord
        CMP     r6, #2
        MOVHI   r8, r8, LSR #2          ; words per line
        MOVEQ   r8, r8, LSR #1          ; half-words per line
 |
        TEQS    r6, #4
        MOVEQ   r8, r8, LSR #2          ; words per line
 ]
d3569 2
a3570 1
      [ HalfWord
a3573 5
      |
        TEQS    r6, #4                  ; Need to size reset each loop
        MOVEQ   r2, #32-4               ; word
        BEQ     %FT20
      ]
d3578 1
d3580 2
a3581 2
        TEQ     r0, r7
        BEQ     %FT50                   ; [ended, so blank. DO NOT READ BYTE]
a3582 2
 [ PhysAddr
        BVS     %FA30
a3588 4
 |
        LDRVCB  r10, [r0], #1           ; <<<get from buffer
        B       %FA30
 ]
a3589 1
 [ HalfWord
d3593 2
a3594 1
        SWI     XOS_WriteI+space
d3596 2
a3597 2
        TEQ     r0, r7
        BEQ     %FT50                   ; [ended, so blank. DO NOT READ BYTE]
a3598 2
        BVS     %FA30
 [ PhysAddr
a3604 7
 |
        TEQ     pc, pc
        LDRNE   r10, [r0], #2
        LDREQH  r10, [r0], #2           ; <<<get from buffer
        B       %FA30
 ]
 ]
a3606 1
 [ HalfWord
a3607 1
 ]
d3611 1
d3613 2
a3614 2
        TEQ     r0, r7
        BEQ     %FT50                   ; [ended, so blank. DO NOT READ WORD]
a3615 2
 [ PhysAddr
        BVS     %FT30
d3621 18
a3638 3
 |
        LDRVC   r10, [r0], #4           ; <<<get from buffer
 ]
a3679 1
 [ PhysAddr
d3684 24
a3726 1
 [ HalfWord
d3733 1
a3733 3
        TEQ     pc, pc
        LDRNE   r1, [r0]
        LDREQH  r1, [r0]
d3741 1
a3741 3
        TEQ     pc, pc
        LDRNE   r2, [r2]         ;read from logical mapping
        LDREQH  r2, [r2]
a3746 1
 ]
d3767 24
a3810 1
 [ HalfWord
d3817 1
a3817 9
        TEQ     pc, pc
        STREQH  r1, [r0]
        Pull    "r0-r3, pc",EQ
        LDR     r14, [r0]
        MOV     r14, r14, LSR #16
        ORR     r14, r14, r1, LSL #16
        TST     r0, #2
        MOVEQ   r14, r14, ROR #16
        STR     r14, [r0]
a3825 2
        TEQ     pc, pc
        BNE     %FT75
d3827 1
a3827 1
60      MOVVC   r0, #15
a3831 8
75      LDR     r14, [r2]
        MOV     r14, r14, LSR #16
        ORR     r14, r14, r1, LSL #16
        TST     r2, #2
        MOVEQ   r14, r14, ROR #16
        STR     r14, [r2]        ;write to logical mapping
        B       %BT60
 ]
a3852 2
 ] ;PhysAddr

d3873 16
a3888 1
 [ HalfWord
a3889 1
        ADRHI   r0, Words
d3892 1
a3892 6
 |
        TEQ     r6, #4
        ADREQ   r0, Words
        ADRNE   r0, Bytes
 ]
        MOV     lr, pc
d3894 3
a3896 1

d3921 2
a3922 1
; Print header in right order dependent on r9 (0,4,8,C)
d3924 1
a3924 1
Words Entry "r9, r10, r11"
d3927 21
d3949 5
a3953 1
        ADR     r10, Words_Header
d3956 1
a3956 1
        DCB     "     ", 0
d3959 2
a3960 2
        ADDVC   r0, r10, r9, LSL #1
        SWIVC   XOS_Write0
d3969 11
a3979 5
Words_Header
        DCB     "3 2 1 0", 0
        DCB     "7 6 5 4", 0
        DCB     "B A 9 8", 0
        DCB     "F E D C", 0
d3981 11
d3993 4
a3996 1
 [ HalfWord
d3998 3
a4000 1
; Print header in right order dependent on r9 (0,2,4,6,8,A,C,E)
d4005 2
a4006 2

        ADR     r10, HalfWords_Header
d4009 1
a4009 1
        DCB     "   ", 0
d4012 3
a4014 2
        ADDVC   r0, r10, r9, LSL #1
        SWIVC   XOS_Write0
d4023 15
a4037 9
HalfWords_Header
        DCB     "1 0", 0
        DCB     "3 2", 0
        DCB     "5 4", 0
        DCB     "7 6", 0
        DCB     "9 8", 0
        DCB     "B A", 0
        DCB     "D C", 0
        DCB     "F E", 0
d4039 44
a4082 1
 ]
d4124 1
a4124 2
 [ HalfWord
;       r6 = 1, 2 or 4 if r6 = 'B' on entry, else r6 = 1 or 4 depending on whether 'r6' present
a4125 7
 |
 [ Thumb
;       r6 = 1 or 4 depending on whether 'r6' present (+ skipped)
 |
;       r6 = 1 or 4 depending on whether 'B' present (+ skipped)
 ]
 ]
a4133 1
 [ PhysAddr
a4136 1
 ]
a4138 2
 [ HalfWord
        ASSERT  Thumb
d4140 14
a4153 5
        MOVEQ   r14, #'H'               ; alternate character
        MOVNE   r14, r6

        TEQ     r0, r6                  ; Check upper case
        TEQNE   r0, r14
a4154 1
        ADDNE   r14, r14, #"a"-"A"
a4155 8
        TEQNE   r0, r14

        LDREQB  r14, [r1, #1]
        TEQEQ   r14, #space
        MOVNE   r6, #4                  ; Neither found
        BNE     %FT50
        ADD     r1, r1, #2              ; skip 'r6',space
        TEQ     r0, r6                  ; First or only alternate?
d4157 1
a4157 11
        MOVNE   r6, #2
50
 |
 [ Thumb
        TEQ     r0, R6                  ; Check upper case
        ADDNE   r6, r6, #"a"-"A"
        TEQNE   r0, R6                  ; Check lower case
 |
        TEQ     r0, #"b"
        TEQNE   r0, #"B"
 ]
d4160 2
a4161 4
        ADDEQ   r1, r1, #2              ; skip 'r6',space
        MOVEQ   r6, #1                  ; bytes (or Thumb)
        MOVNE   r6, #4                  ; otherwise
 ]
a4162 1
 [ PhysAddr
a4165 1
 ]
a4168 1
 [ PhysAddr
a4188 1
 ]
d4192 1
a4192 1
MemoryA_Code Entry "r6-r11"
a4193 1
 [ Thumb
a4194 1
 ]
d4198 4
a4207 9
 [ HalfWord
        SUB     r6, r6, #1
        BIC     r9, r9, r6              ; Round down by appropriate amount
        ADD     r6, r6, #1
 |
        TEQS    r6, #4                  ; round down if words
        BICEQ   r9, r9, #3
 ]

d4215 2
a4216 2
 [ HalfWord
        ASSERT  PhysAddr
d4220 2
a4221 7
 |
        TEQ     r6, #4
 [ PhysAddr
        BNE     mai_byte
 ]
 ]
 [ PhysAddr
a4233 7
 |
        MOVEQ   r2, #32-4
        LDREQ   r4, [r9]
        STREQ   r7, [r9]
        LDREQ   r5, [r9]
        ADREQ   r0, %FT40
 ]
d4235 15
a4249 1
 [ PhysAddr :LAND: HalfWord
a4262 1
 ]
a4263 1
 [ PhysAddr
a4276 7
 |
        MOVNE   r2, #8-4
        LDRNEB  r4, [r9]
        STRNEB  r7, [r9]
        LDRNE   r5, [r9]
        ADRNE   r0, %FT41
 ]
a4301 1
 [ HalfWord
d4304 2
a4305 1
 ]
a4339 2
        ASSERT  PhysAddr :LOR: :LNOT: HalfWord
 [ HalfWord
a4340 2
 ]
 [ PhysAddr
d4343 5
a4347 2
 [ HalfWord
        ADD     lr, pc, #12             ; they don't return using MOVS
a4348 1
        BHI     do_readW
d4351 1
a4351 6
 |
        TEQ     r6, #4
        BLEQ    do_readW
        TEQ     r6, #4
        BLNE    do_readB
 ]
a4353 5
 |
        TEQ     r6, #4
        LDREQ   r10, [r9]
        LDRNEB  r10, [r9]
 ]
a4358 1
 [ HalfWord
d4360 3
a4363 1
        MOVHI   r2, #32-4
a4365 5
 |
        TEQ     r6, #4
        MOVEQ   r2, #32-4
        MOVNE   r2, #8-4
 ]
a4371 1
 [ HalfWord
d4373 2
d4376 2
a4377 4
        BLO     %FT50                   ; Only don't disassemble when doing bytes
        BHI     %FT40

        ASSERT  PhysAddr
a4388 4
 |
        TEQ     r6, #4                  ; Only disassemble when doing words
        BNE     %FT50
 ]
a4389 1
 [ PhysAddr
a4396 3
 |
        LDRVC   r0, [r9]
 ]
d4434 4
a4437 1
        Push    r8
d4439 1
a4439 1
        Pull    r8
d4442 2
a4443 2
 [ HalfWord
        ASSERT  PhysAddr
d4445 4
a4448 9
        BLO     %FT60
        BEQ     %FT55
 |
 [ PhysAddr
        TEQ     r6, #4
        BNE     %FT60
 ]
 ]
 [ PhysAddr
a4457 6
 |
        TEQ     r6, #4
        STREQ   r7, [r9]
        LDREQ   r10, [r9]
        MOVEQ   r2, #32-4
 ]
d4459 12
a4470 2
 [ HalfWord :LAND: PhysAddr
55
a4479 1
 ]
d4481 1
a4481 2
 [ PhysAddr
60
a4490 5
 |
        STRNEB  r7, [r9]
        LDRNEB  r10, [r9]
        MOVNE   r2, #8-4
 ]
d5054 2
d5069 12
a5097 1
 [ Thumb
a5102 1
 ]
d5112 1
a5112 1
DisplayCharacters Entry "r0-r3, r9"
d5114 1
a5115 1
 [ PhysAddr
d5117 5
a5122 1
        CMP     r6, #2
d5126 6
a5131 11
15      MOV     r0, r1
        ADD     r9, r9, r6
 |
        CMP     r6, #2
        LDRLOB  r0, [r9], r6
        LDREQH  r0, [r9], r6
        LDRHI   r0, [r9], r6
 ]
        MOV     r3, r6
        MOV     r1, r0
20      AND     r0, r1, #&FF
d5138 4
a5141 2
        SUBS    r3, r3, #1
        MOV     r1, r1, LSR #8
d5144 2
a5145 2
        SUBS    r2, r2, r6
        BNE     %BT10
d5334 2
d5368 1
d5389 3
a5391 1
50      BL      ReadParm                ; r7 := parm2
d5496 4
a5499 1
40      MOV     r0, #16                 ; allow any term, read hex
d5510 16
d5534 3
d5545 3
@


4.20
log
@  A new feature and a bugfix.
Detail:
  * Added 'H' flag to *Memory and *MemoryA to allow half-word memory accesses.
    On 26-bit machines, this is emulated using 32-bit reads and read-modify-
    writes; on 32-bit machines, LDRH and STRH are used. Address header in
    *Memory byte mode changed to be only one digit per byte for consistency
    with word and half-word modes. *MemoryA H in interactive mode gives a
    Thumb disassembly.
  * STM Rn!,{reg_list_including_Rn} is actually allowed, provided Rn is the
    lowest register in the list. Warning code adjusted accordingly.
Admin:
  Tested on Risc PC and Tungsten.

Version 1.76. Tagged as 'Debugger-1_76'
@
text
@d269 3
d275 3
d395 1
d1288 3
d1292 1
a1447 6
Ldr     DCB     "LDR", 0
Str     DCB     "STR", 0
Open_B  DCB     ",[", 0
Close_B DCB     "],", 0
Pld     DCB     "PLD", 0

d1482 1
d1488 5
a1492 1
        ALIGN
d1508 4
d1513 1
d1638 9
a1673 4
        ; Rd=R15 -> unpredictable
        TEQS    r5,#15
        MOVEQ   r14,#Mistake_R15
        STREQ   r14,Mistake
d1678 5
d1686 5
a1694 4
        ; Rm=Rn -> unpredictable
        TEQS    r5,r9
        MOVEQ   r14,#Mistake_RmRn
        STREQ   r14,Mistake
d1696 1
a1697 1

a1698 4
        ; Rn=R15 -> unpredictable
        TEQS    r5,#15
        MOVEQ   r14,#Mistake_R15
        STREQ   r14,Mistake
a1700 6
        [ {FALSE}
        BL      Tab
        ADR     R10,arm3only
        BL      lookup_r10
        BL      SaveString
        ]
d1707 1
a1707 5
        TSTEQS  r4, #1:SHL:23
        BEQ     swp

        TSTS    r4, #2_11:SHL:5
        BEQ     Undefined
d2087 7
a2093 1
        ; then split the regester form up by bits 4:7.
d2101 2
a2102 3
        TEQ     r5, #2_0001 :SHL: 4
        TEQNE   r5, #2_0011 :SHL: 4
        BEQ     CLZ_BX_type                     ; 1,3 = CLZ/BX
d2171 1
d2215 1
a2215 4
        TEQ     r5, #2_0010:SHL:4
        BEQ     Undefined

        ; arrive here with cccc 0001 0xx0 xxxx xxxx xxxx 00x1 xxxx
d2219 1
a2219 1
is_BX   ; arrive here with cccc 0001 00x0 xxxx xxxx xxxx 00x1 xxxx
d2233 3
d2248 12
d2282 1
a2282 1
is_CLZ  ; arrive here with cccc 0001 01x0 xxxx xxxx xxxx 00x1 xxxx
d3071 1
d3215 1
d5112 1
d5117 1
a5117 1
DisplayCharacters Entry "r0, r2, r9"
a5120 1
        Push    "r1"
d5122 7
a5128 4
        BL      do_readB
        MOV     r0, r1
        ADD     r9, r9, #1
        Pull    "r1"
d5130 4
a5133 1
        LDRB    r0, [r9], #1
d5135 3
d5144 3
d5148 1
a5148 1
        SUBS    r2, r2, #1
d5694 1
a5694 1
        LNK     s.FP
@


4.19
log
@  Merged in Kevin's latest version, as featured in OS release 5.00.
Detail:
  * Added Q bit to *ShowRegs
  * Added FMSRR, FMRRS, FMDRR and FMRRD to VFP support
  * Shortened lots of VFP literals by treating common "F" prefix separately
  * Cirrus DSP support (switched out)
  * Piccolo support (not even linked in)
  * ARM/Thumb disassembly test programs added
  * Bugfix: code variable init code was trashing the flags that indicated
    whether zero page branch table (used for breakpoints in 32-bit mode) needs
    creating
Admin:
  Builds identical binary to 5.00 release, repository changes were build-
  related only.

Version 1.75. Tagged as 'Debugger-1_75'
@
text
@d278 3
d1131 6
a1136 1
        TSTS    r4, r14, LSL r10
d3546 6
d3555 1
d3593 5
d3600 1
d3605 5
d3613 1
d3635 5
d3641 24
a3664 1
20      SWI     XOS_WriteS              ; Display word
d3746 27
d3812 41
d3895 6
d3904 1
d3961 36
d4005 2
a4006 1
        MOVVC   r2, #8-4
d4037 4
d4046 1
d4062 23
d4098 1
d4147 5
d4154 1
d4163 6
d4172 3
d4195 16
d4257 4
d4295 4
d4302 7
d4313 1
d4326 7
d4336 1
d4343 19
d4364 1
d4419 6
d4428 3
d4445 13
@


4.18
log
@* Fixed register clash warnings on SWP.
* Changes to message files to correct syntax errors.
* *MemoryX P works on IOMD-based systems is OS_Memory 13 fails.
* Changed to use ObjAsm and centralised Makefiles.

Version 1.73. Tagged as 'Debugger-1_73'
@
text
@d608 1
a608 7

        ; SAR
        MOV     R3, #0
        STR     R3, DisOpts
        BL      create_codevar
        BL      init_codevar
        EXIT    EQ
d629 7
d2567 10
a2576 1
        MOV     r5, r4, LSR #12
d2578 1
a2578 1
        BL      Comma_Dis_Register
a2581 4
        BL      AddComma
        MOV     r5, r4
        BL      Dis_C_Register

d2583 1
a2583 1
        BEQ     %F10
a2586 1

d2591 1
a2591 2

        B       InstructionEnd
d3388 4
@


4.17
log
@memory, memorya and memoryi commands support p option,
which specifies physical rather than logical addresses
only functional with kernel that support OS_Memory 14 and 15

Version 1.72. Not tagged
@
text
@d214 11
a224 3
; 1.72  SAR 28-Apr-01    Introduced the Disassemble$Options code variable to control
;                        various alternatives for disassembly. In particular, the
;                        register name output can now be in APCS mode(s).
d488 1
a488 1
        LEADR   Module_LoadAddr
d537 1
a537 1
Debug_Init ENTRY
d605 1
a605 1
        mrs    ,R3, CPSR
d654 1
a654 1
        ENTRY   "r0, r1"
d665 1
a665 1
Debug_Die ENTRY
d758 1
a758 1
Debug_SWI_Code ENTRY "r9"
d824 1
a824 1
Instruction ENTRY "r0, r3-r9"
d1636 3
d1640 1
a1640 1
        AND     r9,r5,#2_1111           ; Rd
d1642 1
a1642 1
        TEQS    r9,#15
d1645 4
d1656 1
a1656 1
        ; Rd=Rm -> unpredictable
d1658 1
a1658 1
        MOVEQ   r14,#Mistake_RdRm
d1663 1
a1663 2
        MOV     R5,R4,LSR #16
        AND     r5,r5,#2_1111           ; Rn
a1667 4
        ; Rd=Rn -> unpredictable
        TEQS    r5,r9
        MOVEQ   r14,#Mistake_RdRn
        STREQ   r14,Mistake
d2699 1
a2699 1
Tab_CPN ENTRY
d2743 1
a2743 1
        ENTRY
d2815 1
a2815 1
 
d2898 1
a2898 1
Conditions ENTRY "r1, r10"
d2959 1
a2959 1
Tab ENTRY
d2990 1
a2990 1
        ENTRY   "r5"
d3039 1
a3039 1
StoreHex ENTRY "r2"
d3080 1
a3080 1
StoreDecimal_Comma ENTRY
d3111 1
a3111 1
MemoryI_Code ENTRY "r6-r11"
d3257 1
a3257 1
InitStore_Code ENTRY "r6-r11"
d3295 1
a3295 1
ShowRegs_Code_Common ENTRY "r6-r11"
d3500 1
a3500 1
DoFlagBit ENTRY
d3515 1
a3515 1
Memory_Code ENTRY "r6-r11"
d3614 1
a3614 1
        Pull    "r1"        
d3660 3
d3674 2
d3677 4
a3680 4
        MOV     r0, #15
        MOV     r1, r3
        SWI     XOS_Memory       ;release physical address
        MOV     r1, r2
d3693 2
d3696 4
a3699 4
        MOV     r0, #15
        MOV     r1, r3
        SWI     XOS_Memory       ;release physical address
        MOV     r1, r2
d3712 2
d3716 4
a3719 3
        MOV     r0, #15
        MOV     r1, r3
        SWI     XOS_Memory       ;release physical address
d3732 2
d3736 4
a3739 3
        MOV     r0, #15
        MOV     r1, r3
        SWI     XOS_Memory       ;release physical address
d3746 1
a3746 1
SpaceColonSpace ENTRY
d3755 1
a3755 1
MemoryHeader ENTRY
d3796 1
a3796 1
Words ENTRY "r9, r10, r11"
d3826 1
a3826 1
Bytes ENTRY "r9, r10, r11"
d3847 1
a3847 1
Blank ENTRY
d3869 1
a3869 1
MemoryCommon ENTRY
d3911 1
a3911 1
        ; check for 'P',space, 
d3923 1
a3923 1
        SWI     XOS_MMUControl 
d3929 1
a3929 1
MemoryA_Code ENTRY "r6-r11"
d4201 1
a4201 1
BreakSet_Code ENTRY "r6-r11"
d4290 1
a4290 1
BreakList_Code ENTRY "r6-r11"
d4367 1
a4367 1
BreakClr_Code ENTRY "r6-r11"
d4439 1
a4439 1
ClearBreakpoint ENTRY "r0-r2, r10"
d4478 1
a4478 1
Continue_Code ENTRY "r6-r11"
d4636 2
a4637 2
        msr    ,CPSR_c, r1              ; Enter correct mode, ints off
        msr    ,SPSR_cxsf, r14_svc      ; Set up SPSR ready for return
d4641 1
a4641 1
        mrs    ,r14_svc, CPSR
d4643 1
a4643 1
        msr    ,CPSR_c, r14_svc         ; IRQs off for SPSR use
d4646 1
a4646 1
        msr    ,SPSR_cxsf, r14_svc      ; Set up SPSR ready for return
d4679 1
a4679 1
Debug_Code_Common ENTRY "r6-r11"
d4710 1
a4710 1
AckEscape ENTRY "r1, r2"
d4723 1
a4723 1
PrintError ENTRY
d4736 1
a4736 1
DisplayHex ENTRY "r0, r2"
d4760 1
a4760 1
DisplayHexWord ENTRY "r2"
d4769 1
a4769 1
DisplayHexHalfword ENTRY "r2"
d4783 1
a4783 1
DisplayCharacters ENTRY "r0, r2, r9"
d4810 1
a4810 1
DisplayDecimalNumber ENTRY "r0-r2"
d4831 1
a4831 1
MarkBreakpoints ENTRY "r2, r3"
d4915 1
a4915 1
        mrs    ,r4, CPSR
d5011 1
a5011 1
GetCommandParms ENTRY "r2"
d5022 1
a5022 1
        ENTRY
d5099 1
a5099 1
ReadParm ENTRY "r2"
d5109 1
a5109 1
        ENTRY
d5186 1
a5186 1
ReadOneParm ENTRY "r0"
d5242 1
a5242 1
lookup_r10 ENTRY r0-r7
d5260 1
a5260 1
        ENTRY   r0-r7
d5275 1
a5275 1
message_write0 ENTRY r0-r7
d5298 1
a5298 1
CopyErrorP1 ENTRY r1-r7
d5307 1
a5307 1
CopyError ENTRY r1-r7
d5326 1
a5326 1
open_messagefile ENTRY r0-r2
@


4.16
log
@  * Added a couple of tweaks to the MakeMess and MkClean files.
  * Added the Disassemble$Options system variable.
Detail:
  * MakeMess now does a CDir command (in case you run it before
    running MkRom). MkClean now includes a 'stripdepnd' call.

  * There is a new system (code) variable created on module init
    called Disassemble$Options. This controls (at the moment)
    register naming for disassembly.
Admin:
  Tested on RiscOS 4 and 3.70.

Version 1.72. Tagged as 'Debugger-1_72'
@
text
@d264 3
d307 4
a310 1
OldThumbInst	#	4		; last Thumb instruction disassembled
d320 28
a347 28
DisOpts		#	4		; Disassembler options
DisOpt_APCS	*	2_1		; Use APCS register names (when set)
DisOpt_v6	*	2_10		; Use 'v6' rather than 'sb'
DisOpt_v7	*	2_100		; Use 'v7' rather than 'sl'
DisOpt_v8	*	2_1000		; Use 'v8' rather than 'fp'
DisOpt_sp	*	2_10000		; Use 'SP' rather than 'R13'
DisOpt_lr	*	2_100000	; Use 'LR' rather than 'R14'
DisRegLabels	*	@@		; Pointers to register name strings
DisReg_R0	#	4
DisReg_R1	#	4
DisReg_R2	#	4
DisReg_R3	#	4
DisReg_R4	#	4
DisReg_R5	#	4
DisReg_R6	#	4
DisReg_R7	#	4
DisReg_R8	#	4
DisReg_R9	#	4
DisReg_R10	#	4
DisReg_R11	#	4
DisReg_R12	#	4
DisReg_R13	#	4
DisReg_R14	#	4
DisReg_R15	#	4
DisReg_F	#	1		; Prefix char for FP registers
DisReg_C	#	1		; Prefix char for Co-pro registers
		#	1
		#	1
d357 11
a367 11
		^	1
Mistake_PlingHat #	1
Mistake_Banked	#	1
Mistake_SWICDP	#	1
Mistake_MUL	#	1
Mistake_R15shift #	1
Mistake_R15	#	1
Mistake_PCwriteback #	1
Mistake_BytePC	#	1
Mistake_StorePC	#	1
Mistake_Unpred	#	1
d369 7
a375 7
Mistake_RmRn	#	1
Mistake_RdLoRdHi #	1
Mistake_RdLoRm	#	1
Mistake_RdHiRm	#	1
Mistake_Rninlist #	1
Mistake_RdRm	#	1
Mistake_STMHat	#	1
d379 3
a381 3
		^	-1
Potential_SWICDP #	-1
Potential_Banked #	-1
d383 1
a383 1
Potential_SWICDP_Next #	-1
d387 1
a387 1
ExeBufLen	*	4+4+4+?Registers
d400 8
a407 8
TAB		*       9
LF		*       10
CR		*       13
space		*       " "
quote		*       """"
colon		*       ":"
delete		*       &7F
ampersand	*	"&"
d413 5
a417 5
	MACRO
	AddChar	  $c,$cond
	MOV$cond  R10,#"$c"
	STR$cond.B R10,[R0],#1
	MEND
d422 3
a424 3
	MACRO
	AddStr	$c,$cond,$conds,$two
	ADR$cond R10,$c
d426 1
a426 1
	  BL$cond  SaveStringConditions$two
d428 1
a428 1
	  BL$cond  SaveString
d430 1
a430 1
	MEND
d436 16
a451 16
	MACRO
	TestBit	$bit,$set,$unset
	TSTS	R4,#1:SHL:$bit
	[ "$set" <> "" :LAND: "$unset" <> ""
	MOVEQ	R10,#"$unset"
	MOVNE	R10,#"$set"
	STRB	R10,[R0],#1
	|
	  [ "$set" <> ""
	  AddChar "$set",NE
	  ]
	  [ "$unset" <> ""
	  AddChar "$unset",EQ
	  ]
	]
	MEND
d457 20
a476 20
	MACRO
	TestStr	$bit,$set,$unset,$conds,$two
	TSTS	R4,#1:SHL:$bit
	[ "$set" <> "" :LAND: "$unset" <> ""
	ADREQ	R10,$unset
	ADRNE	R10,$set
	  [ "$conds" <> ""
	  BL	SaveStringConditions$two
	  |
	  BL	SaveString
	  ]
	|
	  [ "$set" <> ""
	  AddStr   $set,NE,$conds
	  ]
	  [ "$unset" <> ""
	  AddStr   $unset,EQ,$conds
	  ]
	]
	MEND
d555 4
a558 4
	MOV	r0, #1
	MOV	r1, r2
	ADD	r2, r1, #(nbreakpoints*8)
	SWI	XOS_SynchroniseCodeAreas
d590 7
a596 4
	[ Thumb
	STR	R3, OldThumbAddress
	STR	R3, OldThumbInst
	]
d601 5
a605 5
	; SAR
	MOV	R3, #0
	STR	R3, DisOpts
	BL	create_codevar
        BL	init_codevar
d620 2
a621 2
	MOV	r0, #1
	MOV	r1, #DebuggerSpace
d623 1
a623 1
	SWI	XOS_SynchroniseCodeAreas
d634 4
a637 4
	DCD	0
	DCD	Debug_ServiceBody - Module_BaseAddr
	DCD	Service_Reset
	DCD	0
d639 1
a639 1
	DCD	Debug_ServiceTable - Module_BaseAddr
d641 1
a641 1
	MOV	r0, r0
d675 2
a676 2
	MOV	r0, #0
	STR	r0, MessageFile_Open
d678 2
a679 2
	; SAR
	BL	destroy_codevar
d690 10
a699 10
        Command BreakClr,          1, 0,
        Command BreakList,         0, 0,
        Command BreakSet,          1, 1,
        Command Continue,          0, 0,
        Command Debug,             0, 0,
        Command InitStore,         1, 0,
        Command Memory,            4, 1,; B R + R
        Command MemoryA,           3, 1,; B R V
 [ Thumb
        Command MemoryI,           6, 1,; T A +/- B + C
d701 7
a707 1
        Command MemoryI,           5, 1,; A +/- B + C
d709 2
a710 2
        Command ShowRegs,          0, 0,
        Command ShowFPRegs,        0, 0,
d712 10
a721 10
        Command BreakClr,          1, 0, International_Help
        Command BreakList,         0, 0, International_Help
        Command BreakSet,          1, 1, International_Help
        Command Continue,          0, 0, International_Help
        Command Debug,             0, 0, International_Help
        Command InitStore,         1, 0, International_Help
        Command Memory,            4, 1, International_Help     ; B R + R
        Command MemoryA,           3, 1, International_Help     ; B R V
 [ Thumb
        Command MemoryI,           6, 1, International_Help     ; T A +/- B + C
d723 7
a729 1
        Command MemoryI,           5, 1, International_Help     ; A +/- B + C
d731 2
a732 2
        Command ShowRegs,          0, 0, International_Help
        Command ShowFPRegs,        0, 0, International_Help
d756 2
a757 2
	TEQ	R11,#1
	BEQ	swi01
d792 2
a793 2
	MOV	R9,R1
	BL	ThumbInstruction
d795 1
a795 1
	EXIT
d862 1
a862 1
	ADR	r0, StringBuffer	; Reset pointer
d888 1
a888 1
	SUBS	r2, r0, r1		; Clears V flag
d890 1
a890 1
	EXIT
d896 7
a902 7
	; arrive here with cccc 1111 xxxx xxxx xxxx xxxx xxxx xxxx
	; format is        cccc 1111 nnnn nnnn nnnn nnnn nnnn nnnn
	;
	; SWI{cond} <number|name>
	;
	; where cccc = condition
	;       nnnn = number
d909 1
a909 1
	AddStr	Swi_Instruction,,conds
d918 4
a921 4
	BVS	InstructionEnd
	MOV	R3, #24
        BL	unknown_swis
        ADD	r0, r1, r2
d940 4
a943 4
	Entry
	; Ensure all bytes after the SWI name string up to the next word boundary are zero
	MOV	R14, #0
	ADD	R8, R1, R2
d945 16
a960 16
	TST	R8, #2_11
	STRNEB	R14, [R8], #1
	BNE	unk_swi_align
	; Compare this SWI name string against some pre-defined unknown SWI name strings
	ADR	R8, str_user
	BL	strcmp
	ADRNE	R8, str_xuser
	BLNE	strcmp
	ADRNE	R8, str_os_undefined
	BLNE	strcmp
	ADRNE	R8, str_xos_undefined
	BLNE	strcmp
	BEQ	unk_swi_replace
	SUB	R2,R2,#1                ; Adjust to avoid taking the zero byte
	EXIT
	; Replace the SWI name string with the SWI number decoded as hexadecimal
d962 6
a967 6
	MOV	R8, R0
	MOV	R0, R1
	SUB	R2, R3, #4
	BL	StoreHex
	SUB	R2, R0, R1		; Convert end pointer back to offset
	EXIT
d980 1
a980 1
	Entry	"R0, R1"
d982 6
a987 6
	LDR	R0, [R1], #4
	LDR	R14, [R8], #4
	TEQ	R0, R14
	BNE	strcmp_exit		; Conditional Pull is bad on newer ARMs, branch instead
	TST	R0, #&FF000000
	BNE	strcmp_loop
d989 1
a989 1
	EXIT
d991 1
a991 1
	; Some SWI names indicating that a SWI number was not recognised (in length order)
d993 2
a994 2
	DCB	"User", 0
	ALIGN
d996 2
a997 2
	DCB	"XUser", 0
	ALIGN
d999 2
a1000 2
	DCB	"OS_Undefined", 0
	ALIGN
d1002 2
a1003 2
	DCB	"XOS_Undefined", 0
	ALIGN
d1061 1
a1061 1
Unknown DCB     "M00", 0		; "Undefined instruction"
d1073 13
a1085 13
	; arrive here with cccc 100x xxxx xxxx xxxx xxxx xxxx xxxx
	; format is        cccc 100p uswl nnnn rrrr rrrr rrrr rrrr
	;
	; <LDM|STM>{cond}<I|D><A|B> Rn{!},register list{^}
	;
	; where cccc = condition
	;          p = Pre-indexing/~Post-indexing
	;          u = Up/~Down
	;          s = the ^ bit (transfer user registers, or restore PSR)
	;          w = Writeback
	;          l = Load/~Store
	;       nnnn = Rn
	;       rrrr = register list
d1094 1
a1094 1
        TestBit	15
d1097 1
a1097 1
        TestBit	22
d1101 1
a1101 1
        TestBit	21
d1107 1
a1107 1
        TestBit	20
d1110 1
a1110 1
	BNE	notbad2 ; don't bother with next test
d1113 10
a1122 10
	;case 3 - Rn in list with writeback
	TestBit	21
	BEQ	notbad3
	MOV	r10, r4, LSR #16
	AND	r10, r10, #2_1111
	MOV	r14, #1
	TSTS	r4, r14, LSL r10
	MOVNE	r10,#Mistake_Rninlist
	STRNE	r10,Mistake
	BNE	notbad2
d1125 14
a1138 14
	;case 4 - storing PC
	AND	r14, r4, #1 :SHL: 20 :OR: 1 :SHL: 15
	TEQ	r14, #1 :SHL: 15
	BNE	notbad2
	; okay, we're storing PC, but complaining about APCS would be boring.
	; Therefore don't bother whinging about STMFD R13!,{[any R0-R9],R11,R12,R14,PC}
	AND	r14, r4, #2_1111 :SHL: 21
	TEQ	r14, #2_1001 :SHL: 21		; Check FD, !, and no ^
	ANDEQ	r14, r4, #2_1111 :SHL: 16
	TEQEQ	r14, #13 :SHL: 16		; Check R13
	ANDEQ	r14, r4, #2_1111110000000000
	TEQEQ	r14,     #2_1101100000000000
	MOVNE	r10,#Mistake_StorePC
	STRNE	r10,Mistake
d1141 1
a1141 1
	TestStr	20,Ldm,Stm,conds        ; Load/~Store bit
d1143 1
a1143 1
	TestBit	23,"I","D"              ; Up/~Down bit
d1145 1
a1145 1
	TestBit	24,"B","A"              ; Pre/~Post bit
d1148 4
a1151 4
	AND	r5, r5, #2_1111
	TEQS	r5, #15
	MOVEQ	r14, #Mistake_R15
	STREQ	r14, Mistake
d1161 1
a1161 1
        MOV     r5, #0		; Current register
d1163 1
a1163 1
	MOV	r7, #0		; Total registers
d1165 1
a1165 1
        MOV     r8, #0		; Registers in current group
d1177 1
a1177 1
	ADD	r7, r7, #1
d1206 2
a1207 2
	ADD	r7, r7, r8
	SUB	r7, r7, #1
d1215 3
a1217 1
        AddChar	"}"                     ; end register list
d1219 4
a1222 1
	TestBit	22,"^"                  ; '^' bit
d1224 6
a1229 11
	[ WarnSArev2
	BEQ	InstructionEnd		; It's not ^
	TestBit	20
	BNE	InstructionEnd		; It's not a store

	; If we have more than 1 register in a STM user bank,
	; then it may fail on early StrongARMs
	CMPS	r7, #1
	MOVHI	r10, #Mistake_STMHat
	STRHI	r10, Mistake
	]
d1236 22
a1257 22
LdrStr	ROUT
	; Load and Store Word or Byte
	; arrive here with cccc 01xx xxxx xxxx xxxx xxxx xxxx xxxx
	; format is        cccc 010p ubwl nnnn dddd iiii iiii iiii
	;        or        cccc 011p ubwl nnnn dddd rrrr rtt0 mmmm
	;
	; <LDR|STR>{cond}{B}    Rd,[Rn,#offset]{!}
	; 	                Rd,[Rn,{+|-}Rm{,shift}]{!}
	; <LDR|STR>{cond}{B}{T} Rd,[Rn],#offset
	;                       Rd,[Rn],{+|-}Rm{,shift}
	; where cccc = condition
	;	   p = Pre-indexed/~Post-indexed
	;	   u = Up/~Down
	;	   b = Byte/~Word
	;	   w = Writeback (or T bit if post-indexed)
	;          l = Load/~Store
	;       nnnn = Rn
	;       dddd = Rd
	;      rrrrr = shift amount
	;         tt = shift type (LSL, LSR, ASR or ROR)
	;       mmmm = Rm
	;       iiii = 12-bit unsigned immediate offset
d1270 1
a1270 1
	TestStr	20,Ldr,Str,conds        ; Load/~Store bit
d1273 1
a1273 1
	AND	r5, r5, #2_1111
d1276 1
a1276 1
	BEQ	%FT01
d1278 10
a1287 10
	AddChar	"B"
	TEQS	r5, #15
	MOVEQ	r10, #Mistake_BytePC
	STREQ	r10, Mistake
	BEQ	%FT03

1	TEQS	r5, #15
	TSTEQS	r4, #1 :SHL: 20
	MOVEQ	r10, #Mistake_StorePC
	STREQ	r10, Mistake
d1291 1
a1291 1
	AddChar	"T",EQ                    ; -> T(ranslate)
d1293 1
a1293 1
        BL      Tab_Dis_Register	; uses r5 from above
d1295 1
a1295 1
	; Check for writeback LDR/STR with Rd=Rn
d1297 2
a1298 2
	TEQS	r10, #2_1000 :SHL: 21
	BEQ	%FT10			; if not writeback, okay
d1301 4
a1304 4
	TestBit	25                      ; offset OK, and it isn't entirely
	BNE	%FT05                   ; logical - KJB
	MOVS	r14, r4, LSL #32-12
	BEQ	%FT10			; zero offset, so okay
d1307 15
a1321 15
5	AND	r14, r4, #2_1111 :SHL: 12
	AND	r10, r4, #2_1111 :SHL: 16
	TEQS	r10, r14, LSL #4
	MOVEQ	r10, #Mistake_RdRn
	STREQ	r10, Mistake

	; Check for post-indexed LDR/STR with Rm=Rn
10	AND	r14, r4, #2_11000 :SHL: 21
	TEQS	r14, #2_10000 :SHL: 21
	BNE	%FT20
	AND	r14, r4, #2_1111 :SHL: 16
	AND	r10, r4, #2_1111
	TEQS	r10, r14, LSR #16
	MOVEQ	r10, #Mistake_RmRn
	STREQ	r10, Mistake
d1333 2
a1334 2
	TEQ	R5,#15
	BNE	not_rel
d1336 3
a1338 3
	TestBit 21                      ; Writeback bit set?
	MOVNE	r10, #Mistake_PCwriteback
	STRNE	r10, Mistake
d1340 2
a1341 2
	MOVEQ	r10, #Mistake_PCwriteback
	STREQ	r10, Mistake
d1344 3
a1346 3
	AND	r14,R4,#2_11001 :SHL: 21
	TEQS	r14,#2_01000 :SHL: 21
	BNE	not_rel
d1353 1
a1353 1
        TestBit	27		        ; if a coproc data transfer
d1356 1
a1356 1
        TestBit	23		        ; Up/~Down bit
d1369 1
a1369 1
	TestStr	24,Close_B+1,Close_B    ; Pre/~Post bit - just ',' else '],'
d1371 1
a1371 1
	TestBit	25        		; Shift/~Immediate bit
d1380 1
a1380 1
	AddChar	"#"
d1382 1
a1382 1
	TestBit	23,,"-"                 ; Up/~Down bit
d1386 1
a1386 1
	TestBit	27
d1391 1
a1391 1
	TestBit	24,"]"                 ; Pre/~Post bit
d1396 1
a1396 1
	AddChar	"!",EQ
d1411 1
a1411 1
	TestBit	23,,"-"                 ; Up/~Down bit
d1468 1
a1468 1
	; Arrive here with cccc 000x xxxx xxxx xxxx xxxx 1xx1 xxxx
d1475 1
a1475 1
	; Arrive here with cccc 0000 oooo xxxx xxxx xxxx 1001 xxxx
d1483 14
a1496 14
	; Multiply + Multiply-with-Accumulate
	; Arrive here with cccc 0000 00xx xxxx xxxx xxxx 1001 xxxx
	; Format is        cccc 0000 00as dddd nnnn ssss 1001 mmmm
	;
	; MUL{cond}{S} Rd,Rm,Rs
	; MLA{cond}{S} Rd,Rm,Rs,Rn
	;
	; where cccc = condition
	;          a = Accumulate
	;          s = Set flags
	;       dddd = Rd
	;       nnnn = Rn
	;       ssss = Rs
	;       mmmm = Rm
d1498 1
a1498 1
	TestStr	21,Mla,Mul,conds        ; Accumulate bit
d1500 1
a1500 1
	TestBit	20,"S"                  ; Update flags bit
d1529 1
a1529 1
        TestBit	21		        ; MLA has extra operand
d1531 2
a1532 2
	BLNE	Comma_Dis_Register
	BNE	InstructionEnd
d1534 2
a1535 2
	TST	r4, #2_1111:SHL:12	; Check Rn=R0 for MUL
	BNE	Undefined
d1540 14
a1553 14
	; Multiply long + Multiply-with-Accumulate long
	; Arrive here with cccc 0000 1xxx xxxx xxxx xxxx 1001 xxxx
	; Format is        cccc 0000 1uas hhhh llll ssss 1001 mmmm
	;
	; <U|S><MULL|MLAL>{cond}{S} RdLo,RdHi,Rm,Rs
	;
	; where cccc = condition
	;          u = Signed/~Unsigned
	;          a = Accumulate
	;          s = Set flags
	;       hhhh = RdHi
	;       llll = RdLo
	;       ssss = Rs
	;       mmmm = Rm
d1556 1
a1556 1
	TestBit 22,"S","U"
d1563 1
a1563 1
	TestStr	21,Mlal,Mull,conds      ; Accumulate bit
d1565 1
a1565 1
	TestBit	20,"S"                  ; Update flags bit
d1567 3
a1569 3
	; This stupid opcode can be too long. Will hardly ever happen
	; so don't increase the tab width (might break some programs).
	; Instead, just push the registers over one space.
d1573 1
a1573 1
	AND	r6, r5, #2_1111
d1577 1
a1577 1
	AND	r7, r5, #2_1111
d1581 1
a1581 1
	AND	r8, r5, #2_1111
d1585 1
a1585 1
	AND	r9, r5, #2_1111
d1588 15
a1602 15
	; Can't use R15 as any register, unpredictable
	; if RdLo=RdHi or RdLo=Rm or RdHi=Rm
	LDR	r14, Mistake
	TEQS	r7, r8
	MOVEQ	r14, #Mistake_RdHiRm
	TEQS	r6, r8
	MOVEQ	r14, #Mistake_RdLoRm
	TEQS	r6, r7
	MOVEQ	r14, #Mistake_RdLoRdHi
	TEQS	r6, #15
	TEQNES	r7, #15
	TEQNES	r8, #15
	TEQNES	r9, #15
	MOVEQ	r14, #Mistake_R15
	STR	r14, Mistake
d1607 11
a1617 11
	; Swap register/memory
	; arrive here with cccc 0001 0xxx xxxx xxxx xxxx 1001 xxxx
	; format is        cccc 0001 0b00 nnnn dddd 0000 1001 mmmm
	;
	; SWP{cond}{B} Rd,Rm,[Rn]
	;
	; where cccc = condition
	;          b = Byte/~Word
	;       nnnn = Rn
	;       dddd = Rd
	;       mmmm = Rm
d1619 1
a1619 1
	TSTS	R4,#2_1111 :SHL: 8
d1622 2
a1623 2
	TST	R4,#2_11 :SHL: 20
	BNE	Undefined
d1625 2
a1626 2
	AddStr	aswp,,conds
	TestBit	22,"B"
d1629 5
a1633 5
	AND	r9,r5,#2_1111		; Rd
	; Rd=R15 -> unpredictable
	TEQS	r9,#15
	MOVEQ	r14,#Mistake_R15
	STREQ	r14,Mistake
d1636 9
a1644 9
        AND     R5,R4,#2_1111		; Rm
	; Rm=R15 -> unpredictable
	TEQS	r5,#15
	MOVEQ	r14,#Mistake_R15
	STREQ	r14,Mistake
	; Rd=Rm -> unpredictable
	TEQS	r5,r9
	MOVEQ	r14,#Mistake_RdRm
	STREQ	r14,Mistake
d1646 1
a1646 1
	AddStr	Open_B
d1649 9
a1657 9
	AND	r5,r5,#2_1111		; Rn
	; Rn=R15 -> unpredictable
	TEQS	r5,#15
	MOVEQ	r14,#Mistake_R15
	STREQ	r14,Mistake
	; Rd=Rn -> unpredictable
	TEQS	r5,r9
	MOVEQ	r14,#Mistake_RdRn
	STREQ	r14,Mistake
d1659 2
a1660 2
	AddChar	"]"
	[ {FALSE}
d1665 1
a1665 1
	]
d1678 38
a1715 38
LdrStrH	; Load and Store Halfword/Doubleword or Load Signed Byte
	; arrive here with cccc 000x xxxx xxxx xxxx xxxx 1nn1 xxxx
	; (nn != 00)
	; format is        cccc 000p uiwl nnnn dddd aaaa 1sh1 bbbb
	;
	; LDR{cond}<H|SH|SB|D> Rd,[Rn,<#offset|Rm>]{!}
	;                      Rd,[Rn],<#offset|Rm>
	; STR{cond}<H|D>       Rd,[Rn,<#offset|Rm>]{!}
	;                      Rd,[Rn],<#offset|Rm>
	; where cccc = condition
	;	   p = Pre-indexed/~Post-indexed
	;	   u = Up/~Down
	;	   i = Immediate/~Register offset
	;	   w = Writeback (must be zero if post-indexed)
	;          l = Load/~Store
	;       nnnn = Rn
	;       dddd = Rd
	;       aaaa = immediate offset high nibble (if i==1), else 0
	;          s = Signed/~Unsigned halfword
	;	   h = Halfword/~Signed byte
	;	bbbb = immediate offset low nibble (if i==1), else Rm

	; cccc 000x x0xx xxxx xxxx nnnn 1xx1 xxx is undefined if any of
	; nnnn are 1.
	TSTS	r4, #1:SHL:22		; Immediate/~Register offset
	BNE	%F5
	TSTS	r4, #&00000F00
	BNE	Undefined

5	AND	r5, r4, #1:SHL:24 :OR: 1:SHL:21
	TEQS	r5, #1:SHL:21		; Check for post-indexed with W set (illegal)
	BEQ	Undefined

	TSTS	r4, #1:SHL:20		; Load/~Store
	BNE	%F20
	AND	r5, r4, #&000000F0
	TEQS	r5, #&000000B0
	BEQ	%F20
d1756 22
a1777 22
  	TestStr	20,Ldr,Str,conds
	TestBit	6,"S"
	TestBit	5,"H","B"

22	MOV	r5, r4, LSR #12
	BL	Tab_Dis_Register

	; Check we're not storing/loading PC
	TEQS	r5, #15
	MOVEQ	r10, #Mistake_R15
	STREQ	r10, Mistake
	BEQ	%FT30

	;
	; Check for Rd=Rn with writeback
	;
	AND	r10, r4, #2_10010:SHL:20	; If pre-indexed and no writeback, then OK
	TEQS	r10, #2_10000:SHL:20
	BEQ	%FT30
	AND	r10, r4, #&F:SHL:16		; If Rd <> Rn then OK
	TEQS	r5, r10, LSR #16
	BNE	%FT30
d1779 5
a1783 5
	TSTS	r4, #1:SHL:22			; If a register offset, then fail
	BEQ	%FT25
	TSTS	r4, #&F
	TSTEQS	r4, #&F00
	BEQ	%FT30				; If an immediate offset of 0, then OK
d1786 19
a1804 2
25	MOV	r10, #Mistake_RdRn
	STR	r10, Mistake
d1806 9
a1814 26
30	MOV	r5, r4, LSR #16
	AND	r5, r5, #&F
	TEQS	r5, #15
	BNE	not_ldrh_rel

	;
	; Check for PC-writeback
	;
	AND	r10, r4, #2_10010:SHL:20
	TEQS	r10, #2_10000:SHL:20
	MOVNE	r10, #Mistake_PCwriteback
	STRNE	r10, Mistake

	ANDEQ	r10, r4, #2_10110:SHL:20     	; Check P,I and W bits
	TEQEQS	r10, #2_10100:SHL:20		; Must be pre-indexed,immediate,no writeback
	BNE	not_ldrh_rel

	; show resultant [LD|ST]R[H|SH|SB] Rd,[PC,#nn] address directly

	AddChar	","
	AND	r8,  r4, #&0000000F
	AND	r10, r4, #&00000F00
	ORR	r8, r8, r10, LSR #4
	TSTS	r4, #1:SHL:23		; Up/~Down bit
	SUBEQ	r8, r9, r8
	ADDNE	r8, r9, r8
d1816 1
a1816 1
	B	BranchLdrStrCommon
d1821 1
a1821 1
	AddStr	Open_B	        	; ",["
d1823 1
a1823 1
	BL	Dis_Register
d1825 15
a1839 15
	TSTS	r4, #1:SHL:24           ; Pre/~Post bit
	ADRL	r10, Close_B
	ADDNE	r10, r10, #1            ; just ',' else '],'
	BL	SaveString
	TSTS	r4, #1:SHL:22		; Immediate/~Register bit
	BEQ	ldrstrh_reg

	AddChar	"#"
	TestBit	23,,"-"	        	; Up/~Down bit

	AND	r8,  r4, #&0000000F
	AND	r10, r4, #&00000F00
	ORR	r8, r8, r10, LSR #4
	BL	StoreDecimal
	B	%F50
d1842 10
a1851 10
	TestBit	23,,"-"	        	; Up/~Down bit
	AND	r5, r4, #&F
	BL	Dis_Register

	; Check for Rm=Rn in register post-indexed case
	AND	r6, r4, #&F :SHL: 16
	TEQS	r5, r6, LSR #16
	TSTEQS	r4, #1:SHL:24
	MOVEQ	r6, #Mistake_RmRn
	STREQ	r6, Mistake
d1853 2
a1854 2
50	TSTS	r4, #1:SHL:24           ; Pre/~Post bit
	BEQ	InstructionEnd
d1856 1
a1856 1
	AddChar	"]"
d1858 2
a1859 2
	TestBit	21,"!"                  ; Writeback bit
	B	InstructionEnd
d1865 2
a1866 2
	; Arrive here with cccc 00xx xxxx xxxx xxxx xxxx xxxx xxxx
	; Format is        cccc 000o ooos nnnn dddd rrrr rtt0 mmmm
d1868 19
a1886 19
	;                  cccc 001o ooos nnnn dddd rrrr iiii iiii
	;
	; <data op>{cond}{S} Rd,Rn,op2    (0-7,12,14: AND,EOR,SUB,RSB,ADD,ADC,SBC,RSC,ORR,BIC)
	; <data op>{cond}{S} Rd,op2       (13,15: MOV,MVN)
	; <compare>{cond}{P} Rn,op2       (8-11: TST,TEQ,CMP,CMN)
	;
	;        op2 = #imm
	;              Rm{,<LSL|LSR|ASR|ROR> <#imm|Rs>}
	;	       Rm,RRX
	;
	; where cccc = condition
	;       oooo = operation
	;          s = Set flags (required for comparisons)
	;       nnnn = Rn (0 if not used, 15 signals P flag on compares)
	;       dddd = Rd (0 if not used)
	;      rrrrr = rotate/shift amount
	;         tt = shift type (LSL,LSR,ASR,ROR) (RRX encoded by ROR #0)
	;   iiiiiiii = immediate
	;       mmmm = Rm
d1894 1
a1894 1
					; (and LDRH etc from 1.48)
d1909 2
a1910 2
        TST	r4, #1 :SHL: 20
        BNE	notADR ;S bit set - not ADR
d1912 1
a1912 1
        TestBit	25			; I bit
d1915 3
a1917 3
	AND	r5, r4, #2_11001 :SHL: 20
	TEQS	r5, #2_10000 :SHL: 20		; Check for opcodes 8-11 with S clear
	BEQ	ControlExtension
d1930 1
a1930 1
	BEQ	%FT05
d1932 2
a1933 2
	BNE	Undefined		; Otherwise check Rd=R0
	AddChar	"P"
d1941 1
a1941 1
	TestBit	20,"S"       		; Update flags bit
d1949 4
a1952 4
	BNE	%FT20
	TSTS	r4, #2_1111 :SHL: 16	; Check that Rn=R0
	BNE	Undefined
	B	Operand_2
d1959 1
a1959 1
	TestBit	25         		; Immediate bit
d1970 1
a1970 1
	AddChar	"#"
d2002 1
a2002 1
	AddChar	"="
d2027 1
a2027 1
	AddStr	AdrTAB,,conds
d2044 1
a2044 1
	TestBit	22
d2058 1
a2058 1
	TestBit	25
d2093 1
a2093 1
	BNE	is_MSR
d2095 19
a2113 19
is_MRS	; arrive here with cccc 0001 0x00 xxxx xxxx xxxx 0000 xxxx
	;
	; format is        cccc 0001 0r00 1111 dddd 0000 0000 0000
	;
	; MRS{cond} Rd, <CPSR|SPSR>
	; where cccc = condition
	;	   r = 1 for SPSR, 0 for CPSR
	MOVS	r5, r4, LSL #20		   ; bottom 12 bits should be 0
	BNE	Undefined
	AND	r14, r4, #2_1111 :SHL: 16  ; bits 16-19 should be 1
	TEQS	r14, #2_1111 :SHL: 16
	BNE	Undefined

	AddStr	MrsTAB,,conds
	MOV	r5, r4, LSR #12
	BL	Tab_Dis_Register	   ; Rd
	BL	AddComma
	BL	CPSR_or_SPSR
	B	InstructionEnd
d2141 1
a2141 1
is_MSR	; arrive here with cccc 0001 0x10 xxxx xxxx xxxx 0000 xxxx
d2143 33
a2175 33
	;
	; format is        cccc 0001 0r10 fsxc 1111 0000 0000 mmmm
	;        or        cccc 0011 0r10 fsxc 1111 rrrr iiii iiii
	; MSR{cond} <CPSR|SPSR>_<fields>, Rm
	; MSR{cond} <CPSR|SPSR>_<fields>, #imm
	;
	; where cccc = condition
	;	   r = 1 for SPSR, 0 for CPSR
	;       fsxc = field mask bits
	;       rrrr = rotate amount (/2)
	;       iiii = immediate
	;	mmmm = Rm
	TestBit	25       	      ; if register, bits 4-11 must be 0
	BNE	%FT01

	TST	r4, #2_11111111 :SHL: 4
	BNE	Undefined

01	AND	r10, r4, #2_1111 :SHL: 12
	TEQ	r10, #2_1111 :SHL: 12
	BNE	Undefined

05	ADR	r10, MsrTAB
	BL	SaveStringConditions
	BL	Tab
	BL	CPSR_or_SPSR
	AddChar	"_"
	TestBit	16,"c"
	TestBit	17,"x"
	TestBit	18,"s"
	TestBit	19,"f"
	BL	AddComma
	B	Operand_2
d2185 7
a2191 7
is_BX	; arrive here with cccc 0001 00x0 xxxx xxxx xxxx 00x1 xxxx
	;
	; format is        cccc 0001 0010 1111 1111 1111 00l1 mmmm
	;
	; B{L}X{cond} Rm
	;
	; where cccc = condition
d2193 1
a2193 1
	;	mmmm = Rm
d2200 2
a2201 2
	AND	R5,R4,#2_1111
	BL	Tab_Dis_Register
d2209 1
a2209 1
	B	InstructionEnd
d2443 1
a2443 1
	ALIGN
d2448 3
a2450 3
	; Coprocessor operations
	; arrive here with cccc 11nn xxxx xxxx xxxx xxxx xxxx xxxx
	; with nn <> 11
d2484 5
a2488 5
	; arrive here with cccc 110x xxxx xxxx xxxx xxxx xxxx xxxx
	; format is        cccc 110p unwl nnnn dddd #### iiii iiii
	;
	; <LDC|STC>{cond}{L} CP#,Cd,[Rn,#imm]{!}
	;		     CP#,Cd,[Rn],#imm
d2491 11
a2501 11
	;
	; where cccc = condition
	;	   p = Pre-indexed/~Post-indexed
	;	   u = Up/~Down
	;	   n = Transfer length
	;	   w = Writeback
	;	   l = Load/~Store
	;	nnnn = Rn
	;	dddd = Cd
	;	#### = CP#
	;	iiii = immediate offset (in words), or info (puw = 010)
d2508 1
a2508 1
	TestStr	20,Ldc,Stc,conds,2      ; Load/~Store bit
d2510 1
a2510 1
	TestBit	22,"L"                  ; Length bit
d2584 1
a2584 1
	; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxxx xxxx
d2586 1
a2586 1
        TestBit 4		; Transfer/~Operation bit
d2590 13
a2602 13
	; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxx0 xxxx
	; format is        cccc 1110 oooo nnnn dddd #### iii0 mmmm
	;
	; CDP{cond} CP#,op,Cd,Cn,Cm{,info}
	; CDP2      CP#,op,Cd,Cn,Cm{,info}
	;
	; where cccc = cond
	;	oooo = operation
	;       nnnn = Cn
	;       dddd = Cd
	;       #### = CP#
	;        iii = info
	;       mmmm = Cm
d2607 1
a2607 1
	AddStr	Cdp,,conds,2
d2633 1
a2633 1
        TestBit	4                       ; Transfer/~Operation bit
d2641 4
a2644 4
	TEQS	R5,#&40000
	BEQ	InstructionEnd
	CMPS	R5,#&80000
	BHI	InstructionEnd
d2658 4
a2661 4
	; arrive here with cccc 1110 xxxx xxxx xxxx xxxx xxx1 xxxx
	; format is        cccc 1110 oool nnnn dddd #### iii1 mmmm
	;
	; <MCR|MRC>{cond} CP#,op,Rd,Cn,Cm{,info}
d2663 9
a2671 9
	;
	; where cccc = cond
	;	 ooo = operation
	;          l = Load/~Store (ie load from coprocessor)
	;       nnnn = Cn
	;       dddd = Rd
	;       #### = CP#
	;        iii = info
	;       mmmm = Cm
d2673 1
a2673 1
	TestStr	20,Mrc,Mcr,conds,2      ; Load/~Store bit
d2693 1
a2693 1
	AddStr	Cp
d2703 9
a2711 9
msg0    = "M02",0    	; CP15,C0 : ARMv4 ID
msg1    = "M03",0    	; CP15,C1 : ARMv4 Control
msg2    = "M04",0 	; CP15,C2 : ARMv4 Translation Table
msg3    = "M05",0	; CP15,C3 : ARMv4 Domain Access Control
msg4    = "M08",0	; CP15,C4 : ARMv4 - Bad register
msg5    = "M06",0	; CP15,C5 : ARMv4 Fault Status
msg6    = "M07",0	; CP15,C6 : ARMv4 Fault Address
msg7    = "M51",0	; CP15,C7 : ARMv4 Cache Operations
msg8	= "M52",0	; CP15,C8 : ARMv4 TLB Operations
d2721 1
a2721 1
	AddChar	","
d2749 1
a2749 1
	AddChar	"#"
d2760 4
a2763 4
	AND	r5, r5, #2_1111
	TEQS	r5, #15
	MOVEQ	r14, #Mistake_R15shift
	STREQ	r14, Mistake
d2789 4
a2792 4
	LDRB	r10, DisReg_F
	AND	r5, r5, #2_111		; Only 8 FP registers
;	MOV	r10, #"F"
	B	%FT20
d2798 1
a2798 1
	LDRB	r10, DisReg_C
d2805 1
a2805 1

d2810 1
a2810 1
	AddChar "1",HS
d2848 9
a2856 9
;	MOV	R14, #"R"
;	ORR	R14, R14, #"1" :SHL: 8
;	ORR	R14, R14, #"4" :SHL: 16

	STRB    R14, [R0], #1
	MOV     R14, R14, LSR #8
	STRB    R14, [R0], #1
	MOVS    R14, R14, LSR #8
	STRNEB  R14, [R0], #1
d2862 1
a2862 1
;	AddStr	pc_Reg
d2999 18
a3016 18
        =       "M10",0		; ! and ^
        =       "M11",0		; Not R8-R14
        =       "M12",0		; SWI after CDP
        =       "M13",0		; Rd=Rm or Rd=R15
     	=	"M53",0		; Shift by R15
     	=	"M54",0		; Not R15
     	=	"M55",0		; PC writeback
     	=	"M56",0		; Byte load/store of PC
     	=	"M57",0		; May store PC+8 or PC+12
     	=	"M58",0		; Unpredictable
     	=	"M59",0		; Rd=Rn
     	=	"M60",0		; Rm=Rn
     	=	"M61",0		; RdLo=RdHi
     	=	"M62",0		; RdLo=Rm
     	=	"M63",0		; RdHi=Rm
     	=	"M64",0		; Rn in list
	=	"M66",0		; Rd=Rm
	=	"M67",0		; Only 1 reg on SA-110 rev 2
d3031 1
a3031 1
	AddChar "&"
d3083 1
a3083 1
	AddChar ","
d3104 4
a3107 4
	MOV	R6,#"T"
	BL	MemoryCommon
	TEQS	R6,#1
	MOVEQ	R6,#2
d3170 1
a3170 1
	EXIT	VS
d3172 7
d3180 2
d3183 2
a3184 2
	TEQS	r6, #4
	BNE	%F40
d3188 2
a3189 2
	B	%F45
40	BL	DisplayHexHalfword
d3194 1
a3194 1
	EXIT	VS
d3196 7
d3204 1
d3207 2
a3208 2
	TEQS	r6, #4
	BNE	%F50
d3212 2
a3213 2
	B	%F55
50	SWI	XDebugger_DisassembleThumb
d3267 1
a3267 1
        DCB     "M16", 0		; "Store inititalised to &"
d3288 1
a3288 1
        DCB     "M17", 0	      ; "Register dump (stored at &)
d3296 1
a3296 1
        DCB     "M18", 0	      ; ") is:"
d3399 1
a3399 1
        DCB     "M19", 0	        ; "Mode "
d3409 1
a3409 1
        DCB     "M20", 0	   	; " flags set: "
d3577 9
d3588 1
d3598 8
d3607 1
a3607 1

d3649 72
d3737 1
a3737 1
        DCB     "M22", 0		; "Address  :"
d3762 1
a3762 1
        DCB     "M23"			; "   ASCII Data"
d3836 1
a3836 1
;	r6 = character to check for
d3850 9
a3858 2
        MOV     r1, r0                  ; Check for 'r6',space
        BL      SkipSpaces
d3860 3
a3862 3
        TEQ     r0, R6			; Check upper case
	ADDNE	r6, r6, #"a"-"A"
        TEQNE   r0, R6			; Check lower case
d3872 7
d3881 23
d3909 1
a3909 1
	MOV	R6,#"B"
d3931 15
d3951 1
d3953 15
d3973 1
d3996 1
a3996 1
        DCB     "M24", 0		; "Word at &"
d3998 1
a3998 1
        DCB     "M25", 0		; "Byte at &"
d4000 1
a4000 1
        DCB     "M26", 0		; " was &"
d4002 1
a4002 1
        DCB     "M27", 0		; " altered to &"
d4033 10
d4046 1
d4064 9
d4074 1
d4117 13
d4134 1
d4136 12
d4151 1
d4173 1
a4173 1
        DCB     "M29", 0		; "  Enter new value : "
d4236 4
a4239 4
	;Do the IMB thingy here, for the replaced instruction
	MOV	r0, #1		;Ranged IMB
	MOV	r2, r1
	SWI	XOS_SynchroniseCodeAreas
d4280 1
a4280 1
        DCB     "M31", 0		; "No breakpoints set"
d4289 1
a4289 1
        DCB     "M32", 0		; "Address     Old data"
d4324 1
a4324 1
        DCB     "M33", 0 ; No newline	; " : bad breakpoint; cleared."
d4382 1
a4382 1
        DCB     "M35", 0		; "Clear all breakpoints? [Y/N]"
d4403 1
a4403 1
        DCB     "M36", 0		; "All breakpoints cleared"
d4433 4
a4436 4
	;Do the IMB thingy here
	MOV	r0, #1			;Ranged IMB
	MOV	r2, r1
	SWI	XOS_SynchroniseCodeAreas
d4441 1
a4441 1
        DCB     "M37", 0		; "Bad breakpoint at &"
d4448 1
a4448 1
        DCB     "M38", 0		; "; cleared."
d4496 1
a4496 1
        DCB     "M39", 0		; "Continue from breakpoint set at &"
d4507 1
a4507 1
        DCB     "M40", 0		; "Execute out of line? [Y/N] "
d4574 5
a4578 5
	;Best IMB the ExecuteBuffer here
	MOV	r0, #1			; Guess what? It's a ranged sync
	ADR	r1, ExecuteBuffer
	ADD	r2, r1, #ExeBufLen
	SWI	XOS_SynchroniseCodeAreas
d4637 1
a4637 1
        DCB     "M41", 0		; "Bad breakpoint at &"
d4643 1
a4643 1
        DCB     "M42", 0		; "; cleared."
d4660 1
a4660 1
        DCB     "M43", 0		; "Debug*"
d4763 8
d4772 1
d5290 2
a5291 2
	ADR	R2, StringBuffer
	MOV	R3, #?StringBuffer
d5305 1
a5305 1
        CMPS    r0, #0			; clears V
d5326 1
a5326 1
	LNK	s.FP
@


4.15
log
@Fixed and tidied *ShowFPRegs. In particular, will work with 26-bit
FPEmulators.

Version 1.71. Tagged as 'Debugger-1_71'
@
text
@d214 3
d313 30
d592 5
d669 3
d681 8
a688 8
        Command BreakClr,    1,   0,
        Command BreakList,   0,   0,
        Command BreakSet,    1,   1,
        Command Continue,    0,   0,
        Command Debug,       0,   0,
        Command InitStore,   1,   0,
        Command Memory,      4,   1,; B R + R
        Command MemoryA,     3,   1,; B R V
d690 1
a690 1
        Command MemoryI,     6,   1,; T A +/- B + C
d692 1
a692 1
        Command MemoryI,     5,   1,; A +/- B + C
d694 2
a695 2
        Command ShowRegs,    0,   0,
        Command ShowFPRegs,  0,   0,
d697 8
a704 8
        Command BreakClr,    1,   0, International_Help
        Command BreakList,   0,   0, International_Help
        Command BreakSet,    1,   1, International_Help
        Command Continue,    0,   0, International_Help
        Command Debug,       0,   0, International_Help
        Command InitStore,   1,   0, International_Help
        Command Memory,      4,   1, International_Help     ; B R + R
        Command MemoryA,     3,   1, International_Help     ; B R V
d706 1
a706 1
        Command MemoryI,     6,   1, International_Help     ; T A +/- B + C
d708 1
a708 1
        Command MemoryI,     5,   1, International_Help     ; A +/- B + C
d710 2
a711 2
        Command ShowRegs,    0,   0, International_Help
        Command ShowFPRegs,  0,   0, International_Help
d2768 1
d2770 2
a2771 3

	MOV	r10, #"F"
	B	%FT50
d2777 3
a2779 19
        MOV     r10, #"C"
        B       %FT50

; .............................................................................

; In	r5 = register number (in bottom 4 bits, rest can be garbage)
; Out   r5 = register number (correctly masked)
;       r2, r10 corrupted

Dis_Register ALTENTRY

20      AND     r5, r5, #2_1111
        TEQ     r5, #15
        BEQ     Dis_pc

	CMPS	R5,#8
	BLHS	checkreg

        MOV     r10, #"R"
d2785 1
a2785 2
50      STRB    r10, [r0], #1

d2796 4
a2799 3
Dis_pc
	AddStr	pc_Reg
        EXITS
d2801 1
d2803 4
a2806 2
pc_Reg  DCB     "PC", 0
        ALIGN
d2810 5
a2814 1
Comma_Dis_Register ALTENTRY
d2816 21
a2836 2
        BL      AddComma
        B       %BT20
d2840 7
a2846 4
Tab_Dis_Register ALTENTRY

        BL      Tab
        B       %BT20
@


4.14
log
@  Optimisation of SWI stuff.
  Changed wacky immediate format.
Detail:
  SWI number stuff now uses an internal routine rather than a call
  to SWI OS_ConvertHex...

  When someone disassembles a wacky immediate, it is represented as
  "<OP> Rd,Rn,#&xx,x" rather than the non-standard
  "<OP> Rd,Rn,#&xx,ROR #x" format. This can then be assembled and
  conforms to ARM's standards.
Admin:
  Tested on RiscPC

  My editor blew-up in the middle of srccommit on Debugger-1_69 so
  don't use that version!

Version 1.70. Tagged as 'Debugger-1_70'
@
text
@d209 5
@


4.13
log
@  Modified SWI number output.
  SWI number stuff also implemented in Thumb mode.
Detail:
  Unknown SWIs were dissasembled as an 8 nibble hexadecimal number.
  This has been reduced to a six nibble number (as the top byte is
  always zero).

  The unknown SWI disassembled as a number stuff has also been added
  to Thumb mode disassembly. Only two nibbles are displayed in this
  mode.
Admin:
  Tested on a RiscPC.

Version 1.68. Tagged as 'Debugger-1_68'
@
text
@d852 1
a853 1
not_thumb_swi
d864 1
d868 3
a870 1
;   R2 - pointer to last char of string (may be different)
d873 1
a873 1
	Push	"R3, R12, LR"
a874 1
	BIC     R12, R14, #&FC000003    ; This is 32-bit safe
d876 1
a876 1
	ADD	R3, R1, R2
d878 2
a879 2
	TST	R3, #2_11
	STRNEB	R14, [R3], #1
d882 1
a882 1
	ADR	R3, str_user
d884 6
d891 2
a892 11
	ADR	R3, str_xuser
	BL	strcmp
	BEQ	unk_swi_replace
	ADR	R3, str_os_undefined
	BL	strcmp
	BEQ	unk_swi_replace
	ADR	R3, str_xos_undefined
	BL	strcmp
	BEQ	unk_swi_replace
        SUB	R2,R2,#1                ; Adjust to avoid taking the zero byte
	Pull	"R3, R12, PC"
d895 6
a900 12
	MOV	R2, #ampersand
	STRB	R2, [R1], #1
	MOV	R2, #12
	ADR     R14, not_thumb_swi
	BIC     R14, R14, #&FC000003    ; This is 32-bit safe
	TEQ     R12, R14
	SWIEQ	XOS_ConvertHex6         ; If called from non-Thumb mode, do a 6 char hex number
	SWINE	XOS_ConvertHex2         ; If called from Thumb mode, do a 2 char hex number
	SUB	R2, R1, R0
	SUB	R1, R0, #1
	ADD	R2, R2, #1
	Pull	"R3, R12, PC"
d907 1
a907 1
;   R3    - pointer to second string
d910 1
a910 1
;   R3    - corrupted
d913 1
a913 1
	Push	"R0, R1, LR"
d916 1
a916 1
	LDR	R14, [R3], #4
d922 1
a922 1
	Pull	"R0, R1, PC"
d2651 2
a2652 2
        TEQS    r8, #0                  ; 0,n prettified
	AddChar	"0",EQ
d2654 1
a2654 7
        MOVNE   r2, #8-4                ; Display unrotated byte,decimal rotate
        BLNE    StoreHex

;1.26 - Change layout to #0, ROR #nn
	AddStr	ShiftROR

	AddChar	"#"
a2712 1
ShiftROR ;used for wacky zero shifts
@


4.12
log
@QADD etc "corrected" to have operands in Rm,Rn order.

Version 1.67. Tagged as 'Debugger-1_67'
@
text
@d853 1
d870 1
a870 1
	Push	"R3, LR"
d872 1
d893 1
a893 1
	Pull	"R3, PC"
d899 5
a903 1
	SWI	XOS_ConvertHex8
d907 1
a907 1
	Pull	"R3, PC"
@


4.11
log
@  Fixed SWI number disassembly.
Detail:
  The routine was returning the length of the disassembled instruction
  *including* the terminator. Changed to exclude it as the others do
Admin:
  Tested on RiscPC

Version 1.66. Tagged as 'Debugger-1_66'
@
text
@d208 1
d2231 1
a2231 1
        ; Q{D}<ADD|SUB>{cond} Rd, Rn, Rm
d2262 2
a2264 2
        BL      Comma_Dis_Register
        MOV     r5, r4
@


4.10
log
@* Breakpoints now work on 32-bit systems - it got confused over which
  breakpoint was hit.
* *MemoryI T now disassembles 24 instructions by default rather than 48.

Version 1.65. Tagged as 'Debugger-1_65'
@
text
@d899 1
a899 1
	ADD	R2, R2, #2
@


4.9
log
@* Added ARMv5TE instructions.
* Fixed disassembly of Thumb high MOV/ADD/CMP instructions.

Version 1.64. Tagged as 'Debugger-1_64'
@
text
@d204 4
d560 1
a560 1
        ADR     R2, BreakCodeStart
d562 1
a562 1
        ADD     R2, R2, #8
d3049 4
d3054 1
@


4.8
log
@  Fixed ADR and modified SWI disassembly.
Detail:
  ADDS Rd,PC,#.. and SUBS Rd,PC,#.. were being incorrectly disassembled
  as ADR pseudo-instructions. Fixed.

  Unknown SWIs (such as OS_Undefined and User) are disassembled in the
  form 'SWI &<num>' so that you can re-assemble the code (and it makes
  more sense if you don't have a module loaded which defined that SWI).
Admin:
  Tested on RiscPC

  I also added some notes on ARM v5TE to the Doc directory. May be of
  some use when adding compatibility for that to Debugger.

Version 1.63. Tagged as 'Debugger-1_63'
@
text
@d202 2
d245 3
d328 1
d787 3
d1188 3
d1195 4
d1229 3
a1231 2
	TestBit	25
	BNE	%FT05
d1234 1
d1254 3
a1276 1
	AddChar	","
d1293 1
a1293 1
	AddStr	Open_B                  ; ',['
d1353 32
d1390 1
d1437 15
a1451 4
        TEQS    R10,R5
        TEQNES  R10,#15
        MOVEQ   R14,#Mistake_MUL
        STREQ   R14,Mistake
d1607 1
a1607 1
LdrStrH	; Load and Store Halfword or Load Signed Byte
d1612 4
a1615 4
	; LDR{cond}<H|SH|SB> Rd,[Rn,<#offset|Rm>]{!}
	;                    Rd,[Rn],<#offset|Rm>
	; STR{cond}H         Rd,[Rn,<#offset|Rm>]{!}
	;                    Rd,[Rn],<#offset|Rm>
d1635 6
a1640 2
	; Can only have STRH, not STRSH or STRSB
5	TSTS	r4, #1:SHL:20		; Load/~Store
d1644 39
a1682 4
	BNE	Undefined
20	AND	r5, r4, #1:SHL:24 :OR: 1:SHL:21
	TEQS	r5, #1:SHL:21		; Check for post-indexed with W set (illegal)
	BEQ	Undefined
d1684 2
a1685 1
	TestStr	20,Ldr,Str,conds
d1689 1
a1689 1
	MOV	r5, r4, LSR #12
d1707 1
d1713 1
d1997 3
d2003 7
a2009 1
        B       Undefined
d2044 17
d2063 4
a2114 1
        ; (oo != 00)
d2116 1
a2116 1
	; format is        cccc 0001 0010 1111 1111 1111 00l1 nnnn
d2118 1
a2118 1
	; B{L}X{cond} Rn
d2122 1
a2122 1
	;	nnnn = Rn
a2162 1
        ; (oo != 00)
d2164 1
a2164 1
        ; format is        cccc 0001 0110 1111 dddd 1111 0001 nnnn
d2166 1
a2166 1
        ; CLZ{cond} Rd, Rn
d2170 1
a2170 1
        ;       nnnn = Rn
d2222 124
a2349 2
BxTAB   DCB     "BX", 0
BkptTAB DCB     "BKPT",0
d2352 10
a2361 17
	ALIGN
OpcTAB  DCB     "AND",0
        DCB     "EOR",0
        DCB     "SUB",0
        DCB     "RSB",0
        DCB     "ADD",0
        DCB     "ADC",0
        DCB     "SBC",0
        DCB     "RSC",0
        DCB     "TST",0
        DCB     "TEQ",0
        DCB     "CMP",0
        DCB     "CMN",0
        DCB     "ORR",0
        DCB     "MOV",0
        DCB     "BIC",0
        DCB     "MVN",0
d2369 2
d2435 1
a2435 1
        BEQ     Undefined               ; Post-indexed, down, no writeback
d2453 55
d2772 1
a2772 1
        EXIT
d2941 1
@


4.7
log
@* Disassembly of VFP instruction set added.
* Changed invalid instruction to &E7FFFFFF (as per ARM
  recommendation that &E7FxxxFx should be used)
* Branch disassembly changed - when running on a
  26-bit systems, branch instructions in the lower
  64M will be wrapped within 64M, but branches
  above 64M will not.
* PC-relative LDRH family instructions calculated
  target address incorrectly.

Version 1.62. Tagged as 'Debugger-1_62'
@
text
@d24 1
d199 3
d298 1
d345 8
a352 7
TAB     *       9
LF      *       10
CR      *       13
space   *       " "
quote   *       """"
colon   *       ":"
delete  *       &7F
d837 51
d889 35
a923 3
        SUBVC   R2,R2,#1                ;adjust to avoid taking the zero byte
        ADDVC   r0, r1, r2
        B       InstructionEnd
d1731 3
@


4.6
log
@"ARMv5 only" warning now shown reliably.

Version 1.61. Tagged as 'Debugger-1_61'
@
text
@d189 9
d864 2
d869 2
a870 3
        LDRB    r2, SysIs32bit
        TEQ     r2, #0

d1346 1
a1346 5
	ADR	r1, StringBuffer
	SUB	r1, r0, r1
	TEQS	r1, #8
	AddChar	" ",EQ
	BLNE	Tab
d1549 1
d2050 4
d2478 1
a2478 1
        MOV     r14, #space
d2489 12
d2760 1
a2760 1
        LDREQ   r7, =&E6000010          ; A nice invalid instruction
@


4.5
log
@* 32-bit compatibility added.
* New *ShowFPRegs command.
* Added ARMv5 instructions (BLX, CLZ, BKPT, CDP2 et al)
* Handling of instruction extension space adjusted as per ARMv4.
* Fixed some Thumb instructions.
* Added "info" form of LDC and STC.
* NV condition code is now undefined, except for the new instructions using
  it.

Version 1.60. Tagged as 'Debugger-1_60'
@
text
@d188 1
d2453 3
a2455 3
        TEQ     r10, #0
        MOVNE   r10, #Mistake_ARMv5
        STRNE   r10, Mistake
@


4.4
log
@Ursula and Spinner branches merged.
Makefile changed to use LocalRes$Path.
Changed to use srccommit.

Version 1.57. Tagged as 'Debugger-1_57'
@
text
@d23 1
a23 1
;               Kevin Bracey (Architecture 4 instructions, fixes)
d178 11
d195 1
d205 2
d214 2
a215 3
        GBLL    debug
debug   SETL    False
;debug   SETL    True
d217 2
a218 2
        GBLL    rp0512
rp0512  SETL    False ;False = do not implement RP0512 bug fix coding
d220 2
a221 2
        GBLL    Addr26
Addr26  SETL    True ; true for 26 bit wrap on addresses
d223 2
a224 2
        GBLL    national
national SETL   False
d226 2
a227 2
	GBLL	StrongARM
StrongARM SETL  True
d229 2
a230 2
	GBLL	WarnSArev2
WarnSArev2	SETL False	; Warn about hitting the SA revision 2 STM^ bug
d232 2
a233 2
	GBLL	Thumb
Thumb	SETL	True
d254 1
a254 1
Registers       #       4*16            ; Register dump area
d256 1
d278 3
d283 1
a283 1
                                        ; and a full register set + two instrs
a288 1
Mistake_NV	#	1
d307 1
d317 1
a317 3
 [ StrongARM
ExeBufLen	*	4+4+4*16
 ]
a323 1
 [ StrongARM
a324 3
 |
ExecuteBuffer   #       4+4+4*16
 ]
d352 1
a352 1
	AddStr	$c,$cond,$conds
d354 3
a356 3
	[ "$conds" <> ""
	  BL$cond  SaveStringConditions
	|
d358 1
a358 1
	]
d387 1
a387 1
	TestStr	$bit,$set,$unset,$conds
d393 1
a393 1
	  BL	SaveStringConditions
d429 3
d450 5
d502 1
a502 1
        MOV     r3, #16
d514 2
d523 25
d599 2
a600 1
        EXITS                           ; Don't refuse to die
d622 1
d638 1
d646 2
d830 8
a837 8
	; arrive here with cccc 101x xxxx xxxx xxxx xxxx xxxx xxxx
	; format is        cccc 101l oooo oooo oooo oooo oooo oooo
	;
	; B{L}{cond} address
	;
	; where cccc = condition
	;          l = Link
	;          o = 24-bit signed offset (in words)
d841 6
a846 2
	AddChar	"B"
	TestBit	24,"L"
d852 22
a873 6
 [ Addr26
        ADD     r8, r9, r4, LSL #2      ; Form offset from required address
 |
        MOV     r8, r4, ASL #8          ; shift offset up to top
        ADD     r8, r9, r8, ASR #6      ; convert to signed offset and add
 ]
a875 4
        ADD     r8, r8, #8              ; pc advanced by 8
 [ Addr26
        BIC     r8, r8, #ARM_Addr_Mask    ; Wrap in 64MByte space
 ]
d1059 2
a1060 3
	; (nn != 00)
	; format is        cccc 010p ubwl nnnn dddd rrrr rtt0 mmmm
	;        or        cccc 011p ubwl nnnn dddd iiii iiii iiii
a1066 1
	;          i = Immediate/~Register offset
d1144 1
a1144 1
	TestBit 21
d1147 1
a1147 1
	TestBit	24
d1151 1
d1169 1
d1185 4
a1198 13
        AND     r5, r5, #&0F
        TEQS    r5, #&0F                ; If [pc, #xxx] then comment it
        MOVNE   r8, #-1
        BNE     %FT80

        TestBit	24		        ; Pre/~Post bit
        MOVEQ   r8, #-1
        BEQ     %FT80                   ; [postincrement, so wacky]

        TestBit 23		        ; Up/~Down bit
        SUBEQ   r8, r9, r8              ; Form offset from required address
        ADDNE   r8, r9, r8

d1207 1
a1207 6
        CMP     r8, #-1
        BEQ     InstructionEnd

        BL      Tab                     ; Will also insert '; '

        B       BranchLdrStrCommon
d1209 7
a1226 1
        MOV     r8, #-1
d1236 2
d1240 1
a1240 3
Mull    DCB     "MULL",0
Mlal    DCB     "MLAL",0
aswp    DCB     "SWP",0
d1244 1
a1244 11
	; Arrive here with cccc 00xx xxxx xxxx xxxx xxxx 1xx1 xxxx

        AND     R10,R4,#&F0             ; forcible check for &xxxxxx9x
        TEQS    R10,#&90
        BNE	LdrStrH

        MOV     R5,R4,LSR #23
        AND     R5,R5,#&1F
                                        ; vvv - tested
        TST     r4, #&38 :SHL: 22       ; 0000 00AS dddd nnnn ssss 1001 mmmm ?
        BNE     Undefined               ; test was &3F - changed to allow SWP,MULL,MLAL through
d1246 9
a1254 2
        TEQS    R5,#2_00001
        BEQ     mul_long
d1256 2
a1257 6
        CMPS    R5,#2_00010
        BEQ     swp
	BHS	Undefined

	TestBit	22
	BNE	Undefined
d1437 10
d1587 1
d1640 1
a1640 1
	BEQ	is_MRSorMSR
d1772 35
a1806 3
is_MRSorMSR
	; arrive here with cccc 00x1 0xx0 xxxx xxxx xxxx xxxx xxxx
	TestBit	21
d1809 1
a1809 1
is_MRS	; arrive here with cccc 00x1 0x00 xxxx xxxx xxxx xxxx xxxx
a1820 2
	TestBit	25
	BNE	Undefined
d1834 2
a1835 1
is_MSR	; arrive here with cccc 00x1 0x10 xxxx xxxx xxxx xxxx xxxx
a1850 6
	; Check it's not a BX (encoded as MSR CPSR_cxsf, Rm, LSL PC)
	BIC	r5, r4, #&F000000F
	LDR	r10, =&012FFF10
	TEQS	r5, r10
	BEQ	is_BX

a1857 7
	; Can't use cxs bits in an immediate MSR
	TestBit	25
	BEQ	%FT05
	TST	r4, #2_0111 :SHL: 16
	MOVNE	r10, #Mistake_Unpred
	STRNE	r10, Mistake

d1870 10
a1879 1
is_BX	; arrive here with cccc 0001 0010 1111 1111 1111 0001 xxxx
d1881 1
a1881 1
	; format is        cccc 0001 0010 1111 1111 1111 0001 nnnn
d1883 1
a1883 1
	; BX{cond} Rn
d1886 1
d1888 6
a1893 1
	AddStr	BxTAB,,conds
d1897 6
d1905 84
d1993 3
d2030 4
d2036 1
a2036 1
        TEQS    r2, #2_0001 :SHL: 8
d2039 1
a2039 1
        TEQS    r2, #2_0010 :SHL: 8
d2042 7
d2056 2
d2063 2
d2070 1
a2070 1
	;	   w = Writeback (must be 1 if post-indexed)
d2075 1
a2075 1
	;	iiii = immediate offset (in words)
d2079 2
a2080 2
	TST	r4, #1:SHL:24 :OR: 1:SHL:21
	BEQ	Undefined		; Post-indexed, but no writeback!
d2082 1
a2082 1
	TestStr	20,Ldc,Stc,conds        ; Load/~Store bit
a2090 1

d2113 1
d2126 1
a2126 1
	AddStr	Cdp,,conds
d2170 1
a2170 2
        BL      SaveString
        B       InstructionEnd
d2181 1
d2192 1
a2192 1
	TestStr	20,Mrc,Mcr,conds        ; Load/~Store bit
d2313 1
a2313 1
Dis_F_Register ENTRY "r2"
d2356 1
a2356 1
        EXIT
d2388 1
a2388 1
SaveString ENTRY
d2394 1
a2394 1
        EXIT
d2404 11
a2414 11
        TEQS    R1, #15
        MOVEQ   R10,#Mistake_NV
        STREQ   R10,Mistake
        ADR     R10, CondSym
        ADD     r1, r10, r1, LSL #1
        LDRB    r10, [r1], #1
        TEQS    r10, #0
        STRNEB  r10, [r0], #1
        LDRNEB  r10, [r1], #1
        STRNEB  r10, [r0], #1
        EXIT
a2431 2
        DCB     0,0                     ; 14 : AL cc
        DCB     "NV"                    ; 15
d2442 17
a2499 1
        =       "M09",0		; Use of NV
d2518 1
d2549 1
a2549 1
StoreDecimal ENTRY "r1-r2, r4"
d2566 1
a2566 1
        EXIT
d2584 1
a2584 1
        EXITS
a2641 4
        [       rp0512
        BL      memorytest
        ]

d2811 2
d2816 49
a2864 1
        SWI     XOS_NewLine
d2866 10
d2924 33
d2959 2
a3004 4
        [       rp0512
        BL      memorytest
        ]

a3273 7
        [       rp0512
        MOV     r2, r7                 ; avoid walking over the value to write
        MOV     r7,r9

        BL      memorytest2
        ]

a3275 3
        [       rp0512
        MOV     r7, r2                  ; and back where it should be
        ]
a3393 5
        [       rp0512
        ADDCC   sp,sp,#256
        BLCC    memorytest2             ;ensure not walking into prohibited space
        SUBCC   sp,sp,#256
        ]
d3460 1
d3462 3
d3469 1
a3469 6
        [       rp0512
        MOV     r9,r7
        BL      memorytest
        ]

        ADR     r4, Breaklist           ; Check for breakpoint already in list
d3499 6
a3504 3
        ADR     r0, BreakCodeStart
        ADD     r0, r0, r3              ; each code entry is 8 bytes too
        BL      MakeBranch
d3581 6
a3586 3
        ADR     r0, BreakCodeStart      ; Check still B debugger
        ADD     r0, r0, r3              ; each code entry is 8 bytes too
        BL      MakeBranch              ; r1 from up there
d3692 6
a3697 3
        ADR     r0, BreakCodeStart      ; Check that breakpoint was valid
        ADD     r0, r0, r3              ; Each code entry is 8 bytes too
        BL      MakeBranch
d3715 1
a3715 1
        BICVC   R10,R10,#ARM_CC_Mask
d3730 3
d3734 1
a3734 1
        BIC     r14, r14, #ARM_CC_Mask
d3755 7
a3761 3
        ADR     r0, BreakCodeStart
        ADD     r0, r0, r3
        BL      MakeBranch
d3771 1
a3771 1
        BICVC   R10,R10,#ARM_CC_Mask
d3793 1
a3793 1
        ADR     r8, ExecuteBuffer+8
d3795 2
d3800 2
a3801 2
        LDR     r14, pc_register
        AND     r14, r14, #ARM_CC_Mask
d3803 1
a3803 1
        ORR     r7, r7, r14             ; dumped pc -> ExecBuffer +mode +flags
d3805 2
d3819 2
d3840 4
a3843 5

        ADD     r0, r1, #4              ; Make a BAL to the next instruction
        ADR     r1, ExecuteBuffer+4     ; that it wants to execute after this
        BL      MakeBranch              ; one, ie. back in real program @@ r1+4
        STR     r2, [r1]
d3851 1
a3851 1
        ADR     r0, ExecuteBuffer+8     ; and drop into ...
d3856 4
a3870 1
; ECN: Inserted NOP to avoid registers being trashed.
d3875 28
a3910 1
        BICVC   R10,R10,#ARM_CC_Mask
d4091 1
d4093 2
a4094 1
        BIC     r14, r14, #ARM_CC_Mask
d4104 1
a4104 1
SwapAllBreakpoints ENTRY "r1-r5"
d4153 4
a4167 2
        ORR     r10, r10, r3
        STR     r10, pc_register        ; Save pc+psr from breakpoint
d4169 12
a4184 1
        BIC     R10,R10,#ARM_CC_Mask
d4194 27
d4360 2
d4363 4
a4366 3
        MOVEQ   r0, #"c"                ; Expect 'c'
        LDREQ   r7, pc_register
 [ :LNOT: Addr26
d4368 1
a4368 2
 ]
        BEQ     %FT60
d4370 5
a4374 4
        TEQ     r0, #"l"
        MOVEQ   r0, #"r"                ; Expect 'r'
        LDREQ   r7, Registers + 14*4
 [ :LNOT: Addr26
d4376 1
a4376 2
 ]
        BEQ     %FT60
d4378 1
a4378 1
        TEQ     r0, #"s"
d4468 12
a4479 1
        MOVS    pc, lr
d4500 3
a4502 1
        BIC     r0, lr, #&fc000003
a4577 83

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ rp0512

memorytest2
;for memorya - only allow values <&3000000
  STMFD R13!,{R7-R9,R14}
  CMPS R7,#&3000000
  CMPLTS R9,#&3000000
  BHS bad_write_addr
  B memtest

memorytest
  STMFD R13!,{R7-R9,R14}
memtest
  ;address range=R9 to R7

  ;under <&2000000 call OS_ValidateAddress
  ;no if within &3000000-&33FFFFF
  ;yes if &3400000-&3FFFFFF

  ;is high address above validated area ?
  CMPS r7,#&2000000
  BHS above_logical

  ;feed both through OS_ValidateAddress
  MOV r0,r9
  MOV r1,r7
  SWI XOS_ValidateAddress
  BCS bad_addr
values_ok
  LDMFD R13!,{R7-R9,R15}


above_logical
  ;is low address below this range
  CMPS r9,#&2000000
  BHS not_logical

  ;validate from low address to end of logical ram
  MOV r0,r9
  MOV r1,#&2000000
  SUB r1,r1,#1
  SWI XOS_ValidateAddress
  BCS bad_addr

not_logical
  ;now bounce if either involve, or pass &3000000-&33FFFFF
  ;logic - if low addr<&33FFFFF and hi>&3000000 bounce it - crosses the range
  ;then bounce if either is within the range &3000000-&33FFFFF

  MOV r8,#&3400000
  SUB r8,r8,#1

  CMPS r9,r8
  BHS values_ok ;lower is >end of area, so higher must be

  CMPS r7,#&3000000
  BLT values_ok ; higher is before area, so lower must be

bad_addr
  ADR R0,badaddr
bad_common
  LDMFD R13!,{R7-R9,R14} ;recover regs and return for BL
  LDMFD R13!,{R6-R11,R14}
  B CopyError

bad_write_addr
  ADR R0,badwrite
  B bad_common

badaddr
  DCD ErrorNumber_CoreNotReadable
  = "BadRead",0
  ALIGN

badwrite
  DCD ErrorNumber_CoreNotWriteable
  = "BadWrt",0
  ALIGN

 ]
@


4.3
log
@Lots of bug fixes and extra warnings. Source code tidied.
Thumb disassembly added.
@
text
@d22 2
a23 2
;		William Turner (StrongARM compatibility)
;		Kevin Bracey (Architecture 4 instructions, fixes)
d139 3
a141 3
;			 CP15 comments amended to ARMv4
;			 ARM3 warning removed from SWP (after all, MRS,
;			   MULL etc don't have warnings!)
d146 12
a157 12
;			 FLT was showing wrong dest reg, with registers
;			   shown in wrong order.
;			 WFC etc were showing precision.
;			 Unknown FP opcodes now shown as normal coprocessor
;			   operations.
;			 LDC/STC (and FP derivatives) didn't detect
;			   post-indexing with no writeback. Now reported as
;			   undefined instructions.
;			 UMULLEQS no longer pushes registers into the
;			   comment field.
;			 MSR/MRS now specified as described in ARM
;			   Architecture Reference 4.
d159 2
a160 2
;			 More FP opcodes tightened up.
;			 PC-relative load/store with writeback no longer
d169 9
d196 1
a196 1
        GET     Version
d424 1
a424 1
	DCB	"DisassembleThumb", 0	; +1
d429 5
a433 1
        DCB     "Debugger", TAB, "$Version ($CurrentDate)", 0
d508 5
d514 1
d516 1
a516 1

d520 1
d972 1
a976 1
	[ WarnSArev2
a983 4
	TestBit	15
	MOVNE	r10, #Mistake_R15	; STM {R15}^ not allowed
	STRNE	r10, Mistake		; according to ARMv4

d993 2
a994 2
	; format is        cccc 011p ubwl nnnn dddd rrrr rtt0 mmmm
	;        or        cccc 010p ubwl nnnn dddd iiii iiii iiii
d1419 1
a1419 1
20	AND	r5, r5, #1:SHL:24 :OR: 1:SHL:21
d1544 1
a1544 1
	;       nnnn = Rn (0 if not used)
a1578 5
	LDR	r10, =&E1A00000			; MOV R0,R0
	TEQ	r4, r10
	ADREQ	r10, Nop
	BEQ	SaveStringEnd

a1823 1
Nop	DCB	"NOP",0
d2299 1
a2299 1
	=	"M67",0		; Precede by store or MRC/MCR
d2405 7
a2411 3
 [ Addr26
        BIC     r9, r9, #ARM_CC_Mask    ; Ensure in 64M space
        BIC     r7, r7, #ARM_CC_Mask
d2418 3
a2420 4
        ADDEQ   r7, r7, #4
 [ Addr26
        BICEQ   r7, r7, #ARM_CC_Mask    ; Ensure still in 64M space
 ]
d2422 1
a2488 3
 [ Addr26
        BIC     r9, r9, #ARM_CC_Mask            ; Wrap within 64M
 ]
d2676 1
a2676 1
	MOV	R6,#"B"
a2687 5
 [ Addr26
        BIC     r9, r9, #&FC000000      ; Ensure in 64M space
        BIC     r7, r7, #&FC000000
 ]

a2693 3
 [ Addr26
        BICEQ   r7, r7, #&FC000000      ; Ensure still in 64M space
 ]
a2737 3
 [ Addr26
        BIC     r0, r0, #&FC000000      ; Wrap to keep in 64M each loop
 ]
a2964 3
 [ Addr26
        BIC     r9, r9, #&FC000000      ; Ensure in 64M space
 ]
a3045 3
 [ Addr26
        BIC     r9, r9, #&FC000000      ; Wrap in 64M space
 ]
a3168 6
 [ Addr26
        BIC     r7, r7, #ARM_CC_Mask    ; Can only set at word address in 64M

        CMP     r7, #&02000000          ; Can only set in LogRam
        BHS     BreakSetError1
 |
a3172 1
 ]
a3692 3
 [ Addr26
        BIC     r9, r9, #&FC000000      ; Wrap within 64M each loop
 ]
@


4.3.2.1
log
@Stopped Addr26 screwing up Thumb disassembly. Set Addr26 to True.
@
text
@a168 3
; 1.53  KJB 11-Nov-96    SWI called checkreg for no apparent reason.
;                        Stopped Addr26 screwing up Thumb disassembly.
;                        Set Addr26 to True.
a951 1
	[ WarnSArev2
d956 1
d964 4
d977 2
a978 2
	; format is        cccc 010p ubwl nnnn dddd rrrr rtt0 mmmm
	;        or        cccc 011p ubwl nnnn dddd iiii iiii iiii
d1528 1
a1528 1
	;       nnnn = Rn (0 if not used, 15 signals P flag on compares)
d1563 5
d1813 1
d2289 1
a2289 1
	=	"M67",0		; Only 1 reg on SA-110 rev 2
a2394 15
 [ Thumb
	TEQ	r6, #4

 [ Addr26
        BICEQ   r9, r9, #ARM_CC_Mask    ; Ensure in 64M space
        BICEQ   r7, r7, #ARM_CC_Mask
        BICNE   r9, r9, #1              ; ensure halfword aligned
        BICNE   r7, r7, #1
 |
        BICEQ   r9, r9, #3              ; ensure word aligned
        BICEQ   r7, r7, #3
        BICNE   r9, r9, #1              ; ensure halfword aligned
        BICNE   r7, r7, #1
 ]
 |
a2401 1
 ]
d2404 1
a2404 3
	BNE	%FT05

	ADD	r7, r7, r6
a2405 1
	TEQ	r6, #4
a2408 1
05
d2476 1
a2476 1
        BIC     r9, r9, #&FC000000            ; Wrap within 64M
@


4.3.2.2
log
@Test for post-indexed LDRH etc with W bit set didn't work.
Service call table added.
@
text
@a171 2
; 1.54  KJB 27-Mar-98    Test for post-indexed LDRH etc with W set didn't work.
;                        Service call table added.
a497 5
Debug_ServiceTable
	DCD	0
	DCD	Debug_ServiceBody - Module_BaseAddr
	DCD	Service_Reset
	DCD	0
a498 1
	DCD	Debug_ServiceTable - Module_BaseAddr
d500 1
a500 1
	MOV	r0, r0
a503 1
Debug_ServiceBody
d1402 1
a1402 1
20	AND	r5, r4, #1:SHL:24 :OR: 1:SHL:21
@


4.3.2.3
log
@Only wrap addresses in 64M space for branch disassembly and use of
lr and pc in *Commands.
@
text
@d22 2
a23 2
;               William Turner (StrongARM compatibility)
;               Kevin Bracey (Architecture 4 instructions, fixes)
d139 3
a141 3
;                        CP15 comments amended to ARMv4
;                        ARM3 warning removed from SWP (after all, MRS,
;                          MULL etc don't have warnings!)
d146 12
a157 12
;                        FLT was showing wrong dest reg, with registers
;                          shown in wrong order.
;                        WFC etc were showing precision.
;                        Unknown FP opcodes now shown as normal coprocessor
;                          operations.
;                        LDC/STC (and FP derivatives) didn't detect
;                          post-indexing with no writeback. Now reported as
;                          undefined instructions.
;                        UMULLEQS no longer pushes registers into the
;                          comment field.
;                        MSR/MRS now specified as described in ARM
;                          Architecture Reference 4.
d159 2
a160 2
;                        More FP opcodes tightened up.
;                        PC-relative load/store with writeback no longer
a173 4
; 1.55  KJB 08-May-98    Made Addr26 flag only affect disassembly of BL
;                        and use of lr and pc. Addresses are not wrapped
;                        to 64M. This makes sense for our 32-bit ARM in 26-bit
;                        mode.
d2398 1
a2398 1
        TEQ     r6, #4
d2400 6
d2410 5
d2419 1
d2422 1
a2422 1
        BNE     %FT05
d2424 5
a2428 1
        ADD     r7, r7, r6
d2497 3
d2687 1
a2687 1
        MOV     R6,#"B"
d2699 5
d2710 3
d2757 3
d2987 3
d3071 3
d3197 6
d3207 1
d3728 3
@


4.2
log
@Version RO_3_70 taken
@
text
@d15 1
a15 1
        TTL     > <wini>arm.Debugger.Debugger - ARM/Arthur debugger (principally for machine code)
d23 1
a23 1
;		Kevin Bracey (Architecture 4 instructions)
d133 3
d141 28
a168 1
;			 MULL etc don't have warnings!)
d199 1
a199 1
Addr26  SETL    CPU_Type <> "ARM600" ; true for 26 bit wrap on addresses
d207 7
d247 4
d255 1
a255 1
StringBuffer    #       88              ; Temp string buffer. Big enough to
d260 28
d318 69
d414 3
d485 4
d522 1
a522 1
        CMP     r14, r1
d527 1
a527 1
        CMP     r0, #0
d530 2
d549 3
d553 1
d564 3
d568 1
d583 1
a583 1
;       r2 = length of string including 0
d590 4
d605 4
a608 4
        CMP     R14,#-3            ;potential error if a banked access occurs (after LDM)
        MOVEQ   R14,#-2
        CMP     R14,#-4            ;potential error if a SWI occurs (after coproc)
        MOVEQ   R14,#-1
d617 2
a618 2
        CMP     R14,#-2
        CMPNE   R14,#-1
d625 8
d638 2
a639 2
        CMP     R14,#-2
        MOVEQ   R14,#3
d655 1
a655 1
        CMP     R4, R5
d674 1
a674 1
        CMP     r3, #&0F
d681 1
a681 2
        BEQ     Branch
        BHI     BranchLink
d694 1
d720 1
a720 2
        SUBS    r2, r0, r1              ; VClear
        EXIT
d722 1
a723 2
Unknown DCB     "M00", 0
        ALIGN
d728 8
d737 2
a738 2
        CMP     R10, #-1
        MOVEQ   R10, #4
d741 1
a741 4
        BL      checkreg

        ADR     r10, Swi_Instruction
        BL      SaveStringConditions
a755 4
Swi_Instruction
        DCB     "SWI", 0
        ALIGN

d759 9
d770 2
a771 11
        MOV     r2, #"B"
        B       %FT50

BranchLink

        BL      checkreg
        MOV     r2, #"B"
        STRB    r2, [r0], #1
        MOV     r2, #"L"

50      STRB    r2, [r0], #1
d780 1
a780 1
        MOV     r8, r4, LSL #8          ; shift offset up to top
d794 3
a796 3
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load and store multiple

d803 16
d827 1
a827 1
        TST     R4, #1 :SHL: 15
d830 1
a830 1
        TST     R4, #1 :SHL: 22
d834 4
a837 4
        TST     R4, #1 :SHL: 21
        MOVNE   R10, #2
        STRNE   R10, Mistake
        BNE     notbad ;don"t bother with next test
d840 4
a843 3
        TST     R4, #1 :SHL: 20
        MOVNE   R10,#-3
        STRNE   R10,Mistake
d846 29
a874 4
        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Ldm
        ADREQ   r10, Stm
        BL      SaveStringConditions
d876 1
a876 4
        TST     r4, #1 :SHL: 23         ; Up/~Down bit
        MOVEQ   r10, #"D"
        MOVNE   r10, #"I"
        STRB    r10, [r0], #1
d878 1
a878 4
        TST     r4, #1 :SHL: 24         ; Pre/~Post bit
        MOVEQ   r10, #"A"
        MOVNE   r10, #"B"
        STRB    r10, [r0], #1
d881 4
a884 3
        CMP     R5, #15
        CMPNE   R5, #8
        BLHI    checkreg                ;error if R8-R14
d894 5
a898 2
        MOV     r5, #0
        MOV     r8, #0
d909 4
a912 1
        CMP     r5, #16
d916 1
a916 1
        TST     r2, r4, LSR r2
d922 1
a922 1
        CMP     r5, #16
d926 1
a926 1
        TST     r2, r4, LSR r2
d932 2
a933 2
        CMP     r8, #3
        MOVCS   r6, #"-"
d938 4
d944 1
a944 1
        CMP     r5, #16
d947 4
d952 11
a962 2
Xxm_End MOV     r10, #"}"               ; end register list
        STRB    r10, [r0], #1
d964 3
a966 3
        TST     r4, #1 :SHL:  22        ; '^' bit
        MOVNE   r10, #"^"
        STRNEB  r10, [r0], #1
d973 24
a996 2

LdrStr ROUT
d1002 4
a1005 4
        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Ldr
        ADREQ   r10, Str
        BL      SaveStringConditions
d1008 18
a1025 2
        MOVNE   r10, #"B"
        STRNEB  r10, [r0], #1
d1027 1
d1029 2
a1030 6
        CMP     r10,     #2_0001 :SHL: 21 ; postincrement with writeback ?
        MOVEQ   r10, #"T"               ; -> T(ranslate)
        STREQB  r10, [r0], #1

        MOV     r5, r4, LSR #12         ; Rd
        BL      Tab_Dis_Register
d1032 20
d1053 1
d1060 2
a1061 9
        CMP     R5,#15

        TSTEQ   R4,#1 :SHL: 25

        MOVEQ   R5,#","
        STREQB  R5,[R0],#1
        MOVEQ   R8,R4,LSL #32-12
        MOVEQ   R8,R8,LSR #32-12
        BNE     not_rel
d1063 14
a1076 1
 [ {TRUE} ; TMD 27-Oct-93 - fix MED-00167
d1080 1
a1080 1
        TST     r4, #1 :SHL: 27         ; if a coproc data transfer
a1081 1
 ]
d1083 1
a1083 1
        TST     r4, #1 :SHL: 23         ; Up/~Down bit
d1090 1
a1090 2
        ADR     r10, Open_B             ; ',['
        BL      SaveString
d1095 1
a1095 4
        TST     r4, #1 :SHL: 24         ; Pre/~Post bit
        ADR     r10, Close_B
        ADDNE   r10, r10, #1            ; just ',' else '],'
        BL      SaveString
d1097 1
a1097 1
        TST     r4, #1 :SHL: 25         ; Shift/~Immediate bit
d1102 1
a1102 2
        MOV     r6, #"#"
        STRB    r6, [r0], #1
d1104 1
a1104 3
        TST     r4, #1 :SHL: 23         ; Up/~Down bit
        MOVEQ   r6, #"-"
        STREQB  r6, [r0], #1            ; -ve index
d1108 2
a1109 4
        AND     r6, r4, #&0C000000
        CMP     r6,     #&0C000000
        ANDEQ   r8, r8, #&FF            ; smaller offset if coproc (1.32)
        MOVEQ   r8, r8, LSL #2          ; Word offset if coprocessor
d1113 1
a1113 1
        CMP     r5, #&0F                ; If [pc, #xxx] then comment it
d1117 1
a1117 1
        TST     r4, #1 :SHL: 24         ; Pre/~Post bit
d1121 1
a1121 1
        TST     r4, #1 :SHL: 23         ; Up/~Down bit
d1125 3
a1127 4

80      TST     r4, #1 :SHL: 24         ; Pre/~Post bit
        MOVNE   r10, #"]"
        STRNEB  r10, [r0], #1           ; [preincrement, so close]
d1130 2
a1131 3
        CMP     r10,     #2_1001 :SHL: 21 ; preincrement with writeback ?
        MOVEQ   r10, #"!"
        STREQB  r10, [r0], #1
d1143 2
a1144 4

90      TST     r4, #1 :SHL: 23         ; Up/~Down bit
        MOVEQ   r10, #"-"
        STREQB  r10, [r0], #1           ; -ve index
a1157 1
        ALIGN
a1159 1
; Multiply + Multiply-with-Accumulate
d1163 3
d1169 1
d1172 1
a1172 1
        CMP     R10,#&90
d1181 1
a1181 1
        CMP     R5,#2_00001
d1184 1
a1184 1
        CMP     R5,#2_00010
d1186 4
d1191 14
a1204 1
; MUL/MLA
d1206 1
a1206 4
        TST     r4, #1 :SHL: 21         ; Accumulate bit
        ADREQ   r10, Mul
        ADRNE   r10, Mla
        BL      SaveStringConditions
d1208 1
a1208 3
        TST     r4, #1 :SHL: 20         ; Update flags bit
        MOVNE   r10, #"S"
        STRNEB  r10, [r0], #1
d1213 1
a1213 2
        MOV     r5, r4                  ; Rm
        AND     R5,R5,#15
d1216 3
a1218 3
        CMP     R10,R5
        CMPNE   R10,#15
        MOVEQ   R14,#5
d1226 1
a1226 1
        TST     r4, #1 :SHL: 21         ; MLA has extra operand
d1228 5
a1232 1
        BLNE    Comma_Dis_Register
d1237 15
d1253 1
a1253 6
        TST     R4, #1 :SHL: 22
        MOVNE   R10, #"S"
        MOVEQ   R10, #"U"
        STRB    R10, [R0], #1

        TST     r4, #1 :SHL: 21         ; Accumulate bit
d1260 3
a1262 3
        ADREQ   r10, Mull
        ADRNE   r10, Mlal
        BL      SaveStringConditions
d1264 8
a1271 3
        TST     r4, #1 :SHL: 20         ; Update flags bit
        MOVNE   r10, #"S"
        STRNEB  r10, [r0], #1
d1274 2
a1275 1
        BL      Tab_Dis_Register
d1278 1
d1282 1
d1286 1
d1289 16
d1307 18
a1324 4
aswp    DCB     "SWP",0
Mull    DCB     "MULL",0
Mlal    DCB     "MLAL",0
        ALIGN
d1326 2
a1327 3
swp     AND     R5,R4,#&F90
        CMP     R5,#&90
        BNE     Undefined               ;it is SWP, ie cond00010b00nnnndddd00001001mmmm
a1328 5
        ADR     R10,aswp
        BL      SaveStringConditions
        ANDS    R5,R4,#1 :SHL: 22
        MOVNE   R10,#"B"
        STRNEB  R10,[R0],#1
d1330 5
d1336 10
a1345 1
        MOV     R5,R4
d1347 2
a1348 2
        ADR     R10,Open_B
        BL      SaveString
d1350 9
d1360 1
a1360 2
        MOV     R10,#"]"
        STRB    R10,[R0],#1
d1374 4
a1377 3
	; {LDRH|LDRSH|LDRSB|STRH} Rd,[Rn,{#offset|Rm}]
	;                         Rd,[Rn,{#offset|Rm}]!
	;                         Rd,[Rn],{#offset|Rm}
d1382 1
a1382 1
	;	   w = Writeback
d1403 7
a1409 12

20	TSTS	r4, #1:SHL:20
	ADRNE	r10, Ldr
	ADREQ	r10, Str
	BL	SaveStringConditions
	TSTS	r4, #1:SHL:6
	MOVNE	r10, #"S"
	STRNEB	r10, [r0], #1
	TSTS	r4, #1:SHL:5
	MOVNE	r10, #"H"
	MOVEQ	r10, #"B"
	STRB	r10, [r0], #1
d1414 25
a1438 1
	MOV	r5, r4, LSR #16
d1441 12
a1452 2
	ANDEQ	r10, r4, #1:SHL:22      ; Immediate/~Register offset
	TEQEQS	r10, #1:SHL:22
d1457 1
a1457 2
	MOV	r5, #","
	STRB	r5, [r0], #1
d1468 2
a1469 2
	ADR	r10, Open_B		; ",["
	BL	SaveString
d1480 2
a1481 5
	MOV	r6, #"#"
	STRB	r6, [r0], #1
	TSTS	r4, #1 :SHL: 23		; Up/~Down bit
	MOVEQ	r6, #"-"
	STREQB	r6, [r0], #1
d1490 1
a1490 3
	TSTS	r4, #1:SHL:23		; Up/~Down bit
	MOVEQ	r6, #"-"
	STREQB	r6, [r0], #1
d1494 6
d1504 1
a1504 2
	MOV	r6, #"]"
	STRB	r6, [r0], #1
d1506 1
a1506 3
	TSTS	r4, #1:SHL:21           ; Writeback bit
	MOVNE	r6, #"!"
	STRNEB	r6, [r0], #1
a1508 6
	[ {FALSE}
arm3only = "M01",0
        ALIGN
	]


d1512 22
d1536 1
a1536 1
        LDR     r3, =&0E000090          ; Data processing op with bit 4 set
d1538 1
a1538 2
        LDR     r2, =&00000090          ; is not defined
        CMP     r3, r2
d1541 1
d1547 2
a1548 2
        CMP     R6,#2
        CMPNE   R6,#4
d1553 1
a1553 1
        CMP     R5,#15
d1556 1
a1556 1
        ANDS    R5,R4,#&02000000
d1559 8
a1566 28
        ;if opc is 0xx0 we need to check whether it's going to a MRS/MSR
        ANDS    R5,R6,#8
        BEQ     notMRSorMSR
        ;r4 still holds the opcode, we want the following cases
        ;31   27   23   19   15
        ;cccc 0001 0x00 1111 xxxx MRS
        ;cccc 0001 0x10 1001 1111 MSR (register to PSR)
        ;cccc 00x1 0x10 1000 1111 MSR (flag bits only)
        ;previous test ensures that b24 is set

        AND     R5,R4,#&00BF0000
        CMP     R5,#&000F0000
        BEQ     is_MRS

        AND     R10,R4,#&0000F000
        CMP     R10,#&F000
        BNE     notMRSorMSR
        BIC     R5,R5,#&00010000
        CMP     R5,#&00280000
        BEQ     is_MSR

        ; and fall through to...

notMRSorMSR
	BIC	r5, r4, #&F000000F
	LDR	r10, =&012FFF10
	TEQS	r5, r10
	BEQ	is_BX
d1573 1
a1573 1
        MOV     r5, r4, LSR #12         ; Rn
d1575 2
a1576 2
        RSBCSS  r14, r6, #&0B
        BCC     %FT10
d1578 2
a1579 1
        AND     r5, r5, #2_1111         ; If Rn = pc then xxxP
d1581 4
a1584 4
        MOVEQ   r10, #"P"
        STREQB  r10, [r0], #1
        MOVEQ   R10, #-3
        STREQ   R10, Mistake            ;potential bank access error
d1586 1
a1586 1
        BL      Tab
d1589 2
a1590 4

10      TST     r4, #1 :SHL: 20         ; Update flags bit
        MOVNE   r10, #"S"
        STRNEB  r10, [r0], #1
d1598 4
a1601 1
        BEQ     Operand_2
d1603 1
a1603 2

20      MOV     r5, r4, LSR #16         ; Rd
d1608 1
a1608 1
        TST     r4, #1 :SHL: 25         ; Immediate bit
d1619 1
a1619 2
        MOV     r10, #"#"
        STRB    r10, [r0], #1
d1622 2
a1623 2
        AND     r2, r2, #30             ; Yes, I really do mean 30, see the bok
        AND     r8, r4, #&FF
d1635 2
a1636 2
        CMP     r8, #10
        BCC     Rem_Number              ; If really simple, just display number
d1640 4
a1643 4
        CMP     r8, #&100
        MOVCS   r2, #16-4               ; then halfword
        CMP     r8, #&10000
        MOVCS   r2, #32-4               ; then fullword
d1646 1
a1646 1
        CMP     r8, #8192               ; If really big, don't comment on it
d1651 1
a1651 2
        MOV     r10, #"="
        STRB    r10, [r0], #1
d1655 2
a1656 2
        CMP     r8, #delete
        CMPNE   r8, #space-1
d1659 1
a1659 1
        CMP     r8, #&100
d1675 2
a1676 3
isADR   ADR     R10, AdrTAB
        BL      SaveStringConditions
        BL      Tab
d1678 1
a1678 1
        BL      Dis_Register
d1681 2
a1682 2
        AND     R2, R2, #&1E
        AND     R8, R4, #&FF
d1684 1
a1684 1
        CMP     R6, #2
d1693 1
a1693 1
        ANDS    R5,R4,#&00400000
d1698 4
a1701 5
CPSR_or_SPSRflag
        ANDS    R5,R4,#&00400000
        ADREQ   R10,cpsr_flag_tab
        ADRNE   R10,spsr_flag_tab
        B       SaveString
d1703 14
a1716 3
is_MRS  ;check for illegal instruction first
        MOVS    R5, R4, LSL #20            ;bottom 12 bits should be zero
        BNE     Undefined
d1718 6
a1723 9
        ADR     R10, MrsTAB
        BL      SaveStringConditions
        BL      Tab
        MOV     R5,R4,LSR #12              ;get Rd
        BL      Dis_Register
        BL      AddComma
        ;either CPSR or SPSR - b22 clear for CPSR
        BL      CPSR_or_SPSR
        B       InstructionEnd
d1725 2
a1726 13
cpsr_tab DCB    "CPSR_all",0
spsr_tab DCB    "SPSR_all",0
cpsr_flag_tab DCB    "CPSR_flg",0
spsr_flag_tab DCB    "SPSR_flg",0
        ALIGN

is_MSR  ;two legal cases here
        ;cccc 0001 0x10 1001 1111 xxxx xxxx xxxx
        ;cccc 00x1 0x10 1000 1111 xxxx xxxx xxxx
        ;so if b25 set and b16 set we revert to a data op
        ANDS    R5,R4,#&02000000
        ANDNES  R5,R4,#&00010000
        BNE     notMRSorMSR
d1728 1
a1728 1
        ;if bit is 16 it is MSR to whole PSR, otherwise it is to flags only
d1730 15
a1744 2
        TST     R4,#&10000
        BNE     msr_whole
d1746 5
a1750 7
        ;flags only, may be register or immediate value
        ADR     R10,MsrTAB
        BL      SaveStringConditions
        BL      Tab
        BL      CPSR_or_SPSRflag
        BL      AddComma
        B       Operand_2
d1752 2
a1753 1
msr_whole
d1755 3
a1757 1
        ;but undefined if shift is non zero
d1759 6
a1764 2
        ANDS    R5,R4,#&FF0
        BNE     Undefined
d1766 11
a1776 6
        ADR     R10,MsrTAB
        BL      SaveStringConditions
        BL      Tab
        BL      CPSR_or_SPSR
        BL      AddComma
        B       Operand_2
d1778 1
a1778 2
is_BX	; one legal case
	; cccc 0001 0010 1111 1111 1111 0001 mmmm
d1780 1
a1780 1
	; BX Rm
d1782 1
a1782 1
	; where mmmm = Rm
d1784 4
a1787 3
	ADR	R10,BxTAB
	BL	SaveStringConditions
	AND	R5,R4,#&FF
d1795 2
a1796 2
BxTAB   DCB     "BX", 0, 0

d1813 1
d1815 6
d1822 1
a1822 19
WackyShift
        AND     r8, r4, #&FF            ; Get unrotated byte back
        CMP     r8, #0                  ; 0,n prettified
        MOVEQ   r10, #"0"
        STREQB  r10, [r0], #1

        MOVNE   r2, #8-4                ; Display unrotated byte,decimal rotate
        BLNE    StoreHex

;1.26 - Change layout to #0, ROR #nn
        ADRL    R10,ShiftROR
        BL      SaveString

        MOV     r10, #"#"
        STRB    r10, [r0], #1

        MOV     r8, r4, LSR #7          ; Extract shift part again
        AND     r8, r8, #30
        B       Rem_Number
d1827 3
d1831 1
a1831 2
        MOV     r2, r4, LSR #8          ; r2 := CP#
        AND     r2, r2, #2_1111
d1833 1
a1833 1
        TEQ     r2, #2_0001
d1836 1
a1836 2
;1.32 add coproc 2 for FPA LFM/SFM instructions
        TEQ     r2, #2_0010
d1839 2
d1843 1
a1843 1
        CMP     r3, #&0E
d1846 17
d1865 4
a1868 4
        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Ldc
        ADREQ   r10, Stc
        BL      SaveStringConditions
d1870 1
a1870 3
        TST     r4, #1 :SHL: 22         ; Precision bit
        MOVNE   r10, #"L"
        STRNEB  r10, [r0], #1
d1881 1
a1881 1
                                        ; 0C,0D -> 04,05
a1886 2
Ldc     DCB     "LDC", 0
Stc     DCB     "STC", 0
d1888 1
a1888 1
Cdp     DCB     "CDP", 0
d1890 1
a1890 2
Mcr     DCB     "MCR", 0
Mrc     DCB     "MRC", 0
d1892 1
a1892 8
Cp      DCB     "CP", 0

        ALIGN


Co_Operations

        TST     r4, #1 :SHL: 4          ; Transfer/~Operation bit
d1896 12
d1909 1
a1909 1
        MOV     R10, #-4 ;deferred warning in case SWI next
d1912 1
a1912 2
        ADR     r10, Cdp
        BL      SaveStringConditions
d1938 1
a1938 1
        TST     r4, #1 :SHL: 4          ; Transfer/~Operation bit
d1942 1
a1942 1
        CMP     R5,#&F00
d1945 2
a1946 3
        MOV     R5,R4,LSR #16
        AND     R5,R5,#&0F
	TEQS	R5,#4
d1948 1
a1948 1
	CMPS	R5,#8
d1954 1
a1954 1
        ADD     R10,R10,R5,LSL #2
a1958 12
msgtable
msg0    = "M02",0
msg1    = "M03",0
msg2    = "M04",0
msg3    = "M05",0
msg4    = "M08",0
msg5    = "M06",0
msg6    = "M07",0
msg7    = "M51",0
msg8	= "M52",0

        ALIGN
d1964 13
d1978 1
a1978 4
        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Mrc
        ADREQ   r10, Mcr
        BL      SaveStringConditions
d1982 2
a1983 2
        MOV     r8, r4, LSR #20         ; CPOpc
        AND     r8, r8, #2_1110         ; Only three bits for CPRT
d1998 1
a1998 2
        ADR     r10, Cp
        BL      SaveString
a2004 106
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Lfm     DCB     "LFM",0
Sfm     DCB     "SFM",0
        ALIGN

New_FPA
        CMP     r3,#&0C
        CMPNE   r3,#&0D
        BNE     Undefined       ;only coproc 2 codes so far are LFM/SFM

        TST     r4, #1 :SHL: 20
        ADRNE   r10,Lfm
        ADREQ   r10,Sfm
        BL      SaveStringConditions
        BL      Tab

        MOV     r5, r4, LSR #12         ; Fd
        BIC     r5, r5, #2_1000         ; Only 8 FP registers
        BL      Dis_F_Register

        MOV     r5,#","
        STRB    r5, [r0], #1

        MOV     r5, r4, LSR #15
        AND     r5, r5, #1
        MOV     r14, r4, LSR #21
        AND     r14, r14, #2
        ORR     r5, r5, r14
        TEQ     r5, #0
        MOVEQ   r5, #4
        ORR     r5, r5, #&30
        STRB    r5, [r0], #1

        B       not_rel ;drop into ordinary CPDT processing

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Ldf     DCB     "LDF", 0
Stf     DCB     "STF", 0

        ALIGN

Floating_Point

        CMP     r3, #&0E
        BEQ     Floating_processing

; Floating Point Data Transfer (CPDT)

        TST     r4, #1 :SHL: 20         ; Load/~Store bit
        ADRNE   r10, Ldf
        ADREQ   r10, Stf
        BL      SaveStringConditions

        AND     r14, r4, #1 :SHL: 15    ; FPDT precision bits (Y,X)
        MOV     r14, r14, LSR #15
        AND     r10, r4, #1 :SHL: 22
        ORR     r14, r14, r10, LSR #22-1
        ADR     r10, fpdt_prec
        LDRB    r10, [r10, r14]
        STRB    r10, [r0], #1

        BL      Tab

        MOV     r5, r4, LSR #12         ; Fd
        BIC     r5, r5, #2_1000         ; Only 8 FP registers
        BL      Dis_F_Register

        B       CPDT_Common


fpdt_prec
        DCB     "SDEP"
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Floating_processing

        TST     r4, #1 :SHL: 4          ; Transfer/~Operation bit
        BNE     Floating_Register_Transfer

; Floating Point Data Operation (CPDO)

        MOV     R6, #-4
        STR     R6, Mistake

        MOV     r6, r4, LSR #20         ; FPOpc
        AND     r6, r6, #2_01111
        TST     r4, #1 :SHL: 15
        ORRNE   r6, r6, #2_10000        ; jabcde

        ADR     r1, Floating_Operations
        BL      FPRT_FPDO_Common

        MOV     r5, r4, LSR #12         ; Fd
        BIC     r5, r5, #2_1000         ; Only 8 FP registers
        BL      Dis_F_Register

        TST     r4, #1 :SHL: 15
        BNE     Dis_FmOrConstant        ; [unary op]

        BL      AddComma
        B       Dis_Fn_FmOrConstant

d2007 10
a2017 39
Floating_Operations

        DCB     "ADF"           ; 0  ... binary ops
        DCB     "MUF"           ; 1
        DCB     "SUF"           ; 2
        DCB     "RSF"           ; 3
        DCB     "DVF"           ; 4
        DCB     "RDF"           ; 5
        DCB     "POW"           ; 6
        DCB     "RPW"           ; 7

        DCB     "RMF"           ; 8
        DCB     "FML"           ; 9
        DCB     "FDV"           ; 10
        DCB     "FRD"           ; 11
        DCB     "POL"           ; 12
        DCB     "F0D"           ; 13 ... undefined binary ops
        DCB     "F0E"           ; 14
        DCB     "F0F"           ; 15

        DCB     "MVF"           ; 16 ... unary ops
        DCB     "MNF"           ; 17
        DCB     "ABS"           ; 18
        DCB     "RND"           ; 19
        DCB     "SQT"           ; 20
        DCB     "LOG"           ; 21
        DCB     "LGN"           ; 22
        DCB     "EXP"           ; 23

        DCB     "SIN"           ; 24
        DCB     "COS"           ; 25
        DCB     "TAN"           ; 26
        DCB     "ASN"           ; 27
        DCB     "ACS"           ; 28
        DCB     "ATN"           ; 29
        DCB     "URD"           ; 30
        DCB     "NRM"           ; 31

        ALIGN
d2021 4
a2024 1
FPRT_FPDO_Common ENTRY
d2026 2
a2027 8
        ADD     r6, r6, r6, LSL #1      ; *3
        ADD     r1, r1, r6
        LDRB    r10, [r1], #1
        STRB    r10, [r0], #1
        LDRB    r10, [r1], #1
        STRB    r10, [r0], #1
        LDRB    r10, [r1], #1
        STRB    r10, [r0], #1
d2029 2
a2030 1
        BL      Conditions
d2032 1
a2032 18
        AND     r14, r4, #1 :SHL: 7     ; FPDO/FPRT precision bits (e,f)
        MOV     r14, r14, LSR #7
        AND     r10, r4, #1 :SHL: 19
        ORR     r14, r14, r10, LSR #19-1
        ADR     r10, fpdo_fprt_prec
        LDRB    r10, [r10, r14]
        STRB    r10, [r0], #1

        MOV     r10, #"Z"               ; Rounding mode
        TST     r4, #2_01 :SHL: 5
        MOVEQ   r10, #"M"
        TST     r4, #2_10 :SHL: 5
        MOVEQ   r10, #"P"
        TST     r4, #2_11 :SHL: 5
        STRNEB  r10, [r0], #1

        BL      Tab
        EXIT
d2034 3
a2036 122

fpdo_fprt_prec
        DCB     "SDE?"
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Floating Point Register Transfer (CPRT)

Floating_Register_Transfer

        LDR     r2,  =&0E98FF10
        LDR     r10, =&0E90F110
        AND     r2, r4, r2
        CMP     r2, r10
        BEQ     Floating_Status_Transfer

        MOV     r6, r4, LSR #20         ; FPOpc
        AND     r6, r6, #2_1111

        ADR     r1, Floating_Transfers
        BL      FPRT_FPDO_Common

        MOV     r5, r4, LSR #12         ; Rd (ARM register)
        BL      Dis_Register

        MOV     r6, r4, LSR #20         ; FPOpc
        AND     r6, r6, #2_1111
        CMP     r6, #2_0010             ; FLT/FIX have another operand
        BLCC    Dis_FmOrConstant
        B       InstructionEnd


        LTORG

Floating_Transfers

        DCB     "FLT"           ; 0
        DCB     "FIX"           ; 1
        DCB     "WFS"           ; 2
        DCB     "RFS"           ; 3
        DCB     "WFC"           ; 4
        DCB     "RFC"           ; 5
        DCB     "FT6"           ; 6 ... undefined floating_transfers
        DCB     "FT7"           ; 7

        DCB     "FT8"           ; 8
        DCB     "FT9"           ; 9
        DCB     "FTA"           ; 10
        DCB     "FTB"           ; 11
        DCB     "FTC"           ; 12
        DCB     "FTD"           ; 13
        DCB     "FTE"           ; 14
        DCB     "FTF"           ; 15

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Floating Point Status Transfer

Cmf     DCB     "CMF", 0
Cnf     DCB     "CNF", 0
        ALIGN

Floating_Status_Transfer

        TST     r4, #1 :SHL: 21         ; Negated compare/~Compare bit
        ADREQ   r10, Cmf
        ADRNE   r10, Cnf
        BL      SaveString

        TST     r4, #1 :SHL: 22         ; Exception bit
        MOVNE   r10, #"E"
        STRNEB  r10, [r0], #1

        BL      Conditions

        BL      Tab

; .............................................................................

Dis_Fn_FmOrConstant

        MOV     r5, r4, LSR #16         ; Fn
        BIC     r5, r5, #2_1000         ; Only 8 FP registers
        BL      Dis_F_Register

; .............................................................................

Dis_FmOrConstant ROUT

        BL      AddComma

        TST     r4, #2_1000             ; Immediate operand ?
        BNE     %FT50

        AND     r5, r4, #2_0111         ; Fm
        BL      Dis_F_Register
        B       InstructionEnd


50      MOV     r10, #"#"
        STRB    r10, [r0], #1

        AND     r8, r4, #2_0111         ; 3 bits instead of Fm
        TEQ     r8, #6                  ; 0..7 -> 0,1,2,3,4,5,0.5,10
        ADREQ   r10, Pt5                ; 0.5
        BEQ     SaveStringEnd

        TEQ     r8, #7
        MOVEQ   r8, #10
        BL      StoreDecimal

        ADR     r10, Point0
        B       SaveStringEnd


Pt5     DCB     "0.5", 0
Point0  DCB     ".0", 0

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d2060 1
a2060 2
        MOV     r10, #"#"
        STRB    r10, [r0], #1
d2070 6
a2083 1

d2101 1
a2101 1
        MOV     r10, #"F"
d2103 2
a2104 15
        AND     r5, r5, #2_1111
        CMP     r5, #2_1000             ; Only 8 FP registers
        BCC     %FT50

        STRB    r10, [r0], #1

        CMP     r5, #2_1111             ; Of other 8, only #15 (FSW) valid
        MOVEQ   r10, #"S"
        MOVNE   r10, #"?"
        STRB    r10, [r0], #1

        MOVEQ   r10, #"W"
        MOVNE   r10, #"?"
        STRB    r10, [r0], #1
        EXIT
d2115 4
d2125 3
a2135 4
        CMP     R5,#15
        CMPNE   R5,#7
        BLHI    checkreg

d2138 3
a2140 4
        CMP     r5, #10
        MOVCS   r10, #"1"
        STRCSB  r10, [r0], #1
        SUBCS   r2, r2, #10
d2146 2
a2147 2
Dis_pc  ADR     r10, pc_Reg
        BL      SaveString
d2177 3
a2179 3
        CMP     r14, #32
        STRCSB  r14, [r0], #1
        BCS     %BT10
d2190 2
a2191 2
        CMP     R1, #15
        MOVEQ   R10,#1
d2196 1
a2196 1
        CMP     r10, #0
d2239 1
a2239 1
        CMP     r1, #7
d2241 2
a2242 2
        CMP     r1, #25 ;new exit position for longer comments
        BCC     %BT10
d2254 1
a2254 1
        CMP     R5,#1
d2271 20
a2290 5
sil01   =       "M09",0
sil02   =       "M10",0
sil03   =       "M11",0
sil04   =       "M12",0
sil05   =       "M13",0
d2302 1
a2302 2
        MOV     r14, #"&"
        STRB    r14, [r0], #1
d2306 1
a2306 1
        CMP     r14, #9
d2353 2
a2354 2
50      MOV     r14, #","
        STRB    r14, [r0], #1
d2368 1
a2368 1
        DCB     "M14", 0
d2374 6
d2381 1
d2384 3
d2388 1
d2403 1
a2403 1
        CMP     r9, r7                  ; If same, ensure we do one word
d2424 3
d2428 1
d2436 14
a2449 2
        LDRVC   r10, [r9]               ; Display word at address
        BLVC    DisplayHexWord
d2451 1
a2451 1
        BLVC    MarkBreakpoints
d2453 12
a2464 4
        LDRVC   r0, [r9]                ; Display instruction at address
        MOVVC   r1, r9
        SWIVC   XDebugger_Disassemble
        MOVVC   r0, r1
d2470 3
d2474 1
d2479 1
a2479 1
        CMP     r9, r7
d2493 1
a2493 1
        DCB     "M15", 0
d2519 1
a2519 1
        DCB     "M16", 0
d2540 1
a2540 1
        DCB     "M17", 0
d2548 1
a2548 1
        DCB     "M18", 0
d2569 2
a2570 2
        CMP     r4, #10
        SWICC   XOS_WriteI+space
d2582 1
a2582 1
        CMP     r4, #16
d2591 1
a2591 1
        DCB     "M19", 0
d2601 1
a2601 1
        DCB     "M20", 0
d2658 1
a2658 1
        DCB     "M21", 0
d2664 3
d2682 1
a2682 1
        CMP     r6, #4                  ; Round down if words
d2686 1
a2686 1
        CMP     r7, r9                  ; If same, ensure we do one byte/word
d2707 1
a2707 1
        CMP     r0, #8+2+3*32+3+1*32
d2729 1
a2729 1
        CMP     r6, #4
d2738 1
a2738 1
        CMP     r6, #4                  ; Need to size reset each loop
d2783 1
a2783 1
        CMP     r2, #0                  ; VClear
d2793 1
a2793 1
        CMP     r9, r7
d2819 1
a2819 1
        DCB     "M22", 0
d2833 1
a2833 1
        CMP     r14, #32
d2844 1
a2844 1
        DCB     "M23"
d2918 1
d2921 3
d2925 1
d2932 1
a2932 1
        MOV     r1, r0                  ; Check for 'B',space
d2934 5
d2941 1
d2944 3
a2946 3
        ADDEQ   r1, r1, #2              ; skip 'B',space
        MOVEQ   r6, #1                  ; bytes
        MOVNE   r6, #4                  ; words
d2953 3
d2968 1
a2968 1
        CMP     r6, #4                  ; round down if words
d3022 1
a3022 1
        DCB     "M24", 0
d3024 1
a3024 1
        DCB     "M25", 0
d3026 1
a3026 1
        DCB     "M26", 0
d3028 1
a3028 1
        DCB     "M27", 0
d3038 1
a3038 1
        DCB     "M28", 0
d3052 1
a3052 1
        CMP     r8, #0
d3159 1
a3159 1
        DCB     "M29", 0
d3250 1
a3250 1
        DCB     "M30", 0
d3271 1
a3271 1
        DCB     "M31", 0
d3280 1
a3280 1
        DCB     "M32", 0
d3305 1
a3305 1
        CMP     r14, r2
d3312 1
a3312 1
        DCB     "M33", 0 ; No newline
d3328 1
a3328 1
        DCB     "M34", 0
d3353 1
a3353 1
        CMP     r1, r7
d3370 1
a3370 1
        DCB     "M35", 0
d3391 1
a3391 1
        DCB     "M36", 0
d3413 1
a3413 1
        CMP     r14, r2
d3426 1
a3426 1
        DCB     "M37", 0
d3433 1
a3433 1
        DCB     "M38", 0
d3450 1
a3450 1
        CMP     r1, r14
d3474 1
a3474 1
        DCB     "M39", 0
d3485 1
a3485 1
        DCB     "M40", 0
d3579 1
a3579 1
        DCB     "M41", 0
d3586 1
a3586 1
        DCB     "M42", 0
d3603 1
a3603 1
        DCB     "M43", 0
d3660 1
a3660 1
        CMP     r0, #9
d3686 10
d3710 2
a3711 2
        CMP     r0, #delete
        CMPNE   r0, #space-1
d3736 1
a3736 1
        CMP     r1, r2
d3750 1
a3750 1
        CMP     r14, r9
d3768 1
a3768 1
        CMP     r14, r9
d3986 1
a3986 1
        EXIT    CC
d4071 1
a4071 1
;       flags from CMP r0, #space for eol detection. (CC -> r0 = CtrlChar)
d4076 1
a4076 1
        CMP     r0, #space
d4123 1
a4123 1
        CMP     r1, #0
d4148 2
a4149 2
        CMP     r0, #32
        SWICS   XOS_WriteC
d4170 2
a4171 1
        MOV     R2, #0
d4185 1
a4185 1
        CMP     r0, #0
d4204 2
a4205 2
  CMP R7,#&3000000
  CMPLT R9,#&3000000
d4219 1
a4219 1
  CMP r7,#&2000000
d4233 1
a4233 1
  CMP r9,#&2000000
d4251 1
a4251 1
  CMP r9,r8
d4254 1
a4254 1
  CMP r7,#&3000000
d4289 1
a4289 1
        END
@


4.1
log
@Initial revision
@
text
@d22 2
d133 6
a138 1

d174 3
d222 4
d231 3
d235 1
d310 7
a746 6
Ldr     DCB     "LDR", 0
Str     DCB     "STR", 0
Open_B  DCB     ",[", 0
Close_B DCB     "],", 0
        ALIGN

d880 6
d895 4
d901 2
a902 2
                                        ; vvvv - tested
        TST     r4, #&3C :SHL: 22       ; 000000ASddddnnnnssss1001mmmm ?
a904 4
        AND     R10,R4,#&F0             ; forcible check for &xxxxxx9x
        CMP     R10,#&90
        BNE     Undefined

d1005 1
d1010 1
d1013 114
d1129 1
d1135 1
a1135 1
DataProcessing
d1184 5
d1382 14
d1399 1
d1532 1
a1532 1
        ;if MRC/MCR check for ARM3 and comment accordingly
d1539 8
a1546 1
        BNE     InstructionEnd          ; Not ARM3
a1549 2
        MOV     R5,R4,LSR #16
        AND     R5,R5,#&0F
a1550 2
        CMP     R5,#6
        MOVHI   R5,#6
a1551 2
;        LDR     R5,[R5]
;        ADD     R10,R10,R5
d1561 6
a1566 3
msg4    = "M06",0
msg5    = "M07",0
msg6    = "M08",0
d3036 6
d3227 6
d3356 7
a3362 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a21 2
;		William Turner (StrongARM compatibility)
;		Kevin Bracey (Architecture 4 instructions)
d131 1
a131 6
; 1.46  WT  07-Feb-96    Made StrongARM compatible (breakpoint code breaks IDcache)
; 1.48  KJB 04-Jun-96    Added ARMv4 instructions (BX, LDR[H|SH|SB], STRH)
;                        SWP wasn't being disassembled
;			 CP15 comments amended to ARMv4
;			 ARM3 warning removed from SWP (after all, MRS,
;			 MULL etc don't have warnings!)
a166 3
	GBLL	StrongARM
StrongARM SETL  True

a211 4
 [ StrongARM
ExeBufLen	*	4+4+4*16
 ]

a216 3
 [ StrongARM
ExecuteBuffer   #       ExeBufLen
 |
a217 1
 ]
a291 7
 [ StrongARM
	MOV	r0, #1
	MOV	r1, r2
	ADD	r2, r1, #(nbreakpoints*8)
	SWI	XOS_SynchroniseCodeAreas
 ]

d722 6
a860 6
Ldr     DCB     "LDR", 0
Str     DCB     "STR", 0
Open_B  DCB     ",[", 0
Close_B DCB     "],", 0
        ALIGN

a869 4
        AND     R10,R4,#&F0             ; forcible check for &xxxxxx9x
        CMP     R10,#&90
        BNE	LdrStrH

d872 2
a873 2
                                        ; vvv - tested
        TST     r4, #&38 :SHL: 22       ; 0000 00AS dddd nnnn ssss 1001 mmmm ?
d876 4
a979 1
	[ {FALSE}
a983 1
	]
a985 114
LdrStrH	; Load and Store Halfword or Load Signed Byte
	; arrive here with cccc 000x xxxx xxxx xxxx xxxx 1nn1 xxxx
	; (nn != 00)
	; format is        cccc 000p uiwl nnnn dddd aaaa 1sh1 bbbb
	;
	; {LDRH|LDRSH|LDRSB|STRH} Rd,[Rn,{#offset|Rm}]
	;                         Rd,[Rn,{#offset|Rm}]!
	;                         Rd,[Rn],{#offset|Rm}
	; where cccc = condition
	;	   p = Pre-indexed/~Post-indexed
	;	   u = Up/~Down
	;	   i = Immediate/~Register offset
	;	   w = Writeback
	;          l = Load/~Store
	;       nnnn = Rn
	;       dddd = Rd
	;       aaaa = immediate offset high nibble (if i==1), else 0
	;          s = Signed/~Unsigned halfword
	;	   h = Halfword/~Signed byte
	;	bbbb = immediate offset low nibble (if i==1), else Rm

	; cccc 000x x0xx xxxx xxxx nnnn 1xx1 xxx is undefined if any of
	; nnnn are 1.
	TSTS	r4, #1:SHL:22		; Immediate/~Register offset
	BNE	%F5
	TSTS	r4, #&00000F00
	BNE	Undefined
	; Can only have STRH, not STRSH or STRSB
5	TSTS	r4, #1:SHL:20		; Load/~Store
	BNE	%F20
	AND	r5, r4, #&000000F0
	TEQS	r5, #&000000B0
	BNE	Undefined

20	TSTS	r4, #1:SHL:20
	ADRNE	r10, Ldr
	ADREQ	r10, Str
	BL	SaveStringConditions
	TSTS	r4, #1:SHL:6
	MOVNE	r10, #"S"
	STRNEB	r10, [r0], #1
	TSTS	r4, #1:SHL:5
	MOVNE	r10, #"H"
	MOVEQ	r10, #"B"
	STRB	r10, [r0], #1

	MOV	r5, r4, LSR #12
	BL	Tab_Dis_Register

	MOV	r5, r4, LSR #16
	AND	r5, r5, #&F
	TEQS	r5, #15
	ANDEQ	r10, r4, #1:SHL:22      ; Immediate/~Register offset
	TEQEQS	r10, #1:SHL:22
	BNE	not_ldrh_rel

	; show resultant [LD|ST]R[H|SH|SB] Rd,[PC,#nn] address directly

	MOV	r5, #","
	STRB	r5, [r0], #1
	AND	r8,  r4, #&0000000F
	AND	r10, r4, #&00000F00
	ORR	r8, r8, r10, LSR #4
	TSTS	r4, #1:SHL:23		; Up/~Down bit
	SUBEQ	r8, r9, r8
	ADDNE	r8, r9, r8
	B	BranchLdrStrCommon


not_ldrh_rel
	ADR	r10, Open_B		; ",["
	BL	SaveString

	BL	Dis_Register

	TSTS	r4, #1:SHL:24           ; Pre/~Post bit
	ADRL	r10, Close_B
	ADDNE	r10, r10, #1            ; just ',' else '],'
	BL	SaveString
	TSTS	r4, #1:SHL:22		; Immediate/~Register bit
	BEQ	ldrstrh_reg

	MOV	r6, #"#"
	STRB	r6, [r0], #1
	TSTS	r4, #1 :SHL: 23		; Up/~Down bit
	MOVEQ	r6, #"-"
	STREQB	r6, [r0], #1

	AND	r8,  r4, #&0000000F
	AND	r10, r4, #&00000F00
	ORR	r8, r8, r10, LSR #4
	BL	StoreDecimal
	B	%F50

ldrstrh_reg
	TSTS	r4, #1:SHL:23		; Up/~Down bit
	MOVEQ	r6, #"-"
	STREQB	r6, [r0], #1
	AND	r5, r4, #&F
	BL	Dis_Register


50	TSTS	r4, #1:SHL:24           ; Pre/~Post bit
	BEQ	InstructionEnd

	MOV	r6, #"]"
	STRB	r6, [r0], #1

	TSTS	r4, #1:SHL:21           ; Writeback bit
	MOVNE	r6, #"!"
	STRNEB	r6, [r0], #1
	B	InstructionEnd

	[ {FALSE}
a987 1
	]
d993 1
a993 1
DataProcessing ROUT
a1041 5
	BIC	r5, r4, #&F000000F
	LDR	r10, =&012FFF10
	TEQS	r5, r10
	BEQ	is_BX

a1234 14
is_BX	; one legal case
	; cccc 0001 0010 1111 1111 1111 0001 mmmm
	;
	; BX Rm
	;
	; where mmmm = Rm
	;
	ADR	R10,BxTAB
	BL	SaveStringConditions
	AND	R5,R4,#&FF
	BL	Tab_Dis_Register

	B	InstructionEnd

a1237 1
BxTAB   DCB     "BX", 0, 0
d1370 1
a1370 1
        ;if MRC/MCR check for system control coprocessor and comment accordingly
d1377 3
a1379 1
        BNE     InstructionEnd          ; Not CP15
a1382 7
	TEQS	R5,#4
	BEQ	InstructionEnd
	CMPS	R5,#8
	BHI	InstructionEnd

        BL      Tab

d1384 2
d1387 2
d1398 3
a1400 6
msg4    = "M08",0
msg5    = "M06",0
msg6    = "M07",0
msg7    = "M51",0
msg8	= "M52",0

a2869 6
 [ StrongARM
	;Do the IMB thingy here, for the replaced instruction
	MOV	r0, #1		;Ranged IMB
	MOV	r2, r1
	SWI	XOS_SynchroniseCodeAreas
 ]
a3054 6
 [ StrongARM
	;Do the IMB thingy here
	MOV	r0, #1			;Ranged IMB
	MOV	r2, r1
	SWI	XOS_SynchroniseCodeAreas
 ]
d3178 1
a3178 7
 [ StrongARM
	;Best IMB the ExecuteBuffer here
	MOV	r0, #1			; Guess what? It's a ranged sync
	ADR	r1, ExecuteBuffer
	ADD	r2, r1, #ExeBufLen
	SWI	XOS_SynchroniseCodeAreas
 ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	1.13;
access;
symbols
	DDEUtils-1_75:1.13
	DDEUtils-1_74:1.12
	DDEUtils-1_73:1.10
	DDEUtils-1_72:1.10
	DDEUtils-1_71:1.9
	DDEUtils-1_70:1.8
	DDEUtils-1_69:1.7
	DDEUtils-1_68:1.5
	DDEUtils-1_67:1.4
	RO_5_07:1.3
	DDEUtils-1_66:1.3
	DDEUtils-1_65:1.2
	DDEUtils-1_64:1.2
	dellis_autobuild_BaseSW:1.1.1.1
	dcotton_autobuild_BaseSW:1.1.1.1
	DDEUtils-1_63:1.1.1.1
	DDEUtils-1_62:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.13
date	2015.07.12.16.42.04;	author jballance;	state Exp;
branches;
next	1.12;
commitid	EQ0xxJmTDJNL31ty;

1.12
date	2015.03.29.17.24.02;	author rsprowson;	state Exp;
branches;
next	1.11;
commitid	ezI37RNr898sFwfy;

1.11
date	2015.03.29.17.05.07;	author rsprowson;	state Exp;
branches;
next	1.10;
commitid	IGEJz6nrdC0Dywfy;

1.10
date	2012.01.07.10.54.42;	author rsprowson;	state Exp;
branches;
next	1.9;
commitid	7pErncE4rjyxleOv;

1.9
date	2012.01.02.14.24.22;	author bavison;	state Exp;
branches;
next	1.8;
commitid	dPMJD5dLWXSoFBNv;

1.8
date	2011.11.05.17.03.01;	author rsprowson;	state Exp;
branches;
next	1.7;
commitid	Xr4jFNUQHgLqpaGv;

1.7
date	2011.09.17.21.26.53;	author rsprowson;	state Exp;
branches;
next	1.6;
commitid	ckFvcjQ3ZVpDrTzv;

1.6
date	2011.09.17.21.18.46;	author rsprowson;	state Exp;
branches;
next	1.5;
commitid	Q6R9vcKjFhgCoTzv;

1.5
date	2011.09.17.21.07.41;	author rsprowson;	state Exp;
branches;
next	1.4;
commitid	zcQDXufUwpQ1lTzv;

1.4
date	2011.09.17.08.50.07;	author rsprowson;	state Exp;
branches;
next	1.3;
commitid	8nsnP9TGNzk0gPzv;

1.3
date	2003.11.03.18.16.19;	author bavison;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.05.18.13.44;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	99.11.22.12.03.21;	author sbrodie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.22.12.03.21;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


1.13
log
@  Added additional debugging via HAL_DebugTX with enabling switch
Detail:
  Added some debugging code to reroute, (assmebly time option) debug
  output through the HAL debug route. Has proved useful locating null
  pointer errors with vectors assembled high.
Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 1.75. Tagged as 'DDEUtils-1_75'
@
text
@; Copyright 1999 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Title:   s.ddeutils
; Purpose: Assembler source for DDEUtils module
;

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Services
        GET     Hdr:OSRSI6
        GET     Hdr:PublicWS
        GET     Hdr:HighFSI
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:Variables
        GET     Hdr:Wimp
        GET     Hdr:MsgTrans
        GET     Hdr:ModHand
        GET     hdr.DDEUtils
        GET     VersionASM

; JRF: Debugging. Turn this off for ROMing
                  GBLL  Debug
Debug             SETL  {FALSE};{TRUE};
; use hal_debugtx for debug output
                  GBLL  HALDebug
HALDebug          SETL  {TRUE};{FALSE}

; JRF: Switch added to allow longer filenames to be 'handled'. This may
;      not necessarily fix all the problems that DDEUtils has with them,
;      but will alleviate the majority. Problems may still lie in the
;      throwback handler.
                  GBLL  LongFilenames
LongFilenames     SETL  {TRUE}

; JRF: Set this to the length of filenames that is the maximum you wish
;      to handle
 [ LongFilenames
FilenameLength        * 1024
 |
FilenameLength        * 256
 ]

; JRF: Turn this on and all prefixes passed will be canonicalised for you
                  GBLL  CanonicalisePath
CanonicalisePath  SETL  {TRUE}

; JRF: We should /really/ be checking the strings fit our CL buffer!
                  GBLL  CheckBufferSize
CheckBufferSize   SETL  {TRUE}

                  GBLL  AllowDirChanging
AllowDirChanging  SETL  {TRUE}

; JRF: Allow a lot of the later image file extensions
;      This has NOT been tested and it's a little too late to add them
                  GBLL  HandleImages
HandleImages      SETL  {FALSE}

; DDEUtils error codes
ddeutils_errbase      * ErrorBase_AcornDDE
                      ^ ddeutils_errbase
unk_swi_error         # 1
no_cli_buffer_error   # 1
not_desktop_error     # 1
no_task_error         # 1
already_reg_error     # 1
not_reg_error         # 1
buffer_too_short      # 1

; DDEUtils messages
ddeutils_msgbase             * DDEUtilsSWI_Base
                             ^ 0
msg_throwback_start          # 1
msg_throwback_processingfile # 1
msg_throwback_errorsin       # 1
msg_throwback_errordetails   # 1
msg_throwback_end            # 1
msg_throwback_infoforfile    # 1
msg_throwback_infodetails    # 1

; DDEUtils workspace
                  ^     0, r12
chain             #     4
fname_buffer      #     4
cli_buffer        #     4
cli_size          #     4
receiver_id       #     4
wimp_domain       #     4
workspace_end     #     0

; DDEUtils linked list member
                  ^     0
o_next            #     4
o_wimpdomain      #     4
o_prefix          #     4

        AREA    |ddeutils$$module|, CODE, READONLY

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Header
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
module_start
        DCD     0                          ; Run
        DCD     init - module_start        ; Init
        DCD     finish - module_start      ; Finish
        DCD     service - module_start     ; Service call
        DCD     title - module_start       ; Title
        DCD     help - module_start        ; Help
        DCD     cmd_table - module_start   ; *commands
        DCD     DDEUtilsSWI_Base           ; SWI Base
        DCD     do_swi - module_start      ; SWI Handler
        DCD     swi_table - module_start   ; SWI Table
        DCD     0                          ; SWI Decoder
        DCD     0                          ; Messages filename
        DCD     flags - module_start       ; Module flags

help
        DCB     "DDEUtils", 9
        DCB     Module_MajorVersion, " (", Module_Date, ")", 0
      [ Module_MinorVersion <> ""
        DCB     " ", Module_MinorVersion
      ]
        DCB     0

title
        ; Share title with SWI table
swi_table
        DCB     "DDEUtils", 0
        DCB     "Prefix", 0
        DCB     "SetCLSize", 0
        DCB     "SetCL", 0
        DCB     "GetCLSize", 0
        DCB     "GetCl", 0                 ; Lowercase 'L'? Go figure.
        DCB     "ThrowbackRegister", 0
        DCB     "ThrowbackUnRegister", 0
        DCB     "ThrowbackStart", 0
        DCB     "ThrowbackSend", 0
        DCB     "ThrowbackEnd", 0
        DCB     "ReadPrefix", 0
        DCB     "FlushCL", 0
        DCB     0

cmd_table
        DCB     "Prefix", 0
        ALIGN
        DCD     prefix_cmd - module_start
        DCB     0                          ; Min. parameters
        DCB     1                          ; GSTrans map
        DCB     1                          ; Max. parameters
        DCB     0                          ; Flags
        DCD     prefix_syn - module_start  ; Syntax message
        DCD     prefix_help - module_start ; Help message
        DCD     0                          ; End of command table

prefix_help
        DCB     "*Prefix selects a directory as the current directory unique to the currently executing "
        DCB     "task. *Prefix with no arguments sets the current directory back to the systemwide "
        DCB     "default (as set with *Dir).", 13

prefix_syn
        DCB     "Syntax: *Prefix [<directory>]", 0
        ALIGN

flags
        DCD     ModuleFlag_32bit

ursservtab
        ASSERT  Service_Reset < Service_WimpCloseDown
        DCD     0                          ; Flags
        DCD     ursservice - module_start
        DCD     Service_Reset
        DCD     Service_WimpCloseDown
        DCD     0                          ; Terminator
        DCD     ursservtab - module_start  ; Anchor
service
        MOV     r0,r0                      ; Magic instruction for Ursula despatcher
        TEQ     r1, #Service_Reset
        TEQNE   r1, #Service_WimpCloseDown
        MOVNE   pc,lr
ursservice
        ; Service_Reset
        TEQ     r1, #Service_Reset
        LDREQ   r12,[r12]
        BEQ     reset
        ; else Service_WimpCloseDown
        CMP     r0, #0
        MOVNE   pc, lr
        STMFD   sp!, {r0, lr}
        MOV     r0, #0
        SWI     XDDEUtils_Prefix
        LDMFD   sp!, {r0, pc}

reset
        ; Really should clear the chain here...
        STMFD   sp!, {r0, lr}
        BL      claimvectors
        LDMFD   sp!, {r0, pc}

filetype_fd3
        DCB     "File$$Type_FD3", 0
debimage
        DCB     "DebImage", 0
runtype_fd3
        DCB     "Alias$@@RunType_FD3", 0
debugaif
        DCB     "DebugAIF %*0", 0
loadtype_fd3
        DCB     "Alias$@@LoadType_FD3", 0
loadaif
        DCB     "Load %0 8000", 0
filetype_fe1
        DCB     "File$$Type_FE1", 0
makefile
        DCB     "Makefile", 0
runtype_fe1
        DCB     "Alias$@@RunType_FE1", 0
make
        DCB     "DDE:!Make %*0", 0
prefix_dir
        DCB     "Prefix$$Dir", 0
        ALIGN

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Initialisation and finalisation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
init
        STMFD   sp!, {r7, r8, r9, r10, r11, lr}
        ADR     r0, filetype_fd3
        ADR     r1, debimage
        BL      initvar
        ADR     r0, runtype_fd3
        ADR     r1, debugaif
        BL      initvar
        ADR     r0, loadtype_fd3
        ADR     r1, loadaif
        BL      initvar
        ADR     r0, filetype_fe1
        ADR     r1, makefile
        BL      initvar
        ADR     r0, runtype_fe1
        ADR     r1, make
        BL      initvar

        MOV     r0, #ModHandReason_Claim
        MOV     r3, #:INDEX: workspace_end
        SWI     XOS_Module                 ; claim our module workspace
        STRVC   r2,[r12]
        MOVVC   r12,r2

        MOVVC   r0, #0
        STRVC   r0, chain
        STRVC   r0, cli_buffer
        STRVC   r0, cli_size
        STRVC   r0, receiver_id

        BVS     %FT10
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_DomainId
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        TEQ     r2, #0
        LDREQ   r2, =Legacy_DomainId
        STR     r2, wimp_domain

        BL      claimvectors
        MOVVC   r0, #ModHandReason_Claim
        MOVVC   r3, #FilenameLength * 2
        SWIVC   XOS_Module
        STRVC   r2, fname_buffer
        ADRVC   r0, prefix_dir
        ADRVC   r1, prefix_dir_code
        MOVVC   r2, #prefix_dir_code_end - prefix_dir_code
        MOVVC   r3, #0
        MOVVC   r4, #VarType_Code
        SWIVC   XOS_SetVarVal
10
        LDMFD   sp!, {r7, r8, r9, r10, r11, lr}
xferv
        TEQ     pc, pc
        MOVEQ   pc, lr
        ORRVS   lr, lr, #V_bit
        MOVS    pc, lr

xfervc
        TEQ     pc, pc
        MOVEQ   pc, lr
        BIC     lr, lr, #C_bit
        ORRCS   lr, lr, #C_bit
        ORRVS   lr, lr, #V_bit
        MOVS    pc, lr

claimvectors
        STMFD   sp!, {r2, r3, lr}
        MOV     r2,r12
        MOV     r0, #FileV
        TEQ     pc, pc
        ADREQL  r1, file_handler_32
        ADRNEL  r1, file_handler_26
        SWI     XOS_Claim
        MOVVS   r3, r0
        BVS     %FT01
        MOV     r0, #GBPBV
        TEQ     pc, pc
        ADREQL  r1, gbpb_handler_32
        ADRNEL  r1, gbpb_handler_26
        SWI     XOS_Claim
        MOVVS   r3, r0
        BVS     %FT02
        MOV     r0, #FindV
        TEQ     pc, pc
        ADREQL  r1, find_handler_32
        ADRNEL  r1, find_handler_26
        SWI     XOS_Claim
        MOVVS   r3, r0
        BVS     %FT03
        MOV     r0, #FSCV
        TEQ     pc, pc
        ADREQL  r1, fscontrol_handler_32
        ADRNEL  r1, fscontrol_handler_26
        SWI     XOS_Claim
        MOVVS   r3, r0
        BVS     %FT04
        LDMFD   sp!, {r2,r3,pc}

        ; these are the failure cases
04
        MOV     r0, #FindV
        TEQ     pc, pc
        ADREQL  r1, find_handler_32
        ADRNEL  r1, find_handler_26
        SWI     XOS_Release
03
        MOV     r0, #GBPBV
        TEQ     pc, pc
        ADREQL  r1, gbpb_handler_32
        ADRNEL  r1, gbpb_handler_26
        SWI     XOS_Release
02
        MOV     r0, #FileV
        TEQ     pc, pc
        ADREQL  r1, file_handler_32
        ADRNEL  r1, file_handler_26
        SWI     XOS_Release
01
        MOV     r0,r3
        LDMFD   sp!, {r2,r3,lr}
        B       return_setv

prefix_dir_code
        B       dir_code_write
        ; prefix_dir read code
        ; <= r0-> value
        STR     lr, [sp, #-4]!
        MOV     r0,#0
        SWI     XDDEUtils_ReadPrefix
        MOVVS   r0,#0
        CMP     r0,#0                      ; was it invalid ?
        MOVEQ   r0,#0
        MOVEQ   r2,#0
        LDREQ   pc, [sp], #4               ; yes
        ; now we need to find the length of the directory
        MOV     r1,r0
01
        LDRB    r2,[r1],#1
        CMP     r2,#' '
        BCS     %BT01
        SUB     r2,r1,r0
        SUB     r2,r2,#1                   ; and we increased over the terminator
        LDR     pc, [sp], #4

dir_code_write
        STMFD   sp!, {r0, lr}
        MOV     r0, r1
        SWI     XDDEUtils_Prefix
        ADDS    r0, r0, #0                 ; clear V
        LDMFD   sp!, {r0, pc}
prefix_dir_code_end

finish
        MOV     r6, lr
        LDR     r12, [r12]
        MOV     r0, #ModHandReason_Free
        LDR     r2, fname_buffer
        CMP     r2, #0
        SWINE   XOS_Module

        LDR     r2, cli_buffer
        CMP     r2, #0
        SWINE   XOS_Module

        LDR     r2, chain
        MOV     r1, #0
        STR     r1, chain
        STR     r1, fname_buffer
        STR     r1, cli_buffer
        STR     r1, cli_size
        STR     r1, receiver_id

finish1
        CMP     r2, #0
        BEQ     finish2
        LDR     r5, [r2,#o_next]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        MOV     r2, r5
        BVC     finish1

finish2
        MOV     r2, r12
        MOV     r0, #FileV
        TEQ     pc, pc
        ADREQL  r1, file_handler_32
        ADRNEL  r1, file_handler_26
        SWI     XOS_Release
        MOV     r0, #GBPBV
        TEQ     pc, pc
        ADREQ   r1, gbpb_handler_32
        ADRNE   r1, gbpb_handler_26
        SWI     XOS_Release
        MOV     r0, #FindV
        TEQ     pc, pc
        ADREQ   r1, find_handler_32
        ADRNE   r1, find_handler_26
        SWI     XOS_Release
        MOV     r0, #FSCV
        TEQ     pc, pc
        ADREQL  r1, fscontrol_handler_32
        ADRNEL  r1, fscontrol_handler_26
        SWI     XOS_Release
        MOV     r2, r12                    ; free our main workspace
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        CMP     r0, #0
        MOV     pc, r6

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI despatch
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
do_swi
        STR     lr,[sp,#-4]!
        LDR     r12,[r12]                  ; read workspace pointer
        BL      do_swi_orig
        TEQ     pc, pc
        LDREQ   pc,[sp],#4                 ; 32-bit return corrupting flags
        LDMVCFD sp!,{pc}^                  ; 26-bit return without error
        LDR     lr,[sp],#4                 ; 26-bit return with error
        ORRS    pc,lr,#V_bit

do_swi_orig
        CMP     r11,#first_unused_swi
        ADDLT   pc,pc,r11,LSL #2
        B       module_swierror
lowest_swi
        B       doswi_prefix
        B       doswi_setclsize
        B       doswi_setcl
        B       doswi_getclsize
        B       doswi_getcl
        B       doswi_throwbackregister
        B       doswi_throwbackunregister
        B       doswi_throwbackstart
        B       doswi_throwbacksend
        B       doswi_throwbackend
        B       doswi_readprefix
        B       doswi_flushcl
highest_swi
first_unused_swi *      (highest_swi - lowest_swi) / 4

module_swierror
        STMFD   sp!, {r1-r4, lr}
        ADR     r0,msg_swierror
        MOV     r1,#0
        MOV     r2,#0
        ADRL    r4,title
        SWI     XMessageTrans_ErrorLookup
        LDMFD   sp!,{r1-r4,pc}

msg_swierror
        DCD     ErrorNumber_ModuleBadSWI
        DCB     "BadSWI",0
        ALIGN

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Prefixer
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
add_prefix
        ; Entry: VC
        ;        R1  = Filename
        ;        R11 = Filename buffer
        ;        R8  = Task block
        ; Exit:  R11, LR = ???
        ;        R1  = Preserved
        ;        R11 = Preserved
        ;        R8  = New Filename (R1 or R11 on entry)
        ;        CS  => No prefix added (filename contained root char)
        SUBS    r0, r0, #0                 ; set C
add_prefix0
        STMFD   sp!, {r0-r4, r5, lr}       ; r5 is placeholder
        MRS     lr, CPSR                   ; NOP on old machine
        STR     lr, [sp, #20]
  [ Debug
    [ HALDebug
 DebugTX01 r1,"Before add_prefix: "
    |
        STMFD   sp!, {r0-r2}
        SWI     OS_WriteS
        DCB     "Before add_prefix: ", 0
        ALIGN
        MOV     r2, r1
write_name0
        LDRB    r0, [r2], #1
        CMP     r0, #' '+1
        SWICS   OS_WriteC
        CMP     r0, #' '+1
        BCS     write_name0
        SWI     OS_NewLine
        LDMFD   sp!,{r0-r2}
    ]
  ]
        MOV     r2, r1
add_prefix1
        LDRB    r0, [r2], #1
        CMP     r0, #':'
        CMPNE   r0, #'$'
        CMPNE   r0, #'&'
        CMPNE   r0, #'%'
        CMPNE   r0, #'<'
        MOVEQ   r8, r1
        BEQ     add_prefix5
        CMP     r0, #' ' + 1
        BCS     add_prefix1
        MOV     r2, r1
        LDRB    r0, [r2]
        CMP     r0, #'@@'
        BNE     add_prefix2
        LDRB    r0, [r2, #1]!
        CMP     r0, #'.'
        ADDEQ   r2, r2, #1
add_prefix2
        MOV     r3, r11
        ADD     r8, r8, #o_prefix
add_prefix3
        LDRB    r0, [r8], #1
        CMP     r0, #' ' + 1
        STRCSB  r0, [r3], #1
        BCS     add_prefix3
        LDRB    r0, [r2]
        CMP     r0, #' ' + 1
        MOVCS   r0, #'.'
        STRCSB  r0, [r3], #1
add_prefix4
        LDRB    r0, [r2], #1
        CMP     r0, #' ' + 1
        MOVCC   r0, #0
        STRB    r0, [r3], #1
        BCS     add_prefix4
        MOV     r8, r11

  [ Debug
    [ HALDebug
 DebugTX01 r8, "After add_prefix: "
    |
        SWI     OS_WriteS
        DCB     4, "After add_prefix: ", 0
        ALIGN
        MOV     r2, r8
01
        LDRB    r0, [r2], #1
        CMP     r0, #' '+1
        SWICS   OS_WriteC
        CMP     r0, #' '+1
        BCS     %BT01
        SWI     OS_NewLine
    ]
  ]
        LDMFD   sp, {r0, r1, r2, r3, r4, lr}
        BIC     lr, lr, #C_bit
        STR     lr, [sp, #20]
        B       add_prefix5

strip_hats
        SUBS    r0, r0, #0                 ; set carry
strip_hats0
        STMFD   sp!, {r0, r1, r2, r3, r4, r5, lr}
        MRS     lr, CPSR                   ; NOP on old machine
        STR     lr, [sp, #20]
add_prefix5
        MOV     r2, r8
        MOV     r1, r11
        MOV     r3, r1
        MOV     r4, r3
add_prefix6
        LDRB    r0, [r2], #1
        STRB    r0, [r1], #1
        CMP     r0, #'.'
        LDREQB  lr, [r2]
        CMPEQ   lr, #'^'
        BNE     add_prefix9
        LDRB    lr, [r3]
        CMP     lr, #'$'
        CMPNE   lr, #'@@'
        CMPNE   lr, #'%'
        CMPNE   lr, #'&'
        CMPNE   lr, #'<'
        CMPNE   lr, #'^'
        MOVEQ   r0, #'!'                   ; R0 > ' ' and != '.'
        BEQ     add_prefix9
add_prefix7
        LDRB    lr, [r2], #1
        CMP     lr, #'.'
        CMPNE   lr, #' '
        BHI     add_prefix7
        SUB     r2, r2, #1
        CMP     r3, r4
        STREQB  lr, [r3]
add_prefix8
        LDRB    lr, [r2], #1
        STRNEB  lr, [r3], #1
        CMP     lr, #' '
        BHI     add_prefix8
        MOV     r8, r11
        LDR     r2, [sp, #20]
        BIC     r2, r2, #C_bit
        STR     r2, [sp, #20]
        B       add_prefix5
add_prefix9
        CMP     r0, #':'
        MOVEQ   r4, r1
        MOVEQ   r3, r1
        CMP     r0, #'.'
        SUBEQ   r3, r1, #1
        CMP     r0, #' '
        BHI     add_prefix6
  [ Debug
    [ HALDebug
 DebugTX01 r8, "After stripping ^s "
    |
        SWI     OS_WriteS
        DCB     4, "After stripping ^s ", 0
        ALIGN
        SWI     OS_NewLine
        MOV     r2, r8
write_name1
        LDRB    r0, [r2], #1
        CMP     r0, #' '+1
        SWICS   OS_WriteC
        CMP     r0, #' '+1
        BCS     write_name1
        SWI     OS_NewLine
    ]
  ]
        LDMFD   sp!, {r0, r1, r2, r3, r4, lr}
        TEQ     pc, pc
        BNE     add_prefix_ret_26
        MSR     CPSR_f, lr
        LDR     pc, [sp], #4

add_prefix_ret_26
        TEQP    pc, lr
        NOP                                ; banked register follows
        LDR     pc, [sp], #4

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Vector claimaints
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
find_handler_26
        STR     lr, [sp, #-4]!
        STR     pc, [sp, #-4]!
        BL      find_handler_32
        NOP
        ADD     sp, sp, #4
        LDMVCFD sp!, {pc}^
        LDR     lr, [sp], #4
        ORRS    pc, lr, #V_bit

find_handler_32
        TST     r0, #open_write :OR: open_read
        MOVEQ   pc, lr                     ; must be a close operation
        STR     r0, [sp, #-4]!
        AND     r0, r0, #open_pathbits
        TEQ     r0, #open_pathvar          ; explicit path variable supplied
        TEQNE   r0, #open_pathstring       ; explicit path string supplied
        LDR     r0, [sp], #4
        BNE     common_handler_external_entry
        CMP     r0, #0                     ; clear V
        MOV     pc, lr

gbpb_handler_26
        STR     lr, [sp, #-4]!
        STR     pc, [sp, #-4]!
        BL      gbpb_handler_32
        NOP
        ADD     sp, sp, #4
        LDMVCFD sp!, {pc}^
        LDR     lr, [sp], #4
        ORRS    pc, lr, #V_bit

gbpb_handler_32
        CMP     r0, #OSGBPB_ReadDirEntries
        MOVLO   pc, lr                     ; V clear
        ASSERT  OSGBPB_ReadDirEntriesFileType > OSGBPB_ReadDirEntries
        CMP     r0, #OSGBPB_ReadDirEntriesFileType
        BLS     common_handler_external_entry
        CMP     r0, #0                     ; V clear
        MOV     pc, lr

file_handler_26
        STR     lr, [sp, #-4]!
        STR     pc, [sp, #-4]!
        BL      file_handler_32
        NOP
        ADD     sp, sp, #4
        LDMVCFD sp!, {pc}^
        LDR     lr, [sp], #4
        ORRS    pc, lr, #V_bit

file_handler_32
        CMP     r0, #OSFile_LoadPath       ; Respect path string and path variables
        CMPNE   r0, #OSFile_LoadPathVar
        CMPNE   r0, #OSFile_ReadPath
        CMPNE   r0, #OSFile_ReadPathVar
        CMPNE   r0, #OSFile_ReadWithTypePath
        CMPNE   r0, #OSFile_ReadWithTypePathVar
        BNE     common_handler_external_entry
        CMP     r0, #0                     ; V clear
        MOV     pc, lr

common_handler_external_entry
        ; R1 = pointer to name to use
        STMFD   sp!, {r8, r11, lr}
  [ Debug
    [ HALDebug
 DebugRegNCR r0,""
 DebugRegNCR r1,""
 DebugTX01 r1, "common file handler: "
    |
        STMFD   sp!, {r0, r1}
        SWI     OS_WriteS
        DCB     4, "common file handler: ", 0
        ALIGN
01
        LDRB    r0, [r1], #1
        CMP     r0, #' '+1
        SWICS   OS_WriteC
        CMP     r0, #' '+1
        BHS     %BT01
        SWI     OS_NewLine
        LDMFD   sp!, {r0, r1}
    ]
  ]
        LDR     r8, chain
        LDR     lr, wimp_domain
        LDR     lr, [lr]                   ; lr = domainid
common_handler1
        CMP     r8, #0
        BEQ     common_handler2
        LDR     r11, [r8, #o_wimpdomain]
        CMP     r11, lr                    ; hunt for domainid in linked list of tasks
        LDRNE   r8, [r8, #o_next]
        BNE     common_handler1
        LDR     r11, fname_buffer
        BL      add_prefix
common_handler3
        MOV     r12,r8                     ; hold dir block otherwise this gets very icky
        LDMFD   sp!, {r8, r11, lr}
        MOVCS   pc, lr
        TEQ     pc, pc
        LDRNE   lr, [sp, #4]               ; get real pass-on address from 26-bit veneer
        TEQNEP  pc, lr                     ; restore vector's entry flags
        NOP                                ; banked register follows
        STR     r1, [sp, #-4]!
        MOV     r1, r12
        STR     pc, [sp, #-4]!             ; store PC+8 (Architecture 4) or PC+12
        MOV     pc, lr
        NOP                                ; so that PC+8 is ok

common_upcall
        LDMFD   sp!, {r1, lr}              ; target of stored PC
        B       xfervc

common_handler2
        LDR     r11, fname_buffer
        MOV     r8, r1
        BL      strip_hats
        B       common_handler3

fscontrol_handler_26
        STR     lr, [sp, #-4]!
        STR     pc, [sp, #-4]!
        BL      fscontrol_handler_32
        NOP
        ADD     sp, sp, #4
        LDMVCFD sp!, {pc}^
        LDR     lr, [sp], #4
        ORRS    pc, lr, #V_bit

fscontrol_handler_32
        CMP     r0, #FSControl_Access
        BLS     fscontrol_lownumbered
        ASSERT  (FSControl_Rename > FSControl_Access) :LAND: (FSControl_Rename < FSControl_Copy)
        CMP     r0, #FSControl_Copy
        BLS     copy_or_rename
        CMP     r0, #FSControl_CanonicalisePath
        BEQ     fscontrol_canon
        CMPNE   r0, #FSControl_Count
        CMPNE   r0, #FSControl_FileInfo
        CMPNE   r0, #FSControl_InfoToFileType
  [ HandleImages
        CMPNE   r0, #41                    ; return defects for image
        CMPNE   r0, #42                    ; map out defects for image
        CMPNE   r0, #46                    ; return used space map for image
        CMPNE   r0, #47                    ; read boot for disc/image
        CMPNE   r0, #48                    ; write boot for disc/image
        CMPNE   r0, #49                    ; read free space for disc/image
        CMPNE   r0, #50                    ; rename disc/image
        ; CMPNE   r0, #51                  ; update stamp (should already be canonical, I think - JRF)
        CMPNE   r0, #52                    ; find object at offset
        CMPNE   r0, #55                    ; read freespace (large)
        CMPNE   r0, #56                    ; read defects (large)
        CMPNE   r0, #57                    ; map out defect (large)
  ]
        BEQ     common_handler_external_entry
  [ AllowDirChanging
        CMP     r0, #FSControl_SetDir
        BEQ     fscontrol_set_dir
        CMP     r0, #FSControl_NoDir
        BEQ     fscontrol_unset_dir
  ]
        CMP     r0, r0
        MOV     pc, lr

fscontrol_canon
        ORRS    r0, r3, r4                 ; only process if the path variable & path string are absent
        MOV     r0, #FSControl_CanonicalisePath
        MOVNE   pc, lr
        B       common_handler_external_entry

fscontrol_lownumbered
        CMP     r0, #FSControl_Cat
        CMPNE   r0, #FSControl_Ex
        CMPNE   r0, #FSControl_Info
        CMPNE   r0, #FSControl_Access
        BEQ     common_handler_external_entry
  [ AllowDirChanging
        CMP     r0, #FSControl_Dir
        BEQ     fscontrol_change_dir
  ]
        CMP     r0, r0
        MOV     pc, lr

  [ AllowDirChanging
fscontrol_unset_dir
        STMFD   sp!, {r0, lr}
        MOV     r0, #0
        SWI     XDDEUtils_ReadPrefix       ; read context
        BVS     %FT01
        TEQ     r0, #0
        LDMEQFD sp!, {r0, pc}
        MOV     r0, #0
        SWI     XDDEUtils_Prefix
        BVS     %FT01

fscontrol_set_dir
        CMP     r2, #Dir_Current
        MOVNE   pc, lr                     ; only process if 'set CSD'

        STMFD   sp!, {r0, lr}
        MOV     r0, #0
        SWI     XDDEUtils_ReadPrefix       ; read context
        BVS     %FT01
        CMP     r0, #0
        LDMEQFD sp!, {r0, pc}
        MOV     r0, r1
        SWI     XDDEUtils_Prefix
01
        STRVS   r0, [sp, #0]
        LDMFD   sp!, {r0, lr}
        LDR     pc, [sp], #4

fscontrol_change_dir
        STMFD   sp!, {r0-r5, lr}
        MOV     r0, #0
        SWI     XDDEUtils_ReadPrefix       ; read context
        BVS     %FT01
        TEQ     r0, #0
        LDMEQFD sp!, {r0-r5,pc}
        MOV     r0, #OSFile_ReadInfo
        SWI     XOS_File
        TST     r0, #object_directory      ; also catches image files
        BEQ     %FT02
        MOV     r0, r1
        SWI     XDDEUtils_Prefix
01
        STRVS   r0, [sp, #0]
        LDMFD   sp!, {r0-r5, lr}
        LDR     pc, [sp], #4
02
        MOV     r0, #OSFile_MakeError
        MOV     r2, #&100                  ; Directory 'wibble' not found
        SWI     XOS_File
        ADD     sp, sp, #4                 ; skip r0
        LDMFD   sp!, {r1-r5, lr}
        LDR     pc, [sp], #4
  ]

copy_or_rename
        STMFD   sp!, {r1, r2}
        SUB     sp, sp, #4                 ; avoid storing LR + PC together
        STMFD   sp!, {r8-r11, lr}
        STR     pc, [sp, #5 * 4]           ; store PC+8 or PC+12
        B       copy_or_rename1
        NOP                                ; so that PC+8 is ok

copy_or_rename_upcall                      ; target of stored PC
        LDMFD   sp!, {r1, r2, lr}
        B       xfervc

copy_or_rename1
        ADR     r8, chain
copy_or_rename1b
        LDR     r8, [r8]
        CMP     r8, #0
        BEQ     copy_or_rename2
        LDR     lr, wimp_domain
        LDR     lr, [lr]
        LDR     r11, [r8, #o_wimpdomain]
        CMP     r11, lr
        BNE     copy_or_rename1b
        LDR     r11, fname_buffer
        MOV     r9, r8
        BL      add_prefix
        MOV     r10, r8
        MOV     r8, r9
        ADD     r11, r11, #FilenameLength
        MOV     r9, r1
        MOV     r1, r2
        BL      add_prefix0
copy_or_rename3
        MOV     r1, r9
        MOVCC   r2, r8
        MOVCC   r1, r10
        LDMFD   sp!, {r8-r11, lr}
        ADDCS   sp, sp, #12
        MOVCS   pc, lr
        TEQ     pc, pc
        LDRNE   lr, [sp, #16]              ; get real pass-on address from 26-bit veneer
        MOVNES  pc, lr
        MOV     pc, lr

copy_or_rename2
        LDR     r11, fname_buffer
        MOV     r8, r1
        BL      strip_hats
        MOV     r10, r8
        ADD     r11, r11, #FilenameLength
        MOV     r9, r1
        MOV     r8, r2
        BL      strip_hats0
        B       copy_or_rename3

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_Prefix
; ---------------
; Entry: R0  = pointer to null terminated directory name, or zero to clear
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_prefix
        STMFD   sp!, {r1, r2, r3, r8, lr}
        MOVS    r10, r0
        BEQ     %FT01                      ; they gave 0
        LDRB    r0,[r10]
        CMP     r0,#' '
        BLO     %FT01                      ; it was a null command

  [ CanonicalisePath
        STMFD   sp!, {r4, r5}
        MOV     r0,#FSControl_CanonicalisePath
        MOV     r1,r10
        LDR     r2,fname_buffer
        MOV     r3,#0                      ; no path var
        MOV     r4,#0                      ; 0
        MOV     r5,#FilenameLength
        SWI     XOS_FSControl              ; canonicalise it!
        LDRVC   r10,fname_buffer
        LDMFD   sp!, { r4, r5 }
01
  ]

  [ Debug
    [ HALDebug
 DebugTX01 r10, "attempting to set prefix: "
    |
        STMFD   sp!, {r0, r2}              ; Stack registers
        SWI     OS_WriteS
        DCB     4, "attempting to set prefix: ", 0
        ALIGN
        MOV     r2, r10
01
        LDRB    r0, [r2], #1
        CMP     r0, #' '+1
        SWICS   OS_WriteC
        CMP     r0, #' '+1
        BCS     %BT01
        SWI     OS_NewLine
        LDMFD   sp!,{r0,r2}                ; Unstack registers
    ]
  ]

        ASSERT  DDEUtils_Prefix = DDEUtilsSWI_Base
        LDR     r11, wimp_domain
        LDR     r11, [r11]
        ADR     r8, chain
        LDR     r2, chain
do_swi1
        TEQ     r2, #0
        BEQ     do_swi2
        LDR     r1, [r2, #o_wimpdomain]
        TEQ     r1, r11
        ADDNE   r8, r2, #o_next            ; r8 = last next pointer addr
        LDRNE   r2, [r2, #o_next]          ; r2 = this pointer
        BNE     do_swi1
        LDR     r3, [r2, #o_next]          ; read this next
        STR     r3, [r8]                   ; store as last next
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        MOVVC   r2,r3
        BVC     do_swi1
        LDMFD   sp!, {r1, r2, r3, r8, pc}  ; V set

do_swi2
        ADDS    r0, r10, #0
        LDMEQFD sp!, {r1, r2, r3, r8, pc}  ; V clear
        LDRB    r1, [r0]
        CMP     r1, #' ' + 1
        LDMLOFD sp!, {r1, r2, r3, r8, pc}  ; V clear
        MOV     r3, #0
do_swi3
        LDRB    r1, [r0], #1
        ADD     r3, r3, #1
        CMP     r1, #' ' + 1
        BCS     do_swi3
        ADD     r3, r3, #o_prefix
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        LDMVSFD sp!, {r1, r2, r3, r8, pc}  ; V set
        STR     r2, [r8]                   ; store over last next pointer (!)
        MOV     r0, #0
        STR     r0, [r2], #4               ; next
        STR     r11, [r2], #4              ; domain
                                           ; prefix follows
        MOV     r0, r10
do_swi4
        LDRB    r1, [r10], #1
        STRB    r1, [r2], #1
        CMP     r1, #' ' + 1
        MOVHS   r3, r1
        BHS     do_swi4
        CMP     r3, #'.'
        STREQB  r1, [r2, #-2]
        MOV     r3,#0
        STRB    r3, [r2, #-1]              ; store it as terminated
        LDMFD   sp!, {r1, r2, r3, r8, pc}  ; V clear

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_ReadPrefix
; -------------------
; Entry: R0  = task handle or 0 for current task
; Exit:  R0  = pointer to prefix dir for that task or 0 if none.
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_readprefix
        MOVS    r11, r0, LSL #16
        LDREQ   r11, wimp_domain
        LDREQ   r11, [r11]
        MOVEQ   r11, r11, ROR #16
        MOV     r0, #0
        STMFD   sp!, {r1, r2, r8, lr}
        LDR     r8, chain

doswi_readprefix1
        CMP     r8, #0
        LDMEQFD sp!, {r1, r2, r8, pc}
        LDR     r2, [r8,#o_next]
        LDR     r1, [r8, #o_wimpdomain]
        CMP     r11, r1, ROR #16
        ADDEQ   r0, r8, #o_prefix
        LDMEQFD sp!, {r1, r2, r8, pc}
        MOV     r8, r2
        B       doswi_readprefix1

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_GetClSize
; ------------------
; Exit:  R0  = size
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_getclsize
        LDR     r0, cli_size
        MOV     pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_GetCl
; --------------
; Entry: R0  = pointer to buffer to copy into
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_getcl
        LDR     r11, cli_buffer
        CMP     r11, #0
        MOVEQ   r12, #0
        STREQB  r12, [r0]
        MOVEQ   pc, lr
        STMFD   sp!, {r2, r8, lr}
        MOV     r8, #0
        STR     r8, cli_buffer
        STR     r8, cli_size
        MOV     r2, r11
        MOV     r8, r0
getcl1
        LDRB    r10, [r11], #1
        STRB    r10, [r0], #1
        CMP     r10, #' '
        BHS     getcl1
        MOV     r10, #0
        STRB    r10, [r0, #-1]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        MOVVC   r0, r8
        LDMFD   sp!, {r2, r8, lr}
        B       xferv

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_FlushCL
; ----------------
; Entry: Nothing
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_flushcl
        LDR     r11, cli_buffer
        CMP     r11, #0
        MOVEQ   pc, lr
        STMFD   sp!, {r2, lr}
        MOV     lr, #0
        STR     lr, cli_buffer
        STR     lr, cli_size
        MOV     r2, r11
        MOV     r11, r0
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        MOVVC   r0, r11
        LDMFD   sp!, {r2, lr}
        B       xferv

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_SetCLSize
; ------------------
; Entry: R0  = size
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_setclsize
        STMFD   sp!, {r1, r2, r3, lr}
        MOV     r3, r0
        LDR     r2, cli_buffer
        CMP     r2, #0
        MOVNE   r0, #ModHandReason_Free
        SWINE   XOS_Module
        LDMVSFD sp!, {r1, r2, r3, pc}
  [ {FALSE}
        CMP     r3, #0
        LDMEQFD sp!, {r1, r2, r3, pc}
  ]
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        MOVVS   r1, #0
        STRVS   r1, cli_buffer
        STRVS   r1, cli_size
        STRVC   r2, cli_buffer
        STRVC   r3, cli_size
        MOVVC   r0, r2
        LDMFD   sp!, {r1, r2, r3, lr}
        B       xferv

no_cli_buffer_msg
        DCD     no_cli_buffer_error
        DCB     "CLI buffer not set", 0
        ALIGN

do_no_cli_buffer
        ADR     r0, no_cli_buffer_msg
        B       return_setv

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_SetCL
; --------------
; Entry: R0  = pointer to null terminated command tail
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_setcl
        LDR     r11, cli_buffer
        CMP     r11, #0
        BEQ     do_no_cli_buffer
        STMFD   sp!, {r0, r1, lr}
        LDR     r1, cli_size
setcl1
        LDRB    r10, [r0], #1
        STRB    r10, [r11], #1
  [ CheckBufferSize
        SUBS    r1,r1,#1
        BMI     do_buffer_too_short
  ]
        CMP     r10, #' '
        BCS     setcl1
        LDMFD   sp!, {r0, r1, pc}
  [ CheckBufferSize
do_buffer_too_short
        LDMFD   sp!, {r0, r1, lr}
        ADR     r0, buffer_too_short_msg
        B       return_setv

buffer_too_short_msg
        DCD     buffer_too_short
        DCB     "CLI buffer too short", 0
        ALIGN
  ]

prefix_cmd
        MOV     r6, lr
        SWI     XDDEUtils_Prefix
        MOV     pc, r6

not_desktop_msg
        DCD     not_desktop_error
        DCB     "Throwback not available outside the desktop", 0
        ALIGN

no_task_msg
        DCD     no_task_error
        DCB     "No task registered for throwback", 0
        ALIGN

already_reg_msg
        DCD     already_reg_error
        DCB     "Another task is registered for throwback", 0
        ALIGN

not_reg_msg
        DCD     not_reg_error
        DCB     "Task not registered for throwback", 0
        ALIGN


        ; check if we're in the desktop or not
checkactivetasks
        STMFD   sp!, {r0, lr}
        MOV     r0, #0
        SWI     XWimp_ReadSysInfo
        MOVVS   r0, #0
        CMP     r0, #0
        LDMFD   sp!, {r0, lr}
        MOVNE   pc, lr
        ADR     r0, not_desktop_msg
        B       return_setv

do_no_task
        ADR     r0, no_task_msg
return_setv
        TEQ     pc, pc
        ORRNES  pc, lr, #V_bit
        MSR     CPSR_f, #V_bit
        MOV     pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_ThrowbackEnd
; ---------------------
; Entry: Nothing
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_throwbackend
        STMFD   sp!, {r0-r4, r9, lr}
        BL      checkactivetasks
        ADDVS   sp,sp,#4
        LDMVSFD sp!, {r1-r4, r9, pc}
        LDR     r9, receiver_id
        CMP     r9, #0
        LDMEQFD sp!, {r0-r4, r9, lr}
        BEQ     do_no_task

        MOV     r0, #msg_throwback_end
startorendmsg
        MOV     r1, #0                  ; No string
stringonlymsg1
        MVN     r3, #0                  ; No line no.
        MVN     r4, #0                  ; No error level
        BL      sendmessage
throwback_vsret
        ADDVS   sp, sp, #4
        LDRVC   r0, [sp], #4
        LDMFD   sp!, {r1-r4, r9, lr}
        B       xferv


stringonlymsg
        STMFD   sp!, {r0-r4, r9, lr}
        B       stringonlymsg1

throwback_err
        DCB     "Throwback error", 13, 10, 0
        ALIGN

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_ThrowbackRegister
; --------------------------
; Entry: R0  = task handle
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_throwbackregister
        STMFD   sp!, {r0, r9, lr}
        BL      checkactivetasks
        ADDVS   sp,sp,#4
        LDMVSFD sp!, {r9, pc}
        LDR     r9, receiver_id
        CMP     r9, #0
        LDMFD   sp!, {r0, r9, lr}
        ADRNE   r0, already_reg_msg
        BNE     return_setv
        STR     r0, receiver_id
        MOV     pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_ThrowbackUnregister
; ----------------------------
; Entry: R0  = task handle
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_throwbackunregister
        STMFD   sp!, {r0, r9, lr}
        BL      checkactivetasks
        ADDVS   sp,sp,#4
        LDMVSFD sp!, {r9, pc}
        LDR     r9, receiver_id
        CMP     r9, r0
        MOVEQ   r0, #0
        STREQ   r0, receiver_id
        LDMFD   sp!, {r0, r9, lr}
        ADRNE   r0, not_reg_msg
        BNE     return_setv
        MOV     pc, lr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_ThrowbackStart
; -----------------------
; Entry: Nothing
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_throwbackstart
        STMFD   sp!, {r0-r4, r9, lr}
        BL      checkactivetasks
        ADDVS   sp,sp,#4
        LDMVSFD sp!, {r1-r4, r9, pc}
        LDR     r9, receiver_id
        CMP     r9, #0
        LDMEQFD sp!, {r0-r4, r9, lr}
        BEQ     do_no_task

        MOV     r0, #msg_throwback_start
        B       startorendmsg

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_ThrowbackSend
; ----------------------
; Entry: R0  = subreason code
;        R2-R5 dependant on subreason
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_throwbacksend
        STMFD   sp!, {r0-r4, r9, lr}
        BL      checkactivetasks
        ADDVS   sp,sp,#4
        LDMVSFD sp!, {r1-r4, r9, pc}
        LDR     r9, receiver_id
        CMP     r9, #0
        LDMEQFD sp!, {r0-r4, r9, lr}
        BEQ     do_no_task

        TEQ     pc, pc
        ADRNE   lr, tap_handler_26      ; For the 26 bit case, arrange the same stack as
        ORRNE   lr, lr, #SVC_mode       ; though entered via the veneer added to all the 26 bit
                                        ; vectors (in SVC mode with NZCV clear).
                                        ; For the 32 bit case, it's a harmless extra push of LR.
        STR     lr, [sp, #-4]!
        BL      throwback_add_prefix
        ADD     sp, sp, #4

        B       throwback_vsret

        ; support for ThrowbackSend
        ; R0 = subreason code
        ; R2 = filename to prefix
        ; R3-R5 dependant on subreason
throwback_add_prefix
        STR     lr, [sp, #-4]!
        MOV     r1, r2
        BL      common_handler_external_entry
tap_handler_26
        STMFD   sp!, {r0, r3, r4}
        MOV     lr, r0
        CMP     lr, #Throwback_ReasonInfoDetails
        MOVEQ   r0, #msg_throwback_infoforfile
        CMP     lr, #Throwback_ReasonProcessing
        MOVEQ   r0, #msg_throwback_processingfile
        CMP     lr, #Throwback_ReasonErrorDetails
        MOVEQ   r0, #msg_throwback_errorsin
        BL      stringonlymsg
        LDRVC   r0, [sp], #4
        ADDVS   sp, sp, #4
        LDMFD   sp!, {r3, r4}
        BVS     %FT10
        CMP     r0, #Throwback_ReasonProcessing
        LDREQ   pc, [sp], #4
        CMP     r0, #Throwback_ReasonInfoDetails
        MOVEQ   r0, #msg_throwback_infodetails
        MOVNE   r0, #msg_throwback_errordetails
        MOV     r1, r5
        BL      sendmessage
10
        LDR     lr, [sp], #4
        B       xferv

        ; R0 = message id
        ; R1 = string       0 => no string
        ; R3 = line no     -1 => no line no
        ; R4 = error level -1 => no errorlevel
sendmessage
        STR     lr, [sp, #-4]!
  [ Debug
        STMFD   sp!, {r0, r1, r2, r3}
        MOV     r3, r1
        SWI     OS_WriteS
        DCB     4, "Message id = ", 0
        ALIGN
        ADR     r1, hbuff
        MOV     r2, #12
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_WriteS
        DCB     13, 10, 0
        ALIGN
        MOV     r0, r3
        SWI     OS_Write0
        SWI     OS_WriteS
        DCB     13, 10, 5, 0
        ALIGN
        LDMFD   sp!, {r0, r1, r2, r3}
        B       %FT01
hbuff
        %       256
01
  ]
        MOV     r2, r1
        MOVS    lr, r1
        BEQ     sendmessage2
sendmessage1
        LDRB    r2, [lr], #1
        CMP     r2, #0
        BNE     sendmessage1
        SUB     r2, lr, r1
sendmessage2
        ADD     r2, r2, #31
        BIC     r2, r2, #3
        MOV     lr, sp
        SUB     sp, sp, r2
        STR     r2, [sp]
        ADD     r2, sp, #12
        STR     lr, [sp, #-4]!
        MOV     lr, #0
        STR     lr, [r2], #4
        ADD     r0, r0, #ddeutils_msgbase :AND: &FFF000
        ADD     r0, r0, #ddeutils_msgbase :AND: &000FFF
        STR     r0, [r2], #4
        CMN     r3, #1
        STRNE   r3, [r2], #4
        CMN     r4, #1
        STRNE   r4, [r2], #4
        CMP     r1, #0
        BEQ     sendmessage4
sendmessage3
        LDRB    lr, [r1], #1
        STRB    lr, [r2], #1
        CMP     lr, #0
        BNE     sendmessage3
sendmessage4
        MOV     r0, #17
        ADD     r1, sp, #4
        MOV     r2, r9
        LDR     lr, [r1]                   ; length of msg
        CMP     lr, #256
        MOVGT   lr, #256
        STRGT   lr, [r1]                   ; 256 is max size of msg
        MOVGT   lr, #0
        STRGTB  lr, [r1, #255]
        SWI     XWimp_SendMessage
        LDR     sp, [sp]
        LDR     lr, [sp], #4
        B       xferv

initvar
        STMFD   sp!, {r4, lr}
        MOV     r3, r1
initvar1
        LDRB    r2, [r3], #1
        CMP     r2, #' '
        BCS     initvar1
        SUB     r2, r3, r1
        MOV     r3, #0
        MOV     r4, #0
        SWI     XOS_SetVarVal
        LDMFD   sp!, {r4, pc}
  [ HALDebug
        GET     s.debug
  ]
        END
@


1.12
log
@Fix for DDE_ThrowbackSend failing on 26 bit systems when a prefix is set
On a 26 bit system a call to DDE_ThrowbackSend internally uses common_handler_external_entry to expand the thrown filename with the task local prefix, sharing code with the various filing system vectors which are intercepted.
However, common_handler_external_entry looks up the stack at sp+4 to retrieve the entry flags that the vectors stack on entry, only DDE_ThrowbackSend didn't. The result was instead to read stacked R0 which is most often 1 to pass an error, then the TEQNEP would switch from SVC to FIQ mode, and an abort due to the banked registers pointed in the wrong place.

In the 26 bit case a fake return is now stacked (we want common_handler_external_entry to return in both cases whether or not a prefix is set) in SVC26 mode.
Tested on RISC OS 4.02 with the !ObjAsm front end setting a task local prefix.

Version 1.74. Tagged as 'DDEUtils-1_74'
@
text
@d37 4
a40 1
Debug             SETL  {FALSE}
d517 3
d533 1
d575 3
d589 1
d650 3
d665 1
d747 5
d764 1
d817 1
a817 1
        BLS     copy_or_rename             
d881 1
a881 1
 
d1004 3
d1020 1
d1371 1
a1371 1
 
d1521 3
a1523 1

@


1.11
log
@Block move
Move throwback_add_prefix down to where it's used.
Escape some dollars in strings.
Not tagged.
@
text
@d763 1
a763 1
        TEQNEP  pc, lr
d1346 1
a1346 1

d1363 6
d1370 1
d1382 1
@


1.10
log
@Be ultra cautious and NOP after the TEQP, but more to shut the assembler warning up.

Version 1.72. Tagged as 'DDEUtils-1_72'
@
text
@d211 1
a211 1
        DCB     "File$Type_FD3", 0
d223 1
a223 1
        DCB     "File$Type_FE1", 0
d231 1
a231 1
        DCB     "Prefix$Dir", 0
d1347 20
d1368 3
d1387 1
a1387 1
        BVS     throwback_add_prefix1
d1395 1
a1395 1
throwback_add_prefix1
a1398 21
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DDEUtils_ThrowbackSend
; ----------------------
; Entry: R0  = subreason code
;        R2-R5 dependant on subreason
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
doswi_throwbacksend
        STMFD   sp!, {r0-r4, r9, lr}
        BL      checkactivetasks
        ADDVS   sp,sp,#4
        LDMVSFD sp!, {r1-r4, r9, pc}
        LDR     r9, receiver_id
        CMP     r9, #0
        LDMEQFD sp!, {r0-r4, r9, lr}
        BEQ     do_no_task

        BL      throwback_add_prefix

        B       throwback_vsret


@


1.9
log
@  Bugfix to *Prefix
Detail:
  A missing ALIGN directive caused bit 0 of the offset to the *Prefix code
  to be set. On ARMv7, ALU instructions targetting the PC with bit 0 set
  causes a Thumb interworking branch to be taken, which isn't what you want.
  A number of LDM/STMs of single registers have also been optimised.
Admin:
  Fix received from Willi Theiss

Version 1.71. Tagged as 'DDEUtils-1_71'
@
text
@d660 1
d764 1
@


1.8
log
@Push of LR+PC split out.

Version 1.70. Tagged as 'DDEUtils-1_70'
@
text
@d365 1
a365 1
        STMFD   sp!, {lr}
d372 1
a372 1
        LDMEQFD sp!, {pc}                  ; yes
d381 1
a381 1
        LDMFD   sp!, {pc}
d678 1
a678 1
        STMFD   sp!, {r0}
d682 1
a682 1
        LDMFD   sp!, {r0}
d870 1
a870 1
        LDMFD   sp!, {pc}
d888 1
a888 1
        LDMFD   sp!, {pc}
d895 1
a895 1
        LDMFD   sp!, {pc}
d1204 1
d1347 1
a1347 1
        STMFD   sp!, {lr}
d1364 1
a1364 1
        LDMEQFD sp!, {pc}
d1371 1
a1371 1
        LDMFD   sp!, {lr}
d1400 1
a1400 1
        STMFD   sp!, {lr}
d1440 1
a1440 1
        STMFD   sp!, {lr}
d1469 1
a1469 1
        LDMFD   sp!, {lr}
@


1.7
log
@Fix over zealous path prefixing.
Various of OS_File, OS_Find, and OS_FSControl have subreasons which force the use of a path or path variable, which DDEUtils was not respecting. Fixes ticket #167.
Moved the ReadPrefix SWI code down with the other SWIs.
Moved the Prefix SWI code down with the other SWIs.
Moved 'strip_hats' next to 'strip_hats0'.
Added FSControl_InfoToFileType to the list of FSControl subreasons operated on.
Made the various SWI error exits use the common 'return_setv' so overall the module is smaller than in 1.66.

Version 1.69. Tagged as 'DDEUtils-1_69'
@
text
@d900 3
a902 1
        STMFD   sp!, {r8-r11, lr, pc}      ; store PC+8 or PC+12
d934 1
a934 1
        LDMFD   sp!, {r8, r9, r10, r11, lr}
@


1.6
log
@Shock addition of some comments.
Two more hardwired constants swapped for defines.
Not tagged.
@
text
@d261 1
a261 1
        MOVVC   r0,#0
d359 1
a359 6
        TEQ     pc, pc
        ORRNES  pc,lr,#V_bit
        MSR     CPSR_f, #V_bit
        MOV     pc, lr


d448 3
a450 22
        ; Input: R0: task handle or 0 for current task
        ; Output: R0: pointer to prefix dir for that task or 0 if none.
doswi_readprefix
        MOVS    r11, r0, lsl #16
        LDREQ   r11, wimp_domain
        LDREQ   r11, [r11]
        MOVEQ   r11, r11, ror #16
        MOV     r0, #0
        STMFD   sp!, {r1, r2, r3, r8, lr}
        LDR     r8, chain

doswi_readprefix1
        CMP     r8, #0
        LDMEQFD sp!, {r1, r2, r3, r8, pc}
        LDR     r2, [r8,#o_next]
        LDR     r1, [r8, #o_wimpdomain]
        CMP     r11, r1, ror #16
        ADDEQ   r0, r8, #o_prefix
        LDMEQFD sp!, {r1, r2, r3, r8, pc}
        MOV     r8, r2
        B       doswi_readprefix1

d495 4
a498 97
doswi_prefix
        STMFD   sp!, {r1, r2, r3, r8, lr}
        MOVS    r10, r0
        BEQ     %FT01                      ; they gave 0
        LDRB    r0,[r10]
        CMP     r0,#' '
        BLO     %FT01                      ; it was a null command

  [ CanonicalisePath
        STMFD   sp!, {r4, r5}
        MOV     r0,#FSControl_CanonicalisePath
        MOV     r1,r10
        LDR     r2,fname_buffer
        MOV     r3,#0                      ; no path var
        MOV     r4,#0                      ; 0
        MOV     r5,#FilenameLength
        SWI     XOS_FSControl              ; canonicalise it!
        LDRVC   r10,fname_buffer
        LDMFD   sp!, { r4, r5 }
01
  ]

  [ Debug
        STMFD   sp!, {r0, r2}              ; Stack registers
        SWI     OS_WriteS
        DCB     4, "attempting to set prefix: ", 0
        ALIGN
        MOV     r2, r10
01
        LDRB    r0, [r2], #1
        CMP     r0, #' '+1
        SWICS   OS_WriteC
        CMP     r0, #' '+1
        BCS     %BT01
        SWI     OS_NewLine
        LDMFD   sp!,{r0,r2}                ; Unstack registers
  ]

        ASSERT  DDEUtils_Prefix = DDEUtilsSWI_Base
        LDR     r11, wimp_domain
        LDR     r11, [r11]
        ADR     r8, chain
        LDR     r2, chain
do_swi1
        TEQ     r2, #0
        BEQ     do_swi2
        LDR     r1, [r2, #o_wimpdomain]
        TEQ     r1, r11
        ADDNE   r8, r2, #o_next            ; r8 = last next pointer addr
        LDRNE   r2, [r2, #o_next]          ; r2 = this pointer
        BNE     do_swi1
        LDR     r3, [r2, #o_next]          ; read this next
        STR     r3, [r8]                   ; store as last next
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        MOVVC   r2,r3
        BVC     do_swi1
        LDMFD   sp!, {r1, r2, r3, r8, pc}  ; V set

do_swi2
        ADDS    r0, r10, #0
        LDMEQFD sp!, {r1, r2, r3, r8, pc}  ; V clear
        LDRB    r1, [r0]
        CMP     r1, #' ' + 1
        LDMLOFD sp!, {r1, r2, r3, r8, pc}  ; V clear
        MOV     r3, #0
do_swi3
        LDRB    r1, [r0], #1
        ADD     r3, r3, #1
        CMP     r1, #' ' + 1
        BCS     do_swi3
        ADD     r3, r3, #o_prefix
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        LDMVSFD sp!, {r1, r2, r3, r8, pc}  ; V set
        STR     r2, [r8]                   ; store over last next pointer (!)
        MOV     r0, #0
        STR     r0, [r2], #4               ; next
        STR     r11, [r2], #4              ; domain
                                           ; prefix follows
        MOV     r0, r10
do_swi4
        LDRB    r1, [r10], #1
        STRB    r1, [r2], #1
        CMP     r1, #' ' + 1
        MOVHS   r3, r1
        BHS     do_swi4
        CMP     r3, #'.'
        STREQB  r1, [r2, #-2]
        MOV     r3,#0
        STRB    r3, [r2, #-1]              ; store it as terminated
        LDMFD   sp!, {r1, r2, r3, r8, pc}  ; V clear

strip_hats
        SUBS    r0, r0, #0                 ; set carry
        B       strip_hats0

d502 1
a502 1
        ;        R8 = Task block
d506 2
a507 3
        ;        R8 = New Filename (R1 or R11 on entry)
        ;        CS => No prefix added (filename contained root char)
add_prefix
d585 2
d676 8
a683 2
        CMP     r0, #&40
        BHS     file_handler_external_entry
d702 1
a702 1
        BLS     file_handler_external_entry
a715 4
  [ Debug
file_handler_external_entry
        STMFD   sp!, {r8, r11, lr}
        B       %FT02
d717 12
d730 1
d733 1
a733 1
        DCB     4, "file_handler: ", 0
d742 1
a742 6
        LDMFD   sp!, {r0,r1}
02
  |
file_handler_external_entry
file_handler_32
        STMFD   sp!, {r8, r11, lr}
d747 1
a747 1
file_handler1
d749 1
a749 1
        BEQ     file_handler2
d753 1
a753 1
        BNE     file_handler1
d756 1
a756 1
file_handler3
d769 1
a769 1
file_upcall
d773 1
a773 1
file_handler2
d777 1
a777 1
        B       file_handler3
d791 1
a791 1
        BLS     fscontrol_handler1         
d795 2
d799 1
a799 1
        CMPNE   r0, #FSControl_CanonicalisePath
d814 1
a814 1
        BEQ     file_handler_external_entry
d817 1
a817 1
        BEQ     set_given_dir
d819 1
a819 1
        BEQ     unset_dir
d824 7
a830 1
fscontrol_handler1
d835 1
a835 1
        BEQ     file_handler_external_entry
d838 1
a838 1
        BEQ     change_dir
d844 1
a844 1
unset_dir
d846 1
a846 1
        MOV     r0,#0
d849 1
a849 1
        TEQ     r0,#0
d851 1
a851 1
        MOV     r0,#0
d855 1
a855 1
set_given_dir
d857 1
a857 1
        MOVNE   pc,lr                      ; only process if 'set CSD'
d860 1
a860 1
        MOV     r0,#0
d863 1
a863 1
        CMP     r0,#0
d865 1
a865 1
        MOV     r0,r1
d872 1
a872 1
change_dir
d874 1
a874 1
        MOV     r0,#0
d877 1
a877 1
        TEQ     r0,#0
d879 1
a879 1
        MOV     r0,#OSFile_ReadInfo
d883 1
a883 1
        MOV     r0,r1
d890 2
a891 2
        MOV     r0,#OSFile_MakeError
        MOV     r2,#&100                   ; Directory 'wibble' not found
d893 1
a893 1
        ADD     sp,sp,#4                   ; skip r0
d952 123
d1136 1
a1136 1
; DDEUtils_SetClSize
d1170 1
a1170 4
        TEQ     pc, pc
        ORRNES  pc, lr, #V_bit
        MSR     CPSR_f, #V_bit
        MOV     pc, lr
d1173 1
a1173 1
; DDEUtils_SetCl
d1197 1
a1197 4
        TEQ     pc, pc
        ORRNES  pc, lr, #V_bit
        MSR     CPSR_f, #V_bit
        MOV     pc, lr
d1240 1
a1240 4
        TEQ     pc, pc
        ORRNES  pc, lr, #V_bit
        MSR     CPSR_f, #V_bit
        MOV     pc, lr
d1346 1
a1346 1
        BL      file_handler_external_entry
@


1.5
log
@Stop peeking zero page.
Now uses OS_ReadSysInfo 6 to get the address of the domain id.
Put the throwback subreasons into the exported constants.
Remove more of the hardwired constants.
Remove all occurences of LDMFD r13! {lr and pc together} cos ARM have deprecated it.

Version 1.68. Tagged as 'DDEUtils-1_68'
@
text
@d110 3
d204 1
a205 1
reset
d234 3
d382 2
a383 2
        CMP     r2,#31
        BGT     %BT01
d778 3
d808 1
a808 1
        CMP     r0, #9
d810 3
a812 2
        CMP     r0, #13
        BLO     file_handler_external_entry
d1050 1
d1053 1
d1062 1
d1092 1
d1113 1
d1153 1
d1237 1
d1274 1
d1292 1
d1311 1
d1358 2
@


1.4
log
@Replace local definitions from central header files.
Line up code to more normal tab stops.
Add warning that it messes with zero page values.
Same size binary, but the "BadSWI" error number was wrong, so the binary differs.

Version 1.67. Tagged as 'DDEUtils-1_67'
@
text
@a18 1
        GET     VersionASM
d23 2
d33 1
a69 5
; DDEUtils throwback subreasons
reason_processing     * 0
reason_errordetails   * 1
reason_infodetails    * 2

d92 1
a92 1
; DDEUtils linked list
d99 1
d102 5
a106 8
o_next          EQU     &00
                ASSERT :INDEX: o_next = 0
o_wimpdomain    EQU     &04
o_prefix        EQU     &08
zp_wimpdomain         * &ff8
                ! 0,    "Warning: Zero page grubbing with domain!"

                IMPORT  |__RelocCode|
d108 1
a108 1
                AREA    |!|, CODE, READONLY
d141 1
a141 1
        DCB     "GetCl", 0
d190 1
a190 1
        TEQ     r1,#Service_Reset
d261 11
a271 1
        BLVC    claimvectors
d282 1
d351 1
a352 1
        MOV     r0,r3
d451 2
a452 1
        LDREQ   r11, [r11, #zp_wimpdomain]
d483 1
a483 1
do_lowest_swi
d496 2
a497 2
do_highest_swi
first_unused_swi *      (do_highest_swi - do_lowest_swi) / 4
a513 1
        MOV     r10, r0
d515 1
a515 1
        TEQ     r0,#0
d518 1
a518 1
        CMP     r0,#32
d523 1
a523 1
        MOV     r0,#37
d552 2
a553 1
        LDR     r11, [r11, #zp_wimpdomain]
d637 1
a637 1
        SWI     os_newline
d760 1
a760 1
        SWI     os_newline
d832 1
a832 1
        SWI     os_newline
d841 2
a842 2
        MOV     lr, #0
        LDR     lr, [lr, #zp_wimpdomain]   ; lr = domainid
d847 1
a847 1
        CMP     r11, lr
d886 8
a893 7
        CMP     r0, #25                    ; Rename objects
        BLO     fscontrol_handler1         
        CMP     r0, #27                    ; Copy objects
        BLO     copy_or_rename             
        CMPNE   r0, #28                    ; Count objects
        CMPNE   r0, #32                    ; *FileInfo
        CMPNE   r0, #37                    ; Canonicalise
d902 1
a902 2
        ; (should already be canonical, I think - JRF)
        ; CMPNE   r0, #51                  ; update stamp
d910 1
a910 1
        CMP     r0, #53
d912 1
a912 1
        CMP     r0, #43
d919 4
a922 4
        CMP     r0, #5                     ; *.
        CMPNE   r0, #6                     ; *Ex
        CMPNE   r0, #9                     ; *Info
        CMPNE   r0, #24                    ; *Access
d925 1
a925 1
        CMP     r0, #0
d938 1
a938 1
        LDMEQFD sp!, {r0,pc}
d941 1
a941 4
01
        LDMVCFD sp!, {r0,lr,pc}
        ADDVS   sp,sp,#4
        LDMFD   sp!, {lr,pc}
d944 1
a944 1
        CMP     r2,#0
d952 1
a952 1
        LDMEQFD sp!, {r0,pc}
d956 3
a958 3
        LDMVCFD sp!, {r0,lr,pc}
        ADDVS   sp,sp,#4
        LDMFD   sp!, {lr,pc}
d967 1
a967 1
        MOV     r0,#5
d969 1
a969 1
        TST     r0,#2
d974 3
a976 3
        LDMVCFD sp!, {r0-r5,lr,pc}
        ADDVS   sp,sp,#4
        LDMFD   sp!, {r1-r5,lr,pc}
d978 1
a978 1
        MOV     r0,#19
d982 2
a983 2
        LDMFD   sp!, {r1-r5,lr,pc}

d999 1
a999 1
        LDR    r8, [r8]
d1002 2
a1003 2
        MOV     lr, #0
        LDR     lr, [lr, #zp_wimpdomain]
d1313 1
a1313 1
        CMP     lr, #reason_infodetails
d1315 1
a1315 1
        CMP     lr, #reason_processing
d1317 1
a1317 1
        CMP     lr, #reason_errordetails
d1324 1
a1324 1
        CMP     r0, #reason_processing
d1326 1
a1326 1
        CMP     r0, #reason_infodetails
d1335 1
a1335 1

d1337 2
@


1.3
log
@  Bugfixes.
Detail:
  * Some 32-bit unsafe instructions removed
  * Now runs on 26-bit systems again (passing on vectors branched to the
    wrong address!)
  * Added new SWI DDEUtils_FlushCL to allow a bugfix to system() in the
    shared C library
Admin:
  Tested on a 26-bit system.

Version 1.66. Tagged as 'DDEUtils-1_66'
@
text
@a16 2
; Author:
; History: Used to live on Aquarius SrcFiler
a17 1
                GET     VersionASM
d19 17
a35 15
                ^    0,r12
chain           #     4
fname_buffer    #     4
cli_buffer      #     4
cli_size        #     4
receiver_id     #     4
workspace_end   #     0

; JRF: Debugging
                GBLL    DEBUG ; turn this off for ROMing
DEBUG           SETL    {FALSE}

; JRF: Don't make it work on pre-RO4
                GBLL    RO4Only
RO4Only         SETL    {FALSE}
d41 2
a42 2
                GBLL    LongFilenames
LongFilenames   SETL    {TRUE}
d47 1
a47 1
FilenameLength    EQU    1024
d49 1
a49 1
FilenameLength    EQU     256
d53 2
a54 2
                  GBLL    CanonicalisePath
CanonicalisePath  SETL    {TRUE}
d57 2
a58 2
                  GBLL    CheckBufferSize
CheckBufferSize   SETL    {TRUE}
d60 2
a61 2
                        GBLL   AllowDirectoryChanging
AllowDirectoryChanging  SETL   {TRUE}
d65 2
a66 2
                        GBLL   HandleImages
HandleImages            SETL   {FALSE}
d68 35
a102 80
os_writec       EQU     0
os_writes       EQU     1
os_write0       EQU     2
os_newline      EQU     3

xos_module      EQU     &2001e
xos_claim       EQU     &2001f
xos_release     EQU     &20020
xos_fscontrol   EQU     &20029
xos_file        EQU     &20008
xos_changeenvironment EQU &20040
xos_readsysinfo EQU     &20058
xos_enteros     EQU     &20016
os_exit         EQU     &11
os_generateerror EQU    &2b
xwimp_readsysinfo EQU   &600f2
xwimp_sendmessage EQU   &600e7
xmessagetrans_errorlookup EQU &61506
xos_setvarval   EQU     &20024
xos_word        EQU     &20007
os_converthex8  EQU     &d4

zp_wimpdomain   EQU     &ff8

n_module_claim  EQU     6
n_module_free   EQU     7

n_filev         EQU     &08
n_gbpbv         EQU     &0c
n_findv         EQU     &0d
n_fscontrolv    EQU     &0f

n_error_h       EQU     6
n_exit_h        EQU     11

ddeutils_swibase             EQU    &42580
xddeutils_swibase            EQU    &62580
ddeutils_prefix              EQU    0               ; + ddeutils_swibase
ddeutils_setclsize           EQU    1
ddeutils_setcl               EQU    2
ddeutils_getclsize           EQU    3
ddeutils_getcl               EQU    4
ddeutils_throwbackregister   EQU    5
ddeutils_throwbackunregister EQU    6
ddeutils_throwbackstart      EQU    7
ddeutils_throwbacksend       EQU    8
ddeutils_throwbackend        EQU    9
ddeutils_readprefix          EQU    10
ddeutils_flushcl             EQU    11
first_unused_swi             EQU    12

reason_processing            EQU    0
reason_errordetails          EQU    1
reason_infodetails           EQU    2

overflow        EQU     &10000000
carry           EQU     &20000000

ddeutils_errbase    EQU &20600
unk_swi_error       EQU ddeutils_errbase + 0
no_cli_buffer_error EQU ddeutils_errbase + 1
not_desktop_error   EQU ddeutils_errbase + 2
no_task_error       EQU ddeutils_errbase + 3
already_reg_error   EQU ddeutils_errbase + 4
not_reg_error       EQU ddeutils_errbase + 5
buffer_too_short    EQU ddeutils_errbase + 6

ddeutils_msgbase             EQU ddeutils_swibase
ddeutils_msgbase_h           EQU &42000
ddeutils_msgbase_l           EQU &580
msg_throwback_start          EQU 0               ; + ddeutils_msgbase
msg_throwback_processingfile EQU 1
msg_throwback_errorsin       EQU 2
msg_throwback_errordetails   EQU 3
msg_throwback_end            EQU 4
msg_throwback_infoforfile    EQU 5
msg_throwback_infodetails    EQU 6

service_reset         EQU &27
service_wimpclosedown EQU &53
d108 2
d115 73
a187 70
module_start    EQU     .

                DCD     0                         ; Run
                DCD     init - module_start       ; Init
                DCD     finish - module_start     ; Finish
                DCD     service - module_start    ; Service call
                DCD     title - module_start      ; Title
                DCD     help - module_start       ; Help
                DCD     cmd_table - module_start  ; *commands
                DCD     ddeutils_swibase          ; SWI Base
                DCD     do_swi - module_start     ; SWI Handler
                DCD     swi_table - module_start  ; SWI Table
                DCD     0                         ; SWI Decoder
                DCD     0                         ; Messages filename
                DCD     flags - module_start      ; Module flags


help            DCB     "DDEUtils", 9
                DCB     Module_MajorVersion, " (", Module_Date, ")", 0
        [ Module_MinorVersion <> ""
                DCB     " ", Module_MinorVersion
        |
        ]
                DCB     0

title           ; DCB     "DDEUtils", 0
swi_table       DCB     "DDEUtils", 0
                DCB     "Prefix", 0
                DCB     "SetCLSize", 0
                DCB     "SetCL", 0
                DCB     "GetCLSize", 0
                DCB     "GetCl", 0
                DCB     "ThrowbackRegister", 0
                DCB     "ThrowbackUnRegister", 0
                DCB     "ThrowbackStart", 0
                DCB     "ThrowbackSend", 0
                DCB     "ThrowbackEnd", 0
                DCB     "ReadPrefix", 0
                DCB     "FlushCL", 0
                DCB     0

cmd_table       DCB     "Prefix", 0
                ALIGN
                DCD     prefix_cmd - module_start
                DCB     0                          ; Min. parameters
                DCB     1                          ; GSTrans map
                DCB     1                          ; Max. parameters
                DCB     0                          ; Flags
                DCD     prefix_syn - module_start  ; Syntax message
                DCD     prefix_help - module_start ; Help message
                DCD     0                          ; End of command table

prefix_help     DCB     "*Prefix selects a directory as the current directory unique to the currently executing task. *Prefix with no arguments sets the current directory back to the systemwide default (as set with *Dir).", 13

prefix_syn      DCB     "Syntax: *Prefix [<directory>]", 0
                ALIGN

flags           DCD     1                          ; 32-bit compatible

;Ursula format
;
                ASSERT  service_reset < service_wimpclosedown
;
UServTab
                DCD     0                              ;flags
                DCD     UService - module_start
                DCD     service_reset
                DCD     service_wimpclosedown
                DCD     0                              ;terminator
                DCD     UServTab - module_start        ;anchor
d189 16
a204 22
 [ RO4Only
                MOV     r0,r0                          ;magic instruction
                TEQNE   r1,#service_reset
                TEQNE   r1,#service_wimpclosedown
                MOVNE   pc,lr
                B       service
 |
                MOV     r0,r0                          ;magic instruction
                TEQ     r1, #service_reset
                TEQNE   r1, #service_wimpclosedown
                MOVNE   pc,lr
 ]
UService
                TEQ     r1,#service_reset
                LDREQ   r12,[r12]
                BEQ     reset
                CMP     r0, #0
                MOVNE   pc, lr
                STMFD   sp!, {r0, lr}
                MOV     r0, #0
                SWI     xddeutils_swibase + ddeutils_prefix
                LDMFD   sp!, {r0, pc}
d206 1
a206 1
; Really should clear the chain here...
d208 83
a290 77
                STMFD   sp!, {r0, lr}
                BL      claimvectors
                LDMFD   sp!, {r0, pc}

filetype_fd3    DCB     "File$Type_FD3", 0
debimage        DCB     "DebImage", 0
runtype_fd3     DCB     "Alias$@@RunType_FD3", 0
debugaif        DCB     "DebugAIF %*0", 0
loadtype_fd3    DCB     "Alias$@@LoadType_FD3", 0
loadaif         DCB     "Load %0 8000", 0
filetype_fe1    DCB     "File$Type_FE1", 0
makefile        DCB     "Makefile", 0
runtype_fe1     DCB     "Alias$@@RunType_FE1", 0
make            DCB     "DDE:!Make %*0", 0
prefix_dir      DCB     "Prefix$Dir", 0
                ALIGN
n_vartype_code  EQU     16

init            STMFD   sp!, {r7, r8, r9, r10, r11, lr}
  [ RO4Only
                MOV     r0,#9
                MOV     r1,#0
                SWI     xos_readsysinfo
                MOVVS   pc,#0
  ]
                ADR     r0, filetype_fd3
                ADR     r1, debimage
                BL      initvar
                ADR     r0, runtype_fd3
                ADR     r1, debugaif
                BL      initvar
                ADR     r0, loadtype_fd3
                ADR     r1, loadaif
                BL      initvar
                ADR     r0, filetype_fe1
                ADR     r1, makefile
                BL      initvar
                ADR     r0, runtype_fe1
                ADR     r1, make
                BL      initvar

                MOV     r0, #n_module_claim
                MOV     r3, #:INDEX: workspace_end
                SWI     xos_module            ; claim our module workspace
                STRVC   r2,[r12]
                MOVVC   r12,r2

                MOVVC   r0,#0
                STRVC   r0, chain
                STRVC   r0, cli_buffer
                STRVC   r0, cli_size
                STRVC   r0, receiver_id

                BLVC    claimvectors
;                MOVVC   r2, r12
                MOVVC   r0, #n_module_claim
                MOVVC   r3, #FilenameLength * 2
                SWIVC   xos_module
                STRVC   r2, fname_buffer
                ADRVC   r0, prefix_dir
                ADRVC   r1, prefix_dir_code
                MOVVC   r2, #prefix_dir_code_end - prefix_dir_code
                MOVVC   r3, #0
                MOVVC   r4, #n_vartype_code
                SWIVC   xos_setvarval
                LDMFD   sp!, {r7, r8, r9, r10, r11, lr}
xferv           TEQ     pc, pc
                MOVEQ   pc, lr
                ORRVS   lr, lr, #overflow
                MOVS    pc, lr

xfervc          TEQ     pc, pc
                MOVEQ   pc, lr
                BIC     lr, lr, #carry
                ORRCS   lr, lr, #carry
                ORRVS   lr, lr, #overflow
                MOVS    pc, lr
d293 31
a323 31
                STMFD   sp!, {r2,r3,lr}
                MOV     r2,r12
                MOV     r0, #n_filev
                TEQ     pc, pc
                ADREQL  r1, file_handler_32
                ADRNEL  r1, file_handler_26
                SWI     xos_claim
                MOVVS   r3, r0
                BVS     %FT01
                MOV     r0, #n_gbpbv
                TEQ     pc, pc
                ADREQL  r1, gbpb_handler_32
                ADRNEL  r1, gbpb_handler_26
                SWI     xos_claim
                MOVVS   r3, r0
                BVS     %FT02
                MOV     r0, #n_findv
                TEQ     pc, pc
                ADREQL  r1, find_handler_32
                ADRNEL  r1, find_handler_26
                SWI     xos_claim
                MOVVS   r3, r0
                BVS     %FT03
                MOV     r0, #n_fscontrolv
                TEQ     pc, pc
                ADREQL  r1, fscontrol_handler_32
                ADRNEL  r1, fscontrol_handler_26
                SWI     xos_claim
                MOVVS   r3, r0
                BVS     %FT04
                LDMFD   sp!, {r2,r3,pc}
d325 1
a325 1
; these are the failure cases
d327 5
a331 5
                MOV     r0, #n_findv
                TEQ     pc, pc
                ADREQL  r1, find_handler_32
                ADRNEL  r1, find_handler_26
                SWI     xos_release
d333 5
a337 5
                MOV     r0, #n_gbpbv
                TEQ     pc, pc
                ADREQL  r1, gbpb_handler_32
                ADRNEL  r1, gbpb_handler_26
                SWI     xos_release
d339 5
a343 5
                MOV     r0, #n_filev
                TEQ     pc, pc
                ADREQL  r1, file_handler_32
                ADRNEL  r1, file_handler_26
                SWI     xos_release
d345 6
a350 6
                LDMFD   sp!, {r2,r3,lr}
                MOV     r0,r3
                TEQ     pc, pc
                ORRNES  pc,lr,#overflow
                MSR     CPSR_f, #overflow
                MOV     pc, lr
d354 14
a367 13
prefix_dir_code B       dir_code_write
; prefix_dir read code
; <= r0-> value
                STMFD   sp!, {lr}
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_readprefix
                MOVVS   r0,#0
                CMP     r0,#0     ; was it invalid ?
                MOVEQ   r0,#0
                MOVEQ   r2,#0
                LDMEQFD sp!, {pc} ; yes
; now we need to find the length of the directory
                MOV     r1,r0
d369 13
a381 12
                LDRB    r2,[r1],#1
                CMP     r2,#31
                BGT     %BT01
                SUB     r2,r1,r0
                SUB     r2,r2,#1 ; and we increased over the terminator
                LDMFD   sp!, {pc}

dir_code_write  STMFD   sp!, {r0, lr}
                MOV     r0, r1
                SWI     xddeutils_swibase + ddeutils_prefix
                ADDS    r0, r0, #0 ; clear V
                LDMFD   sp!, {r0, pc}
d384 56
a439 53
finish          MOV     r6, lr
                LDR     r12, [r12]
                MOV     r0, #n_module_free
                LDR     r2, fname_buffer
                CMP     r2, #0
                SWINE   xos_module

                LDR     r2, cli_buffer
                CMP     r2, #0
                SWINE   xos_module

                LDR     r2, chain
                MOV     r1, #0
                STR     r1, chain
                STR     r1, fname_buffer
                STR     r1, cli_buffer
                STR     r1, cli_size
                STR     r1, receiver_id

finish1         CMP     r2, #0
                BEQ     finish2
                LDR     r5, [r2,#o_next]
                MOV     r0, #n_module_free
                SWI     xos_module
                MOV     r2, r5
                BVC     finish1

finish2         MOV     r2, r12
                MOV     r0, #n_filev
                TEQ     pc, pc
                ADREQL  r1, file_handler_32
                ADRNEL  r1, file_handler_26
                SWI     xos_release
                MOV     r0, #n_gbpbv
                TEQ     pc, pc
                ADREQ   r1, gbpb_handler_32
                ADRNE   r1, gbpb_handler_26
                SWI     xos_release
                MOV     r0, #n_findv
                TEQ     pc, pc
                ADREQ   r1, find_handler_32
                ADRNE   r1, find_handler_26
                SWI     xos_release
                MOV     r0, #n_fscontrolv
                TEQ     pc, pc
                ADREQL  r1, fscontrol_handler_32
                ADRNEL  r1, fscontrol_handler_26
                SWI     xos_release
                MOV     r2, r12               ; free our main workspace
                MOV     r0, #n_module_free
                SWI     xos_module
                CMP     r0, #0
                MOV     pc, r6
d441 2
a442 2
; Input: R0: task handle or 0 for current task
; Output: R0: pointer to prefix dir for that task or 0 if none.
d444 7
a450 6
		MOVS	r11, r0, lsl #16
		LDREQ	r11, [r11, #zp_wimpdomain]
		MOVEQ	r11, r11, ror #16
		MOV	r0, #0
		STMFD	sp!, {r1, r2, r3, r8, lr}
		LDR     r8, chain
d452 9
a460 9
		CMP	r8, #0
		LDMEQFD	sp!, {r1, r2, r3, r8, pc}
		LDR	r2, [r8,#o_next]
		LDR	r1, [r8, #o_wimpdomain]
		CMP	r11, r1, ror #16
		ADDEQ	r0, r8, #o_prefix
		LDMEQFD	sp!, {r1, r2, r3, r8, pc}
		MOV	r8, r2
		B	doswi_readprefix1
d463 8
a470 8
   STR     lr,[sp,#-4]!
   LDR     r12,[r12] ; read workspace pointer
   BL      do_swi_orig
   TEQ     pc, pc
   LDREQ   pc,[sp],#4 ; 32-bit return corrupting flags
   LDMVCFD sp!,{pc}^  ; 26-bit return without error
   LDR     lr,[sp],#4 ; 26-bit return with error
   ORRS    pc,lr,#overflow
d473 18
a490 16
   CMP     r11,#first_unused_swi
   ADDLT   pc,pc,r11,LSL #2
   B       module_swierror
; ***** SWI jump table
   B       doswi_prefix
   B       doswi_setclsize
   B       doswi_setcl
   B       doswi_getclsize
   B       doswi_getcl
   B       doswi_throwbackregister
   B       doswi_throwbackunregister
   B       doswi_throwbackstart
   B       doswi_throwbacksend
   B       doswi_throwbackend
   B       doswi_readprefix
   B       doswi_flushcl
d493 7
a499 7
   STMFD   sp!,{r1-r4,lr}
   ADR     r0,msg_swierror
   MOV     r1,#0
   MOV     r2,#0
   ADRL    r4,title
   SWI     xmessagetrans_errorlookup
   LDMFD   sp!,{r1-r4,pc}
d502 3
a504 4
   DCD     &1E6
   DCB     "BadSWI",0
   ALIGN

d507 7
a513 7
                MOV     r10, r0
                STMFD   sp!, {r1, r2, r3, r8, lr}
                TEQ     r0,#0
                BEQ     %FT01       ; they gave 0
                LDRB    r0,[r10]
                CMP     r0,#32
                BLO     %FT01       ; it was a null command
d516 10
a525 10
                STMFD   sp!, { r4, r5 }
                MOV     r0,#37
                MOV     r1,r10
                LDR     r2,fname_buffer
                MOV     r3,#0 ; no path var
                MOV     r4,#0 ; 0
                MOV     r5,#FilenameLength
                SWI     xos_fscontrol ; canonicalise it!
                LDRVC   r10,fname_buffer
                LDMFD   sp!, { r4, r5 }
d529 14
a542 12
  [ DEBUG
                STMFD   sp!,{r0,r2}            ; Stack registers
                SWI     os_writes
                DCB     4, "attempting to set prefix: ", 0
                MOV     r2, r10
01              LDRB    r0, [r2], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BCS     %BT01
                SWI     os_newline
                LDMFD   sp!,{r0,r2}            ; Unstack registers
d545 87
a631 78
                ASSERT  ddeutils_prefix = 0
                LDR     r11, [r11, #zp_wimpdomain]
                ADR     r8, chain
                LDR     r2, chain
do_swi1         TEQ     r2, #0
                BEQ     do_swi2
                LDR     r1, [r2, #o_wimpdomain]
                TEQ     r1, r11
                ADDNE   r8, r2, #o_next       ; r8 = last next pointer addr
                LDRNE   r2, [r2, #o_next]     ; r2 = this pointer
                BNE     do_swi1
                LDR     r3, [r2, #o_next]     ; read this next
                STR     r3, [r8]              ; store as last next
                MOV     r0, #n_module_free
                SWI     xos_module
                MOVVC   r2,r3
                BVC     do_swi1
                LDMFD   sp!, {r1, r2, r3, r8, pc} ; V set

do_swi2         ADDS    r0, r10, #0
                LDMEQFD sp!, {r1, r2, r3, r8, pc} ; V clear
                LDRB    r1, [r0]
                CMP     r1, #' ' + 1
                LDMLOFD sp!, {r1, r2, r3, r8, pc} ; V clear
                MOV     r3, #0
do_swi3         LDRB    r1, [r0], #1
                ADD     r3, r3, #1
                CMP     r1, #' ' + 1
                BCS     do_swi3
                ADD     r3, r3, #o_prefix
                MOV     r0, #n_module_claim
                SWI     xos_module
                LDMVSFD sp!, {r1, r2, r3, r8, pc} ; V set
                STR     r2, [r8]      ; store over last next pointer (!)
                MOV     r0, #0
                STR     r0, [r2], #4  ; next
                STR     r11, [r2], #4 ; domain
                                      ; prefix follows
                MOV     r0, r10
do_swi4         LDRB    r1, [r10], #1
                STRB    r1, [r2], #1
                CMP     r1, #' ' + 1
                MOVHS   r3, r1
                BHS     do_swi4
                CMP     r3, #'.'
                STREQB  r1, [r2, #-2]
                MOV     r3,#0
                STRB    r3, [r2, #-1] ; store it as terminated
                LDMFD   sp!, {r1, r2, r3, r8, pc} ; V clear

strip_hats      SUBS    r0, r0, #0 ; set carry
                B       strip_hats0

; Entry: VC
;        R1  = Filename
;        R11 = Filename buffer
;        R8 = Task block
; Exit:  R11, LR = ???
;        R1  = Preserved
;        R11 = Preserved
;        R8 = New Filename (R1 or R11 on entry)
;        CS => No prefix added (filename contained root char)
add_prefix      SUBS    r0, r0, #0      ; set C
add_prefix0     STMFD   sp!, {r0, r1, r2, r3, r4, r5, lr}       ; r5 is placeholder
                MRS     lr, CPSR        ; NOP on old machine
                STR     lr, [sp, #20]
  [ DEBUG
                STMFD   sp!, {r0-r2}
                SWI     os_writes
                DCB     "Before add_prefix: ", 0
                MOV     r2, r1
write_name0     LDRB    r0, [r2], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BCS     write_name0
                SWI     os_newline
                LDMFD   sp!,{r0-r2}
d633 51
a683 45
                MOV     r2, r1
add_prefix1     LDRB    r0, [r2], #1
                CMP     r0, #':'
                CMPNE   r0, #'$'
                CMPNE   r0, #'&'
                CMPNE   r0, #'%'
                CMPNE   r0, #'<'
                MOVEQ   r8, r1
                BEQ     add_prefix5
                CMP     r0, #' ' + 1
                BCS     add_prefix1
                MOV     r2, r1
                LDRB    r0, [r2]
                CMP     r0, #'@@'
                BNE     add_prefix2
                LDRB    r0, [r2, #1]!
                CMP     r0, #'.'
                ADDEQ   r2, r2, #1
add_prefix2     MOV     r3, r11
                ADD     r8, r8, #o_prefix
add_prefix3     LDRB    r0, [r8], #1
                CMP     r0, #' ' + 1
                STRCSB  r0, [r3], #1
                BCS     add_prefix3
                LDRB    r0, [r2]
                CMP     r0, #' ' + 1
                MOVCS   r0, #'.'
                STRCSB  r0, [r3], #1
add_prefix4     LDRB    r0, [r2], #1
                CMP     r0, #' ' + 1
                MOVCC   r0, #0
                STRB    r0, [r3], #1
                BCS     add_prefix4
                MOV     r8, r11

  [ DEBUG
                SWI     os_writes
                DCB     4, "After add_prefix: ", 0
                MOV     r2, r8
01              LDRB    r0, [r2], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BCS     %BT01
                SWI     os_newline
d685 69
a753 61
                LDMFD   sp, {r0, r1, r2, r3, r4, lr}
                BIC     lr, lr, #carry
                STR     lr, [sp, #20]
                B       add_prefix5

strip_hats0     STMFD   sp!, {r0, r1, r2, r3, r4, r5, lr}
                MRS     lr, CPSR        ; NOP on old machine
                STR     lr, [sp, #20]
add_prefix5     MOV     r2, r8
                MOV     r1, r11
                MOV     r3, r1
                MOV     r4, r3
add_prefix6     LDRB    r0, [r2], #1
                STRB    r0, [r1], #1
                CMP     r0, #'.'
                LDREQB  lr, [r2]
                CMPEQ   lr, #'^'
                BNE     add_prefix9
                LDRB    lr, [r3]
                CMP     lr, #'$'
                CMPNE   lr, #'@@'
                CMPNE   lr, #'%'
                CMPNE   lr, #'&'
                CMPNE   lr, #'<'
                CMPNE   lr, #'^'
                MOVEQ   r0, #'!'        ; R0 > ' ' and != '.'
                BEQ     add_prefix9
add_prefix7     LDRB    lr, [r2], #1
                CMP     lr, #'.'
                CMPNE   lr, #' '
                BHI     add_prefix7
                SUB     r2, r2, #1
                CMP     r3, r4
                STREQB  lr, [r3]
add_prefix8     LDRB    lr, [r2], #1
                STRNEB  lr, [r3], #1
                CMP     lr, #' '
                BHI     add_prefix8
                MOV     r8, r11
                LDR     r2, [sp, #20]
                BIC     r2, r2, #carry
                STR     r2, [sp, #20]
                B       add_prefix5
add_prefix9     CMP     r0, #':'
                MOVEQ   r4, r1
                MOVEQ   r3, r1
                CMP     r0, #'.'
                SUBEQ   r3, r1, #1
                CMP     r0, #' '
                BHI     add_prefix6
  [ DEBUG
                SWI     os_writes
                DCB     4, "After stripping ^s ", 0
                SWI     os_newline
                MOV     r2, r8
write_name1     LDRB    r0, [r2], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BCS     write_name1
                SWI     os_newline
d755 5
a759 5
                LDMFD   sp!, {r0, r1, r2, r3, r4, lr}
                TEQ     pc, pc
                BNE     add_prefix_ret_26
                MSR     CPSR_f, lr
                LDR     pc, [sp], #4
d762 2
a763 2
                TEQP    pc, lr
                LDR     pc, [sp], #4
d766 14
a779 13
                STR     lr, [sp, #-4]!
                STR     pc, [sp, #-4]!
                BL      find_handler_32
                NOP
                ADD     sp, sp, #4
                LDMVCFD sp!, {pc}^
                LDR     lr, [sp], #4
                ORRS    pc, lr, #overflow

find_handler_32 CMP     r0, #&40
                BHS     file_handler_external_entry
                CMP     r0, #0 ; clear V
                MOV     pc, lr
d782 16
a797 15
                STR     lr, [sp, #-4]!
                STR     pc, [sp, #-4]!
                BL      gbpb_handler_32
                NOP
                ADD     sp, sp, #4
                LDMVCFD sp!, {pc}^
                LDR     lr, [sp], #4
                ORRS    pc, lr, #overflow

gbpb_handler_32 CMP     r0, #9
                MOVLO   pc, lr          ; V clear
                CMP     r0, #13
                BLO     file_handler_external_entry
                CMP     r0, #0          ; V clear
                MOV     pc, lr
d800 8
a807 8
                STR     lr, [sp, #-4]!
                STR     pc, [sp, #-4]!
                BL      file_handler_32
                NOP
                ADD     sp, sp, #4
                LDMVCFD sp!, {pc}^
                LDR     lr, [sp], #4
                ORRS    pc, lr, #overflow
d809 1
a809 1
  [ DEBUG
d811 2
a812 2
                STMFD   sp!, {r8, r11, lr}
                B       %FT02
d814 13
a826 11
                STMFD   sp!, {r8, r11, lr}
                STMFD   sp!, {r0,r1}
                SWI     os_writes
                DCB     4, "file_handler: ", 0
01              LDRB    r0, [r1], #1
                CMP     r0, #' '+1
                SWICS   os_writec
                CMP     r0, #' '+1
                BHS     %BT01
                SWI     os_newline
                LDMFD   sp!, {r0,r1}
d831 1
a831 1
                STMFD   sp!, {r8, r11, lr}
d833 34
a866 30
                LDR     r8, chain
                MOV     lr, #0
                LDR     lr, [lr, #zp_wimpdomain]    ; lr = domainid
file_handler1   CMP     r8, #0
                BEQ     file_handler2
                LDR     r11, [r8, #o_wimpdomain]
                CMP     r11, lr
                LDRNE   r8, [r8, #o_next]
                BNE     file_handler1
                LDR     r11, fname_buffer
                BL      add_prefix
file_handler3   MOV     r12,r8 ; hold dir block otherwise this gets very icky
                LDMFD   sp!, {r8, r11, lr}
                MOVCS   pc, lr
                TEQ     pc, pc
                LDRNE   lr, [sp, #4]     ;get real pass-on address from 26-bit veneer
                TEQNEP  pc, lr
                STR     r1, [sp, #-4]!
                MOV     r1, r12
                STR     pc, [sp, #-4]!   ;store PC+8 (Architecture 4) or PC+12
                MOV     pc, lr
                NOP                      ;so that PC+8 is ok

file_upcall     LDMFD   sp!, {r1, lr}    ;target of stored PC
                B       xfervc

file_handler2   LDR     r11, fname_buffer
                MOV     r8, r1
                BL      strip_hats
                B       file_handler3
d869 8
a876 8
                STR     lr, [sp, #-4]!
                STR     pc, [sp, #-4]!
                BL      fscontrol_handler_32
                NOP
                ADD     sp, sp, #4
                LDMVCFD sp!, {pc}^
                LDR     lr, [sp], #4
                ORRS    pc, lr, #overflow
d879 7
a885 7
                CMP     r0, #25             ; Rename objects
                BLO     fscontrol_handler1
                CMP     r0, #27             ; Copy objects
                BLO     copy_or_rename
                CMPNE   r0, #28             ; Count objects
                CMPNE   r0, #32             ; *FileInfo
                CMPNE   r0, #37             ; Canonicalise
d887 13
a899 13
                CMPNE   r0, #41             ; return defects for image
                CMPNE   r0, #42             ; map out defects for image
                CMPNE   r0, #46             ; return used space map for image
                CMPNE   r0, #47             ; read boot for disc/image
                CMPNE   r0, #48             ; write boot for disc/image
                CMPNE   r0, #49             ; read free space for disc/image
                CMPNE   r0, #50             ; rename disc/image
; (should already be canonical, I think - JRF)
;                CMPNE   r0, #51             ; update stamp
                CMPNE   r0, #52             ; find object at offset
                CMPNE   r0, #55             ; read freespace (large)
                CMPNE   r0, #56             ; read defects (large)
                CMPNE   r0, #57             ; map out defect (large)
d901 6
a906 6
                BEQ     file_handler_external_entry
  [ AllowDirectoryChanging
                CMP     r0, #53
                BEQ     set_given_dir
                CMP     r0, #43
                BEQ     unset_dir
d908 2
a909 2
                CMP     r0, r0
                MOV     pc, lr
d912 8
a919 8
                CMP     r0, #5              ; *.
                CMPNE   r0, #6              ; *Ex
                CMPNE   r0, #9              ; *Info
                CMPNE   r0, #24             ; *Access
                BEQ     file_handler_external_entry
  [ AllowDirectoryChanging
                CMP     r0, #0
                BEQ     change_dir
d921 2
a922 2
                CMP     r0, r0
                MOV     pc, lr
d924 1
a924 1
  [ AllowDirectoryChanging
d926 8
a933 8
                STMFD   sp!, {r0,lr}
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_readprefix ;read context
                BVS     %FT01
                TEQ     r0,#0
                LDMEQFD sp!, {r0,pc}
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_prefix
d935 3
a937 3
                LDMVCFD sp!, {r0,lr,pc}
                ADDVS   sp,sp,#4
                LDMFD   sp!, {lr,pc}
d940 11
a950 11
                CMP     r2,#0
                MOVNE   pc,lr  ; only process if 'set CSD'

                STMFD   sp!, {r0,lr}
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_readprefix ;read context
                BVS     %FT01
                CMP     r0,#0
                LDMEQFD sp!, {r0,pc}
                MOV     r0,r1
                SWI     xddeutils_swibase + ddeutils_prefix
d952 3
a954 3
                LDMVCFD sp!, {r0,lr,pc}
                ADDVS   sp,sp,#4
                LDMFD   sp!, {lr,pc}
d957 12
a968 12
                STMFD   sp!, {r0-r5,lr}
                MOV     r0,#0
                SWI     xddeutils_swibase + ddeutils_readprefix ;read context
                BVS     %FT01
                TEQ     r0,#0
                LDMEQFD sp!, {r0-r5,pc}
                MOV     r0,#5
                SWI     xos_file
                TST     r0,#2
                BEQ     %FT02
                MOV     r0,r1
                SWI     xddeutils_swibase + ddeutils_prefix
d970 3
a972 3
                LDMVCFD sp!, {r0-r5,lr,pc}
                ADDVS   sp,sp,#4
                LDMFD   sp!, {r1-r5,lr,pc}
d974 5
a978 5
                MOV     r0,#19
                MOV     r2,#&100 ; Directory 'wibble' not found
                SWI     xos_file
                ADD     sp,sp,#4 ; skip r0
                LDMFD   sp!, {r1-r5,lr,pc}
d982 9
a990 8
copy_or_rename  STMFD   sp!, {r1, r2}
                STMFD   sp!, {r8, r9, r10, r11, lr, pc} ;store PC+8 or PC+12
                B       copy_or_rename1
                NOP                                  ;so that PC+8 is ok

copy_or_rename_upcall                                ;target of stored PC
                LDMFD   sp!, {r1, r2, lr}
                B       xfervc
d993 114
a1106 109
;   [ DEBUG
;                 STMFD   sp!, {r0,r1}
;                 SWI     os_writes
;                 DCB     4, "copy_or_rename1: ", 0
; 01              LDRB    r0, [r1], #1
;                 CMP     r0, #' '+1
;                 SWICS   os_writec
;                 CMP     r0, #' '+1
;                 BCS     %BT01
;                 SWI     os_newline
;                 LDMFD   sp!, {r0,r1}
;   ]
                ADR     r8, chain
copy_or_rename1b LDR    r8, [r8]
                CMP     r8, #0
                BEQ     copy_or_rename2
                MOV     lr, #0
                LDR     lr, [lr, #zp_wimpdomain]
                LDR     r11, [r8, #o_wimpdomain]
                CMP     r11, lr
                BNE     copy_or_rename1b
                LDR     r11, fname_buffer
                MOV     r9, r8
                BL      add_prefix
                MOV     r10, r8
                MOV     r8, r9
                ADD     r11, r11, #FilenameLength
                MOV     r9, r1
                MOV     r1, r2
                BL      add_prefix0
copy_or_rename3 MOV     r1, r9
                MOVCC   r2, r8
                MOVCC   r1, r10
                LDMFD   sp!, {r8, r9, r10, r11, lr}
                ADDCS   sp, sp, #12
                MOVCS   pc, lr
                TEQ     pc, pc
                LDRNE   lr, [sp, #16]     ;get real pass-on address from 26-bit veneer
                MOVNES  pc, lr
                MOV     pc, lr

copy_or_rename2 LDR     r11, fname_buffer
                MOV     r8, r1
                BL      strip_hats
                MOV     r10, r8
                ADD     r11, r11, #FilenameLength
                MOV     r9, r1
                MOV     r8, r2
                BL      strip_hats0
                B       copy_or_rename3

; SWI DDEUtils_GetClSize
doswi_getclsize LDR     r0, cli_size
                MOV     pc, lr


; SWI DDEUtils_GetCl
doswi_getcl     LDR     r11, cli_buffer
                CMP     r11, #0
                MOVEQ   r12, #0
                STREQB  r12, [r0]
                MOVEQ   pc, lr
                STMFD   sp!, {r2, r8, lr}
                MOV     r8, #0
                STR     r8, cli_buffer
                STR     r8, cli_size
                MOV     r2, r11
                MOV     r8, r0
getcl1          LDRB    r10, [r11], #1
                STRB    r10, [r0], #1
                CMP     r10, #' '
                BHS     getcl1
                MOV     r10, #0
                STRB    r10, [r0, #-1]
                MOV     r0, #n_module_free
                SWI     xos_module
                MOVVC   r0, r8
                LDMFD   sp!, {r2, r8, lr}
                B       xferv


; SWI DDEUtils_FlushCL
doswi_flushcl   LDR     r11, cli_buffer
                CMP     r11, #0
                MOVEQ   pc, lr
                STMFD   sp!, {r2, lr}
                MOV     lr, #0
                STR     lr, cli_buffer
                STR     lr, cli_size
                MOV     r2, r11
                MOV     r11, r0
                MOV     r0, #n_module_free
                SWI     xos_module
                MOVVC   r0, r11
                LDMFD   sp!, {r2, lr}
                B       xferv


; SWI DDEUtils_SetClSize
doswi_setclsize STMFD   sp!, {r1, r2, r3, lr}
                MOV     r3, r0
                LDR     r2, cli_buffer
                CMP     r2, #0
                MOVNE   r0, #n_module_free
                SWINE   xos_module
                LDMVSFD sp!, {r1, r2, r3, pc}
  [ 0 = 1
                CMP     r3, #0
                LDMEQFD sp!, {r1, r2, r3, pc}
d1108 10
a1117 10
                MOV     r0, #n_module_claim
                SWI     xos_module
                MOVVS   r1, #0
                STRVS   r1, cli_buffer
                STRVS   r1, cli_size
                STRVC   r2, cli_buffer
                STRVC   r3, cli_size
                MOVVC   r0, r2
                LDMFD   sp!, {r1, r2, r3, lr}
                B       xferv
d1120 3
a1122 3
                DCD     no_cli_buffer_error
                DCB     "CLI buffer not set", 0
                ALIGN
d1125 19
a1143 15
                ADR     r0, no_cli_buffer_msg
                TEQ     pc, pc
                ORRNES  pc, lr, #overflow
                MSR     CPSR_f, #overflow
                MOV     pc, lr


; SWI DDEUtils_SetCl
doswi_setcl     LDR     r11, cli_buffer
                CMP     r11, #0
                BEQ     do_no_cli_buffer
                STMFD   sp!, {r0, r1, lr}
                LDR     r1, cli_size
setcl1          LDRB    r10, [r0], #1
                STRB    r10, [r11], #1
d1145 2
a1146 2
                SUBS    r1,r1,#1
                BMI     do_buffer_too_short
d1148 3
a1150 3
                CMP     r10, #' '
                BCS     setcl1
                LDMFD   sp!, {r0, r1, pc}
d1153 6
a1158 6
                LDMFD   sp!, {r0, r1, lr}
                ADR     r0, buffer_too_short_msg
                TEQ     pc, pc
                ORRNES  pc, lr, #overflow
                MSR     CPSR_f, #overflow
                MOV     pc, lr
d1161 2
a1162 2
                DCD     buffer_too_short
                DCB     "CLI buffer too short", 0
d1165 24
a1188 21
prefix_cmd      MOV     r6, lr
                SWI     xddeutils_swibase + ddeutils_prefix
                MOV     pc, r6



not_desktop_msg DCD     not_desktop_error
                DCB     "Throwback not available outside the desktop", 0
                ALIGN

no_task_msg     DCD     no_task_error
                DCB     "No task registered for throwback", 0
                ALIGN

already_reg_msg DCD     already_reg_error
                DCB     "Another task is registered for throwback", 0
                ALIGN

not_reg_msg     DCD     not_reg_error
                DCB     "Task not registered for throwback", 0
                ALIGN
d1191 1
a1191 2

; check if we're in the desktop or not
d1193 12
a1204 12
                STMFD   sp!, {r0, lr}
                MOV     r0, #0
                SWI     xwimp_readsysinfo
                MOVVS   r0, #0
                CMP     r0, #0
                LDMFD   sp!, {r0, lr}
                MOVNE   pc, lr
                ADR     r0, not_desktop_msg
                TEQ     pc, pc
                ORRNES  pc, lr, #overflow
                MSR     CPSR_f, #overflow
                MOV     pc, lr
d1207 11
a1217 7
                ADR     r0, no_task_msg
return_setv     TEQ     pc, pc
                ORRNES  pc, lr, #overflow
                MSR     CPSR_f, #overflow
                MOV     pc, lr

; SWI DDEUtils_ThrowbackEnd
d1219 21
a1239 18
                STMFD   sp!, {r0-r4, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r1-r4, r9, pc}
                LDR     r9, receiver_id
                CMP     r9, #0
                LDMEQFD sp!, {r0-r4, r9, lr}
                BEQ     do_no_task

                MOV     r0, #msg_throwback_end
startorendmsg   MOV     r1, #0                  ; No string
stringonlymsg1  MVN     r3, #0                  ; No line no.
                MVN     r4, #0                  ; No error level
                BL      sendmessage
throwback_vsret ADDVS   sp, sp, #4
                LDRVC   r0, [sp], #4
                LDMFD   sp!, {r1-r4, r9, lr}
                B       xferv
d1243 2
a1244 6
                STMFD   sp!, {r0-r4, r9, lr}
                B       stringonlymsg1

throwback_err   DCB     "Throwback error", 13, 10, 0
                ALIGN

d1246 8
a1253 1
; SWI DDEUtils_ThrowbackRegister
d1255 16
a1270 13
                STMFD   sp!, {r0, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r9, pc}
                LDR     r9, receiver_id
                CMP     r9, #0
                LDMFD   sp!, {r0, r9, lr}
                ADRNE   r0, already_reg_msg
                BNE     return_setv
                STR     r0, receiver_id
                MOV     pc, lr

; SWI DDEUtils_ThrowbackUnregister
d1272 17
a1288 14
                STMFD   sp!, {r0, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r9, pc}
                LDR     r9, receiver_id
                CMP     r9, r0
                MOVEQ   r0, #0
                STREQ   r0, receiver_id
                LDMFD   sp!, {r0, r9, lr}
                ADRNE   r0, not_reg_msg
                BNE     return_setv
                MOV     pc, lr

; SWI DDEUtils_ThrowbackStart
d1290 8
a1297 8
                STMFD   sp!, {r0-r4, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r1-r4, r9, pc}
                LDR     r9, receiver_id
                CMP     r9, #0
                LDMEQFD sp!, {r0-r4, r9, lr}
                BEQ     do_no_task
d1299 2
a1300 2
                MOV     r0, #msg_throwback_start
                B       startorendmsg
d1302 1
a1302 1
; support for ThrowbackSend
d1304 23
a1326 23
                STMFD   sp!, {lr}
                MOV     r1, r2
                BL      file_handler_external_entry
                STMFD   sp!, {r0, r3, r4}
                MOV     lr, r0
                CMP     lr, #reason_infodetails
                MOVEQ   r0, #msg_throwback_infoforfile
                CMP     lr, #reason_processing
                MOVEQ   r0, #msg_throwback_processingfile
                CMP     lr, #reason_errordetails
                MOVEQ   r0, #msg_throwback_errorsin
                BL      stringonlymsg
                LDRVC   r0, [sp], #4
                ADDVS   sp, sp, #4
                LDMFD   sp!, {r3, r4}
                BVS     throwback_add_prefix1
                CMP     r0, #reason_processing
                LDMEQFD sp!, {pc}
                CMP     r0, #reason_infodetails
                MOVEQ   r0, #msg_throwback_infodetails
                MOVNE   r0, #msg_throwback_errordetails
                MOV     r1, r5
                BL      sendmessage
d1328 2
a1329 2
                LDMFD   sp!, {lr}
                B       xferv
d1334 40
a1373 36
                STMFD   sp!, {r0-r4, r9, lr}
                BL      checkactivetasks
                ADDVS   sp,sp,#4
                LDMVSFD sp!, {r1-r4, r9, pc}
                LDR     r9, receiver_id
                CMP     r9, #0
                LDMEQFD sp!, {r0-r4, r9, lr}
                BEQ     do_no_task

                BL      throwback_add_prefix

                B       throwback_vsret


; R0 = message id
; R1 = string       0 => no string
; R3 = line no     -1 => no line no
; R4 = error level -1 => no errorlevel
sendmessage     STMFD   sp!, {lr}
  [ DEBUG
                STMFD   sp!, {r0, r1, r2, r3}
                MOV     r3, r1
                SWI     os_writes
                DCB     4, "Message id = ", 0
                ADR     r1, hbuff
                MOV     r2, #12
                SWI     os_converthex8
                SWI     os_write0
                SWI     os_writes
                DCB     13, 10, 0
                MOV     r0, r3
                SWI     os_write0
                SWI     os_writes
                DCB     13, 10, 5, 0
                LDMFD   sp!, {r0, r1, r2, r3}
                B       %FT01
d1375 1
a1375 1
                %       256
d1378 59
a1436 57
                MOV     r2, r1
                MOVS    lr, r1
                BEQ     sendmessage2
sendmessage1    LDRB    r2, [lr], #1
                CMP     r2, #0
                BNE     sendmessage1
                SUB     r2, lr, r1
sendmessage2    ADD     r2, r2, #31
                BIC     r2, r2, #3
                MOV     lr, sp
                SUB     sp, sp, r2
                STR     r2, [sp]
                ADD     r2, sp, #12
                STMFD   sp!, {lr}
                MOV     lr, #0
                STR     lr, [r2], #4
                ADD     r0, r0, #ddeutils_msgbase_l
                ADD     r0, r0, #ddeutils_msgbase_h
                STR     r0, [r2], #4
                CMN     r3, #1
                STRNE   r3, [r2], #4
                CMN     r4, #1
                STRNE   r4, [r2], #4
                CMP     r1, #0
                BEQ     sendmessage4
sendmessage3    LDRB    lr, [r1], #1
                STRB    lr, [r2], #1
                CMP     lr, #0
                BNE     sendmessage3
sendmessage4    MOV     r0, #17
                ADD     r1, sp, #4
                MOV     r2, r9
;               IDJ/NK 4-Jan-95: AQU-00756 - truncate if message text too long
                LDR     lr, [r1]   ; length of msg
                CMP     lr, #256
                MOVGT   lr, #256
                STRGT   lr, [r1]   ; 256 is max size of msg
                MOVGT   lr, #0
                STRGTB  lr, [r1, #255]
                SWI     xwimp_sendmessage
                LDR     sp, [sp]
                LDMFD   sp!, {lr}
                B       xferv

initvar         STMFD   sp!, {r4, lr}
                MOV     r3, r1
initvar1        LDRB    r2, [r3], #1
                CMP     r2, #' '
                BCS     initvar1
                SUB     r2, r3, r1
                MOV     r3, #0
                MOV     r4, #0
                SWI     xos_setvarval
                LDMFD   sp!, {r4, pc}

                END

d1438 1
@


1.2
log
@32 bitified

Version 1.64. Tagged as 'DDEUtils-1_64'
@
text
@d117 2
d197 1
d474 2
a475 1
                MOVS    pc, r6
d508 1
a508 1
   CMP     r11,#11
d523 1
d853 1
a853 1
                LDRNE   lr, [sp, #8]     ;get real pass-on address from 26-bit veneer
d1074 17
d1244 1
a1244 1
                MOVS    pc, lr
@


1.1
log
@Initial revision
@
text
@d47 5
a51 1
LongFilenameLength EQU    1024
d169 3
a171 1
                DCD     0
d213 2
d231 1
a231 1
                MOVNES  pc,lr
d237 1
a237 1
                MOVNES  pc,lr
d244 1
a244 1
                MOVNES  pc, lr
d248 1
a248 1
                LDMFD   sp!, {r0, pc}^
d254 1
a254 1
                LDMFD   sp!, {r0, pc}^
d308 1
a308 5
   [ LongFilenames
                MOVVC   r3, #LongFilenameLength * 2
   |
                MOVVC   r3, #256
   ]
d318 10
a327 1
xferv           ORRVS   lr, lr, #overflow
a329 2
; JRF: I didn't write this - it /should/ release the handlers if something's
; up, but doesn't
d334 3
a336 1
                ADRL    r1, file_handler
d341 3
a343 1
                ADRL    r1, gbpb_handler
d348 3
a350 1
                ADRL    r1, find_handler
d355 3
a357 1
                ADRL    r1, fscontrol_handler
d364 1
a364 5
01
                MOV     r0, #n_fscontrolv
                ADRL    r1, fscontrol_handler
                SWI     xos_release
02
d366 3
a368 1
                ADRL    r1, find_handler
d372 3
a374 1
                ADRL    r1, gbpb_handler
d376 1
a376 1
04
d378 3
a380 1
                ADRL    r1, file_handler
d382 1
a382 1

d385 5
a389 1
                ORRS    pc,lr,#overflow
d399 1
a399 1
                TEQ     r0,#0     ; was it invalid ?
d402 1
a402 1
                LDMEQFD sp!, {pc}^ ; yes
d411 1
a411 1
                LDMFD   sp!, {pc}^
d416 2
a417 1
                LDMFD   sp!, {r0, pc}^
d449 3
a451 1
                ADRL    r1, file_handler
d454 3
a456 1
                ADR     r1, gbpb_handler
d459 3
a461 1
                ADR     r1, find_handler
d464 3
a466 1
                ADRL    r1, fscontrol_handler
d483 2
a484 2
		TEQ	r8, #0
		LDMEQFD	sp!, {r1, r2, r3, r8, pc}^
d487 1
a487 1
		TEQ	r11, r1, ror #16
d489 1
a489 1
		LDMEQFD	sp!, {r1, r2, r3, r8, pc}^
d494 1
d496 8
d527 1
a527 2
   LDMFD   sp!,{r1-r4,lr}
   ORRS    pc,lr,#overflow        ; set V flag and return
d551 1
a551 5
  [ LongFilenames
                MOV     r5,#LongFilenameLength
  |
                MOV     r5,#256
  ]
d589 1
a589 2
                LDMFD   sp!, {r1, r2, r3, r8, lr}
                ORRS    pc, lr, #overflow
d591 2
a592 2
do_swi2         MOVS    r0, r10
                LDMEQFD sp!, {r1, r2, r3, r8, pc}^
d595 1
a595 1
                LDMLOFD sp!, {r1, r2, r3, r8, pc}^
d604 1
a604 2
                LDMVSFD sp!, {r1, r2, r3, r8, lr}
                ORRVS   pc, lr, #overflow
d620 1
a620 1
                LDMFD   sp!, {r1, r2, r3, r8, pc}^
d622 1
a622 1
strip_hats      ORR     lr, lr, #carry
d634 4
a637 2
add_prefix      ORR     lr, lr, #carry
add_prefix0     STMFD   sp!, {r0, r1, r2, r3, r4, lr}
d697 4
d702 3
a704 4
                LDMFD   sp!, {r0, r1, r2, r3, r4, lr} ; FIXME
                BICS    lr, lr, #carry

strip_hats0     STMFD   sp!, {r0, r1, r2, r3, r4, lr}
d736 3
a738 3
                LDMFD   sp!, {r0, r1, r2, r3, r4, lr} ; FIXME
                BICS    lr, lr, #carry
                STMFD   sp!, {r0, r1, r2, r3, r4, lr}
d759 19
a777 1
                LDMFD   sp!, {r0, r1, r2, r3, r4, pc}^
d779 14
a792 3
find_handler    CMP     r0, #&40
                MOVCCS  pc, lr
                B       file_handler_external_entry
d794 2
a795 2
gbpb_handler    CMP     r0, #9
                MOVLOS  pc, lr
d797 13
a809 1
                MOVHSS  pc, lr
d815 1
a815 1
file_handler
d830 1
a830 1
file_handler
d846 8
a853 4
                STRCC   r1, [sp, #-4]!
                MOVCC   r1, r12
                STRCC   pc, [sp, #-4]!   ;store PC+8 (Architecture 4) or PC+12
                MOVS    pc, lr
d857 1
a857 3
                BIC     lr, lr, #carry
                ORRCS   lr, lr, #carry
                B       xferv
d864 11
a874 1
fscontrol_handler
d904 3
a906 1
                MOVS    pc, lr
d917 2
a918 1
                MOVS    pc, lr
d927 1
a927 1
                LDMEQFD sp!, {r0,pc}^
d931 1
a931 1
                LDMVCFD sp!, {r0,lr,pc}^
d933 1
a933 1
                LDMFD   sp!, {lr,pc}^
d936 2
a937 2
                TEQ     r2,#0
                MOVNES  pc,lr  ; only process if 'set CSD'
d943 2
a944 2
                TEQ     r0,#0
                LDMEQFD sp!, {r0,pc}^
d948 1
a948 1
                LDMVCFD sp!, {r0,lr,pc}^
d950 1
a950 1
                LDMFD   sp!, {lr,pc}^
d958 1
a958 1
                LDMEQFD sp!, {r0-r5,pc}^
d966 1
a966 1
                LDMVCFD sp!, {r0-r5,lr,pc}^
d979 1
a979 2
                STMFD   sp!, {r8, r9, r10, r11, lr, pc}  ;PC saved just as a placeholder here
                STR     pc, [sp, #20]                ;store PC+8 (Architecture 4) or PC+12
d985 1
a985 3
                BIC     lr, lr, #carry
                ORRCS   lr, lr, #carry
                B       xferv
a1003 3
                LDMEQFD sp!, {r8, r9, r10, r11, lr}
                ADDEQ   sp, sp, #12
                MOVEQS  pc, lr
d1014 1
a1014 5
   [ LongFilenames
                ADD     r11, r11, #LongFilenameLength
   |
                ADD     r11, r11, #128
   ]
d1023 5
a1027 1
                MOVS    pc, lr
d1033 1
a1033 5
   [ LongFilenames
                ADD     r11, r11, #LongFilenameLength
   |
                ADD     r11, r11, #128
   ]
d1041 1
a1041 1
                MOVS    pc, lr
d1049 1
a1049 1
                MOVEQS  pc, lr
d1076 1
a1076 2
                LDMVSFD sp!, {r1, r2, r3, lr}
                ORRVSS  pc, lr, #overflow
d1079 1
a1079 1
                LDMEQFD sp!, {r1, r2, r3, pc}^
d1095 8
d1108 1
a1108 2
                ADREQ   r0, no_cli_buffer_msg
                ORREQS  pc, lr, #overflow
d1119 1
a1119 1
                LDMFD   sp!, {r0, r1, pc}^
d1124 4
a1127 1
                ORRS    pc,lr,#overflow
d1164 1
a1164 1
                TEQ     r0, #0
d1166 13
a1178 3
                ADREQ   r0, not_desktop_msg
                ORREQS  pc, lr, #overflow
                BICNES  pc, lr, #overflow
d1189 1
a1189 2
                ADREQ   r0, no_task_msg
                ORREQS  pc, lr, #overflow
d1220 1
a1220 1
                ORRNES  pc, lr, #overflow
d1236 2
a1237 2
                ORRNES  pc, lr, #overflow
                MOVS    pc, lr
d1248 1
a1248 2
                ADREQ   r0, no_task_msg
                ORREQS  pc, lr, #overflow
d1272 1
a1272 1
                LDMEQFD sp!, {pc}^
d1292 1
a1292 2
                ADREQ   r0, no_task_msg
                ORREQS  pc, lr, #overflow
d1378 1
a1378 1
                LDMFD   sp!, {r4, pc}^
@


1.1.1.1
log
@  DDEUtils is now a separate component from RiscOS/Sources/SystemRes/System
Detail:
  DDEUtils does not really fit in System but should be its own component.
  It is now.
Admin:
  Exports a header that is required by the shared C library builds
    (currently only the one on the 32-bit branch)
  Version number incremented to 1.62
  Now uses srccommit for version number maintenance.

@
text
@@

head	1.3;
access;
symbols
	MemInfo-0_04:1.2
	MemInfo-0_03:1.1
	nicke_MemInfo_0_02:1.1
	afrost_NC2_Generic:1.1;
locks; strict;
comment	@# @;


1.3
date	98.10.28.13.23.45;	author smiddle;	state dead;
branches;
next	1.2;

1.2
date	98.10.28.13.04.25;	author smiddle;	state Exp;
branches;
next	1.1;

1.1
date	97.11.20.17.10.33;	author rbuckley;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Removed autogenerated header and fixed for clean build.

Version 0.05. Tagged as 'MemInfo-0_05'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Created by cmhg vsn 5.16 [18 Mar 1998]
 */

#ifndef __cmhg_header_h
#define __cmhg_header_h

#ifndef __kernel_h
#include "kernel.h"
#endif

#define CMHG_VERSION 516

#define Module_Title                     "MemInfo"
#define Module_Help                      "MemInfo"
#define Module_VersionString             "0.03"
#define Module_VersionNumber             3
#ifndef Module_Date
#define Module_Date                      "14 Sep 1998"
#endif


/*
 * Initialisation code
 * ===================
 *
 * Return NULL if your initialisation succeeds; otherwise return a pointer
 * to an error block. cmd_tail points to the string of arguments with which
 * the module is invoked (may be "", and is control-terminated, not zero
 * terminated).
 * podule_base is 0 unless the code has been invoked from a podule.
 * pw is the 'R12' value established by module initialisation. You may
 * assume nothing about its value (in fact it points to some RMA space
 * claimed and used by the module veneers). All you may do is pass it back
 * for your module veneers via an intermediary such as SWI OS_CallEvery
 * (use _swix() to issue the SWI call).
 */
_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw);


/*
 * Finalisation code
 * =================
 *
 * Return NULL if your finalisation succeeds. Otherwise return a pointer to
 * an error block if your finalisation handler does not wish to die (e.g.
 * toolbox modules return a 'Task(s) active' error).
 * fatal, podule and pw are the values of R10, R11 and R12 (respectively)
 * on entry to the finalisation code.
 */
_kernel_oserror *module_finalise(int fatal, int podule, void *pw);


/*
 * Command handler
 * ===============
 *
 * If cmd_no identifies a command, then arg_string gives the command tail
 * (which you may not overwrite), and argc is the number of parameters.
 * Return NULL if the command has been successfully handled; otherwise
 * return a pointer to an error block describing the failure (in this
 * case, the veneer code will set the 'V' bit).
 *
 * If cmd_no identifies a *Help entry, then arg_string denotes a buffer
 * that you can assemble your output into. cmd_handler must return
 * NULL, an error pointer or help_PRINT_BUFFER (if help_PRINT_BUFFER)
 * is returned, the zero-terminated buffer will be printed).
 *
 * If cmd_no identifies a *Configure option, then arg_string gives the
 * command tail, and argc the number of parameters. Return NULL, an error
 * pointer, or one of the four special values defined below. If arg_string
 * is set to arg_CONFIGURE_SYNTAX, the user has typed *Configure with no
 * parameter; simply print your syntax string. If arg_string is set to
 * arg_STATUS, print your current configured status. Otherwise use
 * arg_string and argc to set the *Configure option.
 *
 * pw is the private word pointer ('R12') value passed into the entry
 * veneer
 */
#define help_PRINT_BUFFER         ((_kernel_oserror *) arg_string)
#define arg_CONFIGURE_SYNTAX      ((char *) 0)
#define arg_STATUS                ((char *) 1)
#define configure_BAD_OPTION      ((_kernel_oserror *) -1)
#define configure_NUMBER_NEEDED   ((_kernel_oserror *) 1)
#define configure_TOO_LARGE       ((_kernel_oserror *) 2)
#define configure_TOO_MANY_PARAMS ((_kernel_oserror *) 3)

#define CMD_MemInfo_HTML                0
#define CMD_MemInfo_Text                1

_kernel_oserror *module_cmd_handler(const char *arg_string, int argc, int cmd_no, void *pw);

#endif
@


1.2
log
@Updated to fill in much more information about memory used
in the box. Should now mostly add up. Also uses the task manager
if it is about to get task information.

Version 0.04. Tagged as 'MemInfo-0_04'
@
text
@@


1.1
log
@Added for first time.
@
text
@d16 1
a16 1
 * Created by cmhg vsn 5.15 [Feb 14 1997]
d26 1
a26 1
#define CMHG_VERSION 515
d30 5
a34 3
#define Module_VersionString             "0.02"
#define Module_VersionNumber             2
#define Module_Date                      "08 Oct 1997"
d43 2
a44 1
 * the module is invoked (may be "").
d52 1
a52 1
_kernel_oserror *module_initialise(char *cmd_tail, int podule_base, void *pw);
d75 1
a75 1
 * return a pointer to an erro block describing the failure (in this
d81 1
a81 1
 * is returned, the NUL-terminated buffer will be printed).
d105 1
a105 1
_kernel_oserror *module_cmd_handler(char *arg_string, int argc, int cmd_no, void *pw);
@

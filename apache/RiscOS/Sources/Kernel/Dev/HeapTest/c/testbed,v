head	1.2;
access;
symbols
	Kernel-6_15:1.2
	Kernel-6_14:1.2
	Kernel-6_01-3:1.2
	Kernel-6_13:1.2
	Kernel-6_12:1.2
	Kernel-6_11:1.2
	Kernel-6_10:1.2
	Kernel-6_09:1.2
	Kernel-6_08-4_129_2_10:1.2
	Kernel-6_08-4_129_2_9:1.2
	Kernel-6_08:1.2
	Kernel-6_07:1.2
	Kernel-6_06:1.2
	Kernel-6_05-4_129_2_8:1.2
	Kernel-6_05:1.2
	Kernel-6_04:1.2
	Kernel-6_03:1.2
	Kernel-6_01-2:1.2
	Kernel-6_01-4_146_2_1:1.2
	Kernel-6_02:1.2
	Kernel-6_01-1:1.2
	Kernel-6_01:1.2
	Kernel-6_00:1.2
	Kernel-5_99:1.2
	Kernel-5_98:1.2
	Kernel-5_97-4_129_2_7:1.2
	Kernel-5_97:1.2
	Kernel-5_96:1.2
	Kernel-5_95:1.2
	Kernel-5_94:1.2
	Kernel-5_93:1.2
	Kernel-5_92:1.2
	Kernel-5_91:1.2
	Kernel-5_90:1.2
	Kernel-5_89-4_129_2_6:1.2
	Kernel-5_89:1.2
	Kernel-5_88-4_129_2_5:1.2
	Kernel-5_88-4_129_2_4:1.2
	Kernel-5_88:1.2
	Kernel-5_87:1.2
	Kernel-5_86-4_129_2_3:1.2
	Kernel-5_86-4_129_2_2:1.2
	Kernel-5_86-4_129_2_1:1.2
	Kernel-5_86:1.2
	SMP:1.2.0.2
	SMP_bp:1.2
	Kernel-5_85:1.2
	Kernel-5_54-1:1.2
	Kernel-5_84:1.2
	Kernel-5_83:1.2
	Kernel-5_82:1.2
	Kernel-5_81:1.2
	Kernel-5_80:1.2
	Kernel-5_79:1.2
	Kernel-5_78:1.2
	Kernel-5_77:1.2
	Kernel-5_76:1.2
	Kernel-5_75:1.2
	Kernel-5_74:1.2
	Kernel-5_73:1.2
	Kernel-5_72:1.2
	Kernel-5_71:1.2
	Kernel-5_70:1.2
	Kernel-5_69:1.2
	Kernel-5_68:1.2
	Kernel-5_67:1.2
	Kernel-5_66:1.2
	Kernel-5_65:1.2
	Kernel-5_64:1.2
	Kernel-5_63:1.2
	Kernel-5_62:1.2
	Kernel-5_61:1.2
	Kernel-5_60:1.2
	Kernel-5_59:1.2
	Kernel-5_58:1.2
	Kernel-5_57:1.2
	Kernel-5_56:1.2
	Kernel-5_55:1.2
	Kernel-5_54:1.2
	Kernel-5_53:1.2
	Kernel-5_52:1.2
	Kernel-5_51:1.2
	Kernel-5_50:1.2
	Kernel-5_49:1.2
	HAL_merge:1.1.2.2
	Kernel-5_48:1.2
	Kernel-5_35-4_79_2_327:1.1.2.2
	Kernel-5_35-4_79_2_326:1.1.2.2
	Kernel-5_35-4_79_2_325:1.1.2.2
	Kernel-5_35-4_79_2_324:1.1.2.2
	Kernel-5_35-4_79_2_323:1.1.2.2
	Kernel-5_35-4_79_2_322:1.1.2.2
	Kernel-5_35-4_79_2_321:1.1.2.2
	Kernel-5_35-4_79_2_320:1.1.2.2
	Kernel-5_35-4_79_2_319:1.1.2.2
	Kernel-5_35-4_79_2_318:1.1.2.2
	Kernel-5_35-4_79_2_317:1.1.2.2
	Kernel-5_35-4_79_2_316:1.1.2.2
	Kernel-5_35-4_79_2_315:1.1.2.2
	Kernel-5_35-4_79_2_314:1.1.2.2
	Kernel-5_35-4_79_2_313:1.1.2.2
	Kernel-5_35-4_79_2_312:1.1.2.2
	Kernel-5_35-4_79_2_311:1.1.2.2
	Kernel-5_35-4_79_2_310:1.1.2.2
	Kernel-5_35-4_79_2_309:1.1.2.2
	Kernel-5_35-4_79_2_308:1.1.2.2
	Kernel-5_35-4_79_2_307:1.1.2.2
	Kernel-5_35-4_79_2_306:1.1.2.2
	Kernel-5_35-4_79_2_305:1.1.2.2
	Kernel-5_35-4_79_2_304:1.1.2.2
	Kernel-5_35-4_79_2_303:1.1.2.2
	Kernel-5_35-4_79_2_302:1.1.2.2
	Kernel-5_35-4_79_2_301:1.1.2.2
	Kernel-5_35-4_79_2_300:1.1.2.2
	Kernel-5_35-4_79_2_299:1.1.2.2
	Kernel-5_35-4_79_2_298:1.1.2.2
	Kernel-5_35-4_79_2_297:1.1.2.2
	Kernel-5_35-4_79_2_296:1.1.2.2
	Kernel-5_35-4_79_2_295:1.1.2.2
	Kernel-5_35-4_79_2_294:1.1.2.2
	Kernel-5_35-4_79_2_293:1.1.2.2
	Kernel-5_35-4_79_2_292:1.1.2.2
	Kernel-5_35-4_79_2_291:1.1.2.2
	Kernel-5_35-4_79_2_290:1.1.2.2
	Kernel-5_35-4_79_2_289:1.1.2.2
	Kernel-5_35-4_79_2_288:1.1.2.2
	Kernel-5_35-4_79_2_287:1.1.2.2
	Kernel-5_35-4_79_2_286:1.1.2.2
	Kernel-5_35-4_79_2_285:1.1.2.2
	Kernel-5_35-4_79_2_284:1.1.2.2
	Kernel-5_35-4_79_2_283:1.1.2.2
	Kernel-5_35-4_79_2_282:1.1.2.2
	Kernel-5_35-4_79_2_281:1.1.2.2
	Kernel-5_35-4_79_2_280:1.1.2.2
	Kernel-5_35-4_79_2_279:1.1.2.2
	Kernel-5_35-4_79_2_278:1.1.2.2
	Kernel-5_35-4_79_2_277:1.1.2.2
	Kernel-5_35-4_79_2_276:1.1.2.2
	Kernel-5_35-4_79_2_275:1.1.2.2
	Kernel-5_35-4_79_2_274:1.1.2.2
	Kernel-5_35-4_79_2_273:1.1.2.2
	Kernel-5_35-4_79_2_272:1.1.2.2
	Kernel-5_35-4_79_2_271:1.1.2.2
	Kernel-5_35-4_79_2_270:1.1.2.2
	Kernel-5_35-4_79_2_269:1.1.2.2
	Kernel-5_35-4_79_2_268:1.1.2.2
	Kernel-5_35-4_79_2_267:1.1.2.2
	Kernel-5_35-4_79_2_266:1.1.2.2
	Kernel-5_35-4_79_2_265:1.1.2.2
	Kernel-5_35-4_79_2_264:1.1.2.2
	Kernel-5_35-4_79_2_263:1.1.2.2
	Kernel-5_35-4_79_2_262:1.1.2.2
	Kernel-5_35-4_79_2_261:1.1.2.2
	Kernel-5_35-4_79_2_260:1.1.2.2
	Kernel-5_35-4_79_2_259:1.1.2.2
	Kernel-5_35-4_79_2_258:1.1.2.2
	Kernel-5_35-4_79_2_257:1.1.2.2
	Kernel-5_35-4_79_2_256:1.1.2.2
	Kernel-5_35-4_79_2_255:1.1.2.2
	Kernel-5_35-4_79_2_254:1.1.2.2
	Kernel-5_35-4_79_2_253:1.1.2.2
	Kernel-5_35-4_79_2_252:1.1.2.2
	Kernel-5_35-4_79_2_251:1.1.2.2
	Kernel-5_35-4_79_2_250:1.1.2.2
	Kernel-5_35-4_79_2_249:1.1.2.2
	Kernel-5_35-4_79_2_248:1.1.2.2
	Kernel-5_35-4_79_2_247:1.1.2.2
	Kernel-5_35-4_79_2_246:1.1.2.2
	Kernel-5_35-4_79_2_245:1.1.2.2
	Kernel-5_35-4_79_2_244:1.1.2.2
	Kernel-5_35-4_79_2_243:1.1.2.2
	Kernel-5_35-4_79_2_242:1.1.2.2
	Kernel-5_35-4_79_2_241:1.1.2.2
	Kernel-5_35-4_79_2_240:1.1.2.2
	Kernel-5_35-4_79_2_239:1.1.2.2
	Kernel-5_35-4_79_2_238:1.1.2.2
	Kernel-5_35-4_79_2_237:1.1.2.2
	Kernel-5_35-4_79_2_236:1.1.2.2
	Kernel-5_35-4_79_2_235:1.1.2.2
	Kernel-5_35-4_79_2_234:1.1.2.2
	Kernel-5_35-4_79_2_233:1.1.2.2
	Kernel-5_35-4_79_2_232:1.1.2.2
	Kernel-5_35-4_79_2_231:1.1.2.2
	Kernel-5_35-4_79_2_230:1.1.2.2
	Kernel-5_35-4_79_2_229:1.1.2.2
	Kernel-5_35-4_79_2_228:1.1.2.2
	Kernel-5_35-4_79_2_227:1.1.2.2
	Kernel-5_35-4_79_2_226:1.1.2.2
	Kernel-5_35-4_79_2_225:1.1.2.2
	Kernel-5_35-4_79_2_224:1.1.2.2
	Kernel-5_35-4_79_2_223:1.1.2.2
	Kernel-5_35-4_79_2_222:1.1.2.2
	Kernel-5_35-4_79_2_221:1.1.2.2
	Kernel-5_35-4_79_2_220:1.1.2.2
	Kernel-5_35-4_79_2_219:1.1.2.2
	Kernel-5_35-4_79_2_218:1.1.2.2
	Kernel-5_35-4_79_2_217:1.1.2.2
	Kernel-5_35-4_79_2_216:1.1.2.2
	Kernel-5_35-4_79_2_215:1.1.2.2
	Kernel-5_35-4_79_2_214:1.1.2.2
	Kernel-5_35-4_79_2_213:1.1.2.2
	Kernel-5_35-4_79_2_212:1.1.2.2
	Kernel-5_35-4_79_2_211:1.1.2.2
	Kernel-5_35-4_79_2_210:1.1.2.2
	Kernel-5_35-4_79_2_209:1.1.2.2
	Kernel-5_35-4_79_2_208:1.1.2.2
	Kernel-5_35-4_79_2_207:1.1.2.2
	Kernel-5_35-4_79_2_206:1.1.2.2
	Kernel-5_35-4_79_2_205:1.1.2.2
	Kernel-5_35-4_79_2_204:1.1.2.2
	Kernel-5_35-4_79_2_203:1.1.2.2
	Kernel-5_35-4_79_2_202:1.1.2.2
	Kernel-5_35-4_79_2_201:1.1.2.2
	Kernel-5_35-4_79_2_200:1.1.2.2
	Kernel-5_35-4_79_2_199:1.1.2.2
	Kernel-5_35-4_79_2_198:1.1.2.2
	Kernel-5_35-4_79_2_197:1.1.2.2
	Kernel-5_35-4_79_2_196:1.1.2.2
	Kernel-5_35-4_79_2_195:1.1.2.2
	Kernel-5_35-4_79_2_194:1.1.2.2
	Kernel-5_35-4_79_2_193:1.1.2.2
	Kernel-5_35-4_79_2_192:1.1.2.2
	Kernel-5_35-4_79_2_191:1.1.2.2
	Kernel-5_35-4_79_2_190:1.1.2.2
	Kernel-5_35-4_79_2_189:1.1.2.2
	Kernel-5_35-4_79_2_188:1.1.2.2
	Kernel-5_35-4_79_2_187:1.1.2.2
	Kernel-5_35-4_79_2_186:1.1.2.2
	Kernel-5_35-4_79_2_185:1.1.2.2
	Kernel-5_35-4_79_2_184:1.1.2.2
	Kernel-5_35-4_79_2_183:1.1.2.2
	Kernel-5_35-4_79_2_182:1.1.2.2
	Kernel-5_35-4_79_2_181:1.1.2.2
	Kernel-5_35-4_79_2_180:1.1.2.2
	Kernel-5_35-4_79_2_179:1.1.2.2
	Kernel-5_35-4_79_2_178:1.1.2.2
	Kernel-5_35-4_79_2_177:1.1.2.2
	Kernel-5_35-4_79_2_176:1.1.2.2
	Kernel-5_35-4_79_2_175:1.1.2.2
	Kernel-5_35-4_79_2_174:1.1.2.2
	Kernel-5_35-4_79_2_173:1.1.2.2
	Kernel-5_35-4_79_2_172:1.1.2.2
	Kernel-5_35-4_79_2_171:1.1.2.2
	Kernel-5_35-4_79_2_170:1.1.2.2
	Kernel-5_35-4_79_2_169:1.1.2.2
	Kernel-5_35-4_79_2_168:1.1.2.2
	Kernel-5_35-4_79_2_167:1.1.2.2
	Kernel-5_35-4_79_2_166:1.1.2.2
	Kernel-5_35-4_79_2_165:1.1.2.2
	RPi_merge:1.1.2.2
	Kernel-5_35-4_79_2_147_2_23:1.1.2.2
	Kernel-5_35-4_79_2_147_2_22:1.1.2.2
	Kernel-5_35-4_79_2_147_2_21:1.1.2.2
	Kernel-5_35-4_79_2_147_2_20:1.1.2.2
	Kernel-5_35-4_79_2_147_2_19:1.1.2.2
	Kernel-5_35-4_79_2_147_2_18:1.1.2.2
	Kernel-5_35-4_79_2_164:1.1.2.2
	Kernel-5_35-4_79_2_163:1.1.2.2
	Kernel-5_35-4_79_2_147_2_17:1.1.2.2
	Kernel-5_35-4_79_2_147_2_16:1.1.2.2
	Kernel-5_35-4_79_2_147_2_15:1.1.2.2
	Kernel-5_35-4_79_2_162:1.1.2.2
	Kernel-5_35-4_79_2_161:1.1.2.2
	Kernel-5_35-4_79_2_147_2_14:1.1.2.2
	Kernel-5_35-4_79_2_147_2_13:1.1.2.2
	Kernel-5_35-4_79_2_160:1.1.2.2
	Kernel-5_35-4_79_2_159:1.1.2.2
	Kernel-5_35-4_79_2_158:1.1.2.2
	Kernel-5_35-4_79_2_157:1.1.2.2
	Kernel-5_35-4_79_2_156:1.1.2.2
	Kernel-5_35-4_79_2_147_2_12:1.1.2.2
	Kernel-5_35-4_79_2_147_2_11:1.1.2.2
	Kernel-5_35-4_79_2_155:1.1.2.2
	Kernel-5_35-4_79_2_147_2_10:1.1.2.2
	Kernel-5_35-4_79_2_154:1.1.2.2
	Kernel-5_35-4_79_2_153:1.1.2.2
	Kernel-5_35-4_79_2_147_2_9:1.1.2.2
	Kernel-5_35-4_79_2_152:1.1.2.2
	Kernel-5_35-4_79_2_151:1.1.2.2
	Kernel-5_35-4_79_2_147_2_8:1.1.2.2
	Kernel-5_35-4_79_2_147_2_7:1.1.2.2
	Kernel-5_35-4_79_2_150:1.1.2.2
	Kernel-5_35-4_79_2_147_2_6:1.1.2.2
	Kernel-5_35-4_79_2_147_2_5:1.1.2.2
	Kernel-5_35-4_79_2_149:1.1.2.2
	Kernel-5_35-4_79_2_147_2_4:1.1.2.2
	Kernel-5_35-4_79_2_147_2_3:1.1.2.2
	Kernel-5_35-4_79_2_148:1.1.2.2
	Kernel-5_35-4_79_2_147_2_2:1.1.2.2
	Kernel-5_35-4_79_2_147_2_1:1.1.2.2
	RPi:1.1.2.2.0.2
	RPi_bp:1.1.2.2
	Kernel-5_35-4_79_2_147:1.1.2.2
	Kernel-5_35-4_79_2_146:1.1.2.2
	Kernel-5_35-4_79_2_145:1.1.2.2
	Kernel-5_35-4_79_2_144:1.1.2.2
	Kernel-5_35-4_79_2_143:1.1.2.2
	Kernel-5_35-4_79_2_142:1.1.2.2
	Kernel-5_35-4_79_2_141:1.1.2.2
	Kernel-5_35-4_79_2_140:1.1.2.2
	Kernel-5_35-4_79_2_139:1.1.2.2
	Kernel-5_35-4_79_2_138:1.1.2.2
	Kernel-5_35-4_79_2_137:1.1.2.2
	Kernel-5_35-4_79_2_136:1.1.2.2
	Kernel-5_35-4_79_2_135:1.1.2.2
	Kernel-5_35-4_79_2_134:1.1.2.2
	Kernel-5_35-4_79_2_133:1.1.2.2
	Kernel-5_35-4_79_2_132:1.1.2.2
	Kernel-5_35-4_79_2_131:1.1.2.2
	Kernel-5_35-4_79_2_130:1.1.2.2
	Kernel-5_35-4_79_2_129:1.1.2.2
	Kernel-5_35-4_79_2_128:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


1.2
date	2016.06.30.20.07.20;	author jlee;	state Exp;
branches;
next	1.1;
commitid	IWoXxARWeuLDOwcz;

1.1
date	2011.12.10.19.03.37;	author jlee;	state dead;
branches
	1.1.2.1;
next	;
commitid	tEbdTPC2UwO3XFKv;

1.1.2.1
date	2011.12.10.19.03.37;	author jlee;	state Exp;
branches;
next	1.1.2.2;
commitid	tEbdTPC2UwO3XFKv;

1.1.2.2
date	2011.12.10.19.13.48;	author jlee;	state Exp;
branches;
next	;
commitid	SMXVpjgkaHiz0GKv;


desc
@@


1.2
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@/* Copyright 2011 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "Global/Heap.h"
#include "Global/NewErrors.h"

/* Whether to use the XOS_Heap SWI or the local copy of the heap code */
#define USE_LOCAL_OSHEAP

/* Maximum number of allocations to make */
#define MAX_ALLOCS 1024

#define VBIT (1<<28)

#ifdef USE_LOCAL_OSHEAP
extern _kernel_oserror *CallHeap(_kernel_swi_regs *r);
#else
#define CallHeap(R) _kernel_swi(OS_Heap,R,R)
#endif

/* Workspace */
static uint32_t *heap=NULL; /* Main heap */
static uint32_t *backup=NULL; /* Backup copy of heap */
static uint32_t allocsize=0; /* Heap memory block size */
static uint32_t *usedspace=NULL; /* Bitmap of used space; 1 bit per word */
static uint32_t seed=0; /* RNG seed */
static uint32_t sequence=0; /* Number of ops performed */
static uint32_t numblocks=0; /* Number of blocks currently allocated */
static uint32_t blocks[MAX_ALLOCS]; /* Offsets of blocks within heap */
static uint32_t currentop = 0; /* Current heap operation */
static uint32_t opsleft = 0; /* Number of ops left */
static _kernel_swi_regs r;
static _kernel_swi_regs last;

/* Utility functions */

static void init(void)
{
	srand(seed);
	printf("Seed %08x alloc size %08x\n",seed,allocsize);
	/* Make heap 4K aligned */
	heap = (uint32_t *) (((uint32_t) malloc(allocsize+4096)+4095)&0xfffff000);
	/* Same for backup */
	backup = (uint32_t *) (((uint32_t) malloc(allocsize+4096)+4095)&0xfffff000);
	/* Used space map */
	usedspace = (uint32_t *) malloc(((allocsize+31*4)>>7)<<2);
	memset(usedspace,0,((allocsize+31*4)>>7)<<2);
	memset(heap,0,allocsize);
	memset(backup,0,allocsize);
}

static uint32_t getrand(uint32_t max)
{
	uint64_t temp = ((uint64_t) max)*rand();
	return (uint32_t) (temp/RAND_MAX);
}

static void dumpheap(uint32_t *h)
{
	fprintf(stderr,"heap @@ %p:\nmag %x\nfree %x\nbase %x\nend %x\n",h,h[0],h[1],h[2],h[3]);
	uint32_t free = h[1];
	uint32_t next = 16;
	if(free)
		free += 4;
	while(free)
	{
		if(free > next)
		{
			fprintf(stderr,"allocs between %x and %x:\n",next,free);
			do {
				fprintf(stderr,"%x: alloc size %x\n",next,h[next>>2]);
				if((h[next>>2] > h[2]) || (h[next>>2]+next > h[2]) || (h[next>>2]&3) || !h[next>>2])
				{
					fprintf(stderr,"bad block, skipping rest\n");
					break;
				}
				next += h[next>>2];
			} while(free>next);
			if(free!=next)
				fprintf(stderr,"alloc mismatch! next=%x\n",next);
		}
		fprintf(stderr,"%x: free size %x next %x\n",free,h[(free+4)>>2],h[free>>2]);
		if(h[(free+4)>>2] == h[free>>2])
			fprintf(stderr,"consecutive free blocks!\n");
		next = free+h[(free+4)>>2];
		if((h[free>>2] & 3) || (h[free>>2] >= h[2]) || (h[free>>2]+free >= h[2]))
		{
			fprintf(stderr,"bad next ptr\n");
			return;
		}
		if((h[(free+4)>>2] & 3) || (h[(free+4)>>2] >= h[2]) || (h[(free+4)>>2]+free >= h[2]))
		{
			fprintf(stderr,"bad size\n");
			return;
		}
		if(!h[free>>2])
		{
			fprintf(stderr,"end of free list\n");
			break;
		}
		free = free+h[free>>2];
		if(free<next)
		{
			fprintf(stderr,"next free is inside current?\n");
			return;
		}
	}
	if(free > h[2])
	{
		fprintf(stderr,"free list extends beyond heap end\n");
	}
	if(next > h[2])
	{
		fprintf(stderr,"next ptr beyond heap end\n");
	}
	fprintf(stderr,"end allocs:\n");
	while(next < h[2])
	{
		fprintf(stderr,"%x: alloc size %x\n",next,h[next>>2]);
		if((h[next>>2] > h[2]) || (h[next>>2]+next > h[2]) || (h[next>>2]&3) || !h[next>>2])
		{
			fprintf(stderr,"bad block, skipping rest\n");
			return;
		}
		next += h[next>>2];
	}
	fprintf(stderr,"end\n");
}

static bool heapvalid(uint32_t *h)
{
	uint32_t free = h[1];
	uint32_t next = 16;
	if(free)
		free += 4;
	while(free)
	{
		if(free > next)
		{
			do {
				if((h[next>>2] > h[2]) || (h[next>>2]+next > h[2]) || (h[next>>2]&3) || !h[next>>2])
				{
					return false;
				}
				next += h[next>>2];
			} while(free>next);
			if(free!=next)
				return false;
		}
		if(h[(free+4)>>2] == h[free>>2])
			return false;
		next = free+h[(free+4)>>2];
		if((h[free>>2] & 3) || (h[free>>2] >= h[2]) || (h[free>>2]+free >= h[2]))
		{
			return false;
		}
		if((h[(free+4)>>2] & 3) || (h[(free+4)>>2] >= h[2]) || (h[(free+4)>>2]+free >= h[2]))
		{
			return false;
		}
		if(!h[free>>2])
		{
			break;
		}
		free = free+h[free>>2];
		if(free<next)
		{
			return false;
		}
	}
	if(free > h[2])
	{
		return false;
	}
	if(next > h[2])
	{
		return false;
	}
	while(next < h[2])
	{
		if((h[next>>2] > h[2]) || (h[next>>2]+next > h[2]) || (h[next>>2]&3) || !h[next>>2])
		{
			return false;
		}
		next += h[next>>2];
	}
	return true;
}

static void fail(void)
{
	fprintf(stderr,"Failed on sequence %d\n",sequence);
	fprintf(stderr,"Last op registers:\n");
	for(int i=0;i<5;i++)
		fprintf(stderr,"r%d = %08x\n",i,last.r[i]);
	fprintf(stderr,"Result registers:\n");
	for(int i=0;i<5;i++)
		fprintf(stderr,"r%d = %08x\n",i,r.r[i]);
	fprintf(stderr,"Heap before op:\n");
	dumpheap(backup);
	fprintf(stderr,"Heap after op:\n");
	dumpheap(heap);
	fprintf(stderr,"Allocated blocks:\n");
	for(uint32_t i=0;i<numblocks;i++)
	{
		fprintf(stderr,"%08x\n",blocks[i]);
	}
	exit(1);
}

static uint32_t blocksize(uint32_t offset)
{
	return heap[(offset-4)>>2];
}

static void tryuse(uint32_t offset)
{
	uint32_t len = blocksize(offset);
	if((len-4 > allocsize-offset) || (len & 3) || (len<4))
	{
		fprintf(stderr,"tryuse: Bad block at %08x\n",offset);
		fail();
	}
	offset >>= 2;
	while(len)
	{
		if(usedspace[offset>>5] & (1<<(offset&31)))
		{
			fprintf(stderr,"tryuse: Overlapping block at %08x\n",offset<<2);
			fail();
		}
		usedspace[offset>>5] |= 1<<(offset&31);
		offset++;
		len -= 4;
	}
}

static void tryfree(uint32_t offset)
{
	uint32_t len = blocksize(offset);
	if((len-4 > allocsize-offset) || (len & 3) || (len<4))
	{
		fprintf(stderr,"tryfree: Bad block at %08x\n",offset);
		fail();
	}
	offset >>= 2;
	while(len)
	{
		if(!(usedspace[offset>>5] & (1<<(offset&31))))
		{
			fprintf(stderr,"tryfree: Block at %08x already freed\n",offset<<2);
			fail();
		}
		usedspace[offset>>5] -= 1<<(offset&31);
		offset++;
		len -= 4;
	}
}

/* Main function */

int main(int argc,char **argv)
{
	_kernel_oserror *err;

	/* TODO - Take parameters from command line */
	_swix(OS_ReadMonotonicTime,_OUT(0),&seed);
	allocsize = 8*1024;

	init();

	/* Initialise heap */
	r.r[0] = HeapReason_Init;
	r.r[1] = (int) heap;
	r.r[3] = allocsize;
	err = CallHeap(&r);
	if(err)
	{
		fprintf(stderr,"Heap initialise failed! %s\n",err->errmess);
		exit(1);
	}
	usedspace[0] = 0xf;

	/* Begin tests */
	uint32_t temp,temp2,temp3,temp4;
	while(heapvalid(heap))
	{
		if(!opsleft)
		{
			opsleft = getrand(128);
			switch(getrand(4))
			{
			case 0:
				currentop = HeapReason_Get;
				break;
			case 1:
				currentop = HeapReason_Free;
				break;
			case 2:
				currentop = HeapReason_ExtendBlock;
				break;
			default:
				currentop = HeapReason_GetAligned;
				break;
			}
		}
		if(!(sequence&0xffff))
		{
//			printf(".");
			dumpheap(heap);
		}
		sequence++;
		r.r[0] = currentop;
		memcpy(backup,heap,allocsize);
		switch(currentop)
		{
		case HeapReason_Get:
			if(numblocks == MAX_ALLOCS)
			{
				opsleft = 0;
				break;
			}
			r.r[3] = temp = getrand(allocsize>>5)+1;
			last = r;
			err = CallHeap(&r);
			if(err)
			{
				if(err->errnum != ErrorNumber_HeapFail_Alloc)
				{
					fprintf(stderr,"Failed allocating %08x bytes: %s\n",temp,err->errmess);
					fail();
				}
			}
			else
			{
				temp2 = blocks[numblocks++] = r.r[2]-((uint32_t)heap);
				if(blocksize(temp2) < temp+4)
				{
					fprintf(stderr,"Failed to allocate requested block size: %08x bytes at %08x\n",temp,temp2);
					fail();
				}
				tryuse(temp2);
			}
			break;
		case HeapReason_Free:
			if(!numblocks)
			{
				opsleft = 0;
				break;
			}
			temp = getrand(numblocks);
			r.r[2] = blocks[temp]+((uint32_t) heap);
			tryfree(blocks[temp]); /* Must free beforehand */
			last = r;
			err = CallHeap(&r);
			if(err)
			{
				fprintf(stderr,"Failed freeing block at %08x: %s\n",blocks[temp],err->errmess);
				fail();
			}
			blocks[temp] = blocks[--numblocks];
			break;
		case HeapReason_ExtendBlock:
			if(!numblocks)
			{
				opsleft = 0;
				break;
			}
			temp = getrand(numblocks);
			r.r[2] = blocks[temp]+((uint32_t) heap);
			temp2 = getrand(allocsize>>4)-(allocsize>>5);
			r.r[3] = temp2;
			temp3 = blocksize(blocks[temp]);
			tryfree(blocks[temp]); /* Must free beforehand */
			last = r;
			err = CallHeap(&r);
			if(err)
			{
				if(err->errnum != ErrorNumber_HeapFail_Alloc)
				{
					fprintf(stderr,"Failed resizing block at %08x by %08x bytes: %s\n",blocks[temp],(int) temp2,err->errmess);
					fail();
				}
				if(blocksize(blocks[temp]) != temp3)
				{
					fprintf(stderr,"Resize failed but block size changed\n");
					fail();
				}
				tryuse(blocks[temp]);
			}
			else
			{
				if(r.r[2] && (r.r[2] != 0xffffffff))
				{
					if((int) (temp3+temp2) <= 4)
					{
						fprintf(stderr,"Resized block was kept when it should have been freed: block %08x by %08x\n",blocks[temp],(int) temp2);
						fail();
					}
					blocks[temp] = r.r[2]-((uint32_t)heap);
					tryuse(blocks[temp]);
					if((blocksize(blocks[temp])-(temp3+temp2)) > 7)
					{
						fprintf(stderr,"Failed to resize block by required amount: block %08x by %08x\n",blocks[temp],(int) temp2);
						fail();
					}
				}
				else
				{
					if((int) (temp3+temp2) > 4)
					{
						fprintf(stderr,"Resized block was freed when it should have remained: block %08x by %08x\n",blocks[temp],(int) temp2);
						fail();
					}
					blocks[temp] = blocks[--numblocks];
				}
			}
			break;
		case HeapReason_GetAligned:
			if(numblocks == MAX_ALLOCS)
			{
				opsleft = 0;
				break;
			}
			r.r[3] = temp = getrand(allocsize>>4)+1;
			temp2 = 4<<getrand(9); /* Max 2K alignment (heap 4K aligned) */
			temp3 = temp2*(1<<getrand(5));
			if(temp3 > 4096) /* Max 2K boundary (heap 4K aligned) */
				temp3 = 2048;
			if(temp3 < temp)
				temp3 = 0;
			r.r[2] = temp2;
			r.r[4] = temp3;
			last = r;
			err = CallHeap(&r);
			if(err)
			{
				if(err->errnum != ErrorNumber_HeapFail_Alloc)
				{
					fprintf(stderr,"Failed allocating %08x bytes at alignment %08x boundary %08x: %s\n",temp,temp2,temp3,err->errmess);
					fail();
				}
			}
			else
			{
				temp4 = blocks[numblocks++] = r.r[2]-((uint32_t) heap);
				if(blocksize(temp4) < temp+4)
				{
					fprintf(stderr,"Failed to allocate requested block size: %08x bytes at alignment %08x boundary %08x at %08x\n",temp,temp2,temp3,temp4);
					fail();
				}
				if(temp4 & (temp2-1))
				{
					fprintf(stderr,"Block allocated at wrong alignment: %08x bytes at alignment %08x boundary %08x at %08x\n",temp,temp2,temp3,temp4);
					fail();
				}
				if(temp3 && ((temp4 & ~(temp3-1)) != ((temp4+temp-1) & ~(temp3-1))))
				{
					fprintf(stderr,"Block crosses boundary: %08x bytes at alignment %08x boundary %08x at %08x\n",temp,temp2,temp3,temp4);
					fail();
				}
				tryuse(temp4);
			}
			break;
		}
		if(opsleft)
			opsleft--;
	}
	fprintf(stderr,"Heap corruption detected!\n");
	fail();
	return 0;
}
@


1.1
log
@file testbed was initially added on branch HAL.
@
text
@d1 494
@


1.1.2.1
log
@Improve heap manager. Add heap testbed. Add dummy implementation of some OS_ScreenMode reason codes.
Detail:
  s/HeapMan, hdr/KernelWS - Heap manager improvements:
    - Errors generated by interrupted heap operations that are forced to complete by a OS_Heap call from the background are now cached in kernel workspace until the foreground task is resumed. This prevents them from being potentially overwritten by MessageTrans running out of background error buffers.
    - Added new OS_Heap reason code, #7 - Get area aligned. This allows areas of memory to be allocated at specific (power-of-2) alignments, and optionally without crossing a given (power-of-2) boundary. Alignment & boundary calculations are performed using logical addresses.
    - Removed the limitation that all free and allocated blocks must be a multiple of 8 bytes in length. This change was required in order to allow OS_Heap 7 to function correctly. Now the only requirements are that blocks must be multiples of 4 bytes in length, at 4 byte alignment, with a minimum length of 8 bytes. 4 extra padding bytes may still be added to the end of allocations in order to avoid creating 4-byte free blocks.
  s/HeapMan, TestSrc/HeapTest/Makefile, TestSrc/HeapTest/c/testbed, TestSrc/HeapTest/s/asm - Added heap testbed program. Can either use the OS_Heap SWI or directly include a copy of the Kernel's heap manager sources.
  s/vdudecl, s/vduswis - Added dummy implementations of OS_ScreenMode 4, 5 and 6. This prevents the Wimp generating lots of "Unknown OS_ScreenMode reason code" errors when redrawing the screen.
  s/Arthur3, s/Oscli - Moved dotstring closer to where it's used to avoid "ADRL out of range" errors in Tungsten build
Admin:
  Tested in OMAP3 ROM & Tungsten ROM softload.
  Heap testbed successfully performed over 400 million heap ops, so there shouldn't be any serious bugs in the new code (touch wood)


Version 5.35, 4.79.2.128. Tagged as 'Kernel-5_35-4_79_2_128'
@
text
@a0 500
/* Copyright 2011 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* OS_Heap testbed code. Creates a heap and randomly allocates/deallocates/
   resizes blocks of memory to test for any bugs. Tests can either be performed
   using the OS_Heap SWI or by compiling a special version of the heap code
   from the kernel source folder (see USE_LOCAL_OSHEAP #define and s.asm)
*/   

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "Global/Heap.h"
#include "Global/NewErrors.h"

/* Whether to use the XOS_Heap SWI or the local copy of the heap code */
#define USE_LOCAL_OSHEAP

/* Maximum number of allocations to make */
#define MAX_ALLOCS 1024

#define VBIT (1<<28)

#ifdef USE_LOCAL_OSHEAP
extern _kernel_oserror *CallHeap(_kernel_swi_regs *r);
#else
#define CallHeap(R) _kernel_swi(OS_Heap,R,R)
#endif

/* Workspace */
static uint32_t *heap=NULL; /* Main heap */
static uint32_t *backup=NULL; /* Backup copy of heap */
static uint32_t allocsize=0; /* Heap memory block size */
static uint32_t *usedspace=NULL; /* Bitmap of used space; 1 bit per word */
static uint32_t seed=0; /* RNG seed */
static uint32_t sequence=0; /* Number of ops performed */
static uint32_t numblocks=0; /* Number of blocks currently allocated */
static uint32_t blocks[MAX_ALLOCS]; /* Offsets of blocks within heap */
static uint32_t currentop = 0; /* Current heap operation */
static uint32_t opsleft = 0; /* Number of ops left */
static _kernel_swi_regs r;
static _kernel_swi_regs last;

/* Utility functions */

static void init(void)
{
	srand(seed);
	printf("Seed %08x alloc size %08x\n",seed,allocsize);
	/* Make heap 4K aligned */
	heap = (uint32_t *) (((uint32_t) malloc(allocsize+4096)+4095)&0xfffff000);
	/* Same for backup */
	backup = (uint32_t *) (((uint32_t) malloc(allocsize+4096)+4095)&0xfffff000);
	/* Used space map */
	usedspace = (uint32_t *) malloc(((allocsize+31*4)>>7)<<2);
	memset(usedspace,0,((allocsize+31*4)>>7)<<2);
	memset(heap,0,allocsize);
	memset(backup,0,allocsize);
}

static uint32_t getrand(uint32_t max)
{
	uint64_t temp = ((uint64_t) max)*rand();
	return (uint32_t) (temp/RAND_MAX);
}

static void dumpheap(uint32_t *h)
{
	fprintf(stderr,"heap @@ %p:\nmag %x\nfree %x\nbase %x\nend %x\n",h,h[0],h[1],h[2],h[3]);
	uint32_t free = h[1];
	uint32_t next = 16;
	if(free)
		free += 4;
	while(free)
	{
		if(free > next)
		{
			fprintf(stderr,"allocs between %x and %x:\n",next,free);
			do {
				fprintf(stderr,"%x: alloc size %x\n",next,h[next>>2]);
				if((h[next>>2] > h[2]) || (h[next>>2]+next > h[2]) || (h[next>>2]&3) || !h[next>>2])
				{
					fprintf(stderr,"bad block, skipping rest\n");
					break;
				}
				next += h[next>>2];
			} while(free>next);
			if(free!=next)
				fprintf(stderr,"alloc mismatch! next=%x\n",next);
		}
		fprintf(stderr,"%x: free size %x next %x\n",free,h[(free+4)>>2],h[free>>2]);
		if(h[(free+4)>>2] == h[free>>2])
			fprintf(stderr,"consecutive free blocks!\n");
		next = free+h[(free+4)>>2];
		if((h[free>>2] & 3) || (h[free>>2] >= h[2]) || (h[free>>2]+free >= h[2]))
		{
			fprintf(stderr,"bad next ptr\n");
			return;
		}
		if((h[(free+4)>>2] & 3) || (h[(free+4)>>2] >= h[2]) || (h[(free+4)>>2]+free >= h[2]))
		{
			fprintf(stderr,"bad size\n");
			return;
		}
		if(!h[free>>2])
		{
			fprintf(stderr,"end of free list\n");
			break;
		}
		free = free+h[free>>2];
		if(free<next)
		{
			fprintf(stderr,"next free is inside current?\n");
			return;
		}
	}
	if(free > h[2])
	{
		fprintf(stderr,"free list extends beyond heap end\n");
	}
	if(next > h[2])
	{
		fprintf(stderr,"next ptr beyond heap end\n");
	}
	fprintf(stderr,"end allocs:\n");
	while(next < h[2])
	{
		fprintf(stderr,"%x: alloc size %x\n",next,h[next>>2]);
		if((h[next>>2] > h[2]) || (h[next>>2]+next > h[2]) || (h[next>>2]&3) || !h[next>>2])
		{
			fprintf(stderr,"bad block, skipping rest\n");
			return;
		}
		next += h[next>>2];
	}
	fprintf(stderr,"end\n");
}

static bool heapvalid(uint32_t *h)
{
	uint32_t free = h[1];
	uint32_t next = 16;
	if(free)
		free += 4;
	while(free)
	{
		if(free > next)
		{
			do {
				if((h[next>>2] > h[2]) || (h[next>>2]+next > h[2]) || (h[next>>2]&3) || !h[next>>2])
				{
					return false;
				}
				next += h[next>>2];
			} while(free>next);
			if(free!=next)
				return false;
		}
		if(h[(free+4)>>2] == h[free>>2])
			return false;
		next = free+h[(free+4)>>2];
		if((h[free>>2] & 3) || (h[free>>2] >= h[2]) || (h[free>>2]+free >= h[2]))
		{
			return false;
		}
		if((h[(free+4)>>2] & 3) || (h[(free+4)>>2] >= h[2]) || (h[(free+4)>>2]+free >= h[2]))
		{
			return false;
		}
		if(!h[free>>2])
		{
			break;
		}
		free = free+h[free>>2];
		if(free<next)
		{
			return false;
		}
	}
	if(free > h[2])
	{
		return false;
	}
	if(next > h[2])
	{
		return false;
	}
	while(next < h[2])
	{
		if((h[next>>2] > h[2]) || (h[next>>2]+next > h[2]) || (h[next>>2]&3) || !h[next>>2])
		{
			return false;
		}
		next += h[next>>2];
	}
	return true;
}

static void fail(void)
{
	fprintf(stderr,"Failed on sequence %d\n",sequence);
	fprintf(stderr,"Last op registers:\n");
	for(int i=0;i<5;i++)
		fprintf(stderr,"r%d = %08x\n",i,last.r[i]);
	fprintf(stderr,"Result registers:\n");
	for(int i=0;i<5;i++)
		fprintf(stderr,"r%d = %08x\n",i,r.r[i]);
	fprintf(stderr,"Heap before op:\n");
	dumpheap(backup);
	fprintf(stderr,"Heap after op:\n");
	dumpheap(heap);
	fprintf(stderr,"Allocated blocks:\n");
	for(uint32_t i=0;i<numblocks;i++)
	{
		fprintf(stderr,"%08x\n",blocks[i]);
	}
	exit(1);
}

static uint32_t blocksize(uint32_t offset)
{
	return heap[(offset-4)>>2];
}

static void tryuse(uint32_t offset)
{
	uint32_t len = blocksize(offset);
	if((len-4 > allocsize-offset) || (len & 3) || (len<4))
	{
		fprintf(stderr,"tryuse: Bad block at %08x\n",offset);
		fail();
	}
	offset >>= 2;
	while(len)
	{
		if(usedspace[offset>>5] & (1<<(offset&31)))
		{
			fprintf(stderr,"tryuse: Overlapping block at %08x\n",offset<<2);
			fail();
		}
		usedspace[offset>>5] |= 1<<(offset&31);
		offset++;
		len -= 4;
	}
}

static void tryfree(uint32_t offset)
{
	uint32_t len = blocksize(offset);
	if((len-4 > allocsize-offset) || (len & 3) || (len<4))
	{
		fprintf(stderr,"tryfree: Bad block at %08x\n",offset);
		fail();
	}
	offset >>= 2;
	while(len)
	{
		if(!(usedspace[offset>>5] & (1<<(offset&31))))
		{
			fprintf(stderr,"tryfree: Block at %08x already freed\n",offset<<2);
			fail();
		}
		usedspace[offset>>5] -= 1<<(offset&31);
		offset++;
		len -= 4;
	}
}

/* Main function */

int main(int argc,char **argv)
{
	_kernel_oserror *err;

	/* TODO - Take parameters from command line */
	_swix(OS_ReadMonotonicTime,_OUT(0),&seed)
	allocsize = 8*1024;

	init();

	/* Initialise heap */
	r.r[0] = HeapReason_Init;
	r.r[1] = (int) heap;
	r.r[3] = allocsize;
	err = CallHeap(&r);
	if(err)
	{
		fprintf(stderr,"Heap initialise failed! %s\n",err->errmess);
		exit(1);
	}
	usedspace[0] = 0xf;

	/* Begin tests */
	uint32_t temp,temp2,temp3,temp4;
	while(heapvalid(heap))
	{
		if(!opsleft)
		{
			opsleft = getrand(128);
			switch(getrand(4))
			{
			case 0:
				currentop = HeapReason_Get;
				break;
			case 1:
				currentop = HeapReason_Free;
				break;
			case 2:
				currentop = HeapReason_ExtendBlock;
				break;
			default:
				currentop = HeapReason_GetAligned;
				break;
			}
		}
		if(!(sequence&0xffff))
		{
//			printf(".");
			dumpheap(heap);
		}
		sequence++;
		r.r[0] = currentop;
		memcpy(backup,heap,allocsize);
		switch(currentop)
		{
		case HeapReason_Get:
			if(numblocks == MAX_ALLOCS)
			{
				opsleft = 0;
				break;
			}
			r.r[3] = temp = getrand(allocsize>>5)+1;
			last = r;
			err = CallHeap(&r);
			if(err)
			{
				if(err->errnum != ErrorNumber_HeapFail_Alloc)
				{
					fprintf(stderr,"Failed allocating %08x bytes: %s\n",temp,err->errmess);
					fail();
				}
			}
			else
			{
				temp2 = blocks[numblocks++] = r.r[2]-((uint32_t)heap);
				if(blocksize(temp2) < temp+4)
				{
					fprintf(stderr,"Failed to allocate requested block size: %08x bytes at %08x\n",temp,temp2);
					fail();
				}
				tryuse(temp2);
			}
			break;
		case HeapReason_Free:
			if(!numblocks)
			{
				opsleft = 0;
				break;
			}
			temp = getrand(numblocks);
			r.r[2] = blocks[temp]+((uint32_t) heap);
			tryfree(blocks[temp]); /* Must free beforehand */
			last = r;
			err = CallHeap(&r);
			if(err)
			{
				fprintf(stderr,"Failed freeing block at %08x: %s\n",blocks[temp],err->errmess);
				fail();
			}
			blocks[temp] = blocks[--numblocks];
			break;
		case HeapReason_ExtendBlock:
			if(!numblocks)
			{
				opsleft = 0;
				break;
			}
			temp = getrand(numblocks);
			r.r[2] = blocks[temp]+((uint32_t) heap);
			temp2 = getrand(allocsize>>4)-(allocsize>>5);
			r.r[3] = temp2;
			temp3 = blocksize(blocks[temp]);
			tryfree(blocks[temp]); /* Must free beforehand */
			last = r;
			err = CallHeap(&r);
			if(err)
			{
				if(err->errnum != ErrorNumber_HeapFail_Alloc)
				{
					fprintf(stderr,"Failed resizing block at %08x by %08x bytes: %s\n",blocks[temp],(int) temp2,err->errmess);
					fail();
				}
				if(blocksize(blocks[temp]) != temp3)
				{
					fprintf(stderr,"Resize failed but block size changed\n");
					fail();
				}
				tryuse(blocks[temp]);
			}
			else
			{
				if(r.r[2] && (r.r[2] != 0xffffffff))
				{
					if((int) (temp3+temp2) <= 4)
					{
						fprintf(stderr,"Resized block was kept when it should have been freed: block %08x by %08x\n",blocks[temp],(int) temp2);
						fail();
					}
					blocks[temp] = r.r[2]-((uint32_t)heap);
					tryuse(blocks[temp]);
					if((blocksize(blocks[temp])-(temp3+temp2)) > 7)
					{
						fprintf(stderr,"Failed to resize block by required amount: block %08x by %08x\n",blocks[temp],(int) temp2);
						fail();
					}
				}
				else
				{
					if((int) (temp3+temp2) > 4)
					{
						fprintf(stderr,"Resized block was freed when it should have remained: block %08x by %08x\n",blocks[temp],(int) temp2);
						fail();
					}
					blocks[temp] = blocks[--numblocks];
				}
			}
			break;
		case HeapReason_GetAligned:
			if(numblocks == MAX_ALLOCS)
			{
				opsleft = 0;
				break;
			}
			r.r[3] = temp = getrand(allocsize>>4)+1;
			temp2 = 4<<getrand(9); /* Max 2K alignment (heap 4K aligned) */
			temp3 = temp2*(1<<getrand(5));
			if(temp3 > 4096) /* Max 2K boundary (heap 4K aligned) */
				temp3 = 2048;
			if(temp3 < temp)
				temp3 = 0;
			r.r[2] = temp2;
			r.r[4] = temp3;
			last = r;
			err = CallHeap(&r);
			if(err)
			{
				if(err->errnum != ErrorNumber_HeapFail_Alloc)
				{
					fprintf(stderr,"Failed allocating %08x bytes at alignment %08x boundary %08x: %s\n",temp,temp2,temp3,err->errmess);
					fail();
				}
			}
			else
			{
				temp4 = blocks[numblocks++] = r.r[2]-((uint32_t) heap);
				if(blocksize(temp4) < temp+4)
				{
					fprintf(stderr,"Failed to allocate requested block size: %08x bytes at alignment %08x boundary %08x at %08x\n",temp,temp2,temp3,temp4);
					fail();
				}
				if(temp4 & (temp2-1))
				{
					fprintf(stderr,"Block allocated at wrong alignment: %08x bytes at alignment %08x boundary %08x at %08x\n",temp,temp2,temp3,temp4);
					fail();
				}
				if(temp3 && ((temp4 & ~(temp3-1)) != ((temp4+temp-1) & ~(temp3-1))))
				{
					fprintf(stderr,"Block crosses boundary: %08x bytes at alignment %08x boundary %08x at %08x\n",temp,temp2,temp3,temp4);
					fail();
				}
				tryuse(temp4);
			}
			break;
		}
		if(opsleft)
			opsleft--;
	}
	fprintf(stderr,"Heap corruption detected!\n");
	fail();
	return 0;
}
@


1.1.2.2
log
@Fix heap test compile errors
Detail:
  TestSrc/HeapTest/c/testbed - Added missing semicolon
  TestSrc/HeapTest/s/asm - Include Hdr:MsgTrans for XMessageTrans_CopyError
Admin:
  Now compiles and runs properly!


Version 5.35, 4.79.2.129. Tagged as 'Kernel-5_35-4_79_2_129'
@
text
@d16 6
d295 1
a295 1
	_swix(OS_ReadMonotonicTime,_OUT(0),&seed);
@



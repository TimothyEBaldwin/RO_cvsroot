head	4.5;
access;
symbols
	Kernel-6_14:4.5
	Kernel-6_01-3:4.5
	Kernel-6_13:4.5
	Kernel-6_12:4.5
	Kernel-6_11:4.5
	Kernel-6_10:4.5
	Kernel-6_09:4.5
	Kernel-6_08-4_129_2_10:4.5
	Kernel-6_08-4_129_2_9:4.5
	Kernel-6_08:4.5
	Kernel-6_07:4.5
	Kernel-6_06:4.5
	Kernel-6_05-4_129_2_8:4.5
	Kernel-6_05:4.5
	Kernel-6_04:4.5
	Kernel-6_03:4.5
	Kernel-6_01-2:4.5
	Kernel-6_01-4_146_2_1:4.5
	Kernel-6_02:4.5
	Kernel-6_01-1:4.5
	Kernel-6_01:4.5
	Kernel-6_00:4.5
	Kernel-5_99:4.5
	Kernel-5_98:4.5
	Kernel-5_97-4_129_2_7:4.5
	Kernel-5_97:4.5
	Kernel-5_96:4.5
	Kernel-5_95:4.5
	Kernel-5_94:4.5
	Kernel-5_93:4.5
	Kernel-5_92:4.5
	Kernel-5_91:4.5
	Kernel-5_90:4.5
	Kernel-5_89-4_129_2_6:4.5
	Kernel-5_89:4.5
	Kernel-5_88-4_129_2_5:4.5
	Kernel-5_88-4_129_2_4:4.5
	Kernel-5_88:4.5
	Kernel-5_87:4.5
	Kernel-5_86-4_129_2_3:4.5
	Kernel-5_86-4_129_2_2:4.5
	Kernel-5_86-4_129_2_1:4.5
	Kernel-5_86:4.5
	SMP:4.5.0.2
	SMP_bp:4.5
	Kernel-5_85:4.5
	Kernel-5_54-1:4.1
	Kernel-5_84:4.5
	Kernel-5_83:4.5
	Kernel-5_82:4.5
	Kernel-5_81:4.5
	Kernel-5_80:4.5
	Kernel-5_79:4.5
	Kernel-5_78:4.5
	Kernel-5_77:4.5
	Kernel-5_76:4.4
	Kernel-5_75:4.4
	Kernel-5_74:4.4
	Kernel-5_73:4.4
	Kernel-5_72:4.3
	Kernel-5_71:4.3
	Kernel-5_70:4.3
	Kernel-5_69:4.3
	Kernel-5_68:4.3
	Kernel-5_67:4.2
	Kernel-5_66:4.2
	Kernel-5_65:4.2
	Kernel-5_64:4.2
	Kernel-5_63:4.2
	Kernel-5_62:4.2
	Kernel-5_61:4.1
	Kernel-5_60:4.1
	Kernel-5_59:4.1
	Kernel-5_58:4.1
	Kernel-5_57:4.1
	Kernel-5_56:4.1
	Kernel-5_55:4.1
	Kernel-5_54:4.1
	Kernel-5_53:4.1
	Kernel-5_52:4.1
	Kernel-5_51:4.1
	Kernel-5_50:4.1
	Kernel-5_49:4.1
	HAL_merge:1.1.2.6
	Kernel-5_48:4.1
	Kernel-5_35-4_79_2_327:1.1.2.6
	Kernel-5_35-4_79_2_326:1.1.2.6
	Kernel-5_35-4_79_2_325:1.1.2.6
	Kernel-5_35-4_79_2_324:1.1.2.5
	Kernel-5_35-4_79_2_323:1.1.2.5
	Kernel-5_35-4_79_2_322:1.1.2.5
	Kernel-5_35-4_79_2_321:1.1.2.5
	Kernel-5_35-4_79_2_320:1.1.2.5
	Kernel-5_35-4_79_2_319:1.1.2.5
	Kernel-5_35-4_79_2_318:1.1.2.4
	Kernel-5_35-4_79_2_317:1.1.2.4
	Kernel-5_35-4_79_2_316:1.1.2.4
	Kernel-5_35-4_79_2_315:1.1.2.4
	Kernel-5_35-4_79_2_314:1.1.2.4
	Kernel-5_35-4_79_2_313:1.1.2.4
	Kernel-5_35-4_79_2_312:1.1.2.3
	Kernel-5_35-4_79_2_311:1.1.2.3
	Kernel-5_35-4_79_2_310:1.1.2.3
	Kernel-5_35-4_79_2_309:1.1.2.3
	Kernel-5_35-4_79_2_308:1.1.2.3
	Kernel-5_35-4_79_2_307:1.1.2.3
	Kernel-5_35-4_79_2_306:1.1.2.3
	Kernel-5_35-4_79_2_305:1.1.2.2
	Kernel-5_35-4_79_2_304:1.1.2.2
	Kernel-5_35-4_79_2_303:1.1.2.2
	Kernel-5_35-4_79_2_302:1.1.2.1
	Kernel-5_35-4_79_2_301:1.1.2.1
	Kernel-5_35-4_79_2_300:1.1.2.1
	Kernel-5_35-4_79_2_299:1.1.2.1
	Kernel-5_35-4_79_2_298:1.1.2.1
	Kernel-5_35-4_79_2_297:1.1.2.1
	Kernel-5_35-4_79_2_296:1.1.2.1
	Kernel-5_35-4_79_2_295:1.1.2.1
	Kernel-5_35-4_79_2_294:1.1.2.1
	Kernel-5_35-4_79_2_293:1.1.2.1
	Kernel-5_35-4_79_2_292:1.1.2.1
	Kernel-5_35-4_79_2_291:1.1.2.1
	Kernel-5_35-4_79_2_290:1.1.2.1
	Kernel-5_35-4_79_2_289:1.1.2.1
	Kernel-5_35-4_79_2_288:1.1.2.1
	Kernel-5_35-4_79_2_287:1.1.2.1
	Kernel-5_35-4_79_2_286:1.1.2.1
	Kernel-5_35-4_79_2_285:1.1.2.1
	Kernel-5_35-4_79_2_284:1.1.2.1
	Kernel-5_35-4_79_2_283:1.1.2.1
	Kernel-5_35-4_79_2_282:1.1.2.1
	Kernel-5_35-4_79_2_281:1.1.2.1
	Kernel-5_35-4_79_2_280:1.1.2.1
	Kernel-5_35-4_79_2_279:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


4.5
date	2017.02.09.20.43.10;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	g0y4kUhbpTcDOjFz;

4.4
date	2016.12.13.19.56.15;	author jlee;	state Exp;
branches;
next	4.3;
commitid	rSUxY3Nd3nP7qRxz;

4.3
date	2016.12.13.17.31.01;	author jlee;	state Exp;
branches;
next	4.2;
commitid	xwV3EbxXsXlhCQxz;

4.2
date	2016.10.17.20.52.44;	author jlee;	state Exp;
branches;
next	4.1;
commitid	duwVFka8P3V5zxqz;

4.1
date	2016.06.30.20.07.59;	author jlee;	state Exp;
branches;
next	1.1;
commitid	IWoXxARWeuLDOwcz;

1.1
date	2015.08.14.22.02.28;	author jlee;	state dead;
branches
	1.1.2.1;
next	;
commitid	6gyfvmM0cNZULhxy;

1.1.2.1
date	2015.08.14.22.02.28;	author jlee;	state Exp;
branches;
next	1.1.2.2;
commitid	6gyfvmM0cNZULhxy;

1.1.2.2
date	2016.02.28.17.00.46;	author rsprowson;	state Exp;
branches;
next	1.1.2.3;
commitid	rbz3PPhs8KbOJHWy;

1.1.2.3
date	2016.03.10.22.57.37;	author jlee;	state Exp;
branches;
next	1.1.2.4;
commitid	DAXUqMY2ucjim9Yy;

1.1.2.4
date	2016.04.05.19.36.32;	author jlee;	state Exp;
branches;
next	1.1.2.5;
commitid	8RLqvkae1X7wpt1z;

1.1.2.5
date	2016.05.19.21.03.46;	author jlee;	state Exp;
branches;
next	1.1.2.6;
commitid	7f3vfXP8BWCNt87z;

1.1.2.6
date	2016.05.24.22.04.53;	author jlee;	state Exp;
branches;
next	;
commitid	bFx0216wkidOEM7z;


desc
@@


4.5
log
@Expose CLREX via OS_PlatformFeatures
To account for ARM changing their minds about how to clear the exclusive lock on different architectures, provide a function pointer with a known good implementation. This is similar to the run of NOPs returned by OS_PlatformFeatures 0 for those that need it.
If in the future any errata or similar are needed, then there's only 1 place to change it, plus clients don't need their own CPU type detection logic.

Version 5.77. Tagged as 'Kernel-5_77'
@
text
@; Copyright 2015 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

; Miscellaneous public definitions that aren't important enough to pollute
; Hdr:RISCOS or to have their own header

; OS_PlatformFeatures reason codes

OSPlatformFeatures_ReadCodeFeatures     * 0
OSPlatformFeatures_ReadProcessorVectors * 32
OSPlatformFeatures_ReadCacheInfo        * 33
OSPlatformFeatures_ReadCPUFeatures      * 34
OSPlatformFeatures_ReadClearExclusive   * 35

; These flags are returned by OS_PlatformFeatures 0 (Read code features)

CPUFlag_SynchroniseCodeAreas    * 1:SHL:0       ; Calls to OS_SynchroniseCodeAreas required
CPUFlag_InterruptDelay          * 1:SHL:1       ; Clearing then setting I bit immediately doesn't trigger IRQs
CPUFlag_VectorReadException     * 1:SHL:2       ; 26-bit reads of hardware vectors abort
CPUFlag_StorePCplus8            * 1:SHL:3       ; Stores of R15 store PC+8 rather than PC+12
CPUFlag_BaseRestored            * 1:SHL:4       ; Base Restored abort model rather than Base Updated
CPUFlag_SplitCache              * 1:SHL:5       ; CPU has separate I and D caches
CPUFlag_32bitOS                 * 1:SHL:6       ; OS is 32-bit
CPUFlag_No26bitMode             * 1:SHL:7       ; CPU does not support 26-bit modes
CPUFlag_LongMul                 * 1:SHL:8       ; Has M extensions (UMULL etc)
CPUFlag_Thumb                   * 1:SHL:9       ; Supports Thumb
CPUFlag_DSP                     * 1:SHL:10      ; Has E extensions (QADD etc)
CPUFlag_NoSWP                   * 1:SHL:11      ; CPU does not support SWP/SWPB
CPUFlag_LoadStoreEx             * 1:SHL:12      ; Has LDR/STREX
CPUFlag_LoadStoreClearExSizes   * 1:SHL:13      ; Has CLREX and LDR/STREX[B|H|D]
CPUFlag_NoDCacheDisable         * 1:SHL:14      ; D-cache can't be disabled safely & OS_MMUControl won't allow it
CPUFlag_ExtendedPages           * 1:SHL:15      ; Supports extended small page L2 descriptors
CPUFlag_NoWBDrain               * 1:SHL:16      ; CPU does not support Drain Write Buffer instruction
CPUFlag_AbortRestartBroken      * 1:SHL:17      ; Aborts do not correctly follow documented abort model
CPUFlag_XScale                  * 1:SHL:18      ; it's an XScale, so weird debug etc
CPUFlag_XScaleJTAGconnected     * 1:SHL:19      ; JTAG has been connected
CPUFlag_HiProcVecs              * 1:SHL:20      ; High processor vectors are in use
CPUFlag_ExtraReasonCodesFixed   * 1:SHL:31      ; Bug causing unknown reason codes to always raise an error has been fixed (bug affected 3.7X, 5.XX, and CallASWI)

; OS_PlatformFeatures 34 flags:

                                ^ 0
CPUFeature_AESE_AESD_AESMC_AESIMC # 1
CPUFeature_BFC_BFI_SBFX_UBFX # 1
CPUFeature_BKPT # 1
CPUFeature_BLX # 1
CPUFeature_BX # 1
CPUFeature_CLREX_LDREXB_LDREXH_STREXB_STREXH # 1
CPUFeature_CLZ # 1
CPUFeature_CRC32B_CRC32H_CRC32W_CRC32CB_CRC32CH_CRC32CW # 1
CPUFeature_DMB_DSB_ISB # 1
CPUFeature_ERET_MSR_MRS_banked # 1
CPUFeature_HVC # 1
CPUFeature_Interworking_MOV_pc # 1
CPUFeature_LDAx_STLx # 1 ; LDAB, LDAH, LDA, LDAEXB, LDAEXH, LDAEX, LDAEXD, STLB, STLH, STL, STLEXB, STLEXH, STLEX, STLEXD
CPUFeature_LDM_STM_continuable # 1
CPUFeature_LDM_STM_noninterruptible # 1
CPUFeature_LDM_STM_restartable # 1
CPUFeature_LDRD_STRD # 1
CPUFeature_LDREXD_STREXD # 1
CPUFeature_LDREX_STREX # 1
CPUFeature_LDRHT_LDRSBT_LDRSHT_STRHT # 1
CPUFeature_LDRH_LDRSH_STRH # 1
CPUFeature_LDRSB # 1
CPUFeature_LDR_STR_Rd_Rn_restriction # 1 ; LDR/STR with writeback and Rd == Rn is not allowed. Applies to all load/store single instructions. 
CPUFeature_MLS # 1
CPUFeature_MOVW_MOVT # 1
CPUFeature_MRS_MSR # 1
CPUFeature_MUL_Rd_Rn_restriction # 1 ; MUL with Rd == Rn is not allowed. Applies to MUL, MLA, SMLAL, SMULL, UMLAL, UMULL
CPUFeature_MULS_flag_corruption # 1 ; MULS, MLAS corrupt C flag. SMLALS, SMULLS, UMLALS, UMULLS corrupt C & V flags.
CPUFeature_NOP_hints # 1
CPUFeature_PKHxy_xADD16_xADD8_xASX_xSUB16_xSUB8_xSAX_SEL # 1 ; PKHBT, PKHTB, QADD16, QADD8, QASX, QSUB16, QSUB8, QSAX, SADD16, SADD8, SASX, SEL, SHADD16, SHADD8, SHASX, SHSUB16, SHSUB8, SHSAX, SSAT16, SSUB16, SSUB8, SSAX, UADD16, UADD8, UASX, UHADD16, UADD8, UHASX, UHSUB16, UHSUB8, UHSAX, UQADD16, UQADD8, UQASX, UQSUB16, UQSUB8, UQSAX, USAD8, USADA8, USAT16, USUB16, USUB8, USAX
CPUFeature_PLD # 1
CPUFeature_PLDW # 1
CPUFeature_PLI # 1
CPUFeature_PSR_GE_bits # 1
CPUFeature_PSR_Q_bit # 1
CPUFeature_QADD_QDADD_QDSUB_QSUB # 1
CPUFeature_RBIT # 1
CPUFeature_REV_REV16_REVSH # 1
CPUFeature_SEVL # 1
CPUFeature_SHA1C_SHA1P_SHA1M_SHA1H_SHA1SU0_SHA1SU1 # 1
CPUFeature_SHA256H_SHA256H2_SHA256SU0_SHA256SU1 # 1
CPUFeature_SMC # 1
CPUFeature_SMLAxy_SMLALxy_SMLAWy_SMULxy_SMULWy # 1 ; SMLABB, SMLABT, SMLALBB, SMLALBT, SMLALTB, SMLALTT, SMLATB, SMLATT, SMLAWB, SMLAWT, SMULBB, SMULBT, SMULTB, SMULTT, SMULWB, SMULWT
CPUFeature_SMLAlDx_SMLSlDx_SMMLAr_SMMLSr_SMMULr_SMUADx_SMUSDx # 1 ; SMLAD, SMLADX, SMLALD, SMLALDX, SMLSD, SMLSDX, SMLSLD, SMLSLDX, SMMLA, SMMLAR, SMMLS, SMMLSR, SMMUL, SMMULR, SMUAD, SMUADX, SMUSD, SMUSDX
CPUFeature_SMULL_SMLAL # 1
CPUFeature_SRS_RFE_CPS # 1
CPUFeature_SSAT_USAT # 1
CPUFeature_SWP_SWPB # 1
CPUFeature_SWP_SWPB_uniproc # 1
CPUFeature_SXTAB_SXTAH_UXTAB_UXTAH # 1
CPUFeature_SXTB16_SXTAB16_UXTB16_UXTAB16 # 1
CPUFeature_SXTB_SXTH_UXTB_UXTH # 1
CPUFeature_SYS_mode # 1
CPUFeature_TEQP # 1 ; TEQP, TSTP, CMPP, CMNP
CPUFeature_UDIV_SDIV # 1
CPUFeature_UMAAL # 1
CPUFeature_UMULL_UMLAL # 1
CPUFeature_WFE # 1
CPUFeature_Rotated_loads # 1 ; CPU supports old-style rotated load behaviour
CPUFeature_Unaligned_loads # 1 ; CPU supports new-style unaligned load/store behaviour
CPUFeature_Max # 0

; OS_MMUControl reason codes

                                ^ 0
MMUCReason_ModifyControl        # 1
MMUCReason_Flush                # 1
MMUCReason_GetARMop             # 1
MMUCReason_Unknown              # 0

; These are the ARMops exposed by OS_MMUControl 2

                                  ^ 0
ARMop_Cache_CleanInvalidateAll    # 1 ; 0
ARMop_Cache_CleanAll              # 1 ; 1
ARMop_Cache_InvalidateAll         # 1 ; 2
ARMop_Cache_RangeThreshold        # 1 ; 3
ARMop_TLB_InvalidateAll           # 1 ; 4
ARMop_TLB_InvalidateEntry         # 1 ; 5
ARMop_DSB_ReadWrite               # 1 ; 6
ARMop_IMB_Full                    # 1 ; 7
ARMop_IMB_Range                   # 1 ; 8
ARMop_IMB_List                    # 1 ; 9
ARMop_MMU_Changing                # 1 ; 10
ARMop_MMU_ChangingEntry           # 1 ; 11
ARMop_MMU_ChangingUncached        # 1 ; 12
ARMop_MMU_ChangingUncachedEntry   # 1 ; 13
ARMop_MMU_ChangingEntries         # 1 ; 14
ARMop_MMU_ChangingUncachedEntries # 1 ; 15
ARMop_DSB_Write                   # 1 ; 16
ARMop_DSB_Read                    # 1 ; 17
ARMop_DMB_ReadWrite               # 1 ; 18
ARMop_DMB_Write                   # 1 ; 19
ARMop_DMB_Read                    # 1 ; 20
ARMop_Cache_CleanInvalidateRange  # 1 ; 21
; Not fully tested yet, so keep out of the public API
;ARMop_Cache_CleanRange            # 1 ; 22
;ARMop_Cache_InvalidateRange       # 1 ; 23
;ARMop_ICache_InvalidateAll        # 1 ; 24
;ARMop_ICache_InvalidateRange      # 1 ; 25
ARMop_Max                         # 0

; SeriousErrorV reason codes (R2)
                           ^ 0
SeriousErrorV_Collect      # 1 ; ABT mode, IRQ disabled (maybe FIQ disabled too), R0=reg dump, R1=(untranslated) error block
SeriousErrorV_Recover      # 1 ; SVC mode, IRQ disabled, R0=translated error block
SeriousErrorV_Report       # 1 ; SVC mode, IRQ enabled, R0=translated error block
SeriousErrorV_CustomReport # 1 ; SVC mode, IRQ enabled, R0=translated error, R1=flags, R3=callback function, R4=callback R0

SeriousErrorV_CustomReport_Annotated * 1 ; 1 => Produce annotated text dump
                                         ; 0 => Produce raw binary dump
; Have more flags to control which items are included in the annotated dump?

; Extended ROM footer entries
                                ^ 0
ExtROMFooter_BuildDate          # 1
ExtROMFooter_CompressedROMHints # 1
ExtROMFooter_DebugSymbols       # 1

        END
@


4.4
log
@Disable public use of new ARMops until ready
Detail:
  hdr/OSMisc, s/ARMops - Don't expose the new ARMops via OS_MMUControl 2, they haven't been fully tested/developed yet
Admin:
  Builds, untested


Version 5.73. Tagged as 'Kernel-5_73'
@
text
@d25 1
@


4.3
log
@Add new ARMops. Add macros which map the ARMv7/v8 cache/TLB maintenance mnemonics (as featured in recent ARM ARMs) to MCR ops.
Detail:
  - Docs/HAL/ARMop_API - Document the new ARMops. These ops are intended to help with future work (DMA without OS_Memory 0 "make temp uncacheable", and minimising cache maintenance when unmapping pages) and aren't in use just yet.
  - hdr/Copro15ops - Add new macros for ARMv7+ which map the mnemonics seen in recent ARM ARMs to the corresponding MCR ops. This should make things easier when cross-referencing docs and reduce the risk of typos.
  - hdr/KernelWS - Shuffle kernel workspace a bit to make room for the new ARMops
  - hdr/OSMisc - Expose new ARMops via OS_MMUControl 2
  - s/ARMops - Implement the new ARMops. Change the ARMv7+ ARMops to use the new mnemonic macros. Also get rid of myDSB / myISB usage from ARMv7+ code paths; use DSB/ISB/etc. directly to ensure correct behaviour
  - s/HAL - Mnemonic + ISB/DSB updates. Change software RAM clear to do 16 bytes at a time for kernel workspace instead of 32 to allow the kernel workspace tweaks to work.
Admin:
  Binary diff shows that mnemonics map to the original MCR ops correctly
  Note: Raspberry Pi builds will now emit lots of warnings due to increased DSB/ISB instruction use. However it should be safe to ignore these as they should only be present in v7+ code paths.
  Note: New ARMops haven't been tested yet, will be disabled (or at least hidden from user code) in a future checkin


Version 5.68. Tagged as 'Kernel-5_68'
@
text
@d149 5
a153 4
ARMop_Cache_CleanRange            # 1 ; 22
ARMop_Cache_InvalidateRange       # 1 ; 23
ARMop_ICache_InvalidateAll        # 1 ; 24
ARMop_ICache_InvalidateRange      # 1 ; 25
@


4.2
log
@Prevent disabling of the D-cache on Cortex-A53. Other OS_MMUControl 0 fixes.
Detail:
  On Cortex-A53, a load/store exclusive instruction will abort if it targets non-cacheable memory or if the D-cache is disabled. Since the correct operation of these instructions is important to the OS and apps, it makes sense to prevent *Cache Off / OS_MMUControl 0 from being able to disable the D-cache on such systems.
  hdr/OSMisc, s/ARMops - Add new OS_PlatformFeatures 0 flag to indicate when disabling of the D-cache isn't allowed
  s/VMSAv6 - Update MMUControl_ModifyControl to force the D-cache to always be on when the "unsafe to disable D-cache" PlatformFeatures flag is set. Also, disallow mismatched I+D cache settings if we have an L2 cache (causes issues due to IMB ops only flushing to PoU), and fix dangerous D-cache invalidation when it's only the I-cache which is being disabled
  s/ARM600 - Clean up MMUControl_ModifyControl a bit so that it's a closer match to the VMSAv6 version, and fix the dangerous D-cache invalidation.
Admin:
  Tested on ARM11, Cortex-A7, Cortex-A53


Version 5.62. Tagged as 'Kernel-5_62'
@
text
@d149 4
@


4.1
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@d42 1
@


1.1
log
@file OSMisc was initially added on branch HAL.
@
text
@d1 167
@


1.1.2.1
log
@Replace WriteBuffer_Drain ARMop with a suite of memory barrier ARMops
Detail:
  - Docs/HAL/ARMop_API - Updated with documentation for the new ARMops.
  - s/ARMops - Set up pointers for the new memory barrier ARMops. Add full implementations for ARMv6 & ARMv7; older architectures should be able to get by with a mix of null ops & write buffer drain ops. Update ARMopPtrTable to validate structure against the list in hdr/OSMisc
  - hdr/KernelWS - Reserve workspace for new ARMops. Free up a bit of space by limiting ourselves to 2 cache levels with ARMv7. Remove some unused definitions.
  - hdr/OSMisc - New header defining OS_PlatformFeatures & OS_MMUControl reason codes, OS_PlatformFeatures 0 flags, and OS_MMUControl 2 ARMop indices
  - Makefile - Add export rules for OSMisc header
  - hdr/ARMops, s/ARM600, s/VMSAv6 - Remove CPUFlag_* and MMUCReason_* definitions. Update OS_MMUControl write buffer drain to use DSB_ReadWrite ARMop (which is what most existing write buffer drain implementations have been renamed to).
  - s/GetAll - Get Hdr:OSMisc
  - s/Kernel - Use OS_PlatformFeatures reason code symbols
  - s/vdu/vdudecl - Remove unused definition
Admin:
  Tested on ARM11, Cortex-A8, Cortex-A9


Version 5.35, 4.79.2.279. Tagged as 'Kernel-5_35-4_79_2_279'
@
text
@a0 79
; Copyright 2015 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

; Miscellaneous public definitions that aren't important enough to pollute
; Hdr:RISCOS or to have their own header

; OS_PlatformFeatures reason codes

OSPlatformFeatures_ReadCodeFeatures     * 0
OSPlatformFeatures_ReadProcessorVectors * 32
OSPlatformFeatures_ReadCacheInfo        * 33

; These flags are returned by OS_PlatformFeatures 0 (Read code features)

CPUFlag_SynchroniseCodeAreas    * 1:SHL:0       ; Calls to OS_SynchroniseCodeAreas required
CPUFlag_InterruptDelay          * 1:SHL:1       ; Clearing then setting I bit immediately doesn't trigger IRQs
CPUFlag_VectorReadException     * 1:SHL:2       ; 26-bit reads of hardware vectors abort
CPUFlag_StorePCplus8            * 1:SHL:3       ; Stores of R15 store PC+8 rather than PC+12
CPUFlag_BaseRestored            * 1:SHL:4       ; Base Restored abort model rather than Base Updated
CPUFlag_SplitCache              * 1:SHL:5       ; CPU has separate I and D caches
CPUFlag_32bitOS                 * 1:SHL:6       ; OS is 32-bit
CPUFlag_No26bitMode             * 1:SHL:7       ; CPU does not support 26-bit modes
CPUFlag_LongMul                 * 1:SHL:8       ; Has M extensions (UMULL etc)
CPUFlag_Thumb                   * 1:SHL:9       ; Supports Thumb
CPUFlag_DSP                     * 1:SHL:10      ; Has E extensions (QADD etc)
CPUFlag_ExtendedPages           * 1:SHL:15      ; Supports extended small page L2 descriptors
CPUFlag_NoWBDrain               * 1:SHL:16      ; CPU does not support Drain Write Buffer instruction
CPUFlag_AbortRestartBroken      * 1:SHL:17      ; Aborts do not correctly follow documented abort model
CPUFlag_XScale                  * 1:SHL:18      ; it's an XScale, so weird debug etc
CPUFlag_XScaleJTAGconnected     * 1:SHL:19      ; JTAG has been connected
CPUFlag_HiProcVecs              * 1:SHL:20      ; High processor vectors are in use

; OS_MMUControl reason codes

                                ^ 0
MMUCReason_ModifyControl        # 1
MMUCReason_Flush                # 1
MMUCReason_GetARMop             # 1
MMUCReason_Unknown              # 0

; These are the ARMops exposed by OS_MMUControl 2

                                  ^ 0
ARMop_Cache_CleanInvalidateAll    # 1 ; 0
ARMop_Cache_CleanAll              # 1 ; 1
ARMop_Cache_InvalidateAll         # 1 ; 2
ARMop_Cache_RangeThreshold        # 1 ; 3
ARMop_TLB_InvalidateAll           # 1 ; 4
ARMop_TLB_InvalidateEntry         # 1 ; 5
ARMop_DSB_ReadWrite               # 1 ; 6
ARMop_IMB_Full                    # 1 ; 7
ARMop_IMB_Range                   # 1 ; 8
ARMop_IMB_List                    # 1 ; 9
ARMop_MMU_Changing                # 1 ; 10
ARMop_MMU_ChangingEntry           # 1 ; 11
ARMop_MMU_ChangingUncached        # 1 ; 12
ARMop_MMU_ChangingUncachedEntry   # 1 ; 13
ARMop_MMU_ChangingEntries         # 1 ; 14
ARMop_MMU_ChangingUncachedEntries # 1 ; 15
ARMop_DSB_Write                   # 1 ; 16
ARMop_DSB_Read                    # 1 ; 17
ARMop_DMB_ReadWrite               # 1 ; 18
ARMop_DMB_Write                   # 1 ; 19
ARMop_DMB_Read                    # 1 ; 20
ARMop_Max                         # 0

        END
@


1.1.2.2
log
@Define some extra platform feature flags
For disc based applications (ie. those that don't know the architecture at build time, like a ROM would) we have OS_PlatformFeatures to provide an abstract way of seeing when new chunks of instructions get added. Back at ARMv6 ARM deprecated SWP, but currently we have no way of knowing that at runtime without grubbing round the coprocessor registers.
Add 3 new flags
* One to say LDR/STREX is (not) available
* One to say that SWP/SWPB is (not) available
* One to say that CLREX and LDR/STREX[B|H|D] is (not) available
shame it took a few goes for ARM to bring in these variants, requiring 3 flags not 1.

Also:
Condition the exception on vector read code on No32bitCode, rather than just having it permanently disabled.
Improve the HAL device docs.

Tested on a StrongARM Risc PC, Model B Pi, and Titanium.

Version 5.35, 4.79.2.303. Tagged as 'Kernel-5_35-4_79_2_303'
@
text
@a37 3
CPUFlag_NoSWP                   * 1:SHL:11      ; CPU does not support SWP/SWPB
CPUFlag_LoadStoreEx             * 1:SHL:12      ; Has LDR/STREX
CPUFlag_LoadStoreClearExSizes   * 1:SHL:13      ; Has CLREX and LDR/STREX[B|H|D]
@


1.1.2.3
log
@Cache maintenance fixes
Detail:
  This set of changes tackles two main issues:
  * Before mapping out a cacheable page or making it uncacheable, the OS performs a cache clean+invalidate op. However this leaves a small window where data may be fetched back into the cache, either accidentally (dodgy interrupt handler) or via agressive prefetch (as allowed for by the architecture). This rogue data can then result in coherency issues once the pages are mapped out or made uncacheable a short time later.
    The fix for this is to make the page uncacheable before performing the cache maintenance (although this isn't ideal, as prior to ARMv7 it's implementation defined whether address-based cache maintenance ops affect uncacheable pages or not - and on ARM11 it seems that they don't, so for that CPU we currently force a full cache clean instead)
  * Modern ARMs generally ignore unexpected cache hits, so there's an interrupt hole in the current OS_Memory 0 "make temporarily uncacheable" implementation where the cache is being flushed after the page has been made uncacheable (consider the case of a page that's being used by an interrupt handler, but the page is being made uncacheable so it can also be used by DMA). As well as affecting ARMv7+ devices this was found to affect XScale (and ARM11, although untested for this issue, would have presumably suffered from the "can't clean uncacheable pages" limitation)
    The fix for this is to disable IRQs around the uncache sequence - however FIQs are currently not being dealt with, so there's still a potential issue there.
  File changes:
  - Docs/HAL/ARMop_API, hdr/KernelWS, hdr/OSMisc - Add new Cache_CleanInvalidateRange ARMop
  - s/ARM600, s/VMSAv6 - BangCam updated to make the page uncacheable prior to flushing the cache. Add GetTempUncache macro to help with calculating the page flags required for making pages uncacheable. Fix abort in OS_MMUControl on Raspberry Pi - MCR-based ISB was resetting ZeroPage pointer to 0
  - s/ARMops - Cache_CleanInvalidateRange implementations. PL310 MMU_ChangingEntry/MMU_ChangingEntries refactored to rely on Cache_CleanInvalidateRange_PL310, which should be a more optimal implementation of the cache cleaning code that was previously in MMU_ChangingEntry_PL310.
  - s/ChangeDyn - Rename FastCDA_UpFront to FastCDA_Bulk, since the cache maintenance is no longer performed upfront. CheckCacheabilityR0ByMinusR2 now becomes RemoveCacheabilityR0ByMinusR2. PMP LogOp implementation refactored quite a bit to perform cache/TLB maintenance after making page table changes instead of before. One flaw with this new implementation is that mapping out large areas of cacheable pages will result in multiple full cache cleans while the old implementation would have (generally) only performed one - a two-pass approach over the page list would be needed to solve this.
  - s/GetAll - Change file ordering so GetTempUncache macro is available earlier
  - s/HAL - ROM decompression changed to do full MMU_Changing instead of MMU_ChangingEntries, to make sure earlier cached data is truly gone from the cache. ClearPhysRAM changed to make page uncacheable before flushing cache.
  - s/MemInfo - OS_Memory 0 interrupt hole fix
  - s/AMBControl/memmap - AMB_movepagesout_L2PT now split into cacheable+non-cacheable variants. Sparse map out operation now does two passes through the page list so that they can all be made uncacheable prior to the cache flush + map out.
Admin:
  Tested on StrongARM, XScale, ARM11, Cortex-A7, Cortex-A9, Cortex-A15, Cortex-A53
  Appears to fix the major issues plaguing SATA on IGEPv5


Version 5.35, 4.79.2.306. Tagged as 'Kernel-5_35-4_79_2_306'
@
text
@a79 1
ARMop_Cache_CleanInvalidateRange  # 1 ; 21
@


1.1.2.4
log
@Add SWI error pointer validation, SeriousErrorV hooks, and OS_ReadSysInfo 15
Detail:
  Resources/UK/Messages, hdr/KernelWS, s/Kernel - On return from a SWI with V set, do some basic validity checks on the error pointer in order to try and catch buggy SWIs that return bad pointers or invalid error blocks. If a bad pointer is found we'll substitute it with a pointer to a different error block, which has the SWI number in the error message, to allow the user to identify the source of the problem. (There's also a chance we'll crash when investigating a bad pointer, but crashing here in the kernel is preferable to crashing elsewhere because R12 should still contain the SWI number)
  hdr/OSMisc - Define SeriousErrorV reason codes and extended ROM footer entry IDs
  hdr/Options - Remove HangWatch integration flag, obsolete now that SeriousErrorV is available
  s/ArthurSWIs - Keep defaultvectab up to date with vector allocations
  s/Middle - Update serious error handling to call SeriousErrorV at several key points. This allows for accurate crash dumps to be obtained, along with a mechanism to warn low-level components such as RTSupport that the privileged mode stacks are being flattened.
  s/Middle - Add OS_ReadSysInfo 15, for enumerating extended ROM footer entries
  s/PMF/osbyte - Update InitNewFX0Error to use the ROM footer entry ID defined in hdr/OSMisc
Admin:
  Tested on Pi 1B, 2B, 3B


Version 5.35, 4.79.2.313. Tagged as 'Kernel-5_35-4_79_2_313'
@
text
@a82 17
; SeriousErrorV reason codes (R2)
                           ^ 0
SeriousErrorV_Collect      # 1 ; ABT mode, IRQ disabled (maybe FIQ disabled too), R0=reg dump, R1=(untranslated) error block
SeriousErrorV_Recover      # 1 ; SVC mode, IRQ disabled, R0=translated error block
SeriousErrorV_Report       # 1 ; SVC mode, IRQ enabled, R0=translated error block
SeriousErrorV_CustomReport # 1 ; SVC mode, IRQ enabled, R0=translated error, R1=flags, R3=callback function, R4=callback R0

SeriousErrorV_CustomReport_Annotated * 1 ; 1 => Produce annotated text dump
                                         ; 0 => Produce raw binary dump
; Have more flags to control which items are included in the annotated dump?

; Extended ROM footer entries
                                ^ 0
ExtROMFooter_BuildDate          # 1
ExtROMFooter_CompressedROMHints # 1
ExtROMFooter_DebugSymbols       # 1

@


1.1.2.5
log
@Add new OS_PlatformFeatures reason code for reading CPU features (inspired by ARMv6+ CPUID scheme). Add OS_ReadSysInfo 8 flags for indicating the alignment mode the ROM was built with. Fix long-standing bug with OS_PlatformFeatures when an unknown reason code is used.
Detail:
  s/CPUFeatures, hdr/OSMisc, hdr/KernelWS - Code and definitions for reading CPU features and reporting them via OS_PlatformFeatures 34. All the instruction set features which are exposed by the CPUID scheme and which are relevant to RISC OS are exposed, along with a few extra flags which we derive ourselves (e.g. things relating to < ARMv4, and some register usage restrictions in instructions). s/CPUFeatures is designed to be easily copyable into a future version of CallASWI without requiring any changes.
  s/ARMops - Read and cache CPU features during ARMop initialisation
  s/GetAll - GET new file
  s/Kernel - Hook up the CPU features code to OS_PlatformFeatures. Fix a long standing stack imbalance bug (fixed in RISC OS 3.8, but never merged back to our main branch) which meant that calling OS_PlatformFeatures with an invalid reason code would raise an error, even if it was the X form of the SWI that was called. Similar fix also applied to the unused service call code, along with a fix for the user's R1-R9 being corrupt (shuffled up one place) should an error have been generated.
  s/MemInfo - Extra LTORG needed to keep things happy
  s/Middle - Extend OS_ReadSysInfo 8 to include flags for indicating what memory alignment mode (if any) the OS relies upon. Together with OS_PlatformFeatures 34 this could e.g. be used by !CPUSetup to determine which options should be offered to the user.
Admin:
  Tested on Raspberry Pi 1, 2, 3


Version 5.35, 4.79.2.319. Tagged as 'Kernel-5_35-4_79_2_319'
@
text
@a23 1
OSPlatformFeatures_ReadCPUFeatures      * 34
a47 65
; OS_PlatformFeatures 34 flags:

                                ^ 0
CPUFeature_AESE_AESD_AESMC_AESIMC # 1
CPUFeature_BFC_BFI_SBFX_UBFX # 1
CPUFeature_BKPT # 1
CPUFeature_BLX # 1
CPUFeature_BX # 1
CPUFeature_CLREX_LDREXB_LDREXH_STREXB_STREXH # 1
CPUFeature_CLZ # 1
CPUFeature_CRC32B_CRC32H_CRC32W_CRC32CB_CRC32CH_CRC32CW # 1
CPUFeature_DMB_DSB_ISB # 1
CPUFeature_ERET_MSR_MRS_banked # 1
CPUFeature_HVC # 1
CPUFeature_Interworking_MOV_pc # 1
CPUFeature_LDAx_STLx # 1 ; LDAB, LDAH, LDA, LDAEXB, LDAEXH, LDAEX, LDAEXD, STLB, STLH, STL, STLEXB, STLEXH, STLEX, STLEXD
CPUFeature_LDM_STM_continuable # 1
CPUFeature_LDM_STM_noninterruptible # 1
CPUFeature_LDM_STM_restartable # 1
CPUFeature_LDRD_STRD # 1
CPUFeature_LDREXD_STREXD # 1
CPUFeature_LDREX_STREX # 1
CPUFeature_LDRHT_LDRSBT_LDRSHT_STRHT # 1
CPUFeature_LDRH_LDRSH_STRH # 1
CPUFeature_LDRSB # 1
CPUFeature_LDR_STR_Rd_Rn_restriction # 1 ; LDR/STR with writeback and Rd == Rn is not allowed. Applies to all load/store single instructions. 
CPUFeature_MLS # 1
CPUFeature_MOVW_MOVT # 1
CPUFeature_MRS_MSR # 1
CPUFeature_MUL_Rd_Rn_restriction # 1 ; MUL with Rd == Rn is not allowed. Applies to MUL, MLA, SMLAL, SMULL, UMLAL, UMULL
CPUFeature_MULS_flag_corruption # 1 ; MULS, MLAS corrupt C flag. SMLALS, SMULLS, UMLALS, UMULLS corrupt C & V flags.
CPUFeature_NOP_hints # 1
CPUFeature_PKHxy_xADD16_xADD8_xASX_xSUB16_xSUB8_xSAX_SEL # 1 ; PKHBT, PKHTB, QADD16, QADD8, QASX, QSUB16, QSUB8, QSAX, SADD16, SADD8, SASX, SEL, SHADD16, SHADD8, SHASX, SHSUB16, SHSUB8, SHSAX, SSAT16, SSUB16, SSUB8, SSAX, UADD16, UADD8, UASX, UHADD16, UADD8, UHASX, UHSUB16, UHSUB8, UHSAX, UQADD16, UQADD8, UQASX, UQSUB16, UQSUB8, UQSAX, USAD8, USADA8, USAT16, USUB16, USUB8, USAX
CPUFeature_PLD # 1
CPUFeature_PLDW # 1
CPUFeature_PLI # 1
CPUFeature_PSR_GE_bits # 1
CPUFeature_PSR_Q_bit # 1
CPUFeature_QADD_QDADD_QDSUB_QSUB # 1
CPUFeature_RBIT # 1
CPUFeature_REV_REV16_REVSH # 1
CPUFeature_SEVL # 1
CPUFeature_SHA1C_SHA1P_SHA1M_SHA1H_SHA1SU0_SHA1SU1 # 1
CPUFeature_SHA256H_SHA256H2_SHA256SU0_SHA256SU1 # 1
CPUFeature_SMC # 1
CPUFeature_SMLAxy_SMLALxy_SMLAWy_SMULxy_SMULWy # 1 ; SMLABB, SMLABT, SMLALBB, SMLALBT, SMLALTB, SMLALTT, SMLATB, SMLATT, SMLAWB, SMLAWT, SMULBB, SMULBT, SMULTB, SMULTT, SMULWB, SMULWT
CPUFeature_SMLAlDx_SMLSlDx_SMMLAr_SMMLSr_SMMULr_SMUADx_SMUSDx # 1 ; SMLAD, SMLADX, SMLALD, SMLALDX, SMLSD, SMLSDX, SMLSLD, SMLSLDX, SMMLA, SMMLAR, SMMLS, SMMLSR, SMMUL, SMMULR, SMUAD, SMUADX, SMUSD, SMUSDX
CPUFeature_SMULL_SMLAL # 1
CPUFeature_SRS_RFE_CPS # 1
CPUFeature_SSAT_USAT # 1
CPUFeature_SWP_SWPB # 1
CPUFeature_SWP_SWPB_uniproc # 1
CPUFeature_SXTAB_SXTAH_UXTAB_UXTAH # 1
CPUFeature_SXTB16_SXTAB16_UXTB16_UXTAB16 # 1
CPUFeature_SXTB_SXTH_UXTB_UXTH # 1
CPUFeature_SYS_mode # 1
CPUFeature_TEQP # 1 ; TEQP, TSTP, CMPP, CMNP
CPUFeature_UDIV_SDIV # 1
CPUFeature_UMAAL # 1
CPUFeature_UMULL_UMLAL # 1
CPUFeature_WFE # 1
CPUFeature_Rotated_loads # 1 ; CPU supports old-style rotated load behaviour
CPUFeature_Unaligned_loads # 1 ; CPU supports new-style unaligned load/store behaviour
CPUFeature_Max # 0

@


1.1.2.6
log
@Add OS_PlatformFeatures 0 flag to indicate that the "Unknown OS_PlatformFeatures reason codes always raise an error" bug has been fixed
Detail:
  hdr/OSMisc - Use bit 31 to indicate that the error reporting bug has been fixed
  s/ARMops - Make sure the flag is set when preparing ProcessorFlags (i.e. the OS_PlatformFeatures 0 flags)
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.325. Tagged as 'Kernel-5_35-4_79_2_325'
@
text
@a47 1
CPUFlag_ExtraReasonCodesFixed   * 1:SHL:31      ; Bug causing unknown reason codes to always raise an error has been fixed (bug affected 3.7X, 5.XX, and CallASWI)
@



head	4.3;
access;
symbols
	HAL_merge:4.2
	Kernel-5_48:4.2
	Kernel-5_35-4_79_2_327:4.2
	Kernel-5_35-4_79_2_326:4.2
	Kernel-5_35-4_79_2_325:4.2
	Kernel-5_35-4_79_2_324:4.2
	Kernel-5_35-4_79_2_323:4.2
	Kernel-5_35-4_79_2_322:4.2
	Kernel-5_35-4_79_2_321:4.2
	Kernel-5_35-4_79_2_320:4.2
	Kernel-5_35-4_79_2_319:4.2
	Kernel-5_35-4_79_2_318:4.2
	Kernel-5_35-4_79_2_317:4.2
	Kernel-5_35-4_79_2_316:4.2
	Kernel-5_35-4_79_2_315:4.2
	Kernel-5_35-4_79_2_314:4.2
	Kernel-5_35-4_79_2_313:4.2
	Kernel-5_35-4_79_2_312:4.2
	Kernel-5_35-4_79_2_311:4.2
	Kernel-5_35-4_79_2_310:4.2
	Kernel-5_35-4_79_2_309:4.2
	Kernel-5_35-4_79_2_308:4.2
	Kernel-5_35-4_79_2_307:4.2
	Kernel-5_35-4_79_2_306:4.2
	Kernel-5_35-4_79_2_305:4.2
	Kernel-5_35-4_79_2_304:4.2
	Kernel-5_35-4_79_2_303:4.2
	Kernel-5_35-4_79_2_302:4.2
	Kernel-5_35-4_79_2_301:4.2
	Kernel-5_35-4_79_2_300:4.2
	Kernel-5_35-4_79_2_299:4.2
	Kernel-5_35-4_79_2_298:4.2
	Kernel-5_35-4_79_2_297:4.2
	Kernel-5_35-4_79_2_296:4.2
	Kernel-5_35-4_79_2_295:4.2
	Kernel-5_35-4_79_2_294:4.2
	Kernel-5_35-4_79_2_293:4.2
	Kernel-5_35-4_79_2_292:4.2
	Kernel-5_35-4_79_2_291:4.2
	Kernel-5_35-4_79_2_290:4.2
	Kernel-5_35-4_79_2_289:4.2
	Kernel-5_35-4_79_2_288:4.2
	Kernel-5_35-4_79_2_287:4.2
	Kernel-5_35-4_79_2_286:4.2
	Kernel-5_35-4_79_2_285:4.2
	Kernel-5_35-4_79_2_284:4.2
	Kernel-5_35-4_79_2_283:4.2
	Kernel-5_35-4_79_2_282:4.2
	Kernel-5_35-4_79_2_281:4.2
	Kernel-5_35-4_79_2_280:4.2
	Kernel-5_35-4_79_2_279:4.2
	Kernel-5_35-4_79_2_278:4.2
	Kernel-5_35-4_79_2_277:4.2
	Kernel-5_35-4_79_2_276:4.2
	Kernel-5_35-4_79_2_275:4.2
	Kernel-5_35-4_79_2_274:4.2
	Kernel-5_35-4_79_2_273:4.2
	Kernel-5_35-4_79_2_272:4.2
	Kernel-5_35-4_79_2_271:4.2
	Kernel-5_35-4_79_2_270:4.2
	Kernel-5_35-4_79_2_269:4.2
	Kernel-5_35-4_79_2_268:4.2
	Kernel-5_35-4_79_2_267:4.2
	Kernel-5_35-4_79_2_266:4.2
	Kernel-5_35-4_79_2_265:4.2
	Kernel-5_35-4_79_2_264:4.2
	Kernel-5_35-4_79_2_263:4.2
	Kernel-5_35-4_79_2_262:4.2
	Kernel-5_35-4_79_2_261:4.2
	Kernel-5_35-4_79_2_260:4.2
	Kernel-5_35-4_79_2_259:4.2
	Kernel-5_35-4_79_2_258:4.2
	Kernel-5_35-4_79_2_257:4.2
	Kernel-5_35-4_79_2_256:4.2
	Kernel-5_35-4_79_2_255:4.2
	Kernel-5_35-4_79_2_254:4.2
	Kernel-5_35-4_79_2_253:4.2
	Kernel-5_35-4_79_2_252:4.2
	Kernel-5_35-4_79_2_251:4.2
	Kernel-5_35-4_79_2_250:4.2
	Kernel-5_35-4_79_2_249:4.2
	Kernel-5_35-4_79_2_248:4.2
	Kernel-5_35-4_79_2_247:4.2
	Kernel-5_35-4_79_2_246:4.2
	Kernel-5_35-4_79_2_245:4.2
	Kernel-5_35-4_79_2_244:4.2
	Kernel-5_35-4_79_2_243:4.2
	Kernel-5_35-4_79_2_242:4.2
	Kernel-5_35-4_79_2_241:4.2
	Kernel-5_35-4_79_2_240:4.2
	Kernel-5_35-4_79_2_239:4.2
	Kernel-5_35-4_79_2_238:4.2
	Kernel-5_35-4_79_2_237:4.2
	Kernel-5_35-4_79_2_236:4.2
	Kernel-5_35-4_79_2_235:4.2
	Kernel-5_35-4_79_2_234:4.2
	Kernel-5_35-4_79_2_233:4.2
	Kernel-5_35-4_79_2_232:4.2
	Kernel-5_35-4_79_2_231:4.2
	Kernel-5_35-4_79_2_230:4.2
	Kernel-5_35-4_79_2_229:4.2
	Kernel-5_35-4_79_2_228:4.2
	Kernel-5_35-4_79_2_227:4.2
	Kernel-5_35-4_79_2_226:4.2
	Kernel-5_35-4_79_2_225:4.2
	Kernel-5_35-4_79_2_224:4.2
	Kernel-5_35-4_79_2_223:4.2
	Kernel-5_35-4_79_2_222:4.2
	Kernel-5_35-4_79_2_221:4.2
	Kernel-5_35-4_79_2_220:4.2
	Kernel-5_35-4_79_2_219:4.2
	Kernel-5_35-4_79_2_218:4.2
	Kernel-5_35-4_79_2_217:4.2
	Kernel-5_35-4_79_2_216:4.2
	Kernel-5_35-4_79_2_215:4.2
	Kernel-5_35-4_79_2_214:4.2
	Kernel-5_35-4_79_2_213:4.2
	Kernel-5_35-4_79_2_212:4.2
	Kernel-5_35-4_79_2_211:4.2
	Kernel-5_35-4_79_2_210:4.2
	Kernel-5_35-4_79_2_209:4.2
	Kernel-5_35-4_79_2_208:4.2
	Kernel-5_35-4_79_2_207:4.2
	Kernel-5_35-4_79_2_206:4.2
	Kernel-5_35-4_79_2_205:4.2
	Kernel-5_35-4_79_2_204:4.2
	Kernel-5_35-4_79_2_203:4.2
	Kernel-5_35-4_79_2_202:4.2
	Kernel-5_35-4_79_2_201:4.2
	Kernel-5_35-4_79_2_200:4.2
	Kernel-5_35-4_79_2_199:4.2
	Kernel-5_35-4_79_2_198:4.2
	Kernel-5_35-4_79_2_197:4.2
	Kernel-5_35-4_79_2_196:4.2
	Kernel-5_35-4_79_2_195:4.2
	Kernel-5_35-4_79_2_194:4.2
	Kernel-5_35-4_79_2_193:4.2
	Kernel-5_35-4_79_2_192:4.2
	Kernel-5_35-4_79_2_191:4.2
	Kernel-5_35-4_79_2_190:4.2
	Kernel-5_35-4_79_2_189:4.2
	Kernel-5_35-4_79_2_188:4.2
	Kernel-5_35-4_79_2_187:4.2
	Kernel-5_35-4_79_2_186:4.2
	Kernel-5_35-4_79_2_185:4.2
	Kernel-5_35-4_79_2_184:4.2
	Kernel-5_35-4_79_2_183:4.2
	Kernel-5_35-4_79_2_182:4.2
	Kernel-5_35-4_79_2_181:4.2
	Kernel-5_35-4_79_2_180:4.2
	Kernel-5_35-4_79_2_179:4.2
	Kernel-5_35-4_79_2_178:4.2
	Kernel-5_35-4_79_2_177:4.2
	Kernel-5_35-4_79_2_176:4.2
	Kernel-5_35-4_79_2_175:4.2
	Kernel-5_35-4_79_2_174:4.2
	Kernel-5_35-4_79_2_173:4.2
	Kernel-5_35-4_79_2_172:4.2
	Kernel-5_35-4_79_2_171:4.2
	Kernel-5_35-4_79_2_170:4.2
	Kernel-5_35-4_79_2_169:4.2
	Kernel-5_35-4_79_2_168:4.2
	Kernel-5_35-4_79_2_167:4.2
	Kernel-5_35-4_79_2_166:4.2
	Kernel-5_35-4_79_2_165:4.2
	RPi_merge:4.2
	Kernel-5_35-4_79_2_147_2_23:4.2
	Kernel-5_35-4_79_2_147_2_22:4.2
	Kernel-5_35-4_79_2_147_2_21:4.2
	Kernel-5_35-4_79_2_147_2_20:4.2
	Kernel-5_35-4_79_2_147_2_19:4.2
	Kernel-5_35-4_79_2_147_2_18:4.2
	Kernel-5_35-4_79_2_164:4.2
	Kernel-5_35-4_79_2_163:4.2
	Kernel-5_35-4_79_2_147_2_17:4.2
	Kernel-5_35-4_79_2_147_2_16:4.2
	Kernel-5_35-4_79_2_147_2_15:4.2
	Kernel-5_35-4_79_2_162:4.2
	Kernel-5_35-4_79_2_161:4.2
	Kernel-5_35-4_79_2_147_2_14:4.2
	Kernel-5_35-4_79_2_147_2_13:4.2
	Kernel-5_35-4_79_2_160:4.2
	Kernel-5_35-4_79_2_159:4.2
	Kernel-5_35-4_79_2_158:4.2
	Kernel-5_35-4_79_2_157:4.2
	Kernel-5_35-4_79_2_156:4.2
	Kernel-5_35-4_79_2_147_2_12:4.2
	Kernel-5_35-4_79_2_147_2_11:4.2
	Kernel-5_35-4_79_2_155:4.2
	Kernel-5_35-4_79_2_147_2_10:4.2
	Kernel-5_35-4_79_2_154:4.2
	Kernel-5_35-4_79_2_153:4.2
	Kernel-5_35-4_79_2_147_2_9:4.2
	Kernel-5_35-4_79_2_152:4.2
	Kernel-5_35-4_79_2_151:4.2
	Kernel-5_35-4_79_2_147_2_8:4.2
	Kernel-5_35-4_79_2_147_2_7:4.2
	Kernel-5_35-4_79_2_150:4.2
	Kernel-5_35-4_79_2_147_2_6:4.2
	Kernel-5_35-4_79_2_147_2_5:4.2
	Kernel-5_35-4_79_2_149:4.2
	Kernel-5_35-4_79_2_147_2_4:4.2
	Kernel-5_35-4_79_2_147_2_3:4.2
	Kernel-5_35-4_79_2_148:4.2
	Kernel-5_35-4_79_2_147_2_2:4.2
	Kernel-5_35-4_79_2_147_2_1:4.2
	RPi:4.2.0.12
	RPi_bp:4.2
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2
	alees_Kernel_dev:4.2.0.10
	alees_Kernel_dev_bp:4.2
	Kernel-5_35-4_79_2_147:4.2
	Kernel-5_35-4_79_2_146:4.2
	Kernel-5_35-4_79_2_145:4.2
	Kernel-5_35-4_79_2_144:4.2
	Kernel-5_35-4_79_2_143:4.2
	Kernel-5_35-4_79_2_142:4.2
	Kernel-5_35-4_79_2_141:4.2
	Kernel-5_35-4_79_2_140:4.2
	Kernel-5_35-4_79_2_139:4.2
	Kernel-5_35-4_79_2_138:4.2
	Kernel-5_35-4_79_2_137:4.2
	Kernel-5_35-4_79_2_136:4.2
	Kernel-5_35-4_79_2_135:4.2
	Kernel-5_35-4_79_2_134:4.2
	Kernel-5_35-4_79_2_133:4.2
	Kernel-5_35-4_79_2_132:4.2
	Kernel-5_35-4_79_2_131:4.2
	Kernel-5_35-4_79_2_130:4.2
	Kernel-5_35-4_79_2_129:4.2
	Kernel-5_35-4_79_2_128:4.2
	Kernel-5_35-4_79_2_127:4.2
	Kernel-5_35-4_79_2_126:4.2
	Kernel-5_35-4_79_2_125:4.2
	Kernel-5_35-4_79_2_124:4.2
	Kernel-5_35-4_79_2_123:4.2
	Cortex_merge:4.2
	Kernel-5_35-4_79_2_122:4.2
	Kernel-5_35-4_79_2_98_2_54:4.2
	Kernel-5_35-4_79_2_98_2_53:4.2
	Kernel-5_35-4_79_2_98_2_52:4.2
	Kernel-5_35-4_79_2_98_2_51:4.2
	Kernel-5_35-4_79_2_98_2_50:4.2
	Kernel-5_35-4_79_2_98_2_49:4.2
	Kernel-5_35-4_79_2_98_2_48:4.2
	Kernel-5_35-4_79_2_121:4.2
	Kernel-5_35-4_79_2_98_2_47:4.2
	Kernel-5_35-4_79_2_120:4.2
	Kernel-5_35-4_79_2_98_2_46:4.2
	Kernel-5_35-4_79_2_119:4.2
	Kernel-5_35-4_79_2_98_2_45:4.2
	Kernel-5_35-4_79_2_98_2_44:4.2
	Kernel-5_35-4_79_2_118:4.2
	Kernel-5_35-4_79_2_98_2_43:4.2
	Kernel-5_35-4_79_2_117:4.2
	Kernel-5_35-4_79_2_116:4.2
	Kernel-5_35-4_79_2_98_2_42:4.2
	Kernel-5_35-4_79_2_115:4.2
	Kernel-5_35-4_79_2_98_2_41:4.2
	Kernel-5_35-4_79_2_98_2_40:4.2
	Kernel-5_35-4_79_2_114:4.2
	Kernel-5_35-4_79_2_98_2_39:4.2
	Kernel-5_35-4_79_2_98_2_38:4.2
	Kernel-5_35-4_79_2_113:4.2
	Kernel-5_35-4_79_2_112:4.2
	Kernel-5_35-4_79_2_98_2_37:4.2
	Kernel-5_35-4_79_2_98_2_36:4.2
	Kernel-5_35-4_79_2_98_2_35:4.2
	Kernel-5_35-4_79_2_98_2_34:4.2
	Kernel-5_35-4_79_2_98_2_33:4.2
	Kernel-5_35-4_79_2_98_2_32:4.2
	Kernel-5_35-4_79_2_98_2_31:4.2
	Kernel-5_35-4_79_2_98_2_30:4.2
	Kernel-5_35-4_79_2_98_2_29:4.2
	Kernel-5_35-4_79_2_98_2_28:4.2
	Kernel-5_35-4_79_2_98_2_27:4.2
	Kernel-5_35-4_79_2_98_2_26:4.2
	Kernel-5_35-4_79_2_111:4.2
	Kernel-5_35-4_79_2_98_2_25:4.2
	Kernel-5_35-4_79_2_98_2_24:4.2
	Kernel-5_35-4_79_2_98_2_23:4.2
	Kernel-5_35-4_79_2_110:4.2
	Kernel-5_35-4_79_2_98_2_22:4.2
	Kernel-5_35-4_79_2_109:4.2
	Kernel-5_35-4_79_2_98_2_21:4.2
	Kernel-5_35-4_79_2_98_2_20:4.2
	Kernel-5_35-4_79_2_108:4.2
	Kernel-5_35-4_79_2_107:4.2
	Kernel-5_35-4_79_2_98_2_19:4.2
	Kernel-5_35-4_79_2_98_2_18:4.2
	Kernel-5_35-4_79_2_98_2_17:4.2
	Kernel-5_35-4_79_2_98_2_16:4.2
	Kernel-5_35-4_79_2_98_2_15:4.2
	Kernel-5_35-4_79_2_106:4.2
	Kernel-5_35-4_79_2_105:4.2
	Kernel-5_35-4_79_2_104:4.2
	Kernel-5_35-4_79_2_98_2_14:4.2
	Kernel-5_35-4_79_2_98_2_13:4.2
	Kernel-5_35-4_79_2_98_2_12:4.2
	Kernel-5_35-4_79_2_98_2_11:4.2
	Kernel-5_35-4_79_2_98_2_10:4.2
	Kernel-5_35-4_79_2_98_2_9:4.2
	Kernel-5_35-4_79_2_103:4.2
	Kernel-5_35-4_79_2_102:4.2
	Kernel-5_35-4_79_2_98_2_8:4.2
	Kernel-5_35-4_79_2_98_2_7:4.2
	Kernel-5_35-4_79_2_98_2_6:4.2
	Kernel-5_35-4_79_2_98_2_5:4.2
	Kernel-5_35-4_79_2_98_2_4:4.2
	Kernel-5_35-4_79_2_101:4.2
	Kernel-5_35-4_79_2_100:4.2
	Kernel-5_35-4_79_2_99:4.2
	Kernel-5_35-4_79_2_98_2_3:4.2
	Kernel-5_35-4_79_2_98_2_2:4.2
	Kernel-5_35-4_79_2_98_2_1:4.2
	Cortex:4.2.0.6
	Cortex_bp:4.2
	Kernel-5_35-4_79_2_98:4.2
	Kernel-5_35-4_79_2_97:4.2
	Kernel-5_35-4_79_2_96:4.2
	Kernel-5_35-4_79_2_95:4.2
	Kernel-5_35-4_79_2_94:4.2
	Kernel-5_35-4_79_2_93:4.2
	Kernel-5_35-4_79_2_92:4.2
	Kernel-5_35-4_79_2_91:4.2
	Kernel-5_35-4_79_2_90:4.2
	Kernel-5_35-4_79_2_89:4.2
	Kernel-5_35-4_79_2_88:4.2
	Kernel-5_35-4_79_2_87:4.2
	Kernel-5_35-4_79_2_86:4.2
	Kernel-5_35-4_79_2_85:4.2
	Kernel-5_35-4_79_2_84:4.2
	Kernel-5_35-4_79_2_83:4.2
	Kernel-5_35-4_79_2_82:4.2
	Kernel-5_35-4_79_2_81:4.2
	Kernel-5_35-4_79_2_80:4.2
	Kernel-5_35-4_79_2_79:4.2
	Kernel-5_35-4_79_2_78:4.2
	Kernel-5_35-4_79_2_77:4.2
	RO_5_07:4.2
	Kernel-5_35-4_79_2_76:4.2
	Kernel-5_35-4_79_2_75:4.2
	Kernel-5_35-4_79_2_74:4.2
	Kernel-5_35-4_79_2_73:4.2
	Kernel-5_35-4_79_2_72:4.2
	Kernel-5_35-4_79_2_71:4.2
	Kernel-5_35-4_79_2_70:4.2
	Kernel-5_35-4_79_2_69:4.2
	Kernel-5_35-4_79_2_68:4.2
	Kernel-5_35-4_79_2_67:4.2
	Kernel-5_35-4_79_2_66:4.2
	Kernel-5_35-4_79_2_65:4.2
	Kernel-5_35-4_79_2_64:4.2
	Kernel-5_35-4_79_2_63:4.2
	Kernel-5_35-4_79_2_62:4.2
	Kernel-5_35-4_79_2_61:4.2
	Kernel-5_35-4_79_2_59:4.2
	Kernel-5_35-4_79_2_58:4.2
	Kernel-5_35-4_79_2_57:4.2
	Kernel-5_35-4_79_2_56:4.2
	Kernel-5_35-4_79_2_55:4.2
	Kernel-5_35-4_79_2_54:4.2
	Kernel-5_35-4_79_2_53:4.2
	Kernel-5_35-4_79_2_52:4.2
	Kernel-5_35-4_79_2_51:4.2
	Kernel-5_35-4_79_2_50:4.2
	Kernel-5_35-4_79_2_49:4.2
	Kernel-5_35-4_79_2_48:4.2
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.8
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2
	Kernel-5_35-4_79_2_46:4.2
	Kernel-5_35-4_79_2_45:4.2
	Kernel-5_35-4_79_2_44:4.2
	Kernel-5_35-4_79_2_25_2_2:4.2
	Kernel-5_35-4_79_2_43:4.2
	Kernel-5_35-4_79_2_42:4.2
	Kernel-5_35-4_79_2_41:4.2
	Kernel-5_35-4_79_2_40:4.2
	Kernel-5_35-4_79_2_39:4.2
	Kernel-5_35-4_79_2_38:4.2
	Kernel-5_35-4_79_2_37:4.2
	Kernel-5_35-4_79_2_36:4.2
	Kernel-5_35-4_79_2_35:4.2
	Kernel-5_35-4_79_2_34:4.2
	Kernel-5_35-4_79_2_33:4.2
	Kernel-5_35-4_79_2_32:4.2
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2
	Kernel-5_35-4_79_2_30:4.2
	Kernel-5_35-4_79_2_29:4.2
	Kernel-5_35-4_79_2_28:4.2
	Kernel-5_35-4_79_2_27:4.2
	Kernel-5_35-4_79_2_26:4.2
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2
	Kernel-5_35-4_79_2_24:4.2
	Kernel-5_35-4_79_2_23:4.2
	Kernel-5_35-4_79_2_22:4.2
	Kernel-5_35-4_79_2_21:4.2
	Kernel-5_35-4_79_2_20:4.2
	Kernel-5_35-4_79_2_19:4.2
	Kernel-5_35-4_79_2_18:4.2
	Kernel-5_35-4_79_2_17:4.2
	Kernel-5_35-4_79_2_16:4.2
	Kernel-5_35-4_79_2_15:4.2
	Kernel-5_35-4_79_2_14:4.2
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.2
	Bethany:4.2.0.4
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2
	Kernel-5_35-4_79_2_12:4.2
	Kernel-5_35-4_79_2_11:4.2
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2
	Kernel-5_35-4_79_2_9:4.2
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2
	Kernel-5_35-4_79_2_7:4.2
	Kernel-5_35-4_79_2_6:4.2
	Kernel-5_35-4_79_2_5:4.2
	Kernel-5_35-4_79_2_4:4.2
	Kernel-5_35-4_79_2_3:4.2
	Kernel-5_35-4_79_2_2:4.2
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Kernel-5_21:4.2
	Kernel-5_20:4.2
	Kernel-5_19:4.2
	Kernel-5_18:4.2
	Kernel-5_17:4.2
	Kernel-5_16:4.2
	Kernel-5_15:4.2
	Kernel-5_14:4.2
	Kernel-5_13:4.2
	Kernel-5_12:4.2
	Kernel-5_11:4.2
	Kernel-5_10:4.2
	Kernel-5_09:4.2
	Kernel-5_08:4.2
	Kernel-5_07:4.2
	Kernel-5_06:4.2
	Kernel-5_05:4.2
	Kernel-5_04:4.2
	Kernel-5_03:4.2
	Kernel-5_02:4.2
	Kernel-5_01:4.2
	Kernel-5_00:4.2
	Kernel-4_99:4.2
	Kernel-4_98:4.2
	Kernel-4_97:4.2
	Kernel-4_96:4.2
	Kernel-4_95:4.2
	Kernel-4_94:4.2
	Kernel-4_93:4.2
	Kernel-4_92:4.2
	Kernel-4_91:4.2
	Kernel-4_90:4.2
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.2
	Kernel-4_88:4.2
	Kernel-4_87:4.2
	Kernel-4_86:4.2
	Kernel-4_85:4.2
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1
	Ursula_RiscPC_bp:4.1
	Kernel-4_83:4.2
	Kernel-4_82:4.2
	Kernel-4_81:4.2
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	Kernel-4_63-1_1_2_5:4.1.7.2
	Kernel-4_63-1_1_2_4:4.1.7.2
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.2
	Kernel-4_65:4.2
	Ursula_merge:4.1
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.1
	Kernel-4_63-1_1_2_2:4.1.7.2
	nicke_Kernel_4_62:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	nturton_v459:4.1.7.2
	nturton_v460:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	mstphens_Kernel-3_80:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	afrost_Boca-1_2-Beta:4.1.7.2
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2016.06.30.20.28.49;	author jlee;	state dead;
branches;
next	4.2;
commitid	lMnWzoE9eJz3Wwcz;

4.2
date	98.09.30.08.42.13;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.48;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.41.48;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.04.48;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.14.18;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.05.28;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.18.16.02.15;	author brice;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; > TestSrc.VIDC

        TTL RISC OS 2+ POST video controller
;
; The video outputs cannot be tested directly, and VIDC permits only
; write operations on its registers.
; This module performs two tests to verify VIDC's operation
;
;       - measure mode 0 FLBK period against IOC timer
;       - check that sound DMA occurs (MEMC reports DMA complete)
;
; This code contains timing loops affected by gross changes in processor
; speed, and will re-initialise MEMC with 4K pages and continous refresh.
;
;------------------------------------------------------------------------
; History
;
; Date          Name            Comment
; ----          ----            -------
; 18-Dec-89     ArtG            Initial version
; 04-Apr-90     ArtG            Use saved MEMC control register setting
; 20-Jun-93     ArtG            Medusa VIDC20 / IOMD changes
; 18-Nov-94     RCM             Morris changes
; 25 Feb 97     ???             ??
; 18 Mar 97     BAR             Change border colour from grey to black for
;                               IDC20 std. and vga definition tables.
;
;
;------------------------------------------------------------------------


VIDC_CLOCK_CONTROL      *       ts_S5_base :OR: &0048  ; Fox VIDC clock control
VIDC_CLOCK_NORMAL       *       &0

VIDC_VFLYWAIT           *       72000           ; 200mS timeout loop
VIDC_SOUNDWAIT          *       40000           ; 100mS  timeout loop

MEMC_Sstart             *       MEMCADR   :OR: &80000
MEMC_SendN              *       MEMCADR   :OR: &A0000
MEMC_Sptr               *       MEMCADR   :OR: &C0000
MEMC_Son                *                      &00800

ts_Soundbuf             *       &200            ; relative to PhysRam
ts_Soundbuf_length      *       &400

        [ VIDC_Type = "VIDC20"
VIDSTIM0                *       &A0000000       ; base VIDC20 register values
VIDSTIM1                *       &A1000000
VIDSFR                  *       &B0000000
VIDSCR                  *       &B1000005
VIDDMAoff               *       &94000024
VIDVCOWAIT              *       &5
VIDVCOFREQ              *       &D0000404
        |
VIDSTIM0                *       &60000000       ; base VIDC register values
VIDSTIM1                *       &64000000
VIDSFR                  *       &C0000100
        ]

        SUBT    FLBK period test
;
; This test attempts to validate the video timing system by checking for
; the proper period from the vertical flyback pulse. To make life easier,
; the test is performed only in mode 0 - i.e a 20mS period.
;
; This test contains a processor-clock timed loop as an outer limit :
; it assumes that the processor will never run more than a factor of ten
; faster than an 8Mhz ARM2.
; This is valid provided that this code isn't run with an ARM3 cache enabled.
;

; Initialise video clock control (for FOX)
; Initialise VIDC
; Clear IR interrupt request in IOC
; Poll IOC until IR appears (if ever)
; Set IOC timer 0 to 32 mS
; Clear IR interrupt request in IOC
; Poll IOC until IR appears (if ever)
; Check timer 0 has counted down 20 mS (19.8 - 20.2 mS)
; Return zero flag set on OK, clear on test failure.


ts_VIDC_period ROUT

        ; Initialise VIDC clock and VIDC

        [ VIDC_Type = "VIDC1a"
        LDR     r3, =VIDC_CLOCK_CONTROL         ;
        MOV     r1, #VIDC_CLOCK_NORMAL
        STRB    r1, [r3]
        ]

        MOV     r7, #0
        MOV     r1, #ts_VIDCPhys
        ADRL    r6, TestVIDCTAB
00      LDR     r0, [r6],#4                     ; setup using main table
        CMP     r0, #-1
        STRNE   r0, [r1]
        BNE     %BT00
01      LDR     r0, [r6],#4                     ; enable DMA using 2nd table
        CMP     r0, #-1
        STRNE   r0, [r1]
        BNE     %BT01

        ; Wait for the start of a flyback period

04
        LDR     r3, =IOC
        [ MEMC_Type = "IOMD"
        LDR     r1, [r6]                        ; get FSIZE value from end of TestVIDCTAB
        STR     r1, [r3, #IOMD_FSIZE]
        ]
        MOV     r1, #vsync_bit
        STRB    r1, [r3, #IOCIRQCLRA]
        LDR     r2, =VIDC_VFLYWAIT              ; long timeout loop - C 200mS

05      LDRB    r1, [r3, #IOCIRQSTAA]
        ANDS    r1, r1,  #vsync_bit
        BNE     %06
        SUBS    r2, r2,#1
        BNE     %05

        LDR     r0,=&fffff
        ORRS    r0, r0,r7, LSL #20              ; Failed : clear 0 flag
        MOV     pc, r14                         ; ... and quit

        ; Set up IOC timer 0
06
        LDR     r1, =(32 * 1000 * 2)            ; 32mS upper limit
        STRB    r1, [r3, #Timer0LL]
        MOV     r0, r1, LSR #8
        STRB    r0, [r3, #Timer0LH]
        MOV     r0, #0
        STRB    r0, [r3, #Timer0GO]             ; start the timer

        ; clear the IR and T0 bits

        MOV     r0, #(vsync_bit :OR: timer0_bit)
        STRB    r0, [r3,#IOCIRQCLRA]

        ; wait for what should be a complete vflyback period

10      LDR     r2, =VIDC_VFLYWAIT              ; timeout loop -  C 200 msec
11      LDRB    r0, [r3,#IOCIRQSTAA]
        TSTS    r0, #vsync_bit
        BNE     %14                             ; wait for end of vsync

        TSTS    r0, #timer0_bit                 ; or timer underflow
        BNE     %13

12      SUBS    r2, r2, #1                      ; or last-ditch timeout
        BNE     %11

13      ORRS    r0, r0,#1                       ; Failed : clear 0 flag
        MOV     r0, #0                          ; but return a zero
        MOV     pc, r14                         ; ... and quit

        ; finished in reasonable time : check against margins.

14      STRB    r0, [r3, #Timer0LR]             ; latch the current count
        LDRB    r2, [r3, #Timer0CL]
        LDRB    r0, [r3, #Timer0CH]
        ADD     r2, r2, r0, LSL #8

        SUB     r2, r1, r2
        MOV     r0, r2, LSR #1                  ; Vertical flyback time in uS

        LDR     r1, =19800                      ; inside limits ?
        SUBS    r2, r0, r1
        BLE     %F20

        LDR     r1, =400                        ; 19.8 -> 20.2 mS
        CMPS    r2, r1
        BGE     %F20
        MOV     r1,#0                           ; OK -  0 indicates pass

        ; After success using the 24MHz reference clock, select the
        ; VCO clock (also at 24MHz) and ensure the test is passed after
        ; a few cycles to allow the VCO to settle.

20
        [ VIDC_Type = "VIDC20"

        TEQ     r7,#0                           ; if this is the first loop ..
        BNE     %FT21
        TEQ     r1,#0                           ; and it passed OK ..
        BNE     %FT25
        MOV     r2,#ts_VIDCPhys
        LDR     r3,=VIDVCOFREQ                  ; set the vco to 24MHz
        LDR     r4,=&E0000400                   ; and use the vco clock
        STMIA   r2,{r3,r4}
        MOV     r7,#VIDVCOWAIT                  ; set the vco test loop count
        B       %BT04                           ; and run around again

21      ORR     r0,r0,r7,LSL #20
        SUBS    r7,r7,#1                        ; if all attempts now made
        BEQ     %FT25                           ; return final result
        TEQ     r1,#0                           ; else repeat until passed
        BNE     %BT04
        ]

        ; return with zero flag set if timers were OK
        ; measured time (in uS) in r0 if flyback was wrong,
        ; bits 20+ show fail loop - 0 for refclk, 1 for vcoclk.

25
        ORRS    r1,r1,r1
        MOV     pc, r14


        SUBT    Sound DMA test
;
; This test runs the sound DMA system to prove the operation of VIDC and
; MEMC's sound DMA control and the operation of the SIRQ sound DMA complete
; interrupt.
; To avoid making a noise, set the sound muting bit on.
;
; Initialise MEMC sound DMA
; Initialise VIDC sound channel
; Initialise timer 0 and timer 1 to guard-band 10mS sound duration
; Poll IOC until IL1 (SIRQ interrupt) becomes active
; Check timer 0 has completed and timer 1 has not
;

ts_SIRQ_period  ROUT

        ; set up MEMC to point to a buffer near the start of physical RAM,
        ; labelled in r9_fiq by the early memory size tests (not MemSize)
        ; Registers are set as (address / 16)
        ; Register bits are (register * 4) in VIDC address mask
        ; Hence values written to MEMC + register offset + (pointer / 4)


        [ MEMC_Type = "IOMD"
        MOV     r3,#IOMD_Base
        MOV     r0,#(IOMD_DMA_C_Bit :OR: IOMD_DMA_E_Bit :OR: 16)
        STR     r0,[r3,#IOMD_SD0CR]
        MOV_fiq r0,r9                   ; zero the DMA buffer
        ADD     r1,r0,#ts_Soundbuf_length
        MOV     r2,#0
02      STR     r2,[r0],#4
        CMPS    r0,r1
        BNE     %BT02
        |
        MOV_fiq r0,r11_fiq
        BIC     r0, r0, #MEMC_Son        ; ensure sound DMA disabled

        STR     r0, [r0]
        LDR     r1, =(MEMC_SendN :OR: ((ts_Soundbuf + ts_Soundbuf_length) / 4))
        STR     r1, [r1]
        LDR     r2, =(MEMC_Sstart :OR: (ts_Soundbuf / 4))
        STR     r2, [r2]
        LDR     r0, =MEMC_Sptr          ; initialise Sptr and set up again ..
        STR     r0, [r0]
        STR     r1, [r1]
        STR     r2, [r2]
        ]

        ; Set up VIDC for 8 channels, 10uS (/8) per sample

        LDR     r0, =ts_VIDCPhys
        [ VIDC_Type = "VIDC20"
        LDR     r1, =VIDSCR             ; VIDC10 mode, 24Mhz clock
        STR     r1, [r0]
        LDR     r1, =VIDDMAoff
        STR     r1, [r0]
        ]
        LDR     r1, =(VIDSTIM0 + 1)     ; channel 0 at 100% left
        LDR     r2, =((VIDSTIM1 - VIDSTIM0) + 1)
        MOV     r3, #7
05      STR     r1, [r0]                ; .. up to 6 at 100% right
        ADD     r1, r1, r2
        SUBS    r3, r3, #1
        BNE     %05
        SUB     r1, r1, #4              ; finally ch7 at centre again
        STR     r1, [r0]

        LDR     r1, =(VIDSFR + 8)       ; 10uS/byte
        STR     r1, [r0]

        ; Set up the timer to limit at 20 us (10uS/sample, 1024-16 bytes => 10.08 mS)

        LDR     r3, =IOC
        LDR     r1, =(20 * 1000 * 2)        ; 20 mS upper limit
        STRB    r1, [r3, #Timer1LL]
        MOV     r0, r1, LSR #8
        STRB    r0, [r3, #Timer1LH]

        MOV     r0, #-1
        STRB    r0, [r3, #IOCControl]           ; mute sound (on IOC system)
        STRB    r0, [r3, #Timer1GO]             ; start the timer

        [ MEMC_Type = "IOMD"
        MOV     r0, #(IOMD_DMA_E_Bit :OR: 16)   ; enable the IOMD DMA
        STR     r0, [r3,#IOMD_SD0CR]
        MOV_fiq r0,r9                           ; set the buffer pointers
        MOV     r4,#((ts_Soundbuf_length/2) - 16)
        STR     r0,[r3,#IOMD_SD0CURA]
        STR     r4,[r3,#IOMD_SD0ENDA]
        LDR     r2,[r3,#IOMD_SD0ST]
        ORR     r4,r4,#IOMD_DMA_S_Bit
        STR     r0,[r3,#IOMD_SD0CURB]
        STR     r4,[r3,#IOMD_SD0ENDB]
        |
        MOV_fiq r0, r11_fiq
        ORR     r0, r0, #MEMC_Son
        STR     r0, [r0]                        ; enable the MEMC1a DMA
        ]

        ; set long timeout, clear the IL1, T0 and T1 bits

        LDR     r2, =VIDC_SOUNDWAIT             ; lastditch timeout loop
        LDR     r0, =(timer0_bit :OR: timer1_bit)
        STRB    r0, [r3,#IOCIRQCLRA]


        ; Wait until sound DMA completes (or up to about 100 mS),
        ; then check timers.

10
        [ MEMC_Type = "IOMD"
        LDRB    r0,[r3, #IOMD_SD0ST]
        AND     r0, r0, #(IOMD_DMA_O_Bit :OR: IOMD_DMA_I_Bit)
        CMPS    r0, #(IOMD_DMA_O_Bit :OR: IOMD_DMA_I_Bit)
        BEQ     %12
        |
        LDRB    r0, [r3,#IOCIRQSTAB]
        ANDS    r0, r0, #sound_IRQ_bit
        BNE     %12
        ]
        LDR     r0, [r3, #IOCIRQSTAA]
        ANDS    r0, r0,#timer1_bit              ; timeout if timer 1 expires
        BNE     %11

        SUBS    r2, r2, #1                      ; or counter reaches zero
        BNE     %10

11      ORRS    r0, r0, #1                      ; Failed : clear 0 flag
        MOV     r2, #0                          ; return a timeout value of 0
        B       %15                             ; ... and quit

        ; finished in reasonable time : check time remaining in t1
        ; Time for DMA should be 10.24ms (1024 bytes at 10us/byte)
        ; less up to the time to use the final 16-byte transfer, 160us.

12      STRB    r0, [r3, #Timer1LR]             ; latch the current count
        LDRB    r2, [r3, #Timer1CL]
        LDRB    r0, [r3, #Timer1CH]
        ADD     r2, r2, r0, LSL #8

        SUB     r2, r1, r2
        MOV     r2, r2, LSR #1                  ; Sound DMA time in uS

        LDR     r1, =10030                      ; inside limits ?
        SUBS    r0, r2, r1
        BLE     %F13

        LDR     r1, =260                        ; 10.03  -> 10.29 mS
        CMPS    r0, r1
        MOVLT   r1,#0                           ; inside limits : set Z flag

13      ORRS    r1,r1,r1

        ; return with zero flag set if time (in r2) was within limits

15
        [ MEMC_Type = "IOMD"
        MOV     r0, #IOMD_DMA_C_Bit
        STR     r0, [r3,#IOMD_SD0CR]
        |
        BIC     r0, r0, #MEMC_Son
        STR     r0, [r0]
        ]
        MOV     r0, r2                          ; return the long time value
        MOV     pc, r14

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Data tables: VIDC := mode 0, all palette black

TestVIDCTAB

        [ VIDC_Type = "VIDC1a"

        & &00000000
        & &04000000
        & &08000000
        & &0C000000
        & &10000000
        & &14000000
        & &18000000
        & &1C000000
        & &20000000
        & &24000000
        & &28000000
        & &2C000000
        & &30000000
        & &34000000
        & &38000000
        & &3C000000
        & &40000000     ; Border -> black
        & &44000000     ; Cursor -> black
        & &48000000
        & &4C000000     ; Palette programmed (avoid messy screen on reset)
;
; standard mode 0 setup (except display area disabled)
;

        & &807FC000
        & &8408C000
        & &881B0000
        & &8C1EC000     ; HDSR
        & &906EC000     ; HDER
        & &94770000
        & &9C400000
        & &A04DC000
        & &A4008000
        & &A8050000     ; VBSR
        & &AC098000     ; VDSR
        & &B0000000     ; VDER < VDSR to disable screen DMA       B0000000
        & &B44DC000     ; VBER
        & &E00000B2
;
; Additional setup : cursor blanked, sound frequency test bit set
;
        & &C0000100     ; SFR  NB. TEST BIT! - also DFlynn requested value
        & &98258000     ; HCSR
        & &B8004000     ; VCSR
        & &BC400000     ; VCER
; don't mess with the stereo image registers: sound code will set them.
        & &FFFFFFFF     ; That's the lot

;
; Further registers to turn screen DMA on again (border all over)
; Must have a video start register before video end register to get
; a vertical flyback interrupt.
;
        & &B0494000     ; VDER > VDSR to enable screen DMA
        & &FFFFFFFF
        ]

        [ VIDC_Type = "VIDC20"

; This differs from the default RISC OS VIDCTAB in running from
; the 24MHZ video ref clock. H register contents are increased by 50%.

; Program Control Register first, to clear power-down bit

        & &E0000402     ; CR: FIFO load 16 words, 1 bpp, ck/1, rclk
        & &E0000402     ;
        & &B1000001     ; SCR: sound disabled (+use 24MHz clock)

; Don't bother programming all 256 palette entries, we'll be here all night
; Since we're setting up a 1 bit-per-pixel mode, just do colours 0 and 1

        & &10000000     ; Palette address register = 0
        & &00000000     ; Colour 0 = black
        & &00000000     ; Colour 1 = black
        & &40000000     ; Border colour = black(was grey &7F7F7F)
        & &50000000     ; Pointer colour 1 = black
        & &60000000     ; Pointer colour 2 = black
        & &70000000     ; Pointer colour 3 = black

; Get a stable display up so we get stable signals

        & &800005F8     ; HCR  = 114 + 132 + 144 + 960 + 144 + 42
        & &8100006A     ; HSWR = 114
        & &820000EA     ; HBSR = 114 + 132
        & &83000174     ; HDSR = 114 + 132 + 144
        & &84000534     ; HDER = 114 + 132 + 144 + 960
        & &850005CA     ; HBER = 114 + 132 + 144 + 960 + 144
        & &860000F3     ; HCSR = HDSR

        & &90000137     ; VCR  = 3 + 19 + 16 + 256 + 16 + 2
        & &91000002     ; VSWR = 3
        & &92000015     ; VBSR = 3 + 19
        & &93000025     ; VDSR = 3 + 19 + 16
        & &94000024     ; VDER = VDSR -1 to disable sceeen DMA
        & &95000135     ; VBER = 3 + 19 + 16 + 256 + 16
        & &96000025     ; VCSR = VDSR
        & &97000025     ; VCER = VDSR

        & &C00F1003     ; EREG = comp sync, DACs on, ereg output ext lut
        & &D000C385     ; FSYNREG, clk = (3+1)/(5+1) * 24MHz = 16MHz
        & &F0013000     ; DCR: bus D[31:0], Hdisc
        & &FFFFFFFF

        & &94000125     ; VDER > VDSR to enable screen DMA
        & &FFFFFFFF
                        ; FSIZE is one less than number of rasters in Vflyback
        & &00000037     ; (3 + 19 + 16 + 0 + 16 + 2) - 1

        ; Alternate settings for VGA monitor

TestVVIDCTAB
        & &E0000402     ; CR: FIFO load 16 words, 1 bpp, ck/1, rclk
        & &E0000402     ;
        & &B1000001     ; SCR: sound disabled (+use 24MHz clock)

        & &10000000     ; Palette address register = 0
        & &00000000     ; Colour 0 = black
        & &00000000     ; Colour 1 = black
        & &40000000     ; Border colour = black(was grey &7F7F7F)
        & &50000000     ; Pointer colour 1 = black
        & &60000000     ; Pointer colour 2 = black
        & &70000000     ; Pointer colour 3 = black

        & &80000310     ; HCR  = 92 + 45 + 0 + 640 + 0 + 16
        & &81000054     ; HSWR = 92
        & &82000080     ; HBSR = 92 + 45
        & &83000080     ; HDSR = 92 + 45 + 0
        & &84000300     ; HDER = 92 + 45 + 0 + 640
        & &85000300     ; HBER = 92 + 45 + 0 + 640 + 0
        & &86000080     ; HCSR = HDSR

        & &9000020B     ; VCR  = 2 + 32 + 0 + 480 + 0 + 11
        & &91000001     ; VSWR = 2
        & &92000021     ; VBSR = 2 + 32
        & &93000021     ; VDSR = 2 + 32 + 0
        & &94000020     ; VDER = VDSR -1 to disable sceeen DMA
        & &95000201     ; VBER = 2 + 32 + 0 + 480 + 0
        & &96000021     ; VCSR = VDSR
        & &97000021     ; VCER = VDSR

        & &C0051003     ; EREG = sep/inv sync, DACs on, ereg output ext lut
        & &D000C385     ; FSYNREG, clk = (3+1)/(5+1) * 24MHz = 16MHz
        & &F0013000     ; DCR: bus D[31:0], Hdisc
        & &FFFFFFFF

        ]

        END



@


4.2
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@@


4.1
log
@Initial revision
@
text
@d6 2
a7 2
; write operations on its registers. 
; This module performs two tests to verify VIDC's operation 
d9 1
a9 1
;       - measure mode 0 FLBK period against IOC timer 
d12 2
a13 2
; This code contains timing loops affected by gross changes in processor 
; speed, and will re-initialise MEMC with 4K pages and continous refresh.  
d24 3
d63 1
a63 1
; the proper period from the vertical flyback pulse. To make life easier, 
d70 1
a70 1
; 
d88 1
a88 1
        LDR     r3, =VIDC_CLOCK_CONTROL         ; 
d100 1
a100 1
01      LDR     r0, [r6],#4                     ; enable DMA using 2nd table 
d104 1
a104 1
        
d117 5
a121 5
05      LDRB    r1, [r3, #IOCIRQSTAA] 
        ANDS    r1, r1,  #vsync_bit    
        BNE     %06                    
        SUBS    r2, r2,#1               
        BNE     %05                   
d151 1
a151 1
12      SUBS    r2, r2, #1                      ; or last-ditch timeout 
d213 1
a213 1
; This test runs the sound DMA system to prove the operation of VIDC and 
d228 1
a228 1
        ; labelled in r9_fiq by the early memory size tests (not MemSize) 
d231 1
a231 1
        ; Hence values written to MEMC + register offset + (pointer / 4)    
d313 1
a313 1
        LDR     r0, =(timer0_bit :OR: timer1_bit) 
d317 1
a317 1
        ; Wait until sound DMA completes (or up to about 100 mS), 
d424 1
a424 1
; Additional setup : cursor blanked, sound frequency test bit set 
d450 1
a450 1
        & &E0000402     ; 
d459 1
a459 1
        & &407f7f7f     ; Border colour = grey
d497 1
a497 1
        & &E0000402     ; 
d503 1
a503 1
        & &407f7f7f     ; Border colour = grey
d532 2
a533 2
        END 
 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Change the default border colour from grey to black
@
text
@d6 2
a7 2
; write operations on its registers.
; This module performs two tests to verify VIDC's operation
d9 1
a9 1
;       - measure mode 0 FLBK period against IOC timer
d12 2
a13 2
; This code contains timing loops affected by gross changes in processor
; speed, and will re-initialise MEMC with 4K pages and continous refresh.
a23 3
; 25 Feb 97     ???             ??
; 18 Mar 97     BAR             Change border colour from grey to black for
;                               IDC20 std. and vga definition tables.
d60 1
a60 1
; the proper period from the vertical flyback pulse. To make life easier,
d67 1
a67 1
;
d85 1
a85 1
        LDR     r3, =VIDC_CLOCK_CONTROL         ;
d97 1
a97 1
01      LDR     r0, [r6],#4                     ; enable DMA using 2nd table
d101 1
a101 1

d114 5
a118 5
05      LDRB    r1, [r3, #IOCIRQSTAA]
        ANDS    r1, r1,  #vsync_bit
        BNE     %06
        SUBS    r2, r2,#1
        BNE     %05
d148 1
a148 1
12      SUBS    r2, r2, #1                      ; or last-ditch timeout
d210 1
a210 1
; This test runs the sound DMA system to prove the operation of VIDC and
d225 1
a225 1
        ; labelled in r9_fiq by the early memory size tests (not MemSize)
d228 1
a228 1
        ; Hence values written to MEMC + register offset + (pointer / 4)
d310 1
a310 1
        LDR     r0, =(timer0_bit :OR: timer1_bit)
d314 1
a314 1
        ; Wait until sound DMA completes (or up to about 100 mS),
d421 1
a421 1
; Additional setup : cursor blanked, sound frequency test bit set
d447 1
a447 1
        & &E0000402     ;
d456 1
a456 1
        & &40000000     ; Border colour = black(was grey &7F7F7F)
d494 1
a494 1
        & &E0000402     ;
d500 1
a500 1
        & &40000000     ; Border colour = black(was grey &7F7F7F)
d529 2
a530 2
        END

@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.6;
access;
symbols
	HAL_merge:4.5
	Kernel-5_48:4.5
	Kernel-5_35-4_79_2_327:4.5
	Kernel-5_35-4_79_2_326:4.5
	Kernel-5_35-4_79_2_325:4.5
	Kernel-5_35-4_79_2_324:4.5
	Kernel-5_35-4_79_2_323:4.5
	Kernel-5_35-4_79_2_322:4.5
	Kernel-5_35-4_79_2_321:4.5
	Kernel-5_35-4_79_2_320:4.5
	Kernel-5_35-4_79_2_319:4.5
	Kernel-5_35-4_79_2_318:4.5
	Kernel-5_35-4_79_2_317:4.5
	Kernel-5_35-4_79_2_316:4.5
	Kernel-5_35-4_79_2_315:4.5
	Kernel-5_35-4_79_2_314:4.5
	Kernel-5_35-4_79_2_313:4.5
	Kernel-5_35-4_79_2_312:4.5
	Kernel-5_35-4_79_2_311:4.5
	Kernel-5_35-4_79_2_310:4.5
	Kernel-5_35-4_79_2_309:4.5
	Kernel-5_35-4_79_2_308:4.5
	Kernel-5_35-4_79_2_307:4.5
	Kernel-5_35-4_79_2_306:4.5
	Kernel-5_35-4_79_2_305:4.5
	Kernel-5_35-4_79_2_304:4.5
	Kernel-5_35-4_79_2_303:4.5
	Kernel-5_35-4_79_2_302:4.5
	Kernel-5_35-4_79_2_301:4.5
	Kernel-5_35-4_79_2_300:4.5
	Kernel-5_35-4_79_2_299:4.5
	Kernel-5_35-4_79_2_298:4.5
	Kernel-5_35-4_79_2_297:4.5
	Kernel-5_35-4_79_2_296:4.5
	Kernel-5_35-4_79_2_295:4.5
	Kernel-5_35-4_79_2_294:4.5
	Kernel-5_35-4_79_2_293:4.5
	Kernel-5_35-4_79_2_292:4.5
	Kernel-5_35-4_79_2_291:4.5
	Kernel-5_35-4_79_2_290:4.5
	Kernel-5_35-4_79_2_289:4.5
	Kernel-5_35-4_79_2_288:4.5
	Kernel-5_35-4_79_2_287:4.5
	Kernel-5_35-4_79_2_286:4.5
	Kernel-5_35-4_79_2_285:4.5
	Kernel-5_35-4_79_2_284:4.5
	Kernel-5_35-4_79_2_283:4.5
	Kernel-5_35-4_79_2_282:4.5
	Kernel-5_35-4_79_2_281:4.5
	Kernel-5_35-4_79_2_280:4.5
	Kernel-5_35-4_79_2_279:4.5
	Kernel-5_35-4_79_2_278:4.5
	Kernel-5_35-4_79_2_277:4.5
	Kernel-5_35-4_79_2_276:4.5
	Kernel-5_35-4_79_2_275:4.5
	Kernel-5_35-4_79_2_274:4.5
	Kernel-5_35-4_79_2_273:4.5
	Kernel-5_35-4_79_2_272:4.5
	Kernel-5_35-4_79_2_271:4.5
	Kernel-5_35-4_79_2_270:4.5
	Kernel-5_35-4_79_2_269:4.5
	Kernel-5_35-4_79_2_268:4.5
	Kernel-5_35-4_79_2_267:4.5
	Kernel-5_35-4_79_2_266:4.5
	Kernel-5_35-4_79_2_265:4.5
	Kernel-5_35-4_79_2_264:4.5
	Kernel-5_35-4_79_2_263:4.5
	Kernel-5_35-4_79_2_262:4.5
	Kernel-5_35-4_79_2_261:4.5
	Kernel-5_35-4_79_2_260:4.5
	Kernel-5_35-4_79_2_259:4.5
	Kernel-5_35-4_79_2_258:4.5
	Kernel-5_35-4_79_2_257:4.5
	Kernel-5_35-4_79_2_256:4.5
	Kernel-5_35-4_79_2_255:4.5
	Kernel-5_35-4_79_2_254:4.5
	Kernel-5_35-4_79_2_253:4.5
	Kernel-5_35-4_79_2_252:4.5
	Kernel-5_35-4_79_2_251:4.5
	Kernel-5_35-4_79_2_250:4.5
	Kernel-5_35-4_79_2_249:4.5
	Kernel-5_35-4_79_2_248:4.5
	Kernel-5_35-4_79_2_247:4.5
	Kernel-5_35-4_79_2_246:4.5
	Kernel-5_35-4_79_2_245:4.5
	Kernel-5_35-4_79_2_244:4.5
	Kernel-5_35-4_79_2_243:4.5
	Kernel-5_35-4_79_2_242:4.5
	Kernel-5_35-4_79_2_241:4.5
	Kernel-5_35-4_79_2_240:4.5
	Kernel-5_35-4_79_2_239:4.5
	Kernel-5_35-4_79_2_238:4.5
	Kernel-5_35-4_79_2_237:4.5
	Kernel-5_35-4_79_2_236:4.5
	Kernel-5_35-4_79_2_235:4.5
	Kernel-5_35-4_79_2_234:4.5
	Kernel-5_35-4_79_2_233:4.5
	Kernel-5_35-4_79_2_232:4.5
	Kernel-5_35-4_79_2_231:4.5
	Kernel-5_35-4_79_2_230:4.5
	Kernel-5_35-4_79_2_229:4.5
	Kernel-5_35-4_79_2_228:4.5
	Kernel-5_35-4_79_2_227:4.5
	Kernel-5_35-4_79_2_226:4.5
	Kernel-5_35-4_79_2_225:4.5
	Kernel-5_35-4_79_2_224:4.5
	Kernel-5_35-4_79_2_223:4.5
	Kernel-5_35-4_79_2_222:4.5
	Kernel-5_35-4_79_2_221:4.5
	Kernel-5_35-4_79_2_220:4.5
	Kernel-5_35-4_79_2_219:4.5
	Kernel-5_35-4_79_2_218:4.5
	Kernel-5_35-4_79_2_217:4.5
	Kernel-5_35-4_79_2_216:4.5
	Kernel-5_35-4_79_2_215:4.5
	Kernel-5_35-4_79_2_214:4.5
	Kernel-5_35-4_79_2_213:4.5
	Kernel-5_35-4_79_2_212:4.5
	Kernel-5_35-4_79_2_211:4.5
	Kernel-5_35-4_79_2_210:4.5
	Kernel-5_35-4_79_2_209:4.5
	Kernel-5_35-4_79_2_208:4.5
	Kernel-5_35-4_79_2_207:4.5
	Kernel-5_35-4_79_2_206:4.5
	Kernel-5_35-4_79_2_205:4.5
	Kernel-5_35-4_79_2_204:4.5
	Kernel-5_35-4_79_2_203:4.5
	Kernel-5_35-4_79_2_202:4.5
	Kernel-5_35-4_79_2_201:4.5
	Kernel-5_35-4_79_2_200:4.5
	Kernel-5_35-4_79_2_199:4.5
	Kernel-5_35-4_79_2_198:4.5
	Kernel-5_35-4_79_2_197:4.5
	Kernel-5_35-4_79_2_196:4.5
	Kernel-5_35-4_79_2_195:4.5
	Kernel-5_35-4_79_2_194:4.5
	Kernel-5_35-4_79_2_193:4.5
	Kernel-5_35-4_79_2_192:4.5
	Kernel-5_35-4_79_2_191:4.5
	Kernel-5_35-4_79_2_190:4.5
	Kernel-5_35-4_79_2_189:4.5
	Kernel-5_35-4_79_2_188:4.5
	Kernel-5_35-4_79_2_187:4.5
	Kernel-5_35-4_79_2_186:4.5
	Kernel-5_35-4_79_2_185:4.5
	Kernel-5_35-4_79_2_184:4.5
	Kernel-5_35-4_79_2_183:4.5
	Kernel-5_35-4_79_2_182:4.5
	Kernel-5_35-4_79_2_181:4.5
	Kernel-5_35-4_79_2_180:4.5
	Kernel-5_35-4_79_2_179:4.5
	Kernel-5_35-4_79_2_178:4.5
	Kernel-5_35-4_79_2_177:4.5
	Kernel-5_35-4_79_2_176:4.5
	Kernel-5_35-4_79_2_175:4.5
	Kernel-5_35-4_79_2_174:4.5
	Kernel-5_35-4_79_2_173:4.5
	Kernel-5_35-4_79_2_172:4.5
	Kernel-5_35-4_79_2_171:4.5
	Kernel-5_35-4_79_2_170:4.5
	Kernel-5_35-4_79_2_169:4.5
	Kernel-5_35-4_79_2_168:4.5
	Kernel-5_35-4_79_2_167:4.5
	Kernel-5_35-4_79_2_166:4.5
	Kernel-5_35-4_79_2_165:4.5
	RPi_merge:4.5
	Kernel-5_35-4_79_2_147_2_23:4.5
	Kernel-5_35-4_79_2_147_2_22:4.5
	Kernel-5_35-4_79_2_147_2_21:4.5
	Kernel-5_35-4_79_2_147_2_20:4.5
	Kernel-5_35-4_79_2_147_2_19:4.5
	Kernel-5_35-4_79_2_147_2_18:4.5
	Kernel-5_35-4_79_2_164:4.5
	Kernel-5_35-4_79_2_163:4.5
	Kernel-5_35-4_79_2_147_2_17:4.5
	Kernel-5_35-4_79_2_147_2_16:4.5
	Kernel-5_35-4_79_2_147_2_15:4.5
	Kernel-5_35-4_79_2_162:4.5
	Kernel-5_35-4_79_2_161:4.5
	Kernel-5_35-4_79_2_147_2_14:4.5
	Kernel-5_35-4_79_2_147_2_13:4.5
	Kernel-5_35-4_79_2_160:4.5
	Kernel-5_35-4_79_2_159:4.5
	Kernel-5_35-4_79_2_158:4.5
	Kernel-5_35-4_79_2_157:4.5
	Kernel-5_35-4_79_2_156:4.5
	Kernel-5_35-4_79_2_147_2_12:4.5
	Kernel-5_35-4_79_2_147_2_11:4.5
	Kernel-5_35-4_79_2_155:4.5
	Kernel-5_35-4_79_2_147_2_10:4.5
	Kernel-5_35-4_79_2_154:4.5
	Kernel-5_35-4_79_2_153:4.5
	Kernel-5_35-4_79_2_147_2_9:4.5
	Kernel-5_35-4_79_2_152:4.5
	Kernel-5_35-4_79_2_151:4.5
	Kernel-5_35-4_79_2_147_2_8:4.5
	Kernel-5_35-4_79_2_147_2_7:4.5
	Kernel-5_35-4_79_2_150:4.5
	Kernel-5_35-4_79_2_147_2_6:4.5
	Kernel-5_35-4_79_2_147_2_5:4.5
	Kernel-5_35-4_79_2_149:4.5
	Kernel-5_35-4_79_2_147_2_4:4.5
	Kernel-5_35-4_79_2_147_2_3:4.5
	Kernel-5_35-4_79_2_148:4.5
	Kernel-5_35-4_79_2_147_2_2:4.5
	Kernel-5_35-4_79_2_147_2_1:4.5
	RPi:4.5.0.12
	RPi_bp:4.5
	Kernel-5_35-4_79_2_98_2_52_2_1:4.5
	alees_Kernel_dev:4.5.0.10
	alees_Kernel_dev_bp:4.5
	Kernel-5_35-4_79_2_147:4.5
	Kernel-5_35-4_79_2_146:4.5
	Kernel-5_35-4_79_2_145:4.5
	Kernel-5_35-4_79_2_144:4.5
	Kernel-5_35-4_79_2_143:4.5
	Kernel-5_35-4_79_2_142:4.5
	Kernel-5_35-4_79_2_141:4.5
	Kernel-5_35-4_79_2_140:4.5
	Kernel-5_35-4_79_2_139:4.5
	Kernel-5_35-4_79_2_138:4.5
	Kernel-5_35-4_79_2_137:4.5
	Kernel-5_35-4_79_2_136:4.5
	Kernel-5_35-4_79_2_135:4.5
	Kernel-5_35-4_79_2_134:4.5
	Kernel-5_35-4_79_2_133:4.5
	Kernel-5_35-4_79_2_132:4.5
	Kernel-5_35-4_79_2_131:4.5
	Kernel-5_35-4_79_2_130:4.5
	Kernel-5_35-4_79_2_129:4.5
	Kernel-5_35-4_79_2_128:4.5
	Kernel-5_35-4_79_2_127:4.5
	Kernel-5_35-4_79_2_126:4.5
	Kernel-5_35-4_79_2_125:4.5
	Kernel-5_35-4_79_2_124:4.5
	Kernel-5_35-4_79_2_123:4.5
	Cortex_merge:4.5
	Kernel-5_35-4_79_2_122:4.5
	Kernel-5_35-4_79_2_98_2_54:4.5
	Kernel-5_35-4_79_2_98_2_53:4.5
	Kernel-5_35-4_79_2_98_2_52:4.5
	Kernel-5_35-4_79_2_98_2_51:4.5
	Kernel-5_35-4_79_2_98_2_50:4.5
	Kernel-5_35-4_79_2_98_2_49:4.5
	Kernel-5_35-4_79_2_98_2_48:4.5
	Kernel-5_35-4_79_2_121:4.5
	Kernel-5_35-4_79_2_98_2_47:4.5
	Kernel-5_35-4_79_2_120:4.5
	Kernel-5_35-4_79_2_98_2_46:4.5
	Kernel-5_35-4_79_2_119:4.5
	Kernel-5_35-4_79_2_98_2_45:4.5
	Kernel-5_35-4_79_2_98_2_44:4.5
	Kernel-5_35-4_79_2_118:4.5
	Kernel-5_35-4_79_2_98_2_43:4.5
	Kernel-5_35-4_79_2_117:4.5
	Kernel-5_35-4_79_2_116:4.5
	Kernel-5_35-4_79_2_98_2_42:4.5
	Kernel-5_35-4_79_2_115:4.5
	Kernel-5_35-4_79_2_98_2_41:4.5
	Kernel-5_35-4_79_2_98_2_40:4.5
	Kernel-5_35-4_79_2_114:4.5
	Kernel-5_35-4_79_2_98_2_39:4.5
	Kernel-5_35-4_79_2_98_2_38:4.5
	Kernel-5_35-4_79_2_113:4.5
	Kernel-5_35-4_79_2_112:4.5
	Kernel-5_35-4_79_2_98_2_37:4.5
	Kernel-5_35-4_79_2_98_2_36:4.5
	Kernel-5_35-4_79_2_98_2_35:4.5
	Kernel-5_35-4_79_2_98_2_34:4.5
	Kernel-5_35-4_79_2_98_2_33:4.5
	Kernel-5_35-4_79_2_98_2_32:4.5
	Kernel-5_35-4_79_2_98_2_31:4.5
	Kernel-5_35-4_79_2_98_2_30:4.5
	Kernel-5_35-4_79_2_98_2_29:4.5
	Kernel-5_35-4_79_2_98_2_28:4.5
	Kernel-5_35-4_79_2_98_2_27:4.5
	Kernel-5_35-4_79_2_98_2_26:4.5
	Kernel-5_35-4_79_2_111:4.5
	Kernel-5_35-4_79_2_98_2_25:4.5
	Kernel-5_35-4_79_2_98_2_24:4.5
	Kernel-5_35-4_79_2_98_2_23:4.5
	Kernel-5_35-4_79_2_110:4.5
	Kernel-5_35-4_79_2_98_2_22:4.5
	Kernel-5_35-4_79_2_109:4.5
	Kernel-5_35-4_79_2_98_2_21:4.5
	Kernel-5_35-4_79_2_98_2_20:4.5
	Kernel-5_35-4_79_2_108:4.5
	Kernel-5_35-4_79_2_107:4.5
	Kernel-5_35-4_79_2_98_2_19:4.5
	Kernel-5_35-4_79_2_98_2_18:4.5
	Kernel-5_35-4_79_2_98_2_17:4.5
	Kernel-5_35-4_79_2_98_2_16:4.5
	Kernel-5_35-4_79_2_98_2_15:4.5
	Kernel-5_35-4_79_2_106:4.5
	Kernel-5_35-4_79_2_105:4.5
	Kernel-5_35-4_79_2_104:4.5
	Kernel-5_35-4_79_2_98_2_14:4.5
	Kernel-5_35-4_79_2_98_2_13:4.5
	Kernel-5_35-4_79_2_98_2_12:4.5
	Kernel-5_35-4_79_2_98_2_11:4.5
	Kernel-5_35-4_79_2_98_2_10:4.5
	Kernel-5_35-4_79_2_98_2_9:4.5
	Kernel-5_35-4_79_2_103:4.5
	Kernel-5_35-4_79_2_102:4.5
	Kernel-5_35-4_79_2_98_2_8:4.5
	Kernel-5_35-4_79_2_98_2_7:4.5
	Kernel-5_35-4_79_2_98_2_6:4.5
	Kernel-5_35-4_79_2_98_2_5:4.5
	Kernel-5_35-4_79_2_98_2_4:4.5
	Kernel-5_35-4_79_2_101:4.5
	Kernel-5_35-4_79_2_100:4.5
	Kernel-5_35-4_79_2_99:4.5
	Kernel-5_35-4_79_2_98_2_3:4.5
	Kernel-5_35-4_79_2_98_2_2:4.5
	Kernel-5_35-4_79_2_98_2_1:4.5
	Cortex:4.5.0.6
	Cortex_bp:4.5
	Kernel-5_35-4_79_2_98:4.5
	Kernel-5_35-4_79_2_97:4.5
	Kernel-5_35-4_79_2_96:4.5
	Kernel-5_35-4_79_2_95:4.5
	Kernel-5_35-4_79_2_94:4.5
	Kernel-5_35-4_79_2_93:4.5
	Kernel-5_35-4_79_2_92:4.5
	Kernel-5_35-4_79_2_91:4.5
	Kernel-5_35-4_79_2_90:4.5
	Kernel-5_35-4_79_2_89:4.5
	Kernel-5_35-4_79_2_88:4.5
	Kernel-5_35-4_79_2_87:4.5
	Kernel-5_35-4_79_2_86:4.5
	Kernel-5_35-4_79_2_85:4.5
	Kernel-5_35-4_79_2_84:4.5
	Kernel-5_35-4_79_2_83:4.5
	Kernel-5_35-4_79_2_82:4.5
	Kernel-5_35-4_79_2_81:4.5
	Kernel-5_35-4_79_2_80:4.5
	Kernel-5_35-4_79_2_79:4.5
	Kernel-5_35-4_79_2_78:4.5
	Kernel-5_35-4_79_2_77:4.5
	RO_5_07:4.5
	Kernel-5_35-4_79_2_76:4.5
	Kernel-5_35-4_79_2_75:4.5
	Kernel-5_35-4_79_2_74:4.5
	Kernel-5_35-4_79_2_73:4.5
	Kernel-5_35-4_79_2_72:4.5
	Kernel-5_35-4_79_2_71:4.5
	Kernel-5_35-4_79_2_70:4.5
	Kernel-5_35-4_79_2_69:4.5
	Kernel-5_35-4_79_2_68:4.5
	Kernel-5_35-4_79_2_67:4.5
	Kernel-5_35-4_79_2_66:4.5
	Kernel-5_35-4_79_2_65:4.5
	Kernel-5_35-4_79_2_64:4.5
	Kernel-5_35-4_79_2_63:4.5
	Kernel-5_35-4_79_2_62:4.5
	Kernel-5_35-4_79_2_61:4.5
	Kernel-5_35-4_79_2_59:4.5
	Kernel-5_35-4_79_2_58:4.5
	Kernel-5_35-4_79_2_57:4.5
	Kernel-5_35-4_79_2_56:4.5
	Kernel-5_35-4_79_2_55:4.5
	Kernel-5_35-4_79_2_54:4.5
	Kernel-5_35-4_79_2_53:4.5
	Kernel-5_35-4_79_2_52:4.5
	Kernel-5_35-4_79_2_51:4.5
	Kernel-5_35-4_79_2_50:4.5
	Kernel-5_35-4_79_2_49:4.5
	Kernel-5_35-4_79_2_48:4.5
	Kernel-5_47:4.5
	Kernel-5_46-4_90_2_1:4.5
	nbingham_Kernel_FastNC_dev_bp:4.5
	nbingham_Kernel_FastNC_dev:4.5.0.8
	Kernel-5_46:4.5
	Kernel-5_45:4.5
	Kernel-5_35-4_79_2_47:4.5
	Kernel-5_35-4_79_2_46:4.5
	Kernel-5_35-4_79_2_45:4.5
	Kernel-5_35-4_79_2_44:4.5
	Kernel-5_35-4_79_2_25_2_2:4.5
	Kernel-5_35-4_79_2_43:4.5
	Kernel-5_35-4_79_2_42:4.5
	Kernel-5_35-4_79_2_41:4.5
	Kernel-5_35-4_79_2_40:4.5
	Kernel-5_35-4_79_2_39:4.5
	Kernel-5_35-4_79_2_38:4.5
	Kernel-5_35-4_79_2_37:4.5
	Kernel-5_35-4_79_2_36:4.5
	Kernel-5_35-4_79_2_35:4.5
	Kernel-5_35-4_79_2_34:4.5
	Kernel-5_35-4_79_2_33:4.5
	Kernel-5_35-4_79_2_32:4.5
	Kernel-5_44:4.5
	Kernel-5_35-4_79_2_25_2_1:4.5
	Kernel-5_43:4.5
	Kernel-5_35-4_79_2_31:4.5
	Kernel-5_35-4_79_2_30:4.5
	Kernel-5_35-4_79_2_29:4.5
	Kernel-5_35-4_79_2_28:4.5
	Kernel-5_35-4_79_2_27:4.5
	Kernel-5_35-4_79_2_26:4.5
	Kernel-5_42:4.5
	Kernel-5_41:4.5
	Kernel-5_40:4.5
	Kernel-5_35-4_79_2_25:4.5
	Kernel-5_35-4_79_2_24:4.5
	Kernel-5_35-4_79_2_23:4.5
	Kernel-5_35-4_79_2_22:4.5
	Kernel-5_35-4_79_2_21:4.5
	Kernel-5_35-4_79_2_20:4.5
	Kernel-5_35-4_79_2_19:4.5
	Kernel-5_35-4_79_2_18:4.5
	Kernel-5_35-4_79_2_17:4.5
	Kernel-5_35-4_79_2_16:4.5
	Kernel-5_35-4_79_2_15:4.5
	Kernel-5_35-4_79_2_14:4.5
	Kernel-5_39:4.5
	Kernel-5_13-4_52_2_1:4.5
	Bethany:4.5.0.4
	Kernel-5_38:4.5
	Kernel-5_35-4_79_2_13:4.5
	Kernel-5_35-4_79_2_12:4.5
	Kernel-5_35-4_79_2_11:4.5
	Kernel-5_37:4.5
	Kernel-5_35-4_79_2_10:4.5
	Kernel-5_35-4_79_2_9:4.5
	Kernel-5_36:4.5
	Kernel-5_35-4_79_2_8:4.5
	Kernel-5_35-4_79_2_7:4.5
	Kernel-5_35-4_79_2_6:4.5
	Kernel-5_35-4_79_2_5:4.5
	Kernel-5_35-4_79_2_4:4.5
	Kernel-5_35-4_79_2_3:4.5
	Kernel-5_35-4_79_2_2:4.5
	dellis_autobuild_BaseSW:4.5
	Kernel-5_35-4_79_2_1:4.5
	HAL:4.5.0.2
	Kernel-5_35:4.5
	Kernel-5_34:4.5
	Kernel-5_33:4.5
	Kernel-5_32:4.5
	Kernel-5_31:4.5
	Kernel-5_30:4.5
	Kernel-5_29:4.5
	Kernel-5_28:4.5
	Kernel-5_27:4.5
	Kernel-5_26:4.5
	Kernel-5_25:4.5
	Kernel-5_24:4.5
	Kernel-5_23:4.5
	Kernel-5_22:4.5
	sbrodie_sedwards_16Mar2000:4.5
	Kernel-5_21:4.5
	Kernel-5_20:4.5
	Kernel-5_19:4.5
	Kernel-5_18:4.5
	Kernel-5_17:4.5
	Kernel-5_16:4.5
	Kernel-5_15:4.5
	Kernel-5_14:4.5
	Kernel-5_13:4.5
	Kernel-5_12:4.5
	Kernel-5_11:4.5
	Kernel-5_10:4.5
	Kernel-5_09:4.5
	Kernel-5_08:4.5
	Kernel-5_07:4.5
	Kernel-5_06:4.5
	Kernel-5_05:4.5
	Kernel-5_04:4.5
	Kernel-5_03:4.5
	Kernel-5_02:4.5
	Kernel-5_01:4.5
	Kernel-5_00:4.5
	Kernel-4_99:4.5
	Kernel-4_98:4.5
	Kernel-4_97:4.5
	Kernel-4_96:4.5
	Kernel-4_95:4.5
	Kernel-4_94:4.5
	Kernel-4_93:4.5
	Kernel-4_92:4.5
	Kernel-4_91:4.5
	Kernel-4_90:4.5
	dcotton_autobuild_BaseSW:4.5
	Kernel-4_89:4.5
	Kernel-4_88:4.5
	Kernel-4_87:4.5
	Kernel-4_86:4.5
	Kernel-4_85:4.5
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2
	Kernel-4_84:4.5
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2
	Ursula_RiscPC_bp:4.2
	Kernel-4_83:4.5
	Kernel-4_82:4.5
	Kernel-4_81:4.5
	Kernel-4_80:4.5
	Kernel-4_79:4.5
	Kernel-4_78:4.5
	Kernel-4_77:4.4
	Kernel-4_76:4.3
	Kernel-4_75:4.3
	Kernel-4_74:4.3
	Kernel-4_73:4.3
	Kernel-4_72:4.3
	Kernel-4_71:4.3
	Kernel-4_70:4.3
	Kernel-4_69:4.3
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.2
	Ursula_merge:4.2
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	mstphens_Kernel-3_80:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2016.06.30.20.28.47;	author jlee;	state dead;
branches;
next	4.5;
commitid	lMnWzoE9eJz3Wwcz;

4.5
date	99.05.06.13.47.09;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.05.04.13.41.23;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.02.09.10.57.34;	author nturton;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.06.39;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.45;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.41.45;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.04.22;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.56;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.05.11;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; > TestSrc.ExtIO

        TTL RISC OS 2+ POST external commands
;
; External interface for RISC OS ROM.
; provides entry points to send byte- and word- and string-sized objects
; and to receive byte- and word-sized objects
;
; A minimal set of opcodes should be used (ideally, only B, LDR and ADDS)
; so that a processor test may be validly included in the internal test
; sequence.
;
;------------------------------------------------------------------------
; History
;
; Date          Name            Comment
; ----          ----            -------
; 06-Dec-89     ArtG            Initial version - split from `Begin`
;                               Release 0.2 for integration
; 31-Mar-90     ArtG            Added ts_MoreText, cursor position, hex.
; 19-Apr-90     ArtG            Added bus exercise commands
; 09-May-90     ArtG            Changed LCD strobe to 12 pulses
; 15-May-90     ArtG            Added ReadyByte : improves synchronization
;                               when ExtCmd execution toggles A21/A22.
; 18-Jun-90	ArtG		Added CPR15 read/write functions
; 04-Oct-96	JRH		Updated comments to refer to test box on A23.
;				Added support for speaking to the test box when
;				running from the 2nd ROM bank, conditioned on
;				CanLiveOnROMCard. Needed because 2nd ROM bank
;				isn't ghosted on the A23 line like the 1st bank.
; 04-May-99     KJB             Modified to cope with >8M ROMs.
;------------------------------------------------------------------------


        SUBT    Test adapter interface

;
; The test adapter senses an access to the ROM with address line A23 high.
;
; 8M addressing space ROMs only use address lines A2 to A22,
; so if A23 is asserted it will be ignored (the ROMS are aliased
; into 16M of space). With no test adapter, the aliased ROM location will
; be read and may be recognised. The test adapter may selectively disable
; ROMs when A23 is high, causing arbitrary data to be read. This data
; should be dependent on the previous ROM read operation, and will
; therefore be predictably not equal to the data read when the ROMs are
; aliased.
;
; On a system with >8M of ROM, A23 is now meaningful, and there is no
; aliasing of the ROM image. In this case, we read a fixed location at the
; end of the ROM that always contains zero - if it reads as non-zero, the
; test adapter is signalling.
;


        MACRO
        TestAdapterLocation $reg
;
; Load up the registers for the test interface communication.
; On exit: R0 = 0
;          R1 corrupted
;          $reg -> zero word in 8-16MB space we can read to communicate with
;                  test box

; If the ROM is >8M, we will use the fixed zero word in the ROM trailer.
; If not, we use the old scheme (in case someone is using an old ROM joiner
; that doesn't write the correct trailer.) Because the ROM is >8M, the
; trailer will be at an address with A23 set, as desired.
;
; KJB - note I haven't kept the purity of the minimal instruction set -
; I feel that it is unlikely that there ever will be a processor test,
; and if there is, then this won't be the only place where the purity
; has been broken...

        ASSERT  ts_Alias_bits = 8*1024*1024

        MOV     r0,#0
        LDR     r1,[r0, #ts_ROMSIZE]    ; size of ROM in bank 0
        CMP     r1,#8*1024*1024
        SUBHI   $reg,r1,#20             ; zero word is at end-20
        BHI     %FT05

; Point r2 at a word which contains 0 in 0-8MB physical space.
; Note that this code doesn't cope with the case where it can't find a zero
; word anywhere in the whole ROM. I don't think that this is a problem.

        MOV     r0, #0                  ; expected below
        MOV     $reg, #0                ; start of physical space
01
        LDR     r1, [$reg, #4]!
        TEQ     r1, r0                  ; is it zero?
        BNE     %BT01

        ADD     $reg, $reg, #ts_Alias_bits  ; point to zero word in ghost
05
        MEND



;
; This section determines whether the test interface adapter exists, and
; what variety is fitted (dumb, display or external)
; 3 read operations are performed (a WS operation): if all of these
; find a ROM alias then no adapter is fitted.
;
; If an adapter responds, then a RD operation is performed - 4 strobes then
; clocking 8 bits into r4. These bits may be all zeros (a dumb adapter)
; or all ones (a display adapter) or some other value (an external
; adapter)
;

ts_GetCommand  ROUT

        LDR     r0,%01
        ADD     pc,pc,r0
01
        &       0

        ; delay to make a gap before reading

        LDR     r3,%02
        ADD     pc,pc,r0
02
        &       ts_recover_time
03
        ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %03

        ROUT

        TestAdapterLocation r2          ; r0 = 0, r1 corrupted

        MOV     r1, #-1                 ; expected below
04
        ; do an RD operation (four strobes) to ensure interface cleared

        LDR     r3,[r2]
        ADDS    r3,r3,r1
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        LDR     r3,[r2]
        ADDS    r3,r3,r1

        ; write a byte (initially, &90) to indicate readiness

        LDR     r4,%20
        ADD     pc,pc,r0
20
        &       ts_ReadyByte_00
        ADDS    r14,r0,pc
        B       ts_SendByte

        ; delay to make a gap between WRS and RD operations

        LDR     r3,%05
        ADD     pc,pc,r0
05
        &       ts_recover_time
06
        ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %06

        LDR     r5,%07                  ; counter for first 5 bits
        ADD     pc,pc,r0
07
        &       1 :SHL: (32 - 5)
        LDR     r6,%08                  ; counter for last 3 bits
        ADD     pc,pc,r0
08
        &       1 :SHL: (32 - 3)
        ADDS    r4,r0,r0                ; input accumulator initialisation

; put the test interface into input mode

        LDR     r3,[r2]                 ; 3 bit lead-in
        ADDS    r3,r3,r1                ; (adapter detects WS operation)
        BCC     ts_User_startup         ; abort if no adapter present

        LDR     r3,[r2]                 ; two more strobes, then waitloop
        ADDS    r3,r3,r1
        LDR     r3,[r2]
        ADDS    r3,r3,r1

; started input operation : wait for interface to be ready

09
        LDR     r3,[r2]                 ; read start bit repeatedly
        ADDS    r3,r3,r1                ; (adapter detects RD operation)
        BCC     %09                     ; loop until interface is ready

; read the first 5 bits into r5 and the second 3 bits into r4

10      LDR     r3,[r2]                 ; read a bit of the byte
        ADDS    r3,r3,r1                ; .. if the test adapter is present, carry bit set
        ADCS    r4,r4,r4                ; .. shift left and add in carry

        ADDS    r5,r5,r5                ; loop until 5 bits are read
        BCC     %10

        ADDS    r5,r4,r4                ; copy bits 7..3 to r5, bits 5..1

        ADDS    r4,r0,r0                ; and read the last 3 bits to r4
11      LDR     r3,[r2]                 ; read a bit of the byte
        ADDS    r3,r3,r1
        ADCS    r4,r4,r4

        ADDS    r6,r6,r6                ; loop until last 3 bits are read
        BCC     %11

;
; Command byte read in (split between r4 and r5)
; Pass the option bits (r4) to the function identified by r5.
;

        ADDS    r5,r5,r5                ; index * 2 -> index * 4
        LDR     r3,%12                  ; pc-relative ptr to command_table
        ADD     pc,pc,r0
12
        &       ts_command_table - %13
        ADDS    r3,pc,r3                ; absolute pointer to command table
        ADDS    r3,r3,r5

13      LDR     r3,[r3]                 ; get table entry
14      ADD     pc,pc,r3                ; (offset from command_table)

        &       0                       ; necessary padding : pc must point
                                        ; to command table when r3 is added.

;
; This is the table of offsets to all the built-in functions.
; The top 5 bits of the command are used to index, so there are
; 32 possible entries, mostly illegal.
; Decoding of the function modifier bits is performed by multiple
; entries in this table.
;

; pc must point here when ADDS pc,r3,pc is executed

        ASSERT  ((ts_command_table - %14)  = 8)

ts_command_table

        DCD     (ts_Dealer_startup - ts_command_table)   ; display interface
ts_Windex
        DCD     (ts_write_memory   - ts_command_table)   ; external tests
ts_Rindex
        DCD     (ts_read_memory    - ts_command_table)
ts_Eindex
        DCD     (ts_execute        - ts_command_table)
ts_Bindex
        DCD     (ts_bus_exercise   - ts_command_table)

        DCD     (ts_GetCommand     - ts_command_table)	; dummy entry aligns CPR instructions
							; to allow 4-bit option field
ts_CWindex
	DCD	(ts_write_cpr15l   - ts_command_table)
	DCD	(ts_write_cpr15h   - ts_command_table)
ts_CRindex
	DCD	(ts_read_cpr15l    - ts_command_table)
	DCD	(ts_read_cpr15h    - ts_command_table)

        ; pad the table out to 31 entries
        ; (leave space for display vector)

OldOpt  SETA    {OPT}
        OPT     OptNoList
doffset SETA    .
        WHILE   doffset < (ts_command_table + (31 * 4)) ; illegal entries
        DCD     (ts_GetCommand     - ts_command_table)
doffset SETA    doffset + 4
        WEND
        OPT     OldOpt

        DCD     (ts_Forced_startup - ts_command_table)  ; dumb interface

;
; The indexes into the above table are needed in ExtCmd ...
;
ts_WriteCmdByte         *       ((ts_Windex - ts_command_table) :SHL: 1)
ts_ReadCmdByte          *       ((ts_Rindex - ts_command_table) :SHL: 1)
ts_ExecuteCmdByte       *       ((ts_Eindex - ts_command_table) :SHL: 1)
ts_BusExCmdByte         *       ((ts_Bindex - ts_command_table) :SHL: 1)
ts_CPWCmdByte		*	((ts_CWindex  - ts_command_table) :SHL: 1)
ts_CPRCmdByte		*	((ts_CRindex  - ts_command_table) :SHL: 1)


;
; Primitives for reading data from the external interface
;
;               - Get a byte from the interface (into r4)
;               - Get a (4 byte) word from the interface (into r4)
;
; Required register setup is presumed done by a recent ts_GetCommand.
; r0, r1 and r2 have critical values
; r14 is the link address
;

ts_GetWord      ROUT

        LDR     r6,%01                  ; counter for 4 bytes per word
        ADD     pc,pc,r0                ; (bit set 4 left shifts from Carry)
01
        &       1 :SHL: (32 - 4)
        B       ts_Getdata

ts_GetByte      ROUT
        LDR     r6,%01                  ; counter for single byte
        ADD     pc,pc,r0
01
        &       1 :SHL: (32 - 1)

ts_Getdata      ROUT
        ADDS    r4,r0,r0                ; input accumulator initialisation

        LDR     r3,[r2]                 ; 3 bit lead-in
        ADDS    r3,r3,r1                ; (adapter detects RD operation)
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        LDR     r3,[r2]
        ADDS    r3,r3,r1

; started input operation : now loop until r6 shifts into Carry

02
        LDR     r5,%03                  ; counter for 8 bits per byte
        ADD     pc,pc,r0
03
        &       2_00000001000000010000000100000001
04
        LDR     r3,[r2]                 ; read start bit repeatedly
        ADDS    r3,r3,r1
        BCC     %04                     ; loop until interface is ready
05
        LDR     r3,[r2]                 ; read a bit of the byte
        ADDS    r3,r3,r1
        ADCS    r4,r4,r4                ; SHL r4, add carry bit.

        ADDS    r5,r5,r5                ; loop until byte is read
        BCC     %05

        ADDS    r6,r6,r6                ; loop until word is read
        BCC     %04

        ADD     pc,r0,r14               ; back to the caller


;
; Primitives for sending data to the interface
;
;               - Send a byte to the interface (from r4 lsb)
;               - Send a (4 byte) word to the interface (from r4)
;
; Required register setup is presumed done by a recent ts_GetCommand.
; r0, r1 and r2 have critical values
; r14 is the link address
;

ts_SendWord     ROUT
        LDR     r6,%01                  ; counter for 4 bytes per word
        ADD     pc,pc,r0                ; (bit set 4 left shifts from Carry)
01
        &       1 :SHL: (32 - 4)
        B       ts_Putdata

ts_SendByte      ROUT
        LDR     r6,%01                  ; counter for single byte
        ADD     pc,pc,r0
01
        &       (3 :SHL: 7)
02      ADDS    r4,r4,r4                ;shift byte into highest 8 bits
        ADDS    r6,r6,r6
        BCC     %02                     ;stop when byte shifted,
                                        ;leaving bit 31 set in r6

ts_Putdata      ROUT

; Wait - gap between successive WS attempts or successive bytes

01      LDR     r3,%02
        ADD     pc,pc,r0
02
        &       ts_recover_time
03      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %03

        LDR     r3,[r2]                 ; Test for adapter ready for data
        ADDS    r3,r3,r1                ; (adapter detects WS operation)
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        BCC     %10                     ; skip out if adapter not present
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        BCC     %01                     ; loop back until adapter is ready

; Adapter ready - loop around all the bits in the byte

        LDR     r5,%04                  ; load bits-per-byte counter
        ADD     pc,pc,r0
04
        &       (1 :SHL: (32-8))

05      LDR     r3,%06                  ; delay before sending bit
        ADD     pc,pc,r0
06
        &       ts_recover_time
07      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %07

        ; Send a single bit : 1 pulse for 1, 2 pulses for 0

        LDR     r3,[r2]
        ADDS    r4,r4,r4                ; shift current bit into Carry
        LDRCC   r3,[r2]                 ; second pulse if bit is 0

        ; repeat until 8 bits are sent

        ADDS    r5,r5,r5
        BCC     %05

; Repeat for all the bytes to be sent (1 or 4)

        ADDS    r6,r6,r6
        BCC     %01

; Go to TXRDY to ensure the host sees the transmit request

        LDR     r3,%08                  ; delay before sending pattern
        ADD     pc,pc,r0
08
        &       ts_recover_time
09      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %09

        LDR     r3,[r2]
        ADDS    r3,r3,r1                ; dummy - space between pulses
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        LDR     r3,[r2]

; All sent - r14 holds the caller's return address
10
        ADD     pc,r0,r14



;
; Reporting primitive
;
;               - Send the text (nul-terminated, at r4) to the display
;
; Interface registers need to be set up : this function is called from test
; code rather than external interface code.
;
; The display is assumed to be a standard 16 character LCD module using
; the Hitachi HD44780 display controller.
; The 16-digit module uses a single 44780. This is an abnormal use of the
; controller, and requires it to be set to two-line mode, with the first
; 8 displayed characters on the first 'line', and the second 8 on the
; second 'line'. Characters sent to the second line must be written at
; character position 40 +. In order to permit different modules to be
; fitted to later adapters, it is suggested that the first 7 characters
; be treated as a 'title' line, and the second 8 as a 'comment' line.
; A space should always be placed at the end of the title line to
; split the display fields, unless there is no 'comment' line.
; Do not display characters across the two areas as though they adjoined
; (even though they do :-) ).
;
; The controller is operated in its 4-bit mode, which allows the interface
; to drive 4 bits of alpha information and 4 bits of control information.
; The bits in a transmitted byte are assigned as :
;
;       bit 0   -       D4  }   4-bit mode data bus
;           1   -       D5  }
;           2   -       D6  }
;           3   -       D7  }
;
;           4   -       RS      Register Select : 0 for control, 1 for data
;
;           5   -           }   Unassigned
;           6   -           }
;
;           7   -       CPEN    Interface control :     0 for enable,
;                                                       1 for disable
;
; For each message sent, the display is first initialised, using the
; following sequence (each byte is sent as 2 bytes, high nibble first,
; with RS clear in bit 4 of each byte)
; After each byte, an RD operation is performed : this is used by the
; interface hardware to strobe the data into the display.
;
;
; The message addressed by r4 is then sent (data mode : RS set in each byte)
; until a 0 byte is encountered.
;

;
; This is the command sequence sent to initialise the display
;

ts_initialise
        =       &30,&30,&30,&20 ; power-up initialisation
        =       &20,&80         ; 4 bit mode, two line, Font 0
        =       &00,&C0         ; Display on, no cursor visible
        =       &00,&60         ; Incrementing display position, no shift
        =       &80,&00         ; Set DD RAM address 0
        =       &00,&20         ; Cursor home
        =       &00,&10         ; Display clear
ts_initialise_end

        ASSERT  ((ts_initialise_end - ts_initialise) / 2) < 32


;
; This is the command sequence sent when continuation text is sent
;

ts_extend
        =       &00,&C0         ; Display on, cursor invisible
        =       &00,&60         ; Incrementing display position, no shift
ts_extend_end

        ASSERT  ((ts_extend_end - ts_extend) / 2) < 32

;
; One of these commands are sent when offset text is required
;

ts_offset_table
        =       &80,&00         ; Set DD RAM address 0
ts_offset_table_1
        =       &80,&10         ; Set DD RAM address 1
        =       &80,&20         ; Set DD RAM address 2
        =       &80,&30         ; Set DD RAM address 3
        =       &80,&40         ; Set DD RAM address 4
        =       &80,&50         ; Set DD RAM address 5
        =       &80,&60         ; Set DD RAM address 6
        =       &80,&70         ; Set DD RAM address 7
        =       &C0,&00         ; Set DD RAM address 40
        =       &C0,&10         ; Set DD RAM address 41
        =       &C0,&20         ; Set DD RAM address 42
        =       &C0,&30         ; Set DD RAM address 43
        =       &C0,&40         ; Set DD RAM address 44
        =       &C0,&50         ; Set DD RAM address 45
        =       &C0,&60         ; Set DD RAM address 46
        =       &C0,&70         ; Set DD RAM address 47


; This assertion is forced by the code : each sequence assumed 2 bytes.

        ASSERT  ((ts_offset_table_1 - ts_offset_table) = 2)



        ALIGN

;
; Here starts the code ...
;

ts_SendQuit     ROUT                    ; put this code BEFORE %16
        ADD     pc,r0,r14               ;



;
; Entry point for initialising the display and sending r4 text.
;


ts_SendText     ROUT

;
; Point to the command sequence to setup and clear the display
;

        LDR     r0,%10                  ; set zero in r0
        ADD     pc,pc,r0
10
        &       0
        LDR     r7,%11                  ; pointer to init sequence
	ADDS	r7,pc,r7
        ADD     pc,pc,r0
11
        &       (ts_initialise - .)
        LDR     r6,%12                  ; length of init sequence
        ADD     pc,pc,r0
12
        &       (1 :SHL: (32 - (ts_initialise_end - ts_initialise)))
        B       ts_SendLCDCmd


;
; Entry point for adding text to current cursor position
;

ts_MoreText     ROUT

        LDR     r0,%10                  ; set zero in r0
        ADD     pc,pc,r0
10
        &       0
        LDR     r7,%11                  ; pointer to command sequence
	ADDS	r7,pc,r7
        ADD     pc,pc,r0
11
        &       (ts_extend - .)
        LDR     r6,%12                  ; length of command sequence
        ADD     pc,pc,r0
12
        &       (1 :SHL: (32 - (ts_extend_end - ts_extend)))
        B       ts_SendLCDCmd


ts_PosText      ROUT

;
; Entry point for adding text at a specific cursor position
; Used iteratively by SendText, etc if cursor position command found.
; Offset into display is given in r6.
;

        LDR     r0,%10                  ; set zero in r0
        ADD     pc,pc,r0
10
        &       0
        LDR     r7,%11                  ; pointer to command sequence
	ADDS	r7,pc,r7
        ADD     pc,pc,r0
11
        &       (ts_offset_table - .)   ; offset * 2 into table of
        ADDS    r6,r6,r6                ; offset command sequences
        ADDS    r7,r7,r6

        LDR     r6,%12                  ; length of command sequence
        ADD     pc,pc,r0
12
        &       (1 :SHL: (32 - 2))


;
; Entry point for writing arbitrary command strings.
; Set r7 to point to command string, r6 length (as tables above),
; Set r4 to point to following Data string (null-terminated).
;

ts_SendLCDCmd
        TestAdapterLocation r2          ; r0 = 0, r1 corrupted
04

; Wait - gap between successive WS attempts or successive bytes

ts_send_command_byte ROUT

        LDR     r3,%14
        ADD     pc,pc,r0
14
        &       ts_recover_time
15      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %15
        LDR     r1,%16                  ; reload test register
        ADD     pc,pc,r0
16
        &       (-1)

        LDR     r3,[r2]                 ; Test for adapter ready for data
        ADDS    r3,r3,r1                ; (adapter detects WS operation)
        BCC     ts_SendQuit             ; skip output : adapter not present
                                        ; (backward jump helps ensure LDR r3,[r2]
                                        ; only reads zero when adapter absent
        LDR     r3,[r2]			; since previous bus data is nonzero)
        ADDS    r3,r3,r1
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        BCC     ts_send_command_byte    ; loop back until adapter is ready

; Adapter ready - loop around all the bits in the byte


        LDR     r5,%21                  ; load byte-shift counter ...
        ADD     pc,pc,r0                ; ... and bits-per-byte counter
21
        &       (1 :SHL: 8) + 1         ; 24 shifts + 8 shifts
        LDRB    r1,[r7]
22      ADDS    r1,r1,r1                ; shift byte up into m.s.d.
        ADDS    r5,r5,r5
        BCC     %22

        ; Send a single bit : 1 pulse for 1, 2 pulses for 0

23      LDR     r3,[r2]
        ADDS    r1,r1,r1                ; shift current bit into Carry
        LDRCC   r3,[r2]                 ; second pulse if bit is 0

        ; and wait for the inter-bit time

        LDR     r3,%24
        ADD     pc,pc,r0
24
        &       ts_recover_time
25      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %25

        ; repeat until 8 bits are sent

        ADDS    r5,r5,r5
        BCC     %23

        ; do a RD operation to strobe the data out

        LDR     r5,%26
        ADD     pc,pc,r0
26
        &       (1 :SHL: (32 - 12))
27
        LDR     r3,[r2]
        ADDS    r5,r5,r5
        BCC     %27

; Repeat for all the bytes to be sent (ts_initialise_end - ts_initialise)

        LDR     r3,%33
        ADD     pc,pc,r0
33
        &       1
        ADDS    r7,r7,r3                ; bump the pointer
        ADDS    r6,r6,r6                ; bump the counter (shift left)
        BCC     ts_send_command_byte


;
; Then send all the display bytes (in 4-bit mode) until a nul-terminator
; is reached.
;

;
; Send a single character (as two separate 4-bit fields)
; First, look to see if it's one of :
;
;       NUL                     - end of text string
;       0x80 - 0xfe             - cursor positioning
;       0xff                    - introduce a hex digit
;

ts_send_text_byte       ROUT

        LDR     r1,%40                  ; reload test register
        ADD     pc,pc,r0
40
        &       (-1)

        LDRB    r7,[r4]
        ADDS    r3,r7,r1                ; test for nul terminator
        BCC     ts_SendEnd

;
; Byte isn't null. Check for >= 0x80.
;

        LDR     r6,%42                  ; test for cursor control
        ADD     pc,pc,r0
42
        &       (-&80)                  ; &8x means column x.
        ADDS    r6,r7,r6
        BCC     ts_printable_char       ; < &80 : write a character

;
; Carry set : r6 now holds (value - 0x80). Check for numeric escape (&ff).
;
        LDR     r3,%43
        ADD     pc,pc,r0
43
        &       (-&7f)
        ADDS    r3,r6,r3
        BCC     %47

;
; Carry set : fetch a nybble from the top of r8 and display that.
;

        ADDS    r8,r8,r8
        ADCS    r6,r0,r0
        ADDS    r8,r8,r8
        ADCS    r6,r6,r6
        ADDS    r8,r8,r8
        ADCS    r6,r6,r6
        ADDS    r8,r8,r8
        ADCS    r6,r6,r6

        LDRB    r7,[pc,r6]
        B       ts_printable_char
45
        =       "0123456789ABCDEF"

;
; Not &ff : r6 holds cursor positioning offset (< &80). Skip over
; the cursor control byte and iterate thro' PosText to move
; typing position.
;

47
        LDR     r3, %48
        ADD     pc,pc,r0
48
        &       1
        ADDS    r4,r3,r4
        B       ts_PosText

;
; Character is normal text : write it to the LCD.
; The shift loop is used to generate the inter-byte delay normally
; provided by  ts_recover_time. Always make sure this is long enough.
;

ts_printable_char

        ADDS    r6,r0,r7                ; take a copy of character
        LDR     r5,%51                  ; load byte-shift counter ...
        ADD     pc,pc,r0                ; ... and bits-per-byte counter
51                                      ; as a bitmask of the shift pattern
        &       (1:SHL:8)+(1:SHL:4)+1   ; 24 shifts + 4 shifts + 4 shifts
52      ADDS    r6,r6,r6                ; shift byte up into m.s.d.
        ADDS    r0,r0,r0                ; slow this loop down - ensure it's
        ADDS    r0,r0,r0                ; always slower than ts_recover_time
        ADDS    r5,r5,r5
        BCC     %52

        LDR     r3,[r2]                 ; Test for adapter ready for data
        ADDS    r3,r3,r1                ; (adapter detects WS operation)
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        BCC     ts_printable_char       ; loop back until adapter is ready

; Adapter ready - loop around all the bits in the byte

ts_send_tbit_upper

        ; wait for the inter-bit time

        LDR     r3,%55
        ADD     pc,pc,r0
55
        &       ts_recover_time
56      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %56

        ; Send a single bit : 1 pulse for 1, 2 pulses for 0

        LDR     r3,[r2]
        ADDS    r6,r6,r6                ; shift current bit into Carry
        LDRCC   r3,[r2]                 ; second pulse if bit is 0

        ; repeat until upper 4 bits are sent

        ADDS    r5,r5,r5
        BCC     ts_send_tbit_upper

        ; then send the interface control bits

        LDR     r1,%57
        ADD     pc,pc,r0
57
        &       (8 :SHL: 28)            ; assert RS control pin

ts_send_cbit_upper

        ; wait for the inter-bit time

        LDR     r3,%58
        ADD     pc,pc,r0
58
        &       ts_recover_time
59      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %59

        ; Send a single bit : 1 pulse for 1, 2 pulses for 0

        LDR     r3,[r2]
        ADDS    r1,r1,r1                ; shift current bit into Carry
        LDRCC   r3,[r2]                 ; second pulse if bit is 0
        ADDS    r5,r5,r5
        BCC     ts_send_cbit_upper

;
; do a RD operation to strobe the data out
;

        LDR     r3,%61
        ADD     pc,pc,r0
61
        &       ts_recover_time
62      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %62

        LDR     r5,%63
        ADD     pc,pc,r0
63
        &       (1 :SHL: (32 - 12))
64
        LDR     r3,[r2]
        ADDS    r5,r5,r5
        BCC     %64

        ; prepare to send the lower 4 bits out

        LDR     r5,%70                  ; bitcount mask for 4 data bits
        ADD     pc,pc,r0                ; and 4 interface control bits
70
        &       (((1 :SHL: 4) + 1) :SHL: 24)

ts_send_text_lower
        LDR     r3,%71
        ADD     pc,pc,r0
71
        &       ts_recover_time
72      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %72

        LDR     r1,%73
        ADD     pc,pc,r0
73
        &       (-1)

        LDR     r3,[r2]                 ; Test for adapter ready for data
        ADDS    r3,r3,r1                ; (adapter detects WS operation)
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        BCC     ts_send_text_lower      ; loop back until adapter is ready

ts_send_tbit_lower

        ; wait for the inter-bit time

        LDR     r3,%76
        ADD     pc,pc,r0
76
        &       ts_recover_time
77      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %77

        ; Send a single bit : 1 pulse for 1, 2 pulses for 0

        LDR     r3,[r2]
        ADDS    r6,r6,r6                ; shift current bit into Carry
        LDRCC   r3,[r2]                 ; second pulse if bit is 0

        ; repeat until lower 4 bits are sent

        ADDS    r5,r5,r5
        BCC     ts_send_tbit_lower


        ; then send the interface control bits

        LDR     r1,%78
        ADD     pc,pc,r0
78
        &       (8 :SHL: 28)            ; assert RS control pin

ts_send_cbit_lower

        ; wait for the inter-bit time

        LDR     r3,%80
        ADD     pc,pc,r0
80
        &       ts_recover_time
81      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %81

        ; Send a single bit : 1 pulse for 1, 2 pulses for 0

        LDR     r3,[r2]
        ADDS    r1,r1,r1                ; shift current bit into Carry
        LDRCC   r3,[r2]                 ; second pulse if bit is 0

        ADDS    r5,r5,r5
        BCC     ts_send_cbit_lower

;
; do a RD operation to strobe the data out
;

        ; wait for the inter-bit time

        LDR     r3,%82
        ADD     pc,pc,r0
82
        &       ts_recover_time
83      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %83

        LDR     r5,%84
        ADD     pc,pc,r0
84
        &       1 :SHL: (32 - 12)
85
        LDR     r3,[r2]
        ADDS    r5,r5,r5
        BCC     %85

; Repeat for all the bytes to be sent (until nul terminator is found)

        LDR     r3,%86
        ADD     pc,pc,r0
86
        &       1
        ADDS    r4,r3,r4                ; bump text pointer
        B       ts_send_text_byte

;
; Wait for about 1 seconds worth of LCD operation delays to
; permit the operator to read the text.
; Use of the interface's monitor allows this delay to be increased
; or decreased externally.
;

ts_SendEnd      ROUT

        LDR     r7, %01
        ADD     pc,pc,r0
01
        &       (ts_pause_time + 1)     ; must be an odd number
					; to ensure pairs of zeros
        ASSERT ((ts_pause_time :AND: 1) = 0)

02
        LDR     r3,%03
        ADD     pc,pc,r0
03
        &       ts_recover_time
04      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %04
        LDR     r1,%05                  ; reload test register
        ADD     pc,pc,r0
05
        &       (-1)

        LDR     r3,[r2]                 ; Test for adapter ready for data
        ADDS    r3,r3,r1                ; (adapter detects WS operation)
        BCC     ts_SendQuit             ; skip output : adapter not present
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        LDR     r3,[r2]
        ADDS    r3,r3,r1
        BCC     %02                     ; loop back until adapter is ready

; Adapter ready - loop around all the bits in the byte
; Note that each byte is actually 4 bits to the LCD module,
; so a even number must be sent or the display will get out
; of sync until the next display reset sequence.

        LDR     r5,%10                  ; bits-per-byte counter
        ADD     pc,pc,r0
10
        &       (1 :SHL: 24)
        LDR     r3,%11
        ADD     pc,pc,r0
11
        &       ts_recover_time         ; wait before sending data bits
12      ADDS    r3,r3,r3                ; for byte timing.
        BCC     %12

        ; Send a single bit : always 2 pulses for 0

13      LDR     r3,[r2]
        LDR     r3,[r2]

        ; and wait for the inter-bit time

        LDR     r3,%14
        ADD     pc,pc,r0
14
        &       ts_recover_time
15      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %15

        ; repeat until 8 bits are sent

        ADDS    r5,r5,r5
        BCC     %13

        ; do a RD operation to strobe the data out

        LDR     r5,%16
        ADD     pc,pc,r0
16
        &       1 :SHL: (32 - 12)
17
        LDR     r3,[r2]
        ADDS    r5,r5,r5
        BCC     %17

        ; repeat until a sufficient number of nuls are done

        ADDS    r7,r7,r1                ; count down loop counter
        BCS     %02

        ADD    pc,r0,r14                ; back to caller


        END
@


4.5
log
@More adjustments to >8MB POST situation.
Added a missing ALIGN before ts_ROM_dvectors.

Version 4.78. Tagged as 'Kernel-4_78'
@
text
@@


4.4
log
@First attempt to get POST working with >8M ROMs.

Version 4.77. Tagged as 'Kernel-4_77'
@
text
@d56 44
d131 1
a131 3
;
; Load up the registers for the test interface communication.
;
d133 1
a133 32
; If the ROM is >8M, we will use the fixed zero word in the ROM trailer.
; If not, we use the old scheme (in case someone is using an old ROM joiner
; that doesn't write the correct trailer.) Because the ROM is >8M, the
; trailer will be at an address with A23 set, as desired.
;
; KJB - note I haven't kept the purity of the minimal instruction set -
; I feel that it is unlikely that there ever will be a processor test,
; and if there is, then this won't be the only place where the purity
; has been broken...

        ASSERT  ts_Alias_bits = 8*1024*1024

        MOV     r0,#0
        LDR     r1,[r0, #ts_ROMSIZE]    ; size of ROM in bank 0
        CMP     r1,#8*1024*1024
        SUBHI   r2,r1,#20               ; zero word is at end-20
        BHI     %42

; Point r2 at a word which contains 0 in 0-8MB physical space.
; Note that this code doesn't cope with the case where it can't find a zero
; word anywhere in the whole ROM. I don't think that this is a problem.

	MOV	r0, #0			; expected below
	MOV	r2, #0			; start of physical space
01
	LDR	r1, [r2, #4]!
	TEQ	r1, r0			; is it zero?
	BNE	%01

	ADD	r2, r2, #ts_Alias_bits	; point to zero word in ghost
42
	MOV	r1, #-1			; expected below
d649 1
a649 14
; Point r2 at a word which contains 0 in 0-8MB physical space.
; If this word still reads as 0 when its ghost/alias is read from 8-16MB space
; (A23 set) then we don't have a test box, otherwise we do.
; Note that this code doesn't cope with the case where it can't find a zero
; word anywhere in the whole ROM. I don't think that this is a problem.

	MOV	r0, #0			; ts_send_command_byte expects r0=0
	MOV	r2, #0			; start of physical space
01
	LDR	r1, [r2, #4]!
	TEQ	r1, r0			; is it zero?
	BNE	%01

	ADD	r2, r2, #ts_Alias_bits	; point to zero word in ghost
@


4.3
log
@ROM speed not taken from the Machine header file.  POST can now exist
in a softloaded OS, since it searches for a zero word in the ROM
instead of using one within the POST when trying to communicate with
the POST adapter (the zero word must be in ROM).  Fixed to build on
non-chrontel STB/NC products.  Lots of duplicate code merged in
MemSize.  MemSize copes better with the softload case, and is less
willing to use the region the OS occupies as video memory, or
page tables.  POST is now ON (memory tests disabled).
OS_ReadSysInfo 4 now uses the NVRAM module to access the ethernet
address in NVRAM/CMOS, so that the availability/location of the
MAC address can be changed.  CMOS location 0 is now unprotected on
STB/NC products to try to stop people poking the hardware directly.
Fixed a CMOS resetting problem on STBs where the value expected in a
location was different from the value written on a CMOS reset, so the
CMOS would be reset every time...

Version 4.69. Tagged as 'Kernel-4_69'
@
text
@d7 1
a7 1
; and to receive byte- and word-sized objects   
d31 1
d39 2
a40 1
; Current (8M addressing space) ROMs only use address lines A2 to A22,
d48 5
a52 3
; The assumption that A23 is unused may be invalidated by a later issue
; of the PCB. Machines using larger ROMs than 8Mbytes will require explicit
; decoding or a new communication scheme.
d57 3
a59 3
; This section determines whether the test interface adapter exists, and 
; what variety is fitted (dumb, display or external)      
; 3 read operations are performed (a WS operation): if all of these 
d88 1
a88 1
; Load up the registers for the test interface communication -
d90 19
d121 1
d191 1
a191 1
        ADDS    r5,r4,r4                ; copy bits 7..3 to r5, bits 5..1 
d206 1
a206 1
        ADDS    r5,r5,r5                ; index * 2 -> index * 4 
d214 1
a214 1
13      LDR     r3,[r3]                 ; get table entry 
d221 1
a221 1
; This is the table of offsets to all the built-in functions. 
d253 1
a253 1
        ; pad the table out to 31 entries 
d442 1
a442 1
; Interface registers need to be set up : this function is called from test 
d445 1
a445 1
; The display is assumed to be a standard 16 character LCD module using 
d452 1
a452 1
; fitted to later adapters, it is suggested that the first 7 characters 
d464 1
a464 1
;           1   -       D5  }  
d473 1
a473 1
;           7   -       CPEN    Interface control :     0 for enable, 
d476 2
a477 2
; For each message sent, the display is first initialised, using the 
; following sequence (each byte is sent as 2 bytes, high nibble first, 
d480 1
a480 1
; interface hardware to strobe the data into the display. 
d814 1
a814 1
; The shift loop is used to generate the inter-byte delay normally 
d914 1
a914 1
        &       (((1 :SHL: 4) + 1) :SHL: 24)   
d1020 2
a1021 2
; permit the operator to read the text. 
; Use of the interface's monitor allows this delay to be increased 
d1065 1
a1065 1
        ADD     pc,pc,r0 
@


4.2
log
@Kernel merged
@
text
@a85 17
  [ :LNOT: CanLiveOnROMCard
        LDR     r0,%01                  ; set zero in r0
        ADD     pc,pc,r0  ;(generally useful constant - especially for skip)
01
        &       0
        LDR     r1,%02                  ; set FFFFFFFF in r1
        ADD     pc,pc,r0  ;(test value : sets carry when added to non-zero)
02
        &       (-1)
        LDR     r2,%03                  ; set pointer to test address
        ADD     pc,pc,r0  ;(points to aliased copy of a zero word)
03
        &       (ts_Alias_bits + (%01 - %04))
        ADDS    r2,pc,r2                ; adjust r2 for ROM-relative address
        ADDS    r4,r0,r0                ; clear output accumulator
04                                      ; where pc is when added to r2
  |
a99 1
  ]
a613 17
  [ STB :LAND: :LNOT: CanLiveOnROMCard
        LDR     r0,%01                  ; set zero in r0
        ADD     pc,pc,r0
01
        &       0
        LDR     r1,%02                  ; set FFFFFFFF in r1
        ADD     pc,pc,r0  ;(test value : sets carry when added to non-zero)
02
        &       (-1)
        LDR     r2,%03                  ; set pointer to test address
        ADD     pc,pc,r0  ;(points to aliased copy of a zero word)
03
        &       (ts_Alias_bits + (%01 - %04))
        ADDS    r2,pc,r2                ; adjust r2 for ROM-relative address
        ADDS    r0,r0,r0                ; dummy (to keep labels nearby !)
04                                      ; where pc points when added to r2
  |
a628 1
  ]
@


4.1
log
@Initial revision
@
text
@d26 5
a30 2
;
;
d37 4
a40 4
; The test adapter senses an access to the ROM with address line A21 high.
; Current (2M addressing space) ROMs only use address lines A2 to A20,
; so if A21 to A22 are asserted they will be ignored (the ROMS are aliased
; into 8M of space). With no test adapter, the aliased ROM location will
d42 1
a42 1
; ROMs when A21 is high, causing arbitrary data to be read. This data
d46 3
a48 5
; The assumption that A21 is unused may be invalidated by a later issue
; of the PCB. A22 is therefore asserted at the same time : this will then
; be used on a PCB where A22 is tracked to a test connector and 8Mbit ROMS
; are used. Machines using larger ROMs than 8 Mbit (4M addressing space) 
; will require explicit decoding or a new communication scheme.
d86 1
a86 1

d102 11
d114 4
d632 1
a632 1

d648 6
d655 10
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d26 2
a27 5
; 04-Oct-96	JRH		Updated comments to refer to test box on A23.
;				Added support for speaking to the test box when
;				running from the 2nd ROM bank, conditioned on
;				CanLiveOnROMCard. Needed because 2nd ROM bank
;				isn't ghosted on the A23 line like the 1st bank.
d34 4
a37 4
; The test adapter senses an access to the ROM with address line A23 high.
; Current (8M addressing space) ROMs only use address lines A2 to A22,
; so if A23 is asserted it will be ignored (the ROMS are aliased
; into 16M of space). With no test adapter, the aliased ROM location will
d39 1
a39 1
; ROMs when A23 is high, causing arbitrary data to be read. This data
d43 5
a47 3
; The assumption that A23 is unused may be invalidated by a later issue
; of the PCB. Machines using larger ROMs than 8Mbytes will require explicit
; decoding or a new communication scheme.
d85 1
a85 1
  [ :LNOT: CanLiveOnROMCard
a100 11
  |
; Point r2 at a word which contains 0 in 0-8MB physical space.
; Note that this code doesn't cope with the case where it can't find a zero
; word anywhere in the whole ROM. I don't think that this is a problem.

	MOV	r0, #0			; expected below
	MOV	r2, #0			; start of physical space
01
	LDR	r1, [r2, #4]!
	TEQ	r1, r0			; is it zero?
	BNE	%01
a101 4
	ADD	r2, r2, #ts_Alias_bits	; point to zero word in ghost
	MOV	r1, #-1			; expected below
04
  ]
d616 1
a616 1
  [ :LNOT: CanLiveOnROMCard
a631 6
  |
; Point r2 at a word which contains 0 in 0-8MB physical space.
; If this word still reads as 0 when its ghost/alias is read from 8-16MB space
; (A23 set) then we don't have a test box, otherwise we do.
; Note that this code doesn't cope with the case where it can't find a zero
; word anywhere in the whole ROM. I don't think that this is a problem.
a632 10
	MOV	r0, #0			; ts_send_command_byte expects r0=0
	MOV	r2, #0			; start of physical space
01
	LDR	r1, [r2, #4]!
	TEQ	r1, r0			; is it zero?
	BNE	%01

	ADD	r2, r2, #ts_Alias_bits	; point to zero word in ghost
04
  ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d26 2
a27 5
; 04-Oct-96	JRH		Updated comments to refer to test box on A23.
;				Added support for speaking to the test box when
;				running from the 2nd ROM bank, conditioned on
;				CanLiveOnROMCard. Needed because 2nd ROM bank
;				isn't ghosted on the A23 line like the 1st bank.
d34 4
a37 4
; The test adapter senses an access to the ROM with address line A23 high.
; Current (8M addressing space) ROMs only use address lines A2 to A22,
; so if A23 is asserted it will be ignored (the ROMS are aliased
; into 16M of space). With no test adapter, the aliased ROM location will
d39 1
a39 1
; ROMs when A23 is high, causing arbitrary data to be read. This data
d43 5
a47 3
; The assumption that A23 is unused may be invalidated by a later issue
; of the PCB. Machines using larger ROMs than 8Mbytes will require explicit
; decoding or a new communication scheme.
d85 1
a85 1
  [ :LNOT: CanLiveOnROMCard
a100 11
  |
; Point r2 at a word which contains 0 in 0-8MB physical space.
; Note that this code doesn't cope with the case where it can't find a zero
; word anywhere in the whole ROM. I don't think that this is a problem.

	MOV	r0, #0			; expected below
	MOV	r2, #0			; start of physical space
01
	LDR	r1, [r2, #4]!
	TEQ	r1, r0			; is it zero?
	BNE	%01
a101 4
	ADD	r2, r2, #ts_Alias_bits	; point to zero word in ghost
	MOV	r1, #-1			; expected below
04
  ]
d616 1
a616 1
  [ :LNOT: CanLiveOnROMCard
a631 6
  |
; Point r2 at a word which contains 0 in 0-8MB physical space.
; If this word still reads as 0 when its ghost/alias is read from 8-16MB space
; (A23 set) then we don't have a test box, otherwise we do.
; Note that this code doesn't cope with the case where it can't find a zero
; word anywhere in the whole ROM. I don't think that this is a problem.
a632 10
	MOV	r0, #0			; ts_send_command_byte expects r0=0
	MOV	r2, #0			; start of physical space
01
	LDR	r1, [r2, #4]!
	TEQ	r1, r0			; is it zero?
	BNE	%01

	ADD	r2, r2, #ts_Alias_bits	; point to zero word in ghost
04
  ]
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.5;
access;
symbols
	HAL_merge:4.4
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.4
	Kernel-5_35-4_79_2_326:4.4
	Kernel-5_35-4_79_2_325:4.4
	Kernel-5_35-4_79_2_324:4.4
	Kernel-5_35-4_79_2_323:4.4
	Kernel-5_35-4_79_2_322:4.4
	Kernel-5_35-4_79_2_321:4.4
	Kernel-5_35-4_79_2_320:4.4
	Kernel-5_35-4_79_2_319:4.4
	Kernel-5_35-4_79_2_318:4.4
	Kernel-5_35-4_79_2_317:4.4
	Kernel-5_35-4_79_2_316:4.4
	Kernel-5_35-4_79_2_315:4.4
	Kernel-5_35-4_79_2_314:4.4
	Kernel-5_35-4_79_2_313:4.4
	Kernel-5_35-4_79_2_312:4.4
	Kernel-5_35-4_79_2_311:4.4
	Kernel-5_35-4_79_2_310:4.4
	Kernel-5_35-4_79_2_309:4.4
	Kernel-5_35-4_79_2_308:4.4
	Kernel-5_35-4_79_2_307:4.4
	Kernel-5_35-4_79_2_306:4.4
	Kernel-5_35-4_79_2_305:4.4
	Kernel-5_35-4_79_2_304:4.4
	Kernel-5_35-4_79_2_303:4.4
	Kernel-5_35-4_79_2_302:4.4
	Kernel-5_35-4_79_2_301:4.4
	Kernel-5_35-4_79_2_300:4.4
	Kernel-5_35-4_79_2_299:4.4
	Kernel-5_35-4_79_2_298:4.4
	Kernel-5_35-4_79_2_297:4.4
	Kernel-5_35-4_79_2_296:4.4
	Kernel-5_35-4_79_2_295:4.4
	Kernel-5_35-4_79_2_294:4.4
	Kernel-5_35-4_79_2_293:4.4
	Kernel-5_35-4_79_2_292:4.4
	Kernel-5_35-4_79_2_291:4.4
	Kernel-5_35-4_79_2_290:4.4
	Kernel-5_35-4_79_2_289:4.4
	Kernel-5_35-4_79_2_288:4.4
	Kernel-5_35-4_79_2_287:4.4
	Kernel-5_35-4_79_2_286:4.4
	Kernel-5_35-4_79_2_285:4.4
	Kernel-5_35-4_79_2_284:4.4
	Kernel-5_35-4_79_2_283:4.4
	Kernel-5_35-4_79_2_282:4.4
	Kernel-5_35-4_79_2_281:4.4
	Kernel-5_35-4_79_2_280:4.4
	Kernel-5_35-4_79_2_279:4.4
	Kernel-5_35-4_79_2_278:4.4
	Kernel-5_35-4_79_2_277:4.4
	Kernel-5_35-4_79_2_276:4.4
	Kernel-5_35-4_79_2_275:4.4
	Kernel-5_35-4_79_2_274:4.4
	Kernel-5_35-4_79_2_273:4.4
	Kernel-5_35-4_79_2_272:4.4
	Kernel-5_35-4_79_2_271:4.4
	Kernel-5_35-4_79_2_270:4.4
	Kernel-5_35-4_79_2_269:4.4
	Kernel-5_35-4_79_2_268:4.4
	Kernel-5_35-4_79_2_267:4.4
	Kernel-5_35-4_79_2_266:4.4
	Kernel-5_35-4_79_2_265:4.4
	Kernel-5_35-4_79_2_264:4.4
	Kernel-5_35-4_79_2_263:4.4
	Kernel-5_35-4_79_2_262:4.4
	Kernel-5_35-4_79_2_261:4.4
	Kernel-5_35-4_79_2_260:4.4
	Kernel-5_35-4_79_2_259:4.4
	Kernel-5_35-4_79_2_258:4.4
	Kernel-5_35-4_79_2_257:4.4
	Kernel-5_35-4_79_2_256:4.4
	Kernel-5_35-4_79_2_255:4.4
	Kernel-5_35-4_79_2_254:4.4
	Kernel-5_35-4_79_2_253:4.4
	Kernel-5_35-4_79_2_252:4.4
	Kernel-5_35-4_79_2_251:4.4
	Kernel-5_35-4_79_2_250:4.4
	Kernel-5_35-4_79_2_249:4.4
	Kernel-5_35-4_79_2_248:4.4
	Kernel-5_35-4_79_2_247:4.4
	Kernel-5_35-4_79_2_246:4.4
	Kernel-5_35-4_79_2_245:4.4
	Kernel-5_35-4_79_2_244:4.4
	Kernel-5_35-4_79_2_243:4.4
	Kernel-5_35-4_79_2_242:4.4
	Kernel-5_35-4_79_2_241:4.4
	Kernel-5_35-4_79_2_240:4.4
	Kernel-5_35-4_79_2_239:4.4
	Kernel-5_35-4_79_2_238:4.4
	Kernel-5_35-4_79_2_237:4.4
	Kernel-5_35-4_79_2_236:4.4
	Kernel-5_35-4_79_2_235:4.4
	Kernel-5_35-4_79_2_234:4.4
	Kernel-5_35-4_79_2_233:4.4
	Kernel-5_35-4_79_2_232:4.4
	Kernel-5_35-4_79_2_231:4.4
	Kernel-5_35-4_79_2_230:4.4
	Kernel-5_35-4_79_2_229:4.4
	Kernel-5_35-4_79_2_228:4.4
	Kernel-5_35-4_79_2_227:4.4
	Kernel-5_35-4_79_2_226:4.4
	Kernel-5_35-4_79_2_225:4.4
	Kernel-5_35-4_79_2_224:4.4
	Kernel-5_35-4_79_2_223:4.4
	Kernel-5_35-4_79_2_222:4.4
	Kernel-5_35-4_79_2_221:4.4
	Kernel-5_35-4_79_2_220:4.4
	Kernel-5_35-4_79_2_219:4.4
	Kernel-5_35-4_79_2_218:4.4
	Kernel-5_35-4_79_2_217:4.4
	Kernel-5_35-4_79_2_216:4.4
	Kernel-5_35-4_79_2_215:4.4
	Kernel-5_35-4_79_2_214:4.4
	Kernel-5_35-4_79_2_213:4.4
	Kernel-5_35-4_79_2_212:4.4
	Kernel-5_35-4_79_2_211:4.4
	Kernel-5_35-4_79_2_210:4.4
	Kernel-5_35-4_79_2_209:4.4
	Kernel-5_35-4_79_2_208:4.4
	Kernel-5_35-4_79_2_207:4.4
	Kernel-5_35-4_79_2_206:4.4
	Kernel-5_35-4_79_2_205:4.4
	Kernel-5_35-4_79_2_204:4.4
	Kernel-5_35-4_79_2_203:4.4
	Kernel-5_35-4_79_2_202:4.4
	Kernel-5_35-4_79_2_201:4.4
	Kernel-5_35-4_79_2_200:4.4
	Kernel-5_35-4_79_2_199:4.4
	Kernel-5_35-4_79_2_198:4.4
	Kernel-5_35-4_79_2_197:4.4
	Kernel-5_35-4_79_2_196:4.4
	Kernel-5_35-4_79_2_195:4.4
	Kernel-5_35-4_79_2_194:4.4
	Kernel-5_35-4_79_2_193:4.4
	Kernel-5_35-4_79_2_192:4.4
	Kernel-5_35-4_79_2_191:4.4
	Kernel-5_35-4_79_2_190:4.4
	Kernel-5_35-4_79_2_189:4.4
	Kernel-5_35-4_79_2_188:4.4
	Kernel-5_35-4_79_2_187:4.4
	Kernel-5_35-4_79_2_186:4.4
	Kernel-5_35-4_79_2_185:4.4
	Kernel-5_35-4_79_2_184:4.4
	Kernel-5_35-4_79_2_183:4.4
	Kernel-5_35-4_79_2_182:4.4
	Kernel-5_35-4_79_2_181:4.4
	Kernel-5_35-4_79_2_180:4.4
	Kernel-5_35-4_79_2_179:4.4
	Kernel-5_35-4_79_2_178:4.4
	Kernel-5_35-4_79_2_177:4.4
	Kernel-5_35-4_79_2_176:4.4
	Kernel-5_35-4_79_2_175:4.4
	Kernel-5_35-4_79_2_174:4.4
	Kernel-5_35-4_79_2_173:4.4
	Kernel-5_35-4_79_2_172:4.4
	Kernel-5_35-4_79_2_171:4.4
	Kernel-5_35-4_79_2_170:4.4
	Kernel-5_35-4_79_2_169:4.4
	Kernel-5_35-4_79_2_168:4.4
	Kernel-5_35-4_79_2_167:4.4
	Kernel-5_35-4_79_2_166:4.4
	Kernel-5_35-4_79_2_165:4.4
	RPi_merge:4.4
	Kernel-5_35-4_79_2_147_2_23:4.4
	Kernel-5_35-4_79_2_147_2_22:4.4
	Kernel-5_35-4_79_2_147_2_21:4.4
	Kernel-5_35-4_79_2_147_2_20:4.4
	Kernel-5_35-4_79_2_147_2_19:4.4
	Kernel-5_35-4_79_2_147_2_18:4.4
	Kernel-5_35-4_79_2_164:4.4
	Kernel-5_35-4_79_2_163:4.4
	Kernel-5_35-4_79_2_147_2_17:4.4
	Kernel-5_35-4_79_2_147_2_16:4.4
	Kernel-5_35-4_79_2_147_2_15:4.4
	Kernel-5_35-4_79_2_162:4.4
	Kernel-5_35-4_79_2_161:4.4
	Kernel-5_35-4_79_2_147_2_14:4.4
	Kernel-5_35-4_79_2_147_2_13:4.4
	Kernel-5_35-4_79_2_160:4.4
	Kernel-5_35-4_79_2_159:4.4
	Kernel-5_35-4_79_2_158:4.4
	Kernel-5_35-4_79_2_157:4.4
	Kernel-5_35-4_79_2_156:4.4
	Kernel-5_35-4_79_2_147_2_12:4.4
	Kernel-5_35-4_79_2_147_2_11:4.4
	Kernel-5_35-4_79_2_155:4.4
	Kernel-5_35-4_79_2_147_2_10:4.4
	Kernel-5_35-4_79_2_154:4.4
	Kernel-5_35-4_79_2_153:4.4
	Kernel-5_35-4_79_2_147_2_9:4.4
	Kernel-5_35-4_79_2_152:4.4
	Kernel-5_35-4_79_2_151:4.4
	Kernel-5_35-4_79_2_147_2_8:4.4
	Kernel-5_35-4_79_2_147_2_7:4.4
	Kernel-5_35-4_79_2_150:4.4
	Kernel-5_35-4_79_2_147_2_6:4.4
	Kernel-5_35-4_79_2_147_2_5:4.4
	Kernel-5_35-4_79_2_149:4.4
	Kernel-5_35-4_79_2_147_2_4:4.4
	Kernel-5_35-4_79_2_147_2_3:4.4
	Kernel-5_35-4_79_2_148:4.4
	Kernel-5_35-4_79_2_147_2_2:4.4
	Kernel-5_35-4_79_2_147_2_1:4.4
	RPi:4.4.0.10
	RPi_bp:4.4
	Kernel-5_35-4_79_2_98_2_52_2_1:4.4
	alees_Kernel_dev:4.4.0.8
	alees_Kernel_dev_bp:4.4
	Kernel-5_35-4_79_2_147:4.4
	Kernel-5_35-4_79_2_146:4.4
	Kernel-5_35-4_79_2_145:4.4
	Kernel-5_35-4_79_2_144:4.4
	Kernel-5_35-4_79_2_143:4.4
	Kernel-5_35-4_79_2_142:4.4
	Kernel-5_35-4_79_2_141:4.4
	Kernel-5_35-4_79_2_140:4.4
	Kernel-5_35-4_79_2_139:4.4
	Kernel-5_35-4_79_2_138:4.4
	Kernel-5_35-4_79_2_137:4.4
	Kernel-5_35-4_79_2_136:4.4
	Kernel-5_35-4_79_2_135:4.4
	Kernel-5_35-4_79_2_134:4.4
	Kernel-5_35-4_79_2_133:4.4
	Kernel-5_35-4_79_2_132:4.4
	Kernel-5_35-4_79_2_131:4.4
	Kernel-5_35-4_79_2_130:4.4
	Kernel-5_35-4_79_2_129:4.4
	Kernel-5_35-4_79_2_128:4.4
	Kernel-5_35-4_79_2_127:4.4
	Kernel-5_35-4_79_2_126:4.4
	Kernel-5_35-4_79_2_125:4.4
	Kernel-5_35-4_79_2_124:4.4
	Kernel-5_35-4_79_2_123:4.4
	Cortex_merge:4.4
	Kernel-5_35-4_79_2_122:4.4
	Kernel-5_35-4_79_2_98_2_54:4.4
	Kernel-5_35-4_79_2_98_2_53:4.4
	Kernel-5_35-4_79_2_98_2_52:4.4
	Kernel-5_35-4_79_2_98_2_51:4.4
	Kernel-5_35-4_79_2_98_2_50:4.4
	Kernel-5_35-4_79_2_98_2_49:4.4
	Kernel-5_35-4_79_2_98_2_48:4.4
	Kernel-5_35-4_79_2_121:4.4
	Kernel-5_35-4_79_2_98_2_47:4.4
	Kernel-5_35-4_79_2_120:4.4
	Kernel-5_35-4_79_2_98_2_46:4.4
	Kernel-5_35-4_79_2_119:4.4
	Kernel-5_35-4_79_2_98_2_45:4.4
	Kernel-5_35-4_79_2_98_2_44:4.4
	Kernel-5_35-4_79_2_118:4.4
	Kernel-5_35-4_79_2_98_2_43:4.4
	Kernel-5_35-4_79_2_117:4.4
	Kernel-5_35-4_79_2_116:4.4
	Kernel-5_35-4_79_2_98_2_42:4.4
	Kernel-5_35-4_79_2_115:4.4
	Kernel-5_35-4_79_2_98_2_41:4.4
	Kernel-5_35-4_79_2_98_2_40:4.4
	Kernel-5_35-4_79_2_114:4.4
	Kernel-5_35-4_79_2_98_2_39:4.4
	Kernel-5_35-4_79_2_98_2_38:4.4
	Kernel-5_35-4_79_2_113:4.4
	Kernel-5_35-4_79_2_112:4.4
	Kernel-5_35-4_79_2_98_2_37:4.4
	Kernel-5_35-4_79_2_98_2_36:4.4
	Kernel-5_35-4_79_2_98_2_35:4.4
	Kernel-5_35-4_79_2_98_2_34:4.4
	Kernel-5_35-4_79_2_98_2_33:4.4
	Kernel-5_35-4_79_2_98_2_32:4.4
	Kernel-5_35-4_79_2_98_2_31:4.4
	Kernel-5_35-4_79_2_98_2_30:4.4
	Kernel-5_35-4_79_2_98_2_29:4.4
	Kernel-5_35-4_79_2_98_2_28:4.4
	Kernel-5_35-4_79_2_98_2_27:4.4
	Kernel-5_35-4_79_2_98_2_26:4.4
	Kernel-5_35-4_79_2_111:4.4
	Kernel-5_35-4_79_2_98_2_25:4.4
	Kernel-5_35-4_79_2_98_2_24:4.4
	Kernel-5_35-4_79_2_98_2_23:4.4
	Kernel-5_35-4_79_2_110:4.4
	Kernel-5_35-4_79_2_98_2_22:4.4
	Kernel-5_35-4_79_2_109:4.4
	Kernel-5_35-4_79_2_98_2_21:4.4
	Kernel-5_35-4_79_2_98_2_20:4.4
	Kernel-5_35-4_79_2_108:4.4
	Kernel-5_35-4_79_2_107:4.4
	Kernel-5_35-4_79_2_98_2_19:4.4
	Kernel-5_35-4_79_2_98_2_18:4.4
	Kernel-5_35-4_79_2_98_2_17:4.4
	Kernel-5_35-4_79_2_98_2_16:4.4
	Kernel-5_35-4_79_2_98_2_15:4.4
	Kernel-5_35-4_79_2_106:4.4
	Kernel-5_35-4_79_2_105:4.4
	Kernel-5_35-4_79_2_104:4.4
	Kernel-5_35-4_79_2_98_2_14:4.4
	Kernel-5_35-4_79_2_98_2_13:4.4
	Kernel-5_35-4_79_2_98_2_12:4.4
	Kernel-5_35-4_79_2_98_2_11:4.4
	Kernel-5_35-4_79_2_98_2_10:4.4
	Kernel-5_35-4_79_2_98_2_9:4.4
	Kernel-5_35-4_79_2_103:4.4
	Kernel-5_35-4_79_2_102:4.4
	Kernel-5_35-4_79_2_98_2_8:4.4
	Kernel-5_35-4_79_2_98_2_7:4.4
	Kernel-5_35-4_79_2_98_2_6:4.4
	Kernel-5_35-4_79_2_98_2_5:4.4
	Kernel-5_35-4_79_2_98_2_4:4.4
	Kernel-5_35-4_79_2_101:4.4
	Kernel-5_35-4_79_2_100:4.4
	Kernel-5_35-4_79_2_99:4.4
	Kernel-5_35-4_79_2_98_2_3:4.4
	Kernel-5_35-4_79_2_98_2_2:4.4
	Kernel-5_35-4_79_2_98_2_1:4.4
	Cortex:4.4.0.4
	Cortex_bp:4.4
	Kernel-5_35-4_79_2_98:4.4
	Kernel-5_35-4_79_2_97:4.4
	Kernel-5_35-4_79_2_96:4.4
	Kernel-5_35-4_79_2_95:4.4
	Kernel-5_35-4_79_2_94:4.4
	Kernel-5_35-4_79_2_93:4.4
	Kernel-5_35-4_79_2_92:4.4
	Kernel-5_35-4_79_2_91:4.4
	Kernel-5_35-4_79_2_90:4.4
	Kernel-5_35-4_79_2_89:4.4
	Kernel-5_35-4_79_2_88:4.4
	Kernel-5_35-4_79_2_87:4.4
	Kernel-5_35-4_79_2_86:4.4
	Kernel-5_35-4_79_2_85:4.4
	Kernel-5_35-4_79_2_84:4.4
	Kernel-5_35-4_79_2_83:4.4
	Kernel-5_35-4_79_2_82:4.4
	Kernel-5_35-4_79_2_81:4.4
	Kernel-5_35-4_79_2_80:4.4
	Kernel-5_35-4_79_2_79:4.4
	Kernel-5_35-4_79_2_78:4.4
	Kernel-5_35-4_79_2_77:4.4
	RO_5_07:4.4
	Kernel-5_35-4_79_2_76:4.4
	Kernel-5_35-4_79_2_75:4.4
	Kernel-5_35-4_79_2_74:4.4
	Kernel-5_35-4_79_2_73:4.4
	Kernel-5_35-4_79_2_72:4.4
	Kernel-5_35-4_79_2_71:4.4
	Kernel-5_35-4_79_2_70:4.4
	Kernel-5_35-4_79_2_69:4.4
	Kernel-5_35-4_79_2_68:4.4
	Kernel-5_35-4_79_2_67:4.4
	Kernel-5_35-4_79_2_66:4.4
	Kernel-5_35-4_79_2_65:4.4
	Kernel-5_35-4_79_2_64:4.4
	Kernel-5_35-4_79_2_63:4.4
	Kernel-5_35-4_79_2_62:4.4
	Kernel-5_35-4_79_2_61:4.4
	Kernel-5_35-4_79_2_59:4.4
	Kernel-5_35-4_79_2_58:4.4
	Kernel-5_35-4_79_2_57:4.4
	Kernel-5_35-4_79_2_56:4.4
	Kernel-5_35-4_79_2_55:4.4
	Kernel-5_35-4_79_2_54:4.4
	Kernel-5_35-4_79_2_53:4.4
	Kernel-5_35-4_79_2_52:4.4
	Kernel-5_35-4_79_2_51:4.4
	Kernel-5_35-4_79_2_50:4.4
	Kernel-5_35-4_79_2_49:4.4
	Kernel-5_35-4_79_2_48:4.4
	Kernel-5_47:4.4
	Kernel-5_46-4_90_2_1:4.4
	nbingham_Kernel_FastNC_dev_bp:4.4
	nbingham_Kernel_FastNC_dev:4.4.0.6
	Kernel-5_46:4.4
	Kernel-5_45:4.4
	Kernel-5_35-4_79_2_47:4.4
	Kernel-5_35-4_79_2_46:4.4
	Kernel-5_35-4_79_2_45:4.4
	Kernel-5_35-4_79_2_44:4.4
	Kernel-5_35-4_79_2_25_2_2:4.4
	Kernel-5_35-4_79_2_43:4.4
	Kernel-5_35-4_79_2_42:4.4
	Kernel-5_35-4_79_2_41:4.4
	Kernel-5_35-4_79_2_40:4.4
	Kernel-5_35-4_79_2_39:4.4
	Kernel-5_35-4_79_2_38:4.4
	Kernel-5_35-4_79_2_37:4.4
	Kernel-5_35-4_79_2_36:4.4
	Kernel-5_35-4_79_2_35:4.4
	Kernel-5_35-4_79_2_34:4.4
	Kernel-5_35-4_79_2_33:4.4
	Kernel-5_35-4_79_2_32:4.4
	Kernel-5_44:4.4
	Kernel-5_35-4_79_2_25_2_1:4.4
	Kernel-5_43:4.4
	Kernel-5_35-4_79_2_31:4.4
	Kernel-5_35-4_79_2_30:4.4
	Kernel-5_35-4_79_2_29:4.4
	Kernel-5_35-4_79_2_28:4.4
	Kernel-5_35-4_79_2_27:4.4
	Kernel-5_35-4_79_2_26:4.4
	Kernel-5_42:4.4
	Kernel-5_41:4.4
	Kernel-5_40:4.4
	Kernel-5_35-4_79_2_25:4.4
	Kernel-5_35-4_79_2_24:4.4
	Kernel-5_35-4_79_2_23:4.4
	Kernel-5_35-4_79_2_22:4.4
	Kernel-5_35-4_79_2_21:4.4
	Kernel-5_35-4_79_2_20:4.4
	Kernel-5_35-4_79_2_19:4.4
	Kernel-5_35-4_79_2_18:4.4
	Kernel-5_35-4_79_2_17:4.4
	Kernel-5_35-4_79_2_16:4.4
	Kernel-5_35-4_79_2_15:4.4
	Kernel-5_35-4_79_2_14:4.4
	Kernel-5_39:4.4
	Kernel-5_13-4_52_2_1:4.3
	Bethany:4.3.0.8
	Kernel-5_38:4.4
	Kernel-5_35-4_79_2_13:4.4
	Kernel-5_35-4_79_2_12:4.4
	Kernel-5_35-4_79_2_11:4.4
	Kernel-5_37:4.4
	Kernel-5_35-4_79_2_10:4.4
	Kernel-5_35-4_79_2_9:4.4
	Kernel-5_36:4.4
	Kernel-5_35-4_79_2_8:4.4
	Kernel-5_35-4_79_2_7:4.4
	Kernel-5_35-4_79_2_6:4.4
	Kernel-5_35-4_79_2_5:4.4
	Kernel-5_35-4_79_2_4:4.4
	Kernel-5_35-4_79_2_3:4.4
	Kernel-5_35-4_79_2_2:4.4
	dellis_autobuild_BaseSW:4.4
	Kernel-5_35-4_79_2_1:4.4
	HAL:4.4.0.2
	Kernel-5_35:4.4
	Kernel-5_34:4.4
	Kernel-5_33:4.4
	Kernel-5_32:4.4
	Kernel-5_31:4.4
	Kernel-5_30:4.4
	Kernel-5_29:4.4
	Kernel-5_28:4.4
	Kernel-5_27:4.4
	Kernel-5_26:4.4
	Kernel-5_25:4.4
	Kernel-5_24:4.4
	Kernel-5_23:4.4
	Kernel-5_22:4.3
	sbrodie_sedwards_16Mar2000:4.3
	Kernel-5_21:4.3
	Kernel-5_20:4.3
	Kernel-5_19:4.3
	Kernel-5_18:4.3
	Kernel-5_17:4.3
	Kernel-5_16:4.3
	Kernel-5_15:4.3
	Kernel-5_14:4.3
	Kernel-5_13:4.3
	Kernel-5_12:4.3
	Kernel-5_11:4.3
	Kernel-5_10:4.3
	Kernel-5_09:4.3
	Kernel-5_08:4.3
	Kernel-5_07:4.3
	Kernel-5_06:4.3
	Kernel-5_05:4.3
	Kernel-5_04:4.3
	Kernel-5_03:4.3
	Kernel-5_02:4.3
	Kernel-5_01:4.3
	Kernel-5_00:4.3
	Kernel-4_99:4.3
	Kernel-4_98:4.3
	Kernel-4_97:4.3
	Kernel-4_96:4.3
	Kernel-4_95:4.3
	Kernel-4_94:4.3
	Kernel-4_93:4.3
	Kernel-4_92:4.3
	Kernel-4_91:4.3
	Kernel-4_90:4.3
	dcotton_autobuild_BaseSW:4.4
	Kernel-4_89:4.3
	Kernel-4_88:4.3
	Kernel-4_87:4.3
	Kernel-4_86:4.3
	Kernel-4_85:4.3
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.3
	Kernel-4_84:4.3
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.3
	Ursula_RiscPC_bp:4.3
	Kernel-4_83:4.3
	Kernel-4_82:4.3
	Kernel-4_81:4.3
	Kernel-4_80:4.3
	Kernel-4_79:4.3
	Kernel-4_78:4.3
	Kernel-4_77:4.3
	Kernel-4_76:4.3
	Kernel-4_75:4.3
	Kernel-4_74:4.3
	Kernel-4_73:4.3
	Kernel-4_72:4.3
	Kernel-4_71:4.3
	Kernel-4_70:4.3
	Kernel-4_69:4.3
	Kernel-4_68:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.6
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.3
	Kernel-4_66:4.3
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.3
	Ursula_merge:4.3
	Kernel-4_64:4.3
	mstphens_Kernel-3_81:4.3
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	mstphens_Kernel-3_80:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.3
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2016.06.30.20.28.47;	author jlee;	state dead;
branches;
next	4.4;
commitid	lMnWzoE9eJz3Wwcz;

4.4
date	2000.04.04.14.27.22;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.05.51.40;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.06.41;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.45;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.41.45;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.04.26;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.08.09.12;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.16.45.50;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.14.01;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.05.16;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; > TestSrc.Mem1IOMD

        TTL RISC OS 2+ POST memory linetest
;
; This test code is used to perform basic integrity tests on DRAM.
; It doesn't test all locations - just walks patterns through data
; and address lines.
;
;------------------------------------------------------------------------
; History
;
; Date          Name            Comment
; ----          ----            -------
; 1-Jun-93      ArtG            Derived from Mem1 for use on Medusa
; 18-Nov-94     RCM             Morris changes
; 24-Jun-96	BAR		Change the IOMD ID code checking code,
;				instead of checking for ARM7500 and skipping
;				ARM7500 specifi code if not equal, not
;				checks for original (RriscPC) IOM ID code
;				and skip if equal, thus ARM7500 and
;				ARM7500FE parts still do correct test.
; 08-Jul-96     BAR             Ensure r0 is cleared before checking IOMD vsn no.
;
;------------------------------------------------------------------------

;
; Test the data and address and byte strobe lines for uniqueness.
;

        LTORG
        ROUT

1
        =       "VRAM  :",0
2
        =       "VRAM-F",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
3
        =       "DRAM ",&ff,":",0
4
        =       "Data  :",0
5
        =       &88,&ff,&ff," MByte",0

        ALIGN

ts_LineTest
 [ MorrisSupport
        MOV     r12, #IOMD_Base
        MOV     r0,#0                   ; Clear out r0
        LDRB    r1,[r12,#IOMD_ID1]	; load r1 with IOMD ID high byte
        ORR     r0,r0,r1, LSL #8	; Or r0 and r1 - shifted left 8, put in r0
        LDRB    r1,[r12,#IOMD_ID0]	; load r1 with IOMD ID low byte
        ORR     r0,r0,r1		; Or r0 and r1, put in r0
        LDR     r1,=ts_IOMD_ID1		; get Ref IOMD ID code #1 (Original)
        CMPS    r0,r1                   ; check for IOMD ID Code #1
	BEQ	ts_LineTestIOMD         ; Original IOMD, not 7500 or 7500FE, assume RiscPC hardware
;
; Here bceause its an ARM7500 or ARM7500 'FE' variant : Morris H/W
;
        MOV     r11, #IOMD_DRAMWID_DRAM_32bit * &0F     ;set all 4 banks to be 32bit initially
 	LDR	r1, =ts_IOMD_ID3
	TEQ	r0, r1					; are we on FE part?
	ORREQ	r11, r11, #IOMD_DRAMWID_EDO_Enable :OR: IOMD_DRAMWID_RASCAS_3 :OR: IOMD_DRAMWID_RASPre_4
							; if so, then enable EDO and slower RASCAS and RASPre times

; ts_LineTest for Morris
;
        MOV     r14, #IOMD_Base
        STRB    r11, [r14, #IOMD_DRAMWID]

; enable 32-bit addressing of data, also forces 26 bit mode, if ARM 6/7 (since P bit zero)
        MOV     r0,#MMUC_D
        SetCop  r0,CR_Control

        MOV     r0,#0
        MOV_fiq r9,r0                                   ; r9-fiq records low DRAM address for use elsewhere

        MOV     r10, #0                                 ;indicate no RAM found yet
        MOV     r9, #IOMD_DRAMWID_DRAM_16bit            ;bit to OR into DRAMWID to set 16bit
        MOV     r12, #DRAM0PhysRam
;
; r12    DRAM address
; r9    IOMD_DRAMWID_DRAM_16bit for current DRAM bank
; r11   current IOMD_DRAMWID register contents
;
;ExamineDRAMBank                                        ;examine first/next DRAM bank
2005
;
        MOV     r8,r12,LSL #2                           ; indicate bank under test
        AND     r8,r8,#(3 :SHL: 28)
        ADR     r4,%BT3
        BL      ts_SendText
;
        MOV     r8,#0                                   ; r8 indicates RAM found in this bank

        LDMIA   r12, {r1, r2}                            ;Preserve the two locations that we widdle on

        ADRL    r3, funnypatterns                       ;We write different values to two locations
        LDMIA   r3, {r3, r4}                            ; incase bus capacitance holds our value
        STMIA   r12, {r3, r4}
        LDMIA   r12, {r5, r6}                            ;Reread test locations
        EORS    r5, r5, r3                              ;Both locations should read correctly
        EOR     r6, r6, r4                              ; if memory is 32bits wide
       ;TEQ     r5, #0
        TEQEQ   r6, #0
        BEQ     %FT2010                                   ;32bit wide memory

        TST     r5, #&00FF                              ;If the bottom 16bits of each location
        TSTEQ   r5, #&FF00                              ; are correct, the memory is 16bits wide
        TSTEQ   r6, #&00FF
        TSTEQ   r6, #&FF00
        BNE     %FT2050                                 ;No memory in this bank

        ORR     r11, r11, r9                            ;Bank is 16bits wide
2010
        STMIA   r12, {r1, r2}                            ;Restore the two locations we widdled on
                                                        ;Must do BEFORE poking the DRAMWID register
        MOV     r14, #IOMD_Base                         ;
        STRB    r11, [r14, #IOMD_DRAMWID]               ;
;
; minimum ram test
;
        MOV     r0, r12
        ADD     r1, r12, #A18
        BL      DistinctAddresses
        BNE     %FT2050                                 ;Less than 512KBytes, so ignore this bank

        MOV_fiq r2,r9                                   ; if this is the first bank of DRAM or VRAM,
        TEQS    r2,#0                                   ; put it's address in r9_fiq
        BNE     %FT2012
        MOV_fiq r9,r0
2012


        MOV     r6, #0                                  ;Fragment address
        MOV     r7, #0                                  ;Fragment address
        MOV     r8, #A19                                ; now go through address lines A19-A25
2015
        MOV     r0, r12
        ADD     r1, r12, r8                              ; see if this address line is unique
        BL      DistinctAddresses
        BNE     %FT2020                                   ; if we've failed then r8 is true size, so exit
        MOV     r8, r8, LSL #1                          ; else shift up to next
        TEQ     r8, #A26                                ; only test up to A25
        BNE     %BT2015
        BEQ     %FT2035                           ;Bank fully occupied, DON'T test for higher fragments
2020
;
; Found some DRAM, at address r0, size r8.
; There may be one or two higher address lines connected, so scan upto A25 looking for
; extra DRAM chunks.
;
        MOV     r1, r8
2025
        TEQ     r1, #A25
        BEQ     %FT2035                           ;No higher active address lines found ie one lump of DRAM
        ADD     r1, r0, r1,LSL #1
        BL      DistinctAddresses
        SUB     r1, r1, r0                              ;Recover bit value
        BNE     %BT2025
;
; Got a 2nd fragment, at address r1 (also of size r8)
;
        MOV     r6, r1
2030
        TEQ     r1, #A25
        BEQ     %FT2035                           ;No higher active address lines found ie two lumps of DRAM
        ADD     r1, r0, r1,LSL #1
        BL      DistinctAddresses
        SUB     r1, r1, r0                              ;Recover bit value
        BNE     %BT2030
;
; Got another active address line (ie total four fragments)
;
        MOV     r7, r1
;
2035
;
; Found 1, 2 or 4 lumps of DRAM
;
;NoRamInBank
2050
        MOV     r13, r8
        TEQ     r6, #0
        MOVNE   r13, r13, LSL #1
        TEQNE   r7, #0
        MOVNE   r13, r13, LSL #1                        ; remember size of this bank in bytes
        MOV     r8,r13,LSL #(24 - 20)                   ; and display it in 2 digits, in MBytes.
        ADR     r4,%BT5
        BL      ts_MoreText


        ADRL    r4,%FT73                                ; announce data line test
        BL      ts_SendText
        MOV     r1,r12                                  ; do walking bit test
        BL      ts_Dataline
        BEQ     %FT2055                                 ; looks OK, carry on to next bank

        ADRL    r4,%FT74                                ; bit test failed, so report it
        MOV     r8,r0
        BL      ts_SendText                             ; and bit fault mask

        CMPS    r13,#0                                  ; was any RAM thought to be here ?
        BEQ     %FT2055
        FAULT   #R_LINFAILBIT                           ; if so, it's faulty.
        MOV     r13,#0                                  ; so ignore it
2055
2055
;
; If there was some RAM found here, and it passed the dataline test,
; do the address and bytestrobe tests on it too.
;
        CMPS    r13,#0
        BEQ     %FT2060

        ADRL    r4,%FT75                                ; announce start of address line test
        BL      ts_SendText
        MOV     r1,r12                                  ; test address lines in this block
        MOV     r0,r13, LSR #2                          ; bank may be in 4 fragments
        BL      ts_Addrline
        BEQ     %FT2056
        ADRL    r4,%FT76                                ; failed - report error mask
        MOV     r8,r0
        BL      ts_SendText
        FAULT   #R_LINFAILBIT                           ; and record failure
        MOV     r13,#0                                  ; then forget this memory block

2056
        ADR     r4,%FT77                                ; announce start of byte test
        BL      ts_SendText
        MOV     r1,r12
        BL      ts_Byteword
        BEQ     %FT2060
        ADR     r4,%FT78                                ; failed - report error mask
        MOV     r8,r0,LSL #16
        BL      ts_SendText
        FAULT   #R_LINFAILBIT                           ; and record failure
        MOV     r13,#0                                  ; then forget this memory block
2060


; If the RAM found still seems OK, add it's size into the r10 accumulator
; Working or not, carry on to check the next bank.

        ADD     r10,r10,r13                             ; accumulate DRAM if any found
        ADD     r12, r12, #DRAM1PhysRam-DRAM0PhysRam    ; move onto next bank
        MOV     r9, r9, LSL #1                          ; shunt up position in DRAMWID
        CMP     r9, #&0010                              ; if more banks to do
        BLT     %BT2005                                 ; then loop

        ADR     r4,%FT70
        BL      ts_SendText                             ; None found .. print message

        MOVS    r8,r10,LSL #(24 - 20)                   ; all finished ..
        ADREQL  r4,%FT71                                ; did we find any DRAM?
        ADRNEL  r4,%FT72
        BNE     %FT2065
        FAULT   #R_LINFAILBIT                           ; fault if we didn't
2065
        BL      ts_MoreText
        B       ts_endline


 ]

ts_LineTestIOMD
        ADR     r4,%BT1
        BL      ts_SendText                             ; Start data line tests on VRAM

        MOV     r0,#0
        MOV_fiq r9,r0                                   ; r9-fiq records VRAM or low DRAM address

        MOV     r12, #IOMD_Base
        MOV     r2, #IOMD_VREFCR_VRAM_256Kx64 :OR: IOMD_VREFCR_REF_16 ; assume 2 banks of VRAM by default
        STRB    r2, [r12, #IOMD_VREFCR]

; Find the size, using MemSize's method

        MOV     r0, #VideoPhysRam                       ; point at VRAM
        ADD     r1, r0, #A2                             ; test A2
        BL      DistinctAddresses
        MOVEQ   r9, #2                                  ; we've got 2M of VRAM
        BEQ     %FT21

        MOV     r2, #IOMD_VREFCR_VRAM_256Kx32 :OR: IOMD_VREFCR_REF_16
        STRB    r2, [r12, #IOMD_VREFCR]
        ADD     r1, r0, #A2                             ; check for any VRAM at all
        BL      DistinctAddresses
        MOVEQ   r9, #1                                  ; we've got 1M of VRAM
        MOVNE   r9, #0                                  ; no VRAM
21
        BNE     %FT22
        MOV_fiq r9,r0                                   ; record VRAM address
        FAULT   #R_VRAM                                 ; indicate VRAM present

; Report size .. if this is non-zero and the data line test fails,
; RISC OS will have problems.

22
        ADR     r4,%BT5                                 ; Add size (in hex Mbyte)
        MOV     r8,r9, LSL #24                          ; to "VRam : " message
        BL      ts_MoreText

; Worked out what size VRAM is, and set up IOMD register.
; Do a data line test on the resulting array, repeated at oddword address to
; ensure both banks get tested with walking 0 and walking 1

        ADR     r4,%BT4
        BL      ts_SendText
        MOV     r1, #VideoPhysRam
        BL      ts_Dataline
        ADDEQ   r1,r1,#4
        BLEQ    ts_Dataline
        BEQ     %FT25                   ; looks OK - carry on with VRAM test
;
; Data line test failed. Report the bitmap that failed, then carry on.
;
        ADR     r4,%BT2
        MOV     r8,r0                   ; report data fault mask
        BL      ts_SendText
        B       %FT30

;
; If there was some VRAM found here, and it passed the dataline test,
; do the address and bytestrobe tests on it too.
;

25
        ADRL    r4,%FT75                                ; announce start of address line test
        BL      ts_SendText
        MOV     r1,#VideoPhysRam
        MOV     r0,r9,LSL #20                           ; size in MB determined before dataline test
        BL      ts_Addrline
        BEQ     %FT26
        ADRL    r4,%FT76                                ; failed - report error mask
        MOV     r8,r0
        BL      ts_SendText
        FAULT   #R_LINFAILBIT                           ; and record failure
        B       %FT30
26
        ADRL    r4,%FT77                                ; announce start of byte test
        BL      ts_SendText
        MOV     r1,#VideoPhysRam
        BL      ts_Byteword
        ADDEQ   r1,r1,#4                                ; retest at an oddword boundary
        BLEQ    ts_Byteword
        BEQ     %FT27
        ADRL    r4,%FT78                                ; failed - report error mask
        MOV     r8,r0,LSL #16
        BL      ts_SendText
        FAULT   #R_LINFAILBIT                           ; and record failure
27


; Similarly, test each DRAM bank in turn, reporting failures or sizes for each

30
        MOV     r11, #IOMD_DRAMCR_DRAM_Large * &55      ; set all banks to be large initially
        MOV     r14, #IOMD_Base
        STRB    r11, [r14, #IOMD_DRAMCR]

; enable 32-bit addressing of data, also forces 26 bit mode, if ARM 6/7 (since P bit zero)
        MOV     r0,#MMUC_D
        SetCop  r0,CR_Control

        MOV     r10, #0                                 ; indicate no RAM found yet
        MOV     r9, #IOMD_DRAMCR_DRAM_Small             ; bit to OR into DRAMCR
        MOV     r12, #DRAM0PhysRam
35
        MOV     r8,r12,LSL #2                           ; indicate bank under test
        AND     r8,r8,#(3 :SHL: 28)
        ADRL    r4,%BT3
        BL      ts_SendText

        MOV     r8,#0                                   ; r8 indicates RAM found in this bank
        MOV     r0, r12
        ADD     r1, r12, #A10                           ; this should be OK for both configurations
        BL      DistinctAddresses
        BNE     %FT50                                   ; [no RAM in this bank at all]

        MOV_fiq r2,r9                                   ; if this is the first bank of DRAM or VRAM,
        TEQS    r2,#0                                   ; put it's address in r9_fiq
        BNE     %FT36
        MOV_fiq r9,r0

36      ADD     r1, r12, #A11                           ; test for 256K DRAM
        BL      DistinctAddresses
        ORRNE   r11, r11, r9                            ; it is, so select small multiplexing
        MOVNE   r14, #IOMD_Base
        STRNEB  r11, [r14, #IOMD_DRAMCR]                ; store new value of DRAMCR, so we can use memory immediately
        MOVNE   r8, #1024*1024                          ; must be 1Mbyte at this address
        BNE     %FT50

; it's bigger than 256K words, so test address lines A21-A25 in sequence
; we assume that the size of each bank is a power of 2

        MOV     r8, #A21                                ; now go through address lines A21-A25
40
        ADD     r1, r12, r8                             ; see if this address line is unique
        BL      DistinctAddresses
        BNE     %FT50                                   ; if we've failed then r8 is true size, so exit
        MOV     r8, r8, LSL #1                          ; else shift up to next
        TEQ     r8, #A26                                ; only test up to A25
        BNE     %BT40

50
        MOV     r13,r8                                  ; remember size of this bank in bytes
        MOV     r8,r13,LSL #(24 - 20)                   ; and display it in 2 digits, in MBytes.
        ADRL    r4,%BT5
        BL      ts_MoreText

        ADRL    r4,%FT73                                ; announce data line test
        BL      ts_SendText
        MOV     r1,r12                                  ; do walking bit test
        BL      ts_Dataline
        BEQ     %FT55                                   ; looks OK, carry on to next bank

        ADRL    r4,%FT74                                ; bit test failed, so report it
        MOV     r8,r0
        BL      ts_SendText                             ; and bit fault mask

        CMPS    r13,#0                                  ; was any RAM thought to be here ?
        BEQ     %FT55
        FAULT   #R_LINFAILBIT                           ; if so, it's faulty.
        MOV     r13,#0                                  ; so ignore it
55

;
; If there was some RAM found here, and it passed the dataline test,
; do the address and bytestrobe tests on it too.
;
        CMPS    r13,#0
        BEQ     %FT60

        ADR     r4,%FT75                                ; announce start of address line test
        BL      ts_SendText
        MOV     r1,r12                                  ; test address lines in this block
        MOV     r0,r13
        BL      ts_Addrline
        BEQ     %FT56
        ADR     r4,%FT76                                ; failed - report error mask
        MOV     r8,r0
        BL      ts_SendText
        FAULT   #R_LINFAILBIT                           ; and record failure
        MOV     r13,#0                                  ; then forget this memory block

56
        ADR     r4,%FT77                                ; announce start of byte test
        BL      ts_SendText
        MOV     r1,r12
        BL      ts_Byteword
        BEQ     %FT60
        ADR     r4,%FT78                                ; failed - report error mask
        MOV     r8,r0,LSL #16
        BL      ts_SendText
        FAULT   #R_LINFAILBIT                           ; and record failure
        MOV     r13,#0                                  ; then forget this memory block
60


; If the RAM found still seems OK, add it's size into the r10 accumulator
; Working or not, carry on to check the next bank.

        ADD     r10,r10,r13                             ; accumulate DRAM if any found
        ADD     r12, r12, #DRAM1PhysRam-DRAM0PhysRam    ; move onto next bank
        MOV     r9, r9, LSL #2                          ; shunt up position in DRAMCR
        CMP     r9, #&100                               ; if more banks to do
        BCC     %BT35                                   ; then loop

        ADR     r4,%FT70
        BL      ts_SendText                             ; None found .. print message

        MOVS    r8,r10,LSL #(24 - 20)                   ; all finished ..
        ADREQ   r4,%FT71                                ; did we find any DRAM?
        ADRNE   r4,%FT72
        BNE     %FT65
        FAULT   #R_LINFAILBIT                           ; fault if we didn't
65
        BL      ts_MoreText
        B       ts_endline


70
        =       "DRAM",0
71
        =       &88,"Failed",0
72
        =       &88,&ff,&ff," MByte",0
73
        =       "Data  :",0
74
        =       "Data-F",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
75
        =       "Addrs :",0
76
        =       "Addrs-F",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
77
        =       "Byte  :",0
78
        =       "Byte-F",&88,&ff,&ff,&ff,&ff,0


;
; Data line test.
;
; In  : r1  - start address for test
;
; Out : r0  - failing data pattern
;       r1  - address of failure
;
;
; This exercises data lines in attempt to find shorts/opens.
; It goes something like :
;
;       for (ptr = address, pattern = 1; pattern != 0; pattern <<= 1)
;               *ptr++ =  pattern;
;               *ptr++ = ~pattern;
;       for (ptr = address, pattern = 1; pattern != 0; pattern <<= 1)
;               result |=  pattern ^ *ptr++;
;               result |= ~pattern ^ *ptr++;
;       return result and address
;

ts_Dataline     ROUT

;
; Write all walking-zero, walking-one patterns
;
10      MOV     r6,r1                   ; set pointer for a write loop
        MOV     r5,#1                   ; set initial test pattern
        MVN     r4,r5                   ; and it's inverse
11
        STMIA   r6!,{r4-r5}             ; write the patterns

        ADDS    r5,r5,r5                ; shift the pattern (into Carry)
        MVN     r4,r5
        BCC     %BT11                   ; repeat until all bits done
;
; Read back and accumulate in r0 any incorrect bits
;
        MOV     r6,r1                   ; set pointer for a read loop
        MOV     r5,#1                   ; set initial test pattern
        MVN     r4,r5                   ; and it's inverse
        MOV     r0,#0                   ; accumulate result
21
        LDMIA   r6!,{r2-r3}             ; read the patterns
        EOR     r2,r2,r4
        ORR     r0,r0,r2                ; OR any failed bits into r0
        EOR     r3,r3,r5
        ORR     r0,r0,r2

        ADDS    r5,r5,r5                ; shift the pattern (into Carry)
        MVN     r4,r5
        BCC     %BT21                   ; repeat until all bits done
;
; After all checks at this address group, report back errors
;
        MOVS    r0,r0                   ; check for any result bits set
        MOV     pc,r14                  ; return r0 with error map (or 0)



;
; Address line test
;
; In  : r0  - size of memory block
;       r1  - start address of memory block
;
; Out : r0  - failing address bit mask
;
; This exercises address lines in an attempt to find any which don't
; work (i.e., don't select unique addresses).
;
; It works something like :
;
; MaxRam = PhysRam | (Memory size - 4);
; for (pattern = 4; pattern < memsize; pattern <<= 1 )
;       *(PhysRam ^ pattern) = pattern;
;       *(MaxRam  ^ pattern) = ~pattern;
; for (pattern = 4; pattern < memsize; pattern <<= 1 )
;       if (*PhysRam == *(PhysRam ^ pattern))
;               result |= pattern;
;       if (*MaxRam == *(MaxRam + pattern))
;               result |= pattern;
;  return result
;


ts_Addrline     ROUT

        MOVS    r7,r0                   ; Save memory size
        SUB     r6,r0,#4                ; Calculate MaxRam
        ADD     r6,r6,r1                ; (all-bits-set memory address)
;
; Mark (walking one, walking 0) addresses with unique patterns
;
        LDR     r5,=&5A5AA5A5           ; initialize end markers
        STR     r5,[r6]
        MVN     r4,r5
        MOV     r3,r1
        STR     r4,[r3]

        MOV     r5,#4                   ; initialize pattern
02
        MVN     r4,r5
        EOR     r3,r5,r1                ; point to (start ^ pattern)
        STR     r4,[r3]
        EOR     r3,r5,r6                ; point to (end ^ pattern)
        STR     r5,[r3]

        MOV     r5,r5,LSL #1            ; shift test pattern up
        CMPS    r5,r7                   ; test bit still inside memory ?
        BCC     %02                     ; reached top bit - end this loop
;
; Check (walking one, walking 0) addresses for effectivity
;
        MOV     r5,#4                   ; initialize pattern
        MOV     r3,r1
        MOV     r0,#0
04
        MVN     r4,r5
        EOR     r2,r5,r3                ; point to (start ^ pattern)
        LDR     r2,[r2]
        LDR     r1,[r3]
        CMPS    r1,r2                   ; do contents differ ?
        ORREQ   r0,r0,r5                ; no - record ineffective bit

        EOR     r2,r5,r6                ; point to (end ^ pattern)
        LDR     r2,[r2]
        LDR     r1,[r6]
        CMPS    r1,r2                   ; do contents differ ?
        ORREQ   r0,r0,r5                ; no - record ineffective bit

        MOV     r5,r5,LSL #1            ; shift test pattern up
        CMPS    r5,r7                   ; test bit still inside memory ?
        BCC     %04                     ; reached top bit - end this loop

        MOVS    r0,r0                   ; any result bits set - return error
        MOV     pc,r14


;
; Byte / word test
;
; In  :  r1 - memory start
;
; Out :  r0 - Failure indication
;
; This test ensures that individual bytes may be written to each part of a word
; without affecting the other bytes in the word.
;
;       for (byte = 0; byte < 4; byte ++)
;               address[0] = word_signature
;               address[1] = ~word_signature
;               address + byte = byte_signature
;               if (address[0] !=
;                                 (word_signature & (~ff << byte * 8))
;                               | (byte_signature        << byte * 8)  )
;                       result |= (1 << byte)
;       if (result != 0
;               result |= address;      /* fail at address, byte(s)     */
;       return result;                       /* pass */
;

ts_Byteword     ROUT

        LDR     r3,=&AABBCCDD           ; word signature
        MOV     r0,#0
        MOV     r2,r0
;
; byte test loop ( for bytes 0 to 4  ...)
;
02
        MVN     r4,r3
        STMIA   r1,{r3,r4}              ; write word signature
        STRB    r2,[r1,r2]              ; write byte (0, 1, 2 or 3)

        MOV     r4,r2,LSL #3            ; calculate expected result
        MOV     r5,#&ff
        MVN     r5,r5,LSL r4
        AND     r5,r5,r3                ; word signature, byte removed
        ORR     r5,r5,r2,LSL r4         ; byte signature inserted

        LDR     r4,[r1,#4]              ; read (probable) inverse data to precharge bus
        LDR     r4,[r1]                 ; read modified word
        CMPS    r4,r5
        MOV     r5,#1
        MOV     r4,r2,LSL #2
        ORRNE   r0,r0,r5,LSL r4         ; fault : set bit in result mask
;
; Loop for next byte
;
        ADD     r2,r2,#1                ; Bump byte counter
        CMPS    r2,#4                   ; ... until 4 byte strobes tested
        BLO     %BT02
;
; byte strobes all tested : check for errors
;
        CMPS    r0,#0
        MOV     pc,r14                  ; Result : return address and fault mask.

;
; End of RAM line tests
;

ts_endline

        END
@


4.4
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@@


4.3
log
@RISC OS 3.71 kernel changes merged.
Not fully tested on all hardware permutations.
@
text
@a74 4
  [ StrongARM_POST
        Ensure26bit_ARM8A r0
  ]

a364 4

  [ StrongARM_POST
        Ensure26bit_ARM8A r10
  ]
@


4.2
log
@Kernel merged
@
text
@d70 3
a72 1
        MOV     r0,#MMUC_D                              ; enable 32-bit addressing of data
d75 4
d365 3
a367 1
        MOV     r0,#MMUC_D                              ; enable 32-bit addressing of data
d369 4
@


4.1
log
@Initial revision
@
text
@d16 7
a22 1
;
d49 16
a65 7
        LDRB    r0, [r12, #IOMD_ID0]
        CMP     r0, #&98
        LDRB    r0, [r12, #IOMD_ID1]
        CMPEQ   r0, #&5B
        BNE     ts_LineTestIOMD                         ; NOT MORRIS assume Medusa hardware

;
a67 1
        MOV     r11, #IOMD_DRAMWID_DRAM_32bit * &0F     ;set all 4 banks to be 32bit initially
d243 1
a243 1
        ADD     r10,r10,r13                             ; accumulate DRAM if any found 
d300 1
a300 1
        BL      ts_MoreText     
d302 2
a303 2
; Worked out what size VRAM is, and set up IOMD register. 
; Do a data line test on the resulting array, repeated at oddword address to 
d460 1
a460 1
        ADD     r10,r10,r13                             ; accumulate DRAM if any found 
d527 1
a527 1
        MVN     r4,r5                   ; and it's inverse        
d539 1
a539 1
        MVN     r4,r5                   ; and it's inverse        
d554 1
a554 1
        MOVS    r0,r0                   ; check for any result bits set 
d572 1
a572 1
; MaxRam = PhysRam | (Memory size - 4); 
d675 1
a675 1
        MOV     r5,#&ff     
d690 1
a690 1
        CMPS    r2,#4                   ; ... until 4 byte strobes tested 
d704 1
a704 2
        END 
 @


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d16 1
a16 7
; 24-Jun-96	BAR		Change the IOMD ID code checking code,
;				instead of checking for ARM7500 and skipping
;				ARM7500 specifi code if not equal, not
;				checks for original (RriscPC) IOM ID code
;				and skip if equal, thus ARM7500 and
;				ARM7500FE parts still do correct test.
; 08-Jul-96     BAR             Ensure r0 is cleared before checking IOMD vsn no.
d43 7
a49 8
        MOV     r0,#0                   ; Clear out r0
        LDRB    r1,[r12,#IOMD_ID1]	; load r1 with IOMD ID high byte
        ORR     r0,r0,r1, LSL #8	; Or r0 and r1 - shifted left 8, put in r0
        LDRB    r1,[r12,#IOMD_ID0]	; load r1 with IOMD ID low byte
        ORR     r0,r0,r1		; Or r0 and r1, put in r0
        LDR     r1,=ts_IOMD_ID1		; get Ref IOMD ID code #1 (Original)
        CMPS    r0,r1                   ; check for IOMD ID Code #1
	BEQ	ts_LineTestIOMD         ; Original IOMD, not 7500 or 7500FE, assume RiscPC hardware
d51 1
a51 1
; Here bceause its an ARM7500 or ARM7500 'FE' variant : Morris H/W
a53 7
 	LDR	r1, =ts_IOMD_ID3
	TEQ	r0, r1					; are we on FE part?
	ORREQ	r11, r11, #IOMD_DRAMWID_EDO_Enable :OR: IOMD_DRAMWID_RASCAS_3 :OR: IOMD_DRAMWID_RASPre_4
							; if so, then enable EDO and slower RASCAS and RASPre times

; ts_LineTest for Morris
;
d229 1
a229 1
        ADD     r10,r10,r13                             ; accumulate DRAM if any found
d286 1
a286 1
        BL      ts_MoreText
d288 2
a289 2
; Worked out what size VRAM is, and set up IOMD register.
; Do a data line test on the resulting array, repeated at oddword address to
d446 1
a446 1
        ADD     r10,r10,r13                             ; accumulate DRAM if any found
d513 1
a513 1
        MVN     r4,r5                   ; and it's inverse
d525 1
a525 1
        MVN     r4,r5                   ; and it's inverse
d540 1
a540 1
        MOVS    r0,r0                   ; check for any result bits set
d558 1
a558 1
; MaxRam = PhysRam | (Memory size - 4);
d661 1
a661 1
        MOV     r5,#&ff
d676 1
a676 1
        CMPS    r2,#4                   ; ... until 4 byte strobes tested
d690 2
a691 1
        END
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d16 1
a16 7
; 24-Jun-96	BAR		Change the IOMD ID code checking code,
;				instead of checking for ARM7500 and skipping
;				ARM7500 specifi code if not equal, not
;				checks for original (RriscPC) IOM ID code
;				and skip if equal, thus ARM7500 and
;				ARM7500FE parts still do correct test.
; 08-Jul-96     BAR             Ensure r0 is cleared before checking IOMD vsn no.
d43 7
a49 8
        MOV     r0,#0                   ; Clear out r0
        LDRB    r1,[r12,#IOMD_ID1]	; load r1 with IOMD ID high byte
        ORR     r0,r0,r1, LSL #8	; Or r0 and r1 - shifted left 8, put in r0
        LDRB    r1,[r12,#IOMD_ID0]	; load r1 with IOMD ID low byte
        ORR     r0,r0,r1		; Or r0 and r1, put in r0
        LDR     r1,=ts_IOMD_ID1		; get Ref IOMD ID code #1 (Original)
        CMPS    r0,r1                   ; check for IOMD ID Code #1
	BEQ	ts_LineTestIOMD         ; Original IOMD, not 7500 or 7500FE, assume RiscPC hardware
d51 1
a51 1
; Here bceause its an ARM7500 or ARM7500 'FE' variant : Morris H/W
a53 7
 	LDR	r1, =ts_IOMD_ID3
	TEQ	r0, r1					; are we on FE part?
	ORREQ	r11, r11, #IOMD_DRAMWID_EDO_Enable :OR: IOMD_DRAMWID_RASCAS_3 :OR: IOMD_DRAMWID_RASPre_4
							; if so, then enable EDO and slower RASCAS and RASPre times

; ts_LineTest for Morris
;
d229 1
a229 1
        ADD     r10,r10,r13                             ; accumulate DRAM if any found
d286 1
a286 1
        BL      ts_MoreText
d288 2
a289 2
; Worked out what size VRAM is, and set up IOMD register.
; Do a data line test on the resulting array, repeated at oddword address to
d446 1
a446 1
        ADD     r10,r10,r13                             ; accumulate DRAM if any found
d513 1
a513 1
        MVN     r4,r5                   ; and it's inverse
d525 1
a525 1
        MVN     r4,r5                   ; and it's inverse
d540 1
a540 1
        MOVS    r0,r0                   ; check for any result bits set
d558 1
a558 1
; MaxRam = PhysRam | (Memory size - 4);
d661 1
a661 1
        MOV     r5,#&ff
d676 1
a676 1
        CMPS    r2,#4                   ; ... until 4 byte strobes tested
d690 2
a691 1
        END
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a55 1

d229 1
a229 1
        ADD     r10,r10,r13                             ; accumulate DRAM if any found
d286 1
a286 1
        BL      ts_MoreText
d288 2
a289 2
; Worked out what size VRAM is, and set up IOMD register.
; Do a data line test on the resulting array, repeated at oddword address to
a344 1

d446 1
a446 1
        ADD     r10,r10,r13                             ; accumulate DRAM if any found
d513 1
a513 1
        MVN     r4,r5                   ; and it's inverse
d525 1
a525 1
        MVN     r4,r5                   ; and it's inverse
d540 1
a540 1
        MOVS    r0,r0                   ; check for any result bits set
d558 1
a558 1
; MaxRam = PhysRam | (Memory size - 4);
d661 1
a661 1
        MOV     r5,#&ff
d676 1
a676 1
        CMPS    r2,#4                   ; ... until 4 byte strobes tested
d690 2
a691 1
        END
@


4.1.3.2
log
@RISC OS 3.71 version taken
@
text
@d45 1
a45 1
        CMP     r0, #&E7
d47 2
a48 2
        CMPEQ   r0, #&D4
        BEQ     ts_LineTestIOMD                         ; Medusa hardware, else assume Morris
d57 1
a57 2
; enable 32-bit addressing of data, also forces 26 bit mode, if ARM 6/7 (since P bit zero)
        MOV     r0,#MMUC_D
a59 4
  [ StrongARM_POST
        Ensure26bit_ARM8A r0
  ]

d347 1
a347 2
; enable 32-bit addressing of data, also forces 26 bit mode, if ARM 6/7 (since P bit zero)
        MOV     r0,#MMUC_D
a348 4

  [ StrongARM_POST
        Ensure26bit_ARM8A r10
  ]
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d45 1
a45 1
        CMP     r0, #&E7
d47 2
a48 2
        CMPEQ   r0, #&D4
        BEQ     ts_LineTestIOMD                         ; Medusa hardware, else assume Morris
d57 1
a57 2
; enable 32-bit addressing of data, also forces 26 bit mode, if ARM 6/7 (since P bit zero)
        MOV     r0,#MMUC_D
a59 4
  [ StrongARM_POST
        Ensure26bit_ARM8A r0
  ]

d347 1
a347 2
; enable 32-bit addressing of data, also forces 26 bit mode, if ARM 6/7 (since P bit zero)
        MOV     r0,#MMUC_D
a348 4

  [ StrongARM_POST
        Ensure26bit_ARM8A r10
  ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.15;
access;
symbols
	HAL_merge:4.13.2.1
	Kernel-5_48:4.14
	Kernel-5_35-4_79_2_327:4.13.2.1
	Kernel-5_35-4_79_2_326:4.13.2.1
	Kernel-5_35-4_79_2_325:4.13.2.1
	Kernel-5_35-4_79_2_324:4.13.2.1
	Kernel-5_35-4_79_2_323:4.13.2.1
	Kernel-5_35-4_79_2_322:4.13.2.1
	Kernel-5_35-4_79_2_321:4.13.2.1
	Kernel-5_35-4_79_2_320:4.13.2.1
	Kernel-5_35-4_79_2_319:4.13.2.1
	Kernel-5_35-4_79_2_318:4.13.2.1
	Kernel-5_35-4_79_2_317:4.13.2.1
	Kernel-5_35-4_79_2_316:4.13.2.1
	Kernel-5_35-4_79_2_315:4.13.2.1
	Kernel-5_35-4_79_2_314:4.13.2.1
	Kernel-5_35-4_79_2_313:4.13.2.1
	Kernel-5_35-4_79_2_312:4.13.2.1
	Kernel-5_35-4_79_2_311:4.13.2.1
	Kernel-5_35-4_79_2_310:4.13.2.1
	Kernel-5_35-4_79_2_309:4.13.2.1
	Kernel-5_35-4_79_2_308:4.13.2.1
	Kernel-5_35-4_79_2_307:4.13.2.1
	Kernel-5_35-4_79_2_306:4.13.2.1
	Kernel-5_35-4_79_2_305:4.13.2.1
	Kernel-5_35-4_79_2_304:4.13.2.1
	Kernel-5_35-4_79_2_303:4.13.2.1
	Kernel-5_35-4_79_2_302:4.13.2.1
	Kernel-5_35-4_79_2_301:4.13.2.1
	Kernel-5_35-4_79_2_300:4.13.2.1
	Kernel-5_35-4_79_2_299:4.13.2.1
	Kernel-5_35-4_79_2_298:4.13.2.1
	Kernel-5_35-4_79_2_297:4.13.2.1
	Kernel-5_35-4_79_2_296:4.13.2.1
	Kernel-5_35-4_79_2_295:4.13.2.1
	Kernel-5_35-4_79_2_294:4.13.2.1
	Kernel-5_35-4_79_2_293:4.13.2.1
	Kernel-5_35-4_79_2_292:4.13.2.1
	Kernel-5_35-4_79_2_291:4.13.2.1
	Kernel-5_35-4_79_2_290:4.13.2.1
	Kernel-5_35-4_79_2_289:4.13.2.1
	Kernel-5_35-4_79_2_288:4.13.2.1
	Kernel-5_35-4_79_2_287:4.13.2.1
	Kernel-5_35-4_79_2_286:4.13.2.1
	Kernel-5_35-4_79_2_285:4.13.2.1
	Kernel-5_35-4_79_2_284:4.13.2.1
	Kernel-5_35-4_79_2_283:4.13.2.1
	Kernel-5_35-4_79_2_282:4.13.2.1
	Kernel-5_35-4_79_2_281:4.13.2.1
	Kernel-5_35-4_79_2_280:4.13.2.1
	Kernel-5_35-4_79_2_279:4.13.2.1
	Kernel-5_35-4_79_2_278:4.13.2.1
	Kernel-5_35-4_79_2_277:4.13.2.1
	Kernel-5_35-4_79_2_276:4.13.2.1
	Kernel-5_35-4_79_2_275:4.13.2.1
	Kernel-5_35-4_79_2_274:4.13.2.1
	Kernel-5_35-4_79_2_273:4.13.2.1
	Kernel-5_35-4_79_2_272:4.13.2.1
	Kernel-5_35-4_79_2_271:4.13.2.1
	Kernel-5_35-4_79_2_270:4.13.2.1
	Kernel-5_35-4_79_2_269:4.13.2.1
	Kernel-5_35-4_79_2_268:4.13.2.1
	Kernel-5_35-4_79_2_267:4.13.2.1
	Kernel-5_35-4_79_2_266:4.13.2.1
	Kernel-5_35-4_79_2_265:4.13.2.1
	Kernel-5_35-4_79_2_264:4.13.2.1
	Kernel-5_35-4_79_2_263:4.13.2.1
	Kernel-5_35-4_79_2_262:4.13.2.1
	Kernel-5_35-4_79_2_261:4.13.2.1
	Kernel-5_35-4_79_2_260:4.13.2.1
	Kernel-5_35-4_79_2_259:4.13.2.1
	Kernel-5_35-4_79_2_258:4.13.2.1
	Kernel-5_35-4_79_2_257:4.13.2.1
	Kernel-5_35-4_79_2_256:4.13.2.1
	Kernel-5_35-4_79_2_255:4.13.2.1
	Kernel-5_35-4_79_2_254:4.13.2.1
	Kernel-5_35-4_79_2_253:4.13.2.1
	Kernel-5_35-4_79_2_252:4.13.2.1
	Kernel-5_35-4_79_2_251:4.13.2.1
	Kernel-5_35-4_79_2_250:4.13.2.1
	Kernel-5_35-4_79_2_249:4.13.2.1
	Kernel-5_35-4_79_2_248:4.13.2.1
	Kernel-5_35-4_79_2_247:4.13.2.1
	Kernel-5_35-4_79_2_246:4.13.2.1
	Kernel-5_35-4_79_2_245:4.13.2.1
	Kernel-5_35-4_79_2_244:4.13.2.1
	Kernel-5_35-4_79_2_243:4.13.2.1
	Kernel-5_35-4_79_2_242:4.13.2.1
	Kernel-5_35-4_79_2_241:4.13.2.1
	Kernel-5_35-4_79_2_240:4.13.2.1
	Kernel-5_35-4_79_2_239:4.13.2.1
	Kernel-5_35-4_79_2_238:4.13.2.1
	Kernel-5_35-4_79_2_237:4.13.2.1
	Kernel-5_35-4_79_2_236:4.13.2.1
	Kernel-5_35-4_79_2_235:4.13.2.1
	Kernel-5_35-4_79_2_234:4.13.2.1
	Kernel-5_35-4_79_2_233:4.13.2.1
	Kernel-5_35-4_79_2_232:4.13.2.1
	Kernel-5_35-4_79_2_231:4.13.2.1
	Kernel-5_35-4_79_2_230:4.13.2.1
	Kernel-5_35-4_79_2_229:4.13.2.1
	Kernel-5_35-4_79_2_228:4.13.2.1
	Kernel-5_35-4_79_2_227:4.13.2.1
	Kernel-5_35-4_79_2_226:4.13.2.1
	Kernel-5_35-4_79_2_225:4.13.2.1
	Kernel-5_35-4_79_2_224:4.13.2.1
	Kernel-5_35-4_79_2_223:4.13.2.1
	Kernel-5_35-4_79_2_222:4.13.2.1
	Kernel-5_35-4_79_2_221:4.13.2.1
	Kernel-5_35-4_79_2_220:4.13.2.1
	Kernel-5_35-4_79_2_219:4.13.2.1
	Kernel-5_35-4_79_2_218:4.13.2.1
	Kernel-5_35-4_79_2_217:4.13.2.1
	Kernel-5_35-4_79_2_216:4.13.2.1
	Kernel-5_35-4_79_2_215:4.13.2.1
	Kernel-5_35-4_79_2_214:4.13.2.1
	Kernel-5_35-4_79_2_213:4.13.2.1
	Kernel-5_35-4_79_2_212:4.13.2.1
	Kernel-5_35-4_79_2_211:4.13.2.1
	Kernel-5_35-4_79_2_210:4.13.2.1
	Kernel-5_35-4_79_2_209:4.13.2.1
	Kernel-5_35-4_79_2_208:4.13.2.1
	Kernel-5_35-4_79_2_207:4.13.2.1
	Kernel-5_35-4_79_2_206:4.13.2.1
	Kernel-5_35-4_79_2_205:4.13.2.1
	Kernel-5_35-4_79_2_204:4.13.2.1
	Kernel-5_35-4_79_2_203:4.13.2.1
	Kernel-5_35-4_79_2_202:4.13.2.1
	Kernel-5_35-4_79_2_201:4.13.2.1
	Kernel-5_35-4_79_2_200:4.13.2.1
	Kernel-5_35-4_79_2_199:4.13.2.1
	Kernel-5_35-4_79_2_198:4.13.2.1
	Kernel-5_35-4_79_2_197:4.13.2.1
	Kernel-5_35-4_79_2_196:4.13.2.1
	Kernel-5_35-4_79_2_195:4.13.2.1
	Kernel-5_35-4_79_2_194:4.13.2.1
	Kernel-5_35-4_79_2_193:4.13.2.1
	Kernel-5_35-4_79_2_192:4.13.2.1
	Kernel-5_35-4_79_2_191:4.13.2.1
	Kernel-5_35-4_79_2_190:4.13.2.1
	Kernel-5_35-4_79_2_189:4.13.2.1
	Kernel-5_35-4_79_2_188:4.13.2.1
	Kernel-5_35-4_79_2_187:4.13.2.1
	Kernel-5_35-4_79_2_186:4.13.2.1
	Kernel-5_35-4_79_2_185:4.13.2.1
	Kernel-5_35-4_79_2_184:4.13.2.1
	Kernel-5_35-4_79_2_183:4.13.2.1
	Kernel-5_35-4_79_2_182:4.13.2.1
	Kernel-5_35-4_79_2_181:4.13.2.1
	Kernel-5_35-4_79_2_180:4.13.2.1
	Kernel-5_35-4_79_2_179:4.13.2.1
	Kernel-5_35-4_79_2_178:4.13.2.1
	Kernel-5_35-4_79_2_177:4.13.2.1
	Kernel-5_35-4_79_2_176:4.13.2.1
	Kernel-5_35-4_79_2_175:4.13.2.1
	Kernel-5_35-4_79_2_174:4.13.2.1
	Kernel-5_35-4_79_2_173:4.13.2.1
	Kernel-5_35-4_79_2_172:4.13.2.1
	Kernel-5_35-4_79_2_171:4.13.2.1
	Kernel-5_35-4_79_2_170:4.13.2.1
	Kernel-5_35-4_79_2_169:4.13.2.1
	Kernel-5_35-4_79_2_168:4.13.2.1
	Kernel-5_35-4_79_2_167:4.13.2.1
	Kernel-5_35-4_79_2_166:4.13.2.1
	Kernel-5_35-4_79_2_165:4.13.2.1
	RPi_merge:4.13.2.1
	Kernel-5_35-4_79_2_147_2_23:4.13.2.1
	Kernel-5_35-4_79_2_147_2_22:4.13.2.1
	Kernel-5_35-4_79_2_147_2_21:4.13.2.1
	Kernel-5_35-4_79_2_147_2_20:4.13.2.1
	Kernel-5_35-4_79_2_147_2_19:4.13.2.1
	Kernel-5_35-4_79_2_147_2_18:4.13.2.1
	Kernel-5_35-4_79_2_164:4.13.2.1
	Kernel-5_35-4_79_2_163:4.13.2.1
	Kernel-5_35-4_79_2_147_2_17:4.13.2.1
	Kernel-5_35-4_79_2_147_2_16:4.13.2.1
	Kernel-5_35-4_79_2_147_2_15:4.13.2.1
	Kernel-5_35-4_79_2_162:4.13.2.1
	Kernel-5_35-4_79_2_161:4.13.2.1
	Kernel-5_35-4_79_2_147_2_14:4.13.2.1
	Kernel-5_35-4_79_2_147_2_13:4.13.2.1
	Kernel-5_35-4_79_2_160:4.13.2.1
	Kernel-5_35-4_79_2_159:4.13.2.1
	Kernel-5_35-4_79_2_158:4.13.2.1
	Kernel-5_35-4_79_2_157:4.13.2.1
	Kernel-5_35-4_79_2_156:4.13.2.1
	Kernel-5_35-4_79_2_147_2_12:4.13.2.1
	Kernel-5_35-4_79_2_147_2_11:4.13.2.1
	Kernel-5_35-4_79_2_155:4.13.2.1
	Kernel-5_35-4_79_2_147_2_10:4.13.2.1
	Kernel-5_35-4_79_2_154:4.13.2.1
	Kernel-5_35-4_79_2_153:4.13.2.1
	Kernel-5_35-4_79_2_147_2_9:4.13.2.1
	Kernel-5_35-4_79_2_152:4.13.2.1
	Kernel-5_35-4_79_2_151:4.13.2.1
	Kernel-5_35-4_79_2_147_2_8:4.13.2.1
	Kernel-5_35-4_79_2_147_2_7:4.13.2.1
	Kernel-5_35-4_79_2_150:4.13.2.1
	Kernel-5_35-4_79_2_147_2_6:4.13.2.1
	Kernel-5_35-4_79_2_147_2_5:4.13.2.1
	Kernel-5_35-4_79_2_149:4.13.2.1
	Kernel-5_35-4_79_2_147_2_4:4.13.2.1
	Kernel-5_35-4_79_2_147_2_3:4.13.2.1
	Kernel-5_35-4_79_2_148:4.13.2.1
	Kernel-5_35-4_79_2_147_2_2:4.13.2.1
	Kernel-5_35-4_79_2_147_2_1:4.13.2.1
	RPi:4.13.2.1.0.6
	RPi_bp:4.13.2.1
	Kernel-5_35-4_79_2_98_2_52_2_1:4.13.2.1
	alees_Kernel_dev:4.13.2.1.0.4
	alees_Kernel_dev_bp:4.13.2.1
	Kernel-5_35-4_79_2_147:4.13.2.1
	Kernel-5_35-4_79_2_146:4.13.2.1
	Kernel-5_35-4_79_2_145:4.13.2.1
	Kernel-5_35-4_79_2_144:4.13.2.1
	Kernel-5_35-4_79_2_143:4.13.2.1
	Kernel-5_35-4_79_2_142:4.13.2.1
	Kernel-5_35-4_79_2_141:4.13.2.1
	Kernel-5_35-4_79_2_140:4.13.2.1
	Kernel-5_35-4_79_2_139:4.13.2.1
	Kernel-5_35-4_79_2_138:4.13.2.1
	Kernel-5_35-4_79_2_137:4.13.2.1
	Kernel-5_35-4_79_2_136:4.13.2.1
	Kernel-5_35-4_79_2_135:4.13.2.1
	Kernel-5_35-4_79_2_134:4.13.2.1
	Kernel-5_35-4_79_2_133:4.13.2.1
	Kernel-5_35-4_79_2_132:4.13.2.1
	Kernel-5_35-4_79_2_131:4.13.2.1
	Kernel-5_35-4_79_2_130:4.13.2.1
	Kernel-5_35-4_79_2_129:4.13.2.1
	Kernel-5_35-4_79_2_128:4.13.2.1
	Kernel-5_35-4_79_2_127:4.13.2.1
	Kernel-5_35-4_79_2_126:4.13.2.1
	Kernel-5_35-4_79_2_125:4.13.2.1
	Kernel-5_35-4_79_2_124:4.13.2.1
	Kernel-5_35-4_79_2_123:4.13.2.1
	Cortex_merge:4.13.2.1
	Kernel-5_35-4_79_2_122:4.13.2.1
	Kernel-5_35-4_79_2_98_2_54:4.13.2.1
	Kernel-5_35-4_79_2_98_2_53:4.13.2.1
	Kernel-5_35-4_79_2_98_2_52:4.13.2.1
	Kernel-5_35-4_79_2_98_2_51:4.13.2.1
	Kernel-5_35-4_79_2_98_2_50:4.13.2.1
	Kernel-5_35-4_79_2_98_2_49:4.13.2.1
	Kernel-5_35-4_79_2_98_2_48:4.13.2.1
	Kernel-5_35-4_79_2_121:4.13.2.1
	Kernel-5_35-4_79_2_98_2_47:4.13.2.1
	Kernel-5_35-4_79_2_120:4.13.2.1
	Kernel-5_35-4_79_2_98_2_46:4.13.2.1
	Kernel-5_35-4_79_2_119:4.13.2.1
	Kernel-5_35-4_79_2_98_2_45:4.13.2.1
	Kernel-5_35-4_79_2_98_2_44:4.13.2.1
	Kernel-5_35-4_79_2_118:4.13.2.1
	Kernel-5_35-4_79_2_98_2_43:4.13.2.1
	Kernel-5_35-4_79_2_117:4.13.2.1
	Kernel-5_35-4_79_2_116:4.13.2.1
	Kernel-5_35-4_79_2_98_2_42:4.13.2.1
	Kernel-5_35-4_79_2_115:4.13.2.1
	Kernel-5_35-4_79_2_98_2_41:4.13.2.1
	Kernel-5_35-4_79_2_98_2_40:4.13.2.1
	Kernel-5_35-4_79_2_114:4.13.2.1
	Kernel-5_35-4_79_2_98_2_39:4.13.2.1
	Kernel-5_35-4_79_2_98_2_38:4.13.2.1
	Kernel-5_35-4_79_2_113:4.13.2.1
	Kernel-5_35-4_79_2_112:4.13.2.1
	Kernel-5_35-4_79_2_98_2_37:4.13.2.1
	Kernel-5_35-4_79_2_98_2_36:4.13.2.1
	Kernel-5_35-4_79_2_98_2_35:4.13.2.1
	Kernel-5_35-4_79_2_98_2_34:4.13.2.1
	Kernel-5_35-4_79_2_98_2_33:4.13.2.1
	Kernel-5_35-4_79_2_98_2_32:4.13.2.1
	Kernel-5_35-4_79_2_98_2_31:4.13.2.1
	Kernel-5_35-4_79_2_98_2_30:4.13.2.1
	Kernel-5_35-4_79_2_98_2_29:4.13.2.1
	Kernel-5_35-4_79_2_98_2_28:4.13.2.1
	Kernel-5_35-4_79_2_98_2_27:4.13.2.1
	Kernel-5_35-4_79_2_98_2_26:4.13.2.1
	Kernel-5_35-4_79_2_111:4.13.2.1
	Kernel-5_35-4_79_2_98_2_25:4.13.2.1
	Kernel-5_35-4_79_2_98_2_24:4.13.2.1
	Kernel-5_35-4_79_2_98_2_23:4.13.2.1
	Kernel-5_35-4_79_2_110:4.13.2.1
	Kernel-5_35-4_79_2_98_2_22:4.13.2.1
	Kernel-5_35-4_79_2_109:4.13.2.1
	Kernel-5_35-4_79_2_98_2_21:4.13.2.1
	Kernel-5_35-4_79_2_98_2_20:4.13.2.1
	Kernel-5_35-4_79_2_108:4.13.2.1
	Kernel-5_35-4_79_2_107:4.13.2.1
	Kernel-5_35-4_79_2_98_2_19:4.13.2.1
	Kernel-5_35-4_79_2_98_2_18:4.13.2.1
	Kernel-5_35-4_79_2_98_2_17:4.13.2.1
	Kernel-5_35-4_79_2_98_2_16:4.13.2.1
	Kernel-5_35-4_79_2_98_2_15:4.13.2.1
	Kernel-5_35-4_79_2_106:4.13.2.1
	Kernel-5_35-4_79_2_105:4.13.2.1
	Kernel-5_35-4_79_2_104:4.13.2.1
	Kernel-5_35-4_79_2_98_2_14:4.13.2.1
	Kernel-5_35-4_79_2_98_2_13:4.13.2.1
	Kernel-5_35-4_79_2_98_2_12:4.13.2.1
	Kernel-5_35-4_79_2_98_2_11:4.13.2.1
	Kernel-5_35-4_79_2_98_2_10:4.13.2.1
	Kernel-5_35-4_79_2_98_2_9:4.13.2.1
	Kernel-5_35-4_79_2_103:4.13.2.1
	Kernel-5_35-4_79_2_102:4.13.2.1
	Kernel-5_35-4_79_2_98_2_8:4.13.2.1
	Kernel-5_35-4_79_2_98_2_7:4.13.2.1
	Kernel-5_35-4_79_2_98_2_6:4.13.2.1
	Kernel-5_35-4_79_2_98_2_5:4.13.2.1
	Kernel-5_35-4_79_2_98_2_4:4.13.2.1
	Kernel-5_35-4_79_2_101:4.13.2.1
	Kernel-5_35-4_79_2_100:4.13.2.1
	Kernel-5_35-4_79_2_99:4.13.2.1
	Kernel-5_35-4_79_2_98_2_3:4.13.2.1
	Kernel-5_35-4_79_2_98_2_2:4.13.2.1
	Kernel-5_35-4_79_2_98_2_1:4.13.2.1
	Cortex:4.13.2.1.0.2
	Cortex_bp:4.13.2.1
	Kernel-5_35-4_79_2_98:4.13.2.1
	Kernel-5_35-4_79_2_97:4.13.2.1
	Kernel-5_35-4_79_2_96:4.13.2.1
	Kernel-5_35-4_79_2_95:4.13.2.1
	Kernel-5_35-4_79_2_94:4.13.2.1
	Kernel-5_35-4_79_2_93:4.13.2.1
	Kernel-5_35-4_79_2_92:4.13.2.1
	Kernel-5_35-4_79_2_91:4.13.2.1
	Kernel-5_35-4_79_2_90:4.13.2.1
	Kernel-5_35-4_79_2_89:4.13.2.1
	Kernel-5_35-4_79_2_88:4.13.2.1
	Kernel-5_35-4_79_2_87:4.13.2.1
	Kernel-5_35-4_79_2_86:4.13.2.1
	Kernel-5_35-4_79_2_85:4.13.2.1
	Kernel-5_35-4_79_2_84:4.13.2.1
	Kernel-5_35-4_79_2_83:4.13.2.1
	Kernel-5_35-4_79_2_82:4.13.2.1
	Kernel-5_35-4_79_2_81:4.13.2.1
	Kernel-5_35-4_79_2_80:4.13.2.1
	Kernel-5_35-4_79_2_79:4.13.2.1
	Kernel-5_35-4_79_2_78:4.13.2.1
	Kernel-5_35-4_79_2_77:4.13.2.1
	RO_5_07:4.13.2.1
	Kernel-5_35-4_79_2_76:4.13.2.1
	Kernel-5_35-4_79_2_75:4.13.2.1
	Kernel-5_35-4_79_2_74:4.13.2.1
	Kernel-5_35-4_79_2_73:4.13.2.1
	Kernel-5_35-4_79_2_72:4.13.2.1
	Kernel-5_35-4_79_2_71:4.13.2.1
	Kernel-5_35-4_79_2_70:4.13.2.1
	Kernel-5_35-4_79_2_69:4.13.2.1
	Kernel-5_35-4_79_2_68:4.13.2.1
	Kernel-5_35-4_79_2_67:4.13.2.1
	Kernel-5_35-4_79_2_66:4.13.2.1
	Kernel-5_35-4_79_2_65:4.13.2.1
	Kernel-5_35-4_79_2_64:4.13.2.1
	Kernel-5_35-4_79_2_63:4.13.2.1
	Kernel-5_35-4_79_2_62:4.13.2.1
	Kernel-5_35-4_79_2_61:4.13.2.1
	Kernel-5_35-4_79_2_59:4.13.2.1
	Kernel-5_35-4_79_2_58:4.13.2.1
	Kernel-5_35-4_79_2_57:4.13.2.1
	Kernel-5_35-4_79_2_56:4.13.2.1
	Kernel-5_35-4_79_2_55:4.13.2.1
	Kernel-5_35-4_79_2_54:4.13.2.1
	Kernel-5_35-4_79_2_53:4.13.2.1
	Kernel-5_35-4_79_2_52:4.13.2.1
	Kernel-5_35-4_79_2_51:4.13.2.1
	Kernel-5_35-4_79_2_50:4.13.2.1
	Kernel-5_35-4_79_2_49:4.13.2.1
	Kernel-5_35-4_79_2_48:4.13.2.1
	Kernel-5_47:4.13
	Kernel-5_46-4_90_2_1:4.13
	nbingham_Kernel_FastNC_dev_bp:4.13
	nbingham_Kernel_FastNC_dev:4.13.0.4
	Kernel-5_46:4.13
	Kernel-5_45:4.13
	Kernel-5_35-4_79_2_47:4.13.2.1
	Kernel-5_35-4_79_2_46:4.13.2.1
	Kernel-5_35-4_79_2_45:4.13.2.1
	Kernel-5_35-4_79_2_44:4.13.2.1
	Kernel-5_35-4_79_2_25_2_2:4.13.2.1
	Kernel-5_35-4_79_2_43:4.13.2.1
	Kernel-5_35-4_79_2_42:4.13.2.1
	Kernel-5_35-4_79_2_41:4.13.2.1
	Kernel-5_35-4_79_2_40:4.13.2.1
	Kernel-5_35-4_79_2_39:4.13.2.1
	Kernel-5_35-4_79_2_38:4.13.2.1
	Kernel-5_35-4_79_2_37:4.13.2.1
	Kernel-5_35-4_79_2_36:4.13.2.1
	Kernel-5_35-4_79_2_35:4.13.2.1
	Kernel-5_35-4_79_2_34:4.13.2.1
	Kernel-5_35-4_79_2_33:4.13.2.1
	Kernel-5_35-4_79_2_32:4.13.2.1
	Kernel-5_44:4.13
	Kernel-5_35-4_79_2_25_2_1:4.13.2.1
	Kernel-5_43:4.13
	Kernel-5_35-4_79_2_31:4.13.2.1
	Kernel-5_35-4_79_2_30:4.13.2.1
	Kernel-5_35-4_79_2_29:4.13.2.1
	Kernel-5_35-4_79_2_28:4.13.2.1
	Kernel-5_35-4_79_2_27:4.13.2.1
	Kernel-5_35-4_79_2_26:4.13.2.1
	Kernel-5_42:4.13
	Kernel-5_41:4.13
	Kernel-5_40:4.13
	Kernel-5_35-4_79_2_25:4.13.2.1
	Kernel-5_35-4_79_2_24:4.13.2.1
	Kernel-5_35-4_79_2_23:4.13.2.1
	Kernel-5_35-4_79_2_22:4.13.2.1
	Kernel-5_35-4_79_2_21:4.13.2.1
	Kernel-5_35-4_79_2_20:4.13.2.1
	Kernel-5_35-4_79_2_19:4.13.2.1
	Kernel-5_35-4_79_2_18:4.13.2.1
	Kernel-5_35-4_79_2_17:4.13.2.1
	Kernel-5_35-4_79_2_16:4.13.2.1
	Kernel-5_35-4_79_2_15:4.13.2.1
	Kernel-5_35-4_79_2_14:4.13.2.1
	Kernel-5_39:4.13
	Kernel-5_13-4_52_2_1:4.10
	Bethany:4.10.0.2
	Kernel-5_38:4.13
	Kernel-5_35-4_79_2_13:4.13.2.1
	Kernel-5_35-4_79_2_12:4.13.2.1
	Kernel-5_35-4_79_2_11:4.13.2.1
	Kernel-5_37:4.13
	Kernel-5_35-4_79_2_10:4.13.2.1
	Kernel-5_35-4_79_2_9:4.13.2.1
	Kernel-5_36:4.13
	Kernel-5_35-4_79_2_8:4.13.2.1
	Kernel-5_35-4_79_2_7:4.13.2.1
	Kernel-5_35-4_79_2_6:4.13.2.1
	Kernel-5_35-4_79_2_5:4.13.2.1
	Kernel-5_35-4_79_2_4:4.13.2.1
	Kernel-5_35-4_79_2_3:4.13.2.1
	Kernel-5_35-4_79_2_2:4.13.2.1
	dellis_autobuild_BaseSW:4.13
	Kernel-5_35-4_79_2_1:4.13.2.1
	HAL:4.13.0.2
	Kernel-5_35:4.13
	Kernel-5_34:4.13
	Kernel-5_33:4.13
	Kernel-5_32:4.13
	Kernel-5_31:4.13
	Kernel-5_30:4.13
	Kernel-5_29:4.13
	Kernel-5_28:4.13
	Kernel-5_27:4.13
	Kernel-5_26:4.13
	Kernel-5_25:4.13
	Kernel-5_24:4.12
	Kernel-5_23:4.11
	Kernel-5_22:4.10
	sbrodie_sedwards_16Mar2000:4.10
	Kernel-5_21:4.10
	Kernel-5_20:4.10
	Kernel-5_19:4.10
	Kernel-5_18:4.10
	Kernel-5_17:4.10
	Kernel-5_16:4.10
	Kernel-5_15:4.10
	Kernel-5_14:4.10
	Kernel-5_13:4.10
	Kernel-5_12:4.9
	Kernel-5_11:4.8
	Kernel-5_10:4.8
	Kernel-5_09:4.8
	Kernel-5_08:4.8
	Kernel-5_07:4.8
	Kernel-5_06:4.8
	Kernel-5_05:4.8
	Kernel-5_04:4.8
	Kernel-5_03:4.8
	Kernel-5_02:4.8
	Kernel-5_01:4.8
	Kernel-5_00:4.8
	Kernel-4_99:4.8
	Kernel-4_98:4.8
	Kernel-4_97:4.8
	Kernel-4_96:4.8
	Kernel-4_95:4.8
	Kernel-4_94:4.8
	Kernel-4_93:4.8
	Kernel-4_92:4.8
	Kernel-4_91:4.8
	Kernel-4_90:4.8
	dcotton_autobuild_BaseSW:4.13
	Kernel-4_89:4.7
	Kernel-4_88:4.7
	Kernel-4_87:4.7
	Kernel-4_86:4.7
	Kernel-4_85:4.7
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.3
	Kernel-4_84:4.7
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.3
	Ursula_RiscPC_bp:4.3
	Kernel-4_83:4.7
	Kernel-4_82:4.7
	Kernel-4_81:4.7
	Kernel-4_80:4.7
	Kernel-4_79:4.7
	Kernel-4_78:4.7
	Kernel-4_77:4.6
	Kernel-4_76:4.6
	Kernel-4_75:4.6
	Kernel-4_74:4.6
	Kernel-4_73:4.6
	Kernel-4_72:4.6
	Kernel-4_71:4.6
	Kernel-4_70:4.6
	Kernel-4_69:4.6
	Kernel-4_68:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3
	Ursula_RiscPC:4.3.0.6
	Kernel-4_63-1_1_2_5:4.1.7.13
	Kernel-4_63-1_1_2_4:4.1.7.12
	Kernel-4_67:4.4
	Kernel-4_66:4.4
	Kernel-4_63-1_1_2_3:4.1.7.11
	Kernel-4_65:4.4
	Ursula_merge:4.3
	Kernel-4_64:4.4
	mstphens_Kernel-3_81:4.3
	Kernel-4_63-1_1_2_2:4.1.7.11
	nicke_Kernel_4_62:4.1.7.11
	rthornb_UrsulaBuild-19Aug1998:4.3
	UrsulaBuild_FinalSoftload:4.3
	rthornb_UrsulaBuild-12Aug1998:4.3
	aglover_UrsulaBuild-05Aug1998:4.3
	rthornb_UrsulaBuild-29Jul1998:4.3
	rthornb_UrsulaBuild-22Jul1998:4.3
	nturton_v459:4.1.7.11
	nturton_v460:4.1.7.11
	rthornb_UrsulaBuild-15Jul1998:4.3
	rthornb_UrsulaBuild-07Jul1998:4.3
	rthornb_UrsulaBuild-17Jun1998:4.3
	rthornb_UrsulaBuild-03Jun1998:4.3
	rthornb_UrsulaBuild-27May1998:4.3
	mstphens_Kernel-3_80:4.3
	rthornb_UrsulaBuild-21May1998:4.3
	afrost_Boca-1_2-Beta:4.1.7.11
	rthornb_UrsulaBuild_01May1998:4.3
	afrost_NC2_Generic:4.1.7.11
	Spinner_B20_2:4.1.7.11
	Spinner_19_3:4.1.7.11
	Spinner_B18:4.1.7.11
	Spinner_B17:4.1.7.11
	Spinner_B15:4.1.7.11
	Spinner_B14:4.1.7.11
	Spinner_B13:4.1.7.8
	Spinner_B12:4.1.7.8
	Spinner_B10:4.1.7.8
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Spinner_B7:4.1.7.8
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.4
	Spin_3Apr97:4.1.7.4
	ARTtmp:4.1.7.4.0.2
	Spin_merge:4.1.7.11
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2016.06.30.20.28.47;	author jlee;	state dead;
branches;
next	4.14;
commitid	lMnWzoE9eJz3Wwcz;

4.14
date	2016.06.30.20.07.52;	author jlee;	state Exp;
branches;
next	4.13;
commitid	IWoXxARWeuLDOwcz;

4.13
date	2000.04.20.14.57.27;	author kbracey;	state Exp;
branches
	4.13.2.1;
next	4.12;

4.12
date	2000.04.13.14.29.25;	author kbracey;	state Exp;
branches;
next	4.11;

4.11
date	2000.04.04.14.27.21;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	2000.01.26.15.12.03;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	2000.01.26.13.55.14;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.09.29.17.09.20;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.05.06.13.47.08;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.02.11.13.34.22;	author nturton;	state Exp;
branches;
next	4.5;

4.5
date	99.02.09.10.57.33;	author nturton;	state Exp;
branches;
next	4.4;

4.4
date	98.09.30.08.42.06;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.05.51.38;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.06.38;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.44;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.13.2.1
date	2000.09.15.12.38.00;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.44;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.04.15;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.08.09.10;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.16.45.47;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.50;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.05.07;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.12.19.15.50;	author brice;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.03.13.21.23.44;	author brice;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.03.18.15.59.23;	author brice;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.04.21.15.41.46;	author scormie;	state Exp;
branches;
next	4.1.7.6;

4.1.7.6
date	97.04.23.13.22.35;	author nturton;	state Exp;
branches;
next	4.1.7.7;

4.1.7.7
date	97.04.28.18.41.17;	author scormie;	state Exp;
branches;
next	4.1.7.8;

4.1.7.8
date	97.04.29.11.51.34;	author scormie;	state Exp;
branches;
next	4.1.7.9;

4.1.7.9
date	97.06.12.20.36.48;	author brice;	state Exp;
branches;
next	4.1.7.10;

4.1.7.10
date	97.06.19.11.48.12;	author brice;	state Exp;
branches;
next	4.1.7.11;

4.1.7.11
date	97.06.19.15.12.19;	author brice;	state Exp;
branches;
next	4.1.7.12;

4.1.7.12
date	98.11.02.11.22.55;	author nicke;	state Exp;
branches;
next	4.1.7.13;

4.1.7.13
date	98.11.06.15.33.51;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.15
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; > TestSrc.Begin

        TTL RISC OS 2+ Power-On Self-Test
;
; Startup code for RISC OS ROM Self-Test.
;
; Performs ROM test patterns, determines test strategy and enters
; external or internal test code.
;
; A minimal set of opcodes should be used (ideally, only B, LDR and ADDS)
; so that a processor test may be validly included in the internal test
; sequence.
;
;------------------------------------------------------------------------
; History
;
; Date          Name    Rel     Comment
; ----          ----    ---     -------
; 23-Feb-93     ArtG    2.00    Experimental ARM 600 / Jordan mods
; 20-Oct-93     ARTG    2.02    Changed to new conditional assembly scheme
; 18-Nov-94     RCM     2.05    Morris changes
; 15-May-96	BAR	2.06	Update for ARM7500FE variant, new IOMD ID
;				Code. Used initially in the NC product;
;				needs different prescalers and ROM speed
;				settings, switched on IOMD ID code.
; 30-May-96	BAR	2.07	Add code to flash NC's led's. Ignore morse
;				code and just use the simplified flash
;				sequence.
; 14-Jun-96	BAR	2.08	Add get call for initmodule file.
; 17-Jun-96	BAR	2.09	Change speed settings for the second bank of
;				ROM space.
; 24-Jun-96	BAR	2.10	Updated second check on IOMD ID, instead of
;				checking for ARM7500 IOMD ID code to skip
;				the Virq test, now checks for the original
;				(RiscPC) IOMD ID code and skips Virq test if
;				not equal. Thus ARM7500 and ARM7500FE
;				devices don't execute the test.
;				Updated version number.
;				Added call to sir_IOMD_Regs -show iomd registers
; 08-Jul-96     BAR     2.11    Ensure r0 is cleared before checking IOMD vsn no.
;                               Change ROM Burst speed from93.75nS to 125nS.
; 09-Jul-96                     Make IOMD ID code more efficent. Change
;                               variables used for ROMCR Values and remove
;                               'NormalSpeed' ROMs compiler switching code -
;                               no longer supporting PSwindell.
;                               Change non-7500FE ROM Burst speed from 3 ticks
;				to 4 ticks
; 25-Jul-96	BAR	2.12	Add code to handle EEPROM as well as CMOS
;				RAM. Code supplied by J.Harris.
; 29-Jul-96     BAR     2.13    Update LED stuff to wait properly.
; 29-Jul-96	BAR	2.14	Update exit codes IOMD et all.
;				More work on the LED code.
; 30-Jul-96	BAR	2.15	Humm, get the LED's to work !
; 16-Aug-96	JRH	2.16	Add check for OS image in 2nd ROM bank.
;				Don't program the 2nd ROM bank speed (ROMCR1),
;				unless CanLiveInROMCard is True, in which case
;				check whether we're running from the 2nd bank.
;				Made display of IOMD regs conditional on new
;				ShowIOMDRegs flag, which is set to TRUE
; 05-Sep-96	BAR	2.17	Updated to NOT show the progress colours on
;				the screen unless a POST box is added when
;				they will be shown. This is in accordance
;				with fault report  ANC-00159. The final red
;				fail screen will be maintained as this
;				enfoces the fact the the POSt has failed and
;				that the ser needs to attend to the unit.
;				The compile switch DontShowProgressColours
;				can be set to FALSE, then the progress
;				colours will always be shown.
; 07-Oct-96	JRH	2.18	Changed ExtIO to fix support for speaking to
;				the test box when running from the 2nd ROM bank,
;				conditioned on CanLiveOnROMCard.
; 22-Oct-96	JRH	2.19	Added an Align64 at the end of the file because
;				OS_Find was sometimes failing. Don't know why.
;				Fixed bug introduced in 2.18 which turned burst
;				off on ROMCR0.
; 08 Nov 96	BAR	2.20	Add kluge to skip ram (long) test
;				altogether, 'cos it appears to be crashing.
; amg: Renaissance merge. 7500FE unconditional, other changes now conditioned
;      on STB being {TRUE}. Extra declarations left unconditional.
; 10 Mar 97     BAR     2.21    Add code to check 1K of NVRAM - if reqd.
; 13 Mar 97     BAR     2.22    Change conditional assemble flags for
;                               including new LED flashing routines. Now
;                               checks for Left & Right LED flags.
;                               Always use the VGA VIDC Definition Table if
;                               the flag ChrontelSupport is TRUE.
; 18 Mar 97     BAR     2.23    Added C_DEFAULT (Black) Change use of
;                               C_WARMSTART to C_DEFAULT.
; 12 Jun 97     BAR     2.24    Ensure LED is set to RED before flashing
;                               them - gets the sequence right. If flashed
;                               ensure that BOTH are turned back on.
; 19 Jun 97     BAR     2.25    Remove un-necessary mov r13,r14's
;                               When completed flashing LED's restore the
;                               faultcode flag from fiq_regs.
; 04 Apr 00     KJB     2.30    Converted to run in 32-bit mode always.
;                               ShowIOMDRegs set to FALSE (request from
;                               Tom Clay)
;
;------------------------------------------------------------------------
;
; TS_STATUS should be one of :
;
; 'R'   RISC OS POST
; 'S'   Standalone version (with a2 memory test instead of RISCOS)
; 'T'   Test build - development only
;

TS_STATUS       *       "R"     ;  Medusa POST version 2.0x
;
TS_RELEASE      *       23
TS_CHANGES      *       0


                GBLL    POSTenabled
POSTenabled     SETL    {TRUE}          ; don't permit POST for ordinary startup

                GBLL    AlwaysShortPOST
AlwaysShortPOST SETL    {TRUE} :LAND: STB       		; always do a short POST

                GBLL    ShowIOMDRegs
ShowIOMDRegs	SETL    (IO_Type = "IOMD") :LAND: {FALSE} :LAND: STB	; show IOMD regs

                GBLL   DontShowProgressColours
DontShowProgressColours	SETL	{TRUE} :LAND: STB		; Do not show the progress colour screens.
								; Progress Colours will always be shown when using POST Box.
								; Set to true for NC - Fault Report ANC-00159.

                GBLL    DontDoCMOSTest
DontDoCMOSTest  SETL    {TRUE} :LAND: STB



ts_Rom_bits     *       21                              ; Widest ROM address
ts_Rom_length   *       1 :SHL: ts_Rom_bits             ; Longest ROM
ts_highaddr_bit *       1 :SHL: 25                      ; ARM address width
ts_Alias_bits   *       (1 :SHL: 23)                    ; I/F output bits
ts_recover_time *       (1 :SHL: 8)                     ; inter-twiddle delay
ts_pause_time   *       200                             ; Display pause time
ts_S5_base      *       &3350000                        ; IO register base address
ts_IOEB_ID      *       (ts_S5_base + &50)              ; IOE_B ASIC identification
ts_IOEB_ident   *       &5                              ; the value found there
ts_PCaddress    *       &3010000                        ; PC IO world base address
ts_ReadyByte_00 *       &90                             ; signal 'Here I am' to ExtIO
ts_BBRAM        *       &A0                             ; IIC address of clock/ram chip
                [ STB
ts_BBE2         *       &A8                             ; IIC address of E2ROM chip
ts_BB2KE2       *       &E0                             ; IIC address of 2K E2ROM chip
		]
ts_RamChunk     *       &2000                           ; gap between data line tests
ts_MaxRamTest   *       4*1024*1024                     ; Max. DRAM tested on normal reset
ts_VIDCPhys     *       &3400000                        ; Real location of VIDC

;
; Border colours used for self-test indicators
;
        [ VIDC_Type = "VIDC1a"
C_ARMOK         *       &40000000+&70C  ; testing ROM
C_RAMTEST       *       &40000000+&C70  ; testing RAM
C_FAULT         *       &40000000+&00F  ; failed tests
C_PASSED        *       &40000000+&7C0  ; all passed
C_WARMSTART     *       &40000000+&777  ; not tested
C_DEFAULT       *       &40000000+&000  ; default (Black)
        ]

        [ VIDC_Type = "VIDC20"
C_2NDBANK	*	&40000000+&C00070  ; jumping to image in 2nd ROM bank (Dark blue)
C_ARMOK         *       &40000000+&7000C0  ; testing ROM (Magenta)
C_RAMTEST       *       &40000000+&C07000  ; testing RAM (Blue)
C_FAULT         *       &40000000+&0000F0  ; failed tests(Red)
C_PASSED        *       &40000000+&70C000  ; all passed  (Green)
C_WARMSTART     *       &40000000+&707070  ; not tested  (Mid grey)
C_DEFAULT       *       &40000000+&000000  ; default (Black)
        ]
;
;
; Responses to external commands
;
;
ErrorCmd        *       &00FF
;
; Control bitmasks used to indicate results of test to RISCOS
;

R_SOFT          *       0               ; not a power-on reset
R_HARD          *       1               ; Self-test run due to POR
R_EXTERN        *       2               ; external tests performed
R_TESTED        *       4               ; Self-test run due to test link
R_MEMORY        *       8               ; Memory has been tested
R_ARM3          *       &10             ; ARM 3 fitted
R_MEMSKIP       *       &20             ; long memory test disabled
R_IOEB          *       &40             ; PC-style IO controller (A5000)
R_IOMD          *       &40             ; PC-style IO controller (RiscPC, ARM7500)
R_VRAM          *       &80             ; VRAM present

R_STATUS        *       &1ff            ; bits that aren't a fault

R_CHKFAILBIT    *       &100            ; CMOS contents failed checksum
R_ROMFAILBIT    *       &200            ; ROM failed checksum
R_CAMFAILBIT    *       &400            ; CAM failed
R_PROFAILBIT    *       &800            ; MEMC protection failed
R_IOCFAILBIT    *       &1000           ; IOC register test failed
R_INTFAILBIT    *       &2000           ; Cannot clear interrupts
R_VIDFAILBIT    *       &4000           ; VIDC flyback failure
R_SNDFAILBIT    *       &8000           ; Sound DMA failure
R_CMSFAILBIT    *       &10000          ; CMOS unreadable
R_LINFAILBIT    *       &20000          ; Page zero RAM failure
R_MEMFAILBIT    *       &40000          ; Main RAM test failure
R_CACFAILBIT    *       &80000          ; ARM 3 Cache test failure
;
 [ MorrisSupport
Kludge * 96
 |
Kludge * 0
 ]
        SUBT    Exception vectors
;
; These vectors are available for use while the Rom is mapped into
; low memory addresses. The Reset vector will be copied to low RAM
; as part of a software reset sequence : therefore it must perform
; a fixed operation to ensure compatibility with future versions
; of RISC-OS.
;

Reset
ts_start
        $DoMorrisROMHeader

 [ :LNOT: MorrisSupport
  [ ResetIndirected
        LDR     pc,.+ResetIndirection   ; load pc from vector at &118
  |
        B       ts_RomPatt + PhysROM    ; Jump to normal ROM space
  ]
 ]
01
        &       ts_Rom_length           ; gets patched by ROM builder
02
        &       (ts_ROM_cvectors - ROM) ; pointer to code vector table
03
        &       (ts_ROM_dvectors - ROM) ; pointer to data vector table
04
        &       (ts_ROM_bvectors - ROM) ; pointer to branch table
        B       Reset                   ; not currently used
        B       Reset
        B       Reset


ts_ROMSIZE      *       %BT01 - ts_start
ts_CVECTORS     *       %BT02 - ts_start
ts_DVECTORS     *       %BT03 - ts_start
ts_BVECTORS     *       %BT04 - ts_start

 ! 0, "ts_Rom_length held at ":CC::STR:(%BT01 - ROM)


;
; Selftest version ID
;

00
        ASSERT  %B00 <= (ts_start + &2c + Kludge)
        %       ((ts_start + &2c + Kludge) - %B00)

ts_ID   &       ((TS_STATUS :SHL: 24) + (TS_RELEASE :SHL: 16) + TS_CHANGES)

ts_ID_text
ts_himsg
        =       "SELFTEST"                      ; **DISPLAY_TEXT**
        =       &89                             ; Cursor position
        =       TS_STATUS
        =       ("0" + (TS_RELEASE /     10))
        =       "."
        =       ("0" + (TS_RELEASE :MOD: 10))
        =       ("0" + (TS_CHANGES :MOD: 10))
        =       0

        ALIGN

;
; These vector tables permit access by the external (or downloaded) test
; software to data and code in the POST modules.
; Find the start of these tables through the 2nd and 3rd vectors at
; the start of the ROM.
;

ts_ROM_dvectors
01
        &       ts_ID                   ; Selftest identification number
02
        &       (ts_ID_text - ROM)      ; Selftest identification text


ts_ROM_cvectors
        &       ts_RomPatt
        &       ts_User_startup
        &       ts_Self_test_startup
        &       ts_Dealer_startup
        &       ts_Forced_startup
        &       ts_GetCommand
        &       ts_Softstart
        &       ts_Hardstart


;
; ROM branch vectors - intended primarily so downloaded programs
; may use standard subroutines.  This table should be in a fixed place.
;

00
        ASSERT  %B00 <= (ts_start + 128 + Kludge)
        %       ((ts_start + 128 + Kludge) - %B00)

ts_ROM_bvectors
        B       ts_RomPatt
        B       ts_GetCommand
        B       ts_SendByte
        B       ts_SendWord
        B       ts_GetByte
        B       ts_GetWord
        B       ts_SendText
        B       ts_MoreText
        B       ts_SendLCDCmd


;
; Pad out until the location of the ResetIndirection vector
;

        ASSERT  .-ROM <= ResetIndirection
        %       ResetIndirection-(.-ROM)
        &       ts_RomPatt-ROM+PhysROM

;
; ROM test code
;
; Note : the register order in ADDS ...pc.. is often critical.
; If we want to adjust pc, use ADDS pc,rn,pc so that the PSR is
; rewritten with it's original value.
; If we want to do some pc-relative arithmetic, use ADDS rn,pc,rn
; so that the bits from PSR are NOT used in the address calculation.
;

        SUBT    Macros

        MACRO
        MODE    $mode_bits
        MSR     CPSR_c,#I32_bit :OR: F32_bit :OR: $mode_bits
        MEND

        MACRO
        MOV_fiq $dest,$src
        MODE    FIQ32_mode
        MOV     $dest,$src
        MODE    SVC32_mode
        MEND

        MACRO
        FAULT   $code
        MODE    FIQ32_mode
        ORR     r12_fiq,r12_fiq,$code
        MODE    SVC32_mode
        MEND


;
; Define an area of storage with the required set of data bus patterns
; These are used both for testing the complete width of the data bus
; during ROM pattern testing, and will provide a tidy set of patterns
; if the reset is held, while the ARM increments addresses.
;

        SUBT    ROM Address and Data Patterns

DataPatterns

        GBLA    dmask
dmask   SETA    &80000000

        DCD     &FFFFFFFF               ; first two : all set
        DCD     &0                      ;             all clear

        GBLA    OldOpt                  ; don't list all the walking
OldOpt  SETA    {OPT}                   ; patterns
        OPT     OptNoList

        WHILE   dmask > 0               ; then for each bit
        DCD     &$dmask                 ; set it
        DCD     :NOT: &$dmask           ; and clear it
dmask   SETA    dmask :SHR: 1
        WEND
        OPT     OldOpt
DEnd


        OPT     OptList
;
;
; Read the ROM at a series of addresses
; such that :   a) all the address lines are exercised individually
;               b) all the data lines are exercised individually
;
; Data and address lines are exercised as walking-0 and walking-1.
; The test is performed as a series of LDR operations to avoid using
; a larger instruction set.
;

ts_RomPatt ROUT

        ; Patterns which will exercise most of the data bus.
        ; All are arbitrary instructions with NV execution

        DCD     &F0000000               ; walking 1

OldOpt  SETA    {OPT}                   ; patterns
        OPT     OptNoList

dmask   SETA    &08000000
        WHILE   dmask > 0
        DCD     dmask :OR: &F0000000
dmask   SETA    dmask :SHR: 1
        WEND

        DCD     &FFFFFFFF               ; walking 0

dmask   SETA    &08000000
        WHILE   dmask > 0
        DCD     (:NOT: dmask) :OR: &F0000000
dmask   SETA    dmask :SHR: 1
        WEND

        OPT     OldOpt

        ; Now some proper code :
        ; Initialise address pointer and make MemC safe

        LDR     r0,%01
        ADD     pc,r0,pc
01
        &       0                       ; useful constant

        [ IO_Type = "IOC-A1"            ;;!! unsafe if we execute ROM at zero
        LDR     r1,%02
        ADD     pc,r0,pc
02                                      ;;!! This remaps MEMC's ROM
        &       &E000C :OR: MEMCADR     ;;!! addressing if it hasn't
        STR     r1,[r1]                 ;;!! already happened.
        ]

        LDR     r5,%03                  ; Load r5 with a constant which
        ADD     pc,r0,pc                ; may be added to ROM plus a
03                                      ; walking-zero bitmask to create
        &       ts_Rom_length - 3       ; a valid word address in ROM.
        LDR     r2,%04                  ; Offset from ROM start to here
        ADD     pc,r0,pc
04
        &       ROM - pcfromstart

        ADD     r2,pc,r2                ; pointer to start of ROM
        ADD     r3,r2,r0                ; pointer to start of ROM
pcfromstart
        ADD     r4,r2,r0                ; pointer to start of ROM

        ; assembly-time loop - only 32 iterations required

OldOpt  SETA    {OPT}

        GBLA    doffset
doffset SETA    DataPatterns
        WHILE   doffset < DEnd

        LDR     r0,doffset              ; walking 1 data pattern
        LDR     r1,doffset+4            ; walking 0 data pattern
        LDR     r6,[r2]                 ; walking 1 address pattern
        LDR     r6,[r3]                 ; walking 0 address pattern

        [ (doffset - DataPatterns) > ((32 - ts_Rom_bits) * 8)
        [ (doffset - DataPatterns) < (31 * 8)
        ADD     r2,r4,r0                ; r2 = ROM + walking 1 pattern
        ADD     r3,r4,r1                ; r3 = ROM + walking 0 pattern
        ADD     r3,r3,r5                ; adjust to a valid address
        ]
        ]

        OPT     OptNoList

doffset SETA    doffset + 8
        WEND

        ASSERT  (. - doffset < 4095)    ; in range without barrel shift ?

        OPT     OldOpt

        [ EmulatorSupport
        ARM_on_emulator r0              ; we skip the rest of POST if
        BEQ     CONT                    ; on the emulator
        ]

;
; External interface drivers -
; provides entry points to send byte- and word- and string-sized objects
; and to receive byte- and word-sized objects
;
; Continue into GetCommand, which determines adapter type (or no adapter)
; and jumps to an ExtCmd handler, ts_User_startup, ts_Forced_startup or
; ts_Dealer_startup as appropriate.
;
        B       ts_GetCommand	; (This instruction redundant 'cos ts_GetCommand
				;  is the first thing defined in TestSrc.ExtIO)
        GET     TestSrc.ExtIO

;
; External command handlers - respond to commands given through the
; external test interface.
;

        GET     TestSrc.ExtCmd


        SUBT    Selftest
;
; There is no attached test interface. Is this a power-on reset ?
; Addressing IOC will make MEMC1a remap the ROM to high memory if
; it hasn't already done it, so be careful to ensure that the
; ARM is addressing normally-addressed ROM when this code runs.
;

ts_User_startup    ROUT
        LDR     r0,%01
        ADD     pc,r0,pc
01
        &       0
;
; IOMD will only access the ROM until a write to IOMD has been made -
; make this write also switch on refresh so the DRAM has a chance to
; get running before the memory test starts.
;
        [ MEMC_Type = "IOMD"
        LDR     r1,%02
        ADD     pc,r0,pc
02
        &       (IOMD_Base+IOMD_VREFCR)
        LDR     r2,%03
        ADD     pc,r0,pc
03
        &       IOMD_VREFCR_REF_16
        STR     r2, [r1,#0]
        ]

        [ POSTenabled
        LDR     r1,%12                  ; load address of IOC IRQ register
        ADD     pc,r0,pc
12
        &       IOC+IOCIRQSTAA

        LDR     r1, [r1,#0]             ; Get IRQSTAA register (hence POR bit)
        LDR     r2, %13
        ADD     pc,r0,pc                ; Constant to shift por to bit 31
13
        &       por_bit :SHL: 1
14      ADD     r1,r1,r1
        ADDS    r2,r2,r2
        BCC     %14                     ; loop until por_bit is at bit 31
        ADDS    r1,r1,r1                ; then shift it into carry
        BCC     ts_Self_test_end        ; POR bit clear - do soft reset.

; it's a power-on reset, so assume we can't be in 32-bit mode for ARM 6/7

        MOV_fiq r12_fiq, #R_HARD
        B       ts_Self_test_startup
        |
        B       CONT                    ; if user POST disabled
        ]
;
; Perform self - tests
;
; Any distinction between test operation for Power-up, Display-only
; and Forced tests needs to be made between these three entry points.
;


; This is where tests start if a dumb test link is fitted
; (a diode from A21 to *ROMCS, disabling the ROMs when A21 is high)

ts_Forced_startup  ROUT

        MOV_fiq r12_fiq, #R_TESTED
        B       ts_Self_test_startup

; This is where the tests start if an external display adapter is fitted

ts_Dealer_startup  ROUT

        MOV_fiq r12_fiq, #R_EXTERN

        LDR     r4,%FT02                ; make a pointer to signon string
01      ADD     r4,pc,r4
        ADD     pc,r0,pc
02
        &       (ts_himsg - %BT01 - 8)

        ADD     r14,pc,r0               ; make a return address for this 'call'
        ASSERT  (.+4 = ts_Self_test_startup)    ; PC must point there already !
        B       ts_SendText

ts_Self_test_startup ROUT

; This is where the power-on test starts (every user gets this)


;
; Processor test would go here .... if there was one.
;

 [ MorrisSupport
;
; On startup Morris defaults to dividing all its clocks by two and
; accessing ROM at the slowest possible access speed. So check for
; Morris and set to sensible values.
;
; check for te veriosn of IOMD, only need to determin between variants in
; the ARM7500 and ARM7500FE - condional code assembly excludes non-ARM7500
; devices.

        MOV     r2, #IOMD_Base		; r2 points to the IOMD base address defiend in HDR:IO.IOMDL
        LDRB    r1,[r2,#IOMD_ID1]	; load r1 with IOMD ID high byte
        LDRB    r0,[r2,#IOMD_ID0]	; load r0 with IOMD ID low byte
        ORR     r0,r0,r1,LSL#8		; Or r0 and r1, shifted left 8, put in r0
        LDR     r1,=ts_IOMD_ID2		; get Ref IOMD ID code #2
        CMPS    r0,r1                   ; check for IOMD ID Code #2
	BEQ	%FT05			; If equal, got to 05

        LDRNE   r1,=ts_IOMD_ID3		; If not ID1, get ID code #3
        CMPNES  r0,r1			; If not ID1, check for IOMD ID Code #3
        BNE     %FT10			; Not equal; not an ARM7500 or an ARM7500FE - skip

  [ RO371Timings
05
        MOV     r0, #0                  ;Calling from POST
        BL      TimeCPU                 ;just sets things according to assumed bus speeds for each IOMD id, in this case

  | ; else if not RO371Timings

; Here because its an ARM7500 'FE' variant
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;	CPUCLK divide by 2 unless FECPUSpeedNormal set
;	MEMCLK divide by 1
;	IOCLK  divide by 1
;
 [ FECPUSpeedNormal
	MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
 |
	MOV     r0, #IOMD_CLKCTL_CpuclkHalf + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
 ]
        STRB    r0, [r2, #IOMD_CLKCTL] ; initialise all the prescalers.
;
; Set ROM speed, take care to preserve 16-bit mode bit...
;
; According to BSiddle on the 15-May-96, Omega will use burst mode roms: use 93nS burst, 156nS initial.
; According to TDbson on the 09-Jul-96, Omega will handle ROMS up to 120nS and 70nS.
; Thus the ROM speed should be initilised to :-
; Half Speed or H bit, clear, which is ON ! : Half the delays, thus DOUBLE all clock ticks.
; Non-Sequental delay : 10 Ticks : Half speed on, so select 5 ticks (5*2)
; Burst delay         :  8 Ticks : Half speed on, so select 4 ticks (4*2)
; Remember the Memory clock on Omega is faster than on previous porducts.
; The fast flash devices used for Omega testing should be able to cope even
; though they aren't burst devices.
        LDRB    r0, [r2, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
    [ ROMSpeedNormal
        ORR     r0, r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_NSTicks_$ROMSpeedNSTicks :OR: IOMD_ROMCR_BTicks_$ROMSpeedBurstTicks
    |
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_NSTicks_$ROMSpeedNSTicks :OR: IOMD_ROMCR_BTicks_$ROMSpeedBurstTicks
    ]
        STRB    r0, [r2, #IOMD_ROMCR0]          ; Prog. the reg.s
  [ CanLiveOnROMCard
	TST	pc, #ts_RC_2ndbank		; Not running out of 2nd ROM bank?
        ; Don't know what's in the 2nd bank -> program it to a slow default
    [ ExtROMis16bit
     [ ROMSpeedNormal
        MOVEQ   r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_16bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     |
        MOVEQ   r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_16bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     ]
    |
     [ ROMSpeedNormal
        MOVEQ   r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_32bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     |
        MOVEQ   r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_32bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     ]
    ]
        STRB    r0, [r2, #IOMD_ROMCR1]		; Otherwise program it the same
  ]
	B	%FT10
;

05
; Here because its an ARM7500 variant - NON 'FE' device.
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;	CPUCLK divide by 1
;	MEMCLK divide by 1
;	IOCLK  divide by 1
;
        MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
        STRB    r0, [r2, #IOMD_CLKCTL] ; initialise all prescalers to div1
;
; Set ROM speed, take care to preserve 16-bit mode bit...
;
; According to RJKing on 6/5/94, Kryten will use burst mode roms: use 93nS burst, 156nS initial.
; According to BSiddle on 09-Jul-96 - Omega will need to set the burst speed to 4 ticks from 3 ticks.
; Thus the ROM speed should be initilised to :-
; Half Speed or H bit, Set, which is OFF ! : Don't half the delays.
; Non-Sequental delay :  5 Ticks : Half speed off, so select 5 ticks
; Burst delay         :  4 Ticks : Half speed off, so select 4 ticks
; The fast EPROMS used for Kryten testing should be able to cope even though
; they aren't burst devices

        LDRB    r0, [r2, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
    [ ROMSpeedNormal
        ORR     r0, r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_NSTicks_$ROMSpeedNSTicks :OR: IOMD_ROMCR_BTicks_$ROMSpeedBurstTicks
    |
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_NSTicks_$ROMSpeedNSTicks :OR: IOMD_ROMCR_BTicks_$ROMSpeedBurstTicks
    ]
        STRB    r0, [r2, #IOMD_ROMCR0]          ; Prog. the reg.s
  [ CanLiveOnROMCard
	TST	pc, #ts_RC_2ndbank		; Not running out of 2nd ROM bank?
        ; Don't know what's in the 2nd bank -> program it to a slow default
    [ ExtROMis16bit
     [ ROMSpeedNormal
        MOVEQ   r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_16bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     |
        MOVEQ   r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_16bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     ]
    |
     [ ROMSpeedNormal
        MOVEQ   r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_32bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     |
        MOVEQ   r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_32bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     ]
    ]
        STRB    r0, [r2, #IOMD_ROMCR1]		; Otherwise program it the same
  ]

 ] ;RO371Timings conditional

;
10
 ]
;
; From this point on we assume we can safely use all the processor
;
; Initialise VIDC
;

ts_InitVIDC
        [ IO_Type = "IOMD"              ; If POSTbox fitted, ROM may still be mapped everywhere
                ; Using IOMD
                MOV     r2,#IOMD_Base
                MOV     r0, #IOMD_VREFCR_REF_16 ; switch on DRAM refresh
                STR     r0, [r2, #IOMD_VREFCR]
                MOV     r1,#ts_VIDCPhys

                [ ChrontelSupport
                        ; We have a Chrontel chip ... thus always set for VGA.
                        ADRL    r2,TestVVIDCTAB
                | ; NOT ChrontelSupport
                        ; We don't have a Chrontel chip
                        ; ... thus check MonitorType and select table as reqd.
                        ADRL    r2,TestVIDCTAB
                        LDR     r0,=IOMD_MonitorType
                        LDR     r0,[r0]
                        ANDS    r0,r0,#IOMD_MonitorIDMask
                        ADDEQ   r2,r2,#(TestVVIDCTAB-TestVIDCTAB)
                ] ; Endif - ChrontelSupport
        | ; not IOMD
                MOV     r1,#ts_VIDCPhys
                ADRL    r2,TestVIDCTAB
        ] ; Endif - IO_Type = "IOMD"

10      LDR     r0, [r2],#4
        CMP     r0, #-1
        STRNE   r0, [r1]
        BNE     %BT10

;
; Test for presence of OS image in 2nd ROM bank and jump to it
;
	GBLS	DoROMCardThings
  [ ROMCardSupport :LOR: CanLiveOnROMCard
DoROMCardThings	SETS	"GET	TestSrc.ROMCard"
  |
DoROMCardThings	SETS	""
  ]
	$DoROMCardThings


;
; Set purple screen
;

	[ DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	ts_RomTest			; EQ : Don't show colours
	]
	MOV	r1, #ts_VIDCPhys

 [ :LNOT: StrongARM_POST
   ;skip POST for StrongARM or ARM8
        ARM_read_ID r0
        AND     r0,r0,#&F000
        CMP     r0,#&A000              ;if we are a StrongARM...
        CMPNE   r0,#&8000              ;or an ARM8...
        LDREQ   r0,=C_WARMSTART        ;the colour that indicates no POST performed
        STREQ   r0,[r1]
        BEQ     ts_Hardstart           ;RISC OS - right now!
 ]

 [ ARM810support :LAND: (:LNOT: ARM810_POST)
   ;just too horrible to fix POST for ARM 8 at the moment
        ARM_read_ID r0
        AND     r0,r0,#&F000
        CMP     r0,#&8000              ;if we are an ARM 8
        LDREQ   r0,=C_WARMSTART        ;the colour that indicates no POST performed
        STREQ   r0,[r1]
        BEQ     ts_Hardstart           ;RISC OS - right now!
 ]

        LDR	r0, =C_ARMOK     		; set initial screen colour
        STR	r0, [r1]

        B       ts_RomTest

        LTORG
        ROUT

;
; Calculate ROM checksum : display status and calculated checksum.
;

1
        =       "ROM   :",0
2
        =       "ROM bad",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
3
        =       "ROM size",&8A,&ff,&ff,&ff,&ff,&ff,&ff,0
        ALIGN

ts_RomTest
        ADR     r4,%BT1
        BL      ts_SendText

        BL      ts_ROM_checksum
        BEQ     %20
        ADR     r4,%BT2                 ; Failed message
        FAULT   #R_ROMFAILBIT           ; set ROM bit in r12_fiq
        MOV     r8,r0                   ; calculated checksum
        BL      ts_SendText

        BL      ts_ROM_alias            ; Checksum failed :-
        ADR     r4,%BT3                 ; hunt for first alias
        MOV     r8,r0, LSL #8
        BL      ts_SendText             ; and report it.
20

        [ IO_Type = "IOC-A1"            ; Don't use RISC OS MemSize
                                        ; until much later - it sets up
                                        ; the ARM600 MMU as well.
        B       ts_MEMCset

;
; Do MEMC setup and memory size determination (the first time).
;
        LTORG
        ROUT

1
        =       "M Size :",0
2
        =       "M Size",&89,&ff,&ff,&ff,&ff,".",&ff,&ff,0
        ALIGN

ts_MEMCset
        MOV     r12,#0
        ADR     r4,%BT1
        BL      ts_SendText
        LDR     r1,=(&E000C :OR: MEMCADR)       ; MemSize expects 32k page
        STR     r1,[r1]
        BL      MemSize

;
; MemSize returns with  r0 = page size   (now in bytes, *NOT* in MEMC control patterns),
;                       r1 = memory size (in bytes)
;                       r2 = MEMC control value
;
; Translate these into a number that looks like :
;
;                       mmmm.pp
;
; where mmmm is memory size in hex Kbytes, pp is page size in hex Kbytes.
;
        MODE    FIQ32_mode                      ; Save memory size and
        MOV     r11_fiq,r2                      ; MEMC setup value for
        MOV     r10_fiq,r1                      ; later use
        MODE    SVC32_mode

        MOV     r8, r0, LSR #2                  ; MemSize now returns actual page size in r0
        ADD     r8,r8,r1,LSL #6
        ADR     r4,%BT2
        BL      ts_SendText

        ]

;
; Test data, address and byte strobe lines.
; On MEMC systems, this calls MemSize and tests the memory that finds.
; On IOMD systems, memory sizing is performed along with the data line
; tests, and that result is used for address line testing.
;

        B       ts_LineTest

                GBLS    tsGetMem1
tsGetMem1       SETS    "GET TestSrc.Mem1" :CC: MEMC_Type
                $tsGetMem1

;
; Test IOC.
; This shuld require vector space to work (for testing interrupts),
; but the current version just reports the status register contents.
;
; Display is    ccaabbff
;
;  where cc is the control register
;        aa is IRQ status register A
;        bb is IRQ status register B
;        ff is FIQ status register
;

        B       ts_IOCTest

        LTORG
        ROUT

        [ IO_Type = "IOMD"
1
        =       "IOMD  :",0
2
        =       "IOMD-F",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
3
        =       "IOMD-V"
4
        =       &88,&ff,&ff,&ff,&ff," V.",&ff,0
        |
1
        =       "IOC   :",0
2
        =       "IOC-F",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
3
        =       "IOC"
4
        =       &88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
        ]
        ALIGN

ts_IOCTest
        ADR     r4,%BT1
        BL      ts_SendText
        BL      ts_IOCreg       ; check register integrity
        BEQ     %FT8
        ADR     r4,%BT2
        BL      ts_SendText     ; report if failure

        FAULT   #R_IOCFAILBIT
8
        ADR     r4,%BT1
        BL      ts_SendText
        BL      ts_IOCstat      ; IOCstat, get IOC/IOMD Vsn number.
                                ; Note : func leaves falgs un altered, thus
                                ; result of last comparison is passed back
                                ; as the result.
                                ; r8 has the id&vsn number : &IIIIVV00
        BEQ     %FT10           ; fail message only printed if
        ADR     r4,%BT3         ; ID code unrecognised
        BL      ts_SendText
        FAULT   #R_IOCFAILBIT   ; .. and set error bit if IOMD code is wrong
        B       %FT11
10
        ADR     r4,%BT4         ; print the status value
        BL      ts_MoreText
        FAULT   #R_IOMD         ; set that bit in the result word
				; to indicate an IOMD was found.

11

  [ IO_Type = "IOMD"
		; IO world is IOMD : Show IOMD Regs, skip IOEB test
    [ ShowIOMDRegs
	BL	sir_ShowIOMDRegs
    ]
        B       ts_CMOStest
  |
		; IO world is IOEB: Do the IOEB test, skip Show IOMD Regs.
        B       ts_IOEBtest
  ]

        LTORG
        ROUT

;
; Check for presence of IOEB ASIC
;

        [ IO_Type = "IOEB"

1
        =       "IOEB  :",0
2
        =       "IOEB",&88,"exists",0


        ALIGN

ts_IOEBtest
        ADR     r4,%BT1
        BL      ts_SendText

        LDR     r0,=ts_IOEB_ID                  ; read an ID register in the IOEB ASIC
        LDRB    r0, [r0]
        AND     r0, r0, #&f
        CMPS    r0, #ts_IOEB_ident              ; if it looks right ( == 5) ..
        BNE     %10

        FAULT   #R_IOEB                         ; set that bit in the result word
        ADR     r4, %BT2
        BL      ts_SendText
10      B       ts_CMOStest
        ] ; IOEB IO world
        ROUT

;
; Read CMOS
; Check the checksum, read the memory test flag.
;


ts_CMOStest
        [ DontDoCMOSTest
        B       ts_IOinit
        |
        ADR     r4,%FT1
        BL      ts_SendText

        [ ChecksumCMOS :LAND: STB
        LDR     r0,=(ts_BBRAM + &4000)
        MOV     r1,#&C0                 ; Get first RAM area
        MOV     r2,#CMOSxseed
        BL      ts_CMOSread
        BNE     %FT10
        MOV     r2, r0
        LDR     r0,=(ts_BBRAM + &1000)  ; Accumulate the second RAM area
        MOV     r1,#&2F
        BL      ts_CMOSread
        BNE     %FT10
        RSB     r2, r0, #0              ; Subtract from the checksum byte
        LDR     r0,=(ts_BBRAM + &3F00)
        MOV     r1,#1
        BL      ts_CMOSread
        BNE     %FT10
        MOV     r8, r0, LSL #24
        ANDS    r0, r0, #&FF            ; A zero result ?
        MOV     r1, #R_CHKFAILBIT
        ADR     r4,%FT3                 ; Report checksum failure
        BNE     %FT21                   ; failed .. report error
        ]                               ; end ChecksumCMOS

	[ :LNOT: AlwaysShortPOST	; Always do a short post on STBs
        LDR     r0,=(ts_BBRAM + &FC00)  ; Read Misc1CMOS byte
        MOV     r1,#1
        MOV     r2,#0
        BL      ts_CMOSread
        BNE     %FT10
        ANDS    r0,r0,#&80              ; Test the memory-test-disable bit
        BEQ     %FT25
	]
        FAULT   #R_MEMSKIP              ; If set, skip the memory test
        B       %FT25

10
; CMOS failed -> try E2
    [ E2ROMSupport :LAND: STB
        [ ChecksumCMOS

                                        ; Accumulate the first RAM area
        LDR     r0,=(ts_BBE2 + &4000)   ; r0 = base addr + start location
        MOV     r1,#&C0                 ; r1 = length of data to read
        MOV     r2,#CMOSxseed           ; r2 = checksum seed or previous value
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %FT20                   ; branch if NE - failed to ready at all.

                                        ; Accumulate the second RAM area
        MOV     r2, r0                  ; r2 = r0 = new checksum value.
        LDR     r0,=(ts_BBE2 + &1000)   ; r0 = base addr + start location
        MOV     r1,#&2F                 ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %FT22                   ; branch if NE - failed to ready at all.
        RSB     r2, r0, #0              ; Subtract from the checksum byte

                                        ; Check to see if we need to Accumulate the THIRD area.
        MOV     r1,#?CMOSRAMCache        ; r1 = size of the CMOS RAM
        TEQ     r1,#240                 ; Is r1 = 240 bytes ?
        BEQ     %FT15                   ; It is equal, go to checksum checking code

                                        ; Accumulate the third RAM area
        MOV     r2,r0                   ; r2 = r0 = new checksum value.
        LDR     r0,=(ts_BBE2 + &10000)  ; r0 = base addr + start location
        MOV     r1,#&300                ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %FT22                   ; branch if NE - failed to ready at all.

                                        ; read and check the shecksum value.
15      RSB     r2, r0, #0              ; Subtract from the checksum byte
        LDR     r0,=(ts_BBE2 + &3F00)   ; r0 = base addr + start location
        MOV     r1,#1                   ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %FT22                   ; branch if NE - failed to ready at all.

                                        ; Check the checksum is correct
        MOV     r8, r0, LSL #24         ; r8 = r0 << 24 : put the checksum value in r8 for displaying.
        ANDS    r0, r0, #&FF            ; r0 = r0 + &FF : If alls ok s/be a zero result ...
        MOV     r1, #R_CHKFAILBIT       ; r1 = checksum fail flag
        ADR     r4,%FT3                 ; Report checksum failure
        BNE     %FT21                   ; failed .. report error
        ]                               ; end ChecksumCMOS

	[ STB :LAND: :LNOT: AlwaysShortPOST	; Always do a short post on STBs
        LDR     r0,=(ts_BBE2 + &FC00)   ; Read Misc1CMOS byte
        MOV     r1,#1
        MOV     r2,#0
        BL      ts_CMOSread
        BNE     %FT22
        ANDS    r0,r0,#&80              ; Test the memory-test-disable bit
        BEQ     %FT25
	]
        FAULT   #R_MEMSKIP              ; If set, skip the memory test
        B       %FT25
    ]

1
        =       "SRAM  :",0
2
        =       "SRAM-F",0
3
        =       "SRAM-C",&8e,&ff,&ff,0
        ALIGN

20
; CMOS failed -> try 2K E2
    [ E2ROMSupport
        [ ChecksumCMOS

                                        ; Accumulate the first RAM area
        LDR     r0,=(ts_BB2KE2 + &4000) ; r0 = base addr + start location
        MOV     r1,#&C0                 ; r1 = length of data to read
        MOV     r2,#CMOSxseed           ; r2 = checksum seed or previous value
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %FT22                   ; branch if NE - failed to ready at all.

                                        ; Accumulate the second RAM area
        MOV     r2, r0                  ; r2 = r0 = new checksum value.
        LDR     r0,=(ts_BB2KE2 + &1000) ; r0 = base addr + start location
        MOV     r1,#&2F                 ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %FT22                   ; branch if NE - failed to ready at all.
        RSB     r2, r0, #0              ; Subtract from the checksum byte

                                        ; Check to see if we need to Accumulate the THIRD area.
        MOV     r1,#?CMOSRAMCache        ; r1 = size of the CMOS RAM
        TEQ     r1,#240                 ; Is r1 = 240 bytes ?
        BEQ     %FT15                   ; It is equal, go to checksum checking code

                                        ; Accumulate the third RAM area
        MOV     r2,r0                   ; r2 = r0 = new checksum value.
        LDR     r0,=(ts_BB2KE2 + &10000); r0 = base addr + start location
        MOV     r1,#&300                ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %FT22                   ; branch if NE - failed to ready at all.

                                        ; read and check the shecksum value.
15      RSB     r2, r0, #0              ; Subtract from the checksum byte
        LDR     r0,=(ts_BB2KE2 + &3F00) ; r0 = base addr + start location
        MOV     r1,#1                   ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %FT22                   ; branch if NE - failed to ready at all.

                                        ; Check the checksum is correct
        MOV     r8, r0, LSL #24         ; r8 = r0 << 24 : put the checksum value in r8 for displaying.
        ANDS    r0, r0, #&FF            ; r0 = r0 + &FF : If alls ok s/be a zero result ...
        MOV     r1, #R_CHKFAILBIT       ; r1 = checksum fail flag
        ADR     r4,%BT3                 ; Report checksum failure
        BNE     %FT21                   ; failed .. report error
        ]                               ; end ChecksumCMOS

	[ :LNOT: AlwaysShortPOST	; Always do a short post on STBs
        LDR     r0,=(ts_BB2KE2 + &FC00) ; Read Misc1CMOS byte
        MOV     r1,#1
        MOV     r2,#0
        BL      ts_CMOSread
        BNE     %FT22
        ANDS    r0,r0,#&80              ; Test the memory-test-disable bit
        BEQ     %FT25
	]
        FAULT   #R_MEMSKIP              ; If set, skip the memory test
        B       %FT25
    ]
22
        MOV     r1,#R_CMSFAILBIT        ; Real fault - set the fault bit
        ADR     r4,%BT2                 ; Report fault accessing IIC
                                        ; (Bitmap & POST display)
21
        FAULT   r1
        BL      ts_SendText             ; Report one fault or another
25
        B       ts_IOinit

        ] ; DontDoCMOSTest

        LTORG
        ROUT
;
; Initialize  various machine registers - e.g, turn off the floppy
; drive, etc, etc.
;

1
        =       "IOinit:",0
        ALIGN

ts_IOinit
        ADR     r4,%BT1
        BL      ts_SendText
        ADRL    r2,ts_IOinitab
10
        LDR     r0,[r2],#4              ; Get address
        LDR     r1,[r2],#4              ; Get initialization data
        CMPS    r0,#(-1)
        STRNE   r1,[r0]                 ; write to IO port
        BNE     %10
        B       Speedset
;
; Use the RISC OS MEMC setup code to guess the proper processor / memory
; configuration. The memory speed can then be set up correctly for
; fastest possible working, and the memory array tested in the
; configuration RISC OS expects.
;
; Display the results of the TimeCPU test as :
;
;               ssss.m.r
;
; where ssss is the processor speed in hex kHz,
;       m    is 0 for MEMC, 1 for MEMC1a
;       r    is the MEMC rom speed switch setting.
;
        ROUT

1
        =       "Speed :",0
2
        =       "Speed",&88,&ff,&ff,&ff,&ff,".",&ff,".",&ff,0

        ALIGN

Speedset
        ADR     r4,%BT1
        BL      ts_SendText

        [ MEMC_Type = "IOMD"
        MOV     r9,#0
        |
        MOV_fiq r0, r11_fiq                     ; get MEMC setup
        MOV     r9,r0                           ; compare IOC and CPU clocks
        ]

        BL      TimeCPU
        MOV     r0,r9
        MOV_fiq r11_fiq,r0

        MOV     r8,r7,LSL #16
        TST     r7, #1 :SHL: 16                 ; test bit 16 of r7 :
        ADDNE   r8,r8,#&1000                    ; MEMC1 / MEMC1a detected
        AND     r9,r9,#&C0                      ; get High ROM access bits
        ADD     r8,r8,r9, LSL #2
        ADR     r4,%BT2
        BL      ts_SendText
        B       RAMtest

;
; Long RAM test, ideally exercising all memory.
; In order to keep boot time short, the following scheme is used :
;
; Normal power-on boot - test VRAM and up to 4M of first DRAM entry
; CMOS disable set     - test nothing
; Test hardware fitted - test entire memory
;

        ROUT


1
        =       "RAM   :",0
2
        =       "RAM bad",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
3
        =       &89,"skipped",0
4
        =       "RAM   :",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0


        ALIGN

RAMtest
 [ {TRUE}
        B       ts_VIDCtest	; skip memory test altogether
 |
	ADR     r4,%BT1
 ]
        BL      ts_SendText
;
; if (R_MEMSKIP && R_HARD)
;       skip all the remaining tests
; if (!R_LINFAILBIT)
;       perform the long memory test
;
        MOV_fiq r0,r12_fiq              ; skip this test if data line fault
        AND     r1,r0,#(R_MEMSKIP :OR: R_HARD)  ; or the user didn't want it
        TEQS    r1,#(R_MEMSKIP :OR: R_HARD)
        ANDNE   r1,r1,#R_LINFAILBIT
        TEQNE   r1,#R_LINFAILBIT
        BNE     %12
        ADR     r4,%BT3                 ; skipping memory test ....
        BL      ts_MoreText
        B       ts_Report
12
	[ STB :LAND: DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	%FT13				; EQ : Don't show colours
	]
        LDR     r1,=C_RAMTEST           ; doing at least part of the long memory test
        LDR     r0,=ts_VIDCPhys         ; write the border colour
        STR     r1,[r0]
13
        BL      MemSize                 ; Set MMU up, mapping (some) RAM at logical address 0
                                        ; Note that this returns with the MMU enabled,
                                        ; the ROM remapped to it's ORGed address,
					; and r4 the offset from physical to ORGed ROM addresses
					; r4 = ROM - Phys[Ext]ROM
	RSB	r4, r4, #PhysSpace	; r4 = PhysSpace - ROM + Phys[Ext]ROM, pc = ROM + offset
        MODE    SVC32_mode              ; Must do this, as PhysSpace is outside 26 bit addressing
	ADD	pc, pc, r4		; pc = PhysSpace + Phys[Ext]ROM + offset
        NOP                             ; this instruction skipped by pc adjustment

;
; Modify the PhysRamTable so only VRAM and the first ts_MaxRamTest of DRAM gets tested
;
        MOV_fiq r0,r12                  ; get the test condition flags

        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)
        BNE     %FT16                   ; do full test if test adapter is present
        MOV     r9,#PhysRamTable
        ADD     r10,r9,#(PhysRamTableEnd-PhysRamTable)
14
        LDR     r1,[r9, #4]
        ADD     r0,r0,r1                ; r0 = running sum of memory sizes
        SUBS    r2,r0,#ts_MaxRamTest    ; r2 = excess over ts_MaxRamTest
        SUBHI   r1,r1,r2                ; r1 = current size truncated
        STRHI   r1,[r9, #4]
        MOVHI   r0,#ts_MaxRamTest       ; truncate running sum to MaxRamTest

        ADD     r9,r9,#(DRAMPhysAddrB-DRAMPhysAddrA)
        CMPS    r9,r10
        BNE     %BT14
16
        FAULT   #R_MEMORY               ; memory tests were attempted

        MOV     r9,#VideoPhysAddr
        LDR     r8,[r9]                 ; report the test address
        ADRL    r4,%BT4
        BL      ts_SendText
        LDR     r0,[r9]                 ; get VRAM start address and size
        LDR     r1,[r9,#4]
        ADD     r0,r0,#PhysSpace
        BL      ts_RamTest
        BNE     %FT20                   ; failed - abort ram testing

;
; VRAM (or 1st MB of DRAM, if no VRAM fitted) looks OK - move the translation
; table there so memory tests can proceed without smashing it.
;
        MOV     r9,#PhysRamTable
        LDR     r0,[r9,#VideoPhysAddr-PhysRamTable]     ; get address of video RAM
        LDR     r1,[r9,#DRAMPhysAddrA-PhysRamTable]     ; get address of 1st DRAM bank
        LDR     r3, =DRAMOffset_L2PT
        ADD     r1, r1, r3              ; make r1 -> L2PT
        ADD     r0, r0, r3              ; make r0 -> temporary L2PT
        BL      ts_remap_ttab           ; copy ttab at r1 to r0 and change table base

;
; Now run the RAM test at each DRAMPhysAddr until the end of the table or a zero entry
; is reached. Mark tested entries by setting the PhysSpace address, so a pointer to the
; next entry need not be kept.
;
18
        MOV     r9,#DRAMPhysAddrA
        ADD     r10,r9,#(PhysRamTableEnd-DRAMPhysAddrA)
19
        CMPS    r9,r10                  ; reached end of table ?
        LDRNE   r0,[r9]
        TSTNE   r0,r0                   ; reached unused entries ?
        LDRNE   r1,[r9,#4]              ; or blanked-out entries ?
        TSTNE   r1,r1
        BEQ     %FT21                   ; .. all passed OK
        TSTS    r0,#PhysSpace
        ADDNE   r9,r9,#(DRAMPhysAddrB-DRAMPhysAddrA)
        BNE     %BT19                   ; this entry done .. find the next

        MOV     r8,r0                   ; report address of this block
        ADRL    r4,%BT4
        BL      ts_SendText

        LDR     r0,[r9]                 ; start testing it
        ADD     r0,r0,#PhysSpace
        LDR     r1,[r9, #4]
        STR     r0,[r9]                 ; mark block so it isn't retested
        MOV     r2,#PhysRamTable
        LDMIA   r2,{r3-r14}             ; save the PhysRamTable
        STMIA   r0,{r3-r14}
        BL      ts_RamTest
        LDMIA   r13,{r1-r11,r14}        ; restore the PhysRamTable
        MOV     r13,#PhysRamTable
        STMIA   r13,{r1-r11,r14}
        BEQ     %BT18                   ; if it passed, go look for another block

20
        FAULT   #R_MEMFAILBIT           ; failed - report fault address
        ADRL    r4,%BT2
        MOV     r11,r1                  ; Save failed data
        MOV     r8,r0                   ; first failing address
        BL      ts_SendText
        MOV     r4,r12                  ; get fault message
        MOV     r8,r11                  ; and fault data
        BL      ts_SendText
21

 [ MEMM_Type = "MEMC1"

;
; Test the CAMs - for each fitted MEMC, go through all the CAM entries
; remapping logical memory and testing against physical correspondence.
; Then try out the protection bits in each CAM entry and various
; processor modes.
; These tests return pointers to their own fault report strings.
;
        B       ts_CAMtest
        ROUT
1
        =       "CAMs :",0
2
        =       "PPLs :",0
3
        =       &89,"skipped",0
        ALIGN

ts_CAMtest
        LDR     r4,=%BT1
        BL      ts_SendText

        MOV_fiq r0,r12_fiq              ; skip this test if memory fault
        MOV     r1,#(R_LINFAILBIT :OR: R_MEMFAILBIT)
        ANDS    r0,r0,r1
        BEQ     %08
        LDR     r4,=%BT3
        BL      ts_MoreText
        B       %20

08
        BL      ts_CAM
        BEQ     %10
        BL      ts_SendText
        FAULT   #R_CAMFAILBIT
10
        LDR     r4,=%BT2
        BL      ts_SendText

        MOV_fiq r0,r12_fiq              ; skip this test if memory fault
        MOV     r1,#(R_LINFAILBIT :OR: R_MEMFAILBIT)
        ANDS    r0,r0,r1
        BEQ     %18
        LDR     r4,=%BT3
        BL      ts_MoreText
        B       %20
18
        BL      ts_memc_prot
        BEQ     %20
        BL      ts_SendText
        FAULT   #R_PROFAILBIT
20

 ]

;
; After testing memory and translation, turn MMU off again before running remainder
; of tests. This simplifies finishing up (where system must be put back into 26-bit
; mode before initialising RISCOS) if memory tests were deselected.
; Take care to poke the real translation table - it's been relocated to video
; RAM during the memory tests.
;

ts_restore_physical

  [ StrongARM_POST
    ;make sure ARM810 cache or StrongARM data cache is cleaned/flushed, because we are going to remap
        ARM_read_ID r5
        AND     r5,r5,#&F000
        CMP     r5,#&8000
        BNE     %FT22
;ARM810
;;;        ARM8_cleanflush_IDC r5  ;not implemented yet
        B       %FT24
22
        CMP     r5,#&A000
        BNE     %FT24
;StrongARM
;tricky...we'll read 16k of data in current ROM space, to act as clean and flush of current data
        MOV     r3,pc
        BIC     r3,r3,#31      ;32 byte aligned
        ARMA_clean_DC r3,r5,r7
24
  ] ;StrongARM_POST

        MOV     r5, pc                          ; obtain current address
        SUB     r5, r5,#PhysSpace               ; adjust to point to unmapped version
        MOV     r5, r5, LSR #20                 ; divide by 1MB
        MOV     r7, r5, LSL #20                 ; r7 = physical address of base of section
        ORR     r7, r7, #(AP_None * L1_APMult)
        ORR     r7, r7, #L1_Section
        MOV     r3, #VideoPhysAddr              ; find the copied translation table
        LDR     r3, [r3]
        ADD     r3, r3, #PhysSpace
        ADD     r3, r3, #DRAMOffset_L1PT
        STR     r7, [r3, r5, LSL #2]            ; store replacement entry in L1 (not U,C or B)

  [ StrongARM_POST
    ;flush cache if ARM 6/7 (ARM 8,StrongARM already sorted, above)
    ;flush TLB(s)
        ARM_read_ID r4
        AND      r4,r4,#&F000
        CMP      r4,#&8000   ;ARM 8?
        CMPNE    r4,#&A000   ;or StrongARM?
        MCRNE    ARM_config_cp,0,R0,ARM67_cacheflush_reg,C0,0   ;flush 6/7 cache
        MCRNE    ARM_config_cp,0,R0,ARM67_TLBflush_reg,C0,0     ;flush 6/7 TLB
        MCREQ    ARM_config_cp,0,R0,ARM8A_TLB_reg,C7,0          ;flush 8/StrongARM TLB(s)
  |
        SetCop  r7, CR_IDCFlush                 ; flush cache + TLB just in case
        SetCop  r7, CR_TLBFlush                 ; (data written is irrelevant)
  ]

; The ROM should now be mapped at the present address less PhysSpace, which is where it
; would be if the MMU were turned off.

        MOV     r4,#PhysSpace
        SUB     pc,pc,r4
        NOP                             ; this instruction is skipped

; now turn the MMU off, also ensures 26 bit mode, if ARM 6/7 (since P bit zero)
        MOV     r7, #MMUC_D
        SetCop  r7, CR_Control

        B       ts_VIDCtest

;
; The VIDC tests check vertical blanking frequency in a fixed video
; mode and measure the time taken for sound DMA.
;

        ROUT

1
        =       "VIDC  :",0
2
        =       "Virq bad",&88,' ',&ff,'.',&ff,&ff,&ff,&ff,&ff,0
3
        =       "Sirq bad",&8B,&ff,&ff,&ff,&ff,&ff,0
4
        =       &8A,"Mid0 ",&ff,0

        ALIGN

ts_VIDCtest
        ADR     r4,%BT1
        BL      ts_SendText
        [ IO_Type = "IOMD"
        LDR     r0,=IOMD_MonitorType    ; Indicate monitor ID bit's value
        LDR     r0,[r0]
        AND     r0,r0,#IOMD_MonitorIDMask
        MOV     r8,r0,LSL #28
        ADR     r4,%BT4
        BL      ts_MoreText
        ]

 [ MorrisSupport
        MOV     r3, #IOMD_Base
        LDRB    r1,[r3,#IOMD_ID1]	; load r1 with IOMD ID high byte
        LDRB    r0,[r3,#IOMD_ID0]	; load r1 with IOMD ID low byte
        ORR     r0,r0,r1,LSL#8		; Or r0 and r1, shifted left 8, put in r0
        LDR     r1,=ts_IOMD_ID1		; get Ref IOMD ID code #1 (Original)
        CMPS    r0,r1                   ; check for IOMD ID Code #1
	BNE	%FT10			; If not equal, got to 10
					; thus skip Virq test on ARM7500 and ARM7500FE (Morris)
 ]

        BL      ts_VIDC_period
        BEQ     %10
        ADR     r4,%B2
        MOV     r8, r0, LSL #8
        BL      ts_SendText             ; Display Virq fail msg
        FAULT   #R_VIDFAILBIT
10
        [ IO_Type = "IOMD"
  ; RCM thinks this is no longer needed - all IOMD's are issue two
  ;     besides, the test takes no account of Morris reusing the number space!
  ;      MOV     r3,#IOMD_Base           ; skip Sirq test on version 1 IOMD
  ;      LDRB    r0,[r3,#IOMD_VERSION]
  ;      CMPS    r0,#1
  ;      BEQ     %FT20
        ]
        BL      ts_SIRQ_period
        BEQ     %20
        ADR     r4,%B3
        MOV     r8, r0, LSL #12
        BL      ts_SendText             ; Display Sirq fail msg
        FAULT   #R_SNDFAILBIT
20
        MOV     r1,#ts_VIDCPhys         ; Restore full-screen
        ADRL    r2,TestVIDCTAB          ; border colour.
        [ IO_Type = "IOMD"
        LDR     r0,=IOMD_MonitorType
        LDR     r0,[r0]
        ANDS    r0,r0,#IOMD_MonitorIDMask
        ADDEQ   r2,r2,#(TestVVIDCTAB-TestVIDCTAB)
        ]
30      LDR     r0, [r2],#4
        CMP     r0, #-1
        STRNE   r0, [r1]
        BNE     %BT30

	[ STB :LAND: DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	ts_ARMtype_test			; EQ : Don't show colours
	]
        LDR     r0,=C_ARMOK             ; set initial screen colour
        STR     r0, [r1]

        B       ts_ARMtype_test

;
; Read the ARM3 identification register.
; If memory tests failed, this won't be performed since the vector
; page must exist for error recovery on ARM2 systems.
;

        ROUT
1
        =       "ARM ID:",0
2
        =       "ARM ID",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
3
        =       &89,"skipped",0

        ALIGN

ts_ARMtype_test

        ADR     r4,%BT1
        BL      ts_SendText

        MOV_fiq r0,r12_fiq              ; skip this test if memory fault
        LDR     r1,=((R_LINFAILBIT :OR: R_MEMFAILBIT) :OR: (R_CAMFAILBIT :OR: R_PROFAILBIT))
        ANDS    r0,r0,r1
        BEQ     %05
        ADR     r4,%BT3
        BL      ts_MoreText
        B       %08                     ; and quit

05
        BL      ts_ARM_type
        MOVS    r8, r0                  ; ready to display ID code
        ADR     r4,%BT2

        BEQ     %FT07                   ; ARM 2 : skip cache test
        FAULT   #R_ARM3                 ; not really a fault, just status
07
        BL      ts_SendText

08
        B       ts_Report



;
; Report the test results to the user
;
; If this was a forced test (test adapter fitted) then pause even when
; test passed : otherwise, pause only on error.
;

ts_passmsg
        =       "PASS  :",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0
ts_failmsg
        =       "FAIL  :",&88,&ff,&ff,&ff,&ff,&ff,&ff,&ff,&ff,0

ts_R00  &       00


 [ STB :LAND: POSTFlashesFrontPanelLEDs
        ; Define Long, Equal and short flash delays
ts_Long_Flash      	*	&03		; Number of 1/4 Sec delays for a long flash
ts_Short_Flash	   	*	&01		; Number of 1/4 Sec delays for a short flash
ts_Equal_Flash     	*	&02		; Number of 1/4 Sec delays for a equal flash
ts_Fail_Flash_Delay	*	&14		; Number of Flash Cycles for a Fail, with adaptor
ts_Pass_Flash_Delay	*	&0A		; Number of Flash Cycles for a Pass, with adaptor

IOMD_LED_GREENLED       *       IOMD_C_FrontPanelRightLED               ; The right LED should be the GREEN LED
IOMD_LED_REDLED         *       IOMD_C_FrontPanelLeftLED                ; The left  LED should be the RED   LED
IOMD_LED_BOTH           *       IOMD_LED_REDLED :OR: IOMD_LED_GREENLED  ;

 ] ; Endif (POSTFlashesFrontPanelLEDs)

ts_Report       ROUT
        MOV_fiq r7,r12_fiq              ; check for fault bits set
        LDR     r0,=R_STATUS
        BICS    r0,r7,r0

        ADREQ   r4, ts_passmsg          ; tests passed
        LDREQ   r9,=C_PASSED

        ADRNE   r4, ts_failmsg          ; tests failed
        LDRNE   r9,=C_FAULT

        LDR     r0,=ts_VIDCPhys         ; write the border colour
        STR     r9,[r0]

        MOV     r8,r7
        BL      ts_SendText             ; write the message and fault code

        ; if the test adapter is present, leave green screen awhile
        ; otherwise, wait only if there's a fault.

        LDR     r3,=ts_recover_time
00      ADDS    r3,r3,r3                ; 16-loop delay
        BCC     %B00                    ; - let the adapter recover
                                        ; from previous bus activity
        ADR     r2,ts_R00
        ORR     r2,r2,#ts_Alias_bits
        LDR     r3,[r2]
        MOV     r2,#-1
        ADDS    r3,r3,r2
        BCS     ts_Report_wait

	; Here is r3 = 0, which ment a DUMP adaptor was present.
	;
	; Continue to the OS
	;
        MOV_fiq r0,r12_fiq
        LDR     r2,=R_STATUS
        BICS    r0,r0,r2
        BEQ     ts_Hardstart

ts_Report_wait        ROUT
	;
	; Here if a Display or other type of adaptor found.
	;
 [ STB :LAND: POSTFlashesFrontPanelLEDs
	;
	; Check to see if we are a PASS or FAIL
	;
        MOV_fiq r7,r12_fiq              	; check for fault bits set
        LDR     r0,=R_STATUS
        BICS    r0,r7,r0

	BEQ	ts_flash_leds_pass		; flash the leds to show a pass
						; flash the leds to show a failure
						; Fall through !

ts_flash_leds_fail
	;
	; Get here if the POST fails !
	;
        ; Set it so the RED LED is on.
        BL      ts_led_redon_only               ; Ensure that the RED LED only is on,
	; Check for display adpator, if fitted, flash LED's for 20 times
	; else flash LEDs forever.
	;
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
        BNE	%FT19	                   	; Adaptor    : Goto 20 Flash loops Code
 	           				; No Adaptor : Goto Infinite flash loop Code
						; Fall through !
14
	; Infinite Flash loop
	; Register usage ....
	; 	r0, used by toggle leds & delay routines
	;	r1, used by toggle leds routine
	;
15	BL	ts_led_fail			; Call code to flash the leds
	B	%BT15				; Repeat forever.

19
	; Loop for specified time
	; Register usage ....
	; 	r0, used by toggle leds & delay routines
	;	r1, used by toggle leds routine
	;
	;	r3, Loop counter
	;       r4, Pass delay time to delay code.
	;
	MOV	r3,#ts_Fail_Flash_Delay		; Set the loop counter.
20	BL	ts_led_fail			; Call code to flash the leds
	SUBS	r3,r3,#1			; Decrment loop counter
	BNE	%BT20				; Repeat until r3 = 0
	BEQ	%FT50				; r3=0, were all done
						; Goto start the OS

ts_flash_leds_pass
	; Here if POST passed.
	; If adaptor fitted, flash the LEDs for a 10 secs
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
	BEQ	%FT55				; No Adaptor : Goto start the OS
                                       		; Adaptor    : Goto 10 Flash loops Code
						; Fall through !

        ; Set it so the RED LED is on.
        BL      ts_led_redon_only               ; Ensure that the RED LED only is on,
	; Loop for specified time
	; Register usage ....
	; 	r0, used by toggle leds & delay routines
	;	r1, used by toggle leds routine
	;
	;	r3, Loop counter
	;       r4, Pass delay time to delay code.
	;
	MOV	r3,#ts_Pass_Flash_Delay		; Set the loop counter.
30	BL	ts_led_pass			; Call code to flash the leds
	SUBS	r3,r3,#1			; Decrment loop counter
	BNE	%BT30				; Repeat until r3 = 0
	BEQ	%FT50				; r3=0, were all done
						; Goto start the OS

ts_led_fail
	; Code to flash the LED's through one flash cycle (on-off)
	; This will take 1 Second to complete.
	;
	;|------>|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|
	;|--Red--|---Green---|----Red----|----Red----|----Red----|\
	;         \_______________________________________________/
	;
	;									Red	Green
	MOV	r13,r14				; make a note of where we	On	Off
						; came from.
	BL	tl_Toggle_LEDs			; Toggle the LEDs		Off	On
	MOV	r4,#ts_Short_Flash		; Load r4 with Short flash	Off	On
	BL	ld_LED_Delay			; call delay routine		Off	On
	BL	tl_Toggle_LEDs			; Toggle the LEDs		On	Off
	MOV	r4,#ts_Long_Flash		; load r4 with long flash	On	Off
	BL	ld_LED_Delay			; call delay routine		On	Off

	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.

ts_led_pass
	; Code to flash the LED's through one flash cycle (on-off)
	; This will take 1 Second to complete.
	;
	;|------>|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|
	;|--Red--|---Green---|---Green---|---Green---|----RED----|\
	;         \_______________________________________________/
	;
	;									Red	Green
	MOV	r13,r14				; make a note of where we	On	Off
						; came from.
	BL	tl_Toggle_LEDs			; Toggle the LEDs		Off	On
	MOV	r4,#ts_Long_Flash		; Load r4 with long flash	Off	On
	BL	ld_LED_Delay			; call delay routine		Off	On
	BL	tl_Toggle_LEDs			; Toggle the LEDs		On	Off
	MOV	r4,#ts_Short_Flash		; load r4 with short flash	On	Off
	BL	ld_LED_Delay			; call delay routine		On	Off

	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.

ts_led_redon_only
	LDR	r1, =IOMD_IOLINES               ; r1 = addr of IOMD_IOLINES
        LDRB    r0,[r1]                         ; load r0 with the byte pointed to by r1
;        DREG    r0,"contents of loc->r1"
        BIC     r0,r0,#IOMD_LED_GREENLED        ; Clear GREEN LED bit
        ORR     r0,r0,#IOMD_LED_REDLED          ; Set   RED LED bit
        ORR     r0,r0,#IOMD_C_ReadMask          ; OR with the default I/O settings
        STRB    r0,[r1]                         ; store a byte of r0 in to loc pointed to by r1
        MOV     pc, r14                         ; Return to caller

ts_led_greenon_only
	LDR	r1, =IOMD_IOLINES               ; r1 = addr of IOMD_IOLINES
        LDRB    r0,[r1]                         ; load r0 with the byte pointed to by r1
;        DREG    r0,"contents of loc->r1"
        BIC     r0,r0,#IOMD_LED_REDLED          ; clear RED LED bit
        ORR     r0,r0,#IOMD_LED_GREENLED        ; Set   GREEN LED bit
        ORR     r0,r0,#IOMD_C_ReadMask          ; OR with the default I/O settings
        STRB    r0,[r1]                         ; store a byte of r0 in to loc pointed to by r1
        MOV     pc, r14                         ; Return to caller

ts_led_bothon
	LDR	r1, =IOMD_IOLINES               ; r1 = addr of IOMD_IOLINES
        LDRB    r0,[r1]                         ; load r0 with the byte pointed to by r1
;        DREG    r0,"contents of loc->r1"
        ORR     r0,r0,#IOMD_LED_BOTH            ; Set Both Green & RED LED bits
        ORR     r0,r0,#IOMD_C_ReadMask          ; OR with the default I/O settings
        STRB    r0,[r1]                         ; store a byte of r0 in to loc pointed to by r1
        MOV     pc, r14                         ; Return to caller

ts_led_bothoff
	LDR	r1, =IOMD_IOLINES               ; r1 = addr of IOMD_IOLINES
        LDRB    r0,[r1]                         ; load r0 with the byte pointed to by r1
;        DREG    r0,"contents of loc->r1"
        BIC     r0,r0,#IOMD_LED_BOTH            ; Clear Both Green & RED LED bits
        ORR     r0,r0,#IOMD_C_ReadMask          ; OR with the default I/O settings
        STRB    r0,[r1]                         ; store a byte of r0 in to loc pointed to by r1
        MOV     pc, r14                         ; Return to caller



50
        ; come here if we've finished showing pass/fail by flashing the LEDs
        ; thus a test link or display aaptor was fitted
        ; so turn on the LED's
        BL      ts_led_bothon

55
        ; come here because we passed, but no display adaptor ot test link, thus LEDs weren't flashed
	; so ........
	; Continue on our way
	;
 | ; else
	;
	; :LNOT: POSTFlashesFrontPanelLEDs
        ; Thus we use the old way of flashing the LED etc ....
	;
	; Indicate fault found : Set the border to fault colour and flash
	; the disk LED, using the fault bitmap in r12_fiq to modulate the flashing.
	;

ts_oldLED_on       *       &be0000         ; assert SEL0 and INUSE
ts_oldLED_off      *       &ff0000         ; on machines with 1772 controller
ts_oldLEDaddr      *       (ts_S5_base :OR: &40)

ts_710LED_on       *       &100000         ; assert SEL0 and MotorEN0
ts_710LED_off      *       &110000         ; on machines with 82C710 controller
ts_710LEDaddr      *       (ts_PCaddress :OR: (&3f2 :SHL: 2))

ts_665LED_on       *       &10          ; assert SEL0 and MotorEN0
ts_665LED_off      *       &11          ; on machines with 37665 controller
                                        ; and Medusa low-byte I/O world
ts_665LEDaddr      *       (ts_PCaddress :OR: (&3f2 :SHL: 2))

01
        MOV_fiq r6,r12_fiq
        LDR     r2,=&11111111
        [ :LNOT: STB
        LDR     r7,=(35000 * 8)         ; 1/4 second pause loop count
        ]

   [ IO_Type = "IOMD"
        LDRNE   r1,=ts_665LEDaddr       ; set up for Medusa disc address
        MOVNE   r8,#ts_665LED_on
        MOVNE   r9,#ts_665LED_off
   |
        TST     r6, #R_IOEB             ; determine original / 710 disc controller
        LDREQ   r1,=ts_oldLEDaddr       ; set up for Archimedes disc address
        MOVEQ   r8,#ts_oldLED_on
        MOVEQ   r9,#ts_oldLED_off
        LDRNE   r1,=ts_710LEDaddr       ; set up for Brisbane disc address
        MOVNE   r8,#ts_710LED_on
        MOVNE   r9,#ts_710LED_off
   ]

02
	[ STB
	BL	ld_LED_Delay			; call delay routine

        MOV     r0,r8                   ; turn the LED on
        STR     r0,[r1]

	BL	ld_LED_Delay			; call delay routine

        ADDS    r6,r6,r6                ; if a '1' is to be written,
        BCC     %06
	BL	ld_LED_Delay			; call delay routine }
	BL	ld_LED_Delay			; call delay routine } Half A Second
	|
        MOV     r0,r7
03      SUBS    r0,r0,#1                ; pause for a 1/4 second
        BNE     %03

        MOV     r0,r8                   ; turn the LED on
        STR     r0,[r1]

        MOV     r0,r7
04      SUBS    r0,r0,#1                ; pause for a 1/4 second
        BNE     %04
        ADDS    r6,r6,r6                ; if a '1' is to be written,
        BCC     %06
        MOV     r0,r7,LSL #1            ; then pause another 1/2 second
05      SUBS    r0,r0,#1
        BNE     %05
	]
06
        MOV     r0, r9                  ; turn the LED off
        STR     r0,[r1]

;
; Count down 32 bits. Every 4 bits, insert an extra pause to simplify
; reading the flashes.
;
        ADDS    r2,r2,r2
        BCC     %08
 [ STB
	BL	ld_LED_Delay			; call delay routine }
	BL	ld_LED_Delay			; call delay routine } One Seconds Worth
	BL	ld_LED_Delay			; call delay routine }
	BL	ld_LED_Delay			; call delay routine }
 |
        MOV     r0,r7,LSL #2            ; then pause another second
05      SUBS    r0,r0,#1
        BNE     %05
 ]
08
        ANDS    r2,r2,r2                ; all the bits displayed now ?
        BNE     %02
        MOV_fiq r0,r12_fiq              ; restore the faultcode bits
 ] ; Endif (POSTFlashesFrontPanelLEDs)
;
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
; Uncomment the following line if the POST code is to loop when the POST
; display adaptor (post box) is fitted.
;
;        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED) ; If the display adapter & test link are present,
;
; Comment this line out if POST Code is to loop when the POST display
; adaptor (post box) is fitted.
;
        ANDS    r0,r0,# R_TESTED	; If the test link is present,
        BNE     Reset                   ; repeat the test forever

        B       CONT                    ; otherwise, run RISC OS

ts_Hardstart
        MOVS    r0,#R_HARD              ; and report a hard start
        B       CONT                    ; to RISC OS

;
; Tests skipped : fall into RISC-OS
;

ts_Self_test_end

	[ STB :LAND: DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	ts_Softstart			; EQ : Don't show colours
	]
        LDR     r1,=C_DEFAULT
        LDR     r0,=ts_VIDCPhys         ; write the border colour
        STR     r1,[r0]

ts_Softstart
        MOVS    r0,#R_SOFT              ; soft reset indicator
        B       CONT

;
;
;
        ROUT
;
; This table consists of a series of address/data pairs for IO
; initialization.
; Note that these addresses are likely to be in the IO world,
; and hence the data written is that from the MOST significant
; 16 bits of the data bus.
; An 'address' of -1 terminates the table.
;

ts_IOinitab
        [ IO_Type = "IOMD"
        |
        & ts_S5_base :OR: &10,  &000000         ; Printer port data
        & ts_S5_base :OR: &18,  &000000         ; FDC control & printer strobes
        & ts_S5_base :OR: &40,  &ff0000         ; FDD select lines
        & ts_S5_base :OR: &48,  &000000         ; VIDC clock control
        ]
        & (-1)


;
;
;---------------------------------------------------------------------------

        LTORG


; Include test modules executed by call, rather than inline

        GET     TestSrc.Mem2
        GET     TestSrc.Mem3
        GET     TestSrc.Mem4
        GET     TestSrc.Mem5
        GET     TestSrc.Vidc
        GET     TestSrc.Ioc
        GET     TestSrc.Cmos
        GET     TestSrc.Arm3

        ; amg: 7/12/96 Renaissance. Once again I wish AASM could understand conditionals
        ;              around GETs

        GBLS    get_toggleled
        GBLS    get_leddelay
        GBLS    get_showiomdrs
        [ STB
get_toggleled   SETS "GET TestSrc.ToggleLED"
get_leddelay    SETS "GET TestSrc.LEDDelay"
get_showiomdrs  SETS "GET TestSrc.ShowIOMDRs"
        |
get_toggleled   SETS ""
get_leddelay    SETS ""
get_showiomdrs  SETS ""
	]
	$get_toggleled
	$get_leddelay
	$get_showiomdrs

	ALIGN	64		; JRH: Kernel seems happier if we do this!

        END
@


4.14
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@@


4.13
log
@OS_CallASWI and OS_CallASWIR12 sped up by 4-6 cycles (depending on which ARM).
Some POST changes which got lost recommitted.

Version 5.24. Not tagged
@
text
@d347 1
a347 1
        msr    ,CPSR_c,#I32_bit :OR: F32_bit :OR: $mode_bits
d1874 1
a1874 1
	;|--Red--|---Green---|----Red----|----Red----|----Red----|\
d1895 1
a1895 1
	;|--Red--|---Green---|---Green---|---Green---|----RED----|\
@


4.13.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d347 1
a347 1
        MSR     CPSR_c,#I32_bit :OR: F32_bit :OR: $mode_bits
d1874 1
a1874 1
	;|--Red--|---Green---|----Red----|----Red----|----Red----|\
d1895 1
a1895 1
	;|--Red--|---Green---|---Green---|---Green---|----RED----|\
@


4.12
log
@* POST now correctly run-time checks for the emulator (missed on last
  check-in).
* IOMD register listing removed from POST (for Tom).

This version seems to be pretty stable in a 26-bit desktop build. Apart from
silly modules relying on the manner in which SWIs corrupt R14_svc :(

Version 5.24. Tagged as 'Kernel-5_24'
@
text
@d95 3
d110 2
a111 2
TS_RELEASE      *       22
TS_CHANGES      *       4
d121 1
a121 1
ShowIOMDRegs	SETL    (IO_Type = "IOMD") :LAND: {TRUE} :LAND: STB	; show IOMD regs
@


4.11
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a94 3
; 04 Apr 00     KJB     2.30    Converted to run in 32-bit mode always.
;                               ShowIOMDRegs set to FALSE (request from
;                               Tom Clay)
d107 2
a108 2
TS_RELEASE      *       23
TS_CHANGES      *       0
d118 1
a118 1
ShowIOMDRegs	SETL    (IO_Type = "IOMD") :LAND: {FALSE} :LAND: STB	; show IOMD regs
d490 4
@


4.10
log
@Corrected typo in POST modifications.

Version 5.13. Tagged as 'Kernel-5_13'
@
text
@d95 3
d110 2
a111 2
TS_RELEASE      *       22
TS_CHANGES      *       4
d121 1
a121 1
ShowIOMDRegs	SETL    (IO_Type = "IOMD") :LAND: {TRUE} :LAND: STB	; show IOMD regs
a292 7
;
; vectors ORd with these flags to assure proper mode when
; executed by host thro' vector table.
;

ts_runflags     *       (I_bit :OR: F_bit :OR: SVC_mode)

d294 8
a301 8
        &       ts_RomPatt              :OR: ts_runflags
        &       ts_User_startup         :OR: ts_runflags
        &       ts_Self_test_startup    :OR: ts_runflags
        &       ts_Dealer_startup       :OR: ts_runflags
        &       ts_Forced_startup       :OR: ts_runflags
        &       ts_GetCommand           :OR: ts_runflags
        &       ts_Softstart            :OR: ts_runflags
        &       ts_Hardstart            :OR: ts_runflags
d347 1
a347 2
        TEQP    psr,#($mode_bits :OR: I_bit :OR: F_bit)
        NOP
d352 1
a352 1
        MODE    FIQ_mode
d354 1
a354 1
        MODE    SVC_mode
d359 1
a359 15
        MODE    FIQ_mode
        ORR     r12_fiq,r12_fiq,$code
        MODE    SVC_mode
        MEND

        MACRO
        M32_fiq $dest,$src,$tmp1,$tmp2
        SetMode FIQ32_mode,$tmp1,$tmp2
        MOV     $dest,$src
        msr     AL,CPSR_all,$tmp2
        MEND

        MACRO
        FAULT32 $code,$tmp
        SetMode FIQ32_mode,$tmp
d361 1
a361 1
        SetMode SVC32_mode,$tmp
a363 13
 [ StrongARM_POST
;  ensure 26-bit mode for StrongARM or ARM 8 (since there is no 26 bit configuration)
        MACRO
        Ensure26bit_ARM8A $tmp
        ARM_read_ID $tmp
        AND     $tmp, $tmp, #&F000
        CMP     $tmp, #&A000
        CMPNE   $tmp, #&8000
        mrs     EQ, $tmp, CPSR_all
        BICEQ   $tmp, $tmp, #&10
        msr     EQ, CPSR_all, $tmp
        MEND
  ]
a563 5
  [ StrongARM_POST
    ; make sure we are in 26-bit mode (ARM 6/7 reset in 26-bit config)
    ; note that MOV_fiq macro assumes 26-bit, so must sort this now
    Ensure26bit_ARM8A r0
  ]
a581 5
  [ StrongARM_POST
    ; make sure we are in 26-bit mode (ARM 6/7 reset in 26-bit config)
    ; note that MOV_fiq macro assumes 26-bit, so must sort this now
    Ensure26bit_ARM8A r0
  ]
a588 5
  [ StrongARM_POST
    ; make sure we are in 26-bit mode (ARM 6/7 reset in 26-bit config)
    ; note that MOV_fiq macro assumes 26-bit, so must sort this now
    Ensure26bit_ARM8A r4
  ]
d902 1
a902 1
        MODE    FIQ_mode                        ; Save memory size and
d905 1
a905 1
        MODE    SVC_mode
d1361 1
a1361 1
	SetMode SVC32_mode,r0		; Must do this, as PhysSpace is outside 26 bit addressing
d1368 1
a1368 1
        M32_fiq r0,r12_fiq,r1,r2        ; get the test condition flags
d1386 1
a1386 1
        FAULT32 #R_MEMORY,r0            ; memory tests were attempted
d1447 1
a1447 1
        FAULT32 #R_MEMFAILBIT,r2        ; failed - report fault address
a1579 5

  [ StrongARM_POST
        Ensure26bit_ARM8A r7
        MOV     r7, #MMUC_D    ;avoid corrupting r7, just in case
  ]
@


4.9
log
@POST now uses option from Hdr:Machine.<Machine> to determine whether or not
to flash the front panel LEDs (Lazarus doesn't want this function).

Version 5.12. Tagged as 'Kernel-5_12'
@
text
@d1840 1
a1840 1
 [ STB :LAND: POSTFlashesFrontPanelLEDs)
@


4.8
log
@* Meaning of FEIOSpeedHalf was accidentally inverted.
* Wasn't allowing writes to most of EEPROM.
* Old prototype OS_SetTime SWI code removed.
* MPEGPoduleNTSCNotPALMask option support removed to simplify things a bit.
* Now can cope with a system with a PAL/NTSC link, but no monitor detect line.
* Default PAL & NTSC modes now always 12 & 46 respectively.
* Kernel now knows about monitor type 8 (NTSC) - modes 44-46 (640x200) are
  available.
* STB/NC CMOS test removed from POST pending further investigation.

Version 4.90. Tagged as 'Kernel-4_90'
@
text
@d1782 1
a1782 1
 [ STB :LAND: (((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0))))
d1794 1
a1794 1
 ] ; Endif ((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0)))
d1840 1
a1840 4
 [ STB :LAND: (((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0))))
	;
	; IOMD_C_FrontPanelLED <> 0 OR ((IOMD_C_FrontPanelRightLED <> 0) :AND: IOMD_C_FrontPanelLeftLED <> 0))
        ; Thus we have some FP Leds to play with !
d2012 1
a2012 1
	; ((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0)))
d2107 1
a2107 1
 ] ; Endif ((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0)))
@


4.7
log
@More adjustments to >8MB POST situation.
Added a missing ALIGN before ts_ROM_dvectors.

Version 4.78. Tagged as 'Kernel-4_78'
@
text
@d125 3
d1095 3
d1272 2
@


4.6
log
@Fixed typo (how did that happen?)
@
text
@d271 1
@


4.5
log
@ROM speed not taken from the Machine header file.  POST can now exist
in a softloaded OS, since it searches for a zero word in the ROM
instead of using one within the POST when trying to communicate with
the POST adapter (the zero word must be in ROM).  Fixed to build on
non-chrontel STB/NC products.  Lots of duplicate code merged in
MemSize.  MemSize copes better with the softload case, and is less
willing to use the region the OS occupies as video memory, or
page tables.  POST is now ON (memory tests disabled).
OS_ReadSysInfo 4 now uses the NVRAM module to access the ethernet
address in NVRAM/CMOS, so that the availability/location of the
MAC address can be changed.  CMOS location 0 is now unprotected on
STB/NC products to try to stop people poking the hardware directly.
Fixed a CMOS resetting problem on STBs where the value expected in a
location was different from the value written on a CMOS reset, so the
CMOS would be reset every time...

Version 4.69. Tagged as 'Kernel-4_69'
@
text
@d761 1
a761 1
        ORR     r0, r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_NSTicks_$ROMSpeed_NSTicks :OR: IOMD_ROMCR_BTicks_$ROMSpeedBurstTicks
d763 1
a763 1
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_NSTicks_$ROMSpeed_NSTicks :OR: IOMD_ROMCR_BTicks_$ROMSpeedBurstTicks
@


4.4
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d710 1
a710 1
        ORR     r0, r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_NSTicks_5 :OR: IOMD_ROMCR_BTicks_4
d712 1
a712 1
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_NSTicks_5 :OR: IOMD_ROMCR_BTicks_4
d761 1
a761 1
        ORR     r0, r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_NSTicks_5 :OR: IOMD_ROMCR_BTicks_4
d763 1
a763 1
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_NSTicks_5 :OR: IOMD_ROMCR_BTicks_4
d1360 5
a1364 1
        B       ts_VIDCtest	; skip memory test altogether; was	ADR     r4,%BT1
@


4.3
log
@RISC OS 3.71 kernel changes merged.
Not fully tested on all hardware permutations.
@
text
@d81 14
d108 1
a108 1
TS_CHANGES      *       0
d141 1
d156 1
d166 1
d685 1
a685 1
;	CPUCLK divide by 2
d689 3
d693 1
d709 5
a713 1
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_4
d718 13
a730 1
	MOVNE	r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_32bit + IOMD_ROMCR_NSTicks_7 + IOMD_ROMCR_BurstOff
d760 5
a764 1
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_4
d769 13
a781 1
	MOVNE	r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_32bit + IOMD_ROMCR_NSTicks_7 + IOMD_ROMCR_BurstOff
d793 1
a793 1
; Initialise VIDC : Sync mode 0, border covers screen
d798 22
a819 16
        MOV     r2,#IOMD_Base
        MOV     r0, #IOMD_VREFCR_REF_16 ; switch on DRAM refresh
        STR     r0, [r2, #IOMD_VREFCR]

        ; choose monitor settings from ID bit 0
        MOV     r1,#ts_VIDCPhys
        ADRL    r2,TestVIDCTAB
        LDR     r0,=IOMD_MonitorType
        LDR     r0,[r0]
        ANDS    r0,r0,#IOMD_MonitorIDMask
        ADDEQ   r2,r2,#(TestVVIDCTAB-TestVIDCTAB)

        |                               ; not IOMD
        MOV     r1,#ts_VIDCPhys
        ADRL    r2,TestVIDCTAB
        ]
d1082 2
a1088 8
1
        =       "SRAM  :",0
2
        =       "SRAM-F",0
3
        =       "SRAM-C",&8e,&ff,&ff,0
        ALIGN

d1091 1
a1091 1
        ADR     r4,%BT1
d1099 1
a1099 1
        BNE     %10
d1104 1
a1104 1
        BNE     %10
d1109 1
a1109 1
        BNE     %10
d1113 2
a1114 2
        ADR     r4,%BT3                 ; Report checksum failure
        BNE     %21                     ; failed .. report error
d1122 1
a1122 1
        BNE     %10
d1124 1
a1124 1
        BEQ     %25
d1127 1
a1127 1
        B       %25
d1134 13
a1146 10
        LDR     r0,=(ts_BBE2 + &4000)
        MOV     r1,#&C0                 ; Get first RAM area
        MOV     r2,#CMOSxseed
        BL      ts_CMOSread
        BNE     %20
        MOV     r2, r0
        LDR     r0,=(ts_BBE2 + &1000)   ; Accumulate the second RAM area
        MOV     r1,#&2F
        BL      ts_CMOSread
        BNE     %20
d1148 26
a1173 9
        LDR     r0,=(ts_BBE2 + &3F00)
        MOV     r1,#1
        BL      ts_CMOSread
        BNE     %20
        MOV     r8, r0, LSL #24
        ANDS    r0, r0, #&FF            ; A zero result ?
        MOV     r1, #R_CHKFAILBIT
        ADR     r4,%BT3                 ; Report checksum failure
        BNE     %21                     ; failed .. report error
d1181 1
a1181 1
        BNE     %20
d1183 1
a1183 1
        BEQ     %25
d1186 1
a1186 1
        B       %25
d1189 8
d1198 59
d1769 2
a1770 2
 [ STB :LAND: IOMD_C_FrontPanelLED = (1<<7)
	; Define Long, Equal and short flash delays
d1776 6
a1781 1
 ]
d1827 1
a1827 1
 [ STB :LAND: IOMD_C_FrontPanelLED = (1<<7)
d1829 2
a1830 1
	; IOMD_C_FrontPanelLED  = 1<<7, therefore an NC
d1846 2
d1886 1
a1886 1
	BEQ	%FT50				; No Adaptor : Goto start the OS
d1890 2
d1927 1
d1949 40
d1990 8
a1997 1
	;
d2000 1
a2000 1
 |
d2002 2
a2003 1
	; IOMD_C_FrontPanelLED  <> 1<<7, therefore not an NC
d2097 1
a2097 1
 ]
d2099 1
d2105 1
a2105 1
; Comment thi line out if POST Code is to loop when the POST display
d2130 1
a2130 1
        LDR     r1,=C_WARMSTART
@


4.2
log
@Kernel merged
@
text
@d110 1
a110 1
								
d362 14
d573 1
a573 1
; it's a power-on reset, so assume we can't be in 32-bit mode
d575 5
d598 5
d610 5
d658 8
a665 1
; Here bceause its an ARM7500 'FE' variant
d731 3
d792 19
a810 8
 [ StrongARM
   ;just too horrible to fix POST for StrongARM (Architecture 4) at the moment
   ARM_read_ID r0
   AND     r0,r0,#&F000
   CMP     r0,#&A000              ;if we are a StrongARM...
   LDREQ   r0,=C_WARMSTART        ;the colour that indicates no POST performed
   STREQ   r0,[r1]
   BEQ     ts_Hardstart           ;RISC OS - right now!
d1416 21
d1449 11
d1462 1
d1471 2
a1472 1
        MOV     r7, #MMUC_D             ; Now turn the MMU off
d1475 5
a1481 1

d1884 1
a1884 1
 [ STB       
d1889 1
a1889 1
 |	
d1893 1
a1893 1
 ] 	
d1979 1
a1979 1
        
d1996 1
a1996 1
	$get_leddelay 
@


4.1
log
@Initial revision
@
text
@d22 59
d83 1
a83 1

d93 2
a94 2
TS_RELEASE      *       20
TS_CHANGES      *       5
d98 14
a111 1
POSTenabled     SETL    {TRUE}          ; don't permit POST for ordinary startup 
d114 1
a114 1
ts_Rom_length   *       1 :SHL: ts_Rom_bits             ; Longest ROM 
d125 3
d143 7
a149 6
        [ VIDC_Type = "VIDC20" 
C_ARMOK         *       &40000000+&7000C0  ; testing ROM
C_RAMTEST       *       &40000000+&C07000  ; testing RAM
C_FAULT         *       &40000000+&0000F0  ; failed tests
C_PASSED        *       &40000000+&70C000  ; all passed
C_WARMSTART     *       &40000000+&707070  ; not tested
d151 1
a151 1

d155 1
a155 1

a156 2


d168 2
a169 1
R_IOEB          *       &40             ; PC-style IO controller
d176 1
a176 1
R_CAMFAILBIT    *       &400            ; CAM failed 
d195 1
a195 1
; low memory addresses. The Reset vector will be copied to low RAM 
d244 1
a244 1
ts_himsg 
d305 1
a305 1
        B       ts_SendLCDCmd 
d319 1
a319 1
; Note : the register order in ADDS ...pc.. is often critical. 
d334 1
a334 1
        MACRO   
d341 1
a341 1
        MACRO   
d379 1
a379 1
        GBLA    OldOpt                  ; don't list all the walking 
d418 1
a418 1
        WEND 
d426 1
a426 1
        WEND 
d453 1
a453 1
        &       ROM - pcfromstart   
d469 1
a469 1
        LDR     r1,doffset+4            ; walking 0 data pattern 
d492 1
a492 1
; External interface drivers - 
d494 1
a494 1
; and to receive byte- and word-sized objects   
d499 3
a501 3
; 
        B       ts_GetCommand

d591 1
a591 1
02      
d613 49
a661 7
        MOV     r2, #IOMD_Base

        LDRB    r0, [r2, #IOMD_ID0]
        CMP     r0, #&98
        LDRB    r0, [r2, #IOMD_ID1]
        CMPEQ   r0, #&5B
        BNE     %FT10
d663 7
a669 2
;
; PSwindell wants all prescalers set to divide by 1
d677 18
a694 19
;
; We assume that the extension ROMs are the same access time and width as the main OS ROMS.
;
        LDRB    r0, [r2, #IOMD_ROMCR0]
        AND     r0, r0, #&40            ; clear all but 16-bit mode bit
 [ NormalSpeedROMS
   ;Normal code
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_156 + IOMD_ROMCR_Burst93
                                                                ; initialise ROM speed to 156.25nS, 93.75nS burst
        ; the fast EPROMS used for Kryten testing should be able to cope even though they aren't
        ; burst devices
 |
   ;Slow ROM access for PSwindells test EPROMS. Paul requested 156nS (or slower), burst off.
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_187 + IOMD_ROMCR_BurstOff

        ! 0, "*** WARNING *** Slow ROM version ment for PSwindell"
 ]
        STRB    r0, [r2, #IOMD_ROMCR0]
        STRB    r0, [r2, #IOMD_ROMCR1]         ; and do the same for extension ROMs (just in case)
d728 37
a764 2
        LDR     r0,=C_ARMOK     ; set initial screen colour
        STR     r0, [r1]
a767 1

d802 1
a802 1
                                        ; the ARM600 MMU as well. 
d813 1
a813 1
2 
d826 2
a827 2
; MemSize returns with  r0 = page size   (now in bytes, *NOT* in MEMC control patterns), 
;                       r1 = memory size (in bytes)  
d836 1
a836 1
        MODE    FIQ_mode                        ; Save memory size and 
d862 1
a862 1
; Test IOC. 
d865 1
a865 1
; 
d912 5
a916 1
        BL      ts_IOCstat
d921 1
a921 1
        B       %FT11   
d925 3
d930 5
a934 1
        [ IO_Type = "IOMD"
d936 2
a937 1
        |
d939 1
a939 1
        ]
d946 1
a946 1
; 
d986 1
d991 38
d1031 1
a1031 1
        LDR     r0,=(ts_BBRAM + &4000)
d1037 1
a1037 1
        LDR     r0,=(ts_BBRAM + &1000)  ; Accumulate the second RAM area
d1042 1
a1042 1
        LDR     r0,=(ts_BBRAM + &3F00)
d1053 2
a1054 1
        LDR     r0,=(ts_BBRAM + &FC00)  ; Read Misc1CMOS byte
d1060 3
a1062 2
        BEQ     %25     
        FAULT   #R_MEMSKIP              ; If set, skip the memory test  
d1064 1
d1068 1
a1068 1
        ADR     r4,%BT2                 ; Report fault accessing IIC 
d1100 2
a1101 2
; configuration. The memory speed can then be set up correctly for 
; fastest possible working, and the memory array tested in the 
d1108 1
a1108 1
; where ssss is the processor speed in hex kHz, 
d1110 2
a1111 2
;       r    is the MEMC rom speed switch setting. 
; 
d1137 1
a1137 1
        TST     r7, #1 :SHL: 16                 ; test bit 16 of r7 : 
a1144 1

d1148 1
a1148 1
; 
d1170 1
a1170 1
        ADR     r4,%BT1
d1175 1
a1175 1
; if (!R_LINFAILBIT) 
d1185 1
a1185 1
        BL      ts_MoreText 
d1188 7
d1198 1
a1198 1

d1202 5
a1206 4
        RSB     r4,r4,#PhysROM          ; and r4 the offset from physical to ORGed ROM addresses
        ADD     r4,r4,#PhysSpace
        SetMode SVC32_mode,r0           ; Must do this, as PhysSpace is outside 26 bit addressing
        ADD     pc,pc,r4                ; Jump into the ROM at its image in PhysSpace
d1245 1
a1245 1
; 
d1253 1
a1253 1
        
d1306 2
a1307 2
; Then try out the protection bits in each CAM entry and various 
; processor modes. 
d1329 1
a1329 1
        BL      ts_MoreText 
d1346 1
a1346 1
        BL      ts_MoreText 
d1410 1
a1410 1
        ALIGN 
d1426 7
a1432 6

        LDRB    r0, [r3, #IOMD_ID0]
        CMP     r0, #&98
        LDRB    r0, [r3, #IOMD_ID1]
        CMPEQ   r0, #&5B                ; skip Virq test on Morris
        BEQ     %FT10
d1449 1
a1449 1
        ]       
d1469 8
d1483 1
a1483 1
; Read the ARM3 identification register. 
d1508 1
a1508 1
        BL      ts_MoreText 
d1529 1
a1529 1
; If this was a forced test (test adapter fitted) then pause even when 
d1540 10
d1559 1
a1559 1
        LDRNE   r9,=C_FAULT          
d1572 1
a1572 1
        BCC     %B00                    ; - let the adapter recover 
d1581 4
d1591 12
d1604 117
a1720 3
;
; Indicate fault found : Set the border to the fault colour and flash 
; the disk LED, using the fault bitmap in r12_fiq to modulate the flashing.
d1735 2
a1736 2

01      MOV_fiq r6,r12_fiq
d1738 1
d1740 1
d1742 1
a1742 1
        [ IO_Type = "IOMD"
d1746 1
a1746 1
        |
d1754 10
a1763 1
        ]
d1765 6
a1770 1
02      MOV     r0,r7
d1785 1
a1785 1

d1796 6
d1805 1
d1810 12
a1821 3

        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED) ; If test adapter present, 
        BNE     Reset                   ; repeat test forever
d1835 7
d1850 3
a1852 1

a1853 1

a1873 3



d1881 1
a1881 1
; Include test modules executed by call, rather than inline 
d1891 21
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a21 57
; 15-May-96	BAR	2.06	Update for ARM7500FE variant, new IOMD ID
;				Code. Used initially in the NC product;
;				needs different prescalers and ROM speed
;				settings, switched on IOMD ID code.
; 30-May-96	BAR	2.07	Add code to flash NC's led's. Ignore morse
;				code and just use the simplified flash
;				sequence.
; 14-Jun-96	BAR	2.08	Add get call for initmodule file.
; 17-Jun-96	BAR	2.09	Change speed settings for the second bank of
;				ROM space.
; 24-Jun-96	BAR	2.10	Updated second check on IOMD ID, instead of
;				checking for ARM7500 IOMD ID code to skip
;				the Virq test, now checks for the original
;				(RiscPC) IOMD ID code and skips Virq test if
;				not equal. Thus ARM7500 and ARM7500FE
;				devices don't execute the test.
;				Updated version number.
;				Added call to sir_IOMD_Regs -show iomd registers
; 08-Jul-96     BAR     2.11    Ensure r0 is cleared before checking IOMD vsn no.
;                               Change ROM Burst speed from93.75nS to 125nS.
; 09-Jul-96                     Make IOMD ID code more efficent. Change
;                               variables used for ROMCR Values and remove
;                               'NormalSpeed' ROMs compiler switching code -
;                               no longer supporting PSwindell.
;                               Change non-7500FE ROM Burst speed from 3 ticks
;				to 4 ticks
; 25-Jul-96	BAR	2.12	Add code to handle EEPROM as well as CMOS
;				RAM. Code supplied by J.Harris.
; 29-Jul-96     BAR     2.13    Update LED stuff to wait properly.
; 29-Jul-96	BAR	2.14	Update exit codes IOMD et all.
;				More work on the LED code.
; 30-Jul-96	BAR	2.15	Humm, get the LED's to work !
; 16-Aug-96	JRH	2.16	Add check for OS image in 2nd ROM bank.
;				Don't program the 2nd ROM bank speed (ROMCR1),
;				unless CanLiveInROMCard is True, in which case
;				check whether we're running from the 2nd bank.
;				Made display of IOMD regs conditional on new
;				ShowIOMDRegs flag, which is set to TRUE
; 05-Sep-96	BAR	2.17	Updated to NOT show the progress colours on
;				the screen unless a POST box is added when
;				they will be shown. This is in accordance
;				with fault report  ANC-00159. The final red
;				fail screen will be maintained as this
;				enfoces the fact the the POSt has failed and
;				that the ser needs to attend to the unit.
;				The compile switch DontShowProgressColours
;				can be set to FALSE, then the progress
;				colours will always be shown.
; 07-Oct-96	JRH	2.18	Changed ExtIO to fix support for speaking to
;				the test box when running from the 2nd ROM bank,
;				conditioned on CanLiveOnROMCard.
; 22-Oct-96	JRH	2.19	Added an Align64 at the end of the file because
;				OS_Find was sometimes failing. Don't know why.
;				Fixed bug introduced in 2.18 which turned burst
;				off on ROMCR0.
; 08 Nov 96	BAR	2.20	Add kluge to skip ram (long) test
;				altogether, 'cos it appears to be crashing.
d24 1
a24 1
;
d34 2
a35 2
TS_RELEASE      *       22
TS_CHANGES      *       0
d39 1
a39 13
POSTenabled     SETL    {TRUE}          ; don't permit POST for ordinary startup

                GBLL    AlwaysShortPOST
AlwaysShortPOST SETL    {TRUE}          ; always do a short POST

                GBLL    ShowIOMDRegs
ShowIOMDRegs	SETL    (IO_Type = "IOMD") :LAND: {TRUE}	; show IOMD regs

                GBLL   DontShowProgressColours
DontShowProgressColours	SETL	{TRUE}				; Do not show the progress colour screens.
								; Progress Colours will always be shown when using POST Box.
								; Set to true for NC - Fault Report ANC-00159.

d42 1
a42 1
ts_Rom_length   *       1 :SHL: ts_Rom_bits             ; Longest ROM
a52 1
ts_BBE2         *       &A8                             ; IIC address of E2ROM chip
d68 6
a73 7
        [ VIDC_Type = "VIDC20"
C_2NDBANK	*	&40000000+&C00070  ; jumping to image in 2nd ROM bank (Dark blue)
C_ARMOK         *       &40000000+&7000C0  ; testing ROM (Magenta)
C_RAMTEST       *       &40000000+&C07000  ; testing RAM (Blue)
C_FAULT         *       &40000000+&0000F0  ; failed tests(Red)
C_PASSED        *       &40000000+&70C000  ; all passed  (Green)
C_WARMSTART     *       &40000000+&707070  ; not tested  (Mid grey)
d75 1
a75 1
;
d79 1
a79 1
;
d81 2
d94 1
a94 2
R_IOEB          *       &40             ; PC-style IO controller (A5000)
R_IOMD          *       &40             ; PC-style IO controller (RiscPC, ARM7500)
d101 1
a101 1
R_CAMFAILBIT    *       &400            ; CAM failed
d120 1
a120 1
; low memory addresses. The Reset vector will be copied to low RAM
d169 1
a169 1
ts_himsg
d230 1
a230 1
        B       ts_SendLCDCmd
d244 1
a244 1
; Note : the register order in ADDS ...pc.. is often critical.
d259 1
a259 1
        MACRO
d266 1
a266 1
        MACRO
d304 1
a304 1
        GBLA    OldOpt                  ; don't list all the walking
d343 1
a343 1
        WEND
d351 1
a351 1
        WEND
d378 1
a378 1
        &       ROM - pcfromstart
d394 1
a394 1
        LDR     r1,doffset+4            ; walking 0 data pattern
d417 1
a417 1
; External interface drivers -
d419 1
a419 1
; and to receive byte- and word-sized objects
d424 3
a426 3
;
        B       ts_GetCommand	; (This instruction redundant 'cos ts_GetCommand
				;  is the first thing defined in TestSrc.ExtIO)
d516 1
a516 1
02
d538 8
a545 48
; check for te veriosn of IOMD, only need to determin between variants in
; the ARM7500 and ARM7500FE - condional code assembly excludes non-ARM7500
; devices.

        MOV     r2, #IOMD_Base		; r2 points to the IOMD base address defiend in HDR:IO.IOMDL
        LDRB    r1,[r2,#IOMD_ID1]	; load r1 with IOMD ID high byte
        LDRB    r0,[r2,#IOMD_ID0]	; load r0 with IOMD ID low byte
        ORR     r0,r0,r1,LSL#8		; Or r0 and r1, shifted left 8, put in r0
        LDR     r1,=ts_IOMD_ID2		; get Ref IOMD ID code #2
        CMPS    r0,r1                   ; check for IOMD ID Code #2
	BEQ	%FT05			; If equal, got to 05

        LDRNE   r1,=ts_IOMD_ID3		; If not ID1, get ID code #3
        CMPNES  r0,r1			; If not ID1, check for IOMD ID Code #3
        BNE     %FT10			; Not equal; not an ARM7500 or an ARM7500FE - skip

; Here bceause its an ARM7500 'FE' variant
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;	CPUCLK divide by 2
;	MEMCLK divide by 1
;	IOCLK  divide by 1
;
	MOV     r0, #IOMD_CLKCTL_CpuclkHalf + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
        STRB    r0, [r2, #IOMD_CLKCTL] ; initialise all the prescalers.
;
; Set ROM speed, take care to preserve 16-bit mode bit...
;
; According to BSiddle on the 15-May-96, Omega will use burst mode roms: use 93nS burst, 156nS initial.
; According to TDbson on the 09-Jul-96, Omega will handle ROMS up to 120nS and 70nS.
; Thus the ROM speed should be initilised to :-
; Half Speed or H bit, clear, which is ON ! : Half the delays, thus DOUBLE all clock ticks.
; Non-Sequental delay : 10 Ticks : Half speed on, so select 5 ticks (5*2)
; Burst delay         :  8 Ticks : Half speed on, so select 4 ticks (4*2)
; Remember the Memory clock on Omega is faster than on previous porducts.
; The fast flash devices used for Omega testing should be able to cope even
; though they aren't burst devices.
        LDRB    r0, [r2, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_4
        STRB    r0, [r2, #IOMD_ROMCR0]          ; Prog. the reg.s
  [ CanLiveOnROMCard
	TST	pc, #ts_RC_2ndbank		; Not running out of 2nd ROM bank?
        ; Don't know what's in the 2nd bank -> program it to a slow default
	MOVNE	r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_32bit + IOMD_ROMCR_NSTicks_7 + IOMD_ROMCR_BurstOff
        STRB    r0, [r2, #IOMD_ROMCR1]		; Otherwise program it the same
  ]
	B	%FT10
d547 1
a547 8

05
; Here because its an ARM7500 variant - NON 'FE' device.
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;	CPUCLK divide by 1
;	MEMCLK divide by 1
;	IOCLK  divide by 1
d555 19
a573 18
; According to BSiddle on 09-Jul-96 - Omenga will need to set the burst speed to 4 ticks from 3 ticks.
; Thus the ROM speed should be initilised to :-
; Half Speed or H bit, Set, which is OFF ! : Don't half the delays.
; Non-Sequental delay :  5 Ticks : Half speed off, so select 5 ticks
; Burst delay         :  4 Ticks : Half speed off, so select 4 ticks
; The fast EPROMS used for Kryten testing should be able to cope even though
; they aren't burst devices

        LDRB    r0, [r2, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_4
        STRB    r0, [r2, #IOMD_ROMCR0]          ; Prog. the reg.s
  [ CanLiveOnROMCard
	TST	pc, #ts_RC_2ndbank		; Not running out of 2nd ROM bank?
        ; Don't know what's in the 2nd bank -> program it to a slow default
	MOVNE	r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_32bit + IOMD_ROMCR_NSTicks_7 + IOMD_ROMCR_BurstOff
        STRB    r0, [r2, #IOMD_ROMCR1]		; Otherwise program it the same
  ]
d607 2
a608 10
;
; Test for presence of OS image in 2nd ROM bank and jump to it
;
	GBLS	DoROMCardThings
  [ ROMCardSupport :LOR: CanLiveOnROMCard
DoROMCardThings	SETS	"GET	TestSrc.ROMCard"
  |
DoROMCardThings	SETS	""
  ]
	$DoROMCardThings
d610 1
a611 16
;
; Set purple screen
;

	[ DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	ts_RomTest			; EQ : Don't show colours
	]
	MOV	r1, #ts_VIDCPhys
        LDR	r0, =C_ARMOK     		; set initial screen colour
        STR	r0, [r1]

        B       ts_RomTest
d647 1
a647 1
                                        ; the ARM600 MMU as well.
d658 1
a658 1
2
d671 2
a672 2
; MemSize returns with  r0 = page size   (now in bytes, *NOT* in MEMC control patterns),
;                       r1 = memory size (in bytes)
d681 1
a681 1
        MODE    FIQ_mode                        ; Save memory size and
d707 1
a707 1
; Test IOC.
d710 1
a710 1
;
d757 1
a757 5
        BL      ts_IOCstat      ; IOCstat, get IOC/IOMD Vsn number.
                                ; Note : func leaves falgs un altered, thus
                                ; result of last comparison is passed back
                                ; as the result.
                                ; r8 has the id&vsn number : &IIIIVV00
d762 1
a762 1
        B       %FT11
a765 3
        FAULT   #R_IOMD         ; set that bit in the result word
				; to indicate an IOMD was found.

d768 1
a768 5
  [ IO_Type = "IOMD"
		; IO world is IOMD : Show IOMD Regs, skip IOEB test
    [ ShowIOMDRegs
	BL	sir_ShowIOMDRegs
    ]
d770 1
a770 2
  |
		; IO world is IOEB: Do the IOEB test, skip Show IOMD Regs.
d772 1
a772 1
  ]
d779 1
a779 1
;
a818 1

d824 1
d829 1
a829 1
        BNE     %10
d834 1
a834 1
        BNE     %10
d839 1
a839 1
        BNE     %10
a846 1
	[ :LNOT: AlwaysShortPOST	; Always do a short post on STBs
a850 39
        BNE     %10
        ANDS    r0,r0,#&80              ; Test the memory-test-disable bit
        BEQ     %25
	]
        FAULT   #R_MEMSKIP              ; If set, skip the memory test
        B       %25

10
; CMOS failed -> try E2
    [ E2ROMSupport
        [ ChecksumCMOS

        LDR     r0,=(ts_BBE2 + &4000)
        MOV     r1,#&C0                 ; Get first RAM area
        MOV     r2,#CMOSxseed
        BL      ts_CMOSread
        BNE     %20
        MOV     r2, r0
        LDR     r0,=(ts_BBE2 + &1000)   ; Accumulate the second RAM area
        MOV     r1,#&2F
        BL      ts_CMOSread
        BNE     %20
        RSB     r2, r0, #0              ; Subtract from the checksum byte
        LDR     r0,=(ts_BBE2 + &3F00)
        MOV     r1,#1
        BL      ts_CMOSread
        BNE     %20
        MOV     r8, r0, LSL #24
        ANDS    r0, r0, #&FF            ; A zero result ?
        MOV     r1, #R_CHKFAILBIT
        ADR     r4,%BT3                 ; Report checksum failure
        BNE     %21                     ; failed .. report error
        ]                               ; end ChecksumCMOS

	[ :LNOT: AlwaysShortPOST	; Always do a short post on STBs
        LDR     r0,=(ts_BBE2 + &FC00)   ; Read Misc1CMOS byte
        MOV     r1,#1
        MOV     r2,#0
        BL      ts_CMOSread
d853 2
a854 3
        BEQ     %25
	]
        FAULT   #R_MEMSKIP              ; If set, skip the memory test
a855 1
    ]
d859 1
a859 1
        ADR     r4,%BT2                 ; Report fault accessing IIC
d891 2
a892 2
; configuration. The memory speed can then be set up correctly for
; fastest possible working, and the memory array tested in the
d899 1
a899 1
; where ssss is the processor speed in hex kHz,
d901 2
a902 2
;       r    is the MEMC rom speed switch setting.
;
d928 1
a928 1
        TST     r7, #1 :SHL: 16                 ; test bit 16 of r7 :
d936 1
d940 1
a940 1
;
d962 1
a962 1
        B       ts_VIDCtest	; skip memory test altogether; was	ADR     r4,%BT1
d967 1
a967 1
; if (!R_LINFAILBIT)
d977 1
a977 1
        BL      ts_MoreText
a979 7
	[ DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	%FT13				; EQ : Don't show colours
	]
d983 1
a983 1
13
d987 4
a990 5
					; and r4 the offset from physical to ORGed ROM addresses
					; r4 = ROM - Phys[Ext]ROM
	RSB	r4, r4, #PhysSpace	; r4 = PhysSpace - ROM + Phys[Ext]ROM, pc = ROM + offset
	SetMode SVC32_mode,r0		; Must do this, as PhysSpace is outside 26 bit addressing
	ADD	pc, pc, r4		; pc = PhysSpace + Phys[Ext]ROM + offset
d1029 1
a1029 1
;
d1037 1
a1037 1

d1090 2
a1091 2
; Then try out the protection bits in each CAM entry and various
; processor modes.
d1113 1
a1113 1
        BL      ts_MoreText
d1130 1
a1130 1
        BL      ts_MoreText
d1194 1
a1194 1
        ALIGN
d1210 6
a1215 7
        LDRB    r1,[r3,#IOMD_ID1]	; load r1 with IOMD ID high byte
        LDRB    r0,[r3,#IOMD_ID0]	; load r1 with IOMD ID low byte
        ORR     r0,r0,r1,LSL#8		; Or r0 and r1, shifted left 8, put in r0
        LDR     r1,=ts_IOMD_ID1		; get Ref IOMD ID code #1 (Original)
        CMPS    r0,r1                   ; check for IOMD ID Code #1
	BNE	%FT10			; If not equal, got to 10
					; thus skip Virq test on ARM7500 and ARM7500FE (Morris)
d1232 1
a1232 1
        ]
a1251 8

	[ DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	ts_ARMtype_test			; EQ : Don't show colours
	]
d1258 1
a1258 1
; Read the ARM3 identification register.
d1283 1
a1283 1
        BL      ts_MoreText
d1304 1
a1304 1
; If this was a forced test (test adapter fitted) then pause even when
a1314 10

 [ IOMD_C_FrontPanelLED = (1<<7)
	; Define Long, Equal and short flash delays
ts_Long_Flash      	*	&03		; Number of 1/4 Sec delays for a long flash
ts_Short_Flash	   	*	&01		; Number of 1/4 Sec delays for a short flash
ts_Equal_Flash     	*	&02		; Number of 1/4 Sec delays for a equal flash
ts_Fail_Flash_Delay	*	&14		; Number of Flash Cycles for a Fail, with adaptor
ts_Pass_Flash_Delay	*	&0A		; Number of Flash Cycles for a Pass, with adaptor
 ]

d1324 1
a1324 1
        LDRNE   r9,=C_FAULT
d1337 1
a1337 1
        BCC     %B00                    ; - let the adapter recover
a1345 4
	; Here is r3 = 0, which ment a DUMP adaptor was present.
	;
	; Continue to the OS
	;
a1351 12
	;
	; Here if a Display or other type of adaptor found.
	;
 [ IOMD_C_FrontPanelLED = (1<<7)
	;
	; IOMD_C_FrontPanelLED  = 1<<7, therefore an NC
	;
	; Check to see if we are a PASS or FAIL
	;
        MOV_fiq r7,r12_fiq              	; check for fault bits set
        LDR     r0,=R_STATUS
        BICS    r0,r7,r0
d1353 3
a1355 117
	BEQ	ts_flash_leds_pass		; flash the leds to show a pass
						; flash the leds to show a failure
						; Fall through !

ts_flash_leds_fail
	;
	; Get here if the POST fails !
	;
	; Check for display adpator, if fitted, flash LED's for 20 times
	; else flash LEDs forever.
	;
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
        BNE	%FT19	                   	; Adaptor    : Goto 20 Flash loops Code
 	           				; No Adaptor : Goto Infinite flash loop Code
						; Fall through !
14
	; Infinite Flash loop
	; Register usage ....
	; 	r0, used by toggle leds & delay routines
	;	r1, used by toggle leds routine
	;
15	BL	ts_led_fail			; Call code to flash the leds
	B	%BT15				; Repeat forever.

19
	; Loop for specified time
	; Register usage ....
	; 	r0, used by toggle leds & delay routines
	;	r1, used by toggle leds routine
	;
	;	r3, Loop counter
	;       r4, Pass delay time to delay code.
	;
	MOV	r3,#ts_Fail_Flash_Delay		; Set the loop counter.
20	BL	ts_led_fail			; Call code to flash the leds
	SUBS	r3,r3,#1			; Decrment loop counter
	BNE	%BT20				; Repeat until r3 = 0
	BEQ	%FT50				; r3=0, were all done
						; Goto start the OS

ts_flash_leds_pass
	; Here if POST passed.
	; If adaptor fitted, flash the LEDs for a 10 secs
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
	BEQ	%FT50				; No Adaptor : Goto start the OS
                                       		; Adaptor    : Goto 10 Flash loops Code
						; Fall through !

	; Loop for specified time
	; Register usage ....
	; 	r0, used by toggle leds & delay routines
	;	r1, used by toggle leds routine
	;
	;	r3, Loop counter
	;       r4, Pass delay time to delay code.
	;
	MOV	r3,#ts_Pass_Flash_Delay		; Set the loop counter.
30	BL	ts_led_pass			; Call code to flash the leds
	SUBS	r3,r3,#1			; Decrment loop counter
	BNE	%BT30				; Repeat until r3 = 0
	BEQ	%FT50				; r3=0, were all done
						; Goto start the OS

ts_led_fail
	; Code to flash the LED's through one flash cycle (on-off)
	; This will take 1 Second to complete.
	;
	;|------>|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|
	;|--Red--|---Green---|----Red----|----Red----|----Red----|\
	;         \_______________________________________________/
	;
	;									Red	Green
	MOV	r13,r14				; make a note of where we	On	Off
						; came from.
	BL	tl_Toggle_LEDs			; Toggle the LEDs		Off	On
	MOV	r4,#ts_Short_Flash		; Load r4 with Short flash	Off	On
	BL	ld_LED_Delay			; call delay routine		Off	On
	BL	tl_Toggle_LEDs			; Toggle the LEDs		On	Off
	MOV	r4,#ts_Long_Flash		; load r4 with long flash	On	Off
	BL	ld_LED_Delay			; call delay routine		On	Off

	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.
ts_led_pass
	; Code to flash the LED's through one flash cycle (on-off)
	; This will take 1 Second to complete.
	;
	;|------>|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|
	;|--Red--|---Green---|---Green---|---Green---|----RED----|\
	;         \_______________________________________________/
	;
	;									Red	Green
	MOV	r13,r14				; make a note of where we	On	Off
						; came from.
	BL	tl_Toggle_LEDs			; Toggle the LEDs		Off	On
	MOV	r4,#ts_Long_Flash		; Load r4 with long flash	Off	On
	BL	ld_LED_Delay			; call delay routine		Off	On
	BL	tl_Toggle_LEDs			; Toggle the LEDs		On	Off
	MOV	r4,#ts_Short_Flash		; load r4 with short flash	On	Off
	BL	ld_LED_Delay			; call delay routine		On	Off

	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.

50
	;
	; Continue on our way
	;
 |
	;
	; IOMD_C_FrontPanelLED  <> 1<<7, therefore not an NC
	;
	; Indicate fault found : Set the border to fault colour and flash
	; the disk LED, using the fault bitmap in r12_fiq to modulate the flashing.
	;
d1370 2
a1371 2
01
        MOV_fiq r6,r12_fiq
d1373 1
d1375 1
a1375 1
   [ IO_Type = "IOMD"
d1379 1
a1379 1
   |
d1387 1
a1387 1
   ]
d1389 3
a1391 2
02
	BL	ld_LED_Delay			; call delay routine
d1396 3
a1398 2
	BL	ld_LED_Delay			; call delay routine

d1401 3
a1403 2
	BL	ld_LED_Delay			; call delay routine }
	BL	ld_LED_Delay			; call delay routine } Half A Second
d1415 3
a1417 5
	BL	ld_LED_Delay			; call delay routine }
	BL	ld_LED_Delay			; call delay routine } One Seconds Worth
	BL	ld_LED_Delay			; call delay routine }
	BL	ld_LED_Delay			; call delay routine }

d1422 3
a1424 12
 ]
;
; Uncomment the following line if the POST code is to loop when the POST
; display adaptor (post box) is fitted.
;
;        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED) ; If the display adapter & test link are present,
;
; Comment thi line out if POST Code is to loop when the POST display
; adaptor (post box) is fitted.
;
        ANDS    r0,r0,# R_TESTED	; If the test link is present,
        BNE     Reset                   ; repeat the test forever
a1437 7
	[ DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	ts_Softstart			; EQ : Don't show colours
	]
d1446 1
a1446 3
;
;
;
d1448 1
d1469 3
d1479 1
a1479 1
; Include test modules executed by call, rather than inline
a1488 5
        GET     TestSrc.ToggleLED
        GET     TestSrc.LEDDelay
	GET	TestSrc.ShowIOMDRs

	ALIGN	64		; JRH: Kernel seems happier if we do this!
@


4.1.7.2
log
@12 mar 97 BAR
@
text
@a78 1
; 10 Mar 97     BAR     2.21    Add code to check 1K of NVRAM - if reqd.
d92 1
a92 1
TS_CHANGES      *       1
d1015 10
a1024 13
                                        ; Accumulate the first RAM area
        LDR     r0,=(ts_BBE2 + &4000)   ; r0 = base addr + start location
        MOV     r1,#&C0                 ; r1 = length of data to read
        MOV     r2,#CMOSxseed           ; r2 = checksum seed or previous value
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %20                     ; branch if NE - failed to ready at all.

                                        ; Accumulate the second RAM area
        MOV     r2, r0                  ; r2 = r0 = new checksum value.
        LDR     r0,=(ts_BBE2 + &1000)   ; r0 = base addr + start location
        MOV     r1,#&2F                 ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %20                     ; branch if NE - failed to ready at all.
d1026 7
a1032 24

                                        ; Check to see if we need to Accumulate the THIRD area.
        MOV     r1,#CMOSRAMCache        ; r1 = size of the CMOS RAM
        TEQ     r1,#240                 ; Is r1 = 240 bytes ?
        BEQ     %FT15                   ; It is equal, go to checksum checking code

                                        ; Accumulate the third RAM area
        MOV     r2,r0                   ; r2 = r0 = new checksum value.
        LDR     r0,=(ts_BBE2 + &10000)  ; r0 = base addr + start location
        MOV     r1,#&300                ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %20                     ; branch if NE - failed to ready at all.

                                        ; read and check the shecksum value.
15      RSB     r2, r0, #0              ; Subtract from the checksum byte
        LDR     r0,=(ts_BBE2 + &3F00)   ; r0 = base addr + start location
        MOV     r1,#1                   ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %20                     ; branch if NE - failed to ready at all.

                                        ; Check the checksum is correct
        MOV     r8, r0, LSL #24         ; r8 = r0 << 24 : put the checksum value in r8 for displaying.
        ANDS    r0, r0, #&FF            ; r0 = r0 + &FF : If alls ok s/be a zero result ...
        MOV     r1, #R_CHKFAILBIT       ; r1 = checksum fail flag
@


4.1.7.3
log
@Updated to check for Left & Right LED flags. Always use the VGA VIDC data
table when ChrontelSupport is TRUE.
@
text
@a79 5
; 13 Mar 97     BAR     2.22    Change conditional assemble flags for
;                               including new LED flashing routines. Now
;                               checks for Left & Right LED flags.
;                               Always use the VGA VIDC Definition Table if
;                               the flag ChrontelSupport is TRUE.
d93 1
a93 1
TS_CHANGES      *       2
d697 1
a697 1
; Initialise VIDC
d702 16
a717 22
                ; Using IOMD
                MOV     r2,#IOMD_Base
                MOV     r0, #IOMD_VREFCR_REF_16 ; switch on DRAM refresh
                STR     r0, [r2, #IOMD_VREFCR]
                MOV     r1,#ts_VIDCPhys

                [ ChrontelSupport
                        ; We have a Chrontel chip ... thus always set for VGA.
                        ADRL    r2,TestVVIDCTAB
                | ; NOT ChrontelSupport
                        ; We don't have a Chrontel chip
                        ; ... thus check MonitorType and select table as reqd.
                        ADRL    r2,TestVIDCTAB
                        LDR     r0,=IOMD_MonitorType
                        LDR     r0,[r0]
                        ANDS    r0,r0,#IOMD_MonitorIDMask
                        ADDEQ   r2,r2,#(TestVVIDCTAB-TestVIDCTAB)
                ] ; Endif - ChrontelSupport
        | ; not IOMD
                MOV     r1,#ts_VIDCPhys
                ADRL    r2,TestVIDCTAB
        ] ; Endif - IO_Type = "IOMD"
d1546 2
a1547 2
 [ ((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0)))
        ; Define Long, Equal and short flash delays
d1553 1
a1553 1
 ] ; Endif ((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0)))
d1599 1
a1599 1
 [ ((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0)))
d1601 1
a1601 2
	; IOMD_C_FrontPanelLED <> 0 OR ((IOMD_C_FrontPanelRightLED <> 0) :AND: IOMD_C_FrontPanelLeftLED <> 0))
        ; Thus we have some FP Leds to play with !
d1719 1
a1719 1
 | ; else
d1721 1
a1721 2
	; ((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0)))
        ; Thus we use the old way of flashing the LED etc ....
d1790 1
a1790 1
 ] ; Endif ((IOMD_C_FrontPanelLED <> 0) :LOR: ((IOMD_C_FrontPanelRightLED <> 0) :LAND: (IOMD_C_FrontPanelLeftLED <> 0)))
@


4.1.7.4
log
@Correct bug in CMOS RAM check code, now get size of CMSRAMCache. Change to leave the screen colour as black.
@
text
@a84 2
; 18 Mar 97     BAR     2.23    Added C_DEFAULT (Black) Change use of
;                               C_WARMSTART to C_DEFAULT.
d98 1
a98 1
TS_CHANGES      *       3
a141 1
C_DEFAULT       *       &40000000+&000  ; default (Black)
a150 1
C_DEFAULT       *       &40000000+&000000  ; default (Black)
d1043 1
a1043 1
        MOV     r1,#?CMOSRAMCache        ; r1 = size of the CMOS RAM
d1835 1
a1835 1
        LDR     r1,=C_DEFAULT
@


4.1.7.5
log
@Now uses global variable "ROMSpeedNormal".
@
text
@d657 1
a657 5
    [ ROMSpeedNormal
        ORR     r0, r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_NSTicks_5 :OR: IOMD_ROMCR_BTicks_4
    |
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_NSTicks_5 :OR: IOMD_ROMCR_BTicks_4
    ]
d662 1
a662 13
    [ ExtROMis16bit
     [ ROMSpeedNormal
        MOVEQ   r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_16bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     |
        MOVEQ   r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_16bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     ]
    |
     [ ROMSpeedNormal
        MOVEQ   r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_32bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     |
        MOVEQ   r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_32bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     ]
    ]
d692 1
a692 5
    [ ROMSpeedNormal
        ORR     r0, r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_NSTicks_5 :OR: IOMD_ROMCR_BTicks_4
    |
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_NSTicks_5 :OR: IOMD_ROMCR_BTicks_4
    ]
d697 1
a697 13
    [ ExtROMis16bit
     [ ROMSpeedNormal
        MOVEQ   r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_16bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     |
        MOVEQ   r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_16bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     ]
    |
     [ ROMSpeedNormal
        MOVEQ   r0, #IOMD_ROMCR_Normal :OR: IOMD_ROMCR_32bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     |
        MOVEQ   r0, #IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_32bit :OR: IOMD_ROMCR_NSTicks_7 :OR: IOMD_ROMCR_BurstOff
     ]
    ]
@


4.1.7.6
log
@Speed up Boca CPU clock
@
text
@d637 1
a637 1
;	CPUCLK divide by 2 unless FECPUSpeedNormal set
a640 3
 [ FECPUSpeedNormal
	MOV     r0, #IOMD_CLKCTL_CpuclkNormal + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
 |
a641 1
 ]
@


4.1.7.7
log
@Added support for 2K EEPROM.
@
text
@a130 1
ts_BB2KE2       *       &E0                             ; IIC address of 2K E2ROM chip
d1014 8
d1024 1
a1024 1
        ADR     r4,%FT1
d1046 1
a1046 1
        ADR     r4,%FT3                 ; Report checksum failure
d1079 1
a1079 1
        BNE     %22                     ; branch if NE - failed to ready at all.
d1092 1
a1092 1
        BNE     %22                     ; branch if NE - failed to ready at all.
d1099 1
a1099 1
        BNE     %22                     ; branch if NE - failed to ready at all.
d1105 1
a1105 1
        ADR     r4,%FT3                 ; Report checksum failure
d1114 1
a1114 1
        BNE     %22
a1121 8
1
        =       "SRAM  :",0
2
        =       "SRAM-F",0
3
        =       "SRAM-C",&8e,&ff,&ff,0
        ALIGN

a1122 59
; CMOS failed -> try 2K E2
    [ E2ROMSupport
        [ ChecksumCMOS

                                        ; Accumulate the first RAM area
        LDR     r0,=(ts_BB2KE2 + &4000) ; r0 = base addr + start location
        MOV     r1,#&C0                 ; r1 = length of data to read
        MOV     r2,#CMOSxseed           ; r2 = checksum seed or previous value
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %22                     ; branch if NE - failed to ready at all.

                                        ; Accumulate the second RAM area
        MOV     r2, r0                  ; r2 = r0 = new checksum value.
        LDR     r0,=(ts_BB2KE2 + &1000) ; r0 = base addr + start location
        MOV     r1,#&2F                 ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %22                     ; branch if NE - failed to ready at all.
        RSB     r2, r0, #0              ; Subtract from the checksum byte

                                        ; Check to see if we need to Accumulate the THIRD area.
        MOV     r1,#?CMOSRAMCache        ; r1 = size of the CMOS RAM
        TEQ     r1,#240                 ; Is r1 = 240 bytes ?
        BEQ     %FT15                   ; It is equal, go to checksum checking code

                                        ; Accumulate the third RAM area
        MOV     r2,r0                   ; r2 = r0 = new checksum value.
        LDR     r0,=(ts_BB2KE2 + &10000); r0 = base addr + start location
        MOV     r1,#&300                ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %22                     ; branch if NE - failed to ready at all.

                                        ; read and check the shecksum value.
15      RSB     r2, r0, #0              ; Subtract from the checksum byte
        LDR     r0,=(ts_BB2KE2 + &3F00) ; r0 = base addr + start location
        MOV     r1,#1                   ; r1 = length of data to read
        BL      ts_CMOSread             ; read the cmos r0 = new checksum. NE = failure; EQ = ok.
        BNE     %22                     ; branch if NE - failed to ready at all.

                                        ; Check the checksum is correct
        MOV     r8, r0, LSL #24         ; r8 = r0 << 24 : put the checksum value in r8 for displaying.
        ANDS    r0, r0, #&FF            ; r0 = r0 + &FF : If alls ok s/be a zero result ...
        MOV     r1, #R_CHKFAILBIT       ; r1 = checksum fail flag
        ADR     r4,%BT3                 ; Report checksum failure
        BNE     %21                     ; failed .. report error
        ]                               ; end ChecksumCMOS

	[ :LNOT: AlwaysShortPOST	; Always do a short post on STBs
        LDR     r0,=(ts_BB2KE2 + &FC00) ; Read Misc1CMOS byte
        MOV     r1,#1
        MOV     r2,#0
        BL      ts_CMOSread
        BNE     %22
        ANDS    r0,r0,#&80              ; Test the memory-test-disable bit
        BEQ     %25
	]
        FAULT   #R_MEMSKIP              ; If set, skip the memory test
        B       %25
    ]
22
@


4.1.7.8
log
@Made branches to local labels in CMOS test go in the correct direction.
@
text
@a1009 2
        ROUT

d1025 1
a1025 1
        BNE     %FT10
d1030 1
a1030 1
        BNE     %FT10
d1035 1
a1035 1
        BNE     %FT10
d1040 1
a1040 1
        BNE     %FT21                   ; failed .. report error
d1048 1
a1048 1
        BNE     %FT10
d1050 1
a1050 1
        BEQ     %FT25
d1053 1
a1053 1
        B       %FT25
d1065 1
a1065 1
        BNE     %FT20                   ; branch if NE - failed to ready at all.
d1072 1
a1072 1
        BNE     %FT22                   ; branch if NE - failed to ready at all.
d1085 1
a1085 1
        BNE     %FT22                   ; branch if NE - failed to ready at all.
d1092 1
a1092 1
        BNE     %FT22                   ; branch if NE - failed to ready at all.
d1099 1
a1099 1
        BNE     %FT21                   ; failed .. report error
d1107 1
a1107 1
        BNE     %FT22
d1109 1
a1109 1
        BEQ     %FT25
d1112 1
a1112 1
        B       %FT25
d1133 1
a1133 1
        BNE     %FT22                   ; branch if NE - failed to ready at all.
d1140 1
a1140 1
        BNE     %FT22                   ; branch if NE - failed to ready at all.
d1153 1
a1153 1
        BNE     %FT22                   ; branch if NE - failed to ready at all.
d1160 1
a1160 1
        BNE     %FT22                   ; branch if NE - failed to ready at all.
d1167 1
a1167 1
        BNE     %FT21                   ; failed .. report error
d1175 1
a1175 1
        BNE     %FT22
d1177 1
a1177 1
        BEQ     %FT25
d1180 1
a1180 1
        B       %FT25
@


4.1.7.9
log
@Ensure LED is set to RED before flashing them - gets the sequence right. If
flashed ensure that BOTH are turned back on.
@
text
@a86 3
; 12 Jun 97     BAR     2.24    Ensure LED is set to RED before flashing
;                               them - gets the sequence right. If flashed
;                               ensure that BOTH are turned back on.
d100 1
a100 1
TS_CHANGES      *       4
a1665 5

IOMD_LED_GREENLED       *       IOMD_C_FrontPanelRightLED               ; The right LED should be the GREEN LED
IOMD_LED_REDLED         *       IOMD_C_FrontPanelLeftLED                ; The left  LED should be the RED   LED
IOMD_LED_BOTH           *       IOMD_LED_REDLED :OR: IOMD_LED_GREENLED  ;

a1730 2
        ; Set it so the RED LED is on.
        BL      ts_led_redon_only               ; Ensure that the RED LED only is on,
d1761 1
a1761 1
	BEQ	%FT55				; r3=0, were all done
a1772 2
        ; Set it so the RED LED is on.
        BL      ts_led_redon_only               ; Ensure that the RED LED only is on,
a1828 49
ts_led_redon_only
	MOV	r13,r14				; make a note of where we came from
	LDR	r1, =IOMD_IOLINES               ; r1 = addr of IOMD_IOLINES
        LDRB    r0,[r1]                         ; load r0 with the byte pointed to by r1
;        DREG    r0,"contents of loc->r1"
        BIC     r0,r0,#IOMD_LED_GREENLED        ; Clear GREEN LED bit
        ORR     r0,r0,#IOMD_LED_REDLED          ; Set   RED LED bit
        ORR     r0,r0,#IOMD_C_ReadMask          ; OR with the default I/O settings
        STRB    r0,[r1]                         ; store a byte of r0 in to loc pointed to by r1
	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.

ts_led_greenon_only
	MOV	r13,r14				; make a note of where we came from
	LDR	r1, =IOMD_IOLINES               ; r1 = addr of IOMD_IOLINES
        LDRB    r0,[r1]                         ; load r0 with the byte pointed to by r1
;        DREG    r0,"contents of loc->r1"
        BIC     r0,r0,#IOMD_LED_REDLED          ; clear RED LED bit
        ORR     r0,r0,#IOMD_LED_GREENLED        ; Set   GREEN LED bit
        ORR     r0,r0,#IOMD_C_ReadMask          ; OR with the default I/O settings
        STRB    r0,[r1]                         ; store a byte of r0 in to loc pointed to by r1
	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.

ts_led_bothon
	MOV	r13,r14				; make a note of where we came from
	LDR	r1, =IOMD_IOLINES               ; r1 = addr of IOMD_IOLINES
        LDRB    r0,[r1]                         ; load r0 with the byte pointed to by r1
;        DREG    r0,"contents of loc->r1"
        ORR     r0,r0,#IOMD_LED_BOTH            ; Set Both Green & RED LED bits
        ORR     r0,r0,#IOMD_C_ReadMask          ; OR with the default I/O settings
        STRB    r0,[r1]                         ; store a byte of r0 in to loc pointed to by r1
	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.

ts_led_bothoff
	MOV	r13,r14			        ; make a note of where we came from
	LDR	r1, =IOMD_IOLINES               ; r1 = addr of IOMD_IOLINES
        LDRB    r0,[r1]                         ; load r0 with the byte pointed to by r1
;        DREG    r0,"contents of loc->r1"
        BIC     r0,r0,#IOMD_LED_BOTH            ; Clear Both Green & RED LED bits
        ORR     r0,r0,#IOMD_C_ReadMask          ; OR with the default I/O settings
        STRB    r0,[r1]                         ; store a byte of r0 in to loc pointed to by r1
	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.




d1830 1
a1830 8
        ; come here if we've finished showing pass/fail by flashing the LEDs
        ; thus a test link or display aaptor was fitted
        ; so turn on the LED's
        BL      ts_led_bothon

55
        ; come here because we passed, but no display adaptor ot test link, thus LEDs weren't flashed
	; so ........
@


4.1.7.10
log
@Remove un-necessary mov r13,r14's. When completed flashing LED's restore the
faultcode flag from fiq_regs.
@
text
@a89 3
; 19 Jun 97     BAR     2.25    Remove un-necessary mov r13,r14's
;                               When completed flashing LED's restore the
;                               faultcode flag from fiq_regs.
d1771 1
a1771 1
	BEQ	%FT50				; r3=0, were all done
d1779 1
a1779 1
	BEQ	%FT55				; No Adaptor : Goto start the OS
d1809 2
a1816 1
        MOV     pc, r14                         ; Return to caller
d1818 2
d1829 2
d1837 3
a1839 1
        MOV     pc, r14                         ; Return to caller
d1842 1
d1850 2
a1851 1
        MOV     pc, r14                         ; Return to caller
d1854 1
d1862 2
a1863 1
        MOV     pc, r14                         ; Return to caller
d1866 1
d1873 2
a1874 1
        MOV     pc, r14                         ; Return to caller
d1877 1
d1884 3
a1886 1
        MOV     pc, r14                         ; Return to caller
a1974 1
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
d1980 1
a1980 1
; Comment this line out if POST Code is to loop when the POST display
@


4.1.7.11
log
@Fix flash_leds_pass/fail
@
text
@a1811 2
	MOV	r13,r14				; make a note of where we	On	Off
						; came from.
d1818 1
a1818 3

	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.
a1828 2
	MOV	r13,r14				; make a note of where we	On	Off
						; came from.
d1835 1
a1835 3

	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.
@


4.1.7.12
log
@Added option to do POST on a non-power on reset.

Version 4.63, 1.1.2.4. Tagged as 'Kernel-4_63-1_1_2_4'
@
text
@a554 1
        [ :LNOT:DoPOSTwithoutPowerOn
a569 1
        ]
@


4.1.7.13
log
@Turns off Chrontel device inside POST to surpress TV noise.

Version 4.63, 1.1.2.5. Tagged as 'Kernel-4_63-1_1_2_5'
@
text
@a757 8
                [ ChrontelSupport :LAND: IOMD_C_VideoPowerDown <> 0
                ; Turn off the Chrontel device to prevent TV noise. The Chrontel module may
                ; or may not turn it on later, as is its wont.
                LDRB    r0, [r2, #IOMD_CLINES]
                ORR     r0, r0, #IOMD_C_ReadMask        ; must keep inputs high
                BIC     r0, r0, #IOMD_C_VideoPowerDown  ; bit is actually /PowerDown, so clear it for power off
                STRB    r0, [r2, #IOMD_CLINES]
                ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a21 57
; 15-May-96	BAR	2.06	Update for ARM7500FE variant, new IOMD ID
;				Code. Used initially in the NC product;
;				needs different prescalers and ROM speed
;				settings, switched on IOMD ID code.
; 30-May-96	BAR	2.07	Add code to flash NC's led's. Ignore morse
;				code and just use the simplified flash
;				sequence.
; 14-Jun-96	BAR	2.08	Add get call for initmodule file.
; 17-Jun-96	BAR	2.09	Change speed settings for the second bank of
;				ROM space.
; 24-Jun-96	BAR	2.10	Updated second check on IOMD ID, instead of
;				checking for ARM7500 IOMD ID code to skip
;				the Virq test, now checks for the original
;				(RiscPC) IOMD ID code and skips Virq test if
;				not equal. Thus ARM7500 and ARM7500FE
;				devices don't execute the test.
;				Updated version number.
;				Added call to sir_IOMD_Regs -show iomd registers
; 08-Jul-96     BAR     2.11    Ensure r0 is cleared before checking IOMD vsn no.
;                               Change ROM Burst speed from93.75nS to 125nS.
; 09-Jul-96                     Make IOMD ID code more efficent. Change
;                               variables used for ROMCR Values and remove
;                               'NormalSpeed' ROMs compiler switching code -
;                               no longer supporting PSwindell.
;                               Change non-7500FE ROM Burst speed from 3 ticks
;				to 4 ticks
; 25-Jul-96	BAR	2.12	Add code to handle EEPROM as well as CMOS
;				RAM. Code supplied by J.Harris.
; 29-Jul-96     BAR     2.13    Update LED stuff to wait properly.
; 29-Jul-96	BAR	2.14	Update exit codes IOMD et all.
;				More work on the LED code.
; 30-Jul-96	BAR	2.15	Humm, get the LED's to work !
; 16-Aug-96	JRH	2.16	Add check for OS image in 2nd ROM bank.
;				Don't program the 2nd ROM bank speed (ROMCR1),
;				unless CanLiveInROMCard is True, in which case
;				check whether we're running from the 2nd bank.
;				Made display of IOMD regs conditional on new
;				ShowIOMDRegs flag, which is set to TRUE
; 05-Sep-96	BAR	2.17	Updated to NOT show the progress colours on
;				the screen unless a POST box is added when
;				they will be shown. This is in accordance
;				with fault report  ANC-00159. The final red
;				fail screen will be maintained as this
;				enfoces the fact the the POSt has failed and
;				that the ser needs to attend to the unit.
;				The compile switch DontShowProgressColours
;				can be set to FALSE, then the progress
;				colours will always be shown.
; 07-Oct-96	JRH	2.18	Changed ExtIO to fix support for speaking to
;				the test box when running from the 2nd ROM bank,
;				conditioned on CanLiveOnROMCard.
; 22-Oct-96	JRH	2.19	Added an Align64 at the end of the file because
;				OS_Find was sometimes failing. Don't know why.
;				Fixed bug introduced in 2.18 which turned burst
;				off on ROMCR0.
; 08 Nov 96	BAR	2.20	Add kluge to skip ram (long) test
;				altogether, 'cos it appears to be crashing.
d24 1
a24 1
;
d34 2
a35 2
TS_RELEASE      *       22
TS_CHANGES      *       0
d39 1
a39 13
POSTenabled     SETL    {TRUE}          ; don't permit POST for ordinary startup

                GBLL    AlwaysShortPOST
AlwaysShortPOST SETL    {TRUE}          ; always do a short POST

                GBLL    ShowIOMDRegs
ShowIOMDRegs	SETL    (IO_Type = "IOMD") :LAND: {TRUE}	; show IOMD regs

                GBLL   DontShowProgressColours
DontShowProgressColours	SETL	{TRUE}				; Do not show the progress colour screens.
								; Progress Colours will always be shown when using POST Box.
								; Set to true for NC - Fault Report ANC-00159.

d42 1
a42 1
ts_Rom_length   *       1 :SHL: ts_Rom_bits             ; Longest ROM
a52 1
ts_BBE2         *       &A8                             ; IIC address of E2ROM chip
d68 6
a73 7
        [ VIDC_Type = "VIDC20"
C_2NDBANK	*	&40000000+&C00070  ; jumping to image in 2nd ROM bank (Dark blue)
C_ARMOK         *       &40000000+&7000C0  ; testing ROM (Magenta)
C_RAMTEST       *       &40000000+&C07000  ; testing RAM (Blue)
C_FAULT         *       &40000000+&0000F0  ; failed tests(Red)
C_PASSED        *       &40000000+&70C000  ; all passed  (Green)
C_WARMSTART     *       &40000000+&707070  ; not tested  (Mid grey)
d75 1
a75 1
;
d79 1
a79 1
;
d81 2
d94 1
a94 2
R_IOEB          *       &40             ; PC-style IO controller (A5000)
R_IOMD          *       &40             ; PC-style IO controller (RiscPC, ARM7500)
d101 1
a101 1
R_CAMFAILBIT    *       &400            ; CAM failed
d120 1
a120 1
; low memory addresses. The Reset vector will be copied to low RAM
d169 1
a169 1
ts_himsg
d230 1
a230 1
        B       ts_SendLCDCmd
d244 1
a244 1
; Note : the register order in ADDS ...pc.. is often critical.
d259 1
a259 1
        MACRO
d266 1
a266 1
        MACRO
d304 1
a304 1
        GBLA    OldOpt                  ; don't list all the walking
d343 1
a343 1
        WEND
d351 1
a351 1
        WEND
d378 1
a378 1
        &       ROM - pcfromstart
d394 1
a394 1
        LDR     r1,doffset+4            ; walking 0 data pattern
d417 1
a417 1
; External interface drivers -
d419 1
a419 1
; and to receive byte- and word-sized objects
d424 3
a426 3
;
        B       ts_GetCommand	; (This instruction redundant 'cos ts_GetCommand
				;  is the first thing defined in TestSrc.ExtIO)
d516 1
a516 1
02
d538 8
a545 48
; check for te veriosn of IOMD, only need to determin between variants in
; the ARM7500 and ARM7500FE - condional code assembly excludes non-ARM7500
; devices.

        MOV     r2, #IOMD_Base		; r2 points to the IOMD base address defiend in HDR:IO.IOMDL
        LDRB    r1,[r2,#IOMD_ID1]	; load r1 with IOMD ID high byte
        LDRB    r0,[r2,#IOMD_ID0]	; load r0 with IOMD ID low byte
        ORR     r0,r0,r1,LSL#8		; Or r0 and r1, shifted left 8, put in r0
        LDR     r1,=ts_IOMD_ID2		; get Ref IOMD ID code #2
        CMPS    r0,r1                   ; check for IOMD ID Code #2
	BEQ	%FT05			; If equal, got to 05

        LDRNE   r1,=ts_IOMD_ID3		; If not ID1, get ID code #3
        CMPNES  r0,r1			; If not ID1, check for IOMD ID Code #3
        BNE     %FT10			; Not equal; not an ARM7500 or an ARM7500FE - skip

; Here bceause its an ARM7500 'FE' variant
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;	CPUCLK divide by 2
;	MEMCLK divide by 1
;	IOCLK  divide by 1
;
	MOV     r0, #IOMD_CLKCTL_CpuclkHalf + IOMD_CLKCTL_MemclkNormal + IOMD_CLKCTL_IOclkNormal
        STRB    r0, [r2, #IOMD_CLKCTL] ; initialise all the prescalers.
;
; Set ROM speed, take care to preserve 16-bit mode bit...
;
; According to BSiddle on the 15-May-96, Omega will use burst mode roms: use 93nS burst, 156nS initial.
; According to TDbson on the 09-Jul-96, Omega will handle ROMS up to 120nS and 70nS.
; Thus the ROM speed should be initilised to :-
; Half Speed or H bit, clear, which is ON ! : Half the delays, thus DOUBLE all clock ticks.
; Non-Sequental delay : 10 Ticks : Half speed on, so select 5 ticks (5*2)
; Burst delay         :  8 Ticks : Half speed on, so select 4 ticks (4*2)
; Remember the Memory clock on Omega is faster than on previous porducts.
; The fast flash devices used for Omega testing should be able to cope even
; though they aren't burst devices.
        LDRB    r0, [r2, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_4
        STRB    r0, [r2, #IOMD_ROMCR0]          ; Prog. the reg.s
  [ CanLiveOnROMCard
	TST	pc, #ts_RC_2ndbank		; Not running out of 2nd ROM bank?
        ; Don't know what's in the 2nd bank -> program it to a slow default
	MOVNE	r0, #IOMD_ROMCR_HalfSpeed + IOMD_ROMCR_32bit + IOMD_ROMCR_NSTicks_7 + IOMD_ROMCR_BurstOff
        STRB    r0, [r2, #IOMD_ROMCR1]		; Otherwise program it the same
  ]
	B	%FT10
d547 1
a547 8

05
; Here because its an ARM7500 variant - NON 'FE' device.
; Program the CPU, Memory and IO clock prescalers
; Set the prescalers to :-
;	CPUCLK divide by 1
;	MEMCLK divide by 1
;	IOCLK  divide by 1
d555 19
a573 18
; According to BSiddle on 09-Jul-96 - Omenga will need to set the burst speed to 4 ticks from 3 ticks.
; Thus the ROM speed should be initilised to :-
; Half Speed or H bit, Set, which is OFF ! : Don't half the delays.
; Non-Sequental delay :  5 Ticks : Half speed off, so select 5 ticks
; Burst delay         :  4 Ticks : Half speed off, so select 4 ticks
; The fast EPROMS used for Kryten testing should be able to cope even though
; they aren't burst devices

        LDRB    r0, [r2, #IOMD_ROMCR0]          ; Get contents of ROMCR0 in to r0
        AND     r0, r0, #&40                    ; clear all but the 16-bit mode flag
        ORR     r0, r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_NSTicks_5 + IOMD_ROMCR_BTicks_4
        STRB    r0, [r2, #IOMD_ROMCR0]          ; Prog. the reg.s
  [ CanLiveOnROMCard
	TST	pc, #ts_RC_2ndbank		; Not running out of 2nd ROM bank?
        ; Don't know what's in the 2nd bank -> program it to a slow default
	MOVNE	r0, #IOMD_ROMCR_Normal + IOMD_ROMCR_32bit + IOMD_ROMCR_NSTicks_7 + IOMD_ROMCR_BurstOff
        STRB    r0, [r2, #IOMD_ROMCR1]		; Otherwise program it the same
  ]
d607 2
a608 10
;
; Test for presence of OS image in 2nd ROM bank and jump to it
;
	GBLS	DoROMCardThings
  [ ROMCardSupport :LOR: CanLiveOnROMCard
DoROMCardThings	SETS	"GET	TestSrc.ROMCard"
  |
DoROMCardThings	SETS	""
  ]
	$DoROMCardThings
d610 1
a611 16
;
; Set purple screen
;

	[ DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	ts_RomTest			; EQ : Don't show colours
	]
	MOV	r1, #ts_VIDCPhys
        LDR	r0, =C_ARMOK     		; set initial screen colour
        STR	r0, [r1]

        B       ts_RomTest
d647 1
a647 1
                                        ; the ARM600 MMU as well.
d658 1
a658 1
2
d671 2
a672 2
; MemSize returns with  r0 = page size   (now in bytes, *NOT* in MEMC control patterns),
;                       r1 = memory size (in bytes)
d681 1
a681 1
        MODE    FIQ_mode                        ; Save memory size and
d707 1
a707 1
; Test IOC.
d710 1
a710 1
;
d757 1
a757 5
        BL      ts_IOCstat      ; IOCstat, get IOC/IOMD Vsn number.
                                ; Note : func leaves falgs un altered, thus
                                ; result of last comparison is passed back
                                ; as the result.
                                ; r8 has the id&vsn number : &IIIIVV00
d762 1
a762 1
        B       %FT11
a765 3
        FAULT   #R_IOMD         ; set that bit in the result word
				; to indicate an IOMD was found.

d768 1
a768 5
  [ IO_Type = "IOMD"
		; IO world is IOMD : Show IOMD Regs, skip IOEB test
    [ ShowIOMDRegs
	BL	sir_ShowIOMDRegs
    ]
d770 1
a770 2
  |
		; IO world is IOEB: Do the IOEB test, skip Show IOMD Regs.
d772 1
a772 1
  ]
d779 1
a779 1
;
a818 1

d824 1
d829 1
a829 1
        BNE     %10
d834 1
a834 1
        BNE     %10
d839 1
a839 1
        BNE     %10
a846 1
	[ :LNOT: AlwaysShortPOST	; Always do a short post on STBs
a850 39
        BNE     %10
        ANDS    r0,r0,#&80              ; Test the memory-test-disable bit
        BEQ     %25
	]
        FAULT   #R_MEMSKIP              ; If set, skip the memory test
        B       %25

10
; CMOS failed -> try E2
    [ E2ROMSupport
        [ ChecksumCMOS

        LDR     r0,=(ts_BBE2 + &4000)
        MOV     r1,#&C0                 ; Get first RAM area
        MOV     r2,#CMOSxseed
        BL      ts_CMOSread
        BNE     %20
        MOV     r2, r0
        LDR     r0,=(ts_BBE2 + &1000)   ; Accumulate the second RAM area
        MOV     r1,#&2F
        BL      ts_CMOSread
        BNE     %20
        RSB     r2, r0, #0              ; Subtract from the checksum byte
        LDR     r0,=(ts_BBE2 + &3F00)
        MOV     r1,#1
        BL      ts_CMOSread
        BNE     %20
        MOV     r8, r0, LSL #24
        ANDS    r0, r0, #&FF            ; A zero result ?
        MOV     r1, #R_CHKFAILBIT
        ADR     r4,%BT3                 ; Report checksum failure
        BNE     %21                     ; failed .. report error
        ]                               ; end ChecksumCMOS

	[ :LNOT: AlwaysShortPOST	; Always do a short post on STBs
        LDR     r0,=(ts_BBE2 + &FC00)   ; Read Misc1CMOS byte
        MOV     r1,#1
        MOV     r2,#0
        BL      ts_CMOSread
d853 2
a854 3
        BEQ     %25
	]
        FAULT   #R_MEMSKIP              ; If set, skip the memory test
a855 1
    ]
d859 1
a859 1
        ADR     r4,%BT2                 ; Report fault accessing IIC
d891 2
a892 2
; configuration. The memory speed can then be set up correctly for
; fastest possible working, and the memory array tested in the
d899 1
a899 1
; where ssss is the processor speed in hex kHz,
d901 2
a902 2
;       r    is the MEMC rom speed switch setting.
;
d928 1
a928 1
        TST     r7, #1 :SHL: 16                 ; test bit 16 of r7 :
d936 1
d940 1
a940 1
;
d962 1
a962 1
        B       ts_VIDCtest	; skip memory test altogether; was	ADR     r4,%BT1
d967 1
a967 1
; if (!R_LINFAILBIT)
d977 1
a977 1
        BL      ts_MoreText
a979 7
	[ DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	%FT13				; EQ : Don't show colours
	]
d983 1
a983 1
13
d987 4
a990 5
					; and r4 the offset from physical to ORGed ROM addresses
					; r4 = ROM - Phys[Ext]ROM
	RSB	r4, r4, #PhysSpace	; r4 = PhysSpace - ROM + Phys[Ext]ROM, pc = ROM + offset
	SetMode SVC32_mode,r0		; Must do this, as PhysSpace is outside 26 bit addressing
	ADD	pc, pc, r4		; pc = PhysSpace + Phys[Ext]ROM + offset
d1029 1
a1029 1
;
d1037 1
a1037 1

d1090 2
a1091 2
; Then try out the protection bits in each CAM entry and various
; processor modes.
d1113 1
a1113 1
        BL      ts_MoreText
d1130 1
a1130 1
        BL      ts_MoreText
d1194 1
a1194 1
        ALIGN
d1210 6
a1215 7
        LDRB    r1,[r3,#IOMD_ID1]	; load r1 with IOMD ID high byte
        LDRB    r0,[r3,#IOMD_ID0]	; load r1 with IOMD ID low byte
        ORR     r0,r0,r1,LSL#8		; Or r0 and r1, shifted left 8, put in r0
        LDR     r1,=ts_IOMD_ID1		; get Ref IOMD ID code #1 (Original)
        CMPS    r0,r1                   ; check for IOMD ID Code #1
	BNE	%FT10			; If not equal, got to 10
					; thus skip Virq test on ARM7500 and ARM7500FE (Morris)
d1232 1
a1232 1
        ]
a1251 8

	[ DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	ts_ARMtype_test			; EQ : Don't show colours
	]
d1258 1
a1258 1
; Read the ARM3 identification register.
d1283 1
a1283 1
        BL      ts_MoreText
d1304 1
a1304 1
; If this was a forced test (test adapter fitted) then pause even when
a1314 10

 [ IOMD_C_FrontPanelLED = (1<<7)
	; Define Long, Equal and short flash delays
ts_Long_Flash      	*	&03		; Number of 1/4 Sec delays for a long flash
ts_Short_Flash	   	*	&01		; Number of 1/4 Sec delays for a short flash
ts_Equal_Flash     	*	&02		; Number of 1/4 Sec delays for a equal flash
ts_Fail_Flash_Delay	*	&14		; Number of Flash Cycles for a Fail, with adaptor
ts_Pass_Flash_Delay	*	&0A		; Number of Flash Cycles for a Pass, with adaptor
 ]

d1324 1
a1324 1
        LDRNE   r9,=C_FAULT
d1337 1
a1337 1
        BCC     %B00                    ; - let the adapter recover
a1345 4
	; Here is r3 = 0, which ment a DUMP adaptor was present.
	;
	; Continue to the OS
	;
a1351 12
	;
	; Here if a Display or other type of adaptor found.
	;
 [ IOMD_C_FrontPanelLED = (1<<7)
	;
	; IOMD_C_FrontPanelLED  = 1<<7, therefore an NC
	;
	; Check to see if we are a PASS or FAIL
	;
        MOV_fiq r7,r12_fiq              	; check for fault bits set
        LDR     r0,=R_STATUS
        BICS    r0,r7,r0
d1353 3
a1355 117
	BEQ	ts_flash_leds_pass		; flash the leds to show a pass
						; flash the leds to show a failure
						; Fall through !

ts_flash_leds_fail
	;
	; Get here if the POST fails !
	;
	; Check for display adpator, if fitted, flash LED's for 20 times
	; else flash LEDs forever.
	;
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
        BNE	%FT19	                   	; Adaptor    : Goto 20 Flash loops Code
 	           				; No Adaptor : Goto Infinite flash loop Code
						; Fall through !
14
	; Infinite Flash loop
	; Register usage ....
	; 	r0, used by toggle leds & delay routines
	;	r1, used by toggle leds routine
	;
15	BL	ts_led_fail			; Call code to flash the leds
	B	%BT15				; Repeat forever.

19
	; Loop for specified time
	; Register usage ....
	; 	r0, used by toggle leds & delay routines
	;	r1, used by toggle leds routine
	;
	;	r3, Loop counter
	;       r4, Pass delay time to delay code.
	;
	MOV	r3,#ts_Fail_Flash_Delay		; Set the loop counter.
20	BL	ts_led_fail			; Call code to flash the leds
	SUBS	r3,r3,#1			; Decrment loop counter
	BNE	%BT20				; Repeat until r3 = 0
	BEQ	%FT50				; r3=0, were all done
						; Goto start the OS

ts_flash_leds_pass
	; Here if POST passed.
	; If adaptor fitted, flash the LEDs for a 10 secs
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
	BEQ	%FT50				; No Adaptor : Goto start the OS
                                       		; Adaptor    : Goto 10 Flash loops Code
						; Fall through !

	; Loop for specified time
	; Register usage ....
	; 	r0, used by toggle leds & delay routines
	;	r1, used by toggle leds routine
	;
	;	r3, Loop counter
	;       r4, Pass delay time to delay code.
	;
	MOV	r3,#ts_Pass_Flash_Delay		; Set the loop counter.
30	BL	ts_led_pass			; Call code to flash the leds
	SUBS	r3,r3,#1			; Decrment loop counter
	BNE	%BT30				; Repeat until r3 = 0
	BEQ	%FT50				; r3=0, were all done
						; Goto start the OS

ts_led_fail
	; Code to flash the LED's through one flash cycle (on-off)
	; This will take 1 Second to complete.
	;
	;|------>|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|
	;|--Red--|---Green---|----Red----|----Red----|----Red----|\
	;         \_______________________________________________/
	;
	;									Red	Green
	MOV	r13,r14				; make a note of where we	On	Off
						; came from.
	BL	tl_Toggle_LEDs			; Toggle the LEDs		Off	On
	MOV	r4,#ts_Short_Flash		; Load r4 with Short flash	Off	On
	BL	ld_LED_Delay			; call delay routine		Off	On
	BL	tl_Toggle_LEDs			; Toggle the LEDs		On	Off
	MOV	r4,#ts_Long_Flash		; load r4 with long flash	On	Off
	BL	ld_LED_Delay			; call delay routine		On	Off

	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.
ts_led_pass
	; Code to flash the LED's through one flash cycle (on-off)
	; This will take 1 Second to complete.
	;
	;|------>|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|--1/4 Sec--|
	;|--Red--|---Green---|---Green---|---Green---|----RED----|\
	;         \_______________________________________________/
	;
	;									Red	Green
	MOV	r13,r14				; make a note of where we	On	Off
						; came from.
	BL	tl_Toggle_LEDs			; Toggle the LEDs		Off	On
	MOV	r4,#ts_Long_Flash		; Load r4 with long flash	Off	On
	BL	ld_LED_Delay			; call delay routine		Off	On
	BL	tl_Toggle_LEDs			; Toggle the LEDs		On	Off
	MOV	r4,#ts_Short_Flash		; load r4 with short flash	On	Off
	BL	ld_LED_Delay			; call delay routine		On	Off

	MOV	pc,r13                          ; move r13 (r14) back to
						; where we came from.

50
	;
	; Continue on our way
	;
 |
	;
	; IOMD_C_FrontPanelLED  <> 1<<7, therefore not an NC
	;
	; Indicate fault found : Set the border to fault colour and flash
	; the disk LED, using the fault bitmap in r12_fiq to modulate the flashing.
	;
d1370 2
a1371 2
01
        MOV_fiq r6,r12_fiq
d1373 1
d1375 1
a1375 1
   [ IO_Type = "IOMD"
d1379 1
a1379 1
   |
d1387 1
a1387 1
   ]
d1389 3
a1391 2
02
	BL	ld_LED_Delay			; call delay routine
d1396 3
a1398 2
	BL	ld_LED_Delay			; call delay routine

d1401 3
a1403 2
	BL	ld_LED_Delay			; call delay routine }
	BL	ld_LED_Delay			; call delay routine } Half A Second
d1415 3
a1417 5
	BL	ld_LED_Delay			; call delay routine }
	BL	ld_LED_Delay			; call delay routine } One Seconds Worth
	BL	ld_LED_Delay			; call delay routine }
	BL	ld_LED_Delay			; call delay routine }

d1422 3
a1424 12
 ]
;
; Uncomment the following line if the POST code is to loop when the POST
; display adaptor (post box) is fitted.
;
;        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED) ; If the display adapter & test link are present,
;
; Comment thi line out if POST Code is to loop when the POST display
; adaptor (post box) is fitted.
;
        ANDS    r0,r0,# R_TESTED	; If the test link is present,
        BNE     Reset                   ; repeat the test forever
a1437 7
	[ DontShowProgressColours
        MOV_fiq r0,r12_fiq              	; restore the faultcode bits
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED)	; If test adapter present,
			                   	; NE : Adaptor fitted, show progress.
 	           				; EQ : No Adaptor fitted, don't show progress
	BEQ	ts_Softstart			; EQ : Don't show colours
	]
d1446 1
a1446 3
;
;
;
d1448 1
d1469 3
d1479 1
a1479 1
; Include test modules executed by call, rather than inline
a1488 5
        GET     TestSrc.ToggleLED
        GET     TestSrc.LEDDelay
	GET	TestSrc.ShowIOMDRs

	ALIGN	64		; JRH: Kernel seems happier if we do this!
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d39 1
a39 1
POSTenabled     SETL    {TRUE}          ; don't permit POST for ordinary startup
d42 1
a42 1
ts_Rom_length   *       1 :SHL: ts_Rom_bits             ; Longest ROM
d68 1
a68 1
        [ VIDC_Type = "VIDC20"
d101 1
a101 1
R_CAMFAILBIT    *       &400            ; CAM failed
d120 1
a120 1
; low memory addresses. The Reset vector will be copied to low RAM
d169 1
a169 1
ts_himsg
d230 1
a230 1
        B       ts_SendLCDCmd
d244 1
a244 1
; Note : the register order in ADDS ...pc.. is often critical.
d259 1
a259 1
        MACRO
d266 1
a266 1
        MACRO
d304 1
a304 1
        GBLA    OldOpt                  ; don't list all the walking
d343 1
a343 1
        WEND
d351 1
a351 1
        WEND
d378 1
a378 1
        &       ROM - pcfromstart
d394 1
a394 1
        LDR     r1,doffset+4            ; walking 0 data pattern
d417 1
a417 1
; External interface drivers -
d419 1
a419 1
; and to receive byte- and word-sized objects
d424 1
a424 1
;
d516 1
a516 1
02
d558 3
a560 4
        LDRB    r1, [r2, #IOMD_ROMCR0]
        AND     r1, r1, #&40            ; clear all but 16-bit mode bit
 [ :LNOT: AutoSpeedROMS
  [ NormalSpeedROMS
d562 1
a562 1
        ORR     r1, r1, #IOMD_ROMCR_Normal + IOMD_ROMCR_156 + IOMD_ROMCR_Burst93
d566 1
a566 1
  |
d568 1
a568 1
        ORR     r1, r1, #IOMD_ROMCR_Normal + IOMD_ROMCR_187 + IOMD_ROMCR_BurstOff
a570 6
  ]
        STRB    r1, [r2, #IOMD_ROMCR0]
        STRB    r1, [r2, #IOMD_ROMCR1]         ; and do the same for extension ROMs (just in case)
 |
        MOV     r0, #0                  ;Don't muck with the CPU coprocessor regs
        BL      TimeCPU                 ;This times the memory bus & sets the ROM speed accordingly
d572 2
d585 1
a585 1
        MOV     r2, #IOMD_Base
a606 9
 [ StrongARM
   ;just too horrible to fix POST for StrongARM (Architecture 4) at the moment
   ARM_read_ID r0
   AND     r0,r0,#&F000
   CMP     r0,#&A000              ;if we are a StrongARM...
   LDREQ   r0,=C_WARMSTART        ;the colour that indicates no POST performed
   STREQ   r0,[r1]
   BEQ     ts_Hardstart           ;RISC OS - right now!
 ]
d647 1
a647 1
                                        ; the ARM600 MMU as well.
d658 1
a658 1
2
d671 2
a672 2
; MemSize returns with  r0 = page size   (now in bytes, *NOT* in MEMC control patterns),
;                       r1 = memory size (in bytes)
d681 1
a681 1
        MODE    FIQ_mode                        ; Save memory size and
d707 1
a707 1
; Test IOC.
d710 1
a710 1
;
d762 1
a762 1
        B       %FT11
d779 1
a779 1
;
d853 2
a854 2
        BEQ     %25
        FAULT   #R_MEMSKIP              ; If set, skip the memory test
d859 1
a859 1
        ADR     r4,%BT2                 ; Report fault accessing IIC
d891 2
a892 2
; configuration. The memory speed can then be set up correctly for
; fastest possible working, and the memory array tested in the
d899 1
a899 1
; where ssss is the processor speed in hex kHz,
d901 2
a902 2
;       r    is the MEMC rom speed switch setting.
;
a922 1
        MOV     r0, #0                          ; Make sure TimeCPU doesn't fiddle with the cache
d928 1
a928 1
        TST     r7, #1 :SHL: 16                 ; test bit 16 of r7 :
d940 1
a940 1
;
d967 1
a967 1
; if (!R_LINFAILBIT)
d977 1
a977 1
        BL      ts_MoreText
d1029 1
a1029 1
;
d1037 1
a1037 1

d1090 2
a1091 2
; Then try out the protection bits in each CAM entry and various
; processor modes.
d1113 1
a1113 1
        BL      ts_MoreText
d1130 1
a1130 1
        BL      ts_MoreText
d1177 1
d1194 1
a1194 1
        ALIGN
d1232 1
a1232 1
        ]
d1258 1
a1258 1
; Read the ARM3 identification register.
d1283 1
a1283 1
        BL      ts_MoreText
d1304 1
a1304 1
; If this was a forced test (test adapter fitted) then pause even when
d1324 1
a1324 1
        LDRNE   r9,=C_FAULT
d1337 1
a1337 1
        BCC     %B00                    ; - let the adapter recover
d1354 1
a1354 1
; Indicate fault found : Set the border to the fault colour and flash
d1423 1
a1423 1
        ANDS    r0,r0,#(R_EXTERN :OR: R_TESTED) ; If test adapter present,
d1479 1
a1479 1
; Include test modules executed by call, rather than inline
@


4.1.3.2
log
@RISC OS 3.71 version taken
@
text
@a286 14
 [ StrongARM_POST
;  ensure 26-bit mode for StrongARM or ARM 8 (since there is no 26 bit configuration)
        MACRO
        Ensure26bit_ARM8A $tmp
        ARM_read_ID $tmp
        AND     $tmp, $tmp, #&F000
        CMP     $tmp, #&A000
        CMPNE   $tmp, #&8000
        mrs     EQ, $tmp, CPSR_all
        BICEQ   $tmp, $tmp, #&10
        msr     EQ, CPSR_all, $tmp
        MEND
  ]

d484 1
a484 1
; it's a power-on reset, so assume we can't be in 32-bit mode for ARM 6/7
a485 5
  [ StrongARM_POST
    ; make sure we are in 26-bit mode (ARM 6/7 reset in 26-bit config)
    ; note that MOV_fiq macro assumes 26-bit, so must sort this now
    Ensure26bit_ARM8A r0
  ]
a503 5
  [ StrongARM_POST
    ; make sure we are in 26-bit mode (ARM 6/7 reset in 26-bit config)
    ; note that MOV_fiq macro assumes 26-bit, so must sort this now
    Ensure26bit_ARM8A r0
  ]
a510 5
  [ StrongARM_POST
    ; make sure we are in 26-bit mode (ARM 6/7 reset in 26-bit config)
    ; note that MOV_fiq macro assumes 26-bit, so must sort this now
    Ensure26bit_ARM8A r4
  ]
d541 1
a541 1
        CMP     r0, #&E7
d543 2
a544 9
        CMPEQ   r0, #&D4
        BEQ     %FT10

 [ RO371Timings

        MOV     r0, #0                  ;Calling from POST
        BL      TimeCPU                 ;just sets things according to assumed bus speeds for each IOMD id, in this case

 | ; else if not RO371Timings
a559 1

a572 1

a578 3

 ] ;RO371Timings conditional

d612 8
a619 19
 [ :LNOT: StrongARM_POST
   ;skip POST for StrongARM or ARM8
        ARM_read_ID r0
        AND     r0,r0,#&F000
        CMP     r0,#&A000              ;if we are a StrongARM...
        CMPNE   r0,#&8000              ;or an ARM8...
        LDREQ   r0,=C_WARMSTART        ;the colour that indicates no POST performed
        STREQ   r0,[r1]
        BEQ     ts_Hardstart           ;RISC OS - right now!
 ]

 [ ARM810support :LAND: (:LNOT: ARM810_POST)
   ;just too horrible to fix POST for ARM 8 at the moment
        ARM_read_ID r0
        AND     r0,r0,#&F000
        CMP     r0,#&8000              ;if we are an ARM 8
        LDREQ   r0,=C_WARMSTART        ;the colour that indicates no POST performed
        STREQ   r0,[r1]
        BEQ     ts_Hardstart           ;RISC OS - right now!
a620 1

a1164 21

  [ StrongARM_POST
    ;make sure ARM810 cache or StrongARM data cache is cleaned/flushed, because we are going to remap
        ARM_read_ID r5
        AND     r5,r5,#&F000
        CMP     r5,#&8000
        BNE     %FT22
;ARM810
;;;        ARM8_cleanflush_IDC r5  ;not implemented yet
        B       %FT24
22
        CMP     r5,#&A000
        BNE     %FT24
;StrongARM
;tricky...we'll read 16k of data in current ROM space, to act as clean and flush of current data
        MOV     r3,pc
        BIC     r3,r3,#31      ;32 byte aligned
        ARMA_clean_DC r3,r5,r7
24
  ] ;StrongARM_POST

a1176 11
  [ StrongARM_POST
    ;flush cache if ARM 6/7 (ARM 8,StrongARM already sorted, above)
    ;flush TLB(s)
        ARM_read_ID r4
        AND      r4,r4,#&F000
        CMP      r4,#&8000   ;ARM 8?
        CMPNE    r4,#&A000   ;or StrongARM?
        MCRNE    ARM_config_cp,0,R0,ARM67_cacheflush_reg,C0,0   ;flush 6/7 cache
        MCRNE    ARM_config_cp,0,R0,ARM67_TLBflush_reg,C0,0     ;flush 6/7 TLB
        MCREQ    ARM_config_cp,0,R0,ARM8A_TLB_reg,C7,0          ;flush 8/StrongARM TLB(s)
  |
a1178 1
  ]
d1187 1
a1187 2
; now turn the MMU off, also ensures 26 bit mode, if ARM 6/7 (since P bit zero)
        MOV     r7, #MMUC_D
a1189 5
  [ StrongARM_POST
        Ensure26bit_ARM8A r7
        MOV     r7, #MMUC_D    ;avoid corrupting r7, just in case
  ]

d1226 1
a1226 1
        CMP     r0, #&E7
d1228 2
a1229 2
        CMPEQ   r0, #&D4                ; skip Virq test on Morris
        BNE     %FT10
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@a286 14
 [ StrongARM_POST
;  ensure 26-bit mode for StrongARM or ARM 8 (since there is no 26 bit configuration)
        MACRO
        Ensure26bit_ARM8A $tmp
        ARM_read_ID $tmp
        AND     $tmp, $tmp, #&F000
        CMP     $tmp, #&A000
        CMPNE   $tmp, #&8000
        mrs     EQ, $tmp, CPSR_all
        BICEQ   $tmp, $tmp, #&10
        msr     EQ, CPSR_all, $tmp
        MEND
  ]

d484 1
a484 1
; it's a power-on reset, so assume we can't be in 32-bit mode for ARM 6/7
a485 5
  [ StrongARM_POST
    ; make sure we are in 26-bit mode (ARM 6/7 reset in 26-bit config)
    ; note that MOV_fiq macro assumes 26-bit, so must sort this now
    Ensure26bit_ARM8A r0
  ]
a503 5
  [ StrongARM_POST
    ; make sure we are in 26-bit mode (ARM 6/7 reset in 26-bit config)
    ; note that MOV_fiq macro assumes 26-bit, so must sort this now
    Ensure26bit_ARM8A r0
  ]
a510 5
  [ StrongARM_POST
    ; make sure we are in 26-bit mode (ARM 6/7 reset in 26-bit config)
    ; note that MOV_fiq macro assumes 26-bit, so must sort this now
    Ensure26bit_ARM8A r4
  ]
d541 1
a541 1
        CMP     r0, #&E7
d543 2
a544 9
        CMPEQ   r0, #&D4
        BEQ     %FT10

 [ RO371Timings

        MOV     r0, #0                  ;Calling from POST
        BL      TimeCPU                 ;just sets things according to assumed bus speeds for each IOMD id, in this case

 | ; else if not RO371Timings
a559 1

a572 1

a578 3

 ] ;RO371Timings conditional

d612 8
a619 19
 [ :LNOT: StrongARM_POST
   ;skip POST for StrongARM or ARM8
        ARM_read_ID r0
        AND     r0,r0,#&F000
        CMP     r0,#&A000              ;if we are a StrongARM...
        CMPNE   r0,#&8000              ;or an ARM8...
        LDREQ   r0,=C_WARMSTART        ;the colour that indicates no POST performed
        STREQ   r0,[r1]
        BEQ     ts_Hardstart           ;RISC OS - right now!
 ]

 [ ARM810support :LAND: (:LNOT: ARM810_POST)
   ;just too horrible to fix POST for ARM 8 at the moment
        ARM_read_ID r0
        AND     r0,r0,#&F000
        CMP     r0,#&8000              ;if we are an ARM 8
        LDREQ   r0,=C_WARMSTART        ;the colour that indicates no POST performed
        STREQ   r0,[r1]
        BEQ     ts_Hardstart           ;RISC OS - right now!
a620 1

a1164 21

  [ StrongARM_POST
    ;make sure ARM810 cache or StrongARM data cache is cleaned/flushed, because we are going to remap
        ARM_read_ID r5
        AND     r5,r5,#&F000
        CMP     r5,#&8000
        BNE     %FT22
;ARM810
;;;        ARM8_cleanflush_IDC r5  ;not implemented yet
        B       %FT24
22
        CMP     r5,#&A000
        BNE     %FT24
;StrongARM
;tricky...we'll read 16k of data in current ROM space, to act as clean and flush of current data
        MOV     r3,pc
        BIC     r3,r3,#31      ;32 byte aligned
        ARMA_clean_DC r3,r5,r7
24
  ] ;StrongARM_POST

a1176 11
  [ StrongARM_POST
    ;flush cache if ARM 6/7 (ARM 8,StrongARM already sorted, above)
    ;flush TLB(s)
        ARM_read_ID r4
        AND      r4,r4,#&F000
        CMP      r4,#&8000   ;ARM 8?
        CMPNE    r4,#&A000   ;or StrongARM?
        MCRNE    ARM_config_cp,0,R0,ARM67_cacheflush_reg,C0,0   ;flush 6/7 cache
        MCRNE    ARM_config_cp,0,R0,ARM67_TLBflush_reg,C0,0     ;flush 6/7 TLB
        MCREQ    ARM_config_cp,0,R0,ARM8A_TLB_reg,C7,0          ;flush 8/StrongARM TLB(s)
  |
a1178 1
  ]
d1187 1
a1187 2
; now turn the MMU off, also ensures 26 bit mode, if ARM 6/7 (since P bit zero)
        MOV     r7, #MMUC_D
a1189 5
  [ StrongARM_POST
        Ensure26bit_ARM8A r7
        MOV     r7, #MMUC_D    ;avoid corrupting r7, just in case
  ]

d1226 1
a1226 1
        CMP     r0, #&E7
d1228 2
a1229 2
        CMPEQ   r0, #&D4                ; skip Virq test on Morris
        BNE     %FT10
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

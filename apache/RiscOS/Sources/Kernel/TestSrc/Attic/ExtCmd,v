head	4.3;
access;
symbols
	HAL_merge:4.1.10.1
	Kernel-5_48:4.2
	Kernel-5_35-4_79_2_327:4.1.10.1
	Kernel-5_35-4_79_2_326:4.1.10.1
	Kernel-5_35-4_79_2_325:4.1.10.1
	Kernel-5_35-4_79_2_324:4.1.10.1
	Kernel-5_35-4_79_2_323:4.1.10.1
	Kernel-5_35-4_79_2_322:4.1.10.1
	Kernel-5_35-4_79_2_321:4.1.10.1
	Kernel-5_35-4_79_2_320:4.1.10.1
	Kernel-5_35-4_79_2_319:4.1.10.1
	Kernel-5_35-4_79_2_318:4.1.10.1
	Kernel-5_35-4_79_2_317:4.1.10.1
	Kernel-5_35-4_79_2_316:4.1.10.1
	Kernel-5_35-4_79_2_315:4.1.10.1
	Kernel-5_35-4_79_2_314:4.1.10.1
	Kernel-5_35-4_79_2_313:4.1.10.1
	Kernel-5_35-4_79_2_312:4.1.10.1
	Kernel-5_35-4_79_2_311:4.1.10.1
	Kernel-5_35-4_79_2_310:4.1.10.1
	Kernel-5_35-4_79_2_309:4.1.10.1
	Kernel-5_35-4_79_2_308:4.1.10.1
	Kernel-5_35-4_79_2_307:4.1.10.1
	Kernel-5_35-4_79_2_306:4.1.10.1
	Kernel-5_35-4_79_2_305:4.1.10.1
	Kernel-5_35-4_79_2_304:4.1.10.1
	Kernel-5_35-4_79_2_303:4.1.10.1
	Kernel-5_35-4_79_2_302:4.1.10.1
	Kernel-5_35-4_79_2_301:4.1.10.1
	Kernel-5_35-4_79_2_300:4.1.10.1
	Kernel-5_35-4_79_2_299:4.1.10.1
	Kernel-5_35-4_79_2_298:4.1.10.1
	Kernel-5_35-4_79_2_297:4.1.10.1
	Kernel-5_35-4_79_2_296:4.1.10.1
	Kernel-5_35-4_79_2_295:4.1.10.1
	Kernel-5_35-4_79_2_294:4.1.10.1
	Kernel-5_35-4_79_2_293:4.1.10.1
	Kernel-5_35-4_79_2_292:4.1.10.1
	Kernel-5_35-4_79_2_291:4.1.10.1
	Kernel-5_35-4_79_2_290:4.1.10.1
	Kernel-5_35-4_79_2_289:4.1.10.1
	Kernel-5_35-4_79_2_288:4.1.10.1
	Kernel-5_35-4_79_2_287:4.1.10.1
	Kernel-5_35-4_79_2_286:4.1.10.1
	Kernel-5_35-4_79_2_285:4.1.10.1
	Kernel-5_35-4_79_2_284:4.1.10.1
	Kernel-5_35-4_79_2_283:4.1.10.1
	Kernel-5_35-4_79_2_282:4.1.10.1
	Kernel-5_35-4_79_2_281:4.1.10.1
	Kernel-5_35-4_79_2_280:4.1.10.1
	Kernel-5_35-4_79_2_279:4.1.10.1
	Kernel-5_35-4_79_2_278:4.1.10.1
	Kernel-5_35-4_79_2_277:4.1.10.1
	Kernel-5_35-4_79_2_276:4.1.10.1
	Kernel-5_35-4_79_2_275:4.1.10.1
	Kernel-5_35-4_79_2_274:4.1.10.1
	Kernel-5_35-4_79_2_273:4.1.10.1
	Kernel-5_35-4_79_2_272:4.1.10.1
	Kernel-5_35-4_79_2_271:4.1.10.1
	Kernel-5_35-4_79_2_270:4.1.10.1
	Kernel-5_35-4_79_2_269:4.1.10.1
	Kernel-5_35-4_79_2_268:4.1.10.1
	Kernel-5_35-4_79_2_267:4.1.10.1
	Kernel-5_35-4_79_2_266:4.1.10.1
	Kernel-5_35-4_79_2_265:4.1.10.1
	Kernel-5_35-4_79_2_264:4.1.10.1
	Kernel-5_35-4_79_2_263:4.1.10.1
	Kernel-5_35-4_79_2_262:4.1.10.1
	Kernel-5_35-4_79_2_261:4.1.10.1
	Kernel-5_35-4_79_2_260:4.1.10.1
	Kernel-5_35-4_79_2_259:4.1.10.1
	Kernel-5_35-4_79_2_258:4.1.10.1
	Kernel-5_35-4_79_2_257:4.1.10.1
	Kernel-5_35-4_79_2_256:4.1.10.1
	Kernel-5_35-4_79_2_255:4.1.10.1
	Kernel-5_35-4_79_2_254:4.1.10.1
	Kernel-5_35-4_79_2_253:4.1.10.1
	Kernel-5_35-4_79_2_252:4.1.10.1
	Kernel-5_35-4_79_2_251:4.1.10.1
	Kernel-5_35-4_79_2_250:4.1.10.1
	Kernel-5_35-4_79_2_249:4.1.10.1
	Kernel-5_35-4_79_2_248:4.1.10.1
	Kernel-5_35-4_79_2_247:4.1.10.1
	Kernel-5_35-4_79_2_246:4.1.10.1
	Kernel-5_35-4_79_2_245:4.1.10.1
	Kernel-5_35-4_79_2_244:4.1.10.1
	Kernel-5_35-4_79_2_243:4.1.10.1
	Kernel-5_35-4_79_2_242:4.1.10.1
	Kernel-5_35-4_79_2_241:4.1.10.1
	Kernel-5_35-4_79_2_240:4.1.10.1
	Kernel-5_35-4_79_2_239:4.1.10.1
	Kernel-5_35-4_79_2_238:4.1.10.1
	Kernel-5_35-4_79_2_237:4.1.10.1
	Kernel-5_35-4_79_2_236:4.1.10.1
	Kernel-5_35-4_79_2_235:4.1.10.1
	Kernel-5_35-4_79_2_234:4.1.10.1
	Kernel-5_35-4_79_2_233:4.1.10.1
	Kernel-5_35-4_79_2_232:4.1.10.1
	Kernel-5_35-4_79_2_231:4.1.10.1
	Kernel-5_35-4_79_2_230:4.1.10.1
	Kernel-5_35-4_79_2_229:4.1.10.1
	Kernel-5_35-4_79_2_228:4.1.10.1
	Kernel-5_35-4_79_2_227:4.1.10.1
	Kernel-5_35-4_79_2_226:4.1.10.1
	Kernel-5_35-4_79_2_225:4.1.10.1
	Kernel-5_35-4_79_2_224:4.1.10.1
	Kernel-5_35-4_79_2_223:4.1.10.1
	Kernel-5_35-4_79_2_222:4.1.10.1
	Kernel-5_35-4_79_2_221:4.1.10.1
	Kernel-5_35-4_79_2_220:4.1.10.1
	Kernel-5_35-4_79_2_219:4.1.10.1
	Kernel-5_35-4_79_2_218:4.1.10.1
	Kernel-5_35-4_79_2_217:4.1.10.1
	Kernel-5_35-4_79_2_216:4.1.10.1
	Kernel-5_35-4_79_2_215:4.1.10.1
	Kernel-5_35-4_79_2_214:4.1.10.1
	Kernel-5_35-4_79_2_213:4.1.10.1
	Kernel-5_35-4_79_2_212:4.1.10.1
	Kernel-5_35-4_79_2_211:4.1.10.1
	Kernel-5_35-4_79_2_210:4.1.10.1
	Kernel-5_35-4_79_2_209:4.1.10.1
	Kernel-5_35-4_79_2_208:4.1.10.1
	Kernel-5_35-4_79_2_207:4.1.10.1
	Kernel-5_35-4_79_2_206:4.1.10.1
	Kernel-5_35-4_79_2_205:4.1.10.1
	Kernel-5_35-4_79_2_204:4.1.10.1
	Kernel-5_35-4_79_2_203:4.1.10.1
	Kernel-5_35-4_79_2_202:4.1.10.1
	Kernel-5_35-4_79_2_201:4.1.10.1
	Kernel-5_35-4_79_2_200:4.1.10.1
	Kernel-5_35-4_79_2_199:4.1.10.1
	Kernel-5_35-4_79_2_198:4.1.10.1
	Kernel-5_35-4_79_2_197:4.1.10.1
	Kernel-5_35-4_79_2_196:4.1.10.1
	Kernel-5_35-4_79_2_195:4.1.10.1
	Kernel-5_35-4_79_2_194:4.1.10.1
	Kernel-5_35-4_79_2_193:4.1.10.1
	Kernel-5_35-4_79_2_192:4.1.10.1
	Kernel-5_35-4_79_2_191:4.1.10.1
	Kernel-5_35-4_79_2_190:4.1.10.1
	Kernel-5_35-4_79_2_189:4.1.10.1
	Kernel-5_35-4_79_2_188:4.1.10.1
	Kernel-5_35-4_79_2_187:4.1.10.1
	Kernel-5_35-4_79_2_186:4.1.10.1
	Kernel-5_35-4_79_2_185:4.1.10.1
	Kernel-5_35-4_79_2_184:4.1.10.1
	Kernel-5_35-4_79_2_183:4.1.10.1
	Kernel-5_35-4_79_2_182:4.1.10.1
	Kernel-5_35-4_79_2_181:4.1.10.1
	Kernel-5_35-4_79_2_180:4.1.10.1
	Kernel-5_35-4_79_2_179:4.1.10.1
	Kernel-5_35-4_79_2_178:4.1.10.1
	Kernel-5_35-4_79_2_177:4.1.10.1
	Kernel-5_35-4_79_2_176:4.1.10.1
	Kernel-5_35-4_79_2_175:4.1.10.1
	Kernel-5_35-4_79_2_174:4.1.10.1
	Kernel-5_35-4_79_2_173:4.1.10.1
	Kernel-5_35-4_79_2_172:4.1.10.1
	Kernel-5_35-4_79_2_171:4.1.10.1
	Kernel-5_35-4_79_2_170:4.1.10.1
	Kernel-5_35-4_79_2_169:4.1.10.1
	Kernel-5_35-4_79_2_168:4.1.10.1
	Kernel-5_35-4_79_2_167:4.1.10.1
	Kernel-5_35-4_79_2_166:4.1.10.1
	Kernel-5_35-4_79_2_165:4.1.10.1
	RPi_merge:4.1.10.1
	Kernel-5_35-4_79_2_147_2_23:4.1.10.1
	Kernel-5_35-4_79_2_147_2_22:4.1.10.1
	Kernel-5_35-4_79_2_147_2_21:4.1.10.1
	Kernel-5_35-4_79_2_147_2_20:4.1.10.1
	Kernel-5_35-4_79_2_147_2_19:4.1.10.1
	Kernel-5_35-4_79_2_147_2_18:4.1.10.1
	Kernel-5_35-4_79_2_164:4.1.10.1
	Kernel-5_35-4_79_2_163:4.1.10.1
	Kernel-5_35-4_79_2_147_2_17:4.1.10.1
	Kernel-5_35-4_79_2_147_2_16:4.1.10.1
	Kernel-5_35-4_79_2_147_2_15:4.1.10.1
	Kernel-5_35-4_79_2_162:4.1.10.1
	Kernel-5_35-4_79_2_161:4.1.10.1
	Kernel-5_35-4_79_2_147_2_14:4.1.10.1
	Kernel-5_35-4_79_2_147_2_13:4.1.10.1
	Kernel-5_35-4_79_2_160:4.1.10.1
	Kernel-5_35-4_79_2_159:4.1.10.1
	Kernel-5_35-4_79_2_158:4.1.10.1
	Kernel-5_35-4_79_2_157:4.1.10.1
	Kernel-5_35-4_79_2_156:4.1.10.1
	Kernel-5_35-4_79_2_147_2_12:4.1.10.1
	Kernel-5_35-4_79_2_147_2_11:4.1.10.1
	Kernel-5_35-4_79_2_155:4.1.10.1
	Kernel-5_35-4_79_2_147_2_10:4.1.10.1
	Kernel-5_35-4_79_2_154:4.1.10.1
	Kernel-5_35-4_79_2_153:4.1.10.1
	Kernel-5_35-4_79_2_147_2_9:4.1.10.1
	Kernel-5_35-4_79_2_152:4.1.10.1
	Kernel-5_35-4_79_2_151:4.1.10.1
	Kernel-5_35-4_79_2_147_2_8:4.1.10.1
	Kernel-5_35-4_79_2_147_2_7:4.1.10.1
	Kernel-5_35-4_79_2_150:4.1.10.1
	Kernel-5_35-4_79_2_147_2_6:4.1.10.1
	Kernel-5_35-4_79_2_147_2_5:4.1.10.1
	Kernel-5_35-4_79_2_149:4.1.10.1
	Kernel-5_35-4_79_2_147_2_4:4.1.10.1
	Kernel-5_35-4_79_2_147_2_3:4.1.10.1
	Kernel-5_35-4_79_2_148:4.1.10.1
	Kernel-5_35-4_79_2_147_2_2:4.1.10.1
	Kernel-5_35-4_79_2_147_2_1:4.1.10.1
	RPi:4.1.10.1.0.6
	RPi_bp:4.1.10.1
	Kernel-5_35-4_79_2_98_2_52_2_1:4.1.10.1
	alees_Kernel_dev:4.1.10.1.0.4
	alees_Kernel_dev_bp:4.1.10.1
	Kernel-5_35-4_79_2_147:4.1.10.1
	Kernel-5_35-4_79_2_146:4.1.10.1
	Kernel-5_35-4_79_2_145:4.1.10.1
	Kernel-5_35-4_79_2_144:4.1.10.1
	Kernel-5_35-4_79_2_143:4.1.10.1
	Kernel-5_35-4_79_2_142:4.1.10.1
	Kernel-5_35-4_79_2_141:4.1.10.1
	Kernel-5_35-4_79_2_140:4.1.10.1
	Kernel-5_35-4_79_2_139:4.1.10.1
	Kernel-5_35-4_79_2_138:4.1.10.1
	Kernel-5_35-4_79_2_137:4.1.10.1
	Kernel-5_35-4_79_2_136:4.1.10.1
	Kernel-5_35-4_79_2_135:4.1.10.1
	Kernel-5_35-4_79_2_134:4.1.10.1
	Kernel-5_35-4_79_2_133:4.1.10.1
	Kernel-5_35-4_79_2_132:4.1.10.1
	Kernel-5_35-4_79_2_131:4.1.10.1
	Kernel-5_35-4_79_2_130:4.1.10.1
	Kernel-5_35-4_79_2_129:4.1.10.1
	Kernel-5_35-4_79_2_128:4.1.10.1
	Kernel-5_35-4_79_2_127:4.1.10.1
	Kernel-5_35-4_79_2_126:4.1.10.1
	Kernel-5_35-4_79_2_125:4.1.10.1
	Kernel-5_35-4_79_2_124:4.1.10.1
	Kernel-5_35-4_79_2_123:4.1.10.1
	Cortex_merge:4.1.10.1
	Kernel-5_35-4_79_2_122:4.1.10.1
	Kernel-5_35-4_79_2_98_2_54:4.1.10.1
	Kernel-5_35-4_79_2_98_2_53:4.1.10.1
	Kernel-5_35-4_79_2_98_2_52:4.1.10.1
	Kernel-5_35-4_79_2_98_2_51:4.1.10.1
	Kernel-5_35-4_79_2_98_2_50:4.1.10.1
	Kernel-5_35-4_79_2_98_2_49:4.1.10.1
	Kernel-5_35-4_79_2_98_2_48:4.1.10.1
	Kernel-5_35-4_79_2_121:4.1.10.1
	Kernel-5_35-4_79_2_98_2_47:4.1.10.1
	Kernel-5_35-4_79_2_120:4.1.10.1
	Kernel-5_35-4_79_2_98_2_46:4.1.10.1
	Kernel-5_35-4_79_2_119:4.1.10.1
	Kernel-5_35-4_79_2_98_2_45:4.1.10.1
	Kernel-5_35-4_79_2_98_2_44:4.1.10.1
	Kernel-5_35-4_79_2_118:4.1.10.1
	Kernel-5_35-4_79_2_98_2_43:4.1.10.1
	Kernel-5_35-4_79_2_117:4.1.10.1
	Kernel-5_35-4_79_2_116:4.1.10.1
	Kernel-5_35-4_79_2_98_2_42:4.1.10.1
	Kernel-5_35-4_79_2_115:4.1.10.1
	Kernel-5_35-4_79_2_98_2_41:4.1.10.1
	Kernel-5_35-4_79_2_98_2_40:4.1.10.1
	Kernel-5_35-4_79_2_114:4.1.10.1
	Kernel-5_35-4_79_2_98_2_39:4.1.10.1
	Kernel-5_35-4_79_2_98_2_38:4.1.10.1
	Kernel-5_35-4_79_2_113:4.1.10.1
	Kernel-5_35-4_79_2_112:4.1.10.1
	Kernel-5_35-4_79_2_98_2_37:4.1.10.1
	Kernel-5_35-4_79_2_98_2_36:4.1.10.1
	Kernel-5_35-4_79_2_98_2_35:4.1.10.1
	Kernel-5_35-4_79_2_98_2_34:4.1.10.1
	Kernel-5_35-4_79_2_98_2_33:4.1.10.1
	Kernel-5_35-4_79_2_98_2_32:4.1.10.1
	Kernel-5_35-4_79_2_98_2_31:4.1.10.1
	Kernel-5_35-4_79_2_98_2_30:4.1.10.1
	Kernel-5_35-4_79_2_98_2_29:4.1.10.1
	Kernel-5_35-4_79_2_98_2_28:4.1.10.1
	Kernel-5_35-4_79_2_98_2_27:4.1.10.1
	Kernel-5_35-4_79_2_98_2_26:4.1.10.1
	Kernel-5_35-4_79_2_111:4.1.10.1
	Kernel-5_35-4_79_2_98_2_25:4.1.10.1
	Kernel-5_35-4_79_2_98_2_24:4.1.10.1
	Kernel-5_35-4_79_2_98_2_23:4.1.10.1
	Kernel-5_35-4_79_2_110:4.1.10.1
	Kernel-5_35-4_79_2_98_2_22:4.1.10.1
	Kernel-5_35-4_79_2_109:4.1.10.1
	Kernel-5_35-4_79_2_98_2_21:4.1.10.1
	Kernel-5_35-4_79_2_98_2_20:4.1.10.1
	Kernel-5_35-4_79_2_108:4.1.10.1
	Kernel-5_35-4_79_2_107:4.1.10.1
	Kernel-5_35-4_79_2_98_2_19:4.1.10.1
	Kernel-5_35-4_79_2_98_2_18:4.1.10.1
	Kernel-5_35-4_79_2_98_2_17:4.1.10.1
	Kernel-5_35-4_79_2_98_2_16:4.1.10.1
	Kernel-5_35-4_79_2_98_2_15:4.1.10.1
	Kernel-5_35-4_79_2_106:4.1.10.1
	Kernel-5_35-4_79_2_105:4.1.10.1
	Kernel-5_35-4_79_2_104:4.1.10.1
	Kernel-5_35-4_79_2_98_2_14:4.1.10.1
	Kernel-5_35-4_79_2_98_2_13:4.1.10.1
	Kernel-5_35-4_79_2_98_2_12:4.1.10.1
	Kernel-5_35-4_79_2_98_2_11:4.1.10.1
	Kernel-5_35-4_79_2_98_2_10:4.1.10.1
	Kernel-5_35-4_79_2_98_2_9:4.1.10.1
	Kernel-5_35-4_79_2_103:4.1.10.1
	Kernel-5_35-4_79_2_102:4.1.10.1
	Kernel-5_35-4_79_2_98_2_8:4.1.10.1
	Kernel-5_35-4_79_2_98_2_7:4.1.10.1
	Kernel-5_35-4_79_2_98_2_6:4.1.10.1
	Kernel-5_35-4_79_2_98_2_5:4.1.10.1
	Kernel-5_35-4_79_2_98_2_4:4.1.10.1
	Kernel-5_35-4_79_2_101:4.1.10.1
	Kernel-5_35-4_79_2_100:4.1.10.1
	Kernel-5_35-4_79_2_99:4.1.10.1
	Kernel-5_35-4_79_2_98_2_3:4.1.10.1
	Kernel-5_35-4_79_2_98_2_2:4.1.10.1
	Kernel-5_35-4_79_2_98_2_1:4.1.10.1
	Cortex:4.1.10.1.0.2
	Cortex_bp:4.1.10.1
	Kernel-5_35-4_79_2_98:4.1.10.1
	Kernel-5_35-4_79_2_97:4.1.10.1
	Kernel-5_35-4_79_2_96:4.1.10.1
	Kernel-5_35-4_79_2_95:4.1.10.1
	Kernel-5_35-4_79_2_94:4.1.10.1
	Kernel-5_35-4_79_2_93:4.1.10.1
	Kernel-5_35-4_79_2_92:4.1.10.1
	Kernel-5_35-4_79_2_91:4.1.10.1
	Kernel-5_35-4_79_2_90:4.1.10.1
	Kernel-5_35-4_79_2_89:4.1.10.1
	Kernel-5_35-4_79_2_88:4.1.10.1
	Kernel-5_35-4_79_2_87:4.1.10.1
	Kernel-5_35-4_79_2_86:4.1.10.1
	Kernel-5_35-4_79_2_85:4.1.10.1
	Kernel-5_35-4_79_2_84:4.1.10.1
	Kernel-5_35-4_79_2_83:4.1.10.1
	Kernel-5_35-4_79_2_82:4.1.10.1
	Kernel-5_35-4_79_2_81:4.1.10.1
	Kernel-5_35-4_79_2_80:4.1.10.1
	Kernel-5_35-4_79_2_79:4.1.10.1
	Kernel-5_35-4_79_2_78:4.1.10.1
	Kernel-5_35-4_79_2_77:4.1.10.1
	RO_5_07:4.1.10.1
	Kernel-5_35-4_79_2_76:4.1.10.1
	Kernel-5_35-4_79_2_75:4.1.10.1
	Kernel-5_35-4_79_2_74:4.1.10.1
	Kernel-5_35-4_79_2_73:4.1.10.1
	Kernel-5_35-4_79_2_72:4.1.10.1
	Kernel-5_35-4_79_2_71:4.1.10.1
	Kernel-5_35-4_79_2_70:4.1.10.1
	Kernel-5_35-4_79_2_69:4.1.10.1
	Kernel-5_35-4_79_2_68:4.1.10.1
	Kernel-5_35-4_79_2_67:4.1.10.1
	Kernel-5_35-4_79_2_66:4.1.10.1
	Kernel-5_35-4_79_2_65:4.1.10.1
	Kernel-5_35-4_79_2_64:4.1.10.1
	Kernel-5_35-4_79_2_63:4.1.10.1
	Kernel-5_35-4_79_2_62:4.1.10.1
	Kernel-5_35-4_79_2_61:4.1.10.1
	Kernel-5_35-4_79_2_59:4.1.10.1
	Kernel-5_35-4_79_2_58:4.1.10.1
	Kernel-5_35-4_79_2_57:4.1.10.1
	Kernel-5_35-4_79_2_56:4.1.10.1
	Kernel-5_35-4_79_2_55:4.1.10.1
	Kernel-5_35-4_79_2_54:4.1.10.1
	Kernel-5_35-4_79_2_53:4.1.10.1
	Kernel-5_35-4_79_2_52:4.1.10.1
	Kernel-5_35-4_79_2_51:4.1.10.1
	Kernel-5_35-4_79_2_50:4.1.10.1
	Kernel-5_35-4_79_2_49:4.1.10.1
	Kernel-5_35-4_79_2_48:4.1.10.1
	Kernel-5_47:4.1
	Kernel-5_46-4_90_2_1:4.1
	nbingham_Kernel_FastNC_dev_bp:4.1
	nbingham_Kernel_FastNC_dev:4.1.0.14
	Kernel-5_46:4.1
	Kernel-5_45:4.1
	Kernel-5_35-4_79_2_47:4.1.10.1
	Kernel-5_35-4_79_2_46:4.1.10.1
	Kernel-5_35-4_79_2_45:4.1.10.1
	Kernel-5_35-4_79_2_44:4.1.10.1
	Kernel-5_35-4_79_2_25_2_2:4.1.10.1
	Kernel-5_35-4_79_2_43:4.1.10.1
	Kernel-5_35-4_79_2_42:4.1.10.1
	Kernel-5_35-4_79_2_41:4.1.10.1
	Kernel-5_35-4_79_2_40:4.1.10.1
	Kernel-5_35-4_79_2_39:4.1.10.1
	Kernel-5_35-4_79_2_38:4.1.10.1
	Kernel-5_35-4_79_2_37:4.1.10.1
	Kernel-5_35-4_79_2_36:4.1.10.1
	Kernel-5_35-4_79_2_35:4.1.10.1
	Kernel-5_35-4_79_2_34:4.1.10.1
	Kernel-5_35-4_79_2_33:4.1.10.1
	Kernel-5_35-4_79_2_32:4.1.10.1
	Kernel-5_44:4.1
	Kernel-5_35-4_79_2_25_2_1:4.1.10.1
	Kernel-5_43:4.1
	Kernel-5_35-4_79_2_31:4.1.10.1
	Kernel-5_35-4_79_2_30:4.1.10.1
	Kernel-5_35-4_79_2_29:4.1.10.1
	Kernel-5_35-4_79_2_28:4.1.10.1
	Kernel-5_35-4_79_2_27:4.1.10.1
	Kernel-5_35-4_79_2_26:4.1.10.1
	Kernel-5_42:4.1
	Kernel-5_41:4.1
	Kernel-5_40:4.1
	Kernel-5_35-4_79_2_25:4.1.10.1
	Kernel-5_35-4_79_2_24:4.1.10.1
	Kernel-5_35-4_79_2_23:4.1.10.1
	Kernel-5_35-4_79_2_22:4.1.10.1
	Kernel-5_35-4_79_2_21:4.1.10.1
	Kernel-5_35-4_79_2_20:4.1.10.1
	Kernel-5_35-4_79_2_19:4.1.10.1
	Kernel-5_35-4_79_2_18:4.1.10.1
	Kernel-5_35-4_79_2_17:4.1.10.1
	Kernel-5_35-4_79_2_16:4.1.10.1
	Kernel-5_35-4_79_2_15:4.1.10.1
	Kernel-5_35-4_79_2_14:4.1.10.1
	Kernel-5_39:4.1
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.12
	Kernel-5_38:4.1
	Kernel-5_35-4_79_2_13:4.1.10.1
	Kernel-5_35-4_79_2_12:4.1.10.1
	Kernel-5_35-4_79_2_11:4.1.10.1
	Kernel-5_37:4.1
	Kernel-5_35-4_79_2_10:4.1.10.1
	Kernel-5_35-4_79_2_9:4.1.10.1
	Kernel-5_36:4.1
	Kernel-5_35-4_79_2_8:4.1.10.1
	Kernel-5_35-4_79_2_7:4.1.10.1
	Kernel-5_35-4_79_2_6:4.1.10.1
	Kernel-5_35-4_79_2_5:4.1.10.1
	Kernel-5_35-4_79_2_4:4.1.10.1
	Kernel-5_35-4_79_2_3:4.1.10.1
	Kernel-5_35-4_79_2_2:4.1.10.1
	dellis_autobuild_BaseSW:4.1
	Kernel-5_35-4_79_2_1:4.1.10.1
	HAL:4.1.0.10
	Kernel-5_35:4.1
	Kernel-5_34:4.1
	Kernel-5_33:4.1
	Kernel-5_32:4.1
	Kernel-5_31:4.1
	Kernel-5_30:4.1
	Kernel-5_29:4.1
	Kernel-5_28:4.1
	Kernel-5_27:4.1
	Kernel-5_26:4.1
	Kernel-5_25:4.1
	Kernel-5_24:4.1
	Kernel-5_23:4.1
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.1
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1
	Ursula_RiscPC_bp:4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	mstphens_Kernel-3_80:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2016.06.30.20.28.47;	author jlee;	state dead;
branches;
next	4.2;
commitid	lMnWzoE9eJz3Wwcz;

4.2
date	2016.06.30.20.07.52;	author jlee;	state Exp;
branches;
next	4.1;
commitid	IWoXxARWeuLDOwcz;

4.1
date	96.11.05.09.41.44;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.10.1;
next	;

4.1.1.1
date	96.11.05.09.41.44;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.04.19;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.54;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.05.10;	author nturton;	state Exp;
branches;
next	;

4.1.10.1
date	2000.09.15.12.38.00;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; > TestSrc.ExtCmd

        TTL RISC OS 2+ POST external commands
;
; External test commands for RISC OS ROM.
;
; Provides functions to read data, write data and execute code using
; parameters from an external controlling host.
;
; A minimal set of opcodes should be used (ideally, only B, LDR and ADDS)
; so that a processor test may be validly included in the internal test
; sequence.
;
;------------------------------------------------------------------------
; History
;
; Date          Name            Comment
; ----          ----            -------
; 27-Nov-89     ArtG            Initial version
; 06-Dec-89     ArtG            Release 0.2 for integration
; 30-Mar-90	ArtG		Added NOPs (ADDS r0,r0,r0) after ADDS pc,..
; 19-Apr-90	ArtG		Speedups for read/write commands.
; 15-May-90	ArtG		Fixed multiple %13 label in ts_W_FIW
; 22-May-90	ArtG		Fixed bugs in ts_B_MWW, ts_W_RIB
; 18-Jun-93	ArtG		Added Arm600 control instructions
; 1-Jul-93	ArtG		Replaced ADDS pc.. instructions with ADD pc..
;				for compatibility with SVC32_mode. 
;
;------------------------------------------------------------------------



;
; All these routines use registers as follows :
;
;       r0  - always zero
;       r1
;       r2
;       r3  - undisturbed : used as constant by I/O routine
;       r4  - return value from I/O routine, parameter to I/O routines
;       r5
;       r6
;       r7  - saved value of command byte on entry
;       r8  - operation counter
;       r9  - pointer to data transfer operation
;       r10 - increment value (0, 1 or 4) to add to pointer in r9
;       r11 - decrement constant (-1) to add to counter in r8
;       r12 - checksum accumulator
;       r13 - pointer to operation code
;       r14 - return address for calls to I/O routines
;

        SUBT    External command handlers
;
; Called by vectoring through command_table. 
; R4 contains command byte (including 3 option bits)
; Get operation count
; Get address
; If single-word data
;   Get data
;   Get checksum
;   Reply with command byte or FF
;   Do operation
; Else
;   For each word
;     Get data
;     Do operation 
;   Get checksum
;   Reply with command byte or FF
; Return by branching to GetCommand.

ts_write_memory    ROUT

        ADDS    r13,r0,r4               ; save the control byte
        ADDS    r7,r0,r4
        ADDS    r14, r0, pc             ; setup return address for ..
        B       ts_GetWord              ; .. get operation count word
        ADDS    r8, r0, r4              ; r8 is operation count
        ADDS    r12,r0,r4               ; initialise checksum 
        ADDS    r14, r0, pc
        B       ts_GetWord              ; r9 is initial target address
        ADDS    r9, r0, r4
        ADDS    r12,r12,r4              ; accumulate checksum 
        ADDS    r10,r0,r0               ; set initial constants
        LDR     r11,%01
	ADD     pc,pc,r0
01
        DCD     (0 - 1)

;
; Check for operations which don't involve reading a block of data.
; These are acknowledged BEFORE performing the operation.
;
	ADDS	r0,r0,r0
        ADDS    r13,r13,r13             ; convert operation code to vector 
        ADDS    r13,r13,r13
        LDR     r4, %02
	ADD     pc,pc,r0
02
        &       (ts_write_cmd_table - %03)
        ADDS    r4,pc,r4
        ADDS    r13,r4,r13
03
        LDR     r13,[r13]               ; fetch pointer to code
        LDR     r4,%04
	ADD     pc,pc,r0
04
        &       (ts_write_cmd_table - ts_W_fetch_operations) 
	ADDS	r0,r0,r0
        ADDS    r4,r4,r13
        BCS     ts_Write_getdata        ; defer acknowledgement till later

        ; check the above test was valid, given code layout
	; Note - this is also required by code near ts_Write_cmd_done

        ASSERT  (ts_W_RSW <  ts_W_fetch_operations)
        ASSERT  (ts_W_RSB <  ts_W_fetch_operations)
        ASSERT  (ts_W_RIW <  ts_W_fetch_operations)
        ASSERT  (ts_W_RIB <  ts_W_fetch_operations)
        ASSERT  (ts_W_FSW >= ts_W_fetch_operations)
        ASSERT  (ts_W_FSB >= ts_W_fetch_operations)
        ASSERT  (ts_W_FIW >= ts_W_fetch_operations)
        ASSERT  (ts_W_FIB >= ts_W_fetch_operations)

;
; Fetch the first data word and checksum, and acknowledge
;

        ADDS    r14,r0,pc               ;get next data word
        B       ts_GetWord
        ADDS    r12,r12,r4              ;accumulate checksum
        ADDS    r10,r0,r4
        ADDS    r14,r0,pc
        B       ts_GetWord              ;read transmitted checksum
        ADDS    r4,r4,r12               ;tx + total should be zero
        LDR     r5,%05
        ADD     pc,pc,r0
05
        &       (0 - 1)
        ADDS    r5,r5,r4                ;carry set on checksum failure
        BCS     ts_cmd_error

;
; Checksum looks OK. Send the command and the checksum back.
;
	LDR	r4,%06
	ADD     pc,pc,r0
06
	&	ts_WriteCmdByte
        ADDS    r4,r4,r7                ;restore the original 

        ADDS    r14,r0,pc
        B       ts_SendByte
        ADDS    r4,r0,r12               ;then send the calculated checksum
        ADDS    r14,r0,pc
        B       ts_SendWord

        ADDS    r4,r0,r10               ;restore the data word
        ADDS    r10,r0,r0               ;and the zero in r10
        B       ts_Write_usedata        ;dive off to do the work

;
; Enter the main loop, repeating the operation labelled in r13.
;

ts_Write_getdata
        ADDS    r9,r9,r10               ;perform increment operation
        ADDS    r8,r8,r11               ;countdown repeat counter
        BCC     ts_Write_cmd_ack
        ADDS    r14,r0,pc               ;get next data word
        B       ts_GetWord
        ADDS    r12,r12,r4              ;accumulate checksum
	B	%07

ts_Write_usedata
        ADDS    r9,r9,r10               ;perform increment operation
ts_Write_count
        ADDS    r8,r8,r11               ;countdown repeat counter
        BCC     ts_Write_cmd_done
07
        ADD     pc,pc,r13               ;jump back to operations
        &       0

;
; In this table, the operation after any word fetch is vectored by
; the 3 least significant bits of the command byte to perform some 
; combination of writing with  : 
;
; bit 2 -> 0    R : repeat with same data
;          1    F : fetch more data for next operation
;
; bit 1 -> 0    S : leave address static
;          1    I : increment address after operation
;
; bit 0 -> 0    W : word operation
;          1    B : byte operation
;

        ASSERT  ((ts_write_cmd_table - %07) = 8)

ts_write_cmd_table

        DCD     (ts_W_RSW - ts_write_cmd_table)
        DCD     (ts_W_RSB - ts_write_cmd_table)
        DCD     (ts_W_RIW - ts_write_cmd_table)
        DCD     (ts_W_RIB - ts_write_cmd_table)
        DCD     (ts_W_FSW - ts_write_cmd_table)
        DCD     (ts_W_FSB - ts_write_cmd_table)
        DCD     (ts_W_FIW - ts_write_cmd_table)
        DCD     (ts_W_FIB - ts_write_cmd_table)

;
; And here are the trailers that perform these operations.
; Each is started with the data in r4, address in r9 and completes
; by returning to Write_getdata (to read another word) or Write_usedata
; (to repeat with the same data) with r10 = increment value (initially 0)
;

ts_W_RSW
        STR     r4,[r9]                 ;store word, repeat address
        ADDS    r8,r8,r11               ;countdown repeat counter
        BCS     ts_W_RSW
        B       ts_Write_cmd_done

ts_W_RSB
        STRB    r4,[r9]                 ;store byte, repeat address
	ADDS	r8,r8,r11
	BCS	ts_W_RSB
        B       ts_Write_cmd_done

ts_W_RIW
        LDR     r10,%11
	ADD     pc,pc,r0
11
        DCD     4
12
        STR     r4,[r9]                 ;store word, increment word address
        ADDS    r9,r9,r10               ;perform increment operation
        ADDS    r8,r8,r11               ;countdown repeat counter
	BCS	%B12
        B       ts_Write_cmd_done


ts_W_RIB
	LDR	r10,%13
	ADD     pc,pc,r0
13
        DCD     1
14
        STRB    r4,[r9]                 ;store byte, increment byte address
	ADDS	r9,r9,r10
	ADDS	r8,r8,r11
	BCS	%B14
	B	ts_Write_cmd_done



ts_W_fetch_operations                   ;all past here fetch new data
                                        ;on each loop

ts_W_FSW
        STR     r4,[r9]                 ;store word, repeat address
        B       ts_Write_getdata

ts_W_FSB
        STRB    r4,[r9]                 ;store byte, repeat address
        B       ts_Write_getdata

ts_W_FIW
        STR     r4,[r9]                 ;store word, increment word address
        LDR     r10,%15
        B       ts_Write_getdata
15
        DCD     4

ts_W_FIB
        STRB    r4,[r9]                 ;store byte, increment byte address
        LDR     r10,%16
        B       ts_Write_getdata
16
        DCD     1 


;
; Operations completed. Operations that read multiple data words from
; the host must now checksum and acknowledge the block (even though
; it's a bit late to do anything about it)
;

ts_Write_cmd_ack
;
; Operation involved multiple fetches - only now ready to ACK. 
;
        ADDS    r14,r0,pc
        B       ts_GetWord              ;read transmitted checksum
        ADDS    r4,r4,r12               ;tx + total should be zero
        LDR     r5,%25
        ADD     pc,pc,r0
25
        &       (0 - 1)
        ADDS    r5,r5,r4                ;carry set on checksum failure
        BCS     ts_cmd_error

;
; Checksum looks OK. Send the command and the checksum back.
;
	LDR	r4,%26
	ADD     pc,pc,r0
26
	&	ts_WriteCmdByte
        ADDS    r4,r4,r7                ;restore the original 
        ADDS    r14,r0,pc
        B       ts_SendByte
        ADDS    r4,r0,r12               ;then send the calculated checksum
        ADDS    r14,r0,pc
        B       ts_SendWord

ts_Write_cmd_done
        B       ts_GetCommand



; Called by vectoring through command_table. 
; R4 contains command byte (including 3 option bits)
; Get operation count
; Get address
; Reply with command byte or FF
; Reply with checksum
; For each word
;   Read data
;   If Verbose option
;     Send data
; If Quiet option
;   Send result of read operation
; Send checksum of result packet
; Return by branching to GetCommand.

ts_read_memory    ROUT

        ADDS    r13,r0,r4               ; save the control byte
        ADDS    r7,r0,r4

        ADDS    r14, r0, pc             ; setup return address for ..
        B       ts_GetWord              ; .. get operation count word
        ADDS    r8, r0, r4              ; r8 is operation count
        ADDS    r12,r0,r4               ; initialise checksum 

        ADDS    r14, r0, pc
        B       ts_GetWord              ; r9 is initial target address
        ADDS    r9, r0, r4
        ADDS    r12,r12,r4              ; accumulate checksum 
        ADDS    r10,r0,r0               ; set initial constants
        LDR     r11,%01
        ADD     pc,pc,r0
01
        DCD     (0 - 1)
;
; Convert the operation options into a code pointer
;
	ADDS	r0,r0,r0
        ADDS    r13,r13,r13             ; convert operation code to vector 
        ADDS    r13,r13,r13
        LDR     r4, %02
        ADD     pc,pc,r0
02
        &       (ts_read_cmd_table - %03)
        ADDS    r4,pc,r4
        ADDS    r13,r4,r13
03
        LDR     r13,[r13]               ; fetch pointer to code

;
; Fetch the checksum, and acknowledge
;

        ADDS    r14,r0,pc
        B       ts_GetWord              ;read transmitted checksum
        ADDS    r4,r4,r12               ;tx + total should be zero
        LDR     r5,%05
        ADD     pc,pc,r0
05
        &       (0 - 1)
        ADDS    r5,r5,r4                ;carry set on checksum failure
        BCS     ts_cmd_error

;
; Checksum looks OK. Send the command and the checksum back.
;
	LDR	r4,%06
	ADD     pc,pc,r0
06
	&	ts_ReadCmdByte
        ADDS    r4,r4,r7                ;restore the original 
        ADDS    r14,r0,pc
        B       ts_SendByte
        ADDS    r4,r0,r12               ;then send the calculated checksum
        ADDS    r14,r0,pc
        B       ts_SendWord

        ADDS    r12,r0,r0               ;initialise the upload checksum 
        B       ts_Read_count		;enter the loop

;
; Enter the main loop, repeating the operation labelled in r13.
; This loop is for operations that finish with all data sent

ts_Read_Txdata                          ;send data to host
        ADDS    r12,r12,r4              ;accumulate the checksum
        ADDS    r14,r0,pc
        B       ts_SendWord             ;send this word
        ADDS    r9,r9,r10               ;perform increment operation
        ADDS    r8,r8,r11               ;countdown repeat counter
        BCC     ts_Read_cmd_done
        B       %07                     ;go off to the jump handler

ts_Read_count
        ADDS    r8,r8,r11               ;countdown repeat counter
        BCC     ts_Read_cmd_read        ;send data at finish
07
        ADD     pc,pc,r13               ;jump back to operations
        &       0

;
; In this table, the operation after any word fetch is vectored by
; the 2 least significant bits of the command byte to perform some 
; combination of reading with  : 
;
; bit 2 -> 0    Q : read data without reporting it
;          1    V : Transmit the result of every read operation
;
; bit 1 -> 0    S : leave address static
;          1    I : increment address after operation
;
; bit 0 -> 0    W : word operation
;          1    B : byte operation
;

        ASSERT  ((ts_read_cmd_table - %07) = 8)

ts_read_cmd_table

        DCD     (ts_R_QSW - ts_read_cmd_table)
        DCD     (ts_R_QSB - ts_read_cmd_table)
        DCD     (ts_R_QIW - ts_read_cmd_table)
        DCD     (ts_R_QIB - ts_read_cmd_table)
        DCD     (ts_R_VSW - ts_read_cmd_table)
        DCD     (ts_R_VSB - ts_read_cmd_table)
        DCD     (ts_R_VIW - ts_read_cmd_table)
        DCD     (ts_R_VIB - ts_read_cmd_table)

;
; And here are the trailers that perform these operations.
; Each is started with the data in r4, address in r9 and completes
; by returning to Write_getdata (to read another word) or Write_usedata
; (to repeat with the same data) with r10 = increment value (initially 0)
;

ts_R_QSW
        LDR     r4,[r9]                 ;read word, repeat address
        ADDS    r8,r8,r11               ;countdown repeat counter
	BCS	ts_R_QSW
        B       ts_Read_cmd_read        ;send data at finish


ts_R_QSB
        LDRB    r4,[r9]                 ;read byte, repeat address
	ADDS	r8,r8,r11
	BCS	ts_R_QSB
        B       ts_Read_cmd_read

ts_R_QIW
        LDR     r10,%11
	ADD     pc,pc,r0
11
        DCD     4
12
        LDR     r4,[r9]                 ;read word, increment word address
        ADDS    r9,r9,r10               ;perform increment operation
        ADDS    r8,r8,r11               ;countdown repeat counter
	BCS	%B12
        B       ts_Read_cmd_read        ;send data at finish


ts_R_QIB
        LDR     r10,%13
	ADD     pc,pc,r0
13
        DCD     1
14
        LDRB    r4,[r9]                 ;read byte, increment byte address
        ADDS    r9,r9,r10               ;perform increment operation
        ADDS    r8,r8,r11               ;countdown repeat counter
	BCS	%B14
        B       ts_Read_cmd_read        ;send data at finish


ts_R_VSW
        LDR     r4,[r9]                 ;read and tx word, repeat address
        B       ts_Read_Txdata

ts_R_VSB
        LDRB    r4,[r9]                 ;read and tx byte, repeat address
        B       ts_Read_Txdata

ts_R_VIW
        LDR     r4,[r9]                 ;read and tx word, next word address
        LDR     r10,%15
        B       ts_Read_Txdata
15
        DCD     4

ts_R_VIB
	ADDS	r0,r0,r0
        LDRB    r4,[r9]                 ;read and tx byte, next byte address
        LDR     r10,%16
        B       ts_Read_Txdata
16
        DCD     1 


;
; Operations completed. Report final result and checksum back to host.
; Quiet option only transmits read data here (this is pretty useless
; except where only one value was read)
;

ts_Read_cmd_read
	ADDS	r12,r12,r4
        ADDS    r14,r0,pc               ;send result of 'quiet' read
        B       ts_SendWord
ts_Read_cmd_done
        SUBS    r4,r0,r12               ;get overall checksum  - can't think
        ADDS    r14,r0,pc               ;how to do this using only ADDS !
        B       ts_SendWord

        B       ts_GetCommand


; Called by vectoring through command table.
; if option 1 set, read processor mode
; Read address
; Read and check checksum
; Reply with command byte or FF
; Reply with checksum
; if option 1 set, load SPSR
; Jump to code


ts_execute      ROUT
	ADDS	r12,r0,r0		; initialise checksum adder
	LDR	r8,%00			; initialise msr-jumper
	ADD	pc,pc,r0
00
	&	4
	ADDS	r7,r4,r4		; get operation type
	ADDS	r7,r7,r7
	ADD 	pc,pc,r7		; jump to pc + (r4 * 4)
	&	0

	B	%FT10
	B	%FT08
	B	%FT10
	B	%FT10
	B	%FT10
	B	%FT10
	B	%FT10
	B	%FT10


08	ADDS	r14,r0,pc		; get new processor mode
	B	ts_GetWord
	ADDS	r12,r0,r4
	ADDS	r8,r0,r0		; kill msr-jumper
10
        ADDS    r14,r0,pc
        B       ts_GetWord              ; get jump address
        ADDS    r9,r12,r4
        ADDS    r14,r0,pc
        B       ts_GetWord              ; get checksum
        ADDS    r4,r4,r9
        LDR     r5,%11
        ADD     pc,pc,r0
11
        &       (0 - 1)
        ADDS    r4,r5,r4                ; compare total chex with zero
        BCS     ts_cmd_error            ; carry set on error

	LDR	r4,%12
	ADD     pc,pc,r0
12
	&	ts_ExecuteCmdByte
	ADDS	r0,r0,r0
        ADDS    r14,r0,pc  	        ; echo command byte
        B       ts_SendByte
        ADDS    r4,r0,r9                ;return checksum (actually, the
        ADDS    r14,r0,pc               ; entire message ..)
        B       ts_SendWord


; Now jump to the location given in the message, using the given status bits

	ADD	pc,pc,r8		; jump over the msr instruction
	NOP
	MSR	SPSR_cf,R12

	ADDS	r14,pc,r0		; Load the address of %13 into r14
			           	; to provide a return address
        ADD     pc,r0,r9		; Do the jump
13
        B      ts_GetCommand



; Called by vectoring through command table
; Read operation count
; Read target addresses
; Read data
; Send command byte or FF
; Send checksum
; For all operation count
;   write data 
;   if read-back option
;     read data
; Return by branching to GetCommand


ts_bus_exercise	ROUT
        ADDS    r7,r0,r4                ; save the control byte

        ADDS    r14, r0, pc             ; setup return address for ..
        B       ts_GetWord              ; .. get operation count word
        ADDS    r8, r0, r4              ; r8 is operation count
        ADDS    r12,r0,r4               ; initialise checksum 

        ADDS    r14, r0, pc
        B       ts_GetWord              ; r9 is first target address
        ADDS    r9, r0, r4
        ADDS    r12,r12,r4              ; accumulate checksum 
        ADDS    r14, r0, pc
        B       ts_GetWord              ; r10 is second target address
        ADDS    r10, r0, r4
        ADDS    r12,r12,r4              ; accumulate checksum 

        ADDS    r14, r0, pc
        B       ts_GetWord              ; r11 is first data word
        ADDS    r11, r0, r4
        ADDS    r12,r12,r4              ; accumulate checksum 
        ADDS    r14, r0, pc
        B       ts_GetWord              ; r13 is second data word
        ADDS    r13, r0, r4
        ADDS    r12,r12,r4              ; accumulate checksum 

;
; Fetch the checksum, and acknowledge
;

        ADDS    r14,r0,pc
        B       ts_GetWord              ;read transmitted checksum
        ADDS    r4,r4,r12               ;tx + total should be zero
        LDR     r5,%05
        ADD     pc,pc,r0
05
        &       (0 - 1)
        ADDS    r5,r5,r4                ;carry set on checksum failure
        BCS     ts_cmd_error

;
; Checksum looks OK. Send the command and the checksum back.
;
	LDR	r4,%06
	ADD     pc,pc,r0
06
	&	ts_BusExCmdByte
        ADDS    r4,r4,r7                ;restore the original 
        ADDS    r14,r0,pc
        B       ts_SendByte
        ADDS    r4,r0,r12               ;then send the calculated checksum
        ADDS    r14,r0,pc
        B       ts_SendWord

	ADDS	r12,r0,r13		; Now addresses are in r9, r10
					; and data in r11, r12.
;
; Convert the operation options into a code pointer
;
        ADDS    r13,r7,r7              ; convert operation code to vector 
        ADDS    r13,r13,r13
        LDR     r4, %02
        ADD     pc,pc,r0
02
        &       (ts_busex_cmd_table - %03)
        ADDS    r4,pc,r4
        ADDS    r13,r4,r13
03
        LDR     r13,[r13]               ; fetch pointer to code
	LDR	r7, %04			; set up decrementer in r8
	ADD 	pc,pc,r0
04
	DCD	(0 - 1)
07
        ADD     pc,pc,r13               ; jump to operation
	&	0

;
; In this table, the operation after any word fetch is vectored by
; the 3 least significant bits of the command byte to perform some 
; combination of writing with  : 
;
; bit 2 -> 0    S : Perform separate data write ops
;          1    M : Use STM / LDM instructions 
;
; bit 1 -> 0    R : Perform only read operations
;          1    W : Write before reading
;
; bit 0 -> 0    W : word operation
;          1    B : byte operation
;
; Note that byte and multiple operations are mutually
; exclusive.
;

        ASSERT  ((ts_busex_cmd_table - %07) = 8)

ts_busex_cmd_table

        DCD     (ts_B_SRW - ts_busex_cmd_table)
        DCD     (ts_B_SRB - ts_busex_cmd_table)
        DCD     (ts_B_SWW - ts_busex_cmd_table)
        DCD     (ts_B_SWB - ts_busex_cmd_table)
        DCD     (ts_B_MRW - ts_busex_cmd_table)
        DCD     (ts_B_MRB - ts_busex_cmd_table)
        DCD     (ts_B_MWW - ts_busex_cmd_table)
        DCD     (ts_B_MWB - ts_busex_cmd_table)

ts_B_SRW
	LDR	r11,[r9]		; read-only separate words
	LDR	r12,[r10]
	ADDS	r8, r8, r7
	BCS	ts_B_SRW
	B	ts_B_done

ts_B_SRB
	LDRB	r11,[r9]		; read-only separate bytes
	LDRB	r12,[r10]
	ADDS	r8, r8, r7
	BCS	ts_B_SRB
	B	ts_B_done

ts_B_SWW
	STR	r11,[r9]		; write and read separate words
	STR	r12,[r10]
	LDR	r1,[r9]
	LDR	r2,[r10]
	ADDS	r8, r8, r7
	BCS	ts_B_SWW
	B	ts_B_done

ts_B_SWB
	STRB	r11,[r9]		; write and read separate bytes
	STRB	r12,[r10]
	LDRB	r1,[r9]
	LDRB	r2,[r10]
	ADDS	r8, r8, r7
	BCS	ts_B_SWB
	B	ts_B_done


ts_B_MRW
	LDMIA	r9,{r1,r2}		; read-only multiple words
	LDMIA	r10,{r1,r2}
	ADDS	r8, r8, r7
	BCS	ts_B_MRW
	B	ts_B_done

ts_B_MWW
	STMIA	r9,{r11,r12}		; write and read multiple words
	LDMIA	r9,{r1,r2}
	STMIA	r10,{r11,r12}
	LDMIA	r10,{r1,r2}
	ADDS	r8, r8, r7
	BCS	ts_B_MWW
	B	ts_B_done

;
; Orthogonally, these should be multiple byte operations - we can't do that, 
; so they actually do a single/multiple mixture.
; The first address argument is used for word-aligned operations and the
; second for byte-aligned operations - so set only the second address
; to a non-word-aligned address.

ts_B_MRB
	LDMIA	r9,{r1,r2}		; read-only multiple words
	LDRB	r1,[r10]		; then single bytes
	LDR 	r1,[r9]			; and single words
	ADDS	r8, r8, r7
	BCS	ts_B_MRB
	B	ts_B_done

ts_B_MWB
	STMIA	r9,{r11,r12}		; store multiple words
	STRB	r11,[r10]		; write byte
	STR	r12,[r9]		; write words
	LDMIA	r9,{r1,r2}
	LDRB	r1,[r10]
	LDR	r1,[r9]			; read single and multiple words
	ADDS	r8, r8, r7
	BCS	ts_B_MWB
;	B	ts_B_done

ts_B_done
	B	ts_GetCommand



;
; All commands fall through here to respond with FF if the received
; message block checksums fail.
;

ts_cmd_error    ROUT                    ; error in command
        LDR     r4, %01                 ; return error response
        ADD     pc,pc,r0
01
        DCD     ErrorCmd
	ADDS	r0,r0,r0
        ADDS    r14, r0, pc             ; send response byte to host
        B       ts_SendByte

        B       ts_GetCommand


; generic coprocessor register names

cpr0	CN	0
cpr1	CN	1
cpr2	CN	2
cpr3	CN	3
cpr4	CN	4
cpr5	CN	5
cpr6	CN	6
cpr7	CN	7
cpr8	CN	8
cpr9	CN	9
cpr10	CN	10
cpr11	CN	11
cpr12	CN	12
cpr13	CN	13
cpr14	CN	14
cpr15	CN	15


; Called by vectoring through command table.
; Read transfer value
; Read and check checksum
; Extract copro register number
; Index suitable MRC instruction
; Perform copro write
; Reply with command byte or FF
; Reply with checksum

ts_write_cpr15h	ROUT
	ADDS	r4,r4,#8		; adjust opcode for high registers
ts_write_cpr15l
	ADDS	r7,r0,r4		; save opcode to r7
        ADDS    r14,r0,pc
        B       ts_GetWord              ; get value for copro
        ADDS    r9,r0,r4
        ADDS    r14,r0,pc
        B       ts_GetWord              ; get checksum
        ADDS    r4,r4,r9
        LDR     r5,%01
        ADD     pc,pc,r0
01
        &       (0 - 1)
        ADDS    r4,r5,r4                ; compare total chex with zero
        BCS     ts_cmd_error            ; carry set on error

	ADDS	r13,r7,r7		; point into instruction table
	ADDS	r13,r13,r13
	ADDS	r13,r13,r13
	ADD 	pc,pc,r13		; jump to pc + (r7 * 8)
	&	0

	SetCop	r9,cpr0			; transfer instructions
	B	%02
	SetCop	r9,cpr1
	B	%02
	SetCop	r9,cpr2
	B	%02
	SetCop	r9,cpr3
	B	%02
	SetCop	r9,cpr4
	B	%02
	SetCop	r9,cpr5
	B	%02
	SetCop	r9,cpr6
	B	%02
	SetCop	r9,cpr7
	B	%02
	SetCop	r9,cpr8
	B	%02
	SetCop	r9,cpr9
	B	%02
	SetCop	r9,cpr10
	B	%02
	SetCop	r9,cpr11
	B	%02
	SetCop	r9,cpr12
	B	%02
	SetCop	r9,cpr13
	B	%02
	SetCop	r9,cpr14
	B	%02
	SetCop	r9,cpr15

02
	LDR	r4,%03
	ADD     pc,pc,r0
03
	&	ts_CPWCmdByte		; build command byte + option
	ADDS	r4,r4,r7
        ADDS    r14,r0,pc  	        ; echo command byte
        B       ts_SendByte
        ADDS    r4,r0,r9                ; return checksum 
        ADDS    r14,r0,pc               ;
        B       ts_SendWord

	B	ts_GetCommand




; Called by vectoring through command table.
; Read and check checksum
; Extract copro register number
; Index suitable MCR instruction
; Perform copro read
; Reply with command byte or FF
; Reply with checksum
; Send transfer results
; Send checksum

ts_read_cpr15h	ROUT
	ADDS	r4,r4,#8		; adjust opcode for high registers
ts_read_cpr15l
	ADDS	r7,r0,r4		; save opcode in r7
        ADDS    r14,r0,pc
        B       ts_GetWord              ; get checksum to r4
	ADDS	r9,r0,r4		; copy to r9
        LDR     r5,%01
        ADD     pc,pc,r0
01
        &       (0 - 1)
        ADDS    r4,r5,r4                ; compare total chex with zero
        BCS     ts_cmd_error            ; carry set on error

	LDR	r4,%02
	ADD     pc,pc,r0
02
	&	ts_CPRCmdByte		; build command byte + option
	ADDS	r4,r4,r7
        ADDS    r14,r0,pc  	        ; echo command byte
        B       ts_SendByte
        ADDS    r4,r0,r9                ; return checksum
        ADDS    r14,r0,pc
        B       ts_SendWord

	ADDS	r13,r7,r7		; point into instruction table
	ADDS	r13,r13,r13
	ADDS	r13,r13,r13
	ADD 	pc,pc,r13		; jump to pc + (r7 * 8)
	&	0

	ReadCop	r12,cpr0		; transfer instructions
	B	%03
	ReadCop	r12,cpr1
	B	%03
	ReadCop	r12,cpr2
	B	%03
	ReadCop	r12,cpr3
	B	%03
	ReadCop	r12,cpr4
	B	%03
	ReadCop	r12,cpr5
	B	%03
	ReadCop	r12,cpr6
	B	%03
	ReadCop	r12,cpr7
	B	%03
	ReadCop	r12,cpr8
	B	%03
	ReadCop	r12,cpr9
	B	%03
	ReadCop	r12,cpr10
	B	%03
	ReadCop	r12,cpr11
	B	%03
	ReadCop	r12,cpr12
	B	%03
	ReadCop	r12,cpr13
	B	%03
	ReadCop	r12,cpr14
	B	%03
	ReadCop	r12,cpr15

03
	ADDS	r4,r0,r12		; return result
	ADDS	r14,r0,pc
	B	ts_SendWord
	SUBS	r4,r0,r12		; return checksum
	ADDS	r14,r0,pc
	B	ts_SendWord

	B	ts_GetCommand


        END


@


4.2
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@@


4.1
log
@Initial revision
@
text
@d604 1
a604 1
	&	2_11100001011010011111000000001100 ; 
@


4.1.10.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d604 1
a604 1
	MSR	SPSR_cf,R12
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	1.2;
access;
symbols
	Kernel-6_14:1.2
	Kernel-6_01-3:1.2
	Kernel-6_13:1.2
	Kernel-6_12:1.2
	Kernel-6_11:1.2
	Kernel-6_10:1.2
	Kernel-6_09:1.2
	Kernel-6_08-4_129_2_10:1.2
	Kernel-6_08-4_129_2_9:1.2
	Kernel-6_08:1.2
	Kernel-6_07:1.2
	Kernel-6_06:1.2
	Kernel-6_05-4_129_2_8:1.2
	Kernel-6_05:1.2
	Kernel-6_04:1.2
	Kernel-6_03:1.2
	Kernel-6_01-2:1.2
	Kernel-6_01-4_146_2_1:1.2
	Kernel-6_02:1.2
	Kernel-6_01-1:1.2
	Kernel-6_01:1.2
	Kernel-6_00:1.2
	Kernel-5_99:1.2
	Kernel-5_98:1.2
	Kernel-5_97-4_129_2_7:1.2
	Kernel-5_97:1.2
	Kernel-5_96:1.2
	Kernel-5_95:1.2
	Kernel-5_94:1.2
	Kernel-5_93:1.2
	Kernel-5_92:1.2
	Kernel-5_91:1.2
	Kernel-5_90:1.2
	Kernel-5_89-4_129_2_6:1.2
	Kernel-5_89:1.2
	Kernel-5_88-4_129_2_5:1.2
	Kernel-5_88-4_129_2_4:1.2
	Kernel-5_88:1.2
	Kernel-5_87:1.2
	Kernel-5_86-4_129_2_3:1.2
	Kernel-5_86-4_129_2_2:1.2
	Kernel-5_86-4_129_2_1:1.2
	Kernel-5_86:1.2
	SMP:1.2.0.2
	SMP_bp:1.2
	Kernel-5_85:1.2
	Kernel-5_54-1:1.2
	Kernel-5_84:1.2
	Kernel-5_83:1.2
	Kernel-5_82:1.2
	Kernel-5_81:1.2
	Kernel-5_80:1.2
	Kernel-5_79:1.2
	Kernel-5_78:1.2
	Kernel-5_77:1.2
	Kernel-5_76:1.2
	Kernel-5_75:1.2
	Kernel-5_74:1.2
	Kernel-5_73:1.2
	Kernel-5_72:1.2
	Kernel-5_71:1.2
	Kernel-5_70:1.2
	Kernel-5_69:1.2
	Kernel-5_68:1.2
	Kernel-5_67:1.2
	Kernel-5_66:1.2
	Kernel-5_65:1.2
	Kernel-5_64:1.2
	Kernel-5_63:1.2
	Kernel-5_62:1.2
	Kernel-5_61:1.2
	Kernel-5_60:1.2
	Kernel-5_59:1.2
	Kernel-5_58:1.2
	Kernel-5_57:1.2
	Kernel-5_56:1.2
	Kernel-5_55:1.2
	Kernel-5_54:1.2
	Kernel-5_53:1.2
	Kernel-5_52:1.2
	Kernel-5_51:1.2
	Kernel-5_50:1.2
	Kernel-5_49:1.2
	HAL_merge:1.1.2.7
	Kernel-5_48:1.2
	Kernel-5_35-4_79_2_327:1.1.2.7
	Kernel-5_35-4_79_2_326:1.1.2.7
	Kernel-5_35-4_79_2_325:1.1.2.7
	Kernel-5_35-4_79_2_324:1.1.2.7
	Kernel-5_35-4_79_2_323:1.1.2.7
	Kernel-5_35-4_79_2_322:1.1.2.7
	Kernel-5_35-4_79_2_321:1.1.2.7
	Kernel-5_35-4_79_2_320:1.1.2.7
	Kernel-5_35-4_79_2_319:1.1.2.7
	Kernel-5_35-4_79_2_318:1.1.2.7
	Kernel-5_35-4_79_2_317:1.1.2.7
	Kernel-5_35-4_79_2_316:1.1.2.7
	Kernel-5_35-4_79_2_315:1.1.2.7
	Kernel-5_35-4_79_2_314:1.1.2.7
	Kernel-5_35-4_79_2_313:1.1.2.7
	Kernel-5_35-4_79_2_312:1.1.2.7
	Kernel-5_35-4_79_2_311:1.1.2.7
	Kernel-5_35-4_79_2_310:1.1.2.7
	Kernel-5_35-4_79_2_309:1.1.2.7
	Kernel-5_35-4_79_2_308:1.1.2.7
	Kernel-5_35-4_79_2_307:1.1.2.7
	Kernel-5_35-4_79_2_306:1.1.2.7
	Kernel-5_35-4_79_2_305:1.1.2.7
	Kernel-5_35-4_79_2_304:1.1.2.7
	Kernel-5_35-4_79_2_303:1.1.2.7
	Kernel-5_35-4_79_2_302:1.1.2.6
	Kernel-5_35-4_79_2_301:1.1.2.6
	Kernel-5_35-4_79_2_300:1.1.2.6
	Kernel-5_35-4_79_2_299:1.1.2.6
	Kernel-5_35-4_79_2_298:1.1.2.6
	Kernel-5_35-4_79_2_297:1.1.2.6
	Kernel-5_35-4_79_2_296:1.1.2.6
	Kernel-5_35-4_79_2_295:1.1.2.6
	Kernel-5_35-4_79_2_294:1.1.2.6
	Kernel-5_35-4_79_2_293:1.1.2.6
	Kernel-5_35-4_79_2_292:1.1.2.6
	Kernel-5_35-4_79_2_291:1.1.2.6
	Kernel-5_35-4_79_2_290:1.1.2.6
	Kernel-5_35-4_79_2_289:1.1.2.6
	Kernel-5_35-4_79_2_288:1.1.2.6
	Kernel-5_35-4_79_2_287:1.1.2.6
	Kernel-5_35-4_79_2_286:1.1.2.6
	Kernel-5_35-4_79_2_285:1.1.2.6
	Kernel-5_35-4_79_2_284:1.1.2.6
	Kernel-5_35-4_79_2_283:1.1.2.6
	Kernel-5_35-4_79_2_282:1.1.2.6
	Kernel-5_35-4_79_2_281:1.1.2.6
	Kernel-5_35-4_79_2_280:1.1.2.6
	Kernel-5_35-4_79_2_279:1.1.2.6
	Kernel-5_35-4_79_2_278:1.1.2.6
	Kernel-5_35-4_79_2_277:1.1.2.6
	Kernel-5_35-4_79_2_276:1.1.2.6
	Kernel-5_35-4_79_2_275:1.1.2.6
	Kernel-5_35-4_79_2_274:1.1.2.6
	Kernel-5_35-4_79_2_273:1.1.2.6
	Kernel-5_35-4_79_2_272:1.1.2.6
	Kernel-5_35-4_79_2_271:1.1.2.6
	Kernel-5_35-4_79_2_270:1.1.2.6
	Kernel-5_35-4_79_2_269:1.1.2.6
	Kernel-5_35-4_79_2_268:1.1.2.6
	Kernel-5_35-4_79_2_267:1.1.2.6
	Kernel-5_35-4_79_2_266:1.1.2.6
	Kernel-5_35-4_79_2_265:1.1.2.6
	Kernel-5_35-4_79_2_264:1.1.2.6
	Kernel-5_35-4_79_2_263:1.1.2.6
	Kernel-5_35-4_79_2_262:1.1.2.6
	Kernel-5_35-4_79_2_261:1.1.2.6
	Kernel-5_35-4_79_2_260:1.1.2.6
	Kernel-5_35-4_79_2_259:1.1.2.6
	Kernel-5_35-4_79_2_258:1.1.2.6
	Kernel-5_35-4_79_2_257:1.1.2.6
	Kernel-5_35-4_79_2_256:1.1.2.6
	Kernel-5_35-4_79_2_255:1.1.2.6
	Kernel-5_35-4_79_2_254:1.1.2.6
	Kernel-5_35-4_79_2_253:1.1.2.6
	Kernel-5_35-4_79_2_252:1.1.2.6
	Kernel-5_35-4_79_2_251:1.1.2.6
	Kernel-5_35-4_79_2_250:1.1.2.6
	Kernel-5_35-4_79_2_249:1.1.2.6
	Kernel-5_35-4_79_2_248:1.1.2.5
	Kernel-5_35-4_79_2_247:1.1.2.5
	Kernel-5_35-4_79_2_246:1.1.2.5
	Kernel-5_35-4_79_2_245:1.1.2.5
	Kernel-5_35-4_79_2_244:1.1.2.5
	Kernel-5_35-4_79_2_243:1.1.2.5
	Kernel-5_35-4_79_2_241:1.1.2.5
	Kernel-5_35-4_79_2_240:1.1.2.5
	Kernel-5_35-4_79_2_239:1.1.2.5
	Kernel-5_35-4_79_2_238:1.1.2.5
	Kernel-5_35-4_79_2_237:1.1.2.5
	Kernel-5_35-4_79_2_236:1.1.2.5
	Kernel-5_35-4_79_2_235:1.1.2.5
	Kernel-5_35-4_79_2_234:1.1.2.5
	Kernel-5_35-4_79_2_233:1.1.2.5
	Kernel-5_35-4_79_2_232:1.1.2.5
	Kernel-5_35-4_79_2_231:1.1.2.5
	Kernel-5_35-4_79_2_230:1.1.2.5
	Kernel-5_35-4_79_2_229:1.1.2.5
	Kernel-5_35-4_79_2_228:1.1.2.5
	Kernel-5_35-4_79_2_227:1.1.2.5
	Kernel-5_35-4_79_2_226:1.1.2.5
	Kernel-5_35-4_79_2_225:1.1.2.5
	Kernel-5_35-4_79_2_224:1.1.2.5
	Kernel-5_35-4_79_2_223:1.1.2.5
	Kernel-5_35-4_79_2_222:1.1.2.5
	Kernel-5_35-4_79_2_221:1.1.2.5
	Kernel-5_35-4_79_2_220:1.1.2.5
	Kernel-5_35-4_79_2_219:1.1.2.5
	Kernel-5_35-4_79_2_218:1.1.2.5
	Kernel-5_35-4_79_2_217:1.1.2.5
	Kernel-5_35-4_79_2_216:1.1.2.5
	Kernel-5_35-4_79_2_215:1.1.2.5
	Kernel-5_35-4_79_2_214:1.1.2.5
	Kernel-5_35-4_79_2_213:1.1.2.5
	Kernel-5_35-4_79_2_212:1.1.2.5
	Kernel-5_35-4_79_2_211:1.1.2.5
	Kernel-5_35-4_79_2_210:1.1.2.5
	Kernel-5_35-4_79_2_209:1.1.2.5
	Kernel-5_35-4_79_2_208:1.1.2.5
	Kernel-5_35-4_79_2_207:1.1.2.5
	Kernel-5_35-4_79_2_206:1.1.2.5
	Kernel-5_35-4_79_2_205:1.1.2.5
	Kernel-5_35-4_79_2_204:1.1.2.5
	Kernel-5_35-4_79_2_203:1.1.2.5
	Kernel-5_35-4_79_2_202:1.1.2.5
	Kernel-5_35-4_79_2_201:1.1.2.5
	Kernel-5_35-4_79_2_200:1.1.2.5
	Kernel-5_35-4_79_2_199:1.1.2.5
	Kernel-5_35-4_79_2_198:1.1.2.5
	Kernel-5_35-4_79_2_197:1.1.2.5
	Kernel-5_35-4_79_2_196:1.1.2.5
	Kernel-5_35-4_79_2_195:1.1.2.5
	Kernel-5_35-4_79_2_194:1.1.2.5
	Kernel-5_35-4_79_2_193:1.1.2.5
	Kernel-5_35-4_79_2_192:1.1.2.5
	Kernel-5_35-4_79_2_191:1.1.2.5
	Kernel-5_35-4_79_2_190:1.1.2.5
	Kernel-5_35-4_79_2_189:1.1.2.5
	Kernel-5_35-4_79_2_188:1.1.2.5
	Kernel-5_35-4_79_2_187:1.1.2.5
	Kernel-5_35-4_79_2_186:1.1.2.5
	Kernel-5_35-4_79_2_185:1.1.2.5
	Kernel-5_35-4_79_2_184:1.1.2.5
	Kernel-5_35-4_79_2_183:1.1.2.5
	Kernel-5_35-4_79_2_182:1.1.2.5
	Kernel-5_35-4_79_2_181:1.1.2.5
	Kernel-5_35-4_79_2_180:1.1.2.5
	Kernel-5_35-4_79_2_179:1.1.2.5
	Kernel-5_35-4_79_2_178:1.1.2.5
	Kernel-5_35-4_79_2_177:1.1.2.5
	Kernel-5_35-4_79_2_176:1.1.2.5
	Kernel-5_35-4_79_2_175:1.1.2.5
	Kernel-5_35-4_79_2_174:1.1.2.5
	Kernel-5_35-4_79_2_173:1.1.2.5
	Kernel-5_35-4_79_2_172:1.1.2.5
	Kernel-5_35-4_79_2_171:1.1.2.5
	Kernel-5_35-4_79_2_170:1.1.2.5
	Kernel-5_35-4_79_2_169:1.1.2.5
	Kernel-5_35-4_79_2_168:1.1.2.5
	Kernel-5_35-4_79_2_167:1.1.2.5
	Kernel-5_35-4_79_2_166:1.1.2.5
	Kernel-5_35-4_79_2_165:1.1.2.5
	RPi_merge:1.1.2.5
	Kernel-5_35-4_79_2_147_2_23:1.1.2.5
	Kernel-5_35-4_79_2_147_2_22:1.1.2.5
	Kernel-5_35-4_79_2_147_2_21:1.1.2.5
	Kernel-5_35-4_79_2_147_2_20:1.1.2.5
	Kernel-5_35-4_79_2_147_2_19:1.1.2.5
	Kernel-5_35-4_79_2_147_2_18:1.1.2.5
	Kernel-5_35-4_79_2_164:1.1.2.5
	Kernel-5_35-4_79_2_163:1.1.2.5
	Kernel-5_35-4_79_2_147_2_17:1.1.2.5
	Kernel-5_35-4_79_2_147_2_16:1.1.2.5
	Kernel-5_35-4_79_2_147_2_15:1.1.2.5
	Kernel-5_35-4_79_2_162:1.1.2.5
	Kernel-5_35-4_79_2_161:1.1.2.5
	Kernel-5_35-4_79_2_147_2_14:1.1.2.5
	Kernel-5_35-4_79_2_147_2_13:1.1.2.5
	Kernel-5_35-4_79_2_160:1.1.2.5
	Kernel-5_35-4_79_2_159:1.1.2.5
	Kernel-5_35-4_79_2_158:1.1.2.5
	Kernel-5_35-4_79_2_157:1.1.2.5
	Kernel-5_35-4_79_2_156:1.1.2.5
	Kernel-5_35-4_79_2_147_2_12:1.1.2.5
	Kernel-5_35-4_79_2_147_2_11:1.1.2.5
	Kernel-5_35-4_79_2_155:1.1.2.5
	Kernel-5_35-4_79_2_147_2_10:1.1.2.5
	Kernel-5_35-4_79_2_154:1.1.2.5
	Kernel-5_35-4_79_2_153:1.1.2.5
	Kernel-5_35-4_79_2_147_2_9:1.1.2.5
	Kernel-5_35-4_79_2_152:1.1.2.5
	Kernel-5_35-4_79_2_151:1.1.2.5
	Kernel-5_35-4_79_2_147_2_8:1.1.2.5
	Kernel-5_35-4_79_2_147_2_7:1.1.2.5
	Kernel-5_35-4_79_2_150:1.1.2.5
	Kernel-5_35-4_79_2_147_2_6:1.1.2.5
	Kernel-5_35-4_79_2_147_2_5:1.1.2.5
	Kernel-5_35-4_79_2_149:1.1.2.5
	Kernel-5_35-4_79_2_147_2_4:1.1.2.5
	Kernel-5_35-4_79_2_147_2_3:1.1.2.5
	Kernel-5_35-4_79_2_148:1.1.2.5
	Kernel-5_35-4_79_2_147_2_2:1.1.2.5
	Kernel-5_35-4_79_2_147_2_1:1.1.2.5
	RPi:1.1.2.5.0.6
	RPi_bp:1.1.2.5
	Kernel-5_35-4_79_2_98_2_52_2_1:1.1.2.5
	alees_Kernel_dev:1.1.2.5.0.4
	alees_Kernel_dev_bp:1.1.2.5
	Kernel-5_35-4_79_2_147:1.1.2.5
	Kernel-5_35-4_79_2_146:1.1.2.5
	Kernel-5_35-4_79_2_145:1.1.2.5
	Kernel-5_35-4_79_2_144:1.1.2.5
	Kernel-5_35-4_79_2_143:1.1.2.5
	Kernel-5_35-4_79_2_142:1.1.2.5
	Kernel-5_35-4_79_2_141:1.1.2.5
	Kernel-5_35-4_79_2_140:1.1.2.5
	Kernel-5_35-4_79_2_139:1.1.2.5
	Kernel-5_35-4_79_2_138:1.1.2.5
	Kernel-5_35-4_79_2_137:1.1.2.5
	Kernel-5_35-4_79_2_136:1.1.2.5
	Kernel-5_35-4_79_2_135:1.1.2.5
	Kernel-5_35-4_79_2_134:1.1.2.5
	Kernel-5_35-4_79_2_133:1.1.2.5
	Kernel-5_35-4_79_2_132:1.1.2.5
	Kernel-5_35-4_79_2_131:1.1.2.5
	Kernel-5_35-4_79_2_130:1.1.2.5
	Kernel-5_35-4_79_2_129:1.1.2.5
	Kernel-5_35-4_79_2_128:1.1.2.5
	Kernel-5_35-4_79_2_127:1.1.2.5
	Kernel-5_35-4_79_2_126:1.1.2.5
	Kernel-5_35-4_79_2_125:1.1.2.5
	Kernel-5_35-4_79_2_124:1.1.2.5
	Kernel-5_35-4_79_2_123:1.1.2.5
	Cortex_merge:1.1.2.5
	Kernel-5_35-4_79_2_122:1.1.2.5
	Kernel-5_35-4_79_2_98_2_54:1.1.2.5
	Kernel-5_35-4_79_2_98_2_53:1.1.2.5
	Kernel-5_35-4_79_2_98_2_52:1.1.2.5
	Kernel-5_35-4_79_2_98_2_51:1.1.2.5
	Kernel-5_35-4_79_2_98_2_50:1.1.2.5
	Kernel-5_35-4_79_2_98_2_49:1.1.2.5
	Kernel-5_35-4_79_2_98_2_48:1.1.2.5
	Kernel-5_35-4_79_2_121:1.1.2.5
	Kernel-5_35-4_79_2_98_2_47:1.1.2.5
	Kernel-5_35-4_79_2_120:1.1.2.5
	Kernel-5_35-4_79_2_98_2_46:1.1.2.5
	Kernel-5_35-4_79_2_119:1.1.2.5
	Kernel-5_35-4_79_2_98_2_45:1.1.2.5
	Kernel-5_35-4_79_2_98_2_44:1.1.2.5
	Kernel-5_35-4_79_2_118:1.1.2.5
	Kernel-5_35-4_79_2_98_2_43:1.1.2.5
	Kernel-5_35-4_79_2_117:1.1.2.5
	Kernel-5_35-4_79_2_116:1.1.2.5
	Kernel-5_35-4_79_2_98_2_42:1.1.2.5
	Kernel-5_35-4_79_2_115:1.1.2.5
	Kernel-5_35-4_79_2_98_2_41:1.1.2.5
	Kernel-5_35-4_79_2_98_2_40:1.1.2.5
	Kernel-5_35-4_79_2_114:1.1.2.5
	Kernel-5_35-4_79_2_98_2_39:1.1.2.5
	Kernel-5_35-4_79_2_98_2_38:1.1.2.5
	Kernel-5_35-4_79_2_113:1.1.2.5
	Kernel-5_35-4_79_2_112:1.1.2.5
	Kernel-5_35-4_79_2_98_2_37:1.1.2.5
	Kernel-5_35-4_79_2_98_2_36:1.1.2.5
	Kernel-5_35-4_79_2_98_2_35:1.1.2.5
	Kernel-5_35-4_79_2_98_2_34:1.1.2.5
	Kernel-5_35-4_79_2_98_2_33:1.1.2.5
	Kernel-5_35-4_79_2_98_2_32:1.1.2.5
	Kernel-5_35-4_79_2_98_2_31:1.1.2.5
	Kernel-5_35-4_79_2_98_2_30:1.1.2.5
	Kernel-5_35-4_79_2_98_2_29:1.1.2.5
	Kernel-5_35-4_79_2_98_2_28:1.1.2.5
	Kernel-5_35-4_79_2_98_2_27:1.1.2.5
	Kernel-5_35-4_79_2_98_2_26:1.1.2.5
	Kernel-5_35-4_79_2_111:1.1.2.5
	Kernel-5_35-4_79_2_98_2_25:1.1.2.5
	Kernel-5_35-4_79_2_98_2_24:1.1.2.5
	Kernel-5_35-4_79_2_98_2_23:1.1.2.5
	Kernel-5_35-4_79_2_110:1.1.2.5
	Kernel-5_35-4_79_2_98_2_22:1.1.2.5
	Kernel-5_35-4_79_2_109:1.1.2.5
	Kernel-5_35-4_79_2_98_2_21:1.1.2.5
	Kernel-5_35-4_79_2_98_2_20:1.1.2.5
	Kernel-5_35-4_79_2_108:1.1.2.5
	Kernel-5_35-4_79_2_107:1.1.2.5
	Kernel-5_35-4_79_2_98_2_19:1.1.2.5
	Kernel-5_35-4_79_2_98_2_18:1.1.2.5
	Kernel-5_35-4_79_2_98_2_17:1.1.2.5
	Kernel-5_35-4_79_2_98_2_16:1.1.2.5
	Kernel-5_35-4_79_2_98_2_15:1.1.2.5
	Kernel-5_35-4_79_2_106:1.1.2.5
	Kernel-5_35-4_79_2_105:1.1.2.5
	Kernel-5_35-4_79_2_104:1.1.2.5
	Kernel-5_35-4_79_2_98_2_14:1.1.2.5
	Kernel-5_35-4_79_2_98_2_13:1.1.2.5
	Kernel-5_35-4_79_2_98_2_12:1.1.2.5
	Kernel-5_35-4_79_2_98_2_11:1.1.2.5
	Kernel-5_35-4_79_2_98_2_10:1.1.2.5
	Kernel-5_35-4_79_2_98_2_9:1.1.2.5
	Kernel-5_35-4_79_2_103:1.1.2.5
	Kernel-5_35-4_79_2_102:1.1.2.5
	Kernel-5_35-4_79_2_98_2_8:1.1.2.5
	Kernel-5_35-4_79_2_98_2_7:1.1.2.5
	Kernel-5_35-4_79_2_98_2_6:1.1.2.5
	Kernel-5_35-4_79_2_98_2_5:1.1.2.5
	Kernel-5_35-4_79_2_98_2_4:1.1.2.5
	Kernel-5_35-4_79_2_101:1.1.2.5
	Kernel-5_35-4_79_2_100:1.1.2.5
	Kernel-5_35-4_79_2_99:1.1.2.5
	Kernel-5_35-4_79_2_98_2_3:1.1.2.5
	Kernel-5_35-4_79_2_98_2_2:1.1.2.5
	Kernel-5_35-4_79_2_98_2_1:1.1.2.5
	Cortex:1.1.2.5.0.2
	Cortex_bp:1.1.2.5
	Kernel-5_35-4_79_2_98:1.1.2.5
	Kernel-5_35-4_79_2_97:1.1.2.5
	Kernel-5_35-4_79_2_96:1.1.2.5
	Kernel-5_35-4_79_2_95:1.1.2.5
	Kernel-5_35-4_79_2_94:1.1.2.5
	Kernel-5_35-4_79_2_93:1.1.2.5
	Kernel-5_35-4_79_2_92:1.1.2.5
	Kernel-5_35-4_79_2_91:1.1.2.5
	Kernel-5_35-4_79_2_90:1.1.2.5
	Kernel-5_35-4_79_2_89:1.1.2.5
	Kernel-5_35-4_79_2_88:1.1.2.5
	Kernel-5_35-4_79_2_87:1.1.2.5
	Kernel-5_35-4_79_2_86:1.1.2.5
	Kernel-5_35-4_79_2_85:1.1.2.5
	Kernel-5_35-4_79_2_84:1.1.2.5
	Kernel-5_35-4_79_2_83:1.1.2.5
	Kernel-5_35-4_79_2_82:1.1.2.5
	Kernel-5_35-4_79_2_81:1.1.2.5
	Kernel-5_35-4_79_2_80:1.1.2.5
	Kernel-5_35-4_79_2_79:1.1.2.5
	Kernel-5_35-4_79_2_78:1.1.2.5
	Kernel-5_35-4_79_2_77:1.1.2.5
	RO_5_07:1.1.2.5
	Kernel-5_35-4_79_2_76:1.1.2.5
	Kernel-5_35-4_79_2_75:1.1.2.5
	Kernel-5_35-4_79_2_74:1.1.2.5
	Kernel-5_35-4_79_2_73:1.1.2.5
	Kernel-5_35-4_79_2_72:1.1.2.5
	Kernel-5_35-4_79_2_71:1.1.2.5
	Kernel-5_35-4_79_2_70:1.1.2.5
	Kernel-5_35-4_79_2_69:1.1.2.5
	Kernel-5_35-4_79_2_68:1.1.2.5
	Kernel-5_35-4_79_2_67:1.1.2.5
	Kernel-5_35-4_79_2_66:1.1.2.5
	Kernel-5_35-4_79_2_65:1.1.2.5
	Kernel-5_35-4_79_2_64:1.1.2.5
	Kernel-5_35-4_79_2_63:1.1.2.5
	Kernel-5_35-4_79_2_62:1.1.2.5
	Kernel-5_35-4_79_2_61:1.1.2.5
	Kernel-5_35-4_79_2_59:1.1.2.5
	Kernel-5_35-4_79_2_58:1.1.2.5
	Kernel-5_35-4_79_2_57:1.1.2.5
	Kernel-5_35-4_79_2_56:1.1.2.5
	Kernel-5_35-4_79_2_55:1.1.2.4
	Kernel-5_35-4_79_2_54:1.1.2.4
	Kernel-5_35-4_79_2_53:1.1.2.4
	Kernel-5_35-4_79_2_52:1.1.2.4
	Kernel-5_35-4_79_2_51:1.1.2.3
	Kernel-5_35-4_79_2_50:1.1.2.3
	Kernel-5_35-4_79_2_49:1.1.2.3
	Kernel-5_35-4_79_2_48:1.1.2.2
	Kernel-5_35-4_79_2_47:1.1.2.2
	Kernel-5_35-4_79_2_46:1.1.2.2
	Kernel-5_35-4_79_2_45:1.1.2.2
	Kernel-5_35-4_79_2_44:1.1.2.2
	Kernel-5_35-4_79_2_25_2_2:1.1.2.2
	Kernel-5_35-4_79_2_43:1.1.2.2
	Kernel-5_35-4_79_2_42:1.1.2.2
	Kernel-5_35-4_79_2_41:1.1.2.2
	Kernel-5_35-4_79_2_40:1.1.2.2
	Kernel-5_35-4_79_2_39:1.1.2.2
	Kernel-5_35-4_79_2_38:1.1.2.2
	Kernel-5_35-4_79_2_37:1.1.2.2
	Kernel-5_35-4_79_2_36:1.1.2.2
	Kernel-5_35-4_79_2_35:1.1.2.2
	Kernel-5_35-4_79_2_34:1.1.2.2
	Kernel-5_35-4_79_2_33:1.1.2.2
	Kernel-5_35-4_79_2_32:1.1.2.2
	Kernel-5_35-4_79_2_25_2_1:1.1.2.2
	Kernel-5_35-4_79_2_31:1.1.2.2
	Kernel-5_35-4_79_2_30:1.1.2.2
	Kernel-5_35-4_79_2_29:1.1.2.2
	Kernel-5_35-4_79_2_28:1.1.2.2
	Kernel-5_35-4_79_2_27:1.1.2.2
	Kernel-5_35-4_79_2_26:1.1.2.2
	Kernel-5_35-4_79_2_25:1.1.2.2
	Kernel-5_35-4_79_2_24:1.1.2.2
	Kernel-5_35-4_79_2_23:1.1.2.2
	Kernel-5_35-4_79_2_22:1.1.2.2
	Kernel-5_35-4_79_2_21:1.1.2.2
	Kernel-5_35-4_79_2_20:1.1.2.2
	Kernel-5_35-4_79_2_19:1.1.2.2
	Kernel-5_35-4_79_2_18:1.1.2.1
	Kernel-5_35-4_79_2_17:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


1.2
date	2016.06.30.20.07.36;	author jlee;	state Exp;
branches;
next	1.1;
commitid	IWoXxARWeuLDOwcz;

1.1
date	2001.02.13.09.36.03;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.02.13.09.36.03;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.03.07.15.12.50;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.10.16.17.23.11;	author bavison;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.12.13.17.38.10;	author bavison;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.02.21.20.21.50;	author bavison;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2014.12.06.10.28.46;	author rsprowson;	state Exp;
branches;
next	1.1.2.7;
commitid	bHUalvxulCRc0Y0y;

1.1.2.7
date	2016.02.28.17.00.43;	author rsprowson;	state Exp;
branches;
next	;
commitid	rbz3PPhs8KbOJHWy;


desc
@@


1.2
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@Overview
========

The HAL introduces the new concept of a "device". A device is a logical
representation of a component of hardware. Each active devices is uniquely
identified by a constant pointer to a device descriptor. The descriptor is
a structure which contains information about the device and a series of entry
points to perform usually simple operations on the device. Devices can be
provided by the Bootloader, or by RISC OS modules.

Devices provided outside the Bootloader are, in principle, hot swappable,
although it is up to device drivers using it whether they can support this.

Throughout this document, device descriptors are described in terms of C,
although the scheme maps naturally to assembler or C++. All device calls use
the base ATPCS calling standard (R0-R3 arguments/return values, R4-R11
preserved, R12 corrupted), to permit straightforward use from C or assembler.

From C:
        XXXDevice->Activate(XXXDevice);

A simple call to a activate a device from assembler might look like:

        LDR    R0, XXXDevice
        MOV    LR, PC
        LDR    PC, [R0, #DevEntry_Activate]      ; R0-R3,R12 corrupted

If an assembler device driver module is using a lot of device calls, it
might be preferable to move the workspace pointer from the traditional R12
to R11.


The device descriptor
=====================

The device descriptor starts with a fixed format header, as described
below. Following this header are more function pointers providing device-specific calls.

struct device
{
    uint16_t type;
    uint16_t id;
    uint32_t location;
    uint32_t version;
    const char *description;
    void *address;
    uint32_t reserved[3];
    bool (*Activate)(struct device *);
    void (*Deactivate)(struct device *);
    void (*Reset)(struct device *);
    int32_t (*Sleep)(struct device *, int32_t state);
    int32_t devicenumber;
    bool (*TestIRQ)(struct device *);
    uint32_t reserved[2];

};


struct serial
{
    struct device dev;
    uint8_t (*ReadByte)(struct serial *);
    void (*WriteByte)(struct serial *, uint8_t c);

    // private data
}

Hence, the first device specific function pointer is offset 32 bytes from the
device pointer.

Type
----
The type word describes what the device is.

   Bits 15-8: Top level type (eg video, sound, system peripheral, comms port)
              Defined values are: 1 = video
                                  2 = sound
                                  3 = system peripheral
                                  4 = comms port
   Bits 7-0:  Second level type (eg VDU display, 16-bit PCM sound output,
              interrupt controller, UART). Allocated independently within each top
              level type.

This half-word, together with the version number, indicate which device specific calls
are available.

ID
--
16-bit product code - a unique identifier for this particular device.

Location
--------
The location describes the location of the device in terms of the bus architecture
of the computer. Again, it is grouped by bytes.

   Bits 31-28: Bus type
                     0 => processor
                          eg. timer TCR0 on XScale coprocessor CP6
                     1 => main system bus
                          eg. DMA controller on OMAP3
                     2 => peripheral bus
                          eg. on chip UART on iMx6
                     3 => expansion bus
                          eg. UART inside the southbridge over PCI
                     4 => serial bus
                          eg. audio codec fed by a southbridge over PCI
   Bits 27-24: Bus sub-type (see Hdr:HALDevice for definitions)
   Bits 23-16: Bus number
   Bits 15-8:  Card number (PCI, expansion card etc) / chip select number
   Bits 7-0:   Unit number

The bus type fields are broadly ordered by access cost. Therefore peripherals directly attached to the ARM core are first, then on-chip buses typically at the same clock speed as the caches, then low bandwidth on chip peripheral buses, off chip expansion via circuit board tracks, and lastly the slowest/narrowest serial bus class.

Each step down the heirarchy typically involves a bridge component to translate the bus transactions. The processor bus, for example, has no translation as it is accessed using native ARM instructions.

Note that the field is describing the location of the device being described, which may itself emit another bus type. For example an APB connected IIC controller is on the peripheral bus (not the serial bus).

Version
-------
The version describes the version of the device API implemented. It consists of a
major version number (bits 31-16) and a minor version number (bits 15-0). A change in
major version number indicates an incompatible change of API. An increase in the
minor version number indicates backwards-compatible extensions to the API (eg
extra functions).

Description
-----------
A textual description of the device. This should be English, human-readable and
Basic Latin (characters &20-&7E). Descriptors along the lines of those output by
*Podules are expected. For example:

           National Semiconductor 16C550 UART
           Philips ISP1160 USB host controller
           Acorn IOMD21 PS/2 keyboard
           Acorn VIDC20
           Intel SA-1110 DMA controller

Address
-------
This field may either be 0, or may be a pointer to the base address of the
memory-mapped registers of the device in question. Drivers should not
normally use this field to directly poke the device. If they do, they must be
absolutely certain that there is no other way to achieve the effect, and that
the device type word is known to them. What exactly the address points to
depends on the exact device in question.

Activate
--------
A device driver must call the Activate entry point before using a device. A
success/failure indication is returned: 1 indicates successful activation, 0 indicates
unsuccessful. Devices may ignore activate/deactivate calls, count them, or
may alternatively provide full locking to allow only one activation. Typically this
would be called by in a driver's module initialisation routine. Alternatively, it might
be called just before a DeviceFS device is opened for access.

Deactivate
----------
A device driver must call the Deactivate entry point when it has finished
using a device.

Reset
-----
The Kernel will call the Reset entry point of every device on the system
before performing a software reset (eg OS_Reset or Ctrl-Break), after it has
issued Service_PreReset. All devices must enter a quiescent state.

Sleep
-----
This call reads or sets a device's power-down state. If the second parameter is -1,
then the current state is returned; otherwise the second parameter must be a value in
the range 0-255 giving sleepiness (0 = full power, 255 = off) and the old sleepiness
is returned. Note that the value returned does not have to match the last value
programmed: for example, if a device cannot power down, it will always return 0.

DeviceNumber
------------
If this is -1, then the device has no associated interrupt. Otherwise, bits 0-30 give
the device number and bit 31 flags that the device vector is shared, ie this is the R0
that should be passed to OS_ClaimDeviceVector. If bit 31 is set then the TestIRQ
routine must be used to determine whether the vector should be claimed or passed on.

TestIRQ
-------
Returns 0 if the device is not interrupting, or 1 if the device is interrupting.
When DeviceNumber is -1, this must be a null pointer.


Workspace
=========

As noted in the overview, a device may be implemented either in the HAL
or supplemented after the kernel starts through RISC OS modules.

The HAL uses the ATPCS assigned static base (sb/r9) to access position
independent data, while traditional modules use the workspace pointer (wp/r12).
Assembler modules use r12 directly, for C modules CMHG arranges this to keep
track of position independent data as r12 may be corrupted across function
calls as the ATPCS uses it as scratch register 'ip'.

When designing device specific extensions to the basic device descriptor, do
not create a dependence on the data pointer that would preclude implementing
the device in the HAL or a RISC OS module.

Each device specific extension takes a
  struct device *
as its first argument. This is the structure which is defined as part of the
client API. You are free to keep other unrelated private data or state in
addition to this structure, typically this would be implemented as:

a) For a HAL based device, the device structure is typically allocated from
   the global HAL workspace, so it is possible to compute the base of that
   workspace (and hence recover sb) by subtraction.
   Alternatively, keep a larger version of the structure internally, and
   keep the original sb in a private area off the end or the one seen by
   the client.
   In both cases the original sb was known at the point the HAL device was
   registered.
b) For a RISC OS module based device, keep private data in global variables
   associated with your module. CMHG will dereference these automatically
   by deriving offsets from the R12 value passed to the CMHG veneers.


Creation and removal of devices
===============================

Devices are declared by calling the HAL->OS call OS_AddDevice or SWI OS_Hardware 2.

SWI OS_Hardware 2 (SWI &7A)
---------------------------
On entry: R0 -> device descriptor
          R8 = 2
On exit:  All registers preserved

void OS_AddDevice(uint32_t flags, struct device *d);

void HAL_InitDevices(uint32_t flags);

Declare a new device to the system. OS_AddDevice must not be called until
HAL_InitDevices is called.


Devices are removed by calling OS_Hardware 3. There is no HAL->OS equivalent.

SWI OS_Hardware 3 (SWI &7A)
---------------------------
On entry: R0 -> device descriptor
          R8 = 3
On exit:  All registers preserved


The Kernel tracks all present devices, issuing service calls as devices come and go, and
providing a call to enumerate devices of a particular type.

SWI OS_Hardware 4 (SWI &7A)
---------------------------
On entry: R0 bits 0-15  = type to match
             bits 16-31 = maximum major version number to match
          R1 = 0 to start an enumeration, else preserved from last call
          R8 = 4
On exit:  R1 = -1 if there are no (more) devices of this type
          R2 -> device descriptor (undefined if R1 = -1)
          Other registers preserved


Service_Hardware  (Service Call &D9)
------------------------------------
On entry: R0 bits 0-7 = sub-reason code, bits 8-31 flags (undefined, ignore)
          R1 = reason code (&D9)
          R2 -> device
On exit:  Depends on sub-reason code

          Sub-reason code 0: Device added
On exit:  All registers must be preserved

          Sub-reason code 1: Device being removed
On exit:  R1 = 0 => we object to device being removed
                    R0 -> error block
                    other registers must be preserved
          else all registers must be preserved
@


1.1
log
@file NewAPI was initially added on branch HAL.
@
text
@d1 279
@


1.1.2.1
log
@Various L7200 tweaks, plus working ARM920T code.

Version 5.35, 4.79.2.17. Tagged as 'Kernel-5_35-4_79_2_17'
@
text
@a0 27
struct peripheral
{
    uint32_t type;
    uint32_t location;
    uint32_t version;
    const char *description;
    uint32_t reserved[4];
    int (*Activate)(struct peripheral *);
    void (*Deactivate)(struct peripheral *)
    void (*Reset)(struct peripheral *);
    int (*Sleep)(struct peripheral *, state);
    int (*Claim)(struct peripheral *, int intno, myfunc, handle);
    void (*Release)(struct peripheral *, int intno, myfunc, handle);
    uint32_t reserved[2];

};


struct serial
{
    struct peripheral p;
    int (*ReadByte)(struct serial *);

    // private data
}


@


1.1.2.2
log
@Customer L-y HAL-y IIC-y type stuff. It's great.
@
text
@d1 1
a1 40
Overview
========

The HAL introduces the new concept of a "device". A device is a logical
representation of a component of hardware. Each active devices is uniquely
identified by a constant pointer to a device descriptor. The descriptor is
a structure which contains information about the device and a series of entry
points to perform usually simple operations on the device. Devices can be
provided by the Bootloader, or by RISC OS modules.

Devices provided outside the Bootloader are, in principle, hot swappable,
although it is up to device drivers using it whether they can support this.

Throughout this document, device descriptors are described in terms of C,
although the scheme maps naturally to assembler or C++. All device calls use
the base ATPCS calling standard (R0-R3 arguments/return values, R4-R11
preserved, R12 corrupted), to permit straightforward use from C or assembler.

From C:
        XXXDevice->Activate(XXXDevice);

A simple call to a activate a device from assembler might look like:

        LDR    R0, XXXDevice
        MOV    LR, PC
        LDR    PC, [R0, #DevEntry_Activate]      ; R0-R3,R12 corrupted

If an assembler device driver module is using a lot of device calls, it
might be preferable to move the workspace pointer from the traditional R12
to R11.
       

The device descriptor
=====================

The device descriptor starts with a fixed format header, as described
below. Following this header are more function pointers providing device-specific
calls.

struct device
d3 1
a3 2
    uint16_t type;
    uint16_t id;
d7 1
a7 2
    void *address;
    uint32_t reserved[3];
d21 1
a21 1
    struct device dev;
a22 1
    void (*WriteByte)(struct serial *, int c);
a25 119

Hence, the first device specific function pointer is offset 32 bytes from the
device pointer.

Type
----
The type word describes what the device is. It is grouped into sub-words as follows:

   Bits 31-24: Top level type (eg video, sound, system peripheral, comms port)
   Bits 23-16: Second level type (eg VDU display, 16-bit PCM sound output,
               interrupt controller, UART).
   Bits 15-0:  Product code - a unique identifier for this particular device.

A device driver will normally search for devices with a specific value in bits 31-16,
and not care about bits 15-0. Bits 31-16, together with the version number, indicate
which device specific calls are available.

Location
--------
The location describes the location of the device in terms of the bus architecture
of the computer. Again, it is grouped by bytes.

   Bits 31-24: Bus type
                     0 => processor (0 = core, 1 = coprocessor)
                     1 => main system bus (0 = AHB, 1 = ASB)
                     2 => peripheral bus (0 = APB)
                     3 => expansion bus (0 = Acorn Expansion Card, 1 = ISA, 2 = PCI)
   Bits 23-16: Bus
   Bits 15-8:  Card number (PCI, expansion card etc) / chip select number
   Bits 7-0:   Unit number

Version
-------
The version describes the version of the device API implemented. It consists of a
major version number (bits 31-16) and a minor version number (bits 15-0). A change in
major version number indicates an incompatible change of API. An increase in the
minor version number indicates backwards-compatible extensions to the API (eg
extra functions).

Description
-----------
A textual description of the device. This should be English, human-readable and
Basic Latin (characters &20-&7E). Descriptors along the lines of those output by
*Podules are expected. For example:

           National Semiconductor 16C550 UART
           Philips ISP1160 USB host controller
           Acorn IOMD21 PS/2 keyboard
           Acorn VIDC20
           Intel SA-1110 DMA controller

Address
-------
This field may either be 0, or may be a pointer to the base address of the
memory-mapped registers of the device in question. Drivers should not
normally use this field to directly poke the device. If they do, they must be
absolutely certain that there is no other way to achieve the effect, and that
the device type word is known to them. What exactly the address points to
depends on the exact device in question.

Activate
--------
A device driver must call the Activate entry point before using a device. A
success/failure indication is returned: 0 indicates successful activation, -1 indicates
unsuccessful. Devices may ignore activate/deactivate calls, count them, or
may alternatively provide full locking to allow only one activation. Typically this
would be called by in a driver's module initialisation routine. Alternatively, it might
be called just before a DeviceFS device is opened for access.

Deactivate
----------
A device driver must call the Deactivate entry point when it has finished
using a device.

Reset
-----
The Kernel will call the Reset entry point of every device on the system
before performing a software reset (eg OS_Reset or Ctrl-Break), after it has
issued Service_PreReset. All devices must enter a quiescent state.

Claim
-----
Claim is a front-end to OS_ClaimDeviceVector. The device should set up interrupt
parameters appropriately for the interrupt in question, and call OS_ClaimDeviceVector.




Creation and removal of devices
===============================

Devices are declared by calling the HAL->OS call OS_AddDevice or SWI OS_Hardware 2.

SWI OS_Hardware 2 (SWI &7A)
---------------------------
On entry: R0 -> device descriptor
          R8 = 2
On exit:  All registers preserved

void OS_AddDevice(device *d);

Declare a new device to the system.

Devices are removed by calling OS_Hardware 3. There is no HAL->OS equivalent.

SWI OS_Hardware 3 (SWI &7A)
---------------------------
On entry: R0 -> device descriptor
          R8 = 3
On exit:  All registers preserved

The Kernel tracks all present devices, issuing service calls as devices come and go, and
providing a call to enumerate devices of a particular type.

SWI OS_Hardware 4 (SWI &7A)
---------------------------
On entry: R0 = type
          R8 = 4
On exit:
@


1.1.2.3
log
@  Mostly device stuff.
Detail:
  * Implemented OS_Hardware 2, 3 and 4 as described in Docs.HAL.NewAPI.
  * Added new OS->HAL and HAL->OS routines to register HAL devices with the
    OS during hard resets.
  * Updated Docs.HAL.NewAPI to correct inconsistencies, fill in missing
    definitions, and allow for interrupt sharing.
  * Now uses OS_LeaveOS to trigger callbacks after ROM module init.
Admin:
  Untested. Requires new HAL.

Version 5.35, 4.79.2.49. Tagged as 'Kernel-5_35-4_79_2_49'
@
text
@d49 6
a54 6
    bool (*Activate)(struct device *);
    void (*Deactivate)(struct device *);
    void (*Reset)(struct device *);
    int32_t (*Sleep)(struct device *, int32_t state);
    int32_t devicenumber;
    bool (*TestIRQ)(struct device *);
d63 2
a64 2
    uint8_t (*ReadByte)(struct serial *);
    void (*WriteByte)(struct serial *, uint8_t c);
d74 1
a74 1
The type word describes what the device is.
d76 8
a83 15
   Bits 15-8: Top level type (eg video, sound, system peripheral, comms port)
              Defined values are: 1 = video
                                  2 = sound
                                  3 = system peripheral
                                  4 = comms port
   Bits 7-0:  Second level type (eg VDU display, 16-bit PCM sound output,
              interrupt controller, UART). Allocated independently within each top
              level type.

This half-word, together with the version number, indicate which device specific calls
are available.

ID
--
16-bit product code - a unique identifier for this particular device.
d131 1
a131 1
success/failure indication is returned: 1 indicates successful activation, 0 indicates
d148 1
a148 1
Sleep
d150 2
a151 12
This call reads or sets a device's power-down state. If the second parameter is -1,
then the current state is returned; otherwise the second parameter must be a value in
the range 0-255 giving sleepiness (0 = full power, 255 = off) and the old sleepiness
is returned. Note that the value returned does not have to match the last value
programmed: for example, if a device cannot power down, it will always return 0.

DeviceNumber
------------
If this is -1, then the device has no associated interrupt. Otherwise, bits 0-30 give
the device number and bit 31 flags that the device vector is shared, ie this is the R0
that should be passed to OS_ClaimDeviceVector. If bit 31 is set then the TestIRQ
routine must be used to determine whether the vector should be claimed or passed on.
a152 4
TestIRQ
-------
Returns 0 if the device is not interrupting, or 1 if the device is interrupting.
When DeviceNumber is -1, this must be a null pointer.
d167 1
a167 6
void OS_AddDevice(uint32_t flags, struct device *d);

void HAL_InitDevices(uint32_t flags);

Declare a new device to the system. OS_AddDevice must not be called until
HAL_InitDevices is called.
d169 1
a178 1

d184 1
a184 2
On entry: R0 = type to match
          R1 = 0 to start an enumeration, else preserved from last call
d186 3
a188 20
On exit:  R1 = -1 if there are no (more) devices of this type
          R2 -> device descriptor (undefined if R1 = -1)
          Other registers preserved


Service_Device  (Service Call &??)
----------------------------------
On entry: R0 bits 0-7 = sub-reason code, bits 8-31 flags (undefined, ignore)
          R1 = reason code (&??)
          R2 -> device
On exit:  Depends on sub-reason code

          Sub-reason code 0: Device added
On exit:  All registers must be preserved

          Sub-reason code 1: Device being removed
On exit:  R1 = 0 => we object to device being removed
                    R0 -> error block
                    other registers must be preserved
          else all registers must be preserved
@


1.1.2.4
log
@  HAL device support, and a couple of new service calls.
Detail:
  * Rejigged documented meaning of device "Location" field so that we can
    fit full PCI locations in.
  * Defined lots of device "Type" values in Hdr:HALDevice.
  * Removed obsolete DMA-related HAL entries in Hdr:HALEntries (no longer
    required by DMAManager 0_15-4_4_2_6, no longer provided by Tungsten HAL
    0.07).
  * OS_Hardware 2 and 3 actually work now.
  * Changed OS_Hardware 4 to take a maximum major version number to match.
  * HAL workspace is now USR mode readable.
  * Service calls issued after module initialisation/finalisation (see
    Docs.ModPostServ).
Admin:
  OS_Hardware tested, service calls not tested.

Version 5.35, 4.79.2.52. Tagged as 'Kernel-5_35-4_79_2_52'
@
text
@d97 1
a97 1
   Bits 31-28: Bus type
d102 1
a102 2
   Bits 27-24: Bus sub-type (see above)
   Bits 23-16: Bus number
d210 1
a210 2
On entry: R0 bits 0-15  = type to match
             bits 16-31 = maximum major version number to match
d218 2
a219 2
Service_Hardware  (Service Call &D9)
------------------------------------
d221 1
a221 1
          R1 = reason code (&D9)
@


1.1.2.5
log
@  Miscellaneous stuff.
Detail:
  * Merged in the change to RISC OS 4.02 kernel that moved the GSTrans
    workspace out of scratch space.
  * Fixed a few bugs in callback postponement, and interrupt holes in
    callback dispatch. See Docs.CallbackChange for full info.
  * Fixed SystemSizeCMOS to SysHeapCMOS - wouldn't build as was.
  * Added an export of a C version of Hdr:HALDevice, based on the Hdr2H
    translation but with an additional struct definition. Required by
    SoundControl 1.00.
  * Added some additional location and ID allocations to Hdr:HALDevice.
    Required by today's HAL and SoundControl.
Admin:
  Partially tested.

Version 5.35, 4.79.2.56. Tagged as 'Kernel-5_35-4_79_2_56'
@
text
@d99 1
a99 1
                     1 => main system bus (0 = AHB, 1 = ASB, 2 = PXBus)
a101 1
                     4 => serial bus (0 = AC-Link)
@


1.1.2.6
log
@Untangle some buses
Docs/HAL/NewAPI:
 More clearly describe the intent of the different bus types.
hdr/HALDevice
 Reclassify the OMAP interconnect as either a system bus or peripheral bus, noting their names from the datasheet.
 Reclassify the GPMC as an expansion bus.
 Add AMBA 3's AXI bus, which (along with the existing AHB/APB) is what iMx6 uses. Delete redundant iMx6 interconnect type.

Version 5.35, 4.79.2.249. Tagged as 'Kernel-5_35-4_79_2_249'
@
text
@d98 6
a103 11
                     0 => processor
                          eg. timer TCR0 on XScale coprocessor CP6
                     1 => main system bus
                          eg. DMA controller on OMAP3
                     2 => peripheral bus
                          eg. on chip UART on iMx6
                     3 => expansion bus
                          eg. UART inside the southbridge over PCI
                     4 => serial bus
                          eg. audio codec fed by a southbridge over PCI
   Bits 27-24: Bus sub-type (see Hdr:HALDevice for definitions)
a107 6
The bus type fields are broadly ordered by access cost. Therefore peripherals directly attached to the ARM core are first, then on-chip buses typically at the same clock speed as the caches, then low bandwidth on chip peripheral buses, off chip expansion via circuit board tracks, and lastly the slowest/narrowest serial bus class.

Each step down the heirarchy typically involves a bridge component to translate the bus transactions. The processor bus, for example, has no translation as it is accessed using native ARM instructions.

Note that the field is describing the location of the device being described, which may itself emit another bus type. For example an APB connected IIC controller is on the peripheral bus (not the serial bus).

@


1.1.2.7
log
@Define some extra platform feature flags
For disc based applications (ie. those that don't know the architecture at build time, like a ROM would) we have OS_PlatformFeatures to provide an abstract way of seeing when new chunks of instructions get added. Back at ARMv6 ARM deprecated SWP, but currently we have no way of knowing that at runtime without grubbing round the coprocessor registers.
Add 3 new flags
* One to say LDR/STREX is (not) available
* One to say that SWP/SWPB is (not) available
* One to say that CLREX and LDR/STREX[B|H|D] is (not) available
shame it took a few goes for ARM to bring in these variants, requiring 3 flags not 1.

Also:
Condition the exception on vector read code on No32bitCode, rather than just having it permanently disabled.
Improve the HAL device docs.

Tested on a StrongARM Risc PC, Model B Pi, and Titanium.

Version 5.35, 4.79.2.303. Tagged as 'Kernel-5_35-4_79_2_303'
@
text
@d31 1
a31 1

d37 2
a38 1
below. Following this header are more function pointers providing device-specific calls.
a188 34
Workspace
=========

As noted in the overview, a device may be implemented either in the HAL
or supplemented after the kernel starts through RISC OS modules.

The HAL uses the ATPCS assigned static base (sb/r9) to access position
independent data, while traditional modules use the workspace pointer (wp/r12).
Assembler modules use r12 directly, for C modules CMHG arranges this to keep
track of position independent data as r12 may be corrupted across function
calls as the ATPCS uses it as scratch register 'ip'.

When designing device specific extensions to the basic device descriptor, do
not create a dependence on the data pointer that would preclude implementing
the device in the HAL or a RISC OS module.

Each device specific extension takes a
  struct device *
as its first argument. This is the structure which is defined as part of the
client API. You are free to keep other unrelated private data or state in
addition to this structure, typically this would be implemented as:

a) For a HAL based device, the device structure is typically allocated from
   the global HAL workspace, so it is possible to compute the base of that
   workspace (and hence recover sb) by subtraction.
   Alternatively, keep a larger version of the structure internally, and
   keep the original sb in a private area off the end or the one seen by
   the client.
   In both cases the original sb was known at the point the HAL device was
   registered.
b) For a RISC OS module based device, keep private data in global variables
   associated with your module. CMHG will dereference these automatically
   by deriving offsets from the R12 value passed to the CMHG veneers.

@



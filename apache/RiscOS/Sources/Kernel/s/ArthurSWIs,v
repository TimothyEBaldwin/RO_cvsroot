head	4.15;
access;
symbols
	Kernel-6_14:4.15
	Kernel-6_01-3:4.14
	Kernel-6_13:4.15
	Kernel-6_12:4.15
	Kernel-6_11:4.15
	Kernel-6_10:4.15
	Kernel-6_09:4.15
	Kernel-6_08-4_129_2_10:4.14.2.1
	Kernel-6_08-4_129_2_9:4.14.2.1
	Kernel-6_08:4.15
	Kernel-6_07:4.15
	Kernel-6_06:4.15
	Kernel-6_05-4_129_2_8:4.14.2.1
	Kernel-6_05:4.15
	Kernel-6_04:4.15
	Kernel-6_03:4.15
	Kernel-6_01-2:4.14
	Kernel-6_01-4_146_2_1:4.14
	Kernel-6_02:4.14
	Kernel-6_01-1:4.14
	Kernel-6_01:4.14
	Kernel-6_00:4.14
	Kernel-5_99:4.14
	Kernel-5_98:4.14
	Kernel-5_97-4_129_2_7:4.14
	Kernel-5_97:4.14
	Kernel-5_96:4.14
	Kernel-5_95:4.14
	Kernel-5_94:4.14
	Kernel-5_93:4.14
	Kernel-5_92:4.14
	Kernel-5_91:4.14
	Kernel-5_90:4.14
	Kernel-5_89-4_129_2_6:4.14
	Kernel-5_89:4.14
	Kernel-5_88-4_129_2_5:4.14
	Kernel-5_88-4_129_2_4:4.14
	Kernel-5_88:4.14
	Kernel-5_87:4.14
	Kernel-5_86-4_129_2_3:4.14
	Kernel-5_86-4_129_2_2:4.14
	Kernel-5_86-4_129_2_1:4.14
	Kernel-5_86:4.14
	SMP:4.14.0.2
	SMP_bp:4.14
	Kernel-5_85:4.14
	Kernel-5_54-1:4.13
	Kernel-5_84:4.14
	Kernel-5_83:4.14
	Kernel-5_82:4.14
	Kernel-5_81:4.14
	Kernel-5_80:4.14
	Kernel-5_79:4.14
	Kernel-5_78:4.14
	Kernel-5_77:4.14
	Kernel-5_76:4.14
	Kernel-5_75:4.14
	Kernel-5_74:4.14
	Kernel-5_73:4.14
	Kernel-5_72:4.14
	Kernel-5_71:4.14
	Kernel-5_70:4.14
	Kernel-5_69:4.14
	Kernel-5_68:4.14
	Kernel-5_67:4.14
	Kernel-5_66:4.14
	Kernel-5_65:4.13
	Kernel-5_64:4.13
	Kernel-5_63:4.13
	Kernel-5_62:4.13
	Kernel-5_61:4.13
	Kernel-5_60:4.13
	Kernel-5_59:4.13
	Kernel-5_58:4.13
	Kernel-5_57:4.13
	Kernel-5_56:4.13
	Kernel-5_55:4.13
	Kernel-5_54:4.13
	Kernel-5_53:4.12
	Kernel-5_52:4.12
	Kernel-5_51:4.12
	Kernel-5_50:4.11
	Kernel-5_49:4.10
	HAL_merge:4.8.2.22
	Kernel-5_48:4.9
	Kernel-5_35-4_79_2_327:4.8.2.22
	Kernel-5_35-4_79_2_326:4.8.2.21
	Kernel-5_35-4_79_2_325:4.8.2.21
	Kernel-5_35-4_79_2_324:4.8.2.21
	Kernel-5_35-4_79_2_323:4.8.2.21
	Kernel-5_35-4_79_2_322:4.8.2.21
	Kernel-5_35-4_79_2_321:4.8.2.21
	Kernel-5_35-4_79_2_320:4.8.2.21
	Kernel-5_35-4_79_2_319:4.8.2.21
	Kernel-5_35-4_79_2_318:4.8.2.21
	Kernel-5_35-4_79_2_317:4.8.2.21
	Kernel-5_35-4_79_2_316:4.8.2.21
	Kernel-5_35-4_79_2_315:4.8.2.21
	Kernel-5_35-4_79_2_314:4.8.2.21
	Kernel-5_35-4_79_2_313:4.8.2.21
	Kernel-5_35-4_79_2_312:4.8.2.20
	Kernel-5_35-4_79_2_311:4.8.2.20
	Kernel-5_35-4_79_2_310:4.8.2.20
	Kernel-5_35-4_79_2_309:4.8.2.20
	Kernel-5_35-4_79_2_308:4.8.2.20
	Kernel-5_35-4_79_2_307:4.8.2.20
	Kernel-5_35-4_79_2_306:4.8.2.20
	Kernel-5_35-4_79_2_305:4.8.2.20
	Kernel-5_35-4_79_2_304:4.8.2.20
	Kernel-5_35-4_79_2_303:4.8.2.20
	Kernel-5_35-4_79_2_302:4.8.2.20
	Kernel-5_35-4_79_2_301:4.8.2.20
	Kernel-5_35-4_79_2_300:4.8.2.20
	Kernel-5_35-4_79_2_299:4.8.2.20
	Kernel-5_35-4_79_2_298:4.8.2.20
	Kernel-5_35-4_79_2_297:4.8.2.20
	Kernel-5_35-4_79_2_296:4.8.2.20
	Kernel-5_35-4_79_2_295:4.8.2.20
	Kernel-5_35-4_79_2_294:4.8.2.20
	Kernel-5_35-4_79_2_293:4.8.2.20
	Kernel-5_35-4_79_2_292:4.8.2.20
	Kernel-5_35-4_79_2_291:4.8.2.20
	Kernel-5_35-4_79_2_290:4.8.2.20
	Kernel-5_35-4_79_2_289:4.8.2.20
	Kernel-5_35-4_79_2_288:4.8.2.20
	Kernel-5_35-4_79_2_287:4.8.2.20
	Kernel-5_35-4_79_2_286:4.8.2.20
	Kernel-5_35-4_79_2_285:4.8.2.20
	Kernel-5_35-4_79_2_284:4.8.2.20
	Kernel-5_35-4_79_2_283:4.8.2.20
	Kernel-5_35-4_79_2_282:4.8.2.20
	Kernel-5_35-4_79_2_281:4.8.2.20
	Kernel-5_35-4_79_2_280:4.8.2.20
	Kernel-5_35-4_79_2_279:4.8.2.20
	Kernel-5_35-4_79_2_278:4.8.2.20
	Kernel-5_35-4_79_2_277:4.8.2.20
	Kernel-5_35-4_79_2_276:4.8.2.20
	Kernel-5_35-4_79_2_275:4.8.2.20
	Kernel-5_35-4_79_2_274:4.8.2.20
	Kernel-5_35-4_79_2_273:4.8.2.20
	Kernel-5_35-4_79_2_272:4.8.2.20
	Kernel-5_35-4_79_2_271:4.8.2.20
	Kernel-5_35-4_79_2_270:4.8.2.20
	Kernel-5_35-4_79_2_269:4.8.2.20
	Kernel-5_35-4_79_2_268:4.8.2.20
	Kernel-5_35-4_79_2_267:4.8.2.20
	Kernel-5_35-4_79_2_266:4.8.2.20
	Kernel-5_35-4_79_2_265:4.8.2.20
	Kernel-5_35-4_79_2_264:4.8.2.20
	Kernel-5_35-4_79_2_263:4.8.2.20
	Kernel-5_35-4_79_2_262:4.8.2.20
	Kernel-5_35-4_79_2_261:4.8.2.20
	Kernel-5_35-4_79_2_260:4.8.2.20
	Kernel-5_35-4_79_2_259:4.8.2.20
	Kernel-5_35-4_79_2_258:4.8.2.20
	Kernel-5_35-4_79_2_257:4.8.2.20
	Kernel-5_35-4_79_2_256:4.8.2.20
	Kernel-5_35-4_79_2_255:4.8.2.20
	Kernel-5_35-4_79_2_254:4.8.2.20
	Kernel-5_35-4_79_2_253:4.8.2.20
	Kernel-5_35-4_79_2_252:4.8.2.20
	Kernel-5_35-4_79_2_251:4.8.2.20
	Kernel-5_35-4_79_2_250:4.8.2.20
	Kernel-5_35-4_79_2_249:4.8.2.20
	Kernel-5_35-4_79_2_248:4.8.2.20
	Kernel-5_35-4_79_2_247:4.8.2.20
	Kernel-5_35-4_79_2_246:4.8.2.20
	Kernel-5_35-4_79_2_245:4.8.2.20
	Kernel-5_35-4_79_2_244:4.8.2.20
	Kernel-5_35-4_79_2_243:4.8.2.20
	Kernel-5_35-4_79_2_242:4.8.2.20
	Kernel-5_35-4_79_2_241:4.8.2.20
	Kernel-5_35-4_79_2_240:4.8.2.20
	Kernel-5_35-4_79_2_239:4.8.2.20
	Kernel-5_35-4_79_2_238:4.8.2.20
	Kernel-5_35-4_79_2_237:4.8.2.20
	Kernel-5_35-4_79_2_236:4.8.2.20
	Kernel-5_35-4_79_2_235:4.8.2.20
	Kernel-5_35-4_79_2_234:4.8.2.20
	Kernel-5_35-4_79_2_233:4.8.2.20
	Kernel-5_35-4_79_2_232:4.8.2.20
	Kernel-5_35-4_79_2_231:4.8.2.20
	Kernel-5_35-4_79_2_230:4.8.2.20
	Kernel-5_35-4_79_2_229:4.8.2.20
	Kernel-5_35-4_79_2_228:4.8.2.20
	Kernel-5_35-4_79_2_227:4.8.2.20
	Kernel-5_35-4_79_2_226:4.8.2.20
	Kernel-5_35-4_79_2_225:4.8.2.20
	Kernel-5_35-4_79_2_224:4.8.2.20
	Kernel-5_35-4_79_2_223:4.8.2.20
	Kernel-5_35-4_79_2_222:4.8.2.20
	Kernel-5_35-4_79_2_221:4.8.2.19
	Kernel-5_35-4_79_2_220:4.8.2.19
	Kernel-5_35-4_79_2_219:4.8.2.19
	Kernel-5_35-4_79_2_218:4.8.2.19
	Kernel-5_35-4_79_2_217:4.8.2.19
	Kernel-5_35-4_79_2_216:4.8.2.19
	Kernel-5_35-4_79_2_215:4.8.2.19
	Kernel-5_35-4_79_2_214:4.8.2.19
	Kernel-5_35-4_79_2_213:4.8.2.19
	Kernel-5_35-4_79_2_212:4.8.2.19
	Kernel-5_35-4_79_2_211:4.8.2.19
	Kernel-5_35-4_79_2_210:4.8.2.19
	Kernel-5_35-4_79_2_209:4.8.2.19
	Kernel-5_35-4_79_2_208:4.8.2.19
	Kernel-5_35-4_79_2_207:4.8.2.19
	Kernel-5_35-4_79_2_206:4.8.2.19
	Kernel-5_35-4_79_2_205:4.8.2.19
	Kernel-5_35-4_79_2_204:4.8.2.19
	Kernel-5_35-4_79_2_203:4.8.2.18
	Kernel-5_35-4_79_2_202:4.8.2.17
	Kernel-5_35-4_79_2_201:4.8.2.17
	Kernel-5_35-4_79_2_200:4.8.2.17
	Kernel-5_35-4_79_2_199:4.8.2.17
	Kernel-5_35-4_79_2_198:4.8.2.17
	Kernel-5_35-4_79_2_197:4.8.2.17
	Kernel-5_35-4_79_2_196:4.8.2.17
	Kernel-5_35-4_79_2_195:4.8.2.17
	Kernel-5_35-4_79_2_194:4.8.2.17
	Kernel-5_35-4_79_2_193:4.8.2.17
	Kernel-5_35-4_79_2_192:4.8.2.17
	Kernel-5_35-4_79_2_191:4.8.2.17
	Kernel-5_35-4_79_2_190:4.8.2.17
	Kernel-5_35-4_79_2_189:4.8.2.17
	Kernel-5_35-4_79_2_188:4.8.2.17
	Kernel-5_35-4_79_2_187:4.8.2.17
	Kernel-5_35-4_79_2_186:4.8.2.17
	Kernel-5_35-4_79_2_185:4.8.2.17
	Kernel-5_35-4_79_2_184:4.8.2.17
	Kernel-5_35-4_79_2_183:4.8.2.17
	Kernel-5_35-4_79_2_182:4.8.2.16
	Kernel-5_35-4_79_2_181:4.8.2.16
	Kernel-5_35-4_79_2_180:4.8.2.16
	Kernel-5_35-4_79_2_179:4.8.2.16
	Kernel-5_35-4_79_2_178:4.8.2.16
	Kernel-5_35-4_79_2_177:4.8.2.16
	Kernel-5_35-4_79_2_176:4.8.2.16
	Kernel-5_35-4_79_2_175:4.8.2.16
	Kernel-5_35-4_79_2_174:4.8.2.16
	Kernel-5_35-4_79_2_173:4.8.2.15
	Kernel-5_35-4_79_2_172:4.8.2.15
	Kernel-5_35-4_79_2_171:4.8.2.15
	Kernel-5_35-4_79_2_170:4.8.2.15
	Kernel-5_35-4_79_2_169:4.8.2.15
	Kernel-5_35-4_79_2_168:4.8.2.15
	Kernel-5_35-4_79_2_167:4.8.2.15
	Kernel-5_35-4_79_2_166:4.8.2.15
	Kernel-5_35-4_79_2_165:4.8.2.15
	RPi_merge:4.8.2.15
	Kernel-5_35-4_79_2_147_2_23:4.8.2.15
	Kernel-5_35-4_79_2_147_2_22:4.8.2.15
	Kernel-5_35-4_79_2_147_2_21:4.8.2.15
	Kernel-5_35-4_79_2_147_2_20:4.8.2.15
	Kernel-5_35-4_79_2_147_2_19:4.8.2.15
	Kernel-5_35-4_79_2_147_2_18:4.8.2.15
	Kernel-5_35-4_79_2_164:4.8.2.15
	Kernel-5_35-4_79_2_163:4.8.2.15
	Kernel-5_35-4_79_2_147_2_17:4.8.2.15
	Kernel-5_35-4_79_2_147_2_16:4.8.2.15
	Kernel-5_35-4_79_2_147_2_15:4.8.2.15
	Kernel-5_35-4_79_2_162:4.8.2.15
	Kernel-5_35-4_79_2_161:4.8.2.15
	Kernel-5_35-4_79_2_147_2_14:4.8.2.15
	Kernel-5_35-4_79_2_147_2_13:4.8.2.15
	Kernel-5_35-4_79_2_160:4.8.2.15
	Kernel-5_35-4_79_2_159:4.8.2.15
	Kernel-5_35-4_79_2_158:4.8.2.15
	Kernel-5_35-4_79_2_157:4.8.2.15
	Kernel-5_35-4_79_2_156:4.8.2.15
	Kernel-5_35-4_79_2_147_2_12:4.8.2.15
	Kernel-5_35-4_79_2_147_2_11:4.8.2.15
	Kernel-5_35-4_79_2_155:4.8.2.15
	Kernel-5_35-4_79_2_147_2_10:4.8.2.15
	Kernel-5_35-4_79_2_154:4.8.2.15
	Kernel-5_35-4_79_2_153:4.8.2.15
	Kernel-5_35-4_79_2_147_2_9:4.8.2.15
	Kernel-5_35-4_79_2_152:4.8.2.15
	Kernel-5_35-4_79_2_151:4.8.2.15
	Kernel-5_35-4_79_2_147_2_8:4.8.2.15
	Kernel-5_35-4_79_2_147_2_7:4.8.2.15
	Kernel-5_35-4_79_2_150:4.8.2.15
	Kernel-5_35-4_79_2_147_2_6:4.8.2.15
	Kernel-5_35-4_79_2_147_2_5:4.8.2.15
	Kernel-5_35-4_79_2_149:4.8.2.15
	Kernel-5_35-4_79_2_147_2_4:4.8.2.15
	Kernel-5_35-4_79_2_147_2_3:4.8.2.15
	Kernel-5_35-4_79_2_148:4.8.2.15
	Kernel-5_35-4_79_2_147_2_2:4.8.2.15
	Kernel-5_35-4_79_2_147_2_1:4.8.2.15
	RPi:4.8.2.15.0.2
	RPi_bp:4.8.2.15
	Kernel-5_35-4_79_2_98_2_52_2_1:4.8.2.9.2.2
	alees_Kernel_dev:4.8.2.9.2.2.0.2
	alees_Kernel_dev_bp:4.8.2.9.2.2
	Kernel-5_35-4_79_2_147:4.8.2.15
	Kernel-5_35-4_79_2_146:4.8.2.15
	Kernel-5_35-4_79_2_145:4.8.2.14
	Kernel-5_35-4_79_2_144:4.8.2.14
	Kernel-5_35-4_79_2_143:4.8.2.14
	Kernel-5_35-4_79_2_142:4.8.2.14
	Kernel-5_35-4_79_2_141:4.8.2.14
	Kernel-5_35-4_79_2_140:4.8.2.14
	Kernel-5_35-4_79_2_139:4.8.2.14
	Kernel-5_35-4_79_2_138:4.8.2.14
	Kernel-5_35-4_79_2_137:4.8.2.13
	Kernel-5_35-4_79_2_136:4.8.2.13
	Kernel-5_35-4_79_2_135:4.8.2.13
	Kernel-5_35-4_79_2_134:4.8.2.13
	Kernel-5_35-4_79_2_133:4.8.2.13
	Kernel-5_35-4_79_2_132:4.8.2.13
	Kernel-5_35-4_79_2_131:4.8.2.13
	Kernel-5_35-4_79_2_130:4.8.2.13
	Kernel-5_35-4_79_2_129:4.8.2.12
	Kernel-5_35-4_79_2_128:4.8.2.12
	Kernel-5_35-4_79_2_127:4.8.2.12
	Kernel-5_35-4_79_2_126:4.8.2.12
	Kernel-5_35-4_79_2_125:4.8.2.12
	Kernel-5_35-4_79_2_124:4.8.2.12
	Kernel-5_35-4_79_2_123:4.8.2.11
	Cortex_merge:4.8.2.9.2.2
	Kernel-5_35-4_79_2_122:4.8.2.10
	Kernel-5_35-4_79_2_98_2_54:4.8.2.9.2.2
	Kernel-5_35-4_79_2_98_2_53:4.8.2.9.2.2
	Kernel-5_35-4_79_2_98_2_52:4.8.2.9.2.2
	Kernel-5_35-4_79_2_98_2_51:4.8.2.9.2.2
	Kernel-5_35-4_79_2_98_2_50:4.8.2.9.2.2
	Kernel-5_35-4_79_2_98_2_49:4.8.2.9.2.2
	Kernel-5_35-4_79_2_98_2_48:4.8.2.9.2.2
	Kernel-5_35-4_79_2_121:4.8.2.10
	Kernel-5_35-4_79_2_98_2_47:4.8.2.9.2.1
	Kernel-5_35-4_79_2_120:4.8.2.10
	Kernel-5_35-4_79_2_98_2_46:4.8.2.9.2.1
	Kernel-5_35-4_79_2_119:4.8.2.9
	Kernel-5_35-4_79_2_98_2_45:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_44:4.8.2.9.2.1
	Kernel-5_35-4_79_2_118:4.8.2.9
	Kernel-5_35-4_79_2_98_2_43:4.8.2.9.2.1
	Kernel-5_35-4_79_2_117:4.8.2.9
	Kernel-5_35-4_79_2_116:4.8.2.9
	Kernel-5_35-4_79_2_98_2_42:4.8.2.9.2.1
	Kernel-5_35-4_79_2_115:4.8.2.9
	Kernel-5_35-4_79_2_98_2_41:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_40:4.8.2.9.2.1
	Kernel-5_35-4_79_2_114:4.8.2.9
	Kernel-5_35-4_79_2_98_2_39:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_38:4.8.2.9.2.1
	Kernel-5_35-4_79_2_113:4.8.2.9
	Kernel-5_35-4_79_2_112:4.8.2.9
	Kernel-5_35-4_79_2_98_2_37:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_36:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_35:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_34:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_33:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_32:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_31:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_30:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_29:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_28:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_27:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_26:4.8.2.9.2.1
	Kernel-5_35-4_79_2_111:4.8.2.9
	Kernel-5_35-4_79_2_98_2_25:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_24:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_23:4.8.2.9.2.1
	Kernel-5_35-4_79_2_110:4.8.2.9
	Kernel-5_35-4_79_2_98_2_22:4.8.2.9.2.1
	Kernel-5_35-4_79_2_109:4.8.2.9
	Kernel-5_35-4_79_2_98_2_21:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_20:4.8.2.9.2.1
	Kernel-5_35-4_79_2_108:4.8.2.9
	Kernel-5_35-4_79_2_107:4.8.2.9
	Kernel-5_35-4_79_2_98_2_19:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_18:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_17:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_16:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_15:4.8.2.9.2.1
	Kernel-5_35-4_79_2_106:4.8.2.9
	Kernel-5_35-4_79_2_105:4.8.2.9
	Kernel-5_35-4_79_2_104:4.8.2.9
	Kernel-5_35-4_79_2_98_2_14:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_13:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_12:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_11:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_10:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_9:4.8.2.9.2.1
	Kernel-5_35-4_79_2_103:4.8.2.9
	Kernel-5_35-4_79_2_102:4.8.2.9
	Kernel-5_35-4_79_2_98_2_8:4.8.2.9.2.1
	Kernel-5_35-4_79_2_98_2_7:4.8.2.9
	Kernel-5_35-4_79_2_98_2_6:4.8.2.9
	Kernel-5_35-4_79_2_98_2_5:4.8.2.9
	Kernel-5_35-4_79_2_98_2_4:4.8.2.9
	Kernel-5_35-4_79_2_101:4.8.2.9
	Kernel-5_35-4_79_2_100:4.8.2.9
	Kernel-5_35-4_79_2_99:4.8.2.9
	Kernel-5_35-4_79_2_98_2_3:4.8.2.9
	Kernel-5_35-4_79_2_98_2_2:4.8.2.9
	Kernel-5_35-4_79_2_98_2_1:4.8.2.9
	Cortex:4.8.2.9.0.2
	Cortex_bp:4.8.2.9
	Kernel-5_35-4_79_2_98:4.8.2.9
	Kernel-5_35-4_79_2_97:4.8.2.9
	Kernel-5_35-4_79_2_96:4.8.2.9
	Kernel-5_35-4_79_2_95:4.8.2.9
	Kernel-5_35-4_79_2_94:4.8.2.9
	Kernel-5_35-4_79_2_93:4.8.2.9
	Kernel-5_35-4_79_2_92:4.8.2.9
	Kernel-5_35-4_79_2_91:4.8.2.9
	Kernel-5_35-4_79_2_90:4.8.2.9
	Kernel-5_35-4_79_2_89:4.8.2.9
	Kernel-5_35-4_79_2_88:4.8.2.9
	Kernel-5_35-4_79_2_87:4.8.2.9
	Kernel-5_35-4_79_2_86:4.8.2.9
	Kernel-5_35-4_79_2_85:4.8.2.9
	Kernel-5_35-4_79_2_84:4.8.2.9
	Kernel-5_35-4_79_2_83:4.8.2.9
	Kernel-5_35-4_79_2_82:4.8.2.9
	Kernel-5_35-4_79_2_81:4.8.2.9
	Kernel-5_35-4_79_2_80:4.8.2.9
	Kernel-5_35-4_79_2_79:4.8.2.9
	Kernel-5_35-4_79_2_78:4.8.2.9
	Kernel-5_35-4_79_2_77:4.8.2.9
	RO_5_07:4.8.2.9
	Kernel-5_35-4_79_2_76:4.8.2.9
	Kernel-5_35-4_79_2_75:4.8.2.9
	Kernel-5_35-4_79_2_74:4.8.2.9
	Kernel-5_35-4_79_2_73:4.8.2.9
	Kernel-5_35-4_79_2_72:4.8.2.8
	Kernel-5_35-4_79_2_71:4.8.2.8
	Kernel-5_35-4_79_2_70:4.8.2.8
	Kernel-5_35-4_79_2_69:4.8.2.8
	Kernel-5_35-4_79_2_68:4.8.2.7
	Kernel-5_35-4_79_2_67:4.8.2.7
	Kernel-5_35-4_79_2_66:4.8.2.7
	Kernel-5_35-4_79_2_65:4.8.2.7
	Kernel-5_35-4_79_2_64:4.8.2.7
	Kernel-5_35-4_79_2_63:4.8.2.7
	Kernel-5_35-4_79_2_62:4.8.2.7
	Kernel-5_35-4_79_2_61:4.8.2.7
	Kernel-5_35-4_79_2_59:4.8.2.7
	Kernel-5_35-4_79_2_58:4.8.2.7
	Kernel-5_35-4_79_2_57:4.8.2.6
	Kernel-5_35-4_79_2_56:4.8.2.6
	Kernel-5_35-4_79_2_55:4.8.2.6
	Kernel-5_35-4_79_2_54:4.8.2.6
	Kernel-5_35-4_79_2_53:4.8.2.6
	Kernel-5_35-4_79_2_52:4.8.2.6
	Kernel-5_35-4_79_2_51:4.8.2.6
	Kernel-5_35-4_79_2_50:4.8.2.5
	Kernel-5_35-4_79_2_49:4.8.2.5
	Kernel-5_35-4_79_2_48:4.8.2.5
	Kernel-5_47:4.8
	Kernel-5_46-4_90_2_1:4.8
	nbingham_Kernel_FastNC_dev_bp:4.8
	nbingham_Kernel_FastNC_dev:4.8.0.4
	Kernel-5_46:4.8
	Kernel-5_45:4.8
	Kernel-5_35-4_79_2_47:4.8.2.4
	Kernel-5_35-4_79_2_46:4.8.2.4
	Kernel-5_35-4_79_2_45:4.8.2.4
	Kernel-5_35-4_79_2_44:4.8.2.4
	Kernel-5_35-4_79_2_25_2_2:4.8.2.2
	Kernel-5_35-4_79_2_43:4.8.2.4
	Kernel-5_35-4_79_2_42:4.8.2.4
	Kernel-5_35-4_79_2_41:4.8.2.4
	Kernel-5_35-4_79_2_40:4.8.2.4
	Kernel-5_35-4_79_2_39:4.8.2.4
	Kernel-5_35-4_79_2_38:4.8.2.4
	Kernel-5_35-4_79_2_37:4.8.2.4
	Kernel-5_35-4_79_2_36:4.8.2.4
	Kernel-5_35-4_79_2_35:4.8.2.4
	Kernel-5_35-4_79_2_34:4.8.2.4
	Kernel-5_35-4_79_2_33:4.8.2.4
	Kernel-5_35-4_79_2_32:4.8.2.3
	Kernel-5_44:4.8
	Kernel-5_35-4_79_2_25_2_1:4.8.2.2
	Kernel-5_43:4.8
	Kernel-5_35-4_79_2_31:4.8.2.3
	Kernel-5_35-4_79_2_30:4.8.2.3
	Kernel-5_35-4_79_2_29:4.8.2.2
	Kernel-5_35-4_79_2_28:4.8.2.2
	Kernel-5_35-4_79_2_27:4.8.2.2
	Kernel-5_35-4_79_2_26:4.8.2.2
	Kernel-5_42:4.8
	Kernel-5_41:4.8
	Kernel-5_40:4.8
	Kernel-5_35-4_79_2_25:4.8.2.2
	Kernel-5_35-4_79_2_24:4.8.2.2
	Kernel-5_35-4_79_2_23:4.8.2.2
	Kernel-5_35-4_79_2_22:4.8.2.2
	Kernel-5_35-4_79_2_21:4.8.2.2
	Kernel-5_35-4_79_2_20:4.8.2.2
	Kernel-5_35-4_79_2_19:4.8.2.2
	Kernel-5_35-4_79_2_18:4.8.2.2
	Kernel-5_35-4_79_2_17:4.8.2.2
	Kernel-5_35-4_79_2_16:4.8.2.2
	Kernel-5_35-4_79_2_15:4.8.2.2
	Kernel-5_35-4_79_2_14:4.8.2.2
	Kernel-5_39:4.8
	Kernel-5_13-4_52_2_1:4.5
	Bethany:4.5.0.2
	Kernel-5_38:4.8
	Kernel-5_35-4_79_2_13:4.8.2.2
	Kernel-5_35-4_79_2_12:4.8.2.2
	Kernel-5_35-4_79_2_11:4.8.2.2
	Kernel-5_37:4.8
	Kernel-5_35-4_79_2_10:4.8.2.2
	Kernel-5_35-4_79_2_9:4.8.2.1
	Kernel-5_36:4.8
	Kernel-5_35-4_79_2_8:4.8.2.1
	Kernel-5_35-4_79_2_7:4.8.2.1
	Kernel-5_35-4_79_2_6:4.8.2.1
	Kernel-5_35-4_79_2_5:4.8.2.1
	Kernel-5_35-4_79_2_4:4.8.2.1
	Kernel-5_35-4_79_2_3:4.8.2.1
	Kernel-5_35-4_79_2_2:4.8.2.1
	dellis_autobuild_BaseSW:4.8
	Kernel-5_35-4_79_2_1:4.8.2.1
	HAL:4.8.0.2
	Kernel-5_35:4.8
	Kernel-5_34:4.8
	Kernel-5_33:4.8
	Kernel-5_32:4.8
	Kernel-5_31:4.8
	Kernel-5_30:4.8
	Kernel-5_29:4.8
	Kernel-5_28:4.8
	Kernel-5_27:4.8
	Kernel-5_26:4.7
	Kernel-5_25:4.7
	Kernel-5_24:4.6
	Kernel-5_23:4.6
	Kernel-5_22:4.5
	sbrodie_sedwards_16Mar2000:4.5
	Kernel-5_21:4.5
	Kernel-5_20:4.5
	Kernel-5_19:4.5
	Kernel-5_18:4.5
	Kernel-5_17:4.5
	Kernel-5_16:4.5
	Kernel-5_15:4.5
	Kernel-5_14:4.5
	Kernel-5_13:4.5
	Kernel-5_12:4.5
	Kernel-5_11:4.5
	Kernel-5_10:4.5
	Kernel-5_09:4.5
	Kernel-5_08:4.5
	Kernel-5_07:4.5
	Kernel-5_06:4.5
	Kernel-5_05:4.5
	Kernel-5_04:4.5
	Kernel-5_03:4.5
	Kernel-5_02:4.5
	Kernel-5_01:4.5
	Kernel-5_00:4.5
	Kernel-4_99:4.5
	Kernel-4_98:4.5
	Kernel-4_97:4.5
	Kernel-4_96:4.5
	Kernel-4_95:4.5
	Kernel-4_94:4.5
	Kernel-4_93:4.5
	Kernel-4_92:4.4
	Kernel-4_91:4.4
	Kernel-4_90:4.4
	dcotton_autobuild_BaseSW:4.8
	Kernel-4_89:4.4
	Kernel-4_88:4.4
	Kernel-4_87:4.4
	Kernel-4_86:4.4
	Kernel-4_85:4.4
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.4
	Kernel-4_84:4.4
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.4
	Ursula_RiscPC_bp:4.2.2.4
	Kernel-4_83:4.4
	Kernel-4_82:4.3
	Kernel-4_81:4.3
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.4
	Ursula_RiscPC:4.2.2.4.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.2
	Ursula_merge:4.2
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.2.2.4
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.4
	UrsulaBuild_FinalSoftload:4.2.2.4
	rthornb_UrsulaBuild-12Aug1998:4.2.2.4
	aglover_UrsulaBuild-05Aug1998:4.2.2.4
	rthornb_UrsulaBuild-29Jul1998:4.2.2.4
	rthornb_UrsulaBuild-22Jul1998:4.2.2.4
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.4
	rthornb_UrsulaBuild-07Jul1998:4.2.2.4
	rthornb_UrsulaBuild-17Jun1998:4.2.2.4
	rthornb_UrsulaBuild-03Jun1998:4.2.2.4
	rthornb_UrsulaBuild-27May1998:4.2.2.4
	mstphens_Kernel-3_80:4.2.2.4
	rthornb_UrsulaBuild-21May1998:4.2.2.4
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.4
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2018.04.19.22.08.28;	author bavison;	state Exp;
branches;
next	4.14;
commitid	EJJRnnDGeShWk6zA;

4.14
date	2016.12.13.16.42.50;	author jlee;	state Exp;
branches
	4.14.2.1;
next	4.13;
commitid	aGog9bB8f4QKlQxz;

4.13
date	2016.07.24.10.50.43;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	x4yCuRzf90zVXyfz;

4.12
date	2016.06.30.20.59.45;	author jlee;	state Exp;
branches;
next	4.11;
commitid	skOEjp3ipLHx6xcz;

4.11
date	2016.06.30.20.42.05;	author jlee;	state Exp;
branches;
next	4.10;
commitid	bDF3DCxdmyMD0xcz;

4.10
date	2016.06.30.20.28.55;	author jlee;	state Exp;
branches;
next	4.9;
commitid	lMnWzoE9eJz3Wwcz;

4.9
date	2016.06.30.20.08.07;	author jlee;	state Exp;
branches;
next	4.8;
commitid	IWoXxARWeuLDOwcz;

4.8
date	2000.05.10.09.45.58;	author dcotton;	state Exp;
branches
	4.8.2.1;
next	4.7;

4.7
date	2000.04.17.14.22.52;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2000.04.04.14.27.28;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.10.07.16.49.52;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.08.17.11.16.15;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.08.03.09.58.57;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.06.57;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.13;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.14.2.1
date	2018.05.14.19.33.43;	author jlee;	state Exp;
branches;
next	;
commitid	wrVtYH84nAz1GiCA;

4.8.2.1
date	2000.09.15.12.38.00;	author kbracey;	state Exp;
branches;
next	4.8.2.2;

4.8.2.2
date	2000.10.16.11.55.38;	author kbracey;	state Exp;
branches;
next	4.8.2.3;

4.8.2.3
date	2001.05.17.10.51.11;	author kbracey;	state Exp;
branches;
next	4.8.2.4;

4.8.2.4
date	2001.06.11.11.33.31;	author kbracey;	state Exp;
branches;
next	4.8.2.5;

4.8.2.5
date	2002.10.07.17.29.40;	author kbracey;	state Exp;
branches;
next	4.8.2.6;

4.8.2.6
date	2002.11.30.00.31.06;	author bavison;	state Exp;
branches;
next	4.8.2.7;

4.8.2.7
date	2003.03.02.23.30.46;	author kbracey;	state Exp;
branches;
next	4.8.2.8;

4.8.2.8
date	2004.06.21.11.36.01;	author bavison;	state Exp;
branches;
next	4.8.2.9;

4.8.2.9
date	2004.08.12.14.53.48;	author jballance;	state Exp;
branches
	4.8.2.9.2.1;
next	4.8.2.10;

4.8.2.10
date	2011.08.07.00.05.00;	author jlee;	state Exp;
branches;
next	4.8.2.11;
commitid	1LhiU7JeG3NwFvuv;

4.8.2.11
date	2011.11.26.21.11.15;	author jlee;	state Exp;
branches;
next	4.8.2.12;
commitid	cI3W0zbtALQG6TIv;

4.8.2.12
date	2011.11.27.11.48.09;	author rsprowson;	state Exp;
branches;
next	4.8.2.13;
commitid	OFgqaKhOb6swXXIv;

4.8.2.13
date	2011.12.10.20.50.06;	author jlee;	state Exp;
branches;
next	4.8.2.14;
commitid	BN8iJ3uF8zWAxGKv;

4.8.2.14
date	2012.02.25.16.19.36;	author jlee;	state Exp;
branches;
next	4.8.2.15;
commitid	ad3WnPntkzrizyUv;

4.8.2.15
date	2012.04.15.19.48.05;	author jlee;	state Exp;
branches;
next	4.8.2.16;
commitid	95iLwHSxemPb701w;

4.8.2.16
date	2012.10.28.16.51.45;	author rsprowson;	state Exp;
branches;
next	4.8.2.17;
commitid	ruXZqdTJKJ85Qaqw;

4.8.2.17
date	2013.01.27.17.50.27;	author rsprowson;	state Exp;
branches;
next	4.8.2.18;
commitid	tDlfhdSfOxFReSBw;

4.8.2.18
date	2013.12.15.21.34.04;	author jlee;	state Exp;
branches;
next	4.8.2.19;
commitid	KwuK29hKRyXO7hhx;

4.8.2.19
date	2013.12.17.19.08.51;	author jlee;	state Exp;
branches;
next	4.8.2.20;
commitid	mr92WavK9Mu4gwhx;

4.8.2.20
date	2014.04.20.17.00.21;	author jlee;	state Exp;
branches;
next	4.8.2.21;
commitid	6eesW4yWEAvSyrxx;

4.8.2.21
date	2016.04.05.19.36.35;	author jlee;	state Exp;
branches;
next	4.8.2.22;
commitid	8RLqvkae1X7wpt1z;

4.8.2.22
date	2016.06.15.19.24.51;	author jlee;	state Exp;
branches;
next	;
commitid	QoMRsy6vZNP34Baz;

4.8.2.9.2.1
date	2009.05.17.01.34.38;	author bavison;	state Exp;
branches;
next	4.8.2.9.2.2;

4.8.2.9.2.2
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

4.2.2.1
date	97.09.09.13.33.00;	author mstphens;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.10.21.15.31.06;	author mstphens;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	97.12.08.14.34.16;	author mstphens;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	98.03.26.11.25.28;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.13;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.59.44;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.10.46;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.22;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.15
log
@Increase number of vectors supported by the kernel to 96.

Version 6.03. Tagged as 'Kernel-6_03'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => ArthurSWIs - ReadUnsigned, Vectors, Bits

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; ReadUnsigned.
; ============
;
; Read an unsigned number from a string in decimal (no prefix), hex (&)
; or given base (nn_). Leading spaces are stripped.
; 'Bad base for number' is given if a base is not in 02..10_36
; 'Bad number' is given if
;      (i) No valid number was
;  or (ii) a '<base>_' or '&' has no following valid number
; 'Number too big' is given if the result overflowed a 32-bit word

; In    r1 -> string
;       r0 =     bits 0-7: base to read number in (0 means any based number allowed)
;                bit 31 set -> check term chars for ok-ness
;                bit 30 set -> restrict range to 00..FF
;                bit 29 set -> restrict range to 0..R2 (inclusive)
;                               (overrides bit 30)
;                bit 28 set -> read 64-bit value to R2,R3 and
;                               if applicable, range is in R2,R3
;       r4 != &45444957 ("WIDE") -> legacy mode: bits 8-28 are considered part of the base

; Out   VC : r1 -> first unused char, r2 = number
;       VS : r1 unchanged, r2 = 0, current error block set
;       either way, R4 = mask of flag bits supported

ReadUnsigned_Routine Entry "r0-r1, r3-r6, r9"

        WritePSRc SVC_mode, r9

        LDR     lr, =&45444957
        CMP     r4, lr
        MOVEQ   r4, #(2_1111 :SHL: 28)
        MOVNE   r4, #(2_111 :SHL: 29)
        STREQ   r4, [stack, #3*4]
        
        AND     r11, r0, r4       ; Remember the input flags
        ANDEQ   r12, r0, #255     ; r12 := base
        BICNE   r12, r0, r4

; first set range limit
        MOV     r9, r2            ; limit value lo word
        TST     r11, #1 :SHL: 28
        MOVEQ   r6, #0            ; limit value hi word
        MOVNE   r6, r3
        TST     r11, #3 :SHL: 29
        MOVEQ   r9, #-1           ; used unsigned; allows anything
        MOVEQ   r6, #-1
        TST     r11, #1 :SHL: 30
        MOVNE   r9, #&FF
        MOVNE   r6, #0

        CMP     r12, #2          ; If base nonsensical, default to 10
        RSBGES  r14, r12, #36    ; ie. try to match most generally
        MOVLT   r12, #10

01      LDRB    r0, [r1], #1    ; Skip spaces for Bruce
        TEQ     r0, #" "
        BEQ     %BT01
        SUB     r10, r1, #1      ; Keep ptr to start of string after spaces

        TEQ     r0, #"&"        ; '&' always forces hex read
        BNE     %FT20
        MOV     r4, #16
        TST     r11, #1 :SHL: 28
        ADR     lr, %FT09
        BEQ     ReadNumberInBase
        BNE     Read64BitNumberInBase
09      BVS     %FT95

10      STR     r1, [sp, #4]       ; Update string^
        TST     r11, #(1 :SHL: 31) ; Was the termcheck flag set ?
        BEQ     %FT15
        LDRB    r0, [r1]           ; What was the term char ?
        CMP     r0, #" "           ; CtrlChar + space all ok
        BGT     %FT85              ; For bad term errors

15      CMP     r9, r2
        SBCS    lr, r6, r5
        BCC     %FT80
        TST     r11, #1 :SHL: 28
        STRNE   r5, [stack, #4*2]
        PullEnv
        ExitSWIHandler          ; VClear already in lr


20      SUB     r1, r1, #1      ; Skip back to first char of string
        MOV     r4, #10         ; Try reading a decimal number
        BL      ReadNumberInBase
        MOVVS   r4, r12          ; If we failed to read a decimal number
        BVS     %FT30           ; then use the one supplied (r12). r1 ok
        LDRB    r0, [r1], #1    ; Is it base_number ?
        CMP     r0, #"_"        ; If not based, use supplied base
        MOVNE   r1, r10         ; to read from given start of string (spaces !)
        MOVNE   r4, r12         ; restore supplied base!
        MOVEQ   r4, r2          ; Use this as new base

; Reading number in base r4

30      CMP     r4, #2          ; Is base valid (2..36) ?
        RSBGES  r0, r4, #36     ; LT -> invalid
        BLT     %FT90
        TST     r11, #1 :SHL: 28
        ADR     lr, %FT39
        BEQ     ReadNumberInBase ; Read rest of number
        BNE     Read64BitNumberInBase
39      BVS     %FT95
        B       %BT10


80      ADR     r2, ErrorBlock_NumbTooBig
        B       %FT95

85      ADR     r2, ErrorBlock_BadNumb
        B       %FT95

90      ADR     r2, ErrorBlock_BadBase

95
      [ International
        Push    "r0,lr"
        MOV     r0,r2
        BL      TranslateError
        MOV     r2,r0
        Pull    "r0,lr"
      ]
        STR     r2, [stack]     ; Go set the current error
        MOV     r2, #0          ; Defined to return 0 on error
        TST     r11, #1 :SHL: 28
        STRNE   r2, [stack, #4*2] ; return MSB=0 on error too, if 64-bit read reqd
        PullEnv
        B       SLVK_SetV

        MakeErrorBlock BadBase

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; ReadNumberInBase
; ================

; In    r1 -> string, r4 = base (valid)

; Out   VC : Number read in r2, r1 updated. r3 = number of chars used, r5 = 0
;       VS : r1 preserved, r2 -> error block

ReadNumberInBase Entry "r0, r1, r12"

        MOV     r2, #0          ; Result
        MOV     r3, #0          ; Number of valid digits read
        MOV     r5, #0

10      BL      GetCharForReadNumber
        BNE     %FT50           ; Finished ?

        TST     r2, #&F8000000  ; If EQ, can't possibly overflow in any base up to 26
        MLAEQ   r2, r4, r2, r0
        BEQ     %BT10
        
        MOV     r12, r4
        MOV     r14, #0         ; Multiply by repeated addition. Base <> 0 !
20      ADDS    r14, r14, r2
        BCS     %FT90           ; Now checks for overflow !
        SUBS    r12, r12, #1    ; result *:= base
        BNE     %BT20
        ADDS    r2, r14, r0     ; result +:= digit
        BCC     %BT10
        B       %FT90           ; Now checks for overflow here too!

50      CMP     r3, #0          ; Read any chars at all ? VClear
        STRNE   r1, [sp, #4]    ; Update string^
        EXIT    NE              ; Resultis r2

      [ International
        Push    "r0"
        ADR     r0, ErrorBlock_BadNumb
        BL      TranslateError
        MOV     r2,r0
        Pull    "r0"
      |
        ADR     r2, ErrorBlock_BadNumb
        SETV
      ]
        EXIT
        MakeErrorBlock BadNumb

90
      [ International
        Push    "r0"
        ADR     r0, ErrorBlock_NumbTooBig
        BL      TranslateError
        MOV     r2,r0
        Pull    "r0"
      |
        ADR     r2, ErrorBlock_NumbTooBig
        SETV
      ]
        EXIT
        MakeErrorBlock NumbTooBig

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Read64BitNumberInBase
; =====================

; In    r1 -> string, r4 = base (valid)

; Out   VC : Number read in r2 (lo) and r5 (hi), r1 updated. r3 = number of chars used
;       VS : r1 preserved, r2 -> error block, r5 corrupted

Read64BitNumberInBase ALTENTRY

        MOV     r2, #0          ; Result lo
        MOV     r3, #0          ; Number of valid digits read
        MOV     r5, #0          ; Result hi

10      BL      GetCharForReadNumber
        BNE     %BT50           ; Finished ?

      [ :LNOT: NoARMM
        TST     r5, #&F8000000  ; If EQ, can't possibly overflow in any base up to 26
        MULEQ   r5, r4, r5      ; r0,r5 = new_digit + (old_msw * base)<<32
        UMLALEQ r0, r5, r4, r2  ; r0,r5 += old_lsw * base
        MOVEQ   r2, r0
        BEQ     %BT10
      ]
                                ; Multiply by repeated addition. Base <> 0 !
        SUBS    r12, r4, #1     ; Final iteration has r2,r5 as dest, so one fewer main iterations
        MOV     r14, #0         ; r0,r14 is accumulator, initialised to new_digit,0
20      ADDS    r0, r0, r2
        ADCS    r14, r14, r5
        BCS     %BT90
        SUBS    r12, r12, #1
        BNE     %BT20
        ADDS    r2, r0, r2
        ADCS    r5, r14, r5
        BCC     %BT10
        B       %BT90           ; Checks for overflow here too!

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; GetCharForReadNumber
; ====================
;
; Read a digit and validate for reading in current base. Bases 2..36 are valid

; In    r1 -> string, r4 = base for number input

; Out   EQ -> r0 = valid number in [0..base-1], r1++
;       NE -> r0 invalid, r1 same

GetCharForReadNumber Entry

        LDRB    r0, [r1]
        CMP     r0, #"0"
        BLO     %FT95
        CMP     r0, #"9"
        BLS     %FT50
        UpperCase r0, r14
        CMP     r0, #"A"        ; Always hex it, even if reading in decimal
        RSBGES  r14, r0, #"Z"   ; Inverse compare as nicked from UpperCase
        BLT     %FT95           ; GE -> in range A..Z
        SUB     r0, r0, #"A"-("0"+10)
50      SUB     r0, r0, #"0"
        CMP     r0, r4          ; digit in [0..base-1] ?
        BHS     %FT95
        ADD     r1, r1, #1      ; r1++
        ADD     r3, r3, #1      ; Valid digit has been read
        CMP     r0, r0          ; EQ
        EXIT

95      CMP     r0, #-1         ; NE
        EXIT

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Initialise_vectors()
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

            ^ 0
TailPtr     # 4     ; order very carefully chosen!
VecWSpace   # 4
Address     # 4
VecNodeSize # 0

InitVectors

; for vec:=0 to NVECTORS-1 do vectab!(vec*4):= defaultvectab+8*vec

      MOV   R0, #NVECTORS
      ADR   R1, defaultvectab    ; Point at the default vector table
      LDR   R2, =ZeroPage+VecPtrTab ; Point at table of head pointers

VecInitLoop
      STR    R1, [R2], #4
      ADD    R1, R1, #VecNodeSize ; defaultvectab+vns*vec
      SUBS   R0, R0, #1             ; Next vec
      BGT    VecInitLoop

      MOV    PC, link
      LTORG

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Call_vector (n)
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In:   r10 = vector number
;       lr contains return address
;       cpsr contains flags/int state to set up before calling

; Out:  r10, r12, lr corrupted

CallVector ROUT

        MRS     r12, CPSR
        CMP     r10, #NVECTORS
        BHS     CallVecTooHigh          ; return - silly value

        MSR     CPSR_f, r12             ; put back caller's flags + int state
        Push    lr                      ; claimed return goes back to caller

        LDR     r14, =ZeroPage+VecPtrTab ; Point at table of head pointers
        LDR     r10, [r14, r10, LSL #2] ; nextblock:=vecptrtab!(n*4)

CallVecLoop
        MOV     lr, pc                  ; Set up the return address
        LDMIA   r10, {r10, r12, pc}     ; CALL the vectored routine, step chain

; NB. It is the responsibility of vector code NOT to corrupt flags that are
; part of the input conditions if they are going to pass the call on, eg. INSV
; must not do CMP as C,V are needed by old handler

        TEQ     r10, #0                 ; until nextblock points to zero
        BNE     CallVecLoop

        Pull    pc                      ; can't restore all flags. CV will be preserved

CallVecTooHigh
        MSR     CPSR_f, r12
        MOV     pc, lr

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;Add_To_vector(n, Addressess)
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Add_ToVector_SWICode   ROUT

      CMP   R0, #NVECTORS
      BCS   BadClaimNumber
      Push "R0-R4, link"
      B     GoForAddToVec

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;Claim_vector(n, Addressess)
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ClaimVector_SWICode   ROUT
 ; On Entry : R0 = Vector number, R1 = Address, R2 = workspace reqd

      CMP   R0, #NVECTORS
      BCS   BadClaimNumber

      Push "R0-R4, link"

        PHPSEI  R4, R14                 ; Disable IRQs

        MOV     R3, #0                  ; List of de-linked nodes is empty
        LDR     R11, =ZeroPage+VecPtrTab ; Get ptr to table of head pointers
        LDR     R10, [R11, R0, LSL #2]! ; R10 "nextblock" := *oldptr, R11= root ptr
01      BL      FindAndDelinkNode       ; R10,R11->R10,R11,R12
        STRVC   R3, [R12, #TailPtr]     ; Attach de-linked nodes onto this node
        MOVVC   R3, R12                 ; New head of de-linked nodes
        BVC     %BT01                   ; Repeat until all nodes de-linked

        PLP     R4                      ; Restore IRQ state

; Free the list of de-linked nodes, pointed to by R3, enter with VS

02      LDRVC   R3, [R3, #TailPtr]      ; Update head of de-linked nodes
        BLVC    FreeNode                ; Free the node pointed to by R12
        SUBS    R12, R3, #0             ; Any more nodes to free?
        BNE     %BT02                   ; Yes then jump

GoForAddToVec
      LDR   R11, =ZeroPage+VecPtrTab ; Point at table of head pointers

      ADD   R11, R11, R0, LSL #2
      MOV   R10, R1                 ; Address
      MOV   R4, R2                  ; TailPtr pointer is "nextblock"

  [ ChocolateSysHeap
      ASSERT  ChocolateSVBlocks = ChocolateBlockArrays + 4
      LDR   r3,=ZeroPage+ChocolateBlockArrays
      LDR   r3,[r3,#4]
      BL    ClaimChocolateBlock
      MOVVS R3, #VecNodeSize        ; Ask for this number of bytes
      BLVS  ClaimSysHeapNode        ; The result is in R2 : R12 corrupted
  |
      MOV   R3, #VecNodeSize        ; Ask for this number of bytes
      BL    ClaimSysHeapNode        ; The result is in R2 : R12 corrupted
  ]
      BVS   BadClaimVector          ; Failed : Exit

      WritePSRc SVC_mode+I_bit, R3  ; force noirq
      LDR   R3, [R11]               ; "nextblock" :=vecptrtab!(n*4)
      STMIA R2, {R3, R4, R10}       ; Atomic Operation thus links in the new
                                    ; routine
      STR   R2, [R11]               ; vectab!(n*4) := "thisblock"
BadClaimVector
      STRVS R0, [stack]
      Pull "R0-R4, link"
      B    SLVK_TestV

BadClaimNumber
      ADR    R0, ErrorBlock_BadClaimNum
    [ International
      Push   "lr"
      BL     TranslateError
      Pull   "lr"
    ]
      B      SLVK_SetV

      MakeErrorBlock BadClaimNum

;Release_vector(n, Addressess)
;+++++++++++++++++++++++++

ReleaseVector_SWICode
 ; On Entry : R0 = vector number, R1 = Address, R2 = workspace, SVC mode

      CMP   R0, #NVECTORS
      SETV  CS
      BVS   BadVectorRelease

        Push    "R0-R2,R9,link"

        PHPSEI  R9, R14                 ; Disable IRQs

        LDR     R11, =ZeroPage+VecPtrTab ; Get ptr to table of head pointers
        LDR     R10, [R11, R0, LSL #2]! ; R10 "nextblock" := *oldptr, R11= root ptr
        BL      FindAndDelinkNode       ; R10,R11->R10,R11,R12
        PLP     R9                      ; Restore IRQ state
        BLVC    FreeNode                ; If found, free the node in R12

        Pull    "R0-R2,R9,link"

BadVectorRelease
      ADRVS R0, ErrorBlock_NaffRelease
    [ International
      Push  "lr",VS
      BLVS  TranslateError
      Pull  "lr",VS
    ]
      B     SLVK_TestV

      MakeErrorBlock NaffRelease

; Find a node and de-link it from the vector chain
; In:
; R1 = code address
; R2 = workspace address
; R10 -> Node
; R11 -> Root ptr
; Out:
; VC:
; R10 -> Node following found
; R11 -> New root ptr
; R12 -> Node de-linked
; VS:
; R10,11,12 trashed - node not found

10      ADD     R11, R10, #TailPtr      ; oldptr := thisblock+TailPtr
        LDR     R10, [R11]              ; nextblock:=thisblock!TailPtr

FindAndDelinkNode
        CMP     R10, #0                 ; End of chain?
        RETURNVS EQ                     ; Yes, return error

        LDR     R12, [R10, #VecWSpace]
        CMP     R12, R2                 ; Workspace matches?
        LDREQ   R12, [R10, #Address]
        CMPEQ   R12, R1                 ; And code address matches?
        BNE     %BT10                   ; No then jump, try next node

; Remove node from vector chain

        MOV     R12, R10                ; R12-> node to de-link
        LDR     R10, [R12, #TailPtr]    ; Get link to next node
        STR     R10, [R11]              ; Previous node's link -> next node
        RETURNVC EQ                     ; Return no error

; Return node to heap space
; In:
; R12-> node to release

FreeNode
        Push    "R0-R2, lr"
        MOV     R2, R12
  [ ChocolateSysHeap
        ASSERT  ChocolateSVBlocks = ChocolateBlockArrays + 4
        LDR     r1,=ZeroPage+ChocolateBlockArrays
        LDR     r1,[r1,#4]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
        BL      FreeSysHeapNode
  ]
        STRVS   R0, [stack]
        Pull    "R0-R2, PC"                     ; returns Vset if sysheap poo'd.

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      LTORG

defaultvectab
   & 0, 0, NaffVector           ; UserV  * &00
   & 0, 0, ErrHandler           ; ErrorV * &01
   & 0, 0, NOIRQ                ; IrqV   * &02
   & 0, ZeroPage+OsbyteVars, PMFWrch ; WrchV  * &03

   & 0, 0, NewRdch              ; RdchV  * &04  - start of VecNo=SWINo section
   & 0, 0, VecOsCli
   & 0, ZeroPage+OsbyteVars, OsByte
   & 0, ZeroPage+OsbyteVars, OsWord
   & 0, 0, NaffVector             ; filev
   & 0, 0, NaffVector             ; argsv
   & 0, 0, NaffVector             ; bgetv
   & 0, 0, NaffVector             ; bputv
   & 0, 0, NaffVector             ; gbpbv
   & 0, 0, NaffVector             ; findv
   & 0, ZeroPage+OsbyteVars, VecRdLine ; ReadlineV  * &0E - end of VecNo=SWINo

   & 0, 0, NaffVector           ; fscv

   & 0, ZeroPage+EvtHan_ws, DefEvent ; EventV * &10

   & 0, 0, NaffVector           ; UPTV   * &11
   & 0, 0, NaffVector           ; NETV   * &12

   & 0, 0, KeyVector            ; KEYV   * &13

   & 0, BuffParms+0, NewInsV    ; INSV   * &14
   & 0, BuffParms+0, NewRemV    ; REMV   * &15
   & 0, BuffParms+4, NewCnpV    ; CNPV   * &16     ; Count/Purge Buffer V

   & 0, 0, NaffVector           ; UKVDU23V * &17   ; ---| VDU23 (decimal)

   & 0, ZeroPage+HiServ_ws, HighSWI ; UKSWIV   * &18   ; ---| Unknown SWI numbers

   & 0, 0, NaffVector           ; UKPLOTV  * &19   ; ---| VDU25 (decimal)

   & 0, 0, ReadMouse            ; MouseV * &1A

   & 0, 0, NaffVector           ; VDUXV   * &1B
   & 0, 0, Def_100HZ            ; TickerV * &1C

   & 0, ZeroPage+UpCallHan_ws, CallUpcallHandler
                                ; UpCallV * &1D
   & 0, 0, AdjustOurSet         ; ChangeEnvironment * &1E

   & 0, ZeroPage+VduDriverWorkSpace, SpriteVecHandler ; SpriteV * &1F
   & 0, 0, NaffVector           ; DrawV * &20
   & 0, 0, NaffVector           ; EconetV * &21
   & 0, 0, NaffVector           ; ColourV * &22
   & 0, ZeroPage+VduDriverWorkSpace, MOSPaletteV ; PaletteV * &23
   & 0, 0, NaffVector           ; SerialV * &24

   & 0, 0, NaffVector           ; FontV * &25

   & 0, 0, PointerVector        ; PointerV * &26
   & 0, 0, NaffVector           ; TimeCodeV * &27
   & 0, 0, NaffVector           ; LowPriorityEventV &28
   & 0, 0, NaffVector           ; &29
   & 0, ZeroPage+VduDriverWorkSpace, MOSGraphicsV  ; GraphicsV * &2a
   & 0, 0, NaffVector           ; UnthreadV * &2b
   & 0, 0, NaffVector           ; &2c
   & 0, 0, NaffVector           ; SeriousErrorV * &2d
   & 0, 0, NaffVector           ; &2e
   & 0, 0, NaffVector           ; &2f
   & 0, 0, NaffVector           ; &30
   & 0, 0, NaffVector           ; &31
   & 0, 0, NaffVector           ; &32
   & 0, 0, NaffVector           ; &33
   & 0, 0, NaffVector           ; &34
   & 0, 0, NaffVector           ; &35
   & 0, 0, NaffVector           ; &36
   & 0, 0, NaffVector           ; &37
   & 0, 0, NaffVector           ; &38
   & 0, 0, NaffVector           ; &39
   & 0, 0, NaffVector           ; &3A
   & 0, 0, NaffVector           ; &3B
   & 0, 0, NaffVector           ; &3C
   & 0, 0, NaffVector           ; &3D
   & 0, 0, NaffVector           ; &3E
   & 0, 0, NaffVector           ; &3F
   & 0, 0, NaffVector           ; &40
   & 0, 0, NaffVector           ; &41
   & 0, 0, NaffVector           ; &42
   & 0, 0, NaffVector           ; &43
   & 0, 0, NaffVector           ; &44
   & 0, 0, NaffVector           ; &45
   & 0, 0, NaffVector           ; &46
   & 0, 0, NaffVector           ; &47
   & 0, 0, NaffVector           ; &48
   & 0, 0, NaffVector           ; &49
   & 0, 0, NaffVector           ; &4A
   & 0, 0, NaffVector           ; &4B
   & 0, 0, NaffVector           ; &4C
   & 0, 0, NaffVector           ; &4D
   & 0, 0, NaffVector           ; &4E
   & 0, 0, NaffVector           ; &4F
   & 0, 0, NaffVector           ; &50
   & 0, 0, NaffVector           ; &51
   & 0, 0, NaffVector           ; &52
   & 0, 0, NaffVector           ; &53
   & 0, 0, NaffVector           ; &54
   & 0, 0, NaffVector           ; &55
   & 0, 0, NaffVector           ; &56
   & 0, 0, NaffVector           ; &57
   & 0, 0, NaffVector           ; &58
   & 0, 0, NaffVector           ; &59
   & 0, 0, NaffVector           ; &5A
   & 0, 0, NaffVector           ; &5B
   & 0, 0, NaffVector           ; &5C
   & 0, 0, NaffVector           ; &5D
   & 0, 0, NaffVector           ; &5E
   & 0, 0, NaffVector           ; &5F

 assert (.-defaultvectab) = NVECTORS*VecNodeSize

NaffVector ROUT
Def_100HZ
        MRS     lr, CPSR
        BIC     lr, lr, #V_bit
        MSR     CPSR_f, lr              ; Clear V, preserve rest
        LDR     pc, [sp], #4            ; Claim vector, do nowt

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWIs to save any vector entries pointing into application workspace
;
; Delink SWI:
;   R0 pointer to buffer
;   R1 buffer size
; Returns R1 bytes left in buffer
;   V set if buffer not large enough

Application_Delink ROUT
      Push "R0, R2-R4, lr"

      CMP   R1, #4
      BLT   %FT99                   ; invalid buffer size

    [ ZeroPage = 0
      MOV   R3, #NVECTORS-1
      LDR   R4, [R3, #AplWorkSize-(NVECTORS-1)]
    |
      LDR   R4, =ZeroPage
      MOV   R3, #NVECTORS-1
      LDR   R4, [R4, #AplWorkSize]
    ]
      SETPSR I_bit, R2           ; IRQs off while holding context.

03    LDR   R11, =ZeroPage+VecPtrTab ; Point at table of head pointers
      ADD   R10, R11, R3, LSL #2
04    MOV   R11, R10             ; step chain
      LDR   R10, [R11]
05    CMP   R10, #0
      BNE   %FT02
      SUBS  R3, R3, #1
      BPL   %BT03                ; next vector
      MOV   R3, #-1
      STR   R3, [R0]
      SUB   R1, R1, #4
      Pull "R0, R2-R4, lr"
      ExitSWIHandler

02    LDR   R12, [R10, #Address]
      CMP   R12, R4
      BGT   %BT04
      CMP   R12, #AppSpaceStart
      BLT   %BT04

; appl entry found: put in buffer, free it
      CMP   R1, #12+4
      BLT   %FT99                ; no rheum
      LDR   R14, [R10, #VecWSpace]
      STMIA R0!, {R3, R12, R14}
      SUB   R1, R1, #12          ; buffer entry added

      LDR   R12, [R10, #TailPtr]
      STR   R12, [R11]           ; vector delinked

        Push    "R0-R2"
        MOV     R2, R10
        MOV     R10, R12                        ; keep updated thisblk
  [ ChocolateSysHeap
        ASSERT  ChocolateSVBlocks = ChocolateBlockArrays + 4
        LDR     r1,=ZeroPage+ChocolateBlockArrays
        LDR     r1,[r1,#4]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
        BL      FreeSysHeapNode
  ]
        MOVVS   lr, R0
        Pull    "R0-R2"
        BVC     %BT05

98    STR   lr, [stack]
      MOV   R3, #-1               ; terminate buffer even if error
      CMP   r1, #4
      STRGE R3, [R0]
      SUB   R1, R1, #4
      Pull "R0, R2-R4, lr"
      B    SLVK_SetV

99
    [ International
      Push  "r0"
      ADRL  r0, ErrorBlock_BuffOverflow
      BL    TranslateError
      MOV   lr,r0
      Pull  "r0"
    |
      ADRL  lr, ErrorBlock_BuffOverflow
    ]
      B     %BT98

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Relink SWI:
;   R0 pointer to buffer as set by Delink
; Returns V set if can't relink all

Application_Relink ROUT
 [ {TRUE}
; Run through the buffer BACKWARDS to ensure that the vectors are
; reinstalled in the same order.
      Push   "R0-R3, lr"
      MOV     R3, R0            ; R3 -> start of buffer
      MOV     R10, R0
01    LDR     R0, [R10], #12    ; search forwards to find terminator
      CMP     R0, #-1
      BNE     %BT01
      SUB     R10, R10, #12     ; R10 -> terminator
02    CMP     R10, R3           ; loop backwards until we get to start
      Pull   "R0-R3, lr", EQ
      ExitSWIHandler EQ

      LDMDB   R10!, {R0-R2}
      SWI     XOS_AddToVector
      BVC     %BT02
      STR     R0, [stack]
      Pull   "R0-R3, lr"
      B      SLVK_SetV
 |
      Push   "R0-R2, lr"
      MOV     R10, R0
02    LDR     R0, [R10], #4
      CMP     R0, #-1
      Pull   "R0-R2, lr", EQ
      ExitSWIHandler EQ

      LDMIA   R10!, {R1, R2}
      SWI     XOS_AddToVector
      BVC     %BT02
      STR     R0, [stack]
      Pull   "R0-R2, lr"
      B      SLVK_SetV
 ]

;********************************************************************
; Now the stuff that issues service calls; also deals with the MOS
;  being default default FIQ owner, and wanting to see application
;  startup.
;********************************************************************

        GBLL  DebugNeil
DebugNeil SETL {FALSE}          ; if TRUE, check R7-R11 preserved over services

Issue_Service ROUT             ; R1 is service number, R2 may be a parameter
                               ; registers preserved.
       Push    "R9-R12, lr"

       CMP      R1, #Service_ClaimFIQ
       CMPNE    R1, #Service_ClaimFIQinBackground
       BEQ      FIQclaim
       CMP      R1, #Service_ReleaseFIQ
       BEQ      test_FIQclaim_in_progress

       CMP      r1, #Service_NewApplication
       BEQ      checkmoshandlers

  [ ChocolateService
05
       CMP      R1,#ServMinUsrNumber
       BHS      %FT84
;call anyone on the appropriate Sys chain
       LDR      R10,=ZeroPage
       LDR      R10,[R10,#Serv_SysChains]
       CMP      R10,#0
       BEQ      %FT88
       LDR      R11,[R10,R1,LSL #2]             ;pick up the chain anchor
80
;call everyone on the chain, passing R1 value from chain if appropriate
       CMP      R11,#0
       BEQ      %FT88
       LDR      R10,[R11,#ServChain_Size]
       ADD      R11,R11,#ServChain_HdrSIZEOF    ;start of chain
       ADD      R10,R10,R11                     ;end of chain
82
       CMP      R11,R10
       BHS      %FT88

       Push     "R10"
       MOV      R10,R1
       LDR      R9,[R11,#ServEntry_R1]
       TEQ      R9,#0                           ; 0 means pass service number as normal
       MOVNE    R1,R9                           ; else pass R1 value from chain (will be service index)
       LDR      R12,[R11,#ServEntry_WSpace]
       LDR      R9,[R11,#ServEntry_Code]
     [ NoARMv5
       MOV      lr, pc                          ; link inc. PSR, mode
       MOV      pc, R9
     |
       BLX      R9
     ]
       CMP      R1, #Service_Serviced
       MOVNE    R1,R10                          ; restore R1 unless claimed
       Pull     "R10"
       BEQ      %FT01
       ADD      R11,R11,#ServEntry_SIZEOF
       B        %BT82
;
;call anyone on the appropriate Usr chain
84
       LDR      R10,=ZeroPage+Serv_UsrChains
       LDR      R10,[R10]
       CMP      R10,#0
       BEQ      %FT88
       ServHashFunction R9,R1
       LDR      R11,[R10,R9,LSL #2]             ;pick up the chain-array anchor
       CMP      R11,#0
       BEQ      %FT88
       LDR      R10,[R11,#ServUChArray_Size]
       ADD      R11,R11,#ServUChArray_HdrSIZEOF ;start of list
       ADD      R10,R10,R11                     ;end of list
86
       CMP      R11,R10
       BHS      %FT88
       LDR      R9,[R11,#ServUChEntry_ServiceNo]
       TEQ      R9,R1
       ADDNE    R11,R11,#ServUChEntry_SIZEOF
       BNE      %BT86
       LDR      R11,[R11,#ServUChEntry_ChainAnchor]  ;found chain for this service number
       B        %BT80
;
;call everyone on the chain of Awkward modules, always passing service number in R1
88
       LDR      R10,=ZeroPage
       LDR      R11,[R10,#Serv_AwkwardChain]
       CMP      R11,#0
       BEQ      %FT01
       LDR      R10,[R11,#ServChain_Size]
       ADD      R11,R11,#ServChain_HdrSIZEOF    ;start of chain
       ADD      R10,R10,R11                     ;end of chain
90
       CMP      R11,R10
       BHS      %FT01
       LDR      R12,[R11,#ServEntry_WSpace]
       LDR      R9,[R11,#ServEntry_Code]
     [ NoARMv5
       MOV      lr, pc                          ; link inc. PSR, mode
       MOV      pc, R9
     |
       BLX      R9
     ]
       CMP      R1, #Service_Serviced
       BEQ      %FT01
       ADD      R11,R11,#ServEntry_SIZEOF
       B        %BT90

  | ;IF/ELSE ChocolateService

05     LDR      R10, =ZeroPage+Module_List
03     LDR      R10, [R10, #Module_chain_Link]
       CMP      R10, #0
       BEQ      %FT01
       LDR      R9, [R10, #Module_code_pointer]
       LDR      R11, [R9, #Module_Service]
       CMP      R11, #0
       BEQ      %BT03
 [ DebugROMPostInit
       CMP      R1, #Service_PostInit           ; If it is a Service_PostInit call
       BEQ      display_pre_postinit_calls      ; Go and display the postinit call
83
 ]
       ADD      R9, R9, R11
       ADD      R11, R10, #Module_incarnation_list - Incarnation_Link
04     LDR      R11, [R11, #Incarnation_Link]
       CMP      R11, #0
       BEQ      %BT03

       [ DebugNeil
       Push     "R7-R11"
       ]

       ADD      R12, R11, #Incarnation_Workspace
     [ NoARMv5
       MOV      lr, pc               ; link inc. PSR, mode
       MOV      pc, R9
     |
       BLX      R9
     ]

       [ DebugNeil
       ! 0, "Debug code included to check R7-R11 are preserved over services"
       MOV      lr, sp
       Push     "R1-R5"
       LDMIA    lr, {R1-R5}
       TEQ      R1, R7
       TEQEQ    R2, R8
       TEQEQ    R3, R9
       TEQEQ    R4, R10
       TEQEQ    R5, R11
       MOVNE    PC, #0
       Pull     "R1-R5"
       ADD      sp, sp, #5*4
       ]

 [ DebugROMPostInit
       CMP      R1, #Service_PostInit           ; If it is a Service_PostInit call
       BEQ      display_post_postinit_calls     ; Go and display the postinit call
87
 ]

       CMP      R1, #Service_Serviced
       BNE      %BT04
       Pull    "R9-R12, PC"

  ] ;ChocolateService

01     CMP      R1, #Service_ReleaseFIQ
       Pull    "R9-R12, PC",NE

     assert (Service_ReleaseFIQ :AND: &FF) <> 0
     [ ZeroPage = 0
       LDRB     R9, [R1, #MOShasFIQ-Service_ReleaseFIQ]
       STRB     R1, [R1, #MOShasFIQ-Service_ReleaseFIQ]
     |
       LDR      R1, =ZeroPage+MOShasFIQ
       ASSERT ((ZeroPage+MOShasFIQ) :AND: 255) <> 0
       LDRB     R9, [R1]
       STRB     R1, [R1]
     ]
       TEQ      R9, #0
       BNE      %FT06

       ADR      R1, FIQKiller
       MOV      R10, #FIQKiller_ws - FIQKiller
       LDR      R11, =ZeroPage+&1C
04     LDR      LR, [R1], #4
       SUBS     R10, R10, #4
       STR      LR, [R11], #4
       BNE      %BT04
     [ ZeroPage <> 0
       LDR      R10, =ZeroPage
     ]
       AddressHAL R10
       LDR      R14, [R9, #-(EntryNo_HAL_FIQDisableAll+1)*4]
       STMIA    R11, {R9, R14}
       Push     "R0"
       LDR      R0, =ZeroPage
       ADD      R1, R0, #&100
       ARMop    IMB_Range,,,R0
       Pull     "R0"

                                        ; MOS is default owner if nobody
06     MOV      R1, #Service_Serviced   ; else wants it.
       Pull    "R9-R12, PC"

FIQclaim
       LDR      R10, =ZeroPage

  ; first refuse request if a claim is currently in action

       LDRB     R9, [R10, #FIQclaim_interlock]
       CMP      R9, #0
       Pull    "R9-R12, PC",NE                 ; no can do

; have to issue a genuine FIQ claim call: set interlock to prevent another
; one passing round at an awkward moment.

       MOV      r9, #1
       STRB     r9, [r10, #FIQclaim_interlock]

; now safe to inspect our FIQ state

       LDRB     R9, [R10, #MOShasFIQ]
       CMP      R9, #0
       ASSERT   (ZeroPage :AND: 255) = 0
       STRNEB   R10, [R10, #MOShasFIQ]
       MOVNE    r1, #Service_Serviced
fakeservicecall
        ; do it this way to cope with ARM v4/v3 differences on storing PC
       SUBEQ    stack,stack,#20
       STREQ    PC,[stack,#16]
       BEQ      %BT05
       MOV      r0, r0
       LDR      r10, =ZeroPage
       LDRB     r9, [r10, #FIQclaim_interlock]
       ASSERT   (ZeroPage :AND: 255) = 0
       STRB     r10, [r10, #FIQclaim_interlock]

       CMP      r9, #1                         ; test for background release
; if background release happened, there are 3 possibilities:
;   foreground claim; this is defined to have succeeded. Discard release
;   background claim, that succeeded: releaser gave it away anyway. Discard
;       "        "     "   failed; we are holding a giveaway of FIQ, therefore
;                                  claim service call!
; therefore, if background release happened, always claim the service.

       MOVNE    r1, #Service_Serviced
       Pull    "r9-r12, PC"                    ; all done

test_FIQclaim_in_progress

       LDR      r10, =ZeroPage
       LDRB     r9, [r10, #FIQclaim_interlock]
       CMP      r9, #0

       MOVEQ    r9, #1
       STREQB   r9, [r10, #FIQclaim_interlock] ; lock out background calls
       BEQ      fakeservicecall                ; issue call, clear flag

       MOV      r9, #2                         ; mark release as occurring

       STRB     r9, [r10, #FIQclaim_interlock]
       Pull    "r9-r12, PC"

; r9-r12, lr corruptible
checkmoshandlers
     [ ZeroPage = 0
       LDR      r9, [r1, #SExitA-Service_NewApplication]
     |
       LDR      r9, =ZeroPage
       LDR      r9, [r9, #SExitA]
     ]
       ADRL     r10, CLIEXIT
       CMP      r9, r10
       BNE      %BT05
       Push    "r0-r7"
       BL       DEFHAN
       BL       DEFHN2
       Pull    "r0-r7"
       B        %BT05

 [ DebugROMPostInit
 ; Display the title of the current module in the chain.
 ; R9 contains the module pointer.
display_pre_postinit_calls
       SWI     XOS_WriteS
       =       "postinit service call to mod ",0
       Push    "r0-r7"
       LDR     R0, [R9, #Module_TitleStr]
       ADD     R0, R9, R0
       SWI     XOS_Write0
       SWI     XOS_WriteS
       =       " sent"
       SWI     XOS_NewLine
       Pull    "r0-r7"
       B        %BT83

 ; Display a message stating that we have finished the postinit service call.
 ; This will appear once for every module called on postinit.
display_post_postinit_calls
       SWI     XOS_WriteS
       =       "returned from postinit service call.",0
       SWI     XOS_NewLine
       B        %BT87
 ]

FIQKiller
       SUB     R14, R14, #4
       ADR     R13, FIQKiller-&1C+&100
       ADR     R10, FIQKiller_ws
       STMFD   R13!, {R0-R3,R14}
       MOV     R14, PC
       LDMIA   R10, {R9,PC}
       MyCLREX R0, R1
       LDMFD   R13!, {R0-R3,PC}^
FIQKiller_ws


;************************************************
; SWI to call a vector
;************************************************
CallAVector_SWI  ; R9 is the vector number (!!)
       STR       lr, [sp, #-4]!         ; save caller PSR on stack
       MOV       R10, R9
       MSR       CPSR_f, R12            ; restore caller CCs (including V)
       BL        CallVector
       MRS       r10, CPSR              ; restore CCs
       LDR       lr, [sp], #4
     [ NoARMT2
       AND       r10, r10, #&F0000000
       BIC       lr, lr, #&F0000000
       ORR       lr, lr, r10
     |
       MOV       r10, r10, LSR #28
       BFI       lr, r10, #28, #4
     ]
       ExitSWIHandler

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; Now some bits for the dynamic areas

DoSysHeapOpWithExtension
       Push   "R0, lr"
       B       IntoSysHeapOp

ClaimSysHeapNode ROUT ; size in R3
       MOV     R0, #HeapReason_Get
       Push   "R0, lr"
IntoSysHeapOp
       LDR     R1, =SysHeapStart
       SWI     XOS_Heap
       Pull   "R0, PC", VC

       LDR     r14, [r0]                   ; look at error number
       TEQ     r14, #ErrorNumber_HeapFail_Alloc
       STRNE   r0, [stack]
       Pull   "r0, PC", NE                 ; can only retry if ran out of room

       Push    r3                          ; in case extension
       LDR     r1, [stack, #4]
       CMP     r1, #HeapReason_ExtendBlock
       BNE     notsysheapextendblock

       Push   "r5, r6"
       LDR     r5, =SysHeapStart
       LDR     r6, [r5, #:INDEX:hpdbase]
       ADD     r6, r6, r5                  ; free space
       LDR     r1, [r2, #-4]               ; pick up block size
       ADD     r5, r1, r2                  ; block end +4
       SUB     r5, r5, #4                  ; TMD 02-Aug-93: block size includes size field (optimisation was never taken)
       CMP     r5, r6                      ; does block butt against end?
       ADDNE   r3, r3, r1                  ; max poss size needed
       Pull   "r5, r6"

  ; note that this doesn't cope well with a block at the end preceded by a
  ; free block, but tough.

notsysheapextendblock
       LDR     r1, =SysHeapStart
       LDR     R0, hpdbase
       LDR     R1, hpdend
       SUB     R1, R1, R0          ; size left in heap
       SUB     R1, R3, R1          ; size needed
       Pull    r3
       ADD     R1, R1, #8          ; plus safety space.
       MOV     R0, #0
       SWI     XOS_ChangeDynamicArea
       LDRVC   R0, [stack]  ; and retry.
       LDRVC   R1, =SysHeapStart
       SWIVC   XOS_Heap
       Pull   "R0, PC", VC
SysClaimFail
       ADD     stack, stack, #4
       ADR     R0, ErrorBlock_SysHeapFull
     [ International
       BL      TranslateError
     ]
       Pull   "PC"
       MakeErrorBlock  SysHeapFull

;**************************************************************************
;
;       FreeSysHeapNode - Free a node in system heap
;
; in:   R2 -> node to free
;
; out:  R0 = HeapReason_Free or pointer to error if V=1
;       R1 = SysHeapStart
;

FreeSysHeapNode Entry
        MOV     R0, #HeapReason_Free
        LDR     R1, =SysHeapStart
        SWI     XOS_Heap
        EXIT

;**************************************************************************

; ValidateAddress_Code
; R0, R1 are limits of address range to check
; return CC for OK, CS for naff

ValidateAddress_Code ROUT
        Push    "r0-r3, lr"
        MOV     r2, r1
        MOV     r1, r0
        MOV     r0, #24
        SWI     XOS_Memory
        ; Pre-RISC OS 3.5, OS_ValidateAddress would return OK if the region was:
        ; (a) valid RAM in logical address space
        ; (b) the 2nd mapping of screen memory at the start of physical address space
        ; (c) anything claimed by Service_ValidateAddress
        ;
        ; Post-RISC OS 3.5, OS_ValidateAddress would return OK if the region was:
        ; (a) a dynamic area
        ; (b) screen memory
        ; (c) most special areas
        ; (d) anything claimed by Service_ValidateAddress
        ;
        ; RISC OS Select docs suggest that valid regions for their version are:
        ; (a) dynamic areas, including special areas which have been turned into DAs (e.g. ROM)
        ; (b) some special areas (e.g. zero page)
        ; (c) screen memory
        ; (d) anything claimed by Service_ValidateAddress (example given of sparse DA which uses OS_AbortTrap to map pages on demand)
        ; (e) NOT physically mapped areas (unless screen memory)
        ;
        ; Taking the above into account, our version will behave as follows:
        ; (a) anything completely accessible in any mode, which isn't physically mapped - dynamic areas, special areas, ROM, zero page, etc.
        ; (b) anything completely R/W in user mode, which is completely physically mapped (i.e. screen memory; this check should suffice until we decide on a better way of flagging screen memory/"IO RAM" as valid)
        ; (c) anything claimed by Service_ValidateAddress
        TST     r1, #CMA_Partially_Phys
        MOVEQ   r2, #1
        ANDEQ   r1, r1, #CMA_Completely_UserR+CMA_Completely_UserW+CMA_Completely_PrivR+CMA_Completely_PrivW
        LDRNE   r2, =CMA_Completely_UserR+CMA_Completely_UserW+CMA_Completely_Phys
        ANDNE   r1, r1, r2
        CMP     r1, r2
        BHS     AddressIsValid ; EQ case: At least one completely flag set
                               ; NE case: Flags match required value
        ; OS_Memory check failed, try the service call
        LDMIA   sp, {r2-r3}
        MOV     r1, #Service_ValidateAddress
        BL      Issue_Service
        TEQ     r1, #0                  ; EQ => service claimed, so OK
        Pull    "r0-r3,lr"
        ORRNE   lr, lr, #C_bit          ; return CS if invalid
        BICEQ   lr, lr, #C_bit          ; return CC if valid
        ExitSWIHandler

AddressIsValid
        Pull    "r0-r3,lr"
        BIC     lr, lr, #C_bit
        ExitSWIHandler        


        LTORG

        END
@


4.14
log
@Reimplement AMBControl ontop of the PMP system
Detail:
  With this set of changes, each AMB node is now the owner of a fake DANode which is linked to a PMP.
  From a user's perspective the behaviour of AMBControl is the same as before, but rewriting it to use PMPs internally offers the following (potential) benefits:
  * Reduction in the amount of code which messes with the CAM & page tables, simplifying future work/maintenance. Some of the AMB ops (grow, shrink) now just call through to OS_ChangeDynamicArea. However all of the old AMB routines were well-optimised, so to avoid a big performance hit for common operations not all of them have been removed (e.g. mapslot / mapsome). Maybe one day these optimal routines will be made available for use by regular PMP DAs.
  * Removal of the slow Service_MemoryMoved / Service_PagesSafe handlers that had to do page list fixup after the core kernel had reclaimed/moved pages. Since everything is a PMP, the kernel will now deal with this on behalf of AMB.
  * Removal of a couple of other slow code paths (e.g. Do_AMB_MakeUnsparse calls from OS_ChangeDynamicArea)
  * Potential for more flexible mapping of application space in future, e.g. sparse allocation of memory to the wimp slot
  * Simpler transition to an ASID-based task swapping scheme on ARMv6+?
  Other changes of note:
  * AMB_LazyMapIn switch has been fixed up to work correctly (i.e. turning it off now disables lazy task swapping and all associated code instead of producing a build error)
  * The DANode for the current app should be accessed via the GetAppSpaceDANode macro. This will either return the current AMB DANode, or AppSpaceDANode (if e.g. pre-Wimp). However be aware that AppSpaceDANode retains the legacy behaviour of having a base + size relative to &0, while the AMB DANodes (identifiable via the PMP flag) are sane and have their base + size relative to &8000.
  * Mostly-useless DebugAborts switch removed
  * AMBPhysBin (page number -> phys addr lookup table) removed. Didn't seem to give any tangible performance benefit, and was imposing hidden restrictions on memory usage (all phys RAM fragments in PhysRamTable must be multiple of 512k). And if it really was a good optimisation, surely it should have been applied to all areas of the kernel, not just AMB!
  Other potential future improvements:
  * Turn the fake DANodes into real dynamic areas, reducing the amount of special code needed in some places, but allow the DAs to be hidden from OS_DynamicArea 3 so that apps/users won't get too confused
  * Add a generic abort trapping system to PMPs/DAs (lazy task swapping abort handler is still a special case)
  File changes:
  - s/ARM600, s/VMSAv6, s/ExtraSWIs - Remove DebugAborts
  - s/ArthurSWIs - Remove AMB service call handler dispatch
  - s/ChangeDyn - AMB_LazyMapIn switch fixes. Add alternate internal entry points for some PMP ops to allow the DANode to be specified (used by AMB)
  - s/Exceptions - Remove DebugAborts, AMB_LazyMapIn switch fixes
  - s/Kernel - Define GetAppSpaceDANode macro, AMB_LazyMapIn switch fix
  - s/MemInfo - AMB_LazyMapIn switch fixes
  - s/AMBControl/AMB - Update GETs
  - s/AMBControl/Memory - Remove block size quantisation, AMB_BlockResize (page list blocks are now allocated by PMP code)
  - s/AMBControl/Options - Remove PhysBin definitions, AMBMIRegWords (moved to Workspace file), AMB_LimpidFreePool switch. Add AMB_Debug switch.
  - s/AMBControl/Workspace - Update AMBNode to contain an embedded DANode. Move AMBMIRegWords here from Options file.
  - s/AMBControl/allocate - Fake DA node initialisation
  - s/AMBControl/deallocate - Add debug output
  - s/AMBControl/growp, growshrink, mapslot, mapsome, shrinkp - Rewrite to use PMP ops where possible, add debug output
  - s/AMBControl/main - Remove PhysBin initialisation. Update the enumerate/mjs_info call.
  - s/AMBControl/memmap - Low-level memory mapping routines updated or rewritten as appropriate.
  - s/AMBControl/readinfo - Update to cope with DANode
  - s/AMBControl/service - Remove old service call handlers
  - s/AMBControl/handler - DA handler for responding to PMP calls from OS_ChangeDynamicArea; just calls through to growpages/shrinkpages as appropriate.
Admin:
  Tested on pretty much everything currently supported


Version 5.66. Tagged as 'Kernel-5_66'
@
text
@d590 2
a591 4
   & 0, 0, NaffVector           ; SeriousErrorV * &2c

 ; the spares
   & 0, 0, NaffVector           ; &2d
d594 48
@


4.14.2.1
log
@Merge in latest changes from main branch

Version 6.05, 4.129.2.8. Tagged as 'Kernel-6_05-4_129_2_8'
@
text
@d590 4
a593 2
   & 0, 0, NaffVector           ; &2c
   & 0, 0, NaffVector           ; SeriousErrorV * &2d
a595 48
   & 0, 0, NaffVector           ; &30
   & 0, 0, NaffVector           ; &31
   & 0, 0, NaffVector           ; &32
   & 0, 0, NaffVector           ; &33
   & 0, 0, NaffVector           ; &34
   & 0, 0, NaffVector           ; &35
   & 0, 0, NaffVector           ; &36
   & 0, 0, NaffVector           ; &37
   & 0, 0, NaffVector           ; &38
   & 0, 0, NaffVector           ; &39
   & 0, 0, NaffVector           ; &3A
   & 0, 0, NaffVector           ; &3B
   & 0, 0, NaffVector           ; &3C
   & 0, 0, NaffVector           ; &3D
   & 0, 0, NaffVector           ; &3E
   & 0, 0, NaffVector           ; &3F
   & 0, 0, NaffVector           ; &40
   & 0, 0, NaffVector           ; &41
   & 0, 0, NaffVector           ; &42
   & 0, 0, NaffVector           ; &43
   & 0, 0, NaffVector           ; &44
   & 0, 0, NaffVector           ; &45
   & 0, 0, NaffVector           ; &46
   & 0, 0, NaffVector           ; &47
   & 0, 0, NaffVector           ; &48
   & 0, 0, NaffVector           ; &49
   & 0, 0, NaffVector           ; &4A
   & 0, 0, NaffVector           ; &4B
   & 0, 0, NaffVector           ; &4C
   & 0, 0, NaffVector           ; &4D
   & 0, 0, NaffVector           ; &4E
   & 0, 0, NaffVector           ; &4F
   & 0, 0, NaffVector           ; &50
   & 0, 0, NaffVector           ; &51
   & 0, 0, NaffVector           ; &52
   & 0, 0, NaffVector           ; &53
   & 0, 0, NaffVector           ; &54
   & 0, 0, NaffVector           ; &55
   & 0, 0, NaffVector           ; &56
   & 0, 0, NaffVector           ; &57
   & 0, 0, NaffVector           ; &58
   & 0, 0, NaffVector           ; &59
   & 0, 0, NaffVector           ; &5A
   & 0, 0, NaffVector           ; &5B
   & 0, 0, NaffVector           ; &5C
   & 0, 0, NaffVector           ; &5D
   & 0, 0, NaffVector           ; &5E
   & 0, 0, NaffVector           ; &5F
@


4.13
log
@Resolve 2x header clashes
hdr/AHCIDevice:
  Remove this, since it clashes with the (differing API version number) copy exported by SATADriver. Post merging the Kernel back to the trunk the newer file datestamp has meant the wrong one gets exported during any ROM build which includes both components. Since the Kernel doesn't need AHCIDevice itself, it is left to the respective client (SATADriver or AHCIDriver in this case) to export them.
hdr/ModHand:
  Resolve the longstanding clash of Module_Title with the same named symbol that CMHG uses. There are very few assembler needing to look at the module header (Kernel, FileCore, Debugger, Podule) directly, but every C module which uses CMHG and wants one of the ModHandReason values ends up with a duplicate define.
  Obsolete Arthur era Module_LoadAddr value.
ArthurSWIs.s/MoreComms.s/NewReset.s/SWINaming.s/SysComms.s/Utility.s:
  Module_Title->Module_TitleStr.
ModHand.s:
  Module_Title->Module_TitleStr.
  Recode Module_LoadAddr using the file type from Hdr:FileTypes.
GetAlls.s:
  Drop unused NVRAM and PortMan headers. Add Hdr:FileTypes.

Version 5.54. Tagged as 'Kernel-5_54'
@
text
@a751 6
;do the direct calls to AMBControl for service calls of interest
       CMP      R1, #Service_MemoryMoved
       BLEQ     AMBsrv_memorymoved
       CMP      R1, #Service_PagesSafe
       BLEQ     AMBsrv_pagessafe

@


4.12
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d1038 1
a1038 1
       LDR     R0, [R9, #Module_Title]
@


4.11
log
@Delete STB code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a desktop build):
  * STB
  * RO371Timings
  * NormalSpeedROMS
  * AutoSpeedROMS
  * RISCPCBurstMode
  * InterlacedPointer
  * ParallelFlashUpgrade (and s/FlashROM file)
  * Embedded_UI
  Some of the deleted code might be worth revisiting in future:
  * OS_ReadSysInfo 4 support for storing the MAC in alternate CMOS locations (including 2nd copy for error checking) or fetching via Service_MachineAddress
  * Mouse handling changes, possibly aimed at hiding the mouse pointer if a mouse isn't connected
  * More strict CMOS validation in s/NewReset
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.50. Tagged as 'Kernel-5_50'
@
text
@a471 1
 [ IrqsInClaimRelease
a523 29
 |
FreeLink   ; find given vector entry from R10 currptr, R11 prevptr
      CMP   R10, #0
      ORREQS PC, lr, #V_bit

ReleaseWLoop
      LDR   R12, [R10, #VecWSpace]
      CMP   R12, R2
      LDREQ R12, [R10, #Address]
      CMPEQ R12, R1
      BEQ   FoundRelease         ; IF thisblock!Address=OneWanted THEN do it
      ADD   R11, R10, #TailPtr   ; oldptr := thisblock+TailPtr
      LDR   R10, [R11]           ; nextblock:=thisblock!TailPtr
      CMP   R10, #0              ; IF thisblock!TailPtr = 0 THEN naff
      BNE   ReleaseWLoop
      ORRS  PC, lr, #V_bit       ; entry not found

FoundRelease ; else !oldptr   := nextblock!TailPtr : release_block(nextblock)

        LDR     R12, [R10, #TailPtr]
        STR     R12, [R11]

        Push    "R0-R2, lr"
        MOV     R2, R10
        MOV     R10, R12                        ; keep updated thisblk
        BL      FreeSysHeapNode
        STRVS   R0, [stack]
        Pull    "R0-R2, PC"                     ; returns Vset if sysheap poo'd.
 ]
a553 1
 [ AssembleKEYV
a554 3
 |
   & 0, 0, NaffVector           ; KEYV   * &13
 ]
a583 1
 [ AssemblePointerV
a584 3
 |
   & 0, 0, NaffVector           ; PointerV * &26
 ]
a744 3
         GBLL FIQDebug
FIQDebug SETL {FALSE}

a918 3
    [ FIQDebug
     TubeChar r0, r1, "MOV r1, #""D"""
    ]
a957 4
   [ FIQDebug
   TubeChar r0, r1, "MOV r1, #""C"""
   ]

a969 4
   [ FIQDebug
   TubeChar r0, r1, "MOV r1, #""I"""
   ]

a973 7

  [ FIQDebug
  BEQ  sam001
  TubeChar r0, r1, "MOV r1, #""M"""
  CMP  r9, #0
sam001
  ]
a987 4
   [ FIQDebug
   TubeChar r0, r1, "MOV r1, #""i"""
   ]

a988 8

   [ FIQDebug
   BEQ sam002
   TubeChar r0, r1, "MOV r1, #""B"""
   CMP r9, #1
sam002
   ]

a1000 4
   [ FIQDebug
   TubeChar r0, r1, "MOV r1, #""R"""
   ]

a1004 1
   [ {TRUE}
a1007 3
   |
       BEQ      %BT05                          ; issue call
   ]
a1010 4
   [ FIQDebug
   TubeChar r0, r1, "MOV r1, #""b"""
   ]

@


4.10
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a807 5
  [ STB
       CMP      r1, #Service_PortMan
       BLEQ     svc_PortMan
  ]

@


4.9
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a321 1
  [ No26bitCode
a323 3
  |
;       lr contains return address + flags/int state to set up before calling
  ]
a328 1
  [ No26bitCode
a334 7
  |
        CMP     r10, #NVECTORS
        MOVCSS  pc, lr                  ; return - silly value

        Push    lr                      ; claimed return goes back to caller
        TEQP    lr, #0                  ; put back caller's flags + int state
  ]
a349 1
  [ No26bitCode
a354 5
  |
        Pull    pc,,^                   ; we don't expect to get to here
                                        ; (should always be claimed),
                                        ; but return to caller, restoring flags
  ]
a963 3
    [ :LNOT: HAL
       STRB     R1, [R1, #MOShasFIQ-Service_ReleaseFIQ]
    ]
a968 1
    [ HAL
a998 1
    ]
a1143 1
 [ HAL
a1153 1
 ]
@


4.8
log
@	Added new debug flag DebugROMPostInit

Detail:
	It is often the case that modules fail on receipt of a PostInit
cervice call. The Kernel already has an option to display debugging on module
initialisation (DebugROMInit), but this does not help if a module crashes
during the PostInit stage.
	To aid debugging of the PostInit stage of module initialisation, a
new flag (DebugROMPostInit) has been added to the vanilla service call
handler. This flag displays the name of each module that the PostInit is
being dispatched to, and then displays whether control has passed back to the
kernel. Hence crashes of a module during PostInit can be detected.

Admin:
	Note that this debug option only works in the vanilla service call
handler. If your build uses the chocolate handler and you wish to debug
PostInit of modules, then set it temporarilly to use vanilla handlers.
	Tested in Lazarus builds both with and without the option switched.

Version 5.26. Not tagged
@
text
@d31 1
a31 1
;       r0 =  base to read number in (0 means any based number allowed)
d36 3
d42 1
d44 1
a44 1
ReadUnsigned_Routine ENTRY "r0-r1, r3-r4, r9"
d48 10
d59 5
a63 2
        MOV     r9, r2            ; limit value
        TST     r0, #3 :SHL: 29
d65 2
a66 1
        TSTNE   r0, #1 :SHL: 30
d68 1
a69 2
        MOV     r11, r0         ; Remember the input flags
        BIC     r12, r0, #(2_111 :SHL: 29) ; r12 := base
d82 5
a86 2
        BL      ReadNumberInBase
        BVS     %FT95
d95 5
a99 2
15      CMP     r2, r9
        BHI     %FT80
d109 1
a109 1
        LDRB    r0, [r1]        ; Is it base_number ?
a112 1
        ADDEQ   r1, r1, #1      ; Skip the '_'
d120 5
a124 2
        BL      ReadNumberInBase ; Read rest of number
        BVS     %FT95
a128 3
      [ International
        B       %FT94
      |
a129 1
      ]
a131 3
      [ International
        B       %FT94
      |
a132 1
      ]
d136 1
a137 1
94
a143 2

95
d145 3
a148 1
        MOV     r2, #0          ; Defined to return 0 on error
d160 1
a160 1
; Out   VC : Number read in r2, r1 updated. r3 = number of chars used
d163 1
a163 1
ReadNumberInBase ENTRY "r0, r1, r12"
d167 1
d171 5
a176 1

d219 39
d268 1
a268 1
GetCharForReadNumber ENTRY
d307 1
a307 1
      LDR   R2, =VecPtrTab       ; Point at table of head pointers
d334 1
a334 1
        mrs     AL, r12, CPSR
d338 1
a338 1
        msr     AL, CPSR_f, r12         ; put back caller's flags + int state
d348 1
a348 1
        LDR     r14, =VecPtrTab         ; Point at table of head pointers
d366 1
a366 1
        msr     AL, CPSR_f, r12
d400 1
a400 1
        LDR     R11, =VecPtrTab         ; Get ptr to table of head pointers
d417 1
a417 1
      LDR   R11, =VecPtrTab         ; Point at table of head pointers
d425 1
a425 1
      MOV   r3,#ChocolateBlockArrays
d471 1
a471 1
        LDR     R11, =VecPtrTab         ; Get ptr to table of head pointers
d534 1
a534 1
        MOV     r1,#ChocolateBlockArrays
d581 1
a581 1
   & 0, OsbyteVars, PMFWrch     ; WrchV  * &03
d585 2
a586 2
   & 0, OsbyteVars, OsByte
   & 0, OsbyteVars, OsWord
d593 1
a593 1
   & 0, OsbyteVars, VecRdLine   ; ReadlineV  * &0E - end of VecNo=SWINo
d597 1
a597 1
   & 0, EvtHan_ws, DefEvent     ; EventV * &10
d614 1
a614 1
   & 0, HiServ_ws, HighSWI      ; UKSWIV   * &18   ; ---| Unknown SWI numbers
d623 1
a623 1
   & 0, UpCallHan_ws, CallUpcallHandler
d627 1
a627 1
   & 0, VduDriverWorkSpace, SpriteVecHandler ; SpriteV * &1F
d631 1
a631 1
   & 0, VduDriverWorkSpace, MOSPaletteV ; PaletteV * &23
d636 3
d640 7
a648 6
   & 0, 0, NaffVector           ; &27
   & 0, 0, NaffVector           ; &28
   & 0, 0, NaffVector           ; &29
   & 0, 0, NaffVector           ; &2a
   & 0, 0, NaffVector           ; &2b
   & 0, 0, NaffVector           ; &2c
d657 1
a657 1
        mrs     AL, lr, CPSR
d659 1
a659 1
        msr     AL, CPSR_f, lr          ; Clear V, preserve rest
d677 1
d680 6
a685 1
      SETPSR I_bit, R3           ; IRQs off while holding context.
d687 1
a687 1
03    LDR   R11, =VecPtrTab         ; Point at table of head pointers
d704 1
a704 1
      CMP   R12, #UserMemStart
d722 1
a722 1
        MOV     r1,#ChocolateBlockArrays
d759 21
d793 1
d836 1
a836 1
       MOV      R10,#0
d859 1
d862 3
d874 1
a874 1
       LDR      R10,=Serv_UsrChains
d897 1
a897 1
       MOV      R10,#0
d909 1
d912 3
d922 1
a922 1
05     MOV      R10, #Module_List
d946 1
d949 3
d982 1
d984 1
d989 33
a1022 1
     assert (Service_ReleaseFIQ :AND: &FF) <> 0
d1028 1
a1028 1
       MOV      R10, #0
d1061 1
a1061 1

d1065 1
a1065 1
	; do it this way to cope with ARM v4/v3 differences on storing PC
d1070 1
a1070 1
       MOV      r10, #0
d1072 1
d1104 1
a1104 1
       MOV      r10, #0
d1127 1
d1129 4
d1167 13
d1187 1
a1187 1
       msr      ,CPSR_f, R12            ; restore caller CCs (including V)
d1189 1
a1189 1
       mrs      ,r10, CPSR              ; restore CCs
d1191 1
d1195 4
d1220 1
a1220 1
       Pull   "r0, r3, PC", NE            ; can only retry if ran out of room
d1274 1
a1274 1
FreeSysHeapNode ENTRY
d1287 38
a1324 45
        Push    "R1, lr"
        CMP     R0, R1
        SUBNE   R1, R1, #1       ; cope with zero length range sensibly
        MOV     R10, #0

        MOV     R11, #0
        LDR     R12, [R10, #AplWorkSize]
        BL      RangeCheck

        MOV     r11, #SysHeapChunkAddress       ; need to still check 1st 8K
        ADD     r12, r11, #SysHeapStart-SysHeapChunkAddress
        BL      RangeCheck

        MOV     R11, #CursorChunkAddress
        ADD     R12, R11, #32*1024
        BL      RangeCheck

; not in one of those ranges, so check against dynamic area list
        MOV     r10, #DAList
10
        LDR     r10, [r10, #DANode_Link]
        TEQ     r10, #0                 ; end of list
        BEQ     %FT20
        LDR     r11, [r10, #DANode_Base]
        LDR     r12, [r10, #DANode_Flags]
        TST     r12, #DynAreaFlags_DoublyMapped
        LDR     r12, [r10, #DANode_Size]
        SUBNE   r11, r11, r12           ; if doubly mapped, move base back by size
        MOVNE   r12, r12, LSL #1        ; and double size
        ADD     r12, r12, r11           ; make r12 point at end (exclusive)
        CMP     r0, r12                 ; if start >= end (excl)
        BCS     %BT10                   ; then go onto next node

        CMP     r0, r11                 ; if range starts below this area
        BCC     %FT20                   ; then not totally within this area
        CMP     r1, r12                 ; else if range ends before end+1 of this area
        BCC     AddressIsValid          ; then it's valid
20

; not in one of those ranges, so issue service so modules can add other valid areas

        Push    "R2, R3"
        MOV     R2, R0                  ; pass parameters to service in R2 and R3
        LDR     R3, [stack, #2*4]       ; reload stacked R1 into R3
        MOV     R1, #Service_ValidateAddress
d1326 2
a1327 3
        TEQ     R1, #0                  ; EQ => service claimed, so OK
        Pull    "R2, R3"
        Pull    "R1, lr"
a1331 8
RangeCheck ; check R0 - R1 lies totally within R11 - (r12-1)

        SUB     R12, R12, #1
        CMP     R0, R11
        CMPCS   R12, R0
        CMPCS   R1, R11
        CMPCS   R12, R1
        MOVCC   PC, lr                  ; failed
d1333 1
a1333 1
        Pull    "R1, lr"
d1335 2
a1336 1
        ExitSWIHandler
@


4.8.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d40 1
a40 1
ReadUnsigned_Routine Entry "r0-r1, r3-r4, r9"
d146 1
a146 1
ReadNumberInBase Entry "r0, r1, r12"
d207 1
a207 1
GetCharForReadNumber Entry
d273 1
a273 1
        MRS     r12, CPSR
d277 1
a277 1
        MSR     CPSR_f, r12             ; put back caller's flags + int state
d305 1
a305 1
        MSR     CPSR_f, r12
d592 1
a592 1
        MRS     lr, CPSR
d594 1
a594 1
        MSR     CPSR_f, lr              ; Clear V, preserve rest
d1029 1
a1029 1
       MSR       CPSR_f, R12            ; restore caller CCs (including V)
d1031 1
a1031 1
       MRS       r10, CPSR              ; restore CCs
d1111 1
a1111 1
FreeSysHeapNode Entry
d1133 1
a1133 1
        LDR     r11, =SysHeapChunkAddress       ; need to still check 1st 8K
d1137 1
a1137 1
        LDR     R11, =CursorChunkAddress
@


4.8.2.2
log
@More stuff. Up to the desktop now; cache on, working keyboard. Some source
restructuring to start to make splitting it up into several object files more
feasible.
@
text
@d1133 2
a1134 2
        LDR     r11, =SVCStackAddress
        ADD     r12, r11, #SVCStackSize
a1135 16

 [ IRQStackAddress <> CursorChunkAddress
        LDR     r11, =IRQStackAddress
        ADD     r12, r11, #IRQStackSize
        BL      RangeCheck
 ]

        LDR     r11, =UNDStackAddress
        ADD     r12, r11, #UNDStackSize
        BL      RangeCheck

        LDR     r11, =ABTStackAddress
        ADD     r12, r11, #ABTStackSize
        BL      RangeCheck

 ! 0, "ValidateAddress - what about CAM and page tables? - strictly should be included"
@


4.8.2.3
log
@* Fixed the IIC code.
* Kernel puts sensible default FIQ handler in through the HAL.
* Fix to temporary page uncaching code.

Version 5.35, 4.79.2.30. Tagged as 'Kernel-5_35-4_79_2_30'
@
text
@a876 1
    [ :LNOT: HAL
a877 1
    ]
d882 1
a883 15
    [ HAL
       LDRB     R9, [R1, #MOShasFIQ-Service_ReleaseFIQ]
       STRB     R1, [R1, #MOShasFIQ-Service_ReleaseFIQ]
       TEQ      R9, #0
       BNE      %FT06
       AddressHAL
       Push     "R0,R2,R3"
       MOV      R0, #&1C
       CallHAL  HAL_FIQDisableCode
       MOV      R0, #0                  ; in case 32-byte cache lines
       MOV      R1, #&100
       ARMop    IMB_Range,,,R0
       Pull     "R0,R2,R3"
    ]

@


4.8.2.4
log
@* Allows interrupt-driven use of PointerV (as well as polled).
* Allows HAL-driven software resets.
* Sound buffers corrected to be uncacheable.

Version 5.35, 4.79.2.33. Tagged as 'Kernel-5_35-4_79_2_33'
@
text
@a574 3
 [ AssemblePointerV
   & 0, 0, PointerVector        ; PointerV * &26
 |
a575 1
 ]
@


4.8.2.5
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a579 7
   & 0, 0, NaffVector           ; TimeCodeV * &27
   & 0, 0, NaffVector           ; LowPriorityEventV &28
 [ UseGraphicsV
   & 0, 0, MOSGraphicsV         ; GraphicsV * &29
 |
   & 0, 0, NaffVector           ; GraphicsV * &29
 ]
d582 3
d894 4
a897 12

       ADR      R1, FIQKiller
       MOV      R10, #FIQKiller_ws - FIQKiller
       MOV      R11, #&1C
04     LDR      LR, [R1], #4
       SUBS     R10, R10, #4
       STR      LR, [R11], #4
       BNE      %BT04
       AddressHAL R10
       LDR      R14, [R9, #-(EntryNo_HAL_FIQDisableAll+1)*4]
       STMIA    R11, {R9, R14}
       Push     "R0"
d901 1
a901 1
       Pull     "R0"
a1041 12
 [ HAL
FIQKiller
       SUB     R14, R14, #4
       MOV     R13, #&100
       ADR     R10, FIQKiller_ws
       STMFD   R13!, {R0-R3,R14}
       MOV     R14, PC
       LDMIA   R10, {R9,PC}
       LDMFD   R13!, {R0-R3,PC}^
FIQKiller_ws
 ]

a1174 7
        BL      RangeCheck

        VDWS    R12                     ; in case of external framestore
        LDR     R11, [R12, #ScreenEndAddr]
        LDR     R12, [R12, #TotalScreenSize]
        SUB     R11, R11, R12
        ADD     R12, R11, R12, LSL #1   ; doubly-mapped friggage
@


4.8.2.6
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@a581 1
   & 0, 0, NaffVector           ; &29
d583 1
a583 1
   & 0, 0, MOSGraphicsV         ; GraphicsV * &2a
d585 1
a585 1
   & 0, 0, NaffVector           ; GraphicsV * &2a
d589 1
@


4.8.2.7
log
@OSDelink/RelinkApp now work on the list in opposite orders so that
the order of vector claims doesn't get toggled.
Fix for *FX5 not working due to a TST having been swapped for CMP.
Checkprotectionlink option added to HAL version so CMOS lock is
implemented.
Updated HAL docs.

Version 5.35, 4.79.2.58. Tagged as 'Kernel-5_35-4_79_2_58'
@
text
@a695 21
 [ {TRUE}
; Run through the buffer BACKWARDS to ensure that the vectors are
; reinstalled in the same order.
      Push   "R0-R3, lr"
      MOV     R3, R0            ; R3 -> start of buffer
      MOV     R10, R0
01    LDR     R0, [R10], #12    ; search forwards to find terminator
      CMP     R0, #-1
      BNE     %BT01
      SUB     R10, R10, #12     ; R10 -> terminator
02    CMP     R10, R3           ; loop backwards until we get to start
      Pull   "R0-R3, lr", EQ
      ExitSWIHandler EQ

      LDMDB   R10!, {R0-R2}
      SWI     XOS_AddToVector
      BVC     %BT02
      STR     R0, [stack]
      Pull   "R0-R3, lr"
      B      SLVK_SetV
 |
a708 1
 ]
@


4.8.2.8
log
@Added UnthreadV (vector &2B). Called near the end of despatch of the
outermost interrupt, in IRQ32/26 mode with IRQs disabled, just before
transient and non-transient callback checking is performed. Suitable for
implementing a CBAI replacement.

Version 5.35, 4.79.2.69. Tagged as 'Kernel-5_35-4_79_2_69'
@
text
@a587 1
   & 0, 0, NaffVector           ; UnthreadV * &2b
d590 1
@


4.8.2.9
log
@  s.ArthurSWIS  change line 608 to use R2 as temp space.. R3 was needed
Detail:

Admin:
  Tested in ROM at Castle


Version 5.35, 4.79.2.73. Tagged as 'Kernel-5_35-4_79_2_73'
@
text
@d622 1
a622 1
      SETPSR I_bit, R2           ; IRQs off while holding context.
@


4.8.2.10
log
@Merge over some changes from the Cortex branch
Detail:
  hdr/ARMops - Reserve OS_PlatformFeatures 0 bit 20 for indicating whether high processor vectors are in use
  s/Kernel - Add local definitions of BYTEWS, LDROSB, STROSB, VDWS macros (previously in Hdr:Macros)
  s/MoreComms - Fix potential buffer overflow when filling error buffer (although GSTrans shouldn't overflow the buffer in the first place?)
  s/Arthur2 - GSRead number detection fix
  s/ArthurSWIs - Updated OS_ReadUnsigned to support reading 64bit numbers
  Docs/ReadUnsigned - Docs for the updated OS_ReadUnsigned interface
Admin:
  Untested!
  Needs HdrSrc 1.86


Version 5.35, 4.79.2.120. Tagged as 'Kernel-5_35-4_79_2_120'
@
text
@d31 1
a31 1
;       r0 =     bits 0-7: base to read number in (0 means any based number allowed)
a35 3
;                bit 28 set -> read 64-bit value to R2,R3 and
;                               if applicable, range is in R2,R3
;       r4 != &45444957 ("WIDE") -> legacy mode: bits 8-28 are considered part of the base
a38 1
;       either way, R4 = mask of flag bits supported
d40 1
a40 1
ReadUnsigned_Routine Entry "r0-r1, r3-r6, r9"
a43 10
        LDR     lr, =&45444957
        CMP     r4, lr
        MOVEQ   r4, #(2_1111 :SHL: 28)
        MOVNE   r4, #(2_111 :SHL: 29)
        STREQ   r4, [stack, #3*4]
        
        AND     r11, r0, r4       ; Remember the input flags
        ANDEQ   r12, r0, #255     ; r12 := base
        BICNE   r12, r0, r4

d45 2
a46 5
        MOV     r9, r2            ; limit value lo word
        TST     r11, #1 :SHL: 28
        MOVEQ   r6, #0            ; limit value hi word
        MOVNE   r6, r3
        TST     r11, #3 :SHL: 29
d48 1
a48 2
        MOVEQ   r6, #-1
        TST     r11, #1 :SHL: 30
a49 1
        MOVNE   r6, #0
d51 2
d65 2
a66 5
        TST     r11, #1 :SHL: 28
        ADR     lr, %FT09
        BEQ     ReadNumberInBase
        BNE     Read64BitNumberInBase
09      BVS     %FT95
d75 2
a76 5
15      CMP     r9, r2
        SBCS    lr, r6, r5
        BCC     %FT80
        TST     r11, #1 :SHL: 28
        STRNE   r5, [stack, #4*2]
d86 1
a86 1
        LDRB    r0, [r1], #1    ; Is it base_number ?
d90 1
d98 2
a99 5
        TST     r11, #1 :SHL: 28
        ADR     lr, %FT39
        BEQ     ReadNumberInBase ; Read rest of number
        BNE     Read64BitNumberInBase
39      BVS     %FT95
d130 1
a131 3
        TST     r11, #1 :SHL: 28
        STRNE   r2, [stack, #4*2] ; return MSB=0 on error too, if 64-bit read reqd
        PullEnv
d143 1
a143 1
; Out   VC : Number read in r2, r1 updated. r3 = number of chars used, r5 = 0
a149 1
        MOV     r5, #0
d153 1
a154 5
        TST     r2, #&F8000000  ; If EQ, can't possibly overflow in any base up to 26
        MLAEQ   r2, r4, r2, r0
        BEQ     %BT10
        
        MOV     r12, r4
a196 39
; Read64BitNumberInBase
; =====================

; In    r1 -> string, r4 = base (valid)

; Out   VC : Number read in r2 (lo) and r5 (hi), r1 updated. r3 = number of chars used
;       VS : r1 preserved, r2 -> error block, r5 corrupted

Read64BitNumberInBase ALTENTRY

        MOV     r2, #0          ; Result lo
        MOV     r3, #0          ; Number of valid digits read
        MOV     r5, #0          ; Result hi

10      BL      GetCharForReadNumber
        BNE     %BT50           ; Finished ?

      [ :LNOT: NoARMv4
        TST     r5, #&F8000000  ; If EQ, can't possibly overflow in any base up to 26
        MULEQ   r5, r4, r5      ; r0,r5 = new_digit + (old_msw * base)<<32
        UMLALEQ r0, r5, r4, r2  ; r0,r5 += old_lsw * base
        MOVEQ   r2, r0
        BEQ     %BT10
      ]
                                ; Multiply by repeated addition. Base <> 0 !
        SUBS    r12, r4, #1     ; Final iteration has r2,r5 as dest, so one fewer main iterations
        MOV     r14, #0         ; r0,r14 is accumulator, initialised to new_digit,0
20      ADDS    r0, r0, r2
        ADCS    r14, r14, r5
        BCS     %BT90
        SUBS    r12, r12, #1
        BNE     %BT20
        ADDS    r2, r0, r2
        ADCS    r5, r14, r5
        BCC     %BT10
        B       %BT90           ; Checks for overflow here too!

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
@


4.8.2.11
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d317 1
a317 1
      LDR   R2, =ZeroPage+VecPtrTab ; Point at table of head pointers
d358 1
a358 1
        LDR     r14, =ZeroPage+VecPtrTab ; Point at table of head pointers
d410 1
a410 1
        LDR     R11, =ZeroPage+VecPtrTab ; Get ptr to table of head pointers
d427 1
a427 1
      LDR   R11, =ZeroPage+VecPtrTab ; Point at table of head pointers
d435 1
a435 1
      LDR   r3,=ZeroPage+ChocolateBlockArrays
d481 1
a481 1
        LDR     R11, =ZeroPage+VecPtrTab ; Get ptr to table of head pointers
d544 1
a544 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d591 1
a591 1
   & 0, ZeroPage+OsbyteVars, PMFWrch ; WrchV  * &03
d595 2
a596 2
   & 0, ZeroPage+OsbyteVars, OsByte
   & 0, ZeroPage+OsbyteVars, OsWord
d603 1
a603 1
   & 0, ZeroPage+OsbyteVars, VecRdLine ; ReadlineV  * &0E - end of VecNo=SWINo
d607 1
a607 1
   & 0, ZeroPage+EvtHan_ws, DefEvent ; EventV * &10
d624 1
a624 1
   & 0, ZeroPage+HiServ_ws, HighSWI ; UKSWIV   * &18   ; ---| Unknown SWI numbers
d633 1
a633 1
   & 0, ZeroPage+UpCallHan_ws, CallUpcallHandler
d637 1
a637 1
   & 0, ZeroPage+VduDriverWorkSpace, SpriteVecHandler ; SpriteV * &1F
d641 1
a641 1
   & 0, ZeroPage+VduDriverWorkSpace, MOSPaletteV ; PaletteV * &23
d655 1
a655 1
   & 0, ZeroPage, MOSGraphicsV  ; GraphicsV * &2a
a690 1
    [ ZeroPage = 0
a692 5
    |
      LDR   R4, =ZeroPage
      MOV   R3, #NVECTORS-1
      LDR   R4, [R4, #AplWorkSize]
    ]
d695 1
a695 1
03    LDR   R11, =ZeroPage+VecPtrTab ; Point at table of head pointers
d730 1
a730 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d844 1
a844 1
       LDR      R10,=ZeroPage
d878 1
a878 1
       LDR      R10,=ZeroPage+Serv_UsrChains
d901 1
a901 1
       LDR      R10,=ZeroPage
d922 1
a922 1
05     LDR      R10, =ZeroPage+Module_List
a986 1
     [ ZeroPage = 0
a988 6
     |
       LDR      R1, =ZeroPage+MOShasFIQ
       ASSERT ((ZeroPage+MOShasFIQ) :AND: 255) <> 0
       LDRB     R9, [R1]
       STRB     R1, [R1]
     ]
d994 1
a994 1
       LDR      R11, =ZeroPage+&1C
a998 3
     [ ZeroPage <> 0
       LDR      R10, =ZeroPage
     ]
d1003 2
a1004 2
       LDR      R0, =ZeroPage
       ADD      R1, R0, #&100
d1014 1
a1014 1
       LDR      R10, =ZeroPage
d1047 1
a1047 1
       ASSERT   (ZeroPage :AND: 255) = 0
d1056 1
a1056 1
       LDR      r10, =ZeroPage
d1089 1
a1089 1
       LDR      r10, =ZeroPage
a1111 1
     [ ZeroPage = 0
a1112 4
     |
       LDR      r9, =ZeroPage
       LDR      r9, [r9, #SExitA]
     ]
d1150 1
a1150 1
       ADR     R13, FIQKiller-&1C+&100
d1264 1
a1264 1
        LDR     R10, =ZeroPage
a1265 1
 [ ZeroPage = 0
a1266 3
 |
        MOV     R11, #ScratchSpace
 ]
a1300 10
 [ ZeroPage <> 0
        MOV     r11, r10
        ADD     r12, r11, #16*1024
        BL      RangeCheck

        LDR     r11, =DebuggerSpace
        ADD     r12, r11, #DebuggerSpace_Size
        BL      RangeCheck
 ]

d1302 1
a1302 1
        LDR     r10, =ZeroPage+DAList
@


4.8.2.12
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d1067 1
a1067 1
        ; do it this way to cope with ARM v4/v3 differences on storing PC
@


4.8.2.13
log
@Fix OS_Heap 4. Fix stack imbalance in system heap code.
Detail:
  s/HeapMan - The code to check if it's safe to shrink a block by 4 bytes assumed 'addr' was the address of the block, when in reality it's just an offset. This was causing the "OK to shrink?" check to always ignore the shrink request on heaps located below the 2G limit, but fail with "heap corrupt" errors in heaps located above the 2G limit.
  s/ArthurSWIs - Fix stack imbalance causing a crash if OS_Heap returns an unexpected error in DoSysHeapOpWithExtension/ClaimSysHeapNode
Admin:
  Tested in Iyonix ROM softload
  Testbed didn't pick up heap shrink bug due to the sanity checks it performs not being vigorous enough.


Version 5.35, 4.79.2.130. Tagged as 'Kernel-5_35-4_79_2_130'
@
text
@d1215 1
a1215 1
       Pull   "r0, PC", NE                 ; can only retry if ran out of room
@


4.8.2.14
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@d246 1
a246 1
      [ :LNOT: NoARMM
a872 1
     [ NoARMv5
a874 3
     |
       BLX      R9
     ]
a918 1
     [ NoARMv5
a920 3
     |
       BLX      R9
     ]
a951 1
     [ NoARMv5
a953 3
     |
       BLX      R9
     ]
a1190 1
     [ NoARMT2
a1193 4
     |
       MOV       r10, r10, LSR #28
       BFI       lr, r10, #28, #4
     ]
@


4.8.2.15
log
@OS_ChangeDynamicArea performance optimisations
Detail:
  s/ChangeDyn:
    - Apply various optimisations to OS_ChangeDynamicArea to reduce the execution time when performing large grows/shrinks.
    - Optimisations can be toggled on/off with FastCDA_* flags for debugging.
    - On a 1GHz 512MB BB-xM, the initial *FreePool call now takes 0.15s instead of 13.46s. On a 512MB Iyonix the time has dropped from 1.18s to 0.23s.
    - Growing screen memory (on BB-xM) has also seen significant gains - between 2x and 4x speedup, depending on what state the source pages are in.
    - Added/updated documentation for a few functions and made more use of ROUTs for safety
  s/ARM600, s/VMSAv6:
    - Update BangCamUpdate, etc. to add support for the PageFlags_Unsafe flag that OS_ChangeDynamicArea uses to bypass cache/TLB maintenance in some situations
    - Avoid BangCamUpdate calling BangL2PT to map out the page if the page isn't mapped in (avoids unnecessary cache/TLB flush)
  s/ArthurSWIs:
    - Add extra ASSERT for safety
  s/AMBcontrol/memory
    - Fix incorrect assumption that the usable size of a heap block is always 8 less than the value stored in the header. Even with the old 8 byte aligned allocations the usable size will always be 4 bytes less than the value in the header. This code would have resulted in some slight memory wasteage, as AMBcontrol will have always tried growing the block four bytes bigger than needed.
Admin:
  Tested on Iyonix & BB-xM


Version 5.35, 4.79.2.146. Tagged as 'Kernel-5_35-4_79_2_146'
@
text
@a1085 1
       ASSERT   (ZeroPage :AND: 255) = 0
@


4.8.2.16
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d129 3
d133 1
d136 3
d140 1
a143 1
95
d145 1
d152 2
@


4.8.2.17
log
@Adopt some switches from Hdr:Machine/Machine
SystemName, ROMSizeOffset, HAL32, HAL26 only used here, moved here.
Remove uses of "M_" booleans, apparently that's bad form.
Fix SWIDespatch_Size for the non thumb capable case (was ASSERTing).
Swapped UserMemStart for AppSpaceStart.
Removed last use of OldComboSupport (pre Medusa!).
Removed switch 'CDVPoduleIRQs', a correction to the machine definitions mean this can now simply be switched on NumberOfPodules (previously, IOMD couldn't chain podule interrupts).
Take out disabled sub interrupt support - it's in CVS if you want to try to get it working.
Moved ConfiguredLang to 11 for everyone, it only matters if !Boot fails, and no harm in making it common for 5.xx onwards.

Version 5.35, 4.79.2.183. Tagged as 'Kernel-5_35-4_79_2_183'
@
text
@d708 1
a708 1
      CMP   R12, #AppSpaceStart
@


4.8.2.18
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d645 1
a645 1
   & 0, ZeroPage+VduDriverWorkSpace, MOSGraphicsV  ; GraphicsV * &2a
@


4.8.2.19
log
@Strip out some old build switches
Detail:
  hdr/Options, s/ArthurSWIs, s/ChangeDyn, s/PMF/KbdDrA1, s/PMF/key, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdugrafhal, s/vdu/vdugrafv, s/vdu/vdumodes, s/vdu/vduwrch:
  - Strip out DoingVdu build switch (did nothing)
  - Strip out Japanese16BitSound switch (did nothing)
  - Strip out MakeModeSelectorsForModeNUmbers switch (altered the mode list structures, but there wasn't any code to do anything with the new data)
  - Strip out remaining uses of UseGraphicsV switch (now hardwired to {TRUE})
  - Strip out ShadowROM switch (altered FixedAreasTable to show the shadow mapping, but code to create the mapping is missing)
  - Strip out PollMouse switch (old Archimedes-era debug/development option)
Admin:
  Tested on BB-xM
  Builds to same binary as previous version


Version 5.35, 4.79.2.204. Tagged as 'Kernel-5_35-4_79_2_204'
@
text
@d644 1
d646 3
@


4.8.2.20
log
@Add OS_Memory 24 implementation. Change OS_ValidateAddress to use it. Fix kernel leaving the physical access MB in a messy state. Try and protect against infinite abort loops caused by bad environment handlers.
Detail:
  s/MemInfo - Added an implementation of ROL's OS_Memory 24 call. Unlike the old OS_ValidateAddress call, this call should successfully report the presence of all memory areas known to the kernel. It should also correctly indicate which parts of a sparse DA are mapped in, unlike the old OS_ValidateAddress implementation.
  s/ChangeDyn - Update dynamic area handling to construct a lookup table for mapping logical addresses to dynamic areas; this is used by OS_Memory 24 to quickly locate which DA(s) hit a given region
  s/AMBControl/main - Make sure lazy task swapping is marked as disabled when AMB_LazyMapIn is {FALSE} - required so that OS_Memory 24 will give application space the correct flags
  s/ArthurSWIs - Switch OS_ValidateAddress over to using OS_Memory 24, as per ROL. For compatibility, Service_ValidateAddress is still issued for any areas which the kernel doesn't recognise (currently, OS_Memory 24 doesn't issue any service calls itself)
  s/Convrsions - ADR -> ADRL to keep things happy
  s/HAL - Fix L2PT page allocation and RAM clear to release the physical access region once they're done with it
  s/Kernel - Make the error dispatcher validate the error handler code ptr & error buffer using OS_Memory 24 before attempting to use them. If they look bad, reset to default. Should prevent getting stuck in an infinite abort loop in some situations (e.g. as was the case with ticket 279). The system might not fully recover, but it's better than a hard crash.
  s/Middle - Rework data/prefetch/etc. abort handlers so that DumpyTheRegisters can validate the exception dump area via OS_Memory 24 before anything gets written to it. Should also help to prevent some infinite abort loops. Strip 26bit/pre-HAL code to make things a bit more readable.
  hdr/KernelWS - Update comment
Admin:
  Tested on BB-xM, Raspberry Pi


Version 5.35, 4.79.2.222. Tagged as 'Kernel-5_35-4_79_2_222'
@
text
@d1286 82
a1367 38
        Push    "r0-r3, lr"
        MOV     r2, r1
        MOV     r1, r0
        MOV     r0, #24
        SWI     XOS_Memory
        ; Pre-RISC OS 3.5, OS_ValidateAddress would return OK if the region was:
        ; (a) valid RAM in logical address space
        ; (b) the 2nd mapping of screen memory at the start of physical address space
        ; (c) anything claimed by Service_ValidateAddress
        ;
        ; Post-RISC OS 3.5, OS_ValidateAddress would return OK if the region was:
        ; (a) a dynamic area
        ; (b) screen memory
        ; (c) most special areas
        ; (d) anything claimed by Service_ValidateAddress
        ;
        ; RISC OS Select docs suggest that valid regions for their version are:
        ; (a) dynamic areas, including special areas which have been turned into DAs (e.g. ROM)
        ; (b) some special areas (e.g. zero page)
        ; (c) screen memory
        ; (d) anything claimed by Service_ValidateAddress (example given of sparse DA which uses OS_AbortTrap to map pages on demand)
        ; (e) NOT physically mapped areas (unless screen memory)
        ;
        ; Taking the above into account, our version will behave as follows:
        ; (a) anything completely accessible in any mode, which isn't physically mapped - dynamic areas, special areas, ROM, zero page, etc.
        ; (b) anything completely R/W in user mode, which is completely physically mapped (i.e. screen memory; this check should suffice until we decide on a better way of flagging screen memory/"IO RAM" as valid)
        ; (c) anything claimed by Service_ValidateAddress
        TST     r1, #CMA_Partially_Phys
        MOVEQ   r2, #1
        ANDEQ   r1, r1, #CMA_Completely_UserR+CMA_Completely_UserW+CMA_Completely_PrivR+CMA_Completely_PrivW
        LDRNE   r2, =CMA_Completely_UserR+CMA_Completely_UserW+CMA_Completely_Phys
        ANDNE   r1, r1, r2
        CMP     r1, r2
        BHS     AddressIsValid ; EQ case: At least one completely flag set
                               ; NE case: Flags match required value
        ; OS_Memory check failed, try the service call
        LDMIA   sp, {r2-r3}
        MOV     r1, #Service_ValidateAddress
d1369 3
a1371 2
        TEQ     r1, #0                  ; EQ => service claimed, so OK
        Pull    "r0-r3,lr"
d1376 8
d1385 1
a1385 1
        Pull    "r0-r3,lr"
d1387 1
a1387 2
        ExitSWIHandler        

@


4.8.2.21
log
@Add SWI error pointer validation, SeriousErrorV hooks, and OS_ReadSysInfo 15
Detail:
  Resources/UK/Messages, hdr/KernelWS, s/Kernel - On return from a SWI with V set, do some basic validity checks on the error pointer in order to try and catch buggy SWIs that return bad pointers or invalid error blocks. If a bad pointer is found we'll substitute it with a pointer to a different error block, which has the SWI number in the error message, to allow the user to identify the source of the problem. (There's also a chance we'll crash when investigating a bad pointer, but crashing here in the kernel is preferable to crashing elsewhere because R12 should still contain the SWI number)
  hdr/OSMisc - Define SeriousErrorV reason codes and extended ROM footer entry IDs
  hdr/Options - Remove HangWatch integration flag, obsolete now that SeriousErrorV is available
  s/ArthurSWIs - Keep defaultvectab up to date with vector allocations
  s/Middle - Update serious error handling to call SeriousErrorV at several key points. This allows for accurate crash dumps to be obtained, along with a mechanism to warn low-level components such as RTSupport that the privileged mode stacks are being flattened.
  s/Middle - Add OS_ReadSysInfo 15, for enumerating extended ROM footer entries
  s/PMF/osbyte - Update InitNewFX0Error to use the ROM footer entry ID defined in hdr/OSMisc
Admin:
  Tested on Pi 1B, 2B, 3B


Version 5.35, 4.79.2.313. Tagged as 'Kernel-5_35-4_79_2_313'
@
text
@a645 1
   & 0, 0, NaffVector           ; SeriousErrorV * &2c
d648 1
@


4.8.2.22
log
@Clear the exclusive monitor when returning to pre-empted code
Detail:
  s/Kernel - Add macro for CLREX, which uses a dummy STREX on basic ARMv6 machines. Clear the exclusive monitor after issuing transient callbacks, to cope with callbacks being triggered on exit from IRQ
  s/ArthurSWIs, s/HAL, s/NewIRQs - Clear the exclusive monitor on exit from IRQ handlers & default FIQ handler
  s/VMSAv6 - Clear the exclusive monitor on entry to the data abort pre-veneer
Admin:
  Tested on Raspberry Pi
  Non-transient callback handlers, custom abort handlers, FIQ handlers, and anything else which returns directly to interrupted user code is responsible for issuing its own CLREX if the code has done something that could have left the local monitor in the exclusive state (e.g. calling a SWI counts towards this, as there's no guarantee the monitor will be open on exit from the SWI)


Version 5.35, 4.79.2.327. Tagged as 'Kernel-5_35-4_79_2_327'
@
text
@a1174 1
       MyCLREX R0, R1
@


4.8.2.9.2.1
log
@  Miscellaneous v6-related updates
Detail:
 * Stopped calling the broken abort fixup code when running under VMSAv6.
   Might be desirable to update it, possibly farmed out to a separate module -
   still need to think about this.
 * Unaligned load optimisations can now be disabled by the global NoUnaligned
   flag for testing purposes.
 * Extended OS_ReadUnsigned to permit reading of 64-bit unsigned integers.
   See Docs.ReadUnsigned for more details. Also sped it up by using MLA
   (or UMLAL) for most digits rather than repeated addition.
 * Bugfix is OS_GSRead: an uninitialised r0 was being passed to
   OS_ReadUnsigned, causing undesirable effects on rare occasions.
Admin:
  Tested on a rev B7 beagleboard.

Version 5.35, 4.79.2.98.2.8. Tagged as 'Kernel-5_35-4_79_2_98_2_8'
@
text
@d31 1
a31 1
;       r0 =     bits 0-7: base to read number in (0 means any based number allowed)
a35 3
;                bit 28 set -> read 64-bit value to R2,R3 and
;                               if applicable, range is in R2,R3
;       r4 != &45444957 ("WIDE") -> legacy mode: bits 8-28 are considered part of the base
a38 1
;       either way, R4 = mask of flag bits supported
d40 1
a40 1
ReadUnsigned_Routine Entry "r0-r1, r3-r6, r9"
a43 10
        LDR     lr, =&45444957
        CMP     r4, lr
        MOVEQ   r4, #(2_1111 :SHL: 28)
        MOVNE   r4, #(2_111 :SHL: 29)
        STREQ   r4, [stack, #3*4]
        
        AND     r11, r0, r4       ; Remember the input flags
        ANDEQ   r12, r0, #255     ; r12 := base
        BICNE   r12, r0, r4

d45 2
a46 5
        MOV     r9, r2            ; limit value lo word
        TST     r11, #1 :SHL: 28
        MOVEQ   r6, #0            ; limit value hi word
        MOVNE   r6, r3
        TST     r11, #3 :SHL: 29
d48 1
a48 2
        MOVEQ   r6, #-1
        TST     r11, #1 :SHL: 30
a49 1
        MOVNE   r6, #0
d51 2
d65 2
a66 5
        TST     r11, #1 :SHL: 28
        ADR     lr, %FT09
        BEQ     ReadNumberInBase
        BNE     Read64BitNumberInBase
09      BVS     %FT95
d75 2
a76 5
15      CMP     r9, r2
        SBCS    lr, r6, r5
        BCC     %FT80
        TST     r11, #1 :SHL: 28
        STRNE   r5, [stack, #4*2]
d86 1
a86 1
        LDRB    r0, [r1], #1    ; Is it base_number ?
d90 1
d98 2
a99 5
        TST     r11, #1 :SHL: 28
        ADR     lr, %FT39
        BEQ     ReadNumberInBase ; Read rest of number
        BNE     Read64BitNumberInBase
39      BVS     %FT95
d130 1
a131 3
        TST     r11, #1 :SHL: 28
        STRNE   r2, [stack, #4*2] ; return MSB=0 on error too, if 64-bit read reqd
        PullEnv
d143 1
a143 1
; Out   VC : Number read in r2, r1 updated. r3 = number of chars used, r5 = 0
a149 1
        MOV     r5, #0
d153 1
a154 5
        TST     r2, #&F8000000  ; If EQ, can't possibly overflow in any base up to 26
        MLAEQ   r2, r4, r2, r0
        BEQ     %BT10
        
        MOV     r12, r4
a196 39
; Read64BitNumberInBase
; =====================

; In    r1 -> string, r4 = base (valid)

; Out   VC : Number read in r2 (lo) and r5 (hi), r1 updated. r3 = number of chars used
;       VS : r1 preserved, r2 -> error block, r5 corrupted

Read64BitNumberInBase ALTENTRY

        MOV     r2, #0          ; Result lo
        MOV     r3, #0          ; Number of valid digits read
        MOV     r5, #0          ; Result hi

10      BL      GetCharForReadNumber
        BNE     %BT50           ; Finished ?

      [ :LNOT: NoARMv4
        TST     r5, #&F8000000  ; If EQ, can't possibly overflow in any base up to 26
        MULEQ   r5, r4, r5      ; r0,r5 = new_digit + (old_msw * base)<<32
        UMLALEQ r0, r5, r4, r2  ; r0,r5 += old_lsw * base
        MOVEQ   r2, r0
        BEQ     %BT10
      ]
                                ; Multiply by repeated addition. Base <> 0 !
        SUBS    r12, r4, #1     ; Final iteration has r2,r5 as dest, so one fewer main iterations
        MOV     r14, #0         ; r0,r14 is accumulator, initialised to new_digit,0
20      ADDS    r0, r0, r2
        ADCS    r14, r14, r5
        BCS     %BT90
        SUBS    r12, r12, #1
        BNE     %BT20
        ADDS    r2, r0, r2
        ADCS    r5, r14, r5
        BCC     %BT10
        B       %BT90           ; Checks for overflow here too!

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
@


4.8.2.9.2.2
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d317 1
a317 1
      LDR   R2, =ZeroPage+VecPtrTab ; Point at table of head pointers
d358 1
a358 1
        LDR     r14, =ZeroPage+VecPtrTab ; Point at table of head pointers
d410 1
a410 1
        LDR     R11, =ZeroPage+VecPtrTab ; Get ptr to table of head pointers
d427 1
a427 1
      LDR   R11, =ZeroPage+VecPtrTab ; Point at table of head pointers
d435 1
a435 1
      LDR   r3,=ZeroPage+ChocolateBlockArrays
d481 1
a481 1
        LDR     R11, =ZeroPage+VecPtrTab ; Get ptr to table of head pointers
d544 1
a544 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d591 1
a591 1
   & 0, ZeroPage+OsbyteVars, PMFWrch ; WrchV  * &03
d595 2
a596 2
   & 0, ZeroPage+OsbyteVars, OsByte
   & 0, ZeroPage+OsbyteVars, OsWord
d603 1
a603 1
   & 0, ZeroPage+OsbyteVars, VecRdLine ; ReadlineV  * &0E - end of VecNo=SWINo
d607 1
a607 1
   & 0, ZeroPage+EvtHan_ws, DefEvent ; EventV * &10
d624 1
a624 1
   & 0, ZeroPage+HiServ_ws, HighSWI ; UKSWIV   * &18   ; ---| Unknown SWI numbers
d633 1
a633 1
   & 0, ZeroPage+UpCallHan_ws, CallUpcallHandler
d637 1
a637 1
   & 0, ZeroPage+VduDriverWorkSpace, SpriteVecHandler ; SpriteV * &1F
d641 1
a641 1
   & 0, ZeroPage+VduDriverWorkSpace, MOSPaletteV ; PaletteV * &23
d655 1
a655 1
   & 0, ZeroPage, MOSGraphicsV  ; GraphicsV * &2a
a690 1
    [ ZeroPage = 0
a692 5
    |
      LDR   R4, =ZeroPage
      MOV   R3, #NVECTORS-1
      LDR   R4, [R4, #AplWorkSize]
    ]
d695 1
a695 1
03    LDR   R11, =ZeroPage+VecPtrTab ; Point at table of head pointers
d730 1
a730 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d844 1
a844 1
       LDR      R10,=ZeroPage
d878 1
a878 1
       LDR      R10,=ZeroPage+Serv_UsrChains
d901 1
a901 1
       LDR      R10,=ZeroPage
d922 1
a922 1
05     LDR      R10, =ZeroPage+Module_List
a986 1
     [ ZeroPage = 0
a988 6
     |
       LDR      R1, =ZeroPage+MOShasFIQ
       ASSERT ((ZeroPage+MOShasFIQ) :AND: 255) <> 0
       LDRB     R9, [R1]
       STRB     R1, [R1]
     ]
d994 1
a994 1
       LDR      R11, =ZeroPage+&1C
a998 3
     [ ZeroPage <> 0
       LDR      R10, =ZeroPage
     ]
d1003 2
a1004 2
       LDR      R0, =ZeroPage
       ADD      R1, R0, #&100
d1014 1
a1014 1
       LDR      R10, =ZeroPage
d1047 1
a1047 1
       ASSERT   (ZeroPage :AND: 255) = 0
d1056 1
a1056 1
       LDR      r10, =ZeroPage
d1089 1
a1089 1
       LDR      r10, =ZeroPage
a1111 1
     [ ZeroPage = 0
a1112 4
     |
       LDR      r9, =ZeroPage
       LDR      r9, [r9, #SExitA]
     ]
d1150 1
a1150 1
       ADR     R13, FIQKiller-&1C+&100
d1264 1
a1264 1
        LDR     R10, =ZeroPage
a1265 1
 [ ZeroPage = 0
a1266 3
 |
        MOV     R11, #ScratchSpace
 ]
a1300 10
 [ ZeroPage <> 0
        MOV     r11, r10
        ADD     r12, r11, #16*1024
        BL      RangeCheck

        LDR     r11, =DebuggerSpace
        ADD     r12, r11, #DebuggerSpace_Size
        BL      RangeCheck
 ]

d1302 1
a1302 1
        LDR     r10, =ZeroPage+DAList
@


4.7
log
@Had one of those weekend brainstorms - managed to speed up SWI despatcher
_and_ add Thumb support to it.
Fixed OS_BreakPt - was confused by PC/PSR split.

Version 5.24. Not tagged
@
text
@d758 1
d829 5
d863 6
d996 26
@


4.6
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d991 1
a991 1
       msr       AL, CPSR_f, R14        ; restore caller CCs
d993 1
a993 1
       mrs       AL, r10, CPSR          ; restore CCs
@


4.5
log
@Actually call the PortManager service call handling routine.

Version 4.93. Tagged as 'Kernel-4_93'
@
text
@d42 1
a42 1
        TEQP    PC, #SVC_mode
d261 4
d266 1
d272 8
d285 1
d301 7
d311 1
d336 1
a336 5
 [ IrqsInClaimRelease
        MOV     R4, #I_bit
        TST     R4, PC                  ; is I_bit set ?
        TEQEQP  R4, PC                  ; No, then set it, save changed bits
        MOVNE   R4, #0                  ; Else no changed bits
d346 1
a346 1
        TEQP    R4, PC                  ; Restore IRQ state
d354 1
a354 8
 |
      TEQP  PC, #SVC_mode+I_bit     ; IRQs off while holding context.
      LDR   R11, =VecPtrTab         ; Point at table of head pointers
      LDR   R10, [R11, R0, LSL #2]! ; R10 "nextblock" := !oldptr,
                                    ; point R11 at the table entry "oldptr"
01    BL    FreeLink
      BVC   %BT01                   ; loop with chain pointers still set
 ]
d375 1
a375 1
      TEQP  PC, #SVC_mode+I_bit     ; force noirq
a405 1
 [ IrqsInClaimRelease
d408 1
a408 4
        MOV     R9, #I_bit
        TST     R9, PC                  ; is I_bit set ?
        TEQEQP  R9, PC                  ; No, then set it, R9 = changed bits
        MOVNE   R9, #0                  ; Else R9=0 for no change
d413 1
a413 1
        TEQP    R9, PC                  ; Restore IRQ state
a416 10
 |
      Push "R0-R2, link"

      TEQP  PC, #SVC_mode+I_bit     ; IRQs off while holding context.
      LDR   R11, =VecPtrTab         ; Point at table of head pointers
      LDR   R10, [R11, R0, LSL #2]! ; R10 "nextblock" := !oldptr,
                                    ; point R11 at the table entry "oldptr"
      BL    FreeLink
      Pull "R0-R2, link"
 ]
d449 1
a449 1
        ORREQS  PC, lr, #V_bit          ; Yes, return error
d462 1
a462 1
        BICS    PC, lr, #V_bit          ; Return no error
d592 4
a595 2
        Pull    lr                      ; Claim vector, do nowt
        BICS    pc, lr, #V_bit
d614 1
a614 1
      TEQP  PC, #SVC_mode+I_bit     ; IRQs off while holding context.
d743 2
a744 2
       LDR      R10,=Serv_SysChains
       LDR      R10,[R10]
d799 2
a800 2
       LDR      R10,=Serv_AwkwardChain
       LDR      R11,[R10]
a913 5
       [ {FALSE}
       Push     PC, EQ                         ; return address
       SUBEQ    stack, stack, #4*4             ; pseudo- r9-r12
       BEQ      %BT05                          ; wacky pseudo-BL!
	|
d918 1
a918 2
       MOV	R0,R0
	]
d989 1
a989 1
       Push     "lr"
d991 1
a991 2
       ORR       R14, R14, #SVC_mode
       TEQP      PC, R14             ; restore caller CCs
d993 3
a995 2
       MOV       R10, PC, LSR #28    ; restore CCs
       Pull     "lr"
d997 1
a997 1
       ORR       lr, lr, R10, LSL #28
a1094 10
 [ :LNOT: NewStyle_Screen
        VDWS    R11
        MOV     R12, #ScreenEndAdr
        LDR     R11, [R11, #TotalScreenSize]
        ADD     R12, R12, R11
        SUB     R11, R12, R11, LSL #1
        BL      RangeCheck
 ]

 [ NewStyle_SysHeap
a1097 35
 |
        LDR     R11, =SysHeapStart
        LDR     R12, [R11, #:INDEX: hpdend]
        ADD     R12, R11, R12
        MOV     R11, #SysHeapChunkAddress
        BL      RangeCheck
 ]

 [ :LNOT: NewStyle_RMA
        MOV     R11, #RMAAddress
        LDR     R12, [R11, #:INDEX: hpdend]
        ADD     R12, R11, R12
        BL      RangeCheck
 ]

 [ :LNOT: NewStyle_SpriteArea
        LDR     R12, [R10, #SpriteSize]
        ADD     R12, R12, #SpriteSpaceAddress
        MOV     R11, #SpriteSpaceAddress
        BL      RangeCheck
 ]

 [ :LNOT: NewStyle_RAMDisc
        LDR     R12, [R10, #RAMDiscSize]
        ADD     R12, R12, #RAMDiscAddress
        MOV     R11, #RAMDiscAddress
        BL      RangeCheck
 ]

 [ :LNOT: NewStyle_FontArea
        LDR     R12, [R10, #FontCacheSize]
        ADD     R12, R12, #FontCacheAddress
        MOV     R11, #FontCacheAddress
        BL      RangeCheck
 ]
a1102 1
 [ NewCDA
a1123 1
 ]
@


4.4
log
@Ursula ChocolateSysHeap and 128-entry SWI hash table incorporated.

Version 4.83. Tagged as 'Kernel-4_83'
@
text
@d734 4
@


4.3
log
@* Added support for 24LC64 8K EEPROM (untested).
* Integrated Ursula fast service call dispatch code.
* Added Interruptible32bitModes from Ursula.
* Stopped allowing ROM modules (other than the Kernel/UtilityModule) to write
  to the hardware vectors in 26-bit mode.

Version 4.81. Tagged as 'Kernel-4_81'
@
text
@d351 8
d361 1
d474 7
d482 1
d650 7
d658 1
@


4.2
log
@Kernel merged
@
text
@d46 1
a46 1
        TST     r0, #3 :SHL: 29 
d128 1
a128 1
95      
d288 1
a288 1
                                        ; (should always be claimed), 
d320 1
a320 1
        MOV     R3, #0                  ; List of de-linked nodes is empty        
d339 1
a339 1
      LDR   R10, [R11, R0, LSL #2]! ; R10 "nextblock" := !oldptr, 
d392 2
a393 2
        MOVNE   R9, #0                  ; Else R9=0 for no change 
        
d406 1
a406 1
      LDR   R10, [R11, R0, LSL #2]! ; R10 "nextblock" := !oldptr, 
d452 1
a452 1
                   
d511 1
a511 1
   & 0, OsbyteVars, OsWord    
d709 83
d832 2
@


4.2.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d104 1
d106 3
d111 1
d113 3
d119 1
d126 1
d168 1
d174 4
d182 1
d188 4
d314 1
d336 8
d367 1
d371 1
d386 1
d401 10
d414 1
d418 1
d423 1
d468 29
d647 1
d653 3
d801 5
d811 1
d849 1
d853 3
d950 1
d952 1
d988 8
d997 1
d1001 7
d1009 6
d1016 6
d1023 6
d1030 6
d1041 1
d1063 1
@


4.2.2.2
log
@1) Fixes and tidy ups:
   - mapping of Cur/Sys/Sound area done more elegantly, and soft CAM info
     is now consistent with it
   - cached screen cleaning on VSync performed *after* VSync events
   - comments at top of ARM600 modernised
   - Pages_Unsafe/Safe code fixed to work properly on StrongARM with
     pages that are involved in interrupts (there is no fix for ARM8,
     since that is unlikely to be needed - an ASSERT checks use of ARM8
   - OS_DynamicArea code souped up, to be much more efficient for large
     numbers of dynamic areas (see comments near top of ChangeDyn)
   - cached screen is now suspended on h/w scroll (avoids possible cache
     incoherency)
2) API changes:
   - new OS_Memory reason code (10) allows Wimp to inform kernel of
     Wimp_ClaimFreeMemory, and can control VRAM rescue (see below)
   - new OS_ReadSysInfo reason code (6) allows reading of kernel values
     (reserved for Acorn use, eg. for SoftLoad, ROMPatch)
   - new OS_DynamicArea reason codes (6 and 7) allow for more efficient
     monitoring of dynamic areas by TaskManager (reserved for Acorn use)
3) Changes for Phoebe:
   - kernel runs a VRAM rescue process, which ensures that any VRAM not
     used for the screen is reclaimed if necessary and sinks to the bottom
     of the Free Pool. This is important for Phoebe, where VRAM is slower
     than SDRAM, but does no harm on other platforms.
   - logical copy of physical RAM is removed from memory map. This frees
     up 256M of address space that will later be used for PCI on Phoebe,
     but should do no harm on other platforms (this space is marked
     private in PRMs, so 3rd parties should not use it).
@
text
@a615 19
  [ mjsServiceTrace
       Push     "r0-r3"
       MOV      r0,#0
       LDR      r2,[r0,#mjsServiceTrace_ws]
       CMP      r2,#0
       BNE      mjsst_1
       MOV      r3,#256*4
       BL       ClaimSysHeapNode
       MOV      r0,#0
       STR      r2,[r0,#mjsServiceTrace_ws]
mjsst_1
       CMP      r1,#255
       MOVHI    r1,#255
       LDR      r0,[r2,r1,LSL #2]
       ADD      r0,r0,#1
       STR      r0,[r2,r1,LSL #2]
       Pull     "r0-r3"
  ]

@


4.2.2.3
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a105 1
  [ InternationaliseCommonSilentErrors
a107 4
  |
85      ADR     r2, ErrorBlock_BadNumb
        B       %FT95
  ]
a157 1
  [ InternationaliseCommonSilentErrors
a162 4
  |
        ADR     r2, ErrorBlock_BadNumb
        SETV
  ]
a321 8
  [ ChocolateSysHeap
      ASSERT  ChocolateSVBlocks = ChocolateBlockArrays + 4
      MOV   r3,#ChocolateBlockArrays
      LDR   r3,[r3,#4]
      BL    ClaimChocolateBlock
      MOVVS R3, #VecNodeSize        ; Ask for this number of bytes
      BLVS  ClaimSysHeapNode        ; The result is in R2 : R12 corrupted
  |
a323 1
  ]
a371 1
  [ InternationaliseCommonSilentErrors
a374 1
  ]
a419 7
  [ ChocolateSysHeap
        ASSERT  ChocolateSVBlocks = ChocolateBlockArrays + 4
        MOV     r1,#ChocolateBlockArrays
        LDR     r1,[r1,#4]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
a420 1
  ]
a558 7
  [ ChocolateSysHeap
        ASSERT  ChocolateSVBlocks = ChocolateBlockArrays + 4
        MOV     r1,#ChocolateBlockArrays
        LDR     r1,[r1,#4]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
a559 1
  ]
a812 5

  [ SVCAlwaysClearsV
        TST     r10, #V_bit             ; caller's V is in R10 (from SPSR)
        ORRNE   r14, r14, #V_bit        ; now caller's V is preserved
  ]
a829 8
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        MOV     r0,#0
        LDR     r1,[r0,#mjsSHNT_hop_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_hop_total]
        Pull    "r0-r2"
  ]
a834 8
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        MOV     r0,#0
        LDR     r1,[r0,#mjsSHNT_hcl_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_hcl_total]
        Pull    "r0-r2"
  ]
a895 8
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        MOV     r0,#0
        LDR     r1,[r0,#mjsSHNT_hfr_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_hfr_total]
        Pull    "r0-r2"
  ]
@


4.2.2.4
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a686 82
  [ ChocolateService
05
       CMP      R1,#ServMinUsrNumber
       BHS      %FT84
;call anyone on the appropriate Sys chain
       LDR      R10,=Serv_SysChains
       LDR      R10,[R10]
       CMP      R10,#0
       BEQ      %FT88
       LDR      R11,[R10,R1,LSL #2]             ;pick up the chain anchor
80
;call everyone on the chain, passing R1 value from chain if appropriate
       CMP      R11,#0
       BEQ      %FT88
       LDR      R10,[R11,#ServChain_Size]
       ADD      R11,R11,#ServChain_HdrSIZEOF    ;start of chain
       ADD      R10,R10,R11                     ;end of chain
82
       CMP      R11,R10
       BHS      %FT88
       Push     "R10"
       MOV      R10,R1
       LDR      R9,[R11,#ServEntry_R1]
       TEQ      R9,#0                           ; 0 means pass service number as normal
       MOVNE    R1,R9                           ; else pass R1 value from chain (will be service index)
       LDR      R12,[R11,#ServEntry_WSpace]
       LDR      R9,[R11,#ServEntry_Code]
       MOV      lr, pc                          ; link inc. PSR, mode
       MOV      pc, R9
       CMP      R1, #Service_Serviced
       MOVNE    R1,R10                          ; restore R1 unless claimed
       Pull     "R10"
       BEQ      %FT01
       ADD      R11,R11,#ServEntry_SIZEOF
       B        %BT82
;
;call anyone on the appropriate Usr chain
84
       LDR      R10,=Serv_UsrChains
       LDR      R10,[R10]
       CMP      R10,#0
       BEQ      %FT88
       ServHashFunction R9,R1
       LDR      R11,[R10,R9,LSL #2]             ;pick up the chain-array anchor
       CMP      R11,#0
       BEQ      %FT88
       LDR      R10,[R11,#ServUChArray_Size]
       ADD      R11,R11,#ServUChArray_HdrSIZEOF ;start of list
       ADD      R10,R10,R11                     ;end of list
86
       CMP      R11,R10
       BHS      %FT88
       LDR      R9,[R11,#ServUChEntry_ServiceNo]
       TEQ      R9,R1
       ADDNE    R11,R11,#ServUChEntry_SIZEOF
       BNE      %BT86
       LDR      R11,[R11,#ServUChEntry_ChainAnchor]  ;found chain for this service number
       B        %BT80
;
;call everyone on the chain of Awkward modules, always passing service number in R1
88
       LDR      R10,=Serv_AwkwardChain
       LDR      R11,[R10]
       CMP      R11,#0
       BEQ      %FT01
       LDR      R10,[R11,#ServChain_Size]
       ADD      R11,R11,#ServChain_HdrSIZEOF    ;start of chain
       ADD      R10,R10,R11                     ;end of chain
90
       CMP      R11,R10
       BHS      %FT01
       LDR      R12,[R11,#ServEntry_WSpace]
       LDR      R9,[R11,#ServEntry_Code]
       MOV      lr, pc                          ; link inc. PSR, mode
       MOV      pc, R9
       CMP      R1, #Service_Serviced
       BEQ      %FT01
       ADD      R11,R11,#ServEntry_SIZEOF
       B        %BT90

  | ;IF/ELSE ChocolateService

a727 2
  ] ;ChocolateService

d779 1
a779 1
        ; do it this way to cope with ARM v4/v3 differences on storing PC
d783 1
a783 1
       MOV      R0,R0
@


4.1
log
@Initial revision
@
text
@d694 6
d801 1
d805 7
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a693 6
;do the direct calls to AMBControl for service calls of interest
       CMP      R1, #Service_MemoryMoved
       BLEQ     AMBsrv_memorymoved
       CMP      R1, #Service_PagesSafe
       BLEQ     AMBsrv_pagessafe

a794 1
       [ {FALSE}
a797 7
	|
	; do it this way to cope with ARM v4/v3 differences on storing PC
       SUBEQ    stack,stack,#20
       STREQ    PC,[stack,#16]
       BEQ      %BT05
       MOV	R0,R0
	]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.5;
access;
symbols
	Kernel-5_49:4.4
	HAL_merge:4.4
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.4
	Kernel-5_35-4_79_2_326:4.4
	Kernel-5_35-4_79_2_325:4.4
	Kernel-5_35-4_79_2_324:4.4
	Kernel-5_35-4_79_2_323:4.4
	Kernel-5_35-4_79_2_322:4.4
	Kernel-5_35-4_79_2_321:4.4
	Kernel-5_35-4_79_2_320:4.4
	Kernel-5_35-4_79_2_319:4.4
	Kernel-5_35-4_79_2_318:4.4
	Kernel-5_35-4_79_2_317:4.4
	Kernel-5_35-4_79_2_316:4.4
	Kernel-5_35-4_79_2_315:4.4
	Kernel-5_35-4_79_2_314:4.4
	Kernel-5_35-4_79_2_313:4.4
	Kernel-5_35-4_79_2_312:4.4
	Kernel-5_35-4_79_2_311:4.4
	Kernel-5_35-4_79_2_310:4.4
	Kernel-5_35-4_79_2_309:4.4
	Kernel-5_35-4_79_2_308:4.4
	Kernel-5_35-4_79_2_307:4.4
	Kernel-5_35-4_79_2_306:4.4
	Kernel-5_35-4_79_2_305:4.4
	Kernel-5_35-4_79_2_304:4.4
	Kernel-5_35-4_79_2_303:4.4
	Kernel-5_35-4_79_2_302:4.4
	Kernel-5_35-4_79_2_301:4.4
	Kernel-5_35-4_79_2_300:4.4
	Kernel-5_35-4_79_2_299:4.4
	Kernel-5_35-4_79_2_298:4.4
	Kernel-5_35-4_79_2_297:4.4
	Kernel-5_35-4_79_2_296:4.4
	Kernel-5_35-4_79_2_295:4.4
	Kernel-5_35-4_79_2_294:4.4
	Kernel-5_35-4_79_2_293:4.4
	Kernel-5_35-4_79_2_292:4.4
	Kernel-5_35-4_79_2_291:4.4
	Kernel-5_35-4_79_2_290:4.4
	Kernel-5_35-4_79_2_289:4.4
	Kernel-5_35-4_79_2_288:4.4
	Kernel-5_35-4_79_2_287:4.4
	Kernel-5_35-4_79_2_286:4.4
	Kernel-5_35-4_79_2_285:4.4
	Kernel-5_35-4_79_2_284:4.4
	Kernel-5_35-4_79_2_283:4.4
	Kernel-5_35-4_79_2_282:4.4
	Kernel-5_35-4_79_2_281:4.4
	Kernel-5_35-4_79_2_280:4.4
	Kernel-5_35-4_79_2_279:4.4
	Kernel-5_35-4_79_2_278:4.4
	Kernel-5_35-4_79_2_277:4.4
	Kernel-5_35-4_79_2_276:4.4
	Kernel-5_35-4_79_2_275:4.4
	Kernel-5_35-4_79_2_274:4.4
	Kernel-5_35-4_79_2_273:4.4
	Kernel-5_35-4_79_2_272:4.4
	Kernel-5_35-4_79_2_271:4.4
	Kernel-5_35-4_79_2_270:4.4
	Kernel-5_35-4_79_2_269:4.4
	Kernel-5_35-4_79_2_268:4.4
	Kernel-5_35-4_79_2_267:4.4
	Kernel-5_35-4_79_2_266:4.4
	Kernel-5_35-4_79_2_265:4.4
	Kernel-5_35-4_79_2_264:4.4
	Kernel-5_35-4_79_2_263:4.4
	Kernel-5_35-4_79_2_262:4.4
	Kernel-5_35-4_79_2_261:4.4
	Kernel-5_35-4_79_2_260:4.4
	Kernel-5_35-4_79_2_259:4.4
	Kernel-5_35-4_79_2_258:4.4
	Kernel-5_35-4_79_2_257:4.4
	Kernel-5_35-4_79_2_256:4.4
	Kernel-5_35-4_79_2_255:4.4
	Kernel-5_35-4_79_2_254:4.4
	Kernel-5_35-4_79_2_253:4.4
	Kernel-5_35-4_79_2_252:4.4
	Kernel-5_35-4_79_2_251:4.4
	Kernel-5_35-4_79_2_250:4.4
	Kernel-5_35-4_79_2_249:4.4
	Kernel-5_35-4_79_2_248:4.4
	Kernel-5_35-4_79_2_247:4.4
	Kernel-5_35-4_79_2_246:4.4
	Kernel-5_35-4_79_2_245:4.4
	Kernel-5_35-4_79_2_244:4.4
	Kernel-5_35-4_79_2_243:4.4
	Kernel-5_35-4_79_2_242:4.4
	Kernel-5_35-4_79_2_241:4.4
	Kernel-5_35-4_79_2_240:4.4
	Kernel-5_35-4_79_2_239:4.4
	Kernel-5_35-4_79_2_238:4.4
	Kernel-5_35-4_79_2_237:4.4
	Kernel-5_35-4_79_2_236:4.4
	Kernel-5_35-4_79_2_235:4.4
	Kernel-5_35-4_79_2_234:4.4
	Kernel-5_35-4_79_2_233:4.4
	Kernel-5_35-4_79_2_232:4.4
	Kernel-5_35-4_79_2_231:4.4
	Kernel-5_35-4_79_2_230:4.4
	Kernel-5_35-4_79_2_229:4.4
	Kernel-5_35-4_79_2_228:4.4
	Kernel-5_35-4_79_2_227:4.4
	Kernel-5_35-4_79_2_226:4.4
	Kernel-5_35-4_79_2_225:4.4
	Kernel-5_35-4_79_2_224:4.4
	Kernel-5_35-4_79_2_223:4.4
	Kernel-5_35-4_79_2_222:4.4
	Kernel-5_35-4_79_2_221:4.4
	Kernel-5_35-4_79_2_220:4.4
	Kernel-5_35-4_79_2_219:4.4
	Kernel-5_35-4_79_2_218:4.4
	Kernel-5_35-4_79_2_217:4.4
	Kernel-5_35-4_79_2_216:4.4
	Kernel-5_35-4_79_2_215:4.4
	Kernel-5_35-4_79_2_214:4.4
	Kernel-5_35-4_79_2_213:4.4
	Kernel-5_35-4_79_2_212:4.4
	Kernel-5_35-4_79_2_211:4.4
	Kernel-5_35-4_79_2_210:4.4
	Kernel-5_35-4_79_2_209:4.4
	Kernel-5_35-4_79_2_208:4.4
	Kernel-5_35-4_79_2_207:4.4
	Kernel-5_35-4_79_2_206:4.4
	Kernel-5_35-4_79_2_205:4.4
	Kernel-5_35-4_79_2_204:4.4
	Kernel-5_35-4_79_2_203:4.4
	Kernel-5_35-4_79_2_202:4.4
	Kernel-5_35-4_79_2_201:4.4
	Kernel-5_35-4_79_2_200:4.4
	Kernel-5_35-4_79_2_199:4.4
	Kernel-5_35-4_79_2_198:4.4
	Kernel-5_35-4_79_2_197:4.4
	Kernel-5_35-4_79_2_196:4.4
	Kernel-5_35-4_79_2_195:4.4
	Kernel-5_35-4_79_2_194:4.4
	Kernel-5_35-4_79_2_193:4.4
	Kernel-5_35-4_79_2_192:4.4
	Kernel-5_35-4_79_2_191:4.4
	Kernel-5_35-4_79_2_190:4.4
	Kernel-5_35-4_79_2_189:4.4
	Kernel-5_35-4_79_2_188:4.4
	Kernel-5_35-4_79_2_187:4.4
	Kernel-5_35-4_79_2_186:4.4
	Kernel-5_35-4_79_2_185:4.4
	Kernel-5_35-4_79_2_184:4.4
	Kernel-5_35-4_79_2_183:4.4
	Kernel-5_35-4_79_2_182:4.4
	Kernel-5_35-4_79_2_181:4.4
	Kernel-5_35-4_79_2_180:4.4
	Kernel-5_35-4_79_2_179:4.4
	Kernel-5_35-4_79_2_178:4.4
	Kernel-5_35-4_79_2_177:4.4
	Kernel-5_35-4_79_2_176:4.4
	Kernel-5_35-4_79_2_175:4.4
	Kernel-5_35-4_79_2_174:4.4
	Kernel-5_35-4_79_2_173:4.4
	Kernel-5_35-4_79_2_172:4.4
	Kernel-5_35-4_79_2_171:4.4
	Kernel-5_35-4_79_2_170:4.4
	Kernel-5_35-4_79_2_169:4.4
	Kernel-5_35-4_79_2_168:4.4
	Kernel-5_35-4_79_2_167:4.4
	Kernel-5_35-4_79_2_166:4.4
	Kernel-5_35-4_79_2_165:4.4
	RPi_merge:4.4
	Kernel-5_35-4_79_2_147_2_23:4.4
	Kernel-5_35-4_79_2_147_2_22:4.4
	Kernel-5_35-4_79_2_147_2_21:4.4
	Kernel-5_35-4_79_2_147_2_20:4.4
	Kernel-5_35-4_79_2_147_2_19:4.4
	Kernel-5_35-4_79_2_147_2_18:4.4
	Kernel-5_35-4_79_2_164:4.4
	Kernel-5_35-4_79_2_163:4.4
	Kernel-5_35-4_79_2_147_2_17:4.4
	Kernel-5_35-4_79_2_147_2_16:4.4
	Kernel-5_35-4_79_2_147_2_15:4.4
	Kernel-5_35-4_79_2_162:4.4
	Kernel-5_35-4_79_2_161:4.4
	Kernel-5_35-4_79_2_147_2_14:4.4
	Kernel-5_35-4_79_2_147_2_13:4.4
	Kernel-5_35-4_79_2_160:4.4
	Kernel-5_35-4_79_2_159:4.4
	Kernel-5_35-4_79_2_158:4.4
	Kernel-5_35-4_79_2_157:4.4
	Kernel-5_35-4_79_2_156:4.4
	Kernel-5_35-4_79_2_147_2_12:4.4
	Kernel-5_35-4_79_2_147_2_11:4.4
	Kernel-5_35-4_79_2_155:4.4
	Kernel-5_35-4_79_2_147_2_10:4.4
	Kernel-5_35-4_79_2_154:4.4
	Kernel-5_35-4_79_2_153:4.4
	Kernel-5_35-4_79_2_147_2_9:4.4
	Kernel-5_35-4_79_2_152:4.4
	Kernel-5_35-4_79_2_151:4.4
	Kernel-5_35-4_79_2_147_2_8:4.4
	Kernel-5_35-4_79_2_147_2_7:4.4
	Kernel-5_35-4_79_2_150:4.4
	Kernel-5_35-4_79_2_147_2_6:4.4
	Kernel-5_35-4_79_2_147_2_5:4.4
	Kernel-5_35-4_79_2_149:4.4
	Kernel-5_35-4_79_2_147_2_4:4.4
	Kernel-5_35-4_79_2_147_2_3:4.4
	Kernel-5_35-4_79_2_148:4.4
	Kernel-5_35-4_79_2_147_2_2:4.4
	Kernel-5_35-4_79_2_147_2_1:4.4
	RPi:4.4.0.10
	RPi_bp:4.4
	Kernel-5_35-4_79_2_98_2_52_2_1:4.4
	alees_Kernel_dev:4.4.0.8
	alees_Kernel_dev_bp:4.4
	Kernel-5_35-4_79_2_147:4.4
	Kernel-5_35-4_79_2_146:4.4
	Kernel-5_35-4_79_2_145:4.4
	Kernel-5_35-4_79_2_144:4.4
	Kernel-5_35-4_79_2_143:4.4
	Kernel-5_35-4_79_2_142:4.4
	Kernel-5_35-4_79_2_141:4.4
	Kernel-5_35-4_79_2_140:4.4
	Kernel-5_35-4_79_2_139:4.4
	Kernel-5_35-4_79_2_138:4.4
	Kernel-5_35-4_79_2_137:4.4
	Kernel-5_35-4_79_2_136:4.4
	Kernel-5_35-4_79_2_135:4.4
	Kernel-5_35-4_79_2_134:4.4
	Kernel-5_35-4_79_2_133:4.4
	Kernel-5_35-4_79_2_132:4.4
	Kernel-5_35-4_79_2_131:4.4
	Kernel-5_35-4_79_2_130:4.4
	Kernel-5_35-4_79_2_129:4.4
	Kernel-5_35-4_79_2_128:4.4
	Kernel-5_35-4_79_2_127:4.4
	Kernel-5_35-4_79_2_126:4.4
	Kernel-5_35-4_79_2_125:4.4
	Kernel-5_35-4_79_2_124:4.4
	Kernel-5_35-4_79_2_123:4.4
	Cortex_merge:4.4
	Kernel-5_35-4_79_2_122:4.4
	Kernel-5_35-4_79_2_98_2_54:4.4
	Kernel-5_35-4_79_2_98_2_53:4.4
	Kernel-5_35-4_79_2_98_2_52:4.4
	Kernel-5_35-4_79_2_98_2_51:4.4
	Kernel-5_35-4_79_2_98_2_50:4.4
	Kernel-5_35-4_79_2_98_2_49:4.4
	Kernel-5_35-4_79_2_98_2_48:4.4
	Kernel-5_35-4_79_2_121:4.4
	Kernel-5_35-4_79_2_98_2_47:4.4
	Kernel-5_35-4_79_2_120:4.4
	Kernel-5_35-4_79_2_98_2_46:4.4
	Kernel-5_35-4_79_2_119:4.4
	Kernel-5_35-4_79_2_98_2_45:4.4
	Kernel-5_35-4_79_2_98_2_44:4.4
	Kernel-5_35-4_79_2_118:4.4
	Kernel-5_35-4_79_2_98_2_43:4.4
	Kernel-5_35-4_79_2_117:4.4
	Kernel-5_35-4_79_2_116:4.4
	Kernel-5_35-4_79_2_98_2_42:4.4
	Kernel-5_35-4_79_2_115:4.4
	Kernel-5_35-4_79_2_98_2_41:4.4
	Kernel-5_35-4_79_2_98_2_40:4.4
	Kernel-5_35-4_79_2_114:4.4
	Kernel-5_35-4_79_2_98_2_39:4.4
	Kernel-5_35-4_79_2_98_2_38:4.4
	Kernel-5_35-4_79_2_113:4.4
	Kernel-5_35-4_79_2_112:4.4
	Kernel-5_35-4_79_2_98_2_37:4.4
	Kernel-5_35-4_79_2_98_2_36:4.4
	Kernel-5_35-4_79_2_98_2_35:4.4
	Kernel-5_35-4_79_2_98_2_34:4.4
	Kernel-5_35-4_79_2_98_2_33:4.4
	Kernel-5_35-4_79_2_98_2_32:4.4
	Kernel-5_35-4_79_2_98_2_31:4.4
	Kernel-5_35-4_79_2_98_2_30:4.4
	Kernel-5_35-4_79_2_98_2_29:4.4
	Kernel-5_35-4_79_2_98_2_28:4.4
	Kernel-5_35-4_79_2_98_2_27:4.4
	Kernel-5_35-4_79_2_98_2_26:4.4
	Kernel-5_35-4_79_2_111:4.4
	Kernel-5_35-4_79_2_98_2_25:4.4
	Kernel-5_35-4_79_2_98_2_24:4.4
	Kernel-5_35-4_79_2_98_2_23:4.4
	Kernel-5_35-4_79_2_110:4.4
	Kernel-5_35-4_79_2_98_2_22:4.4
	Kernel-5_35-4_79_2_109:4.4
	Kernel-5_35-4_79_2_98_2_21:4.4
	Kernel-5_35-4_79_2_98_2_20:4.4
	Kernel-5_35-4_79_2_108:4.4
	Kernel-5_35-4_79_2_107:4.4
	Kernel-5_35-4_79_2_98_2_19:4.4
	Kernel-5_35-4_79_2_98_2_18:4.4
	Kernel-5_35-4_79_2_98_2_17:4.4
	Kernel-5_35-4_79_2_98_2_16:4.4
	Kernel-5_35-4_79_2_98_2_15:4.4
	Kernel-5_35-4_79_2_106:4.4
	Kernel-5_35-4_79_2_105:4.4
	Kernel-5_35-4_79_2_104:4.4
	Kernel-5_35-4_79_2_98_2_14:4.4
	Kernel-5_35-4_79_2_98_2_13:4.4
	Kernel-5_35-4_79_2_98_2_12:4.4
	Kernel-5_35-4_79_2_98_2_11:4.4
	Kernel-5_35-4_79_2_98_2_10:4.4
	Kernel-5_35-4_79_2_98_2_9:4.4
	Kernel-5_35-4_79_2_103:4.4
	Kernel-5_35-4_79_2_102:4.4
	Kernel-5_35-4_79_2_98_2_8:4.4
	Kernel-5_35-4_79_2_98_2_7:4.4
	Kernel-5_35-4_79_2_98_2_6:4.4
	Kernel-5_35-4_79_2_98_2_5:4.4
	Kernel-5_35-4_79_2_98_2_4:4.4
	Kernel-5_35-4_79_2_101:4.4
	Kernel-5_35-4_79_2_100:4.4
	Kernel-5_35-4_79_2_99:4.4
	Kernel-5_35-4_79_2_98_2_3:4.4
	Kernel-5_35-4_79_2_98_2_2:4.4
	Kernel-5_35-4_79_2_98_2_1:4.4
	Cortex:4.4.0.4
	Cortex_bp:4.4
	Kernel-5_35-4_79_2_98:4.4
	Kernel-5_35-4_79_2_97:4.4
	Kernel-5_35-4_79_2_96:4.4
	Kernel-5_35-4_79_2_95:4.4
	Kernel-5_35-4_79_2_94:4.4
	Kernel-5_35-4_79_2_93:4.4
	Kernel-5_35-4_79_2_92:4.4
	Kernel-5_35-4_79_2_91:4.4
	Kernel-5_35-4_79_2_90:4.4
	Kernel-5_35-4_79_2_89:4.4
	Kernel-5_35-4_79_2_88:4.4
	Kernel-5_35-4_79_2_87:4.4
	Kernel-5_35-4_79_2_86:4.4
	Kernel-5_35-4_79_2_85:4.4
	Kernel-5_35-4_79_2_84:4.4
	Kernel-5_35-4_79_2_83:4.4
	Kernel-5_35-4_79_2_82:4.4
	Kernel-5_35-4_79_2_81:4.4
	Kernel-5_35-4_79_2_80:4.4
	Kernel-5_35-4_79_2_79:4.4
	Kernel-5_35-4_79_2_78:4.4
	Kernel-5_35-4_79_2_77:4.4
	RO_5_07:4.4
	Kernel-5_35-4_79_2_76:4.4
	Kernel-5_35-4_79_2_75:4.4
	Kernel-5_35-4_79_2_74:4.4
	Kernel-5_35-4_79_2_73:4.4
	Kernel-5_35-4_79_2_72:4.4
	Kernel-5_35-4_79_2_71:4.4
	Kernel-5_35-4_79_2_70:4.4
	Kernel-5_35-4_79_2_69:4.4
	Kernel-5_35-4_79_2_68:4.4
	Kernel-5_35-4_79_2_67:4.4
	Kernel-5_35-4_79_2_66:4.4
	Kernel-5_35-4_79_2_65:4.4
	Kernel-5_35-4_79_2_64:4.4
	Kernel-5_35-4_79_2_63:4.4
	Kernel-5_35-4_79_2_62:4.4
	Kernel-5_35-4_79_2_61:4.4
	Kernel-5_35-4_79_2_59:4.4
	Kernel-5_35-4_79_2_58:4.4
	Kernel-5_35-4_79_2_57:4.4
	Kernel-5_35-4_79_2_56:4.4
	Kernel-5_35-4_79_2_55:4.4
	Kernel-5_35-4_79_2_54:4.4
	Kernel-5_35-4_79_2_53:4.4
	Kernel-5_35-4_79_2_52:4.4
	Kernel-5_35-4_79_2_51:4.4
	Kernel-5_35-4_79_2_50:4.4
	Kernel-5_35-4_79_2_49:4.4
	Kernel-5_35-4_79_2_48:4.4
	Kernel-5_47:4.4
	Kernel-5_46-4_90_2_1:4.4
	nbingham_Kernel_FastNC_dev_bp:4.4
	nbingham_Kernel_FastNC_dev:4.4.0.6
	Kernel-5_46:4.4
	Kernel-5_45:4.4
	Kernel-5_35-4_79_2_47:4.4
	Kernel-5_35-4_79_2_46:4.4
	Kernel-5_35-4_79_2_45:4.4
	Kernel-5_35-4_79_2_44:4.4
	Kernel-5_35-4_79_2_25_2_2:4.4
	Kernel-5_35-4_79_2_43:4.4
	Kernel-5_35-4_79_2_42:4.4
	Kernel-5_35-4_79_2_41:4.4
	Kernel-5_35-4_79_2_40:4.4
	Kernel-5_35-4_79_2_39:4.4
	Kernel-5_35-4_79_2_38:4.4
	Kernel-5_35-4_79_2_37:4.4
	Kernel-5_35-4_79_2_36:4.4
	Kernel-5_35-4_79_2_35:4.4
	Kernel-5_35-4_79_2_34:4.4
	Kernel-5_35-4_79_2_33:4.4
	Kernel-5_35-4_79_2_32:4.4
	Kernel-5_44:4.4
	Kernel-5_35-4_79_2_25_2_1:4.4
	Kernel-5_43:4.4
	Kernel-5_35-4_79_2_31:4.4
	Kernel-5_35-4_79_2_30:4.4
	Kernel-5_35-4_79_2_29:4.4
	Kernel-5_35-4_79_2_28:4.4
	Kernel-5_35-4_79_2_27:4.4
	Kernel-5_35-4_79_2_26:4.4
	Kernel-5_42:4.4
	Kernel-5_41:4.4
	Kernel-5_40:4.4
	Kernel-5_35-4_79_2_25:4.4
	Kernel-5_35-4_79_2_24:4.4
	Kernel-5_35-4_79_2_23:4.4
	Kernel-5_35-4_79_2_22:4.4
	Kernel-5_35-4_79_2_21:4.4
	Kernel-5_35-4_79_2_20:4.4
	Kernel-5_35-4_79_2_19:4.4
	Kernel-5_35-4_79_2_18:4.4
	Kernel-5_35-4_79_2_17:4.4
	Kernel-5_35-4_79_2_16:4.4
	Kernel-5_35-4_79_2_15:4.4
	Kernel-5_35-4_79_2_14:4.4
	Kernel-5_39:4.4
	Kernel-5_13-4_52_2_1:4.3
	Bethany:4.3.0.2
	Kernel-5_38:4.4
	Kernel-5_35-4_79_2_13:4.4
	Kernel-5_35-4_79_2_12:4.4
	Kernel-5_35-4_79_2_11:4.4
	Kernel-5_37:4.4
	Kernel-5_35-4_79_2_10:4.4
	Kernel-5_35-4_79_2_9:4.4
	Kernel-5_36:4.4
	Kernel-5_35-4_79_2_8:4.4
	Kernel-5_35-4_79_2_7:4.4
	Kernel-5_35-4_79_2_6:4.4
	Kernel-5_35-4_79_2_5:4.4
	Kernel-5_35-4_79_2_4:4.4
	Kernel-5_35-4_79_2_3:4.4
	Kernel-5_35-4_79_2_2:4.4
	dellis_autobuild_BaseSW:4.4
	Kernel-5_35-4_79_2_1:4.4
	HAL:4.4.0.2
	Kernel-5_35:4.4
	Kernel-5_34:4.4
	Kernel-5_33:4.4
	Kernel-5_32:4.4
	Kernel-5_31:4.4
	Kernel-5_30:4.4
	Kernel-5_29:4.4
	Kernel-5_28:4.4
	Kernel-5_27:4.4
	Kernel-5_26:4.4
	Kernel-5_25:4.4
	Kernel-5_24:4.4
	Kernel-5_23:4.4
	Kernel-5_22:4.3
	sbrodie_sedwards_16Mar2000:4.3
	Kernel-5_21:4.3
	Kernel-5_20:4.3
	Kernel-5_19:4.3
	Kernel-5_18:4.3
	Kernel-5_17:4.3
	Kernel-5_16:4.3
	Kernel-5_15:4.3
	Kernel-5_14:4.3
	Kernel-5_13:4.3
	Kernel-5_12:4.3
	Kernel-5_11:4.3
	Kernel-5_10:4.3
	Kernel-5_09:4.3
	Kernel-5_08:4.3
	Kernel-5_07:4.3
	Kernel-5_06:4.3
	Kernel-5_05:4.3
	Kernel-5_04:4.3
	Kernel-5_03:4.3
	Kernel-5_02:4.3
	Kernel-5_01:4.3
	Kernel-5_00:4.3
	Kernel-4_99:4.3
	Kernel-4_98:4.3
	Kernel-4_97:4.3
	Kernel-4_96:4.3
	Kernel-4_95:4.3
	Kernel-4_94:4.3
	Kernel-4_93:4.3
	Kernel-4_92:4.3
	Kernel-4_91:4.3
	Kernel-4_90:4.3
	dcotton_autobuild_BaseSW:4.4
	Kernel-4_89:4.3
	Kernel-4_88:4.3
	Kernel-4_87:4.3
	Kernel-4_86:4.3
	Kernel-4_85:4.3
	Kernel-4_84:4.3
	Kernel-4_83:4.3
	Kernel-4_82:4.3
	Kernel-4_81:4.3
	Kernel-4_80:4.3
	Kernel-4_79:4.3
	Kernel-4_78:4.3
	Kernel-4_77:4.3
	Kernel-4_76:4.3
	Kernel-4_75:4.3
	Kernel-4_74:4.2
	Kernel-4_73:4.1
	Kernel-4_72:4.1;
locks; strict;
comment	@# @;


4.5
date	2016.06.30.20.42.05;	author jlee;	state dead;
branches;
next	4.4;
commitid	bDF3DCxdmyMD0xcz;

4.4
date	2000.04.04.14.27.29;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.04.14.15.14.42;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.04.14.14.23.32;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	99.04.08.13.23.44;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Delete STB code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a desktop build):
  * STB
  * RO371Timings
  * NormalSpeedROMS
  * AutoSpeedROMS
  * RISCPCBurstMode
  * InterlacedPointer
  * ParallelFlashUpgrade (and s/FlashROM file)
  * Embedded_UI
  Some of the deleted code might be worth revisiting in future:
  * OS_ReadSysInfo 4 support for storing the MAC in alternate CMOS locations (including 2nd copy for error checking) or fetching via Service_MachineAddress
  * Mouse handling changes, possibly aimed at hiding the mouse pointer if a mouse isn't connected
  * More strict CMOS validation in s/NewReset
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.50. Tagged as 'Kernel-5_50'
@
text
@; Copyright 1999 Element 14 Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; This file handles the programming of flash devices in ROM bank 0 with
; a ROM image transferred via the parallel port. This is for development
; purposes only, and is only likely to work on the system for which it was
; designed.

; Flash Memory Settings

FR_FlashBase            * &00000000

FR_DeviceBufferSize     * 32            ; 28F640J5 has 32 byte buffer
FR_DeviceBlockSizeBits  * 17            ; 28F640J5 has 128KB blocks
FR_DeviceBlocks         * 64            ; 64 blocks in a 28F640J5

FR_BufferSize           * FR_DeviceBufferSize*2         ; 2 devices
FR_BlockSizeBits        * FR_DeviceBlockSizeBits+1      ; 2 devices
FR_BlockSize            * 1 :SHL: FR_BlockSizeBits      ; 256KB
FR_FlashSize            * FR_BlockSize*FR_DeviceBlocks  ; 16MB

; Sizes of things in memory

FR_StackSize            * 1024
FR_RAMCodeSize          * 4096
FR_ScreenSize           * 472*1024

; Addresses of where we put things in memory

FR_PageTableBaseAddr    * DRAM0PhysRam
FR_StackBase            * FR_PageTableBaseAddr+16*1024+FR_StackSize
FR_RAMCodeAddr          * FR_StackBase
FR_ScreenBase           * (FR_RAMCodeAddr+FR_RAMCodeSize+15):AND::NOT:&F
FR_TransferBuffAddr     * FR_ScreenBase

; Combo chip addresses
FR_ComboCfgBase         * &03010000 + &3F0*4
FR_PPortBase            * &03010000 + &278*4
FR_ECRPortBase          * FR_PPortBase + &402*4


; On entry, R11->IOMD
; Will either reprogram the flash, or branch back to 0.
; We're in SVC32 mode with the MMU off, by the way.

        ASSERT  IOMD_C_FrontPanelButton <> 0
ConsiderFlashROM
        LDRB    R0,[R11,#IOMD_CLINES]
        TST     R0,#IOMD_C_FrontPanelButton
        MOVNE   PC,#0

FlashROM
; Switch CPU to 32-bit mode
        MOV     R0,#MMUC_L :OR: MMUC_D :OR: MMUC_P      ; Set PROG32 and DATA32
        ARM_write_control R0
        msr    ,CPSR_c,#I32_bit :OR: F32_bit :OR: SVC32_mode

; Initialise various CPU control registers
        MOV     R0,#IOMD_ROMCR_NSTicks_5 :OR: IOMD_ROMCR_HalfSpeed :OR: IOMD_ROMCR_32bit
        STRB    R0,[R11,#IOMD_ROMCR0]
        MOV     R0,#IOMD_CLKCTL_CpuclkHalf :OR: IOMD_CLKCTL_MemclkNormal :OR: IOMD_CLKCTL_IOclkNormal
        STRB    R0,[R11,#IOMD_CLKCTL]
        MOV     R0,#IOMD_DRAMWID_RASPre_3 :OR: IOMD_DRAMWID_RASCAS_3 :OR: IOMD_DRAMWID_EDO_Enable :OR: IOMD_DRAMWID_DRAM_32bit
        STRB    R0,[R11,#IOMD_DRAMWID]
        MOV     R0,#IOMD_IOTCR_Combo_TypeB :OR: IOMD_IOTCR_Network_TypeC
        STRB    R0,[R11,#IOMD_IOTCR]
        MOV     R0,#1                   ; Card 0 type C, the rest type A
        STRB    R0,[R11,#IOMD_ECTCR]
        MOV     R0,#IOMD_ASTCR_WaitStates
        STRB    R0,[R11,#IOMD_ASTCR]
        MOV     R0,#IOMD_C_ReadMask :OR: IOMD_C_ROMCardVpp              ; Green LED on
        STRB    R0,[R11,#IOMD_CLINES]

; Main setup
        MOV     R10,#VIDC               ; Keep R10 pointing to video registers from here on
        BL      FR_InitVideo
        BL      FR_FillScreen
        BL      FR_SetPageTable
        BL      FR_SetMMU
        BL      FR_InitParallel         ; Sets R9 to parallel base address - keep it this way

; Copy the rest of code to RAM and jump to it
        ADR     R0,FR_CopyBlockStart
        LDR     R1,=FR_RAMCodeAddr
        MOV     LR,R1
        LDR     R2,=FR_RAMCodeEnd - FR_CopyBlockStart
01      LDR     R3,[R0],#4
        STR     R3,[R1],#4
        SUBS    R2,R2,#4
        BNE     %BT01
        MOV     PC,LR

FR_InitVideo    ROUT
; Set DMA registers
        LDR     R1,=FR_ScreenBase
        ADD     R2,R1,#FR_ScreenSize
        SUB     R2,R2,#16
        STR     R1,[R11,#IOMD_VIDSTART]
        STR     R2,[R11,#IOMD_VIDEND]
        STR     R1,[R11,#IOMD_VIDINIT]
        STR     R1,[R11,#IOMD_VIDCUR]
        STR     R1,[R11,#IOMD_CURSINIT]
        STR     R1,[R11,#IOMD_CURSCUR]
        MOV     R1,#0
        STR     R1,[R11,#IOMD_VIDINITB]
        MOV     R1,#IOMD_VIDCR_DRAMMode :OR: IOMD_VIDCR_Enable
        STRB    R1,[R11,#IOMD_VIDCR]
; Set video registers
        ADR     R1,FR_InitVidRegs
        MOV     R2,#(FR_InitVidRegsEnd-FR_InitVidRegs)
02      LDR     R3,[R1],#4
        STR     R3,[R10]
        SUBS    R2,R2,#4
        BNE     %BT02
; Set grey palette
        MOV     R1,#&10000000
        STR     R1,[R10]
        MOV     R1,#0
        MOV     R2,#&000001
        ORR     R2,R2,#&000100
        ORR     R2,R2,#&010000
        MOV     R3,#256
03      STR     R1,[R10]
        ADD     R1,R1,R2
        SUBS    R3,R3,#1
        BNE     %BT03
        MOV     PC,LR

; Frequency synthesizer register settings
FR_ModR        * 8
FR_ModV        * 9 ; 36 MHz
; Video control register settings
FR_FIFO        * 3 ; 12 loads
FR_BPP         * 3 ; 8bpp
FR_PixelRate   * 0 ; CK/1
FR_ClockSource * 0 ; VCLK
; Horizontal timings
FR_HSync       * 72
FR_HBPch       * 86
FR_HLBdr       * 24
FR_HDisp       * 800
FR_HRBdr       * 24
FR_HFPch       * 18
FR_HDWR        * FR_HDisp / 4
; Vertical timings
FR_VSync       * 2
FR_VBPch       * 22
FR_VTBdr       * 0
FR_VDisp       * 600
FR_VBBdr       * 0
FR_VFPch       * 1

FR_InitVidRegs  ROUT
        DCD     &E0000000+(FR_FIFO:SHL:8)+(FR_BPP:SHL:5)+(FR_PixelRate:SHL:2)+FR_ClockSource
        DCD     &D0000000+&C288
        DCD     &80000000+FR_HSync+FR_HBPch+FR_HLBdr+FR_HDisp+FR_HRBdr+FR_HFPch-8
        DCD     &81000000+FR_HSync-8
        DCD     &82000000+FR_HSync+FR_HBPch-12
        DCD     &83000000+FR_HSync+FR_HBPch+FR_HLBdr-18
        DCD     &84000000+FR_HSync+FR_HBPch+FR_HLBdr+FR_HDisp-18
        DCD     &85000000+FR_HSync+FR_HBPch+FR_HLBdr+FR_HDisp+FR_HRBdr-12
        DCD     &90000000+FR_VSync+FR_VBPch+FR_VTBdr+FR_VDisp+FR_VBBdr+FR_VFPch-2
        DCD     &91000000+FR_VSync-2
        DCD     &92000000+FR_VSync+FR_VBPch-1
        DCD     &93000000+FR_VSync+FR_VBPch+FR_VTBdr-1
        DCD     &94000000+FR_VSync+FR_VBPch+FR_VTBdr+FR_VDisp-1
        DCD     &95000000+FR_VSync+FR_VBPch+FR_VTBdr+FR_VDisp+FR_VBBdr-1
        DCD     &40008000
        DCD     &C0000000+(1:SHL:12)+3
        DCD     &D0000000+&C080+((FR_ModV-1):SHL:8)+(FR_ModR-1)
        DCD     &D0000000+((FR_ModV-1):SHL:8)+(FR_ModR-1)
        DCD     &F0000000+(1:SHL:16)+(1:SHL:12)+FR_HDWR
        DCD     &B1000000
FR_InitVidRegsEnd

FR_FillScreen   ROUT
        LDR     R1,=FR_ScreenBase
        MOV     R2,#((256:SHL:16)/600):AND:&00FF
        ORR     R2,R2,#((256:SHL:16)/600):AND:&FF00
        MOV     R3,R2
        MOV     R4,#FR_VDisp
01      MOV     R5,#FR_HDisp
        MOV     R0,R3,LSR #16
        ORR     R0,R0,R0,LSL #8
        ORR     R0,R0,R0,LSL #16
02      STR     R0,[R1],#4
        SUBS    R5,R5,#4
        BNE     %BT02
        ADD     R3,R3,R2
        SUBS    R4,R4,#1
        BNE     %BT01
        MOV     PC,LR

;Make a page table that basically gives flat addressing with the C and B bits
;set approriately for the RAM areas. The RAM areas are set with both the C and B
;bits on, and all other areas have both C and B off. The flash area must not
;be made cacheable, or programming won't work.
;On exit
; r0-r4 corrupted
FR_SetPageTable ROUT
        MOV     R1,#FR_PageTableBaseAddr
        MOV     R2,#0                           ; Address
        MOV     R4,#L1_U + L1_Section
        ORR     R4,R4,#AP_Full * L1_APMult
01      BICS    R3,R2,#&E0000000                ; Repeats at &00000000, &20000000, &4000000, etc.
        BICEQ   R4,R4,#L1_C + L1_B              ; Clear B and C bits from start of ROM area
        CMP     R3,#&10000000
        ORREQ   R4,R4,#L1_C + L1_B              ; Set B and C bits (RAM area cacheable and bufferable)
        ORR     R0,R3,R4
        STR     R0,[R1],#4
        ADDS    R2,R2,#1024*1024
        BCC     %BT01
        MOV     PC,LR

FR_SetMMU       ROUT
        MOV     R0,#FR_PageTableBaseAddr
        ARM_MMU_transbase R0
        MVN     R0,#0                           ; Full access to all domains
        ARM_MMU_domain R0
        MOV     R0,#MMUC_L + MMUC_D + MMUC_P + MMUC_W + MMUC_C + MMUC_M
        ARM_write_control R0                    ; Enable write buffer, cache and MMU
        MOV     PC,LR

FR_InitParallel ROUT
        LDR     R1,=FR_ComboCfgBase
; Enter config mode
        MOV     R0,#&55
        STRB    R0,[R1]
        STRB    R0,[R1]
; Write CR0
        MOV     R0,#0
        STRB    R0,[R1]
        MOV     R0,#&22
        STRB    R0,[R1,#4]      ; CR0=&22 (FDC, IDE off)
; Write CR1
        MOV     R0,#1
        STRB    R0,[R1]
        MOV     R0,#&97
        STRB    R0,[R1,#4]      ; CR1=&97 (Parallel port on, extended)
; Write CR4
        MOV     R0,#4
        STRB    R0,[R1]
        MOV     R0,#&03         ; CR4=&03 (ECP & EPP mode)
        STRB    R0,[R1,#4]
; Write ECR
        MOV     R0,#&34         ; PS/2 Parallel Port mode, DMA off, interrupts off
        LDR     R9,=FR_ECRPortBase
        STRB    R0,[R9]
; Exit config mode
        MOV     R0,#&AA
        STRB    R0,[R1]
; Initialise parallel port
        LDR     R9,=FR_PPortBase
; Clear nSTROBE bit (puts nACK high) and clear nSLCTIN bit (puts BUSY high) to
; indicate we are busy and not accepting data.
        MOV     R0,#&20         ; Input, IRQ off, nSLCTIN clear, nSTROBE clear
        STRB    R0,[R9,#8]
; Keep parallel port base address in R9 from here on
        MOV     PC,LR

        LTORG

FR_CopyBlockStart

; Dont use literals from here on in - the assembler's liable to pull them
; the non-RAM stuff above.

; Code from here on gets copied to RAM (at FR_RAMCodeAddr) and run from there.

FR_RAMCodeStart
        MOV     R0,#IOMD_C_ReadMask :OR: IOMD_C_FrontPanelLED :OR: IOMD_C_ROMCardVpp
        STRB    R0,[R11,#IOMD_CLINES]                   ; Red LED on
        LDR     R13,FR_StackBaseVal
FR_LoopForever
        MOV     R0,#FR_WaitCmdState-FR_BorderStateTable
        BL      FR_ShowStateBorder
; Wait for a command header
        BL      FR_ParallelRead
        CMP     R0,#'M'
        BNE     FR_LoopForever
        BL      FR_ParallelRead
        CMP     R0,#'P'
        BNE     FR_LoopForever
        BL      FR_ParallelRead
        CMP     R0,#'T'
        BNE     FR_LoopForever
        BL      FR_ParallelRead
        CMP     R0,#'!'
        BNE     FR_LoopForever
        BL      FR_ParallelRead
        CMP     R0,#'P'
        BEQ     FR_BeginProgram
        CMP     R0,#'V'
        BEQ     FR_BeginVerify
        B       FR_LoopForever

FR_BeginProgram ROUT
        MOV     R0,#FR_BeginProgramState-FR_BorderStateTable
        BL      FR_ShowStateBorder
; Read in parameters
        BL      FR_ReadOffsetAndCount
; Ready to go - first make the ROM area writable
        BL      FR_MakeROM0Writable
01
; Begin erasing the block
        MOV     R0,R7
        BL      FR_StartErase
; Read the block data into the buffer
        BL      FR_ReadBlockIntoBuffer
; Data read in OK - wait for erase to finish
        BL      FR_CheckErase
; Now write block
        MOV     R0,#FR_WriteBlockState-FR_BorderStateTable
        BL      FR_ShowStateBorder
        MOV     R0,R7
        LDR     R1,FR_TransferBuffVal
        BL      FR_DoWriteBlock
; Verify the block
        BL      FR_ResetToReadArray
        MOV     R0,#FR_VerifyBlockState-FR_BorderStateTable
        BL      FR_ShowStateBorder
        MOV     R0,R7
        LDR     R1,FR_TransferBuffVal
        BL      FR_VerifyBlock
; Block done, on to the next
        ADD     R7,R7,#FR_BlockSize
        SUBS    R8,R8,#1
        BNE     %BT01
; All finished - make ROM area read-only
        BL      FR_MakeROM0ReadOnly
        B       FR_LoopForever

FR_BeginVerify  ROUT
        MOV     R0,#FR_BeginVerifyState-FR_BorderStateTable
        BL      FR_ShowStateBorder
; Read in parameters
        BL      FR_ReadOffsetAndCount
01
; Read the block data into the buffer
        BL      FR_ReadBlockIntoBuffer
; Data read in OK - now verify
        MOV     R0,#FR_VerifyBlockState-FR_BorderStateTable
        BL      FR_ShowStateBorder
        MOV     R0,R7
        LDR     R1,FR_TransferBuffVal
        BL      FR_VerifyBlock
; Block done, on to the next
        ADD     R7,R7,#FR_BlockSize
        SUBS    R8,R8,#1
        BNE     %BT01
; All done
        B       FR_LoopForever

FR_ReadOffsetAndCount ROUT
;Called by the program and verify commands to read their parameters (offset
;and count) from the parallel port.
;On exit
; r7 = Initial offset in Flash ROM area
; r8 = Block count
; r0-r3 corrupted
        STMFD   R13!,{LR}
; Next incoming word is the block offset to start from
        BL      FR_ParallelReadWord
        MOV     R7,R0
; Check the offset is valid
        CMP     R7,#FR_FlashSize
        BHS     FR_OffsetError
        MOVS    R0,R7,LSL#(32-FR_BlockSizeBits)         ; The offset within the block should be 0
        BNE     FR_OffsetError
; Next incoming byte is the number of blocks
        BL      FR_ParallelRead
        MOVS    R8,R0
        BEQ     FR_BlockCountError
        ADD     R0,R7,R8,LSL #FR_BlockSizeBits
        CMP     R0,#FR_FlashSize
        BHI     FR_BlockCountError
; Turn the offset into a real address
        ADD     R7,R7,#FR_FlashBase
        LDMFD   R13!,{PC}

FR_ReadBlockIntoBuffer ROUT
;Read a block of data from the parallel port into the transfer buffer
;Corrupts r0-r6
        STMFD   R13!,{LR}
        MOV     R0,#FR_ReadBlockState-FR_BorderStateTable
        BL      FR_ShowStateBorder
        MOV     R6,#FR_BlockSize
        LDR     R5,FR_TransferBuffVal
        MOV     R4,#0                                   ; Checksum
01      BL      FR_ParallelReadWord
        STR     R0,[R5],#4
        ADD     R4,R4,R0
        SUBS    R6,R6,#4
        BNE     %BT01
; Next word is the checksum
        BL      FR_ParallelReadWord
        CMP     R0,R4
        BNE     FR_ChecksumError
        LDMFD   R13!,{PC}

FR_ChecksumError ROUT
        MOV     R0,#FR_ChecksumErrorState-FR_BorderStateTable
        B       FR_Error
FR_OffsetError
        MOV     R0,#FR_OffsetErrorState-FR_BorderStateTable
        B       FR_Error
FR_BlockCountError
        MOV     R0,#FR_BlockCountErrorState-FR_BorderStateTable
FR_Error
        BL      FR_ShowStateBorder
; Wait for front panel button to be pressed
01      LDRB    R0,[R11,#IOMD_CLINES]
        TST     R0,#IOMD_C_FrontPanelButton
        BNE     %BT01
; Start again (note this also resets the stack pointer)
        B       FR_RAMCodeStart

FR_ShowStateBorder
        STMFD   R13!,{R1}
        ADR     R1,FR_BorderStateTable
        LDR     R0,[R1,R0]
        STR     R0,[R10]
        LDMFD   R13!,{R1}
        MOV     PC,LR

FR_BorderStateTable
FR_WaitCmdState            DCD &40FF0000   ;Waiting for command - Blue
FR_BeginProgramState       DCD &40808080   ;Begin Program command - Grey
FR_BeginVerifyState        DCD &40404040   ;Begin Verify command - Dark grey
FR_ReadBlockState          DCD &40FFFF00   ;Reading block - Cyan
FR_WriteBlockState         DCD &4000FF00   ;Writing block - Green
FR_VerifyBlockState        DCD &40FFFFFF   ;Verifying block - White
FR_OffsetErrorState        DCD &400000FF   ;Offset error - Red
FR_BlockCountErrorState    DCD &4000FFFF   ;Block count error - Yellow
FR_ChecksumErrorState      DCD &40FF00FF   ;Checksum error - Magenta
FR_EraseErrorState         DCD &40808000   ;Erase error - Dark Cyan
FR_VoltageRangeErrorState  DCD &40000080   ;Voltage range error - Dark Red
FR_DeviceProtectErrorState DCD &40800000   ;Device protect error - Dark Blue
FR_ProgramErrorState       DCD &40008080   ;Program error - Dark Yellow
FR_VerifyErrorState        DCD &4000BBFF   ;Verify error - Orange

FR_ParallelRead ROUT
;Read a byte of data from the parallel port
;On entry
; r9 = Parallel port base address
;On exit
; r0 = byte read
; r1 corrupted
;Set nSLCTIN bit (puts BUSY low) and clear nSTROBE bit (puts nACK high),
;to indicate that we are ready to receive data
        MOV     R0,#&28                 ; Input, IRQ off, BUSY low, nACK high
        STRB    R0,[R9,#8]
;Now wait until nACK bit (nSTROBE) goes low, meaning a byte is ready to be read
01      LDRB    R0,[R9,#4]
        TST     R0,#&40
        BNE     %BT01
;Read the byte
        LDRB    R0,[R9]
;Set nSTROBE bit (puts nACK low) to indicate we read the byte, and
;clear nSLCTIN bit (puts BUSY high) to indicate we are busy and won't accept
;any more data
        MOV     R1,#&21                 ; Input, IRQ off, BUSY high, nACK low
        STRB    R1,[R9,#8]
;Make sure nACK bit (nSTROBE) has returned high
02      LDRB    R1,[R9,#4]
        TST     R1,#&40
        BEQ     %BT02
;Finish nAck pulse by clearing nSTROBE bit (puts nACK high). Keep BUSY high
        MOV     R1,#&20                 ; Input, IRQ off, BUSY high, nACK high
        STRB    R1,[R9,#8]
        MOV     pc,lr

FR_ParallelReadWord ROUT
;Read a word of data from the parallel port
;On entry
; r9 = Parallel port base address
;On exit
; r0 = word read
; r1-r3 corrupted
        MOV     R3,LR
        BL      FR_ParallelRead
        MOV     R2,R0
        BL      FR_ParallelRead
        ORR     R2,R2,R0,LSL #8
        BL      FR_ParallelRead
        ORR     R2,R2,R0,LSL #16
        BL      FR_ParallelRead
        ORR     R0,R2,R0,LSL #24
        MOV     PC,R3

FR_MakeROM0Writable
        STMFD   R13!,{R0}
        LDRB    R0,[R11,#IOMD_ROMCR0]
        ORR     R0,R0,#&80
        STRB    R0,[R11,#IOMD_ROMCR0]
        LDMFD   R13!,{R0}
        MOV     PC,LR

FR_MakeROM0ReadOnly
        STMFD   R13!,{R0}
        LDRB    R0,[R11,#IOMD_ROMCR0]
        BIC     R0,R0,#&80
        STRB    R0,[R11,#IOMD_ROMCR0]
        LDMFD   R13!,{R0}
        MOV     PC,LR

FR_ResetToReadArray ROUT
;Reset the flash devices to Read Array mode
        STMFD   R13!,{R0,R1}
        MOV     R0,#FR_FlashBase
        MOV     R1,#&FF
        ORR     R1,R1,R1,LSL #8
        STR     R1,[R0]                 ; Write the Read Array command (&FF) to both devices
        LDMFD   R13,{R0,R1}
        MOV     PC,LR

FR_StartErase   ROUT
;Start to erase a block (256KB) of flash memory
;On entry
; r0=Block Address (real memory address)
        STMFD   R13!,{R1}
        MOV     R1,#&20
        ORR     R1,R1,R1,LSL #8
        STR     R1,[R0]                 ; Write the Block Erase command (&20) to both devices
        MOV     R1,#&D0
        ORR     R1,R1,R1,LSL #8
        STR     R1,[R0]                 ; Write the Confirm command (&D0) to both devices
        LDMFD   R13!,{R1}
        MOV     PC,LR

FR_CheckErase   ROUT
;Wait for erase to finish
        STMFD   R13!,{R0,R1}
        MOV     R0,#FR_FlashBase
01      LDR     R1,[R0]                 ; Read the status register
        TST     R1,#&0080               ; Check even SR.7
        TSTNE   R1,#&8000               ; Check odd SR.7
        BEQ     %BT01                   ; Repeat until both set
        TST     R1,#&0020               ; Check even SR.5
        TSTEQ   R1,#&2000               ; Check odd SR.5
        BNE     FR_ceEraseError
        LDMFD   R13!,{R0,R1}
        MOV     PC,LR
FR_ceEraseError
        MOV     R1,#&50
        ORR     R1,R1,R1,LSL #8
        STR     R1,[R0]                 ; Write Clear Status Register command (&50) to beth devices
        BL      FR_ResetToReadArray
        BL      FR_MakeROM0ReadOnly
        LDMFD   R13!,{R0,R1}
        MOV     R0,#FR_EraseErrorState-FR_BorderStateTable
        B       FR_Error

FR_DoWriteBlock ROUT
;Writes a block (256KB) of data to flash memory
;On entry
; r0=Block Address (real memory address)
; r1=Pointer to data to write
;On exit
; r0,r1 have advanced by the block size (256KB)
        STMFD   R13!,{R2,R3,LR}
        MOV     R2,R1
        MOV     R1,R0
        MOV     R3,#FR_BlockSize
01      BL      FR_DoWriteBuffer
        SUBS    R3,R3,#FR_BufferSize
        BNE     %BT01
        MOV     R0,R1
        MOV     R1,R2
        LDMFD   R13!,{R2,R3,PC}

FR_DoWriteBuffer ROUT
;Write a buffer full of data (64 bytes) to flash memory
;On entry
; r0=Block Address
; r1=Start Address
; r2=Pointer to data to write
;On exit
; r0 preserved
; r1,r2 have increased by 64 bytes
        STMFD   R13!,{R3,R4,LR}
        MOV     R3,#&E8
        ORR     R3,R3,R3,LSL #8
01      STR     R3,[R0]                 ; Write the Write to Buffer command (&E8) to both devices
        LDR     R4,[R0]                 ; Read the XSR
        TST     R4,#&0080               ; Check even XSR.7
        TSTNE   R4,#&8000               ; Check odd XSR.7
        BEQ     %BT01                   ; Repeat until both set
        MOV     R3,#(FR_DeviceBufferSize:SHR:1)-1       ; No. of (16-bit) words to write - 1
        ORR     R3,R3,R3,LSL #8
        STR     R3,[R0]                 ; Write the (16-bit) word count to both devices
        MOV     R3,#FR_BufferSize
02      LDR     R4,[R2],#4
        STR     R4,[R1],#4              ; Write a (16-bit) word of data to each device
        SUBS    R3,R3,#4
        BNE     %BT02
        MOV     R3,#&D0
        ORR     R3,R3,R3,LSL #8
        STR     R3,[R0]                 ; Write the Confirm command (&D0) to both devices
03      LDR     R4,[R0]                 ; Read the status register
        TST     R4,#&0080               ; Check even SR.7
        TSTNE   R4,#&8000               ; Check odd SR.7
        BEQ     %BT03                   ; Repeat until both set
        TST     R4,#&0008               ; Check even SR.3
        TSTEQ   R4,#&0800               ; Check odd SR.3
        BNE     FR_dwbfVoltageRangeError
        TST     R4,#&0002               ; Check even SR.1
        TSTEQ   R4,#&0200               ; Check odd SR.1
        BNE     FR_dwbfDeviceProtectError
        TST     R4,#&0010               ; Check even SR.4
        TSTEQ   R4,#&1000               ; Check odd SR.4
        BNE     FR_dwbfProgramError
; Programming completed successfully
        LDMFD   R13!,{R3,R4,PC}

FR_dwbfVoltageRangeError
        MOV     R0,#FR_VoltageRangeErrorState-FR_BorderStateTable
        B       FR_dwbfErrorExit
FR_dwbfDeviceProtectError
        MOV     R0,#FR_DeviceProtectErrorState-FR_BorderStateTable
        B       FR_dwbfErrorExit
FR_dwbfProgramError
        MOV     R0,#FR_ProgramErrorState-FR_BorderStateTable
FR_dwbfErrorExit
        MOV     R3,#&50
        ORR     R3,R3,R3,LSL #8
        MOV     R4,#FR_FlashBase
        STR     R1,[R4]                 ; Write Clear Status Register command (&50) to beth devices
        BL      FR_ResetToReadArray
        BL      FR_MakeROM0ReadOnly
        LDMFD   R13!,{R3,R4,LR}
        B       FR_Error

FR_VerifyBlock  ROUT
;Compare a block (256KB) of data to flash memory
;On entry
; r0=Block Address (real memory address)
; r1=Pointer to block to compare
;On exit
; r0,r1 have advanced by the block size (256KB)
        STMFD   R13!,{R2-R4}
        MOV     R2,#FR_BlockSize
01      LDR     R3,[R0],#4
        LDR     R4,[R1],#4
        CMP     R3,R4
        BNE     FR_VerifyError
        SUBS    R2,R2,#4
        BNE     %BT01
        LDMFD   R13!,{R2-R4}
        MOV     PC,LR
FR_VerifyError
        MOV     R0,#FR_VerifyErrorState-FR_BorderStateTable
        B       FR_Error

FR_StackBaseVal    & FR_StackBase
FR_TransferBuffVal & FR_TransferBuffAddr

FR_RAMCodeEnd

        END
@


4.4
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@@


4.3
log
@Flash upgrade works this time.

Version 4.75. Tagged as 'Kernel-4_75'
@
text
@d67 1
a67 2
        MOV     R0,#I32_bit :OR: F32_bit :OR: SVC32_mode
        msr     AL,CPSR_all,R0
@


4.2
log
@A few fixes to the flash upgrade code.

Version 4.74. Tagged as 'Kernel-4_74'
@
text
@d477 1
a477 1
02      LDRB    R0,[R9,#4]
@


4.1
log
@Parallel port flash upgrade facility added.

Version 4.72. Tagged as 'Kernel-4_72'
@
text
@d134 1
a134 1
        MOV     R3,#255
d168 1
a168 1
        DCD     &80000000+FR_HSync+FR_HLBdr+FR_HDisp+FR_HRBdr+FR_HFPch-8
d179 1
a179 1
        DCD     &90000000+FR_VSync+FR_VBPch+FR_VTBdr+FR_VDisp+FR_VBBdr-1
d192 1
a192 1
        MOV     R3,R3
d255 1
a255 1
        MOV     R0,#&04         ; CR4=&03 (ECP & EPP mode)
a279 3
FR_StackBaseVal    & FR_StackBase
FR_TransferBuffVal & FR_TransferBuffAddr

d666 3
@

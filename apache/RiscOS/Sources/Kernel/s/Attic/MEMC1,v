head	4.2;
access;
symbols
	HAL_merge:4.1
	Kernel-5_48:4.1
	Kernel-5_35-4_79_2_327:4.1
	Kernel-5_35-4_79_2_326:4.1
	Kernel-5_35-4_79_2_325:4.1
	Kernel-5_35-4_79_2_324:4.1
	Kernel-5_35-4_79_2_323:4.1
	Kernel-5_35-4_79_2_322:4.1
	Kernel-5_35-4_79_2_321:4.1
	Kernel-5_35-4_79_2_320:4.1
	Kernel-5_35-4_79_2_319:4.1
	Kernel-5_35-4_79_2_318:4.1
	Kernel-5_35-4_79_2_317:4.1
	Kernel-5_35-4_79_2_316:4.1
	Kernel-5_35-4_79_2_315:4.1
	Kernel-5_35-4_79_2_314:4.1
	Kernel-5_35-4_79_2_313:4.1
	Kernel-5_35-4_79_2_312:4.1
	Kernel-5_35-4_79_2_311:4.1
	Kernel-5_35-4_79_2_310:4.1
	Kernel-5_35-4_79_2_309:4.1
	Kernel-5_35-4_79_2_308:4.1
	Kernel-5_35-4_79_2_307:4.1
	Kernel-5_35-4_79_2_306:4.1
	Kernel-5_35-4_79_2_305:4.1
	Kernel-5_35-4_79_2_304:4.1
	Kernel-5_35-4_79_2_303:4.1
	Kernel-5_35-4_79_2_302:4.1
	Kernel-5_35-4_79_2_301:4.1
	Kernel-5_35-4_79_2_300:4.1
	Kernel-5_35-4_79_2_299:4.1
	Kernel-5_35-4_79_2_298:4.1
	Kernel-5_35-4_79_2_297:4.1
	Kernel-5_35-4_79_2_296:4.1
	Kernel-5_35-4_79_2_295:4.1
	Kernel-5_35-4_79_2_294:4.1
	Kernel-5_35-4_79_2_293:4.1
	Kernel-5_35-4_79_2_292:4.1
	Kernel-5_35-4_79_2_291:4.1
	Kernel-5_35-4_79_2_290:4.1
	Kernel-5_35-4_79_2_289:4.1
	Kernel-5_35-4_79_2_288:4.1
	Kernel-5_35-4_79_2_287:4.1
	Kernel-5_35-4_79_2_286:4.1
	Kernel-5_35-4_79_2_285:4.1
	Kernel-5_35-4_79_2_284:4.1
	Kernel-5_35-4_79_2_283:4.1
	Kernel-5_35-4_79_2_282:4.1
	Kernel-5_35-4_79_2_281:4.1
	Kernel-5_35-4_79_2_280:4.1
	Kernel-5_35-4_79_2_279:4.1
	Kernel-5_35-4_79_2_278:4.1
	Kernel-5_35-4_79_2_277:4.1
	Kernel-5_35-4_79_2_276:4.1
	Kernel-5_35-4_79_2_275:4.1
	Kernel-5_35-4_79_2_274:4.1
	Kernel-5_35-4_79_2_273:4.1
	Kernel-5_35-4_79_2_272:4.1
	Kernel-5_35-4_79_2_271:4.1
	Kernel-5_35-4_79_2_270:4.1
	Kernel-5_35-4_79_2_269:4.1
	Kernel-5_35-4_79_2_268:4.1
	Kernel-5_35-4_79_2_267:4.1
	Kernel-5_35-4_79_2_266:4.1
	Kernel-5_35-4_79_2_265:4.1
	Kernel-5_35-4_79_2_264:4.1
	Kernel-5_35-4_79_2_263:4.1
	Kernel-5_35-4_79_2_262:4.1
	Kernel-5_35-4_79_2_261:4.1
	Kernel-5_35-4_79_2_260:4.1
	Kernel-5_35-4_79_2_259:4.1
	Kernel-5_35-4_79_2_258:4.1
	Kernel-5_35-4_79_2_257:4.1
	Kernel-5_35-4_79_2_256:4.1
	Kernel-5_35-4_79_2_255:4.1
	Kernel-5_35-4_79_2_254:4.1
	Kernel-5_35-4_79_2_253:4.1
	Kernel-5_35-4_79_2_252:4.1
	Kernel-5_35-4_79_2_251:4.1
	Kernel-5_35-4_79_2_250:4.1
	Kernel-5_35-4_79_2_249:4.1
	Kernel-5_35-4_79_2_248:4.1
	Kernel-5_35-4_79_2_247:4.1
	Kernel-5_35-4_79_2_246:4.1
	Kernel-5_35-4_79_2_245:4.1
	Kernel-5_35-4_79_2_244:4.1
	Kernel-5_35-4_79_2_243:4.1
	Kernel-5_35-4_79_2_242:4.1
	Kernel-5_35-4_79_2_241:4.1
	Kernel-5_35-4_79_2_240:4.1
	Kernel-5_35-4_79_2_239:4.1
	Kernel-5_35-4_79_2_238:4.1
	Kernel-5_35-4_79_2_237:4.1
	Kernel-5_35-4_79_2_236:4.1
	Kernel-5_35-4_79_2_235:4.1
	Kernel-5_35-4_79_2_234:4.1
	Kernel-5_35-4_79_2_233:4.1
	Kernel-5_35-4_79_2_232:4.1
	Kernel-5_35-4_79_2_231:4.1
	Kernel-5_35-4_79_2_230:4.1
	Kernel-5_35-4_79_2_229:4.1
	Kernel-5_35-4_79_2_228:4.1
	Kernel-5_35-4_79_2_227:4.1
	Kernel-5_35-4_79_2_226:4.1
	Kernel-5_35-4_79_2_225:4.1
	Kernel-5_35-4_79_2_224:4.1
	Kernel-5_35-4_79_2_223:4.1
	Kernel-5_35-4_79_2_222:4.1
	Kernel-5_35-4_79_2_221:4.1
	Kernel-5_35-4_79_2_220:4.1
	Kernel-5_35-4_79_2_219:4.1
	Kernel-5_35-4_79_2_218:4.1
	Kernel-5_35-4_79_2_217:4.1
	Kernel-5_35-4_79_2_216:4.1
	Kernel-5_35-4_79_2_215:4.1
	Kernel-5_35-4_79_2_214:4.1
	Kernel-5_35-4_79_2_213:4.1
	Kernel-5_35-4_79_2_212:4.1
	Kernel-5_35-4_79_2_211:4.1
	Kernel-5_35-4_79_2_210:4.1
	Kernel-5_35-4_79_2_209:4.1
	Kernel-5_35-4_79_2_208:4.1
	Kernel-5_35-4_79_2_207:4.1
	Kernel-5_35-4_79_2_206:4.1
	Kernel-5_35-4_79_2_205:4.1
	Kernel-5_35-4_79_2_204:4.1
	Kernel-5_35-4_79_2_203:4.1
	Kernel-5_35-4_79_2_202:4.1
	Kernel-5_35-4_79_2_201:4.1
	Kernel-5_35-4_79_2_200:4.1
	Kernel-5_35-4_79_2_199:4.1
	Kernel-5_35-4_79_2_198:4.1
	Kernel-5_35-4_79_2_197:4.1
	Kernel-5_35-4_79_2_196:4.1
	Kernel-5_35-4_79_2_195:4.1
	Kernel-5_35-4_79_2_194:4.1
	Kernel-5_35-4_79_2_193:4.1
	Kernel-5_35-4_79_2_192:4.1
	Kernel-5_35-4_79_2_191:4.1
	Kernel-5_35-4_79_2_190:4.1
	Kernel-5_35-4_79_2_189:4.1
	Kernel-5_35-4_79_2_188:4.1
	Kernel-5_35-4_79_2_187:4.1
	Kernel-5_35-4_79_2_186:4.1
	Kernel-5_35-4_79_2_185:4.1
	Kernel-5_35-4_79_2_184:4.1
	Kernel-5_35-4_79_2_183:4.1
	Kernel-5_35-4_79_2_182:4.1
	Kernel-5_35-4_79_2_181:4.1
	Kernel-5_35-4_79_2_180:4.1
	Kernel-5_35-4_79_2_179:4.1
	Kernel-5_35-4_79_2_178:4.1
	Kernel-5_35-4_79_2_177:4.1
	Kernel-5_35-4_79_2_176:4.1
	Kernel-5_35-4_79_2_175:4.1
	Kernel-5_35-4_79_2_174:4.1
	Kernel-5_35-4_79_2_173:4.1
	Kernel-5_35-4_79_2_172:4.1
	Kernel-5_35-4_79_2_171:4.1
	Kernel-5_35-4_79_2_170:4.1
	Kernel-5_35-4_79_2_169:4.1
	Kernel-5_35-4_79_2_168:4.1
	Kernel-5_35-4_79_2_167:4.1
	Kernel-5_35-4_79_2_166:4.1
	Kernel-5_35-4_79_2_165:4.1
	RPi_merge:4.1
	Kernel-5_35-4_79_2_147_2_23:4.1
	Kernel-5_35-4_79_2_147_2_22:4.1
	Kernel-5_35-4_79_2_147_2_21:4.1
	Kernel-5_35-4_79_2_147_2_20:4.1
	Kernel-5_35-4_79_2_147_2_19:4.1
	Kernel-5_35-4_79_2_147_2_18:4.1
	Kernel-5_35-4_79_2_164:4.1
	Kernel-5_35-4_79_2_163:4.1
	Kernel-5_35-4_79_2_147_2_17:4.1
	Kernel-5_35-4_79_2_147_2_16:4.1
	Kernel-5_35-4_79_2_147_2_15:4.1
	Kernel-5_35-4_79_2_162:4.1
	Kernel-5_35-4_79_2_161:4.1
	Kernel-5_35-4_79_2_147_2_14:4.1
	Kernel-5_35-4_79_2_147_2_13:4.1
	Kernel-5_35-4_79_2_160:4.1
	Kernel-5_35-4_79_2_159:4.1
	Kernel-5_35-4_79_2_158:4.1
	Kernel-5_35-4_79_2_157:4.1
	Kernel-5_35-4_79_2_156:4.1
	Kernel-5_35-4_79_2_147_2_12:4.1
	Kernel-5_35-4_79_2_147_2_11:4.1
	Kernel-5_35-4_79_2_155:4.1
	Kernel-5_35-4_79_2_147_2_10:4.1
	Kernel-5_35-4_79_2_154:4.1
	Kernel-5_35-4_79_2_153:4.1
	Kernel-5_35-4_79_2_147_2_9:4.1
	Kernel-5_35-4_79_2_152:4.1
	Kernel-5_35-4_79_2_151:4.1
	Kernel-5_35-4_79_2_147_2_8:4.1
	Kernel-5_35-4_79_2_147_2_7:4.1
	Kernel-5_35-4_79_2_150:4.1
	Kernel-5_35-4_79_2_147_2_6:4.1
	Kernel-5_35-4_79_2_147_2_5:4.1
	Kernel-5_35-4_79_2_149:4.1
	Kernel-5_35-4_79_2_147_2_4:4.1
	Kernel-5_35-4_79_2_147_2_3:4.1
	Kernel-5_35-4_79_2_148:4.1
	Kernel-5_35-4_79_2_147_2_2:4.1
	Kernel-5_35-4_79_2_147_2_1:4.1
	RPi:4.1.0.16
	RPi_bp:4.1
	Kernel-5_35-4_79_2_98_2_52_2_1:4.1
	alees_Kernel_dev:4.1.0.12
	alees_Kernel_dev_bp:4.1
	Kernel-5_35-4_79_2_147:4.1
	Kernel-5_35-4_79_2_146:4.1
	Kernel-5_35-4_79_2_145:4.1
	Kernel-5_35-4_79_2_144:4.1
	Kernel-5_35-4_79_2_143:4.1
	Kernel-5_35-4_79_2_142:4.1
	Kernel-5_35-4_79_2_141:4.1
	Kernel-5_35-4_79_2_140:4.1
	Kernel-5_35-4_79_2_139:4.1
	Kernel-5_35-4_79_2_138:4.1
	Kernel-5_35-4_79_2_137:4.1
	Kernel-5_35-4_79_2_136:4.1
	Kernel-5_35-4_79_2_135:4.1
	Kernel-5_35-4_79_2_134:4.1
	Kernel-5_35-4_79_2_133:4.1
	Kernel-5_35-4_79_2_132:4.1
	Kernel-5_35-4_79_2_131:4.1
	Kernel-5_35-4_79_2_130:4.1
	Kernel-5_35-4_79_2_129:4.1
	Kernel-5_35-4_79_2_128:4.1
	Kernel-5_35-4_79_2_127:4.1
	Kernel-5_35-4_79_2_126:4.1
	Kernel-5_35-4_79_2_125:4.1
	Kernel-5_35-4_79_2_124:4.1
	Kernel-5_35-4_79_2_123:4.1
	Cortex_merge:4.1
	Kernel-5_35-4_79_2_122:4.1
	Kernel-5_35-4_79_2_98_2_54:4.1
	Kernel-5_35-4_79_2_98_2_53:4.1
	Kernel-5_35-4_79_2_98_2_52:4.1
	Kernel-5_35-4_79_2_98_2_51:4.1
	Kernel-5_35-4_79_2_98_2_50:4.1
	Kernel-5_35-4_79_2_98_2_49:4.1
	Kernel-5_35-4_79_2_98_2_48:4.1
	Kernel-5_35-4_79_2_121:4.1
	Kernel-5_35-4_79_2_98_2_47:4.1
	Kernel-5_35-4_79_2_120:4.1
	Kernel-5_35-4_79_2_98_2_46:4.1
	Kernel-5_35-4_79_2_119:4.1
	Kernel-5_35-4_79_2_98_2_45:4.1
	Kernel-5_35-4_79_2_98_2_44:4.1
	Kernel-5_35-4_79_2_118:4.1
	Kernel-5_35-4_79_2_98_2_43:4.1
	Kernel-5_35-4_79_2_117:4.1
	Kernel-5_35-4_79_2_116:4.1
	Kernel-5_35-4_79_2_98_2_42:4.1
	Kernel-5_35-4_79_2_115:4.1
	Kernel-5_35-4_79_2_98_2_41:4.1
	Kernel-5_35-4_79_2_98_2_40:4.1
	Kernel-5_35-4_79_2_114:4.1
	Kernel-5_35-4_79_2_98_2_39:4.1
	Kernel-5_35-4_79_2_98_2_38:4.1
	Kernel-5_35-4_79_2_113:4.1
	Kernel-5_35-4_79_2_112:4.1
	Kernel-5_35-4_79_2_98_2_37:4.1
	Kernel-5_35-4_79_2_98_2_36:4.1
	Kernel-5_35-4_79_2_98_2_35:4.1
	Kernel-5_35-4_79_2_98_2_34:4.1
	Kernel-5_35-4_79_2_98_2_33:4.1
	Kernel-5_35-4_79_2_98_2_32:4.1
	Kernel-5_35-4_79_2_98_2_31:4.1
	Kernel-5_35-4_79_2_98_2_30:4.1
	Kernel-5_35-4_79_2_98_2_29:4.1
	Kernel-5_35-4_79_2_98_2_28:4.1
	Kernel-5_35-4_79_2_98_2_27:4.1
	Kernel-5_35-4_79_2_98_2_26:4.1
	Kernel-5_35-4_79_2_111:4.1
	Kernel-5_35-4_79_2_98_2_25:4.1
	Kernel-5_35-4_79_2_98_2_24:4.1
	Kernel-5_35-4_79_2_98_2_23:4.1
	Kernel-5_35-4_79_2_110:4.1
	Kernel-5_35-4_79_2_98_2_22:4.1
	Kernel-5_35-4_79_2_109:4.1
	Kernel-5_35-4_79_2_98_2_21:4.1
	Kernel-5_35-4_79_2_98_2_20:4.1
	Kernel-5_35-4_79_2_108:4.1
	Kernel-5_35-4_79_2_107:4.1
	Kernel-5_35-4_79_2_98_2_19:4.1
	Kernel-5_35-4_79_2_98_2_18:4.1
	Kernel-5_35-4_79_2_98_2_17:4.1
	Kernel-5_35-4_79_2_98_2_16:4.1
	Kernel-5_35-4_79_2_98_2_15:4.1
	Kernel-5_35-4_79_2_106:4.1
	Kernel-5_35-4_79_2_105:4.1
	Kernel-5_35-4_79_2_104:4.1
	Kernel-5_35-4_79_2_98_2_14:4.1
	Kernel-5_35-4_79_2_98_2_13:4.1
	Kernel-5_35-4_79_2_98_2_12:4.1
	Kernel-5_35-4_79_2_98_2_11:4.1
	Kernel-5_35-4_79_2_98_2_10:4.1
	Kernel-5_35-4_79_2_98_2_9:4.1
	Kernel-5_35-4_79_2_103:4.1
	Kernel-5_35-4_79_2_102:4.1
	Kernel-5_35-4_79_2_98_2_8:4.1
	Kernel-5_35-4_79_2_98_2_7:4.1
	Kernel-5_35-4_79_2_98_2_6:4.1
	Kernel-5_35-4_79_2_98_2_5:4.1
	Kernel-5_35-4_79_2_98_2_4:4.1
	Kernel-5_35-4_79_2_101:4.1
	Kernel-5_35-4_79_2_100:4.1
	Kernel-5_35-4_79_2_99:4.1
	Kernel-5_35-4_79_2_98_2_3:4.1
	Kernel-5_35-4_79_2_98_2_2:4.1
	Kernel-5_35-4_79_2_98_2_1:4.1
	Cortex:4.1.0.2
	Cortex_bp:4.1
	Kernel-5_35-4_79_2_98:4.1
	Kernel-5_35-4_79_2_97:4.1
	Kernel-5_35-4_79_2_96:4.1
	Kernel-5_35-4_79_2_95:4.1
	Kernel-5_35-4_79_2_94:4.1
	Kernel-5_35-4_79_2_93:4.1
	Kernel-5_35-4_79_2_92:4.1
	Kernel-5_35-4_79_2_91:4.1
	Kernel-5_35-4_79_2_90:4.1
	Kernel-5_35-4_79_2_89:4.1
	Kernel-5_35-4_79_2_88:4.1
	Kernel-5_35-4_79_2_87:4.1
	Kernel-5_35-4_79_2_86:4.1
	Kernel-5_35-4_79_2_85:4.1
	Kernel-5_35-4_79_2_84:4.1
	Kernel-5_35-4_79_2_83:4.1
	Kernel-5_35-4_79_2_82:4.1
	Kernel-5_35-4_79_2_81:4.1
	Kernel-5_35-4_79_2_80:4.1
	Kernel-5_35-4_79_2_79:4.1
	Kernel-5_35-4_79_2_78:4.1
	Kernel-5_35-4_79_2_77:4.1
	RO_5_07:4.1
	Kernel-5_35-4_79_2_76:4.1
	Kernel-5_35-4_79_2_75:4.1
	Kernel-5_35-4_79_2_74:4.1
	Kernel-5_35-4_79_2_73:4.1
	Kernel-5_35-4_79_2_72:4.1
	Kernel-5_35-4_79_2_71:4.1
	Kernel-5_35-4_79_2_70:4.1
	Kernel-5_35-4_79_2_69:4.1
	Kernel-5_35-4_79_2_68:4.1
	Kernel-5_35-4_79_2_67:4.1
	Kernel-5_35-4_79_2_66:4.1
	Kernel-5_35-4_79_2_65:4.1
	Kernel-5_35-4_79_2_64:4.1
	Kernel-5_35-4_79_2_63:4.1
	Kernel-5_35-4_79_2_62:4.1
	Kernel-5_35-4_79_2_61:4.1
	Kernel-5_35-4_79_2_59:4.1
	Kernel-5_35-4_79_2_58:4.1
	Kernel-5_35-4_79_2_57:4.1
	Kernel-5_35-4_79_2_56:4.1
	Kernel-5_35-4_79_2_55:4.1
	Kernel-5_35-4_79_2_54:4.1
	Kernel-5_35-4_79_2_53:4.1
	Kernel-5_35-4_79_2_52:4.1
	Kernel-5_35-4_79_2_51:4.1
	Kernel-5_35-4_79_2_50:4.1
	Kernel-5_35-4_79_2_49:4.1
	Kernel-5_35-4_79_2_48:4.1
	Kernel-5_47:4.1
	Kernel-5_46-4_90_2_1:4.1
	nbingham_Kernel_FastNC_dev_bp:4.1
	nbingham_Kernel_FastNC_dev:4.1.0.14
	Kernel-5_46:4.1
	Kernel-5_45:4.1
	Kernel-5_35-4_79_2_47:4.1
	Kernel-5_35-4_79_2_46:4.1
	Kernel-5_35-4_79_2_45:4.1
	Kernel-5_35-4_79_2_44:4.1
	Kernel-5_35-4_79_2_25_2_2:4.1
	Kernel-5_35-4_79_2_43:4.1
	Kernel-5_35-4_79_2_42:4.1
	Kernel-5_35-4_79_2_41:4.1
	Kernel-5_35-4_79_2_40:4.1
	Kernel-5_35-4_79_2_39:4.1
	Kernel-5_35-4_79_2_38:4.1
	Kernel-5_35-4_79_2_37:4.1
	Kernel-5_35-4_79_2_36:4.1
	Kernel-5_35-4_79_2_35:4.1
	Kernel-5_35-4_79_2_34:4.1
	Kernel-5_35-4_79_2_33:4.1
	Kernel-5_35-4_79_2_32:4.1
	Kernel-5_44:4.1
	Kernel-5_35-4_79_2_25_2_1:4.1
	Kernel-5_43:4.1
	Kernel-5_35-4_79_2_31:4.1
	Kernel-5_35-4_79_2_30:4.1
	Kernel-5_35-4_79_2_29:4.1
	Kernel-5_35-4_79_2_28:4.1
	Kernel-5_35-4_79_2_27:4.1
	Kernel-5_35-4_79_2_26:4.1
	Kernel-5_42:4.1
	Kernel-5_41:4.1
	Kernel-5_40:4.1
	Kernel-5_35-4_79_2_25:4.1
	Kernel-5_35-4_79_2_24:4.1
	Kernel-5_35-4_79_2_23:4.1
	Kernel-5_35-4_79_2_22:4.1
	Kernel-5_35-4_79_2_21:4.1
	Kernel-5_35-4_79_2_20:4.1
	Kernel-5_35-4_79_2_19:4.1
	Kernel-5_35-4_79_2_18:4.1
	Kernel-5_35-4_79_2_17:4.1
	Kernel-5_35-4_79_2_16:4.1
	Kernel-5_35-4_79_2_15:4.1
	Kernel-5_35-4_79_2_14:4.1
	Kernel-5_39:4.1
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.10
	Kernel-5_38:4.1
	Kernel-5_35-4_79_2_13:4.1
	Kernel-5_35-4_79_2_12:4.1
	Kernel-5_35-4_79_2_11:4.1
	Kernel-5_37:4.1
	Kernel-5_35-4_79_2_10:4.1
	Kernel-5_35-4_79_2_9:4.1
	Kernel-5_36:4.1
	Kernel-5_35-4_79_2_8:4.1
	Kernel-5_35-4_79_2_7:4.1
	Kernel-5_35-4_79_2_6:4.1
	Kernel-5_35-4_79_2_5:4.1
	Kernel-5_35-4_79_2_4:4.1
	Kernel-5_35-4_79_2_3:4.1
	Kernel-5_35-4_79_2_2:4.1
	dellis_autobuild_BaseSW:4.1
	Kernel-5_35-4_79_2_1:4.1
	HAL:4.1.0.8
	Kernel-5_35:4.1
	Kernel-5_34:4.1
	Kernel-5_33:4.1
	Kernel-5_32:4.1
	Kernel-5_31:4.1
	Kernel-5_30:4.1
	Kernel-5_29:4.1
	Kernel-5_28:4.1
	Kernel-5_27:4.1
	Kernel-5_26:4.1
	Kernel-5_25:4.1
	Kernel-5_24:4.1
	Kernel-5_23:4.1
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.1
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	Kernel-4_84:4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	afrost_Boca-1_2-Beta:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	2016.06.30.20.28.55;	author jlee;	state dead;
branches;
next	4.1;
commitid	lMnWzoE9eJz3Wwcz;

4.1
date	96.11.05.09.41.20;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.41.20;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.28;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.33.15;	author mstphens;	state dead;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.09;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.37;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > MEMC1

; MEMC interface file - MEMC1 version

; Created by TMD 10-Aug-90

VInit   * &03600000
VStart  * &03620000
VEnd    * &03640000
CInit   * &03660000
; SStart  * &03680000
; SEnd    * &036A0000
; SPtr    * &036C0000

; *****************************************************************************
;
;       SetDAG - Program DMA address generator R1 with physical address R0
;
; in:   r0 = physical address
;       r1 = index of DMA address generator to program, as defined in vdudecl
;
; out:  All registers preserved, operation ignored if illegal
;

SetDAG  ENTRY   "r0"
        CMP     r1, #MEMCDAG_MaxReason
        EXIT    HI
        ADR     r14, DAGAddressTable
        LDR     r14, [r14, r1, LSL #2]          ; load base address in MEMC1
        MOV     r0, r0, LSR #4                  ; bottom 4 bits irrelevant
        CMP     r0, #(1 :SHL: 15)               ; ensure in range
        ORRCC   r14, r14, r0, LSL #2
        STRCC   r14, [r14]                      ; any old data will do
        EXIT

        GBLA    DAGIndex
DAGIndex SETA   0

        MACRO
        DAGTab  $reason, $address
        ASSERT  ($reason)=DAGIndex
        &       $address
DAGIndex SETA   DAGIndex + 1
        MEND

DAGAddressTable
        DAGTab  MEMCDAG_VInit, VInit
        DAGTab  MEMCDAG_VStart, VStart
        DAGTab  MEMCDAG_VEnd, VEnd
        DAGTab  MEMCDAG_CInit, CInit

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; CAM manipulation utility routines

BangCamUpdate ROUT

; R2 = CAM entry no
; R3 = logaddr
; R9 = current MEMC value
; R11 = PPL
; set and update tables

        MOV     R4, #0
        LDR     R4, [R4, #CamEntriesPointer]
        ORR     r0, r3, r11, LSL #28  ; top nibble is PPL
        STR     r0, [R4, R2, LSL #2]

BangCam

; r0 corrupted
; r1 corrupted
; R2 = CAM entry no
; R3 = logaddr
; r4 corrupted
; r5 spare!
; r6 corrupted
; r7, r8 spare
; R9 = current MEMC value
; r10 spare
; R11 = PPL
; r12 spare

        AND     R4, R9, #&C           ; pagesize
        ADR     R0, PageMangleTable
        LDR     R0, [R0, R4]          ; load data table pointer
        MOV     R4, #0
01      LDR     R1, [R0], #4
        CMP     R1, #-1
        BEQ     %FT02
        AND     R6, R2, R1
        LDR     R1, [R0], #4
        CMP     R1, #0
        RSBMI   R1, R1, #0
        ORRPL   R4, R4, R6, LSL R1
        ORRMI   R4, R4, R6, LSR R1
        B       %BT01

02      LDR     R1, [R0], #4
        CMP     R1, #-1
        BEQ     %FT03
        AND     R6, R3, R1
        LDR     R1, [R0], #4
        CMP     R1, #0
        RSBMI   R1, R1, #0
        ORRPL   R4, R4, R6, LSL R1
        ORRMI   R4, R4, R6, LSR R1
        B       %BT02

03      ORR     R4, R4, #CAM
        ORR     R4, R4, R11, LSL #8     ; stuff in PPL
        STR     R4, [R4]                ; and write it
        MOV     PC, LR

; Data to drive CAM setting

PageMangleTable
        &       PageMangle4K
        &       PageMangle8K
        &       PageMangle16K
        &       PageMangle32K

; For each page size, pairs of masks and shift factors to put the bits in the
; right place. Two sets: operations on Physical Page Number, operations on
; Logical Page Number.

; Shifts are Shift Left values (<<). Each section terminated by -1

PageMangle4K
; PPN:
        &       2_011111111
        &       0                       ; bits in right place
        &       -1
; LPN:
        &       2_1100000000000:SHL:12
        &       (11-12)-12              ; LPN[12:11] -> A[11:10]
        &       2_0011111111111:SHL:12
        &       (22-10)-12              ; LPN[10:0 ] -> A[22:12]
        &      -1

PageMangle8K
; PPN:
        &       2_010000000
        &       7-7                     ; PPN[7]   -> A[7]
        &       2_001000000
        &       0-6                     ; PPN[6]   -> A[0]
        &       2_000111111
        &       6-5                     ; PPN[5:0] -> A[6:1]
        &       -1
; LPN:
        &       2_110000000000:SHL:13
        &       (11-11)-13              ; LPN[11:10] -> A[11:10]
        &       2_001111111111:SHL:13
        &       (22-9)-13               ; LPN[9:0]   -> A[22:13]
        &       -1

PageMangle16K
; PPN:
        &       2_010000000
        &       7-7                     ; PPN[7]   -> A[7]
        &       2_001100000
        &       1-6                     ; PPN[6:5] -> A[1:0]
        &       2_000011111
        &       6-4                     ; PPN[4:0] -> A[6:2]
        &       -1
; LPN:
        &       2_11000000000:SHL:14
        &       (11-10)-14              ; LPN[10:9] -> A[11:10]
        &       2_00111111111:SHL:14
        &       (22-8)-14               ; LPN[8:0]  -> A[22:14]
        &       -1

PageMangle32K
; PPN:
        &       2_100000000
        &       12-8                    ; PPN[8] -> A[12]
        &       2_010000000
        &       7-7                     ; PPN[7] -> A[7]
        &       2_001000000
        &       1-6                     ; PPN[6] -> A[1]
        &       2_000100000
        &       2-5                     ; PPN[5] -> A[2]
        &       2_000010000
        &       0-4                     ; PPN[4] -> A[0]
        &       2_000001111
        &       6-3                     ; PPN[3:0] -> A[6:3]
        &       -1
; LPN:
        &       2_1100000000:SHL:15
        &       (11-9)-15               ; LPN[9:8] -> A[11:10]
        &       2_0011111111:SHL:15
        &       (22-7)-15               ; LPN[7:0] -> A[22:15]
        &       -1

PageSizes
        &       4*1024                  ; 0 is 4K
        &       8*1024                  ; 4 is 8K
        &       16*1024                 ; 8 is 16
        &       32*1024                 ; C is 32

PageShifts
        =       12, 13, 0, 14           ; 1 2 3 4
        =       0,  0,  0, 15           ; 5 6 7 8

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_UpdateMEMC: Read/write MEMC1 control register

SSETMEMC ROUT

        AND     r10, r0, r1
        MOV     r12, #0
        TEQP    pc, #SVC_mode+I_bit+F_bit
        LDR     r0, [r12, #MEMC_CR_SoftCopy] ; return old value
        BIC     r11, r0, r1
        ORR     r11, r11, R10
        BIC     r11, r11, #&FF000000
        BIC     r11, r11, #&00F00000
        ORR     r11, r11, #MEMCADR
        STR     r11, [r12, #MEMC_CR_SoftCopy]
        STR     r11, [r11]
        TEQP    pc, #SVC_mode+I_bit
        ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ClearPhysRAM - Routine to clear "all" memory
;
; While this routine is running, keyboard IRQs may happen. For this reason
; it avoids LogRAM 0..31 (where hardware IRQ vector is) and PhysRAM
; 0..31 where the IRQ workspace is.
;
; r7 contains memory speed and must be preserved
; r8 contains page size and must be preserved
; r9 contains MEMC control register and must be preserved
;

ClearPhysRAM ROUT
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r11, #0
        MOV     r12, #PhysRam
        CMP     r13, #512*1024
        ADDEQ   r10, r12, #(512-64)*1024 ; get address that's logram 0
        ADDNE   r10, r12, #512*1024
        ADD     r13, r13, #PhysRam      ; end of memory
        ADD     r12, r12, #4*8          ; skip minimal startup workspace
10      CMP     r12, R10
        ADDEQ   r12, r12, #4*8          ; skip physram that's logram 0
        STMNEIA r12!, {r0-r6, r11}
        CMP     r12, r13
        BNE     %BT10
        SUB     r13, r13, #PhysRam

        LDR     r0, =OsbyteVars + :INDEX: LastBREAK
        MOV     r1, #&80
        STRB    r1, [r0]                ; flag the fact that RAM cleared
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       InitMEMC - Initialise memory controller
;

InitMEMC ROUT
        LDR     R0, ResetMemC_Value
        STR     R0, [R0]     ; set ROM access times, refresh on flyback, no DMA
        MOV     pc, lr

; -> MemSize

; (non-destructive) algorithm to determine MEMC RAM configuration
;
; Dave Flynn and Alasdair Thomas
; 17-March-87
;
; Spooling checkered by NRaine and SSwales !
; 8MByte check bodged in by APT
;
; NOTE: Routines MemSize and TimeCPU are called by the power-on test software,
; so their specifications MUST not change.
;
; Set MEMC for 32-k page then analyse signature of possible
; external RAM configurations...
; The configurations are:
;
; Ram Size    Page Size    Configuration    (Phys RAM) Signature
;--------------------------------------------------------------------
;  16MByte      32k        4*32*1Mx1         A13,A20,A21,A22,A23,A23.5 distinct
;  16MByte      32k        16*8*256kx4       A13,A20,A21,A22,A23,A23.5 distinct
;
;  12MByte      32k        3*32*1Mx1         A13,A20,A21,A22,A23 OK, A23.5 fail
;  12MByte      32k        12*8*256kx4       A13,A20,A21,A22,A23 OK, A23.5 fail
;
;   8MByte      32k        2*32*1Mx1         A13,A20,A21,A22 distinct, A23 fail
;   8MByte      32k         8*8*256kx4       A13,A20,A21,A22 distinct, A23 fail
; 
;   4Mbyte      32k          32*1Mx1         A13,A21,A20 distinct, A22,A23 fail
;   4Mbyte      32k         4*8*256kx4       A13,A21,A20 distinct, A22,A23 fail
;
;   2Mbyte      32k    expandable 2*8*256kx4 A13,A20 distinct, A21 fails
;   2Mbyte ???  16k      fixed 2*8*256kx4    A13,A21 distinct, A20 fails
;   
;   1Mbyte       8k          32*256kx1       A13,A20 fail, A19,A18,A12 distinct
;   1Mbyte       8k           8*256kx1       A13,A20 fail, A19,A18,A12 distinct
;   1Mbyte       8k          4*8*64kx4       A13,A20 fail, A19,A18,A12 distinct
;
; 512Kbyte       8k    expandable 2*8*64kx4  A13,A20,A19 fail, A12,A18 distinct
; 512Kbyte       4k      fixed 2*8*64kx4     A13,A20,A12 fail, A19,A18 distinct
;
; 256Kbyte       4K           8*64kx4        A13,A20,A12,A18 fail, A21,A19 ok  
; 256Kbyte       4K          32*64kx1        A13,A20,A12,A18 fail, A21,A19 ok  
;

Z_Flag     * &40000000

; MemSize routine... enter with 32K pagesize set
; R0 returns page size
; R1 returns memory size
; R2 returns value set in MEMC
; uses R3-R7

MemSize ROUT
        MOV     r7, lr
        MOV     r0, #PhysRam
        ADD     r1, r0, #A13
        BL      DistinctAddresses
        BNE     %10
        ADD     r1, r0, #A21
        BL      DistinctAddresses
        MOVNE   r0, #Page32K
        MOVNE   r1, #2048*1024
        BNE     MemSizeDone

        MOV     r0, #PhysRam
        ADD     r1, r0, #4*1024*1024
        BL      DistinctAddresses
        MOVNE   r0, #Page32K
        MOVNE   r1, #4*1024*1024
        BNE     MemSizeDone

        MOV     r0, #PhysRam
        ADD     r1, r0, #8*1024*1024
        BL      DistinctAddresses
        MOVNE   r0, #Page32K
        MOVNE   r1, #8*1024*1024
        BNE     MemSizeDone

        MOV     r0, #PhysRam
        ADD     r1, r0, #12*1024*1024
        BL      DistinctAddresses
        MOV     r0, #Page32K
        MOVNE   r1, #12*1024*1024
        MOVEQ   r1, #16*1024*1024
        B       MemSizeDone

10      ADD     r1, r0, #A20
        BL      DistinctAddresses
        BNE     %20
        MOV     r0, #Page16K
        MOV     r1, #2048*1024
        B       MemSizeDone

20      ADD     r1, r0, #A19
        BL      DistinctAddresses
        BEQ     %30
        MOV     r0, #Page8K
        MOV     r1, #512*1024
        B       MemSizeDone

30      ADD     r1, r0, #A18
        BL      DistinctAddresses
        BEQ     %40
        MOV     r0, #Page4K
        MOV     r1, #256*1024
        B       MemSizeDone

40      ADD     r1, r0, #A12
        BL      DistinctAddresses
        BEQ     %50
        MOV     r0, #Page4K
        MOV     r1, #512*1024
        B       MemSizeDone

50      MOV     r0, #Page8K
        MOV     r1, #1024*1024

MemSizeDone
        LDR     r2, ResetMemC_Value
        BIC     r2, r2, #&C
        ORR     r2, r2, r0
        STR     r2, [r2]                        ; set MEMC to right state
        ADR     r3, PageSizes
        LDR     r0, [r3, r0]                    ; r0 = convert from page size indicator into actual page size (in bytes)
        MOV     pc, r7


; DistinctAddresses routine...
; r0,r1 are the addresses to check
; uses r2-5
; writes interleaved patterns (to prevent dynamic storage...)
; checks writing every bit low and high...
; return Z-flag set if distinct

DistinctAddresses ROUT
        LDR     r2, [r0] ; preserve
        LDR     r3, [r1]
        LDR     r4, Pattern
        STR     r4, [r0] ; mark first
        MOV     r5, r4, ROR #16
        STR     r5, [r1] ; mark second
        LDR     r5, [r0]
        CMP     r5, r4 ; check first
        BNE     %10    ; exit with Z clear
        LDR     r5, [r1] ; check second
        CMP     r5, r4, ROR #16 ; clear Z if not same
        BNE     %10
; now check inverse bit writes
        STR     r4, [r1] ; mark second
        MOV     r5, r4, ROR #16
        STR     r5, [r0] ; mark first
        LDR     r5, [r1]
        CMP     r5, r4 ; check second
        BNE     %10   ; exit with Z clear
        LDR     r5, [r0] ; check first
        CMP     r5, r4, ROR #16 ; clear Z if not same
10      STR     r3, [r1] ; restore
        STR     r2, [r0]
        ORREQ   lr, lr, #Z_Flag
        BICNE   lr, lr, #Z_Flag
        MOVS    pc, lr

Pattern
        &       &AAFF5500 ; shiftable bit check pattern

; init state with masked out page size

ResetMemC_Value
        & &E010C :OR: MEMCADR       ; slugged ROMs + flyback refresh only + 32K page

; Constants
;
A21 * 1:SHL:21
A20 * 1:SHL:20
A19 * 1:SHL:19
A18 * 1:SHL:18
A13 * 1:SHL:13
A12 * 1:SHL:12

Page32K * &C ; in MEMC control reg patterns...
Page16K * &8
Page8K  * &4
Page4K  * &0


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable
;       r9 = Current MEMC CR

; Out   r9 MEMC value with slowest ROM speed, correct pagesize
;       r7 processor speed in kHz, tbs -> MEMC1a

ncpuloops * 1024 ; don't go longer than 4ms without refresh !
nmulloops * 128

TimeCPU ROUT

        BIC     r9, r9, #3 :SHL: 8
        STR     r9, [r9]                ; turn off refresh for a bit

; Time CPU/Memory speed

        LDR     r1, =&7FFE              ; 32K @@ 2MHz = ~16ms limit
        MOV     r3, #IOC

        MOV     r0, r1, LSR #8
        STRB    r1, [r3, #Timer1LL]
        STRB    r0, [r3, #Timer1LH]
        LDR     r0, =ncpuloops
        STRB    r0, [r3, #Timer1GO]     ; start the timer NOW
        B       %FT10                   ; Looks superfluous, but is required
                                        ; to get ncpuloops pipeline breaks

10      SUBS    r0, r0, #1              ; 1S
        BNE     %BT10                   ; 1N + 2S

        STRB    r0, [r3, #Timer1LR]     ; latch count NOW
        LDRB    r2, [r3, #Timer1CL]
        LDRB    r0, [r3, #Timer1CH]
        ADD     r2, r2, r0, LSL #8      ; count after looping is ...

        SUB     r2, r1, r2              ; decrements !
        MOV     r2, r2, LSR #1          ; IOC clock decrements at 2MHz

; Time CPU/MEMC Multiply time

        MOV     r4, #-1                 ; Gives worst case MUL

        MOV     r0, r1, LSR #8
        STRB    r1, [r3, #Timer1LL]
        STRB    r0, [r3, #Timer1LH]
        LDR     r0, =nmulloops
        STRB    r0, [r3, #Timer1GO]     ; start the timer NOW
        B       %FT20                   ; Looks superfluous, but is required
                                        ; to get nmulloops pipeline breaks

20      MUL     r5, r4, r4              ; 1S + 16I
        MUL     r5, r4, r4              ; 1S + 16I
        SUBS    r0, r0, #1              ; 1S
        BNE     %BT20                   ; 1N + 2S

        STRB    r0, [r3, #Timer1LR]     ; latch count NOW
        LDRB    r4, [r3, #Timer1CL]
        LDRB    r0, [r3, #Timer1CH]
        ADD     r4, r4, r0, LSL #8      ; count after looping is ...

        SUB     r4, r1, r4              ; decrements !
        MOV     r4, r4, LSR #1          ; IOC clock decrements at 2MHz

        ORR     r9, r9, #1 :SHL: 8      ; set refresh on flyback
        STR     r9, [r9]                ; restore MEMC state a.s.a.p.

; In ROM - each cpu loop took 4R cycles @@ 8/f*500ns/cycle

        LDR     r0, =4*(8*500/1000)*ncpuloops*1000
        DivRem  r7, r0, r2, r1          ; r2 preserved
        MOV     r0, #&80                ; At 8 MHz and below, run fast ROMs
        LDR     r1, =8050               ; Over 8 MHz, need medium ROMs
        CMP     r7, r1
        MOVHI   r0, #&40
        LDR     r1, =13000              ; Over 13 MHz, need slowest ROMs
        CMP     r7, r1
        MOVHI   r0, #&00
        ORR     r9, r9, r0
        STR     r9, [r9]                ; Set ROM speed appropriately

 ASSERT ncpuloops = 8*nmulloops ; for given ratio cutoff <------------

        MOV     r4, r4, LSL #10         ; *1024 to get resolution on divide
        DivRem  r0, r4, r2, r1
        LDR     r1, =1100               ; Cutoff point; MEMC1 longer than this
        CMP     r0, r1
        ORRLO   r7, r7, #1 :SHL: 16     ; Note MEMC1a prescence

        MOV     pc, lr

; Typical figures give (in ROM at 8MHz):

; MEMC1  2048 CPU, 2432 MEMC -> MUL ratio 1216
; MEMC1a 2048       864                    432

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        END
@


4.1
log
@Initial revision
@
text
@@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

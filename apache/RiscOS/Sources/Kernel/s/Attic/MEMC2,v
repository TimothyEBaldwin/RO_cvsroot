head	4.2;
access;
symbols
	HAL_merge:4.1
	Kernel-5_48:4.1
	Kernel-5_35-4_79_2_327:4.1
	Kernel-5_35-4_79_2_326:4.1
	Kernel-5_35-4_79_2_325:4.1
	Kernel-5_35-4_79_2_324:4.1
	Kernel-5_35-4_79_2_323:4.1
	Kernel-5_35-4_79_2_322:4.1
	Kernel-5_35-4_79_2_321:4.1
	Kernel-5_35-4_79_2_320:4.1
	Kernel-5_35-4_79_2_319:4.1
	Kernel-5_35-4_79_2_318:4.1
	Kernel-5_35-4_79_2_317:4.1
	Kernel-5_35-4_79_2_316:4.1
	Kernel-5_35-4_79_2_315:4.1
	Kernel-5_35-4_79_2_314:4.1
	Kernel-5_35-4_79_2_313:4.1
	Kernel-5_35-4_79_2_312:4.1
	Kernel-5_35-4_79_2_311:4.1
	Kernel-5_35-4_79_2_310:4.1
	Kernel-5_35-4_79_2_309:4.1
	Kernel-5_35-4_79_2_308:4.1
	Kernel-5_35-4_79_2_307:4.1
	Kernel-5_35-4_79_2_306:4.1
	Kernel-5_35-4_79_2_305:4.1
	Kernel-5_35-4_79_2_304:4.1
	Kernel-5_35-4_79_2_303:4.1
	Kernel-5_35-4_79_2_302:4.1
	Kernel-5_35-4_79_2_301:4.1
	Kernel-5_35-4_79_2_300:4.1
	Kernel-5_35-4_79_2_299:4.1
	Kernel-5_35-4_79_2_298:4.1
	Kernel-5_35-4_79_2_297:4.1
	Kernel-5_35-4_79_2_296:4.1
	Kernel-5_35-4_79_2_295:4.1
	Kernel-5_35-4_79_2_294:4.1
	Kernel-5_35-4_79_2_293:4.1
	Kernel-5_35-4_79_2_292:4.1
	Kernel-5_35-4_79_2_291:4.1
	Kernel-5_35-4_79_2_290:4.1
	Kernel-5_35-4_79_2_289:4.1
	Kernel-5_35-4_79_2_288:4.1
	Kernel-5_35-4_79_2_287:4.1
	Kernel-5_35-4_79_2_286:4.1
	Kernel-5_35-4_79_2_285:4.1
	Kernel-5_35-4_79_2_284:4.1
	Kernel-5_35-4_79_2_283:4.1
	Kernel-5_35-4_79_2_282:4.1
	Kernel-5_35-4_79_2_281:4.1
	Kernel-5_35-4_79_2_280:4.1
	Kernel-5_35-4_79_2_279:4.1
	Kernel-5_35-4_79_2_278:4.1
	Kernel-5_35-4_79_2_277:4.1
	Kernel-5_35-4_79_2_276:4.1
	Kernel-5_35-4_79_2_275:4.1
	Kernel-5_35-4_79_2_274:4.1
	Kernel-5_35-4_79_2_273:4.1
	Kernel-5_35-4_79_2_272:4.1
	Kernel-5_35-4_79_2_271:4.1
	Kernel-5_35-4_79_2_270:4.1
	Kernel-5_35-4_79_2_269:4.1
	Kernel-5_35-4_79_2_268:4.1
	Kernel-5_35-4_79_2_267:4.1
	Kernel-5_35-4_79_2_266:4.1
	Kernel-5_35-4_79_2_265:4.1
	Kernel-5_35-4_79_2_264:4.1
	Kernel-5_35-4_79_2_263:4.1
	Kernel-5_35-4_79_2_262:4.1
	Kernel-5_35-4_79_2_261:4.1
	Kernel-5_35-4_79_2_260:4.1
	Kernel-5_35-4_79_2_259:4.1
	Kernel-5_35-4_79_2_258:4.1
	Kernel-5_35-4_79_2_257:4.1
	Kernel-5_35-4_79_2_256:4.1
	Kernel-5_35-4_79_2_255:4.1
	Kernel-5_35-4_79_2_254:4.1
	Kernel-5_35-4_79_2_253:4.1
	Kernel-5_35-4_79_2_252:4.1
	Kernel-5_35-4_79_2_251:4.1
	Kernel-5_35-4_79_2_250:4.1
	Kernel-5_35-4_79_2_249:4.1
	Kernel-5_35-4_79_2_248:4.1
	Kernel-5_35-4_79_2_247:4.1
	Kernel-5_35-4_79_2_246:4.1
	Kernel-5_35-4_79_2_245:4.1
	Kernel-5_35-4_79_2_244:4.1
	Kernel-5_35-4_79_2_243:4.1
	Kernel-5_35-4_79_2_242:4.1
	Kernel-5_35-4_79_2_241:4.1
	Kernel-5_35-4_79_2_240:4.1
	Kernel-5_35-4_79_2_239:4.1
	Kernel-5_35-4_79_2_238:4.1
	Kernel-5_35-4_79_2_237:4.1
	Kernel-5_35-4_79_2_236:4.1
	Kernel-5_35-4_79_2_235:4.1
	Kernel-5_35-4_79_2_234:4.1
	Kernel-5_35-4_79_2_233:4.1
	Kernel-5_35-4_79_2_232:4.1
	Kernel-5_35-4_79_2_231:4.1
	Kernel-5_35-4_79_2_230:4.1
	Kernel-5_35-4_79_2_229:4.1
	Kernel-5_35-4_79_2_228:4.1
	Kernel-5_35-4_79_2_227:4.1
	Kernel-5_35-4_79_2_226:4.1
	Kernel-5_35-4_79_2_225:4.1
	Kernel-5_35-4_79_2_224:4.1
	Kernel-5_35-4_79_2_223:4.1
	Kernel-5_35-4_79_2_222:4.1
	Kernel-5_35-4_79_2_221:4.1
	Kernel-5_35-4_79_2_220:4.1
	Kernel-5_35-4_79_2_219:4.1
	Kernel-5_35-4_79_2_218:4.1
	Kernel-5_35-4_79_2_217:4.1
	Kernel-5_35-4_79_2_216:4.1
	Kernel-5_35-4_79_2_215:4.1
	Kernel-5_35-4_79_2_214:4.1
	Kernel-5_35-4_79_2_213:4.1
	Kernel-5_35-4_79_2_212:4.1
	Kernel-5_35-4_79_2_211:4.1
	Kernel-5_35-4_79_2_210:4.1
	Kernel-5_35-4_79_2_209:4.1
	Kernel-5_35-4_79_2_208:4.1
	Kernel-5_35-4_79_2_207:4.1
	Kernel-5_35-4_79_2_206:4.1
	Kernel-5_35-4_79_2_205:4.1
	Kernel-5_35-4_79_2_204:4.1
	Kernel-5_35-4_79_2_203:4.1
	Kernel-5_35-4_79_2_202:4.1
	Kernel-5_35-4_79_2_201:4.1
	Kernel-5_35-4_79_2_200:4.1
	Kernel-5_35-4_79_2_199:4.1
	Kernel-5_35-4_79_2_198:4.1
	Kernel-5_35-4_79_2_197:4.1
	Kernel-5_35-4_79_2_196:4.1
	Kernel-5_35-4_79_2_195:4.1
	Kernel-5_35-4_79_2_194:4.1
	Kernel-5_35-4_79_2_193:4.1
	Kernel-5_35-4_79_2_192:4.1
	Kernel-5_35-4_79_2_191:4.1
	Kernel-5_35-4_79_2_190:4.1
	Kernel-5_35-4_79_2_189:4.1
	Kernel-5_35-4_79_2_188:4.1
	Kernel-5_35-4_79_2_187:4.1
	Kernel-5_35-4_79_2_186:4.1
	Kernel-5_35-4_79_2_185:4.1
	Kernel-5_35-4_79_2_184:4.1
	Kernel-5_35-4_79_2_183:4.1
	Kernel-5_35-4_79_2_182:4.1
	Kernel-5_35-4_79_2_181:4.1
	Kernel-5_35-4_79_2_180:4.1
	Kernel-5_35-4_79_2_179:4.1
	Kernel-5_35-4_79_2_178:4.1
	Kernel-5_35-4_79_2_177:4.1
	Kernel-5_35-4_79_2_176:4.1
	Kernel-5_35-4_79_2_175:4.1
	Kernel-5_35-4_79_2_174:4.1
	Kernel-5_35-4_79_2_173:4.1
	Kernel-5_35-4_79_2_172:4.1
	Kernel-5_35-4_79_2_171:4.1
	Kernel-5_35-4_79_2_170:4.1
	Kernel-5_35-4_79_2_169:4.1
	Kernel-5_35-4_79_2_168:4.1
	Kernel-5_35-4_79_2_167:4.1
	Kernel-5_35-4_79_2_166:4.1
	Kernel-5_35-4_79_2_165:4.1
	RPi_merge:4.1
	Kernel-5_35-4_79_2_147_2_23:4.1
	Kernel-5_35-4_79_2_147_2_22:4.1
	Kernel-5_35-4_79_2_147_2_21:4.1
	Kernel-5_35-4_79_2_147_2_20:4.1
	Kernel-5_35-4_79_2_147_2_19:4.1
	Kernel-5_35-4_79_2_147_2_18:4.1
	Kernel-5_35-4_79_2_164:4.1
	Kernel-5_35-4_79_2_163:4.1
	Kernel-5_35-4_79_2_147_2_17:4.1
	Kernel-5_35-4_79_2_147_2_16:4.1
	Kernel-5_35-4_79_2_147_2_15:4.1
	Kernel-5_35-4_79_2_162:4.1
	Kernel-5_35-4_79_2_161:4.1
	Kernel-5_35-4_79_2_147_2_14:4.1
	Kernel-5_35-4_79_2_147_2_13:4.1
	Kernel-5_35-4_79_2_160:4.1
	Kernel-5_35-4_79_2_159:4.1
	Kernel-5_35-4_79_2_158:4.1
	Kernel-5_35-4_79_2_157:4.1
	Kernel-5_35-4_79_2_156:4.1
	Kernel-5_35-4_79_2_147_2_12:4.1
	Kernel-5_35-4_79_2_147_2_11:4.1
	Kernel-5_35-4_79_2_155:4.1
	Kernel-5_35-4_79_2_147_2_10:4.1
	Kernel-5_35-4_79_2_154:4.1
	Kernel-5_35-4_79_2_153:4.1
	Kernel-5_35-4_79_2_147_2_9:4.1
	Kernel-5_35-4_79_2_152:4.1
	Kernel-5_35-4_79_2_151:4.1
	Kernel-5_35-4_79_2_147_2_8:4.1
	Kernel-5_35-4_79_2_147_2_7:4.1
	Kernel-5_35-4_79_2_150:4.1
	Kernel-5_35-4_79_2_147_2_6:4.1
	Kernel-5_35-4_79_2_147_2_5:4.1
	Kernel-5_35-4_79_2_149:4.1
	Kernel-5_35-4_79_2_147_2_4:4.1
	Kernel-5_35-4_79_2_147_2_3:4.1
	Kernel-5_35-4_79_2_148:4.1
	Kernel-5_35-4_79_2_147_2_2:4.1
	Kernel-5_35-4_79_2_147_2_1:4.1
	RPi:4.1.0.16
	RPi_bp:4.1
	Kernel-5_35-4_79_2_98_2_52_2_1:4.1
	alees_Kernel_dev:4.1.0.12
	alees_Kernel_dev_bp:4.1
	Kernel-5_35-4_79_2_147:4.1
	Kernel-5_35-4_79_2_146:4.1
	Kernel-5_35-4_79_2_145:4.1
	Kernel-5_35-4_79_2_144:4.1
	Kernel-5_35-4_79_2_143:4.1
	Kernel-5_35-4_79_2_142:4.1
	Kernel-5_35-4_79_2_141:4.1
	Kernel-5_35-4_79_2_140:4.1
	Kernel-5_35-4_79_2_139:4.1
	Kernel-5_35-4_79_2_138:4.1
	Kernel-5_35-4_79_2_137:4.1
	Kernel-5_35-4_79_2_136:4.1
	Kernel-5_35-4_79_2_135:4.1
	Kernel-5_35-4_79_2_134:4.1
	Kernel-5_35-4_79_2_133:4.1
	Kernel-5_35-4_79_2_132:4.1
	Kernel-5_35-4_79_2_131:4.1
	Kernel-5_35-4_79_2_130:4.1
	Kernel-5_35-4_79_2_129:4.1
	Kernel-5_35-4_79_2_128:4.1
	Kernel-5_35-4_79_2_127:4.1
	Kernel-5_35-4_79_2_126:4.1
	Kernel-5_35-4_79_2_125:4.1
	Kernel-5_35-4_79_2_124:4.1
	Kernel-5_35-4_79_2_123:4.1
	Cortex_merge:4.1
	Kernel-5_35-4_79_2_122:4.1
	Kernel-5_35-4_79_2_98_2_54:4.1
	Kernel-5_35-4_79_2_98_2_53:4.1
	Kernel-5_35-4_79_2_98_2_52:4.1
	Kernel-5_35-4_79_2_98_2_51:4.1
	Kernel-5_35-4_79_2_98_2_50:4.1
	Kernel-5_35-4_79_2_98_2_49:4.1
	Kernel-5_35-4_79_2_98_2_48:4.1
	Kernel-5_35-4_79_2_121:4.1
	Kernel-5_35-4_79_2_98_2_47:4.1
	Kernel-5_35-4_79_2_120:4.1
	Kernel-5_35-4_79_2_98_2_46:4.1
	Kernel-5_35-4_79_2_119:4.1
	Kernel-5_35-4_79_2_98_2_45:4.1
	Kernel-5_35-4_79_2_98_2_44:4.1
	Kernel-5_35-4_79_2_118:4.1
	Kernel-5_35-4_79_2_98_2_43:4.1
	Kernel-5_35-4_79_2_117:4.1
	Kernel-5_35-4_79_2_116:4.1
	Kernel-5_35-4_79_2_98_2_42:4.1
	Kernel-5_35-4_79_2_115:4.1
	Kernel-5_35-4_79_2_98_2_41:4.1
	Kernel-5_35-4_79_2_98_2_40:4.1
	Kernel-5_35-4_79_2_114:4.1
	Kernel-5_35-4_79_2_98_2_39:4.1
	Kernel-5_35-4_79_2_98_2_38:4.1
	Kernel-5_35-4_79_2_113:4.1
	Kernel-5_35-4_79_2_112:4.1
	Kernel-5_35-4_79_2_98_2_37:4.1
	Kernel-5_35-4_79_2_98_2_36:4.1
	Kernel-5_35-4_79_2_98_2_35:4.1
	Kernel-5_35-4_79_2_98_2_34:4.1
	Kernel-5_35-4_79_2_98_2_33:4.1
	Kernel-5_35-4_79_2_98_2_32:4.1
	Kernel-5_35-4_79_2_98_2_31:4.1
	Kernel-5_35-4_79_2_98_2_30:4.1
	Kernel-5_35-4_79_2_98_2_29:4.1
	Kernel-5_35-4_79_2_98_2_28:4.1
	Kernel-5_35-4_79_2_98_2_27:4.1
	Kernel-5_35-4_79_2_98_2_26:4.1
	Kernel-5_35-4_79_2_111:4.1
	Kernel-5_35-4_79_2_98_2_25:4.1
	Kernel-5_35-4_79_2_98_2_24:4.1
	Kernel-5_35-4_79_2_98_2_23:4.1
	Kernel-5_35-4_79_2_110:4.1
	Kernel-5_35-4_79_2_98_2_22:4.1
	Kernel-5_35-4_79_2_109:4.1
	Kernel-5_35-4_79_2_98_2_21:4.1
	Kernel-5_35-4_79_2_98_2_20:4.1
	Kernel-5_35-4_79_2_108:4.1
	Kernel-5_35-4_79_2_107:4.1
	Kernel-5_35-4_79_2_98_2_19:4.1
	Kernel-5_35-4_79_2_98_2_18:4.1
	Kernel-5_35-4_79_2_98_2_17:4.1
	Kernel-5_35-4_79_2_98_2_16:4.1
	Kernel-5_35-4_79_2_98_2_15:4.1
	Kernel-5_35-4_79_2_106:4.1
	Kernel-5_35-4_79_2_105:4.1
	Kernel-5_35-4_79_2_104:4.1
	Kernel-5_35-4_79_2_98_2_14:4.1
	Kernel-5_35-4_79_2_98_2_13:4.1
	Kernel-5_35-4_79_2_98_2_12:4.1
	Kernel-5_35-4_79_2_98_2_11:4.1
	Kernel-5_35-4_79_2_98_2_10:4.1
	Kernel-5_35-4_79_2_98_2_9:4.1
	Kernel-5_35-4_79_2_103:4.1
	Kernel-5_35-4_79_2_102:4.1
	Kernel-5_35-4_79_2_98_2_8:4.1
	Kernel-5_35-4_79_2_98_2_7:4.1
	Kernel-5_35-4_79_2_98_2_6:4.1
	Kernel-5_35-4_79_2_98_2_5:4.1
	Kernel-5_35-4_79_2_98_2_4:4.1
	Kernel-5_35-4_79_2_101:4.1
	Kernel-5_35-4_79_2_100:4.1
	Kernel-5_35-4_79_2_99:4.1
	Kernel-5_35-4_79_2_98_2_3:4.1
	Kernel-5_35-4_79_2_98_2_2:4.1
	Kernel-5_35-4_79_2_98_2_1:4.1
	Cortex:4.1.0.2
	Cortex_bp:4.1
	Kernel-5_35-4_79_2_98:4.1
	Kernel-5_35-4_79_2_97:4.1
	Kernel-5_35-4_79_2_96:4.1
	Kernel-5_35-4_79_2_95:4.1
	Kernel-5_35-4_79_2_94:4.1
	Kernel-5_35-4_79_2_93:4.1
	Kernel-5_35-4_79_2_92:4.1
	Kernel-5_35-4_79_2_91:4.1
	Kernel-5_35-4_79_2_90:4.1
	Kernel-5_35-4_79_2_89:4.1
	Kernel-5_35-4_79_2_88:4.1
	Kernel-5_35-4_79_2_87:4.1
	Kernel-5_35-4_79_2_86:4.1
	Kernel-5_35-4_79_2_85:4.1
	Kernel-5_35-4_79_2_84:4.1
	Kernel-5_35-4_79_2_83:4.1
	Kernel-5_35-4_79_2_82:4.1
	Kernel-5_35-4_79_2_81:4.1
	Kernel-5_35-4_79_2_80:4.1
	Kernel-5_35-4_79_2_79:4.1
	Kernel-5_35-4_79_2_78:4.1
	Kernel-5_35-4_79_2_77:4.1
	RO_5_07:4.1
	Kernel-5_35-4_79_2_76:4.1
	Kernel-5_35-4_79_2_75:4.1
	Kernel-5_35-4_79_2_74:4.1
	Kernel-5_35-4_79_2_73:4.1
	Kernel-5_35-4_79_2_72:4.1
	Kernel-5_35-4_79_2_71:4.1
	Kernel-5_35-4_79_2_70:4.1
	Kernel-5_35-4_79_2_69:4.1
	Kernel-5_35-4_79_2_68:4.1
	Kernel-5_35-4_79_2_67:4.1
	Kernel-5_35-4_79_2_66:4.1
	Kernel-5_35-4_79_2_65:4.1
	Kernel-5_35-4_79_2_64:4.1
	Kernel-5_35-4_79_2_63:4.1
	Kernel-5_35-4_79_2_62:4.1
	Kernel-5_35-4_79_2_61:4.1
	Kernel-5_35-4_79_2_59:4.1
	Kernel-5_35-4_79_2_58:4.1
	Kernel-5_35-4_79_2_57:4.1
	Kernel-5_35-4_79_2_56:4.1
	Kernel-5_35-4_79_2_55:4.1
	Kernel-5_35-4_79_2_54:4.1
	Kernel-5_35-4_79_2_53:4.1
	Kernel-5_35-4_79_2_52:4.1
	Kernel-5_35-4_79_2_51:4.1
	Kernel-5_35-4_79_2_50:4.1
	Kernel-5_35-4_79_2_49:4.1
	Kernel-5_35-4_79_2_48:4.1
	Kernel-5_47:4.1
	Kernel-5_46-4_90_2_1:4.1
	nbingham_Kernel_FastNC_dev_bp:4.1
	nbingham_Kernel_FastNC_dev:4.1.0.14
	Kernel-5_46:4.1
	Kernel-5_45:4.1
	Kernel-5_35-4_79_2_47:4.1
	Kernel-5_35-4_79_2_46:4.1
	Kernel-5_35-4_79_2_45:4.1
	Kernel-5_35-4_79_2_44:4.1
	Kernel-5_35-4_79_2_25_2_2:4.1
	Kernel-5_35-4_79_2_43:4.1
	Kernel-5_35-4_79_2_42:4.1
	Kernel-5_35-4_79_2_41:4.1
	Kernel-5_35-4_79_2_40:4.1
	Kernel-5_35-4_79_2_39:4.1
	Kernel-5_35-4_79_2_38:4.1
	Kernel-5_35-4_79_2_37:4.1
	Kernel-5_35-4_79_2_36:4.1
	Kernel-5_35-4_79_2_35:4.1
	Kernel-5_35-4_79_2_34:4.1
	Kernel-5_35-4_79_2_33:4.1
	Kernel-5_35-4_79_2_32:4.1
	Kernel-5_44:4.1
	Kernel-5_35-4_79_2_25_2_1:4.1
	Kernel-5_43:4.1
	Kernel-5_35-4_79_2_31:4.1
	Kernel-5_35-4_79_2_30:4.1
	Kernel-5_35-4_79_2_29:4.1
	Kernel-5_35-4_79_2_28:4.1
	Kernel-5_35-4_79_2_27:4.1
	Kernel-5_35-4_79_2_26:4.1
	Kernel-5_42:4.1
	Kernel-5_41:4.1
	Kernel-5_40:4.1
	Kernel-5_35-4_79_2_25:4.1
	Kernel-5_35-4_79_2_24:4.1
	Kernel-5_35-4_79_2_23:4.1
	Kernel-5_35-4_79_2_22:4.1
	Kernel-5_35-4_79_2_21:4.1
	Kernel-5_35-4_79_2_20:4.1
	Kernel-5_35-4_79_2_19:4.1
	Kernel-5_35-4_79_2_18:4.1
	Kernel-5_35-4_79_2_17:4.1
	Kernel-5_35-4_79_2_16:4.1
	Kernel-5_35-4_79_2_15:4.1
	Kernel-5_35-4_79_2_14:4.1
	Kernel-5_39:4.1
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.10
	Kernel-5_38:4.1
	Kernel-5_35-4_79_2_13:4.1
	Kernel-5_35-4_79_2_12:4.1
	Kernel-5_35-4_79_2_11:4.1
	Kernel-5_37:4.1
	Kernel-5_35-4_79_2_10:4.1
	Kernel-5_35-4_79_2_9:4.1
	Kernel-5_36:4.1
	Kernel-5_35-4_79_2_8:4.1
	Kernel-5_35-4_79_2_7:4.1
	Kernel-5_35-4_79_2_6:4.1
	Kernel-5_35-4_79_2_5:4.1
	Kernel-5_35-4_79_2_4:4.1
	Kernel-5_35-4_79_2_3:4.1
	Kernel-5_35-4_79_2_2:4.1
	dellis_autobuild_BaseSW:4.1
	Kernel-5_35-4_79_2_1:4.1
	HAL:4.1.0.8
	Kernel-5_35:4.1
	Kernel-5_34:4.1
	Kernel-5_33:4.1
	Kernel-5_32:4.1
	Kernel-5_31:4.1
	Kernel-5_30:4.1
	Kernel-5_29:4.1
	Kernel-5_28:4.1
	Kernel-5_27:4.1
	Kernel-5_26:4.1
	Kernel-5_25:4.1
	Kernel-5_24:4.1
	Kernel-5_23:4.1
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.1
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	Kernel-4_84:4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	afrost_Boca-1_2-Beta:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	2016.06.30.20.28.56;	author jlee;	state dead;
branches;
next	4.1;
commitid	lMnWzoE9eJz3Wwcz;

4.1
date	96.11.05.09.41.20;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.41.20;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.31;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.33.15;	author mstphens;	state dead;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.14;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.39;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > MEMC2

; MEMC interface file - MEMC2 version

; Created by TMD 10-Aug-90

PhysRAML2PT * &02000000 + (512+64)*1024

; Synonyms

VInit                   *       MEMC2Address + MEMC2_VINITe
VStart                  *       MEMC2Address + MEMC2_VSTRTe
VEnd                    *       MEMC2Address + MEMC2_VENDe
CInit                   *       MEMC2Address + MEMC2_CINIT

; *****************************************************************************
;
;       SetDAG - Program DMA address generator R1 with physical address R0
;
; in:   r0 = physical address
;       r1 = index of DMA address generator to program, as defined in vdudecl
;
; out:  All registers preserved, operation ignored if illegal
;

SetDAG  ENTRY   "r0,r1"
        CMP     r1, #MEMCDAG_MaxReason
        EXIT    HI
        ADR     r14, DAGAddressTable
        LDR     r14, [r14, r1, LSL #2]          ; load base address in MEMC2
        MOV     r1, r0, LSR #16                 ; r1 is top 16 bits
        EOR     r0, r0, r1, LSL #16             ; and r0 is bottom 16 bits
        BIC     r0, r0, #&0F                    ; bits 0..3 must be clear
        BIC     r1, r1, #&F000                  ; and bits 28..31 must be clear
        STMIA   r14, {r0, r1}                   ; atomic update (we believe)
        EXIT

        GBLA    DAGIndex
DAGIndex SETA   0

        MACRO
        DAGTab  $reason, $address
        ASSERT  ($reason)=DAGIndex
        &       $address
DAGIndex SETA   DAGIndex + 1
        MEND

DAGAddressTable
        DAGTab  MEMCDAG_VInit, VInit
        DAGTab  MEMCDAG_VStart, VStart
        DAGTab  MEMCDAG_VEnd, VEnd
        DAGTab  MEMCDAG_CInit, CInit

; **************** CAM manipulation utility routines ***********************************

; **************************************************************************************
;
;       BangCamUpdate - Update CAM entry and soft copy
;
; This part of the routine has to do more work on MEMC2
;
; First look in the CamEntries table to find the logical address L this physical page is
; currently allocated to. Then check in the Level 2 page tables to see if page L is currently
; at page R2. If it is, then map page L to be inaccessible, otherwise leave page L alone.
; Then map logical page R3 to physical page R2.
;
; in:   r2 = physical page number
;       r3 = logical address
;       r9 = current MEMC1 control register (irrelevant on MEMC2)
;       r11 = PPL
;
; out:  r0, r1, r4, r6 corrupted
;       r2, r3, r5, r7-r12 preserved
;
; NB Use of stack is allowed in this routine

BangCamUpdate ROUT
        MOV     r1, #0
        LDR     r1, [r1, #CamEntriesPointer]
        LDR     r0, [r1, r2, LSL #2]            ; r0 = current logaddress + PPL for phys page r2
        ORR     r4, r3, r11, LSL #28            ; new entry for CamEntries
        STR     r4, [r1, r2, LSL #2]            ; update

        BIC     r0, r0, #&F0000000              ; just get logical address
        LDR     r1, =PhysRAML2PT                ; point to page tables
        LDR     r4, [r1, r0, LSR #11]           ; get physical page + PPL for this logical page
        TEQ     r2, r4, LSR #3                  ; see if still there
        BNE     %FT10                           ; if not there, then just put in new page

        Push    "r3, r14"
        MOV     r3, r0                          ; map out old page at this logical address
        MOV     r0, #0                          ; physical page 0 but PPL(MEMC2)=0 ie no access, not even for me!
        BL      BangL2PT                        ; map page out
        Pull    "r3, r14"
10

;       and drop thru to ...

; **************************************************************************************
;
;       BangCam - Update CAM entry, but not soft copy
;
; This routine maps a physical page to a given logical address
; For MEMC2, I assume that the physical page was previously not mapped
; anywhere else - on MEMC1 it would automatically unmap any logical
; address that the physical page was previously at, but on MEMC2 it won't
;
; in:   r2 = physical page number
;       r3 = logical address
;       r9 = current MEMC1 control register (irrelevant on MEMC2)
;       r11 = PPL
;
; out:  r0, r1, r4, r6 corrupted
;       r2, r3, r5, r7-r12 preserved
;
; NB Can't use stack - there might not be one!

BangCam
        ADR     r0, PPLTrans            ; translate MEMC1 PPL to MEMC2 PPL
        LDRB    r0, [r0, r11]
        ORR     r0, r0, r2, LSL #3      ; value to store in level 2 page table
                                        ; is PPL :OR: (phys page number << 3)
        
        LDR     r1, =PhysRAML2PT        ; point to level 2 page tables

BangL2PT                                ; internal entry point used only by BangCamUpdate
        BICS    r4, r3, #(3 :SHL: 11)   ; ensure going to be on word boundary (EQ => logical page zero)
        STR     r0, [r1, r4, LSR #11]   ; update level 2 page table

        MOV     r6, #MEMC2Address
        STREQ   r0, [r6, #MEMC2_SuperPageZero] ; if logical page 0 then update special entry

        MOV     r0, #0                  ; now flush the TLB
        STR     r0, [r6, #MEMC2_Flush]

        MOV     pc, lr

PPLTrans
        =       6                       ; R any W any
        =       3                       ; R any W sup
        =       2                       ; R sup W sup
        =       2                       ; R sup W sup

PageSizes
        &       4*1024                  ; 0 is 4K
        &       8*1024                  ; 4 is 8K
        &       16*1024                 ; 8 is 16
        &       32*1024                 ; C is 32

PageShifts
        =       12, 13, 0, 14           ; 1 2 3 4
        =       0,  0,  0, 15           ; 5 6 7 8

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_UpdateMEMC: Read/write MEMC1 control register

SSETMEMC ROUT

        AND     r10, r0, r1
        MOV     r12, #0
        TEQP    pc, #SVC_mode+I_bit+F_bit
        LDR     r0, [r12, #MEMC_CR_SoftCopy] ; return old value
        BIC     r11, r0, r1
        ORR     r11, r11, R10
        BIC     r11, r11, #&FF000000
        BIC     r11, r11, #&00F00000
        ORR     r11, r11, #MEMCADR
        STR     r11, [r12, #MEMC_CR_SoftCopy]

; We now have to mimic the relevant bits of the MEMC1 control register
;
; bits 0,1 => unused
; bits 2,3 => page size, irrelevant since always 8K
; bits 4,5 => low ROM access time, irrelevant since this has to be fixed
; bits 6,7 => hi  ROM access time, -----------------""------------------
; bits 8,9 => DRAM refresh control, irrelevant (refresh must always be on)
; bit 10   => Video/cursor DMA enable, corresponds to bit venbe of VATT
;              (and possibly bit venbo of IATT for interlaced displays)
;              Unfortunately VATT (and IATT) is a write-only register. Later on
;              we might have a soft copy of these, but for now just write whole
;              register.
; bit 11   => Sound DMA enable, ignore for now
; bit 12   => OS mode, ignore

; Program all of VATT
;
; vdis = 0 (don't disable DMA after one buffer)
; venbe = (bit 10 of r11)
; vrnw = 1 (read from RAM, not write)
; vmske = 0 (no interrupts at end of buffer)

        MOV     r12, # (0 * VATT_vdis) + (0 * VATT_venbe) + (1 * VATT_vrnw) + (0 * VATT_vmske)
        TST     r11, # (1 :SHL: 10)
        ORRNE   r12, r12, # VATT_venbe
        MOV     r10, #MEMC2Address
        STR     r12, [r10, #MEMC2_VATT]

        TEQP    pc, #SVC_mode+I_bit
        ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ClearPhysRAM - Routine to clear "all" memory
;
; While this routine is running, keyboard IRQs may happen. For this reason
; it avoids LogRAM 0..31 (where hardware IRQ vector is) and PhysRAM
; 0..31 where the IRQ workspace is.
;
; On MEMC2 it also has to avoid the pages where the level 2 page tables are
;
; r7 contains memory speed and must be preserved
; r8 contains page size and must be preserved
; r9 contains MEMC control register and must be preserved
;

ClearPhysRAM ROUT
        MOV     r0, #0
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        MOV     r11, #0
        MOV     r4, #PhysRam
        CMP     r13, #512*1024
        ADDEQ   r10, r4, #(512-64)*1024 ; get address that's logram 0
        ADDNE   r10, r4, #512*1024
        ADD     r13, r13, #PhysRam      ; end of memory
        ADD     r12, r4, #PhysRAML2PT-PhysRam
        ADD     r4, r4, #4*8            ; skip minimal startup workspace
10
        CMP     r4, r10
        ADDEQ   r4, r4, #4*8            ; skip physram that's logram 0
        CMP     r4, r12
        ADDEQ   r4, r4, #32*1024        ; skip 32K of L2PT
        STMNEIA r4!, {r0-r3}
        CMP     r4, r13
        BNE     %BT10
        SUB     r13, r13, #PhysRam

        LDR     r0, =OsbyteVars + :INDEX: LastBREAK
        MOV     r1, #&80
        STRB    r1, [r0]                ; flag the fact that RAM cleared
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       InitMEMC - Initialise memory controller
;

InitMEMC ROUT
        MOV     r0, # MEMC2Address
        MOV     r1, # Control_romfast
        STR     r1, [r0, #MEMC2_Control]        ; make ROMS go fast

        ADR     r1, ClockTimingTable            ; initialise CLK block
        LDMIA   r1, {r2-r5}
        ADD     r1, r0, #MEMC2_clkj0
        STMIA   r1, {r2-r5}

        ADR     r1, DRAMTimingTable             ; initialise DRAM block
        LDMIA   r1, {r2-r8}
        ADD     r1, r0, #MEMC2_rwt0
        STMIA   r1, {r2-r8}

        LDR     r1, rtype_value
        STR     r1, [r0, #MEMC2_rtype]

        LDR     r1, refr_value
        STR     r1, [r0, #MEMC2_refr]

        MOV     r1, # (PhysRAML2PT-PhysRam)/(8*1024)            ; level 1 entry (paged) for 0..16M
        MOV     r2, # (PhysRAML2PT+8*1024-PhysRam)/(8*1024)     ; level 1 entry (paged) for 16M..32M
        MOV     r3, # Prot_UrwSRW+(L1D_RAM :SHL: 3)+(L1D_RAM :SHL: 5)+(L1D_RAM :SHL: 7)+(L1D_RAM :SHL: 9)+(0 :SHL: 11)
                                                                ; level 1 entry (direct) for 32M..48M (all RAM, base 0)
        LDR     r4, = Prot_URwSRW+(L1D_IO :SHL: 3)+(L1D_PROG :SHL: 5)+(L1D_ROM :SHL: 7)+(L1D_ROM :SHL: 9)+(0 :SHL: 11)
                                                                ; level 1 entry (direct) for 48M..64M (IO,PROG,ROM,ROM)
        ADD     r5, r0, #MEMC2_Level1+L1_Paged+L1_Sec0
        ADD     r6, r5, #4*2*16                 ; cycle thru all 4 bus masters and (USR,SPV)
        ADD     r7, r5, #(L1_Direct+L1_Sec2)-(L1_Paged+L1_Sec0)
10
        STMIA   r5, {r1,r2}                     ; set up the paged sections 0,1
        STMIA   r7, {r3,r4}                     ; set up the direct sections 2,3
        ADD     r5, r5, #16
        ADD     r7, r7, #16
        TEQ     r5, r6                          ; have we got to the end ?
        BNE     %BT10

; Now turn on the translation, but don't set up the level 2 page tables until later,
; when we know the DRAM multiplex option

        LDR     r1, = Control_ton + Control_l1on + Control_romfast
        STR     r1, [r0, #MEMC2_Control]

; now set up VINC

        MOV     r1, #&10                ; low bits
        MOV     r2, #&00                ; high bits
        ADD     r3, r0, #MEMC2_VINC
        STMIA   r3, {r1,r2}

        MOV     pc, lr

ClockTimingTable
J0      &       &F200   ; 3   / 2
J1      &       &F200   ; 3   / 2
RSPEED  &       &1C00   ; 3   / 3
ISPEED  &       &B800   ; 2.5 / 2.5   

DRAMTimingTable
RWT0    &       &2A320
RRD0    &       &2AC80
RSQ0    &       &0B200
B0Dummy &       0
RWT1    &       &2A320
RRD1    &       &2AC80
RSQ1    &       &0B200

rtype_value     &       &3333   ; Bank Type [x,bank,s1,s0] * 4 ; set largest memory type by default

refr_value      &       &1086   ; Enable refresh, refresh length = 10 hclk ticks, refresh period = 12us   

; -> MemSize

; (non-destructive) algorithm to determine MEMC RAM configuration
;
; Dave Flynn and Alasdair Thomas
; 17-March-87
;
; Spooling checkered by NRaine and SSwales !
; 8MByte check bodged in by APT
;
; NOTE: Routines MemSize and TimeCPU are called by the power-on test software,
; so their specifications MUST not change.
;
; Set MEMC for 32-k page then analyse signature of possible
; external RAM configurations...
; The configurations are:
;
; Ram Size    Page Size    Configuration    (Phys RAM) Signature
;--------------------------------------------------------------------
;  16MByte      32k        4*32*1Mx1         A13,A20,A21,A22,A23,A23.5 distinct
;  16MByte      32k        16*8*256kx4       A13,A20,A21,A22,A23,A23.5 distinct
;
;  12MByte      32k        3*32*1Mx1         A13,A20,A21,A22,A23 OK, A23.5 fail
;  12MByte      32k        12*8*256kx4       A13,A20,A21,A22,A23 OK, A23.5 fail
;
;   8MByte      32k        2*32*1Mx1         A13,A20,A21,A22 distinct, A23 fail
;   8MByte      32k         8*8*256kx4       A13,A20,A21,A22 distinct, A23 fail
; 
;   4Mbyte      32k          32*1Mx1         A13,A21,A20 distinct, A22,A23 fail
;   4Mbyte      32k         4*8*256kx4       A13,A21,A20 distinct, A22,A23 fail
;
;   2Mbyte      32k    expandable 2*8*256kx4 A13,A20 distinct, A21 fails
;   2Mbyte ???  16k      fixed 2*8*256kx4    A13,A21 distinct, A20 fails
;   
;   1Mbyte       8k          32*256kx1       A13,A20 fail, A19,A18,A12 distinct
;   1Mbyte       8k           8*256kx1       A13,A20 fail, A19,A18,A12 distinct
;   1Mbyte       8k          4*8*64kx4       A13,A20 fail, A19,A18,A12 distinct
;
; 512Kbyte       8k    expandable 2*8*64kx4  A13,A20,A19 fail, A12,A18 distinct
; 512Kbyte       4k      fixed 2*8*64kx4     A13,A20,A12 fail, A19,A18 distinct
;
; 256Kbyte       4K           8*64kx4        A13,A20,A12,A18 fail, A21,A19 ok  
; 256Kbyte       4K          32*64kx1        A13,A20,A12,A18 fail, A21,A19 ok  
;

Z_Flag     * &40000000

; MemSize routine... enter with 32K pagesize set
; R0 returns page size
; R1 returns memory size
; R2 returns value set in MEMC
; uses R3-R7

MemSize ROUT
 [ {TRUE}                               ; now work on different configurations, but only bank zero
        MOV     r7, lr

; first find out appropriate rtype value
; initial routine has set DRAM type to 3

        MOV     r0, #PhysRam
        ADD     r1, r0, #A9             ; if A9 ghosts
        BL      DistinctAddresses
        MOVNE   r0, #2_00               ; then type 00
        BNE     %FT10

        ADD     r1, r0, #A11            ; else if A11 ghosts
        BL      DistinctAddresses
        MOVNE   r0, #2_01               ; then type 01
        BNE     %FT10

        ADD     r1, r0, #A12            ; else if A12 ghosts
        BL      DistinctAddresses
        MOVNE   r0, #2_01               ; then type 01
        MOVEQ   r0, #2_11               ; else type 11
10
        LDR     r1, rtype_value
        BIC     r1, r1, #2_11
        ORR     r1, r1, r0
        MOV     r0, #MEMC2Address
        STR     r1, [r0, #MEMC2_rtype]

; having set up the DRAM multiplexing correctly, we can now zap the L2PT
; to no access for any page
                           
        LDR     r1, =PhysRAML2PT
        ADD     r2, r1, #2*8*1024               ; two L2PT tables at the moment
        MOV     r3, #0                          ; page 0, no access
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
15
        STMIA   r1!,{r3-r6}
        TEQ     r1, r2
        BNE     %BT15

        STR     r3, [r0, #MEMC2_SuperPageZero]  ; don't forget super page zero

; now find out the memory size

        MOV     r0, #PhysRam
        MOV     r6, #256*1024
20
        ADD     r1, r0, r6
        BL      DistinctAddresses       ; try next address line
        BNE     %FT30                   ; if ghosts or not there then finish
        MOV     r6, r6, LSL #1
        CMP     r6, #16*1024*1024       ; give up if we've got 16MBytes or more
        BCC     %BT20
30
        MOV     r1, r6
        LDR     r2, ResetMemC_Value
        BIC     r2, r2, #&C
        ORR     r2, r2, #Page8K
        MOV     r0, #8*1024             ; fixed 8K page size
        MOV     pc, r7
 |
        MOV     r7, lr
        MOV     r0, #PhysRam
        ADD     r1, r0, #A13
        BL      DistinctAddresses
        BNE     %10
        ADD     r1, r0, #A21
        BL      DistinctAddresses
        MOVNE   r0, #Page32K
        MOVNE   r1, #2048*1024
        BNE     MemSizeDone

        MOV     r0, #PhysRam
        ADD     r1, r0, #4*1024*1024
        BL      DistinctAddresses
        MOVNE   r0, #Page32K
        MOVNE   r1, #4*1024*1024
        BNE     MemSizeDone

        MOV     r0, #PhysRam
        ADD     r1, r0, #8*1024*1024
        BL      DistinctAddresses
        MOVNE   r0, #Page32K
        MOVNE   r1, #8*1024*1024
        BNE     MemSizeDone

        MOV     r0, #PhysRam
        ADD     r1, r0, #12*1024*1024
        BL      DistinctAddresses
        MOV     r0, #Page32K
        MOVNE   r1, #12*1024*1024
        MOVEQ   r1, #16*1024*1024
        B       MemSizeDone

10      ADD     r1, r0, #A20
        BL      DistinctAddresses
        BNE     %20
        MOV     r0, #Page16K
        MOV     r1, #2048*1024
        B       MemSizeDone

20      ADD     r1, r0, #A19
        BL      DistinctAddresses
        BEQ     %30
        MOV     r0, #Page8K
        MOV     r1, #512*1024
        B       MemSizeDone

30      ADD     r1, r0, #A18
        BL      DistinctAddresses
        BEQ     %40
        MOV     r0, #Page4K
        MOV     r1, #256*1024
        B       MemSizeDone

40      ADD     r1, r0, #A12
        BL      DistinctAddresses
        BEQ     %50
        MOV     r0, #Page4K
        MOV     r1, #512*1024
        B       MemSizeDone

50      MOV     r0, #Page8K
        MOV     r1, #1024*1024

MemSizeDone
        LDR     r2, ResetMemC_Value
        BIC     r2, r2, #&C
        ORR     r2, r2, r0
        STR     r2, [r2]                        ; set MEMC to right state
        MOV     pc, r7

 ]

; DistinctAddresses routine...
; r0,r1 are the addresses to check
; uses r2-5
; writes interleaved patterns (to prevent dynamic storage...)
; checks writing every bit low and high...
; return Z-flag set if distinct

DistinctAddresses ROUT
        LDR     r2, [r0] ; preserve
        LDR     r3, [r1]
        LDR     r4, Pattern
        STR     r4, [r0] ; mark first
        MOV     r5, r4, ROR #16
        STR     r5, [r1] ; mark second
        LDR     r5, [r0]
        CMP     r5, r4 ; check first
        BNE     %10    ; exit with Z clear
        LDR     r5, [r1] ; check second
        CMP     r5, r4, ROR #16 ; clear Z if not same
        BNE     %10
; now check inverse bit writes
        STR     r4, [r1] ; mark second
        MOV     r5, r4, ROR #16
        STR     r5, [r0] ; mark first
        LDR     r5, [r1]
        CMP     r5, r4 ; check second
        BNE     %10   ; exit with Z clear
        LDR     r5, [r0] ; check first
        CMP     r5, r4, ROR #16 ; clear Z if not same
10      STR     r3, [r1] ; restore
        STR     r2, [r0]
        ORREQ   lr, lr, #Z_Flag
        BICNE   lr, lr, #Z_Flag
        MOVS    pc, lr

Pattern
        &       &AAFF5500 ; shiftable bit check pattern

; init state with masked out page size

ResetMemC_Value
        & &E010C :OR: MEMCADR       ; slugged ROMs + flyback refresh only + 32K page

; Constants
;
A0      *       1 :SHL: 00
A1      *       1 :SHL: 01
A2      *       1 :SHL: 02
A3      *       1 :SHL: 03
A4      *       1 :SHL: 04
A5      *       1 :SHL: 05
A6      *       1 :SHL: 06
A7      *       1 :SHL: 07
A8      *       1 :SHL: 08
A9      *       1 :SHL: 09
A10     *       1 :SHL: 10
A11     *       1 :SHL: 11
A12     *       1 :SHL: 12
A13     *       1 :SHL: 13
A14     *       1 :SHL: 14
A15     *       1 :SHL: 15
A16     *       1 :SHL: 16
A17     *       1 :SHL: 17
A18     *       1 :SHL: 18
A19     *       1 :SHL: 19
A20     *       1 :SHL: 20
A21     *       1 :SHL: 21
A22     *       1 :SHL: 22
A23     *       1 :SHL: 23
A24     *       1 :SHL: 24
A25     *       1 :SHL: 25
A26     *       1 :SHL: 26
A27     *       1 :SHL: 27
A28     *       1 :SHL: 28
A29     *       1 :SHL: 29
A30     *       1 :SHL: 30
A31     *       1 :SHL: 31

Page32K * &C ; in MEMC control reg patterns...
Page16K * &8
Page8K  * &4
Page4K  * &0


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0-r6 trashable
;       r9 = Current MEMC CR

; Out   r9 MEMC value with slowest ROM speed, correct pagesize
;       r7 processor speed in kHz, bit 16 => can do STM to I/O (ie MEMC1a, MEMC2), bit 17 => MEMC2

ncpuloops * 1024 ; don't go longer than 4ms without refresh !
nmulloops * 128

TimeCPU ROUT
 [ {TRUE}
;       fudge it for now
        LDR     r7, =6000 + (3 :SHL: 16) ; pretend 6MHz system, and MEMC2
        MOV     pc, lr
 |
        BIC     r9, r9, #3 :SHL: 8
        STR     r9, [r9]                ; turn off refresh for a bit

; Time CPU/Memory speed

        LDR     r1, =&7FFE              ; 32K @@ 2MHz = ~16ms limit
        MOV     r3, #IOC

        MOV     r0, r1, LSR #8
        STRB    r1, [r3, #Timer1LL]
        STRB    r0, [r3, #Timer1LH]
        LDR     r0, =ncpuloops
        STRB    r0, [r3, #Timer1GO]     ; start the timer NOW
        B       %FT10                   ; Looks superfluous, but is required
                                        ; to get ncpuloops pipeline breaks

10      SUBS    r0, r0, #1              ; 1S
        BNE     %BT10                   ; 1N + 2S

        STRB    r0, [r3, #Timer1LR]     ; latch count NOW
        LDRB    r2, [r3, #Timer1CL]
        LDRB    r0, [r3, #Timer1CH]
        ADD     r2, r2, r0, LSL #8      ; count after looping is ...

        SUB     r2, r1, r2              ; decrements !
        MOV     r2, r2, LSR #1          ; IOC clock decrements at 2MHz

; Time CPU/MEMC Multiply time

        MOV     r4, #-1                 ; Gives worst case MUL

        MOV     r0, r1, LSR #8
        STRB    r1, [r3, #Timer1LL]
        STRB    r0, [r3, #Timer1LH]
        LDR     r0, =nmulloops
        STRB    r0, [r3, #Timer1GO]     ; start the timer NOW
        B       %FT20                   ; Looks superfluous, but is required
                                        ; to get nmulloops pipeline breaks

20      MUL     r5, r4, r4              ; 1S + 16I
        MUL     r5, r4, r4              ; 1S + 16I
        SUBS    r0, r0, #1              ; 1S
        BNE     %BT20                   ; 1N + 2S

        STRB    r0, [r3, #Timer1LR]     ; latch count NOW
        LDRB    r4, [r3, #Timer1CL]
        LDRB    r0, [r3, #Timer1CH]
        ADD     r4, r4, r0, LSL #8      ; count after looping is ...

        SUB     r4, r1, r4              ; decrements !
        MOV     r4, r4, LSR #1          ; IOC clock decrements at 2MHz

        ORR     r9, r9, #1 :SHL: 8      ; set refresh on flyback
        STR     r9, [r9]                ; restore MEMC state a.s.a.p.

; In ROM - each cpu loop took 4R cycles @@ 8/f*500ns/cycle

        LDR     r0, =4*(8*500/1000)*ncpuloops*1000
        DivRem  r7, r0, r2, r1          ; r2 preserved
        MOV     r0, #&80                ; At 8 MHz and below, run fast ROMs
        LDR     r1, =8050               ; Over 8 MHz, need medium ROMs
        CMP     r7, r1
        MOVHI   r0, #&40
        LDR     r1, =13000              ; Over 13 MHz, need slowest ROMs
        CMP     r7, r1
        MOVHI   r0, #&00
        ORR     r9, r9, r0
        STR     r9, [r9]                ; Set ROM speed appropriately

 ASSERT ncpuloops = 8*nmulloops ; for given ratio cutoff <------------

        MOV     r4, r4, LSL #10         ; *1024 to get resolution on divide
        DivRem  r0, r4, r2, r1
        LDR     r1, =1100               ; Cutoff point; MEMC1 longer than this
        CMP     r0, r1
        ORRLO   r7, r7, #1 :SHL: 16     ; Note MEMC1a prescence

        MOV     pc, lr

; Typical figures give (in ROM at 8MHz):

; MEMC1  2048 CPU, 2432 MEMC -> MUL ratio 1216
; MEMC1a 2048       864                    432

 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        END
@


4.1
log
@Initial revision
@
text
@@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

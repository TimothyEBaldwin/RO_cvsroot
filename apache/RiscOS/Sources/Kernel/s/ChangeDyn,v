head	4.26;
access;
symbols
	Kernel-6_14:4.26
	Kernel-6_01-3:4.25
	Kernel-6_13:4.26
	Kernel-6_12:4.26
	Kernel-6_11:4.26
	Kernel-6_10:4.26
	Kernel-6_09:4.26
	Kernel-6_08-4_129_2_10:4.24.2.2
	Kernel-6_08-4_129_2_9:4.24.2.2
	Kernel-6_08:4.26
	Kernel-6_07:4.25
	Kernel-6_06:4.25
	Kernel-6_05-4_129_2_8:4.24.2.1
	Kernel-6_05:4.25
	Kernel-6_04:4.25
	Kernel-6_03:4.25
	Kernel-6_01-2:4.25
	Kernel-6_01-4_146_2_1:4.25
	Kernel-6_02:4.25
	Kernel-6_01-1:4.25
	Kernel-6_01:4.25
	Kernel-6_00:4.25
	Kernel-5_99:4.24
	Kernel-5_98:4.24
	Kernel-5_97-4_129_2_7:4.24
	Kernel-5_97:4.24
	Kernel-5_96:4.24
	Kernel-5_95:4.24
	Kernel-5_94:4.24
	Kernel-5_93:4.24
	Kernel-5_92:4.24
	Kernel-5_91:4.24
	Kernel-5_90:4.24
	Kernel-5_89-4_129_2_6:4.24
	Kernel-5_89:4.24
	Kernel-5_88-4_129_2_5:4.24
	Kernel-5_88-4_129_2_4:4.24
	Kernel-5_88:4.24
	Kernel-5_87:4.24
	Kernel-5_86-4_129_2_3:4.24
	Kernel-5_86-4_129_2_2:4.24
	Kernel-5_86-4_129_2_1:4.24
	Kernel-5_86:4.24
	SMP:4.24.0.2
	SMP_bp:4.24
	Kernel-5_85:4.24
	Kernel-5_54-1:4.13
	Kernel-5_84:4.24
	Kernel-5_83:4.24
	Kernel-5_82:4.24
	Kernel-5_81:4.24
	Kernel-5_80:4.24
	Kernel-5_79:4.24
	Kernel-5_78:4.24
	Kernel-5_77:4.24
	Kernel-5_76:4.24
	Kernel-5_75:4.23
	Kernel-5_74:4.23
	Kernel-5_73:4.23
	Kernel-5_72:4.23
	Kernel-5_71:4.23
	Kernel-5_70:4.22
	Kernel-5_69:4.21
	Kernel-5_68:4.20
	Kernel-5_67:4.20
	Kernel-5_66:4.19
	Kernel-5_65:4.18
	Kernel-5_64:4.18
	Kernel-5_63:4.18
	Kernel-5_62:4.18
	Kernel-5_61:4.18
	Kernel-5_60:4.18
	Kernel-5_59:4.17
	Kernel-5_58:4.16
	Kernel-5_57:4.15
	Kernel-5_56:4.14
	Kernel-5_55:4.14
	Kernel-5_54:4.13
	Kernel-5_53:4.13
	Kernel-5_52:4.13
	Kernel-5_51:4.13
	Kernel-5_50:4.12
	Kernel-5_49:4.12
	HAL_merge:4.9.2.38
	Kernel-5_48:4.11
	Kernel-5_35-4_79_2_327:4.9.2.38
	Kernel-5_35-4_79_2_326:4.9.2.38
	Kernel-5_35-4_79_2_325:4.9.2.38
	Kernel-5_35-4_79_2_324:4.9.2.38
	Kernel-5_35-4_79_2_323:4.9.2.37
	Kernel-5_35-4_79_2_322:4.9.2.37
	Kernel-5_35-4_79_2_321:4.9.2.37
	Kernel-5_35-4_79_2_320:4.9.2.37
	Kernel-5_35-4_79_2_319:4.9.2.37
	Kernel-5_35-4_79_2_318:4.9.2.37
	Kernel-5_35-4_79_2_317:4.9.2.37
	Kernel-5_35-4_79_2_316:4.9.2.37
	Kernel-5_35-4_79_2_315:4.9.2.37
	Kernel-5_35-4_79_2_314:4.9.2.37
	Kernel-5_35-4_79_2_313:4.9.2.37
	Kernel-5_35-4_79_2_312:4.9.2.37
	Kernel-5_35-4_79_2_311:4.9.2.37
	Kernel-5_35-4_79_2_310:4.9.2.36
	Kernel-5_35-4_79_2_309:4.9.2.36
	Kernel-5_35-4_79_2_308:4.9.2.36
	Kernel-5_35-4_79_2_307:4.9.2.36
	Kernel-5_35-4_79_2_306:4.9.2.36
	Kernel-5_35-4_79_2_305:4.9.2.35
	Kernel-5_35-4_79_2_304:4.9.2.35
	Kernel-5_35-4_79_2_303:4.9.2.35
	Kernel-5_35-4_79_2_302:4.9.2.35
	Kernel-5_35-4_79_2_301:4.9.2.35
	Kernel-5_35-4_79_2_300:4.9.2.35
	Kernel-5_35-4_79_2_299:4.9.2.35
	Kernel-5_35-4_79_2_298:4.9.2.35
	Kernel-5_35-4_79_2_297:4.9.2.35
	Kernel-5_35-4_79_2_296:4.9.2.35
	Kernel-5_35-4_79_2_295:4.9.2.35
	Kernel-5_35-4_79_2_294:4.9.2.35
	Kernel-5_35-4_79_2_293:4.9.2.35
	Kernel-5_35-4_79_2_292:4.9.2.34
	Kernel-5_35-4_79_2_291:4.9.2.34
	Kernel-5_35-4_79_2_290:4.9.2.33
	Kernel-5_35-4_79_2_289:4.9.2.33
	Kernel-5_35-4_79_2_288:4.9.2.33
	Kernel-5_35-4_79_2_287:4.9.2.33
	Kernel-5_35-4_79_2_286:4.9.2.32
	Kernel-5_35-4_79_2_285:4.9.2.31
	Kernel-5_35-4_79_2_284:4.9.2.30
	Kernel-5_35-4_79_2_283:4.9.2.29
	Kernel-5_35-4_79_2_282:4.9.2.29
	Kernel-5_35-4_79_2_281:4.9.2.29
	Kernel-5_35-4_79_2_280:4.9.2.29
	Kernel-5_35-4_79_2_279:4.9.2.29
	Kernel-5_35-4_79_2_278:4.9.2.29
	Kernel-5_35-4_79_2_277:4.9.2.29
	Kernel-5_35-4_79_2_276:4.9.2.29
	Kernel-5_35-4_79_2_275:4.9.2.29
	Kernel-5_35-4_79_2_274:4.9.2.29
	Kernel-5_35-4_79_2_273:4.9.2.29
	Kernel-5_35-4_79_2_272:4.9.2.28
	Kernel-5_35-4_79_2_271:4.9.2.28
	Kernel-5_35-4_79_2_270:4.9.2.28
	Kernel-5_35-4_79_2_269:4.9.2.28
	Kernel-5_35-4_79_2_268:4.9.2.28
	Kernel-5_35-4_79_2_267:4.9.2.27
	Kernel-5_35-4_79_2_266:4.9.2.26
	Kernel-5_35-4_79_2_265:4.9.2.26
	Kernel-5_35-4_79_2_264:4.9.2.26
	Kernel-5_35-4_79_2_263:4.9.2.26
	Kernel-5_35-4_79_2_262:4.9.2.26
	Kernel-5_35-4_79_2_261:4.9.2.26
	Kernel-5_35-4_79_2_260:4.9.2.26
	Kernel-5_35-4_79_2_259:4.9.2.26
	Kernel-5_35-4_79_2_258:4.9.2.26
	Kernel-5_35-4_79_2_257:4.9.2.26
	Kernel-5_35-4_79_2_256:4.9.2.26
	Kernel-5_35-4_79_2_255:4.9.2.26
	Kernel-5_35-4_79_2_254:4.9.2.25
	Kernel-5_35-4_79_2_253:4.9.2.25
	Kernel-5_35-4_79_2_252:4.9.2.25
	Kernel-5_35-4_79_2_251:4.9.2.25
	Kernel-5_35-4_79_2_250:4.9.2.25
	Kernel-5_35-4_79_2_249:4.9.2.25
	Kernel-5_35-4_79_2_248:4.9.2.25
	Kernel-5_35-4_79_2_247:4.9.2.25
	Kernel-5_35-4_79_2_246:4.9.2.25
	Kernel-5_35-4_79_2_245:4.9.2.25
	Kernel-5_35-4_79_2_244:4.9.2.25
	Kernel-5_35-4_79_2_243:4.9.2.25
	Kernel-5_35-4_79_2_242:4.9.2.25
	Kernel-5_35-4_79_2_241:4.9.2.25
	Kernel-5_35-4_79_2_240:4.9.2.25
	Kernel-5_35-4_79_2_239:4.9.2.25
	Kernel-5_35-4_79_2_238:4.9.2.25
	Kernel-5_35-4_79_2_237:4.9.2.25
	Kernel-5_35-4_79_2_236:4.9.2.25
	Kernel-5_35-4_79_2_235:4.9.2.25
	Kernel-5_35-4_79_2_234:4.9.2.25
	Kernel-5_35-4_79_2_233:4.9.2.25
	Kernel-5_35-4_79_2_232:4.9.2.25
	Kernel-5_35-4_79_2_231:4.9.2.25
	Kernel-5_35-4_79_2_230:4.9.2.25
	Kernel-5_35-4_79_2_229:4.9.2.25
	Kernel-5_35-4_79_2_228:4.9.2.25
	Kernel-5_35-4_79_2_227:4.9.2.25
	Kernel-5_35-4_79_2_226:4.9.2.25
	Kernel-5_35-4_79_2_225:4.9.2.25
	Kernel-5_35-4_79_2_224:4.9.2.25
	Kernel-5_35-4_79_2_223:4.9.2.25
	Kernel-5_35-4_79_2_222:4.9.2.25
	Kernel-5_35-4_79_2_221:4.9.2.24
	Kernel-5_35-4_79_2_220:4.9.2.24
	Kernel-5_35-4_79_2_219:4.9.2.24
	Kernel-5_35-4_79_2_218:4.9.2.24
	Kernel-5_35-4_79_2_217:4.9.2.24
	Kernel-5_35-4_79_2_216:4.9.2.24
	Kernel-5_35-4_79_2_215:4.9.2.24
	Kernel-5_35-4_79_2_214:4.9.2.24
	Kernel-5_35-4_79_2_213:4.9.2.24
	Kernel-5_35-4_79_2_212:4.9.2.24
	Kernel-5_35-4_79_2_211:4.9.2.24
	Kernel-5_35-4_79_2_210:4.9.2.24
	Kernel-5_35-4_79_2_209:4.9.2.24
	Kernel-5_35-4_79_2_208:4.9.2.24
	Kernel-5_35-4_79_2_207:4.9.2.24
	Kernel-5_35-4_79_2_206:4.9.2.24
	Kernel-5_35-4_79_2_205:4.9.2.24
	Kernel-5_35-4_79_2_204:4.9.2.24
	Kernel-5_35-4_79_2_203:4.9.2.23
	Kernel-5_35-4_79_2_202:4.9.2.23
	Kernel-5_35-4_79_2_201:4.9.2.23
	Kernel-5_35-4_79_2_200:4.9.2.23
	Kernel-5_35-4_79_2_199:4.9.2.23
	Kernel-5_35-4_79_2_198:4.9.2.23
	Kernel-5_35-4_79_2_197:4.9.2.23
	Kernel-5_35-4_79_2_196:4.9.2.23
	Kernel-5_35-4_79_2_195:4.9.2.23
	Kernel-5_35-4_79_2_194:4.9.2.23
	Kernel-5_35-4_79_2_193:4.9.2.23
	Kernel-5_35-4_79_2_192:4.9.2.23
	Kernel-5_35-4_79_2_191:4.9.2.23
	Kernel-5_35-4_79_2_190:4.9.2.23
	Kernel-5_35-4_79_2_189:4.9.2.23
	Kernel-5_35-4_79_2_188:4.9.2.23
	Kernel-5_35-4_79_2_187:4.9.2.23
	Kernel-5_35-4_79_2_186:4.9.2.23
	Kernel-5_35-4_79_2_185:4.9.2.22
	Kernel-5_35-4_79_2_184:4.9.2.22
	Kernel-5_35-4_79_2_183:4.9.2.22
	Kernel-5_35-4_79_2_182:4.9.2.22
	Kernel-5_35-4_79_2_181:4.9.2.22
	Kernel-5_35-4_79_2_180:4.9.2.22
	Kernel-5_35-4_79_2_179:4.9.2.22
	Kernel-5_35-4_79_2_178:4.9.2.22
	Kernel-5_35-4_79_2_177:4.9.2.22
	Kernel-5_35-4_79_2_176:4.9.2.22
	Kernel-5_35-4_79_2_175:4.9.2.22
	Kernel-5_35-4_79_2_174:4.9.2.22
	Kernel-5_35-4_79_2_173:4.9.2.21
	Kernel-5_35-4_79_2_172:4.9.2.21
	Kernel-5_35-4_79_2_171:4.9.2.21
	Kernel-5_35-4_79_2_170:4.9.2.21
	Kernel-5_35-4_79_2_169:4.9.2.21
	Kernel-5_35-4_79_2_168:4.9.2.21
	Kernel-5_35-4_79_2_167:4.9.2.21
	Kernel-5_35-4_79_2_166:4.9.2.21
	Kernel-5_35-4_79_2_165:4.9.2.21
	RPi_merge:4.9.2.21
	Kernel-5_35-4_79_2_147_2_23:4.9.2.21
	Kernel-5_35-4_79_2_147_2_22:4.9.2.21
	Kernel-5_35-4_79_2_147_2_21:4.9.2.21
	Kernel-5_35-4_79_2_147_2_20:4.9.2.21
	Kernel-5_35-4_79_2_147_2_19:4.9.2.21
	Kernel-5_35-4_79_2_147_2_18:4.9.2.21
	Kernel-5_35-4_79_2_164:4.9.2.21
	Kernel-5_35-4_79_2_163:4.9.2.21
	Kernel-5_35-4_79_2_147_2_17:4.9.2.21
	Kernel-5_35-4_79_2_147_2_16:4.9.2.21
	Kernel-5_35-4_79_2_147_2_15:4.9.2.21
	Kernel-5_35-4_79_2_162:4.9.2.21
	Kernel-5_35-4_79_2_161:4.9.2.21
	Kernel-5_35-4_79_2_147_2_14:4.9.2.21
	Kernel-5_35-4_79_2_147_2_13:4.9.2.21
	Kernel-5_35-4_79_2_160:4.9.2.21
	Kernel-5_35-4_79_2_159:4.9.2.21
	Kernel-5_35-4_79_2_158:4.9.2.21
	Kernel-5_35-4_79_2_157:4.9.2.21
	Kernel-5_35-4_79_2_156:4.9.2.21
	Kernel-5_35-4_79_2_147_2_12:4.9.2.21
	Kernel-5_35-4_79_2_147_2_11:4.9.2.21
	Kernel-5_35-4_79_2_155:4.9.2.21
	Kernel-5_35-4_79_2_147_2_10:4.9.2.21
	Kernel-5_35-4_79_2_154:4.9.2.21
	Kernel-5_35-4_79_2_153:4.9.2.21
	Kernel-5_35-4_79_2_147_2_9:4.9.2.21
	Kernel-5_35-4_79_2_152:4.9.2.21
	Kernel-5_35-4_79_2_151:4.9.2.21
	Kernel-5_35-4_79_2_147_2_8:4.9.2.21
	Kernel-5_35-4_79_2_147_2_7:4.9.2.21
	Kernel-5_35-4_79_2_150:4.9.2.21
	Kernel-5_35-4_79_2_147_2_6:4.9.2.21
	Kernel-5_35-4_79_2_147_2_5:4.9.2.21
	Kernel-5_35-4_79_2_149:4.9.2.21
	Kernel-5_35-4_79_2_147_2_4:4.9.2.21
	Kernel-5_35-4_79_2_147_2_3:4.9.2.21
	Kernel-5_35-4_79_2_148:4.9.2.21
	Kernel-5_35-4_79_2_147_2_2:4.9.2.21
	Kernel-5_35-4_79_2_147_2_1:4.9.2.21
	RPi:4.9.2.21.0.2
	RPi_bp:4.9.2.21
	Kernel-5_35-4_79_2_98_2_52_2_1:4.9.2.18.2.5
	alees_Kernel_dev:4.9.2.18.2.5.0.2
	alees_Kernel_dev_bp:4.9.2.18.2.5
	Kernel-5_35-4_79_2_147:4.9.2.21
	Kernel-5_35-4_79_2_146:4.9.2.21
	Kernel-5_35-4_79_2_145:4.9.2.20
	Kernel-5_35-4_79_2_144:4.9.2.20
	Kernel-5_35-4_79_2_143:4.9.2.20
	Kernel-5_35-4_79_2_142:4.9.2.20
	Kernel-5_35-4_79_2_141:4.9.2.20
	Kernel-5_35-4_79_2_140:4.9.2.20
	Kernel-5_35-4_79_2_139:4.9.2.20
	Kernel-5_35-4_79_2_138:4.9.2.20
	Kernel-5_35-4_79_2_137:4.9.2.20
	Kernel-5_35-4_79_2_136:4.9.2.20
	Kernel-5_35-4_79_2_135:4.9.2.20
	Kernel-5_35-4_79_2_134:4.9.2.20
	Kernel-5_35-4_79_2_133:4.9.2.20
	Kernel-5_35-4_79_2_132:4.9.2.20
	Kernel-5_35-4_79_2_131:4.9.2.20
	Kernel-5_35-4_79_2_130:4.9.2.20
	Kernel-5_35-4_79_2_129:4.9.2.20
	Kernel-5_35-4_79_2_128:4.9.2.20
	Kernel-5_35-4_79_2_127:4.9.2.20
	Kernel-5_35-4_79_2_126:4.9.2.20
	Kernel-5_35-4_79_2_125:4.9.2.20
	Kernel-5_35-4_79_2_124:4.9.2.20
	Kernel-5_35-4_79_2_123:4.9.2.20
	Cortex_merge:4.9.2.18.2.6
	Kernel-5_35-4_79_2_122:4.9.2.19
	Kernel-5_35-4_79_2_98_2_54:4.9.2.18.2.6
	Kernel-5_35-4_79_2_98_2_53:4.9.2.18.2.6
	Kernel-5_35-4_79_2_98_2_52:4.9.2.18.2.5
	Kernel-5_35-4_79_2_98_2_51:4.9.2.18.2.5
	Kernel-5_35-4_79_2_98_2_50:4.9.2.18.2.5
	Kernel-5_35-4_79_2_98_2_49:4.9.2.18.2.5
	Kernel-5_35-4_79_2_98_2_48:4.9.2.18.2.5
	Kernel-5_35-4_79_2_121:4.9.2.19
	Kernel-5_35-4_79_2_98_2_47:4.9.2.18.2.4
	Kernel-5_35-4_79_2_120:4.9.2.19
	Kernel-5_35-4_79_2_98_2_46:4.9.2.18.2.4
	Kernel-5_35-4_79_2_119:4.9.2.19
	Kernel-5_35-4_79_2_98_2_45:4.9.2.18.2.4
	Kernel-5_35-4_79_2_98_2_44:4.9.2.18.2.4
	Kernel-5_35-4_79_2_118:4.9.2.19
	Kernel-5_35-4_79_2_98_2_43:4.9.2.18.2.4
	Kernel-5_35-4_79_2_117:4.9.2.19
	Kernel-5_35-4_79_2_116:4.9.2.19
	Kernel-5_35-4_79_2_98_2_42:4.9.2.18.2.4
	Kernel-5_35-4_79_2_115:4.9.2.19
	Kernel-5_35-4_79_2_98_2_41:4.9.2.18.2.4
	Kernel-5_35-4_79_2_98_2_40:4.9.2.18.2.4
	Kernel-5_35-4_79_2_114:4.9.2.19
	Kernel-5_35-4_79_2_98_2_39:4.9.2.18.2.4
	Kernel-5_35-4_79_2_98_2_38:4.9.2.18.2.4
	Kernel-5_35-4_79_2_113:4.9.2.19
	Kernel-5_35-4_79_2_112:4.9.2.19
	Kernel-5_35-4_79_2_98_2_37:4.9.2.18.2.4
	Kernel-5_35-4_79_2_98_2_36:4.9.2.18.2.4
	Kernel-5_35-4_79_2_98_2_35:4.9.2.18.2.4
	Kernel-5_35-4_79_2_98_2_34:4.9.2.18.2.4
	Kernel-5_35-4_79_2_98_2_33:4.9.2.18.2.4
	Kernel-5_35-4_79_2_98_2_32:4.9.2.18.2.3
	Kernel-5_35-4_79_2_98_2_31:4.9.2.18.2.3
	Kernel-5_35-4_79_2_98_2_30:4.9.2.18.2.3
	Kernel-5_35-4_79_2_98_2_29:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_28:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_27:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_26:4.9.2.18.2.2
	Kernel-5_35-4_79_2_111:4.9.2.19
	Kernel-5_35-4_79_2_98_2_25:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_24:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_23:4.9.2.18.2.2
	Kernel-5_35-4_79_2_110:4.9.2.19
	Kernel-5_35-4_79_2_98_2_22:4.9.2.18.2.2
	Kernel-5_35-4_79_2_109:4.9.2.19
	Kernel-5_35-4_79_2_98_2_21:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_20:4.9.2.18.2.2
	Kernel-5_35-4_79_2_108:4.9.2.19
	Kernel-5_35-4_79_2_107:4.9.2.19
	Kernel-5_35-4_79_2_98_2_19:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_18:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_17:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_16:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_15:4.9.2.18.2.2
	Kernel-5_35-4_79_2_106:4.9.2.19
	Kernel-5_35-4_79_2_105:4.9.2.19
	Kernel-5_35-4_79_2_104:4.9.2.19
	Kernel-5_35-4_79_2_98_2_14:4.9.2.18.2.2
	Kernel-5_35-4_79_2_98_2_13:4.9.2.18.2.1
	Kernel-5_35-4_79_2_98_2_12:4.9.2.18.2.1
	Kernel-5_35-4_79_2_98_2_11:4.9.2.18.2.1
	Kernel-5_35-4_79_2_98_2_10:4.9.2.18.2.1
	Kernel-5_35-4_79_2_98_2_9:4.9.2.18.2.1
	Kernel-5_35-4_79_2_103:4.9.2.18
	Kernel-5_35-4_79_2_102:4.9.2.18
	Kernel-5_35-4_79_2_98_2_8:4.9.2.18.2.1
	Kernel-5_35-4_79_2_98_2_7:4.9.2.18.2.1
	Kernel-5_35-4_79_2_98_2_6:4.9.2.18.2.1
	Kernel-5_35-4_79_2_98_2_5:4.9.2.18.2.1
	Kernel-5_35-4_79_2_98_2_4:4.9.2.18.2.1
	Kernel-5_35-4_79_2_101:4.9.2.18
	Kernel-5_35-4_79_2_100:4.9.2.18
	Kernel-5_35-4_79_2_99:4.9.2.18
	Kernel-5_35-4_79_2_98_2_3:4.9.2.18.2.1
	Kernel-5_35-4_79_2_98_2_2:4.9.2.18
	Kernel-5_35-4_79_2_98_2_1:4.9.2.18
	Cortex:4.9.2.18.0.2
	Cortex_bp:4.9.2.18
	Kernel-5_35-4_79_2_98:4.9.2.18
	Kernel-5_35-4_79_2_97:4.9.2.18
	Kernel-5_35-4_79_2_96:4.9.2.18
	Kernel-5_35-4_79_2_95:4.9.2.18
	Kernel-5_35-4_79_2_94:4.9.2.18
	Kernel-5_35-4_79_2_93:4.9.2.18
	Kernel-5_35-4_79_2_92:4.9.2.18
	Kernel-5_35-4_79_2_91:4.9.2.18
	Kernel-5_35-4_79_2_90:4.9.2.18
	Kernel-5_35-4_79_2_89:4.9.2.18
	Kernel-5_35-4_79_2_88:4.9.2.18
	Kernel-5_35-4_79_2_87:4.9.2.18
	Kernel-5_35-4_79_2_86:4.9.2.18
	Kernel-5_35-4_79_2_85:4.9.2.18
	Kernel-5_35-4_79_2_84:4.9.2.18
	Kernel-5_35-4_79_2_83:4.9.2.18
	Kernel-5_35-4_79_2_82:4.9.2.18
	Kernel-5_35-4_79_2_81:4.9.2.18
	Kernel-5_35-4_79_2_80:4.9.2.18
	Kernel-5_35-4_79_2_79:4.9.2.18
	Kernel-5_35-4_79_2_78:4.9.2.18
	Kernel-5_35-4_79_2_77:4.9.2.18
	RO_5_07:4.9.2.18
	Kernel-5_35-4_79_2_76:4.9.2.18
	Kernel-5_35-4_79_2_75:4.9.2.18
	Kernel-5_35-4_79_2_74:4.9.2.18
	Kernel-5_35-4_79_2_73:4.9.2.18
	Kernel-5_35-4_79_2_72:4.9.2.18
	Kernel-5_35-4_79_2_71:4.9.2.18
	Kernel-5_35-4_79_2_70:4.9.2.18
	Kernel-5_35-4_79_2_69:4.9.2.18
	Kernel-5_35-4_79_2_68:4.9.2.18
	Kernel-5_35-4_79_2_67:4.9.2.18
	Kernel-5_35-4_79_2_66:4.9.2.18
	Kernel-5_35-4_79_2_65:4.9.2.18
	Kernel-5_35-4_79_2_64:4.9.2.18
	Kernel-5_35-4_79_2_63:4.9.2.18
	Kernel-5_35-4_79_2_62:4.9.2.18
	Kernel-5_35-4_79_2_61:4.9.2.18
	Kernel-5_35-4_79_2_59:4.9.2.18
	Kernel-5_35-4_79_2_58:4.9.2.18
	Kernel-5_35-4_79_2_57:4.9.2.18
	Kernel-5_35-4_79_2_56:4.9.2.18
	Kernel-5_35-4_79_2_55:4.9.2.18
	Kernel-5_35-4_79_2_54:4.9.2.18
	Kernel-5_35-4_79_2_53:4.9.2.18
	Kernel-5_35-4_79_2_52:4.9.2.18
	Kernel-5_35-4_79_2_51:4.9.2.18
	Kernel-5_35-4_79_2_50:4.9.2.17
	Kernel-5_35-4_79_2_49:4.9.2.17
	Kernel-5_35-4_79_2_48:4.9.2.17
	Kernel-5_47:4.10
	Kernel-5_46-4_90_2_1:4.10
	nbingham_Kernel_FastNC_dev_bp:4.10
	nbingham_Kernel_FastNC_dev:4.10.0.2
	Kernel-5_46:4.10
	Kernel-5_45:4.10
	Kernel-5_35-4_79_2_47:4.9.2.16
	Kernel-5_35-4_79_2_46:4.9.2.16
	Kernel-5_35-4_79_2_45:4.9.2.16
	Kernel-5_35-4_79_2_44:4.9.2.16
	Kernel-5_35-4_79_2_25_2_2:4.9.2.11
	Kernel-5_35-4_79_2_43:4.9.2.16
	Kernel-5_35-4_79_2_42:4.9.2.16
	Kernel-5_35-4_79_2_41:4.9.2.16
	Kernel-5_35-4_79_2_40:4.9.2.16
	Kernel-5_35-4_79_2_39:4.9.2.16
	Kernel-5_35-4_79_2_38:4.9.2.16
	Kernel-5_35-4_79_2_37:4.9.2.15
	Kernel-5_35-4_79_2_36:4.9.2.14
	Kernel-5_35-4_79_2_35:4.9.2.14
	Kernel-5_35-4_79_2_34:4.9.2.14
	Kernel-5_35-4_79_2_33:4.9.2.14
	Kernel-5_35-4_79_2_32:4.9.2.14
	Kernel-5_44:4.10
	Kernel-5_35-4_79_2_25_2_1:4.9.2.11
	Kernel-5_43:4.10
	Kernel-5_35-4_79_2_31:4.9.2.13
	Kernel-5_35-4_79_2_30:4.9.2.12
	Kernel-5_35-4_79_2_29:4.9.2.12
	Kernel-5_35-4_79_2_28:4.9.2.12
	Kernel-5_35-4_79_2_27:4.9.2.11
	Kernel-5_35-4_79_2_26:4.9.2.11
	Kernel-5_42:4.10
	Kernel-5_41:4.10
	Kernel-5_40:4.10
	Kernel-5_35-4_79_2_25:4.9.2.11
	Kernel-5_35-4_79_2_24:4.9.2.11
	Kernel-5_35-4_79_2_23:4.9.2.11
	Kernel-5_35-4_79_2_22:4.9.2.11
	Kernel-5_35-4_79_2_21:4.9.2.11
	Kernel-5_35-4_79_2_20:4.9.2.11
	Kernel-5_35-4_79_2_19:4.9.2.11
	Kernel-5_35-4_79_2_18:4.9.2.11
	Kernel-5_35-4_79_2_17:4.9.2.11
	Kernel-5_35-4_79_2_16:4.9.2.10
	Kernel-5_35-4_79_2_15:4.9.2.9
	Kernel-5_35-4_79_2_14:4.9.2.9
	Kernel-5_39:4.10
	Kernel-5_13-4_52_2_1:4.7
	Bethany:4.7.0.2
	Kernel-5_38:4.10
	Kernel-5_35-4_79_2_13:4.9.2.9
	Kernel-5_35-4_79_2_12:4.9.2.8
	Kernel-5_35-4_79_2_11:4.9.2.8
	Kernel-5_37:4.10
	Kernel-5_35-4_79_2_10:4.9.2.6
	Kernel-5_35-4_79_2_9:4.9.2.6
	Kernel-5_36:4.10
	Kernel-5_35-4_79_2_8:4.9.2.3
	Kernel-5_35-4_79_2_7:4.9.2.3
	Kernel-5_35-4_79_2_6:4.9.2.3
	Kernel-5_35-4_79_2_5:4.9.2.3
	Kernel-5_35-4_79_2_4:4.9.2.2
	Kernel-5_35-4_79_2_3:4.9.2.2
	Kernel-5_35-4_79_2_2:4.9.2.2
	dellis_autobuild_BaseSW:4.9
	Kernel-5_35-4_79_2_1:4.9.2.1
	HAL:4.9.0.2
	Kernel-5_35:4.9
	Kernel-5_34:4.9
	Kernel-5_33:4.9
	Kernel-5_32:4.9
	Kernel-5_31:4.9
	Kernel-5_30:4.9
	Kernel-5_29:4.9
	Kernel-5_28:4.9
	Kernel-5_27:4.9
	Kernel-5_26:4.9
	Kernel-5_25:4.8
	Kernel-5_24:4.8
	Kernel-5_23:4.8
	Kernel-5_22:4.7
	sbrodie_sedwards_16Mar2000:4.7
	Kernel-5_21:4.7
	Kernel-5_20:4.7
	Kernel-5_19:4.7
	Kernel-5_18:4.7
	Kernel-5_17:4.7
	Kernel-5_16:4.7
	Kernel-5_15:4.7
	Kernel-5_14:4.7
	Kernel-5_13:4.7
	Kernel-5_12:4.7
	Kernel-5_11:4.7
	Kernel-5_10:4.7
	Kernel-5_09:4.7
	Kernel-5_08:4.7
	Kernel-5_07:4.7
	Kernel-5_06:4.7
	Kernel-5_05:4.7
	Kernel-5_04:4.7
	Kernel-5_03:4.7
	Kernel-5_02:4.7
	Kernel-5_01:4.7
	Kernel-5_00:4.7
	Kernel-4_99:4.7
	Kernel-4_98:4.7
	Kernel-4_97:4.7
	Kernel-4_96:4.7
	Kernel-4_95:4.7
	Kernel-4_94:4.7
	Kernel-4_93:4.7
	Kernel-4_92:4.7
	Kernel-4_91:4.7
	Kernel-4_90:4.7
	dcotton_autobuild_BaseSW:4.10
	Kernel-4_89:4.7
	Kernel-4_88:4.7
	Kernel-4_87:4.7
	Kernel-4_86:4.7
	Kernel-4_85:4.7
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.4.4.8.2.1
	Kernel-4_84:4.7
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.4.4.8.2.1
	Ursula_RiscPC_bp:4.4.4.8
	Kernel-4_83:4.6
	Kernel-4_82:4.5
	Kernel-4_81:4.5
	Kernel-4_80:4.5
	Kernel-4_79:4.5
	Kernel-4_78:4.5
	Kernel-4_77:4.5
	Kernel-4_76:4.5
	Kernel-4_75:4.4
	Kernel-4_74:4.4
	Kernel-4_73:4.4
	Kernel-4_72:4.4
	Kernel-4_71:4.4
	Kernel-4_70:4.4
	Kernel-4_69:4.4
	Kernel-4_68:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.4.4.8.2.1
	Ursula_RiscPC:4.4.4.8.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.4
	Kernel-4_66:4.4
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.4
	Ursula_merge:4.4
	Kernel-4_64:4.4
	mstphens_Kernel-3_81:4.4.4.9
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.4.4.8
	UrsulaBuild_FinalSoftload:4.4.4.8
	rthornb_UrsulaBuild-12Aug1998:4.4.4.8
	aglover_UrsulaBuild-05Aug1998:4.4.4.8
	rthornb_UrsulaBuild-29Jul1998:4.4.4.8
	rthornb_UrsulaBuild-22Jul1998:4.4.4.8
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.4.4.8
	rthornb_UrsulaBuild-07Jul1998:4.4.4.8
	rthornb_UrsulaBuild-17Jun1998:4.4.4.8
	rthornb_UrsulaBuild-03Jun1998:4.4.4.8
	rthornb_UrsulaBuild-27May1998:4.4.4.8
	mstphens_Kernel-3_80:4.4.4.8
	rthornb_UrsulaBuild-21May1998:4.4.4.8
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.4.4.7
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.4.0.2
	Daytona_bp:4.4
	Ursula_bp:4.4
	Ursula:4.4.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.26
date	2018.06.30.08.38.52;	author rool;	state Exp;
branches;
next	4.25;
commitid	Bu55fAfHOotJxhIA;

4.25
date	2018.04.14.16.01.30;	author jlee;	state Exp;
branches;
next	4.24;
commitid	SxfJnhKQo352tqyA;

4.24
date	2017.01.11.00.17.16;	author jlee;	state Exp;
branches
	4.24.2.1;
next	4.23;
commitid	hP4UWFrWYbsRXtBz;

4.23
date	2016.12.13.19.41.12;	author jlee;	state Exp;
branches;
next	4.22;
commitid	XeVhUEC50BLVkRxz;

4.22
date	2016.12.13.19.03.34;	author jlee;	state Exp;
branches;
next	4.21;
commitid	dvbJa4TQHit18Rxz;

4.21
date	2016.12.13.18.39.09;	author jlee;	state Exp;
branches;
next	4.20;
commitid	O0s9EhrhFbuFZQxz;

4.20
date	2016.12.13.17.03.40;	author jlee;	state Exp;
branches;
next	4.19;
commitid	ICF3hx0HXNFUsQxz;

4.19
date	2016.12.13.16.42.50;	author jlee;	state Exp;
branches;
next	4.18;
commitid	aGog9bB8f4QKlQxz;

4.18
date	2016.09.13.20.10.39;	author jlee;	state Exp;
branches;
next	4.17;
commitid	VxemW4URwOcpqamz;

4.17
date	2016.09.07.21.45.13;	author jlee;	state Exp;
branches;
next	4.16;
commitid	GPzWDxzZgYTN8plz;

4.16
date	2016.08.23.21.23.24;	author jlee;	state Exp;
branches;
next	4.15;
commitid	hwJKv803ikAdvtjz;

4.15
date	2016.08.18.20.03.59;	author jlee;	state Exp;
branches;
next	4.14;
commitid	s6z3Cu41WX6WdPiz;

4.14
date	2016.08.02.22.10.43;	author jlee;	state Exp;
branches;
next	4.13;
commitid	CnQYuUGzojQfrMgz;

4.13
date	2016.06.30.20.59.45;	author jlee;	state Exp;
branches;
next	4.12;
commitid	skOEjp3ipLHx6xcz;

4.12
date	2016.06.30.20.28.55;	author jlee;	state Exp;
branches;
next	4.11;
commitid	lMnWzoE9eJz3Wwcz;

4.11
date	2016.06.30.20.08.07;	author jlee;	state Exp;
branches;
next	4.10;
commitid	IWoXxARWeuLDOwcz;

4.10
date	2000.10.10.10.16.31;	author sbrodie;	state Exp;
branches;
next	4.9;

4.9
date	2000.05.09.08.39.53;	author sbrodie;	state Exp;
branches
	4.9.2.1;
next	4.8;

4.8
date	2000.04.04.14.27.28;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.08.19.10.52.27;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.08.17.11.16.17;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.04.30.15.18.51;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	97.05.13.14.10.29;	author mstphens;	state Exp;
branches
	4.4.4.1;
next	4.3;

4.3
date	97.05.07.05.51.47;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.06.59;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.15;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.24.2.1
date	2018.05.14.19.33.43;	author jlee;	state Exp;
branches;
next	4.24.2.2;
commitid	wrVtYH84nAz1GiCA;

4.24.2.2
date	2018.07.07.13.15.13;	author jlee;	state Exp;
branches;
next	;
commitid	xZcbvu8u7pqAQcJA;

4.9.2.1
date	2000.09.15.12.38.00;	author kbracey;	state Exp;
branches;
next	4.9.2.2;

4.9.2.2
date	2000.10.02.08.52.19;	author kbracey;	state Exp;
branches;
next	4.9.2.3;

4.9.2.3
date	2000.10.05.13.54.49;	author kbracey;	state Exp;
branches;
next	4.9.2.4;

4.9.2.4
date	2000.10.06.09.08.11;	author kbracey;	state Exp;
branches;
next	4.9.2.5;

4.9.2.5
date	2000.10.09.15.59.15;	author kbracey;	state Exp;
branches;
next	4.9.2.6;

4.9.2.6
date	2000.10.10.10.37.10;	author sbrodie;	state Exp;
branches;
next	4.9.2.7;

4.9.2.7
date	2000.10.20.14.58.21;	author kbracey;	state Exp;
branches;
next	4.9.2.8;

4.9.2.8
date	2000.10.20.15.48.04;	author mstephen;	state Exp;
branches;
next	4.9.2.9;

4.9.2.9
date	2000.11.10.15.51.34;	author kbracey;	state Exp;
branches;
next	4.9.2.10;

4.9.2.10
date	2001.01.25.17.05.01;	author mstephen;	state Exp;
branches;
next	4.9.2.11;

4.9.2.11
date	2001.02.13.09.36.05;	author kbracey;	state Exp;
branches;
next	4.9.2.12;

4.9.2.12
date	2001.05.01.14.10.58;	author mstephen;	state Exp;
branches;
next	4.9.2.13;

4.9.2.13
date	2001.05.22.15.27.53;	author mstephen;	state Exp;
branches;
next	4.9.2.14;

4.9.2.14
date	2001.06.06.14.24.00;	author mstephen;	state Exp;
branches;
next	4.9.2.15;

4.9.2.15
date	2001.06.15.09.39.57;	author mstephen;	state Exp;
branches;
next	4.9.2.16;

4.9.2.16
date	2001.06.18.14.49.43;	author mstephen;	state Exp;
branches;
next	4.9.2.17;

4.9.2.17
date	2002.10.07.17.29.40;	author kbracey;	state Exp;
branches;
next	4.9.2.18;

4.9.2.18
date	2002.11.30.00.31.06;	author bavison;	state Exp;
branches
	4.9.2.18.2.1;
next	4.9.2.19;

4.9.2.19
date	2009.10.22.19.26.42;	author jlee;	state Exp;
branches;
next	4.9.2.20;

4.9.2.20
date	2011.11.26.21.11.15;	author jlee;	state Exp;
branches;
next	4.9.2.21;
commitid	cI3W0zbtALQG6TIv;

4.9.2.21
date	2012.04.15.19.48.06;	author jlee;	state Exp;
branches;
next	4.9.2.22;
commitid	95iLwHSxemPb701w;

4.9.2.22
date	2012.10.28.16.51.45;	author rsprowson;	state Exp;
branches;
next	4.9.2.23;
commitid	ruXZqdTJKJ85Qaqw;

4.9.2.23
date	2013.03.28.21.36.24;	author jlee;	state Exp;
branches;
next	4.9.2.24;
commitid	UN0GP6eB0LlNyBJw;

4.9.2.24
date	2013.12.17.19.08.51;	author jlee;	state Exp;
branches;
next	4.9.2.25;
commitid	mr92WavK9Mu4gwhx;

4.9.2.25
date	2014.04.20.17.00.21;	author jlee;	state Exp;
branches;
next	4.9.2.26;
commitid	6eesW4yWEAvSyrxx;

4.9.2.26
date	2015.01.20.20.21.26;	author jlee;	state Exp;
branches;
next	4.9.2.27;
commitid	XTFnnthpWkiPPN6y;

4.9.2.27
date	2015.07.04.08.26.56;	author rsprowson;	state Exp;
branches;
next	4.9.2.28;
commitid	CNCb4ZR8tZ7SzWry;

4.9.2.28
date	2015.07.04.19.22.26;	author jlee;	state Exp;
branches;
next	4.9.2.29;
commitid	4vKk5RxNmDlJc0sy;

4.9.2.29
date	2015.08.05.21.51.30;	author jlee;	state Exp;
branches;
next	4.9.2.30;
commitid	SpZpzVH47zb408wy;

4.9.2.30
date	2015.08.31.19.28.37;	author jlee;	state Exp;
branches;
next	4.9.2.31;
commitid	Ni3KL17bG70fnszy;

4.9.2.31
date	2015.09.01.21.14.47;	author jlee;	state Exp;
branches;
next	4.9.2.32;
commitid	6XNouVrEaXcGVAzy;

4.9.2.32
date	2015.09.01.22.30.55;	author jlee;	state Exp;
branches;
next	4.9.2.33;
commitid	mUQhVdGL4XmOlBzy;

4.9.2.33
date	2015.09.06.18.45.13;	author jlee;	state Exp;
branches;
next	4.9.2.34;
commitid	9JoJW3FhqXIqWdAy;

4.9.2.34
date	2015.09.30.21.19.43;	author jlee;	state Exp;
branches;
next	4.9.2.35;
commitid	OuAy3Nmkp5gB1kDy;

4.9.2.35
date	2015.10.10.11.59.49;	author jlee;	state Exp;
branches;
next	4.9.2.36;
commitid	k2QociqCLrMAByEy;

4.9.2.36
date	2016.03.10.22.57.41;	author jlee;	state Exp;
branches;
next	4.9.2.37;
commitid	DAXUqMY2ucjim9Yy;

4.9.2.37
date	2016.03.27.02.00.54;	author jlee;	state Exp;
branches;
next	4.9.2.38;
commitid	nHwGXjCPCyRkRd0z;

4.9.2.38
date	2016.05.23.22.02.37;	author jlee;	state Exp;
branches;
next	;
commitid	vs9giyyGBlq1GE7z;

4.9.2.18.2.1
date	2009.03.06.23.23.42;	author jlee;	state Exp;
branches;
next	4.9.2.18.2.2;

4.9.2.18.2.2
date	2009.10.22.00.40.01;	author jlee;	state Exp;
branches;
next	4.9.2.18.2.3;

4.9.2.18.2.3
date	2010.07.03.19.42.49;	author jlee;	state Exp;
branches;
next	4.9.2.18.2.4;

4.9.2.18.2.4
date	2011.02.19.22.19.34;	author jlee;	state Exp;
branches;
next	4.9.2.18.2.5;

4.9.2.18.2.5
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	4.9.2.18.2.6;
commitid	D7rzILnwRRSXoLuv;

4.9.2.18.2.6
date	2011.09.24.19.55.53;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.4.4.1
date	97.05.21.09.30.06;	author mstphens;	state Exp;
branches;
next	4.4.4.2;

4.4.4.2
date	97.09.09.13.33.02;	author mstphens;	state Exp;
branches;
next	4.4.4.3;

4.4.4.3
date	97.10.21.15.31.09;	author mstphens;	state Exp;
branches;
next	4.4.4.4;

4.4.4.4
date	97.12.08.14.34.18;	author mstphens;	state Exp;
branches;
next	4.4.4.5;

4.4.4.5
date	98.03.26.11.25.32;	author mstphens;	state Exp;
branches;
next	4.4.4.6;

4.4.4.6
date	98.04.14.11.23.50;	author mstphens;	state Exp;
branches;
next	4.4.4.7;

4.4.4.7
date	98.04.28.17.05.40;	author mstphens;	state Exp;
branches;
next	4.4.4.8;

4.4.4.8
date	98.05.19.15.51.59;	author sproven;	state Exp;
branches
	4.4.4.8.2.1;
next	4.4.4.9;

4.4.4.9
date	98.09.24.13.17.01;	author mstphens;	state Exp;
branches;
next	;

4.4.4.8.2.1
date	98.11.23.14.59.02;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.15;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.59.47;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.08.09.21;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.16.45.57;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.10.48;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.25;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.26
log
@Simplify initial AplSpace claim
Detail:
  As the application slot is now a normal dynamic area, there's no need to manipulate the CAM directly. Convert FudgeSomeAppSpace into a OS_ChangeDynamicArea SWI followed by memset().
  ChangeDyn.s: Offset by 32k to account for the -32k that dynamic area -1 has.
  NewReset.s: Delete FudgeSomeAppSpace and replace as above.
Admin:
  Submission from Timothy Baldwin.

Version 6.08. Tagged as 'Kernel-6_08'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL   => ChangeDyn

        ; OS_ChangeDynamicArea optimisations:

        GBLL  FastCDA_Bulk ; Do all cache/TLB maintenance in bulk instead of on a per-page basis
FastCDA_Bulk SETL {TRUE}

        GBLL  FastCDA_FIQs ; Don't thrash ClaimFIQ/ReleaseFIQ in DoTheGrowPagesSpecified
FastCDA_FIQs SETL {TRUE}

        GBLL  FastCDA_Unnecessary ; Avoid unnecessary cache cleaning in DoTheGrowPagesSpecified
FastCDA_Unnecessary SETL {TRUE}

        ; DoTheGrowPagesSpecified profiling code
        ; Written to use Cortex-A8 cycle count performance counter - will need modifying for other CPUs!

        GBLL  FastCDA_Prof
FastCDA_Prof SETL {FALSE}

      [ FastCDA_Prof
        ; Squeeze profiling workspace into "free space after envstring"
                                 ^ ExtendedROMFooter+4
        ! 0, "FastCDA_Prof workspace at ":CC::STR:@@
FastCDA_Prof_DoTheGrowInit           # 4
FastCDA_Prof_MarkRequired            # 4
FastCDA_Prof_PagesUnsafe             # 4
FastCDA_Prof_DoublyRemoveCacheability # 4
FastCDA_Prof_DoublyMovePages         # 4
FastCDA_Prof_FindSpare               # 4
FastCDA_Prof_ClaimFIQ                # 4
FastCDA_Prof_AccessPhysical          # 4
FastCDA_Prof_CopyPage                # 4
FastCDA_Prof_ReleasePhysical         # 4
FastCDA_Prof_MoveReplacement         # 4
FastCDA_Prof_MoveNeeded              # 4
FastCDA_Prof_ReleaseFIQ              # 4
FastCDA_Prof_PagesSafe               # 4
FastCDA_Prof_CallPreGrow             # 4
FastCDA_Prof_CallPostGrow            # 4
FastCDA_Prof_MMUChangingCached       # 4 ; MMU_ChangingUncached followed by Cache_CleanInvalidateaAll
FastCDA_Prof_MMUChangingUncached     # 4 ; MMU_ChangingUncached followed by nothing
FastCDA_Prof_ChangingEntry           # 4
        ASSERT @@ <= &500
      ]

        MACRO
        FastCDA_ProfInit $temp
      [ FastCDA_Prof
        MVN     $temp,#0
        MCR     p15,0,$temp,c9,c12,2
        MOV     $temp,#1<<31
        MCR     p15,0,$temp,c9,c12,1
        MOV     $temp,#7
        MCR     p15,0,$temp,c9,c12,0
      ]
        MEND

        MACRO
        FastCDA_ProfStart $var,$temp,$temp2,$temp3,$cc
      [ FastCDA_Prof
        LDR$cc  $temp,=ZeroPage+FastCDA_Prof_$var
        LDR$cc  $temp2,[$temp]
        MRC$cc  p15,0,$temp3,c9,c13,0
        SUB$cc  $temp2,$temp2,$temp3
        STR$cc  $temp2,[$temp]
      ]
        MEND

        MACRO
        FastCDA_ProfEnd $var,$temp,$temp2,$temp3,$cc
      [ FastCDA_Prof
        MRC$cc  p15,0,$temp3,c9,c13,0
        LDR$cc  $temp,=ZeroPage+FastCDA_Prof_$var
        LDR$cc  $temp2,[$temp]
        ADD$cc  $temp2,$temp2,$temp3
        STR$cc  $temp2,[$temp]
      ]
        MEND

;******************************************************************************
; ChangeDynamic SWI
; In  : R0 =  0 => System Heap,
;             1 => RMA
;             2 => Screen
;             3 => Sprite area
;             4 => Font cache
;             5 => RAM disc
;             6 => Free pool
;       R1 = no of bytes to change by
;
; Out : V set if CAO in AplWork or couldn't move all the bytes requested.
;       R1 set to bytes moved.
;******************************************************************************

; OS access privileges (OSAP_ to differentiate from AP_ used in Hdr:MEMM.*)
OSAP_Full * 0 ; user r/w/x, priv r/w/x
OSAP_Read * 1 ; user r/x, priv r/w/x
OSAP_None * 2 ; user none, priv r/w/x
OSAP_ROM  * 3 ; user r/x, priv r/x

; Corresponding values for OS_Memory 24
; (n.b. - XN flag is inverted)
CMA_ROM  * CMA_Partially_UserR+CMA_Partially_UserXN+CMA_Partially_PrivR+CMA_Partially_PrivXN
CMA_Read * CMA_ROM+CMA_Partially_PrivW
CMA_Full * CMA_Read+CMA_Partially_UserW
CMA_None * CMA_Partially_PrivR+CMA_Partially_PrivW+CMA_Partially_PrivXN

; Convenience macro for defining DA/page flags and corresponding CMA value
        MACRO
$area   DefAreaFlags $ap, $extra
AreaFlags_$area * OSAP_$ap :OR: ($extra + 0)
CMA_$area * CMA_$ap
        MEND

; Flags for kernel-managed DAs
AppSpace         DefAreaFlags Full
SysHeap          DefAreaFlags Full
RMA              DefAreaFlags Full
Screen           DefAreaFlags Full, DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped :OR: DynAreaFlags_NeedsSpecificPages
Sprites          DefAreaFlags Full
FontArea         DefAreaFlags None
RAMDisc          DefAreaFlags None, DynAreaFlags_NotCacheable
RAMDisc_SA       DefAreaFlags None ; StrongARM-specific (~CB gives poor performance for current StrongARMs)
FreePool         DefAreaFlags None, DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_PMP

; Flags for other kernel managed areas

Duff                 DefAreaFlags None, DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable
CursorChunkCacheable DefAreaFlags Read, PageFlags_Unavailable ; Should be OSAP_None?
CursorChunk          DefAreaFlags Read, PageFlags_Unavailable :OR: DynAreaFlags_NotCacheable
PageTablesAccess     DefAreaFlags None ; n.b. just the AP value, for full page flags use PageTable_PageFlags workspace var
HALWorkspace         DefAreaFlags Read, PageFlags_Unavailable
HALWorkspaceNCNB     DefAreaFlags None, DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable :OR: PageFlags_Unavailable
ZeroPage             DefAreaFlags Read, PageFlags_Unavailable
ScratchSpace         DefAreaFlags Read, PageFlags_Unavailable
DCacheClean          DefAreaFlags None ; ideally, svc read only, user none but hey ho
CAM                  DefAreaFlags None, PageFlags_Unavailable
SVCStack             DefAreaFlags Read, PageFlags_Unavailable
IRQStack             DefAreaFlags None, PageFlags_Unavailable
ABTStack             DefAreaFlags None, PageFlags_Unavailable
UNDStack             DefAreaFlags None, PageFlags_Unavailable
Kbuffs               DefAreaFlags Read, PageFlags_Unavailable
DebuggerSpace        DefAreaFlags Read, PageFlags_Unavailable

  [ DA_Batman
ChangeDyn_Batcall    * -3               ; special DA number to select Batman usage of OS_ChangeDynamicArea
  ]
; -2 was an internal value, now no longer used
ChangeDyn_AplSpace   * -1
ChangeDyn_SysHeap    * 0
ChangeDyn_RMA        * 1
ChangeDyn_Screen     * 2
ChangeDyn_SpriteArea * 3
ChangeDyn_FontArea   * 4
ChangeDyn_RamFS      * 5
ChangeDyn_FreePool   * 6
ChangeDyn_MaxArea    * 6

; Number of entries in page block on stack

NumPageBlockEntries *   63
PageBlockSize   *       NumPageBlockEntries * 12
PageBlockChunk  *       NumPageBlockEntries * 4096

;
; mjs - performance enhancements (from Ursula, merged into HALised kernel June 2001)
; Workspace for acceleration of operations on a DA, by reducing need to traverse DA list.
;
; - accelerates allocating non-quick DA numbers to O(n) instead of laughable O(n*n), where n is no. of DAs
; - accelerates enumeration to O(n) instead of laughable O(n*n)
; - allocation of a quick handle (DA number) is O(1)
; - access of a DA node from a quick handle is O(1)
; - access of a DA node from a non-quick handle is O(1), if it repeats the most recent non-quick handle access (else O(n))
;
; - creation of a DA still has some O(n) work (requires search for address space), but is now rather quicker
; - removal of a DA is still O(n) (requires traversal of list in order to get previous node)
; - other uses of a DA with a quick handle (eg. get info, change size) avoid any O(n) work
;
; - all system handles will be quick.
; - non-system handles will be quick, except for very large numbers of DAs, or silly modules like the Wimp who insist on
;   their own silly DA number (the latter can still benefit from LastTreacleHandle - see below)
;
; Limitations:
; - does not allow anyone to choose their own DA number that clashes with the quick handle set - should not
;   be a problem since choosing own number reserved for Acorn use
; - does not allow anyone to renumber a DA with a quick handle - again, reserved for system use
; - DA names will be truncated to a maximum of 31 characters (or as defined below)
;
                                  GBLL DynArea_QuickHandles
DynArea_QuickHandles              SETL {TRUE}
;
      ;various bad things happen if DynArea_QuickHandles is FALSE (eg. some new API disappears)
      ;should remove FALSE build option to simplify source code next time kernel is updated (kept for reference/testing now)
      ASSERT DynArea_QuickHandles

                                  GBLL DynArea_NullNamePtrMeansHexString
DynArea_NullNamePtrMeansHexString SETL {TRUE} :LAND: DynArea_QuickHandles
;
  [ DynArea_QuickHandles
DynArea_MaxNameLength     * 31                      ;maximum length of DA name, excluding terminator (multiple of 4, -1)
DynArea_NumQHandles       * 256                     ;maximum no. of non-system quick handles available simultaneously
DynArea_AddrLookupBits    * 8                       ;LUT covers entire 4G logical space, so 4G>>8 = 16M granularity
DynArea_AddrLookupSize    * 1<<(32-DynArea_AddrLookupBits) ; Address space covered by each entry
DynArea_AddrLookupMask    * &FFFFFFFF-(DynArea_AddrLookupSize-1)
;
                          ^  0,R11
DynArea_TreacleGuess      # 4                       ;guess for next non-quick handle to allocate, if needed, is TreacleGuess+1
DynArea_CreatingHandle    # 4                       ;handle proposed but not yet committed, during DynArea_Create, or -1 if none
DynArea_CreatingPtr       # 4                       ;ptr to proposed DANode during DynArea_Create (invalid if CreatingHandle = -1)
DynArea_LastTreacleHandle # 4                       ;last non-quick handle accessed by a client (usually the Wimp), or -1 if none
DynArea_LastTreaclePtr    # 4                       ;ptr to DANode for last non-quick handle accessed (invalid if LastTreacleHandle = -1)
DynArea_LastEnumHandle    # 4                       ;last handle enumerated, or -1 if none
DynArea_LastEnumPtr       # 4                       ;ptr to DANode for last handle enumerated (invalid if LastEnumHandle = -1)
DynArea_ShrinkableSubList # 4                       ;sub list of dynamic areas that are Shrinkable (0 if none)
DynArea_OD6Signature      # 4                       ;signature of changes to non-system DAs since last call to OS_DynamicArea 6
                                                    ;bit  0 = 1 if any DAs have been created
                                                    ;bit  1 = 1 if any DAs have been removed
                                                    ;bit  2 = 1 if any DAs have been resized (excluding grow or shrink at creation or removal)
                                                    ;bit  3 = 1 if any DAs have been renumbered
                                                    ;bits 4-30   reserved (0)
                                                    ;bit 31 = 1 if next resize is not to update signature (used during create, remove)
DynArea_OD6PrevSignature  # 4                       ;previous signature, used to distinguish single from multiple changes
DynArea_OD6Handle         # 4                       ;handle of last DA that affected signature
DynArea_OD8Clamp1         # 4                       ;clamp value on area max size for OS_DynamicArea 0 with R5 = -1
                                                    ;(default -1, set by R1 of OS_DynamicArea 8)
DynArea_OD8Clamp2         # 4                       ;clamp value on area max size for OS_DynamicArea 0 with R5 > 0 (not Sparse)
                                                    ;(default -1, set by R2 of OS_DynamicArea 8)
DynArea_OD8Clamp3         # 4                       ;clamp value on area max size for OS_DynamicArea 0 for a Sparse area
                                                    ;(default 4G-4k, set by R3 of OS_DynamicArea 8)
DynArea_SortedList        # 4                       ;alphabetically sorted list of non-system areas, or 0 if none
DynArea_SysQHandleArray   # 4*(ChangeDyn_MaxArea+1) ;for system areas 0..MaxArea, word = ptr to DANode, or 0 if not created yet
DynArea_FreeQHandles      # 4                       ;index of first free quick handle, starting at 1 (or 0 for none)
DynArea_QHandleArray      # 4*DynArea_NumQHandles   ;1 word per quick handle
                                                    ; - if free, word = index of next free quick handle (or 0 if none)
                                                    ; - if used, word = ptr to DANode (must be > DynArea_NumQHandles)
DynArea_AddrLookup        # 4<<DynArea_AddrLookupBits ; Lookup table for fast logaddr -> dynarea lookup
;
DynArea_ws_size           *  :INDEX:@@               ;must be multiple of 4
;
            ASSERT DynArea_QHandleArray = DynArea_FreeQHandles +4
  ]
;


;        InsertDebugRoutines

; Exit from ChangeDynamicArea with error Not all moved

failure_IRQgoingClearSemaphore
        LDR     r0, =ZeroPage
      [ ZeroPage = 0
        STR     r0, [r0, #CDASemaphore]
      |
        MOV     r10, #0
        STR     r10, [r0, #CDASemaphore]
      ]
failure_IRQgoing
        ADR     r0, ErrorBlock_ChDynamNotAllMoved
ChangeDynamic_Error
        MOV     r10, #0
        STR     r0, [stack]
        LDR     lr, [stack, #4*10]
        ORR     lr, lr, #V_bit
        STR     lr, [stack, #4*10]
CDS_PostServiceWithRestore
      [ International
        LDR     r0, [stack]
        BL      TranslateError
        STR     r0, [stack]
      ]

; and drop thru to ...

CDS_PostService
        MOV     r1, #Service_MemoryMoved
        MOV     r0, r10                 ; amount moved
        MOVS    r2, r11                 ; which way was transfer?
        BMI     %FT47                   ; [definitely a grow]
        CMP     r11, #ChangeDyn_FreePool
        BNE     %FT48                   ; [definitely a shrink]
        CMP     r12, #ChangeDyn_AplSpace
        BEQ     %FT48                   ; [a shrink]
47
        RSB     r0, r0, #0             ; APLwork or free was source
        MOV     r2, r12                ; r2 = area indicator
48
        BL      Issue_Service

        MOV     r1, r10                ; amount moved

        Pull    "r0, r2-r9, r10, lr"
        ExitSWIHandler

        MakeErrorBlock ChDynamNotAllMoved

; Call_CAM_Mapping
; in:   r2 = physical page number
;       r3 = logical address (2nd copy of doubly mapped area)
;       r9 = offset from 1st to 2nd copy of doubly mapped area (either source or dest, but not both)
;       r11 = PPL + CB bits
Call_CAM_Mapping
        Push    "r0, r1, r4, r6, lr"
        BL      BangCamUpdate
        Pull    "r0, r1, r4, r6, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 bits 0..6 = area number
;       r0 bit 7 set => return max area size in r2 (implemented 13 Jun 1990)
;                       this will return an error if not implemented
; Out   r0 = address of area
;       r1 = current size of area
;       r2 = max size of area if r0 bit 7 set on entry (preserved otherwise)

; TMD 19-May-93: When this is updated to new CDA list, change meaning as follows:

; r0 in range 0..&7F    return address, size of area r0
;             &80..&FF  return address, size, maxsize of area (r0-&80)
;             &100..    return address, size, maxsize of area r0

; TMD 20-Aug-93: New bit added - if r0 = -1 on entry, then returns info on application space
; r0 = base address (&8000)
; r1 = current size (for current task)
; r2 = maximum size (eg 16M-&8000)

ReadDynamicArea ROUT

readdyn_returnR2bit     *       &80
        ASSERT  ChangeDyn_MaxArea < readdyn_returnR2bit

        CMP     r0, #ChangeDyn_AplSpace         ; if finding out about app space
      [ ZeroPage = 0
        LDREQ   r1, [r0, #AplWorkSize+1]        ; then r1 = current size
      |
        LDREQ   r1, =ZeroPage
        LDREQ   r1, [r1, #AplWorkSize]
      ]
        LDREQ   r2, =AplWorkMaxSize             ; and r2 = max size
        MOVEQ   r0, #&8000                      ; r0 = base address
        SUBEQ   r1, r1, r0                      ; adjust size and maxsize
        SUBEQ   r2, r2, r0                      ; to remove bottom 32K
        ExitSWIHandler EQ

; first check if it's one of the new ones

        Push    "r1,lr"
        CMP     r0, #&100                       ; if area >= &100
        MOVCS   r1, r0                          ; then just use area
        BICCC   r1, r0, #readdyn_returnR2bit    ; else knock off bit 7
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; out: r10 -> node
  |
        BL      CheckAreaNumber                 ; out: r10 -> node
  ]
        Pull    "r1,lr"
        BCC     %FT05                           ; [not a new one, so use old code]

        LDR     r11, [r10, #DANode_Flags]
        TST     r11, #DynAreaFlags_PMP
        BNE     %FT01
        CMP     r0, #&80                        ; CS => load maxsize into R2
                                                ; (do this either if bit 7 set, or area >=&100)
        LDRCS   r2, [r10, #DANode_MaxSize]
        LDR     r1, [r10, #DANode_Size]         ; r1 = current size
        LDR     r0, [r10, #DANode_Base]         ; r0 -> base
        TST     r11, #DynAreaFlags_DoublyMapped
        SUBNE   r0, r0, r1                      ; if doubly mapped then return start of 1st copy for compatibility
        ExitSWIHandler
01
        ; Convert physical parameters into byte counts
        CMP     r0, #&80
        BCC     %FT02
        LDR     r2, [r10, #DANode_PMPMaxSize]
        CMP     r2, #DynArea_PMP_BigPageCount
        MOVLO   r2, r2, LSL #12
        LDRHS   r2, =DynArea_PMP_BigByteCount
02
        LDR     r1, [r10, #DANode_PMPSize]
        CMP     r1, #DynArea_PMP_BigPageCount
        MOVLO   r1, r1, LSL #12
        LDRHS   r1, =DynArea_PMP_BigByteCount
        LDR     r0, [r10, #DANode_Base]
        ExitSWIHandler
05
        ADRL    r0, ErrorBlock_BadDynamicArea
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        B       SLVK_SetV

        MakeErrorBlock  BadDynamicArea

; *************************************************************************
; User access to CAM mapping
; ReadMemMapInfo:
; returns R0 = pagsize
;         R1 = number of pages in use  (= R2 returned from SetEnv/Pagesize)
; *************************************************************************

ReadMemMapInfo_Code
      LDR      R10, =ZeroPage
      LDR      R0, [R10, #Page_Size]
      LDR      R1, [R10, #RAMLIMIT]    ; = total memory size
      ADRL     R11, PageShifts-1
      LDRB     R11, [R11, R0, LSR #12]
      MOV      R1, R1, LSR R11
      ExitSWIHandler

; ************************************************************************
; SWI ReadMemMapEntries: R0 pointer to list.
;  Entries are three words long, the first of which is the CAM page number.
;  List terminated by -1.
; Returns pagenumber (unaltered)/address/PPL triads as below
; ************************************************************************

ReadMemMapEntries_Code  ROUT
        Push    "r0,r14"
        LDR     r14, =ZeroPage
        LDR     r10, [r14, #CamEntriesPointer]
        LDR     r14, [r14, #MaxCamEntry]
01
        LDR     r12, [r0], #4                   ; page number
        CMP     r12, r14
        Pull    "r0,r14", HI
        ExitSWIHandler HI

   [ AMB_LazyMapIn
        ;may need AMB to make mapping honest (as if not lazy), if page is in currently mapped app
        Push    "r0, lr"
        MOV     r0, r12                         ; page number to make honest
        BL      AMB_MakeHonestPN
        Pull    "r0, lr"
   ]

        ADD     r11, r10, r12, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMIA   r11, {r11, r12}
        STMIA   r0!, {r11, r12}
        B       %BT01

; ************************************************************************
; SWI FindMemMapEntries:
; In:  R0 -> table of 12-byte page entries
;       +0      4       probable page number (0..npages-1) (use 0 if no idea)
;       +4      4       logical address to match with
;       +8      4       undefined
;       terminated by a single word containing -1
;
; Out: table of 12-byte entries updated:
;       +0      4       actual page number (-1 => not found)
;       +4      4       address (preserved)
;       +8      4       page protection level (3 if not found)
;       terminator preserved
;
; ************************************************************************

FindMemMapEntries_Code  ROUT

; Code for expanded CAM map version

        Push    "r0, r9, r14"
        LDR     r14, =ZeroPage
        LDR     r9, [r14, #MaxCamEntry]
        LDR     r14, [r14, #CamEntriesPointer]  ; r14 -> start of cam map
        ADD     r9, r14, r9, LSL #CAM_EntrySizeLog2 ; r9 -> first word of last entry in cam map
10
        LDR     r10, [r0, #0]                   ; r10 = guess page number (or -1)
        CMP     r10, #-1                        ; if -1 then end of list
        Pull    "r0, r9, r14", EQ               ; so restore registers
        ExitSWIHandler EQ                       ; and exit

        LDR     r11, [r0, #4]                   ; r11 = logical address

   [ AMB_LazyMapIn
        ;may need AMB to make mapping honest (as if not lazy), if page is in currently mapped app
        Push    "r0, lr"
        MOV     r0, r11                         ; logical address to make honest
        BL      AMB_MakeHonestLA                ; note, quickly dismisses non app space addresses
        Pull    "r0, lr"
   ]

        ADD     r10, r14, r10, LSL #CAM_EntrySizeLog2 ; form address with 'guess' page
        CMP     r10, r9                         ; if off end of CAM
        BHI     %FT20                           ; then don't try to use the guess

        LDR     r12, [r10, #CAM_LogAddr]        ; load address from guessed page
        TEQ     r11, r12                        ; compare address
        BEQ     %FT60                           ; if equal, then guessed page was OK
20

; for now, cheat by looking in L2PT, to see if we can speed things up

        Push    "r5-r8"                         ; need some registers here!
        LDR     r10, =L2PT
        MOV     r8, r11, LSR #12                ; r8 = logical page number
        ADD     r8, r10, r8, LSL #2             ; r8 -> L2PT entry for log.addr
        MOV     r5, r8, LSR #12                 ; r5 = page offset to L2PT entry for log.addr
        LDR     r5, [r10, r5, LSL #2]           ; r5 = L2PT entry for L2PT entry for log.addr
        TST     r5, #3                          ; if page not there
        SUBEQ   r10, r9, #CAM_EntrySize         ; then invalid page so go from last one
        BEQ     %FT45
        LDR     r8, [r8]                        ; r8 = L2PT entry for log.addr
        MOV     r8, r8, LSR #12                 ; r8 = physaddr / 4K

        LDR     r5, =ZeroPage+PhysRamTable
        SUB     r10, r14, #CAM_EntrySize
30
        CMP     r10, r9                         ; have we run out of RAM banks?
        BCS     %FT40                           ; then fail
        LDMIA   r5!, {r6,r7}                    ; load next address, size
        SUB     r6, r8, r6, LSR #12             ; number of pages into this bank
        CMP     r6, r7, LSR #12                 ; if more than there are
        ASSERT  CAM_EntrySizeLog2 <= 16
        BICCS   r7, r7, #&F00
        ADDCS   r10, r10, r7, LSR #12-CAM_EntrySizeLog2 ; then advance CAM entry position
        BCS     %BT30                           ; and loop to next bank

        ADD     r10, r10, r6, LSL #CAM_EntrySizeLog2 ; advance by 2 words for each page in this bank
40
        SUBCS   r10, r9, #CAM_EntrySize         ; search from last one, to fail quickly (if CS)
45
        Pull    "r5-r8"
50
        CMP     r10, r9                         ; if not just done last one,
        ASSERT  CAM_LogAddr=0
        LDRNE   r12, [r10, #CAM_EntrySize]!     ; then get logical address
        TEQNE   r11, r12                        ; compare address
        BNE     %BT50                           ; loop if not same and not at end

; either found page or run out of pages

        TEQ     r11, r12                        ; see if last one matched
                                                ; (we always load at least one!)
60
        LDREQ   r12, [r10, #CAM_PageFlags]      ; if match, then r12 = PPL
        SUBEQ   r10, r10, r14                   ; and page number=(r10-r14)>>3
        MOVEQ   r10, r10, LSR #CAM_EntrySizeLog2

        MOVNE   r10, #-1                        ; else unknown page number indicator
        MOVNE   r12, #3                         ; and PPL=3 (no user access)

        STMIA   r0!, {r10-r12}                  ; store all 3 words
        B       %BT10                           ; and go back for another one

;**************************************************************************
; SWI SetMemMapEntries: R0 pointer to list of CAM page/address/PPL triads,
;  terminated by -1.
; address of -1 means "put the page out of the way"
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; note, if ChocolateAMB, no MakeHonest consideration here, this SWI just
; changes the mapping of pages regardless of their current mapping, and
; assumes the caller knows what he is doing (ho ho)
;

SetMemMapEntries_Code  ROUT
        Push    "r0-r6, r9, lr"
        MOV     r12, r0

; BangCamUpdate takes entry no in r2, logaddr to set to in r3, r11 = PPL
; corrupts r0,r1,r4,r6

        LDR     r9, =ZeroPage
        LDR     r5, [r9, #MaxCamEntry]
        LDR     r9, [r9, #CamEntriesPointer]
        ADD     r9, r9, #CAM_PageFlags
01
        LDR     r2, [r12], #4
        CMP     r2, r5
        BHI     %FT02                   ; finished
        LDMIA   r12!, {r3, r11}
        CMP     r3, #-1
        LDRHS   r3, =DuffEntry
        MOVHS   r11, #AreaFlags_Duff
        ; Ensure PMP membership flag is retained - just in case caller doesn't
        ; know what he's doing
        LDR     r0, [r9, r2, LSL #CAM_EntrySizeLog2]
        AND     r0, r0, #DynAreaFlags_PMP
        BIC     r11, r11, #DynAreaFlags_PMP
        ORR     r11, r11, r0
        BL      BangCamUpdate
        B       %BT01
02
        Pull    "r0-r6, r9, lr"
        ExitSWIHandler

        LTORG



;**************************************************************************
;
;       DynamicAreaSWI - Code to handle SWI OS_DynamicArea
;
; in:   r0 = reason code
;       Other registers depend on reason code
;
; out:  Depends on reason code
;


DynArea_NewAreas *      &100            ; Allocated area numbers start here
DynArea_NewAreasBase *  &04000000       ; Allocated area addresses start here
DynArea_PMP_BigPageCount * 1:SHL:(31-12) ; If PMP has >= this many pages...
DynArea_PMP_BigByteCount * &7FFFF000     ; Then convert to this byte value

;
; Internal page flags (note - may overlap DA flags)
;
TempUncacheableShift            * 16
PageFlags_TempUncacheableBits   * 15 :SHL: TempUncacheableShift    ; temporary count of uncacheability, used by DMA mgr (via OS_Memory 0)
PageFlags_Required              *  1 :SHL: 21                      ; physical page asked for by handler (only set temporarily)

;
; Temporary flags only used by kernel (note - may overlap DA flags)
;
PageFlags_Unsafe                *  1 :SHL: 31                      ; skip cache/TLB maintenance in BangCamUpdate. flag not saved to CAM map.

; Mask to convert DANode_Flags to page flags (i.e. flags that are common between the two)
DynAreaFlags_AccessMask * DynAreaFlags_APBits :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped :OR: DynAreaFlags_CPBits :OR: DynAreaFlags_PMP
; PMP LogOp can specify these flags
DynAreaFlags_PMPLogOpAccessMask * (DynAreaFlags_AccessMask :OR: PageFlags_Unavailable) :AND: :NOT: (DynAreaFlags_DoublyMapped :OR: DynAreaFlags_PMP)
; PMP PhysOp can specify these flags
DynAreaFlags_PMPPhysOpAccessMask * PageFlags_Unavailable


DynamicAreaSWI Entry
        BL      DynAreaSub
        PullEnv
        ORRVS   lr, lr, #V_bit
        ExitSWIHandler

DynAreaSub
        CMP     r0, #DAReason_Limit
        ADDCC   pc, pc, r0, LSL #2
        B       DynArea_Unknown
        B       DynArea_Create
        B       DynArea_Remove
        B       DynArea_GetInfo
        B       DynArea_Enumerate
        B       DynArea_Renumber
 [ ShrinkableDAs
        B       DynArea_ReturnFree
 |
        B       DynArea_Unknown
 ]
 [ DynArea_QuickHandles
        B       DynArea_GetChangeInfo
        B       DynArea_EnumerateInfo
        B       DynArea_SetClamps
 |
        B       DynArea_Unknown
        B       DynArea_Unknown
        B       DynArea_Unknown
 ]
 [ DA_Batman
        B       DynArea_SparseClaim
        B       DynArea_SparseRelease
 |
        B       DynArea_Unknown
        B       DynArea_Unknown
 ]
        B       DynArea_Unknown ; 11
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; | 
        B       DynArea_Unknown ; |--Reserved for ROL 
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; 19
        B       DynArea_Locate
        B       DynArea_PMP_PhysOp
        B       DynArea_PMP_LogOp
        B       DynArea_PMP_Resize
        B       DynArea_PMP_GetInfo
        B       DynArea_PMP_GetPages

;
; unknown OS_DynamicArea reason code
;
DynArea_Unknown
        ADRL    r0, ErrorBlock_HeapBadReason
DynArea_TranslateAndReturnError
      [ International
        Push    lr
        BL      TranslateError
        Pull    lr
      ]
DynArea_ReturnError
        SETV
        MOV     pc, lr

;**************************************************************************
;
;       DynArea_Create - Create a dynamic area
;
;       Internal routine called by DynamicAreaSWI and by reset code
;
; in:   r0 = reason code (0)
;       r1 = new area number, or -1 => RISC OS allocates number
;       r2 = initial size of area (in bytes)
;       r3 = base logical address of area, or -1 => RISC OS allocates address space
;       r4 = area flags
;               bits 0..3 = access privileges
;               bit  4 = 1 => not bufferable
;               bit  5 = 1 => not cacheable
;               bit  6 = 0 => area is singly mapped
;                      = 1 => area is doubly mapped
;               bit  7 = 1 => area is not user draggable in TaskManager window
;               bit  8 = 1 => area may require specific physical pages
;               bit  9 = 1 => area is shrinkable (only implemented if ShrinkableDAs)
;               bit 10 = 1 => area may be sparsely mapped (only implemented if DA_Batman)
;               bit 11 = 1 => area is bound to client application (allows areas to be overlayed in address space)
;                             not implemented yet, but declared in public API for Ursula
;               bits 12..14 => cache policy (if bits 4 or 5 set)
;               bit 15 = 1 => area requires DMA capable pages (is bit 12 in ROL's OS!)
;               bits 16-19 used by ROL
;               bit 20 = 1 => area is backed by physical memory pool
;               other bits reserved for future expansion + internal page flags (should be 0)
;
;       r5 = maximum size of logical area, or -1 for total RAM size
;       r6 -> area handler routine
;       r7 = workspace pointer for area handler (-1 => use base address)
;       r8 -> area description string (null terminated) (gets copied)
;       r9 = initial physical area size limit, in pages (physical memory pools), otherwise ignored
;
; out:  r1 = given or allocated area number
;       r3 = given or allocated base address of area
;       r5 = given or allocated maximum size
;       r0, r2, r4, r6-r9 preserved
;       r10-r12 may be corrupted
;

DynArea_Create Entry "r2,r6-r8"
        CMP     r1, #-1         ; do we have to allocate a new area number
        BEQ     %FT10

  [ DynArea_QuickHandles
        CMP     r1, #DynArea_NewAreas
        BLO     %FT06
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BLO     %FT08           ; can't choose your own quick handle
  ]

06
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber ; see if area number is unique
  |
        BL      CheckAreaNumber ; see if area number is unique
  ]
        BCC     %FT20           ; didn't find it, so OK

08
        ADR     r0, ErrorBlock_AreaAlreadyExists
DynArea_ErrorTranslateAndExit
        PullEnv
        B       DynArea_TranslateAndReturnError

        MakeErrorBlock  AreaAlreadyExists
        MakeErrorBlock  AreaNotOnPageBdy
        MakeErrorBlock  OverlappingAreas
        MakeErrorBlock  CantAllocateArea
        MakeErrorBlock  CantAllocateLevel2
        MakeErrorBlock  UnknownAreaHandler
        MakeErrorBlock  BadDynamicAreaOptions
        MakeErrorBlock  BadPageNumber

; we have to allocate an area number for him

  [ DynArea_QuickHandles
10
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws ]
        LDR     r1, DynArea_FreeQHandles          ;get index of next available quick handle, if any free
        CMP     r1, #0
        ADDNE   r1, r1, #DynArea_NewAreas-1       ;compute quick handle from index
        BNE     %FT20
        LDR     r1, DynArea_TreacleGuess          ;last non-quick number allocated
12
        ADD     r1, r1, #1                        ; increment for next guess (collisions should be *very* rare)
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        MOVLO   r1, #DynArea_NewAreas+DynArea_NumQHandles
        BL      QCheckAreaNumber
        BCS     %BT12                             ; and try again
  |
10
        MOV     r1, #DynArea_NewAreas
12
        BL      CheckAreaNumber
        ADDCS   r1, r1, #1      ; that area number already exists, so increment
        BCS     %BT12           ; and try again
  ]

20

; Check PMP settings
; If PMP is requested:
; * Must require specific pages
; * Mustn't be sparse
; * Mustn't be doubly mapped
; * Mustn't be requesting DMA auto-alloc
; * Must be zero initial size
; * Must have handler code
; Some of these restrictions may be lifted in future (e.g. if not requesting specific pages, kernel could implement OS_ChangeDynamicArea?)
        TST     r4, #DynAreaFlags_PMP
        BEQ     %FT21
        LDR     r11, =DynAreaFlags_DoublyMapped+DynAreaFlags_NeedsSpecificPages+DynAreaFlags_SparseMap+DynAreaFlags_NeedsDMA
        AND     r11, r4, r11
        TEQ     r11, #DynAreaFlags_NeedsSpecificPages
        TEQEQ   r2, #0
        ADRNE   r0, ErrorBlock_BadDynamicAreaOptions
        BNE     DynArea_ErrorTranslateAndExit
        TEQ     r6, #0
        ADREQ   r0, ErrorBlock_BadDynamicAreaOptions
        BEQ     DynArea_ErrorTranslateAndExit
21

; Check cacheable doubly-mapped area restrictions
; * On ARMv5 and below we disallow cacheable doubly-mapped areas outright, because the virtually tagged caches simply can't deal with them (at least when it comes to writes)
; * ARMv6 can support cacheable doubly-mapped areas, but only if we comply with the page colouring restrictions, which is something we currently don't do. So disallow there as well.
; * ARMv7+ doesn't have page colouring restrictions, but due to the potential of virtually tagged instruction caches (which would complicate OS_SynchroniseCodeAreas), for simplicity we only allow the area to be cacheable if it's non-executable
        AND     r11, r4, #DynAreaFlags_DoublyMapped+DynAreaFlags_NotCacheable
        TEQ     r11, #DynAreaFlags_DoublyMapped
        BNE     %FT22
        ; Cheesy architecture check: check the identified cache/ARMop type
        LDR     r11, =ZeroPage
        LDRB    lr, [r11, #Cache_Type]
        TEQ     lr, #CT_ctype_WB_CR7_Lx
        ADRNE   r0, ErrorBlock_BadDynamicAreaOptions
        BNE     DynArea_ErrorTranslateAndExit
        ; Check the supplied access policy is XN
        LDR     r11, [r11, #MMU_PPLAccess]
        AND     lr, r4, #DynAreaFlags_APBits
        LDR     r11, [r11, lr, LSL #2]
        TST     r11, #CMA_Partially_UserXN+CMA_Partially_PrivXN ; n.b. XN flag sense is inverted in PPLAccess, so NE means executable
        ADRNE   r0, ErrorBlock_BadDynamicAreaOptions
        BNE     DynArea_ErrorTranslateAndExit        
22

; now validate maximum size of area

  [ DynArea_QuickHandles
    ;
    ; apply clamps on max size, as set by last call to OS_DynamicArea 8
    ;
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
    [ DA_Batman
        TST     r4, #DynAreaFlags_SparseMap
        BEQ     DAC_notsparse
        LDR     r10, DynArea_OD8Clamp3   ; clamp for sparse dynamic area
        CMP     r5, r10                  ; if requested max size is > relevant clamp
        MOVHI   r5, r10                  ; then clamp it!
        LDR     r10, [sp]                ; requested initial size, from stack
        CMP     r5, r10
        MOVLO   r5, r10                  ; we must try to honour initial size (allowed to break clamp)
        LDR     r10, =ZeroPage
        LDR     r11, [r10, #Page_Size]
        B       DAC_roundup
DAC_notsparse
    ]
        CMP     r5, #-1
        LDREQ   r10, DynArea_OD8Clamp1   ; clamp for max size requested of -1
        LDRNE   r10, DynArea_OD8Clamp2   ; clamp for max size requested of some specific value
        CMP     r5, r10                  ; if requested max size is > relevant clamp
        MOVHI   r5, r10                  ; then clamp it!
        LDR     r10, [sp]                ; requested initial size, from stack
        CMP     r5, r10
        MOVLO   r5, r10                  ; we must try to honour initial size (allowed to break clamp)
  ]

        LDR     r10, =ZeroPage
        LDR     r11, [r10, #Page_Size]
        LDR     r10, [r10, #RAMLIMIT]   ; get total RAM size
        CMP     r5, r10                 ; if requested maximum size is > total
        MOVHI   r5, r10                 ; then set max to total (NB. -1 passed in always yields HI)

DAC_roundup
        SUB     r10, r11, #1            ; also round up to a page multiple
        ADD     r5, r5, r10
        BIC     r5, r5, r10

; now see if we have to allocate a logical address space
        TEQ     r5, #0                  ; If no logical size (i.e. purely physical PMP)
        MOVEQ   r3, #0                  ; Then set base addr to 0
        BEQ     %FT41                   ; And skip straight to claiming the DANode

        CMP     r3, #-1                 ; if we are to allocate the address space
        BEQ     %FT30                   ; then go do it

; otherwise we must check that the address does not clash with anything else

        TST     r3, r10                         ; does it start on a page boundary
        ADRNE   r0, ErrorBlock_AreaNotOnPageBdy ; if not then error
        BNE     DynArea_ErrorTranslateAndExit

        BL      CheckForOverlappingAreas        ; in: r3 = address, r4 = flags, r5 = size; out: if error, r0->error, V=1
        BVC     %FT40
25
        PullEnv
        B       DynArea_ReturnError

30
        BL      AllocateAreaAddress             ; in: r4 = flags, r5 = size of area needed; out: r3, or V=1, r0->error
        BVS     %BT25
40
        BL      AllocateBackingLevel2           ; in: r3 = address, r4 = flags, r5 = size; out: VS if error
        BVS     %BT25

41
        Push    "r0,r1,r3"
  [ DynArea_QuickHandles
    ;we save work and reduce stress on system heap by claiming only one block, consisting of node followed by
    ;string space (always maximum length, but typically not overly wasteful compared to 2nd block overhead)
    ;
        MOV     r3, #DANode_NodeSize + DynArea_MaxNameLength + 1
  |
        MOV     r3, #DANode_NodeSize
  ]
        BL      ClaimSysHeapNode                ; out: r2 -> node
        STRVS   r0, [sp]
        Pull    "r0,r1,r3"
        BVS     %BT25                           ; failed to claim node

; now store data in node (could probably use STM if we shuffled things around)

        CMP     r7, #-1                         ; if workspace ptr = -1
        MOVEQ   r7, r3                          ; then use base address

        STR     r1, [r2, #DANode_Number]
        STR     r3, [r2, #DANode_Base]
  [ DA_Batman
        ;disallow some awkward flag options if SparseMap set (no error), and temporarily create as not sparse
        ;also disallow a DA handler
        TST     r4, #DynAreaFlags_SparseMap
        STREQ   r4, [r2, #DANode_Flags]
        BICNE   r7, r4, #DynAreaFlags_DoublyMapped + DynAreaFlags_NeedsSpecificPages + DynAreaFlags_Shrinkable + DynAreaFlags_SparseMap
        ORRNE   r7, r7, #DynAreaFlags_NotUserDraggable
        STRNE   r7, [r2, #DANode_Flags]
        MOVNE   r6, #0
        MOVNE   r7, #0
  |
        STR     r4, [r2, #DANode_Flags]
  ]
        STR     r5, [r2, #DANode_MaxSize]
        STR     r6, [r2, #DANode_Handler]
        STR     r7, [r2, #DANode_Workspace]
        MOV     r7, #0                          ; initial size is zero
        STR     r7, [r2, #DANode_Size]          ; before we grow it
        TST     r4, #DynAreaFlags_PMP
        STR     r7, [r2, #DANode_PMP]
        STREQ   r7, [r2, #DANode_PMPMaxSize]
        STR     r7, [r2, #DANode_PMPSize]
        BEQ     %FT44
        STR     r3, [r2, #DANode_SparseHWM]
        TEQ     r9, #0
        STR     r9, [r2, #DANode_PMPMaxSize]
        BEQ     %FT44
        ; Allocate and initialise PMP for this DA
        Push    "r0-r3"
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #MaxCamEntry]
        CMP     r9, r0
        ADDHI   r9, r0, #1
        MOV     r3, r9, LSL #2
        BL      ClaimSysHeapNode
        BVS     %FT43
        MOV     r10, r2
        MOV     r0, #-1
42
        SUBS    r3, r3, #4
        STR     r0, [r2], #4
        BNE     %BT42
        Pull    "r0-r3"
        STR     r10, [r2, #DANode_PMP]
        B       %FT44
43
        STR     r0, [sp]
        LDR     r2, [sp, #8]
        BL      FreeSysHeapNode
        Pull    "r0-r3"
        SETV
        B       %BT25
44

        ; update lower limit on IO space growth, if this DA exceeds previous limit
      [ ZeroPage <> 0
        LDR     r7, =ZeroPage
      ]
        LDR     r6, [r7, #IOAllocLimit]
        ADD     lr, r3, r5
        CMP     lr, r6
        STRHI   lr, [r7, #IOAllocLimit]

; now make copy of string - first find out length of string

  [ DynArea_QuickHandles

        ADD     r7, r2, #DANode_NodeSize
        STR     r7, [r2, #DANode_Title]
        Push    "r0"
        MOV     r0, #DynArea_MaxNameLength
        TEQ     r8, #0
    [ DynArea_NullNamePtrMeansHexString
        ASSERT  DynArea_MaxNameLength > 8
        BNE     %FT45
        Push    "r1, r2"
        MOV     r0, r1                          ;string is 8-digit hex of DA number
        MOV     r1, r7
        MOV     r2, #DynArea_MaxNameLength+1
        SWI     XOS_ConvertHex8
        Pull    "r1, r2"
        B       %FT55
    |
        BEQ     %FT50                           ;assume NULL ptr to mean no DA name
    ]
45
        LDRB    r6, [r8], #1
        STRB    r6, [r7], #1
        SUB     r0, r0, #1
        TEQ     r6, #0
        TEQNE   r0, #0
        BNE     %BT45
50
        MOV     r0, #0
        STRB    r0, [r7], #1
55
        Pull    "r0"

  |

        MOV     r7, r8
45
        LDRB    r6, [r7], #1
        TEQ     r6, #0
        BNE     %BT45

        Push    "r0-r3"
        SUB     r3, r7, r8                      ; r3 = length inc. term.
        BL      ClaimSysHeapNode
        STRVS   r0, [sp]
        MOV     r7, r2
        Pull    "r0-r3"
        BVS     StringNodeClaimFailed

        STR     r7, [r2, #DANode_Title]
50
        LDRB    r6, [r8], #1                    ; copy string into claimed block
        STRB    r6, [r7], #1
        TEQ     r6, #0
        BNE     %BT50

 ] ;DynArea_QuickHandles

; now put node on list - list is sorted in ascending base address order

        LDR     r8, =ZeroPage+DAList
        LDR     r6, [r2, #DANode_Base]
60
        MOV     r7, r8
        ASSERT  DANode_Link = 0                 ; For picking up pointer to first real node
        LDR     r8, [r7, #DANode_Link]          ; get next node
        TEQ     r8, #0                          ; if no more
        BEQ     %FT70                           ; then put it on here
        LDR     lr, [r8, #DANode_Base]
        CMP     lr, r6                          ; if this one is before ours
        BCC     %BT60                           ; then loop

70
        STR     r8, [r2, #DANode_Link]
        STR     r2, [r7, #DANode_Link]

  [ DynArea_QuickHandles
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        BL      AddDAToAddrLookupTable
        ;so XOS_ChangeDynamicArea can pick up the node we are still creating
        STR     r1, DynArea_CreatingHandle
        STR     r2, DynArea_CreatingPtr
        ;so initial grow won't leave resize signature
        LDR     lr, DynArea_OD6Signature
        ORR     lr, lr, #&80000000
        STR     lr, DynArea_OD6Signature
  ]

; now we need to grow the area to its requested size

        Push    "r0, r1, r2"
        LDR     r0, [r2, #DANode_Number]
        LDR     r1, [sp, #3*4]                  ; reload requested size off stack
        CMP     r1, #0                          ; skip redundant SWI
        SWINE   XOS_ChangeDynamicArea           ; deal with error - r0,r1,r2 still stacked
        BVS     %FT90
        Pull    "r0, r1, r2"

  [ DynArea_QuickHandles
;
; Now put node on alphabetically sorted list
;
        Push    "r3,r4,r5,r7,r8,r9"
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        ADR     r8, DynArea_SortedList - DANode_SortLink ;so that [r8, #DANode_SortLink] addresses list header)
75
        MOV     r7, r8                       ; previous
        LDR     r8, [r7, #DANode_SortLink]
        TEQ     r8, #0
        BEQ     %FT78
        ;ho hum, UK case insensitive string compare
        LDR     r3, [r2, #DANode_Title]
        LDR     r9, [r8, #DANode_Title]
76
        LDRB    r4, [r3],#1
        uk_LowerCase r4,r11
        LDRB    r5, [r9],#1
        uk_LowerCase r5,r11
        CMP     r4, r5
        BNE     %FT77
        CMP     r4, #0
        BNE     %BT76
77
        BHI     %BT75
78
        STR     r2, [r7, #DANode_SortLink]
        STR     r8, [r2, #DANode_SortLink]
79
        Pull    "r3,r4,r5,r7,r8,r9"
  ] ;DynArea_QuickHandles

  [ DA_Batman
        TST     r4, #DynAreaFlags_SparseMap
        LDRNE   r11, [r2, #DANode_Flags]
        ORRNE   r11, r11, #DynAreaFlags_SparseMap ; set this in node now (after initial grow)
        STRNE   r11, [r2, #DANode_Flags]
        LDRNE   r11, [r2, #DANode_Size]
        LDRNE   lr,  [r2, #DANode_Base]
        ADDNE   r11, r11, lr
        STRNE   r11, [r2, #DANode_SparseHWM]      ; initial high water mark
  ]

  [ DynArea_QuickHandles
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]

        TST     r4, #DynAreaFlags_Shrinkable
        LDRNE   lr, DynArea_ShrinkableSubList
        STRNE   lr, [r2, #DANode_SubLink]
        STRNE   r2, DynArea_ShrinkableSubList   ;link onto front of Shrinkable sublist if Shrinkable

        MOV     lr, #-1
        STR     lr, DynArea_CreatingHandle      ;invalidate this now
        CMP     r1, #ChangeDyn_MaxArea
        BHI     %FT72
        ADR     lr, DynArea_SysQHandleArray
        STR     r2, [lr, r1, LSL #2]            ;system handle - store ptr to node for quick reference
        B       %FT80
72
        LDR     lr, DynArea_OD6Signature
        STR     lr, DynArea_OD6PrevSignature
        ORR     lr, lr, #1
        STR     lr, DynArea_OD6Signature
        STR     r1, DynArea_OD6Handle
        CMP     r1, #DynArea_NewAreas
        BLO     %FT80
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BHS     %FT74
        SUB     r10, r1, #DynArea_NewAreas
        ADR     lr, DynArea_QHandleArray
        LDR     r6, [lr, r10, LSL #2]           ;pick up index of next free quick handle
        STR     r6, DynArea_FreeQHandles        ;store as index of first free quick handle
        STR     r2, [lr, r10, LSL #2]           ;store ptr to node for quick reference
        B       %FT80
74
        LDR     r10, DynArea_TreacleGuess
        ADD     r10, r10, #1
        STR     r10, DynArea_TreacleGuess       ;non-quick handle allocated, increment for next allocate
80
  ] ;DynArea_QuickHandles


; Now issue service to tell TaskManager about it

        Push    "r0, r1, r2"
        MOV     r2, r1                          ; r2 = area number
        MOV     r1, #Service_DynamicAreaCreate
        BL      Issue_Service
        Pull    "r0, r1, r2"

        CLRV
        EXIT

90

; The dynamic area is not being created, because we failed to grow the area to the required size.
; The area itself will have no memory allocated to it (since if grow fails it doesn't move any).
; We must delink the node from our list, free the string node, and then the area node itself.

        STR     r0, [sp, #0*4]                  ; remember error pointer in stacked r0
        STR     r8, [r7, #DANode_Link]          ; delink area
  [ :LNOT: DynArea_QuickHandles
        LDR     r2, [r2, #DANode_Title]
        BL      FreeSysHeapNode                 ; free title string node
  ]
        Pull    "r0, r1, r2"                    ; pull stacked registers, and drop thru to...

  [ :LNOT: DynArea_QuickHandles
; The dynamic area is not being created, because there is no room to allocate space for the title string
; We must free the DANode we have allocated
; It would be nice to also free the backing L2, but we'll leave that for now.

; in: r2 -> DANode

StringNodeClaimFailed
  ]

        Push    "r0, r1"
        BL      FreeSysHeapNode
        Pull    "r0, r1"
  [ DynArea_QuickHandles
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        MOV     lr, #-1
        STR     lr, DynArea_CreatingHandle
  ]
        PullEnv
        B       DynArea_ReturnError

        LTORG

; Add a dynamic area to the quick address lookup table
; In:
;  R2 = DANode ptr
;  R11 = DynArea_ws
AddDAToAddrLookupTable ROUT
        Entry   "r0-r1,r3,r6"
        LDR     r3, [r2, #DANode_MaxSize]
        ADRL    r0, DynArea_AddrLookup
        TEQ     r3, #0
        LDR     r1, [r2, #DANode_Flags]
        BEQ     %FT90
        LDR     r6, [r2, #DANode_Base]
        TST     r1, #DynAreaFlags_DoublyMapped
        SUBNE   r6, r6, r3                      ; Get true start address
        MOVNE   r3, r3, LSL #1
        AND     r1, r6, #DynArea_AddrLookupMask ; Round down start address
        ADD     lr, r6, r3
        AND     r3, lr, #DynArea_AddrLookupMask
        TEQ     lr, r3
        ADDNE   r3, r3, #DynArea_AddrLookupSize ; Round up end address
        SUB     r3, r3, r1
        ADD     r0, r0, r1, LSR #30-DynArea_AddrLookupBits
71
        LDR     lr, [r0], #4
        TEQ     lr, #0
        STREQ   r2, [r0, #-4]
        BEQ     %FT72
        LDR     lr, [lr, #DANode_Base]
        CMP     lr, r6
        STRHI   r2, [r0, #-4]                   ; Update LUT if current entry starts after us
72
        SUBS    r3, r3, #DynArea_AddrLookupSize
        BNE     %BT71
90
        EXIT

;**************************************************************************
;
;       DynArea_Remove - Remove a dynamic area
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (1)
;       r1 = area number
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

DynArea_Remove Entry

        ;*MUST NOT USE QCheckAreaNumber* (need r11 = previous)
        BL      CheckAreaNumber         ; check that area is there
        BCC     UnknownDyn              ; [not found]

  [ DA_Batman
        LDR     lr,[r10,#DANode_Flags]
        TST     lr,#DynAreaFlags_SparseMap
        BEQ     DAR_notsparse
        Push    "r0,r2-r3"
        MOV     r0,#DAReason_SparseRelease
        LDR     r2,[r10,#DANode_Base]
        LDR     r3,[r10,#DANode_MaxSize]
        SWI     XOS_DynamicArea            ;release all pages in sparse area
        STRVS   r0,[SP]
        Pull    "r0,r2-r3"
        EXIT    VS
        B       DAR_delink
DAR_notsparse
        TST     lr, #DynAreaFlags_PMP
        BEQ     DAR_notPMP
        ; Unmap all pages from logical space
        ; This is a bit of a simplistic approach - request for everything to
        ; be unmapped and leave it to PMP_LogOp to detect which pages are and
        ; aren't there
        Push    "r1-r8"
        LDR     r6, [r10, #DANode_Base]
        MOV     r3, #0
        LDR     r4, [r10, #DANode_SparseHWM] ; Assume HWM valid
        MOV     r5, #-1
        SUB     r4, r4, r6
        MOV     r6, #0
        MOV     r4, r4, LSR #12
        MOV     r8, sp
DAR_PMP_logloop
        SUBS    r4, r4, #1
        BLT     DAR_PMP_logunmap
        STMDB   sp!, {r4-r6}
        ADD     r3, r3, #1
        CMP     r3, #85 ; Limit to 1K stack
        BLT     DAR_PMP_logloop
DAR_PMP_logunmap
        MOV     r0, #DAReason_PMP_LogOp
        MOV     r2, sp
        SWI     XOS_DynamicArea
        MOV     sp, r8
        Pull    "r1-r8", VS
        EXIT    VS
        CMP     r4, #0
        MOV     r3, #0
        BGT     DAR_PMP_logloop
        ; Pages are all unmapped, now release them from the PMP
        LDR     r4, [r10, #DANode_PMPMaxSize]
        LDR     r7, [r10, #DANode_PMP]
        MOV     r3, #0
DAR_PMP_physloop
        SUBS    r4, r4, #1
        BLT     DAR_PMP_physunmap
        LDR     lr, [r7, r4, LSL #2]
        CMP     lr, #-1                 ; Save some effort and only release pages which exist
        STMNEDB sp!, {r4-r6}
        ADDNE   r3, r3, #1
        CMP     r3, #85 ; Limit to 1K stack
        BLT     DAR_PMP_physloop
DAR_PMP_physunmap
        MOV     r0, #DAReason_PMP_PhysOp
        MOV     r2, sp
        SWI     XOS_DynamicArea
        MOV     sp, r8
        Pull    "r1-r7", VS
        EXIT    VS
        CMP     r4, #0
        MOV     r3, #0
        BGT     DAR_PMP_physloop
        ; All pages released, safe to free area
        Pull    "r1-r8"
        MOV     r0, #DAReason_Remove
        B       DAR_delink
DAR_notPMP
  ]

  [ DynArea_QuickHandles
        Push    "r11"
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        ;so final shrink won't leave resize signature
        LDR     lr, DynArea_OD6Signature
        ORR     lr, lr, #&80000000
        STR     lr, DynArea_OD6Signature
        Pull    "r11"
  ]

; First try to shrink area to zero size

        Push    "r0-r2"
        MOV     r0, r1                  ; area number
        LDR     r2, [r10, #DANode_Size] ; get current size
        RSBS    r1, r2, #0              ; negate it
        SWINE   XOS_ChangeDynamicArea
        BVS     %FT80
        Pull    "r0-r2"

DAR_delink

  [ DynArea_QuickHandles
;
; delink from sorted list
;
        Push    "r0-r4,r7,r8,r11"
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        ADR     r8, DynArea_SortedList - DANode_SortLink ;so that [r8, #DANode_SortLink] addresses list header)
DAR_sdloop
        MOV     r7, r8                      ;previous
        LDR     r8, [r7, #DANode_SortLink]
        TEQ     r8, #0                      ;just in case not on list, shouldn't happen
        BEQ     DAR_sddone
        TEQ     r8, r10
        BNE     DAR_sdloop
        LDR     r8, [r8, #DANode_SortLink]
        STR     r8, [r7, #DANode_SortLink]
DAR_sddone
; Delink from address lookup table
        LDR     r3, [r10, #DANode_MaxSize]
        ADRL    r0, DynArea_AddrLookup
        TEQ     r3, #0
        LDR     r1, [r10, #DANode_Flags]
        BEQ     DAR_addone
        LDR     r2, [r10, #DANode_Base]
        TST     r1, #DynAreaFlags_DoublyMapped
        SUBNE   r2, r2, r3                      ; Get true start address
        MOVNE   r3, r3, LSL #1
        AND     r1, r2, #DynArea_AddrLookupMask ; Round down start address
        ADD     lr, r2, r3
        AND     r3, lr, #DynArea_AddrLookupMask
        TEQ     lr, r3
        ADDNE   r3, r3, #DynArea_AddrLookupSize ; Round up end address
        SUB     r3, r3, r1
        ADD     r0, r0, r1, LSR #30-DynArea_AddrLookupBits
DAR_adloop
        LDR     lr, [r0], #4
        TEQ     lr, r10
        BNE     DAR_adnext
        ; Update to point to next DA, or null if next is outside this chunk
        LDR     lr, [lr, #DANode_Link]
        TEQ     lr, #0
        STREQ   lr, [r0, #-4]
        BEQ     DAR_adnext
        LDR     r4, [lr, #DANode_Flags]
        LDR     r2, [lr, #DANode_Base]
        TST     r4, #DynAreaFlags_DoublyMapped
        LDRNE   r4, [lr, #DANode_MaxSize]
        SUBNE   r2, r2, r4
        AND     r2, r2, #DynArea_AddrLookupMask
        TEQ     r2, r1
        MOVNE   lr, #0
        STR     lr, [r0, #-4]
DAR_adnext
        SUBS    r3, r3, #DynArea_AddrLookupSize
        ADD     r1, r1, #DynArea_AddrLookupSize
        BNE     DAR_adloop
DAR_addone
        Pull    "r0-r4,r7,r8,r11"

  ] ;DynArea_QuickHandles

; Now just de-link from list (r10 -> node, r11 -> prev)

        LDR     lr, [r10, #DANode_Link] ; store our link
        STR     lr, [r11, #DANode_Link] ; in prev link

  [ DynArea_QuickHandles
        ;if it is a Shrinkable area, find on Shrinkable sublist and remove it
        Push    "r0-r2, r11"
        LDR     r0, [r10, #DANode_Flags]
        TST     r0, #DynAreaFlags_Shrinkable
        BEQ     %FT06
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        ADR     r1, DynArea_ShrinkableSubList
        LDR     r2, [r1]
04
        CMP     r2, r10
        LDREQ   r2, [r2, #DANode_SubLink]
        STREQ   r2, [r1]
        BEQ     %FT06
        ADD     r1, r2, #DANode_SubLink
        LDR     r2, [r2, #DANode_SubLink]
        B       %BT04
06
        Pull    "r0-r2, r11"
  ]

        Push    "r0-r2"
  [ :LNOT: DynArea_QuickHandles
        LDR     r2, [r10, #DANode_Title]        ; free title string block
        BL      FreeSysHeapNode
  ]
        LDR     r2, [r10, #DANode_PMP]
        CMP     r2, #0
        BLNE    FreeSysHeapNode
        MOV     r2, r10                         ; and free node block
        BL      FreeSysHeapNode
        Pull    "r0-r2"

  [ DynArea_QuickHandles
        Push    "r2, r3"
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        MOV     r2,#-1
        STR     r2, DynArea_CreatingHandle                ; invalidate these, just in case
        STR     r2, DynArea_LastTreacleHandle
        STR     r2, DynArea_LastEnumHandle
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT08                                     ; system area being removed
        LDR     r2, DynArea_OD6Signature
        STR     r2, DynArea_OD6PrevSignature
        ORR     r2, r2, #2
        STR     r2, DynArea_OD6Signature
        STR     r1, DynArea_OD6Handle
        CMP     r1, #DynArea_NewAreas
        BLO     %FT10
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BHS     %FT10
        SUB     r2, r1, #DynArea_NewAreas-1               ; index of quick handle
        ADR     r10, DynArea_FreeQHandles                 ; so we can index array from 1
        LDR     r3, DynArea_FreeQHandles
        STR     r3, [r10, r2, LSL #2]
        STR     r2, DynArea_FreeQHandles                  ; put on front of free list
        B       %FT10
08
        ADR     r10, DynArea_SysQHandleArray
        MOV     r2,  #0
        STR     r2,  [r10, r1, LSL #2]                    ; reset system Qhandle
10
        Pull    "r2, r3"

  ]

; Issue service to tell TaskManager

        Push    "r0, r1, r2"
        MOV     r2, r1
        MOV     r1, #Service_DynamicAreaRemove
        BL      Issue_Service
        Pull    "r0, r1, r2"

        CLRV
        EXIT

; come here if shrink failed - r0-r2 stacked

80
        STR     r0, [sp]                ; overwrite stacked r0 with error pointer
        LDR     r0, [sp, #1*4]          ; reload area number
        LDR     r1, [r10, #DANode_Size] ; get size after failed shrink
        SUB     r1, r2, r1              ; change needed to restore original size
        SWI     XOS_ChangeDynamicArea   ; ignore any error from this
        Pull    "r0-r2"
        SETV
        EXIT

UnknownDyn
        ADRL    r0, ErrorBlock_BadDynamicArea
 [ International
        BL      TranslateError
 |
        SETV
 ]
        EXIT

;**************************************************************************
;
;       DynArea_GetInfo - Get info on a dynamic area
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (2)
;       r1 = area number
;
; out:  r2 = current size of area
;       r3 = base logical address
;       r4 = area flags
;       r5 = maximum size of area
;       r6 -> area handler routine
;       r7 = workspace pointer
;       r8 -> title string
;       r10-r12 may be corrupted
;       All other registers preserved
;

DynArea_GetInfo ALTENTRY
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     UnknownDyn              ; [it doesn't]

; r10 -> node, so get info

        LDR     r4, [r10, #DANode_Flags]
        LDR     r3, [r10, #DANode_Base]
        LDR     r6, [r10, #DANode_Handler]
        TST     r4, #DynAreaFlags_PMP
        LDREQ   r2, [r10, #DANode_Size]
        LDREQ   r5, [r10, #DANode_MaxSize]
        BEQ     %FT10
        LDR     r2, [r10, #DANode_PMPSize]
        LDR     r5, [r10, #DANode_PMPMaxSize]
        CMP     r2, #DynArea_PMP_BigPageCount
        MOVLO   r2, r2, LSL #12
        LDRHS   r2, =DynArea_PMP_BigByteCount
        CMP     r5, #DynArea_PMP_BigPageCount
        MOVLO   r5, r5, LSL #12
        LDRHS   r5, =DynArea_PMP_BigByteCount
10
        LDR     r7, [r10, #DANode_Workspace]
        LDR     r8, [r10, #DANode_Title]
        CLRV
        EXIT

;**************************************************************************
;
;       DynArea_GetChangeInfo
;
;       Get info on changes to *non-system* dynamic areas
;       Reserved for Acorn use (intended for TaskManager, can only serve one client)
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (6)
;
; out:  r1 = Number of affected area, if a single change has occurred since last call,
;          = -1, if no changes or more than one change have occurred
;       r2 = signature of changes to non-system dynamic areas since last call to
;            OS_DynamicArea 6
;            bit 0 = 1 if any non-system areas have been created
;            bit 1 = 1 if any non-system areas have been removed
;            bit 2 = 1 if any non-system areas have been resized
;            bit 3 = 1 if any non-system areas have been renumbered
;            bits 4-31 reserved (undefined)
;
;Notes:
; (1) bit 2 of r2 excludes the initial grow of a created area, and the final
;     shrink of a removed area
; (2) if a single renumber has occurred, r1 is the old number

  [ DynArea_QuickHandles

DynArea_GetChangeInfo ROUT
        Push    "lr"
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        LDR     r1, DynArea_OD6Handle
        LDR     r2, DynArea_OD6Signature
        LDR     lr, DynArea_OD6PrevSignature
        CMP     lr, #0
        MOVNE   r1, #-1
        CMP     r2, #0
        MOVEQ   r1, #-1
        MOV     lr, #0
        STR     lr, DynArea_OD6Signature
        STR     lr, DynArea_OD6PrevSignature
        CLRV
        Pull    "PC"

  ] ;DynArea_QuickHandles

;**************************************************************************
;
;       DynArea_EnumerateInfo
;
;       Enumerate *non-system* dynamic areas, returning selected info
;       Reserved for Acorn use (intended for TaskManager)
;
; in:   r0 = reason code (7)
;       r1 = -1 to start enumeration, or area number to continue from
;
; out:  r1 = number of next area found, or -1 if no more areas
;       r2 = current size of area, if area found
;       r3 = base logical address, if area found
;       r4 = area flags, if area found
;       r5 = maximum size of area, if area found
;       r6 -> title string, if area found
;
;Notes:
; (1) r2-r6 on exit are undefined if r1 = -1
;

  [ DynArea_QuickHandles

DynArea_EnumerateInfo ROUT
        Push    "lr"

        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]

        CMP     r1, #-1                         ; if starting from beginning
        LDREQ   r10, DynArea_SortedList         ; then load pointer to 1st node on sorted list
        BEQ     %FT10                           ; and skip

        LDR     r10, DynArea_LastEnumHandle
        CMP     r10, r1
        LDREQ   r10, DynArea_LastEnumPtr        ; pick up where we left off
        BEQ     %FT08
        BL      QCheckAreaNumber                ; else check valid area number
        BCC     %FT14

08
        LDR     r10, [r10, #DANode_SortLink]    ; find next one
10
        TEQ     r10, #0                         ; if at end
        MOVEQ   r1, #-1                         ; then return -1
        BEQ     %FT12
        LDR     r1, [r10, #DANode_Number]       ; else return number
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %BT08                           ; skip if system area

        LDR     r4, [r10, #DANode_Flags]        ; return rest of info
        LDR     r3, [r10, #DANode_Base]
        LDR     r6, [r10, #DANode_Title]
        TST     r4, #DynAreaFlags_PMP
        LDREQ   r2, [r10, #DANode_Size]
        LDREQ   r5, [r10, #DANode_MaxSize]
        BEQ     %FT11
        LDR     r2, [r10, #DANode_PMPSize]
        LDR     r5, [r10, #DANode_PMPMaxSize]
        CMP     r2, #DynArea_PMP_BigPageCount
        MOVLO   r2, r2, LSL #12
        LDRHS   r2, =DynArea_PMP_BigByteCount
        CMP     r5, #DynArea_PMP_BigPageCount
        MOVLO   r5, r5, LSL #12
        LDRHS   r5, =DynArea_PMP_BigByteCount
11

        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        STR     r1, DynArea_LastEnumHandle
        STR     r10, DynArea_LastEnumPtr        ; save a lot of messing about on next call
12
        CLRV
        Pull    "PC"

;it's a reserved call, so naff off internationalisation
14
        ADR     r0,DynArea_badei
        SETV
        Pull    "PC"
DynArea_badei
        DCD     0
        DCB     "bad DA number",0
        ALIGN

  ] ;DynArea_QuickHandles

;**************************************************************************
;
;       DynArea_SetClamps
;
;       Set clamps on max size of dynamic areas created by subsequent
;       calls to OS_DynamicArea 0
;
;   On entry
;       R0 = 8 (reason code)
;       R1 = limit on maximum size of (non-Sparse) areas created by
;            OS_DynamicArea 0 with R5 = -1, or 0 to read only
;       R2 = limit on maximum size of (non-Sparse) areas created by
;            OS_DynamicArea 0 with R5 > 0, or 0 to read only
;       R3 = limit on maximum size of Sparse areas created by
;            OS_DynamicArea 0 with R4 bit 10 set, or 0 to read only
;
;   On exit
;       R1 = previous limit for OS_DynamicArea 0 with R5 = -1
;       R2 = previous limit for OS_DynamicArea 0 with R5 > 0
;       R3 = previous limit for OS_DynamicArea 0 with R4 bit 10 set
;
;       Specifying -1 in R1 or R2 means the respective limit
;       is the RAM limit of the machine (this is the default).
;       Specifiying larger than the RAM limit in R1 or R2 is
;       equivalent to specifiying -1.
;
  [ DynArea_QuickHandles

DynArea_SetClamps ROUT
        Push    "r9,lr"

        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]

        LDR     r10, DynArea_OD8Clamp1
        LDR     lr,  DynArea_OD8Clamp2
        LDR     r9,  DynArea_OD8Clamp3

;insist on at least 1M for a clamp value (ignore anything lower)
;
        CMP     r1, #&100000
        STRHS   r1, DynArea_OD8Clamp1
        CMP     r2, #&100000
        STRHS   r2, DynArea_OD8Clamp2
        CMP     r3, #&100000
        STRHS   r3, DynArea_OD8Clamp3

        MOV     r1, r10
        MOV     r2, lr
        MOV     r3, r9

        CLRV
        Pull    "r9,PC"

  ] ;DynArea_QuickHandles

;**************************************************************************

;       DynArea_SparseClaim
;
;  Ensure region of sparse dynamic area is mapped to valid memory
;
; in:   r0 = reason code (9)
;       r1 = area number
;       r2 = base of region to claim
;       r3 = size of region to claim
;
; out:  r0-r3 preserved (error if not all of region successfully mapped)
;       r10-r12 may be corrupted
;
; action: - round base and size to page granularity
;         - scan the L2PT for each page covered
;         - find contiguous fragments of 1 or more pages that are not yet mapped-in
;         - pass each of these fragments as a psuedo DANode to OS_ChangeDynamicArea
;           via special Batcall), to 'grow' pages into each fragment
;
  [ DA_Batman

DynArea_SparseClaim ROUT
        Push    "r0-r9,lr"
        MOV     r4,#1                   ; flags operation as a claim

DynArea_SparseChange                    ; common entry point for claim and release

  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     DA_naffsparse           ; area not there

        LDR     r9,[r10,#DANode_Flags]
        TST     r9,#DynAreaFlags_SparseMap
        BEQ     DA_naffsparse           ; area not sparse

        MOV     r9,#&1000               ;page size
        SUB     r9,r9,#1
        ADD     r3,r3,r2                ;base+size
        CMP     r4,#1
        BICEQ   r2,r2,r9                ;round base down to page granularity for claim
        ADDEQ   r3,r3,r9
        BICEQ   r3,r3,r9                ;round base+size up to page granularity for claim
        ADDNE   r2,r2,r9
        BICNE   r2,r2,r9                ;round base up to page granularity for release
        BICNE   r3,r3,r9                ;round base+size down to page granularity for release
        SUB     r3,r3,r2                ;rounded size

        ADD     r9,r3,r2
        LDR     r5,[r10,#DANode_Base]
        LDR     r6,[r10,#DANode_MaxSize]
        ADD     r6,r6,r5
        CMP     r2,r5
        CMPHS   r9,r5
        BLO     DA_naffsparse
        CMP     r2,r6
        CMPLS   r9,r6
        BHI     DA_naffsparse

        ADD     r5,r2,r3                   ;base+size of mapping
        LDR     r6,[r10,#DANode_SparseHWM] ;high water mark = highest claim base+size seen
        CMP     r4,#1
        BEQ     %FT08
        CMP     r5,r6
        SUBHI   r3,r6,r2                   ;for release we can save work by trimming to high water mark
        B       %FT09                      ;r3 is now trimmed size (may be <=0 for trim to nothing)
08
        CMP     r5,r6
        STRHI   r5,[r10,#DANode_SparseHWM] ;for claim remember highest base+size as high water mark
09
        SUB     SP,SP,#DANode_NodeSize  ;room for temporary DANode on stack
        MOV     r9,r10                  ;actual sparse area DANode
        MOV     r5,SP
        MOV     r6,#DANode_NodeSize
10
        LDR     r7,[r9],#4           ;copy sparse area node to temp node
        STR     r7,[r5],#4
        SUBS    r6,r6,#4
        BNE     %BT10
        ADD     r3,r2,r3             ;stop address
;
        LDR     r5,=L2PT
        ADD     r5,r5,r2,LSR #10     ;r5 -> L2PT for base (assumes 4k page)
        MOV     r8,r2                ;start address
;
;look for next fragment of region that needs to have mapping change
20
        CMP     r8,r3
        BHS     %FT50                ;done
        LDR     r6,[r5],#4           ;pick-up next L2PT entry
        CMP     r4,#0                ;if operation is a release...
        CMPEQ   r6,#0                ;...and L2PT entry is 0 (not mapped)...
        ADDEQ   r8,r8,#&1000         ;...then skip page (is ok)
        BEQ     %BT20
        CMP     r4,#0                ;if operation is a claim (not 0)...
        CMPNE   r6,#0                ;...and L2PT entry is non-0 (mapped)...
        ADDNE   r8,r8,#&1000         ;...then skip page (is ok)
        BNE     %BT20
        MOV     r1,#&1000            ;else we need to do a change (1 page so far)
30
        ADD     r9,r8,r1
        CMP     r9,r3
        BHS     %FT40
        LDR     r6,[r5],#4           ;pick-up next L2PT entry
        CMP     r4,#1                ;if operation is a release (not 1)...
        CMPNE   r6,#0                ;...and L2PT entry is non-0 (mapped)...
        ADDNE   r1,r1,#&1000         ;...then count page as needing change
        BNE     %BT30
        CMP     r4,#1                ;if operation is a claim...
        CMPEQ   r6,#0                ;...and L2PT entry is 0 (not mapped)...
        ADDEQ   r1,r1,#&1000         ;...then count page as needing change
        BEQ     %BT30
;set up pseudo DA and do Batcall to change mapping of fragment we have found
40
        MOV     r2,SP                  ;temp DANode
        STR     r8,[r2,#DANode_Base]
        ADD     r8,r8,r1
        ADD     r8,r8,#&1000           ;next address to check after fragment
        CMP     r4,#1
        MOVEQ   r9,#0                  ;start size of 0 for claim
        MOVNE   r9,r1                  ;start size of fragment size for release
        STR     r9,[r2,#DANode_Size]
        STR     r1,[r2,#DANode_MaxSize]
        MOV     r0,#ChangeDyn_Batcall
        CMP     r4,#0
        RSBEQ   r1,r1,#0               ;batshrink for release, batgrow for claim
        SWI     XOS_ChangeDynamicArea
        TEQ     r4,#0
        RSBEQ   r1,r1,#0
        LDR     r9,[r10,#DANode_Size]
        ADD     r9,r9,r1
        STR     r9,[r10,#DANode_Size]
        BVC     %BT20
;
50
        ADD     SP,SP,#DANode_NodeSize   ;drop temp DANode
        BVS     %FT52
        BL      DA_sparse_serviceandsig
        Pull    "r0-r9,PC"
;
52
        BL      DA_sparse_serviceandsig
        SETV
        STR     r0,[SP]
        Pull    "r0-r9,PC"

DA_naffsparse
        ADR     r0,DA_naffsparseinnit
        SETV
        STR     r0,[SP]
        Pull    "r0-r9,PC"
DA_naffsparseinnit
        DCD     0
        DCB     "invalid OS_DynamicArea sparse claim/release",0
        ALIGN

DA_sparse_serviceandsig ROUT
        Push    "r0,LR"
        LDR     r1,[r10,#DANode_Number]
   [ DynArea_QuickHandles
        LDR     r11,=ZeroPage
        LDR     r11,[r11, #DynArea_ws]
        LDR     r5,DynArea_OD6Signature
        STR     r5,DynArea_OD6PrevSignature
        ORR     r5,r5,#4                     ;signal a resize
        STR     r5,DynArea_OD6Signature
        STR     r1,DynArea_OD6Handle
   ]
        MOV     r2,r1                    ;area number
        MOV     r0,#0                    ;nominal 'grow/shrink' of 0 for service call
        MOV     r1,#Service_MemoryMoved
        BL      Issue_Service
        Pull    "r0,PC"

  ] ;DA_Batman

;**************************************************************************
;
;       DynArea_SparseRelease
;
;  Allow region of sparse dynamic area to release memory to free pool
;
; in:   r0 = reason code (10)
;       r1 = area number
;       r2 = base of region to release
;       r3 = size of region to release
;
; out:  r0-r3 preserved (error if not all of region successfully released)
;       r10-r12 may be corrupted
;
;
; action: - similar to DynArea_SparseClaim, but does 'shrinks' on fragments
;           that are mapped in

  [ DA_Batman

DynArea_SparseRelease ROUT
        Push    "r0-r9,lr"
        MOV     r4,#0                   ; flags operation as a release
        B       DynArea_SparseChange    ; jump to common code

  ] ;DA_Batman

;**************************************************************************
;
;       DynArea_Enumerate - Enumerate dynamic areas
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (3)
;       r1 = -1 to start enumeration, or area number to continue from
;
; out:  r1 = next area number or -1 if no next
;       r10-r12 may be corrupted
;       All other registers preserved

DynArea_Enumerate ALTENTRY
  [ DynArea_QuickHandles
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
  ]
        CMP     r1, #-1                         ; if starting from beginning
  [ DynArea_QuickHandles
        LDREQ   r10, DynArea_SortedList         ; then load pointer to 1st node on sorted list
  |
    [ ZeroPage = 0
        LDREQ   r10, [r1, #DAList+1]            ; then load pointer to 1st node
    |
        LDREQ   r10, =ZeroPage
        LDREQ   r10, [r10, #DAList]
    ]
  ]
        BEQ     %FT10                           ; and skip

  [ DynArea_QuickHandles
        LDR     r10, DynArea_LastEnumHandle
        CMP     r10, r1
        LDREQ   r10, DynArea_LastEnumPtr        ; pick up where we left off
        BEQ     %FT08
        BL      QCheckAreaNumber                ; else check valid area number
  |
        BL      CheckAreaNumber                 ; else check valid area number
  ]
        BCC     UnknownDyn                      ; complain if passed in duff area number

08
  [ DynArea_QuickHandles
        LDR     r10, [r10, #DANode_SortLink]    ; find next one
  |
        LDR     r10, [r10, #DANode_Link]        ; find next one
  ]
10
        TEQ     r10, #0                         ; if at end
        MOVEQ   r1, #-1                         ; then return -1
        BEQ     %FT12
        LDR     r1, [r10, #DANode_Number]       ; else return number

  [ DynArea_QuickHandles
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        STR     r1, DynArea_LastEnumHandle
        STR     r10, DynArea_LastEnumPtr        ; save a lot of messing about on next call
  ]
12
        CLRV
        EXIT

;**************************************************************************
;
;       DynArea_Renumber - Renumber dynamic area
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (4)
;       r1 = old area number
;       r2 = new area number
;

DynArea_Renumber ALTENTRY
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT92                           ; can't renumber a system area
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT92
  [ DynArea_QuickHandles
        CMP     r1, #DynArea_NewAreas
        BLO     %FT10
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BLO     %FT92                           ; can't renumber a quick handle
10
        CMP     r2, #DynArea_NewAreas
        BLO     %FT12
        CMP     r2, #DynArea_NewAreas+DynArea_NumQHandles
        BLO     %FT92                           ; can't choose your own quick handle
12
        BL      QCheckAreaNumber
  |
        BL      CheckAreaNumber                 ; check valid area number
  ]
        BCC     UnknownDyn                      ; [it's not]

        Push    "r1"
        MOV     r12, r10                        ; save pointer to node
        MOV     r1, r2
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; check area r2 doesn't already exist
  |
        BL      CheckAreaNumber                 ; check area r2 doesn't already exist
  ]
        Pull    "r1"
        BCS     %FT90                           ; [area r2 already exists]

        STR     r2, [r12, #DANode_Number]

; Now issue service to tell TaskManager

        Push    "r1-r3"
        MOV     r3, r2                          ; new number
        MOV     r2, r1                          ; old number
        MOV     r1, #Service_DynamicAreaRenumber
        BL      Issue_Service
        Pull    "r1-r3"

  [ DynArea_QuickHandles
        LDR     r11, =ZeroPage                         ; we know system areas cannot be renumbered
        LDR     r11, [r11, #DynArea_ws]
        MOV     r10, #-1
        STR     r10, DynArea_CreatingHandle     ; invalidate these, just in case
        STR     r10, DynArea_LastTreacleHandle
        STR     r10, DynArea_LastEnumHandle
        LDR     lr, DynArea_OD6Signature
        STR     lr, DynArea_OD6PrevSignature
        ORR     lr, lr, #8
        STR     lr, DynArea_OD6Signature
        STR     r1, DynArea_OD6Handle
  ]

        CLRV
        EXIT

90
        ADRL    r0, ErrorBlock_AreaAlreadyExists
 [ International
        BL      TranslateError
 |
        SETV
 ]
        EXIT

;if you think this is worth internationalising, I pity you
92
        ADR     r0, DynArea_NaughtyRenum
        SETV
        EXIT
DynArea_NaughtyRenum
        DCD     0
        DCB     "illegal DA renumber",0
        ALIGN

        LTORG

 [ ShrinkableDAs
;**************************************************************************
;
;       DynArea_ReturnFree - Return total free space, including shrinkables
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (5)
;       r1 = area number to exclude, or -1 to include all shrinkable areas
;
; out:  r2 = total amount of free memory
;

DynArea_ReturnFree ALTENTRY
        CMP     r1, #-1                         ; if no excluded area,
        MOVEQ   r10, r1                         ; then point r10 nowhere
        BEQ     %FT10

  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; else check area number is valid
  |
        BL      CheckAreaNumber                 ; else check area number is valid
  ]
        BCC     UnknownDyn                      ; [unknown area]
10
        LDR     r2, =ZeroPage
        LDR     r2, [r2, #FreePoolDANode + DANode_PMPSize] ; start with current size of free pool
  [ DynArea_QuickHandles
        ;traverse the Shrinkable sublist
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        LDR     r11, DynArea_ShrinkableSubList
        B       %FT21
  |
        LDR     r11, =ZeroPage+DAList
  ]
20
  [ DynArea_QuickHandles
        LDR     r11, [r11, #DANode_SubLink]     ; load next area on sublist
  |
        LDR     r11, [r11, #DANode_Link]        ; load next area
  ]
21
        TEQ     r11, #0                         ; if end of list
        BEQ     %FT90                           ; then exit, with r2 = correct value

  [ DynArea_QuickHandles
        TEQ     r11, r10                        ; must not be the excluded area
  |
        LDR     lr, [r11, #DANode_Flags]        ; load area flags
        TST     lr, #DynAreaFlags_Shrinkable    ; must be shrinkable
        TEQNE   r11, r10                        ; and not excluded area
  ]
        BEQ     %BT20                           ; [don't try this one]

        Push    r3
        BL      CallTestShrink
        ADD     r2, r2, r3, LSR #12             ; add on amount if any
        Pull    r3
        B       %BT20                           ; then go back for more

90
        CMP     r2, #DynArea_PMP_BigPageCount
        MOVLO   r2, r2, LSL #12
        LDRHS   r2, =DynArea_PMP_BigByteCount
        EXIT
 ]

;**************************************************************************
;
;       DynArea_Locate - Return area number given an address
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (20)
;       r1 = logical address to locate
;
; out:  r0 = area type (0=dynamic, 1=system, others reserved)
;       r1 = area number
;       r10-r12 may be corrupted
;       All other registers preserved
;

DynArea_Locate Entry "r2-r5"
        MOV     r5, r1

        MOV     r4, #1
10
        MOV     r0, r4, LSL #8
        BL      MemoryAreaInfo
        BVS     %FT20                           ; no more system areas

        ADD     r2, r1, r2                      ; r1:=base r2:=top
        CMP     r5, r1
        CMPCS   r2, r5
        MOVHI   r1, r4                          ; number
        MOVHI   r0, #1                          ; system area
        EXIT    HI

        ADD     r4, r4, #1
        B       %BT10
20
  [ DynArea_QuickHandles
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]

        ADR     r3, DynArea_SysQHandleArray
        MOV     r4, #0
30
        LDR     r10, [r3, r4, LSL #2]
        TEQ     r10, #0
        BLNE    %FT60                           ; check system DA node

        ADD     r4, r4, #1
        CMP     r4, #ChangeDyn_MaxArea
        BLS     %BT30

        ADR     r3, DynArea_QHandleArray
        MOV     r4, #0
40
        LDR     r10, [r3, r4, LSL #2]
        CMP     r10, #DynArea_NumQHandles
        BLHI    %FT60                           ; check quick DA node

        ADD     r4, r4, #1
        CMP     r4, #DynArea_NumQHandles
        BCC     %BT40
  ]
        LDR     r10, =ZeroPage+DAList
        ASSERT  DANode_Link = 0                 ; because DAList has only link
50
        LDR     r10, [r10, #DANode_Link]
        TEQ     r10, #0
        PullEnv EQ
        ADREQL  r0, ErrorBlock_BadAddress
        BEQ     DynArea_TranslateAndReturnError

        BL      %FT60                           ; check treacle DA node
        B       %BT50
60
        LDR     r1, [r10, #DANode_Flags]
        LDR     r0, [r10, #DANode_MaxSize]
        TST     r1, #DynAreaFlags_DoublyMapped
        LDR     r1, [r10, #DANode_Base]
        ADD     r2, r1, r0                      ; r1:=base r2:=top
        SUBNE   r1, r1, r0                      ; doubly mapped is special
        CMP     r5, r1
        CMPCS   r2, r5
        LDRHI   r1, [r10, #DANode_Number]       ; number
        MOVHI   r0, #0                          ; dynamic area
        EXIT    HI

        MOV     pc, lr                          ; not within this one

;**************************************************************************
;
;       DynArea_PMP_PhysOp
;
;  Claim/release physical memory pages in physical memory pool
;
; in:   r0 = reason code (21)
;       r1 = area number
;       r2 = pointer to array of (PMP page index, phys page index, page flag) tuples
;            phys page index -1 to release
;            phys page index -2 to let kernel pick page
;            otherwise page number to use
;            page flags are defined by DynAreaFlags_PMPPhysOpAccessMask
;       r3 = number of entries
;
; out:  r0-r1 preserved (error if not all of region successfully updated)
;       r2 advanced to first entry not processed (or end of list)
;       r3 updated to number of entries not processed (or 0)
;       r10-r12 may be corrupted
;
DynArea_PMP_PhysOp ROUT
        ; Strategy:
        ; - Check free pool has enough pages to satisfy claim
        ; - Walk page list, comparing against current PMP state
        ; - If free required, check not in use and push straight into free pool
        ; - If kernel auto-alloc required, grab last page from free pool
        ; - If specific page required, batcall into OS_ChangeDynamicArea to let it deal with page reclaiming
        Entry   "r0-r9"
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     %FT90                   ; [it doesn't]
01
        ; r10 -> DANode
        LDR     r8, [r10, #DANode_PMP]
        CMP     r8, #0
        LDR     r9, [r10, #DANode_PMPMaxSize]
        BEQ     %FT90
        BL      ClaimCDASemaphore
        BNE     %FT91
        ; Before we begin, check to see if there's enough space in the free pool to satisfy any map in requests
        LDR     r7, =ZeroPage
        LDR     r11, [r7, #MaxCamEntry]
        LDR     r0, [r7, #FreePoolDANode+DANode_PMPSize]
        LDR     r7, [r7, #CamEntriesPointer]
        CMP     r0, r3
        BHS     %FT45
        ; Free pool may be too small - scan the page list and the PMP to work out exactly how many pages are required
        ; If there aren't enough, try growing the free pool (shrink app space, shrink shrinkables, etc.)
        MOV     r12, #0
        MOV     r1, #0
10
        SUBS    r3, r3, #1
        BLO     %FT20
        LDMIA   r2!, {r4-r6}
        ; Check for silly PMP page index
        CMP     r4, r9
        BHS     %FT92
        ; Check for silly phys page index
        CMP     r5, #-3
        CMPLS   r11, r5
        BLS     %FT92
        ; Look up the page that's currently in the PMP
        LDR     r0, [r8, r4, LSL #2]
        TEQ     r0, r5
        BEQ     %BT10
        ; Do we need to release the existing page?
        CMP     r0, #-1
        BEQ     %FT15
        CMP     r5, #-2
        BEQ     %BT10                   ; Page is currently there, and we want a kernel picked page -> no action required
        ; A page is currently there, but we either want to release it or to swap in a different page.
        SUB     r12, r12, #1            ; Count page release
15
        ; Map in new page if required
        CMP     r5, #-2
        BHI     %BT10 ; i.e. -1
        ADD     r12, r12, #1            ; Count page claim
        ; Because we process list entries in order, we actually need to keep track of the maximum number of pages needed in the free pool at any point in the list, rather than just the delta we'll have at the end
        CMP     r12, r1
        MOVGT   r1, r12
        B       %BT10
20
        ; r1 = number of pages needed in free pool
      [ PMPDebug
        DebugReg r1, "Want this many pages: "
      ]
        MOV     r12, r10
        BL      GrowFreePool
        BCC     %FT94
        ; Enough space is available, reset r2 & r3 and process the list properly
        FRAMLDR r2
        FRAMLDR r3

45
        LDR     r12, [r10, #DANode_PMPSize]
        ; Usage in main loop:
        ; r2 -> input page list
        ; r3 = length
        ; r4 = current entry PMP index
        ; r5 = current entry phys page index
        ; r6 = current entry flags
        ; r7 -> CAM
        ; r8 -> PMP
        ; r9 = PMPMaxSize
        ; r10 -> DANode
        ; r11 = MaxCamEntry
        ; r12 = current PMPSize
        ; r0, r1 temp
50
        SUBS    r3, r3, #1
        BLO     %FT80
        LDMIA   r2!, {r4-r6}
        ; Check for silly PMP page index
        CMP     r4, r9
        BHS     %FT93
        ; Check for silly phys page index
        CMP     r5, #-3
        CMPLS   r11, r5
        BLS     %FT93
        AND     r6, r6, #DynAreaFlags_PMPPhysOpAccessMask
        ; Look up the page that's currently in the PMP
        LDR     r0, [r8, r4, LSL #2]
        TEQ     r0, r5
        BNE     %FT52
        ; Page is there - check/update flags
        ADD     r0, r7, r0, LSL #CAM_EntrySizeLog2
        LDR     r1, [r0, #CAM_PageFlags]
        BIC     lr, r1, #DynAreaFlags_PMPPhysOpAccessMask
        ORR     lr, lr, r6
        TEQ     r1, lr
        STRNE   lr, [r0, #CAM_PageFlags]
        B       %BT50
52
        ; Do we need to release the existing page?
        CMP     r0, #-1
        BEQ     %FT55
        CMP     r5, #-2
        BEQ     %BT50                   ; Page is currently there, and we want a kernel picked page -> no action required
        ; A page is currently there, but we either want to release it or to swap in a different page. Start by releasing the existing page.
        ; TODO - if we're swapping with another page we'll probably want to preserve the contents (have a flag to control behaviour)
        ; Check page isn't mapped in
        ASSERT  CAM_LogAddr=0
        LDR     r1, [r7, r0, LSL #CAM_EntrySizeLog2]
      [ PMPDebug
        DebugReg r0, "Releasing page: "
        DebugReg r1, "Current addr: "
      ]
        LDR     lr, =Nowhere
        TEQ     r1, lr
        BNE     %FT95
        ; Add the page back into the free pool
        Push    "r2-r5,r12"
        LDR     r4, =ZeroPage+FreePoolDANode
        LDR     r12, [r4, #DANode_PMP]
        LDR     r5, [r4, #DANode_PMPSize]
        STR     r0, [r12, r5, LSL #2]
        ADD     r2, r7, r0, LSL #CAM_EntrySizeLog2
        LDR     r3, [r4, #DANode_Flags]
        LDR     lr, =DynAreaFlags_AccessMask
        AND     r3, r3, lr
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        STMIB   r2, {r3-r5}
        ADD     r5, r5, #1
        STR     r5, [r4, #DANode_PMPSize]
        Pull    "r2-r5,r12"
        ; Page no longer owned by us
        MOV     r0, #-1
        STR     r0, [r8, r4, LSL #2]
        SUB     r12, r12, #1
55
        ; Map in new page if required
        CMP     r5, #-2
        BHI     %BT50 ; i.e. -1
        BLO     %FT60
      [ PMPDebug
        DebugTX "Kernel-picking page"
      ]
        ; Kernel-picked page required. Pick the last page from the free pool.
        LDR     r0, =ZeroPage+FreePoolDANode
        LDR     r1, [r0, #DANode_PMP]
        LDR     r5, [r0, #DANode_PMPSize]
        SUBS    r5, r5, #1
        BLO     %FT95                   ; Shouldn't happen
        STR     r5, [r0, #DANode_PMPSize]
        LDR     r5, [r1, r5, LSL #2]!
        MOV     r0, #-1
        STR     r0, [r1]
        ; Add to our PMP
59
        STR     r5, [r8, r4, LSL #2]
        ADD     r5, r7, r5, LSL #CAM_EntrySizeLog2
        LDR     r0, [r10, #DANode_Flags] ; Use default DA flags, modified by flags given in page list
        LDR     r1, =DynAreaFlags_AccessMask :AND: :NOT: DynAreaFlags_PMPPhysOpAccessMask
        MOV     lr, r4
        AND     r0, r0, r1
        ORR     r0, r0, r6
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        STMIB   r5, {r0,r10,lr}
        ADD     r12, r12, #1
        B       %BT50
60
        ; Check that the requested page isn't locked
        ADD     r0, r7, r5, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMIA   r0, {r0-r1}
      [ PMPDebug
        DebugReg r5, "Claiming page: "
        DebugReg r0, "Current addr: "
        DebugReg r1, "Current flags: "
      ]
        TST     r1, #PageFlags_Unavailable
        BNE     %FT95
        ; Construct a dummy DANode on the stack so we can use a Batcall to map
        ; in the page
        SUB     sp, sp, #DANode_NodeSize
        ; Copy over real node as basis
        MOV     r0, #DANode_NodeSize
61
        SUBS    r0, r0, #4
        LDR     r1, [r10, r0]
        STR     r1, [sp, r0]
        BGT     %BT61
        ; Adjust some parameters to ensure batcall is happy
        LDR     r0, =Nowhere
        STR     r0, [sp, #DANode_Base]
        LDR     lr, =ZeroPage
        MOV     r0, #0
        STR     r0, [lr, #CDASemaphore] ; Temporarily release so batcall will work
        STR     r0, [sp, #DANode_Size]
        MOV     r0, #4096
        STR     r0, [sp, #DANode_MaxSize]
        ; Because we're claiming the page via a Batcall, we need to make sure that the DA flags used for the call are valid as DA flags - i.e. don't touch any pageflags-only flags, because they might overlap the DA flags.
        ; Once the page is ours we'll fix up the other flags to be as the user requested.
    [ (DynAreaFlags_AccessMask :AND: DynAreaFlags_PMPPhysOpAccessMask) <> 0
        LDR     r0, [sp, #DANode_Flags]
      [ PMPDebug
        DebugReg r0, "Area flags: "
      ]
        LDR     lr, =DynAreaFlags_AccessMask :AND: DynAreaFlags_PMPPhysOpAccessMask
        BIC     r0, r0, lr
        AND     lr, r6, lr
        ORR     r0, r0, lr
      [ PMPDebug
        DebugReg r0, "Batcall flags: "
      ]
        STR     r0, [sp, #DANode_Flags]
    ]
        ; Replace handler routine with our own
        STR     r5, [sp, #DANode_Workspace] ; Required page number is handler param
        ADR     r0, PMPGrowHandler
        STR     r0, [sp, #DANode_Handler]
        ; Make the call
        Push    "r2"
        ADD     r2, sp, #4
        MOV     r0, #ChangeDyn_Batcall
        MOV     r1, #4096
        SWI     XOS_ChangeDynamicArea
        LDR     r2, =ZeroPage
        STR     sp, [r2, #CDASemaphore]
        Pull    "r2"
        ADD     sp, sp, #DANode_NodeSize
        BVS     %FT99
        ; Everything went OK, remember the new page as being ours
        B       %BT59

80
        BL      PMPMemoryMoved
        CLRV
        FRAMSTR r2
        MOV     r3, #0
        FRAMSTR r3
        EXIT

90
        PullEnv
        ADRL    r0, ErrorBlock_BadDynamicArea
 [ International
        B       TranslateError
 |
        SETV
        MOV     pc, lr
 ]

91
        ; Failed to claim CDASemaphore
        PullEnv
        ADRL    r0, ErrorBlock_ChDynamNotAllMoved
 [ International
        B       TranslateError
 |
        SETV
        MOV     pc, lr
 ]

92
        ; Error during initial list scan - reset parameters as if nothing's been moved
        FRAMLDR r2
        FRAMLDR r3
        ADD     r2, r2, #12
        SUB     r3, r3, #1
        LDR     r12, [r10, #DANode_PMPSize]
93
      [ PMPDebug
        DebugTX "-> bad physop page number"
      ]
        ADRL    r0, ErrorBlock_BadPageNumber
        B       %FT98

94
        ; Error during initial list scan - reset parameters as if nothing's been moved
        FRAMLDR r2
        FRAMLDR r3
        ADD     r2, r2, #12
        SUB     r3, r3, #1
        LDR     r12, [r10, #DANode_PMPSize]
95
      [ PMPDebug
        DebugTX "-> physop can't move"
      ]
        ADRL    r0, ErrorBlock_ChDynamNotAllMoved
        B       %FT98

98
 [ International
        BL      TranslateError
 |
        SETV
 ]
99
        BL      PMPMemoryMoved
        FRAMSTR r0
        ; Wind r2, r3 back one entry to point to the entry that's causing the problem
        SUB     r2, r2, #12
        ADD     r3, r3, #1
        FRAMSTR r2
        FRAMSTR r3
        EXIT

; r10 -> DANode
DynArea_PMP_PhysOp_WithNode ALTENTRY
        B       %BT01


PMPMemoryMoved ROUT
        EntryS  "r0-r2,r5,r11"
        ; In: r10 -> DANode
        ;     r12 = new size (pages)
        ; Update PMPSize, release CDASemaphore, and issue Service_MemoryMoved
        LDR     r0, [r10, #DANode_PMPSize]
        SUBS    r0, r0, r12
        STR     r12, [r10, #DANode_PMPSize]
        RSBLT   r0, r0, #0
        CMP     r0, #DynArea_PMP_BigPageCount
        MOVLO   r0, r0, LSL #12
        LDRHS   r0, =DynArea_PMP_BigByteCount
        LDR     r2, [r10, #DANode_Number]
        ; Release CDASemaphore
        LDR     r11, =ZeroPage
        MOV     r5, #0
        STR     r5, [r11, #CDASemaphore]
   [ DynArea_QuickHandles
        LDR     r11, [r11, #DynArea_ws]
        LDR     r5, DynArea_OD6Signature
        STR     r5, DynArea_OD6PrevSignature
        ORR     r5, r5, #4              ;signal a resize
        STR     r5, DynArea_OD6Signature
        STR     r2, DynArea_OD6Handle
   ]
        MOV     r1,#Service_MemoryMoved
        BL      Issue_Service
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        EXITS
        

PMPGrowHandler ROUT
        TEQ     r0, #DAHandler_PreGrow
        STREQ   r12, [r1]
        MOV     pc, lr       

;**************************************************************************
;
;       DynArea_PMP_LogOp
;
;  Map/unmap pages from logical memory
;
; in:   r0 = reason code (22)
;       r1 = area number
;       r2 = pointer to array of (DA page number, PMP page index, page flags) tuples
;            PMP page index of -1 to unmap (page flags currently ignored)
;            else PMP page index + page flags must be valid
;       r3 = number of entries
;
; out:  r0-r1 preserved (error if not all of region successfully updated)
;       r2 advanced to first entry not processed (or end of list)
;       r3 updated to number of entries not processed (or 0)
;       r10-r12 may be corrupted
;
PMPLogOp_ChunkSize * 384 ; 384 pages = 1.5K stack, or 1.5MB of memory (larger than current max Cache_RangeThreshold - otherwise full cache clean optimisation won't be taken)

                              ^ 0, sp
PMPLogOp_PageList             # PMPLogOp_ChunkSize*4 ; List of pages to map out
PMPLogOp_UnsafeMapIn          # 4 ; Nonzero if we've done an 'unsafe' map in
PMPLogOp_GlobalTLBFlushNeeded # 4 ; Nonzero if a global TLB flush needed on exit
                              # 8 ; Padding!
PMPLogOp_FrameSize            # 0

DynArea_PMP_LogOp ROUT
        Entry   "r0-r9", :INDEX:PMPLogOp_FrameSize
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     %FT90                   ; [it doesn't]
01
        ; r10 -> DANode
        LDR     r7, [r10, #DANode_PMP]
        CMP     r7, #0
        LDR     r9, [r10, #DANode_PMPMaxSize]
        BEQ     %FT90
        BL      ClaimCDASemaphore
        BNE     %FT91
        LDR     r11, [r10, #DANode_MaxSize]
        LDR     r12, [r10, #DANode_Base]
        LDR     r8, =L2PT
        ; Usage in main loop:
        ; r0 = number of cacheable pages being umapped
        ; r1 = offset in temp page list
        ; r2 -> input page list
        ; r3 = length
        ; r4 = current entry DA page index
        ; r5 = current entry PMP page index
        ; r6 = current entry page flags
        ; r7 -> PMP
        ; r8 -> L2PT
        ; r9 -> PMPMaxSize
        ; r10 -> DANode
        ; r11 -> DA max size
        ; r12 -> DA base
        MOV     r0, #0
        STR     r0, PMPLogOp_UnsafeMapIn
        STR     r0, PMPLogOp_GlobalTLBFlushNeeded
        MOV     r1, #0
      [ PMPDebug
        DebugReg r3, "LogOp len "
      ]
05
        ; Examine the first entry and see if it's a request to map in or map out
        CMP     r3, #0
        BEQ     %FT70
06
        LDMIA   r2, {r4-r6}
      [ PMPDebug
        DebugReg r4, "DA page "
        DebugReg r5, "PMP page "
      ]
        ; Check for silly DA page index
        CMP     r4, r11, LSR #12
        BHS     %FT95
        CMP     r5, #-1
        BNE     %FT50
        ; Map out request - get current page
      [ PMPDebug
        DebugTX "-> Map out"
      ]
        ADD     r4, r12, r4, LSL #12
        BL      logical_to_physical
        MOVCS   r5, #-1
        BCS     %FT10
        Push    "r3,r10-r11"
        BL      physical_to_ppn
        MOV     r5, r3
        Pull    "r3,r10-r11"
        BCS     %FT95 ; TODO better error
        ; Check to see if the page is cacheable
        LDR     r6, =ZeroPage
        LDR     r6, [r6, #CamEntriesPointer]
        ADD     r6, r6, #CAM_PageFlags
        LDR     r6, [r6, r5, LSL #CAM_EntrySizeLog2]
        TST     r6, #DynAreaFlags_NotCacheable
        ADDEQ   r0, r0, #1
10
      [ PMPDebug
        DebugReg r5, "Current phys page="
      ]
        LDR     r9, [r10, #DANode_PMPMaxSize] ; restore after logical_to_physical clobbered it
        ; Only add to list if we're mapping out
        CMP     r5, #-1
        STRNE   r5, [sp, r1, LSL #2]
        ADDNE   r1, r1, #1
15
        ADD     r2, r2, #12
        SUB     r3, r3, #1
        CMP     r1, #PMPLogOp_ChunkSize
        BNE     %BT05
        BL      LogOp_MapOut
        MOV     r0, #0
        MOV     r1, #0
        B       %BT05

50
        CMP     r1, #0
        BLNE    LogOp_MapOut
55
        ; Request to map in - examine CAM to see if the page is already at the
        ; requested location (with requested flags)
        CMP     r5, r9
        BHS     %FT95
        LDR     r0, =ZeroPage
        LDR     r5, [r7, r5, LSL #2]
        LDR     r0, [r0, #CamEntriesPointer]
        CMP     r5, #-1
        BEQ     %FT95
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ADD     r0, r0, r5, LSL #CAM_EntrySizeLog2
        LDMIA   r0, {r0, r1}
        LDR     lr, =DynAreaFlags_PMPLogOpAccessMask
      [ PMPDebug
        DebugTX "-> Map in "
      ]
        ADD     r4, r12, r4, LSL #12
      [ PMPDebug
        DebugReg r4, "Log addr "
        DebugReg r5, "Desired phys page "
        DebugReg r6, "Desired flags "
        DebugReg r0, "Page currently at "
        DebugReg r1, "With flags "
      ]
        AND     r6, r6, lr
        BIC     lr, r1, lr
        ORR     r6, r6, lr ; Preserve special flags (e.g. temp uncacheability, PMP membership)
        CMP     r0, r4
        CMPEQ   r6, r1
        BEQ     %FT65
        ; Page needs to be mapped/moved/updated
        Push    "r2-r4,r6,r9,r11"
        MOV     r2, r5
        ; Update our logical size if the page isn't already in position
        CMP     r0, r4
        BEQ     %FT60
        ORR     r6, r6, #PageFlags_Unsafe ; Do unsafe mapping if posible
        ; If the page is currently in our address space, decrease our logical size (-> that mapping is about to go away)
        LDR     r1, [r10, #DANode_Size]
        SUB     lr, r0, r12
        CMP     lr, r11
        SUBLO   r1, r1, #4096
        BICLO   r6, r6, #PageFlags_Unsafe
        ; If there's nothing at the target address, increase our logical size
        BL      logical_to_physical
        ADDCS   r1, r1, #4096
        BICCC   r6, r6, #PageFlags_Unsafe
        STR     r1, [r10, #DANode_Size]
        ; Also update HWM
        BCC     %FT57
      [ PMPDebug
        DebugTX "Nothing at dest addr"
      ]
        LDR     r1, [r10, #DANode_SparseHWM]
        ADD     lr, r4, #4096
        CMP     r1, r4
        STRLS   lr, [r10, #DANode_SparseHWM]
        B       %FT60
57
        ; There's already a page at the target address. Unmap it before we
        ; replace it (BangCamUpdate isn't smart enough to do this for us)
        Push    "r2,r4,r6,r7,r10"
        LDR     r2, =ZeroPage
        LDR     r7, [r2, #MaxCamEntry]
        BL      physical_to_ppn
        BCS     %FT94
      [ PMPDebug
        DebugReg r3, "Unmapping existing page first "
      ]
        LDR     r11, [r2, #CamEntriesPointer]
        MOV     r2, r3
        ADD     r11, r11, r3, LSL #CAM_EntrySizeLog2
        LDR     r3, =Nowhere
        LDR     r11, [r11, #CAM_PageFlags] ; Preserve flags
        ; We should be able to make this an unsafe op if the page isn't cacheable. But to avoid global TLB flushes when only one or two pages are being unmapped, only make it unsafe if we've already scheduled a global flush.
        TST     r11, #DynAreaFlags_NotCacheable
        LDRNE   r7, [sp, #:INDEX:PMPLogOp_GlobalTLBFlushNeeded + 6*4 + 4*4]
        TEQNE   r7, #0
        ORRNE   r11, r11, #PageFlags_Unsafe
        BL      BangCamUpdate
        Pull    "r2,r4,r6,r7,r10"
        ; If the above was unsafe, then it means the below can be unsafe too
        AND     r11, r11, #PageFlags_Unsafe
        ORR     r6, r6, r11
60
        ; Call BangCamUpdate
        MOV     r3, r4
        TST     r6, #PageFlags_Unsafe
        ORR     r11, r6, #DynAreaFlags_PMP
        STRNE   pc, [sp, #:INDEX:PMPLogOp_UnsafeMapIn + 6*4]
      [ PMPDebug
        DebugReg r11, "Actual flags "
      ]
        BL      BangCamUpdate
        Pull    "r2-r4,r6,r9,r11"
65
        MOV     r0, #0
        MOV     r1, #0
        ADD     r2, r2, #12
        SUBS    r3, r3, #1
        BNE     %BT06
70
        MOV     r4, #0
71      ; R4 = error
        ; Store back progress
        FRAMSTR r2
        FRAMSTR r3
        ; Flush any pending changes
        CMP     r1, #0
        BLNE    LogOp_MapOut
      [ PMPDebug
        DebugReg r3, "# not processed "
        LDR     r3, PMPLogOp_GlobalTLBFlushNeeded
        DebugReg r3, "GlobalTLBFlushedNeeded? "
        LDR     r3, PMPLogOp_UnsafeMapIn
        DebugReg r3, "UnsafeMapIn? "
        LDR     r3, [r10, #DANode_Size]
        DebugReg r3, "Size "
      ]
        ; Perform any necessary post maintenance
        LDR     r0, PMPLogOp_GlobalTLBFlushNeeded
        TEQ     r0, #0
        BEQ     %FT72
        ARMop   MMU_ChangingUncached
        B       %FT75
72
      [ SyncPageTables
        LDR     r0, PMPLogOp_UnsafeMapIn
        TEQ     r0, #0
        BEQ     %FT75
        PageTableSync
      ]
75
        ; Release CDASemaphore
        LDR     r1, =ZeroPage
        MOV     r2, #0
        STR     r2, [r1, #CDASemaphore]
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        CLRV
        MOVS    r0, r4
 [ International
        BLNE    TranslateError
 |
        SETV    NE
 ]
        FRAMSTR r0,VS
        EXIT

90
        ADRL    r0, ErrorBlock_BadDynamicArea
        B       %FT92
91
        ADRL    r0, ErrorBlock_ChDynamNotAllMoved
92
 [ International
        BL      TranslateError
 |
        SETV
 ]
        FRAMSTR r0
        EXIT

94
      [ PMPDebug
        DebugTX "-> failed to find page which is currently mapped in"
      ]
        Pull    "r2,r4,r6,r7"
        Pull    "r2-r4,r6,r9,r11"
95
      [ PMPDebug
        DebugTX "-> bad logop page number"
      ]
        ADRL    r4, ErrorBlock_BadPageNumber
        B       %BT71

; r10 -> DANode
DynArea_PMP_LogOp_WithNode ALTENTRY
        B       %BT01

LogOp_MapOut ROUT
        Entry   "r0-r12"
        ADD     r3, sp, #14*4
        LDR     r12, =ZeroPage
      [ PMPDebug
        DebugReg r1, "Unmapping # pages "
        DebugReg r0, "With # cacheable "
      ]
        ; r0 = number of cacheable pages being unmapped
        ; r1 = number of pages being unmapped
        ; r3 -> list of physical pages to unmap
        ; r10 -> DANode
        ; First go through and make them all uncacheable
        CMP     r0, #0
        BEQ     %FT10

        ; Work out if a global cache flush makes sense
        MOV     r8, r1
        MOV     r6, r0, LSL #12
        ARMop   Cache_RangeThreshold,,,r12
        CMP     r6, r0
        ORRLS   r6, r6, #1

        MOV     r7, r3
        LDR     r12, [r12, #CamEntriesPointer]
        LDR     r3, =Nowhere
        LDR     r10, =L2PT
        MOV     r9, #-1
05
        LDR     r2, [r7], #4
      [ PMPDebug
        DebugReg r2, "Uncache page "
      ]
        ADD     r11, r12, r2, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMIA   r11, {r11, lr}
        TEQ     r11, r3                 ; Check something actually there (mainly to stop DANode_Size going out of sync if page list requests for same page to be unmapped multiple times)
        BEQ     %FT08
        TST     lr, #DynAreaFlags_NotCacheable
        BNE     %FT08
        ; Calculate required page flags
        CMP     r9, lr
        BEQ     %FT06
        LDR     r1, =ZeroPage
        LDR     r1, [r1, #MMU_PCBTrans]
        GetTempUncache r2, lr, r1, r4
06
        ; Bypass BangCAM and update L2PT directly (avoids CAM gaining any unwanted temp uncacheability flags)
        LDR     r4, =TempUncache_L2PTMask
        LDR     lr, [r10, r11, LSR #10]
        BIC     lr, lr, r4
        ORR     lr, lr, r2
        STR     lr, [r10, r11, LSR #10]
        ; r6 bit 0 set if TLB+cache invalidation done on per-page basis
        TST     r6, #1
        BEQ     %FT07
        LDR     r4, =ZeroPage
        MOV     r0, r11
        ARMop   MMU_ChangingEntry,,,r4
07
        SUBS    r6, r6, #4096
        BLS     %FT09                   ; Can stop if that was the last cacheable page
08
        SUBS    r8, r8, #1
        BNE     %BT05

09
        ; Do global TLB+cache invalidate if required
        LDR     r12, =ZeroPage
        TST     r6, #1
        BNE     %FT10
      [ PMPDebug
        DebugTX "Global TLB+cache flush"
      ]
        ARMop   MMU_Changing,,,r12

10
        FRAMLDR r1
        ADD     r7, sp, #14*4
        ; Work out if we should do a global TLB flush after the unmap
        MOV     r5, #0
        LDR     r4, [r7, #:INDEX:PMPLogOp_GlobalTLBFlushNeeded]
        CMP     r4, #0
        BNE     %FT20
        CMP     r1, #32 ; Arbitrary TLB size
        BLO     %FT20
        ; Global TLB/uncached flush wanted - make BangCAM unsafe, request global flush from main code
        MOV     r5, #PageFlags_Unsafe
        STR     pc, [r7, #:INDEX:PMPLogOp_GlobalTLBFlushNeeded]
      [ PMPDebug
        DebugTX "Doing unsafe unmap"
      ]
20
        ; Now process the pages
        MOV     r8,r1
        FRAMLDR r10
        LDR     r12, [r12, #CamEntriesPointer]
        LDR     r3, =Nowhere
        LDR     r9, [r10, #DANode_Size]
25
        LDR     r2, [r7], #4
      [ PMPDebug
        DebugReg r2, "Umap page "
      ]
        ADD     r11, r12, r2, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMIA   r11, {r11, lr}
        TEQ     r11, r3                 ; Check something actually there (mainly to stop DANode_Size going out of sync if page list requests for same page to be unmapped multiple times)
        ORR     r11, lr, r5             ; Retain current flags
        SUBNE   r9, r9, #4096
        BLNE    BangCamUpdate
        SUBS    r8, r8, #1
        BNE     %BT25
        STR     r9, [r10, #DANode_Size]
        EXIT

        LTORG

;**************************************************************************
;
;       DynArea_PMP_Resize
;
;  Physical resize of PMP - increase/decrease number of physical pages supported
;
; in:   r0 = reason code (23)
;       r1 = area number
;       r2 = resize amount (positive/negative page count)
;
; out:  r0-r1 preserved (error if not all of region successfully updated)
;       r2 = amount area has changed by (unsigned page count)
;       r10-r12 may be corrupted
;
DynArea_PMP_Resize ROUT
        Entry   "r0-r5"
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     %FT90                   ; [it doesn't]
01
        ; r10 -> DANode
      [ PMPDebug
        DebugReg r2, "Resize by: "
      ]
        ; Check CDASemaphore can be claimed, and then release it - we only make
        ; one call to external code so don't have too much to worry about
        ; (things can still go wrong though - e.g. if PMP resize triggers
        ; sys heap resize which then does something silly in
        ; Service_MemoryMoved)
        BL      ClaimCDASemaphore
        BNE     %FT91
        LDR     r3, =ZeroPage
        MOV     r4, #0
        STR     r4, [r3, #CDASemaphore]
        MOVS    r3, r2
        LDR     r5, [r10, #DANode_PMPMaxSize]
        MOVLT   r4, r2
        LDR     r2, [r10, #DANode_PMP]
        BLT     %FT50
        ; Grow by requested amount
        LDR     r4, =ZeroPage
        LDR     r4, [r4, #MaxCamEntry]
        SUB     r4, r4, r5
        ADD     r4, r4, #1              ; Max grow amount
        CMP     r3, r4
        MOVHI   r3, r4
        MOVS    r3, r3, LSL #2          ; -> byte count
        BEQ     %FT99                   ; Get rid of zero-change case
      [ PMPDebug
        DebugReg r3, "Clamped grow bytes: "
        DebugReg r2, "Current PMP: "
        DebugReg r5, "Current PMPMaxSize: "
      ]
        TEQ     r2, #0
        MOVEQ   r0, #HeapReason_Get
        MOVNE   r0, #HeapReason_ExtendBlock
        BL      DoSysHeapOpWithExtension
        BVS     %FT90
      [ PMPDebug
        DebugReg r2, "New PMP: "
      ]
        MOV     r3, r3, LSR #2
      [ PMPDebug
        DebugReg r3, "Return value: "
      ]
        FRAMSTR r3,,r2
        ; Success - initialise new space
        MOV     r4, #-1
10
        SUBS    r3, r3, #1
        STRGE   r4, [r2, r5, LSL #2]
        ADDGE   r5, r5, #1
        BGT     %BT10
        ; Store new details
        STR     r2, [r10, #DANode_PMP]
        STR     r5, [r10, #DANode_PMPMaxSize]
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        EXIT

50
        ; Shrink request. Only shrink if there aren't any pages allocated to
        ; the end of the PMP.
        CMN     r5, r4
        RSBLO   r4, r5, #0              ; Can't shrink more than PMP size
      [ PMPDebug
        DebugReg r4, "Clamped shrink amount: "
      ]
        MOVS    r3, r4, LSL #2
        BEQ     %FT99                   ; No change to make
        ADD     r1, r2, r5, LSL #2
60
        LDR     lr, [r1, #-4]!
        CMP     lr, #-1
        BNE     %FT45
        ADDS    r4, r4, #1
        SUB     r5, r5, #1
        BNE     %BT60
45
        ; r5 = new size
        ; r4 = amount not changed (negative)
        ; r2 = PMP block
      [ PMPDebug
        DebugReg r5, "New size: "
        DebugReg r4, "Not changed: "
        DebugReg r2, "Current PMP: "
      ]
        SUB     r3, r3, r4, LSL #2      ; Calculate new shrink amount
        RSB     r4, r3, #0
        CMP     r5, #0
        MOV     r4, r4, LSR #2          ; Calculate return value
        MOVEQ   r0, #HeapReason_Free
        MOVNE   r0, #HeapReason_ExtendBlock
        BL      DoSysHeapOpWithExtension
        BVS     %FT91
        ; Operation success
        TEQ     r5, #0
        STR     r5, [r10, #DANode_PMPMaxSize]
        MOVEQ   r2, #0
      [ PMPDebug
        DebugReg r2, "New PMP: "
        DebugReg r4, "Return value: "
      ]
        STR     r2, [r10, #DANode_PMP]  ; Paranoia - store back even if we still have a size (just in case ExtendBlock shrink ops gain the ability to move blocks)
        FRAMSTR r4,,r2
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        EXIT

90
        ADRL    r0, ErrorBlock_BadDynamicArea
        B       %FT92
91
        ADRL    r0, ErrorBlock_ChDynamNotAllMoved
92
        ; Failed for some reason.
        ; Note that we don't do anything fancy for grow failures (like try and
        ; do a partial grow) - a grow failure most likely indicates we're low
        ; on system heap space, which is a bad situation to be in.
 [ International
        BL      TranslateError
 |
        SETV
 ]
        FRAMSTR r0
98
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        PullEnv
        MOV     r2, #0
        MOV     pc, lr

99
        CLRV
        B       %BT98

; r10 already contains node ptr
DynArea_PMP_Resize_WithNode ALTENTRY
        B       %BT01

;**************************************************************************
;
;       DynArea_PMP_GetInfo - Get info on a physical memory pool
;
;       Internal routine called by DynamicAreaSWI
;
;       Although designed for use with PMPs, this call works with regular DAs
;       too (just returns logical page counts for r6 & r7)
;
; in:   r0 = reason code (24)
;       r1 = area number
;
; out:  r2 = current logical size of area (bytes)
;       r3 = base logical address
;       r4 = area flags
;       r5 = maximum logical size of area (bytes)
;       r6 = current physical size of area (pages)
;       r7 = maximum physical size of area (pages)
;       r8 -> title string
;       r10-r12 may be corrupted
;       All other registers preserved
;

DynArea_PMP_GetInfo ROUT
        Entry
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     %FT90                   ; [it doesn't]

; r10 -> node, so get info

        LDR     r4, [r10, #DANode_Flags]
        LDR     r2, [r10, #DANode_Size]
        TST     r4, #DynAreaFlags_PMP
        LDR     r3, [r10, #DANode_Base]
        LDR     r5, [r10, #DANode_MaxSize]
        LDRNE   r6, [r10, #DANode_PMPSize]
        LDRNE   r7, [r10, #DANode_PMPMaxSize]
        MOVEQ   r6, r2, LSR #12
        MOVEQ   r7, r5, LSR #12
        LDR     r8, [r10, #DANode_Title]
        CLRV
        EXIT

90
        ADRL    r0, ErrorBlock_BadDynamicArea
 [ International
        BL      TranslateError
 |
        SETV
 ]
        EXIT

;**************************************************************************
;
;       DynArea_PMP_GetPages - Get page mapping info on a physical memory pool
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (25)
;       r1 = area number
;       r2 = pointer to input/output array:
;            +0: PMP page index
;            +4: phys page number
;            +8: DA page index
;            +12: page flags
;       r3 = number of entries
;
; out:  r0-r3 preserved
;       r10-r12 may be corrupted
;       All other registers preserved
;       Array updated with page details
;
; On entry, for each array entry either the PMP page index, phys page number, or
; DA page index must be provided, with the other indices set to -1 (page flags
; are ignored).
;
; On exit, if the page is a member of the PMP, the entries will be filled in as
; appropriate. If the page isn't mapped in (and it was a lookup by PMP page
; index/phys page number) the DA page index will be set to -1. If no physical
; page is allocated (or the page isn't a member of the PMP) the page flags will
; be set to 0.
;

DynArea_PMP_GetPages ROUT
        Entry   "r0-r9"
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     %FT90                   ; [it doesn't]
        ; r10 -> DANode
        LDR     r6, [r10, #DANode_PMP]
        CMP     r6, #0
        BEQ     %FT90
        LDR     r9, [r10, #DANode_PMPMaxSize]
        BEQ     %FT90
        LDR     r11, =ZeroPage
        LDR     r5, [r10, #DANode_Base]
        LDR     r7, [r11, #MaxCamEntry]
        LDR     r8, =L2PT
        LDR     r11, [r11, #CamEntriesPointer]
        LDR     r12, =DynAreaFlags_PMPLogOpAccessMask
        ; Usage in main loop:
        ; r2 -> input page list
        ; r3 = length
        ; r5 -> DA base
        ; r6 -> PMP
        ; r7 = MaxCamEntry
        ; r8 -> L2PT
        ; r9 = PMP size
        ; r10 -> DANode
        ; r11 -> CAM
        ; r12 = DynAreaFlags_PMPLogOpAccessMask
        ; r0, r1, r4 temp
10
        SUBS    r3, r3, #1
        BLT     %FT80
        ; Get the entry
        LDMIA   r2, {r0, r1, r4}
        ; PMP page provided?
        CMP     r0, #-1
        BNE     %FT50
        ; Phys page provided?
        CMP     r1, #-1
        BNE     %FT20
        ; DA page provided
        ; n.b. skipping any range check here since it won't hurt if the page
        ; doesn't belong to us
        Push    "r3, r5, r9-r11"
        ADD     r4, r5, r4, LSL #12
        BL      logical_to_physical
        BLCC    physical_to_ppn
        MOV     r0, r3
        Pull    "r3, r5, r9-r11"
        BCS     %FT15
        ; r0 = PPN, check to see if it belongs to us
        ADD     r1, r11, r0, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIB   r1, {r1, r4, lr}
        TST     r1, #DynAreaFlags_PMP
        BEQ     %FT15
        CMP     r4, r10
        BNE     %FT15
        STR     lr, [r2], #4            ; Store PMP page index
        AND     r1, r1, r12
        STR     r0, [r2], #8            ; Store phys page number, skip DA page index
        STR     r1, [r2], #4            ; Store page flags
        B       %BT10
15
        ; Bad DA page index
        ; PMP page index & phys page number are already known to be -1, so just
        ; store flags
        MOV     r0, #0
        STR     r0, [r2, #12]
        ADD     r2, r2, #16
        B       %BT10

20
        ; Check for silly phys page number
        CMP     r1, r7
        BHI     %FT91
        ADD     r1, r11, r1, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIA   r1, {r0, r1, r4, lr}
        TST     r1, #DynAreaFlags_PMP
        BEQ     %FT25
        CMP     r4, r10
        BNE     %FT25
        LDR     r4, =Nowhere
        STR     lr, [r2], #8            ; Store PMP page index, skip phys page number
        TEQ     r0, r4
        B       %FT55

25
        ; Bad phys page number
        ; PMP page index known to be -1, so store DA page index + flags
        ADD     r2, r2, #8
        MOV     r0, #-1
        MOV     r1, #0
        STMIA   r2!, {r0-r1}
        B       %BT10        

50
        ; Check for silly PMP page index
        CMP     r0, r9
        BHS     %FT91
        ; Look up the page that's currently in the PMP
        LDR     r0, [r6, r0, LSL #2]
        ADD     r2, r2, #4
        STR     r0, [r2], #4            ; Store phys page number
        ; Does the page exist?
        CMP     r0, #-1
        LDR     r4, =Nowhere
        ADDNE   r0, r11, r0, LSL #CAM_EntrySizeLog2
        MOVEQ   r1, #0                  ; No physical page, so no flags
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMNEIA r0, {r0-r1}             ; Get log addr, flags from CAM
        TEQNE   r0, r4
55
        MOVEQ   r0, #-1                 ; No physical page, or not mapped
        SUBNE   r0, r0, r5
        MOVNE   r0, r0, LSR #12
        AND     r1, r1, r12             ; Mask returned flags
        STMIA   r2!, {r0-r1}            ; Store DA page index, flags
        B       %BT10

80
        CLRV
        EXIT

90
        ADRL    r0, ErrorBlock_BadDynamicArea
        B       %FT98
91
        ADRL    r0, ErrorBlock_BadPageNumber
98
 [ International
        BL      TranslateError
 |
        SETV
 ]
        FRAMSTR r0
        EXIT


;**************************************************************************
;
;       CheckAreaNumber - Try to find area with number r1
;
;       Internal routine called by DynArea_Create
;
; in:   r1 = area number to match
; out:  If match, then
;         C=1, r10 -> node, r11 -> previous node
;       else
;         C=0, r10,r11 corrupted
;       endif

CheckAreaNumber Entry
  [ DynArea_QuickHandles
QCheckAreaNumber_nonQ
  ]
        LDR     r10, =ZeroPage+DAList
        ASSERT  DANode_Link = 0                 ; because DAList has only link
10
        MOV     r11, r10                        ; save prev
        LDR     r10, [r10, #DANode_Link]        ; and load next
        CMP     r10, #1                         ; any more nodes?
        EXIT    CC                              ; no, then no match
        LDR     lr, [r10, #DANode_Number]       ; get number
        CMP     lr, r1                          ; does number match
        BNE     %BT10                           ; no, try next
  [ DynArea_QuickHandles
        Push    "r11"
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        STR     r1,  DynArea_LastTreacleHandle
        STR     r10, DynArea_LastTreaclePtr
        Pull    "r11"
  ]
        EXIT                                    ; (C=1 from CMP lr,r1)

  [ DynArea_QuickHandles

; QCheckAreaNumber - similar to CheckAreaNumber, but blisteringly quick for system or for quick
;                    numbers. However, DOES NOT return previous node in r11.
;
QCheckAreaNumber ROUT
        Push    "lr"
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        CMP     r1, #-1
        BEQ     QCheckAreaNumber_nonQ           ;just to protect against -1 as a proposed number
        LDR     lr, DynArea_LastTreacleHandle
        CMP     lr, r1
        LDREQ   r10, DynArea_LastTreaclePtr
        EXIT    EQ                              ;found node is slow one we handled last time (carry set)
        LDR     lr, DynArea_CreatingHandle
        CMP     lr, r1
        LDREQ   r10, DynArea_CreatingPtr
        EXIT    EQ                              ;found node is one we're creating (carry set)
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT10
        CMP     r1,#DynArea_NewAreas
        BLO     QCheckAreaNumber_nonQ
        SUB     lr, r1, #DynArea_NewAreas
        CMP     lr, #DynArea_NumQHandles
        BHS     QCheckAreaNumber_nonQ
;quick handle
        ADR     r10, DynArea_QHandleArray
        LDR     r10, [r10, lr, LSL #2]
        CMP     r10, #DynArea_NumQHandles
        MOVLS   r10, #0                         ;not a valid pointer
        CMP     r10, #1
        Pull    "pc"                            ;handle free, carry clear
                                                ;or word is ptr to node, carry set
;system handle
10
        ADR     r10, DynArea_SysQHandleArray
        LDR     r10, [r10, r1, LSL #2]
        CMP     r10, #1
        Pull    "pc"                            ;DA does not exist, carry clear
                                                ;or word is ptr to node, carry set
  ] ;DynArea_QuickHandles

;**************************************************************************
;
;       CheckForOverlappingAreas - Check that given area does not overlap any existing ones
;
;       Internal routine called by DynArea_Create
;
; in:   r3 = base address
;       r4 = area flags (NB if doubly mapped, then have to check both halves for overlap)
;       r5 = size (of each half in doubly mapped areas)
;
; out:  If this area overlaps with an existing one, then
;         r0 -> error
;         V=1
;       else
;         r0 preserved
;         V=0
;       endif
;

CheckForOverlappingAreas Entry "r0-r5"
        TST     r4, #DynAreaFlags_DoublyMapped          ; check if doubly mapped
        BEQ     %FT05                                   ; [not, so don't mangle]

        SUBS    r3, r3, r5                              ; move start address back
        BCC     %FT20                                   ; oh dear! - it went back to below 0
        MOVS    r5, r5, LSL #1                          ; and double size
        BCS     %FT20                                   ; if that wrapped then that's bad, too
05
        ADDS    r5, r5, r3                              ; r5 -> end +1
        BHI     %FT20                                   ; if CS, indicating wrap, and not EQ (ie just ending at 0), then bad

        LDR     lr, =ZeroPage
        LDR     r0, [lr, #IOAllocPtr]
        CMP     r5, r0                                  ; end must be below I/O space (allocated down from high memory)
        BHI     %FT20

; check against list of fixed areas

        ADR     lr, FixedAreasTable
10
        LDMIA   lr!, {r0, r1}                           ; r0 = start addr, r1 = size
        CMP     r0, #-1                                 ; if at end of list
        BEQ     %FT30                                   ; then OK wrt fixed areas
        ADD     r1, r1, r0                              ; r1 = end addr+1
        CMP     r5, r0                                  ; if end of our area is <= start of fixed, then OK wrt fixed areas
        BLS     %FT30
        CMP     r3, r1                                  ; if start of our area is >= end of fixed, then go onto next area
        BCS     %BT10

20
        ADRL    r0, ErrorBlock_OverlappingAreas
 [ International
        BL      TranslateError
 |
        SETV
 ]
        STR     r0, [sp]
        EXIT

; Now, check against DAList

30
        LDR     lr, =ZeroPage+DAList
        ASSERT  DANode_Link = 0
40
        LDR     lr, [lr, #DANode_Link]
        CMP     lr, #0                                  ; if got to end of list (V=0)
        BEQ     %FT50                                   ; then exit saying OK
        LDR     r0, [lr, #DANode_Base]
        LDR     r1, [lr, #DANode_Flags]
        TST     r1, #DynAreaFlags_DoublyMapped
        LDR     r1, [lr, #DANode_MaxSize]
        SUBNE   r0, r0, r1                              ; if doubly mapped then move back
        MOVNE   r1, r1, LSL #1                          ; and double size
        ADD     r1, r1, r0                              ; r1 -> end
        CMP     r5, r0                                  ; if end of our area is <= start of dyn, then OK wrt dyn areas)
        BLS     %FT50
        CMP     r3, r1                                  ; if start of our area is >= end of dyn, then go onto next area
        BCS     %BT40
        B       %BT20                                   ; else it overlaps

50
        CLRV                                            ; OK exit
        EXIT


FixedAreasTable                                         ; table of fixed areas (address, size)
        &       0,                      AplWorkMaxSize  ; application space
 [ CursorChunkAddress < IO
        &       CursorChunkAddress,     64*1024                 ; 32K for cursor, 32K for "nowhere"
 ]
 [ ROM < IO
 [ OSROM_ImageSize > 8192
        &       &03800000,              OSROM_ImageSize*1024   ; ROM
 |
        &       &03800000,              8*1024*1024            ; ROM
 ]
 ]
        &       IO,                     &FFFFFFFF-IO    ; Kernel workspace (code will also check dynamic value IOAllocPtr)
        &       -1,                     0               ; termination

;**************************************************************************
;
;       AllocateAreaAddress - Find an area of logical space to use for this area
;
;       Internal routine called by DynArea_Create
;
; in:   r4 = area flags (NB if doubly mapped, we have to find space for both halves)
;       r5 = size (of each half in doubly mapped areas)
;
; out:  If successfully found an address, then
;         r0 preserved
;         r3 = logical address
;         V=0
;       else
;         r0 -> error
;         r3 preserved
;         V=1
;       endif

AllocateAreaAddress Entry "r0-r2,r4-r7"
        TST     r4, #DynAreaFlags_DoublyMapped          ; check if doubly mapped
        BEQ     %FT05                                   ; [not, so don't mangle]
        MOVS    r5, r5, LSL #1                          ; double size
        BCS     %FT90                                   ; if that wrapped then that's bad
05
        LDR     r3, =DynArea_NewAreasBase               ; r3 is our current attempt
        ADR     r0, FixedAreasTable                     ; r0 is ptr into fixed areas table
        LDR     r1, =ZeroPage+DAList                             ; r1 is ptr into dyn areas list
10
        ADDS    r7, r3, r5                              ; r7 is our end+1
        BHI     %FT90                                   ; if we wrapped (but not end+1=0) then we failed
        LDR     lr, =ZeroPage
        LDR     r2, [lr, #IOAllocPtr]
        CMP     r7, r2
        BHI     %FT90                                   ; if we walked into IOspace (assumed higher than any DA space) then we failed
15
        BL      GetNextRange                            ; get next range from either list (r2=start, r6=end+1)
        CMP     r7, r2                                  ; if end(ours) <= start(next) then this is OK
        BLS     %FT80                                   ; (note this also works when r2=-1)
        CMP     r3, r6                                  ; else if start(ours) >= end(next)
        BCS     %BT15                                   ; then get another
        MOV     r3, r6                                  ; else make start(ours) := end(next)
        B       %BT10                                   ; and go back for another try

; we've succeeded - just apply unbodge for doubly-mapped areas

80
        TST     r4, #DynAreaFlags_DoublyMapped          ; if doubly mapped
        MOVNE   r5, r5, LSR #1                          ; halve size again
        ADDNE   r3, r3, r5                              ; and advance base address to middle
        CLRV
        EXIT

90
        ADRL    r0, ErrorBlock_CantAllocateArea
  [ International
        BL      TranslateError
  |
        SETV
  ]
        STR     r0, [sp]
        EXIT                                    ; say we can't do it

        LTORG

;**************************************************************************
;
;       GetNextRange - Get next lowest range from either fixed or dynamic list
;
;       Internal routine called by AllocateAreaAddress
;
; in:   r0 -> next entry in fixed list
;       r1!0 -> next entry in dyn list
;
; out:  r2 = next lowest area base (-1 if none)
;       r6 = end of that range (undefined if none)
;       Either r0 or r1 updated to next one (except when r2=-1 on exit)
;

GetNextRange Entry "r7,r8"
        LDMIA   r0, {r2, r6}                            ; load start, size from fixed list
        ADD     r6, r6, r2                              ; r6 = end+1

        ASSERT  DANode_Link = 0
        LDR     r7, [r1, #DANode_Link]                  ; get next from dyn
        TEQ     r7, #0                                  ; if none
        MOVEQ   r8, #-1                                 ; then use addr -1
        BEQ     %FT10

        LDR     r8, [r7, #DANode_Flags]                 ; more double trouble
        TST     r8, #DynAreaFlags_DoublyMapped
        LDR     r8, [r7, #DANode_Base]
        LDR     lr, [r7, #DANode_MaxSize]
        SUBNE   r8, r8, lr
        MOVNE   lr, lr, LSL #1
        ADD     lr, lr, r8                              ; now r8 = start addr, lr = end+1
10
        CMP     r8, r2                                  ; if dyn one is earlier
        MOVCC   r2, r8                                  ; then use dyn start
        MOVCC   r6, lr                                  ; and end
        MOVCC   r1, r7                                  ; and advance dyn ptr
        EXIT    CC                                      ; then exit
        CMP     r2, #-1                                 ; else if not at end of fixed
        ADDNE   r0, r0, #8                              ; then advance fixed ptr
        EXIT

;**************************************************************************
;
;       AllocateBackingLevel2 - Allocate L2 pages for an area
;
;       Internal routine called by DynArea_Create
;
; in:   r3 = base address (will be page aligned)
;       r4 = area flags (NB if doubly mapped, then have to allocate for both halves)
;       r5 = size (of each half in doubly mapped areas)
;
; out:  If successfully allocated pages, then
;         All registers preserved
;         V=0
;       else
;         r0 -> error
;         V=1
;       endif

AllocateBackingLevel2 Entry "r0-r8,r11"
        TST     r4, #DynAreaFlags_DoublyMapped          ; if doubly mapped
        SUBNE   r3, r3, r5                              ; then area starts further back
        MOVNE   r5, r5, LSL #1                          ; and is twice the size

; NB no need to do sanity checks on addresses here, they've already been checked

; now round address range to 4M boundaries

        ADD     r5, r5, r3                              ; r5 -> end
        MOV     r0, #1 :SHL: 22
        SUB     r0, r0, #1
        BIC     r8, r3, r0                              ; round start address down (+ save for later)
        ADD     r5, r5, r0
        BIC     r5, r5, r0                              ; but round end address up

; first go through existing L2PT working out how much we need

        LDR     r7, =L2PT
        ADD     r3, r7, r8, LSR #10                     ; r3 -> start of L2PT for area
        ADD     r5, r7, r5, LSR #10                     ; r5 -> end of L2PT for area +1

        ADD     r1, r7, r3, LSR #10                     ; r1 -> L2PT for r3
        ADD     r2, r7, r5, LSR #10                     ; r2 -> L2PT for r5

        TEQ     r1, r2                                  ; if no pages needed
        BEQ     %FT30

        MOV     r4, #0                                  ; number of backing pages needed
10
        LDR     r6, [r1], #4                            ; get L2PT entry for L2PT
        TST     r6, #3                                  ; EQ if translation fault
        ADDEQ   r4, r4, #1                              ; if not there then 1 more page needed
        TEQ     r1, r2
        BNE     %BT10

; if no pages needed, then exit

        TEQ     r4, #0
        BEQ     %FT30

; now we need to claim r4 pages from the free pool, if possible; return error if not

        LDR     r1, =ZeroPage
        LDR     r6, [r1, #FreePoolDANode + DANode_PMPSize]
        SUBS    r6, r6, r4                              ; reduce free pool size by that many pages
        BCS     %FT14                                   ; if enough, skip next bit

; not enough pages in free pool currently, so try to grow it by the required amount

        Push    "r0, r1"
        MOV     r0, #ChangeDyn_FreePool
        RSB     r1, r6, #0                              ; size change we want (+ve)
        MOV     r1, r1, LSL #12
        SWI     XOS_ChangeDynamicArea
        Pull    "r0, r1"
        BVS     %FT90                                   ; didn't manage change, so report error

        MOV     r6, #0                                  ; will be no pages left in free pool after this
14
        STR     r6, [r1, #FreePoolDANode + DANode_PMPSize] ; if possible then update size

        LDR     r0, [r1, #FreePoolDANode + DANode_PMP]  ; r0 -> free pool page list
        ADD     r0, r0, r6, LSL #2                      ; r0 -> first page we're taking out of free pool

        LDR     lr, =L1PT
        ADD     r8, lr, r8, LSR #18                     ; point r8 at start of L1 we may be updating
        ADD     r1, r7, r3, LSR #10                     ; point r1 at L2PT for r3 again
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #PageTable_PageFlags]        ; access privs (+CB bits)
20
        LDR     r6, [r1], #4                            ; get L2PT entry again
        TST     r6, #3                                  ; if no fault
        BNE     %FT25                                   ; then skip

        Push    "r1-r2, r4"
        MOV     lr, #-1
        LDR     r2, [r0]                                ; get page number to use
        STR     lr, [r0], #4                            ; remove from PMP
        Push    "r0"
        BL      BangCamUpdate                           ; Map in to L2PT access window

; now that the page is mapped in we can zero its contents (=> cause translation fault for area initially)
; L1PT won't know about the page yet, so mapping it in with garbage initially shouldn't cause any issues

        ADD     r0, r3, #4096
        MOV     r1, #0
        MOV     r2, #0
        MOV     r4, #0
        MOV     r6, #0
15
        STMDB   r0!, {r1,r2,r4,r6}                      ; store data
        TEQ     r0, r3
        BNE     %BT15

        ; Make sure the page is seen to be clear before we update L1PT to make
        ; it visible to the MMU
        PageTableSync

        Pull    "r0-r2, r4"

        LDR     lr, =ZeroPage
        LDR     r6, [lr, #L2PTUsed]
        ADD     r6, r6, #4096
        STR     r6, [lr, #L2PTUsed]

; now update 4 words in L1PT (corresponding to 4M of address space which is covered by the 4K of L2)
; and point them at the physical page we've just allocated (r1!-4 will already hold physical address+bits now!)

        LDR     r6, [r1, #-4]                           ; r6 = physical address for L2 page + other L2 bits
        MOV     r6, r6, LSR #12                         ; r6 = phys.addr >> 12
 [ MEMM_Type = "VMSAv6"
        LDR     lr, =L1_Page
 |
        LDR     lr, =L1_Page + L1_U                     ; form other bits to put in L1
 ]
        ORR     lr, lr, r6, LSL #12                     ; complete L1 entry
        STR     lr, [r8, #0]                            ; store entry for 1st MB
        ADD     lr, lr, #1024                           ; advance L2 pointer
        STR     lr, [r8, #4]                            ; store entry for 2nd MB
        ADD     lr, lr, #1024                           ; advance L2 pointer
        STR     lr, [r8, #8]                            ; store entry for 3rd MB
        ADD     lr, lr, #1024                           ; advance L2 pointer
        STR     lr, [r8, #12]                           ; store entry for 4th MB
25
        ADD     r3, r3, #4096                           ; advance L2PT logical address
        ADD     r8, r8, #16                             ; move onto L1 for next 4M

        TEQ     r1, r2
        BNE     %BT20
        PageTableSync
30
        CLRV
        EXIT

; Come here if not enough space in free pool to allocate level2

90
        ADRL    r0, ErrorBlock_CantAllocateLevel2
  [ International
        BL      TranslateError
  |
        SETV
  ]
        STR     r0, [sp]
        EXIT

;**************************************************************************

  [ ChocolateSysHeap
;
; CreateChocolateBlockArray
;
; entry: r2 = No. of blocks to be created in array (N)
;        r3 = size of each block in bytes (S, must be multiple of 4)
;
; exit:
;        r2 = address of chocolate block array (parent SysHeap block address)
;        array is initialised to all blocks free
;   OR   V set, r0=error pointer, if error (from OS_Heap)
;
; - A Chocolate block array is only suitable for blocks of single fixed size.
;   These blocks may be allocated and freed in any order, but never resized.
; - Allocating and freeing blocks from a Chocolate block array is much faster
;   than OS_Heap, and the cost of operations is independent of N.
; - A Chocolate block array is a single block in the SysHeap, and looks like this
;   (excluding the internal structure of OS_Heap blocks):
;
;  - array header (3 words):
;    - word 0  =  total no. of blocks in array (N)
;    - word 1  =  size of each block container (S+4)
;    - word 2  -> first free block container in array, or 0 if none free
;  - followed immediately by N block containers, each of form:
;    - container header (1 word):
;      - word 0 :  bits  0..30 = container id (C)
;                                C = (S+4)*I, where I is array index, 0..N-1
;                  bit  31     = 1 if block is free, 0 if block is in use
;    - followed immediately by the S/4 words of the block itself
;      - if the block is in use, these words are as defined by the client
;      - if the block is free, the first word is a pointer to the next free
;        block container (or 0 if end of free list), and the other words
;        are undefined
;
; - A Chocolate block array requires a SysHeap block of 3*4 + N*(S + 4) bytes
;
CreateChocolateBlockArray ROUT
        Push    "r0,r1,r3,r4,r5,lr"
        MOV     r5,r2                ;N
        ADD     r4,r3,#4             ;S+4
        MUL     r3,r5,r4
        ADD     r3,r3,#3*4
        BL      ClaimSysHeapNode
        STRVS   r0,[SP]
        BVS     %FT50
        STR     r5,[r2]
        STR     r4,[r2,#4]
        ADD     r1,r2,#3*4
        STR     r1,[r2,#8]
        MOV     lr,r5
        ADD     r0,r2,#3*4
        MOV     r1,#&80000000        ;free flag
10
        STR     r1,[r0]
        ADD     r3,r0,r4
        STR     r3,[r0,#4]
        ADD     r1,r1,r4
        SUBS    lr,lr,#1
        MOVNE   r0,r3
        BNE     %BT10
        MOV     r1,#0
        STR     r1,[r0,#4]           ;end of free list
50
        Pull    "r0,r1,r3,r4,r5,pc"

;
; ClaimChocolateBlock
;
; entry: r3 = address of parent ChocolateBlockArray (must be valid)
; exit:  r2 = address of allocated block
;        r3 = size of block
;  OR    V set, R0=error (no free blocks)
;
ClaimChocolateBlock ROUT
        Push    "r1,r4,lr"
        MRS     r4,CPSR
        ORR     r1,r4,#I32_bit
        MSR     CPSR_c,r1         ;protect critical manipulation from interrupt re-entry
        LDR     r2,[r3,#8]        ;pick up block container at front of free list
        CMP     r2,#0
        BEQ     ClaimChocolateBlock_NoneFree
        LDR     r1,[r2]
        BIC     r1,r1,#&80000000  ;clear the free flag
        STR     r1,[r2]
        LDR     r1,[r2,#4]        ;next free block container
        STR     r1,[r3,#8]        ;put it at front
        ADD     r2,r2,#4          ;address of block
        LDR     r3,[r3,#4]
        SUB     r3,r3,#4          ;size of block
        BIC     r4,r4,#V_bit      ;return with V clear
        MSR     CPSR_cf,r4        ;restore IRQ state
        Pull    "r1,r4,pc"
;
;DON'T even think about internationalisation - this exit route must be fast
ClaimChocolateBlock_NoneFree
        ADR     R0,ChocolateBlock_NFError
        ORR     r4,r4,#V_bit      ;return with V set
        MSR     CPSR_cf,r4        ;restore IRQ state
        Pull    "r1,r4,pc"

;
; FreeChocolateBlock
;
; entry: r1 = address of parent ChocolateBlockArray (must be valid)
;        r2 = address of block to free (may be invalid)
; exit:  -
;   OR   V set, R0=error (not a ChocolateBlock), r1,r2 still preserved
;
FreeChocolateBlock ROUT
        Push    "r2,r3,r4,lr"
        MRS     r4,CPSR
        ORR     r3,r4,#I32_bit
        MSR     CPSR_c,r3         ;protect critical manipulation from interrupt re-entry
        ADD     r3,r1,#12         ;r3 -> first block container
        SUB     r2,r2,#4          ;r2 -> container for block (if valid)
        CMP     r2,r3
        BLO     FreeChocolateBlock_NaffOff
        LDR     lr,[r1,#-4]       ;OS_Heap's size word (naughty!)
        ADD     lr,lr,r1
        CMP     r2,lr
        BHS     FreeChocolateBlock_NaffOff
        LDR     lr,[r2]           ;block container id
        TST     lr,#&80000000     ;free flag
        BNE     FreeChocolateBlock_NaffOff
        ADD     lr,lr,r3          ;lr := address of block container, from container id
        CMP     lr,r2
        BNE     FreeChocolateBlock_NaffOff
;
;we now believe caller is freeing a valid block, currently in use
;
        LDR     lr,[r2]
        ORR     lr,lr,#&80000000
        STR     lr,[r2]           ;set free flag in container id
        LDR     lr,[r1,#8]        ;current front of free list
        STR     lr,[r2,#4]        ;chain free list to block container we are freeing
        STR     r2,[r1,#8]        ;put freed block container at front
        BIC     r4,r4,#V_bit      ;return with V clear
        MSR     CPSR_cf,r4        ;restore IRQ state
        Pull    "r2,r3,r4,pc"
;
;DON'T even think about internationalisation - this exit route must be fast
FreeChocolateBlock_NaffOff
        ADR     R0,ChocolateBlock_NOError
        ORR     r4,r4,#V_bit      ;return with V set
        MSR     CPSR_cf,r4        ;restore IRQ state
        Pull    "r2,r3,r4,pc"

;
;forget internationalisation - if these errors aren't dealt with silently,
;                              the kernel's stuffed anyway
ChocolateBlock_NFError
        DCD     0
        DCB     "Chocolate SysHeap claim failed",0
        ALIGN
ChocolateBlock_NOError
        DCD     0
        DCB     "not a Chocolate SysHeap block",0
        ALIGN

  ] ;ChocolateSysHeap

;**************************************************************************
;
;       InitDynamicAreas - Initialise nodes for dynamic areas
;
;       It only initialises free pool, appspace and sysheap nodes
;       The other areas are created properly, after the screen area has been created (improperly)
;
; in:   -
; out:  -
;

InitDynamicAreas Entry "r0-r12"
        LDR     lr, =ZeroPage+AppSpaceDANode
        ADRL    r0, InitAppSpaceTable
        LDMIA   r0, {r0-r8}
        STMIA   lr, {r0-r8}

        LDR     lr, =ZeroPage+FreePoolDANode
        ADRL    r0, InitFreePoolTable
        LDMIA   r0, {r0-r8}                     ; copy initial data into node
        STMIA   lr, {r0-r8}

; Initialise the system heap first - we need it to store the PMP for the free
; pool

        LDR     r0, =SysHeapStart
        LDR     r1, =magic_heap_descriptor
        MOV     r2, #Nil
        MOV     r3, #hpdsize
        MOV     r4, #32*1024 - (SysHeapStart-SysHeapChunkAddress)
        STMIA   r0, {r1-r4}

        LDR     r0, =ZeroPage                   ; initialise module list to empty
      [ ZeroPage = 0
        STR     r0, [r0, #Module_List]
      |
        MOV     lr, #0
        STR     lr, [r0, #Module_List]
      ]

        LDR     lr, =ZeroPage+SysHeapDANode     ; initialise system heap node
        ADR     r0, InitSysHeapTable
        LDMIA   r0, {r0-r8}
        STMIA   lr, {r0-r8}
        LDR     r0, =ZeroPage
 [ FreePoolAddress < SysHeapStart
        LDR     lr, =ZeroPage+FreePoolDANode    ; cf comments above/below - what was old code? KJB
 ]
        STR     lr, [r0, #DAList]               ; store pointer to 1st node on list (either free pool or sys heap)

; TODO have asserts to check that this all fits OK
  [ ChocolateSysHeap
        ASSERT  ChocolateCBBlocks = ChocolateBlockArrays +  0
        ASSERT  ChocolateSVBlocks = ChocolateBlockArrays +  4
        ASSERT  ChocolateTKBlocks = ChocolateBlockArrays +  8
        ASSERT  ChocolateMRBlocks = ChocolateBlockArrays + 12
        ASSERT  ChocolateMABlocks = ChocolateBlockArrays + 16
        ASSERT  ChocolateMSBlocks = ChocolateBlockArrays + 20
        LDR     r1,=ZeroPage+ChocolateBlockArrays
        MOV     r2,#MaxChocolateCBBlocks
        MOV     r3,#3*4
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#0]
        MOV     r2,#MaxChocolateSVBlocks
        MOV     r3,#VecNodeSize
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#4]
        MOV     r2,#MaxChocolateTKBlocks
        MOV     r3,#TickNodeSize
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#8]
        MOV     r2,#MaxChocolateMRBlocks
        MOV     r3,#ROMModule_NodeSize
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#12]
        MOV     r2,#MaxChocolateMABlocks
        MOV     r3,#ModInfo + Incarnation_Postfix + 8
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#16]
        MOV     r2,#MaxChocolateMSBlocks
        MOV     r3,#ModSWINode_Size
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#20]

  ]

  [ Oscli_HashedCommands
        MOV     r3,#4*(Oscli_MHashValMask+1)
        BL      ClaimSysHeapNode                ; better not fail
        LDR     r0,=ZeroPage
      [ ZeroPage = 0
        STR     r0,[r0,#Oscli_CmdHashSum]
      |
        MOV     r3,#0
        STR     r3,[r0,#Oscli_CmdHashSum]
      ]
        STR     r2,[r0,#Oscli_CmdHashLists]
        MOV     r3,#Oscli_MHashValMask+1
      [ ZeroPage <> 0
        MOV     r0, #0
      ]
DynArea_OHinit_loop
        STR     r0,[r2],#4
        SUBS    r3,r3,#1
        BNE     DynArea_OHinit_loop
  ]

  [ DynArea_QuickHandles

        LDR     r3, =DynArea_ws_size
        BL      ClaimSysHeapNode                    ; should not give error - kernel boot
      [ PMPDebug
        DebugReg r2, "DynArea_ws="
      ]
        LDR     r0, =ZeroPage
        STR     r2, [r0, #DynArea_ws]
        MOV     r11, r2
        LDR     r3, =DynArea_ws_size
        ADD     r3, r3, r2
      [ ZeroPage <> 0
        MOV     r0, #0
      ]
DynArea_QHinit_loop1
        STR     r0, [r2], #4
        CMP     r2, r3
        BLO     DynArea_QHinit_loop1

        MOV     r1, #-1
        STR     r1, DynArea_CreatingHandle
        STR     r1, DynArea_LastTreacleHandle
        STR     r1, DynArea_LastEnumHandle
        STR     r1, DynArea_OD8Clamp1
        STR     r1, DynArea_OD8Clamp2
        MOV     r1, #&1000
        RSB     r1, r1, #0
        STR     r1, DynArea_OD8Clamp3               ; 4G - 4k

        ADR     r1, DynArea_QHandleArray            ; init all Qhandles as free, free list = 1..DynArea_NumQHandles
        MOV     r2, #1
        STR     r2, DynArea_FreeQHandles
DynArea_QHinit_loop2
        ADD     r2, r2, #1
        STR     r2, [r1], #4
        CMP     r2, #DynArea_NumQHandles
        BLO     DynArea_QHinit_loop2
        MOV     r2, #0
        STR     r2, [r1]                            ; 0 = end of free list

        MOV     r1, #DynArea_NewAreas-1
        ADD     r1, r1, #DynArea_NumQHandles        ; first non-quick DA number -1
        STR     r1, DynArea_TreacleGuess

        LDR     r1, =ZeroPage+FreePoolDANode
        STR     r1, DynArea_SortedList              ; initially, FreePool at front of sorted list,
        LDR     r2, =ZeroPage+SysHeapDANode
        STR     r2, [r1, #DANode_SortLink]          ; and SysHeap second...
        MOV     r1, #0
        STR     R1, [r2, #DANode_SortLink]          ; ...and last

        ADR     r1, DynArea_SysQHandleArray
        LDR     r2, =ZeroPage+SysHeapDANode
        STR     r2, [r1, #ChangeDyn_SysHeap:SHL:2]
        LDR     r2, =ZeroPage+FreePoolDANode
        STR     r2, [r1, #ChangeDyn_FreePool:SHL:2]

; Initialise the address lookup table for the current DA's
; Assumes we have at least one DA to start with!
        LDR     r2, =ZeroPage+DAList
        LDR     r2, [r2]
DynArea_AddrLookup_loop
        BL      AddDAToAddrLookupTable
        LDR     r2, [r2, #DANode_Link]
        TEQ     r2, #0
        BNE     DynArea_AddrLookup_loop

  |
        ASSERT  ZeroPage = 0
        MOV     r0, #0
        STR     r0, [r0, #DynArea_ws]

  ] ;DynArea_QuickHandles

        LDR     r0, =ZeroPage
      [ ZeroPage = 0
        STR     r0, [r0, #CDASemaphore]         ; clear CDASemaphore
      |
        MOV     r2, #0
        STR     r2, [r0, #CDASemaphore]         ; clear CDASemaphore
      ]

; Now that the system heap is initialised we can create a page list for the
; free pool and start pushing the free pages into it. However it's highly
; unlikely that we'll be able to build the full page list without having to
; grow the system heap - for which we'd want the fast pages to be available.

; So to cope with this we start by putting the fast pages into the page list,
; growing the system heap for every page we insert (a bit slow but reliable).
; After each grow we try to claim the memory needed for the full page list;
; on success we then switch to a different algorithm which fills the main page
; list.

        SUB     sp, sp, #4                      ; Store the initial list on the stack
        LDR     r5, =ZeroPage
        LDR     r6, =ZeroPage+FreePoolDANode
        STR     sp, [r6, #DANode_PMP]
        MOV     r0, #1
        STR     r0, [r6, #DANode_PMPMaxSize]
        MOV     r0, #0
        STR     r0, [r6, #DANode_PMPSize]
        MOV     r0, #-1
        STR     r0, [sp]

        LDR     r0, [r5, #InitUsedStart]
        ADD     r0, r0, #DRAMOffset_FirstFixed - DRAMOffset_L1PT
        BL      PhysAddrToPageNo
        MOV     r7, r0                          ; r7 = page number of start of static chunk
        LDR     r0, [r5, #InitUsedEnd]
        BL      PhysAddrToPageNo
        SUB     r8, r0, #1                      ; r8 = page number of last page in statics
        ADD     r9, r5, #PhysRamTable
        LDMIA   r9!, {r0, r10}                  ; get VRAM info
        MOV     r10, r10, LSR #12               ; r10 = current page number
        LDMIA   r9!, {r0, r11}                  ; get first regular RAM chunk
        SUB     r10, r10, #1                    ; set things up so the first call to NextFreePage will return the first page of the block
        MOV     r11, r11, LSR #12
        ADD     r11, r11, #1
        LDR     r4, [r5, #CamEntriesPointer]
10
        ; See if we have enough space
        LDR     r3, [r5, #MaxCamEntry]
        ADD     r3, r3, #1
        MOV     r3, r3, LSL #2
        Push    "r3"
        MOV     r0, #HeapReason_Desc
        BL      DoSysHeapOpWithExtension        ; HACK - check space before calling, to avoid crashing when the grow fails and tries to generate an error (vector table not initialised yet, so crashes when UKSWIV is invoked in order to call MessageTrans)
        Pull    "r3"
        SUB     r2, r2, #4096                   ; Paranoia
        CMP     r2, r3
        BLT     %FT20
        BL      ClaimSysHeapNode
        BVC     %FT40
20
        ; Find a page we can use to grow the system heap
        BL      NextFreePage                    ; n.b. no out-of-pages check
        STR     r10, [sp]
        LDR     lr, =AreaFlags_FreePool :AND: DynAreaFlags_AccessMask
        STR     lr, [r0, #CAM_PageFlags]
        STR     r6, [r0, #CAM_PMP]
        MOV     lr, #0
        STR     lr, [r0, #CAM_PMPIndex]
        MOV     lr, #1
        STR     lr, [r6, #DANode_PMPSize]
        ; Now grow the system heap by 4K. This had better consume the page!
        MOV     r0, #ChangeDyn_SysHeap
        MOV     r1, #4096
        SWI     XOS_ChangeDynamicArea
        B       %BT10

40
        ; We've successfully allocated the memory for the PMP - start filling
        ; it in. To ensure the pages are in the correct order we need to fill
        ; it from the last entry working backwards, but unfortunately we don't
        ; know exactly how many pages there are - so once we're done we'll have
        ; to shuffle the list down.
        MOV     r0, r3, LSR #2
      [ PMPDebug
        DebugReg r2, "FreePool PMP="
        DebugReg r0, "PMPMaxSize="
      ]
        STR     r0, [r6, #DANode_PMPMaxSize]
        ADD     r3, r2, r3                      ; -> end of list
        MOV     r1, r3
        STR     r2, [r6, #DANode_PMP]
45
        BL      NextFreePage
        CMP     r10, #-1
        STRNE   r10, [r3, #-4]!
        BNE     %BT45                           ; Keep going until we run out of pages
        ; Left with:
        ; r1 -> end of memory block
        ; r2 -> start of memory block
        ; r3 -> last used entry
        ; Calculate and store size
        SUB     r12, r1, r3
        MOV     r12, r12, LSR #2
        STR     r12, [r6, #DANode_PMPSize]
      [ PMPDebug
        DebugReg r12, "PMPSize="
      ]
        ; Shuffle everything down, and fill in the CAM entries (which we
        ; couldn't do earlier since we didn't know the final PMP indices)
        MOV     r12, #0
        LDR     lr, =AreaFlags_FreePool :AND: DynAreaFlags_AccessMask
56
        CMP     r3, r1
        LDRNE   r0, [r3], #4
        STRNE   r0, [r2], #4
        ADDNE   r0, r4, r0, LSL #CAM_EntrySizeLog2
        STRNE   lr, [r0, #CAM_PageFlags]
        STRNE   r6, [r0, #CAM_PMP]
        STRNE   r12, [r0, #CAM_PMPIndex]
        ADDNE   r12, r12, #1
        BNE     %BT56
60
        ; Now r2 -> end of used portion
        ; Fill empty space with -1 (although, we could probably free the space - I don't think it's possible it will ever get used)
        MOV     r0, #-1
61
        CMP     r2, r1
        STRNE   r0, [r2], #4
        BNE     %BT61

        ; Free pool should now be ready for business

        ADD     sp, sp, #4
      [ PMPDebug
        DebugTX "InitDynamicAreas done"
      ]
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        EXIT

;
; NextFreePage - Find next page to insert into the free pool on startup
;
; In:
;   r4 -> CAM
;   r7 = page number of start of static chunk
;   r8 = page number of end of static chunk
;   r9 -> next PhysRamTable entry
;   r10 = Current page number
;   r11 = Number of pages left in current chunk
; Out:
;   r0 -> CAM entry for page
;   r10 = Next free page in optimal order, -1 if no more pages
;   r9, r11 updated
;
; We have to move all free pages (ie ones not occupied by the static pages)
; into the free pool.
; By default, pages will get taken from the end of the free pool when other
; dynamic areas are initialised or grown. So make sure that the slowest RAM
; is at the start of the free pool and the fastest is at the end; this is the
; reverse of the order in PhysRamTable. Also, within each group of pages (i.e.
; PhysRamTable entry), we want the pages to be in decreasing physical address
; order - so that when they are moved to a DA they end up in increasing address
; order, leading to more optimal DMA transfer lists.
;
; Also note that the VRAM block is kept at the start of the free pool, mainly
; to match old behaviour (it's not clear whether moving it elsewhere will have
; any significant impact on the system - especially when you consider that
; shrinking screen memory will end up adding the pages to the end of the pool
; rather than the start).
;
; Over time this optimal ordering will be lost, so at a later date it might be
; nice to re-sort pages as they are added back into the free pool (and move the
; VRAM block to the end of PhysRamTable, so that it's in order fast RAM -> slow
; RAM -> fast DMA -> slow DMA -> VRAM, so that sorting by page number is
; all that's required to deal with both contiguity and desirability)
;
; In terms of this routine, we fill the free pool from the highest entry down,
; so we want the first page returned to be the lowest-numbered page from the
; first (non-VRAM) PhysRamTable entry.
;
NextFreePage    ROUT
        Entry
10
        SUBS    r11, r11, #1
        ADD     r10, r10, #1
        BEQ     %FT30
20
        CMP     r10, r7
        CMPHS   r8, r10
        BHS     %BT10                           ; page is in statics
        ; Check the CAM map to see if the page is already taken - this will detect the DMA regions, which aren't included in InitUsedStart/InitUsedEnd
        ADD     r0, r4, r10, LSL #CAM_EntrySizeLog2
        LDR     lr, [r0, #CAM_PageFlags]
        TST     lr, #PageFlags_Unavailable
        BNE     %BT10
        ; Page is good
        EXIT

30
        ; Advance to next block
        LDR     lr, =ZeroPage+PhysRamTable+8
        CMP     lr, r9                          ; if we've just processed the VRAM block, we're done
        BEQ     %FT90
        LDMIA   r9!, {r0, r11}                  ; else get next block
        MOVS    r11, r11, LSR #12               ; if no more blocks left...
        BNE     %BT20
        MOV     r10, #0
        MOV     r9, lr
        LDMDB   lr, {r0, r11}                   ; ...then process VRAM
        MOVS    r11, r11, LSR #12               ; And if no VRAM...
        BNE     %BT20
90                                              ; ...then we're done
        MOV     r10, #-1
        EXIT
                

        LTORG

InitFreePoolTable
 [ FreePoolAddress > SysHeapStart
        &       0                               ; link: no more nodes on list
 |
        &       ZeroPage+SysHeapDANode
 ]
        &       ChangeDyn_FreePool
        &       FreePoolAddress
        &       AreaFlags_FreePool
        &       0                               ; size will be updated later
        &       0                               ; max size is computed
        &       0                               ; no workspace needed
        &       0                               ; no handler needed
        &       FreePoolString                  ; title

InitSysHeapTable
 [ FreePoolAddress > SysHeapStart
        &       ZeroPage+FreePoolDANode         ; link -> free pool node, since FreePoolAddress > SysHeapStart
 |
        &       0
 ]
        &       ChangeDyn_SysHeap
        &       SysHeapStart
        &       AreaFlags_SysHeap
        &       32*1024-(SysHeapStart-SysHeapChunkAddress) ; size
        &       SysHeapMaxSize
        &       SysHeapStart                    ; workspace pointer -> base of heap
        &       DynAreaHandler_SysHeap          ; area handler
        &       SysHeapString                   ; title

InitAppSpaceTable
        &       0                               ; link: not on list
        &       ChangeDyn_AplSpace
        &       0                               ; base address
        &       AreaFlags_AppSpace
        &       32*1024                         ; true size will be set up later
        &       AplWorkMaxSize
        &       0                               ; no workspace needed
        &       0                               ; no handler needed
        &       AppSpaceString                  ; title

FreePoolString
        =       "Free pool", 0
AppSpaceString
        =       "Application space", 0
SysHeapString
        =       "System heap", 0
        ALIGN



;**************************************************************************
;
;       ClaimCDASemaphore - Claims CDASemaphore if possible
;
; out:  EQ -> CDASemaphore claimed
;       NE -> not claimed
;
ClaimCDASemaphore
        Entry   "r10"
        LDR     r10, =ZeroPage                  ; check we're not in an IRQ
        LDR     lr, [r10, #IRQsema]
        TEQ     lr, #0
        LDREQ   lr, [r10, #CDASemaphore]       ; now also check whether ChangeDynamicArea is already threaded
        TEQEQ   lr, #0
        STREQ   pc, [r10, #CDASemaphore]     ; store non-zero value in CDASemaphore, to indicate we're threaded
        EXIT

;**************************************************************************
;
;       ChangeDynamicSWI - implement OS_ChangeDynamicArea (change the
;                          size of a dynamic area)
;
; in:   r0 = area number
;       r1 = size of change (in bytes, signed integer)
;
; out:  r0   preserved
;       r1 = actual amount moved (in bytes, unsigned integer)
;

  [ DA_Batman
;OR, a special call is allowed for internal use:
;
; in:   r0 = ChangeDyn_Batman (-3)
;       r1 = size of change (in bytes, signed integer)
;       r2 -> pseudo DANode for this call - base of DA will be base of fragment to map/unmap,
;             magnitude of r1 will give size of fragment, sign of r1 is +ve for map -ve for unmap
  ]

ChangeDynamicSWI ROUT
        Push    "r0, r2-r9, r10, lr"

        FastCDA_ProfInit r3

        BL      ClaimCDASemaphore
        BNE     failure_IRQgoing

 [ DebugCDA2
        DLINE   "Entering OS_ChangeDynamicArea (new code)"
 ]

  [ DA_Batman
    ;check for special Batman call (which uses OS_ChangeDynamicArea to map or unmap a fragment of a sparse DA)
        CMP     r0, #ChangeDyn_Batcall
        MOVEQ   r10, r2                         ; Batman call passes a pseudo DANode in r2
        BEQ     CDA_handlechecked
  ]

        Push    "r1"
        MOV     r1, r0
 [ DebugCDA2
        DREG    r1, "Checking list for area number "
 ]

  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; check area number is on list
  |
        BL      CheckAreaNumber                 ; check area number is on list
  ]

        Pull    "r1"
        BCC     failure_IRQgoingClearSemaphore

 [ DebugCDA2
        DLINE   "Found entry on list"
 ]

  [ DA_Batman
        ;a sparse area is not allowed to do an ordinary grow or shrink
        ;
        LDR     r11, [r10, #DANode_Flags]
        TST     r11, #DynAreaFlags_SparseMap
        BNE     failure_IRQgoingClearSemaphore
        CMP     r0, #ChangeDyn_FreePool         ; Free pool is handled here. Other PMPs call through to their resize handler.
        TSTNE   r11, #DynAreaFlags_PMP
        BNE     CDA_PMP
  ]
      [ PMPParanoid
        BL      ValidatePMPs
      ]

CDA_handlechecked

  [ DynArea_QuickHandles
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        LDR     r5, DynArea_OD6Signature
        CMP     r0, #ChangeDyn_MaxArea
        BLS     daq_cda_od6done
        CMP     r0, #&FFFFFFF0                  ;don't count special DA numbers, such as ChangeDyn_AplSpace
        BHI     daq_cda_od6done
        TST     r5, #&80000000                  ;if set, disables resize signature for this call
        STREQ   r5, DynArea_OD6PrevSignature
        STREQ   r0, DynArea_OD6Handle
        ORREQ   r5, r5, #4
daq_cda_od6done
        BIC     r5, r5, #&80000000              ;clear any disable
        STR     r5, DynArea_OD6Signature
  ]

        LDR     r5, =ZeroPage
        LDR     r5, [r5, #Page_Size]            ; r5 = page size throughout
        SUB     r12, r5, #1                     ; r12 = page mask
        ADD     r1, r1, r12
        BICS    r1, r1, r12
        BEQ     IssueServiceMemoryMoved         ; zero pages! (r0 = area number, r1 = size change (0))
        BPL     AreaGrow

AreaShrink ROUT
        RSB     r1, r1, #0                      ; make size change positive
 [ DebugCDA2
        DREG    r0, "Shrinking area ", cc
        DREG    r1, " by "
 ]
        MOV     r11, r10                        ; source is area
        CMP     r0, #ChangeDyn_FreePool         ; if source is free pool
        BEQ     ShrinkFreePoolToAppSpace        ; then dest is appspace
        LDR     r12, =ZeroPage+FreePoolDANode   ; else dest is free pool

        ASSERT  DANode_PMPMaxSize = DANode_PMPSize +4
        ADD     r2, r12, #DANode_PMPSize
        LDMIA   r2, {r2, r3}

      [ PMPDebug
        DebugReg r0,"Shrinking area "
        DebugReg r1,"by "
        DebugReg r2,"FreePool PMPSize "
      ]
        SUB     lr, r3, r2                      ; lr = amount dest could grow

      [ ZeroPage = 0
        TEQ     r11, #AppSpaceDANode            ; check if src = appspace
      |
        LDR     r2, =ZeroPage+AppSpaceDANode
        TEQ     r11, r2                         ; check if src = appspace
      ]

        LDR     r2, [r11, #DANode_Size]         ; amount src could shrink
        SUBEQ   r2, r2, #&8000                  ; protect first 32K of app space because app space DANode is silly
        CMP     lr, r2, LSR #12
        MOVHI   lr, r2, LSR #12                 ; lr = min(amount dest could grow, amount src could shrink)

        CMP     lr, r1, LSR #12
        BHS     %FT15

; we can't move all that is required, so move smaller amount

        MOV     r1, lr, LSL #12                 ; move smaller amount

        BL      GenNotAllMovedError
        SUB     lr, r5, #1                      ; lr = pagesize mask
        BICS    r1, r1, lr                      ; a pagesize multiple
        BEQ     IssueServiceMemoryMoved
15
      [ ZeroPage = 0
        CMP     r11, #AppSpaceDANode            ; if src <> appspace
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        CMP     r11, lr                         ; if src <> appspace
      ]
        BNE     %FT17                           ; then don't call app
        Push    "r10"                           ; save -> to area we tried to shrink
        MOV     r10, r1
        BL      CheckAppSpace
        Pull    "r10"
        BVS     ChangeDynError
17
        BL      CallPreShrink
        BVS     ChangeDynError                  ; (r10 still points to area we tried to shrink)
        CMP     r2, r1                          ; can we move as much as we wanted?
        MOVCS   r2, r1                          ; if not, then move lesser amount (r2 = amount we're moving)
        BLCC    GenNotAllMovedError             ; store error, but continue

        TEQ     r2, #0                          ; if can't move any pages
        BEQ     NoMemoryMoved                   ; then exit, issuing Service_MemoryMoved

        BL      DoTheShrink                     ; Move all the pages around

        LDR     r4, =ZeroPage
      [ ZeroPage = 0
        STR     r4, [r4, #CDASemaphore]         ; OK to reenter now (we've done the damage)
      |
        MOV     lr, #0
        STR     lr, [r4, #CDASemaphore]
      ]
        BL      CallPostShrink
        RSB     r1, r2, #0
        LDR     r0, [r11, #DANode_Number]       ; reload dynamic area number
        B       IssueServiceMemoryMoved

GrowFreePoolFromAppSpace ROUT
        ; To reduce code complexity, we treat a grow of the free pool as a
        ; shrink of application space
        GetAppSpaceDANode r10
        LDR     r0, [r10, #DANode_Flags]
        TST     r0, #DynAreaFlags_PMP
        RSB     r1, r1, #0                      ; (AreaShrink assumes negative size on entry)
        MOVEQ   r0, #ChangeDyn_AplSpace
        BEQ     AreaShrink
        ; Shrink of PMP appspace - go via CDA_PMP
        B       CDA_PMP

ShrinkFreePoolToAppSpace ROUT
        ; To reduce code complexity, we treat a shrink of the free pool as a
        ; grow of application space
        MOV     r0, #ChangeDyn_AplSpace
        GetAppSpaceDANode r10
        ; Emulate old behaviour, when this case used to be part of AreaShrink:
        ; * If app space doesn't have enough free space, clamp amount and
        ; generate NotAllMoved error (Regular AreaGrow logic will only do this
        ; if dest is free pool - grows of other areas have always failed
        ; outright if they're incapable of growing that big)
        ; * If shrinking more than current free pool size, attempt to shrink
        ; shrinkable DAs so that as much memory as possible can be moved to app
        ; space
        ; * Call CheckAppSpace (rule seems to be that if app space is touched,
        ; CheckAppSpace must be called, except when it's an explicit grow of
        ; app space)
        MOV     r12, r10                        ; required by e.g. TryToShrinkShrinkables
        ASSERT  DANode_MaxSize = DANode_Size +4
        ADD     r2, r10, #DANode_Size
        LDMIA   r2, {r2, r3}
        SUB     lr, r3, r2                      ; lr = amount dest could grow
 [ ShrinkableDAs
        CMP     r1, lr
        MOVHI   r1, lr
        BLHI    GenNotAllMovedError
        SUB     lr, r5, #1                      ; lr = pagesize mask
        BICS    r1, r1, lr                      ; a pagesize multiple
        BEQ     IssueServiceMemoryMoved
 ]

        LDR     r11, =ZeroPage+FreePoolDANode
 [ ShrinkableDAs
        LDR     r2, [r11, #DANode_PMPSize]      ; amount src could shrink
        CMP     r2, r1, LSR #12
        BLCC    TryToShrinkShrinkables
        BCS     %FT15                           ; [we can now do it all]

; we can't move all that is required, so move smaller amount

        MOV     r1, r2, LSL #12                 ; move smaller amount
 |
        LDR     r2, [r11, #DANode_PMPSize]      ; amount src could shrink
        CMP     r2, lr, LSR #12
        MOVCC   lr, r2, LSL #12                 ; lr = min(amount dest could grow, amount src could shrink)

        CMP     r1, lr
        BLS     %FT15     

; we can't move all that is required, so move smaller amount

        MOV     r1, lr                          ; move smaller amount
 ]
        BL      GenNotAllMovedError
        SUB     lr, r5, #1                      ; lr = pagesize mask
        BICS    r1, r1, lr                      ; a pagesize multiple
        BEQ     IssueServiceMemoryMoved
15
        Push    "r10"                           ; save -> to area we tried to shrink
        MOV     r10, r1
        BL      CheckAppSpace
        Pull    "r10"
        BVS     ChangeDynError
        LDR     r12, [r10, #DANode_Flags]
        TST     r12, #DynAreaFlags_PMP
        BNE     CDA_PMP                         ; Make sure PMP AppSpace goes via PMP handler
        ; Fall through...

AreaGrow ROUT
 [ DebugCDA2
        DREG    r0, "Growing area ", cc
        DREG    r1, " by "
 ]
        MOV     r12, r10                        ; dest is area specified
        CMP     r0, #ChangeDyn_FreePool         ; if dest is free pool
        BEQ     GrowFreePoolFromAppSpace        ; then src is appspace
        LDR     r11, =ZeroPage+FreePoolDANode   ; else src is free pool (may later be free+apl)

        ASSERT  DANode_MaxSize = DANode_Size +4
        ADD     r2, r12, #DANode_Size
        LDMIA   r2, {r2, r3}

      [ PMPDebug
        DebugReg r0,"Growing area "
        DebugReg r1,"by "
        DebugReg r2,"dest size "
        DebugReg r3,"dest max size "
        Push    "r0"
        LDR     r0, [r11, #DANode_PMPSize]      ; amount src could shrink
        DebugReg r0, "FreePool PMPSize "
        Pull    "r0"
      ]

        SUB     lr, r3, r2                      ; lr = amount dest could grow

 [ DebugCDA2
        DREG    lr, "Dest could grow by "
 ]
        LDR     r2, [r11, #DANode_PMPSize]      ; amount src could shrink

 [ DebugCDA2
        DREG    r2, "Src could shrink by "
 ]

        CMP     lr, r1                          ; if enough room in dest
        CMPHS   r2, r1, LSR #12                 ; and enough space in src
        MOVHS   r3, r1                          ; then can do full amount
        BHS     %FT65                           ; so skip this bit

; we can't move all that is required
;
; check if adding shrinkables or aplspace would allow us to succeed
; if it does then adjust registers, else give error
;

 [ DebugCDA2
        DLINE   "Can't move all required using just free pool"
 ]
        B       %FT62

61
        BL      GenNotAllMovedError
        SUB     lr, r5, #1                      ; lr = pagesize mask
        BICS    r1, r1, lr                      ; a pagesize multiple
        BEQ     IssueServiceMemoryMoved
        MOV     r3, r1
        B       %FT65

62

 [ ShrinkableDAs
; growing another area from free pool
; insert code here to check for shrinking shrinkable areas

        CMP     r1, lr                          ; if dest can't grow by this amount,
        BHI     %FT64                           ; we're definitely not doing anything

        CMP     r2, r1, LSR #12                 ; this should definitely set C=0 as required by TryToShrinkShrinkables
        Push    "lr"
        BLCC    TryToShrinkShrinkables_Bytes
        Pull    "lr"
        MOVCS   r3, r1                          ; if succeeded set r3 to number of bytes to do
        BCS     %FT65                           ; and do it
64

; end of inserted code
 ]

        GetAppSpaceDANode r4
        EORS    r6, r4, r12                     ; only take from app space if dest isn't app space!
        LDRNE   r6, [r4, #DANode_Size]          ; get current size of apl space
        LDRNE   r4, [r4, #DANode_Flags]
        EORNE   r4, r4, #DynAreaFlags_PMP
        TSTNE   r4, #DynAreaFlags_PMP
        SUBNE   r6, r6, #&8000                  ; can't take away 0-&7FFF
        ADD     r3, r2, r6, LSR #12             ; add on to amount we could remove from free pool (pages)

 [ DebugCDA2
        DREG    r6, "Can get from app space an additional ", cc
        DREG    r3, " bytes making a total of ", cc
        DLINE   " pages"
 ]

        CMP     lr, r1                          ; if not enough room in dest
        CMPHS   r3, r1, LSR #12                 ; or src still doesn't have enough
        MOVLO   r1, #0                          ; then don't move any
        BLO     %BT61                           ; and return error

        ; To reduce code complexity, first shrink application space into the free pool, then take the combined chunk from the free pool
        Push    "r0-r1,r3"
        LDR     r3, =ZeroPage
        MOV     r0, #0
        STR     r0, [r3, #CDASemaphore]         ; Allow nested call
        RSB     r1, r1, r2, LSL #12             ; free pool size minus total amount = app space size change needed
        MOV     r0, #ChangeDyn_AplSpace
        SWI     XOS_ChangeDynamicArea
        STR     pc, [r3, #CDASemaphore]         ; reclaim semaphore
        MOVVS   r1, #1
        CMP     r1, #0                          ; if not all moved
        Pull    "r0-r1"
        MOVNE   r1, #0                          ; then claim nothing moved
        BNE     %BT61                           ; and return error
        ; Double-check that the free pool did actually grow large enough
        ; (just paranoia for now, but may be important in future)
        LDR     r3, [r11, #DANode_PMPSize]
        CMP     r3, r1, LSR #12
        MOVLO   r1, #0
        BLO     %BT61

        MOV     r3, r1                          ; amount actually doing (bytes)
65

        MOV     r7, r3                          ; set up r7 to be total amount

 [ DebugCDA2
        DREG    r3, "Amount actually moving into area = "
        DREG    r7, "Amount coming from 1st src area = "
 ]

; now split up grow into bite-size chunks, and call DoTheGrow to do each one

        Push    "r3"                            ; save original total amount

        LDR     lr, [r12, #DANode_Flags]        ; could this area require particular physical pages at all?
        TST     lr, #DynAreaFlags_NeedsSpecificPages+DynAreaFlags_NeedsDMA
        TSTEQ   lr, #DynAreaFlags_PMP           ; detect batcall from PMP PhysOp
        BNE     %FT70                           ; [yes it could, so do it in lumps]

        MOV     r1, #0                          ; no page block
        MOV     r2, r3, LSR #12                 ; number of pages to do
        BL      CallPreGrow
        LDRVS   r3, [sp]                        ; if error, haven't done any, so restore total as how much to do
        BVS     %FT95

        Push    "r3, r7"
        MOV     r2, r7, LSR #12
        BL      DoTheGrowNotSpecified
        Pull    "r3, r7"

        LDR     r3, [sp]                        ; restore total amount
        MOV     r1, #0                          ; indicate no page block (and ptr to semaphore)
      [ ZeroPage = 0
        STR     r1, [r1, #CDASemaphore]         ; OK to reenter now (we've done the damage)
      |
        LDR     r2, =ZeroPage
        STR     r1, [r2, #CDASemaphore]         ; OK to reenter now (we've done the damage)
      ]
        MOV     r2, r3, LSR #12
        BL      CallPostGrow
        BVS     %FT95
        B       %FT80

70
        Push    "r3, r7"
        CMP     r7, #PageBlockChunk             ; only do 1 area, so do min(r7,page)
        MOVHI   r7, #PageBlockChunk
        MOV     r2, r7, LSR #12                 ; number of entries to fill in in page block
        BL      DoTheGrow
        Pull    "r3, r7"
        BVS     %FT95
        CMP     r7, #PageBlockChunk             ; if 1st area is more than 1 page
        SUBHI   r3, r3, #PageBlockChunk         ; then reduce total
        SUBHI   r7, r7, #PageBlockChunk         ; and partial amounts by 1 page and do it again
        BHI     %BT70

80
        Pull    "r3"                            ; restore total amount

        MOV     r1, r3
        LDR     r0, [r12, #DANode_Number]       ; reload dynamic area number
        B       IssueServiceMemoryMoved

95
        Pull    "r1"                            ; restore total amount
        SUB     r1, r1, r3                      ; subtract off amount left, to leave done amount
        B       ChangeDynErrorSomeMoved

GenNotAllMovedError Entry "r0"
        ADRL    r0, ErrorBlock_ChDynamNotAllMoved
 [ International
        BL      TranslateError
 ]
        STR     r0, [sp, #2*4]          ; sp -> r0,lr, then stacked r0,r2-r9,r10,lr
        LDR     lr, [sp, #12*4]
        ORR     lr, lr, #V_bit
        STR     lr, [sp, #12*4]
        EXIT

        LTORG

ChangeDynError

; in:   r0 -> error
;       r10 -> area that we tried to shrink/grow

        MOV     r1, #0
ChangeDynErrorSomeMoved
        STR     r0, [sp]
        LDR     lr, [sp, #10*4]
        ORR     lr, lr, #V_bit
        STR     lr, [sp, #10*4]
        B       SomeMemoryMoved

NoMemoryMoved
        MOV     r1, #0                          ; nothing moved
SomeMemoryMoved
        LDR     r0, [r10, #DANode_Number]       ; reload area number

; and drop thru to...

IssueServiceMemoryMoved

; in:   r0 = area number that was shrunk/grown
;       r1 = amount moved (signed)
;
  [ DA_Batman
        CMP     r0, #ChangeDyn_Batcall
        BEQ     ISMM_BatCloak           ; cloaking device (no service issue)
  ]
        Push    "r1"
        MOV     r2, r0                  ; r2 = area number
        MOV     r0, r1                  ; amount moved (signed)
        MOV     r1, #Service_MemoryMoved
        BL      Issue_Service
        Pull    "r1"                    ; restore amount moved
  [ DA_Batman
ISMM_BatCloak
  ]
        TEQ     r1, #0
        RSBMI   r1, r1, #0              ; r1 on exit = unsigned amount

        LDR     r0, =ZeroPage
      [ ZeroPage = 0
        STR     r0, [r0, #CDASemaphore] ; clear CDASemaphore
      |
        MOV     lr, #0
        STR     lr, [r0, #CDASemaphore] ; clear CDASemaphore
      ]
        Pull    "r0, r2-r9, r10, lr"
        ExitSWIHandler

CDA_PMP ROUT
        ; OS_ChangeDynamicArea implementation for PMPs
        ; Call through to the areas handler routine and let it do all the work
        LDR     r2, =ZeroPage
        MOV     r0, #0
        STR     r0, [r2, #CDASemaphore] ; Ensure handler can call back into us to modify the PMP
        ASSERT  DANode_Handler = DANode_Workspace + 4
        ADD     r12, r10, #DANode_Workspace
        Pull    "r2"
        ; Call with:
        ; r0 = reason
        ; r1 = change amount (pages)
        ; r2 = DA number
        LDR     r11, [r10, #DANode_PMPSize] ; Remember current size
        MOV     r0, #DAHandler_ResizePMP
        MOV     r1, r1, ASR #12
        MOV     lr, pc
        LDMIA   r12, {r12, pc}          ; Call handler
        ; Exit without issuing service call - PhysOp should have triggered it for us
        MOVVC   r0, r2                  ; r0 = DA number if no error
        MRS     r2, CPSR
        LDR     r10, [r10, #DANode_PMPSize]
        SUBS    r1, r10, r11
        RSBLT   r1, r1, #0              ; get unsigned change for OS_ChangeDynamicArea return
        CMP     r1, #DynArea_PMP_BigPageCount ; even though unsigned, use same +2GB clamp
        MOVLO   r1, r1, LSL #12
        LDRHS   r1, =DynArea_PMP_BigByteCount
        TST     r2, #V_bit
        BNE     %FT90
        Pull    "r2-r9,r10,lr"
        ExitSWIHandler
90
        ; If no error pointer, generate can't move error
        TEQ     r0, #0
        ADREQL  r0, ErrorBlock_ChDynamNotAllMoved
 [ International
        BLEQ    TranslateError
 ]
        Pull    "r2-r9,r10,lr"
        ORR     lr, lr, #V_bit
        ExitSWIHandler

; ***********************************************************************************
;
;       GrowFreePool - Try and grow the free pool so it's at least the given size
;
; in:   r1 = desired page count
;       r12 -> dst area node (we won't try and shrink this one)
;
; out:  C=0 => failed to move as much as we wanted
;       C=1 => succeeded in moving as much as we wanted
GrowFreePool ROUT
        Entry   "r0-r2,r11"
        ; Check to see if there's already enough space
        LDR     r11, =ZeroPage+FreePoolDANode
        LDR     r2, [r11, #DANode_PMPSize]
        SUBS    r0, r2, r1
        BHS     %FT90
 [ ShrinkableDAs
        ; Try and shrink shrinkables
        CLC
        BL      TryToShrinkShrinkables
        EXIT    CS
        SUB     r0, r2, r1              ; Update how many pages still needed
 ]
        ; Try shrinking application space, if r12 != appspace
        LDR     lr, [r12, #DANode_Number]
        CMP     lr, #ChangeDyn_AplSpace
        BEQ     %FT80
        LDR     r2, [r11, #CDASemaphore-FreePoolDANode]
        MOV     r0, #0
        STR     r0, [r11, #CDASemaphore-FreePoolDANode] ; Allow nested call
        CMN     r0, #DynArea_PMP_BigPageCount ; r0 is negative
        MOVGT   r1, r0, LSL #12
        LDRLE   r1, =-DynArea_PMP_BigByteCount
        MOV     r0, #ChangeDyn_AplSpace
        SWI     XOS_ChangeDynamicArea
        STR     r2, [r11, #CDASemaphore-FreePoolDANode] ; reclaim semaphore
        MOVVS   r1, #1
        CMP     r1, #0                  ; if all moved
        BEQ     %FT90                   ; then success
        ; Fall through...
80
        CLC
        EXIT

90
        SEC
        EXIT

 [ ShrinkableDAs
; ***********************************************************************************
;
;       TryToShrinkShrinkables - Attempt to make more space by shrinking shrinkable areas if appropriate
;
; in:   r1 = total amount we wish to have in src area (page count, already limited by max_size of destination area)
;       r2 = current size of src area (pages, must be less than r1)
;       r11 -> src area node (we don't do anything unless this is the free pool)
;       r12 -> dst area node (we won't try and shrink this one)
;       C = 0
;
; out:  r2 = new size of src area (pages)
;       C=0 => failed to move as much as we wanted
;       C=1 => succeeded in moving as much as we wanted

TryToShrinkShrinkables ROUT
        Entry   "r0,r1,r10"
        LDR     lr, [r11, #DANode_Number]
        TEQ     lr, #ChangeDyn_FreePool
        EXIT    NE                              ; if src <> free pool, exit with C, V flags intact

        LDR     r10, [r11, #DynArea_ws-FreePoolDANode]
        ADD     r10, r10, #:INDEX:DynArea_ShrinkableSubList-DANode_SubLink ; get shrinkable DA list
10
        LDR     r10, [r10, #DANode_SubLink]     ; and load next
        CMP     r10, #1                         ; any more nodes?
        EXIT    CC                              ; no, then no match
        TEQ     r10, r12                        ; check area <> dest
        BEQ     %BT10                           ; if not, try next area

        LDR     lr, [r10, #DANode_Flags]
        TST     lr, #DynAreaFlags_PMP
        SUB     lr, r1, r2                      ; lr = amount we still need
        LDREQ   r1, [r10, #DANode_Size]         ; available size of this area
        MOVEQ   r1, r1, LSR #12
        LDRNE   r1, [r10, #DANode_PMPSize]
        CMP     lr, r1
        MOVLO   r1, lr                          ; min(amount we need, size of this area)
        CMP     r1, #DynArea_PMP_BigPageCount
        MOVLO   r1, r1, LSL #12
        RSBLO   r1, r1, #0                      ; make negative - it's a shrink
        LDRHS   r1, =-DynArea_PMP_BigByteCount
        MOV     r0, #0
        LDR     r2, [r11, #CDASemaphore-FreePoolDANode] ; preserve old CDASemaphore (may not be set, e.g. when called from AMBControl)
        STR     r0, [r11, #CDASemaphore-FreePoolDANode] ; momentarily pretend we're not threaded
        LDR     r0, [r10, #DANode_Number]
        SWI     XOS_ChangeDynamicArea
        STR     r2, [r11, #CDASemaphore-FreePoolDANode] ; we're threaded again
        FRAMLDR r1                              ; reload original r1
        LDR     r2, [r11, #DANode_PMPSize]      ; get new size of src area
        CMP     r2, r1
        BCC     %BT10                           ; if still too small, loop
        EXIT                                    ; exit CS indicating success

TryToShrinkShrinkables_Bytes ROUT
        Entry
        MOV     r1, r1, LSR #12
        MOV     r2, r2, LSR #12
        BL      TryToShrinkShrinkables
        MOV     r1, r1, LSL #12
        MOV     r2, r2, LSL #12                 ; n.b. may overflow!
        EXIT
 ]

; ***********************************************************************************
;
;       DoTheGrow - Do one chunk of growing, small enough to fit into the page block on the stack
;
; in:   r2 = number of entries to put in page block (for this chunk)
;       r5 = page size
;       r7 = amount taking from src area (in this chunk)
;       (r10 -> dest area)
;       r11 -> src area (always free pool)
;       r12 -> dest area
;
; out:  r0-r2,r4,r6-r9 may be corrupted
;       r3,r5,r10-r12 preserved
;
; Note: Removal is from one area only, the calling routine breaks the chunks up at free/app boundary.

; Temporary (stack frame) workspace used by this routine

                ^       0, sp
NumEntries      #       4                       ; Number of entries to do for this chunk
TotalAmount     #       4                       ; Total size of grow for this chunk (ie entry value of r3)
DestAddr        #       4                       ; Log addr of 1st page being added to dest
DestFlags       #       4                       ; Page flags for destination area
SavedPSR        #       4                       ; PSR before IRQs disabled
Offset1To2      #       4                       ; Offset from 1st to 2nd bank
PageBlock1      #       PageBlockSize           ; 1st page block, for original page numbers and phys. addrs
PageBlock2      #       PageBlockSize           ; 2nd page block, for new page numbers and phys. addrs

DoTheGrowStackSize *    :INDEX: @@

; Offset1To2 is only used by the first half of the routine. Reuse the space as flags for the second half:
                    ^   :INDEX: Offset1To2, sp
NeedToMoveFlag      #   1                       ; Whether we still need to move the current page
                    #   3                       ; (spare)

DoTheGrow ROUT
        Entry "r3,r5,r10-r12", DoTheGrowStackSize

; First fill in the page block with -1 in the physical page number words

        STR     r2, NumEntries                  ; save number of entries for use later
        STR     r7, TotalAmount                 ; save amount growing by

        FastCDA_ProfStart DoTheGrowInit, r0, r1, lr
        ADR     r1, PageBlock1                  ; point at 1st page block on stack
        ADD     lr, r2, r2, LSL #1              ; lr = number of words in page block
        ADD     lr, r1, lr, LSL #2              ; lr -> off end of page block
        MOV     r0, #-1
10
        STR     r0, [lr, #-12]!                 ; store -1, going backwards
        STR     r0, [lr, #PageBlockSize]        ; and put -1 in 2nd page block as well
        TEQ     lr, r1                          ; until the end
        BNE     %BT10
        FastCDA_ProfEnd DoTheGrowInit, r0, r3, lr

; Now call the pre-grow handler

        MOV     r3, r7
        BL      CallPreGrow
        EXIT    VS

; now check to see if particular pages are required

        LDR     lr, [r1]                        ; load page number in 1st entry
        CMP     lr, #-1                         ; is it -1?
        BNE     DoTheGrowPagesSpecified         ; if not, then jump to special code

        MOV     r2, r3                          ; amount moving
        ADR     r3, PageBlock1
        BL      DoTheGrowCommon                 ; Move all the pages around
        MOV     r3, r2                          ; r3 = size of change
        LDR     r2, NumEntries                  ; restore number of entries in page block
        ADR     r1, PageBlock1                  ; point at page block 1 with page numbers filled in
        BL      CallPostGrow
        CLRV
        EXIT

DoTheGrowPageUnavailable ROUT

; Come here if a required page is not available
; First we need to go back thru all the part of the page block we've already done,
; marking the pages as not being used after all

        ADR     r2, PageBlock1
38
        LDR     r4, [r1, #-12]!                 ; r4 = physical page number
        ADD     r4, r0, r4, LSL #CAM_EntrySizeLog2 ; point at cam entry
        ASSERT  CAM_PageFlags=4
        LDMIA   r4, {r8, lr}
        BIC     lr, lr, #PageFlags_Required
        STMIA   r4, {r8, lr}
        TEQ     r1, r2
        BNE     %BT38

; since pre-grow handler exited without an error, we have to keep our promise
; to call the post-grow handler

        MOV     r3, #0                          ; no pages moved
        MOV     r2, #0                          ; no pages moved
        ADR     r1, PageBlock1                  ; not really relevant
        BL      CallPostGrow

        ADR     r0, ErrorBlock_CantGetPhysMem
 [ International
        BL      TranslateError
 |
        SETV
 ]
        EXIT

        MakeErrorBlock  CantGetPhysMem

DoTheGrowPagesSpecified ROUT

; First check if any of the pages requested are unavailable
; At the same time as we're doing this, we fill in the log. and phys. addresses in the block

        FastCDA_ProfStart MarkRequired, r0, r6, lr
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #CamEntriesPointer]
05
        LDR     r3, [r1], #12                   ; r4 = physical page number
        ADD     r4, r0, r3, LSL #CAM_EntrySizeLog2 ; point at cam entry
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMIA   r4, {r8, lr}                    ; r8 = log. addr, lr = PPL
        STR     r8, [r1, #4-12]                 ; store log. addr in page block
        STR     r8, [r1, #PageBlockSize+4-12]   ; and in 2nd page block

        TST     lr, #PageFlags_Unavailable :OR: PageFlags_Required ; if page in use by someone else, or by us, then return error
        BNE     DoTheGrowPageUnavailable
        ORR     lr, lr, #PageFlags_Required     ; set bit in flags to say page will be needed
        STR     lr, [r4, #CAM_PageFlags]        ; and store back

; work out physical address direct from physical page number, NOT from logical address, since log addr may be Nowhere (multiply mapped, or PMP)

        LDR     r4, =ZeroPage+PhysRamTable
06
        LDMIA   r4!, {r8, lr}                   ; load phys addr, size
        SUBS    r3, r3, lr, LSR #12             ; subtract off number of pages in this chunk
        BCS     %BT06

        ADD     r3, r3, lr, LSR #12             ; put back what could not be subtracted
        ADD     r8, r8, r3, LSL #12             ; and add onto base address
        STR     r8, [r1, #8-12]                 ; store physical address in page block

        SUBS    r2, r2, #1
        BNE     %BT05
        FastCDA_ProfEnd MarkRequired, r0, r6, lr

; now issue Service_PagesUnsafe

        FastCDA_ProfStart PagesUnsafe, r0, r6, lr
        ADR     r2, PageBlock1                  ; r2 -> 1st page block
        LDR     r3, NumEntries                  ; r3 = number of entries in page block
        MOV     r1, #Service_PagesUnsafe
        BL      Issue_Service
        FastCDA_ProfEnd PagesUnsafe, r0, r6, lr

; now move the pages

        LDR     r2, TotalAmount                 ; amount moving
        LDR     r0, [r11, #DANode_PMP]
        LDR     r3, [r11, #DANode_PMPSize]
        ADD     r0, r0, r3, LSL #2              ; move r0 to point to after end of area
        SUB     r3, r3, r2, LSR #12             ; reduce by amount moving from area
        STR     r3, [r11, #DANode_PMPSize]      ; store reduced source size

        LDR     r1, [r12, #DANode_Base]
        LDR     r3, [r12, #DANode_Size]

        LDR     r6, [r12, #DANode_Flags]        ; r6 = dst flags
        ; If dest is a PMP, then this must be the batcall made by PhysOp, and
        ; we don't need to mask the flags.
        TST     r6, #DynAreaFlags_PMP
        LDREQ   lr, =DynAreaFlags_AccessMask
        ANDEQ   r6, r6, lr
        ORREQ   r6, r6, #PageFlags_Unavailable  ; set unavailable bit if regular DA. For PMPs, PMP has control over this.
        STR     r6, DestFlags                   ; save for later
        TST     r6, #DynAreaFlags_DoublyMapped  ; check if dst is doubly mapped
        BEQ     %FT15                           ; [it's not, so skip all this, and r9 will be irrelevant]

; we must shunt all existing pages in dest area down

        MOVS    r4, r3                          ; amount to do
        BLNE    ShuffleDoublyMappedRegionForGrow
        ADD     r9, r3, r2                      ; set up offset from 1st copy to 2nd copy (= new size)
15
        STR     r9, Offset1To2                  ; store offset 1st to 2nd copy
        ADD     r1, r1, r3                      ; r1 -> address of 1st extra page
        STR     r1, DestAddr
        ADR     r8, PageBlock1                  ; r8 -> position in 1st page block
        SUB     r2, r0, r2, LSR #12-2           ; r2 = lowest address being removed from src
        LDR     r3, =ZeroPage
        LDR     r3, [r3, #CamEntriesPointer]
        MOV     r4, r0                          ; r4 is where we're at in allocating spare logical addresses
        LDR     r9, NumEntries                  ; number of entries still to do in 1st loop

; Now before we start, we must construct the second page block, with replacement page numbers

;        DLINE   "Start of 1st loop"
        FastCDA_ProfStart FindSpare, r6, r1, lr

20
        LDR     r6, [r8], #12                   ; r6 = page number required
        LDR     r10, [r8, #8-12]                ; r10 = phys addr

        ; r0 = End of area being removed from src (DANode_PMP+DANode_PMPSize*4)
        ; r1 = Spare
        ; r2 = Start of area being removed from src (DANode_PMP+(DANode_PMPSize-NumEntries)*4)
        ; r3 = CAM
        ; r4 = Where to look next for a replacement page (counts down, == r0)
        ; r5 = PageSize
        ; r6 = Required page number
        ; r7 = Spare
        ; r8 = PageBlock1
        ; r9 = NumEntries
        ; r10 = Required page phys addr
        ; r11 = Src DANode
        ; r12 = Dest DANode

        ; If the required page is in a PMP, then it might not be mapped in and
        ; any logical address checks we perform will be nonsensical.
        ; Considering that the only possible source area is the free pool, the
        ; rules for required pages are:
        ; * If it's not a member of a PMP, we need to find a replacement page
        ; * If it's a different PMP to the src DA, we need to find a replacement page
        ; * If it's the same PMP as the src DA, then we can take the page without looking for a replacement
        ADD     lr, r3, r6, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIB   lr, {r1, r7, lr}
        TST     r1, #DynAreaFlags_PMP
        BEQ     %FT63                           ; Not a PMP, look for a replacement
        TEQ     r7, r11
        BNE     %FT63                           ; Different PMP/DA, look for a replacement
        ; Page is being taken from src PMP, so assume src is free pool and so no replacement needed
        ; However we need to make sure we don't introduce any gaps in the free pool page list - so if this page isn't within the range of pages being removed, we need to look for a replacement still
        LDR     r1, [r7, #DANode_PMP]
        ADD     r1, r1, lr, LSL #2

;        DREG    r6, "Checking page ", cc
;        DREG    r1, "at address "

        CMP     r1, r2                          ; check if address is one being taken from src anyway
        BCC     %FT63
        CMP     r1, r0
        BCS     %FT63

;        DLINE   "Page is being taken away anyway"
        B       %FT68                           ; [page is being taken anyway, so use same page number + phys addr in 2nd block]

; page is not one being taken away, so put in 1st replacement page that isn't required by area

63
;        DLINE   "Page is not being taken, looking for replacement"

64
        LDR     r6, [r4, #-4]!                  ; get next page being taken from src
;        DREG    r6, "Considering page "

        ADD     r1, r3, r6, LSL #CAM_EntrySizeLog2 ; r1 -> cam entry for this page
        LDR     r1, [r1, #CAM_PageFlags]        ; get PPL for this page
        TST     r1, #PageFlags_Required         ; if this page is required for the operation
        BNE     %BT64                           ; then try next page

        Push    "r3,r5,r9"
        MOV     r3, r6
        BL      ppn_to_physical
        MOV     r10, r5
        Pull    "r3,r5,r9"

;        DREG    r6, "Using page number "
68
        STR     r6, [r8, #PageBlockSize-12]     ; store page number in 2nd block
        STR     r10, [r8, #PageBlockSize+8-12]  ; and store phys addr

        SUBS    r9, r9, #1                      ; one less entry to do
        BNE     %BT20
        FastCDA_ProfEnd FindSpare, r7, r1, lr

        MOV     r7, r3                          ; r7 -> camentries

; Now we can go onto the 2nd loop which actually moves the pages

     [ FastCDA_FIQs
        ; Claim FIQs for this entire loop
        ; (With the old behaviour, for large grows, total time in ReleaseFIQ could be several centiseconds, since the kernel reinstalls the default handler each time)
        FastCDA_ProfStart ClaimFIQ, r6, r1, lr
        MOV     r1, #Service_ClaimFIQ
        BL      Issue_Service
        FastCDA_ProfEnd ClaimFIQ, r6, r1, lr
     ]

        LDR     r1, DestAddr
        MOV     r4, #0                          ; amount done
        MOV     r0, r7                          ; point r0 at camentries
        LDR     r7, TotalAmount                 ; amount to do
        ADR     r8, PageBlock1
        LDR     r9, Offset1To2
70
        MRS     r14, CPSR
        STR     r14, SavedPSR                   ; save old PSR (note: stack must be flat when we do this!)

        ; Grab the flags for the page we're replacing; in order to preserve the contents of the page we may map it to its destination early, causing the flags in the CAM map to be "wrong" when we read them back out later on
        LDR     r11, [r8, #0]                   ; need to get PPL for page being replaced
        ADD     lr, r0, #CAM_PageFlags          ; point at PPLs, not addresses
        LDR     r11, [lr, r11, LSL #CAM_EntrySizeLog2]
        MOV     lr, #1
        STRB    lr, NeedToMoveFlag

        Push    "r0-r4,r7-r12"                  ; save regs used during copy
    [ :LNOT: FastCDA_FIQs
        FastCDA_ProfStart ClaimFIQ, r6, r1, lr
        MOV     r1, #Service_ClaimFIQ
        BL      Issue_Service
        FastCDA_ProfEnd ClaimFIQ, r6, r1, lr
    ]

        WritePSRc I_bit+SVC_mode, r6            ; disable IRQs round here (we don't want interrupt code to update
                                                ; the old mapping behind us while we're trying to copy it)

        LDR     lr, [r8, #PageBlockSize+0]      ; lr = page number of replacement page

        ; The replacement page will be a member of the free pool PMP - remove it
        ; from the PMP now, before any CAM updates make it hard to get access
        ; to the original page flags
        LDR     r11, =ZeroPage+FreePoolDANode
        ADD     r4, r0, lr, LSL #CAM_EntrySizeLog2
        LDR     r2, [r11, #DANode_PMP]
        LDR     r6, [r4, #CAM_PMPIndex]!
        MOV     r3, #-1
        STR     r3, [r2, r6, LSL #2]
        ; If the required page is a member of a PMP, update its PMP to point to
        ; the replacement page (and update the CAM for the replacement)
        LDR     r6, [r8, #0]
        TEQ     r6, lr
        BEQ     %FT72                           ; Required == replacement, leave unassociated
        ADD     r6, r0, r6, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIB   r6, {r2, r3, r6}
        TST     r2, #DynAreaFlags_PMP
        BEQ     %FT72
        STMDA   r4, {r3, r6}                    ; Update CAM for replacement to point to PMP of required page
        LDR     r4, [r3, #DANode_PMP]
        STR     lr, [r4, r6, LSL #2]            ; And update PMP of required page to point to replacement
72

        LDR     r6, [r8, #0]                    ; r6 = page number required
        TEQ     r6, lr                          ; if the same
        Pull    "r0-r4,r7-r12", EQ              ; then restore registers
        BEQ     %FT86                           ; and skip copy and first page move

        ;mjs
        ; - if the old page is currently mapped in, copy normally
        ; - if the old page is not mapped in, copy via temporary mapping
        ; The old scheme, always copying from other mapping, had interrupt cache coherency hole, at least for
        ; ARM with writeback cache (bug in 3.7, fixed in Ursula, then lost)

        LDR     r6, [r8, #4]                    ;logical address of src page

        ; If the required page is in the free pool, we don't need to preserve its contents
        ; TODO - have 'volatile' page flag which can be used to indicate that pages can just be taken? (so will work with any PMP)
        TST     r2, #DynAreaFlags_PMP
        BEQ     %FT73
        CMP     r3, r11
        BEQ     %FT84
73

        LDR     r2, =Nowhere

        ; If the required page isn't mapped in, see if we can map it in at the
        ; target address so that we can copy the contents out. If this fails
        ; we'll fall back to using a temporary mapping via AccessPhysicalAddress
        TEQ     r6, r2
        BNE     %FT75                           ; Source is mapped in, everything is fine
        LDR     r3, [sp, #4]                    ; Get stacked r1 (DestAddr)
        LDR     r11, [sp, #11*4+:INDEX:DestFlags]
        TEQ     r3, r2
        BEQ     %FT75                           ; Dest is Nowhere - must use temp mapping
        LDR     r2, [r8, #0]
        FastCDA_ProfStart MoveNeeded, lr, r4, r7
        BL      Call_CAM_Mapping                ; move needed page to destination
        FastCDA_ProfEnd MoveNeeded, lr, r4, r7
        MOV     r6, r3                          ; r6 = logical address of src for copy
        MOV     lr, #0
        LDR     r2, =Nowhere
        STRB    lr, [sp, #11*4+:INDEX:NeedToMoveFlag] ; Flag that page has been moved
75

        MOV     lr, #-1
        Push    "lr"                            ; Push dummy oldp flag for ReleasePhysicalAddress

        ; With the only source of replacement pages being the free pool, we only have two situations to deal with:
        ; * Source mapped, dest unmapped
        ; * Source unmapped, dest unmapped
        ; (where 'source' = copy source, i.e. required page, and 'dest' = copy dest, i.e. replacement page)
        TEQ     r6, r2
        BEQ     ReplacePage_BothUnmapped
        ; Fall through to DestUnmapped

ReplacePage_DestUnmapped
        Push    "r1"
        FastCDA_ProfStart AccessPhysical, r2, r1, lr
        MOV     r0, #L1_B
        LDR     r1, [r8, #PageBlockSize+8]      ; r1 = physical address of dest for copy
        ADD     r2, sp, #4
        BL      RISCOS_AccessPhysicalAddress
        ; r0 = logical address of dest for copy
        FastCDA_ProfEnd AccessPhysical, r2, r1, lr
        Pull    "r1"
        B       ReplacePage_BothMapped

ReplacePage_BothUnmapped
        ; We need to make temp mappings of both pages, but we only have one
        ; PhysicalAccess window. For now, take the easy way out and copy via
        ; a temporary buffer - it'll be a bit slower but since we only move
        ; one page at a time the cache should swallow most of the hit.
        ; Since OS_ChangeDynamicArea can't be used from an IRQ routine, we can
        ; assume that the IRQ stack has enough spare space - so use that rather
        ; than the SVC stack
        Push    "r0,r1"
        FastCDA_ProfStart AccessPhysical, r0, r1, lr
        MOV     r0, #L1_B
        LDR     r1, [r8, #8]                    ; r1 = physical address of src for copy
        ADD     r2, sp, #8
        BL      RISCOS_AccessPhysicalAddress
        MOV     r6, r0                          ; r6 = logical address of src for copy
        FastCDA_ProfEnd AccessPhysical, r0, r1, lr

        ; Copy to IRQ stack
        MSR     CPSR_c, #IRQ32_mode+I32_bit
        Push    "lr"
        SUB     sp, sp, r5
        MOV     r0, sp
        FastCDA_ProfStart CopyPage, r2, r3, r4
        ADD     lr, r6, r5                      ; lr = end src address
77
        LDMIA   r6!, {r2, r3, r4, r7, r9, r10, r11, r12}
        STMIA   r0!, {r2, r3, r4, r7, r9, r10, r11, r12}
        TEQ     r6, lr
        BNE     %BT77
        FastCDA_ProfEnd CopyPage, r2, r3, r4

        ; Now map in dest
        MOV     r0, #L1_B
        LDR     r1, [r8, #PageBlockSize+8]      ; r1 = physical address of src for copy
        MOV     r2, #0                          ; no oldp needed
        BL      RISCOS_AccessPhysicalAddress
        ; r0 = logical address of dest for copy
        MOV     r6, sp
        FastCDA_ProfStart CopyPage, r2, r3, r4
        ADD     lr, r6, r5                      ; lr = end src address
78
        LDMIA   r6!, {r2, r3, r4, r7, r9, r10, r11, r12}
        STMIA   r0!, {r2, r3, r4, r7, r9, r10, r11, r12}
        TEQ     r6, lr
        BNE     %BT78
        FastCDA_ProfEnd CopyPage, r2, r3, r4
        ; Switch back to SVC and clean up the temp mapping
        ADD     sp, sp, r5
        Pull    "lr"
        MSR     CPSR_c, #SVC32_mode+I32_bit
        Pull    "r0,r1"
        B       ReplacePage_Done

 [ {FALSE}
ReplacePage_SrcUnmapped
        Push    "r0,r1"
        FastCDA_ProfStart AccessPhysical, r0, r1, lr
        MOV     r0, #L1_B
        LDR     r1, [r8, #8]                    ; r1 = physical address of src for copy
        ADD     r2, sp, #8
        BL      RISCOS_AccessPhysicalAddress
        MOV     r6, r0                          ; r6 = logical address of src for copy
        FastCDA_ProfEnd AccessPhysical, r0, r1, lr
        Pull    "r0,r1"
 ]

ReplacePage_BothMapped
        FastCDA_ProfStart CopyPage, r2, r3, r4
        ADD     lr, r6, r5                      ; lr = end src address
79
        LDMIA   r6!, {r2, r3, r4, r7, r9, r10, r11, r12}
        STMIA   r0!, {r2, r3, r4, r7, r9, r10, r11, r12}
        TEQ     r6, lr
        BNE     %BT79

        FastCDA_ProfEnd CopyPage, r2, r3, r4

ReplacePage_Done
        ; Release the temp mapping if necessary
        Pull    "r0"
        CMP     r0, #-1
      [ FastCDA_Prof
        BEQ     %FT80
        FastCDA_ProfStart ReleasePhysical, r2, r3, r4
      ]
        BLNE    RISCOS_ReleasePhysicalAddress
      [ FastCDA_Prof
        FastCDA_ProfEnd ReleasePhysical, r2, r3, r4
80
      ]

; now check if page we're replacing is in L2PT, and if so then adjust L1PT entries (4 of these)

        LDR     r2, =L2PT
        LDR     r6, [r8, #4]                    ; look at logical address of page being replaced
        SUBS    r6, r6, r2
        BCC     %FT84                           ; address is below L2PT
        CMP     r6, #4*1024*1024
        BCS     %FT84                           ; address is above L2PT

        LDR     r2, =L1PT
        ADD     r2, r2, r6, LSR #(12-4)         ; address in L1 of 4 consecutive words to update
        LDR     r3, [r2]                        ; load 1st word, to get AP etc bits
        MOV     r3, r3, LSL #(31-9)             ; junk other bits
        LDR     r4, [r8, #PageBlockSize+8]      ; load new physical address for page
        ORR     r3, r4, r3, LSR #(31-9)         ; and merge with AP etc bits
        STR     r3, [r2], #4
        ADD     r3, r3, #&400
        STR     r3, [r2], #4
        ADD     r3, r3, #&400
        STR     r3, [r2], #4
        ADD     r3, r3, #&400
        STR     r3, [r2], #4
      [ MEMM_Type = "VMSAv6"
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncached,,,r3
      ]

84
        Pull    "r0-r4,r7-r12"                  ; restore registers

        ; mjs
        ; OK, what we are about to do is:
        ;   1) move replacement page in (to replace needed page)
        ;   2) move needed page to required destination
        ; This order means that we don't leave a temporary hole at the logical address we're substituting,
        ; which is vital at least in the horrendous case where the logical page is itself used for L2PT.
        ; However, this means there is a potential temporary degeneracy in the caches, two physical pages
        ; having been seen at the same logical address (undefined behaviour).
        ; So, to be safe, we do a MMUChangingEntry first, for the logical page, which will clean/invalidate
        ; caches and invalidate TLBs, to avoid degeneracy. This is slight overkill in some cases, but vital
        ; to avoid serious grief in the awkward cases. Fortunately, these page substitutions are relatively
        ; rare, so performance is not critical.

        BIC     r11, r11, #PageFlags_Required   ; knock off bits that indicate that it was a required page

        ADD     lr, r8, #PageBlockSize
        LDMIA   lr, {r2, r3}                    ; get page number, logical address
        
        LDR     lr, =Nowhere                    ; No need to clean if the page isn't mapped in
        TEQ     r3, lr
        BEQ     %FT85
      [ FastCDA_Unnecessary
        ; We only need to clean the cache/TLB if the page is cacheable
        TST     r11, #DynAreaFlags_NotCacheable
        BNE     %FT85
      ]        
        Push    "r0-r2, r4, r11"
        LDR     r4, =ZeroPage
      [ FastCDA_Prof
        FastCDA_ProfStart ChangingEntry, r6, lr, r4
      ]
        ; Use BangCam to remove the cacheability on the needed page
        LDR     r2, [r8, #0] ; Get page number of needed page
        ORR     r11, r11, #1<<TempUncacheableShift ; Make temp uncache
        BL      Call_CAM_Mapping ; This will flush the TLB for us, but won't flush the cache
        ; So now we flush the cache manually
        MOV     r0, r3
        ADD     r1, r3, #4096
        ARMop   Cache_CleanInvalidateRange,,,r4
      [ FastCDA_Prof
        FastCDA_ProfEnd ChangingEntry, r6, lr, r4
      ]
        Pull    "r0-r2, r4, r11"
85

        FastCDA_ProfStart MoveReplacement, r6, lr, r5
        BL      Call_CAM_Mapping                ; move replacement page in
        FastCDA_ProfEnd MoveReplacement, r6, lr, r5
86
        LDR     r2, [r8, #0]
        MOV     r3, r1
        LDR     r11, DestFlags
        LDRB    lr, NeedToMoveFlag
        TEQ     lr, #0
        BEQ     %FT87                           ; don't bother if page already been moved to dest
        FastCDA_ProfStart MoveNeeded, r6, lr, r5
        BL      Call_CAM_Mapping                ; move needed page to destination
        FastCDA_ProfEnd MoveNeeded, r6, lr, r5

87
        LDR     lr, SavedPSR
        MSR     CPSR_cf, lr

      [ :LNOT: FastCDA_FIQs
        Push    "r1"
        FastCDA_ProfStart ReleaseFIQ, r1, lr, r5
        MOV     r1, #Service_ReleaseFIQ
        BL      Issue_Service
        FastCDA_ProfEnd ReleaseFIQ, r1, lr, r5
        Pull    "r1"
      ]
      [ FastCDA_Prof
        MOV     r5, #4096
      ]

        ADD     r1, r1, r5                      ; advance dest ptr
        ADD     r4, r4, r5                      ; increment amount done
        ADD     r8, r8, #12                     ; advance page block ptr
        CMP     r4, r7                          ; have we done all?
        BNE     %BT70                           ; [no, so loop]

     [ FastCDA_FIQs
        FastCDA_ProfStart ReleaseFIQ, r1, lr, r2
        MOV     r1, #Service_ReleaseFIQ
        BL      Issue_Service
        FastCDA_ProfEnd ReleaseFIQ, r1, lr, r2
     ]

        LDR     r3, [r12, #DANode_Size]
        ADD     r3, r3, r7
        STR     r3, [r12, #DANode_Size]         ; store increased destination size
      [ ZeroPage = 0
        TEQ     r12, #AppSpaceDANode            ; check if dest = appspace
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r12, lr                         ; check if dest = appspace
      ]
        STREQ   r3, [r12, #MemLimit-AppSpaceDANode] ; update memlimit if so

; now issue Service_PagesSafe

        FastCDA_ProfStart PagesSafe, r1, r2, r3
        LDR     r2, NumEntries
        ADR     r3, PageBlock1
        ADR     r4, PageBlock2
        MOV     r1, #Service_PagesSafe
        BL      Issue_Service
        FastCDA_ProfEnd PagesSafe, r1, r2, r3

; now call Post_Grow handler

        LDR     r3, TotalAmount                 ; size of grow
        LDR     r2, NumEntries                  ; restore number of entries in page block
        ADR     r1, PageBlock1                  ; point at page block 1 with page numbers filled in
        BL      CallPostGrow
        CLRV
        EXIT

        LTORG

; ***********************************************************************************
;
;       DoTheGrowNotSpecified - Do one chunk of growing, with no page block
;                               But don't call pre-grow or post-grow either
;
; in:   r2 = number of pages to do (in this chunk)
;       r5 = page size
;       r7 = amount taking from src area (in this chunk)
;       r11 -> src area
;       r12 -> dest area
;
; out:  r0-r2,r4,r6-r9 may be corrupted
;       r3,r5,r10-r12 preserved
;
; Note: Removal is from one area only, the calling routine breaks the chunk at free/app boundary.


DoTheGrowNotSpecified ROUT
        Entry   "r3"
        MOV     r3, #0                          ; no dest page list
        MOV     r2, r7                          ; amount moving
        BL      DoTheGrowCommon                 ; Move all the pages around
        CLRV
        EXIT

; ***********************************************************************************
;
;       CheckAppSpace - If appspace involved in transfer, issue Service or UpCall
;
;       Internal routine, called by OS_ChangeDynamicArea
;
; in:   r0 = area number passed in to ChangeDyn
;       r10 = size of change (signed)
;       r11 -> node for src
;       r12 -> node for dest
;
; out:  If appspace not involved, or application said it was OK, then
;         V=0
;         All registers preserved
;       else
;         V=1
;         r0 -> error
;         All other registers preserved
;       endif
;

CheckAppSpace ROUT
        Entry "r0-r3"
        LDR     r2, =ZeroPage
        LDR     r3, [r2, #AplWorkSize]
        LDR     r2, [r2, #Curr_Active_Object]
        CMP     r2, r3                          ; check if CAO outside application space
        BHI     %FT20                           ; [it is so issue Service not UpCall]

; CAO in application space, so issue UpCall to check it's OK

        MOV     r0, #UpCall_MovingMemory :AND: &FF
        ORR     r0, r0, #UpCall_MovingMemory :AND: &FFFFFF00
        MOVS    r1, r10
        RSBMI   r1, r1, #0                      ; r1 passed in is always +ve (probably a bug, but should be compat.)

        SWI     XOS_UpCall
        CMP     r0, #UpCall_Claimed             ; if upcall claimed
        EXIT    EQ                              ; then OK to move memory, so exit (V=0 from CMP)

05
        ADR     r0, ErrorBlock_ChDynamCAO
10
 [ International
        BL      TranslateError
 |
        SETV
 ]
        STR     r0, [sp]
        EXIT

; IF service call claimed Then Error AplWSpaceInUse

20
        MOV     r0, r10                         ; amount removing from aplspace
        MOV     r1, #Service_Memory
        BL      Issue_Service
        CMP     r1, #Service_Serviced
        ADREQ   r0, ErrorBlock_AplWSpaceInUse   ; if service claimed, then return error
        BEQ     %BT10
        CLRV                                    ; else OK
        EXIT

        MakeErrorBlock AplWSpaceInUse
        MakeErrorBlock ChDynamCAO

; ***********************************************************************************
;
;       CallPreShrink - Call pre-shrink routine
;
; in:   r1 = amount shrinking by (+ve)
;       r5 = page size
;       r11 -> node for area being shrunk
;
; out:  If handler exits VC, then r2 = no. of bytes area can shrink by
;       else r0 -> error block or 0 for generic error, and r2=0
;

CallPreShrink Entry "r0,r3,r4, r12"
        LDR     r0, [r11, #DANode_Handler]              ; check if no handler
        CMP     r0, #0                                  ; if none (V=0)
        EXIT    EQ                                      ; then exit

        MOV     r0, #DAHandler_PreShrink                ; r0 = reason code
        MOV     r3, r1                                  ; r3 = amount shrinking by
        LDR     r4, [r11, #DANode_Size]                 ; r4 = current size
        ASSERT  DANode_Handler = DANode_Workspace +4
        ADD     r12, r11, #DANode_Workspace
        MOV     lr, pc
        LDMIA   r12, {r12, pc}                          ; load workspace pointer and jump to handler

; shrink amount returned by handler may not be page multiple (according to spec),
; so we'd better make it so.

        SUB     lr, r5, #1
        BIC     r2, r3, lr                              ; make page multiple and move into r2
        EXIT    VC
        TEQ     r0, #0                                  ; if generic error returned
        ADREQL  r0, ErrorBlock_ChDynamNotAllMoved       ; then substitute real error message
 [ International
        BLEQ    TranslateError
 ]
        STR     r0, [sp]
        EXIT

; ***********************************************************************************
;
;       CallPostShrink - Call post-shrink routine
;
; in:   r2 = amount shrinking by (+ve)
;       r5 = page size
;       r11 -> node for area being shrunk
;
; out:  All registers preserved
;

CallPostShrink Entry "r0,r3,r4, r12"
        LDR     r0, [r11, #DANode_Handler]              ; check if no handler
        CMP     r0, #0                                  ; if none (V=0)
        EXIT    EQ                                      ; then exit

        MOV     r0, #DAHandler_PostShrink               ; r0 = reason code
        MOV     r3, r2                                  ; r3 = amount shrunk by
        LDR     r4, [r11, #DANode_Size]                 ; r4 = new size
        ASSERT  DANode_Handler = DANode_Workspace +4
        ADD     r12, r11, #DANode_Workspace
        MOV     lr, pc
        LDMIA   r12, {r12, pc}                          ; load workspace pointer and jump to handler

        EXIT

; ***********************************************************************************
;
;       CallPreGrow - Call pre-grow routine
;
; in:   Eventually r1 -> page block (on stack)
;                  r2 = number of entries in block
;       but for now these are both undefined
;       r3 = amount area is growing by
;       r5 = page size
;       r12 -> node for area being grown
;
; out:  If can't grow, then
;         r0 -> error
;         V=1
;       else
;         page block may be updated with page numbers (but not yet!)
;         All registers preserved
;         V=0
;       endif
;

CallPreGrow ROUT
        Entry   "r0,r4, r12"
        LDR     r0, [r12, #DANode_Flags]
        TST     r0, #DynAreaFlags_NeedsDMA              ; if DMA needed
        BNE     %FT10                                   ; use special PreGrow

        LDR     r0, [r12, #DANode_Handler]              ; check if no handler
        CMP     r0, #0                                  ; if none (V=0)
        EXIT    EQ                                      ; then exit

        FastCDA_ProfStart CallPreGrow, r0, r4, lr
        MOV     r0, #DAHandler_PreGrow                  ; r0 = reason code
        LDR     r4, [r12, #DANode_Size]                 ; r4 = current size
        ASSERT  DANode_Handler = DANode_Workspace +4
        ADD     r12, r12, #DANode_Workspace
        MOV     lr, pc
        LDMIA   r12, {r12, pc}                          ; load workspace pointer and jump to handler
        FastCDA_ProfEnd CallPreGrow, r12, r4, lr
        EXIT    VC                                      ; if no error then exit

05
        TEQ     r0, #0                                  ; if generic error returned (V still set)
        ADREQL  r0, ErrorBlock_ChDynamNotAllMoved       ; then substitute real error message
 [ International
        BLEQ    TranslateError
 ]
        STR     r0, [sp]
        EXIT

10
        ; Instead of calling the users PreGrow handler, walk PhysRamTable and
        ; the CAM map to look for some free DMAable pages
        ; Note that we don't guarantee physical contiguity - if you want that,
        ; just use OS_Memory 12 or PCI_RAMAlloc instead
        Push    "r1-r3"
        LDR     r0,=ZeroPage+PhysRamTable+4
        MOV     r2,#0                    ; current page number
        LDR     r4,=ZeroPage+CamEntriesPointer
        LDR     r4,[r4]
        ADD     r4,r4,#CAM_PageFlags     ; -> base of PPLs
        LDR     r12,[r0],#8              ; get video chunk flags
20
        ADD     r2,r2,r12,LSR #12        ; advance page number
21
        LDR     r12,[r0],#8              ; get next chunk details
        CMP     r12,#0
        BEQ     %FT90
        TST     r12,#OSAddRAM_NoDMA
        BNE     %BT20
        ; Check the CAM map to see if any pages here are free
        MOV     r12,r12,LSR #12
30
        LDR     lr,[r4,r2,LSL #CAM_EntrySizeLog2]
        TST     lr,#PageFlags_Unavailable :OR: PageFlags_Required
        STREQ   r2,[r1],#12
        SUBEQS  r3,r3,#4096
        BEQ     %FT80
        SUBS    r12,r12,#1
        ADD     r2,r2,#1
        BNE     %BT30
        B       %BT21
80
        ; Success
        CLRV
        Pull    "r1-r3"
        EXIT
90
        ; Failure
        SETV
        Pull    "r1-r3"
        MOV     r0,#0                
        B       %BT05


; ***********************************************************************************
;
;       CallPostGrow - Call post-grow routine
;
; in:   Eventually, r1 -> page block with actual pages put in
;                   r2 = number of entries in block
;       r3 = size of change
;       r5 = page size
;       r12 -> node for area being grown
;
; out:  All registers preserved
;

CallPostGrow Entry "r0,r3,r4, r12"
        LDR     r0, [r12, #DANode_Handler]              ; check if no handler
        CMP     r0, #0                                  ; if none (V=0)
        EXIT    EQ                                      ; then exit

        FastCDA_ProfStart CallPostGrow, r0, r4, lr
        MOV     r0, #DAHandler_PostGrow                 ; r0 = reason code
        LDR     r4, [r12, #DANode_Size]                 ; r4 = new size
        ASSERT  DANode_Handler = DANode_Workspace +4
        ADD     r12, r12, #DANode_Workspace
        MOV     lr, pc
        LDMIA   r12, {r12, pc}                          ; load workspace pointer and jump to handler
        FastCDA_ProfEnd CallPostGrow, r12, r4, lr
        EXIT

 [ ShrinkableDAs
; ***********************************************************************************
;
;       CallTestShrink - Call test-shrink routine
;
; in:   r11 -> area node
;
; out:  If handler exits VC, then r3 = no. of bytes area can shrink by
;       else r0 -> error block or 0 for generic error, and r3=0
;

CallTestShrink Entry "r0,r4,r5, r12"
        LDR     r0, [r11, #DANode_Handler]              ; check if no handler
        CMP     r0, #0                                  ; if none (V=0)
        EXIT    EQ                                      ; then exit

        MOV     r0, #DAHandler_TestShrink               ; r0 = reason code
        LDR     r4, [r11, #DANode_Size]                 ; r4 = current size
        LDR     r5, =ZeroPage
        LDR     r5, [r5, #Page_Size]                    ; set r5 = page size
        ASSERT  DANode_Handler = DANode_Workspace +4
        ADD     r12, r11, #DANode_Workspace
        MOV     lr, pc
        LDMIA   r12, {r12, pc}                          ; load workspace pointer and jump to handler

; shrink amount returned by handler may not be page multiple (according to spec),
; so we'd better make it so.

        SUBVC   lr, r5, #1
        BICVC   r3, r3, lr                              ; make page multiple
        EXIT    VC
        TEQ     r0, #0                                  ; if generic error returned (V still set)
        ADREQL  r0, ErrorBlock_ChDynamNotAllMoved       ; then substitute real error message
 [ International
        BLEQ    TranslateError
 ]
        STR     r0, [sp]
        MOV     r3, #0                                  ; indicate no shrink possible
        SETV
        EXIT
 ]

; ***********************************************************************************
;
;       DynAreaHandler_SysHeap - Dynamic area handler for system heap
;       DynAreaHandler_RMA     - Dynamic area handler for RMA
;
; in:   r0 = reason code (0=>pre-grow, 1=>post-grow, 2=>pre-shrink, 3=>post-shrink)
;       r12 -> base of area
;

DynAreaHandler_SysHeap
DynAreaHandler_RMA ROUT
        CMP     r0, #4
        ADDCC   pc, pc, r0, LSL #2
        B       UnknownHandlerError
        B       PreGrow_Heap
        B       PostGrow_Heap
        B       PreShrink_Heap
        B       PostShrink_Heap

PostGrow_Heap
PostShrink_Heap
        STR     r4, [r12, #:INDEX:hpdend] ; store new size

; and drop thru to...

PreGrow_Heap
        CLRV                            ; don't need to do anything here
        MOV     pc, lr                  ; so just exit

PreShrink_Heap
        Push    "r0, lr"
        PHPSEI                          ; disable IRQs round this bit
        LDR     r0, [r12, #:INDEX:hpdbase]      ; get minimum size
        SUB     r0, r4, r0              ; r0 = current-minimum = max shrink
        CMP     r3, r0                  ; if requested shrink > max
        MOVHI   r3, r0                  ; then limit it
        SUB     r0, r5, #1              ; r0 = page mask
        BIC     r3, r3, r0              ; round size change down to page multiple
        SUB     r0, r4, r3              ; area size after shrink
        STR     r0, [r12, #:INDEX:hpdend] ; update size

        PLP                             ; restore IRQ status
        CLRV
        Pull    "r0, pc"

AreaName_RMA
        =       "Module area", 0
        ALIGN


UnknownHandlerError
        Push    "lr"
        ADRL    r0, ErrorBlock_UnknownAreaHandler
  [ International
        BL      TranslateError
  |
        SETV
  ]
        Pull    "pc"

DynAreaHandler_Sprites
        CMP     r0, #4
        ADDCC   pc, pc, r0, LSL #2
        B       UnknownHandlerError
        B       PreGrow_Sprite
        B       PostGrow_Sprite
        B       PreShrink_Sprite
        B       PostShrink_Sprite

PostGrow_Sprite
PostShrink_Sprite Entry "r0"

; in - r3 = size change (+ve), r4 = new size, r5 = page size

        LDR     lr, =ZeroPage+VduDriverWorkSpace
        TEQ     r4, #0                  ; if new size = 0
        STREQ   r4, [lr, #SpAreaStart]  ; then set area ptr to zero
        STRNE   r12, [lr, #SpAreaStart] ; else store base address

        LDR     r0, =ZeroPage
        LDR     lr, [r0, #SpriteSize]   ; load old size
        STR     r4, [r0, #SpriteSize]   ; and store new size
        BEQ     %FT10                   ; if new size is zero, don't try to update header

        STR     r4, [r12, #saEnd]       ; store new size in header
        TEQ     lr, #0                  ; if old size was zero
        STREQ   lr, [r12, #saNumber]    ; then initialise header (no. of sprites = 0)
        MOVEQ   lr, #saExten
        STREQ   lr, [r12, #saFirst]     ; ptr to first sprite -> after header
        STREQ   lr, [r12, #saFree]      ; ptr to first free byte -> after header

10
        CLRV                            ; don't need to do anything here
        EXIT                            ; so just exit

PreGrow_Sprite
        CLRV                            ; don't need to do anything here
        MOV     pc, lr                  ; so just exit

PreShrink_Sprite Entry "r0"
        TEQ     r4, #0                  ; if current size is zero
        BEQ     %FT10                   ; then any shrink is OK (shouldn't happen)

        LDR     r0, [r12, #saFree]      ; get used amount
        TEQ     r0, #saExten            ; if only header used,
        MOVEQ   r0, #0                  ; then none really in use

        SUB     r0, r4, r0              ; r0 = current-minimum = max shrink
        CMP     r3, r0                  ; if requested shrink > max
        MOVHI   r3, r0                  ; then limit it
        SUB     r0, r5, #1              ; r0 = page mask
        BIC     r3, r3, r0              ; round size change down to page multiple
10
        CLRV
        EXIT

AreaName_SpriteArea
        =       "System sprites", 0
        ALIGN


DynAreaHandler_RAMDisc ROUT
 [ PMPRAMFS
        CMP     r0, #DAHandler_ResizePMP
        BNE     UnknownHandlerError
        ; r1 = change amount (pages)
        ; r2 = DA number
        Entry   "r2-r11"
        MOV     r10, r1
        MOV     r11, r2
        ; Get current size
        MOV     r0, #DAReason_PMP_GetInfo
        MOV     r1, r2
        SWI     XOS_DynamicArea
        ; R6 = current phys page count
        ; R7 = max size
        ; Check if resizing is allowed
        BLVC    PreGrow_RAMDisc
        EXIT    VS
        CMP     r10, #0
        BLT     RAMDisc_Shrink
        EXIT    EQ
        ; Claim empty space
        MOV     r0, #DAReason_PMP_Resize
      [ {TRUE}
        ; Limit max size to ~512MB - RAMFS currently can't cope with more than that
        RSB     r2, r6, #508<<(20-12)
        CMP     r10, r2
        MOVGT   r10, r2
      ]
        SUB     r2, r6, r7 ; Take into account any mismatch between current max and current page count
        ADDS    r2, r2, r10
        MOV     r9, r2
        SWINE   XOS_DynamicArea
        EXIT    VS
        ; R2 = actual change, use that from now on
        CMP     r9, #0
        ADDGE   r10, r7, r2 ; New PMPMaxSize
        SUBLT   r10, r7, r2 ; Take into account the fact the result is unsigned
        SUB     r10, r10, r6 ; Amount we need to change PMPSize
        ; Claim pages
        MOV     r7, #-2
        MOV     r9, #0
10
        SUBS    r10, r10, #1
        BLT     RAMDisc_PostOp
        Push    "r6,r7,r9"
        MOV     r0, #DAReason_PMP_PhysOp
        MOV     r2, sp
        MOV     r3, #1
        SWI     XOS_DynamicArea
        ADD     sp, sp, #12
        ADDVC   r6, r6, #1
        BVC     %BT10
        B       RAMDisc_PostOp
RAMDisc_Shrink
        ; Unmap all pages (RAMFS will unmap everything on reinit anyway)
        MOV     r0, #0
        MOV     r2, #-1
        MOV     r4, #0
        Push    "r0,r2,r4"
        MOV     r0, #DAReason_PMP_LogOp
15
        MOV     r2, sp
        MOV     r3, #1
        SWI     XOS_DynamicArea
        BVS     %FT16
        ADD     r4, r4, #1
        CMP     r4, #PMPRAMFS_Size
        STRLT   r4, [sp]
        BLT     %BT15
16
        ADD     sp, sp, #12
        ; Release pages
        MOV     r7, #-1
        MOV     r9, #0
        RSB     r10, r10, #0
20              
        SUBS    r10, r10, #1
        SUBGES  r6, r6, #1
        BLT     RAMDisc_PostShrink
        Push    "r6,r7,r9"
        MOV     r0, #DAReason_PMP_PhysOp
        MOV     r2, sp
        MOV     r3, #1
        SWI     XOS_DynamicArea
        ADD     sp, sp, #12
        BVC     %BT20
RAMDisc_PostShrink
        ; Release empty space so that things should stay in sync
        MRS     r2, CPSR
        Push    "r0,r2"
        MOV     r0, #DAReason_PMP_GetInfo
        SWI     XOS_DynamicArea
        BVS     %FT30
        SUBS    r2, r6, r7 ; Release all spare page entries
        MOV     r0, #DAReason_PMP_Resize
        SWINE   XOS_DynamicArea
30             
        Pull    "r0,r2"
        MSR     CPSR_f, r2
RAMDisc_PostOp
        ; Re-init if necessary
        MRS     r2, CPSR
        BL      PostGrow_RAMDisc
        MSR     CPSR_f, r2
        EXIT
        
 | ; PMPRAMFS
        CMP     r0, #4
        ADDCC   pc, pc, r0, LSL #2
        B       UnknownHandlerError
        B       PreGrow_RAMDisc
        B       PostGrow_RAMDisc
        B       PreShrink_RAMDisc
        B       PostShrink_RAMDisc
 ] ; PMPRAMFS

PostGrow_RAMDisc
PostShrink_RAMDisc Entry "r0-r6"

; in - r3 = size change (+ve), r4 = new size, r5 = page size
; but we don't really care about any of these

; The only thing we have to do here is ReInit RAMFS, but NOT if
; a) no modules are initialised yet (eg when we're created), or
; b) RAMFS has been unplugged

        LDR     r0, =ZeroPage
        LDR     r0, [r0, #Module_List]
        TEQ     r0, #0                  ; any modules yet?
        BEQ     %FT90                   ; no, then don't do anything

        MOV     r0, #ModHandReason_EnumerateROM_Modules
        MOV     r1, #0
        MOV     r2, #-1                 ; enumerate ROM modules looking for RAMFS
10
        SWI     XOS_Module
        BVS     %FT50                   ; no more modules, so it can't be unplugged
        ADR     r5, ramfsname
20
        LDRB    r6, [r3], #1            ; get char from returned module name
        CMP     r6, #" "                ; if a terminator then we have a match
        BLS     %FT30                   ; so check for unplugged
        LowerCase r6, lr                ; else force char to lower case
        LDRB    lr, [r5], #1            ; get char from "ramfs" string
        CMP     lr, r6                  ; and if matches
        BEQ     %BT20                   ; then try next char
        B       %BT10                   ; else try next module

30
        CMP     r4, #-1                 ; is module unplugged?
        BEQ     %FT90                   ; if so, then mustn't reinit it
50
        MOV     r0, #ModHandReason_ReInit ; reinit module
        ADR     r1, ramfsname
        SWI     XOS_Module              ; ignore any errors from this
90
        CLRV
        EXIT

PreGrow_RAMDisc
PreShrink_RAMDisc Entry "r0-r5"
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #Module_List]  ; first check if any modules going
        TEQ     r0, #0
        BEQ     %FT90                   ; if not, don't look at filing system

        MOV     r0, #5
        ADR     r1, ramcolondollardotstar
        SWI     XOS_File
        CMPVC   r0, #0
        BVS     %FT90                   ; if no RAMFS then change OK
        BEQ     %FT90                   ; or if no files, then change OK
        ADR     r0, ErrorBlock_RAMFsUnchangeable
 [ International
        BL      TranslateError
 |
        SETV
 ]
        STR     r0, [sp]
        EXIT

90
        CLRV
        EXIT

        MakeErrorBlock  RAMFsUnchangeable

AreaName_RAMDisc
        =       "RAM disc", 0
ramcolondollardotstar
        =       "ram:$.*", 0
ramfsname
        =       "ramfs", 0
        ALIGN


DynAreaHandler_FontArea
        CMP     r0, #4
        ADDCC   pc, pc, r0, LSL #2
        B       UnknownHandlerError
        B       PreGrow_FontArea
        B       PostGrow_FontArea
        B       PreShrink_FontArea
        B       PostShrink_FontArea

PostGrow_FontArea Entry "r0-r2"

; in - r3 = size change (+ve), r4 = new size, r5 = page size

        LDR     r1, =ZeroPage
        LDR     r1, [r1, #Module_List]  ; any modules active?
        TEQ     r1, #0
        MOVNE   r1, r4                  ; there are, so inform font manager of size change
        SWINE   XFont_ChangeArea
        CLRV
        EXIT

PostShrink_FontArea
PreGrow_FontArea
        CLRV                            ; don't need to do anything here
        MOV     pc, lr                  ; so just exit

PreShrink_FontArea Entry "r0-r2"
        MOV     r1, #-1                 ; ask font manager for minimum size of font area
        MOV     r2, #0                  ; default value if no font manager
        SWI     XFont_ChangeArea        ; out: r2 = minimum size

        SUB     r0, r4, r2              ; r0 = current-minimum = max shrink
        CMP     r3, r0                  ; if requested shrink > max
        MOVHI   r3, r0                  ; then limit it
        SUB     r0, r5, #1              ; r0 = page mask
        BIC     r3, r3, r0              ; round size change down to page multiple

        SUB     r1, r4, r3              ; r1 = new size
        SWI     XFont_ChangeArea        ; tell font manager to reduce usage

        CLRV
        EXIT

AreaName_FontArea
        =       "Font cache", 0
        ALIGN


; **** New screen stuff ****
;
;
; This source collects together all the new routines needed to make
; the screen into a new dynamic area.
;
; It has the following dependencies elsewhere in the kernel before
; it can be expected to work:
;
; * Definition of AP_Screen in ChangeDyn needs doubly_mapped and
;   name_is_token bits set
; * name_is_token handling needs adding (or scrap the bit designation)
; * Call to CreateNewScreenArea from NewReset to create area
; * Tim says doubly-mapped areas are broken - this must be fixed first
; * Old CDA routine may be retired, since screen is its last client
; * Has Tim completed the rest of this work?
;
; Once these routines work, they should be grafted into appropriate
; places in the kernel sources
;
; This source is not intended for stand-alone assembly: it should be
; plumbed into the kernel source build
;
; Version history - remove this once integrated with kernel sources
;
; Vsn  Date      Who  What
; ---  --------  ---  ----------------------------------------------
; 000  23/08/93  amg  Written
; 001  24/08/93  amg  Fixes and changes following review by TMD
; 002  03/09/93  tmd  Updated to work!

; *********************************************************************
; Create a new style dynamic area for the screen
; *********************************************************************

; Entry requirements
; none

AreaName_Screen
        =       "Screen memory",0               ;needs replacing with message token
        ALIGN

; *********************************************************************
; Handler despatch routine for screen dynamic area
; *********************************************************************

DynAreaHandler_Screen                           ;despatch routine for pre/post grow/shrink handlers
        CMP     r0, #4
        ADDCC   pc, pc, R0, LSL #2
        B       UnknownHandlerError             ;already defined in ChangeDyn
        B       PreGrow_Screen                  ;the rest are defined here
        B       PostGrow_Screen
        B       PreShrink_Screen
        B       PostShrink_Screen

;The sequence of events which these handlers must do is:
;
;Grow Screen
;
;Pre : Remove cursors
;      Work out which physical page numbers are needed and return a list
;CDA : Move existing pages lower in memory within first copy (ie change logical address
;        associated with physical pages)
;      Locate and free the next physical pages in line (if used a page swap must occur)
;      Assign the new pages logical addresses in the gap between the end of the present
;        logical range and the start of the second physical range
;Post: Adjust screen memory contents & screen start addresses to retain screen display
;
;Shrink Screen
;
;Pre : Remove cursors
;      Adjust screen memory contents & screen start addresses to retain screen display
;CDA : Move pages from screen to free pool (creates a gap in first logical range)
;      Close up the gap in logical addressing
;Post: Restore cursors
;

; ***********************************************************************************
; Handlers for the screen dynamic area
; ***********************************************************************************

;Pregrow entry parameters
; R0 = 0 (reason code)
; R1 -> page block (entries set to -1)
; R2 = number of entries in page block == number of pages area is growing by
; R3 = number of bytes area is growing by (r2 * pagesize)
; R4 = current size (bytes)
; R5 = page size
;
; exit with V clear, all preserved

PreGrow_Screen  Entry   "r0-r2,r4"
        LDR     r0, [WsPtr, #CursorFlags]       ; test if VDU inited yet
        LDRB    lr, [WsPtr, #ExternalFramestore]
        TEQ     r0, #0                          ; if not, CursorFlags will be zero
        BEQ     %FT05
        TEQ     lr, #0
        SWIEQ   XOS_RemoveCursors               ; if VDU inited, then remove cursors

05      ADRL    r0, PageShifts-1
        LDRB    r0, [r0, r5, LSR #12]           ; grab log2Pagesize for shifting
        MOV     r4, r4, LSR r0                  ; change present size into number of pages
                                                ; since page numbers are 0 to n-1 thus n
                                                ; is the first page number we want to insist on
10
        STR     r4, [r1], #12                   ; store physical page number and increment to next
        SUBS    r2, r2, #1                      ; one less to do
        ADDNE   r4, r4, #1                      ; next physical page number
        BNE     %BT10                           ; continue until all pages done
        CLRV                                    ; ok, so I'm paranoid...
        EXIT

; **********************************************************************

;PostGrow entry parameters
;R0 = 1 (reason code)
;R1 -> page block (only physical page numbers are meaningful)
;R2 = number of entries in page block (= number of pages area grew by)
;R3 = number of bytes area grew by
;R4 = new size of area (bytes)
;R5 = page size

PostGrow_Screen Entry   "r0,r5"
        LDR     r0, [WsPtr, #CursorFlags]       ; test if VDU inited (CursorFlags=0 => not)
        TEQ     r0, #0
        BEQ     %FT90                           ; if not inited, do nothing

        PHPSEI  r5                              ; disable IRQs

        MOV     r0, r3                          ; move number of bytes area grew by into r0
        BL      InsertPages                     ; only call InsertPages if VDU inited

        PLP     r5                              ; restore IRQ state
        SWI     XOS_RestoreCursors              ; and restore cursors
90
        CLRV
        EXIT

; ***********************************************************************

;PreShrink Entry parameters
;R0 = 2 (reason code)
;R3 = number of bytes area is shrinking by
;R4 = current size of area (bytes)
;R5 = page size
;R12 = vdu workspace

PreShrink_Screen Entry   "R0-R2,R4-R5"

        ;need to check whether the proposed shrink still leaves enough for
        ;the current amount needed by the vdu drivers, if it doesn't we
        ;reduce R3 to be the most we can spare (in whole pages)

        LDR     LR, =ZeroPage
        LDR     LR, [LR, #VideoSizeFlags]          ;is VRAM suitable for general use?
        TST     LR, #OSAddRAM_VRAMNotForGeneralUse ;if not - don't shrink screen memory
        MOVNE   R3, #0
        SUB     R2, R5, #1                      ;make a page mask

        LDRB    R14, [R12, #ExternalFramestore]
        TEQ     R14, #0                         ;okay to shrink if using external framestore
        BEQ     %FT12
        RSB     R0, R3, #0                      ;R0= -(number of bytes) for RemovePages
        BL      RemovePages
        CLRV
        EXIT

12      LDR     R5, [R12, #ScreenSize]          ;get current minimum size

        SUB     R1, R4, R5                      ;R1 = maximum shrink (current - screensize)
        CMP     R3, R1                          ;if requested shrink > max...
        MOVHI   R3, R1                          ;...then limit it, and...
        BICS    R3, R3, R2                      ;...round down to multiple of page size
        BEQ     %FT10                           ;don't shuffle screen data if resultant
                                                ;shrink is 0 bytes/0 pages
        SWI     XOS_RemoveCursors
        PHPSEI  R5                              ;disable interrupts
        RSB     R0, R3, #0                      ;R0= -(number of bytes) for RemovePages
        BL      RemovePages                     ;entry: R0 = -(number of bytes)
        PLP     R5                              ;restore interrupts
10
        CLRV
        EXIT

; ************************************************************************

;PostShrink Entry parameters
;R0 = 3 (reason code)
;R3 = number of bytes area shrank by
;R4 = new size of area (bytes)
;R5 = page size

PostShrink_Screen Entry
        SWI     XOS_RestoreCursors
        CLRV                                    ;ok, so I'm paranoid...
        EXIT

; ************************************************************************

        LTORG

      [ PMPParanoid
ValidatePMPs ROUT
        EntryS  "r0-r12"
        ; Validate PMPs against the CAM
        LDR     r0, =ZeroPage
        LDR     r1, [r0, #DAList]
        LDR     r2, [r0, #CamEntriesPointer]
        LDR     r3, [r0, #MaxCamEntry]
        MOV     lr, #0
10
        LDR     r4, [r1, #DANode_Flags]
        TST     r4, #DynAreaFlags_PMP
        BEQ     %FT25
        LDR     r5, [r1, #DANode_PMP]
        LDR     r6, [r1, #DANode_PMPSize]
        LDR     r7, [r1, #DANode_PMPMaxSize]
        LDR     r0, [r1, #DANode_Size]
        CMP     r6, r7
        BLHI    %FT90
15
        SUBS    r7, r7, #1
        BLO     %FT20
        LDR     r8, [r5, r7, LSL #2]
        CMP     r8, #-1
        BEQ     %BT15
        CMP     r8, r3
        BLHI    %FT90
        ADD     r9, r2, r8, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIA   r9, {r9-r12}
        TST     r10, #DynAreaFlags_PMP
        BLEQ    %FT90
        CMP     r11, r1
        CMPEQ   r12, r7
        BLNE    %FT90
        SUBS    r6, r6, #1
        BLLO    %FT90
        LDR     r10, =Nowhere
        CMP     r9, r10
        SUBNE   r0, r0, #4096
        B       %BT15
20
        CMP     r6, #0
        CMPEQ   r0, #0
        BLNE    %FT90
25
        CMP     lr, #0
        BNE     %FT26
        ; Iterate through regular DAs
        LDR     r1, [r1, #DANode_Link]
        CMP     r1, #0
        BNE     %BT10
        ; Iterate through AMBControl nodes
        LDR     r12, =ZeroPage+AMBControl_ws
        LDR     r12, [r12]
        CMP     r12, #0
        BEQ     %FT29
        ADR     lr, AMBAnchorNode
        ADD     r1, lr, #AMBNode_DANode
26
        LDR     r1, [r1, #AMBNode_next-AMBNode_DANode]
        CMP     r1, lr
        ADDNE   r1, r1, #AMBNode_DANode
        BNE     %BT10
29
        ; Validate CAM against PMPs
        MOV     r0, #0
30
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIA   r2!, {r4-r7}
        TST     r5, #DynAreaFlags_PMP
        BEQ     %FT35
        LDR     r8, [r6, #DANode_Flags]
        TST     r8, #DynAreaFlags_PMP
        BLEQ    %FT90
        LDR     r8, [r6, #DANode_PMP]
        LDR     r9, [r6, #DANode_PMPMaxSize]
        LDR     r10, [r6, #DANode_PMPSize]
        CMP     r7, r9
        BLHS    %FT90
        LDR     r8, [r8, r7, LSL #2]
        CMP     r0, r8
        BLNE    %FT90
35
        ADD     r0, r0, #1
        CMP     r0, r3
        BLS     %BT30
        EXITS

90
        Push    "lr"
        DebugTX "PMP corrupt"
        DebugReg r0
        DebugReg r1
        DebugReg r2
        DebugReg r3
        DebugReg r4
        DebugReg r5
        DebugReg r6
        DebugReg r7
        DebugReg r8
        DebugReg r9
        DebugReg r10
        DebugReg r11
        DebugReg r12
        Pull     "r0"
        DebugReg r0
        B        .
      ] ; PMPParanoid

        END
@


4.25
log
@Fix ability for PMPs to claim specific pages
Detail:
  s/ChangeDyn - Due to the way that some page flags map to the same bits as (different) DA flags, the Batcall that PMP_PreGrow makes in order to claim the requested page was getting confused and thinking that the special DMA PreGrow handler should be used instead of the DA-specific one (which in this case is a custom one responsible for claiming the right page). Modify PMP_PreGrow so that it only supplies DA flags to the Batcall, and patches in any custom page flags afterwards.
  Also swap magic number for appropriate symbol in PMPGrowHandler.
Admin:
  Tested on BB-xM
  Fixes CAM corruption when a PMP claims a specific page, due to the PMP code and DA code disagreeing about which page should be used


Version 6.00. Tagged as 'Kernel-6_00'
@
text
@d4596 1
a4596 1
        &       0                               ; size will be set up later
@


4.24
log
@Fix inverted global vs. per-page cache flush logic in PMP LogOp_MapOut
Detail:
  s/ChangeDyn - Set r6 bit 0 if the area is smaller than the cache range threshold, because that's what's checked for at lines 3077 and 3092
Admin:
  Tested on Raspberry Pi


Version 5.76. Tagged as 'Kernel-5_76'
@
text
@d635 1
a635 1
; Mask to convert DANode_Flags to page flags
d2519 1
d2565 14
a2578 4
        LDR     r0, [sp, #DANode_Flags] ; Use default DA flags, modified by flags given in page list
        LDR     lr, =DynAreaFlags_AccessMask :AND: :NOT: DynAreaFlags_PMPPhysOpAccessMask
        AND     r0, r0, lr
        ORR     r0, r0, r6
d2580 1
d2597 1
a2597 10
        STR     r5, [r8, r4, LSL #2]
        ADD     r5, r7, r5, LSL #CAM_EntrySizeLog2
        STR     r10, [r5, #CAM_PMP]
        STR     r4, [r5, #CAM_PMPIndex]
      [ PMPDebug
        LDR     r5, [r5, #CAM_PageFlags]
        DebugReg r5, "Claimed with flags: "
      ]
        ADD     r12, r12, #1
        B       %BT50
d2711 1
a2711 1
        TEQ     r0, #0
@


4.24.2.1
log
@Merge in latest changes from main branch

Version 6.05, 4.129.2.8. Tagged as 'Kernel-6_05-4_129_2_8'
@
text
@d635 1
a635 1
; Mask to convert DANode_Flags to page flags (i.e. flags that are common between the two)
a2518 1
59
d2564 4
a2567 14
        ; Because we're claiming the page via a Batcall, we need to make sure that the DA flags used for the call are valid as DA flags - i.e. don't touch any pageflags-only flags, because they might overlap the DA flags.
        ; Once the page is ours we'll fix up the other flags to be as the user requested.
    [ (DynAreaFlags_AccessMask :AND: DynAreaFlags_PMPPhysOpAccessMask) <> 0
        LDR     r0, [sp, #DANode_Flags]
      [ PMPDebug
        DebugReg r0, "Area flags: "
      ]
        LDR     lr, =DynAreaFlags_AccessMask :AND: DynAreaFlags_PMPPhysOpAccessMask
        BIC     r0, r0, lr
        AND     lr, r6, lr
        ORR     r0, r0, lr
      [ PMPDebug
        DebugReg r0, "Batcall flags: "
      ]
a2568 1
    ]
d2585 10
a2594 1
        B       %BT59
d2708 1
a2708 1
        TEQ     r0, #DAHandler_PreGrow
@


4.24.2.2
log
@Merge latest changes from HEAD

Version 6.08, 4.129.2.9. Tagged as 'Kernel-6_08-4_129_2_9'
@
text
@d4596 1
a4596 1
        &       32*1024                         ; true size will be set up later
@


4.23
log
@Implement support for cacheable pagetables
Detail:
  Modern ARMs (ARMv6+) introduce the possibility for the page table walk hardware to make use of the data cache(s) when performing memory accesses. This can significantly reduce the cost of a TLB miss on the system, and since the accesses are cache-coherent with the CPU it allows us to make the page tables cacheable for CPU (program) accesses also, improving the performance of page table manipulation by the OS.
  Even on ARMs where the page table walk can't use the data cache, it's been measured that page table manipulation operations can still benefit from placing the page tables in write-through or bufferable memory.
  So with that in mind, this set of changes updates the OS to allow cacheable/bufferable page tables to be used by the OS + MMU, using a system-appropriate cache policy.
  File changes:
  - hdr/KernelWS - Allocate workspace for storing the page flags that are to be used by the page tables
  - hdr/OSMem - Re-specify CP_CB_AlternativeDCache as having a different behaviour on ARMv6+ (inner write-through, outer write-back)
  - hdr/Options - Add CacheablePageTables option to allow switching back to non-cacheable page tables if necessary. Add SyncPageTables var which will be set {TRUE} if either the OS or the architecture requires a DSB after writing to a faulting page table entry.
  - s/ARM600, s/VMSAv6 - Add new SetTTBR & GetPageFlagsForCacheablePageTables functions. Update VMSAv6 for wider XCBTable (now 2 bytes per element)
  - s/ARMops - Update pre-ARMv7 MMU_Changing ARMops to drain the write buffer on entry if cacheable pagetables are in use (ARMv7+ already has this behaviour due to architectural requirements). For VMSAv6 Normal memory, change the way that the OS encodes the cache policy in the page table entries so that it's more compatible with the encoding used in the TTBR.
  - s/ChangeDyn - Update page table page flag handling to use PageTable_PageFlags. Make use of new PageTableSync macro.
  - s/Exceptions, s/AMBControl/memmap - Make use of new PageTableSync macro.
  - s/HAL - Update MMU initialisation sequence to make use of PageTable_PageFlags + SetTTBR
  - s/Kernel - Add PageTableSync macro, to be used after any write to a faulting page table entry
  - s/MemInfo - Update OS_Memory 0 page flag conversion. Update OS_Memory 24 to use new symbol for page table access permissions.
  - s/MemMap2 - Use PageTableSync. Add routines to enable/disable cacheable pagetables
  - s/NewReset - Enable cacheable pagetables once we're fully clear of the MMU initialision sequence (doing earlier would be trickier due to potential double-mapping)
Admin:
  Tested on pretty much everything currently supported
  Delivers moderate performance benefits to page table ops on old systems (e.g. 10% faster), astronomical benefits on some new systems (up to 8x faster)
  Stats: https://www.riscosopen.org/forum/forums/3/topics/2728?page=2#posts-58015


Version 5.71. Tagged as 'Kernel-5_71'
@
text
@d3040 1
a3040 1
        ORRHI   r6, r6, #1
@


4.22
log
@Make MMU_Changing ARMops perform the sub-operations in a sensible order
Detail:
  For a while we've known that the correct way of doing cache maintenance on ARMv6+ (e.g. when converting a page from cacheable to non-cacheable) is as follows:
  1. Write new page table entry
  2. Flush old entry from TLB
  3. Clean cache + drain write buffer
  The MMU_Changing ARMops (e.g. MMU_ChangingEntry) implement the last two items, but in the wrong order. This has caused the operations to fall out of favour and cease to be used, even in pre-ARMv6 code paths where the effects of improper cache/TLB management perhaps weren't as readily visible.
  This change re-specifies the relevant ARMops so that they perform their sub-operations in the correct order to make them useful on modern ARMs, updates the implementations, and updates the kernel to make use of the ops whereever relevant.
  File changes:
  - Docs/HAL/ARMop_API - Re-specify all the MMU_Changing ARMops to state that they are for use just after a page table entry has been changed (as opposed to before - e.g. 5.00 kernel behaviour). Re-specify the cacheable ones to state that the TLB invalidatation comes first.
  - s/ARM600, s/ChangeDyn, s/HAL, s/MemInfo, s/VMSAv6, s/AMBControl/memmap - Replace MMU_ChangingUncached + Cache_CleanInvalidate pairs with equivalent MMU_Changing op
  - s/ARMops - Update ARMop implementations to do everything in the correct order
  - s/MemMap2 - Update ARMop usage, and get rid of some lingering sledgehammer logic from ShuffleDoublyMappedRegionForGrow
Admin:
  Tested on pretty much everything currently supported


Version 5.70. Tagged as 'Kernel-5_70'
@
text
@d145 1
a145 2
L2PT                 DefAreaFlags None, DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable
L1PT                 DefAreaFlags None, DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable :OR: PageFlags_Unavailable
d2964 1
a2964 1
      [ MEMM_Type = "VMSAv6"
d2968 1
a2968 4
        ; DSB + ISB required to ensure effect of page table write is fully
        ; visible (after overwriting a faulting entry)
        myDSB   ,r0
        myISB   ,r0,,y
d3914 2
a3915 1
        MOV     r11, #AreaFlags_L2PT                      ; access privs (+CB bits)
d3941 4
d3976 1
a3976 6
      [ MEMM_Type = "VMSAv6"
        ; DSB + ISB required to ensure effect of page table write is fully
        ; visible (after overwriting a faulting entry)
        myDSB   ,r0
        myISB   ,r0,,y
      ]
@


4.21
log
@Place restrictions on the use of cacheable doubly-mapped DAs
Detail:
  The kernel has always allowed software to create cacheable doubly-mapped DAs, despite the fact that the VIVT caches used on ARMv5 and below would have no way of keeping both of the mappings coherent
  This change places restrictions the following restrictions on doubly-mapped areas, to ensure that cache settings which can't be supported by the cache architecture of the CPU can't be selected:
  * On ARMv6 and below, cacheable doubly-mapped areas aren't supported.
    * Although ARMv6 has VIPT data caches, it's also subject to page colouring constraints which would require us to force the DA size to be a multiple of 16k. So for now keep things simple and disallow cacheable doubly-mapped areas on ARMv6.
  * On ARMv7 and above, cacheable doubly-mapped areas are allowed, but only if they are marked non-executable
    * The blocker to allowing executable cacheable doubly-mapped areas are the VIPT instruction caches; OS_SynchroniseCodeAreas (or callers of it) would need to know that a doubly-mapped area is in use so that they can flush both mappings from the I-cache. Although some chips do have PIPT instruction caches, again it isn't really worth supporting executable cacheable doubly-mapped areas at the moment.
  These changes also allow us to get rid of the expensive 'sledgehammer' logic when dealing with doubly-mapped areas
  File changes:
  - s/ARM600, s/VMSAv6 - Remove the sledgehammer logic, only perform cache/TLB maintenance for the required areas
  - s/ChangeDyn - Implement the required checks
  - s/MemMap2 - Move some cache maintenance logic into RemoveCacheabilityR0ByMinusR2, which previously would have had to be performed by the caller due to the sledgehammer paranoia
Admin:
  Cacheable doubly-mapped DAs tested on iMx6 (tried making screen memory write-through cacheable; decent performance gain seen)
  Note OS_Memory 0 "make temporarily uncacheable" doesn't work on doubly-mapped areas, so cacheable doubly-mapped areas are not yet safe for general DMA


Version 5.69. Tagged as 'Kernel-5_69'
@
text
@d3082 1
a3082 4
        ARMop   MMU_ChangingUncachedEntry,,,r4
        MOV     r0, r11
        ADD     r1, r11, #4096
        ARMop   Cache_CleanInvalidateRange,,,r4
d3096 1
a3096 1
        DebugTX "Global cache flush"
d3098 1
a3098 2
        ARMop   MMU_ChangingUncached,,,r12
        ARMop   Cache_CleanInvalidateAll,,,r12
@


4.20
log
@Make s/ChangeDyn slightly more readable by splitting some routines out into a separate file
Detail:
  s/MemMap2 - New file containing assorted low-level memory mapping routines taken from s/ChangeDyn. N.B. There's no special significance to this being named "MemMap2", it's just a name that stuck due to some earlier (abandoned) changes which added a file named "MemMap".
  s/ChangeDyn - Remove the routines/chunks of code that were moved to s/MemMap2. Also some duplicate code removal (Regular DA grow code and DoTheGrowNotSpecified are now rely on the new DoTheGrowCommon routine for doing the actual grow)
  s/GetAll - GET s/MemMap2 at an appropriate time
Admin:
  Tested on pretty much everything currently supported


Version 5.67. Tagged as 'Kernel-5_67'
@
text
@d836 22
@


4.19
log
@Reimplement AMBControl ontop of the PMP system
Detail:
  With this set of changes, each AMB node is now the owner of a fake DANode which is linked to a PMP.
  From a user's perspective the behaviour of AMBControl is the same as before, but rewriting it to use PMPs internally offers the following (potential) benefits:
  * Reduction in the amount of code which messes with the CAM & page tables, simplifying future work/maintenance. Some of the AMB ops (grow, shrink) now just call through to OS_ChangeDynamicArea. However all of the old AMB routines were well-optimised, so to avoid a big performance hit for common operations not all of them have been removed (e.g. mapslot / mapsome). Maybe one day these optimal routines will be made available for use by regular PMP DAs.
  * Removal of the slow Service_MemoryMoved / Service_PagesSafe handlers that had to do page list fixup after the core kernel had reclaimed/moved pages. Since everything is a PMP, the kernel will now deal with this on behalf of AMB.
  * Removal of a couple of other slow code paths (e.g. Do_AMB_MakeUnsparse calls from OS_ChangeDynamicArea)
  * Potential for more flexible mapping of application space in future, e.g. sparse allocation of memory to the wimp slot
  * Simpler transition to an ASID-based task swapping scheme on ARMv6+?
  Other changes of note:
  * AMB_LazyMapIn switch has been fixed up to work correctly (i.e. turning it off now disables lazy task swapping and all associated code instead of producing a build error)
  * The DANode for the current app should be accessed via the GetAppSpaceDANode macro. This will either return the current AMB DANode, or AppSpaceDANode (if e.g. pre-Wimp). However be aware that AppSpaceDANode retains the legacy behaviour of having a base + size relative to &0, while the AMB DANodes (identifiable via the PMP flag) are sane and have their base + size relative to &8000.
  * Mostly-useless DebugAborts switch removed
  * AMBPhysBin (page number -> phys addr lookup table) removed. Didn't seem to give any tangible performance benefit, and was imposing hidden restrictions on memory usage (all phys RAM fragments in PhysRamTable must be multiple of 512k). And if it really was a good optimisation, surely it should have been applied to all areas of the kernel, not just AMB!
  Other potential future improvements:
  * Turn the fake DANodes into real dynamic areas, reducing the amount of special code needed in some places, but allow the DAs to be hidden from OS_DynamicArea 3 so that apps/users won't get too confused
  * Add a generic abort trapping system to PMPs/DAs (lazy task swapping abort handler is still a special case)
  File changes:
  - s/ARM600, s/VMSAv6, s/ExtraSWIs - Remove DebugAborts
  - s/ArthurSWIs - Remove AMB service call handler dispatch
  - s/ChangeDyn - AMB_LazyMapIn switch fixes. Add alternate internal entry points for some PMP ops to allow the DANode to be specified (used by AMB)
  - s/Exceptions - Remove DebugAborts, AMB_LazyMapIn switch fixes
  - s/Kernel - Define GetAppSpaceDANode macro, AMB_LazyMapIn switch fix
  - s/MemInfo - AMB_LazyMapIn switch fixes
  - s/AMBControl/AMB - Update GETs
  - s/AMBControl/Memory - Remove block size quantisation, AMB_BlockResize (page list blocks are now allocated by PMP code)
  - s/AMBControl/Options - Remove PhysBin definitions, AMBMIRegWords (moved to Workspace file), AMB_LimpidFreePool switch. Add AMB_Debug switch.
  - s/AMBControl/Workspace - Update AMBNode to contain an embedded DANode. Move AMBMIRegWords here from Options file.
  - s/AMBControl/allocate - Fake DA node initialisation
  - s/AMBControl/deallocate - Add debug output
  - s/AMBControl/growp, growshrink, mapslot, mapsome, shrinkp - Rewrite to use PMP ops where possible, add debug output
  - s/AMBControl/main - Remove PhysBin initialisation. Update the enumerate/mjs_info call.
  - s/AMBControl/memmap - Low-level memory mapping routines updated or rewritten as appropriate.
  - s/AMBControl/readinfo - Update to cope with DANode
  - s/AMBControl/service - Remove old service call handlers
  - s/AMBControl/handler - DA handler for responding to PMP calls from OS_ChangeDynamicArea; just calls through to growpages/shrinkpages as appropriate.
Admin:
  Tested on pretty much everything currently supported


Version 5.66. Tagged as 'Kernel-5_66'
@
text
@a310 152

; in:   r0 = logical address where page is now

GetPageFlagsForR0IntoR6 Entry "R0-R2, R4-R5, R7"
;
; code from MoveCAMatR0toR3
;
        LDR     r5, =L2PT
        ADD     r4, r5, r0, LSR #10             ; r4 -> L2PT for log addr r0
        MOV     r2, r4, LSR #12
        LDR     r2, [r5, r2, LSL #2]            ; r2 = L2PT entry for r4
        TST     r2, #3                          ; if no page there
        BEQ     %FT90                           ; then cam corrupt

        LDR     r4, [r4]                        ; r4 = L2PT entry for r0
        TST     r4, #3                          ; check entry is valid too
        BEQ     %FT91
        MOV     r4, r4, LSR #12                 ; r4 = phys addr >> 12

        LDR     r2, =ZeroPage
        LDR     r6, [r2, #MaxCamEntry]
        ADD     r5, r2, #PhysRamTable
      [ ZeroPage <> 0
        MOV     r2, #0
      ]
10
        CMP     r2, r6                          ; if page we've got to is > max
        BHI     %FT92                           ; then corrupt
        LDMIA   r5!, {r7, lr}                   ; get phys.addr, size
        SUB     r7, r4, r7, LSR #12             ; number of pages into this bank
        CMP     r7, lr, LSR #12                 ; if too many
        ADDCS   r2, r2, lr, LSR #12             ; then advance physical page no.
        BCS     %BT10                           ; and loop

        ADD     r2, r2, r7                      ; add on number of pages within bank
;
; code from BangCamUpdate
;
        LDR     r1, =ZeroPage
        LDR     r1, [r1, #CamEntriesPointer]
        ADD     r1, r1, r2, LSL #CAM_EntrySizeLog2 ; point at cam entry (logaddr, PPL)
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMIA   r1, {r0, r6}                    ; r0 = current logaddress, r6 = current PPL
        EXIT

90
        ADR     lr, NoL2ForPageBeingRemovedError ; NB don't corrupt r0 yet - we need that in block as evidence
95
        STR     lr, [sp]                        ; update returned r0
        BL      StoreDebugRegs
        PullEnv                                 ; seriously broken memory
        SETV
        MOV     pc, lr

91
        ADR     lr, PageBeingRemovedNotPresentError
        B       %BT95

92
        ADR     lr, PhysicalAddressNotFoundError
        B       %BT95


; MoveCAMatR0toR3
; in:   r0 = old logaddr
;       r3 = new logaddr
;       r9 = offset from 1st to 2nd copy of doubly mapped area (either source or dest, but not both)
;       r11 = page protection level
;
; out:  r2 = physical page number of page moved, unless there was a serious error
;       r0,r1,r3,r6-r12 preserved
;       r4,r5 corrupted

MoveCAMatR0toR3 Entry "r0,r1,r6,r7"
        LDR     r5, =L2PT
        ADD     r4, r5, r0, LSR #10             ; r4 -> L2PT for log addr r0
        MOV     r2, r4, LSR #12
        LDR     r2, [r5, r2, LSL #2]            ; r2 = L2PT entry for r4
        TST     r2, #3                          ; if no page there
        BEQ     %FT90                           ; then cam corrupt

        LDR     r4, [r4]                        ; r4 = L2PT entry for r0
        TST     r4, #3                          ; check entry is valid too
        BEQ     %FT91
        MOV     r4, r4, LSR #12                 ; r4 = phys addr >> 12

        LDR     r2, =ZeroPage
        LDR     r6, [r2, #MaxCamEntry]
        ADD     r5, r2, #PhysRamTable
      [ ZeroPage <> 0
        MOV     r2, #0
      ]
10
        CMP     r2, r6                          ; if page we've got to is > max
        BHI     %FT92                           ; then corrupt
        LDMIA   r5!, {r7, lr}                   ; get phys.addr, size
        SUB     r7, r4, r7, LSR #12             ; number of pages into this bank
        CMP     r7, lr, LSR #12                 ; if too many
        ADDCS   r2, r2, lr, LSR #12             ; then advance physical page no.
        BCS     %BT10                           ; and loop

        ADD     r2, r2, r7                      ; add on number of pages within bank
        BL      BangCamUpdate
        CLRV
        EXIT

90
        ADR     lr, NoL2ForPageBeingRemovedError ; NB don't corrupt r0 yet - we need that in block as evidence
95
        STR     lr, [sp]                        ; update returned r0
        BL      StoreDebugRegs
        PullEnv                                 ; seriously broken memory
        SETV
        MOV     pc, lr

91
        ADR     lr, PageBeingRemovedNotPresentError
        B       %BT95

92
        ADR     lr, PhysicalAddressNotFoundError
        B       %BT95

StoreDebugRegs ; Note: Corrupts R0,R1
        Push    "lr"
        LDR     lr, =ZeroPage+CamMapCorruptDebugBlock
        STMIA   lr, {r0-r12}
        STR     sp, [lr, #13*4]!
        LDMIA   sp, {r0,r1}                     ; reload stacked LR & return R0 (error pointer)
        STMIB   lr, {r0,r1}                     ; LR -> LR, error -> PC
        Pull    "pc"

NoL2ForPageBeingRemovedError
        &       0
        =       "Memory Corrupt: No L2PT for page being removed", 0
        ALIGN

PageBeingRemovedNotPresentError
        &       0
        =       "Memory Corrupt: Page being removed was not present", 0
        ALIGN

PhysicalAddressNotFoundError
        &       0
        =       "Memory Corrupt: Physical address not found", 0
        ALIGN

CamMapBroke
        &       0
        =       "!!!! CAM Map Corrupt !!!!", 0
        ALIGN
a320 44
  [ FastCDA_Bulk
; RemoveCacheabilityR0ByMinusR2
; Make a range of pages (temporarily) uncacheable prior to (re)moving them
; Doesn't perform any cache/TLB maintenance
; in:   r0 = end of area
;       r2 = size of area (must be nonzero)
; out:  r6 has DynAreaFlags_NotCacheable set if entire region noncacheable
;              Flag clear if at least one page was cacheable
;       r0 points to start of area
;
;       4K page size assumed!
RemoveCacheabilityR0ByMinusR2 ROUT
        Entry   "r1-r5"
        MOV     r5, #DynAreaFlags_NotCacheable
        MOV     r1, #-1
10
        SUB     r0, r0, #4096
        BL      GetPageFlagsForR0IntoR6
        TST     r6, #DynAreaFlags_NotCacheable
        BNE     %FT90
        ; Work out required page flags - use cached flags from last page if possible
        CMP     r1, r6
        BEQ     %FT20
        LDR     r3, =ZeroPage
        MOV     r1, r6
        LDR     r3, [r3, #MMU_PCBTrans]
        GetTempUncache r4, r6, r3, lr
20
        ; Update the current L2PT entry
        LDR     r3, =L2PT
        LDR     lr, =TempUncache_L2PTMask
        LDR     r5, [r3, r0, LSR #10]
        BIC     r5, r5, lr
        ORR     r5, r5, r4
        STR     r5, [r3, r0, LSR #10]
        ; Clear the flag from R5
        MOV     r5, #0
90
        SUBS    r2, r2, #4096
        BNE     %BT10
        MOV     r6, r5
        EXIT
  ]

a588 3
 [ {FALSE}
        AND     r11, r11, #3
 ]
d4780 1
a4780 23
; Now move pages starting from end of area

        LDR     r0, [r11, #DANode_Base]
        LDR     r3, [r11, #DANode_Size]
        LDR     r6, [r11, #DANode_Flags]        ; r6 = src flags
        Push    "r3, r6"                        ; save src old size, src flags for later
        TST     r6, #DynAreaFlags_DoublyMapped  ; if src is doubly mapped
        MOVNE   r9, r3                          ; then set up offset from 1st copy to 2nd copy = old src size
        ADD     r0, r0, r3                      ; move r0 to point to after end of area (2nd copy)
        SUB     r3, r3, r2
        STR     r3, [r11, #DANode_Size]         ; store reduced source size
      [ ZeroPage = 0
        TEQ     r11, #AppSpaceDANode            ; check if src = appspace
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r11, lr                         ; check if src = appspace
      ]
        STREQ   r3, [r11, #MemLimit-AppSpaceDANode] ; update memlimit if so
      [ PMPDebug
        DebugReg r3, "< src size"
      ]

        LDR     r3, [r12, #DANode_PMPSize]      ; r3 -> index of 1st extra page
a4781 6
      [ FastCDA_Bulk
        Push    "r0"
        BL      RemoveCacheabilityR0ByMinusR2
        LDR     r4, [r11, #DANode_Flags]
        ADR     lr, %FT19
        TST     r4, #DynAreaFlags_DoublyMapped
a4782 105
        BNE     %FT18
        ; Interacting with singly-mapped region - use regular logic
        MOV     r1, r2, LSR #12
        ARMop   MMU_ChangingUncachedEntries,,, r4
        TST     r6, #DynAreaFlags_NotCacheable
        BNE     %FT19
        LDR     r1, [sp]
        SUB     r0, r1, r2
        ARMop   Cache_CleanInvalidateRange,,, r4
        B       %FT19
18
        ; Interacting with doubly-mapped region - use sledgehammer logic
        LDR     r0, [r11, #DANode_Base]
        MOV     r1, r2
        LDR     r2, [sp, #4]                    ; Grab old source size (pushed r3)
        BL      RemoveCacheabilityR0ByMinusR2   ; Remove cacheability for entireity of lower mapping (whole thing needs shuffling)
        MOV     r2, r1
        ARMop   MMU_ChangingUncached,,, r4
        TST     r6, #DynAreaFlags_NotCacheable
        ARMop   Cache_CleanInvalidateAll, EQ,, r4
19
        Pull    "r0"
      ]        

        LDR     lr, =DynAreaFlags_AccessMask
        MOV     r4, r2
        LDR     r6, [r12, #DANode_Flags]        ; r6 = dst flags
        AND     r6, r6, lr
      [ FastCDA_Bulk
        ORR     r6, r6, #PageFlags_Unsafe
      ]
20
        SUB     r0, r0, r5                      ; pre-decrement source pointer
 [ DebugCDA2
        DREG    r0, "Moving page at ", cc
        DREG    r3, " to free pool index ", cc
        DREG    r6, " with PPL "
 ]
        Push    "r2"
        LDR     r1, =Nowhere
        BL      MovePageAtR0ToR1WithAccessR6ReturnPageNumber
        ; Update PMP association
        LDR     r1, [r12, #DANode_PMP]
        STR     r2, [r1, r3, LSL #2]            ; Store in free pool PMP
        LDR     lr, =ZeroPage
        LDR     lr, [lr, #CamEntriesPointer]
        ADD     lr, lr, r2, LSL #CAM_EntrySizeLog2
        STR     r12, [lr, #CAM_PMP]              ; Store PMP in CAM
        STR     r3, [lr, #CAM_PMPIndex]
        ADD     r3, r3, #1
        Pull    "r2"

        SUBS    r4, r4, r5
        BNE     %BT20
      [ FastCDA_Bulk
        ; Flush the TLB for the removed pages
        Push    "r0-r1,r3"
        MOV     r1, r2, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3 ; src region
        LDR     r6, [r11, #DANode_Flags]        ; r6 = src flags
        TST     r6, #DynAreaFlags_DoublyMapped
        LDRNE   r0, [sp]
        SUBNE   r0, r0, r9
        ARMop   MMU_ChangingUncachedEntries,NE,,r3 ; doubly mapped src region
        Pull    "r0-r1,r3"
      ]

        STR     r3, [r12, #DANode_PMPSize]      ; store increased destination size

        Pull    "r3, r6"                        ; restore src old size, src flags
        TST     r6, #DynAreaFlags_DoublyMapped  ; if src doubly mapped
        SUBNES  r4, r3, r2                      ; then set r4 = number of pages to shuffle up
        BEQ     %FT30                           ; [not doubly mapped, or no pages left, so skip]

        SUB     r0, r0, r3                      ; move r0 back to end of 1st copy of pages remaining
        ADD     r1, r0, r2                      ; r1 is end of where they're moving to (should be src base address!)
 [ 1 = 1
 |
        AND     r6, r6, #DynAreaFlags_AccessMask
 ]
        MOV     r9, #0                          ; no funny stuff while moving these pages
25
        SUB     r0, r0, r5
        SUB     r1, r1, r5
 [ 1 = 1
        BL      GetPageFlagsForR0IntoR6
 ]
 [ FastCDA_Bulk
        ORR     r6, r6, #PageFlags_Unsafe
 ]
        BL      MovePageAtR0ToR1WithAccessR6
        SUBS    r4, r4, r5
        BNE     %BT25
      [ FastCDA_Bulk
        ; Flush the TLB for the shuffled pages
        Push    "r0-r1,r3"
        MOV     r1, r3, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r0-r1,r3"
      ]

30
        LDR     r4, =ZeroPage                   ; indicate no page block (and ptr to semaphore)
a5300 3

DoTheGrowNotSpecifiedStackSize * :INDEX: @@      ; amount of stack needed for 'not specified' version

a5346 2
; now move pages starting from end of area

d5348 3
a5350 108
        LDR     r0, [r11, #DANode_PMP]
        LDR     r3, [r11, #DANode_PMPSize]
        ADD     r0, r0, r3, LSL #2              ; move r0 to point to after end of area
        SUB     r3, r3, r2, LSR #12             ; reduce by amount moving from area
        STR     r3, [r11, #DANode_PMPSize]      ; store reduced source size

        LDR     r1, [r12, #DANode_Base]
        LDR     r3, [r12, #DANode_Size]

        LDR     r6, [r12, #DANode_Flags]        ; r6 = dst flags
        LDR     lr, =DynAreaFlags_AccessMask
        TST     r6, #DynAreaFlags_DoublyMapped  ; check if dst is doubly mapped
        AND     r6, r6, lr
        BEQ     %FT25                           ; [it's not, so skip all this]

; we must shunt all existing pages in dest area down

        MOVS    r4, r3                          ; amount to do
        BEQ     %FT20                           ; [none, so skip all this]

      [ FastCDA_Bulk
        ; Perform sledgehammer logic upfront
        Push    "r0,r2,r6"
        MOV     r0, r1
        MOV     r2, r3
        BL      RemoveCacheabilityR0ByMinusR2
        LDR     r2, =ZeroPage
        ARMop   MMU_ChangingUncached,,, r2
        TST     r6, #DynAreaFlags_NotCacheable
        ARMop   Cache_CleanInvalidateAll, EQ,, r2
        Pull    "r0,r2,r6"
        ORR     r6, r6, #PageFlags_Unsafe
      ]

        Push    "r0, r1"
        SUB     r0, r1, r3                      ; src starts at start of 1st copy = start of 2nd - old size
        SUB     r1, r0, r2                      ; dst start = src start - amount of room needed
        MOV     r9, #0                          ; no funny business while moving these pages
15
        BL      MovePageAtR0ToR1WithAccessR6    ; move page
        ADD     r0, r0, r5                      ; advance src ptr
        ADD     r1, r1, r5                      ; advance dst ptr
        SUBS    r4, r4, r5                      ; one less page to move
        BNE     %BT15                           ; loop if more
      [ FastCDA_Bulk
        ; Flush the shuffled pages from the TLB
        ; Note we only flush the area containing pages which have been
        ; moved/removed; for pages which have been mapped in the only
        ; requirement is that (for VMSAv6) we issue a DSB+ISB, which we can
        ; assume the MMU_ChangingUnachedEntries op will do for us.
        Push    "r3"
        SUB     r0, r0, r3
        MOV     r1, r3, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r3"
      ]
        Pull    "r0, r1"                        ; restore original regs
20
        ADD     r9, r3, r2                      ; set up offset from 1st copy to 2nd copy (= new size)
25
        ADD     r1, r1, r3                      ; r1 -> address of 1st extra page
   [ FastCDA_Bulk
        ORR     r6, r6, #PageFlags_Unsafe
   ]
        MOV     r4, #0                          ; amount done so far
        MOV     r10, r2                         ; move amount to do into r10, as routine returns page number in r2
        ADR     r3, PageBlock1                  ; point at 1st entry we have to update
30
        LDR     r2, [r0, #-4]!                  ; pre-decrement source pointer
 [ DebugCDA2
        DREG    r2, "Moving page number ", cc
        DREG    r1, " to ", cc
        DREG    r6, " with PPL "
 ]
        Push    "r0-r1,r3-r4,r6,r11"
        MOV     r11, #-1
        MOV     r3, r1
        STR     r11, [r0]                       ; Remove from free pool PMP
        MOV     r11, r6
        BL      BangCamUpdate
        Pull    "r0-r1,r3-r4,r6,r11"
        STR     r2, [r3], #12                   ; store page number and move on
        ADD     r1, r1, r5
        ADD     r4, r4, r5
        CMP     r4, r10                         ; have we done all of it?
        BNE     %BT30                           ; [no, so loop]
      [ FastCDA_Bulk :LAND: (MEMM_Type = "VMSAv6")
        ; DSB + ISB required to ensure effect of page table write is fully
        ; visible (after overwriting a faulting entry)
        myDSB   ,lr
        myISB   ,lr,,y
        ; Note for non-VMSAv6 case there's nothing needed since we were only
        ; overwriting faulting entries
      ]
35
        LDR     r3, [r12, #DANode_Size]
        ADD     r3, r3, r10
        STR     r3, [r12, #DANode_Size]         ; store increased destination size
      [ ZeroPage = 0
        TEQ     r12, #AppSpaceDANode            ; check if dest = appspace
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r12, lr                         ; check if dest = appspace
      ]
        STREQ   r3, [r12, #MemLimit-AppSpaceDANode] ; update memlimit if so

        MOV     r3, r10                         ; r3 = size of change
d5465 1
a5465 63
        BEQ     %FT10                           ; [none, so skip all this]

    [ FastCDA_Bulk
        ; Perform sledgehammer logic upfront
        Push    "r0,r2,r6"
        FastCDA_ProfStart DoublyRemoveCacheability, r0, r6, lr
        MOV     r0, r1
        MOV     r2, r3
        BL      RemoveCacheabilityR0ByMinusR2
        FastCDA_ProfEnd DoublyRemoveCacheability, r0, r2, lr
        LDR     r2, =ZeroPage
      [ FastCDA_Prof
        TST     r6, #DynAreaFlags_NotCacheable
        LDREQ   lr,[r2,#FastCDA_Prof_MMUChangingCached]
        LDRNE   lr,[r2,#FastCDA_Prof_MMUChangingUncached]
        MRC     p15,0,r0,c9,c13,0
        SUB     lr,lr,r0
        STREQ   lr,[r2,#FastCDA_Prof_MMUChangingCached]
        STRNE   lr,[r2,#FastCDA_Prof_MMUChangingUncached]
      ]      
        ARMop   MMU_ChangingUncached,,, r2
        TST     r6, #DynAreaFlags_NotCacheable
        ARMop   Cache_CleanInvalidateAll, EQ,, r2
      [ FastCDA_Prof
        MRC     p15,0,r0,c9,c13,0
        TST     r6, #DynAreaFlags_NotCacheable
        LDREQ   lr,[r2,#FastCDA_Prof_MMUChangingCached]
        LDRNE   lr,[r2,#FastCDA_Prof_MMUChangingUncached]
        ADD     lr,lr,r0
        STREQ   lr,[r2,#FastCDA_Prof_MMUChangingCached]
        STRNE   lr,[r2,#FastCDA_Prof_MMUChangingUncached]
      ]      
        Pull    "r0,r2,r6"
        ORR     r6, r6, #PageFlags_Unsafe
    ]

        Push    "r0, r1"
        FastCDA_ProfStart DoublyMovePages, r0, r9, lr
        SUB     r0, r1, r3                      ; src starts at start of 1st copy = start of 2nd - old size
        SUB     r1, r0, r2                      ; dst start = src start - amount of room needed
        MOV     r9, #0                          ; no funny business while moving these pages
09
        BL      MovePageAtR0ToR1WithAccessR6    ; move page
        ADD     r0, r0, r5                      ; advance src ptr
        ADD     r1, r1, r5                      ; advance dst ptr
        SUBS    r4, r4, r5                      ; one less page to move
        BNE     %BT09                           ; loop if more
        FastCDA_ProfEnd DoublyMovePages, r0, r9, lr
      [ FastCDA_Bulk
        ; Flush the shuffled pages from the TLB
        ; Note we only flush the area containing pages which have been
        ; moved/removed; for pages which have been mapped in the only
        ; requirement is that (for VMSAv6) we issue a DSB+ISB, which we can
        ; assume the MMU_ChangingUnachedEntries op will do for us.
        Push    "r3"
        SUB     r0, r0, r3
        MOV     r1, r3, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r3"
      ]
        Pull    "r0, r1"                        ; restore original regs
10
a5950 1
;       (r10 -> dest area)
d5961 2
a5962 9
        Entry "r3,r5,r10-r12", DoTheGrowNotSpecifiedStackSize

        ; TODO could merge with code from DoTheGrow? (make this subroutine of DoTheGrow, with write back of pages to page list optional)

        STR     r2, NumEntries                  ; save number of entries for use later
        STR     r7, TotalAmount                 ; save amount growing by

; now move pages starting from end of area

d5964 1
a5964 105
        LDR     r0, [r11, #DANode_PMP]
        LDR     r3, [r11, #DANode_PMPSize]
        ADD     r0, r0, r3, LSL #2              ; move r0 to point to after end of area
        SUB     r3, r3, r2, LSR #12             ; reduce by amount moving from area
        STR     r3, [r11, #DANode_PMPSize]      ; store reduced source size

        LDR     r1, [r12, #DANode_Base]
        LDR     r3, [r12, #DANode_Size]

        LDR     r6, [r12, #DANode_Flags]        ; r6 = dst flags
        LDR     lr, =DynAreaFlags_AccessMask
        AND     r6, r6, lr
        TST     r6, #DynAreaFlags_DoublyMapped  ; check if dst is doubly mapped
        BEQ     %FT25                           ; [it's not, so skip all this]

; we must shunt all existing pages in dest area down

        MOVS    r4, r3                          ; amount to do
        BEQ     %FT20                           ; [none, so skip all this]

      [ FastCDA_Bulk
        ; Perform sledgehammer logic upfront
        Push    "r0,r2,r6"
        MOV     r0, r1
        MOV     r2, r3
        BL      RemoveCacheabilityR0ByMinusR2
        LDR     r2, =ZeroPage
        ARMop   MMU_ChangingUncached,,, r2
        TST     r6, #DynAreaFlags_NotCacheable
        ARMop   Cache_CleanInvalidateAll, EQ,, r2
        Pull    "r0,r2,r6"
        ORR     r6, r6, #PageFlags_Unsafe
      ]

        Push    "r0, r1"
        SUB     r0, r1, r3                      ; src starts at start of 1st copy = start of 2nd - old size
        SUB     r1, r0, r2                      ; dst start = src start - amount of room needed
        MOV     r9, #0                          ; no funny business while moving these pages
15
        BL      MovePageAtR0ToR1WithAccessR6    ; move page
        ADD     r0, r0, r5                      ; advance src ptr
        ADD     r1, r1, r5                      ; advance dst ptr
        SUBS    r4, r4, r5                      ; one less page to move
        BNE     %BT15                           ; loop if more
      [ FastCDA_Bulk
        ; Flush the shuffled pages from the TLB
        ; Note we only flush the area containing pages which have been
        ; moved/removed; for pages which have been mapped in the only
        ; requirement is that (for VMSAv6) we issue a DSB+ISB, which we can
        ; assume the MMU_ChangingUnachedEntries op will do for us.
        Push    "r3"
        SUB     r0, r0, r3
        MOV     r1, r3, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r3"
      ]
        Pull    "r0, r1"                        ; restore original regs
20
        ADD     r9, r3, r2                      ; set up offset from 1st copy to 2nd copy (= new size)
25
        ADD     r1, r1, r3                      ; r1 -> address of 1st extra page
   [ FastCDA_Bulk
        ORR     r6, r6, #PageFlags_Unsafe                
   ]
        MOV     r4, #0                          ; amount done so far
        MOV     r10, r2                         ; move amount to do into r10
30
        LDR     r2, [r0, #-4]!                  ; pre-decrement source pointer
 [ DebugCDA2
        DREG    r2, "Moving page number ", cc
        DREG    r1, " to ", cc
        DREG    r6, " with PPL "
 ]
        Push    "r0-r1,r3-r4,r6,r11"
        MOV     r11, #-1
        MOV     r3, r1
        STR     r11, [r0]                       ; Remove from free pool PMP
        MOV     r11, r6
        BL      BangCamUpdate
        Pull    "r0-r1,r3-r4,r6,r11"
        ADD     r1, r1, r5
        ADD     r4, r4, r5
        CMP     r4, r10                         ; have we done all of it?
        BNE     %BT30                           ; [no, so loop]
      [ FastCDA_Bulk :LAND: (MEMM_Type = "VMSAv6")
        ; DSB + ISB required to ensure effect of page table write is fully
        ; visible (after overwriting a faulting entry)
        myDSB   ,lr
        myISB   ,lr,,y
        ; Note for non-VMSAv6 case there's nothing needed since we were only
        ; overwriting faulting entries
      ]
35
        LDR     r3, [r12, #DANode_Size]
        ADD     r3, r3, r10
        STR     r3, [r12, #DANode_Size]         ; store increased destination size
      [ ZeroPage = 0
        TEQ     r12, #AppSpaceDANode            ; check if dest = appspace
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r12, lr                         ; check if dest = appspace
      ]
        STREQ   r3, [r12, #MemLimit-AppSpaceDANode] ; update memlimit if so

a6265 27
;       MovePageAtR0ToR1WithAccessR6
;
;       Internal routine, called by OS_ChangeDynamicArea
;
; in:   r0 = logical address where page is now
;       r1 = logical address it should be moved to
;       r6 = area flags (which contain access privileges, and cacheable/bufferable bits)
;
; out:  All registers preserved
;

MovePageAtR0ToR1WithAccessR6 Entry "r2-r5,r11"
        MOV     r3, r1
        MOV     r11, r6
        BL      MoveCAMatR0toR3         ; use old internal routine for now
        EXIT

; Same as above, but returns with r2 = page number of page that moved

MovePageAtR0ToR1WithAccessR6ReturnPageNumber Entry "r3-r5,r11"
        MOV     r3, r1
        MOV     r11, r6
        BL      MoveCAMatR0toR3         ; use old internal routine for now
        EXIT

; ***********************************************************************************
;
@


4.18
log
@Fix CAM indexing in DoTheGrowPageUnavailable
Detail:
  s/ChangeDyn - A routine that was missed during the upgrade from 8 byte CAM entries to 16 byte CAM entries, DoTheGrowPageUnavailable was using still using the old CAM entry size, potentially corrupting the CAM whenever it was called (i.e. if a DA grow requested a page that had already been claimed for exclusive use by someone else)
Admin:
  Tested on BB-xM


Version 5.60. Tagged as 'Kernel-5_60'
@
text
@d163 1
a163 1
ChangeDyn_FreeAndApl * -2               ; special reason code for when we're sucking out of free pool and apl space
d639 1
a639 1
   [ ChocolateAMB
d687 1
a687 1
   [ ChocolateAMB
d2538 1
d2847 4
a2917 1
        ; This is basically just a wrapper around OS_FindMemMapEntries & OS_SetMemMapEntries
d2925 1
d3196 3
d3322 2
d3346 1
d3486 3
d5129 3
a5131 2
        MOV     r0, #ChangeDyn_AplSpace
        LDR     r10, =ZeroPage+AppSpaceDANode
d5133 4
a5136 1
        B       AreaShrink
d5142 1
a5142 1
        LDR     r10, =ZeroPage+AppSpaceDANode
d5200 3
d5285 1
a5285 1
        LDR     r4, =ZeroPage+AppSpaceDANode
d5288 3
a6621 6
    [  ChocolateAMB
        BNE     %FT05
        BL      Do_AMB_MakeUnsparse             ; then ok to move memory, so undo laziness and exit
        CLRV
        EXIT
    |
a6622 1
    ]
a6643 3
  [ ChocolateAMB
        BL      Do_AMB_MakeUnsparse             ; undo laziness
  ]
a6646 9
    [ ChocolateAMB
Do_AMB_MakeUnsparse ROUT
        Push    "r0, lr"
        MOVS    r0, r10
        RSBMI   r0, r0, #0
        BL      AMB_MakeUnsparse  ;shrinking AppSpace, so make sure unsparse over area of shrink
        Pull    "r0, pc"
    ] ;ChocolateAMB

d7482 1
d7523 3
d7529 13
@


4.17
log
@Misc memory management fixes
Detail:
  s/ChangeDyn - Fix register corruption in PMP_LogOp when mapping a page into a location that already contains a page. Fix excessive TLB flush in AreaShrink.
  s/ARM600, s/VMSAv6 - Add asserts to GetTempUncache to detect invalid register combinations
Admin:
  Tested on BB-xM


Version 5.59. Tagged as 'Kernel-5_59'
@
text
@d5784 2
a5785 1
        ADD     r4, r0, r4, LSL #3              ; point at cam entry
@


4.16
log
@Fix stack imbalance and incorrect return value in OS_DynamicArea 23 (PMP resize)
Detail:
  s/ChangeDyn - When OS_DynamicArea 23 returned an error, R2 wasn't being set to zero correctly, incorrectly suggesting that a change had been made. And when a non-error resize of zero was being performed, registers were being pulled twice, resulting in a stack imbalance and crash.
Admin:
  Tested on BB-xM


Version 5.58. Tagged as 'Kernel-5_58'
@
text
@d3072 1
a3072 1
        Push    "r2,r4,r6,r7"
d3091 1
a3091 1
        Pull    "r2,r4,r6,r7"
d4999 1
a4999 1
        ARMop   MMU_ChangingUncached,,, r4
@


4.15
log
@Fix OS_FindMemMapEntries
Detail:
  s/ChangeDyn - Since the introduction of the 16 byte CAM entry format, OS_FindMemMapEntries has contained a bug where requesting the details for an address which does not have an L2PT page allocated for it (e.g. a location in ROM) would result in a misaligned CAM entry pointer being generated, resulting in either a crash or incorrect data being returned
Admin:
  Tested on Raspberry Pi 2
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/4/topics/6393


Version 5.57. Tagged as 'Kernel-5_57'
@
text
@d3462 2
d3467 1
a3467 1
        FRAMSTR r0
d3469 1
a3469 1
        EXIT
a3471 1
        PullEnv
d3473 1
a3473 5
        MOV     r2, #0
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        EXIT
@


4.14
log
@Add support for shareable pages and additional access privileges
Detail:
  This set of changes:
  * Refactors page table entry encoding/decoding so that it's (mostly) performed via functions in the MMU files (s.ARM600, s.VMSAv6) rather than on an ad-hoc basis as was the case previously
  * Page table entry encoding/decoding performed during ROM init is also handled via the MMU functions, which resolves some cases where the wrong cache policy was in use on ARMv6+
  * Adds basic support for shareable pages - on non-uniprocessor systems all pages will be marked as shareable (however, we are currently lacking ARMops which broadcast cache maintenance operations to other cores, so safe sharing of cacheable regions isn't possible yet)
  * Adds support for the VMSA XN flag and the "privileged ROM" access permission. These are exposed via RISC OS access privileges 4 and above, taking advantage of the fact that 4 bits have always been reserved for AP values but only 4 values were defined
  * Adds OS_Memory 17 and 18 to convert RWX-style access flags to and from RISC OS access privelege numbers; this allows us to make arbitrary changes to the mappings of AP values 4+ between different OS/hardware versions, and allows software to more easily cope with cases where the most precise AP isn't available (e.g. no XN on <=ARMv5)
  * Extends OS_Memory 24 (CheckMemoryAccess) to return executability information
  * Adds exported OSMem header containing definitions for OS_Memory and OS_DynamicArea
  File changes:
  - Makefile - export C and assembler versions of hdr/OSMem
  - Resources/UK/Messages - Add more text for OS_Memory errors
  - hdr/KernelWS - Correct comment regarding DCacheCleanAddress. Allocate workspace for MMU_PPLTrans and MMU_PPLAccess.
  - hdr/OSMem - New file containing exported OS_Memory and OS_DynamicArea constants, and public page flags
  - hdr/Options - Reduce scope of ARM6support to only cover builds which require ARMv3 support
  - s/AMBControl/Workspace - Clarify AMBNode_PPL usage
  - s/AMBControl/growp, mapslot, mapsome, memmap - Use AreaFlags_ instead of AP_
  - s/AMBControl/main, memmap - Use GetPTE instead of generating page table entry manually
  - s/ARM600 - Remove old coments relating to lack of stack. Update BangCam to use GetPTE. Update PPL tables, removing PPLTransL1 (L1 entries are now derived from L2 table on demand) and adding a separate table for ARM6. Implement the ARM600 versions of the Get*PTE ('get page table entry') and Decode*Entry functions
  - s/ARMops - Add Init_PCBTrans function to allow relevant MMU_PPLTrans/MMU_PCBTrans pointers to be set up during the pre-MMU stage of ROM init. Update ARM_Analyse to set up the pointers that are used post MMU init.
  - s/ChangeDyn - Move a bunch of flags to hdr/OSMem. Rename the AP_ dynamic area flags to AreaFlags_ to avoid name clashes and confusion with the page table AP_ values exported by Hdr:MEMM.ARM600/Hdr:MEMM.VMSAv6. Also generate the relevant flags for OS_Memory 24 so that it can refer to the fixed areas by their name instead of hardcoding the permissions.
  - s/GetAll - GET Hdr:OSMem
  - s/HAL - Change initial page table setup to use DA/page flags and GetPTE instead of building page table entries manually. Simplify AllocateL2PT by removing the requirement for the user to supply the access perimssions that will be used for the area; instead for ARM6 we just assume that cacheable memory is the norm and set L1_U for any L1 entry we create here.
  - s/Kernel - Add GetPTE macro (for easier integration of Get*PTE functions) and GenPPLAccess macro (for easy generation of OS_Memory 24 flags)
  - s/MemInfo - Fixup OS_Memory 0 to not fail on seeing non-executable pages. Implement OS_Memory 17 & 18. Tidy up some error generation. Make OS_Memory 13 use GetPTE. Extend OS_Memory 24 to return (non-) executability information, to use the named CMA_ constants generated by s/ChangeDyn, and to use the Decode*Entry functions when it's necessary to decode page table entries.
  - s/NewReset - Use AreaFlags_ instead of AP_
  - s/VMSAv6 - Remove old comments relating to lack of stack. Update BangCam to use GetPTE. Update PPL tables, removing PPLTransL1 (L1 entries are now derived from L2 table on demand) and adding a separate table for shareable pages. Implement the VMSAv6 versions of the Get*PTE and Decode*Entry functions.
Admin:
  Tested on Raspberry Pi 1, Raspberry Pi 3, Iyonix, RPCEmu (ARM6 & ARM7), comparing before and after CAM and page table dumps to check for any unexpected differences


Version 5.55. Tagged as 'Kernel-5_55'
@
text
@d713 1
a713 1
        SUBEQ   r10, r9, #CAM_EntrySizeLog2     ; then invalid page so go from last one
@


4.13
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d109 50
a158 15
AP_AppSpace     *       0                                       ; user r/w, CB
AP_SysHeap      *       0                                       ; user r/w, CB
AP_RMA          *       0                                       ; user r/w, CB
AP_Screen       *       0 :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped :OR: DynAreaFlags_NeedsSpecificPages
AP_Sprites      *       0                                       ; user r/w, CB
AP_FontArea     *       2                                       ; user none, CB
AP_RAMDisc      *       2 :OR: DynAreaFlags_NotCacheable        ; user none, ~CB (poor performance for current StrongARMs)
AP_RAMDisc_SA   *       2                                       ; user none, 
AP_Duff         *       2 :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable ; user none, ~C~B
AP_FreePool     *       2 :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_PMP
AP_CursorChunk  *       1 :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable :OR: PageFlags_Unavailable

AP_L2PT         *       2 :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable ; user none, ~C~B
AP_L1PT         *       AP_L2PT :OR: PageFlags_Unavailable
AP_UndStackSoftCam *    PageFlags_Unavailable
a173 12
; Area handler reason codes

DAHandler_PreGrow       *       0
DAHandler_PostGrow      *       1
DAHandler_PreShrink     *       2
DAHandler_PostShrink    *       3
 [ ShrinkableDAs
DAHandler_TestShrink    *       4       ; new reason added to find amount area could shrink by
 ]
DAHandler_Abort         *       5       ; ROL abortable DAs
DAHandler_ResizePMP     *       6       ; Called on OS_ChangeDynamicArea

d790 1
a790 1
        MOVHS   r11, #AP_Duff
a817 26
DAReason_Create          *  0
DAReason_Remove          *  1
DAReason_GetInfo         *  2
DAReason_Enumerate       *  3
DAReason_Renumber        *  4
 [ ShrinkableDAs
DAReason_ReturnFree      *  5   ;if ShrinkableDAs, else reason code invalid
 ]
 [ DynArea_QuickHandles
DAReason_GetChangeInfo   *  6   ;if DynArea_Quickhandles, else reason code invalid
DAReason_EnumerateInfo   *  7   ;if DynArea_Quickhandles, else reason code invalid
DAReason_SetClamps       *  8   ;if DynArea_Quickhandles, else reason code invalid
 ]
 [ DA_Batman
DAReason_SparseClaim     *  9   ;if DA_Batman, else reason code invalid
DAReason_SparseRelease   * 10   ;if DA_Batman, else reason code invalid
 ]
DAReason_LocateAddress   * 20
DAReason_PMP_PhysOp      * 21
DAReason_PMP_LogOp       * 22
DAReason_PMP_Resize      * 23
DAReason_PMP_GetInfo     * 24
DAReason_PMP_GetPages    * 25
DAReason_Limit           * 26   ;end of defined DA reasons


a822 46
; Bits in dynamic area flags (and page flags)
;
; rearranged slightly for Ursula - allow room for some expansion of DA flags in future without moving page flags
; mjs June 2001 merged the Ursula arrangement into HALised kernel
;
DynAreaFlags_APBits             * 15 :SHL:  0   ; currently only uses 2 bits, but may extend to allow svc/usr read-only
DynAreaFlags_NotBufferable      *  1 :SHL:  4
DynAreaFlags_NotCacheable       *  1 :SHL:  5
DynAreaFlags_DoublyMapped       *  1 :SHL:  6
DynAreaFlags_NotUserDraggable   *  1 :SHL:  7
DynAreaFlags_NeedsSpecificPages *  1 :SHL:  8   ; whether area will ever require particular physical pages
DynAreaFlags_Shrinkable         *  1 :SHL:  9   ; whether area may be shrunk when need more space in free pool
DynAreaFlags_SparseMap          *  1 :SHL: 10   ; whether area may have non-contiguous mapping of pages (Holey dynamic areas Batman!)
DynAreaFlags_PiersBinding       *  1 :SHL: 11   ; whether area is bound to client application, and so may be swapped out with it (not implemented yet)
DynAreaFlags_CPBits             *  7 :SHL: 12   ; cache policy variant for NotBufferable and NotCacheable bits

; Cache policies
;
CP_NCNB_Default                 * 0             ; no policy variants

CP_NCB_Default                  * 0             ; OS decides buffer policy (currently always MergingIdempotent)
CP_NCB_NonMerging               * 1             ; Non-merging write buffer. If not available, unbuffered.
CP_NCB_Merging                  * 2             ; Merging write buffer. If not available, non-merging.
CP_NCB_MergingIdempotent        * 3             ; Merging write buffer with idempotent memory (i.e. VMSA "Normal" non-cacheable type). If not available, merging write buffer.

CP_CNB_Default                  * 0             ; OS decides cache policy (writethrough). NCNB if not available
CP_CNB_Writethrough             * 1             ; Writethrough cacheable, non-buffered. If not available, NCNB.
CP_CNB_Writeback                * 2             ; Writeback cacheable, non-buffered. If not available,CNB_Writethrough.

CP_CB_Default                   * 0             ; OS decides cache policy (WB if available, W alloc if HAL requests)
CP_CB_Writethrough              * 1             ; Writethrough cacheable, read allocate. If not available, NCB_Merging
CP_CB_WritebackReadAlloc        * 2             ; Writeback cacheable, read allocate. If not available, writethrough.
CP_CB_WritebackWriteAlloc       * 3             ; Writeback cacheable, write allocate. If not available, WB/R.
CP_CB_AlternativeDCache         * 4             ; Use XScale/SA11x0 mini-data cache. If not available, CB_Default.

DynAreaFlags_NeedsDMA           *  1 :SHL: 15   ; only allocate from DMAable memory
; Bits 16-19 are used by RISCOS Ltd. We can reuse them for internal flags, but
; should probably avoid allocating any public flags.
DynAreaFlags_PMP                *  1 :SHL: 20   ; DA is backed by PMP/page is member of PMP

;
; Public page flags (note - may overlap DA flags)
; DynAreaFlags_[PMP]AccessMask also describes public page flags
;
PageFlags_Unavailable           *  1 :SHL: 15                      ; physical page has been claimed by someone for exclusive use (can't be requested by PreGrow handler or PMP PhysOp page list)

d4088 1
a4088 1
        MOV     r11, #AP_L2PT                           ; access privs (+CB bits)
d4575 1
a4575 1
        LDR     lr, =AP_FreePool :AND: DynAreaFlags_AccessMask
d4622 1
a4622 1
        LDR     lr, =AP_FreePool :AND: DynAreaFlags_AccessMask
d4740 1
a4740 1
        &       AP_FreePool
d4755 1
a4755 1
        &       AP_SysHeap
d4766 1
a4766 1
        &       AP_AppSpace
a5819 1
        LDR     r6, =L2PT
@


4.12
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a4177 3
  [ ECC
        LDR     lr, =L1_Page + L1_U + L1_P              ; form other bits to put in L1
  |
a4178 1
  ]
a5151 1
  [ EarlierReentrancyInDAShrink
a5158 1
  ]
@


4.11
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a524 3
; [ HAL32
;        LDREQ   r2, [r0, #RAMLIMIT+1]
; |
a525 1
; ]
a1229 1
  [ HAL
a1237 1
  ]
a3874 1
  [ HAL
a3878 1
  ]
a3930 1
 [ HAL
a3942 15
 |
        &       0,                      AplWorkMaxSize  ; application space
        &       UndStackSoftCamChunk,   1024*1024               ; undefined stack / soft cam map
        &       CursorChunkAddress,     1504*1024               ; cursor, Nowhere, cache cleaners, reserved (up to kernel buffers)
        &       L2PT,                   4*1024*1024             ; L2PT (and L1PT)
 [ OSROM_ImageSize > 8192
        &       &03000000,              8*1024*1024+OSROM_ImageSize*1024    ; I/O + ROM
 |
        &       &03000000,              16*1024*1024            ; I/O + ROM
 ]
        &       PhysSpace,              512*1024*1024   ; PhysSpace
 [ No26bitCode
        &       AbtStack,               AbtStackSize
 ]
 ] ; HAL
a3975 1
  [ HAL
a3979 1
  ]
a4791 4
; [ HAL32
;        ! 0, "Sort out FreePoolInitTable"
;        &       -1
; |
a4792 1
; ]
a7006 4
  [ LongCommandLines :LAND: (:LNOT: HAL)
AreaName_Kbuffs
        =       "Kernel buffers", 0
  ]
a7478 1
 [ HAL
a7482 1
 ]
@


4.10
log
@  Imported OS_Memory 12 from Ursula.
  Imported EarlierReentrancyinDAShrink fix from Ursula.
Detail:
  OS_Memory 12 allows the kernel to suggest physical pages to callers
    who need that sort of information without wanting to have them
    grub around in the page tables.
  EarlierReentrancyInDAShrink should allow RAMFS and FileCore to delete
    their RAMFS related dynamic areas when the Switcher is used to drag
    the RAM disc bar to zero.
Admin:
  Required by Interlace 0.63 or later.

Version 5.36. Tagged as 'Kernel-5_36'
@
text
@d17 77
a108 12
; The following flag controls the operation of ReadCMOSAndConfigure and FudgeConfigureRMA
;
; If false, then no memory is in the free pool to start off, and these routines just allocate pages
; starting at page R2, and update this on exit.
;
; If true, then routine InitDynamicAreas initially moves all non-static free memory into the free pool,
; and then the above routines just take pages off the end of that.

        GBLL    GetPagesFromFreePool    ; whether ReadCMOSAndConfigure extract pages from the free pool
GetPagesFromFreePool SETL NewCDA :LAND: {TRUE}

 [ ExpandedCamMap
a111 2
  [ NewStyle_Screen
   [ DAF_SpecifyBit
a112 6
   |
AP_Screen       *       0 :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped
   ]
  |
AP_Screen       *       0 :OR: DynAreaFlags_NotCacheable        ; user r/w, ~CB
  ]
d115 2
a116 1
AP_RAMDisc      *       2 :OR: DynAreaFlags_NotCacheable        ; user none, ~CB
d118 1
a118 3
  [ UseFreePool
AP_FreePool     *       2 :OR: DynAreaFlags_NotCacheable        ; user none, ~CB
  ]
d120 1
a120 2
AP_PageZero     *       0
  [ MEMM_Type = "ARM600"
d124 3
a127 16
 |
AP_AppSpace     *       0                                       ; user r/w
AP_SysHeap      *       0                                       ; user r/w
AP_RMA          *       0                                       ; user r/w
AP_Screen       *       0                                       ; user r/w
AP_Sprites      *       0                                       ; user r/w
AP_FontArea     *       2                                       ; user none
AP_RAMDisc      *       2                                       ; user none
AP_Duff         *       2
  [ UseFreePool
AP_FreePool     *       2                                       ; user none
  ]
AP_CursorChunk  *       1                                       ; user r-o
AP_PageZero     *       0                                       ; user r/w
 ]

a136 1
 [ UseFreePool
a137 3
 |
ChangeDyn_MaxArea    * 5
 ]
d148 2
d153 1
a153 1
NumPageBlockEntries *   32
d157 80
d242 2
a243 1
        MOV     r0, #0
d245 4
d288 1
a288 2
 [ MEMM_Type = "ARM600"
  [ 1 = 1
d291 1
a291 1
GetPageFlagsForR0IntoR6 ENTRY "R0-R2, R4-R5, R7"
d307 4
d312 1
a312 2
        LDR     r6, [r2, #MaxCamEntry]
        MOV     r5, #PhysRamTable
d326 1
a326 1
        MOV     r1, #0
d328 3
a330 1
        ADD     r1, r1, r2, LSL #3              ; point at cam entry (logaddr, PPL)
a351 3
  ]
 ]

d355 1
a355 1
;       r9 = MEMC CR
d362 1
a362 1
MoveCAMatR0toR3 ENTRY "r0,r1,r6,r7"
d375 4
d380 1
a380 2
        LDR     r6, [r2, #MaxCamEntry]
        MOV     r5, #PhysRamTable
d412 1
a412 1
StoreDebugRegs
d414 5
a418 4
        MOV     lr, #CamMapCorruptDebugBlock
        STMIA   lr, {r0-lr}
        LDR     r0, [sp, #1*4]                  ; reload stacked r0 (error pointer)
        STR     r0, [lr, #15*4]                 ; store in stacked PC position
d440 5
d450 43
d518 2
a519 1
        CMP     r0, #-1                         ; if finding out about app space
d521 7
d529 1
d541 3
d545 1
d549 3
a556 1
        LDR     r11, [r10, #DANode_Flags]       ; if doubly mapped
d558 16
a573 1
        SUBNE   r0, r0, r1                      ; then return start of 1st copy for compatibility
d594 1
a594 1
      MOV      R10, #0
d611 1
a611 1
        MOV     r14, #0
d615 1
a615 1
        LDR     r12, [r0], #4
d619 12
a630 1
        ADD     r11, r10, r12, LSL #3
d656 1
a656 1
        MOV     r14, #0
d659 1
a659 1
        ADD     r9, r14, r9, LSL #3             ; r9 -> first word of last entry in cam map
d667 10
a676 1
        ADD     r10, r14, r10, LSL #3           ; form address with 'guess' page
d680 1
a680 1
        LDR     r12, [r10]                      ; load address from guessed page
d694 1
a694 1
        SUBEQ   r10, r9, #8                     ; then invalid page so go from last one
d699 2
a700 2
        MOV     r5, #PhysRamTable
        SUB     r10, r14, #8
d707 3
a709 1
        ADDCS   r10, r10, r7, LSR #12-3         ; then advance CAM entry position
d712 1
a712 1
        ADD     r10, r10, r6, LSL #3            ; advance by 2 words for each page in this bank
d714 1
a714 1
        SUBCS   r10, r9, #8                     ; search from last one, to fail quickly (if CS)
d719 2
a720 1
        LDRNE   r12, [r10, #8]!                 ; then get logical address
d729 1
a729 1
        LDREQ   r12, [r10, #4]                  ; if match, then r12 = PPL
d731 1
a731 1
        MOVEQ   r10, r10, LSR #3
d742 1
a742 1
; Any address > 32M means "put the page out of the way"
d745 5
d754 1
a754 2
; BangCamUpdate takes entry no in r2, logaddr to set to in r3
; r9 current MEMC, r11 = PPL
d757 1
a757 1
        MOV     r9, #0
d759 2
a760 1
        LDR     r9, [r9, #MEMC_CR_SoftCopy]
d766 1
d768 1
d772 6
d798 6
a803 5
DAReason_Create *       0
DAReason_Remove *       1
DAReason_GetInfo *      2
DAReason_Enumerate *    3
DAReason_Renumber *     4
d805 1
a805 4
DAReason_ReturnFree *   5
DAReason_Limit  *       6
 |
DAReason_Limit  *       5
d807 17
d827 2
d831 14
d846 8
a853 12
DynAreaFlags_APBits     *       15 :SHL: 0      ; currently only uses 2 bits, but may extend to allow svc/usr read-only
DynAreaFlags_NotBufferable *    1 :SHL: 4
DynAreaFlags_NotCacheable *     1 :SHL: 5
DynAreaFlags_DoublyMapped *     1 :SHL: 6
DynAreaFlags_NotUserDraggable * 1 :SHL: 7
 [ DAF_SpecifyBit
DynAreaFlags_NeedsSpecificPages *  1 :SHL: 8    ; whether area will ever require particular physical pages
 ]
 ; amg: renaissance... this is a mess!
 [ ShrinkableDAs
DynAreaFlags_Shrinkable *       1 :SHL: 9       ; whether area should be shrunk when need more space in free pool
DynAreaFlags_AccessMask *       DynAreaFlags_APBits :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped
d855 3
a857 1
; The following bits are only present in page flags
d859 5
a863 3
TempUncacheableShift    *       10
PageFlags_TempUncacheableBits   * 15 :SHL: TempUncacheableShift    ; temporary count of uncacheability, used by DMA mgr
PageFlags_Unavailable   *       1 :SHL: 14      ; physical page may not be requested by a PreShrink handler
d865 4
a868 1
; Temporary flags only used by kernel
d870 5
a874 3
PageFlags_Required      *       1 :SHL: 15      ; physical page asked for by handler
 |
DynAreaFlags_AccessMask *       DynAreaFlags_APBits :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped
d876 6
a881 1
; The following bits are only present in page flags
d883 4
a886 3
TempUncacheableShift    *       9
PageFlags_TempUncacheableBits   * 15 :SHL: TempUncacheableShift    ; temporary count of uncacheability, used by DMA mgr
PageFlags_Unavailable   *       1 :SHL: 13      ; physical page may not be requested by a PreShrink handler
d888 6
a893 1
; Temporary flags only used by kernel
a894 2
PageFlags_Required      *       1 :SHL: 14      ; physical page asked for by handler
 ]
d896 1
a896 1
DynamicAreaSWI ENTRY
d913 18
d932 15
d948 1
d950 1
a950 1

d980 10
a989 1
;               bits 8..31 = 0 (bits 8..12 are used in page flags, but not for areas)
d991 1
a991 1
;       r5 = maximum size of area, or -1 for total RAM size
d995 1
d1004 1
a1004 1
DynArea_Create ENTRY "r2,r6-r8"
d1008 11
d1020 1
d1023 1
d1035 2
d1040 16
d1062 2
d1066 22
d1090 31
a1120 1
        MOV     r10, #0
d1126 1
d1132 3
d1158 1
d1160 6
d1167 1
d1180 11
d1192 1
d1198 46
d1247 35
d1303 2
d1307 1
a1307 1
        MOV     r8, #DAList
d1311 1
a1311 1
        ASSERT  DANode_Link = 0
d1323 13
d1338 1
a1338 1
        Push    "r0, r1"
d1340 3
a1342 2
        LDR     r1, [sp, #2*4]                  ; reload requested size off stack
        SWI     XOS_ChangeDynamicArea
d1344 86
d1433 2
a1434 1
        MOV     r2, r0                          ; r2 = area number
d1437 1
a1437 1
        Pull    "r0, r1"
d1450 2
a1451 2
        MOV     r6, r2                          ; save pointer to DANode itself
        LDR     r2, [r6, #DANode_Title]
d1453 2
a1454 2
        MOV     r2, r6                          ; point r2 back at DANode
        Pull    "r0, r1"                        ; pull stacked registers, and drop thru to...
d1456 1
d1464 2
d1469 6
d1478 38
d1529 3
a1531 1
DynArea_Remove ENTRY
d1535 87
d1627 2
a1628 2
        RSB     r1, r2, #0              ; negate it
        SWI     XOS_ChangeDynamicArea
d1632 61
a1692 1
; Issue service to tell TaskManager
d1694 1
a1694 5
        Push    "r1, r2"
        MOV     r2, r1
        MOV     r1, #Service_DynamicAreaRemove
        BL      Issue_Service
        Pull    "r1, r2"
d1701 22
d1724 1
d1727 4
d1734 43
d1796 2
a1798 2
90
        SETV
d1822 3
d1826 1
d1831 1
a1831 1
        LDR     r2, [r10, #DANode_Size]
a1832 2
        LDR     r4, [r10, #DANode_Flags]
        LDR     r5, [r10, #DANode_MaxSize]
d1834 13
d1854 4
a1857 1
;       DynArea_Enumerate - Enumerate dynamic areas
d1861 1
a1861 2
; in:   r0 = reason code (3)
;       r1 = -1 to start enumeration, or area number to continue from
d1863 16
a1878 3
; out:  r1 = next area number or -1 if no next
;       r10-r12 may be corrupted
;       All other registers preserved
d1880 16
a1895 4
DynArea_Enumerate ALTENTRY
        CMP     r1, #-1                         ; if starting from beginning
        LDREQ   r10, [r1, #DAList+1]            ; then load pointer to 1st node
        BEQ     %FT10                           ; and skip
d1897 1
a1897 2
        BL      CheckAreaNumber                 ; else check valid area number
        BCC     UnknownDyn                      ; complain if passed in duff area number
d1899 395
d2295 1
d2299 10
a2308 1
        LDRNE   r1, [r10, #DANode_Number]       ; else return number
d2324 17
d2342 1
d2348 3
d2352 1
d2367 14
d2388 2
d2391 5
d2398 6
d2423 3
d2427 1
d2430 11
a2440 3
        MOV     r11, #DAList
        MOV     r2, #0
        LDR     r2, [r2, #FreePoolDANode + DANode_Size] ; start with current size of free pool
d2442 3
d2446 2
d2449 1
a2449 1
        EXIT    EQ                              ; then exit, with r2 = correct value
d2451 3
d2457 1
d2462 1
a2462 1
        ADD     r2, r2, r3                      ; add on amount if any
d2465 1300
d3766 3
d3783 5
a3787 2
CheckAreaNumber ENTRY
        MOV     r10, #DAList
d3797 8
d3807 43
d3869 1
a3869 1
CheckForOverlappingAreas ENTRY "r0-r5"
d3881 8
a3888 1
; First, check against list of fixed areas
d3905 2
a3908 1
        SETV
d3914 1
a3914 1
        MOV     lr, #DAList
d3939 14
d3955 1
a3955 1
        &       CursorChunkAddress,     64*1024                 ; 32K for cursor, 32K for "nowhere"
d3966 1
a3966 3
 [ ShadowROM
        &       &FF800000,              &007FFFFF       ; Shadow ROM (length has been bodged to avoid wrap problems)
 ]
d3988 1
a3988 1
AllocateAreaAddress ENTRY "r0-r2,r4-r7"
d3996 1
a3996 1
        MOV     r1, #DAList                             ; r1 is ptr into dyn areas list
d4000 7
d4011 1
a4011 1
        BCS     %BT10                                   ; then get another
d4028 2
a4031 1
        SETV
d4034 2
d4050 1
a4050 1
GetNextRange ENTRY "r7,r8"
d4095 1
a4095 1
AllocateBackingLevel2 ENTRY "r0-r8,r11"
d4138 3
a4140 3
        MOV     r1, #0
        LDR     r6, [r1, #FreePoolDANode + DANode_Size]
        SUBS    r6, r6, r4, LSL #12                     ; reduce free pool size by that many pages
d4148 1
d4155 1
a4155 16
        STR     r6, [r1, #FreePoolDANode + DANode_Size] ; if possible then update size

; after that we need to zero all these pages out (=> cause translation fault for area initially)

        LDR     r0, [r1, #FreePoolDANode + DANode_Base] ; r0 -> base of free pool
        ADD     r0, r0, r6                              ; r0 -> first byte we're taking out of free pool
        ADD     r6, r0, r4, LSL #12                     ; r6 -> byte after last in free pool
        Push    r8                                      ; save original logical address
        MOV     r8, #0                                  ; 0 => translation fault (note r1 already zero)
        MOV     r11, #0
        MOV     lr, #0
15
        STMIA   r0!, {r1,r8,r11,lr}                     ; store data
        TEQ     r0, r6
        BNE     %BT15
        Pull    r8
d4157 2
a4158 1
; now r0 -> after end of free pool (log addr)
d4169 26
a4194 4
        SUB     r0, r0, #4096                           ; move free pointer back
        Push    "r2,r4,r5"
        BL      MoveCAMatR0toR3                         ; else move page from end of free pool to r3
        Pull    "r2,r4,r5"
d4201 6
d4208 2
a4217 1
        ARM_flush_TLB r6                                ; junk TLB(s) (probably not needed)
d4224 6
d4240 2
a4243 1
        SETV
d4323 1
a4323 1
        mrs    ,r4,CPSR
d4325 1
a4325 1
        msr    ,CPSR_c,r1         ;protect critical manipulation from interrupt re-entry
d4338 1
a4338 1
        msr    ,CPSR_cf,r4        ;restore IRQ state
d4345 1
a4345 1
        msr    ,CPSR_cf,r4        ;restore IRQ state
d4358 1
a4358 1
        mrs    ,r4,CPSR
d4360 1
a4360 1
        msr    ,CPSR_c,r3         ;protect critical manipulation from interrupt re-entry
d4385 1
a4385 1
        msr    ,CPSR_cf,r4        ;restore IRQ state
d4392 1
a4392 1
        msr    ,CPSR_cf,r4        ;restore IRQ state
d4420 3
a4422 3
InitDynamicAreas ENTRY "r0-r8,r11"
        MOV     lr, #AppSpaceDANode
        ADR     r0, InitAppSpaceTable
d4426 2
a4427 2
        MOV     lr, #FreePoolDANode
        ADR     r0, InitFreePoolTable
a4428 1
        LDR     r5, [lr, #RAMLIMIT-FreePoolDANode] ; max size is RAMLIMIT
d4431 2
a4432 36

; We have to move all free pages (ie ones not occupied by the static pages) into the free pool
; The lowest numbered physical pages must be put in last, so that when ReadCMOSAndConfigure is
; called to put in the screen, it will get the pages starting at 0 (when the screen is created
; as a dynamic area, this limitation can be removed).

; The free pages consist of two chunks of pages, each of which having consecutive physical page
; numbers. We start at MaxCamEntry and move back until we hit the end of the statics (which are
; at the start of the 1st non-video-RAM chunk). We then separately do the video RAM.

        MOV     r11, r3                         ; r11 = PPL (inc CB) for free pool
        MOV     r3, r2                          ; r3 = base address of free pool, ie where to put stuff
        MOV     r5, #0                          ; r5 = amount of memory in free pool so far (and ptr to 0)
        LDR     r2, [r5, #MaxCamEntry]          ; r2 = 1st page to put in free pool
        LDR     r7, [r5, #VideoSize]            ; r7 = size of video RAM
        MOV     r7, r7, LSR #12                 ; r7 = page number of start of static chunk
        ASSERT  SoftCamMapSize = L2PTSize +4
        MOV     r0, #L2PTSize
        LDMIA   r0, {r0, r8}                    ; r0 = L2PTSize, r8 = SoftCamMapSize
        ADD     r8, r8, r0                      ; add sizes together
        ADD     r8, r8, #StaticPagesSize + UndStackSize ; + number of bytes used for other static bits
        ADD     r8, r7, r8, LSR #12             ; r8 = page number of 1st page in 1st chunk not used for statics
10
        CMP     r2, r8                          ; are we into statics already
        SUBCC   r2, r7, #1                      ; if so, then move to last page of video RAM
        MOVCC   r8, #0                          ; and move barrier so we never hit it again
        BL      BangCamUpdate
        ADD     r3, r3, #4096                   ; advance logical address
        ADD     r5, r5, #4096
        SUBS    r2, r2, #1                      ; decrement page number
        BCS     %BT10                           ; if we haven't gone negative, then loop

        MOV     lr, #FreePoolDANode             ; may be used below to update DAList head ptr
        STR     r5, [lr, #DANode_Size]          ; update size of free pool in node

; Now initialise the system heap by hand, so we can start creating dynamic areas
d4441 2
a4442 1
        MOV     r0, #0                          ; initialise module list to empty
d4444 4
d4449 1
a4449 1
        MOV     lr, #SysHeapDANode              ; initialise system heap node
d4453 4
a4456 1
        MOV     r0, #0
d4459 1
d4467 1
a4467 1
        MOV     r1,#ChocolateBlockArrays
d4498 2
a4499 1
        MOV     r0,#0
d4501 4
d4507 3
d4516 77
d4594 196
d4791 15
d4807 1
d4812 1
d4814 3
d4818 4
d4823 1
d4832 5
a4836 1
        &       FreePoolDANode                  ; link -> free pool node, since FreePoolAddress > SysHeapStart
a4865 2
ChangeDynamicSWI ROUT
        Push    "r0, r2-r9, r10, lr"
d4867 16
a4882 1
; and drop thru to ...
d4886 2
a4887 2
;       CheckForNewArea - Perform operation of OS_ChangeDynamicArea, if
;                         area is on new list
d4890 1
a4890 2
;       r1 = size of change
;       stack: r0,r2-r9,r10,lr
d4892 2
a4893 2
; out:  If not on list, then return to old routine at IsOldArea
;       Else perform operation and exit ourselves
d4896 15
a4910 6
CheckForNewArea ROUT
        MOV     r10, #0                         ; check we're not in an IRQ
        LDR     r10, [r10, #IRQsema]
        TEQ     r10, #0
        LDREQ   r10, [r10, #CDASemaphore]       ; now also check whether ChangeDynamicArea is already threaded
        TEQEQ   r10, #0
a4911 2
        MOV     r10, #1
        STR     r10, [r10, #CDASemaphore-1]     ; store non-zero value in CDASemaphore, to indicate we're threaded
d4917 7
d4929 4
d4934 2
d4943 34
a4976 1
        MOV     r5, #0
d4984 1
a4984 1
AreaShrink
d4992 2
a4993 2
        ADREQ   r12, AppSpaceDANode             ; then dest is appspace
        ADRNE   r12, FreePoolDANode             ; else dest is free pool
d4995 2
a4996 2
        ASSERT  DANode_MaxSize = DANode_Size +4
        ADD     r2, r12, #DANode_Size
d4998 6
d5006 6
a5011 8
 [ ShrinkableDAs
        CMP     r1, lr
        MOVHI   r1, lr                          ; r1 = the most we want to move if we could
        BLHI    GenNotAllMovedError             ; but if not all we still want error
        SUB     lr, r5, #1                      ; lr = pagesize mask
        BICS    r1, r1, lr                      ; a pagesize multiple
        BEQ     IssueServiceMemoryMoved
 ]
a5012 1
 [ ShrinkableDAs
d5014 6
a5019 3
        CMP     r2, r1
        BLCC    TryToShrinkShrinkables
        BCS     %FT15                           ; [we can now do it all]
d5023 1
a5023 10
        MOV     r1, r2                          ; move smaller amount
 |
        LDR     r2, [r11, #DANode_Size]         ; amount src could shrink
        CMP     r2, lr
        MOVCC   lr, r2                          ; lr = min(amount dest could grow, amount src could shrink)

        CMP     r1, lr
        BLS     %FT15

; we can't move all that is required, so move smaller amount
a5024 2
        MOV     r1, lr                          ; move smaller amount
 ]
d5030 1
d5032 4
a5035 1
        CMPNE   r12, #AppSpaceDANode            ; and dst <> appspace
d5063 10
d5074 32
a5105 3
        LDR     r1, [r12, #DANode_Base]         ; this is free pool or app space, so it can't be doubly mapped!
        LDR     r3, [r12, #DANode_Size]
        ADD     r1, r1, r3                      ; r1 -> address of 1st extra page
d5107 1
d5110 4
a5113 1
        AND     r6, r6, #DynAreaFlags_AccessMask
d5118 1
a5118 1
        DREG    r1, " to ", cc
d5121 14
a5134 2
        BL      MovePageAtR0ToR1WithAccessR6
        ADD     r1, r1, r5
d5137 13
d5151 1
a5151 4
        ADD     r3, r3, r2
        STR     r3, [r12, #DANode_Size]         ; store increased destination size
        EORS    lr, r12, #AppSpaceDANode        ; check if dest = appspace (if so lr:=0)
        STREQ   r3, [lr, #MemLimit]             ; update memlimit if so
d5171 3
d5177 8
d5188 2
a5189 1
        MOV     r4, #0                          ; indicate no page block (and ptr to semaphore)
d5191 4
d5201 73
a5273 1
AreaGrow
d5280 2
a5281 2
        ADREQ   r11, AppSpaceDANode             ; then src is appspace
        ADRNE   r11, FreePoolDANode             ; else src is free pool (may later be free+apl)
d5286 12
d5303 1
a5303 4

        LDR     r2, [r11, #DANode_Size]         ; amount src could shrink
        CMP     r11, #AppSpaceDANode            ; if appspace
        SUBEQ   r2, r2, #&8000                  ; then can't take away last 32K (0..&7FFF)
d5309 4
a5312 4
        CMP     r1, lr                          ; if enough room in dest
        CMPLS   r1, r2                          ; and enough space in src
        MOVLS   r3, r1                          ; then can do full amount
        BLS     %FT65                           ; so skip this bit
d5316 2
a5317 9
; if src = AplSpace then
;       (dest must be free pool)
;       move reduced amount
; else
;       (src must be free pool)
;       (dest <> AplSpace, cos that's a shrink!)
;       so check if adding aplspace would allow us to succeed
;       if it does then adjust registers, else give error
; endif
d5323 1
a5323 10

        CMP     r11, #AppSpaceDANode
        BNE     %FT62
        MOV     r1, lr
        CMP     r1, r2
        MOVHI   r1, r2                          ; move min(max addable to dest, max removable from src)

 [ DebugCDA2
        DREG    r1, "Dest is free pool, moving reduced amount of "
 ]
d5342 1
a5342 1
        CMP     r2, r1                          ; this should definitely set C=0 as required by TryToShrinkShrinkables
d5344 1
a5344 1
        BLCC    TryToShrinkShrinkables
d5353 5
a5357 4
        MOV     r4, #AppSpaceDANode
        LDR     r6, [r4, #DANode_Size]          ; get current size of apl space
        SUB     r6, r6, #&8000                  ; can't take away 0-&7FFF
        ADD     r3, r2, r6                      ; add on to amount we could remove from free pool
d5361 2
a5362 1
        DREG    r3, " making a total of "
d5365 25
a5389 13
        CMP     r1, lr                          ; if not enough room in dest
        CMPLS   r1, r3                          ; or src still doesn't have enough
        MOVHI   r1, #0                          ; then don't move any
        BHI     %BT61                           ; and return error

        MOV     r3, r1                          ; amount actually doing

        TEQ     r2, #0                          ; else check to see if there was any at all in free pool
        MOVEQ   r11, #AppSpaceDANode            ; if not, then just take from aplspace
        MOVEQ   r7, r3                          ; and do all

        MOVNE   r11, #0                         ; else make src indicator reflect that we need both
        MOVNE   r7, r2                          ; but save amount we are taking from freepool
d5391 1
d5394 1
a5394 7
        Push    "r10"
        MOV     r10, #0                         ; default value if apl space not involved
        CMP     r11, #AppSpaceDANode            ; if source = aplspace
        RSBEQ   r10, r3, #0                     ; then make amount -ve
        CMP     r11, #0                         ; if source = free and apl
        SUBEQ   r10, r7, r3                     ; then make it -(amount removing from apl space)
        MOVNE   r7, r3                          ; else set up r7 to be total amount (wasn't set up above)
a5400 5
        CMP     r10, #0                         ; if neither of the above then don't talk to app (CMP clears V)
        BLNE    CheckAppSpace                   ; else check app agrees
        Pull    "r10"
        BVS     ChangeDynError

d5404 1
a5404 3
        TEQ     r11, #0                         ; if taking from both free + apl
        MOVEQ   r11, #FreePoolDANode            ; then start with free
 [ DAF_SpecifyBit
d5406 2
a5407 1
        TST     lr, #DynAreaFlags_NeedsSpecificPages
a5419 6
        SUBS    r3, r3, r7                      ; subtract off what we just did

        MOVHI   r7, r3                          ; if not finished, then start 2nd half
        MOVHI   r11, #AppSpaceDANode            ; which is app space
        MOVHI   r2, r7, LSR #12
        BLHI    DoTheGrowNotSpecified
d5423 1
d5425 4
a5432 1
 ]
a5446 4
        SUBS    r3, r3, r7                      ; subtract off what we just did
        MOVHI   r7, r3                          ; if not finished, then start 2nd half
        MOVHI   r11, #AppSpaceDANode            ; which is app space
        BHI     %BT70                           ; and loop
d5459 1
a5459 1
GenNotAllMovedError ENTRY "r0"
d5470 2
d5497 4
d5507 3
d5513 2
a5514 1
        MOV     r0, #0
d5516 4
d5523 90
d5618 2
a5619 2
; in:   r1 = total amount we wish to have in src area (already limited by max_size of destination area)
;       r2 = current size of src area
d5621 1
a5621 1
;       r12 -> dst area node
d5624 1
a5624 1
; out:  r2 = new size of src area
d5628 2
a5629 1
TryToShrinkShrinkables Entry "r0,r1,r10"
d5634 2
a5635 2
        MOV     r10, #DAList
        ASSERT  DANode_Link = 0                 ; because DAList has only link
d5637 1
a5637 1
        LDR     r10, [r10, #DANode_Link]        ; and load next
a5640 2
        LDRNE   lr, [r10, #DANode_Flags]        ; and area is shrinkable
        TSTNE   lr, #DynAreaFlags_Shrinkable
d5643 6
a5648 2
        SUBS    r1, r1, r2                      ; r1 = amount we still need
        LDR     lr, [r10, #DANode_Size]         ; available size of this area
d5650 5
a5654 2
        MOVCC   r1, lr                          ; min(amount we need, size of this area)
        RSB     r1, r1, #0                      ; make negative - it's a shrink
d5656 2
a5657 1
        STR     r0, [r0, #CDASemaphore]         ; momentarily pretend we're not threaded
d5660 3
a5662 4
        MOV     r0, #1
        STR     r0, [r0, #CDASemaphore-1]       ; we're threaded again
        LDR     r1, [sp, #4]                    ; reload original r1
        LDR     r2, [r11, #DANode_Size]         ; get new size of src area
d5666 9
d5685 1
a5685 1
;       r11 -> src area
d5697 4
a5702 1
TotalAmount     #       4                       ; Total size of grow for this chunk (ie entry value of r3)
a5704 5

 [ DAF_SpecifyBit
DoTheGrowNotSpecifiedStackSize * :INDEX: @@      ; amount of stack needed for 'not specified' version
 ]

d5710 7
a5716 1
DoTheGrow ENTRY "r3,r5,r10-r12", DoTheGrowStackSize
d5723 1
d5733 1
d5750 5
a5754 7
        LDR     r0, [r11, #DANode_Base]
        LDR     r3, [r11, #DANode_Size]
        ADD     r0, r0, r3                      ; move r0 to point to after end of area
        SUB     r3, r3, r2                      ; reduce by amount moving from area
        STR     r3, [r11, #DANode_Size]         ; store reduced source size
        TEQ     r11, #AppSpaceDANode                    ; if just appspace
        STREQ   r3, [r11, #MemLimit-AppSpaceDANode]     ; then store in memlimit
d5760 1
a5760 1
        AND     r6, r6, #DynAreaFlags_AccessMask
d5762 1
d5769 15
d5794 13
d5812 3
d5819 1
a5819 1
        SUB     r0, r0, r5                      ; pre-decrement source pointer
d5821 1
a5821 1
        DREG    r0, "Moving page at ", cc
d5825 7
a5831 1
        BL      MovePageAtR0ToR1WithAccessR6ReturnPageNumber
d5837 8
d5849 7
d5864 1
a5864 1
37
d5891 2
a5893 1
        SETV
d5898 1
a5898 1
DoTheGrowPagesSpecified
d5903 2
a5904 1
        MOV     r0, #0
d5907 1
a5907 1
40
d5909 3
a5911 1
        ADD     r4, r0, r3, LSL #3              ; point at cam entry
d5917 1
a5917 1
        BNE     %BT37
d5919 1
a5919 1
        STR     lr, [r4, #4]                    ; and store back
d5921 1
a5921 1
; work out physical address direct from physical page number, NOT from logical address, since log addr may be 01F08000 (multiply mapped)
d5923 2
a5924 2
        MOV     r4, #PhysRamTable
42
d5927 1
a5927 1
        BCS     %BT42
d5934 2
a5935 1
        BNE     %BT40
d5939 1
d5944 1
a5944 24

  [ StrongARM
    ;
    ;Ahem! The data is moved to new pages by reading old pages via 'physical address' (flat copy of
    ;      physical space at virtual addr. 2G). This means data read may not be up to date wrt data in
    ;      StrongARM's write-back cache, and is a potential cache incoherency anyway (two virtual mappings
    ;      to one physical).
    ;      So, clean/flush StrongARM data cache wrt to pages first. Incidentally, since StrongARM does
    ;      not support burst read LDMs from uncacheable areas, the read is going to be a little slow anyway).
    ;
    ;
    ARM_number r0
    CMP     r0,#&A
    BLEQ    dtgps_SAcleanflush
  ]

  [ ARM810support
    ;
    ; ARM810 has writeback cache too
    ;
    ARM_number r0
    CMP     r0,#8
    BLEQ    dtgps_810cleanflush
  ]
d5949 5
a5953 7
        LDR     r0, [r11, #DANode_Base]
        LDR     r3, [r11, #DANode_Size]
        ADD     r0, r0, r3                      ; move r0 to point to after end of area
        SUB     r3, r3, r2                      ; reduce by amount moving from area
        STR     r3, [r11, #DANode_Size]         ; store reduced source size
        TEQ     r11, #AppSpaceDANode                    ; if appspace
        STREQ   r3, [r11, #MemLimit-AppSpaceDANode]     ; then update memlimit
d5959 6
a5964 2
        AND     r6, r6, #DynAreaFlags_AccessMask
        ORR     r6, r6, #PageFlags_Unavailable  ; set unavailable bit
d5967 1
a5967 1
        BEQ     %FT55                           ; [it's not, so skip all this, and r9 will be irrelevant]
d5972 36
a6007 1
        BEQ     %FT50                           ; [none, so skip all this]
d6009 1
d6013 1
a6013 1
45
d6018 15
a6032 1
        BNE     %BT45                           ; loop if more
d6034 1
a6034 1
50
d6036 1
a6036 1
55
d6041 2
a6042 2
        SUB     r2, r0, r2                      ; r2 = lowest address being removed from src
        MOV     r3, #0
d6050 1
d6052 1
a6052 1
60
d6055 36
a6090 1
        LDR     lr, [r3, r6, LSL #3]            ; lr = logical address for this page
d6093 1
a6093 1
;        DREG    lr, "at address "
d6095 1
a6095 1
        CMP     lr, r2                          ; check if address is one being taken from src anyway
d6097 1
a6097 1
        CMP     lr, r0
d6109 2
a6110 6
        SUB     r4, r4, r5                      ; go onto next page being taken from src
;        DREG    r4, "Considering address "

        LDR     lr, =L2PT
        LDR     lr, [lr, r4, LSR #10]           ; get L2PT entry (to get phys addr) for next free page
        MOV     r10, lr, LSR #12                ; r10 = phys addr >>> 12
d6112 2
a6113 15
; now convert phys addr to page number

        MOV     r6, #0
        MOV     r1, #PhysRamTable
66
        LDMIA   r1!, {r7, lr}                   ; load phys addr, size
        SUB     r7, r10, r7, LSR #12            ; number of pages into this bank
        CMP     r7, lr, LSR #12                 ; if more than there are here,
        ADDCS   r6, r6, lr, LSR #12             ; then advance page number by number of pages in this bank
        BCS     %BT66                           ; and go onto next bank

        ADD     r6, r6, r7                      ; advance page number by no. of pages into this bank

        ADD     r1, r3, r6, LSL #3              ; r1 -> cam entry for this page
        LDR     r1, [r1, #4]                    ; get PPL for this page
d6117 6
a6122 1
        MOV     r10, r10, LSL #12               ; make r10 proper phys addr
d6129 2
a6130 1
        BNE     %BT60
d6136 9
d6152 1
a6152 1
        mrs    ,r14, CPSR
d6155 7
d6163 2
d6167 5
d6173 27
a6199 1
        WritePSRc I_bit+SVC_mode, r6            ; disable IRQs round here
a6201 1
        LDR     lr, [r8, #PageBlockSize+0]      ; lr = page number of replacement page
d6204 61
a6264 1
        BEQ     %FT76                           ; and skip copy and first page move
d6266 68
a6333 3
        LDR     r0, [r0, lr, LSL #3]            ; r0 = log. address for replacement page (NB use logical address to write to, for cache consistency)
        LDR     r6, [r8, #8]                    ; r6 = physical address of src for copy
        ORR     r6, r6, #PhysSpace              ; must use physical address, as page may be mapped to 01F08000 along with others
d6335 1
a6335 1
72
d6339 17
a6355 1
        BNE     %BT72
d6359 1
d6361 2
a6362 2
        SUBS    r6, r6, #L2PT
        BCC     %FT74                           ; address is below L2PT
d6364 1
a6364 1
        BCS     %FT74                           ; address is above L2PT
d6379 11
a6389 1
74
d6392 13
a6404 5
        MOV     lr, #0
        LDR     lr, [lr, #CamEntriesPointer]    ; lr -> soft cam map
        ADD     lr, lr, #4                      ; point at PPLs, not addresses
        LDR     r2, [r8, #0]                    ; need to get PPL for page being replaced
        LDR     r11, [lr, r2, LSL #3]
d6409 29
d6439 2
a6440 1
76
d6444 4
d6449 1
d6451 1
d6453 1
a6453 1
        msr    ,CPSR_cf, lr
d6455 1
d6457 1
d6460 1
d6462 4
d6473 7
d6483 7
d6493 1
d6499 1
d6510 2
a6511 1
 [ DAF_SpecifyBit
d6530 4
a6533 1
DoTheGrowNotSpecified ENTRY "r3,r5,r10-r12", DoTheGrowNotSpecifiedStackSize
d6541 5
a6545 7
        LDR     r0, [r11, #DANode_Base]
        LDR     r3, [r11, #DANode_Size]
        ADD     r0, r0, r3                      ; move r0 to point to after end of area
        SUB     r3, r3, r2                      ; reduce by amount moving from area
        STR     r3, [r11, #DANode_Size]         ; store reduced source size
        TEQ     r11, #AppSpaceDANode                    ; if just appspace
        STREQ   r3, [r11, #MemLimit-AppSpaceDANode]     ; then store in memlimit
d6551 2
a6552 1
        AND     r6, r6, #DynAreaFlags_AccessMask
d6560 15
d6585 13
d6603 3
d6609 1
a6609 1
        SUB     r0, r0, r5                      ; pre-decrement source pointer
d6611 1
a6611 1
        DREG    r0, "Moving page at ", cc
d6615 7
a6621 1
        BL      MovePageAtR0ToR1WithAccessR6
d6626 8
d6638 7
a6648 2
 ] ; DAF_SpecifyBit

d6670 3
a6672 2
CheckAppSpace ENTRY "r0-r3"
        MOV     r2, #0
d6687 6
d6694 1
d6696 1
d6701 2
a6704 1
        SETV
d6716 3
d6722 9
d6746 1
a6746 1
CallPreShrink ENTRY "r0,r3,r4, r12"
a6770 1
        SETV
d6784 1
a6784 1
CallPostShrink ENTRY "r0,r3,r4, r12"
d6820 6
a6825 1
CallPreGrow ENTRY "r0,r4, r12"
d6830 1
d6837 1
d6840 2
a6841 1
        TEQ     r0, #0                                  ; if generic error returned
d6847 41
d6889 4
a6892 1
        EXIT
d6907 1
a6907 1
CallPostGrow ENTRY "r0,r3,r4, r12"
d6912 1
d6919 1
d6933 1
a6933 1
CallTestShrink ENTRY "r0,r4,r5, r12"
d6940 1
a6940 1
        MOV     r5, #0
d6953 1
a6953 1
        TEQ     r0, #0                                  ; if generic error returned
d6977 1
a6977 1
MovePageAtR0ToR1WithAccessR6 ENTRY "r2-r5,r11"
d6985 1
a6985 1
MovePageAtR0ToR1WithAccessR6ReturnPageNumber ENTRY "r3-r5,r11"
d7038 4
d7050 2
a7052 1
        SETV
d7065 1
a7065 1
PostShrink_Sprite ENTRY "r0"
d7069 1
a7069 1
        MOV     lr, #VduDriverWorkSpace
d7074 1
a7074 1
        MOV     r0, #0
d7094 1
a7094 1
PreShrink_Sprite ENTRY "r0"
d7116 108
a7223 1
DynAreaHandler_RAMDisc
d7231 1
d7234 1
a7234 1
PostShrink_RAMDisc ENTRY "r0-r6"
d7243 1
a7243 1
        MOV     r0, #0
d7277 2
a7278 2
PreShrink_RAMDisc ENTRY "r0-r5"
        MOV     r0, #0
d7292 2
a7295 1
        SETV
d7322 1
a7322 1
PostGrow_FontArea ENTRY "r0-r2"
d7326 1
a7326 1
        MOV     r1, #0
d7339 1
a7339 1
PreShrink_FontArea ENTRY "r0-r2"
a7369 1
; * Symbol NewStyle_Screen defined TRUE in GetAll
d7452 1
a7452 1
PreGrow_Screen  ENTRY   "r0-r2,r4"
d7454 1
d7456 3
a7458 1
        SWINE   XOS_RemoveCursors               ; if VDU inited, then remove cursors
d7460 1
a7460 1
        ADRL    r0, PageShifts-1
d7483 1
a7483 1
PostGrow_Screen ENTRY   "r0,r5"
d7508 1
a7508 1
PreShrink_Screen ENTRY   "R0-R2,R4-R5"
d7514 6
d7522 9
a7530 1
        LDR     R5, [R12, #ScreenSize]          ;get current minimum size
d7555 1
a7555 1
PostShrink_Screen ENTRY
d7562 100
@


4.9
log
@  Fixed "SWI &6D656D not known" system collapse.
  Fixed multiple internationalisation of error message.
Detail:
  Somebody had decided to write a comment that R0-R2 needed to be
    unstacked before exiting the dynamic area remove routine, but
    then forgot to do so.  The crash is the same each time, as the
    address of MessageTrans error buffer it was trying to return
    is the value mistakenly loaded in R15.
  Kernel doesn't try to translate error messages multiple times.
    Not only does this give rise to errors about not being able
    to translate error messages, but causes MessageTrans to have to
    search repeatedly for non-existant tokens, slowing things down
    enormously.
Admin:
  Tested in Ursula build.
  Not a complete fix - FileCore now leaks map & buffer dynamic areas
    whenever the RAM disc size is altered, but that needs to be fixed
    in FileCore (it needs to accept that OS_ChangeDynamicArea is not
    re-entrant and delete the DAs on a callback)

Version 5.26. Tagged as 'Kernel-5_26'
@
text
@d1949 4
@


4.9.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d167 1
a167 1
GetPageFlagsForR0IntoR6 Entry "R0-R2, R4-R5, R7"
d236 1
a236 1
MoveCAMatR0toR3 Entry "r0,r1,r6,r7"
a341 3
 [ HAL32
        LDREQ   r2, [r0, #RAMLIMIT+1]
 |
a342 1
 ]
d607 1
a607 1
DynamicAreaSWI Entry
d671 1
a671 1
DynArea_Create Entry "r2,r6-r8"
d856 1
a856 1
DynArea_Remove Entry
d1076 1
a1076 1
CheckAreaNumber Entry
d1108 1
a1108 1
CheckForOverlappingAreas Entry "r0-r5"
a1169 3
 [ HAL32
  ! 0, "Sort out FixedAreasTable"
 |
a1170 1
 ]
d1207 1
a1207 1
AllocateAreaAddress Entry "r0-r2,r4-r7"
d1259 1
a1259 1
GetNextRange Entry "r7,r8"
d1304 1
a1304 1
AllocateBackingLevel2 Entry "r0-r8,r11"
d1509 1
a1509 1
        MRS     r4,CPSR
d1511 1
a1511 1
        MSR     CPSR_c,r1         ;protect critical manipulation from interrupt re-entry
d1524 1
a1524 1
        MSR     CPSR_cf,r4        ;restore IRQ state
d1531 1
a1531 1
        MSR     CPSR_cf,r4        ;restore IRQ state
d1544 1
a1544 1
        MRS     r4,CPSR
d1546 1
a1546 1
        MSR     CPSR_c,r3         ;protect critical manipulation from interrupt re-entry
d1571 1
a1571 1
        MSR     CPSR_cf,r4        ;restore IRQ state
d1578 1
a1578 1
        MSR     CPSR_cf,r4        ;restore IRQ state
d1606 1
a1606 1
InitDynamicAreas Entry "r0-r8,r11"
a1633 3
 [ HAL
        ! 0, "Sort out static check in InitDynamicAreas"
 |
a1639 1
 ]
a1728 4
 [ HAL32
        ! 0, "Sort out FreePoolInitTable"
        &       -1
 |
a1729 1
 ]
a1753 4
 [ HAL32
        ! 0, "Sort out InitAppSpaceTable"
        &       -1
 |
a1754 1
 ]
d2150 1
a2150 1
GenNotAllMovedError Entry "r0"
d2284 1
a2284 1
DoTheGrow Entry "r3,r5,r10-r12", DoTheGrowStackSize
d2598 1
a2598 1
        MRS     r14, CPSR
d2664 1
a2664 1
        MSR     CPSR_cf, lr
d2717 1
a2717 1
DoTheGrowNotSpecified Entry "r3,r5,r10-r12", DoTheGrowNotSpecifiedStackSize
d2805 1
a2805 1
CheckAppSpace Entry "r0-r3"
d2859 1
a2859 1
CallPreShrink Entry "r0,r3,r4, r12"
d2898 1
a2898 1
CallPostShrink Entry "r0,r3,r4, r12"
d2934 1
a2934 1
CallPreGrow Entry "r0,r4, r12"
d2969 1
a2969 1
CallPostGrow Entry "r0,r3,r4, r12"
d2993 1
a2993 1
CallTestShrink Entry "r0,r4,r5, r12"
d3037 1
a3037 1
MovePageAtR0ToR1WithAccessR6 Entry "r2-r5,r11"
d3045 1
a3045 1
MovePageAtR0ToR1WithAccessR6ReturnPageNumber Entry "r3-r5,r11"
d3120 1
a3120 1
PostShrink_Sprite Entry "r0"
d3149 1
a3149 1
PreShrink_Sprite Entry "r0"
d3181 1
a3181 1
PostShrink_RAMDisc Entry "r0-r6"
d3224 1
a3224 1
PreShrink_RAMDisc Entry "r0-r5"
d3268 1
a3268 1
PostGrow_FontArea Entry "r0-r2"
d3285 1
a3285 1
PreShrink_FontArea Entry "r0-r2"
d3399 1
a3399 1
PreGrow_Screen  Entry   "r0-r2,r4"
d3427 1
a3427 1
PostGrow_Screen Entry   "r0,r5"
d3452 1
a3452 1
PreShrink_Screen Entry   "R0-R2,R4-R5"
d3485 1
a3485 1
PostShrink_Screen Entry
@


4.9.2.2
log
@More HAL work. IOMD HAL work in progress. Lots of my own little build
scripts. Don't touch this.

Version 5.35, 4.79.2.2. Tagged as 'Kernel-5_35-4_79_2_2'
@
text
@a1187 1
 [ :LNOT: HAL
a1189 1
 ]
@


4.9.2.3
log
@More HAL work. IOMD HAL fleshed out somewhat - system gets most of the way
through initialisation.

Version 5.35, 4.79.2.5. Tagged as 'Kernel-5_35-4_79_2_5'
@
text
@d342 3
a344 3
; [ HAL32
;        LDREQ   r2, [r0, #RAMLIMIT+1]
; |
d346 1
a346 1
; ]
d1174 3
a1176 3
; [ HAL32
;  ! 0, "Sort out FixedAreasTable"
; |
d1178 1
a1178 1
; ]
d1616 1
a1616 1
InitDynamicAreas Entry "r0-r8,r11,r12"
a1637 17
 [ HAL
        MOV     r11, r3                         ; r11 = PPL (inc CB) for free pool
        MOV     r6, r2                          ; r6 = base address of free pool, ie where to put stuff
        MOV     r5, #0                          ; r5 = amount of memory in free pool so far (and ptr to 0)
        LDR     r0, [r5, #InitUsedStart]
        ADD     r0, r0, #DRAMOffset_FirstFixed - DRAMOffset_L1PT
        BL      PhysAddrToPageNo
        MOV     r7, r0                          ; r7 = page number of start of static chunk
        LDR     r0, [r5, #InitUsedEnd]
        BL      PhysAddrToPageNo
        MOV     r8, r0                          ; r8 = page number of 1st page in 1st chunk not used for statics

        LDR     r2, [r5, #MaxCamEntry]          ; r2 = 1st page to put in free pool
        MOV     r3, r6                          ; r3 = base address of free pool, ie where to put stuff

        ! 0, "Sort out static check in InitDynamicAreas"
 |
d1644 3
a1740 1
 [ FreePoolAddress > SysHeapStart
d1742 4
d1747 1
a1747 1
        &       SysHeapDANode
a1748 7
        &       ChangeDyn_FreePool
; [ HAL32
;        ! 0, "Sort out FreePoolInitTable"
;        &       -1
; |
        &       FreePoolAddress
; ]
a1756 1
 [ FreePoolAddress > SysHeapStart
a1757 3
 |
        &       0
 ]
d1773 4
d1778 1
@


4.9.2.4
log
@Wahey! This version gives you a display.

It says "Abort on data transfer".
@
text
@d1187 1
a1188 1
        &       PhysSpace,              512*1024*1024   ; PhysSpace
a2654 10
 [ HAL
        SUB     sp, sp, #4
        Push    "r0,r1"
        MOV     r0, #0
        LDR     r1, [r8, #8]                    ; r1 = physical address of src for copy
        ADD     r2, sp, #8                      ; must use physical address, as page may be mapped to nowhere along with others
        BL      RISCOS_AccessPhysicalAddress
        MOV     r6, r0                          ; r6 = logical address of src for copy
        Pull    "r0,r1"
 |
a2657 1
 ]
a2662 4
 [ HAL
        Pull    "r0"
        BL      RISCOS_ReleasePhysicalAddress
 ]
@


4.9.2.5
log
@More L7200 HAL work
@
text
@d2667 1
a2668 1
        ADD     lr, r6, r5                      ; lr = end src address
@


4.9.2.6
log
@Added OS_Memory 12 and EarlierReentrancyInDAShrink
Imported from Kernel 5.36.
@
text
@a1989 4
  [ EarlierReentrancyInDAShrink
        MOV     r4, #0                          ; indicate no page block (and ptr to semaphore)
        STR     r4, [r4, #CDASemaphore]         ; OK to reenter now (we've done the damage)
  ]
@


4.9.2.7
log
@Stuff. A bit of touchscreen, I expect, and probably some other bits too.
@
text
@d113 1
a113 1
NumPageBlockEntries *   63
@


4.9.2.8
log
@more use of ARMops in page manipulation, change register usage of ARmops
tested by kernel boot to star prompt only

Version 5.35, 4.79.2.11. Tagged as 'Kernel-5_35-4_79_2_11'
@
text
@d1420 1
a1420 1
        ;;;ARM_flush_TLB r6                junk TLB(s) shouldn't be needed, would have to be ARMop now
d2477 1
a2477 1
; work out physical address direct from physical page number, NOT from logical address, since log addr may be Nowhere (multiply mapped)
d2499 24
d2650 1
a2650 2
        WritePSRc I_bit+SVC_mode, r6            ; disable IRQs round here (we don't want interrupt code to update
                                                ; the old mapping behind us while we're trying to copy it)
a2657 6
        ;mjs
        ; - if the old page is currently mapped in, copy normally
        ; - if the old page is not mapped in, copy via temporary mapping
        ; The old scheme, always copying from other mapping, had interrupt cache coherency hole, at least for
        ; ARM with writeback cache (bug in 3.7, fixed in Ursula, then lost)
 
d2659 2
a2660 8

        LDR     r6, [r8, #4]                    ;logical address of src page
        LDR     r3, =Nowhere
        TEQ     r6, r3                          ;will be 'Nowhere' if not mapped in
        BNE     %FT71

        ASSERT  HAL
        SUB     sp, sp, #4                      ; for oldp
d2668 4
a2671 2

71
d2678 4
a2681 7

        LDR     r0, [r8, #4]                    ;logical address of src page
        LDR     r3, =Nowhere
        TEQ     r0, r3

        Pull    "r0", EQ                        ; oldp
        BLEQ    RISCOS_ReleasePhysicalAddress
@


4.9.2.9
log
@Check-in of the few last-minute changes for the Customer L demo. Nothing
exciting, apart from an extended touchscreen API.

Version 5.35, 4.79.2.13. Tagged as 'Kernel-5_35-4_79_2_13'
@
text
@d1174 3
a1176 11
 [ HAL
        ! 0, "Sort out FixedAreasTable"
        &       0,                      AplWorkMaxSize  ; application space
        &       CursorChunkAddress,     64*1024                 ; 32K for cursor, 32K for "nowhere"
 [ OSROM_ImageSize > 8192
        &       &03000000,              8*1024*1024+OSROM_ImageSize*1024    ; I/O + ROM
 |
        &       &03000000,              16*1024*1024            ; I/O + ROM
 ]
        &       IO,                     &FFFFFFFF-IO    ; Kernel workspace (fix - what about dynamic allocs)
 |
d1178 1
d1187 1
d1192 1
a1195 1
 ] ; HAL
d2640 1
a2640 1

@


4.9.2.10
log
@  fix for accidental degeneracy of mapping during page swaps
Detail:
  page swap as part of PagesUnsafe/PagesSafe mechanism
Admin:
  not tested
@
text
@d2638 2
a2639 1
        BNE     %FT21
a2640 10
        ; if the same page, we can skip copy and just move needed page to destination
        ;
        Pull    "r0-r4,r7-r12"                  ; restore registers
        LDR     r2, [r8, #0]
        MOV     r3, r1
        LDR     r11, DestFlags
        BL      Call_CAM_Mapping                ; move needed page
        B       %FT76                           ; and continue

21
a2702 14
        ; mjs: old code moved pages in wrong order for MMU, creating a temporary degeneracy
        ; of two physical pages at same logical address - eg. undefined behaviour for cache writebacks
        ;
        ; so do it this way now:
        ; first, move needed page to destination (nothing there at present)
        ; this also moves page out of way for moving the replacement page in, see below
        ;
        LDR     r2, [r8, #0]
        MOV     r3, r1
        LDR     r11, DestFlags
        BL      Call_CAM_Mapping 

        ; next, move replacement page in
        ;
d2712 6
a2717 1
        BL      Call_CAM_Mapping
a2718 1
76
@


4.9.2.11
log
@Various L7200 tweaks, plus working ARM920T code.

Version 5.35, 4.79.2.17. Tagged as 'Kernel-5_35-4_79_2_17'
@
text
@d2638 1
a2638 2
        Pull    "r0-r4,r7-r12", EQ              ; then restore registers
        BEQ     %FT76                           ; and skip copy and first page move
d2640 10
d2712 11
a2722 12
        ; mjs
        ; OK, what we are about to do is:
        ;   1) move replacement page in (to replace needed page)
        ;   2) move needed page to required destination
        ; This order means that we don't leave a temporary hole at the logical address we're substituting,
        ; which is vital at least in the horrendous case where the logical page is itself used for L2PT.
        ; However, this means there is a potential temporary degeneracy in the caches, two physical pages
        ; having been seen at the same logical address (undefined behaviour).
        ; So, to be safe, we do a MMUChangingEntry first, for the logical page, which will clean/invalidate
        ; caches and invalidate TLBs, to avoid degeneracy. This is slight overkill in some cases, but vital
        ; to avoid serious grief in the awkward cases. Fortunately, these page substitutions are relatively
        ; rare, so performance is not critical.
d2724 2
d2735 1
a2736 7
        Push    "r0, r4"
        MOV     r0, r3
        MOV     r4, #0
        ARMop   MMU_ChangingEntry,,,r4
        Pull    "r0, r4"

        BL      Call_CAM_Mapping                ; move replacement page in
a2737 5
        LDR     r2, [r8, #0]
        MOV     r3, r1
        LDR     r11, DestFlags
        BL      Call_CAM_Mapping                ; move needed page to destination

@


4.9.2.12
log
@spectacular new OS_Memory reason codes
13 map permanent I/O space, return logical address
14 access temporary physical mapping
15 release temporary physical mapping
DA creation and I/O space creation now avoid collision if address
space fills

Version 5.35, 4.79.2.28. Tagged as 'Kernel-5_35-4_79_2_28'
@
text
@a760 8
  [ HAL
        ; update lower limit on IO space growth, if this DA exceeds previous limit
        LDR     r6, [r7, #IOAllocLimit]
        ADD     lr, r3, r5
        CMP     lr, r6
        STRHI   lr, [r7, #IOAllocLimit]
  ]

d1124 1
a1124 8
  [ HAL
        MOV     lr, #0
        LDR     r0, [lr, #IOAllocPtr]
        CMP     r5, r0                                  ; end must be below I/O space (allocated down from high memory)
        BHI     %FT20
  ]

; check against list of fixed areas
d1175 1
d1183 1
a1183 1
        &       IO,                     &FFFFFFFF-IO    ; Kernel workspace (code will also check dynamic value IOAllocPtr)
a1234 7
  [ HAL
        MOV     lr, #0
        LDR     r2, [lr, #IOAllocPtr]
        CMP     r7, r2
        BHI     %FT90                                   ; if we walked into IOspace (assumed higher than any DA space) then we failed
  ]
15
d1239 1
a1239 1
        BCS     %BT15                                   ; then get another
@


4.9.2.13
log
@Reimplement Lazy task swapping, an amusing idea from Ursula,
would have done it sooner but couldn't be bothered (humour).
Currently activates for all ARMs flagged as base-restored
abort model. No handling of eg. StrongARM pre-revT bug, but
then the kernel no longer runs on StrongARM (progress).
Still some details to fix: all aborts in current app space
assumed to be missing pages, but this must be fixed to
handle abort code in app space, things like debuggers
marking code read only.

Plus, small fixes:
  OS_Memory 8 returns vaguely useful info for RAM,VRAM
  in HAL build (temporary partial implementation)
  Broken handling of old BBC commands with (fx,tv etc)
  with no spaces fixed (fudgeulike code from Ursula,
  now 32-bit).

Version 5.35, 4.79.2.31. Tagged as 'Kernel-5_35-4_79_2_31'
@
text
@a2917 6
    [  ChocolateAMB
        BNE     %FT05
        BL      Do_AMB_MakeUnsparse             ; then ok to move memory, so undo laziness and exit
        CLRV
        EXIT
    |
a2918 1
    ]
a2919 1
05
a2937 3
  [ ChocolateAMB
        BL      Do_AMB_MakeUnsparse             ; undo laziness
  ]
a2939 9

    [ ChocolateAMB
Do_AMB_MakeUnsparse ROUT
        Push    "r0, lr"
        MOVS    r0, r10
        RSBMI   r0, r0, #0
        BL      AMB_MakeUnsparse  ;shrinking AppSpace, so make sure unsparse over area of shrink
        Pull    "r0, pc"
    ] ;ChocolateAMB
@


4.9.2.14
log
@Further work on Lazy task swapping:
  hooks to give correct mapping info for OS_Memory 0
  same for OS_ReadMemMapEntries
  same for OS_FindMemMapEntries
  Lazy fixup routine no longer assumes an abort in current
  app space must be a truant page. However, work in this
  area not complete (no support yet for abort handler code
  in app space itself, eg. for C trampoline)
Good to know this will be a big performance boost when
our products use one monolithic application (sarcasm).
Ta

Version 5.35, 4.79.2.32. Tagged as 'Kernel-5_35-4_79_2_32'
@
text
@d411 1
a411 1
        LDR     r12, [r0], #4                   ; page number
a414 9

   [ ChocolateAMB
        ;may need AMB to make mapping honest (as if not lazy), if page is in currently mapped app
        Push    "r0, lr"
        MOV     r0, r12                         ; page number to make honest
        BL      AMB_MakeHonestPN
        Pull    "r0, lr"
   ]

a451 9

   [ ChocolateAMB
        ;may need AMB to make mapping honest (as if not lazy), if page is in currently mapped app
        Push    "r0, lr"
        MOV     r0, r11                         ; logical address to make honest
        BL      AMB_MakeHonestLA                ; note, quickly dismisses non app space addresses
        Pull    "r0, lr"
   ]

d515 1
a515 1
; address of -1 means "put the page out of the way"
a516 5

; note, if ChocolateAMB, no MakeHonest consideration here, this SWI just
; changes the mapping of pages regardless of their current mapping, and
; assumes the caller knows what he is doing (ho ho)
;
@


4.9.2.15
log
@Merge in long command line support from Ursula kernel.
Look for LongCommandLine flag, command line size currently
set at 1k.
For HAL/32bit builds, the kernel buffer space is at high
(top bit set) address, which may break some code using signed
comparisons. So *beware* that there may be some latent
bugs in old kernel code using these buffers, not yet found.
One such bug, in s.Arthur2 found and fixed.
Tested moderately on ARM9 desktop build.
Lovely to reimplement things I did two and half years ago.

Version 5.35, 4.79.2.37. Tagged as 'Kernel-5_35-4_79_2_37'
@
text
@a64 1

d95 1
d97 3
d1224 1
a1224 1
        &       CursorChunkAddress,     1504*1024               ; cursor, Nowhere, cache cleaners, reserved (up to kernel buffers)
@


4.9.2.16
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d41 1
a41 1
GetPagesFromFreePool SETL {TRUE}
d43 1
d47 2
d50 6
d60 1
d62 1
d66 1
d70 16
a86 3
  [ DA_Batman
ChangeDyn_Batcall    * -3               ; special DA number to select Batman usage of OS_ChangeDynamicArea
  ]
a113 76
;
; mjs - performance enhancements (from Ursula, merged into HALised kernel June 2001)
; Workspace for acceleration of operations on a DA, by reducing need to traverse DA list.
;
; - accelerates allocating non-quick DA numbers to O(n) instead of laughable O(n*n), where n is no. of DAs
; - accelerates enumeration to O(n) instead of laughable O(n*n)
; - allocation of a quick handle (DA number) is O(1)
; - access of a DA node from a quick handle is O(1)
; - access of a DA node from a non-quick handle is O(1), if it repeats the most recent non-quick handle access (else O(n))
;
; - creation of a DA still has some O(n) work (requires search for address space), but is now rather quicker
; - removal of a DA is still O(n) (requires traversal of list in order to get previous node)
; - other uses of a DA with a quick handle (eg. get info, change size) avoid any O(n) work
;
; - all system handles will be quick.
; - non-system handles will be quick, except for very large numbers of DAs, or silly modules like the Wimp who insist on
;   their own silly DA number (the latter can still benefit from LastTreacleHandle - see below)
;
; Limitations:
; - does not allow anyone to choose their own DA number that clashes with the quick handle set - should not
;   be a problem since choosing own number reserved for Acorn use
; - does not allow anyone to renumber a DA with a quick handle - again, reserved for system use
; - DA names will be truncated to a maximum of 31 characters (or as defined below)
;
                                  GBLL DynArea_QuickHandles
DynArea_QuickHandles              SETL {TRUE}
;
      ;various bad things happen if DynArea_QuickHandles is FALSE (eg. some new API disappears)
      ;should remove FALSE build option to simplify source code next time kernel is updated (kept for reference/testing now)
      ASSERT DynArea_QuickHandles

                                  GBLL DynArea_NullNamePtrMeansHexString
DynArea_NullNamePtrMeansHexString SETL {TRUE} :LAND: DynArea_QuickHandles
;
  [ DynArea_QuickHandles
DynArea_MaxNameLength     * 31                      ;maximum length of DA name, excluding terminator (multiple of 4, -1)
DynArea_NumQHandles       * 256                     ;maximum no. of non-system quick handles available simultaneously
;
                          ^  0,R11
DynArea_TreacleGuess      # 4                       ;guess for next non-quick handle to allocate, if needed, is TreacleGuess+1
DynArea_CreatingHandle    # 4                       ;handle proposed but not yet committed, during DynArea_Create, or -1 if none
DynArea_CreatingPtr       # 4                       ;ptr to proposed DANode during DynArea_Create (invalid if CreatingHandle = -1)
DynArea_LastTreacleHandle # 4                       ;last non-quick handle accessed by a client (usually the Wimp), or -1 if none
DynArea_LastTreaclePtr    # 4                       ;ptr to DANode for last non-quick handle accessed (invalid if LastTreacleHandle = -1)
DynArea_LastEnumHandle    # 4                       ;last handle enumerated, or -1 if none
DynArea_LastEnumPtr       # 4                       ;ptr to DANode for last handle enumerated (invalid if LastEnumHandle = -1)
DynArea_ShrinkableSubList # 4                       ;sub list of dynamic areas that are Shrinkable (0 if none)
DynArea_OD6Signature      # 4                       ;signature of changes to non-system DAs since last call to OS_DynamicArea 6
                                                    ;bit  0 = 1 if any DAs have been created
                                                    ;bit  1 = 1 if any DAs have been removed
                                                    ;bit  2 = 1 if any DAs have been resized (excluding grow or shrink at creation or removal)
                                                    ;bit  3 = 1 if any DAs have been renumbered
                                                    ;bits 4-30   reserved (0)
                                                    ;bit 31 = 1 if next resize is not to update signature (used during create, remove)
DynArea_OD6PrevSignature  # 4                       ;previous signature, used to distinguish single from multiple changes
DynArea_OD6Handle         # 4                       ;handle of last DA that affected signature
DynArea_OD8Clamp1         # 4                       ;clamp value on area max size for OS_DynamicArea 0 with R5 = -1
                                                    ;(default -1, set by R1 of OS_DynamicArea 8)
DynArea_OD8Clamp2         # 4                       ;clamp value on area max size for OS_DynamicArea 0 with R5 > 0 (not Sparse)
                                                    ;(default -1, set by R2 of OS_DynamicArea 8)
DynArea_OD8Clamp3         # 4                       ;clamp value on area max size for OS_DynamicArea 0 for a Sparse area
                                                    ;(default 4G-4k, set by R3 of OS_DynamicArea 8)
DynArea_SortedList        # 4                       ;alphabetically sorted list of non-system areas, or 0 if none
DynArea_SysQHandleArray   # 4*(ChangeDyn_MaxArea+1) ;for system areas 0..MaxArea, word = ptr to DANode, or 0 if not created yet
DynArea_FreeQHandles      # 4                       ;index of first free quick handle, starting at 1 (or 0 for none)
DynArea_QHandleArray      # 4*DynArea_NumQHandles   ;1 word per quick handle
                                                    ; - if free, word = index of next free quick handle (or 0 if none)
                                                    ; - if used, word = ptr to DANode (must be > DynArea_NumQHandles)
;
DynArea_ws_size           *  :INDEX:@@               ;must be multiple of 4
;
            ASSERT DynArea_QHandleArray = DynArea_FreeQHandles +4
  ]
;


d160 2
a161 1

d220 3
a354 3
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; out: r10 -> node
  |
a355 1
  ]
d578 5
a582 6

DAReason_Create          *  0
DAReason_Remove          *  1
DAReason_GetInfo         *  2
DAReason_Enumerate       *  3
DAReason_Renumber        *  4
d584 4
a587 1
DAReason_ReturnFree      *  5   ;if ShrinkableDAs, else reason code invalid
d589 13
a601 8
 [ DynArea_QuickHandles
DAReason_GetChangeInfo   *  6   ;if DynArea_Quickhandles, else reason code invalid
DAReason_EnumerateInfo   *  7   ;if DynArea_Quickhandles, else reason code invalid
DAReason_SetClamps       *  8   ;if DynArea_Quickhandles, else reason code invalid
 ]
 [ DA_Batman
DAReason_SparseClaim     *  9   ;if DA_Batman, else reason code invalid
DAReason_SparseRelease   * 10   ;if DA_Batman, else reason code invalid
d603 6
a608 1
DAReason_Limit           * 11   ;end of defined DA reasons
d610 3
d614 1
a614 2
DynArea_NewAreas *      &100            ; Allocated area numbers start here
DynArea_NewAreasBase *  &04000000       ; Allocated area addresses start here
d616 3
a619 19
; Bits in dynamic area flags (and page flags)
;
; rearranged slightly for Ursula - allow room for some expansion of DA flags in future without moving page flags
; mjs June 2001 merged the Ursula arrangement into HALised kernel
;
DynAreaFlags_APBits             * 15 :SHL:  0   ; currently only uses 2 bits, but may extend to allow svc/usr read-only
DynAreaFlags_NotBufferable      *  1 :SHL:  4
DynAreaFlags_NotCacheable       *  1 :SHL:  5
DynAreaFlags_DoublyMapped       *  1 :SHL:  6
DynAreaFlags_NotUserDraggable   *  1 :SHL:  7
DynAreaFlags_NeedsSpecificPages *  1 :SHL:  8   ; whether area will ever require particular physical pages
DynAreaFlags_Shrinkable         *  1 :SHL:  9   ; whether area may be shrunk when need more space in free pool
DynAreaFlags_SparseMap          *  1 :SHL: 10   ; whether area may have non-contiguous mapping of pages (Holey dynamic areas Batman!)
DynAreaFlags_PiersBinding       *  1 :SHL: 11   ; whether area is bound to client application, and so may be swapped out with it (not implemented yet)
;
; bits 12..15 nominally reserved for future DA flags expansion
;
DynAreaFlags_AccessMask * DynAreaFlags_APBits :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped
;
d621 2
a622 2
;
TempUncacheableShift            * 16
d624 2
a625 2
PageFlags_Unavailable           *  1 :SHL: 20                      ; physical page may not be requested by a PreShrink handler
;
a626 2
;
PageFlags_Required              *  1 :SHL: 21                      ; physical page asked for by handler
d628 2
a647 2
 |
        B       DynArea_Unknown
d649 1
a649 17
 [ DynArea_QuickHandles
        B       DynArea_GetChangeInfo
        B       DynArea_EnumerateInfo
        B       DynArea_SetClamps
 |
        B       DynArea_Unknown
        B       DynArea_Unknown
        B       DynArea_Unknown
 ]
 [ DA_Batman
        B       DynArea_SparseClaim
        B       DynArea_SparseRelease
 |
        B       DynArea_Unknown
        B       DynArea_Unknown
 ]
;
d651 1
a651 1
;
d681 1
a681 7
;               bit  8 = 1 => area may require specific physical pages
;               bit  9 = 1 => area is shrinkable (only implemented if ShrinkableDAs)
;               bit 10 = 1 => area may be sparsely mapped (only implemented if DA_Batman)
;               bit 11 = 1 => area is bound to client application (allows areas to be overlayed in address space)
;                             not implemented yet, but declared in public API for Ursula
;               bits 12..15 reserved for future DA flag expansion (should be 0)
;               bits 16..31 reserved for internal page flags (should be 0)
a698 11
  [ DynArea_QuickHandles
        CMP     r1, #DynArea_NewAreas
        BLO     %FT06
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BLO     %FT08           ; can't choose your own quick handle
  ]

06
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber ; see if area number is unique
  |
a699 1
  ]
a701 1
08
a715 16
  [ DynArea_QuickHandles
10
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws ]
        LDR     r1, DynArea_FreeQHandles          ;get index of next available quick handle, if any free
        CMP     r1, #0
        ADDNE   r1, r1, #DynArea_NewAreas-1       ;compute quick handle from index
        BNE     %FT20
        LDR     r1, DynArea_TreacleGuess          ;last non-quick number allocated
12
        ADD     r1, r1, #1                        ; increment for next guess (collisions should be *very* rare)
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        MOVLO   r1, #DynArea_NewAreas+DynArea_NumQHandles
        BL      QCheckAreaNumber
        BCS     %BT12                             ; and try again
  |
a721 2
  ]

a725 30
  [ DynArea_QuickHandles
    ;
    ; apply clamps on max size, as set by last call to OS_DynamicArea 8
    ;
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
    [ DA_Batman
        TST     r4, #DynAreaFlags_SparseMap
        BEQ     DAC_notsparse
        LDR     r10, DynArea_OD8Clamp3   ; clamp for sparse dynamic area
        CMP     r5, r10                  ; if requested max size is > relevant clamp
        MOVHI   r5, r10                  ; then clamp it!
        LDR     r10, [sp]                ; requested initial size, from stack
        CMP     r5, r10
        MOVLO   r5, r10                  ; we must try to honour initial size (allowed to break clamp)
        MOV     r10, #0
        LDR     r11, [r10, #Page_Size]
        B       DAC_roundup
DAC_notsparse
    ]
        CMP     r5, #-1
        LDREQ   r10, DynArea_OD8Clamp1   ; clamp for max size requested of -1
        LDRNE   r10, DynArea_OD8Clamp2   ; clamp for max size requested of some specific value
        CMP     r5, r10                  ; if requested max size is > relevant clamp
        MOVHI   r5, r10                  ; then clamp it!
        LDR     r10, [sp]                ; requested initial size, from stack
        CMP     r5, r10
        MOVLO   r5, r10                  ; we must try to honour initial size (allowed to break clamp)
  ]

a731 1
DAC_roundup
a760 6
  [ DynArea_QuickHandles
    ;we save work and reduce stress on system heap by claiming only one block, consisting of node followed by
    ;string space (always maximum length, but typically not overly wasteful compared to 2nd block overhead)
    ;
        MOV     r3, #DANode_NodeSize + DynArea_MaxNameLength + 1
  |
a761 1
  ]
a773 11
  [ DA_Batman
        ;disallow some awkward flag options if SparseMap set (no error), and temporarily create as not sparse
        ;also disallow a DA handler
        TST     r4, #DynAreaFlags_SparseMap
        STREQ   r4, [r2, #DANode_Flags]
        BICNE   r7, r4, #DynAreaFlags_DoublyMapped + DynAreaFlags_NeedsSpecificPages + DynAreaFlags_Shrinkable + DynAreaFlags_SparseMap
        ORRNE   r7, r7, #DynAreaFlags_NotUserDraggable
        STRNE   r7, [r2, #DANode_Flags]
        MOVNE   r6, #0
        MOVNE   r7, #0
  |
a774 1
  ]
a790 35
  [ DynArea_QuickHandles

        ADD     r7, r2, #DANode_NodeSize
        STR     r7, [r2, #DANode_Title]
        Push    "r0"
        MOV     r0, #DynArea_MaxNameLength
        TEQ     r8, #0
    [ DynArea_NullNamePtrMeansHexString
        ASSERT  DynArea_MaxNameLength > 8
        BNE     %FT45
        Push    "r1, r2"
        MOV     r0, r1                          ;string is 8-digit hex of DA number
        MOV     r1, r7
        MOV     r2, #DynArea_MaxNameLength+1
        SWI     XOS_ConvertHex8
        Pull    "r1, r2"
        B       %FT55
    |
        BEQ     %FT50                           ;assume NULL ptr to mean no DA name
    ]
45
        LDRB    r6, [r8], #1
        STRB    r6, [r7], #1
        SUB     r0, r0, #1
        TEQ     r6, #0
        TEQNE   r0, #0
        BNE     %BT45
50
        MOV     r0, #0
        STRB    r0, [r7], #1
55
        Pull    "r0"

  |

a811 2
 ] ;DynArea_QuickHandles

a829 12
  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ;so XOS_ChangeDynamicArea can pick up the node we are still creating
        STR     r1, DynArea_CreatingHandle
        STR     r2, DynArea_CreatingPtr
        ;so initial grow won't leave resize signature
        LDR     lr, DynArea_OD6Signature
        ORR     lr, lr, #&80000000
        STR     lr, DynArea_OD6Signature
  ]

d832 1
a832 1
        Push    "r0, r1, r2"
d834 2
a835 2
        LDR     r1, [sp, #3*4]                  ; reload requested size off stack
        SWI     XOS_ChangeDynamicArea           ; deal with error - r0,r1,r2 still stacked
a836 86
        Pull    "r0, r1, r2"

  [ DynArea_QuickHandles
;
; Now put node on alphabetically sorted list
;
        Push    "r3,r4,r5,r7,r8,r9"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ADR     r8, DynArea_SortedList - DANode_SortLink ;so that [r8, #DANode_SortLink] addresses list header)
75
        MOV     r7, r8                       ; previous
        LDR     r8, [r7, #DANode_SortLink]
        TEQ     r8, #0
        BEQ     %FT78
        ;ho hum, UK case insensitive string compare
        LDR     r3, [r2, #DANode_Title]
        LDR     r9, [r8, #DANode_Title]
76
        LDRB    r4, [r3],#1
        uk_LowerCase r4,r11
        LDRB    r5, [r9],#1
        uk_LowerCase r5,r11
        CMP     r4, r5
        BNE     %FT77
        CMP     r4, #0
        BNE     %BT76
77
        BHI     %BT75
78
        STR     r2, [r7, #DANode_SortLink]
        STR     r8, [r2, #DANode_SortLink]
79
        Pull    "r3,r4,r5,r7,r8,r9"
  ] ;DynArea_QuickHandles

  [ DA_Batman
        TST     r4, #DynAreaFlags_SparseMap
        LDRNE   r11, [r2, #DANode_Flags]
        ORRNE   r11, r11, #DynAreaFlags_SparseMap ; set this in node now (after initial grow)
        STRNE   r11, [r2, #DANode_Flags]
        LDRNE   r11, [r2, #DANode_Size]
        LDRNE   lr,  [r2, #DANode_Base]
        ADDNE   r11, r11, lr
        STRNE   r11, [r2, #DANode_SparseHWM]      ; initial high water mark
  ]

  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]

        TST     r4, #DynAreaFlags_Shrinkable
        LDRNE   lr, DynArea_ShrinkableSubList
        STRNE   lr, [r2, #DANode_SubLink]
        STRNE   r2, DynArea_ShrinkableSubList   ;link onto front of Shrinkable sublist if Shrinkable

        MOV     lr, #-1
        STR     lr, DynArea_CreatingHandle      ;invalidate this now
        CMP     r1, #ChangeDyn_MaxArea
        BHI     %FT72
        ADR     lr, DynArea_SysQHandleArray
        STR     r2, [lr, r1, LSL #2]            ;system handle - store ptr to node for quick reference
        B       %FT80
72
        LDR     lr, DynArea_OD6Signature
        STR     lr, DynArea_OD6PrevSignature
        ORR     lr, lr, #1
        STR     lr, DynArea_OD6Signature
        STR     r1, DynArea_OD6Handle
        CMP     r1, #DynArea_NewAreas
        BLO     %FT80
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BHS     %FT74
        SUB     r10, r1, #DynArea_NewAreas
        ADR     lr, DynArea_QHandleArray
        LDR     r6, [lr, r10, LSL #2]           ;pick up index of next free quick handle
        STR     r6, DynArea_FreeQHandles        ;store as index of first free quick handle
        STR     r2, [lr, r10, LSL #2]           ;store ptr to node for quick reference
        B       %FT80
74
        LDR     r10, DynArea_TreacleGuess
        ADD     r10, r10, #1
        STR     r10, DynArea_TreacleGuess       ;non-quick handle allocated, increment for next allocate
80
  ] ;DynArea_QuickHandles

d840 1
a840 2
        Push    "r0, r1, r2"
        MOV     r2, r1                          ; r2 = area number
d843 1
a843 1
        Pull    "r0, r1, r2"
d856 2
a857 2
  [ :LNOT: DynArea_QuickHandles
        LDR     r2, [r2, #DANode_Title]
d859 2
a860 2
  ]
        Pull    "r0, r1, r2"                    ; pull stacked registers, and drop thru to...
a861 1
  [ :LNOT: DynArea_QuickHandles
a868 2
  ]

a871 6
  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        MOV     lr, #-1
        STR     lr, DynArea_CreatingHandle
  ]
a888 2

        ;*MUST NOT USE QCheckAreaNumber* (need r11 = previous)
a891 29
  [ DA_Batman
        Push    "r11"
        LDR     r11,[r10,#DANode_Flags]
        TST     r11,#DynAreaFlags_SparseMap
        Pull    "r11"
        BEQ     DAR_notsparse
        Push    "r0,r2-r3"
        MOV     r0,#DAReason_SparseRelease
        LDR     r2,[r10,#DANode_Base]
        LDR     r3,[r10,#DANode_MaxSize]
        SWI     XOS_DynamicArea            ;release all pages in sparse area
        STRVS   r0,[SP]
        Pull    "r0,r2-r3"
        EXIT    VS
        B       DAR_delink
DAR_notsparse
  ]

  [ DynArea_QuickHandles
        Push    "r11"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ;so final shrink won't leave resize signature
        LDR     lr, DynArea_OD6Signature
        ORR     lr, lr, #&80000000
        STR     lr, DynArea_OD6Signature
        Pull    "r11"
  ]

d902 1
a902 1
DAR_delink
d904 5
a908 21
  [ DynArea_QuickHandles
;
; delink from sorted list
;
        Push    "r7,r8,r11"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ADR     r8, DynArea_SortedList - DANode_SortLink ;so that [r8, #DANode_SortLink] addresses list header)
DAR_sdloop
        MOV     r7, r8                      ;previous
        LDR     r8, [r7, #DANode_SortLink]
        TEQ     r8, #0                      ;just in case not on list, shouldn't happen
        BEQ     DAR_sddone
        TEQ     r8, r10
        BNE     DAR_sdloop
        LDR     r8, [r8, #DANode_SortLink]
        STR     r8, [r7, #DANode_SortLink]
DAR_sddone
        Pull    "r7,r8,r11"

  ] ;DynArea_QuickHandles
a914 22
  [ DynArea_QuickHandles
        ;if it is a Shrinkable area, find on Shrinkable sublist and remove it
        Push    "r0-r2, r11"
        LDR     r0, [r10, #DANode_Flags]
        TST     r0, #DynAreaFlags_Shrinkable
        BEQ     %FT06
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ADR     r1, DynArea_ShrinkableSubList
        LDR     r2, [r1]
04
        CMP     r2, r10
        LDREQ   r2, [r2, #DANode_SubLink]
        STREQ   r2, [r1]
        BEQ     %FT06
        ADD     r1, r2, #DANode_SubLink
        LDR     r2, [r2, #DANode_SubLink]
        B       %BT04
06
        Pull    "r0-r2, r11"
  ]

a915 1
  [ :LNOT: DynArea_QuickHandles
a917 1
  ]
a920 43

  [ DynArea_QuickHandles
        Push    "r2, r3"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        MOV     r2,#-1
        STR     r2, DynArea_CreatingHandle                ; invalidate these, just in case
        STR     r2, DynArea_LastTreacleHandle
        STR     r2, DynArea_LastEnumHandle
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT08                                     ; system area being removed
        LDR     r2, DynArea_OD6Signature
        STR     r2, DynArea_OD6PrevSignature
        ORR     r2, r2, #2
        STR     r2, DynArea_OD6Signature
        STR     r1, DynArea_OD6Handle
        CMP     r1, #DynArea_NewAreas
        BLO     %FT10
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BHS     %FT10
        SUB     r2, r1, #DynArea_NewAreas-1               ; index of quick handle
        ADR     r10, DynArea_FreeQHandles                 ; so we can index array from 1
        LDR     r3, DynArea_FreeQHandles
        STR     r3, [r10, r2, LSL #2]
        STR     r2, DynArea_FreeQHandles                  ; put on front of free list
        B       %FT10
08
        ADR     r10, DynArea_SysQHandleArray
        MOV     r2,  #0
        STR     r2,  [r10, r1, LSL #2]                    ; reset system Qhandle
10
        Pull    "r2, r3"

  ]

; Issue service to tell TaskManager

        Push    "r0, r1, r2"
        MOV     r2, r1
        MOV     r1, #Service_DynamicAreaRemove
        BL      Issue_Service
        Pull    "r0, r1, r2"

a965 3
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
a966 1
  ]
a982 385
;       DynArea_GetChangeInfo
;
;       Get info on changes to *non-system* dynamic areas
;       Reserved for Acorn use (intended for TaskManager, can only serve one client)
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (6)
;
; out:  r1 = Number of affected area, if a single change has occurred since last call,
;          = -1, if no changes or more than one change have occurred
;       r2 = signature of changes to non-system dynamic areas since last call to
;            OS_DynamicArea 6
;            bit 0 = 1 if any non-system areas have been created
;            bit 1 = 1 if any non-system areas have been removed
;            bit 2 = 1 if any non-system areas have been resized
;            bit 3 = 1 if any non-system areas have been renumbered
;            bits 4-31 reserved (undefined)
;
;Notes:
; (1) bit 2 of r2 excludes the initial grow of a created area, and the final
;     shrink of a removed area
; (2) if a single renumber has occurred, r1 is the old number

  [ DynArea_QuickHandles

DynArea_GetChangeInfo ROUT
        Push    "lr"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        LDR     r1, DynArea_OD6Handle
        LDR     r2, DynArea_OD6Signature
        LDR     lr, DynArea_OD6PrevSignature
        CMP     lr, #0
        MOVNE   r1, #-1
        CMP     r2, #0
        MOVEQ   r1, #-1
        MOV     lr, #0
        STR     lr, DynArea_OD6Signature
        STR     lr, DynArea_OD6PrevSignature
        CLRV
        Pull    "PC"

  ] ;DynArea_QuickHandles

;**************************************************************************
;
;       DynArea_EnumerateInfo
;
;       Enumerate *non-system* dynamic areas, returning selected info
;       Reserved for Acorn use (intended for TaskManager)
;
; in:   r0 = reason code (7)
;       r1 = -1 to start enumeration, or area number to continue from
;
; out:  r1 = number of next area found, or -1 if no more areas
;       r2 = current size of area, if area found
;       r3 = base logical address, if area found
;       r4 = area flags, if area found
;       r5 = maximum size of area, if area found
;       r6 -> title string, if area found
;
;Notes:
; (1) r2-r6 on exit are undefined if r1 = -1
;

  [ DynArea_QuickHandles

DynArea_EnumerateInfo ROUT
        Push    "lr"

        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]

        CMP     r1, #-1                         ; if starting from beginning
        LDREQ   r10, DynArea_SortedList         ; then load pointer to 1st node on sorted list
        BEQ     %FT10                           ; and skip

        LDR     r10, DynArea_LastEnumHandle
        CMP     r10, r1
        LDREQ   r10, DynArea_LastEnumPtr        ; pick up where we left off
        BEQ     %FT08
        BL      QCheckAreaNumber                ; else check valid area number
        BCC     %FT14

08
        LDR     r10, [r10, #DANode_SortLink]    ; find next one
10
        TEQ     r10, #0                         ; if at end
        MOVEQ   r1, #-1                         ; then return -1
        BEQ     %FT12
        LDR     r1, [r10, #DANode_Number]       ; else return number
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %BT08                           ; skip if system area

        LDR     r2, [r10, #DANode_Size]         ; return rest of info
        LDR     r3, [r10, #DANode_Base]
        LDR     r4, [r10, #DANode_Flags]
        LDR     r5, [r10, #DANode_MaxSize]
        LDR     r6, [r10, #DANode_Title]

        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        STR     r1, DynArea_LastEnumHandle
        STR     r10, DynArea_LastEnumPtr        ; save a lot of messing about on next call
12
        CLRV
        Pull    "PC"

;it's a reserved call, so naff off internationalisation
14
        ADR     r0,DynArea_badei
        SETV
        Pull    "PC"
DynArea_badei
        DCD     0
        DCB     "bad DA number",0
        ALIGN

  ] ;DynArea_QuickHandles

;**************************************************************************
;
;       DynArea_SetClamps
;
;       Set clamps on max size of dynamic areas created by subsequent
;       calls to OS_DynamicArea 0
;
;   On entry
;       R0 = 8 (reason code)
;       R1 = limit on maximum size of (non-Sparse) areas created by
;            OS_DynamicArea 0 with R5 = -1, or 0 to read only
;       R2 = limit on maximum size of (non-Sparse) areas created by
;            OS_DynamicArea 0 with R5 > 0, or 0 to read only
;       R3 = limit on maximum size of Sparse areas created by
;            OS_DynamicArea 0 with R4 bit 10 set, or 0 to read only
;
;   On exit
;       R1 = previous limit for OS_DynamicArea 0 with R5 = -1
;       R2 = previous limit for OS_DynamicArea 0 with R5 > 0
;       R3 = previous limit for OS_DynamicArea 0 with R4 bit 10 set
;
;       Specifying -1 in R1 or R2 means the respective limit
;       is the RAM limit of the machine (this is the default).
;       Specifiying larger than the RAM limit in R1 or R2 is
;       equivalent to specifiying -1.
;
  [ DynArea_QuickHandles

DynArea_SetClamps ROUT
        Push    "r9,lr"

        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]

        LDR     r10, DynArea_OD8Clamp1
        LDR     lr,  DynArea_OD8Clamp2
        LDR     r9,  DynArea_OD8Clamp3

;insist on at least 1M for a clamp value (ignore anything lower)
;
        CMP     r1, #&100000
        STRHS   r1, DynArea_OD8Clamp1
        CMP     r2, #&100000
        STRHS   r2, DynArea_OD8Clamp2
        CMP     r3, #&100000
        STRHS   r3, DynArea_OD8Clamp3

        MOV     r1, r10
        MOV     r2, lr
        MOV     r3, r9

        CLRV
        Pull    "r9,PC"

  ] ;DynArea_QuickHandles

;**************************************************************************

;       DynArea_SparseClaim
;
;  Ensure region of sparse dynamic area is mapped to valid memory
;
; in:   r0 = reason code (9)
;       r1 = area number
;       r2 = base of region to claim
;       r3 = size of region to claim
;
; out:  r0-r3 preserved (error if not all of region successfully mapped)
;       r10-r12 may be corrupted
;
; action: - round base and size to page granularity
;         - scan the L2PT for each page covered
;         - find contiguous fragments of 1 or more pages that are not yet mapped-in
;         - pass each of these fragments as a psuedo DANode to OS_ChangeDynamicArea
;           via special Batcall), to 'grow' pages into each fragment
;
  [ DA_Batman

DynArea_SparseClaim ROUT
        Push    "r0-r9,lr"
        MOV     r4,#1                   ; flags operation as a claim

DynArea_SparseChange                    ; common entry point for claim and release

  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     DA_naffsparse           ; area not there

        LDR     r9,[r10,#DANode_Flags]
        TST     r9,#DynAreaFlags_SparseMap
        BEQ     DA_naffsparse           ; area not sparse

        MOV     r9,#&1000               ;page size
        SUB     r9,r9,#1
        ADD     r3,r3,r2                ;base+size
        CMP     r4,#1
        BICEQ   r2,r2,r9                ;round base down to page granularity for claim
        ADDEQ   r3,r3,r9
        BICEQ   r3,r3,r9                ;round base+size up to page granularity for claim
        ADDNE   r2,r2,r9
        BICNE   r2,r2,r9                ;round base up to page granularity for release
        BICNE   r3,r3,r9                ;round base+size down to page granularity for release
        SUB     r3,r3,r2                ;rounded size

        ADD     r9,r3,r2
        LDR     r5,[r10,#DANode_Base]
        LDR     r6,[r10,#DANode_MaxSize]
        ADD     r6,r6,r5
        CMP     r2,r5
        CMPHS   r9,r5
        BLO     DA_naffsparse
        CMP     r2,r6
        CMPLS   r9,r6
        BHI     DA_naffsparse

        ADD     r5,r2,r3                   ;base+size of mapping
        LDR     r6,[r10,#DANode_SparseHWM] ;high water mark = highest claim base+size seen
        CMP     r4,#1
        BEQ     %FT08
        CMP     r5,r6
        SUBHI   r3,r6,r2                   ;for release we can save work by trimming to high water mark
        B       %FT09                      ;r3 is now trimmed size (may be <=0 for trim to nothing)
08
        CMP     r5,r6
        STRHI   r5,[r10,#DANode_SparseHWM] ;for claim remember highest base+size as high water mark
09
        SUB     SP,SP,#DANode_NodeSize  ;room for temporary DANode on stack
        MOV     r9,r10                  ;actual sparse area DANode
        MOV     r5,SP
        MOV     r6,#DANode_NodeSize
10
        LDR     r7,[r9],#4           ;copy sparse area node to temp node
        STR     r7,[r5],#4
        SUBS    r6,r6,#4
        BNE     %BT10
        ADD     r3,r2,r3             ;stop address
;
        MOV     r5,#L2PT
        ADD     r5,r5,r2,LSR #10     ;r5 -> L2PT for base (assumes 4k page)
        MOV     r8,r2                ;start address
;
;look for next fragment of region that needs to have mapping change
20
        CMP     r8,r3
        BHS     %FT50                ;done
        LDR     r6,[r5],#4           ;pick-up next L2PT entry
        CMP     r4,#0                ;if operation is a release...
        CMPEQ   r6,#0                ;...and L2PT entry is 0 (not mapped)...
        ADDEQ   r8,r8,#&1000         ;...then skip page (is ok)
        BEQ     %BT20
        CMP     r4,#0                ;if operation is a claim (not 0)...
        CMPNE   r6,#0                ;...and L2PT entry is non-0 (mapped)...
        ADDNE   r8,r8,#&1000         ;...then skip page (is ok)
        BNE     %BT20
        MOV     r1,#&1000            ;else we need to do a change (1 page so far)
30
        ADD     r9,r8,r1
        CMP     r9,r3
        BHS     %FT40
        LDR     r6,[r5],#4           ;pick-up next L2PT entry
        CMP     r4,#1                ;if operation is a release (not 1)...
        CMPNE   r6,#0                ;...and L2PT entry is non-0 (mapped)...
        ADDNE   r1,r1,#&1000         ;...then count page as needing change
        BNE     %BT30
        CMP     r4,#1                ;if operation is a claim...
        CMPEQ   r6,#0                ;...and L2PT entry is 0 (not mapped)...
        ADDEQ   r1,r1,#&1000         ;...then count page as needing change
        BEQ     %BT30
;set up pseudo DA and do Batcall to change mapping of fragment we have found
40
        MOV     r2,SP                  ;temp DANode
        STR     r8,[r2,#DANode_Base]
        ADD     r8,r8,r1
        ADD     r8,r8,#&1000           ;next address to check after fragment
        CMP     r4,#1
        MOVEQ   r9,#0                  ;start size of 0 for claim
        MOVNE   r9,r1                  ;start size of fragment size for release
        STR     r9,[r2,#DANode_Size]
        STR     r1,[r2,#DANode_MaxSize]
        MOV     r0,#ChangeDyn_Batcall
        CMP     r4,#0
        RSBEQ   r1,r1,#0               ;batshrink for release, batgrow for claim
        SWI     XOS_ChangeDynamicArea
        CMP     r4,#0
        RSBEQ   r1,r1,#0
        LDR     r9,[r10,#DANode_Size]
        ADD     r9,r9,r1
        STR     r9,[r10,#DANode_Size]
        BVC     %BT20
;
50
        ADD     SP,SP,#DANode_NodeSize   ;drop temp DANode
        BVS     %FT52
        BL      DA_sparse_serviceandsig
        Pull    "r0-r9,PC"
;
52
        BL      DA_sparse_serviceandsig
        SETV
        STR     r0,[SP]
        Pull    "r0-r9,PC"

DA_naffsparse
        ADR     r0,DA_naffsparseinnit
        SETV
        STR     r0,[SP]
        Pull    "r0-r9,PC"
DA_naffsparseinnit
        DCD     0
        DCB     "invalid OS_DynamicArea sparse claim/release",0
        ALIGN

DA_sparse_serviceandsig ROUT
        Push    "r0,LR"
        LDR     r1,[r10,#DANode_Number]
   [ DynArea_QuickHandles
        MOV     r11,#0
        LDR     r11,[r11, #DynArea_ws]
        LDR     r5,DynArea_OD6Signature
        STR     r5,DynArea_OD6PrevSignature
        ORR     r5,r5,#4                     ;signal a resize
        STR     r5,DynArea_OD6Signature
        STR     r1,DynArea_OD6Handle
   ]
        MOV     r2,r1                    ;area number
        MOV     r0,#0                    ;nominal 'grow/shrink' of 0 for service call
        MOV     r1,#Service_MemoryMoved
        BL      Issue_Service
        Pull    "r0,PC"

  ] ;DA_Batman

;**************************************************************************
;
;       DynArea_SparseRelease
;
;  Allow region of sparse dynamic area to release memory to free pool
;
; in:   r0 = reason code (10)
;       r1 = area number
;       r2 = base of region to release
;       r3 = size of region to release
;
; out:  r0-r3 preserved (error if not all of region successfully released)
;       r10-r12 may be corrupted
;
;
; action: - similar to DynArea_SparseClaim, but does 'shrinks' on fragments
;           that are mapped in

  [ DA_Batman

DynArea_SparseRelease ROUT
        Push    "r0-r9,lr"
        MOV     r4,#0                   ; flags operation as a release
        B       DynArea_SparseChange    ; jump to common code

  ] ;DA_Batman

;**************************************************************************
;
a994 4
  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
  ]
a995 3
  [ DynArea_QuickHandles
        LDREQ   r10, DynArea_SortedList         ; then load pointer to 1st node on sorted list
  |
a996 1
  ]
a998 7
  [ DynArea_QuickHandles
        LDR     r10, DynArea_LastEnumHandle
        CMP     r10, r1
        LDREQ   r10, DynArea_LastEnumPtr        ; pick up where we left off
        BEQ     %FT08
        BL      QCheckAreaNumber                ; else check valid area number
  |
a999 1
  ]
a1001 4
08
  [ DynArea_QuickHandles
        LDR     r10, [r10, #DANode_SortLink]    ; find next one
  |
a1002 1
  ]
d1006 1
a1006 10
        BEQ     %FT12
        LDR     r1, [r10, #DANode_Number]       ; else return number

  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        STR     r1, DynArea_LastEnumHandle
        STR     r10, DynArea_LastEnumPtr        ; save a lot of messing about on next call
  ]
12
a1021 17
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT92                           ; can't renumber a system area
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT92
  [ DynArea_QuickHandles
        CMP     r1, #DynArea_NewAreas
        BLO     %FT10
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BLO     %FT92                           ; can't renumber a quick handle
10
        CMP     r2, #DynArea_NewAreas
        BLO     %FT12
        CMP     r2, #DynArea_NewAreas+DynArea_NumQHandles
        BLO     %FT92                           ; can't choose your own quick handle
12
        BL      QCheckAreaNumber
  |
a1022 1
  ]
a1027 3
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; check area r2 doesn't already exist
  |
a1028 1
  ]
a1042 14
  [ DynArea_QuickHandles
        MOV     r11, #0                         ; we know system areas cannot be renumbered
        LDR     r11, [r11, #DynArea_ws]
        MOV     r10, #-1
        STR     r10, DynArea_CreatingHandle     ; invalidate these, just in case
        STR     r10, DynArea_LastTreacleHandle
        STR     r10, DynArea_LastEnumHandle
        LDR     lr, DynArea_OD6Signature
        STR     lr, DynArea_OD6PrevSignature
        ORR     lr, lr, #8
        STR     lr, DynArea_OD6Signature
        STR     r1, DynArea_OD6Handle
  ]

a1053 10
;if you think this is worth internationalising, I pity you
92
        ADR     r0, DynArea_NaughtyRenum
        SETV
        EXIT
DynArea_NaughtyRenum
        DCD     0
        DCB     "illegal DA renumber",0
        ALIGN

a1071 3
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; else check area number is valid
  |
a1072 1
  ]
d1075 1
a1077 9
  [ DynArea_QuickHandles
        ;traverse the Shrinkable sublist
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        LDR     r11, DynArea_ShrinkableSubList
        B       %FT21
  |
        MOV     r11, #DAList
  ]
a1078 3
  [ DynArea_QuickHandles
        LDR     r11, [r11, #DANode_SubLink]     ; load next area on sublist
  |
a1079 2
  ]
21
a1082 3
  [ DynArea_QuickHandles
        TEQ     r11, r10                        ; must not be the excluded area
  |
a1085 1
  ]
a1108 3
  [ DynArea_QuickHandles
QCheckAreaNumber_nonQ
  ]
a1118 8
  [ DynArea_QuickHandles
        Push    "r11"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        STR     r1,  DynArea_LastTreacleHandle
        STR     r10, DynArea_LastTreaclePtr
        Pull    "r11"
  ]
a1120 43
  [ DynArea_QuickHandles

; QCheckAreaNumber - similar to CheckAreaNumber, but blisteringly quick for system or for quick
;                    numbers. However, DOES NOT return previous node in r11.
;
QCheckAreaNumber ROUT
        Push    "lr"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        CMP     r1, #-1
        BEQ     QCheckAreaNumber_nonQ           ;just to protect against -1 as a proposed number
        LDR     lr, DynArea_LastTreacleHandle
        CMP     lr, r1
        LDREQ   r10, DynArea_LastTreaclePtr
        EXIT    EQ                              ;found node is slow one we handled last time (carry set)
        LDR     lr, DynArea_CreatingHandle
        CMP     lr, r1
        LDREQ   r10, DynArea_CreatingPtr
        EXIT    EQ                              ;found node is one we're creating (carry set)
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT10
        CMP     r1,#DynArea_NewAreas
        BLO     QCheckAreaNumber_nonQ
        SUB     lr, r1, #DynArea_NewAreas
        CMP     lr, #DynArea_NumQHandles
        BHS     QCheckAreaNumber_nonQ
;quick handle
        ADR     r10, DynArea_QHandleArray
        LDR     r10, [r10, lr, LSL #2]
        CMP     r10, #DynArea_NumQHandles
        MOVLS   r10, #0                         ;not a valid pointer
        CMP     r10, #1
        Pull    "pc"                            ;handle free, carry clear
                                                ;or word is ptr to node, carry set
;system handle
10
        ADR     r10, DynArea_SysQHandleArray
        LDR     r10, [r10, r1, LSL #2]
        CMP     r10, #1
        Pull    "pc"                            ;DA does not exist, carry clear
                                                ;or word is ptr to node, carry set
  ] ;DynArea_QuickHandles

a1794 60
  [ DynArea_QuickHandles

        LDR     r3, =DynArea_ws_size
        BL      ClaimSysHeapNode                    ; should not give error - kernel boot
        MOV     r0, #0
        STR     r2, [r0, #DynArea_ws]
        MOV     r11, r2
        LDR     r3, =DynArea_ws_size
        ADD     r3, r3, r2
DynArea_QHinit_loop1
        STR     r0, [r2], #4
        CMP     r2, r3
        BLO     DynArea_QHinit_loop1

        MOV     r1, #-1
        STR     r1, DynArea_CreatingHandle
        STR     r1, DynArea_LastTreacleHandle
        STR     r1, DynArea_LastEnumHandle
        STR     r1, DynArea_OD8Clamp1
        STR     r1, DynArea_OD8Clamp2
        MOV     r1, #&1000
        RSB     r1, r1, #0
        STR     r1, DynArea_OD8Clamp3               ; 4G - 4k

        ADR     r1, DynArea_QHandleArray            ; init all Qhandles as free, free list = 1..DynArea_NumQHandles
        MOV     r2, #1
        STR     r2, DynArea_FreeQHandles
DynArea_QHinit_loop2
        ADD     r2, r2, #1
        STR     r2, [r1], #4
        CMP     r2, #DynArea_NumQHandles
        BLO     DynArea_QHinit_loop2
        MOV     r2, #0
        STR     r2, [r1]                            ; 0 = end of free list

        MOV     r1, #DynArea_NewAreas-1
        ADD     r1, r1, #DynArea_NumQHandles        ; first non-quick DA number -1
        STR     r1, DynArea_TreacleGuess

        LDR     r1, =FreePoolDANode
        STR     r1, DynArea_SortedList              ; initially, FreePool at front of sorted list,
        LDR     r2, =SysHeapDANode
        STR     r2, [r1, #DANode_SortLink]          ; and SysHeap second...
        MOV     r1, #0
        STR     R1, [r2, #DANode_SortLink]          ; ...and last

        ADR     r1, DynArea_SysQHandleArray
        MOV     r2, #SysHeapDANode
        STR     r2, [r1, #ChangeDyn_SysHeap:SHL:2]
        MOV     r2, #FreePoolDANode
        STR     r2, [r1, #ChangeDyn_FreePool:SHL:2]

  |

        MOV     r0, #0
        STR     r0, [r0, #DynArea_ws]

  ] ;DynArea_QuickHandles

        MOV     r0, #0
d1855 6
d1863 2
a1864 2
;       ChangeDynamicSWI - implement OS_ChangeDynamicArea (change the
;                          size of a dynamic area)
d1867 2
a1868 1
;       r1 = size of change (in bytes, signed integer)
d1870 2
a1871 6
; out:  r0   preserved
;       r1 = actual amount moved (in bytes, unsigned integer)
;

  [ DA_Batman
;OR, a special call is allowed for internal use:
a1872 8
; in:   r0 = ChangeDyn_Batman (-3)
;       r1 = size of change (in bytes, signed integer)
;       r2 -> pseudo DANode for this call - base of DA will be base of fragment to map/unmap,
;             magnitude of r1 will give size of fragment, sign of r1 is +ve for map -ve for unmap
  ]

ChangeDynamicSWI ROUT
        Push    "r0, r2-r9, r10, lr"
d1874 1
a1887 7
  [ DA_Batman
    ;check for special Batman call (which uses OS_ChangeDynamicArea to map or unmap a fragment of a sparse DA)
        CMP     r0, #ChangeDyn_Batcall
        MOVEQ   r10, r2                         ; Batman call passes a pseudo DANode in r2
        BEQ     CDA_handlechecked
  ]

a1892 4

  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; check area number is on list
  |
a1893 2
  ]

a1900 27
  [ DA_Batman
        ;a sparse area is not allowed to do an ordinary grow or shrink
        ;
        LDR     r11, [r10, #DANode_Flags]
        TST     r11, #DynAreaFlags_SparseMap
        BNE     failure_IRQgoingClearSemaphore
  ]

CDA_handlechecked

  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        LDR     r5, DynArea_OD6Signature
        CMP     r0, #ChangeDyn_MaxArea
        BLS     daq_cda_od6done
        CMP     r0, #&FFFFFFF0                  ;don't count special DA numbers, such as ChangeDyn_AplSpace
        BHI     daq_cda_od6done
        TST     r5, #&80000000                  ;if set, disables resize signature for this call
        STREQ   r5, DynArea_OD6PrevSignature
        STREQ   r0, DynArea_OD6Handle
        ORREQ   r5, r5, #4
daq_cda_od6done
        BIC     r5, r5, #&80000000              ;clear any disable
        STR     r5, DynArea_OD6Signature
  ]

d2182 1
a2182 1

d2211 1
a2277 4
  [ DA_Batman
        CMP     r0, #ChangeDyn_Batcall
        BEQ     ISMM_BatCloak           ; cloaking device (no service issue)
  ]
a2283 3
  [ DA_Batman
ISMM_BatCloak
  ]
d2367 1
d2369 1
d2815 1
d2899 2
a3234 4
  [ LongCommandLines :LAND: (:LNOT: HAL)
AreaName_Kbuffs
        =       "Kernel buffers", 0
  ]
d3453 1
@


4.9.2.17
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a412 1
        LDR     r11, [r10, #DANode_Flags]       ; if doubly mapped
d415 1
a604 1
 [ {FALSE}
a605 1
 ]
a667 20
DynAreaFlags_CPBits             *  7 :SHL: 12   ; cache policy variant for NotBufferable and NotCacheable bits

; Cache policies
;
CP_NCNB_Default                 * 0             ; no policy variants

CP_NCB_Default                  * 0             ; OS decides buffer policy (currently always coalescing)
CP_NCB_NonMerging               * 1             ; Non-merging write buffer. If not available, unbuffered.
CP_NCB_Merging                  * 2             ; Merging write buffer. If not available, non-merging.

CP_CNB_Default                  * 0             ; OS decides cache policy (writethrough). NCNB if not available
CP_CNB_Writethrough             * 1             ; Writethrough cacheable, non-buffered. If not available, NCNB.
CP_CNB_Writeback                * 2             ; Writeback cacheable, non-buffered. If not available,CNB_Writethrough.

CP_CB_Default                   * 0             ; OS decides cache policy (WB if available, W alloc if HAL requests)
CP_CB_Writethrough              * 1             ; Writethrough cacheable, read allocate. If not available, NCB_Merging
CP_CB_WritebackReadAlloc        * 2             ; Writeback cacheable, read allocate. If not available, writethrough.
CP_CB_WritebackWriteAlloc       * 3             ; Writeback cacheable, write allocate. If not available, WB/R.
CP_CB_AlternativeDCache         * 4             ; Use XScale/SA11x0 mini-data cache. If not available, CB_Default.

d669 1
a669 1
; bits 15 nominally reserved for future DA flags expansion
d671 1
a671 1
DynAreaFlags_AccessMask * DynAreaFlags_APBits :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped :OR: DynAreaFlags_CPBits
d2170 1
a2170 1
        &       &03800000,              OSROM_ImageSize*1024   ; ROM
d2172 1
a2172 1
        &       &03800000,              8*1024*1024            ; ROM
a2414 3
 [ ECC
        LDR     lr, =L1_Page + L1_U + L1_P              ; form other bits to put in L1
 |
a2415 1
 ]
a2655 3
        SUB     lr, r8, r7
        SUB     lr, r2, lr
        ADD     r3, r3, lr, LSL #12             ; r3 = end address of free pool
a2657 9
10
        CMP     r2, r8                          ; are we into statics already
        SUBCC   r2, r7, #1                      ; if so, then move to last page of video RAM
        MOVCC   r8, #0                          ; and move barrier so we never hit it again
        BL      BangCamUpdate
        SUB     r3, r3, #4096                   ; advance logical address
        ADD     r5, r5, #4096
        SUBS    r2, r2, #1                      ; decrement page number
        BCS     %BT10                           ; if we haven't gone negative, then loop
d2671 1
a2680 1
 ]
a3054 1
        LDR     lr, =DynAreaFlags_AccessMask
d3057 1
a3057 1
        AND     r6, r6, lr
a3312 2
        LTORG

d3485 1
a3485 1
        LDR     lr, =DynAreaFlags_AccessMask
a3486 1
        AND     r6, r6, lr
d3626 1
a3626 2
        LDR     lr, =DynAreaFlags_AccessMask
        AND     r6, r6, lr
a3879 2
        LTORG

d3918 1
a3918 2
        LDR     lr, =DynAreaFlags_AccessMask
        AND     r6, r6, lr
a4602 1
        LDRB    lr, [WsPtr, #ExternalFramestore]
d4604 1
a4604 3
        BEQ     %FT05
        TEQ     lr, #0
        SWIEQ   XOS_RemoveCursors               ; if VDU inited, then remove cursors
d4606 1
a4606 1
05      ADRL    r0, PageShifts-1
a4659 6
 [ HAL
        MOV     LR, #0
        LDR     LR, [LR, #VRAMFlags]            ;is VRAM suitable for general use?
        TST     LR, #2                          ;if not - don't shrink screen memory
        MOVNE   R3, #0
 ]
d4662 1
a4662 9
        LDRB    R14, [R12, #ExternalFramestore]
        TEQ     R14, #0                         ;okay to shrink if using external framestore
        BEQ     %FT12
        RSB     R0, R3, #0                      ;R0= -(number of bytes) for RemovePages
        BL      RemovePages
        CLRV
        EXIT

12      LDR     R5, [R12, #ScreenSize]          ;get current minimum size
@


4.9.2.18
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d49 1
a49 2
AP_RAMDisc      *       2 :OR: DynAreaFlags_NotCacheable        ; user none, ~CB (poor performance for current StrongARMs)
AP_RAMDisc_SA   *       2                                       ; user none, 
a2189 1
 [ CursorChunkAddress < IO
a2190 2
 ]
 [ ROM < IO
a2195 1
 ]
a2431 5
        MOV     lr, #ZeroPage
        LDR     r6, [lr, #L2PTUsed]
        ADD     r6, r6, #4096
        STR     r6, [lr, #L2PTUsed]

a2739 3
 [ FreePoolAddress < SysHeapStart
        MOV     lr, #FreePoolDANode             ; cf comments above/below - what was old code? KJB
 ]
a2938 2
        LDREQB  r10, [r10, #VRAMRescue_control] ; also check that wimp has not locked Free Pool
        TSTEQ   r10, #VRRc_wimp_lock
@


4.9.2.19
log
@Fix error handling for sparse dynamic area resize operations (for main HAL branch)
Detail:
  s/ChangeDyn - Swap CMP with TEQ to avoid accidental clobbering of V flag before its state is checked on return from a SWI. Errors encounterd during sparse dynamic area resize operations (OS_DynamicArea 9 & 10) should now be reported properly.
Admin:
  Not tested, but the same fix has been proven to work on the Cortex branch.


Version 5.35, 4.79.2.104. Tagged as 'Kernel-5_35-4_79_2_104'
@
text
@d1734 1
a1734 1
        TEQ     r4,#0
@


4.9.2.20
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d171 1
a171 2
        LDR     r0, =ZeroPage
      [ ZeroPage = 0
a172 4
      |
        MOV     r10, #0
        STR     r10, [r0, #CDASemaphore]
      ]
d231 1
a231 1
        LDR     r2, =ZeroPage
d233 1
a233 4
        ADD     r5, r2, #PhysRamTable
      [ ZeroPage <> 0
        MOV     r2, #0
      ]
d247 1
a247 1
        LDR     r1, =ZeroPage
d294 1
a294 1
        LDR     r2, =ZeroPage
d296 1
a296 4
        ADD     r5, r2, #PhysRamTable
      [ ZeroPage <> 0
        MOV     r2, #0
      ]
d328 1
a328 1
StoreDebugRegs ; Note: Corrupts R0,R1
d330 4
a333 5
        LDR     lr, =ZeroPage+CamMapCorruptDebugBlock
        STMIA   lr, {r0-r12}
        STR     sp, [lr, #13*4]!
        LDMIA   sp, {r0,r1}                     ; reload stacked LR & return R0 (error pointer)
        STMIB   lr, {r0,r1}                     ; LR -> LR, error -> PC
a385 1
      [ ZeroPage = 0
a386 4
      |
        LDREQ   r1, =ZeroPage
        LDREQ   r1, [r1, #AplWorkSize]
      ]
d439 1
a439 1
      LDR      R10, =ZeroPage
d456 1
a456 1
        LDR     r14, =ZeroPage
d499 1
a499 1
        LDR     r14, =ZeroPage
d542 1
a542 1
        LDR     r5, =ZeroPage+PhysRamTable
d598 1
a598 1
        LDR     r9, =ZeroPage
d831 1
a831 1
        LDR     r11, =ZeroPage
d861 1
a861 1
        LDR     r11, =ZeroPage
d872 1
a872 1
        LDR     r10, =ZeroPage
d887 1
a887 1
        LDR     r10, =ZeroPage
a963 3
      [ ZeroPage <> 0
        LDR     r7, =ZeroPage
      ]
d1032 1
a1032 1
        LDR     r8, =ZeroPage+DAList
d1049 1
a1049 1
        LDR     r11, =ZeroPage
d1074 1
a1074 1
        LDR     r11, =ZeroPage
d1115 1
a1115 1
        LDR     r11, =ZeroPage
d1193 1
a1193 1
        LDR     r11, =ZeroPage
a1200 2
        LTORG

d1240 1
a1240 1
        LDR     r11, =ZeroPage
d1266 1
a1266 1
        LDR     r11, =ZeroPage
d1294 1
a1294 1
        LDR     r11, =ZeroPage
d1321 1
a1321 1
        LDR     r11, =ZeroPage
d1455 1
a1455 1
        LDR     r11, =ZeroPage
d1498 1
a1498 1
        LDR     r11, =ZeroPage
d1528 1
a1528 1
        LDR     r11, =ZeroPage
d1579 1
a1579 1
        LDR     r11, =ZeroPage
d1767 1
a1767 1
        LDR     r11,=ZeroPage
d1825 1
a1825 1
        LDR     r11, =ZeroPage
a1831 1
    [ ZeroPage = 0
a1832 4
    |
        LDREQ   r10, =ZeroPage
        LDREQ   r10, [r10, #DAList]
    ]
d1860 1
a1860 1
        LDR     r11, =ZeroPage
d1925 1
a1925 1
        LDR     r11, =ZeroPage                         ; we know system areas cannot be renumbered
d1984 1
a1984 1
        LDR     r2, =ZeroPage
d1988 1
a1988 1
        LDR     r11, =ZeroPage
d1993 1
a1993 1
        LDR     r11, =ZeroPage+DAList
d2038 1
a2038 1
        LDR     r10, =ZeroPage+DAList
d2050 1
a2050 1
        LDR     r11, =ZeroPage
d2065 1
a2065 1
        LDR     r11, =ZeroPage
d2133 1
a2133 1
        LDR     lr, =ZeroPage
d2164 1
a2164 1
        LDR     lr, =ZeroPage+DAList
d2249 1
a2249 1
        LDR     r1, =ZeroPage+DAList                             ; r1 is ptr into dyn areas list
d2254 1
a2254 1
        LDR     lr, =ZeroPage
a2285 2
        LTORG

d2388 1
a2388 1
        LDR     r1, =ZeroPage
d2412 1
a2412 4
      [ ZeroPage <> 0
        MOV     r1, #0
      ]
        MOV     r8, #0                                  ; 0 => translation fault
d2437 1
a2437 1
        LDR     lr, =ZeroPage
d2447 2
a2448 2
 [ MEMM_Type = "VMSAv6"
        LDR     lr, =L1_Page
a2449 3
  [ ECC
        LDR     lr, =L1_Page + L1_U + L1_P              ; form other bits to put in L1
  |
a2450 1
  ]
d2657 1
a2657 1
        LDR     lr, =ZeroPage+AppSpaceDANode
d2662 1
a2662 1
        LDR     lr, =ZeroPage+FreePoolDANode
d2681 1
a2681 1
        LDR     r5, =ZeroPage                   ; r5 = amount of memory in free pool so far (and ptr to 0)
a2694 3
      [ ZeroPage <> 0
        MOV     r5, #0
      ]
d2709 1
a2709 1
        LDR     r5, =ZeroPage                   ; r5 = amount of memory in free pool so far (and ptr to 0)
a2711 3
      [ ZeroPage <> 0
        MOV     r5, #0
      ]
d2714 1
a2714 1
        LDR     r0, =ZeroPage+L2PTSize
d2730 1
a2730 1
        LDR     lr, =ZeroPage+FreePoolDANode    ; may be used below to update DAList head ptr
d2742 1
a2742 2
        LDR     r0, =ZeroPage                   ; initialise module list to empty
      [ ZeroPage = 0
a2743 4
      |
        MOV     lr, #0
        STR     lr, [r0, #Module_List]
      ]
d2745 1
a2745 1
        LDR     lr, =ZeroPage+SysHeapDANode     ; initialise system heap node
d2749 1
a2749 1
        LDR     r0, =ZeroPage
d2751 1
a2751 1
        ADD     lr, r0, #FreePoolDANode             ; cf comments above/below - what was old code? KJB
d2762 1
a2762 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d2793 1
a2793 2
        LDR     r0,=ZeroPage
      [ ZeroPage = 0
a2794 4
      |
        MOV     r3,#0
        STR     r3,[r0,#Oscli_CmdHashSum]
      ]
a2796 3
      [ ZeroPage <> 0
        MOV     r0, #0
      ]
d2807 1
a2807 1
        LDR     r0, =ZeroPage
a2811 3
      [ ZeroPage <> 0
        MOV     r0, #0
      ]
d2842 1
a2842 1
        LDR     r1, =ZeroPage+FreePoolDANode
d2844 1
a2844 1
        LDR     r2, =ZeroPage+SysHeapDANode
d2850 1
a2850 1
        LDR     r2, =ZeroPage+SysHeapDANode
d2852 1
a2852 1
        LDR     r2, =ZeroPage+FreePoolDANode
d2856 1
a2856 1
        ASSERT  ZeroPage = 0
d2862 1
a2862 2
        LDR     r0, =ZeroPage
      [ ZeroPage = 0
a2863 4
      |
        MOV     r2, #0
        STR     r2, [r0, #CDASemaphore]         ; clear CDASemaphore
      ]
d2873 1
a2873 1
        &       ZeroPage+SysHeapDANode
d2891 1
a2891 1
        &       ZeroPage+FreePoolDANode         ; link -> free pool node, since FreePoolAddress > SysHeapStart
d2947 7
a2953 7
        LDR     r10, =ZeroPage                  ; check we're not in an IRQ
        LDR     lr, [r10, #IRQsema]
        TEQ     lr, #0
        LDREQ   lr, [r10, #CDASemaphore]       ; now also check whether ChangeDynamicArea is already threaded
        TEQEQ   lr, #0
        LDREQB  lr, [r10, #VRAMRescue_control] ; also check that wimp has not locked Free Pool
        TSTEQ   lr, #VRRc_wimp_lock
d2955 2
a2956 1
        STR     pc, [r10, #CDASemaphore]     ; store non-zero value in CDASemaphore, to indicate we're threaded
d2999 1
a2999 1
        LDR     r11, =ZeroPage
d3015 1
a3015 1
        LDR     r5, =ZeroPage
a3032 4
      [ ZeroPage <> 0
        LDR     r2, =ZeroPage
        ADD     r12, r12, r2
      ]
a3073 1
      [ ZeroPage = 0
a3075 5
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        CMP     r11, lr                         ; if src <> appspace
        CMPNE   r12, lr                         ; and dst <> appspace
      ]
a3125 1
      [ ZeroPage = 0
a3127 5
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r12, lr                         ; check if dest = appspace
        STREQ   r3, [lr, #MemLimit-AppSpaceDANode] ; update memlimit if so
      ]
d3153 1
a3153 2
        LDR     r4, =ZeroPage                   ; indicate no page block (and ptr to semaphore)
      [ ZeroPage = 0
a3154 4
      |
        MOV     lr, #0
        STR     lr, [r4, #CDASemaphore]
      ]
a3169 4
      [ ZeroPage <> 0
        LDR     r2, =ZeroPage
        ADD     r11, r11, r2
      ]
d3179 1
a3179 1
      [ ZeroPage = 0
a3181 5
      |
        LDR     r2, =ZeroPage+AppSpaceDANode
        CMP     r11, r2                         ; if appspace        
        LDR     r2, [r11, #DANode_Size]         ; amount src could shrink
      ]
d3209 1
a3209 1
      [ ZeroPage = 0
a3210 6
      |
        Push    "lr"
        LDR     lr, =ZeroPage+AppSpaceDANode
        CMP     r11, lr
        Pull    "lr"
      ]
d3248 1
a3248 1
        LDR     r4, =ZeroPage+AppSpaceDANode
d3266 1
a3266 1
        LDREQ   r11, =ZeroPage+AppSpaceDANode   ; if not, then just take from aplspace
d3275 1
a3275 1
      [ ZeroPage = 0
a3276 5
      |
        LDR     r10, =ZeroPage+AppSpaceDANode
        CMP     r11, r10                        ; if source = aplspace
      ]
        MOV     r10, #0                         ; default value if apl space not involved
d3296 1
a3296 1
        LDREQ   r11, =ZeroPage+FreePoolDANode   ; then start with free
d3315 1
a3315 1
        LDRHI   r11, =ZeroPage+AppSpaceDANode   ; which is app space
a3320 1
      [ ZeroPage = 0
a3321 4
      |
        LDR     r2, =ZeroPage
        STR     r1, [r2, #CDASemaphore]         ; OK to reenter now (we've done the damage)
      ]
d3342 1
a3342 1
        LDRHI   r11, =ZeroPage+AppSpaceDANode   ; which is app space
d3410 1
a3410 2
        LDR     r0, =ZeroPage
      [ ZeroPage = 0
a3411 4
      |
        MOV     lr, #0
        STR     lr, [r0, #CDASemaphore] ; clear CDASemaphore
      ]
d3435 1
a3435 1
        LDR     r10, =ZeroPage+DAList
d3451 1
a3451 2
        LDR     r0, =ZeroPage
      [ ZeroPage = 0
a3452 4
      |
        MOV     lr, #0
        STR     lr, [r0, #CDASemaphore]         ; momentarily pretend we're not threaded
      ]
a3454 1
      [ ZeroPage = 0
a3456 4
      |
        LDR     r0, =ZeroPage
        STR     r0, [r0, #CDASemaphore]         ; we're threaded again
      ]
a3533 1
      [ ZeroPage = 0
a3534 4
      |
        LDR     r1, =ZeroPage+AppSpaceDANode
        TEQ     r11, r1                                 ; if just appspace
      ]
d3631 1
a3631 1
        LDR     r0, =ZeroPage
d3648 1
a3648 1
        LDR     r4, =ZeroPage+PhysRamTable
a3675 1
      [ ZeroPage = 0
a3676 4
      |
        LDR     r1, =ZeroPage+AppSpaceDANode
        TEQ     r11, r1                                 ; if appspace
      ]
d3713 1
a3713 1
        LDR     r3, =ZeroPage
d3754 1
a3754 1
        LDR     r1, =ZeroPage+PhysRamTable
d3880 1
a3880 1
        LDR     lr, =ZeroPage
a3890 1
        LDR     r4, =Nowhere                    ; There's no point in cleaning the nowhere page, and on some architectures it'll even trigger an abort handler due to the lack of mapping
d3892 2
a3893 3
        TEQ     r3, r4
        LDRNE   r4, =ZeroPage
        ARMop   MMU_ChangingEntry,NE,,r4
a3970 1
      [ ZeroPage = 0
a3971 4
      |
        LDR     r1, =ZeroPage+AppSpaceDANode
        TEQ     r1, r11                                 ; if just appspace
      ]
d4046 1
a4046 1
        LDR     r2, =ZeroPage
d4260 1
a4260 1
        LDR     r5, =ZeroPage
d4388 1
a4388 1
        LDR     lr, =ZeroPage+VduDriverWorkSpace
d4393 1
a4393 1
        LDR     r0, =ZeroPage
d4454 1
a4454 1
        LDR     r0, =ZeroPage
d4489 1
a4489 1
        LDR     r0, =ZeroPage
d4536 1
a4536 1
        LDR     r1, =ZeroPage
d4725 1
a4725 1
        LDR     LR, =ZeroPage
@


4.9.2.21
log
@OS_ChangeDynamicArea performance optimisations
Detail:
  s/ChangeDyn:
    - Apply various optimisations to OS_ChangeDynamicArea to reduce the execution time when performing large grows/shrinks.
    - Optimisations can be toggled on/off with FastCDA_* flags for debugging.
    - On a 1GHz 512MB BB-xM, the initial *FreePool call now takes 0.15s instead of 13.46s. On a 512MB Iyonix the time has dropped from 1.18s to 0.23s.
    - Growing screen memory (on BB-xM) has also seen significant gains - between 2x and 4x speedup, depending on what state the source pages are in.
    - Added/updated documentation for a few functions and made more use of ROUTs for safety
  s/ARM600, s/VMSAv6:
    - Update BangCamUpdate, etc. to add support for the PageFlags_Unsafe flag that OS_ChangeDynamicArea uses to bypass cache/TLB maintenance in some situations
    - Avoid BangCamUpdate calling BangL2PT to map out the page if the page isn't mapped in (avoids unnecessary cache/TLB flush)
  s/ArthurSWIs:
    - Add extra ASSERT for safety
  s/AMBcontrol/memory
    - Fix incorrect assumption that the usable size of a heap block is always 8 less than the value stored in the header. Even with the old 8 byte aligned allocations the usable size will always be 4 bytes less than the value in the header. This code would have resulted in some slight memory wasteage, as AMBcontrol will have always tried growing the block four bytes bigger than needed.
Admin:
  Tested on Iyonix & BB-xM


Version 5.35, 4.79.2.146. Tagged as 'Kernel-5_35-4_79_2_146'
@
text
@a16 83
        ; OS_ChangeDynamicArea optimisations:

        GBLL  FastCDA_UpFront ; Do all cache/TLB maintenance upfront instead of on a per-page basis
FastCDA_UpFront SETL {TRUE}

        GBLL  FastCDA_FIQs ; Don't thrash ClaimFIQ/ReleaseFIQ in DoTheGrowPagesSpecified
FastCDA_FIQs SETL {TRUE}

        GBLL  FastCDA_NoPhysical ; Don't use RISCOS_AccessPhysicalAddress/RISCOS_ReleasePhysicalAddress in DoTheGrowPagesSpecified. Instead, map pages straight to destination address.
FastCDA_NoPhysical SETL {TRUE}

        GBLL  FastCDA_CorruptFreePool ; Contents of free pool doesn't need preserving in DoTheGrowPagesSpecified
FastCDA_CorruptFreePool SETL {TRUE}

        GBLL  FastCDA_Unnecessary ; Avoid unnecessary MMU_ChangingEntry calls in DoTheGrowPagesSpecified
FastCDA_Unnecessary SETL {TRUE}

        ; DoTheGrowPagesSpecified profiling code
        ; Written to use Cortex-A8 cycle count performance counter - will need modifying for other CPUs!

        GBLL  FastCDA_Prof
FastCDA_Prof SETL {FALSE}

      [ FastCDA_Prof
        ; Squeeze profiling workspace into "free space after envstring"
                                 ^ ExtendedROMFooter+4
        ! 0, "FastCDA_Prof workspace at ":CC::STR:@@
FastCDA_Prof_DoTheGrowInit           # 4
FastCDA_Prof_MarkRequired            # 4
FastCDA_Prof_PagesUnsafe             # 4
FastCDA_Prof_DoublyCheckCacheability # 4
FastCDA_Prof_DoublyMovePages         # 4
FastCDA_Prof_FindSpare               # 4
FastCDA_Prof_ClaimFIQ                # 4
FastCDA_Prof_AccessPhysical          # 4
FastCDA_Prof_CopyPage                # 4
FastCDA_Prof_ReleasePhysical         # 4
FastCDA_Prof_MoveReplacement         # 4
FastCDA_Prof_MoveNeeded              # 4
FastCDA_Prof_ReleaseFIQ              # 4
FastCDA_Prof_PagesSafe               # 4
FastCDA_Prof_CallPreGrow             # 4
FastCDA_Prof_CallPostGrow            # 4
FastCDA_Prof_MMUChanging             # 4
FastCDA_Prof_MMUChangingUncached     # 4
FastCDA_Prof_ChangingEntry           # 4
        ASSERT @@ <= &500
      ]

        MACRO
        FastCDA_ProfInit $temp
      [ FastCDA_Prof
        MVN     $temp,#0
        MCR     p15,0,$temp,c9,c12,2
        MOV     $temp,#1<<31
        MCR     p15,0,$temp,c9,c12,1
        MOV     $temp,#7
        MCR     p15,0,$temp,c9,c12,0
      ]
        MEND

        MACRO
        FastCDA_ProfStart $var,$temp,$temp2,$temp3,$cc
      [ FastCDA_Prof
        LDR$cc  $temp,=ZeroPage+FastCDA_Prof_$var
        LDR$cc  $temp2,[$temp]
        MRC$cc  p15,0,$temp3,c9,c13,0
        SUB$cc  $temp2,$temp2,$temp3
        STR$cc  $temp2,[$temp]
      ]
        MEND

        MACRO
        FastCDA_ProfEnd $var,$temp,$temp2,$temp3,$cc
      [ FastCDA_Prof
        MRC$cc  p15,0,$temp3,c9,c13,0
        LDR$cc  $temp,=ZeroPage+FastCDA_Prof_$var
        LDR$cc  $temp2,[$temp]
        ADD$cc  $temp2,$temp2,$temp3
        STR$cc  $temp2,[$temp]
      ]
        MEND

d282 1
a282 1
;       r9 = offset from 1st to 2nd copy of doubly mapped area (either source or dest, but not both)
a366 5
; Call_CAM_Mapping
; in:   r2 = physical page number
;       r3 = logical address (2nd copy of doubly mapped area)
;       r9 = offset from 1st to 2nd copy of doubly mapped area (either source or dest, but not both)
;       r11 = PPL + CB bits
a371 20
  [ FastCDA_UpFront
; CheckCacheabilityR0ByMinusR2
; in:   r0 = end of area
;       r2 = size of area (must be nonzero)
; out:  r6 has DynAreaFlags_NotCacheable set if entire region noncacheable
;              Flag clear if at least one page is cacheable
;       r0 points to start of area
;
;       4K page size assumed!
CheckCacheabilityR0ByMinusR2 ROUT
        Entry   "r2"
10
        SUB     r0, r0, #4096
        BL      GetPageFlagsForR0IntoR6
        SUBS    r2, r2, #4096
        TSTNE   r6, #DynAreaFlags_NotCacheable
        BNE     %BT10
        SUB     r0, r0, r2
        EXIT
  ]
a721 1
PageFlags_Unsafe                *  1 :SHL: 22                      ; skip cache/TLB maintenance in BangCamUpdate. flag not saved to CAM map.
a3009 2
        FastCDA_ProfInit r3

d3085 1
a3085 1
AreaShrink ROUT
a3179 22
      [ FastCDA_UpFront
        Push    "r0-r1"
        BL      CheckCacheabilityR0ByMinusR2
        LDR     r4, [r11, #DANode_Flags]
        ADR     lr, %FT19
        TST     r4, #DynAreaFlags_DoublyMapped
        LDR     r4, =ZeroPage
        BNE     %FT18
        ; Interacting with singly-mapped region - use regular logic
        TST     r6, #DynAreaFlags_NotCacheable
        MOV     r1, r2, LSR #12
        ARMop   MMU_ChangingEntries, EQ, tailcall, r4
        ARMop   MMU_ChangingUncachedEntries, NE, tailcall, r4
18
        ; Interacting with doubly-mapped region - use sledgehammer logic
        TST     r6, #DynAreaFlags_NotCacheable
        ARMop   MMU_Changing, EQ, tailcall, r4
        ARMop   MMU_ChangingUncached, NE, tailcall, r4
19
        Pull    "r0-r1"
      ]        

a3183 3
      [ FastCDA_UpFront
        ORR     r6, r6, #PageFlags_Unsafe
      ]
a3224 3
 [ FastCDA_UpFront
        ORR     r6, r6, #PageFlags_Unsafe
 ]
d3244 1
a3244 1
AreaGrow ROUT
d3543 1
a3543 2
TryToShrinkShrinkables ROUT
        Entry "r0,r1,r10"
d3607 2
d3610 2
a3614 4
DestAddr        #       4                       ; Log addr of 1st page being added to dest
DestFlags       #       4                       ; Page flags for destination area
SavedPSR        #       4                       ; PSR before IRQs disabled
Offset1To2      #       4                       ; Offset from 1st to 2nd bank
d3620 1
a3620 7
; Offset1To2 is only used by the first half of the routine. Reuse the space as flags for the second half:
                    ^   :INDEX: Offset1To2, sp
NeedToMoveFlag      #   1                       ; Whether we still need to move the current page
                    #   3                       ; (spare)

DoTheGrow ROUT
        Entry "r3,r5,r10-r12", DoTheGrowStackSize
a3626 1
        FastCDA_ProfStart DoTheGrowInit, r0, r1, lr
a3635 1
        FastCDA_ProfEnd DoTheGrowInit, r0, r3, lr
a3677 17

      [ FastCDA_UpFront
        ; Perform sledgehammer logic upfront
        Push    "r0,r2,r6"
        MOV     r0, r1
        MOV     r2, r3
        BL      CheckCacheabilityR0ByMinusR2
        TST     r6, #DynAreaFlags_NotCacheable
        LDR     r0, =ZeroPage
        ADR     lr, %FT14
        ARMop   MMU_Changing, EQ, tailcall, r0
        ARMop   MMU_ChangingUncached, NE, tailcall, r0
14
        Pull    "r0,r2,r6"
        ORR     r6, r6, #PageFlags_Unsafe
      ]

a3692 15
   [ FastCDA_UpFront
        ; Flush src region from cache
        Push    "r0-r1,r6"
        BL      CheckCacheabilityR0ByMinusR2
        TST     r6, #DynAreaFlags_NotCacheable
        LDR     r4, =ZeroPage
        MOV     r1, r2, LSR #12
        ADR     lr, %FT29
        ARMop   MMU_ChangingEntries, EQ, tailcall, r4
        ARMop   MMU_ChangingUncachedEntries, NE, tailcall, r4
29
        Pull    "r0-r1,r6"
        ; Now BangCam for all the pages
        ORR     r6, r6, #PageFlags_Unsafe                
   ]
d3721 1
a3721 1
DoTheGrowPageUnavailable ROUT
d3754 1
a3754 1
DoTheGrowPagesSpecified ROUT
a3758 1
        FastCDA_ProfStart MarkRequired, r0, r6, lr
d3770 1
a3770 1
        BNE     DoTheGrowPageUnavailable
a3787 1
        FastCDA_ProfEnd MarkRequired, r0, r6, lr
a3790 1
        FastCDA_ProfStart PagesUnsafe, r0, r6, lr
a3794 1
        FastCDA_ProfEnd PagesUnsafe, r0, r6, lr
a3826 36

    [ FastCDA_UpFront
        ; Perform sledgehammer logic upfront
        Push    "r0,r2,r6"
        FastCDA_ProfStart DoublyCheckCacheability, r0, r6, lr
        MOV     r0, r1
        MOV     r2, r3
        BL      CheckCacheabilityR0ByMinusR2
        FastCDA_ProfEnd DoublyCheckCacheability, r0, r2, lr
        TST     r6, #DynAreaFlags_NotCacheable
        LDR     r2, =ZeroPage
      [ FastCDA_Prof
        LDREQ   lr,[r2,#FastCDA_Prof_MMUChanging]
        LDRNE   lr,[r2,#FastCDA_Prof_MMUChangingUncached]
        MRC     p15,0,r0,c9,c13,0
        SUB     lr,lr,r0
        STREQ   lr,[r2,#FastCDA_Prof_MMUChanging]
        STRNE   lr,[r2,#FastCDA_Prof_MMUChangingUncached]
      ]      
        ADR     lr, %FT44
        ARMop   MMU_Changing, EQ, tailcall, r2
        ARMop   MMU_ChangingUncached, NE, tailcall, r2
44
      [ FastCDA_Prof
        MRC     p15,0,r0,c9,c13,0
        TST     r6, #DynAreaFlags_NotCacheable
        LDREQ   lr,[r2,#FastCDA_Prof_MMUChanging]
        LDRNE   lr,[r2,#FastCDA_Prof_MMUChangingUncached]
        ADD     lr,lr,r0
        STREQ   lr,[r2,#FastCDA_Prof_MMUChanging]
        STRNE   lr,[r2,#FastCDA_Prof_MMUChangingUncached]
      ]      
        Pull    "r0,r2,r6"
        ORR     r6, r6, #PageFlags_Unsafe
    ]

a3827 1
        FastCDA_ProfStart DoublyMovePages, r0, r9, lr
a3836 1
        FastCDA_ProfEnd DoublyMovePages, r0, r9, lr
a3853 1
        FastCDA_ProfStart FindSpare, r6, r1, lr
a3909 1
        FastCDA_ProfEnd FindSpare, r7, r1, lr
a3914 9
     [ FastCDA_FIQs
        ; Claim FIQs for this entire loop
        ; (With the old behaviour, for large grows, total time in ReleaseFIQ could be several centiseconds, since the kernel reinstalls the default handler each time)
        FastCDA_ProfStart ClaimFIQ, r6, r1, lr
        MOV     r1, #Service_ClaimFIQ
        BL      Issue_Service
        FastCDA_ProfEnd ClaimFIQ, r6, r1, lr
     ]

a3924 9
    [ FastCDA_NoPhysical
        ; Grab the flags for the page we're replacing; NoPhysical optimisation means the page may get mapped to its target pos earlier than before, causing the flags in the CAM map to be "wrong" when we read them back out later on
        LDR     r11, [r8, #0]                   ; need to get PPL for page being replaced
        ADD     lr, r0, #4                      ; point at PPLs, not addresses
        LDR     r11, [lr, r11, LSL #3]
        MOV     lr, #1
        STRB    lr, NeedToMoveFlag
    ]

a3925 2
    [ :LNOT: FastCDA_FIQs
        FastCDA_ProfStart ClaimFIQ, r6, r1, lr
a3927 2
        FastCDA_ProfEnd ClaimFIQ, r6, r1, lr
    ]
a3943 11
        LDR     r6, [r8, #4]                    ;logical address of src page

      [ FastCDA_CorruptFreePool
        ; If the source is in the free pool, we don't need to preserve its contents
        LDR     r3, =ZeroPage+FreePoolDANode
        SUB     r2, r6, #FreePoolAddress
        LDR     r3, [r3, #DANode_MaxSize]
        CMP     r2, r3
        BLO     %FT74
      ]

d3946 1
a3950 12
      [ FastCDA_NoPhysical
        ; No need to use AccessPhysicalAddress here - if the required page isn't mapped in, all we need to do is map it in at the target address and use that mapping to copy the data out
        LDR     r2, [r8, #0]
        LDR     r3, [sp, #4] ; Get stacked r1
        LDR     r11, [sp, #11*4+:INDEX:DestFlags]
        FastCDA_ProfStart MoveNeeded, lr, r4, r7
        BL      Call_CAM_Mapping                ; move needed page to destination
        FastCDA_ProfEnd MoveNeeded, lr, r4, r7
        MOV     r6, r3                          ; r6 = logical address of src for copy
        MOV     lr, #0
        STRB    lr, [sp, #11*4+:INDEX:NeedToMoveFlag]
      |
a3953 1
        FastCDA_ProfStart AccessPhysical, r0, r1, lr
a3958 1
        FastCDA_ProfEnd AccessPhysical, r0, r1, lr
a3959 1
      ]
a3961 1
        FastCDA_ProfStart CopyPage, r2, r3, r4
a3968 3
        FastCDA_ProfEnd CopyPage, r2, r3, r4

     [ :LNOT: FastCDA_NoPhysical
a3973 4
      [ FastCDA_Prof
        BNE     %FT73
        FastCDA_ProfStart ReleasePhysical, r2, r3, r4
      ]
a3974 5
      [ FastCDA_Prof
        FastCDA_ProfEnd ReleasePhysical, r2, r3, r4
73
      ]
     ]
a4012 1
 [ :LNOT: FastCDA_NoPhysical
a4017 1
 ]
d4022 1
a4022 10
        
        LDR     lr, =Nowhere                    ; There's no point in cleaning the nowhere page, and on some architectures it'll even trigger an abort handler due to the lack of mapping
        TEQ     r3, lr
        BEQ     %FT75
      [ FastCDA_Unnecessary
        ; We only need to clean the cache/TLB if the page is cacheable
        ; For uncacheable pages, BangL2PT will flush the TLB for us just before the mapping is updated
        TST     r11, #DynAreaFlags_NotCacheable
        BNE     %FT75
      ]        
d4024 1
d4026 3
a4028 8
      [ FastCDA_Prof
        FastCDA_ProfStart ChangingEntry, r6, lr, r4
      ]
        LDR     r4, =ZeroPage
        ARMop   MMU_ChangingEntry,,,r4
      [ FastCDA_Prof
        FastCDA_ProfEnd ChangingEntry, r6, lr, r4
      ]
a4029 1
75
a4030 1
        FastCDA_ProfStart MoveReplacement, r6, lr, r5
a4031 1
        FastCDA_ProfEnd MoveReplacement, r6, lr, r5
a4035 6
      [ FastCDA_NoPhysical
        LDRB    lr, NeedToMoveFlag
        TEQ     lr, #0
        BEQ     %FT77                           ; don't bother if page already been moved to dest
      ]
        FastCDA_ProfStart MoveNeeded, r6, lr, r5
a4036 1
        FastCDA_ProfEnd MoveNeeded, r6, lr, r5
a4037 1
77
a4040 1
      [ :LNOT: FastCDA_FIQs
a4041 1
        FastCDA_ProfStart ReleaseFIQ, r1, lr, r5
a4043 1
        FastCDA_ProfEnd ReleaseFIQ, r1, lr, r5
a4044 4
      ]
      [ FastCDA_Prof
        MOV     r5, #4096
      ]
a4051 7
     [ FastCDA_FIQs
        FastCDA_ProfStart ReleaseFIQ, r1, lr, r2
        MOV     r1, #Service_ReleaseFIQ
        BL      Issue_Service
        FastCDA_ProfEnd ReleaseFIQ, r1, lr, r2
     ]

a4057 1
        FastCDA_ProfStart PagesSafe, r1, r2, r3
a4062 1
        FastCDA_ProfEnd PagesSafe, r1, r2, r3
d4093 1
a4093 2
DoTheGrowNotSpecified ROUT
        Entry "r3,r5,r10-r12", DoTheGrowNotSpecifiedStackSize
a4126 17

      [ FastCDA_UpFront
        ; Perform sledgehammer logic upfront
        Push    "r0,r2,r6"
        MOV     r0, r1
        MOV     r2, r3
        BL      CheckCacheabilityR0ByMinusR2
        TST     r6, #DynAreaFlags_NotCacheable
        LDR     r0, =ZeroPage
        ADR     lr, %FT14
        ARMop   MMU_Changing, EQ, tailcall, r0
        ARMop   MMU_ChangingUncached, NE, tailcall, r0
14
        Pull    "r0,r2,r6"
        ORR     r6, r6, #PageFlags_Unsafe
      ]

a4141 15
   [ FastCDA_UpFront
        ; Flush src region from cache
        Push    "r0-r1,r6"
        BL      CheckCacheabilityR0ByMinusR2
        TST     r6, #DynAreaFlags_NotCacheable
        LDR     r4, =ZeroPage
        MOV     r1, r2, LSR #12
        ADR     lr, %FT29
        ARMop   MMU_ChangingEntries, EQ, tailcall, r4
        ARMop   MMU_ChangingUncachedEntries, NE, tailcall, r4
29
        Pull    "r0-r1,r6"
        ; Now BangCam for all the pages
        ORR     r6, r6, #PageFlags_Unsafe                
   ]
d4185 1
a4185 2
CheckAppSpace ROUT
        Entry "r0-r3"
a4338 1
        FastCDA_ProfStart CallPreGrow, r0, r4, lr
a4344 1
        FastCDA_ProfEnd CallPreGrow, r12, r4, lr
a4373 1
        FastCDA_ProfStart CallPostGrow, r0, r4, lr
a4379 1
        FastCDA_ProfEnd CallPostGrow, r12, r4, lr
@


4.9.2.22
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d1511 2
a1512 1
 |
a1513 1
 ]
d2081 1
a2081 1
 |
a2082 1
 ]
a2291 2
 |
        SETV
d2294 1
a2416 2
  |
        SETV
d2419 1
a2621 2
  |
        SETV
d2624 1
d3928 1
a3928 1
 |
a3929 1
 ]
a4574 2
 |
        SETV
d4577 1
d4644 1
d4709 1
a4709 1
        TEQ     r0, #0                                  ; if generic error returned (V still set)
d4715 1
d4777 1
a4777 1
        TEQ     r0, #0                                  ; if generic error returned (V still set)
d4874 1
a4874 1
  |
a4875 1
  ]
a5006 2
 |
        SETV
d5009 1
@


4.9.2.23
log
@Teach the kernel about different memory attributes
Detail:
  Briefly, this set of changes:
  * Adjusts PhysRamTable so that it retains the flags passed in by the HAL from OS_AddRAM (by storing them in the lower 12 bits of the size field)
  * Sorts the non-VRAM entries of PhysRamTable by speed and DMA capability, to ensure optimal memory allocation during OS startup.
  * Adjust the initial memory allocation logic to allow the cursor/sound chunk and HAL noncacheable workspace to come from DMA capable memory
  * Extends OS_Memory 12 to accept a 'must be DMA capable' flag in bit 8 of R0. This is the same as available in ROL's OS.
  * Extends OS_DynamicArea 0 to allow the creation of dynamic areas that automatically allocate from DMA capable memory. In ROL's OS this was done by setting bit 12 of R4, but we're using bits 12-14 for specifying the cache policy, so instead bit 15 is used.
  * Fixes OS_ReadSysInfo 6 to return the correct DevicesEnd value now that the IRQ/device limit is computed at runtime
  File changes:
  * hdr/OSEntries - Add definitions of the various flags passed to OS_AddRAM by the HAL. Add a new flag, NoDMA, for memory which can't be used for DMA.
  * hdr/KernelWS - Tidy PhysRamTable definition a bit by removing all the DRAM bank definitions except the first - this makes it easier to search for code which is interacting with the table. Remove VRAMFlags, it's redundant now that the flags are kept in the table. Add DMA allocation info to InitWs.
  * s/AMBControl/memmap - Updated to mask out the flags from PhysRamTable when reading RAM block sizes.
  * s/ARM600 - Strip out a lot of IOMD specific pre-HAL code.
  * s/ChangeDyn - Updated to cope with the flags stored in PhysRamTable. Implement support for DMA-capable dynamic areas. Rewrite InitDynamicAreas to insert pages into the free pool in the right order so that the fastest memory will be taken from it first.
  * s/GetAll, s/Middle - Fix OS_ReadSysInfo 6 to return the correct HAL-specific DevicesEnd value
  * s/HAL - Significant rework of initial RAM allocation code to allow the kernel workspace to come from the fastest DMA incapable RAM, while also allowing allocation of DMA capable memory for HAL NCNB workspace & kernel cursor/sound chunks. ClearPhysRAM rewritten as part of this.
  * s/MemInfo - Updated to cope with the flags stored in PhysRamTable. Add support for the new OS_Memory 12 flag. Update OS_Memory 7 to not assume PhysRamTable entries are sorted in address order, and rip out the old pre-HAL IOMD implementation.
  * s/NewReset - Remove GetPagesFromFreePool option, assume TRUE (as this has been the case for the past 10+ years). Revise a few comments and strip dead code. Update to cope with PhysRamTable flags.
  * s/VMSAv6 - Remove a couple of unused definitions
  * s/vdu/vdudriver - Update to cope with PhysRamTable flags
Admin:
  Tested in Kinetic RiscPC ROM softload, Iyonix softload, & OMAP3


Version 5.35, 4.79.2.186. Tagged as 'Kernel-5_35-4_79_2_186'
@
text
@d115 11
a674 1
        BICCS   r7, r7, #&F00
a815 1
DynAreaFlags_NeedsDMA           *  1 :SHL: 15   ; only allocate from DMAable memory
d817 1
a817 3
; No more bits left for easy flag expansion. Will have to start claiming bits
; from 16 to 31, or shuffle some of the following flags further up
; (which should be safe in theory, as they all should be kernel private)
d824 1
a824 1
PageFlags_TempUncacheableBits   * 15 :SHL: TempUncacheableShift    ; temporary count of uncacheability, used by DMA mgr (via OS_Memory 0)
d906 2
a907 3
;               bits 12..14 => cache policy (if bits 4 or 5 set)
;               bit 15 = 1 => area requires DMA capable pages (is bit 12 in ROL's OS!)
;               bits 16..31 reserved for future expansion + internal page flags (should be 0)
d2805 1
a2805 1
InitDynamicAreas Entry "r0-r12"
d2818 8
a2825 14
; We have to move all free pages (ie ones not occupied by the static pages)
; into the free pool.
; By default, pages will get taken from the end of the free pool when other
; dynamic areas are initialised or grown. So make sure that the slowest RAM
; is at the start of the free pool and the fastest is at the end; this is the
; reverse of the order in PhysRamTable.

; The blocks of pages within the free pool are kept with consecutive physical
; page numbers; I'm not sure how important this is, but the old code did it.
; However instead of merely keeping the entire free pool in consecutive order,
; we need to process each PhysRamTable entry in turn, to allow us to place the
; fastest block at the end of the pool. Furthermore VRAM block is kept at the
; start of the pool - again to match old behaviour, although moving it elsewhere
; may not have any significant impact on the system
d2827 1
d2830 1
a2830 1
        LDR     r5, =ZeroPage
d2837 1
a2837 1
        SUB     r8, r0, #1                      ; r8 = page number of last page in statics
d2839 10
a2848 6
        ADD     r9, r5, #PhysRamTable
        LDMIA   r9, {r0, r10}                   ; get VRAM info
        ADD     r9, r9, #PhysRamTableEnd-PhysRamTable ; skip to end
        MOV     r10, r10, LSR #12
        LDR     r5, [r5, #CamEntriesPointer]
        ADD     r5, r5, #4                      ; r5 = base of PPLs
d2850 28
a2877 12
        BL      PhysAddrToPageNo
        ; Move r10 pages to r6 starting from r0
        MOV     r2, r0                          ; get ready for BangCamUpdate
        MOV     r3, r6
15
        CMP     r2, r7
        CMPHS   r8, r2
        BHS     %FT20                           ; page is in statics
        ; Check the CAM map to see if the page is already taken - this will detect the DMA regions, which aren't included in InitUsedStart/InitUsedEnd
        LDR     lr, [r5, r2, LSL #3]
        TST     lr, #PageFlags_Unavailable
        BNE     %FT20
d2879 8
a2886 19
        ADD     r3, r3, #4096
20
        ADD     r2, r2, #1
        SUBS    r10, r10, #1
        BNE     %BT15
        ; Advance to next PhysRamTable entry, working backwards
30
        LDMDB   r9!, {r0, r10}
        MOVS    r10, r10, LSR #12
        BEQ     %BT30
        LDR     lr, =ZeroPage+PhysRamTable
        CMP     lr, r9                          ; stop once we hit first entry, it's already been processed
        MOV     r6, r3
        BNE     %BT10
        ; Left with r6 = end of free pool
        LDR     lr, =ZeroPage+FreePoolDANode
        LDR     r5, [lr, #DANode_Base]
        SUB     r5, r6, r5
        STR     r5, [lr, #DANode_Size]
d3545 1
a3545 1
        TST     lr, #DynAreaFlags_NeedsSpecificPages+DynAreaFlags_NeedsDMA
d4699 1
a4699 6
CallPreGrow ROUT
        Entry   "r0,r4, r12"
        LDR     r0, [r12, #DANode_Flags]
        TST     r0, #DynAreaFlags_NeedsDMA              ; if DMA needed
        BNE     %FT10                                   ; use special PreGrow

a4713 1
05
a4721 45
10
        ; Instead of calling the users PreGrow handler, walk PhysRamTable and
        ; the CAM map to look for some free DMAable pages
        ; Note that we don't guarantee physical contiguity - if you want that,
        ; just use OS_Memory 12 or PCI_RAMAlloc instead
        Push    "r1-r3"
        LDR     r0,=ZeroPage+PhysRamTable+4
        MOV     r2,#0                    ; current page number
        LDR     r4,=ZeroPage+CamEntriesPointer
        LDR     r4,[r4]
        ADD     r4,r4,#4                 ; -> base of PPLs
        LDR     r12,[r0],#8              ; get video chunk flags
20
        ADD     r2,r2,r12,LSR #12        ; advance page number
21
        LDR     r12,[r0],#8              ; get next chunk details
        CMP     r12,#0
        BEQ     %FT90
        TST     r12,#OSAddRAM_NoDMA
        BNE     %BT20
        ; Check the CAM map to see if any pages here are free
        MOV     r12,r12,LSR #12
30
        LDR     lr,[r4,r2,LSL #3]
        TST     lr,#PageFlags_Unavailable :OR: PageFlags_Required
        STREQ   r2,[r1],#12
        SUBEQS  r3,r3,#4096
        BEQ     %FT80
        SUBS    r12,r12,#1
        ADD     r2,r2,#1
        BNE     %BT30
        B       %BT21
80
        ; Success
        CLRV
        Pull    "r1-r3"
        EXIT
90
        ; Failure
        SETV
        Pull    "r1-r3"
        MOV     r0,#0                
        B       %BT05


d5236 2
a5237 2
        LDR     LR, [LR, #VideoSizeFlags]          ;is VRAM suitable for general use?
        TST     LR, #OSAddRAM_VRAMNotForGeneralUse ;if not - don't shrink screen memory
a5281 1
        LTORG
@


4.9.2.24
log
@Strip out some old build switches
Detail:
  hdr/Options, s/ArthurSWIs, s/ChangeDyn, s/PMF/KbdDrA1, s/PMF/key, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdugrafhal, s/vdu/vdugrafv, s/vdu/vdumodes, s/vdu/vduwrch:
  - Strip out DoingVdu build switch (did nothing)
  - Strip out Japanese16BitSound switch (did nothing)
  - Strip out MakeModeSelectorsForModeNUmbers switch (altered the mode list structures, but there wasn't any code to do anything with the new data)
  - Strip out remaining uses of UseGraphicsV switch (now hardwired to {TRUE})
  - Strip out ShadowROM switch (altered FixedAreasTable to show the shadow mapping, but code to create the mapping is missing)
  - Strip out PollMouse switch (old Archimedes-era debug/development option)
Admin:
  Tested on BB-xM
  Builds to same binary as previous version


Version 5.35, 4.79.2.204. Tagged as 'Kernel-5_35-4_79_2_204'
@
text
@d2348 3
@


4.9.2.25
log
@Add OS_Memory 24 implementation. Change OS_ValidateAddress to use it. Fix kernel leaving the physical access MB in a messy state. Try and protect against infinite abort loops caused by bad environment handlers.
Detail:
  s/MemInfo - Added an implementation of ROL's OS_Memory 24 call. Unlike the old OS_ValidateAddress call, this call should successfully report the presence of all memory areas known to the kernel. It should also correctly indicate which parts of a sparse DA are mapped in, unlike the old OS_ValidateAddress implementation.
  s/ChangeDyn - Update dynamic area handling to construct a lookup table for mapping logical addresses to dynamic areas; this is used by OS_Memory 24 to quickly locate which DA(s) hit a given region
  s/AMBControl/main - Make sure lazy task swapping is marked as disabled when AMB_LazyMapIn is {FALSE} - required so that OS_Memory 24 will give application space the correct flags
  s/ArthurSWIs - Switch OS_ValidateAddress over to using OS_Memory 24, as per ROL. For compatibility, Service_ValidateAddress is still issued for any areas which the kernel doesn't recognise (currently, OS_Memory 24 doesn't issue any service calls itself)
  s/Convrsions - ADR -> ADRL to keep things happy
  s/HAL - Fix L2PT page allocation and RAM clear to release the physical access region once they're done with it
  s/Kernel - Make the error dispatcher validate the error handler code ptr & error buffer using OS_Memory 24 before attempting to use them. If they look bad, reset to default. Should prevent getting stuck in an infinite abort loop in some situations (e.g. as was the case with ticket 279). The system might not fully recover, but it's better than a hard crash.
  s/Middle - Rework data/prefetch/etc. abort handlers so that DumpyTheRegisters can validate the exception dump area via OS_Memory 24 before anything gets written to it. Should also help to prevent some infinite abort loops. Strip 26bit/pre-HAL code to make things a bit more readable.
  hdr/KernelWS - Update comment
Admin:
  Tested on BB-xM, Raspberry Pi


Version 5.35, 4.79.2.222. Tagged as 'Kernel-5_35-4_79_2_222'
@
text
@d126 1
a198 3
DynArea_AddrLookupBits    * 8                       ;LUT covers entire 4G logical space, so 4G>>8 = 16M granularity
DynArea_AddrLookupSize    * 1<<(32-DynArea_AddrLookupBits) ; Address space covered by each entry
DynArea_AddrLookupMask    * &FFFFFFFF-(DynArea_AddrLookupSize-1)
a229 1
DynArea_AddrLookup        # 4<<DynArea_AddrLookupBits ; Lookup table for fast logaddr -> dynarea lookup
a1173 1
        BL      AddDAToAddrLookupTable
a1325 33
; Add a dynamic area to the quick address lookup table
; In:
;  R2 = DANode ptr
;  R11 = DynArea_ws
AddDAToAddrLookupTable
        Entry   "r0-r1,r3,r6"
        ADRL    r0, DynArea_AddrLookup
        LDR     r1, [r2, #DANode_Flags]
        LDR     r3, [r2, #DANode_MaxSize]
        LDR     r6, [r2, #DANode_Base]
        TST     r1, #DynAreaFlags_DoublyMapped
        SUBNE   r6, r6, r3                      ; Get true start address
        MOVNE   r3, r3, LSL #1
        AND     r1, r6, #DynArea_AddrLookupMask ; Round down start address
        ADD     lr, r6, r3
        AND     r3, lr, #DynArea_AddrLookupMask
        TEQ     lr, r3
        ADDNE   r3, r3, #DynArea_AddrLookupSize ; Round up end address
        SUB     r3, r3, r1
        ADD     r0, r0, r1, LSR #30-DynArea_AddrLookupBits
71
        LDR     lr, [r0], #4
        TEQ     lr, #0
        STREQ   r2, [r0, #-4]
        BEQ     %FT72
        LDR     lr, [lr, #DANode_Base]
        CMP     lr, r6
        STRHI   r2, [r0, #-4]                   ; Update LUT if current entry starts after us
72
        SUBS    r3, r3, #DynArea_AddrLookupSize
        BNE     %BT71
        EXIT

d1390 1
a1390 1
        Push    "r0-r4,r7,r8,r11"
d1404 1
a1404 38
; Delink from address lookup table
        ADRL    r0, DynArea_AddrLookup
        LDR     r1, [r10, #DANode_Flags]
        LDR     r3, [r10, #DANode_MaxSize]
        LDR     r2, [r10, #DANode_Base]
        TST     r1, #DynAreaFlags_DoublyMapped
        SUBNE   r2, r2, r3                      ; Get true start address
        MOVNE   r3, r3, LSL #1
        AND     r1, r2, #DynArea_AddrLookupMask ; Round down start address
        ADD     lr, r2, r3
        AND     r3, lr, #DynArea_AddrLookupMask
        TEQ     lr, r3
        ADDNE   r3, r3, #DynArea_AddrLookupSize ; Round up end address
        SUB     r3, r3, r1
        ADD     r0, r0, r1, LSR #30-DynArea_AddrLookupBits
DAR_adloop
        LDR     lr, [r0], #4
        TEQ     lr, r10
        BNE     DAR_adnext
        ; Update to point to next DA, or null if next is outside this chunk
        LDR     lr, [lr, #DANode_Link]
        TEQ     lr, #0
        STREQ   lr, [r0, #-4]
        BEQ     DAR_adnext
        LDR     r4, [lr, #DANode_Flags]
        LDR     r2, [lr, #DANode_Base]
        TST     r4, #DynAreaFlags_DoublyMapped
        LDRNE   r4, [lr, #DANode_MaxSize]
        SUBNE   r2, r2, r4
        AND     r2, r2, #DynArea_AddrLookupMask
        TEQ     r2, r1
        MOVNE   lr, #0
        STR     lr, [r0, #-4]
DAR_adnext
        SUBS    r3, r3, #DynArea_AddrLookupSize
        ADD     r1, r1, #DynArea_AddrLookupSize
        BNE     DAR_adloop
        Pull    "r0-r4,r7,r8,r11"
a3012 10
; Initialise the address lookup table for the current DA's
; Assumes we have at least one DA to start with!
        LDR     r2, =ZeroPage+DAList
        LDR     r2, [r2]
DynArea_AddrLookup_loop
        BL      AddDAToAddrLookupTable
        LDR     r2, [r2, #DANode_Link]
        TEQ     r2, #0
        BNE     DynArea_AddrLookup_loop

@


4.9.2.26
log
@Perform extra TLB maintenance on ARMv6+. Other cache/TLB maintenance tweaks.
Detail:
  s/ARMops - Implement Cache_RangeThreshold for PL310 (helps AMBControl to decide what type of TLB maintenance is best). Fix MMU_ChangingEntry_PL310 doing more work than is necessary; was attempting to flush all ways for a given address tag, when really it should have only been flushing all the lines within a page and letting the cache worry about the tags/indices they correspond to.
  s/ChangeDyn, s/VMSAv6, s/AMBControl/memmap - Do extra TLB maintenance following writes to the page tables, as mandated by the ARMv6+ memory order model. Fixes frequent crashes on Cortex-A9 when running with lazy task swapping disabled (and presumably fixes other crashes too)
  s/MemInfo - Fix OS_Memory cache/uncache so that it does cache/TLB maintenance on a per-page basis instead of a global basis. Vastly improves performance when you have a large cache, but may need tweaking again in future to do a global op if large numbers of pages are being modified.
Admin:
  Tested on Pandaboard


Version 5.35, 4.79.2.255. Tagged as 'Kernel-5_35-4_79_2_255'
@
text
@a3405 20
      [ FastCDA_UpFront :LAND: (MEMM_Type = "VMSAv6")
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        ; N.B. for the case of mapping in a page to an address which was
        ; previously faulting only DSB & ISB are required. For this we rely
        ; on the DSB + ISB performed by the ARMop for the src region
        Push    "r0-r1,r3"
        MOV     r1, r2, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3 ; src region
        LDR     r6, [r11, #DANode_Flags]        ; r6 = src flags
        TST     r6, #DynAreaFlags_DoublyMapped
        LDRNE   r0, [sp]
        SUBNE   r0, r0, r9
        ARMop   MMU_ChangingUncachedEntries,NE,,r3 ; doubly mapped src region
        Pull    "r0-r1,r3"
      ]
a3441 12
      [ FastCDA_UpFront :LAND: (MEMM_Type = "VMSAv6")
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        Push    "r0-r1,r3"
        MOV     r1, r3, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r0-r1,r3"
      ]
a3927 14
      [ FastCDA_UpFront :LAND: (MEMM_Type = "VMSAv6")
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        Push    "r0-r1,r3"
        SUB     r0, r1, r3
        ADD     r1, r3, r2
        MOV     r1, r1, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r0-r1,r3"
      ]
a3963 16
      [ FastCDA_UpFront :LAND: (MEMM_Type = "VMSAv6")
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        ; N.B. for the case of mapping in a page to an address which was
        ; previously faulting (i.e. the dest region) only DSB & ISB are
        ; required. For this we rely on the DSB + ISB performed by the ARMop
        ; for the src region
        Push    "r0-r1,r3"
        MOV     r1, r10, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r0-r1,r3"
      ]
a4134 17
      [ FastCDA_UpFront :LAND: (MEMM_Type = "VMSAv6")
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        ; N.B. for the case of mapping in a page to an address which was
        ; previously faulting (i.e. dest region) only DSB & ISB are required.
        ; For this we rely on the DSB + ISB performed by the ARMop for the src
        ; region
        Push    "r3"
        SUB     r0, r0, r3
        MOV     r1, r3, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r3"
      ]
a4556 17
      [ FastCDA_UpFront :LAND: (MEMM_Type = "VMSAv6")
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        ; N.B. for the case of mapping in a page to an address which was
        ; previously faulting (i.e. dest region) only DSB & ISB are required.
        ; For this we rely on the DSB + ISB performed by the ARMop for the src
        ; region
        Push    "r3"
        SUB     r0, r0, r3
        MOV     r1, r3, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r3"
      ]
a4590 16
      [ FastCDA_UpFront :LAND: (MEMM_Type = "VMSAv6")
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        ; N.B. for the case of mapping in a page to an address which was
        ; previously faulting (i.e. dest region) only DSB & ISB are required.
        ; For this we rely on the DSB + ISB performed by the ARMop for the src
        ; region
        Push    "r0-r1,r3"
        MOV     r1, r2, LSR #12
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncachedEntries,,,r3
        Pull    "r0-r1,r3"
      ]
@


4.9.2.27
log
@Add extra OS_DynamicArea subreason
Subreason 20 takes a logical address and tells you which area it lies in, including system areas (ie. those returned by OS_Memory 16.
This allows areas to change type in future without the caller needing to care where the kernel put it.

Version 5.35, 4.79.2.267. Tagged as 'Kernel-5_35-4_79_2_267'
@
text
@d497 1
a497 1
        CMP     r0, #ChangeDyn_AplSpace         ; if finding out about app space
d768 1
a768 2
DAReason_LocateAddress   * 20
DAReason_Limit           * 21   ;end of defined DA reasons
a864 11
        B       DynArea_Unknown ; 11
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; | 
        B       DynArea_Unknown ; |--Reserved for ROL 
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; |
        B       DynArea_Unknown ; 19
        B       DynArea_Locate

a2227 83
;       DynArea_Locate - Return area number given an address
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (20)
;       r1 = logical address to locate
;
; out:  r0 = area type (0=dynamic, 1=system, others reserved)
;       r1 = area number
;       r10-r12 may be corrupted
;       All other registers preserved
;

DynArea_Locate Entry "r2-r5"
        MOV     r5, r1

        MOV     r4, #1
10
        MOV     r0, r4, LSL #8
        BL      MemoryAreaInfo
        BVS     %FT20                           ; no more system areas

        ADD     r2, r1, r2                      ; r1:=base r2:=top
        CMP     r5, r1
        CMPCS   r2, r5
        MOVHI   r1, r4                          ; number
        MOVHI   r0, #1                          ; system area
        EXIT    HI

        ADD     r4, r4, #1
        B       %BT10
20
  [ DynArea_QuickHandles
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]

        ADR     r3, DynArea_SysQHandleArray
        MOV     r4, #0
30
        LDR     r10, [r3, r4, LSL #2]
        TEQ     r10, #0
        BLNE    %FT60                           ; check system DA node

        ADD     r4, r4, #1
        CMP     r4, #ChangeDyn_MaxArea
        BLS     %BT30

        ADR     r3, DynArea_QHandleArray
        MOV     r4, #0
40
        LDR     r10, [r3, r4, LSL #2]
        CMP     r10, #DynArea_NumQHandles
        BLHI    %FT60                           ; check quick DA node

        ADD     r4, r4, #1
        CMP     r4, #DynArea_NumQHandles
        BCC     %BT40
  ]
        LDR     r10, =ZeroPage+DAList
        ASSERT  DANode_Link = 0                 ; because DAList has only link
50
        LDR     r10, [r10, #DANode_Link]
        TEQ     r10, #0
        PullEnv EQ
        ADREQL  r0, ErrorBlock_BadAddress
        BEQ     DynArea_ReturnError

        BL      %FT60                           ; check treacle DA node
        B       %BT50
60
        LDR     r1, [r10, #DANode_Base]
        LDR     r2, [r10, #DANode_Size]
        ADD     r2, r1, r2                      ; r1:=base r2:=top
        CMP     r5, r1
        CMPCS   r2, r5
        LDRHI   r1, [r10, #DANode_Number]       ; number
        MOVHI   r0, #0                          ; dynamic area
        EXIT    HI

        MOV     pc, lr                          ; not within this one

;**************************************************************************
;
@


4.9.2.28
log
@Enable high processor vectors/zero page relocation. OS_DynamicArea 20 fixes.
Detail:
  Makefile, hdr/Options - By default enable high processor vectors/zero page relocation for compatible machines, but also allow the components file to override the setting if required
  s/ChangeDyn - Fix OS_DynamicArea 20 to check the correct range for doubly mapped areas, and to correctly localise its error message
Admin:
  Tested on Iyonix


Version 5.35, 4.79.2.268. Tagged as 'Kernel-5_35-4_79_2_268'
@
text
@d2305 1
a2305 1
        BEQ     DynArea_TranslateAndReturnError
a2309 3
        LDR     r1, [r10, #DANode_Flags]
        LDR     r0, [r10, #DANode_Size]
        TST     r1, #DynAreaFlags_DoublyMapped
d2311 2
a2312 2
        ADD     r2, r1, r0                      ; r1:=base r2:=top
        SUBNE   r1, r1, r0                      ; doubly mapped is special
@


4.9.2.29
log
@Improve support for VMSAv6 cache policies & memory types. Expose raw ARMops via OS_MMUControl & cache information via OS_PlatformFeatures.
Detail:
  Docs/HAL/ARMop_API - Document two new ARMops: Cache_Examine and IMB_List
  hdr/KernelWS - Shuffle workspace round a bit to allow space for the two new ARMops. IOSystemType now deleted (has been deprecated and fixed at 0 for some time)
  s/ARM600 - Cosmetic changes to BangCam to make it clearer what's going on. Add OS_MMUControl 2 (get ARMop) implementation.
  s/ARMops - Switch out different ARMop implementations and XCB tables depending on MMU model - helps reduce assembler warnings and make it clearer what code paths are and aren't possible. Add implementations of the two new ARMops. Simplify ARM_Analyse_Fancy by removing some tests which we know will have certain results. Use CCSIDR constants in ARMv7 ARMops instead of magic numbers. Update XCB table comments, and add a new table for VMSAv6
  s/ChangeDyn - Define constant for the new NCB 'idempotent' cache policy (VMSAv6 normal, non-cacheable memory)
  s/HAL - Use CCSIDR constants instead of magic numbers. Extend RISCOS_MapInIO to allow the TEX bits to be specified.
  s/Kernel - OS_PlatformFeatures 33 (read cache information) implementation (actually, just calls through to an ARMop)
  s/MemInfo - Modify VMSAv6 OS_Memory 0 cache/uncache implementation to use the XCB table instead of modifying L2_C directly. This allows the cacheability to be changed without affecting the memory type - important for e.g. unaligned accesses to work correctly. Implement cache policy support for OS_Memory 13.
  s/Middle - Remove IOSystemType from OS_ReadSysInfo 6.
  s/VMSAv6 - Make sure BangCam uses the XCB table for working out the attributes of temp-uncacheable pages instead of manipulating L2_C directly. Add OS_MMUControl 2 implementation.
  s/AMBControl/memmap - Update VMSAv6 page table pokeing to use XCB table
  s/PMF/osinit - Remove IOSystemType reference, and switch out some pre-HAL code that was trying to use IOSystemType.
Admin:
  Tested on Iyonix, ARM11, Cortex-A7, -A8, -A9, -A15
  Note that contrary to the comments in the source the default NCB policy currently maps to VMSAv6 Device memory type (as per previous kernel versions). This is just a temporary measure, and it will be switched over to Normal, non-cacheable once appropriate memory barriers have been added to the affected IO code.


Version 5.35, 4.79.2.273. Tagged as 'Kernel-5_35-4_79_2_273'
@
text
@d796 1
a796 1
CP_NCB_Default                  * 0             ; OS decides buffer policy (currently always MergingIdempotent)
a798 1
CP_NCB_MergingIdempotent        * 3             ; Merging write buffer with idempotent memory (i.e. VMSA "Normal" non-cacheable type). If not available, merging write buffer.
@


4.9.2.30
log
@Add initial support for "physical memory pools"
Detail:
  This set of changes adds support for "physical memory pools" (aka PMPs), a new type of dynamic area which allow physical pages to be claimed/allocated without mapping them in to the logical address space. PMPs have full control over which physical pages they use (similar to DAs which request specific physical pages), and also have full control over the logical mapping of their pages (which pages go where, and per-page access/cacheability control).
  Currently the OS makes use of two PMPs: one for the free pool (which now has a logical size of zero - freeing up gigabytes of logical space), and one for the RAM disc (logical size of 1MB, allowing for a physical size limited only by the amount of free memory)
  Implementing these changes has required a number of other changes to be made:
  * The CAM has been expanded from 8 bytes per entry to 16 bytes per entry, in order to allow each RAM page to store information about its PMP association
  * The system heap has been expanded to 32MB in size (from just under 4MB), in order to allow it to be used to store PMP page lists (1 word needed per page, but PMP pages may not always have physical pages assigned to them - so to allow multiple large PMPs to exist we need more than just 1 word per RAM page)
  * The &FA000000-&FBFFFFFF area of fixed kernel workspace has been shuffled around to accomodate the larger CAM, and the system heap is now located just above the RMA.
  * SoftResets code stripped out (unlikely we'll ever want to fix and re-enable it)
  * A couple of FastCDA options are now permanently on
  * Internal page flags shuffled around a bit. PageFlags_Unavailable now publicly exposed so that PMP clients can lock/unlock pages at will.
  * When OS_ChangeDynamicArea is asked to grow or shrink the free pool, it now implicitly converts it into a shrink or grow of application space (which is what would happen anyway). This simplifies the implementation; during a grow, pages (or replacement pages) are always sourced from the free pool, and during a shrink pages are always sent to the free pool.
  File changes:
  - hdr/KernelWS - Extend DANode structure. Describe CAM format. Adjust kernel workspace.
  - hdr/OSRSI6, s/Middle - Add new item to expose the CAM format
  - hdr/Options - Remove SoftResets switch. Add some PMP switches.
  - s/ARM600, s/VMSAv6 - Updated for new CAM format. Note that although the CAM stores PMP information, BangCamUpdate currently doesn't deal with updating that data - it's the caller's responsibility to do so where appropriate.
  - s/ChangeDyn - Lots of changes to implement PMP support, and to cope with the new CAM format.
  - s/HAL - Updated to cope with new CAM format, and lack of logical mapping of free pool.
  - s/MemInfo - Updated to cope with new CAM format. OS_Memory 0 updated to cope with converting PPN to PA for pages which are mapped out. OS_Memory 24 updated to decode the access permissions on a per-page basis for PMPs, and fixed its HWM usage for sparse DAs.
  - s/NewReset - Soft reset code and unused AddCamEntries function removed. Updated to cope with new CAM format, PMP free pool, PMP RAMFS
  - s/AMBControl/allocate - Update comment (RMA hasn't been used for AMBControl nodes for a long time)
  - s/AMBControl/growp, s/AMBControl/memmap, s/AMBControl/shrinkp - Update for new CAM format + PMP free pool
  - s/vdu/vdudriver - Strip out soft reset code.
Admin:
  Tested on Pandaboard
  This is just a first iteration of the PMP feature, with any luck future changes will improve functionality. This means APIs are subject to change as well.


Version 5.35, 4.79.2.284. Tagged as 'Kernel-5_35-4_79_2_284'
@
text
@d25 6
d124 1
a124 1
AP_FreePool     *       2 :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_PMP
a153 2
DAHandler_Abort         *       5       ; ROL abortable DAs
DAHandler_ResizePMP     *       6       ; Called on OS_ChangeDynamicArea
d332 1
a332 3
        ADD     r1, r1, r2, LSL #CAM_EntrySizeLog2 ; point at cam entry (logaddr, PPL)
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
a527 3
        LDR     r11, [r10, #DANode_Flags]
        TST     r11, #DynAreaFlags_PMP
        BNE     %FT01
d531 1
d535 1
a535 16
        SUBNE   r0, r0, r1                      ; if doubly mapped then return start of 1st copy for compatibility
        ExitSWIHandler
01
        ; Convert physical parameters into byte counts
        CMP     r0, #&80
        BCC     %FT02
        LDR     r2, [r10, #DANode_PMPMaxSize]
        CMP     r2, #DynArea_PMP_BigPageCount
        MOVLO   r2, r2, LSL #12
        LDRHS   r2, =DynArea_PMP_BigByteCount
02
        LDR     r1, [r10, #DANode_PMPSize]
        CMP     r1, #DynArea_PMP_BigPageCount
        MOVLO   r1, r1, LSL #12
        LDRHS   r1, =DynArea_PMP_BigByteCount
        LDR     r0, [r10, #DANode_Base]
d590 1
a590 3
        ADD     r11, r10, r12, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
d619 1
a619 1
        ADD     r9, r14, r9, LSL #CAM_EntrySizeLog2 ; r9 -> first word of last entry in cam map
d636 1
a636 1
        ADD     r10, r14, r10, LSL #CAM_EntrySizeLog2 ; form address with 'guess' page
d640 1
a640 1
        LDR     r12, [r10, #CAM_LogAddr]        ; load address from guessed page
d654 1
a654 1
        SUBEQ   r10, r9, #CAM_EntrySizeLog2     ; then invalid page so go from last one
d660 1
a660 1
        SUB     r10, r14, #CAM_EntrySize
a666 1
        ASSERT  CAM_EntrySizeLog2 <= 16
d668 1
a668 1
        ADDCS   r10, r10, r7, LSR #12-CAM_EntrySizeLog2 ; then advance CAM entry position
d671 1
a671 1
        ADD     r10, r10, r6, LSL #CAM_EntrySizeLog2 ; advance by 2 words for each page in this bank
d673 1
a673 1
        SUBCS   r10, r9, #CAM_EntrySize         ; search from last one, to fail quickly (if CS)
d678 1
a678 2
        ASSERT  CAM_LogAddr=0
        LDRNE   r12, [r10, #CAM_EntrySize]!     ; then get logical address
d687 1
a687 1
        LDREQ   r12, [r10, #CAM_PageFlags]      ; if match, then r12 = PPL
d689 1
a689 1
        MOVEQ   r10, r10, LSR #CAM_EntrySizeLog2
d712 2
a713 1
; BangCamUpdate takes entry no in r2, logaddr to set to in r3, r11 = PPL
d718 1
a718 2
        LDR     r9, [r9, #CamEntriesPointer]
        ADD     r9, r9, #CAM_PageFlags
a729 6
        ; Ensure PMP membership flag is retained - just in case caller doesn't
        ; know what he's doing
        LDR     r0, [r9, r2, LSL #CAM_EntrySizeLog2]
        AND     r0, r0, #DynAreaFlags_PMP
        BIC     r11, r11, #DynAreaFlags_PMP
        ORR     r11, r11, r0
d769 1
a769 6
DAReason_PMP_PhysOp      * 21
DAReason_PMP_LogOp       * 22
DAReason_PMP_Resize      * 23
DAReason_PMP_GetInfo     * 24
DAReason_PMP_GetPages    * 25
DAReason_Limit           * 26   ;end of defined DA reasons
d774 1
a774 2
DynArea_PMP_BigPageCount * 1:SHL:(31-12) ; If PMP has >= this many pages...
DynArea_PMP_BigByteCount * &7FFFF000     ; Then convert to this byte value
a811 4
; Bits 16-19 are used by RISCOS Ltd. We can reuse them for internal flags, but
; should probably avoid allocating any public flags.
DynAreaFlags_PMP                *  1 :SHL: 20   ; DA is backed by PMP/page is member of PMP

d813 3
a815 2
; Public page flags (note - may overlap DA flags)
; DynAreaFlags_[PMP]AccessMask also describes public page flags
d817 1
a817 2
PageFlags_Unavailable           *  1 :SHL: 15                      ; physical page has been claimed by someone for exclusive use (can't be requested by PreGrow handler or PMP PhysOp page list)

d819 1
a819 1
; Internal page flags (note - may overlap DA flags)
d823 1
a823 2
PageFlags_Required              *  1 :SHL: 21                      ; physical page asked for by handler (only set temporarily)

d825 1
a825 1
; Temporary flags only used by kernel (note - may overlap DA flags)
d827 2
a828 8
PageFlags_Unsafe                *  1 :SHL: 31                      ; skip cache/TLB maintenance in BangCamUpdate. flag not saved to CAM map.

; Mask to convert DANode_Flags to page flags
DynAreaFlags_AccessMask * DynAreaFlags_APBits :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped :OR: DynAreaFlags_CPBits :OR: DynAreaFlags_PMP
; PMP LogOp can specify these flags
DynAreaFlags_PMPLogOpAccessMask * (DynAreaFlags_AccessMask :OR: PageFlags_Unavailable) :AND: :NOT: (DynAreaFlags_DoublyMapped :OR: DynAreaFlags_PMP)
; PMP PhysOp can specify these flags
DynAreaFlags_PMPPhysOpAccessMask * PageFlags_Unavailable
a876 5
        B       DynArea_PMP_PhysOp
        B       DynArea_PMP_LogOp
        B       DynArea_PMP_Resize
        B       DynArea_PMP_GetInfo
        B       DynArea_PMP_GetPages
d917 1
a917 3
;               bits 16-19 used by ROL
;               bit 20 = 1 => area is backed by physical memory pool
;               other bits reserved for future expansion + internal page flags (should be 0)
d919 1
a919 1
;       r5 = maximum size of logical area, or -1 for total RAM size
a922 1
;       r9 = initial physical area size limit, in pages (physical memory pools), otherwise ignored
a961 2
        MakeErrorBlock  BadDynamicAreaOptions
        MakeErrorBlock  BadPageNumber
a990 22
; Check PMP settings
; If PMP is requested:
; * Must require specific pages
; * Mustn't be sparse
; * Mustn't be doubly mapped
; * Mustn't be requesting DMA auto-alloc
; * Must be zero initial size
; * Must have handler code
; Some of these restrictions may be lifted in future (e.g. if not requesting specific pages, kernel could implement OS_ChangeDynamicArea?)
        TST     r4, #DynAreaFlags_PMP
        BEQ     %FT21
        LDR     r11, =DynAreaFlags_DoublyMapped+DynAreaFlags_NeedsSpecificPages+DynAreaFlags_SparseMap+DynAreaFlags_NeedsDMA
        AND     r11, r4, r11
        TEQ     r11, #DynAreaFlags_NeedsSpecificPages
        TEQEQ   r2, #0
        ADRNE   r0, ErrorBlock_BadDynamicAreaOptions
        BNE     DynArea_ErrorTranslateAndExit
        TEQ     r6, #0
        ADREQ   r0, ErrorBlock_BadDynamicAreaOptions
        BEQ     DynArea_ErrorTranslateAndExit
21

a1034 3
        TEQ     r5, #0                  ; If no logical size (i.e. purely physical PMP)
        MOVEQ   r3, #0                  ; Then set base addr to 0
        BEQ     %FT41                   ; And skip straight to claiming the DANode
a1057 1
41
a1096 35
        TST     r4, #DynAreaFlags_PMP
        STR     r7, [r2, #DANode_PMP]
        STREQ   r7, [r2, #DANode_PMPMaxSize]
        STR     r7, [r2, #DANode_PMPSize]
        BEQ     %FT44
        STR     r3, [r2, #DANode_SparseHWM]
        TEQ     r9, #0
        STR     r9, [r2, #DANode_PMPMaxSize]
        BEQ     %FT44
        ; Allocate and initialise PMP for this DA
        Push    "r0-r3"
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #MaxCamEntry]
        CMP     r9, r0
        ADDHI   r9, r0, #1
        MOV     r3, r9, LSL #2
        BL      ClaimSysHeapNode
        BVS     %FT43
        MOV     r10, r2
        MOV     r0, #-1
42
        SUBS    r3, r3, #4
        STR     r0, [r2], #4
        BNE     %BT42
        Pull    "r0-r3"
        STR     r10, [r2, #DANode_PMP]
        B       %FT44
43
        STR     r0, [sp]
        LDR     r2, [sp, #8]
        BL      FreeSysHeapNode
        Pull    "r0-r3"
        SETV
        B       %BT25
44
d1175 1
a1175 1
        ASSERT  DANode_Link = 0                 ; For picking up pointer to first real node
d1205 1
a1205 2
        CMP     r1, #0                          ; skip redundant SWI
        SWINE   XOS_ChangeDynamicArea           ; deal with error - r0,r1,r2 still stacked
d1347 1
a1347 1
AddDAToAddrLookupTable ROUT
a1348 1
        LDR     r3, [r2, #DANode_MaxSize]
a1349 1
        TEQ     r3, #0
d1351 1
a1351 1
        BEQ     %FT90
a1373 1
90
d1396 4
a1399 2
        LDR     lr,[r10,#DANode_Flags]
        TST     lr,#DynAreaFlags_SparseMap
a1410 60
        TST     lr, #DynAreaFlags_PMP
        BEQ     DAR_notPMP
        ; Unmap all pages from logical space
        ; This is a bit of a simplistic approach - request for everything to
        ; be unmapped and leave it to PMP_LogOp to detect which pages are and
        ; aren't there
        Push    "r1-r8"
        LDR     r6, [r10, #DANode_Base]
        MOV     r3, #0
        LDR     r4, [r10, #DANode_SparseHWM] ; Assume HWM valid
        MOV     r5, #-1
        SUB     r4, r4, r6
        MOV     r6, #0
        MOV     r4, r4, LSR #12
        MOV     r8, sp
DAR_PMP_logloop
        SUBS    r4, r4, #1
        BLT     DAR_PMP_logunmap
        STMDB   sp!, {r4-r6}
        ADD     r3, r3, #1
        CMP     r3, #85 ; Limit to 1K stack
        BLT     DAR_PMP_logloop
DAR_PMP_logunmap
        MOV     r0, #DAReason_PMP_LogOp
        MOV     r2, sp
        SWI     XOS_DynamicArea
        MOV     sp, r8
        Pull    "r1-r8", VS
        EXIT    VS
        CMP     r4, #0
        MOV     r3, #0
        BGT     DAR_PMP_logloop
        ; Pages are all unmapped, now release them from the PMP
        LDR     r4, [r10, #DANode_PMPMaxSize]
        LDR     r7, [r10, #DANode_PMP]
        MOV     r3, #0
DAR_PMP_physloop
        SUBS    r4, r4, #1
        BLT     DAR_PMP_physunmap
        LDR     lr, [r7, r4, LSL #2]
        CMP     lr, #-1                 ; Save some effort and only release pages which exist
        STMNEDB sp!, {r4-r6}
        ADDNE   r3, r3, #1
        CMP     r3, #85 ; Limit to 1K stack
        BLT     DAR_PMP_physloop
DAR_PMP_physunmap
        MOV     r0, #DAReason_PMP_PhysOp
        MOV     r2, sp
        SWI     XOS_DynamicArea
        MOV     sp, r8
        Pull    "r1-r7", VS
        EXIT    VS
        CMP     r4, #0
        MOV     r3, #0
        BGT     DAR_PMP_physloop
        ; All pages released, safe to free area
        Pull    "r1-r8"
        MOV     r0, #DAReason_Remove
        B       DAR_delink
DAR_notPMP
d1429 2
a1430 2
        RSBS    r1, r2, #0              ; negate it
        SWINE   XOS_ChangeDynamicArea
a1454 1
        LDR     r3, [r10, #DANode_MaxSize]
a1455 1
        TEQ     r3, #0
d1457 1
a1457 1
        BEQ     DAR_addone
a1490 1
DAR_addone
a1526 3
        LDR     r2, [r10, #DANode_PMP]
        CMP     r2, #0
        BLNE    FreeSysHeapNode
d1627 2
d1630 1
a1630 1
        LDR     r3, [r10, #DANode_Base]
a1631 13
        TST     r4, #DynAreaFlags_PMP
        LDREQ   r2, [r10, #DANode_Size]
        LDREQ   r5, [r10, #DANode_MaxSize]
        BEQ     %FT10
        LDR     r2, [r10, #DANode_PMPSize]
        LDR     r5, [r10, #DANode_PMPMaxSize]
        CMP     r2, #DynArea_PMP_BigPageCount
        MOVLO   r2, r2, LSL #12
        LDRHS   r2, =DynArea_PMP_BigByteCount
        CMP     r5, #DynArea_PMP_BigPageCount
        MOVLO   r5, r5, LSL #12
        LDRHS   r5, =DynArea_PMP_BigByteCount
10
d1734 1
a1734 1
        LDR     r4, [r10, #DANode_Flags]        ; return rest of info
d1736 2
a1738 13
        TST     r4, #DynAreaFlags_PMP
        LDREQ   r2, [r10, #DANode_Size]
        LDREQ   r5, [r10, #DANode_MaxSize]
        BEQ     %FT11
        LDR     r2, [r10, #DANode_PMPSize]
        LDR     r5, [r10, #DANode_PMPMaxSize]
        CMP     r2, #DynArea_PMP_BigPageCount
        MOVLO   r2, r2, LSL #12
        LDRHS   r2, =DynArea_PMP_BigByteCount
        CMP     r5, #DynArea_PMP_BigPageCount
        MOVLO   r5, r5, LSL #12
        LDRHS   r5, =DynArea_PMP_BigByteCount
11
d1900 1
a1900 1
        LDR     r5,=L2PT
d2203 1
a2203 1
        LDR     r2, [r2, #FreePoolDANode + DANode_PMPSize] ; start with current size of free pool
d2221 1
a2221 1
        BEQ     %FT90                           ; then exit, with r2 = correct value
d2234 1
a2234 1
        ADD     r2, r2, r3, LSR #12             ; add on amount if any
a2236 6

90
        CMP     r2, #DynArea_PMP_BigPageCount
        MOVLO   r2, r2, LSL #12
        LDRHS   r2, =DynArea_PMP_BigByteCount
        EXIT
d2327 1
a2327 1
;       DynArea_PMP_PhysOp
d2329 1
a2329 1
;  Claim/release physical memory pages in physical memory pool
d2331 21
a2351 22
; in:   r0 = reason code (21)
;       r1 = area number
;       r2 = pointer to array of (PMP page index, phys page index, PMP page flag) tuples
;            phys page index -1 to release
;            phys page index -2 to let kernel pick page
;            otherwise page number to use
;            PMP page flags are defined by DynAreaFlags_PMPPhysOpAccessMask
;       r3 = number of entries
;
; out:  r0-r1 preserved (error if not all of region successfully updated)
;       r2 advanced to first entry not processed (or end of list)
;       r3 updated to number of entries not processed (or 0)
;       r10-r12 may be corrupted
;
DynArea_PMP_PhysOp ROUT
        ; Strategy:
        ; - Check free pool has enough pages to satisfy claim
        ; - Walk page list, comparing against current PMP state
        ; - If free required, check not in use and push straight into free pool
        ; - If kernel auto-alloc required, grab last page from free pool
        ; - If specific page required, batcall into OS_ChangeDynamicArea to let it deal with page reclaiming
        Entry   "r0-r9"
d2353 6
a2358 3
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
d2360 37
a2396 19
        BCC     %FT90                   ; [it doesn't]
        ; r10 -> DANode
        LDR     r8, [r10, #DANode_PMP]
        CMP     r8, #0
        LDR     r9, [r10, #DANode_PMPMaxSize]
        BEQ     %FT90
        LDR     r7, =ZeroPage
        LDR     r11, [r7, #MaxCamEntry]
        LDR     r7, [r7, #CamEntriesPointer]
        BL      ClaimCDASemaphore
        BNE     %FT91
        ; Before we begin, check to see if there's enough space in the free pool to satisfy any map in requests
        LDR     r0, [r7, #FreePoolDANode+DANode_PMPSize]
        CMP     r0, r3
        BHS     %FT45
        ; Free pool may be too small - scan the page list and the PMP to work out exactly how many pages are required
        ; If there aren't enough, try growing the free pool (shrink app space, shrink shrinkables, etc.)
        MOV     r12, #0
        MOV     r1, #0
d2398 25
a2422 41
        SUBS    r3, r3, #1
        BLO     %FT20
        LDMIA   r2!, {r4-r6}
        ; Check for silly PMP page index
        CMP     r4, r9
        BHS     %FT92
        ; Check for silly phys page index
        CMP     r5, #-3
        CMPLS   r11, r5
        BLS     %FT92
        ; Look up the page that's currently in the PMP
        LDR     r0, [r8, r4, LSL #2]
        TEQ     r0, r5
        BEQ     %BT10
        ; Do we need to release the existing page?
        CMP     r0, #-1
        BEQ     %FT15
        CMP     r5, #-2
        BEQ     %BT10                   ; Page is currently there, and we want a kernel picked page -> no action required
        ; A page is currently there, but we either want to release it or to swap in a different page.
        SUB     r12, r12, #1            ; Count page release
15
        ; Map in new page if required
        CMP     r5, #-2
        BHI     %BT10 ; i.e. -1
        ADD     r12, r12, #1            ; Count page claim
        ; Because we process list entries in order, we actually need to keep track of the maximum number of pages needed in the free pool at any point in the list, rather than just the delta we'll have at the end
        CMP     r12, r1
        MOVGT   r1, r12
        B       %BT10
20
        ; r1 = number of pages needed in free pool
      [ PMPDebug
        DebugReg r1, "Want this many pages: "
      ]
        MOV     r12, r10
        BL      GrowFreePool
        BCC     %FT94
        ; Enough space is available, reset r2 & r3 and process the list properly
        FRAMLDR r2
        FRAMLDR r3
d2424 3
a2426 173
45
        LDR     r12, [r10, #DANode_PMPSize]
        ; Usage in main loop:
        ; r2 -> input page list
        ; r3 = length
        ; r4 = current entry PMP index
        ; r5 = current entry phys page index
        ; r6 = current entry flags
        ; r7 -> CAM
        ; r8 -> PMP
        ; r9 = PMPMaxSize
        ; r10 -> DANode
        ; r11 = MaxCamEntry
        ; r12 = current PMPSize
        ; r0, r1 temp
50
        SUBS    r3, r3, #1
        BLO     %FT80
        LDMIA   r2!, {r4-r6}
        ; Check for silly PMP page index
        CMP     r4, r9
        BHS     %FT93
        ; Check for silly phys page index
        CMP     r5, #-3
        CMPLS   r11, r5
        BLS     %FT93
        AND     r6, r6, #DynAreaFlags_PMPPhysOpAccessMask
        ; Look up the page that's currently in the PMP
        LDR     r0, [r8, r4, LSL #2]
        TEQ     r0, r5
        BNE     %FT52
        ; Page is there - check/update flags
        ADD     r0, r7, r0, LSL #CAM_EntrySizeLog2
        LDR     r1, [r0, #CAM_PageFlags]
        BIC     lr, r1, #DynAreaFlags_PMPPhysOpAccessMask
        ORR     lr, lr, r6
        TEQ     r1, lr
        STRNE   lr, [r0, #CAM_PageFlags]
        B       %BT50
52
        ; Do we need to release the existing page?
        CMP     r0, #-1
        BEQ     %FT55
        CMP     r5, #-2
        BEQ     %BT50                   ; Page is currently there, and we want a kernel picked page -> no action required
        ; A page is currently there, but we either want to release it or to swap in a different page. Start by releasing the existing page.
        ; TODO - if we're swapping with another page we'll probably want to preserve the contents (have a flag to control behaviour)
        ; Check page isn't mapped in
        ASSERT  CAM_LogAddr=0
        LDR     r1, [r7, r0, LSL #CAM_EntrySizeLog2]
      [ PMPDebug
        DebugReg r0, "Releasing page: "
        DebugReg r1, "Current addr: "
      ]
        LDR     lr, =Nowhere
        TEQ     r1, lr
        BNE     %FT95
        ; Add the page back into the free pool
        Push    "r2-r5,r12"
        LDR     r4, =ZeroPage+FreePoolDANode
        LDR     r12, [r4, #DANode_PMP]
        LDR     r5, [r4, #DANode_PMPSize]
        STR     r0, [r12, r5, LSL #2]
        ADD     r2, r7, r0, LSL #CAM_EntrySizeLog2
        LDR     r3, [r4, #DANode_Flags]
        LDR     lr, =DynAreaFlags_AccessMask
        AND     r3, r3, lr
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        STMIB   r2, {r3-r5}
        ADD     r5, r5, #1
        STR     r5, [r4, #DANode_PMPSize]
        Pull    "r2-r5,r12"
        ; Page no longer owned by us
        MOV     r0, #-1
        STR     r0, [r8, r4, LSL #2]
        SUB     r12, r12, #1
55
        ; Map in new page if required
        CMP     r5, #-2
        BHI     %BT50 ; i.e. -1
        BLO     %FT60
      [ PMPDebug
        DebugTX "Kernel-picking page"
      ]
        ; Kernel-picked page required. Pick the last page from the free pool.
        LDR     r0, =ZeroPage+FreePoolDANode
        LDR     r1, [r0, #DANode_PMP]
        LDR     r5, [r0, #DANode_PMPSize]
        SUBS    r5, r5, #1
        BLO     %FT95                   ; Shouldn't happen
        STR     r5, [r0, #DANode_PMPSize]
        LDR     r5, [r1, r5, LSL #2]!
        MOV     r0, #-1
        STR     r0, [r1]
        ; Add to our PMP
        STR     r5, [r8, r4, LSL #2]
        ADD     r5, r7, r5, LSL #CAM_EntrySizeLog2
        LDR     r0, [r10, #DANode_Flags] ; Use default DA flags, modified by flags given in page list
        LDR     r1, =DynAreaFlags_AccessMask :AND: :NOT: DynAreaFlags_PMPPhysOpAccessMask
        MOV     lr, r4
        AND     r0, r0, r1
        ORR     r0, r0, r6
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        STMIB   r5, {r0,r10,lr}
        ADD     r12, r12, #1
        B       %BT50
60
        ; Check that the requested page isn't locked
        ADD     r0, r7, r5, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMIA   r0, {r0-r1}
      [ PMPDebug
        DebugReg r5, "Claiming page: "
        DebugReg r0, "Current addr: "
        DebugReg r1, "Current flags: "
      ]
        TST     r1, #PageFlags_Unavailable
        BNE     %FT95
        ; Construct a dummy DANode on the stack so we can use a Batcall to map
        ; in the page
        SUB     sp, sp, #DANode_NodeSize
        ; Copy over real node as basis
        MOV     r0, #DANode_NodeSize
61
        SUBS    r0, r0, #4
        LDR     r1, [r10, r0]
        STR     r1, [sp, r0]
        BGT     %BT61
        ; Adjust some parameters to ensure batcall is happy
        LDR     r0, =Nowhere
        STR     r0, [sp, #DANode_Base]
        LDR     lr, =ZeroPage
        MOV     r0, #0
        STR     r0, [lr, #CDASemaphore] ; Temporarily release so batcall will work
        STR     r0, [sp, #DANode_Size]
        MOV     r0, #4096
        STR     r0, [sp, #DANode_MaxSize]
        LDR     r0, [sp, #DANode_Flags] ; Use default DA flags, modified by flags given in page list
        LDR     lr, =DynAreaFlags_AccessMask :AND: :NOT: DynAreaFlags_PMPPhysOpAccessMask
        AND     r0, r0, lr
        ORR     r0, r0, r6
        STR     r0, [sp, #DANode_Flags]
        ; Replace handler routine with our own
        STR     r5, [sp, #DANode_Workspace] ; Required page number is handler param
        ADR     r0, PMPGrowHandler
        STR     r0, [sp, #DANode_Handler]
        ; Make the call
        Push    "r2"
        ADD     r2, sp, #4
        MOV     r0, #ChangeDyn_Batcall
        MOV     r1, #4096
        SWI     XOS_ChangeDynamicArea
        LDR     r2, =ZeroPage
        STR     sp, [r2, #CDASemaphore]
        Pull    "r2"
        ADD     sp, sp, #DANode_NodeSize
        BVS     %FT99
        ; Everything went OK, remember the new page as being ours
        STR     r5, [r8, r4, LSL #2]
        ADD     r5, r7, r5, LSL #CAM_EntrySizeLog2
        STR     r10, [r5, #CAM_PMP]
        STR     r4, [r5, #CAM_PMPIndex]
      [ PMPDebug
        LDR     r5, [r5, #CAM_PageFlags]
        DebugReg r5, "Claimed with flags: "
      ]
        ADD     r12, r12, #1
        B       %BT50
d2428 7
a2434 7
80
        BL      PMPMemoryMoved
        CLRV
        FRAMSTR r2
        MOV     r3, #0
        FRAMSTR r3
        EXIT
d2436 6
a2441 9
90
        PullEnv
        ADRL    r0, ErrorBlock_BadDynamicArea
 [ International
        B       TranslateError
 |
        SETV
        MOV     pc, lr
 ]
d2443 1
a2443 10
91
        ; Failed to claim CDASemaphore
        PullEnv
        ADRL    r0, ErrorBlock_ChDynamNotAllMoved
 [ International
        B       TranslateError
 |
        SETV
        MOV     pc, lr
 ]
d2445 10
a2454 25
92
        ; Error during initial list scan - reset parameters as if nothing's been moved
        FRAMLDR r2
        FRAMLDR r3
        ADD     r2, r2, #12
        SUB     r3, r3, #1
93
      [ PMPDebug
        DebugTX "-> bad physop page number"
      ]
        ADRL    r0, ErrorBlock_BadPageNumber
        B       %FT98

94
        ; Error during initial list scan - reset parameters as if nothing's been moved
        FRAMLDR r2
        FRAMLDR r3
        ADD     r2, r2, #12
        SUB     r3, r3, #1
95
      [ PMPDebug
        DebugTX "-> physop can't move"
      ]
        ADRL    r0, ErrorBlock_ChDynamNotAllMoved
        B       %FT98
d2456 2
a2457 1
98
d2463 1
a2463 8
99
        BL      PMPMemoryMoved
        FRAMSTR r0
        ; Wind r2, r3 back one entry to point to the entry that's causing the problem
        SUB     r2, r2, #12
        ADD     r3, r3, #1
        FRAMSTR r2
        FRAMSTR r3
d2466 25
a2490 917

PMPMemoryMoved ROUT
        EntryS  "r0-r2,r5,r11"
        ; In: r10 -> DANode
        ;     r12 = new size (pages)
        ; Update PMPSize, release CDASemaphore, and issue Service_MemoryMoved
        LDR     r0, [r10, #DANode_PMPSize]
        SUBS    r0, r0, r12
        STR     r12, [r10, #DANode_PMPSize]
        RSBLT   r0, r0, #0
        CMP     r0, #DynArea_PMP_BigPageCount
        MOVLO   r0, r0, LSL #12
        LDRHS   r0, =DynArea_PMP_BigByteCount
        LDR     r2, [r10, #DANode_Number]
        ; Release CDASemaphore
        LDR     r11, =ZeroPage
        MOV     r5, #0
        STR     r5, [r11, #CDASemaphore]
   [ DynArea_QuickHandles
        LDR     r11, [r11, #DynArea_ws]
        LDR     r5, DynArea_OD6Signature
        STR     r5, DynArea_OD6PrevSignature
        ORR     r5, r5, #4              ;signal a resize
        STR     r5, DynArea_OD6Signature
        STR     r2, DynArea_OD6Handle
   ]
        MOV     r1,#Service_MemoryMoved
        BL      Issue_Service
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        EXITS
        

PMPGrowHandler ROUT
        TEQ     r0, #0
        STREQ   r12, [r1]
        MOV     pc, lr       

;**************************************************************************
;
;       DynArea_PMP_LogOp
;
;  Map/unmap pages from logical memory
;
; in:   r0 = reason code (22)
;       r1 = area number
;       r2 = pointer to array of (DA page number, PMP page index, page flags) tuples
;            PMP page index of -1 to unmap (page flags currently ignored)
;            else PMP page index + page flags must be valid
;       r3 = number of entries
;
; out:  r0-r1 preserved (error if not all of region successfully updated)
;       r2 advanced to first entry not processed (or end of list)
;       r3 updated to number of entries not processed (or 0)
;       r10-r12 may be corrupted
;
PMPLogOp_ChunkSize * 384 ; 384 pages = 1.5K stack, or 1.5MB of memory (larger than current max Cache_RangeThreshold - otherwise full cache clean optimisation won't be taken)

                      ^ 0, sp
PMPLogOp_PageList     # PMPLogOp_ChunkSize*4 ; List of pages to map out
PMPLogOp_Unsafe       # 4 ; Nonzero if we've done an 'unsafe' map in
PMPLogOp_CacheFlushed # 4 ; Nonzero if we've done a global cache flush
PMPLogOp_TLBFlushed   # 4 ; Nonzero if we've done a global TLB flush
                      # 4 ; Padding!
PMPLogOp_FrameSize    # 0

DynArea_PMP_LogOp ROUT
        ; This is basically just a wrapper around OS_FindMemMapEntries & OS_SetMemMapEntries
        Entry   "r0-r9", :INDEX:PMPLogOp_FrameSize
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     %FT90                   ; [it doesn't]
        ; r10 -> DANode
        LDR     r7, [r10, #DANode_PMP]
        CMP     r7, #0
        LDR     r9, [r10, #DANode_PMPMaxSize]
        BEQ     %FT90
        BL      ClaimCDASemaphore
        BNE     %FT91
        LDR     r11, [r10, #DANode_MaxSize]
        LDR     r12, [r10, #DANode_Base]
        LDR     r8, =L2PT
        ; Usage in main loop:
        ; r0 = number of cacheable pages being umapped
        ; r1 = offset in temp page list
        ; r2 -> input page list
        ; r3 = length
        ; r4 = current entry DA page index
        ; r5 = current entry PMP page index
        ; r6 = current entry page flags
        ; r7 -> PMP
        ; r8 -> L2PT
        ; r9 -> PMPMaxSize
        ; r10 -> DANode
        ; r11 -> DA max size
        ; r12 -> DA base
        MOV     r0, #0
        STR     r0, PMPLogOp_Unsafe
        STR     r0, PMPLogOp_CacheFlushed
        STR     r0, PMPLogOp_TLBFlushed
        MOV     r1, #0
      [ PMPDebug
        DebugReg r3, "LogOp len "
      ]
05
        ; Examine the first entry and see if it's a request to map in or map out
        CMP     r3, #0
        BEQ     %FT70
06
        LDMIA   r2, {r4-r6}
      [ PMPDebug
        DebugReg r4, "DA page "
        DebugReg r5, "PMP page "
      ]
        ; Check for silly DA page index
        CMP     r4, r11, LSR #12
        BHS     %FT95
        CMP     r5, #-1
        BNE     %FT50
        ; Map out request - get current page
      [ PMPDebug
        DebugTX "-> Map out"
      ]
        ADD     r4, r12, r4, LSL #12
        BL      logical_to_physical
        MOVCS   r5, #-1
        BCS     %FT10
        Push    "r3,r10-r11"
        BL      physical_to_ppn
        MOV     r5, r3
        Pull    "r3,r10-r11"
        BCS     %FT95 ; TODO better error
        ; Check to see if the page is cacheable
        LDR     r6, =ZeroPage
        LDR     r6, [r6, #CamEntriesPointer]
        ADD     r6, r6, #CAM_PageFlags
        LDR     r6, [r6, r5, LSL #CAM_EntrySizeLog2]
        TST     r6, #DynAreaFlags_NotCacheable
        ADDEQ   r0, r0, #1
10
      [ PMPDebug
        DebugReg r5, "Current phys page="
      ]
        LDR     r9, [r10, #DANode_PMPMaxSize] ; restore after logical_to_physical clobbered it
        ; Only add to list if we're mapping out
        CMP     r5, #-1
        STRNE   r5, [sp, r1, LSL #2]
        ADDNE   r1, r1, #1
15
        ADD     r2, r2, #12
        SUB     r3, r3, #1
        CMP     r1, #PMPLogOp_ChunkSize
        BNE     %BT05
        BL      LogOp_MapOut
        MOV     r0, #0
        MOV     r1, #0
        B       %BT05

50
        CMP     r1, #0
        BLNE    LogOp_MapOut
55
        ; Request to map in - examine CAM to see if the page is already at the
        ; requested location (with requested flags)
        CMP     r5, r9
        BHS     %FT95
        LDR     r0, =ZeroPage
        LDR     r5, [r7, r5, LSL #2]
        LDR     r0, [r0, #CamEntriesPointer]
        CMP     r5, #-1
        BEQ     %FT95
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ADD     r0, r0, r5, LSL #CAM_EntrySizeLog2
        LDMIA   r0, {r0, r1}
        LDR     lr, =DynAreaFlags_PMPLogOpAccessMask
      [ PMPDebug
        DebugTX "-> Map in "
      ]
        ADD     r4, r12, r4, LSL #12
      [ PMPDebug
        DebugReg r4, "Log addr "
        DebugReg r5, "Desired phys page "
        DebugReg r6, "Desired flags "
        DebugReg r0, "Page currently at "
        DebugReg r1, "With flags "
      ]
        AND     r6, r6, lr
        BIC     lr, r1, lr
        ORR     r6, r6, lr ; Preserve special flags (e.g. temp uncacheability, PMP membership)
        CMP     r0, r4
        CMPEQ   r6, r1
        BEQ     %FT65
        ; Page needs to be mapped/moved/updated
        Push    "r2-r4,r6,r9,r11"
        MOV     r2, r5
        ; Update our logical size if the page isn't already in position
        CMP     r0, r4
        BEQ     %FT60
        ORR     r6, r6, #PageFlags_Unsafe ; Do unsafe mapping if posible
        ; If the page is currently in our address space, decrease our logical size (-> that mapping is about to go away)
        LDR     r1, [r10, #DANode_Size]
        SUB     lr, r0, r12
        CMP     lr, r11
        SUBLO   r1, r1, #4096
        BICLO   r6, r6, #PageFlags_Unsafe
        ; If there's nothing at the target address, increase our logical size
        BL      logical_to_physical
        ADDCS   r1, r1, #4096
        BICCC   r6, r6, #PageFlags_Unsafe
        STR     r1, [r10, #DANode_Size]
        ; Also update HWM
        BCC     %FT57
      [ PMPDebug
        DebugTX "Nothing at dest addr"
      ]
        LDR     r1, [r10, #DANode_SparseHWM]
        ADD     lr, r4, #4096
        CMP     r1, r4
        STRLS   lr, [r10, #DANode_SparseHWM]
        B       %FT60
57
        ; There's already a page at the target address. Unmap it before we
        ; replace it (BangCamUpdate isn't smart enough to do this for us)
        Push    "r2,r4,r6,r7"
        LDR     r2, =ZeroPage
        LDR     r7, [r2, #MaxCamEntry]
        BL      physical_to_ppn
        BCS     %FT94
      [ PMPDebug
        DebugReg r3, "Unmapping existing page first "
      ]
        LDR     r11, [r2, #CamEntriesPointer]
        MOV     r2, r3
        ADD     r11, r11, r3, LSL #CAM_EntrySizeLog2
        LDR     r3, =Nowhere
        LDR     r11, [r11, #CAM_PageFlags] ; Preserve flags
        ; We should be able to make this an unsafe op if we've already done an appropriate global invalidate
        TST     r11, #DynAreaFlags_NotCacheable
        LDRNE   r7, [sp, #:INDEX:PMPLogOp_TLBFlushed + 6*4 + 4*4]
        LDREQ   r7, [sp, #:INDEX:PMPLogOp_CacheFlushed + 6*4 + 4*4]
        TEQ     r7, #0
        ORRNE   r11, r11, #PageFlags_Unsafe
        BL      BangCamUpdate
        Pull    "r2,r4,r6,r7"
        ; If the above was unsafe, then it means the below can be unsafe too
        AND     r11, r11, #PageFlags_Unsafe
        ORR     r6, r6, r11
60
        ; Call BangCamUpdate
        ; PageFlags_Unsafe will only be set if this is a map in operation
        MOV     r3, r4
        TST     r6, #PageFlags_Unsafe
        ORR     r11, r6, #DynAreaFlags_PMP
        STRNE   pc, [sp, #:INDEX:PMPLogOp_Unsafe + 6*4]
      [ PMPDebug
        DebugReg r11, "Actual flags "
      ]
        BL      BangCamUpdate
        Pull    "r2-r4,r6,r9,r11"
65
        MOV     r0, #0
        MOV     r1, #0
        ADD     r2, r2, #12
        SUBS    r3, r3, #1
        BNE     %BT06
70
        MOV     r4, #0
71      ; R4 = error
        ; Store back progress
        FRAMSTR r2
        FRAMSTR r3
        ; Flush any pending changes
        CMP     r1, #0
        BLNE    LogOp_MapOut
      [ PMPDebug
        DebugReg r3, "# not processed "
        LDR     r3, PMPLogOp_CacheFlushed
        DebugReg r3, "CacheFlushed? "
        LDR     r3, PMPLogOp_TLBFlushed
        DebugReg r3, "TLBFlushed? "
        LDR     r3, PMPLogOp_Unsafe
        DebugReg r3, "Unsafe? "
        LDR     r3, [r10, #DANode_Size]
        DebugReg r3, "Size "
      ]
      [ MEMM_Type = "VMSAv6"
        ; Perform any necessary post maintenance
        LDR     r0, PMPLogOp_TLBFlushed
        TEQ     r0, #0
        BEQ     %FT72
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        ARMop   MMU_ChangingUncached
        B       %FT75
72
        LDR     r0, PMPLogOp_Unsafe
        TEQ     r0, #0
        BEQ     %FT75
        ; DSB + ISB required to ensure effect of page table write is fully
        ; visible (after overwriting a faulting entry)
        myDSB   ,r0
        myISB   ,r0,,y
75
      ]
        ; Release CDASemaphore
        LDR     r1, =ZeroPage
        MOV     r2, #0
        STR     r2, [r1, #CDASemaphore]
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        CLRV
        MOVS    r0, r4
 [ International
        BLNE    TranslateError
 |
        SETV    NE
 ]
        FRAMSTR r0,VS
        EXIT

90
        ADRL    r0, ErrorBlock_BadDynamicArea
        B       %FT92
91
        ADRL    r0, ErrorBlock_ChDynamNotAllMoved
92
 [ International
        BL      TranslateError
 |
        SETV
 ]
        FRAMSTR r0
        EXIT

94
      [ PMPDebug
        DebugTX "-> failed to find page which is currently mapped in"
      ]
        Pull    "r2,r4,r6,r7"
        Pull    "r2-r4,r6,r9,r11"
95
      [ PMPDebug
        DebugTX "-> bad logop page number"
      ]
        ADRL    r4, ErrorBlock_BadPageNumber
        B       %BT71


LogOp_MapOut ROUT
        Entry   "r0-r12"
        ADD     r3, sp, #14*4
        LDR     r12, =ZeroPage
      [ PMPDebug
        DebugReg r1, "Unmapping # pages "
        DebugReg r0, "With # cacheable "
      ]
        ; r0 = number of cacheable pages being unmapped
        ; r1 = number of pages being unmapped
        ; r3 -> list of physical pages to unmap
        MOV     r5, #0
        ; Work out if we should do a global cache/TLB flush
        LDR     r4, [r3, #:INDEX:PMPLogOp_CacheFlushed]
        CMP     r4, #0
        BNE     %FT17
        MOV     r2, r0
        ARMop   Cache_RangeThreshold,,,r12
        CMP     r0, r2, LSL #12
        BHI     %FT10
        ; Global cache flush wanted
      [ PMPDebug
        DebugTX "MMU_Changing"
      ]
        ARMop   MMU_Changing,,,r12
        STR     pc, [r3, #:INDEX:PMPLogOp_CacheFlushed]
        B       %FT15
10
        ; Work out if we should do a global TLB flush
        CMP     r2, #0 ; Only if there are no cacheable pages involved
        BNE     %FT20
        LDR     r4, [r3, #:INDEX:PMPLogOp_TLBFlushed]
        CMP     r4, #0
        BNE     %FT17
        CMP     r1, #32 ; Arbitrary TLB size
        BLO     %FT20
        ; Global TLB/uncached flush wanted
      [ PMPDebug
        DebugTX "MMU_ChangingUncached"
      ]
        ARMop   MMU_ChangingUncached,,,r12
15
        STR     pc, [r3, #:INDEX:PMPLogOp_TLBFlushed]
17
        ORR     r5, r5, #PageFlags_Unsafe
      [ PMPDebug
        DebugTX "Doing unsafe unmap"
      ]
20
        ; Now process the pages
        MOV     r7, r3
        MOV     r8, r1
        LDR     r12, [r12, #CamEntriesPointer]
        LDR     r3, =Nowhere
        LDR     r9, [r10, #DANode_Size]
25
        LDR     r2, [r7], #4
      [ PMPDebug
        DebugReg r2, "Page "
      ]
        ADD     r11, r12, r2, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMIA   r11, {r11, lr}
        TEQ     r11, r3                 ; Check something actually there (mainly to stop DANode_Size going out of sync if page list requests for same page to be unmapped multiple times)
        ORR     r11, lr, r5             ; Retain current flags
        SUBNE   r9, r9, #4096
        BLNE    BangCamUpdate
        SUBS    r8, r8, #1
        BNE     %BT25
        STR     r9, [r10, #DANode_Size]
        EXIT

;**************************************************************************
;
;       DynArea_PMP_Resize
;
;  Physical resize of PMP - increase/decrease number of physical pages supported
;
; in:   r0 = reason code (23)
;       r1 = area number
;       r2 = resize amount (positive/negative page count)
;
; out:  r0-r1 preserved (error if not all of region successfully updated)
;       r2 = amount area has changed by (unsigned page count)
;       r10-r12 may be corrupted
;
DynArea_PMP_Resize ROUT
        Entry   "r0-r5"
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     %FT90                   ; [it doesn't]
        ; r10 -> DANode
      [ PMPDebug
        DebugReg r2, "Resize by: "
      ]
        ; Check CDASemaphore can be claimed, and then release it - we only make
        ; one call to external code so don't have too much to worry about
        ; (things can still go wrong though - e.g. if PMP resize triggers
        ; sys heap resize which then does something silly in
        ; Service_MemoryMoved)
        BL      ClaimCDASemaphore
        BNE     %FT91
        LDR     r3, =ZeroPage
        MOV     r4, #0
        STR     r4, [r3, #CDASemaphore]
        MOVS    r3, r2
        LDR     r5, [r10, #DANode_PMPMaxSize]
        MOVLT   r4, r2
        LDR     r2, [r10, #DANode_PMP]
        BLT     %FT50
        ; Grow by requested amount
        LDR     r4, =ZeroPage
        LDR     r4, [r4, #MaxCamEntry]
        SUB     r4, r4, r5
        ADD     r4, r4, #1              ; Max grow amount
        CMP     r3, r4
        MOVHI   r3, r4
        MOVS    r3, r3, LSL #2          ; -> byte count
        BEQ     %FT99                   ; Get rid of zero-change case
      [ PMPDebug
        DebugReg r3, "Clamped grow bytes: "
        DebugReg r2, "Current PMP: "
        DebugReg r5, "Current PMPMaxSize: "
      ]
        TEQ     r2, #0
        MOVEQ   r0, #HeapReason_Get
        MOVNE   r0, #HeapReason_ExtendBlock
        BL      DoSysHeapOpWithExtension
        BVS     %FT90
      [ PMPDebug
        DebugReg r2, "New PMP: "
      ]
        MOV     r3, r3, LSR #2
      [ PMPDebug
        DebugReg r3, "Return value: "
      ]
        FRAMSTR r3,,r2
        ; Success - initialise new space
        MOV     r4, #-1
10
        SUBS    r3, r3, #1
        STRGE   r4, [r2, r5, LSL #2]
        ADDGE   r5, r5, #1
        BGT     %BT10
        ; Store new details
        STR     r2, [r10, #DANode_PMP]
        STR     r5, [r10, #DANode_PMPMaxSize]
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        EXIT

50
        ; Shrink request. Only shrink if there aren't any pages allocated to
        ; the end of the PMP.
        CMN     r5, r4
        RSBLO   r4, r5, #0              ; Can't shrink more than PMP size
      [ PMPDebug
        DebugReg r4, "Clamped shrink amount: "
      ]
        MOVS    r3, r4, LSL #2
        BEQ     %FT99                   ; No change to make
        ADD     r1, r2, r5, LSL #2
60
        LDR     lr, [r1, #-4]!
        CMP     lr, #-1
        BNE     %FT45
        ADDS    r4, r4, #1
        SUB     r5, r5, #1
        BNE     %BT60
45
        ; r5 = new size
        ; r4 = amount not changed (negative)
        ; r2 = PMP block
      [ PMPDebug
        DebugReg r5, "New size: "
        DebugReg r4, "Not changed: "
        DebugReg r2, "Current PMP: "
      ]
        SUB     r3, r3, r4, LSL #2      ; Calculate new shrink amount
        RSB     r4, r3, #0
        CMP     r5, #0
        MOV     r4, r4, LSR #2          ; Calculate return value
        MOVEQ   r0, #HeapReason_Free
        MOVNE   r0, #HeapReason_ExtendBlock
        BL      DoSysHeapOpWithExtension
        BVS     %FT91
        ; Operation success
        TEQ     r5, #0
        STR     r5, [r10, #DANode_PMPMaxSize]
        MOVEQ   r2, #0
      [ PMPDebug
        DebugReg r2, "New PMP: "
        DebugReg r4, "Return value: "
      ]
        STR     r2, [r10, #DANode_PMP]  ; Paranoia - store back even if we still have a size (just in case ExtendBlock shrink ops gain the ability to move blocks)
        FRAMSTR r4,,r2
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        EXIT

90
        ADRL    r0, ErrorBlock_BadDynamicArea
        B       %FT92
91
        ADRL    r0, ErrorBlock_ChDynamNotAllMoved
92
        ; Failed for some reason.
        ; Note that we don't do anything fancy for grow failures (like try and
        ; do a partial grow) - a grow failure most likely indicates we're low
        ; on system heap space, which is a bad situation to be in.
 [ International
        BL      TranslateError
 |
        SETV
 ]
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        FRAMSTR r0
        MOV     r2, #0
        EXIT

99
        PullEnv
        CLRV
        MOV     r2, #0
      [ PMPParanoid
        BL      ValidatePMPs
      ]
        EXIT


;**************************************************************************
;
;       DynArea_PMP_GetInfo - Get info on a physical memory pool
;
;       Internal routine called by DynamicAreaSWI
;
;       Although designed for use with PMPs, this call works with regular DAs
;       too (just returns logical page counts for r6 & r7)
;
; in:   r0 = reason code (24)
;       r1 = area number
;
; out:  r2 = current logical size of area (bytes)
;       r3 = base logical address
;       r4 = area flags
;       r5 = maximum logical size of area (bytes)
;       r6 = current physical size of area (pages)
;       r7 = maximum physical size of area (pages)
;       r8 -> title string
;       r10-r12 may be corrupted
;       All other registers preserved
;

DynArea_PMP_GetInfo ROUT
        Entry
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     %FT90                   ; [it doesn't]

; r10 -> node, so get info

        LDR     r4, [r10, #DANode_Flags]
        LDR     r2, [r10, #DANode_Size]
        TST     r4, #DynAreaFlags_PMP
        LDR     r3, [r10, #DANode_Base]
        LDR     r5, [r10, #DANode_MaxSize]
        LDRNE   r6, [r10, #DANode_PMPSize]
        LDRNE   r7, [r10, #DANode_PMPMaxSize]
        MOVEQ   r6, r2, LSR #12
        MOVEQ   r7, r5, LSR #12
        LDR     r8, [r10, #DANode_Title]
        CLRV
        EXIT

90
        ADRL    r0, ErrorBlock_BadDynamicArea
 [ International
        BL      TranslateError
 |
        SETV
 ]
        EXIT

;**************************************************************************
;
;       DynArea_PMP_GetPages - Get page mapping info on a physical memory pool
;
;       Internal routine called by DynamicAreaSWI
;
;       Although designed for use with PMPs, this call works with regular DAs
;       too (just returns zero for r6 & r7)
;
; in:   r0 = reason code (25)
;       r1 = area number
;       r2 = pointer to input/output array:
;            +0: PMP page index (filled in on entry)
;            +4: phys page index (filled in on exit, -1 if none)
;            +8: PMP page flags (filled in on exit, 0 if none)
;            +12: DA page index (filled in on exit, -1 if not mapped)
;            +16: page flags (filled in on exit, 0 if not mapped)
;       r3 = number of entries
;
; out:  r0-r3 preserved
;       r10-r12 may be corrupted
;       All other registers preserved
;       Array updated with page details
;

DynArea_PMP_GetPages ROUT
        Entry   "r0-r9"
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     %FT90                   ; [it doesn't]
        ; r10 -> DANode
        LDR     r8, [r10, #DANode_PMP]
        CMP     r8, #0
        BEQ     %FT90
        LDR     r9, [r10, #DANode_PMPMaxSize]
        BEQ     %FT90
        LDR     r7, =ZeroPage
        LDR     r5, [r10, #DANode_Base]
        LDR     r7, [r7, #CamEntriesPointer]
        LDR     r11, =DynAreaFlags_PMPLogOpAccessMask
        LDR     r12, =Nowhere
        ; Usage in main loop:
        ; r2 -> input page list
        ; r3 = length
        ; r4 = current entry PMP index
        ; r5 -> DA base
        ; r7 -> CAM
        ; r8 -> PMP
        ; r9 = PMP size
        ; r10 -> DANode
        ; r11 = PMPLogOpAccessMask
        ; r12 = Nowhere
        ; r0, r1, r5, r6 temp
10
        SUBS    r3, r3, #1
        BLT     %FT80
        LDR     r4, [r2], #4
        ; Check for silly PMP page index
        CMP     r4, r9
        BHS     %FT91
        ; Look up the page that's currently in the PMP
        LDR     r0, [r8, r4, LSL #2]
        MOV     r1, #0                  ; Currently, no flags
        STMIA   r2!, {r0-r1}
        ; Does the page exist?
        CMP     r0, #-1
        ADDNE   r0, r7, r0, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMNEIA r0, {r0-r1}             ; Get log addr, flags from CAM
        TEQNE   r0, r12
        MOVEQ   r0, #-1                 ; No physical page, or not mapped
        SUBNE   r0, r0, r5
        MOVEQ   r1, #0
        MOVNE   r0, r0, LSR #12
        AND     r1, r1, r11             ; Mask returned flags
        STMIA   r2!, {r0-r1}
        B       %BT10

80
        CLRV
        EXIT

90
        ADRL    r0, ErrorBlock_BadDynamicArea
        B       %FT98
91
        ADRL    r0, ErrorBlock_BadPageNumber
98
 [ International
        BL      TranslateError
 |
        SETV
 ]
        EXIT


;**************************************************************************
;
;       CheckAreaNumber - Try to find area with number r1
;
;       Internal routine called by DynArea_Create
;
; in:   r1 = area number to match
; out:  If match, then
;         C=1, r10 -> node, r11 -> previous node
;       else
;         C=0, r10,r11 corrupted
;       endif

CheckAreaNumber Entry
  [ DynArea_QuickHandles
QCheckAreaNumber_nonQ
  ]
        LDR     r10, =ZeroPage+DAList
        ASSERT  DANode_Link = 0                 ; because DAList has only link
10
        MOV     r11, r10                        ; save prev
        LDR     r10, [r10, #DANode_Link]        ; and load next
        CMP     r10, #1                         ; any more nodes?
        EXIT    CC                              ; no, then no match
        LDR     lr, [r10, #DANode_Number]       ; get number
        CMP     lr, r1                          ; does number match
        BNE     %BT10                           ; no, try next
  [ DynArea_QuickHandles
        Push    "r11"
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        STR     r1,  DynArea_LastTreacleHandle
        STR     r10, DynArea_LastTreaclePtr
        Pull    "r11"
  ]
        EXIT                                    ; (C=1 from CMP lr,r1)

  [ DynArea_QuickHandles

; QCheckAreaNumber - similar to CheckAreaNumber, but blisteringly quick for system or for quick
;                    numbers. However, DOES NOT return previous node in r11.
;
QCheckAreaNumber ROUT
        Push    "lr"
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #DynArea_ws]
        CMP     r1, #-1
        BEQ     QCheckAreaNumber_nonQ           ;just to protect against -1 as a proposed number
        LDR     lr, DynArea_LastTreacleHandle
        CMP     lr, r1
        LDREQ   r10, DynArea_LastTreaclePtr
        EXIT    EQ                              ;found node is slow one we handled last time (carry set)
        LDR     lr, DynArea_CreatingHandle
        CMP     lr, r1
        LDREQ   r10, DynArea_CreatingPtr
        EXIT    EQ                              ;found node is one we're creating (carry set)
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT10
        CMP     r1,#DynArea_NewAreas
        BLO     QCheckAreaNumber_nonQ
        SUB     lr, r1, #DynArea_NewAreas
        CMP     lr, #DynArea_NumQHandles
        BHS     QCheckAreaNumber_nonQ
;quick handle
        ADR     r10, DynArea_QHandleArray
        LDR     r10, [r10, lr, LSL #2]
        CMP     r10, #DynArea_NumQHandles
        MOVLS   r10, #0                         ;not a valid pointer
        CMP     r10, #1
        Pull    "pc"                            ;handle free, carry clear
                                                ;or word is ptr to node, carry set
;system handle
10
        ADR     r10, DynArea_SysQHandleArray
        LDR     r10, [r10, r1, LSL #2]
        CMP     r10, #1
        Pull    "pc"                            ;DA does not exist, carry clear
                                                ;or word is ptr to node, carry set
  ] ;DynArea_QuickHandles

;**************************************************************************
;
;       CheckForOverlappingAreas - Check that given area does not overlap any existing ones
;
;       Internal routine called by DynArea_Create
;
; in:   r3 = base address
;       r4 = area flags (NB if doubly mapped, then have to check both halves for overlap)
;       r5 = size (of each half in doubly mapped areas)
;
; out:  If this area overlaps with an existing one, then
;         r0 -> error
;         V=1
;       else
;         r0 preserved
;         V=0
;       endif
;

CheckForOverlappingAreas Entry "r0-r5"
        TST     r4, #DynAreaFlags_DoublyMapped          ; check if doubly mapped
        BEQ     %FT05                                   ; [not, so don't mangle]

        SUBS    r3, r3, r5                              ; move start address back
        BCC     %FT20                                   ; oh dear! - it went back to below 0
        MOVS    r5, r5, LSL #1                          ; and double size
        BCS     %FT20                                   ; if that wrapped then that's bad, too
05
        ADDS    r5, r5, r3                              ; r5 -> end +1
        BHI     %FT20                                   ; if CS, indicating wrap, and not EQ (ie just ending at 0), then bad

  [ HAL
        LDR     lr, =ZeroPage
        LDR     r0, [lr, #IOAllocPtr]
        CMP     r5, r0                                  ; end must be below I/O space (allocated down from high memory)
        BHI     %FT20
  ]

; check against list of fixed areas

        ADR     lr, FixedAreasTable
10
        LDMIA   lr!, {r0, r1}                           ; r0 = start addr, r1 = size
        CMP     r0, #-1                                 ; if at end of list
        BEQ     %FT30                                   ; then OK wrt fixed areas
        ADD     r1, r1, r0                              ; r1 = end addr+1
        CMP     r5, r0                                  ; if end of our area is <= start of fixed, then OK wrt fixed areas
        BLS     %FT30
        CMP     r3, r1                                  ; if start of our area is >= end of fixed, then go onto next area
        BCS     %BT10

20
        ADRL    r0, ErrorBlock_OverlappingAreas
 [ International
        BL      TranslateError
 |
        SETV
 ]
        STR     r0, [sp]
        EXIT

; Now, check against DAList

30
        LDR     lr, =ZeroPage+DAList
        ASSERT  DANode_Link = 0
40
        LDR     lr, [lr, #DANode_Link]
        CMP     lr, #0                                  ; if got to end of list (V=0)
        BEQ     %FT50                                   ; then exit saying OK
        LDR     r0, [lr, #DANode_Base]
        LDR     r1, [lr, #DANode_Flags]
        TST     r1, #DynAreaFlags_DoublyMapped
        LDR     r1, [lr, #DANode_MaxSize]
        SUBNE   r0, r0, r1                              ; if doubly mapped then move back
        MOVNE   r1, r1, LSL #1                          ; and double size
        ADD     r1, r1, r0                              ; r1 -> end
        CMP     r5, r0                                  ; if end of our area is <= start of dyn, then OK wrt dyn areas)
        BLS     %FT50
        CMP     r3, r1                                  ; if start of our area is >= end of dyn, then go onto next area
        BCS     %BT40
        B       %BT20                                   ; else it overlaps

50
        CLRV                                            ; OK exit
        EXIT
d2694 2
a2695 2
        LDR     r6, [r1, #FreePoolDANode + DANode_PMPSize]
        SUBS    r6, r6, r4                              ; reduce free pool size by that many pages
a2702 1
        MOV     r1, r1, LSL #12
d2709 1
a2709 1
        STR     r6, [r1, #FreePoolDANode + DANode_PMPSize] ; if possible then update size
d2711 19
a2729 2
        LDR     r0, [r1, #FreePoolDANode + DANode_PMP]  ; r0 -> free pool page list
        ADD     r0, r0, r6, LSL #2                      ; r0 -> first page we're taking out of free pool
d2740 4
a2743 21
        Push    "r1-r2, r4"
        MOV     lr, #-1
        LDR     r2, [r0]                                ; get page number to use
        STR     lr, [r0], #4                            ; remove from PMP
        Push    "r0"
        BL      BangCamUpdate                           ; Map in to L2PT access window

; now that the page is mapped in we can zero its contents (=> cause translation fault for area initially)
; L1PT won't know about the page yet, so mapping it in with garbage initially shouldn't cause any issues

        ADD     r0, r3, #4096
        MOV     r1, #0
        MOV     r2, #0
        MOV     r4, #0
        MOV     r6, #0
15
        STMDB   r0!, {r1,r2,r4,r6}                      ; store data
        TEQ     r0, r3
        BNE     %BT15

        Pull    "r0-r2, r4"
d2971 1
a2971 1
        ADRL    r0, InitAppSpaceTable
d2976 1
a2976 1
        ADRL    r0, InitFreePoolTable
d2978 1
d2981 68
a3048 2
; Initialise the system heap first - we need it to store the PMP for the free
; pool
a3074 1
; TODO have asserts to check that this all fits OK
a3134 3
      [ PMPDebug
        DebugReg r2, "DynArea_ws="
      ]
a3210 173
; Now that the system heap is initialised we can create a page list for the
; free pool and start pushing the free pages into it. We want the pages at the
; start of the list to be the VRAM block, followed by all the other pages in
; order of increasing speed. However it's highly unlikely that we'll be able to
; build the full page list without having to grow the system heap - for which
; we'd want the fast pages to be available.

; So to cope with this we start by putting the fast pages into the page list,
; growing the system heap for every page we insert (a bit slow but reliable).
; After each grow we try to claim the memory needed for the full page list;
; on success we then switch to a different algorithm which fills the main page
; list.

; TODO - Make sure pages are inserted in an order which keeps them in consecutive physical order when being transferred to a DA (and make sure shrink/grow preserves order!)

        SUB     sp, sp, #4                      ; Store the initial list on the stack
        LDR     r5, =ZeroPage
        ADD     r6, r5, #FreePoolDANode
        STR     sp, [r6, #DANode_PMP]
        MOV     r0, #1
        STR     r0, [r6, #DANode_PMPMaxSize]
        MOV     r0, #0
        STR     r0, [r6, #DANode_PMPSize]
        MOV     r0, #-1
        STR     r0, [sp]

        LDR     r0, [r5, #InitUsedStart]
        ADD     r0, r0, #DRAMOffset_FirstFixed - DRAMOffset_L1PT
        BL      PhysAddrToPageNo
        MOV     r7, r0                          ; r7 = page number of start of static chunk
        LDR     r0, [r5, #InitUsedEnd]
        BL      PhysAddrToPageNo
        SUB     r8, r0, #1                      ; r8 = page number of last page in statics
        ADD     r9, r5, #PhysRamTable
        LDMIA   r9!, {r0, r10}                  ; get VRAM info
        MOV     r10, r10, LSR #12               ; r10 = current page number
        LDR     r4, [r5, #CamEntriesPointer]
10
        LDMIA   r9!, {r0, r11}                  ; get next block
        MOVS    r11, r11, LSR #12               ; if no more blocks left...
        MOVEQ   r10, #0
        ADDEQ   r9, r5, #PhysRamTable           ; ...panic and use the VRAM
        BEQ     %BT10
15
        ; See if we have enough space
        LDR     r3, [r5, #MaxCamEntry]
        ADD     r3, r3, #1
        MOV     r3, r3, LSL #2
        Push    "r3"
        MOV     r0, #HeapReason_Desc
        BL      DoSysHeapOpWithExtension        ; HACK - check space before calling, to avoid crashing when the grow fails and tries to generate an error (vector table not initialised yet, so crashes when UKSWIV is invoked in order to call MessageTrans)
        Pull    "r3"
        SUB     r2, r2, #4096 ; Paranoia
        CMP     r2, r3
        BLT     %FT20
        BL      ClaimSysHeapNode
        BVC     %FT40
        ; Find a page we can use to grow the system heap
20
        CMP     r10, r7
        CMPHS   r8, r10
        BHS     %FT30                           ; page is in statics
        ; Check the CAM map to see if the page is already taken - this will detect the DMA regions, which aren't included in InitUsedStart/InitUsedEnd
        ADD     r0, r4, r10, LSL #CAM_EntrySizeLog2
        LDR     lr, [r0, #CAM_PageFlags]
        TST     lr, #PageFlags_Unavailable
        BNE     %FT30
        ; Found a page, add it to the free pool
        STR     r10, [sp]
        LDR     lr, =AP_FreePool :AND: DynAreaFlags_AccessMask
        STR     lr, [r0, #CAM_PageFlags]
        STR     r6, [r0, #CAM_PMP]
        MOV     lr, #0
        STR     lr, [r0, #CAM_PMPIndex]
        MOV     lr, #1
        STR     lr, [r6, #DANode_PMPSize]
        ; Now grow the system heap by 4K. This had better consume the page!
        MOV     r0, #ChangeDyn_SysHeap
        MOV     r1, #4096
        SWI     XOS_ChangeDynamicArea
30
        ; Move on to next page
        SUBS    r11, r11, #1
        ADD     r10, r10, #1
        BEQ     %BT10
        B       %BT15
40
        ; We've successfully allocated the memory for the PMP - start filling
        ; it in. To ensure the pages are in the correct order we need to fill
        ; it from the last entry working backwards, but unfortunately we don't
        ; know exactly how many pages there are - so once we're done we'll have
        ; to shuffle the list down.
        MOV     r0, r3, LSR #2
      [ PMPDebug
        DebugReg r2, "FreePool PMP="
        DebugReg r0, "PMPMaxSize="
      ]
        STR     r0, [r6, #DANode_PMPMaxSize]
        ADD     r3, r2, r3                      ; -> end of list
        MOV     r1, r3
        STR     r2, [r6, #DANode_PMP]
45
        CMP     r10, r7
        CMPHS   r8, r10
        BHS     %FT50                           ; page is in statics
        ; Check the CAM map to see if the page is already taken - this will detect the DMA regions, which aren't included in InitUsedStart/InitUsedEnd
        ADD     r0, r4, r10, LSL #CAM_EntrySizeLog2
        LDR     lr, [r0, #CAM_PageFlags]
        TST     lr, #PageFlags_Unavailable
        BNE     %FT50
        ; Found a page, add it to the free pool
        STR     r10, [r3, #-4]!
50
        ; Move on to next page
        SUBS    r11, r11, #1
        ADD     r10, r10, #1
        BNE     %BT45
        ADD     lr, r5, #PhysRamTable+8
        CMP     lr, r9                          ; if we've just processed the VRAM chunk, we're done
        BEQ     %FT55
        LDMIA   r9!, {r0, r11}                  ; else get next block
        MOVS    r11, r11, LSR #12               ; if no more blocks left...
        BNE     %BT45
        MOV     r10, #0
        MOV     r9, lr
        LDMDB   r9, {r0, r11}                   ; ...then process VRAM
        MOVS    r11, r11, LSR #12               ; And if no VRAM...
        BNE     %BT45
                                                ; ...then we're done
55
        ; Left with:
        ; r1 -> end of memory block
        ; r2 -> start of memory block
        ; r3 -> last used entry
        ; Calculate and store size
        SUB     r12, r1, r3
        MOV     r12, r12, LSR #2
        STR     r12, [r6, #DANode_PMPSize]
      [ PMPDebug
        DebugReg r12, "PMPSize="
      ]
        ; Shuffle everything down, and fill in the CAM entries (which we
        ; couldn't do earlier since we didn't know the final PMP indices)
        MOV     r12, #0
        LDR     lr, =AP_FreePool :AND: DynAreaFlags_AccessMask
56
        CMP     r3, r1
        LDRNE   r0, [r3], #4
        STRNE   r0, [r2], #4
        ADDNE   r0, r4, r0, LSL #CAM_EntrySizeLog2
        STRNE   lr, [r0, #CAM_PageFlags]
        STRNE   r6, [r0, #CAM_PMP]
        STRNE   r12, [r0, #CAM_PMPIndex]
        ADDNE   r12, r12, #1
        BNE     %BT56
60
        ; Now r2 -> end of used portion
        ; Fill empty space with -1 (although, we could probably free the space - I don't think it's possible it will ever get used)
        MOV     r0, #-1
61
        CMP     r2, r1
        STRNE   r0, [r2], #4
        BNE     %BT61

        ; Free pool should now be ready for business

        ADD     sp, sp, #4
      [ PMPDebug
        DebugTX "InitDynamicAreas done"
      ]
      [ PMPParanoid
        BL      ValidatePMPs
      ]
a3268 21


;**************************************************************************
;
;       ClaimCDASemaphore - Claims CDASemaphore if possible
;
; out:  EQ -> CDASemaphore claimed
;       NE -> not claimed
;
ClaimCDASemaphore
        Entry   "r10"
        LDR     r10, =ZeroPage                  ; check we're not in an IRQ
        LDR     lr, [r10, #IRQsema]
        TEQ     lr, #0
        LDREQ   lr, [r10, #CDASemaphore]       ; now also check whether ChangeDynamicArea is already threaded
        TEQEQ   lr, #0
        LDREQB  lr, [r10, #VRAMRescue_control] ; also check that wimp has not locked Free Pool
        TSTEQ   lr, #VRRc_wimp_lock
        STREQ   pc, [r10, #CDASemaphore]     ; store non-zero value in CDASemaphore, to indicate we're threaded
        EXIT

d3295 7
a3301 1
        BL      ClaimCDASemaphore
d3303 1
a3340 3
        CMP     r0, #ChangeDyn_FreePool         ; Free pool is handled here. Other PMPs call through to their resize handler.
        TSTNE   r11, #DynAreaFlags_PMP
        BNE     CDA_PMP
a3341 3
      [ PMPParanoid
        BL      ValidatePMPs
      ]
d3378 6
a3383 2
        BEQ     ShrinkFreePoolToAppSpace        ; then dest is appspace
        LDR     r12, =ZeroPage+FreePoolDANode   ; else dest is free pool
d3385 2
a3386 2
        ASSERT  DANode_PMPMaxSize = DANode_PMPSize +4
        ADD     r2, r12, #DANode_PMPSize
a3387 6

      [ PMPDebug
        DebugReg r0,"Shrinking area "
        DebugReg r1,"by "
        DebugReg r2,"FreePool PMPSize "
      ]
d3391 3
a3393 3
        CMP     lr, r1, LSR #12
        MOVLO   r1, lr, LSL #12                 ; r1 = the most we want to move if we could
        BLLO    GenNotAllMovedError             ; but if not all we still want error
a3398 7
      [ ZeroPage = 0
        TEQ     r11, #AppSpaceDANode            ; check if src = appspace
      |
        LDR     r2, =ZeroPage+AppSpaceDANode
        TEQ     r11, r2                         ; check if src = appspace
      ]

a3400 1
        SUBEQ   r2, r2, #&8000                  ; protect first 32K of app space because app space DANode is silly
d3402 1
a3402 1
        BLCC    TryToShrinkShrinkables_Bytes
a3409 1
        SUBEQ   r2, r2, #&8000                  ; protect first 32K of app space because app space DANode is silly
d3427 1
d3431 1
a3459 10
      [ ZeroPage = 0
        TEQ     r11, #AppSpaceDANode            ; check if src = appspace
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r11, lr                         ; check if src = appspace
      ]
        STREQ   r3, [r11, #MemLimit-AppSpaceDANode] ; update memlimit if so
      [ PMPDebug
        DebugReg r3, "< src size"
      ]
d3461 3
a3463 2
        LDR     r1, [r12, #DANode_PMP]
        LDR     r3, [r12, #DANode_PMPSize]      ; r3 -> index of 1st extra page
d3498 1
a3498 1
        DREG    r3, " to free pool index ", cc
d3501 2
a3502 14
        Push    "r1-r2"
        LDR     r1, =Nowhere
        BL      MovePageAtR0ToR1WithAccessR6ReturnPageNumber
        ; Update PMP association
        Pull    "r1"
        STR     r2, [r1, r3, LSL #2]            ; Store in free pool PMP
        LDR     lr, =ZeroPage
        LDR     lr, [lr, #CamEntriesPointer]
        ADD     lr, lr, r2, LSL #CAM_EntrySizeLog2
        STR     r12, [lr, #CAM_PMP]              ; Store PMP in CAM
        STR     r3, [lr, #CAM_PMPIndex]
        ADD     r3, r3, #1
        Pull    "r2"

d3526 10
a3535 1
        STR     r3, [r12, #DANode_PMPSize]      ; store increased destination size
a3588 15
GrowFreePoolFromAppSpace ROUT
        ; To reduce code complexity, we treat a grow of the free pool as a
        ; shrink of application space
        MOV     r0, #ChangeDyn_AplSpace
        LDR     r10, =ZeroPage+AppSpaceDANode
        RSB     r1, r1, #0                      ; (AreaShrink assumes negative size on entry)
        B       AreaShrink

ShrinkFreePoolToAppSpace ROUT
        ; To reduce code complexity, we treat a shrink of the free pool as a
        ; grow of application space
        MOV     r0, #ChangeDyn_AplSpace
        LDR     r10, =ZeroPage+AppSpaceDANode
        ; Fall through...

d3596 6
a3601 2
        BEQ     GrowFreePoolFromAppSpace        ; then src is appspace
        LDR     r11, =ZeroPage+FreePoolDANode   ; else src is free pool (may later be free+apl)
a3605 12

      [ PMPDebug
        DebugReg r0,"Growing area "
        DebugReg r1,"by "
        DebugReg r2,"dest size "
        DebugReg r3,"dest max size "
        Push    "r0"
        LDR     r0, [r11, #DANode_PMPSize]      ; amount src could shrink
        DebugReg r0, "FreePool PMPSize "
        Pull    "r0"
      ]

d3611 9
a3619 1
        LDR     r2, [r11, #DANode_PMPSize]      ; amount src could shrink
d3625 4
a3628 4
        CMP     lr, r1                          ; if enough room in dest
        CMPHS   r2, r1, LSR #12                 ; and enough space in src
        MOVHS   r3, r1                          ; then can do full amount
        BHS     %FT65                           ; so skip this bit
d3632 9
a3640 2
; if dest <> AplSpace, check if adding aplspace would allow us to succeed
; if it does then adjust registers, else give error
d3656 2
a3657 2
        CMP     r2, r1, LSR #12
        MOVLO   r1, r2, LSL #12                 ; move min(max addable to dest, max removable from src)
d3660 1
a3660 1
        DREG    r1, "Dest is apl space, moving reduced amount of "
d3680 1
a3680 1
        CMP     r2, r1, LSR #12                 ; this should definitely set C=0 as required by TryToShrinkShrinkables
d3682 1
a3682 1
        BLCC    TryToShrinkShrinkables_Bytes
d3694 1
a3694 1
        ADD     r3, r2, r6, LSR #12             ; add on to amount we could remove from free pool
d3698 1
a3698 2
        DREG    r3, " bytes making a total of ", cc
        DLINE   " pages"
d3701 10
a3710 4
        CMP     lr, r1                          ; if not enough room in dest
        CMPHS   r3, r1, LSR #12                 ; or src still doesn't have enough
        MOVLO   r1, #0                          ; then don't move any
        BLO     %BT61                           ; and return error
d3712 2
a3713 14
        ; To reduce code complexity, first shrink application space into the free pool, then take the combined chunk from the free pool
        Push    "r0-r1,r3"
        LDR     r3, =ZeroPage
        MOV     r0, #0
        STR     r0, [r3, #CDASemaphore]         ; Allow nested call
        RSB     r1, r1, r2, LSL #12             ; free pool size minus total amount = app space size change needed
        MOV     r0, #ChangeDyn_AplSpace
        SWI     XOS_ChangeDynamicArea
        STR     pc, [r3, #CDASemaphore]         ; reclaim semaphore
        MOVVS   r1, #1
        CMP     r1, #0                          ; if not all moved
        Pull    "r0-r1"
        MOVNE   r1, #0                          ; then claim nothing moved
        BNE     %BT61                           ; and return error
a3714 1
        MOV     r3, r1                          ; amount actually doing
d3717 12
a3728 1
        MOV     r7, r3                          ; set up r7 to be total amount
d3735 5
d3743 2
a3747 1
        TSTEQ   lr, #DynAreaFlags_PMP           ; detect batcall from PMP PhysOp
d3760 6
d3793 4
a3872 90
CDA_PMP ROUT
        ; OS_ChangeDynamicArea implementation for PMPs
        ; Call through to the areas handler routine and let it do all the work
        LDR     r2, =ZeroPage
        MOV     r0, #0
        STR     r0, [r2, #CDASemaphore] ; Ensure handler can call back into us to modify the PMP
        ASSERT  DANode_Handler = DANode_Workspace + 4
        ADD     r12, r10, #DANode_Workspace
        Pull    "r2"
        ; Call with:
        ; r0 = reason
        ; r1 = change amount (pages)
        ; r2 = DA number
        LDR     r11, [r10, #DANode_PMPSize] ; Remember current size
        MOV     r0, #DAHandler_ResizePMP
        MOV     r1, r1, ASR #12
        MOV     lr, pc
        LDMIA   r12, {r12, pc}          ; Call handler
        ; Exit without issuing service call - PhysOp should have triggered it for us
        MOVVC   r0, r2                  ; r0 = DA number if no error
        MRS     r2, CPSR
        LDR     r10, [r10, #DANode_PMPSize]
        SUBS    r1, r10, r11
        RSBLT   r1, r1, #0              ; get unsigned change for OS_ChangeDynamicArea return
        CMP     r1, #DynArea_PMP_BigPageCount ; even though unsigned, use same +2GB clamp
        MOVLO   r1, r1, LSL #12
        LDRHS   r1, =DynArea_PMP_BigByteCount
        TST     r2, #V_bit
        BNE     %FT90
        Pull    "r2-r9,r10,lr"
        ExitSWIHandler
90
        ; If no error pointer, generate can't move error
        TEQ     r0, #0
        ADREQL  r0, ErrorBlock_ChDynamNotAllMoved
 [ International
        BLEQ    TranslateError
 ]
        Pull    "r2-r9,r10,lr"
        ORR     lr, lr, #V_bit
        ExitSWIHandler

; ***********************************************************************************
;
;       GrowFreePool - Try and grow the free pool so it's at least the given size
;
; in:   r1 = desired page count
;       r12 -> dst area node (we won't try and shrink this one)
;
; out:  C=0 => failed to move as much as we wanted
;       C=1 => succeeded in moving as much as we wanted
GrowFreePool ROUT
        Entry   "r0-r2,r11"
        ; Check to see if there's already enough space
        LDR     r11, =ZeroPage+FreePoolDANode
        LDR     r2, [r11, #DANode_PMPSize]
        SUBS    r0, r2, r1
        BHS     %FT90
 [ ShrinkableDAs
        ; Try and shrink shrinkables
        CLC
        BL      TryToShrinkShrinkables
        EXIT    CS
        SUB     r0, r2, r1              ; Update how many pages still needed
 ]
        ; Try shrinking application space, if r12 != appspace
        LDR     r11, [r12, #DANode_Number]
        CMP     r11, #ChangeDyn_AplSpace
        BEQ     %FT80
        LDR     r2, [r11, #CDASemaphore-FreePoolDANode]
        MOV     r0, #0
        STR     r0, [r11, #CDASemaphore-FreePoolDANode] ; Allow nested call
        CMN     r0, #DynArea_PMP_BigPageCount ; r0 is negative
        MOVGT   r1, r0, LSL #12
        LDRLE   r1, =-DynArea_PMP_BigByteCount
        MOV     r0, #ChangeDyn_AplSpace
        SWI     XOS_ChangeDynamicArea
        STR     r2, [r11, #CDASemaphore-FreePoolDANode] ; reclaim semaphore
        MOVVS   r1, #1
        CMP     r1, #0                  ; if all moved
        BEQ     %FT90                   ; then success
        ; Fall through...
80
        CLC
        EXIT

90
        SEC
        EXIT

d3878 2
a3879 2
; in:   r1 = total amount we wish to have in src area (page count, already limited by max_size of destination area)
;       r2 = current size of src area (pages, must be less than r1)
d3881 1
a3881 1
;       r12 -> dst area node (we won't try and shrink this one)
d3884 1
a3884 1
; out:  r2 = new size of src area (pages)
d3889 1
a3889 1
        Entry   "r0,r1,r10"
d3894 2
a3895 2
        LDR     r10, [r11, #DynArea_ws-FreePoolDANode]
        ADD     r10, r10, #:INDEX:DynArea_ShrinkableSubList-DANode_SubLink ; get shrinkable DA list
d3897 1
a3897 1
        LDR     r10, [r10, #DANode_SubLink]     ; and load next
d3901 2
d3905 2
a3906 6
        LDR     lr, [r10, #DANode_Flags]
        TST     lr, #DynAreaFlags_PMP
        SUB     lr, r1, r2                      ; lr = amount we still need
        LDREQ   r1, [r10, #DANode_Size]         ; available size of this area
        MOVEQ   r1, r1, LSR #12
        LDRNE   r1, [r10, #DANode_PMPSize]
d3908 9
a3916 8
        MOVLO   r1, lr                          ; min(amount we need, size of this area)
        CMP     r1, #DynArea_PMP_BigPageCount
        MOVLO   r1, r1, LSL #12
        RSBLO   r1, r1, #0                      ; make negative - it's a shrink
        LDRHS   r1, =-DynArea_PMP_BigByteCount
        MOV     r0, #0
        LDR     r2, [r11, #CDASemaphore-FreePoolDANode] ; preserve old CDASemaphore (may not be set, e.g. when called from AMBControl)
        STR     r0, [r11, #CDASemaphore-FreePoolDANode] ; momentarily pretend we're not threaded
d3919 9
a3927 3
        STR     r2, [r11, #CDASemaphore-FreePoolDANode] ; we're threaded again
        FRAMLDR r1                              ; reload original r1
        LDR     r2, [r11, #DANode_PMPSize]      ; get new size of src area
a3930 9

TryToShrinkShrinkables_Bytes ROUT
        Entry
        MOV     r1, r1, LSR #12
        MOV     r2, r2, LSR #12
        BL      TryToShrinkShrinkables
        MOV     r1, r1, LSL #12
        MOV     r2, r2, LSL #12                 ; n.b. may overflow!
        EXIT
d3941 1
a3941 1
;       r11 -> src area (always free pool)
d4006 12
a4017 5
        LDR     r0, [r11, #DANode_PMP]
        LDR     r3, [r11, #DANode_PMPSize]
        ADD     r0, r0, r3, LSL #2              ; move r0 to point to after end of area
        SUB     r3, r3, r2, LSR #12             ; reduce by amount moving from area
        STR     r3, [r11, #DANode_PMPSize]      ; store reduced source size
d4079 13
a4091 1
        ORR     r6, r6, #PageFlags_Unsafe
d4097 1
a4097 1
        LDR     r2, [r0, #-4]!                  ; pre-decrement source pointer
d4099 1
a4099 1
        DREG    r2, "Moving page number ", cc
d4103 1
a4103 7
        Push    "r0-r1,r3-r4,r6,r11"
        MOV     r11, #-1
        MOV     r3, r1
        STR     r11, [r0]                       ; Remove from free pool PMP
        MOV     r11, r6
        BL      BangCamUpdate
        Pull    "r0-r1,r3-r4,r6,r11"
d4110 14
a4123 6
        ; DSB + ISB required to ensure effect of page table write is fully
        ; visible (after overwriting a faulting entry)
        myDSB   ,lr
        myISB   ,lr,,y
        ; Note for non-VMSAv6 case there's nothing needed since we were only
        ; overwriting faulting entries
a4128 7
      [ ZeroPage = 0
        TEQ     r12, #AppSpaceDANode            ; check if dest = appspace
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r12, lr                         ; check if dest = appspace
      ]
        STREQ   r3, [r12, #MemLimit-AppSpaceDANode] ; update memlimit if so
d4180 1
a4180 1
05
d4182 1
a4182 3
        ADD     r4, r0, r3, LSL #CAM_EntrySizeLog2 ; point at cam entry
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
d4190 1
a4190 1
        STR     lr, [r4, #CAM_PageFlags]        ; and store back
d4192 1
a4192 1
; work out physical address direct from physical page number, NOT from logical address, since log addr may be Nowhere (multiply mapped, or PMP)
d4195 1
a4195 1
06
d4198 1
a4198 1
        BCS     %BT06
d4205 1
a4205 1
        BNE     %BT05
d4220 12
a4231 5
        LDR     r0, [r11, #DANode_PMP]
        LDR     r3, [r11, #DANode_PMPSize]
        ADD     r0, r0, r3, LSL #2              ; move r0 to point to after end of area
        SUB     r3, r3, r2, LSR #12             ; reduce by amount moving from area
        STR     r3, [r11, #DANode_PMPSize]      ; store reduced source size
d4237 3
a4239 6
        ; If dest is a PMP, then this must be the batcall made by PhysOp, and
        ; we don't need to mask the flags.
        TST     r6, #DynAreaFlags_PMP
        LDREQ   lr, =DynAreaFlags_AccessMask
        ANDEQ   r6, r6, lr
        ORREQ   r6, r6, #PageFlags_Unavailable  ; set unavailable bit if regular DA. For PMPs, PMP has control over this.
d4242 1
a4242 1
        BEQ     %FT15                           ; [it's not, so skip all this, and r9 will be irrelevant]
d4247 1
a4247 1
        BEQ     %FT10                           ; [none, so skip all this]
d4267 1
a4267 1
        ADR     lr, %FT08
d4270 1
a4270 1
08
d4289 1
a4289 1
09
d4294 1
a4294 1
        BNE     %BT09                           ; loop if more
d4314 1
a4314 1
10
d4316 1
a4316 1
15
d4321 1
a4321 1
        SUB     r2, r0, r2, LSR #12-2           ; r2 = lowest address being removed from src
d4332 1
a4332 1
20
d4335 1
a4335 36

        ; r0 = End of area being removed from src (DANode_PMP+DANode_PMPSize*4)
        ; r1 = Spare
        ; r2 = Start of area being removed from src (DANode_PMP+(DANode_PMPSize-NumEntries)*4)
        ; r3 = CAM
        ; r4 = Where to look next for a replacement page (counts down, == r0)
        ; r5 = PageSize
        ; r6 = Required page number
        ; r7 = Spare
        ; r8 = PageBlock1
        ; r9 = NumEntries
        ; r10 = Required page phys addr
        ; r11 = Src DANode
        ; r12 = Dest DANode

        ; If the required page is in a PMP, then it might not be mapped in and
        ; any logical address checks we perform will be nonsensical.
        ; Considering that the only possible source area is the free pool, the
        ; rules for required pages are:
        ; * If it's not a member of a PMP, we need to find a replacement page
        ; * If it's a different PMP to the src DA, we need to find a replacement page
        ; * If it's the same PMP as the src DA, then we can take the page without looking for a replacement
        ADD     lr, r3, r6, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIB   lr, {r1, r7, lr}
        TST     r1, #DynAreaFlags_PMP
        BEQ     %FT63                           ; Not a PMP, look for a replacement
        TEQ     r7, r11
        BNE     %FT63                           ; Different PMP/DA, look for a replacement
        ; Page is being taken from src PMP, so assume src is free pool and so no replacement needed
        ; However we need to make sure we don't introduce any gaps in the free pool page list - so if this page isn't within the range of pages being removed, we need to look for a replacement still
        LDR     r1, [r7, #DANode_PMP]
        ADD     r1, r1, lr, LSL #2
d4338 1
a4338 1
;        DREG    r1, "at address "
d4340 1
a4340 1
        CMP     r1, r2                          ; check if address is one being taken from src anyway
d4342 1
a4342 1
        CMP     r1, r0
d4354 19
a4372 2
        LDR     r6, [r4, #-4]!                  ; get next page being taken from src
;        DREG    r6, "Considering page "
d4374 2
a4375 2
        ADD     r1, r3, r6, LSL #CAM_EntrySizeLog2 ; r1 -> cam entry for this page
        LDR     r1, [r1, #CAM_PageFlags]        ; get PPL for this page
d4379 1
a4379 6
        Push    "r3,r5,r9"
        MOV     r3, r6
        BL      ppn_to_physical
        MOV     r10, r5
        Pull    "r3,r5,r9"

d4386 1
a4386 1
        BNE     %BT20
d4412 2
a4413 1
        ; Grab the flags for the page we're replacing; in order to preserve the contents of the page we may map it to its destination early, causing the flags in the CAM map to be "wrong" when we read them back out later on
d4415 2
a4416 2
        ADD     lr, r0, #CAM_PageFlags          ; point at PPLs, not addresses
        LDR     r11, [lr, r11, LSL #CAM_EntrySizeLog2]
d4419 1
d4432 1
a4433 28

        ; The replacement page will be a member of the free pool PMP - remove it
        ; from the PMP now, before any CAM updates make it hard to get access
        ; to the original page flags
        LDR     r11, =ZeroPage+FreePoolDANode
        ADD     r4, r0, lr, LSL #CAM_EntrySizeLog2
        LDR     r2, [r11, #DANode_PMP]
        LDR     r6, [r4, #CAM_PMPIndex]!
        MOV     r3, #-1
        STR     r3, [r2, r6, LSL #2]
        ; If the required page is a member of a PMP, update its PMP to point to
        ; the replacement page (and update the CAM for the replacement)
        LDR     r6, [r8, #0]
        TEQ     r6, lr
        BEQ     %FT72                           ; Required == replacement, leave unassociated
        ADD     r6, r0, r6, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIB   r6, {r2, r3, r6}
        TST     r2, #DynAreaFlags_PMP
        BEQ     %FT72
        STMDA   r4, {r3, r6}                    ; Update CAM for replacement to point to PMP of required page
        LDR     r4, [r3, #DANode_PMP]
        STR     lr, [r4, r6, LSL #2]            ; And update PMP of required page to point to replacement
72

        LDR     r6, [r8, #0]                    ; r6 = page number required
d4436 1
a4436 1
        BEQ     %FT86                           ; and skip copy and first page move
d4446 10
a4455 7
        ; If the required page is in the free pool, we don't need to preserve its contents
        ; TODO - have 'volatile' PMP page flag which can be used to indicate that pages can just be taken? (so will work with any PMP)
        TST     r2, #DynAreaFlags_PMP
        BEQ     %FT73
        CMP     r3, r11
        BEQ     %FT84
73
d4457 3
a4459 1
        LDR     r2, =Nowhere
d4461 4
a4464 6
        ; If the required page isn't mapped in, see if we can map it in at the
        ; target address so that we can copy the contents out. If this fails
        ; we'll fall back to using a temporary mapping via AccessPhysicalAddress
        TEQ     r6, r2
        BNE     %FT75                           ; Source is mapped in, everything is fine
        LDR     r3, [sp, #4]                    ; Get stacked r1 (DestAddr)
a4465 3
        TEQ     r3, r2
        BEQ     %FT75                           ; Dest is Nowhere - must use temp mapping
        LDR     r2, [r8, #0]
d4471 4
a4474 35
        LDR     r2, =Nowhere
        STRB    lr, [sp, #11*4+:INDEX:NeedToMoveFlag] ; Flag that page has been moved
75

        MOV     lr, #-1
        Push    "lr"                            ; Push dummy oldp flag for ReleasePhysicalAddress

        ; With the only source of replacement pages being the free pool, we only have two situations to deal with:
        ; * Source mapped, dest unmapped
        ; * Source unmapped, dest unmapped
        ; (where 'source' = copy source, i.e. required page, and 'dest' = copy dest, i.e. replacement page)
        TEQ     r6, r2
        BEQ     ReplacePage_BothUnmapped
        ; Fall through to DestUnmapped

ReplacePage_DestUnmapped
        Push    "r1"
        FastCDA_ProfStart AccessPhysical, r2, r1, lr
        MOV     r0, #L1_B
        LDR     r1, [r8, #PageBlockSize+8]      ; r1 = physical address of dest for copy
        ADD     r2, sp, #4
        BL      RISCOS_AccessPhysicalAddress
        ; r0 = logical address of dest for copy
        FastCDA_ProfEnd AccessPhysical, r2, r1, lr
        Pull    "r1"
        B       ReplacePage_BothMapped

ReplacePage_BothUnmapped
        ; We need to make temp mappings of both pages, but we only have one
        ; PhysicalAccess window. For now, take the easy way out and copy via
        ; a temporary buffer - it'll be a bit slower but since we only move
        ; one page at a time the cache should swallow most of the hit.
        ; Since OS_ChangeDynamicArea can't be used from an IRQ routine, we can
        ; assume that the IRQ stack has enough spare space - so use that rather
        ; than the SVC stack
d4477 1
a4477 1
        MOV     r0, #L1_B
d4479 1
a4479 1
        ADD     r2, sp, #8
d4483 2
d4486 1
a4486 5
        ; Copy to IRQ stack
        MSR     CPSR_c, #IRQ32_mode+I32_bit
        Push    "lr"
        SUB     sp, sp, r5
        MOV     r0, sp
d4489 1
a4489 1
77
d4493 1
a4493 2
        BNE     %BT77
        FastCDA_ProfEnd CopyPage, r2, r3, r4
a4494 14
        ; Now map in dest
        MOV     r0, #L1_B
        LDR     r1, [r8, #PageBlockSize+8]      ; r1 = physical address of src for copy
        MOV     r2, #0                          ; no oldp needed
        BL      RISCOS_AccessPhysicalAddress
        ; r0 = logical address of dest for copy
        MOV     r6, sp
        FastCDA_ProfStart CopyPage, r2, r3, r4
        ADD     lr, r6, r5                      ; lr = end src address
78
        LDMIA   r6!, {r2, r3, r4, r7, r9, r10, r11, r12}
        STMIA   r0!, {r2, r3, r4, r7, r9, r10, r11, r12}
        TEQ     r6, lr
        BNE     %BT78
a4495 6
        ; Switch back to SVC and clean up the temp mapping
        ADD     sp, sp, r5
        Pull    "lr"
        MSR     CPSR_c, #SVC32_mode+I32_bit
        Pull    "r0,r1"
        B       ReplacePage_Done
d4497 4
a4500 21
 [ {FALSE}
ReplacePage_SrcUnmapped
        Push    "r0,r1"
        FastCDA_ProfStart AccessPhysical, r0, r1, lr
        MOV     r0, #L1_B
        LDR     r1, [r8, #8]                    ; r1 = physical address of src for copy
        ADD     r2, sp, #8
        BL      RISCOS_AccessPhysicalAddress
        MOV     r6, r0                          ; r6 = logical address of src for copy
        FastCDA_ProfEnd AccessPhysical, r0, r1, lr
        Pull    "r0,r1"
 ]

ReplacePage_BothMapped
        FastCDA_ProfStart CopyPage, r2, r3, r4
        ADD     lr, r6, r5                      ; lr = end src address
79
        LDMIA   r6!, {r2, r3, r4, r7, r9, r10, r11, r12}
        STMIA   r0!, {r2, r3, r4, r7, r9, r10, r11, r12}
        TEQ     r6, lr
        BNE     %BT79
d4502 1
a4502 6
        FastCDA_ProfEnd CopyPage, r2, r3, r4

ReplacePage_Done
        ; Release the temp mapping if necessary
        Pull    "r0"
        CMP     r0, #-1
d4504 1
a4504 1
        BEQ     %FT80
d4507 1
a4507 1
        BLNE    RISCOS_ReleasePhysicalAddress
d4510 1
a4510 1
80
d4512 1
a4515 1
        LDR     r2, =L2PT
d4517 2
a4518 2
        SUBS    r6, r6, r2
        BCC     %FT84                           ; address is below L2PT
d4520 1
a4520 1
        BCS     %FT84                           ; address is above L2PT
d4535 1
a4535 11
      [ MEMM_Type = "VMSAv6"
        ; In order to guarantee that the result of a page table write is
        ; visible, the ARMv6+ memory order model requires us to perform TLB
        ; maintenance (equivalent to the MMU_ChangingUncached ARMop) after we've
        ; performed the write. Performing the maintenance beforehand (as we've
        ; done traditionally) will work most of the time, but not always.
        LDR     r3, =ZeroPage
        ARMop   MMU_ChangingUncached,,,r3
      ]

84
d4551 7
d4563 1
a4563 1
        LDR     lr, =Nowhere                    ; No need to clean if the page isn't mapped in
d4565 1
a4565 1
        BEQ     %FT85
d4570 1
a4570 1
        BNE     %FT85
d4583 1
a4583 1
85
d4588 1
a4588 1
86
d4592 1
d4595 2
a4596 1
        BEQ     %FT87                           ; don't bother if page already been moved to dest
d4601 1
a4601 1
87
a4632 7
      [ ZeroPage = 0
        TEQ     r12, #AppSpaceDANode            ; check if dest = appspace
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r12, lr                         ; check if dest = appspace
      ]
        STREQ   r3, [r12, #MemLimit-AppSpaceDANode] ; update memlimit if so
a4675 2
        ; TODO could merge with code from DoTheGrow? (make this subroutine of DoTheGrow, with write back of pages to page list optional)

d4682 12
a4693 5
        LDR     r0, [r11, #DANode_PMP]
        LDR     r3, [r11, #DANode_PMPSize]
        ADD     r0, r0, r3, LSL #2              ; move r0 to point to after end of area
        SUB     r3, r3, r2, LSR #12             ; reduce by amount moving from area
        STR     r3, [r11, #DANode_PMPSize]      ; store reduced source size
d4758 12
d4775 1
a4775 1
        LDR     r2, [r0, #-4]!                  ; pre-decrement source pointer
d4777 1
a4777 1
        DREG    r2, "Moving page number ", cc
d4781 1
a4781 7
        Push    "r0-r1,r3-r4,r6,r11"
        MOV     r11, #-1
        MOV     r3, r1
        STR     r11, [r0]                       ; Remove from free pool PMP
        MOV     r11, r6
        BL      BangCamUpdate
        Pull    "r0-r1,r3-r4,r6,r11"
d4787 14
a4800 6
        ; DSB + ISB required to ensure effect of page table write is fully
        ; visible (after overwriting a faulting entry)
        myDSB   ,lr
        myISB   ,lr,,y
        ; Note for non-VMSAv6 case there's nothing needed since we were only
        ; overwriting faulting entries
a4805 7
      [ ZeroPage = 0
        TEQ     r12, #AppSpaceDANode            ; check if dest = appspace
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r12, lr                         ; check if dest = appspace
      ]
        STREQ   r3, [r12, #MemLimit-AppSpaceDANode] ; update memlimit if so
d5020 1
a5020 1
        ADD     r4,r4,#CAM_PageFlags     ; -> base of PPLs
d5033 1
a5033 1
        LDR     lr,[r4,r2,LSL #CAM_EntrySizeLog2]
d5277 1
a5277 108
DynAreaHandler_RAMDisc ROUT
 [ PMPRAMFS
        CMP     r0, #DAHandler_ResizePMP
        BNE     UnknownHandlerError
        ; r1 = change amount (pages)
        ; r2 = DA number
        Entry   "r2-r11"
        MOV     r10, r1
        MOV     r11, r2
        ; Get current size
        MOV     r0, #DAReason_PMP_GetInfo
        MOV     r1, r2
        SWI     XOS_DynamicArea
        ; R6 = current phys page count
        ; R7 = max size
        ; Check if resizing is allowed
        BLVC    PreGrow_RAMDisc
        EXIT    VS
        CMP     r10, #0
        BLT     RAMDisc_Shrink
        EXIT    EQ
        ; Claim empty space
        MOV     r0, #DAReason_PMP_Resize
      [ {TRUE}
        ; Limit max size to ~512MB - RAMFS currently can't cope with more than that
        RSB     r2, r6, #508<<(20-12)
        CMP     r10, r2
        MOVGT   r10, r2
      ]
        SUB     r2, r6, r7 ; Take into account any mismatch between current max and current page count
        ADDS    r2, r2, r10
        MOV     r9, r2
        SWINE   XOS_DynamicArea
        EXIT    VS
        ; R2 = actual change, use that from now on
        CMP     r9, #0
        ADDGE   r10, r7, r2 ; New PMPMaxSize
        SUBLT   r10, r7, r2 ; Take into account the fact the result is unsigned
        SUB     r10, r10, r6 ; Amount we need to change PMPSize
        ; Claim pages
        MOV     r7, #-2
        MOV     r9, #0
10
        SUBS    r10, r10, #1
        BLT     RAMDisc_PostOp
        Push    "r6,r7,r9"
        MOV     r0, #DAReason_PMP_PhysOp
        MOV     r2, sp
        MOV     r3, #1
        SWI     XOS_DynamicArea
        ADD     sp, sp, #12
        ADDVC   r6, r6, #1
        BVC     %BT10
        B       RAMDisc_PostOp
RAMDisc_Shrink
        ; Unmap all pages (RAMFS will unmap everything on reinit anyway)
        MOV     r0, #0
        MOV     r2, #-1
        MOV     r4, #0
        Push    "r0,r2,r4"
        MOV     r0, #DAReason_PMP_LogOp
15
        MOV     r2, sp
        MOV     r3, #1
        SWI     XOS_DynamicArea
        BVS     %FT16
        ADD     r4, r4, #1
        CMP     r4, #PMPRAMFS_Size
        STRLT   r4, [sp]
        BLT     %BT15
16
        ADD     sp, sp, #12
        ; Release pages
        MOV     r7, #-1
        MOV     r9, #0
        RSB     r10, r10, #0
20              
        SUBS    r10, r10, #1
        SUBGES  r6, r6, #1
        BLT     RAMDisc_PostShrink
        Push    "r6,r7,r9"
        MOV     r0, #DAReason_PMP_PhysOp
        MOV     r2, sp
        MOV     r3, #1
        SWI     XOS_DynamicArea
        ADD     sp, sp, #12
        BVC     %BT20
RAMDisc_PostShrink
        ; Release empty space so that things should stay in sync
        MRS     r2, CPSR
        Push    "r0,r2"
        MOV     r0, #DAReason_PMP_GetInfo
        SWI     XOS_DynamicArea
        BVS     %FT30
        SUBS    r2, r6, r7 ; Release all spare page entries
        MOV     r0, #DAReason_PMP_Resize
        SWINE   XOS_DynamicArea
30             
        Pull    "r0,r2"
        MSR     CPSR_f, r2
RAMDisc_PostOp
        ; Re-init if necessary
        MRS     r2, CPSR
        BL      PostGrow_RAMDisc
        MSR     CPSR_f, r2
        EXIT
        
 | ; PMPRAMFS
a5284 1
 ] ; PMPRAMFS
a5616 99
      [ PMPParanoid
ValidatePMPs ROUT
        EntryS  "r0-r12"
        ; Validate PMPs against the CAM
        LDR     r0, =ZeroPage
        LDR     r1, [r0, #DAList]
        LDR     r2, [r0, #CamEntriesPointer]
        LDR     r3, [r0, #MaxCamEntry]
10
        LDR     r4, [r1, #DANode_Flags]
        TST     r4, #DynAreaFlags_PMP
        BEQ     %FT25
        LDR     r5, [r1, #DANode_PMP]
        LDR     r6, [r1, #DANode_PMPSize]
        LDR     r7, [r1, #DANode_PMPMaxSize]
        LDR     r0, [r1, #DANode_Size]
        CMP     r6, r7
        BLHI    %FT90
15
        SUBS    r7, r7, #1
        BLO     %FT20
        LDR     r8, [r5, r7, LSL #2]
        CMP     r8, #-1
        BEQ     %BT15
        CMP     r8, r3
        BLHI    %FT90
        ADD     r9, r2, r8, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIA   r9, {r9-r12}
        TST     r10, #DynAreaFlags_PMP
        BLEQ    %FT90
        CMP     r11, r1
        CMPEQ   r12, r7
        BLNE    %FT90
        SUBS    r6, r6, #1
        BLLO    %FT90
        LDR     r10, =Nowhere
        CMP     r9, r10
        SUBNE   r0, r0, #4096
        B       %BT15
20
        CMP     r6, #0
        CMPEQ   r0, #0
        BLNE    %FT90
25
        LDR     r1, [r1, #DANode_Link]
        CMP     r1, #0
        BNE     %BT10
        ; Validate CAM against PMPs
        MOV     r0, #0
30
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIA   r2!, {r4-r7}
        TST     r5, #DynAreaFlags_PMP
        BEQ     %FT35
        LDR     r8, [r6, #DANode_Flags]
        TST     r8, #DynAreaFlags_PMP
        BLEQ    %FT90
        LDR     r8, [r6, #DANode_PMP]
        LDR     r9, [r6, #DANode_PMPMaxSize]
        LDR     r10, [r6, #DANode_PMPSize]
        CMP     r7, r9
        BLHS    %FT90
        LDR     r8, [r8, r7, LSL #2]
        CMP     r0, r8
        BLNE    %FT90
35
        ADD     r0, r0, #1
        CMP     r0, r3
        BLS     %BT30
        EXITS

90
        Push    "lr"
        DebugTX "PMP corrupt"
        DebugReg r0
        DebugReg r1
        DebugReg r2
        DebugReg r3
        DebugReg r4
        DebugReg r5
        DebugReg r6
        DebugReg r7
        DebugReg r8
        DebugReg r9
        DebugReg r10
        DebugReg r11
        DebugReg r12
        Pull     "r0"
        DebugReg r0
        B        .
      ] ; PMPParanoid

@


4.9.2.31
log
@Remove OS_Memory 10 and associated code
Detail:
  s/MemInfo - Remove OS_Memory 10 (free pool locking). Locking the free pool has never been a very nice thing to do, so now that there's no logical mapping of the free pool it seems like it's a good time to outlaw the behaviour altogether.
  s/ChangeDyn - No free pool locking means one less thing to check when claiming the OS_ChangeDynamicArea mutex.
  hdr/KernelWS - VRAMRescue_control workspace variable is no longer needed
Admin:
  Tested on Pandaboard


Version 5.35, 4.79.2.285. Tagged as 'Kernel-5_35-4_79_2_285'
@
text
@d4696 2
@


4.9.2.32
log
@Fix IOMD build
Detail:
  s/ChangeDyn - Differing zero page workspace layout between HiProcVecs {TRUE} and {FALSE} means the difference between FreePoolDANode being a valid 8 bit immediate constant or not. Just use a long-form LDR instead since the code in question isn't performance-critical.
Admin:
  Tested briefly under RPCEmu


Version 5.35, 4.79.2.286. Tagged as 'Kernel-5_35-4_79_2_286'
@
text
@d4305 1
a4305 1
        LDR     lr, =ZeroPage+FreePoolDANode    ; cf comments above/below - what was old code? KJB
d4466 1
a4466 1
        LDR     r6, =ZeroPage+FreePoolDANode
@


4.9.2.33
log
@Misc memory management tweaks & fixes
Detail:
  s/ChangeDyn - Fix OS_DynamicArea 20 to work properly with sparse & PMP DAs. It now checks against the max extent of the area rather than the current size; this matches the logic used for checking fixed system workspace areas. The call only determines the ownership of a logical address, and it's considered the caller's responsibility to check if there's actually a page at the given address.
  s/ChangeDyn - Revise OS_DynamicArea 25 to remove the redundant 'PMP page flags' entry, and to allow pages to be looked up by either PMP page index, phys page number, or DA page index
  s/ChangeDyn - Tidy up InitDynamicAreas by adding the NextFreePage routine to help determine the next page to be added to the free pool.
  s/AMBControl/Workspace, s/AMBControl/main, s/AMBControl/memmap - Fix lazy mapping in of pages to use the correct L2PT flags for the default CB cache policy
  s/AMBControl/allocate - Get rid of magic constant when extracting page flags from DA flags, and make note of the fact that assorted bits of code ignore the flags
  s/AMBControl/growp, s/AMBControl/shrinkp - Reverse the page order when growing/shrinking areas, to match OS_ChangeDynamicArea. This helps both DAs and application space to have pages allocated to them in contiguous physical order - which in turn helps produce shorter, more optimal scatter lists for DMA
Admin:
  Tested on Pandaboard


Version 5.35, 4.79.2.287. Tagged as 'Kernel-5_35-4_79_2_287'
@
text
@d2521 1
a2521 1
        LDR     r0, [r10, #DANode_MaxSize]
d2542 1
a2542 1
;       r2 = pointer to array of (PMP page index, phys page index, page flag) tuples
d2546 1
a2546 1
;            page flags are defined by DynAreaFlags_PMPPhysOpAccessMask
d3531 3
d3537 5
a3541 4
;            +0: PMP page index
;            +4: phys page number
;            +8: DA page index
;            +12: page flags
a3548 10
; On entry, for each array entry either the PMP page index, phys page number, or
; DA page index must be provided, with the other indices set to -1 (page flags
; are ignored).
;
; On exit, if the page is a member of the PMP, the entries will be filled in as
; appropriate. If the page isn't mapped in (and it was a lookup by PMP page
; index/phys page number) the DA page index will be set to -1. If no physical
; page is allocated (or the page isn't a member of the PMP) the page flags will
; be set to 0.
;
d3559 2
a3560 2
        LDR     r6, [r10, #DANode_PMP]
        CMP     r6, #0
d3564 1
a3564 1
        LDR     r11, =ZeroPage
d3566 3
a3568 4
        LDR     r7, [r11, #MaxCamEntry]
        LDR     r8, =L2PT
        LDR     r11, [r11, #CamEntriesPointer]
        LDR     r12, =DynAreaFlags_PMPLogOpAccessMask
d3572 1
d3574 2
a3575 3
        ; r6 -> PMP
        ; r7 = MaxCamEntry
        ; r8 -> L2PT
d3578 3
a3580 3
        ; r11 -> CAM
        ; r12 = DynAreaFlags_PMPLogOpAccessMask
        ; r0, r1, r4 temp
d3584 1
a3584 71
        ; Get the entry
        LDMIA   r2, {r0, r1, r4}
        ; PMP page provided?
        CMP     r0, #-1
        BNE     %FT50
        ; Phys page provided?
        CMP     r1, #-1
        BNE     %FT20
        ; DA page provided
        ; n.b. skipping any range check here since it won't hurt if the page
        ; doesn't belong to us
        Push    "r3, r5, r9-r11"
        ADD     r4, r5, r4, LSL #12
        BL      logical_to_physical
        BLCC    physical_to_ppn
        MOV     r0, r3
        Pull    "r3, r5, r9-r11"
        BCS     %FT15
        ; r0 = PPN, check to see if it belongs to us
        ADD     r1, r11, r0, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIB   r1, {r1, r4, lr}
        TST     r1, #DynAreaFlags_PMP
        BEQ     %FT15
        CMP     r4, r10
        BNE     %FT15
        STR     lr, [r2], #4            ; Store PMP page index
        AND     r1, r1, r12
        STR     r0, [r2], #8            ; Store phys page number, skip DA page index
        STR     r1, [r2], #4            ; Store page flags
        B       %BT10
15
        ; Bad DA page index
        ; PMP page index & phys page number are already known to be -1, so just
        ; store flags
        MOV     r0, #0
        STR     r0, [r2, #12]
        ADD     r2, r2, #16
        B       %BT10

20
        ; Check for silly phys page number
        CMP     r1, r7
        BHI     %FT91
        ADD     r1, r11, r1, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        ASSERT  CAM_PMP=8
        ASSERT  CAM_PMPIndex=12
        LDMIA   r1, {r0, r1, r4, lr}
        TST     r1, #DynAreaFlags_PMP
        BEQ     %FT25
        CMP     r4, r10
        BNE     %FT25
        LDR     r4, =Nowhere
        STR     lr, [r2], #8            ; Store PMP page index, skip phys page number
        TEQ     r0, r4
        B       %FT55

25
        ; Bad phys page number
        ; PMP page index known to be -1, so store DA page index + flags
        ADD     r2, r2, #8
        MOV     r0, #-1
        MOV     r1, #0
        STMIA   r2!, {r0-r1}
        B       %BT10        

50
d3586 1
a3586 1
        CMP     r0, r9
d3589 3
a3591 3
        LDR     r0, [r6, r0, LSL #2]
        ADD     r2, r2, #4
        STR     r0, [r2], #4            ; Store phys page number
d3594 1
a3594 3
        LDR     r4, =Nowhere
        ADDNE   r0, r11, r0, LSL #CAM_EntrySizeLog2
        MOVEQ   r1, #0                  ; No physical page, so no flags
d3598 1
a3598 2
        TEQNE   r0, r4
55
d3601 1
d3603 2
a3604 2
        AND     r1, r1, r12             ; Mask returned flags
        STMIA   r2!, {r0-r1}            ; Store DA page index, flags
a3621 1
        FRAMSTR r0
d4450 5
a4454 3
; free pool and start pushing the free pages into it. However it's highly
; unlikely that we'll be able to build the full page list without having to
; grow the system heap - for which we'd want the fast pages to be available.
d4462 2
a4484 4
        LDMIA   r9!, {r0, r11}                  ; get first regular RAM chunk
        SUB     r10, r10, #1                    ; set things up so the first call to NextFreePage will return the first page of the block
        MOV     r11, r11, LSR #12
        ADD     r11, r11, #1
d4487 6
d4501 1
a4501 1
        SUB     r2, r2, #4096                   ; Paranoia
d4506 1
d4508 9
a4516 2
        ; Find a page we can use to grow the system heap
        BL      NextFreePage                    ; n.b. no out-of-pages check
d4529 6
a4534 2
        B       %BT10

d4551 28
a4578 4
        BL      NextFreePage
        CMP     r10, #-1
        STRNE   r10, [r3, #-4]!
        BNE     %BT45                           ; Keep going until we run out of pages
a4623 77
;
; NextFreePage - Find next page to insert into the free pool on startup
;
; In:
;   r4 -> CAM
;   r7 = page number of start of static chunk
;   r8 = page number of end of static chunk
;   r9 -> next PhysRamTable entry
;   r10 = Current page number
;   r11 = Number of pages left in current chunk
; Out:
;   r0 -> CAM entry for page
;   r10 = Next free page in optimal order, -1 if no more pages
;   r9, r11 updated
;
; We have to move all free pages (ie ones not occupied by the static pages)
; into the free pool.
; By default, pages will get taken from the end of the free pool when other
; dynamic areas are initialised or grown. So make sure that the slowest RAM
; is at the start of the free pool and the fastest is at the end; this is the
; reverse of the order in PhysRamTable. Also, within each group of pages (i.e.
; PhysRamTable entry), we want the pages to be in decreasing physical address
; order - so that when they are moved to a DA they end up in increasing address
; order, leading to more optimal DMA transfer lists.
;
; Also note that the VRAM block is kept at the start of the free pool, mainly
; to match old behaviour (it's not clear whether moving it elsewhere will have
; any significant impact on the system - especially when you consider that
; shrinking screen memory will end up adding the pages to the end of the pool
; rather than the start).
;
; Over time this optimal ordering will be lost, so at a later date it might be
; nice to re-sort pages as they are added back into the free pool (and move the
; VRAM block to the end of PhysRamTable, so that it's in order fast RAM -> slow
; RAM -> fast DMA -> slow DMA -> VRAM, so that sorting by page number is
; all that's required to deal with both contiguity and desirability)
;
; In terms of this routine, we fill the free pool from the highest entry down,
; so we want the first page returned to be the lowest-numbered page from the
; first (non-VRAM) PhysRamTable entry.
;
NextFreePage    ROUT
        Entry
10
        SUBS    r11, r11, #1
        ADD     r10, r10, #1
        BEQ     %FT30
20
        CMP     r10, r7
        CMPHS   r8, r10
        BHS     %BT10                           ; page is in statics
        ; Check the CAM map to see if the page is already taken - this will detect the DMA regions, which aren't included in InitUsedStart/InitUsedEnd
        ADD     r0, r4, r10, LSL #CAM_EntrySizeLog2
        LDR     lr, [r0, #CAM_PageFlags]
        TST     lr, #PageFlags_Unavailable
        BNE     %BT10
        ; Page is good
        EXIT

30
        ; Advance to next block
        LDR     lr, =ZeroPage+PhysRamTable+8
        CMP     lr, r9                          ; if we've just processed the VRAM block, we're done
        BEQ     %FT90
        LDMIA   r9!, {r0, r11}                  ; else get next block
        MOVS    r11, r11, LSR #12               ; if no more blocks left...
        BNE     %BT20
        MOV     r10, #0
        MOV     r9, lr
        LDMDB   lr, {r0, r11}                   ; ...then process VRAM
        MOVS    r11, r11, LSR #12               ; And if no VRAM...
        BNE     %BT20
90                                              ; ...then we're done
        MOV     r10, #-1
        EXIT
                

d6012 1
a6012 1
        ; TODO - have 'volatile' page flag which can be used to indicate that pages can just be taken? (so will work with any PMP)
@


4.9.2.34
log
@OS_ChangeDynamicArea tweaks and fixes
Detail:
  s/ChangeDyn - A few fixes to make behaviour be a closer match for the pre-PMP code, and a bit of tidying to get rid of redundant code paths:
  - Remove shrinkable DA checks from AreaShrink - the source of the op is never the free pool, so TryToShrinkShrinkables wouldn't have done anything anyway
  - Fix ShrinkFreePoolToAppSpace to behave more like old OS_ChangeDynamicArea when it was asked to shrink the free pool - allow partial moves (if move amount too large to fit in app space), shrink shrinkables if free pool is unable to satisfy request, and call CheckAppSpace to make sure app space is OK with being changed
  - Remove redundant logic from AreaGrow for clamping grow size to free pool max size (if dest was free pool - dest will never be free pool with current implementation). "Dest is apl space, moving reduced amount" comment was also inaccurate.
  - Fix AreaGrow logic for taking memory from application space to only do so if the dest isn't application space (I can't see anything in the old implementation to protect against this - but, then again, the old implementation didn't seem to fully deal with grows of application space properly anyway, e.g. MemLimit would be updated on a free pool shrink, but not on an app space grow)
  - Add extra sanity check to AreaGrow after taking memory from application space
Admin:
  Tested on iMx6
  Fixes issue with application space having little or no memory if not booting to desktop (due to free pool shrink performed by kernel failing due to shrink amount being larger than app space max size)


Version 5.35, 4.79.2.291. Tagged as 'Kernel-5_35-4_79_2_291'
@
text
@d4936 9
d4952 11
d4965 2
a4966 2
        CMP     lr, r2, LSR #12
        MOVHI   lr, r2, LSR #12                 ; lr = min(amount dest could grow, amount src could shrink)
d4968 2
a4969 2
        CMP     lr, r1, LSR #12
        BHS     %FT15
d4973 2
a4974 2
        MOV     r1, lr, LSL #12                 ; move smaller amount

a5166 57
        ; Emulate old behaviour, when this case used to be part of AreaShrink:
        ; * If app space doesn't have enough free space, clamp amount and
        ; generate NotAllMoved error (Regular AreaGrow logic will only do this
        ; if dest is free pool - grows of other areas have always failed
        ; outright if they're incapable of growing that big)
        ; * If shrinking more than current free pool size, attempt to shrink
        ; shrinkable DAs so that as much memory as possible can be moved to app
        ; space
        ; * Call CheckAppSpace (rule seems to be that if app space is touched,
        ; CheckAppSpace must be called, except when it's an explicit grow of
        ; app space)
        MOV     r12, r10                        ; required by e.g. TryToShrinkShrinkables
        ASSERT  DANode_MaxSize = DANode_Size +4
        ADD     r2, r10, #DANode_Size
        LDMIA   r2, {r2, r3}
        SUB     lr, r3, r2                      ; lr = amount dest could grow
 [ ShrinkableDAs
        CMP     r1, lr
        MOVHI   r1, lr
        BLHI    GenNotAllMovedError
        SUB     lr, r5, #1                      ; lr = pagesize mask
        BICS    r1, r1, lr                      ; a pagesize multiple
        BEQ     IssueServiceMemoryMoved
 ]

        LDR     r11, =ZeroPage+FreePoolDANode
 [ ShrinkableDAs
        LDR     r2, [r11, #DANode_PMPSize]      ; amount src could shrink
        CMP     r2, r1, LSR #12
        BLCC    TryToShrinkShrinkables
        BCS     %FT15                           ; [we can now do it all]

; we can't move all that is required, so move smaller amount

        MOV     r1, r2, LSL #12                 ; move smaller amount
 |
        LDR     r2, [r11, #DANode_PMPSize]      ; amount src could shrink
        CMP     r2, lr, LSR #12
        MOVCC   lr, r2, LSL #12                 ; lr = min(amount dest could grow, amount src could shrink)

        CMP     r1, lr
        BLS     %FT15     

; we can't move all that is required, so move smaller amount

        MOV     r1, lr                          ; move smaller amount
 ]
        BL      GenNotAllMovedError
        SUB     lr, r5, #1                      ; lr = pagesize mask
        BICS    r1, r1, lr                      ; a pagesize multiple
        BEQ     IssueServiceMemoryMoved
15
        Push    "r10"                           ; save -> to area we tried to shrink
        MOV     r10, r1
        BL      CheckAppSpace
        Pull    "r10"
        BVS     ChangeDynError
d5212 1
a5212 1
; check if adding shrinkables or aplspace would allow us to succeed
d5219 16
a5234 1
        B       %FT62
d5265 3
a5267 4
        EORS    r6, r4, r12                     ; only take from app space if dest isn't app space!
        LDRNE   r6, [r4, #DANode_Size]          ; get current size of apl space
        SUBNE   r6, r6, #&8000                  ; can't take away 0-&7FFF
        ADD     r3, r2, r6, LSR #12             ; add on to amount we could remove from free pool (pages)
a5293 6
        ; Double-check that the free pool did actually grow large enough
        ; (just paranoia for now, but may be important in future)
        LDR     r3, [r11, #DANode_PMPSize]
        CMP     r3, r1, LSR #12
        MOVLO   r1, #0
        BLO     %BT61
d5295 1
a5295 1
        MOV     r3, r1                          ; amount actually doing (bytes)
@


4.9.2.35
log
@Fix application space & shrinkable DA shrinking within PMP grow code
Detail:
  s/ChangeDyn - Fix a couple of places where registers were being clobbered, preventing application space & shrinkable DA shrinking logic from being invoked correctly when performing a PMP PhysOp call
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.293. Tagged as 'Kernel-5_35-4_79_2_293'
@
text
@d2573 3
a2578 2
        LDR     r7, =ZeroPage
        LDR     r11, [r7, #MaxCamEntry]
a2579 1
        LDR     r7, [r7, #CamEntriesPointer]
d5522 2
a5523 2
        LDR     lr, [r12, #DANode_Number]
        CMP     lr, #ChangeDyn_AplSpace
@


4.9.2.36
log
@Cache maintenance fixes
Detail:
  This set of changes tackles two main issues:
  * Before mapping out a cacheable page or making it uncacheable, the OS performs a cache clean+invalidate op. However this leaves a small window where data may be fetched back into the cache, either accidentally (dodgy interrupt handler) or via agressive prefetch (as allowed for by the architecture). This rogue data can then result in coherency issues once the pages are mapped out or made uncacheable a short time later.
    The fix for this is to make the page uncacheable before performing the cache maintenance (although this isn't ideal, as prior to ARMv7 it's implementation defined whether address-based cache maintenance ops affect uncacheable pages or not - and on ARM11 it seems that they don't, so for that CPU we currently force a full cache clean instead)
  * Modern ARMs generally ignore unexpected cache hits, so there's an interrupt hole in the current OS_Memory 0 "make temporarily uncacheable" implementation where the cache is being flushed after the page has been made uncacheable (consider the case of a page that's being used by an interrupt handler, but the page is being made uncacheable so it can also be used by DMA). As well as affecting ARMv7+ devices this was found to affect XScale (and ARM11, although untested for this issue, would have presumably suffered from the "can't clean uncacheable pages" limitation)
    The fix for this is to disable IRQs around the uncache sequence - however FIQs are currently not being dealt with, so there's still a potential issue there.
  File changes:
  - Docs/HAL/ARMop_API, hdr/KernelWS, hdr/OSMisc - Add new Cache_CleanInvalidateRange ARMop
  - s/ARM600, s/VMSAv6 - BangCam updated to make the page uncacheable prior to flushing the cache. Add GetTempUncache macro to help with calculating the page flags required for making pages uncacheable. Fix abort in OS_MMUControl on Raspberry Pi - MCR-based ISB was resetting ZeroPage pointer to 0
  - s/ARMops - Cache_CleanInvalidateRange implementations. PL310 MMU_ChangingEntry/MMU_ChangingEntries refactored to rely on Cache_CleanInvalidateRange_PL310, which should be a more optimal implementation of the cache cleaning code that was previously in MMU_ChangingEntry_PL310.
  - s/ChangeDyn - Rename FastCDA_UpFront to FastCDA_Bulk, since the cache maintenance is no longer performed upfront. CheckCacheabilityR0ByMinusR2 now becomes RemoveCacheabilityR0ByMinusR2. PMP LogOp implementation refactored quite a bit to perform cache/TLB maintenance after making page table changes instead of before. One flaw with this new implementation is that mapping out large areas of cacheable pages will result in multiple full cache cleans while the old implementation would have (generally) only performed one - a two-pass approach over the page list would be needed to solve this.
  - s/GetAll - Change file ordering so GetTempUncache macro is available earlier
  - s/HAL - ROM decompression changed to do full MMU_Changing instead of MMU_ChangingEntries, to make sure earlier cached data is truly gone from the cache. ClearPhysRAM changed to make page uncacheable before flushing cache.
  - s/MemInfo - OS_Memory 0 interrupt hole fix
  - s/AMBControl/memmap - AMB_movepagesout_L2PT now split into cacheable+non-cacheable variants. Sparse map out operation now does two passes through the page list so that they can all be made uncacheable prior to the cache flush + map out.
Admin:
  Tested on StrongARM, XScale, ARM11, Cortex-A7, Cortex-A9, Cortex-A15, Cortex-A53
  Appears to fix the major issues plaguing SATA on IGEPv5


Version 5.35, 4.79.2.306. Tagged as 'Kernel-5_35-4_79_2_306'
@
text
@d19 2
a20 2
        GBLL  FastCDA_Bulk ; Do all cache/TLB maintenance in bulk instead of on a per-page basis
FastCDA_Bulk SETL {TRUE}
d25 1
a25 1
        GBLL  FastCDA_Unnecessary ; Avoid unnecessary cache cleaning in DoTheGrowPagesSpecified
d41 1
a41 1
FastCDA_Prof_DoublyRemoveCacheability # 4
d54 2
a55 2
FastCDA_Prof_MMUChangingCached       # 4 ; MMU_ChangingUncached followed by Cache_CleanInvalidateaAll
FastCDA_Prof_MMUChangingUncached     # 4 ; MMU_ChangingUncached followed by nothing
d450 2
a451 4
  [ FastCDA_Bulk
; RemoveCacheabilityR0ByMinusR2
; Make a range of pages (temporarily) uncacheable prior to (re)moving them
; Doesn't perform any cache/TLB maintenance
d455 1
a455 1
;              Flag clear if at least one page was cacheable
d459 2
a460 4
RemoveCacheabilityR0ByMinusR2 ROUT
        Entry   "r1-r5"
        MOV     r5, #DynAreaFlags_NotCacheable
        MOV     r1, #-1
a463 20
        TST     r6, #DynAreaFlags_NotCacheable
        BNE     %FT90
        ; Work out required page flags - use cached flags from last page if possible
        CMP     r1, r6
        BEQ     %FT20
        LDR     r3, =ZeroPage
        MOV     r1, r6
        LDR     r3, [r3, #MMU_PCBTrans]
        GetTempUncache r4, r6, r3, lr
20
        ; Update the current L2PT entry
        LDR     r3, =L2PT
        LDR     lr, =TempUncache_L2PTMask
        LDR     r5, [r3, r0, LSR #10]
        BIC     r5, r5, lr
        ORR     r5, r5, r4
        STR     r5, [r3, r0, LSR #10]
        ; Clear the flag from R5
        MOV     r5, #0
90
d465 1
d467 1
a467 1
        MOV     r6, r5
d2933 7
a2939 6
                              ^ 0, sp
PMPLogOp_PageList             # PMPLogOp_ChunkSize*4 ; List of pages to map out
PMPLogOp_UnsafeMapIn          # 4 ; Nonzero if we've done an 'unsafe' map in
PMPLogOp_GlobalTLBFlushNeeded # 4 ; Nonzero if a global TLB flush needed on exit
                              # 8 ; Padding!
PMPLogOp_FrameSize            # 0
d2975 3
a2977 2
        STR     r0, PMPLogOp_UnsafeMapIn
        STR     r0, PMPLogOp_GlobalTLBFlushNeeded
d3115 1
a3115 1
        ; We should be able to make this an unsafe op if the page isn't cacheable. But to avoid global TLB flushes when only one or two pages are being unmapped, only make it unsafe if we've already scheduled a global flush.
d3117 3
a3119 2
        LDRNE   r7, [sp, #:INDEX:PMPLogOp_GlobalTLBFlushNeeded + 6*4 + 4*4]
        TEQNE   r7, #0
d3128 1
d3132 1
a3132 1
        STRNE   pc, [sp, #:INDEX:PMPLogOp_UnsafeMapIn + 6*4]
d3155 6
a3160 4
        LDR     r3, PMPLogOp_GlobalTLBFlushNeeded
        DebugReg r3, "GlobalTLBFlushedNeeded? "
        LDR     r3, PMPLogOp_UnsafeMapIn
        DebugReg r3, "UnsafeMapIn? "
d3164 1
d3166 1
a3166 1
        LDR     r0, PMPLogOp_GlobalTLBFlushNeeded
d3169 5
d3177 1
a3177 2
      [ MEMM_Type = "VMSAv6"
        LDR     r0, PMPLogOp_UnsafeMapIn
d3184 1
a3185 1
75
d3242 6
a3247 8
        ; r10 -> DANode
        ; First go through and make them all uncacheable
        CMP     r0, #0
        BEQ     %FT10

        ; Work out if a global cache flush makes sense
        MOV     r8, r1
        MOV     r6, r0, LSL #12
d3249 3
a3251 55
        CMP     r6, r0
        ORRHI   r6, r6, #1

        MOV     r7, r3
        LDR     r12, [r12, #CamEntriesPointer]
        LDR     r3, =Nowhere
        LDR     r10, =L2PT
        MOV     r9, #-1
05
        LDR     r2, [r7], #4
      [ PMPDebug
        DebugReg r2, "Uncache page "
      ]
        ADD     r11, r12, r2, LSL #CAM_EntrySizeLog2
        ASSERT  CAM_LogAddr=0
        ASSERT  CAM_PageFlags=4
        LDMIA   r11, {r11, lr}
        TEQ     r11, r3                 ; Check something actually there (mainly to stop DANode_Size going out of sync if page list requests for same page to be unmapped multiple times)
        BEQ     %FT08
        TST     lr, #DynAreaFlags_NotCacheable
        BNE     %FT08
        ; Calculate required page flags
        CMP     r9, lr
        BEQ     %FT06
        LDR     r1, =ZeroPage
        LDR     r1, [r1, #MMU_PCBTrans]
        GetTempUncache r2, lr, r1, r4
06
        ; Bypass BangCAM and update L2PT directly (avoids CAM gaining any unwanted temp uncacheability flags)
        LDR     r4, =TempUncache_L2PTMask
        LDR     lr, [r10, r11, LSR #10]
        BIC     lr, lr, r4
        ORR     lr, lr, r2
        STR     lr, [r10, r11, LSR #10]
        ; r6 bit 0 set if TLB+cache invalidation done on per-page basis
        TST     r6, #1
        BEQ     %FT07
        LDR     r4, =ZeroPage
        MOV     r0, r11
        ARMop   MMU_ChangingUncachedEntry,,,r4
        MOV     r0, r11
        ADD     r1, r11, #4096
        ARMop   Cache_CleanInvalidateRange,,,r4
07
        SUBS    r6, r6, #4096
        BLS     %FT09                   ; Can stop if that was the last cacheable page
08
        SUBS    r8, r8, #1
        BNE     %BT05

09
        ; Do global TLB+cache invalidate if required
        LDR     r12, =ZeroPage
        TST     r6, #1
        BNE     %FT10
d3253 1
a3253 1
        DebugTX "Global cache flush"
d3255 3
a3257 3
        ARMop   MMU_ChangingUncached,,,r12
        ARMop   Cache_CleanInvalidateAll,,,r12

d3259 4
a3262 5
        FRAMLDR r1
        ADD     r7, sp, #14*4
        ; Work out if we should do a global TLB flush after the unmap
        MOV     r5, #0
        LDR     r4, [r7, #:INDEX:PMPLogOp_GlobalTLBFlushNeeded]
d3264 1
a3264 1
        BNE     %FT20
d3267 9
a3275 3
        ; Global TLB/uncached flush wanted - make BangCAM unsafe, request global flush from main code
        MOV     r5, #PageFlags_Unsafe
        STR     pc, [r7, #:INDEX:PMPLogOp_GlobalTLBFlushNeeded]
d3281 2
a3282 2
        MOV     r8,r1
        FRAMLDR r10
d3289 1
a3289 1
        DebugReg r2, "Umap page "
d4153 1
a4159 6
      [ MEMM_Type = "VMSAv6"
        ; DSB + ISB required to ensure effect of page table write is fully
        ; visible (after overwriting a faulting entry)
        myDSB   ,r0
        myISB   ,r0,,y
      ]
d5004 1
d5007 3
a5009 3
      [ FastCDA_Bulk
        Push    "r0"
        BL      RemoveCacheabilityR0ByMinusR2
d5016 1
d5018 2
a5019 7
        ARMop   MMU_ChangingUncached,,, r4
        TST     r6, #DynAreaFlags_NotCacheable
        BNE     %FT19
        LDR     r1, [sp]
        SUB     r0, r1, r2
        ARMop   Cache_CleanInvalidateRange,,, r4
        B       %FT19
a5021 6
        LDR     r0, [r11, #DANode_Base]
        MOV     r1, r2
        LDR     r2, [sp, #4]                    ; Grab old source size (pushed r3)
        BL      RemoveCacheabilityR0ByMinusR2   ; Remove cacheability for entireity of lower mapping (whole thing needs shuffling)
        MOV     r2, r1
        ARMop   MMU_ChangingUncached,,, r4
d5023 2
a5024 1
        ARMop   Cache_CleanInvalidateAll, EQ,, r4
d5026 1
a5026 1
        Pull    "r0"
d5033 1
a5033 1
      [ FastCDA_Bulk
d5043 1
a5043 1
        Push    "r2"
d5047 1
a5047 1
        LDR     r1, [r12, #DANode_PMP]
d5059 9
a5067 2
      [ FastCDA_Bulk
        ; Flush the TLB for the removed pages
d5100 1
a5100 1
 [ FastCDA_Bulk
d5106 6
a5111 2
      [ FastCDA_Bulk
        ; Flush the TLB for the shuffled pages
d5703 1
a5703 1
      [ FastCDA_Bulk
d5708 1
a5708 3
        BL      RemoveCacheabilityR0ByMinusR2
        LDR     r2, =ZeroPage
        ARMop   MMU_ChangingUncached,,, r2
d5710 5
a5714 1
        ARMop   Cache_CleanInvalidateAll, EQ,, r2
d5729 10
a5738 9
      [ FastCDA_Bulk
        ; Flush the shuffled pages from the TLB
        ; Note we only flush the area containing pages which have been
        ; moved/removed; for pages which have been mapped in the only
        ; requirement is that (for VMSAv6) we issue a DSB+ISB, which we can
        ; assume the MMU_ChangingUnachedEntries op will do for us.
        Push    "r3"
        SUB     r0, r0, r3
        MOV     r1, r3, LSR #12
d5741 1
a5741 1
        Pull    "r3"
d5748 1
a5748 1
   [ FastCDA_Bulk
d5773 1
a5773 1
      [ FastCDA_Bulk :LAND: (MEMM_Type = "VMSAv6")
d5910 1
a5910 1
    [ FastCDA_Bulk
d5913 1
a5913 1
        FastCDA_ProfStart DoublyRemoveCacheability, r0, r6, lr
d5916 3
a5918 2
        BL      RemoveCacheabilityR0ByMinusR2
        FastCDA_ProfEnd DoublyRemoveCacheability, r0, r2, lr
d5921 1
a5921 2
        TST     r6, #DynAreaFlags_NotCacheable
        LDREQ   lr,[r2,#FastCDA_Prof_MMUChangingCached]
d5925 1
a5925 1
        STREQ   lr,[r2,#FastCDA_Prof_MMUChangingCached]
d5928 4
a5931 3
        ARMop   MMU_ChangingUncached,,, r2
        TST     r6, #DynAreaFlags_NotCacheable
        ARMop   Cache_CleanInvalidateAll, EQ,, r2
d5935 1
a5935 1
        LDREQ   lr,[r2,#FastCDA_Prof_MMUChangingCached]
d5938 1
a5938 1
        STREQ   lr,[r2,#FastCDA_Prof_MMUChangingCached]
d5957 10
a5966 6
      [ FastCDA_Bulk
        ; Flush the shuffled pages from the TLB
        ; Note we only flush the area containing pages which have been
        ; moved/removed; for pages which have been mapped in the only
        ; requirement is that (for VMSAv6) we issue a DSB+ISB, which we can
        ; assume the MMU_ChangingUnachedEntries op will do for us.
d6356 1
d6360 2
a6361 2
        Push    "r0-r2, r4, r11"
        LDR     r4, =ZeroPage
d6365 2
a6366 8
        ; Use BangCam to remove the cacheability on the needed page
        LDR     r2, [r8, #0] ; Get page number of needed page
        ORR     r11, r11, #1<<TempUncacheableShift ; Make temp uncache
        BL      Call_CAM_Mapping ; This will flush the TLB for us, but won't flush the cache
        ; So now we flush the cache manually
        MOV     r0, r3
        ADD     r1, r3, #4096
        ARMop   Cache_CleanInvalidateRange,,,r4
d6370 1
a6370 1
        Pull    "r0-r2, r4, r11"
d6497 1
a6497 1
      [ FastCDA_Bulk
d6502 1
a6502 3
        BL      RemoveCacheabilityR0ByMinusR2
        LDR     r2, =ZeroPage
        ARMop   MMU_ChangingUncached,,, r2
d6504 5
a6508 1
        ARMop   Cache_CleanInvalidateAll, EQ,, r2
d6523 10
a6532 6
      [ FastCDA_Bulk
        ; Flush the shuffled pages from the TLB
        ; Note we only flush the area containing pages which have been
        ; moved/removed; for pages which have been mapped in the only
        ; requirement is that (for VMSAv6) we issue a DSB+ISB, which we can
        ; assume the MMU_ChangingUnachedEntries op will do for us.
d6545 1
a6545 1
   [ FastCDA_Bulk
d6568 1
a6568 1
      [ FastCDA_Bulk :LAND: (MEMM_Type = "VMSAv6")
@


4.9.2.37
log
@Improve safety of OS_Memory 0 "make temporarily uncacheable" and *Cache off
Detail:
  s/MemInfo - Wrap OS_Memory 0 in some code which will temporarily claim the FIQ vector when making pages temporarily uncacheable, to avoid any issues caused by modern ARMs ignoring unexpected cache hits
  s/VMSAv6 - Claim FIQs when OS_MMUControl is asked to make a change to the SCTLR, to avoid similar issues on modern ARMs. Also make the stack temporarily uncacheable before disabling the cache, so that we don't run into any problems using the stack inbetween disabling the cache and completing the clean+invalidate.
Admin:
  Tested on Pi 2B, 3B
  *Cache off now works reliably on Pi 2B, although there is sometimes a pause of a few seconds while things sort themselves out (USB?)
  *Cache off "works" on Pi 3B but everything will fall over soon afterwards due to the Cortex-A53 not supporting LDREX/STREX to non-cacheable pages (or when the page is effectively non-cacheable, i.e. cacheable page with cache disabled)


Version 5.35, 4.79.2.311. Tagged as 'Kernel-5_35-4_79_2_311'
@
text
@a2402 2
        LTORG

@


4.9.2.38
log
@Fix PMP corruption caused by early errors generated by OS_DynamicArea 21
Detail:
  s/ChangeDyn - When DynArea_PMP_PhysOp generates an error during the initial page list scan, make sure r12 is initialised to the (new) PMP size, as expected by PMPMemoryMoved.
  s/AMBControl/allocate, s/AMBControl/growshrink - Document some extra exit conditions for the AMB allocate & grow/shrink routines
Admin:
  Tested on BB-xM
  Fixes RAM disc PMP becoming corrupt when attempting to grow it (e.g. via *ChangeDynamicArea) by an amount larger than the amount of free memory in the system


Version 5.35, 4.79.2.324. Tagged as 'Kernel-5_35-4_79_2_324'
@
text
@a2862 1
        LDR     r12, [r10, #DANode_PMPSize]
a2875 1
        LDR     r12, [r10, #DANode_PMPSize]
@


4.9.2.18.2.1
log
@Add VMSAv6 MMU support, fixes to allow booting on beagleboard
Detail:
  s/ARM600 - fix to SyncCodeAreasRange to correctly read cache line length for WB_CR7_Lx caches
  s/ARMops - Cortex cache handling fixes. Enable L2 cache for Cortex.
  s/ChangeDyn - VMSAv6 support in AllocateBackingLevel2
  s/HAL - Improve RISCOS_InitARM to set/clear correct CP15 flags for ARMv6/v7. VMSAv6 support in code to generate initial page tables.
  s/NewReset - Extra DebugTX calls during OS startup. Disable pre-HAL Processor_Type for HAL builds.
  s/VMSAv6 - Main VMSAv6 MMU code - stripped down version of s/ARM600 with support for basic VMSAv6 features.
  hdr/Options - Use VMSAv6 MMU code, not ARM600. Disable ARM6support since current VMSAv6 code will conflict with it.
Admin:
  Tested basic OS functionality under qemu-omap3 and revision B6 beagleboard.


Version 5.35, 4.79.2.98.2.3. Tagged as 'Kernel-5_35-4_79_2_98_2_3'
@
text
@d2447 2
a2448 2
 [ MEMM_Type = "VMSAv6"
        LDR     lr, =L1_Page
a2449 3
  [ ECC
        LDR     lr, =L1_Page + L1_U + L1_P              ; form other bits to put in L1
  |
a2450 1
  ]
@


4.9.2.18.2.2
log
@Fix error handling for sparse dynamic area resize operations, increase Cortex kernel version number to 5.15
Detail:
  s/ChangeDyn - Swap CMP with TEQ to avoid accidental clobbering of V flag before its state is checked on return from a SWI. Errors encountered during sparse dynamic area resize operations (OS_DynamicArea 9 & 10) should now be reported properly.
  Version - Update kernel version/date to 5.15, to match current HAL version. This change is to allow modules to properly detect whether the kernel has the sparse dynamic area fix - it does not (yet) mean that the Cortex kernel contains all the features of the current development HAL kernel!
Admin:
  Tested on rev C2 beagleboard


Version 5.35, 4.79.2.98.2.14. Tagged as 'Kernel-5_35-4_79_2_98_2_14'
@
text
@d1734 1
a1734 1
        TEQ     r4,#0
@


4.9.2.18.2.3
log
@Fix more issues caused by aborting MVA cache/TLB ops on ARMv7
Detail:
  s/ARMops - Fixed an instance of 'invalidate branch predictor entry' that should have been 'invalidate all branch predictors'
  s/ChangeDyn - Avoid cleaning the Nowhere page when reallocating memory, to avoid incurring the performance hit of the abort handler, and to avoid AMBControl screwing things up by mapping in pages that we're trying to modify
  s/VMSAv6 - Move MVA cache/TLB abort handler to before ChocolateAMB code, to ensure AMBControl doesn't try mapping in pages for harmless cache/TLB op aborts. Also tweaked code to be a little bit faster.
Admin:
  Tested on rev C2 beagleboard. No more lockups when moving screen memory around, for now at least.


Version 5.35, 4.79.2.98.2.30. Tagged as 'Kernel-5_35-4_79_2_98_2_30'
@
text
@a3894 1
        LDR     r4, =Nowhere                    ; There's no point in cleaning the nowhere page, and on some architectures it'll even trigger an abort handler due to the lack of mapping
a3895 1
        TEQ     r3, r4
d3897 1
a3897 1
        ARMop   MMU_ChangingEntry,NE,,r4
@


4.9.2.18.2.4
log
@Update OS_IICOp to support multiple IIC buses
Detail:
  OS_IICOp (and in turn, RISCOS_IICOpV) now treat the top byte of R1 as containing the IIC bus number, allowing multiple buses to be used.
  hdr/KernelWS - Changed workspace a bit so that the kernel can support up to IICBus_Count buses (currently 3), each with its own IICBus_* block.
  s/HAL - Update Reset_IRQ_Handler to cope with interrupts from all IIC buses instead of just the first. Fix/update RISCOS_IICOpV description.
  s/NewIRQs - Update InitialiseIRQ1Vtable to set up interrupt handlers for all IRQ-supporting IIC buses
  s/NewReset - Get rid of the IICAbort call that was just before IICInit. IICInit now calls IICAbort itself.
  s/PMF/IIC - Bulk of the changes. Code now uses the IICBus_ structures instead of the IICStatus and IICType variables. Re-entrancy code has been updated to take into account the possiblity of multiple buses; when OS_IICOp calls are nested, the IIC transfers will be added to bus-specific queues instead of all going in the same queue. However only one queue will be processed at a time.
  s/ChangeDyn - Workspace shuffling means a couple of MOV's needed to be swapped with LDR's when getting immediate constants
Admin:
  Tested with OMAP & IOMD ROM builds.
  Both high & low-level bus types seem to work OK, along with re-entrancy, both on the same bus and on a different bus.


Version 5.35, 4.79.2.98.2.33. Tagged as 'Kernel-5_35-4_79_2_98_2_33'
@
text
@d2749 1
a2749 1
        LDR     lr, =SysHeapDANode              ; initialise system heap node
d2854 1
a2854 1
        LDR     r2, =SysHeapDANode
@


4.9.2.18.2.5
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d171 1
a171 2
        LDR     r0, =ZeroPage
      [ ZeroPage = 0
a172 4
      |
        MOV     r10, #0
        STR     r10, [r0, #CDASemaphore]
      ]
d231 1
a231 1
        LDR     r2, =ZeroPage
d233 1
a233 4
        ADD     r5, r2, #PhysRamTable
      [ ZeroPage <> 0
        MOV     r2, #0
      ]
d247 1
a247 1
        LDR     r1, =ZeroPage
d294 1
a294 1
        LDR     r2, =ZeroPage
d296 1
a296 4
        ADD     r5, r2, #PhysRamTable
      [ ZeroPage <> 0
        MOV     r2, #0
      ]
a385 1
      [ ZeroPage = 0
a386 4
      |
        LDREQ   r1, =ZeroPage
        LDREQ   r1, [r1, #AplWorkSize]
      ]
d439 1
a439 1
      LDR      R10, =ZeroPage
d456 1
a456 1
        LDR     r14, =ZeroPage
d499 1
a499 1
        LDR     r14, =ZeroPage
d542 1
a542 1
        LDR     r5, =ZeroPage+PhysRamTable
d598 1
a598 1
        LDR     r9, =ZeroPage
d831 1
a831 1
        LDR     r11, =ZeroPage
d861 1
a861 1
        LDR     r11, =ZeroPage
d872 1
a872 1
        LDR     r10, =ZeroPage
d887 1
a887 1
        LDR     r10, =ZeroPage
a963 3
      [ ZeroPage <> 0
        LDR     r7, =ZeroPage
      ]
d1032 1
a1032 1
        LDR     r8, =ZeroPage+DAList
d1049 1
a1049 1
        LDR     r11, =ZeroPage
d1074 1
a1074 1
        LDR     r11, =ZeroPage
d1115 1
a1115 1
        LDR     r11, =ZeroPage
d1193 1
a1193 1
        LDR     r11, =ZeroPage
a1200 2
        LTORG

d1240 1
a1240 1
        LDR     r11, =ZeroPage
d1266 1
a1266 1
        LDR     r11, =ZeroPage
d1294 1
a1294 1
        LDR     r11, =ZeroPage
d1321 1
a1321 1
        LDR     r11, =ZeroPage
d1455 1
a1455 1
        LDR     r11, =ZeroPage
d1498 1
a1498 1
        LDR     r11, =ZeroPage
d1528 1
a1528 1
        LDR     r11, =ZeroPage
d1579 1
a1579 1
        LDR     r11, =ZeroPage
d1767 1
a1767 1
        LDR     r11,=ZeroPage
d1825 1
a1825 1
        LDR     r11, =ZeroPage
a1831 1
    [ ZeroPage = 0
a1832 4
    |
        LDREQ   r10, =ZeroPage
        LDREQ   r10, [r10, #DAList]
    ]
d1860 1
a1860 1
        LDR     r11, =ZeroPage
d1925 1
a1925 1
        LDR     r11, =ZeroPage                         ; we know system areas cannot be renumbered
d1984 1
a1984 1
        LDR     r2, =ZeroPage
d1988 1
a1988 1
        LDR     r11, =ZeroPage
d1993 1
a1993 1
        LDR     r11, =ZeroPage+DAList
d2038 1
a2038 1
        LDR     r10, =ZeroPage+DAList
d2050 1
a2050 1
        LDR     r11, =ZeroPage
d2065 1
a2065 1
        LDR     r11, =ZeroPage
d2133 1
a2133 1
        LDR     lr, =ZeroPage
d2164 1
a2164 1
        LDR     lr, =ZeroPage+DAList
d2249 1
a2249 1
        LDR     r1, =ZeroPage+DAList                             ; r1 is ptr into dyn areas list
d2254 1
a2254 1
        LDR     lr, =ZeroPage
a2285 2
        LTORG

d2388 1
a2388 1
        LDR     r1, =ZeroPage
d2412 1
a2412 4
      [ ZeroPage <> 0
        MOV     r1, #0
      ]
        MOV     r8, #0                                  ; 0 => translation fault
d2437 1
a2437 1
        LDR     lr, =ZeroPage
d2661 1
a2661 1
        LDR     lr, =ZeroPage+AppSpaceDANode
d2666 1
a2666 1
        LDR     lr, =ZeroPage+FreePoolDANode
d2685 1
a2685 1
        LDR     r5, =ZeroPage                   ; r5 = amount of memory in free pool so far (and ptr to 0)
a2698 3
      [ ZeroPage <> 0
        MOV     r5, #0
      ]
d2713 1
a2713 1
        LDR     r5, =ZeroPage                   ; r5 = amount of memory in free pool so far (and ptr to 0)
a2715 3
      [ ZeroPage <> 0
        MOV     r5, #0
      ]
d2718 1
a2718 1
        LDR     r0, =ZeroPage+L2PTSize
d2734 1
a2734 1
        LDR     lr, =ZeroPage+FreePoolDANode    ; may be used below to update DAList head ptr
d2746 1
a2746 2
        LDR     r0, =ZeroPage                   ; initialise module list to empty
      [ ZeroPage = 0
a2747 4
      |
        MOV     lr, #0
        STR     lr, [r0, #Module_List]
      ]
d2749 1
a2749 1
        LDR     lr, =ZeroPage+SysHeapDANode     ; initialise system heap node
d2753 1
a2753 1
        LDR     r0, =ZeroPage
d2755 1
a2755 1
        ADD     lr, r0, #FreePoolDANode             ; cf comments above/below - what was old code? KJB
d2766 1
a2766 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d2797 1
a2797 2
        LDR     r0,=ZeroPage
      [ ZeroPage = 0
a2798 4
      |
        MOV     r3,#0
        STR     r3,[r0,#Oscli_CmdHashSum]
      ]
a2800 3
      [ ZeroPage <> 0
        MOV     r0, #0
      ]
d2811 1
a2811 1
        LDR     r0, =ZeroPage
a2815 3
      [ ZeroPage <> 0
        MOV     r0, #0
      ]
d2846 1
a2846 1
        LDR     r1, =ZeroPage+FreePoolDANode
d2848 1
a2848 1
        LDR     r2, =ZeroPage+SysHeapDANode
d2854 1
a2854 1
        LDR     r2, =ZeroPage+SysHeapDANode
d2856 1
a2856 1
        LDR     r2, =ZeroPage+FreePoolDANode
d2860 1
a2860 1
        ASSERT  ZeroPage = 0
d2866 1
a2866 2
        LDR     r0, =ZeroPage
      [ ZeroPage = 0
a2867 4
      |
        MOV     r2, #0
        STR     r2, [r0, #CDASemaphore]         ; clear CDASemaphore
      ]
d2877 1
a2877 1
        &       ZeroPage+SysHeapDANode
d2895 1
a2895 1
        &       ZeroPage+FreePoolDANode         ; link -> free pool node, since FreePoolAddress > SysHeapStart
d2951 7
a2957 7
        LDR     r10, =ZeroPage                  ; check we're not in an IRQ
        LDR     lr, [r10, #IRQsema]
        TEQ     lr, #0
        LDREQ   lr, [r10, #CDASemaphore]       ; now also check whether ChangeDynamicArea is already threaded
        TEQEQ   lr, #0
        LDREQB  lr, [r10, #VRAMRescue_control] ; also check that wimp has not locked Free Pool
        TSTEQ   lr, #VRRc_wimp_lock
d2959 2
a2960 1
        STR     pc, [r10, #CDASemaphore]     ; store non-zero value in CDASemaphore, to indicate we're threaded
d3003 1
a3003 1
        LDR     r11, =ZeroPage
d3019 1
a3019 1
        LDR     r5, =ZeroPage
a3036 4
      [ ZeroPage <> 0
        LDR     r2, =ZeroPage
        ADD     r12, r12, r2
      ]
a3077 1
      [ ZeroPage = 0
a3079 5
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        CMP     r11, lr                         ; if src <> appspace
        CMPNE   r12, lr                         ; and dst <> appspace
      ]
a3129 1
      [ ZeroPage = 0
a3131 5
      |
        LDR     lr, =ZeroPage+AppSpaceDANode
        TEQ     r12, lr                         ; check if dest = appspace
        STREQ   r3, [lr, #MemLimit-AppSpaceDANode] ; update memlimit if so
      ]
d3157 1
a3157 2
        LDR     r4, =ZeroPage                   ; indicate no page block (and ptr to semaphore)
      [ ZeroPage = 0
a3158 4
      |
        MOV     lr, #0
        STR     lr, [r4, #CDASemaphore]
      ]
a3173 4
      [ ZeroPage <> 0
        LDR     r2, =ZeroPage
        ADD     r11, r11, r2
      ]
d3183 1
a3183 1
      [ ZeroPage = 0
a3185 5
      |
        LDR     r2, =ZeroPage+AppSpaceDANode
        CMP     r11, r2                         ; if appspace        
        LDR     r2, [r11, #DANode_Size]         ; amount src could shrink
      ]
d3213 1
a3213 1
      [ ZeroPage = 0
a3214 6
      |
        Push    "lr"
        LDR     lr, =ZeroPage+AppSpaceDANode
        CMP     r11, lr
        Pull    "lr"
      ]
d3252 1
a3252 1
        LDR     r4, =ZeroPage+AppSpaceDANode
d3270 1
a3270 1
        LDREQ   r11, =ZeroPage+AppSpaceDANode   ; if not, then just take from aplspace
d3279 1
a3279 1
      [ ZeroPage = 0
a3280 5
      |
        LDR     r10, =ZeroPage+AppSpaceDANode
        CMP     r11, r10                        ; if source = aplspace
      ]
        MOV     r10, #0                         ; default value if apl space not involved
d3300 1
a3300 1
        LDREQ   r11, =ZeroPage+FreePoolDANode   ; then start with free
d3319 1
a3319 1
        LDRHI   r11, =ZeroPage+AppSpaceDANode   ; which is app space
a3324 1
      [ ZeroPage = 0
a3325 4
      |
        LDR     r2, =ZeroPage
        STR     r1, [r2, #CDASemaphore]         ; OK to reenter now (we've done the damage)
      ]
d3346 1
a3346 1
        LDRHI   r11, =ZeroPage+AppSpaceDANode   ; which is app space
d3414 1
a3414 2
        LDR     r0, =ZeroPage
      [ ZeroPage = 0
a3415 4
      |
        MOV     lr, #0
        STR     lr, [r0, #CDASemaphore] ; clear CDASemaphore
      ]
d3439 1
a3439 1
        LDR     r10, =ZeroPage+DAList
d3455 1
a3455 2
        LDR     r0, =ZeroPage
      [ ZeroPage = 0
a3456 4
      |
        MOV     lr, #0
        STR     lr, [r0, #CDASemaphore]         ; momentarily pretend we're not threaded
      ]
a3458 1
      [ ZeroPage = 0
a3460 4
      |
        LDR     r0, =ZeroPage
        STR     r0, [r0, #CDASemaphore]         ; we're threaded again
      ]
a3537 1
      [ ZeroPage = 0
a3538 4
      |
        LDR     r1, =ZeroPage+AppSpaceDANode
        TEQ     r11, r1                                 ; if just appspace
      ]
d3635 1
a3635 1
        LDR     r0, =ZeroPage
d3652 1
a3652 1
        LDR     r4, =ZeroPage+PhysRamTable
a3679 1
      [ ZeroPage = 0
a3680 4
      |
        LDR     r1, =ZeroPage+AppSpaceDANode
        TEQ     r11, r1                                 ; if appspace
      ]
d3717 1
a3717 1
        LDR     r3, =ZeroPage
d3758 1
a3758 1
        LDR     r1, =ZeroPage+PhysRamTable
d3884 1
a3884 1
        LDR     lr, =ZeroPage
d3898 1
a3898 1
        LDRNE   r4, =ZeroPage
a3976 1
      [ ZeroPage = 0
a3977 4
      |
        LDR     r1, =ZeroPage+AppSpaceDANode
        TEQ     r1, r11                                 ; if just appspace
      ]
d4052 1
a4052 1
        LDR     r2, =ZeroPage
d4266 1
a4266 1
        LDR     r5, =ZeroPage
d4394 1
a4394 1
        LDR     lr, =ZeroPage+VduDriverWorkSpace
d4399 1
a4399 1
        LDR     r0, =ZeroPage
d4460 1
a4460 1
        LDR     r0, =ZeroPage
d4495 1
a4495 1
        LDR     r0, =ZeroPage
d4542 1
a4542 1
        LDR     r1, =ZeroPage
d4731 1
a4731 1
        LDR     LR, =ZeroPage
@


4.9.2.18.2.6
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d339 1
a339 1
StoreDebugRegs ; Note: Corrupts R0,R1
d341 4
a344 5
        LDR     lr, =ZeroPage+CamMapCorruptDebugBlock
        STMIA   lr, {r0-r12}
        STR     sp, [lr, #13*4]!
        LDMIA   sp, {r0,r1}                     ; reload stacked LR & return R0 (error pointer)
        STMIB   lr, {r0,r1}                     ; LR -> LR, error -> PC
@


4.8
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a157 7
     [ International
        Pull    "r0"
        LDR     lr, [sp, #9*4]
        TST     lr, #V_bit
        BLNE    TranslateError
        Pull    "r2-r9, r10, lr"
     |
a158 1
     ]
a867 1
        STRVS   r0, [sp]
a868 1
        EXIT    VS
d900 1
@


4.7
log
@ChocolateSysVars and ChocolateOscli merged from Ursula.

Version 4.84. Tagged as 'Kernel-4_84'
@
text
@d117 1
a117 842
        InsertDebugRoutines

; *** Start of old style code ***

 [ :LNOT: NewStyle_All

ChangeDynamicSWI ROUT
        Push    "r0, r2-r9, r10, lr"        ; r10 is workspace

  [ NewCDA2
        B       CheckForNewArea
IsOldArea
  ]

        CMP     r0, #ChangeDyn_MaxArea
        MOVLS   r10, #0
        LDRLS   r10, [r10, #IRQsema]
        CMPLS   r10, #0
        BHI     failure_IRQgoing

 [ DebugCDA
        DLINE   "Entering OS_ChangeDynamicArea"
        DREG    r0, "r0 = "
        DREG    r1, "r1 = "
 ]

 [ :LNOT: NewStyle_RAMDisc
        CMP     r0, #ChangeDyn_RamFS
        BEQ     CheckRAMFSChangeOK
AllowRAMFSChange
 ]

        MOV     r6, #0
        LDR     r6, [r6, #Page_Size]
        SUB     r12, r6, #1
        ADD     r1, r1, r12
        BICS    r1, r1, r12                     ; round up to nearest page.
        MOVEQ   r11, r0                         ; area
        MOVEQ   r10, #0                         ; amount moved
        BEQ     CDS_PostService                 ; zero pages!

; Now form source (r11) and destination (r12) registers

 [ UseFreePool

        CMP     r0, #ChangeDyn_FreePool         ; if specified area is free pool
        MOVEQ   r11, #ChangeDyn_AplSpace        ; then "other" area is aplspace
        MOVNE   r11, #ChangeDyn_FreePool        ; else other area is free pool

        CMP     r1, #0                          ; if growing area
        MOVPL   r12, r0                         ; then dest is specified area, and src is other
        MOVMI   r12, r11                        ; else dest is other
        MOVMI   r11, r0                         ; and src is specified
        RSBMI   r1, r1, #0                      ; and make change positive
 |
        MOVMI   r12, #ChangeDyn_AplSpace        ; dest := ApplWork
        MOVMI   r11, r0                         ; source := R0
        MOVPL   r12, r0                         ; dest := R0
        MOVPL   r11, #ChangeDyn_AplSpace        ; source := ApplWork
        RSBMI   r1, r1, #0
 ]

 [ DebugCDA
        DREG    r11, "Initially, src = "
        DREG    r12, "and dest = "
 ]

; amount movable = current size(source) - shrink limit(source)

 [ :LNOT: NewStyle_SpriteArea
        CMP     r11, #ChangeDyn_SpriteArea
        LDREQ   r10, [r11, #SpriteSize-ChangeDyn_SpriteArea]
        TEQEQ   r10, #0                 ; May have no sprite area ...
        MOVEQ   r5, #0                  ; Shrink limit := 0
        BEQ     gotsizeandshrink
 ]

; need to lock the heap if we are shrinking the SysHeap or the RMA
; lock by setting the heap end to be the same as the current base;
; this ensures that no claims will use memory about to disappear

        ADRL    r10, Current_Size+4
        LDR     r10, [r10, r11, LSL #2]                 ; get pointer to current size of area

 [ NewStyle_RMA :LAND: NewStyle_SysHeap                 ; if both new
        LDR     r10, [r10]                              ; then just get current size
 |
  [ NewStyle_SysHeap                                    ; if sys heap new
        CMP     r11, #ChangeDyn_RMA                     ; then RMA must be old
  |
        CMP     r11, #ChangeDyn_SysHeap                 ; else sys heap is old
   [ :LNOT: NewStyle_RMA
        CMPNE   r11, #ChangeDyn_RMA                     ; and if RMA old as well, do 2 CMPs
   ]
  ]
        LDRNE   r10, [r10]
        BNE     CDA_GotSize

; its a heap, so munge it to prevent anyone stealing memory while we are

        MOV     lr, pc                                  ; save I_bit
        TEQP    pc, #SVC_mode + I_bit                   ; disable IRQs round this bit
        LDR     r5, [r10]                               ; current size
        LDR     r2, [r10, #hpdbase-hpdend]              ; remove all of the contiguous free chunk from the heap
        STR     r2, [r10]                               ; so that noone can steal any of it under IRQs
        MOV     r10, r5
        STR     r10, [stack, #4*9]                      ; but save the old size on stack to restore later
        TEQP    lr, #0                                  ; restore state

CDA_GotSize
 ]
 [ :LNOT: NewStyle_FontArea
        CMP     r11, #ChangeDyn_FontArea
        BNE     %FT04                                   ; source not font area

        MOV     r5, r1
        MOV     r1, #-1
        MOV     r2, #0                                  ; in case font manager dead
        SWI     XFont_ChangeArea
        MOV     r1, r5                                  ; preserve r1
        MOV     r5, r2
        B       %FT05
04
 ]
        ADR     r5, Shrink_Limits+4                     ; now see how much we can remove from src
        LDR     r5, [r5, r11, LSL #2]                   ; load shrink limit address
        LDR     r5, [r5]                                ; and contents
05
 [ :LNOT: NewStyle_SpriteArea
        CMP     r11, #ChangeDyn_SpriteArea
        CMPEQ   r5, #saExten                            ; if no sprites defined, can delete hdr
        MOVEQ   r5, #0
 ]

gotsizeandshrink
        SUB     r10, r10, r5                            ; amount removable from source
06
        ADR     r5, Grow_LimitsPtrs+4
        LDR     r5, [r5, r12, LSL #2]                   ; get ptr to maximum size of destination area
        LDR     r5, [r5]                                ; maximum size of dest area

 [ MEMC_Type = "IOMD"
        CMP     r12, #ChangeDyn_Screen                  ; if screen
        MOVEQ   r5, #0
        LDREQ   r5, [r5, #VideoSize]                    ; then maximum size depends on how much video RAM there is
 ]

        ADRL    r4, Current_Size+4
        LDR     r4, [r4, r12, LSL #2]                   ; pointer to destination current size
        LDR     r4, [r4]                                ; current size of dest
        SUB     r5, r5, r4                              ; maximum amount we can add to destination

; r10 = amount removable from src, r5 = amount addable to dest

        MOV     r2, r10                                 ; save amount removable from src, in case we need it again
        CMP     r10, r5
        MOVHI   r10, r5                                 ; min(max removable from src, max addable to dest)

; r10 is now the amount we can move
;  IF removing from ApplWork AND amount moveable < size requested
;    Then Error NotAllMoved

        CMP     r10, r1
        BCS     %FT10                                   ; can move all reqd (TMD 15-Oct-91; was GE)

; we can't move all that is required - there are two cases to be considered
;  a) if (src = AplSpace) and (dest <> FreePool) then give error (this can only happen in old world)
;  b) if (src = FreePool) AND (dest <> AplSpace) then check if adding aplspace would allow us to succeed -
;        if it does then adjust registers, else give error

        CMP     r11, #ChangeDyn_AplSpace                ; if src = aplspace
        BNE     %FT08                                   ; [not, so skip]
        CMP     r12, #ChangeDyn_FreePool                ; and dest <> freepool
        BNE     failure_IRQgoing                         ; then fail (case (a))
08
 [ UseFreePool
        CMP     r11, #ChangeDyn_FreePool                ; if src = FreePool
        BNE     %FT10                                   ; [skip if not]
        CMP     r12, #ChangeDyn_AplSpace                ; and dest <> AplSpace
        BEQ     %FT10                                   ; [skip if not]

; now see if we would have enough if we had aplspace as well (r2 = amount we could remove from free pool)

  [ DebugCDA
        DLINE   "Not enough in just free pool"
  ]

        LDR     r4, Current_Size+4+(ChangeDyn_AplSpace :SHL: 2)
        LDR     r4, [r4]                                ; r4 = current apl size
        LDR     lr, Shrink_Limits+4+(ChangeDyn_AplSpace :SHL: 2)
        LDR     lr, [lr]                                ; lr = shrink limit for aplspace
        SUB     r4, r4, lr                              ; r4 = amount we could remove from aplspace

        ADD     r10, r2, r4                             ; add on to amount we could remove from free pool
        CMP     r10, r5                                 ; if more than amount area can grow
        MOVHI   r10, r5                                 ; then limit to that

        CMP     r10, r1                                 ; if still can't do it now
        BCC     failure_IRQgoing                         ; then give error

        TEQ     r2, #0                                  ; else check to see if there was any at all in free pool
        MOVEQ   r11, #ChangeDyn_AplSpace                ; if not then just take from aplspace
        MOVEQ   r5, r10                                 ; and do all

        MOVNE   r11, #ChangeDyn_FreeAndApl              ; else make src indicator reflect that we need both
        MOVNE   r5, r2                                  ; but save amount we are taking from freepool
        B       %FT10
 ]

 [ (:LNOT: NewStyle_SysHeap) :LOR: (:LNOT: NewStyle_RMA)
testrestoreheapend
  [ NewStyle_SysHeap                                    ; if sys heap new
        CMP     r11, #ChangeDyn_RMA                     ; then RMA must be old
  |
        CMP     r11, #ChangeDyn_SysHeap                 ; else sys heap is old
   [ :LNOT: NewStyle_RMA
        CMPNE   r11, #ChangeDyn_RMA                     ; and if RMA old as well, do 2 CMPs
   ]
  ]
        LDREQ   r2, [stack, #4*9]
        ADREQL  r3, Current_Size + 4
        LDREQ   r3, [r3, r11, LSL #2]
        STREQ   r2, [r3]
        MOV     pc, lr
 ]

UserMemStartAddr & UserMemStart

Shrink_Limits                                   ; locations to look at
        &       UserMemStartAddr                ; AplWork - unfudged
 [ NewStyle_SysHeap
        &       &FE000000                       ; cause abort
 |
        &       SysHeapStart + :INDEX: hpdbase  ; SysHeap
 ]
 [ NewStyle_RMA
        &       &FE000000                       ; cause abort
 |
        &       RMAAddress + :INDEX: hpdbase    ; RMA
 ]
        &       VduDriverWorkSpace + ScreenSize ; Screen
 [ NewStyle_SpriteArea
        &       &FE000000                       ; cause abort
 |
        &       SpriteSpaceAddress + saFree     ; Sprites
 ]
 [ NewStyle_FontArea
        &       &FE000000                       ; cause abort
 |
        &       0                               ; Fonts not needed
 ]
 [ NewStyle_RAMDisc
        &       &FE000000                       ; cause abort
 |
        &       MinRamFSSize                    ; RAMFS
 ]
        &       MinFreePoolSize                 ; Free pool

 [ :LNOT: NewStyle_RAMDisc
MinRamFSSize
 ]
MinFreePoolSize
        &       0



Grow_LimitsPtrs
 [ NewCDA
        &       AppSpaceDANode + DANode_MaxSize ; AplWork
 |
        &       AppSpaceMaxSizePtr
 ]
 [ NewStyle_SysHeap
        &       &FE000000                       ; cause abort
 |
        &       SysHeapMaxSizePtr               ; SysHeap
 ]
 [ NewStyle_RMA
        &       &FE000000                       ; cause abort
 |
        &       RMAMaxSizePtr                   ; RMA
 ]
        &       ScreenMaxSizePtr                ; Screen
 [ NewStyle_SpriteArea
        &       &FE000000                       ; cause abort
 |
        &       SpriteSpaceMaxSizePtr           ; Sprites
 ]
 [ NewStyle_FontArea
        &       &FE000000                       ; cause abort
 |
        &       FontCacheMaxSizePtr             ; Fonts
 ]
 [ NewStyle_RAMDisc
        &       &FE000000                       ; cause abort
 |
        &       RAMDiscMaxSizePtr               ; RAMFS
 ]
 [ UseFreePool
        &       FreePoolDANode + DANode_MaxSize ; Free pool
 ]

; The following will eventually become redundant as more and more areas become new ones
; Ultimately the whole lot can be removed when no old areas exist (perhaps in my grandson's lifetime!)

 [ :LNOT: NewStyle_SysHeap
SysHeapMaxSizePtr       &       SysHeapMaxSize
 ]
 [ :LNOT: NewStyle_RMA
RMAMaxSizePtr           &       RMAMaxSize
 ]
ScreenMaxSizePtr        &       ScreenMaxSize
 [ :LNOT: NewStyle_SpriteArea
SpriteSpaceMaxSizePtr   &       SpriteSpaceMaxSize
 ]
 [ :LNOT: NewStyle_FontArea
FontCacheMaxSizePtr     &       FontCacheMaxSize
 ]
 [ :LNOT: NewStyle_RAMDisc
RAMDiscMaxSizePtr       &       RAMDiscMaxSize
 ]
 [ :LNOT: NewCDA
AppSpaceMaxSizePtr      &       AplWorkMaxSize
 ]


Access_Rights
        &       AP_AppSpace
        &       AP_SysHeap
        &       AP_RMA
        &       AP_Screen
        &       AP_Sprites
        &       AP_FontArea
        &       AP_RAMDisc
 [ UseFreePool
        &       AP_FreePool
 ]

10
        CMP     r10, r1                         ; if can move more than asked for
        MOVHI   r10, r1                         ; then move requested amount (TMD 15-Oct-91; was GT)
        BCS     %FT15                           ; (TMD 15-Oct-91); was GE)

; moving less than asked for: set up an error for exit
        ADR     r0, ErrorBlock_ChDynamNotAllMoved
        STR     r0, [stack]
        LDR     r0, [stack, #4*10]
        ORR     r0, r0, #V_bit
        STR     r0, [stack, #4*10]
        SUB     r0, r6, #1                      ; and make amount moveable
        BICS    r10, r10, r0                    ; a pagesize multiple
        BEQ     CDS_PostServiceWithRestore

; IF CAO in ApplWork AND UpCall not claimed THEN Error ChDynamCAO

15
 [ UseFreePool
        MOV     r1, #0                          ; default value if apl space not involved
        CMP     r11, #ChangeDyn_AplSpace        ; if source = aplspace
        RSBEQ   r1, r10, #0                     ; then make amount -ve
        CMP     r11, #ChangeDyn_FreeAndApl      ; if source = free and apl
        SUBEQ   r1, r5, r10                     ; then make it -(amount removing from apl space)
        MOVNE   r5, r10                         ; else set up r5 to be total amount (wasn't set up above)
        CMP     r12, #ChangeDyn_AplSpace        ; if dest = aplspace
        MOVEQ   r1, r10                         ; then make amount +ve

        TEQ     r1, #0                          ; if none of the above
        BEQ     %FT25                           ; then skip this
 |
        MOV     r5, r10                         ; r5 = total amount moving (since no split removes)
        CMP     r11, #ChangeDyn_AplSpace        ; old code - if src = apl
        RSBEQ   r1, r10, #0                     ; then -ve
        MOVNE   r1, r10                         ; else +ve
 ]

 [ DebugCDA
        DREG    r11, "After checking, src = "
        DREG    r12, "and dest = "
        DREG    r10, "Amount moving (total) = "
        DREG    r5,  "Amount moving (partial) = "

        DLINE   "Consulting application about change"
 ]

        MOV     r2, #0
        LDR     r3, [r2, #AplWorkSize]
        LDR     r2, [r2, #Curr_Active_Object]
        CMP     r2, r3                          ; check if CAO outside application space
        BHI     %FT20                           ; [it is so issue Service not UpCall]

; CAO in application space, so issue UpCall to check it's OK

        MOV     r0, #UpCall_MovingMemory :AND: &FF
        ORR     r0, r0, #UpCall_MovingMemory :AND: &FFFFFF00
        TEQ     r1, #0
        RSBMI   r1, r1, #0                      ; r1 passed in is always +ve (probably a bug, but should be compat.)

        SWI     XOS_UpCall                      ; r1 already set up above
        CMP     r0, #UpCall_Claimed
        BEQ     %FT25

        ADRL    r0, ErrorBlock_ChDynamCAO
        B       ChangeDynamic_Error

; IF service call claimed Then Error AplWSpaceInUse

20
        MOV     r0, r1                          ; amount removing from aplspace
        MOV     r1, #Service_Memory
        BL      Issue_Service
        CMP     r1, #Service_Serviced
        BNE     %FT25

        ADRL    r0, ErrorBlock_AplWSpaceInUse
        B       ChangeDynamic_Error

; Right! r10 is amount of memory we will move
; (if moving from free pool + apl space then r5 is amount removing from free pool)
; r11 is the source
; r12 is the destination

25
 [ DebugCDA
        DLINE   "Change is going ahead"
 ]
 [ :LNOT: NewStyle_FontArea
        CMP     r11, #ChangeDyn_FontArea
        LDREQ   r1, [r11, #FontCacheSize-ChangeDyn_FontArea]
        SUBEQ   r1, r1, r10                     ; new size
        SWIEQ   XFont_ChangeArea
 ]

; remove the cursors if screen moving: might flash during modechange wrch

        CMP     r11, #ChangeDyn_Screen
        CMPNE   r12, #ChangeDyn_Screen
        SWIEQ   XOS_RemoveCursors

        CMP     r11, #ChangeDyn_Screen
        RSBEQ   r0, r10, #0

        MOV     r9, pc
        TEQEQP  pc, #SVC_mode+I_bit+Z_bit
        NOP
    ; disable interrupts while sorting out the screen, in case (e.g) screen
    ; start address is being reprogrammed under interrupt

        BLEQ    RemovePages

        TEQP    pc, r9          ; restore interrupt state

; calculate addresses of blocks

        MOV     r9, #0
        LDR     r9, [r9, #MEMC_CR_SoftCopy]

        MOV     r3, r11
        BL      GetBlockEndSource
        MOV     r0, r3                  ; R0 := blockend(source)

        CMP     r12, #ChangeDyn_Screen
        BEQ     ExtendScreen            ; dest=screen: perversion needed

        MOV     r3, r12
        BL      GetBlockEnd             ; R3 := blockend(dest)

; move memory: r5 bytes from r0 backwards to r3 forwards
        MOV     r1, #0
30
        SUB     r0, r0, r6
        Push    "r5,r11"
        ADR     r11, Access_Rights+4
        LDR     r11, [r11, r12, LSL #2] ; get access privs (+ CB bits in new world)
 [ DebugCDA
        DREG    r0, "Moving page at ", cc
        DREG    r3, " to ", cc
        DREG    r11, " with PPL "
 ]
        BL      MoveCAMatR0toR3
        Pull    "r5,r11"
        BVS     cambust
        ADD     r1, r1, r6
        ADD     r3, r3, r6

        CMP     r1, r5                  ; have we done all (of this lot at least)?
        BNE     %BT30                   ; [no, so loop]

        CMP     r5, r10                 ; have we done all of both lots?
        BEQ     %FT33                   ; yes, so finished

        Push    "r1,r3"
        MOV     r3, #ChangeDyn_AplSpace ; else we have more to do, from aplspace
        BL      GetBlockEnd             ; so get apl block end
        MOV     r0, r3                  ; and put into src register
        Pull    "r1,r3"
        MOV     r5, r10
        B       %BT30

33
        CMP     r11, #ChangeDyn_Screen
        BNE     %FT40

; source=screen: need to shuffle rest of screen down.

        VDWS    r5
        LDR     r5, [r5, #TotalScreenSize]
        MOV     r3, #ScreenEndAdr
35
        SUB     r0, r0, r6
        SUB     r3, r3, r6
        Push    "r5"
        MOV     r11, #AP_Screen
        BL      MoveCAMatR0toR3
        Pull    "r5"
        BVS     cambust
        SUBS    r5, r5, r6
        BGT     %BT35
        MOV     r11, #ChangeDyn_Screen

40
; now need to restore sizes if we have locked a heap

 [ (:LNOT: NewStyle_SysHeap) :LOR: (:LNOT: NewStyle_RMA)
        BL      testrestoreheapend
 ]

; update object sizes: current size(dest)   +:= r10
;                      current size(source) -:= r10

        MOV     r4, #0                          ; remember for later
        LDR     r4, [r4, #SpriteSize]

        CMP     r11, #ChangeDyn_FreeAndApl
        BNE     %FT41
        LDR     r2, Current_Size+4+(ChangeDyn_FreePool :SHL: 2)         ; r2 -> old size of free pool
        LDR     lr, [r2]                                                ; lr = old size
        LDR     r3, Shrink_Limits+4+(ChangeDyn_FreePool :SHL: 2)        ; r3 -> shrink limit of free pool
        LDR     r3, [r3]                                                ; r3 = shrink limit
        SUB     lr, lr, r3                                              ; how much we took out of it
        STR     r3, [r2]                                                ; put shrink limit into current size

        LDR     r2, Current_Size+4+(ChangeDyn_AplSpace :SHL: 2)         ; r2 -> old size of apl space
        LDR     r3, [r2]                                                ; r3 = old size of apl space
        SUB     r3, r3, r10                                             ; how much we would have taken out of it
        ADD     r3, r3, lr                                              ; but don't take out the stuff which came out of free
        STR     r3, [r2]
        ADR     r0, Current_Size+4
        B       %FT42

41
        ADR     r0, Current_Size+4
        CMP     r11, #ChangeDyn_Screen          ; don't update TotalScreenSize
        LDRNE   r2, [r0, r11, LSL #2]
        LDRNE   r3, [r2]
        SUBNE   r3, r3, r10
        STRNE   r3, [r2]
42
        CMP     r12, #ChangeDyn_Screen          ; don't update TotalScreenSize
        LDRNE   r2, [r0, r12, LSL #2]
        LDRNE   r3, [r2]
        ADDNE   r3, r3, r10
        STRNE   r3, [r2]

 [ :LNOT: NewStyle_SpriteArea
        CMP     r11, #ChangeDyn_SpriteArea      ; watch out for sprite area creation
        CMPNE   r12, #ChangeDyn_SpriteArea      ; or deletion
        BNE     %FT45

        MOV     r1, #0                          ; used later also!!
        LDR     r3, [r1, #SpriteSize]
        CMP     r3, #0                          ; if sprite area deleted
        LDRNE   r3, =SpriteSpaceAddress         ; tell the vdu drivers
        MOV     r14, #VduDriverWorkSpace
        STR     r3, [r14, #SpAreaStart]
        BEQ     %FT45                           ; and don't touch non-existent memory

        CMP     r4, #0                          ; if area was null,
        LDMNEIB r3, {r4-r6}                     ; (skip size)
        MOVEQ   r4, #0                          ; initialise variables if was null
        MOVEQ   r5, #saExten
        MOVEQ   r6, #saExten
        LDR     r0, [r1, #SpriteSize]           ; set up earlier
        STMIA   r3, {r0,r4-r6}                  ; stash new set of variables
45
 ]
 [ UseFreePool
        CMP     r11, #ChangeDyn_AplSpace        ; if apl space involved in transfer
        CMPNE   r11, #ChangeDyn_FreeAndApl
        CMPNE   r12, #ChangeDyn_AplSpace
        MOVEQ   r0, #0
        LDREQ   r2, [r0, #AplWorkSize]          ; then reset memlimit to aplworksize
        STREQ   r2, [r0, #MemLimit]             ; MemLimit := AplWorkSize
 |
        MOV     r0, #0
        LDR     r2, [r0, #AplWorkSize]
        STR     r2, [r0, #MemLimit]             ; MemLimit := AplWorkSize
 ]

        CMP     r12, #ChangeDyn_Screen
        MOVEQ   r0, r10

        MOV     r9, pc
        TEQEQP  pc, #SVC_mode+I_bit+Z_bit
    ; disable interrupts while sorting out the screen, in case (e.g) screen
    ; start address is being reprogrammed under interrupt

        BLEQ    InsertPages

        TEQP    pc, r9       ; restore interrupt state

        CMP     r11, #ChangeDyn_Screen
        CMPNE   r12, #ChangeDyn_Screen
        SWIEQ   XOS_RestoreCursors

 [ :LNOT: NewStyle_FontArea
        CMP     r12, #ChangeDyn_FontArea
        LDREQ   r1, [r12, #FontCacheSize-ChangeDyn_FontArea]
        SWIEQ   XFont_ChangeArea
 ]

 [ :LNOT: NewStyle_RAMDisc
        CMP     r11, #ChangeDyn_RamFS
        CMPNE   r12, #ChangeDyn_RamFS
        BEQ     reinitialise_RAMFS
 ]
        B       CDS_PostService

Current_Size
        &       AplWorkSize                             ; AplWork
 [ NewStyle_SysHeap
        &       &FE000000                               ; cause abort
 |
        &       SysHeapStart + :INDEX: hpdend           ; SysHeap
 ]
 [ NewStyle_RMA
        &       &FE000000                               ; cause abort
 |
        &       RMAAddress + :INDEX: hpdend             ; RMA
 ]
        &       VduDriverWorkSpace + TotalScreenSize    ; Screen
 [ NewStyle_SpriteArea
        &       &FE000000                               ; cause abort
 |
        &       SpriteSize                              ; sprites
 ]
 [ NewStyle_FontArea
        &       &FE000000                               ; cause abort
 |
        &       FontCacheSize                           ; fonts
 ]
 [ NewStyle_RAMDisc
        &       &FE000000                               ; cause abort
 |
        &       RAMDiscSize                             ; RAMFS
 ]
 [ UseFreePool
        &       FreePoolDANode + DANode_Size            ; Free pool
 ]

GetBlockEndSource
        CMP     r3, #ChangeDyn_FreeAndApl               ; if removing from free + apl
        MOVEQ   r3, #ChangeDyn_FreePool                 ; then start by removing from free pool
 [ (:LNOT: NewStyle_RMA) :LOR: (:LNOT: NewStyle_SysHeap) ; none of this needed if both sysheap+RMA new
  [ NewStyle_SysHeap                                    ; if sys heap new
        CMP     r3, #ChangeDyn_RMA                      ; then RMA must be old
  |
        CMP     r3, #ChangeDyn_SysHeap                  ; else sys heap is old
   [ :LNOT: NewStyle_RMA
        CMPNE   r3, #ChangeDyn_RMA                      ; and if RMA old as well, do 2 CMPs
   ]
  ]
        BNE     GetBlockEnd
        ADR     r4, StartAddrs+4
        LDR     r3, [r4, r3, LSL #2]
        LDR     r4, [stack, #4*9]
        ADD     r3, r3, r4                              ; start + size = end
        MOV     pc, lr
 ]

GetBlockEnd   ; R3 is area to get end of: return address in R3
        MOV     r1, r3
        ADR     r4, StartAddrs+4
        LDR     r3, [r4, r3, LSL #2]
        CMP     r1, #ChangeDyn_Screen                   ; screen ?
        MOVEQ   pc, lr
        ADR     r4, Current_Size+4
        LDR     r4, [r4, r1, LSL #2]
        LDR     r4, [r4]
        ADD     r3, r3, r4                              ; start + size = end
        MOV     pc, lr

StartAddrs
        &       0                               ; AplWork
 [ NewStyle_SysHeap
        &       &FE000000                       ; cause abort
 |
        &       SysHeapStart                    ; SysHeap
 ]
 [ NewStyle_RMA
        &       &FE000000                       ; cause abort
 |
        &       RMAAddress                      ; RMA
 ]
        &       ScreenEndAdr                    ; Screen
 [ NewStyle_SpriteArea
        &       &FE000000                       ; cause abort
 |
        &       SpriteSpaceAddress              ; sprites
 ]
 [ NewStyle_FontArea
        &       &FE000000                       ; cause abort
 |
        &       FontCacheAddress                ; fonts
 ]
 [ NewStyle_RAMDisc
        &       &FE000000                       ; cause abort
 |
        &       RAMDiscAddress                  ; RAMFS
 ]
 [ UseFreePool
        &       FreePoolAddress                 ; Free pool
 ]

; ExtendScreen - move memory into screen area
;
; in:   r0 -> logical address of end of first source area (either free pool or aplspace)
;       r5 = amount of memory being moved from first source area
;       r6 = page size
;       r9 = MEMC CR
;       r10 = total amount of memory being moved
;       r11 = number of source area
;       r12 = number of dest area


ExtendScreen

; screenpos -:= r10 (move all current blocks down)

        Push    "r5,r11"                ; save partial amount and src area number
        MOV     r2, #0
        VDWS    r5
        LDR     r5, [r5, #TotalScreenSize]
        RSB     r3, r5, #ScreenEndAdr
        SUB     r3, r3, r10             ; where new screen start is
50
        MOV     r11, #AP_Screen         ; access privileges for screen (includes CB bits in new world)
        BL      Call_CAM_Mapping
        ADD     r2, r2, #1
        ADD     r3, r3, r6
        SUBS    r5, r5, r6
        BNE     %BT50
        Pull    "r5,r11"

        ADD     r5, r3, r5              ; logaddr of end of first part (if split) or both otherwise

; r0 -> end of the source (AplSpace or FreePool)
        Push    "r7, r8, r10-r12"
55
        Push    "r2, r3, r5, pc"        ; save flags, etc. too
        ADRL    r3, PageShifts-1
        LDRB    r3, [r3, r6, LSR #12]
        MOV     r3, r2, LSL r3          ; r3 = pagesize*r2
        ADD     r3, r3, #ScreenEndAdr   ; physram addr of next screen block

        SUB     r0, r0, r6              ; address of last src block

        MOV     r1, #Service_ClaimFIQ   ; we may be moving FIQ workspace
        BL      Issue_Service
        ADD     r1, r0, r6              ; end marker

        TEQP    pc, #SVC_mode+I_bit     ; disable IRQs as we may be moving
        NOP                             ; IRQ workspace

; copy R6 bytes from nextscreenblock to last src block; the last
; src block MUST NOT be doubly mapped.

60
        LDMIA   r3!, {r2, r4, r5, r7, r8, r10, r11, r12}
        STMIA   r0!, {r2, r4, r5, r7, r8, r10, r11, r12}
        CMP     r0, r1
        BLT     %BT60

        LDR     r2, [stack]
        SUB     r0, r0, r6
        MOV     r3, #0
        LDR     r3, [r3, #CamEntriesPointer]    ; get address of soft CAM copy
 [ ExpandedCamMap
        ADD     r3, r3, r2, LSL #3              ; point at (address, PPL) for this page
        LDMIA   r3, {r3, r11}                   ; and load them
 |
        LDR     r3, [r3, r2, LSL #2]            ; curr addr of next screen block
        MOV     r11, r3, LSR #28                ; protection level
        BIC     r3, r3, #&F0000000
 ]

 [ UseFreePool
        BL      MoveCAMatR0toR3issuingPagesSafe
 |
        BL      MoveCAMatR0toR3                 ; last aplblock := nextscreenblock
 ]

        Pull    "r2, r3, r5, r7"                ; r7 has IRQ state to restore
        BVS     cambust2
                                                ; entry no in r2, logaddr in r3
        MOV     r11, #AP_Screen
        BL      Call_CAM_Mapping                ; nextscreenblock moves into place

        TEQP    pc, r7                          ; restore IRQ state
        NOP

        MOV     r1, #Service_ReleaseFIQ
        BL      Issue_Service
        ADD     r3, r3, r6
        ADD     r2, r2, #1

        CMP     r3, r5                          ; have we got to end of this part
        BNE     %BT55                           ; [no, so loop]

        CMP     r3, #ScreenEndAdr
        BEQ     %FT65

        MOV     r3, #ChangeDyn_AplSpace
        BL      GetBlockEnd                     ; get end of aplspace
        MOV     r0, r3                          ; r0 -> end of aplspace
        MOV     r3, r5                          ; continue dest where we left off
        MOV     r5, #ScreenEndAdr               ; finish only at end this time
        B       %BT55

65
        Pull    "r7, r8, r10-r12"
        B       %BT40

cambust2
        Pull    "r7, r8, r10-r12"
cambust
        STR     r0, [stack]
        Pull    "r0, r2-r6, r9, r10, lr"
        B      SLVK_SetV

 ]

; *** End of old style code ***
a120 1
 [ NewStyle_All
a123 1
 ]
a132 3
 [ (:LNOT: NewStyle_SysHeap) :LOR: (:LNOT: NewStyle_RMA)
        BL      testrestoreheapend
 ]
a243 1
 [ MEMM_Type = "ARM600"
a312 21
 |

MoveCAMatR0toR3 ROUT
        MOV     r2, #0
        LDR     r4, [r2, #CamEntriesPointer]
        LDR     r2, [r2, #MaxCamEntry]
10
 [ ExpandedCamMap
        LDR     r5, [r4, r2, LSL #3]
 |
        LDR     r5, [r4, r2, LSL #2]
        BIC     r5, r5, #&F0000000
 ]
        CMP     r5, r0
        BEQ     Call_CAM_Mapping
        SUBS    r2, r2, #1
        BGE     %BT10

        ADR     r0, CamMapBroke
        ORRS    pc, lr, #V_bit
 ]
a322 149
 [ UseFreePool :LAND: :LNOT: NewStyle_All

; MoveCAMatR0toR3issuingPagesSafe
; in:   r0 = old logaddr
;       r2 = old physical page number
;       r3 = new logaddr
;       r9 = MEMC CR
;       r11 = page protection level
;
; out:  r0,r1,r3,r6-r12 preserved
;       r2,r4,r5 corrupted
;
; Note: this still needs some serious work done to it to cope with doubly-mapped areas

MoveCAMatR0toR3issuingPagesSafe ENTRY "r0,r1,r3,r6,r7,r12", 6*4
        STR     r2, [sp, #0*4]                  ; store old page number at offset 0 in frame
        LDR     r5, =L2PT
        ADD     r4, r5, r0, LSR #10             ; r4 -> L2PT for log addr r0
        MOV     r2, r4, LSR #12
        LDR     r2, [r5, r2, LSL #2]            ; r2 = L2PT entry for r4
        TST     r2, #3                          ; if no page there
        BEQ     %FT90                           ; then cam corrupt

        LDR     r4, [r4]                        ; r4 = L2PT entry for r0
        TST     r4, #3                          ; check entry OK too
        BEQ     %FT91
        MOV     r12, r4, LSR #12                ; r12 = phys addr >> 12

        MOV     r2, #0
        LDR     r6, [r2, #MaxCamEntry]
        MOV     r5, #PhysRamTable
10
        CMP     r2, r6                          ; if page we've got to is >= max
        BHI     %FT92                           ; then corrupt
        LDMIA   r5!, {r7, lr}                   ; get phys.addr, size
        SUB     r7, r12, r7, LSR #12             ; number of pages into this bank
        CMP     r7, lr, LSR #12                 ; if too many
        ADDCS   r2, r2, lr, LSR #12             ; then advance physical page no.
        BCS     %BT10                           ; and loop

        ADD     r2, r2, r7                      ; add on number of pages within bank
        STR     r2, [sp, #3*4]                  ; store new page number at offset 3 in frame
        BL      BangCamUpdate
        EXIT    VS

; now check if page being snaffled is a L2 page, and if so, change L1 contents to point to new page

        SUBS    lr, r3, #L2PT                   ; check if destination page points in L2PT area
        BCC     %FT20                           ; below L2PT, so OK
        CMP     lr, #4*1024*1024                ; is offset into L2PT less than size of L2PT?
        BCS     %FT20                           ; no, so OK

        LDR     r1, =L1PT
        ADD     r1, r1, lr, LSR #(12-4)         ; address in L1 of 4 consecutive words to update
        LDR     r2, [r1]                        ; load 1st word, to get AP etc bits
        MOV     r2, r2, LSL #(31-9)             ; junk other bits
        MOV     r2, r2, LSR #(31-9)
        ORR     r2, r2, r12, LSL #12            ; merge with address bits
        STR     r2, [r1], #4
        ADD     r2, r2, #&400
        STR     r2, [r1], #4
        ADD     r2, r2, #&400
        STR     r2, [r1], #4
        ADD     r2, r2, #&400
        STR     r2, [r1], #4
20
; now issue the service

        MOV     r1, #Service_PagesSafe
        MOV     r2, #1                          ; 1 page at a time
        MOV     r3, sp                          ; 1st frame starts at sp
        ADD     r4, r3, #3*4                    ; 2nd frame starts at sp +12
        BL      Issue_Service
        CLRV
        EXIT

90
        ADR     lr, NoL2ForPageBeingRemovedError
95
        STR     lr, [sp]                        ; update returned r0
        BL      StoreDebugRegs
        PullEnv                                 ; seriously broken memory
        SETV
        MOV     pc, lr

91
        ADR     lr, PageBeingRemovedNotPresentError
        B       %BT95

92
        ADR     lr, PhysicalAddressNotFoundError
        B       %BT95

 ]

 [ :LNOT: NewStyle_RAMDisc
;........................................
; Old style RAMFS bashing

CheckRAMFSChangeOK
      Push   "r0-r5"
      MOV     r0, #5
      ADR     r1, ramcolondollardotstar
      SWI     XOS_File
      CMPVC   r0, #0
      Pull   "r0-r5"
      BVS     AllowRAMFSChange             ; ramfs not present
      BEQ     AllowRAMFSChange             ; ramfs empty
      ADR     r0, ErrorBlock_RAMFsUnchangeable
      B       ChangeDynamic_Error
      MakeErrorBlock RAMFsUnchangeable

ramcolondollardotstar = "ram:$.*",0
ramfsname = "ramfs",0

      ALIGN

reinitialise_RAMFS
      Push   "r0-r6"
      MOV     r0, #ModHandReason_EnumerateROM_Modules
      MOV     r1, #0
      MOV     r2, #-1
look_for_RAMFS
      SWI     XOS_Module
      BVS     OKtoreinitRAMFS        ; can't find it: may be in ram
      ADR     r5, ramfsname
nameloop
      LDRB    r6, [r3], #1
      CMP     r6, #" "
      BLE     foundramfs
      LowerCase r6, lr
      LDRB    lr, [r5], #1
      CMP     lr, r6
      BEQ     nameloop
      B       look_for_RAMFS

foundramfs
      CMP     r4, #-1
      BNE     OKtoreinitRAMFS
      Pull   "r0-r6"
      B       CDS_PostService

OKtoreinitRAMFS
      MOV     r0, #ModHandReason_ReInit
      ADR     r1, ramfsname
      SWI     XOS_Module
      Pull   "r0-r6"
      B       CDS_PostService
 ]
a347 1
 [ NewCDA
a375 6
 ]
 [ :LNOT: NewStyle_All
        BIC     r10, r0, #readdyn_returnR2bit
        CMP     r10, #ChangeDyn_MaxArea
        BLS     %FT07
 ]
a383 27
 [ :LNOT: NewStyle_All
07
        TST     r0, #readdyn_returnR2bit        ; if bit 7 set, R2 = max size of area
  [ MEMC_Type = "IOMD"
        BEQ     %FT10
        EORS    r11, r10, #ChangeDyn_Screen     ; if screen
        LDREQ   r2, [r11, #VideoSize]           ; then use video size
        ADRNEL  r11, Grow_LimitsPtrs+4
        LDRNE   r2, [r11, r10, LSL #2]          ; else use grow limits
        LDRNE   r2, [r2]                        ; (grow limits are pointers to max sizes now)
10
  |
        ADRNEL  r11, Grow_LimitsPtrs+4
        LDRNE   r2, [r11, r10, LSL #2]
        LDRNE   r2, [r2]                        ; (grow limits are pointers to max sizes now)
  ]

        CMP     r10, #ChangeDyn_Screen    ; screen?
        ADRL    r0, Current_Size+4
        ADRL    r11, StartAddrs+4
        LDR     r1, [r0, r10, LSL #2]
        LDR     r1, [r1]                  ; r1 = current size of area
        LDR     r0, [r11, r10, LSL #2]    ; r0 = start address of area
        SUBEQ   r0, r0, r1                ; screen goes wackbords
        B       SLVK
 ]

a418 1
 [ ExpandedCamMap
a420 5
 |
        LDR     r11, [r10, r12, LSL #2]
        MOV     r12, r11, LSR #28               ; PPL
        BIC     r11, r11, #&F0000000
 ]
a440 1
 [ ExpandedCamMap
a514 81
 |

; Code for non-expanded CAM map version

        Push    "r0, r9, r14"
        MOV     r14, #0
        LDR     r9, [r14, #MaxCamEntry]
        LDR     r14, [r14, #CamEntriesPointer]  ; r14 -> start of cam map
        ADD     r9, r14, r9, LSL #2             ; r9 -> last entry in cam map
10
        LDR     r10, [r0, #0]                   ; r10 = guess page number (or -1)
        CMP     r10, #-1                        ; if -1 then end of list
        Pull    "r0, r9, r14", EQ               ; so restore registers
        ExitSWIHandler EQ                       ; and exit

        LDR     r11, [r0, #4]                   ; r11 = logical address
        MOV     r11, r11, LSL #4                ; shift up so we can compare with
                                                ; shifted up addresses
        ADD     r10, r14, r10, LSL #2           ; form address with 'guess' page
        CMP     r10, r9                         ; if off end of CAM
        BHI     %FT15                           ; then don't try to use the guess

        LDR     r12, [r10]                      ; load address+ppl from guessed page
        TEQ     r11, r12, LSL #4                ; compare address
        BEQ     %FT30                           ; if equal, then guessed page was OK
15
 [ MEMM_Type = "ARM600"

; for now, cheat by looking in L2PT, to see if we can speed things up

        Push    "r5-r8"                         ; need some registers here!
        LDR     r10, =L2PT
        CMP     r11, #256*1024*1024*4           ; if address >= 256M
        BCS     %FT17                           ; then invalid, so search from last one

        MOV     r8, r11, LSR #16                ; r8 = logaddr / 4K
        LDR     r8, [r10, r8, LSL #2]           ; get page table entry
        MOV     r8, r8, LSR #12                 ; r8 = physaddr / 4K

        MOV     r5, #VideoPhysAddr
        SUB     r10, r14, #4
16
        CMP     r10, r9                         ; have we run out of RAM banks?
        BCS     %FT17                           ; then fail
        LDMIA   r5!, {r6,r7}                    ; load next address, size
        SUB     r6, r8, r6, LSR #12             ; number of pages into this bank
        CMP     r6, r7, LSR #12                 ; if more than there are
        ADDCS   r10, r10, r7, LSR #12-2         ; then advance CAM entry position (bank size must be multiple of 4K)
        BCS     %BT16                           ; and loop to next bank

        ADD     r10, r10, r6, LSL #2            ; advance by 1 word for each page in this bank
17
        SUBCS   r10, r9, #4                     ; search from last one, to fail quickly (if CS)
        Pull    "r5-r8"
 |
        SUB     r10, r14, #4                    ; move pointer to start of CAM -4
 ]

20
        CMP     r10, r9                         ; if not just done last one, get
        LDRNE   r12, [r10, #4]!                 ; address in bits 0..27, PPL in 28..31
        TEQNE   r11, r12, LSL #4                ; compare address
        BNE     %BT20                           ; loop if not same and not at end

; either found page or run out of pages

        TEQ     r11, r12, LSL #4                ; see if last one matched
                                                ; (we always load at least one!)
30
        SUBEQ   r10, r10, r14                   ; if match, then
        MOVEQ   r10, r10, LSR #2                ; page number=(r10-r14)>>2
        MOVEQ   r12, r12, LSR #28               ; and PPL=r12>>28

        MOVNE   r10, #-1                        ; else unknown page number indicator
        MOVNE   r12, #3                         ; and PPL=3 (no user access)

        MOV     r11, r11, LSR #4                ; restore r11 to original value

        STMIA   r0!, {r10-r12}                  ; store all 3 words
        B       %BT10                           ; and go back for another one
 ]
a538 1
 [ MEMM_Type = "ARM600"
a539 3
 |
        CMP     r3, #32*1024*1024
 ]
a549 3
 [ :LNOT: NewCDA
InitDynamicAreas        MOV     pc, lr          ; if not new world then nothing to initialise
 ]
a550 1
 [ NewCDA
a1179 6
 [ :LNOT: NewStyle_RMA
        &       RMAAddress,             RMAMaxSize      ; RMA (to be removed from here eventually)
 ]
 [ :LNOT: NewStyle_SysHeap
        &       SysHeapChunkAddress,    SysHeapMaxSize+SVCStackSize   ; system heap (to be removed eventually)
 ]
d1188 3
a1190 2
 [ :LNOT: NewStyle_Screen
        &       ScreenEndAdr-16*1024*1024, 32*1024*1024         ; Screen (removable later)
d1192 2
a1193 8
 [ :LNOT: NewStyle_FontArea
        &       FontCacheAddress,      FontCacheMaxSize ; Font cache (removable later)
 ]
 [ :LNOT: NewStyle_SpriteArea
        &       SpriteSpaceAddress,  SpriteSpaceMaxSize ; Sprite area (removable later)
 ]
 [ :LNOT: NewStyle_RAMDisc
        &       RAMDiscAddress,         RAMDiscMaxSize  ; RAM disc (removable later)
a1194 2
        &       PhysSpace,              512*1024*1024   ; PhysSpace
        &       &FF800000,              &007FFFFF       ; Shadow ROM (length has been bodged to avoid wrap problems)
d1518 3
a1520 3
        MOV     r4,pc
        ORR     r1,r4,#I_bit
        TEQP    r1,#0             ;protect critical manipulation from interrupt re-entry
d1533 1
a1533 1
        TEQP    r4,#0             ;restore IRQ state
d1540 1
a1540 1
        TEQP    r4,#0             ;restore IRQ state
d1553 3
a1555 3
        MOV     r4,pc
        ORR     r3,r4,#I_bit
        TEQP    r3,#0             ;protect critical manipulation from interrupt re-entry
d1580 1
a1580 1
        TEQP    r4,#0             ;restore IRQ state
d1587 1
a1587 1
        TEQP    r4,#0             ;restore IRQ state
a1626 1
 [ GetPagesFromFreePool
d1673 1
a1673 2
 ]
 [ NewStyle_SysHeap
a1677 1
 ]
a1728 1
 [ NewStyle_All
a1729 1
 ]
a1775 1
 ]
a1776 2
 [ NewCDA2
  [ NewStyle_All
a1780 1
  ]
a1798 1
 [ NewStyle_All
a1803 3
 |
        BNE     failure_IRQgoing
 ]
a1815 1
 [ NewStyle_All
a1816 3
 |
        BCC     IsOldArea                       ; if not, then use old code
 ]
a2203 1
 [ NewStyle_All
a2205 1
 ]
d2227 1
a2227 1
        EXITS   NE                              ; if src <> free pool, exit with flags intact
d2281 1
a2281 1
SavedPSR        #       4                       ; PC+PSR before IRQs disabled
d2607 2
a2608 1
        STR     pc, SavedPSR                    ; save old PSR (note: stack must be flat when we do this!)
d2614 1
a2614 2
        TEQP    pc, #SVC_mode + I_bit           ; disable IRQs round here
        NOP
d2673 1
a2673 1
        TEQP    lr, #0
a2852 1
 ]
a2854 1
 [ NewCDA2
d3091 1
a3091 2
        MOV     lr, pc                  ; save old IRQ status
        TEQP    pc, #SVC_mode + I_bit   ; disable IRQs round this bit
d3101 1
a3101 1
        TEQP    lr, #0                  ; restore IRQ status
a3108 1
 ]
a3109 1
 [ NewCDA
a3117 1
 ]
a3118 1
 [ NewStyle_SpriteArea
a3178 1
 ]
a3179 1
 [ NewStyle_RAMDisc
a3266 1
 ]
a3267 1
 [ NewStyle_FontArea
a3314 1
 ]
a3354 1
        [ NewStyle_Screen
d3441 1
a3441 2
        MOV     r5, pc
        TEQP    pc, #SVC_mode+I_bit             ; disable IRQs
d3446 1
a3446 1
        TEQP    r5, #0                          ; restore IRQ state
d3478 1
a3478 2
        MOV     R5, PC
        TEQP    PC, #SVC_mode+I_bit             ;disable interrupts
d3481 1
a3481 1
        TEQP    PC, R5                          ;restore interrupts
a3500 1
 ]
@


4.6
log
@Ursula ChocolateSysHeap and 128-entry SWI hash table incorporated.

Version 4.83. Tagged as 'Kernel-4_83'
@
text
@d2879 13
@


4.5
log
@Up to 16M of ROM now mapped in from 03800000-04800000.
Video memory now limited to 8M (instead of 16M) to make room.
OS_Memory 7 now reports ROM correctly when the image is >4M.

Version 4.76. Tagged as 'Kernel-4_76'
@
text
@d2602 163
d2843 35
@


4.4
log
@added separate flag, ShrinkableDAs
@
text
@d2336 3
d2340 1
@


4.4.4.1
log
@Added following enhancements:

 - Chocolate screen mapping (section mapped and cached), StrongARM only
   Phoebe h/w (IOMD 2) will have register to assist this, but code currently
   relies on data abort mechanism to keep screen up to date wrt write-back
   data cache.

 - Chocolate AMBControl task switching (lazy page mapping), StrongARM only
   Improves task swapping speed. There appears to be a StrongAEM silicon
   bug rev 2 and 3) which means that LDMIB rn, {regs includind rn} cannot
   be reliably restarted after a data abort. This stuffs Chocolate AMBControl
   (awaiting response from Digital).

Both enhancements need more work to complete for Phoebe. Chocolate AMBControl
may well have to be made dormant because of silicon bug.

Note that this kernel *will* cause problems with task switching on StrongARM,
unless Chocolate task switching is disabled via !Flavour application.
@
text
@a2785 9
  [ ChocolateScreen
        MOV     r12,#ARMA_Cleaner_status
        LDR     r12,[r12]
        TST     r12,#ACS_SCdisable
        CMPEQ   r0, #ChangeDyn_Screen
        MOVEQ   r12, #&100000
        SUBEQ   r12, r12, #1                    ; r12 = section mask (1Mb) if screen, and SC enabled
        SUBNE   r12, r5, #1                     ; else r12 = page mask
  |
a2786 1
  ]
a2838 9
  [ ChocolateScreen
        MOV     lr, #ARMA_Cleaner_status
        LDR     lr, [lr]
        TST     lr, #ACS_SCdisable
        CMPEQ   r0, #ChangeDyn_Screen
        MOVEQ   lr, #&100000
        SUBEQ   lr, lr, #1
        SUBNE   lr, r5, #1
  |
a2839 1
  ]
a2985 9
  [ ChocolateScreen
        MOV     lr, #ARMA_Cleaner_status
        LDR     lr, [lr]
        TST     lr, #ACS_SCdisable
        CMPEQ   r0, #ChangeDyn_Screen
        MOVEQ   lr, #&100000
        SUBEQ   lr, lr, #1
        SUBNE   lr, r5, #1
  |
a2986 1
  ]
a3055 6
  [ ChocolateScreen
        LDR     lr, [r12,#DANode_Number]
        CMP     lr,#ChangeDyn_Screen
        BLEQ    Screen_makevanilla
  ]

a3113 4
  [ ChocolateScreen
        CMP     r0, #ChangeDyn_Screen
        BLEQ    Screen_makechocolate            ; do nefarious stuff once new size fully established
  ]
a3793 3
    [  ChocolateAMB
        BLEQ    Do_AMB_MakeSparse
    ]
a3814 3
    [  ChocolateAMB
        BL      Do_AMB_MakeSparse
    ]
a3816 10
    [ ChocolateAMB
Do_AMB_MakeSparse ROUT
        Push    "r0,lr"
        MOVS    r0,r10
        RSBMI   r0,r0,#0
        BL      AMB_MakeUnsparse  ;shrinking AppSpace, so make sure unsparse over area of shrink
        Pull    "r0,pc",,^
    ] ;ChocolateAMB


a4444 8
  [ ChocolateScreen
        MOV     R2, #ARMA_Cleaner_status
        LDR     R2, [R2]
        TST     R2, #ACS_SCdisable              ;section granularity if SC not disabled
        MOVEQ   R2, #&100000
        SUBEQ   R2, R2, #1                      ;make a section (1Mb) mask
        SUBNE   R2, R5, #1                      ;make a page mask
  |
a4445 1
  ]
a4454 3
  [ ChocolateScreen
        BL      Screen_makevanilla
  ]
a4474 3
  [ ChocolateScreen
        BL Screen_makechocolate
  ]
a4478 97

   [ ChocolateScreen

      LTORG
      ALIGN

;action: make lower screen mapping (the one normally used) crazy chocolate flavour by
;        being section mapped, domain 1 and cacheable, then mark domain 1 to fault
;        and resume screen cleaning
;
Screen_makechocolate ROUT
        Push    "r0-r8,LR"
        MOV     r1,#0
        LDR     r0,[r1,#ARMA_Cleaner_status]
        TST     r0,#ACS_SCdisable
        BNE     %FT99                        ;chocolate flavour is off the menu if SC disabled
        MOV     r0,#2
        MOV     r1,#ChangeDyn_Screen
        SWI     XOS_DynamicArea
        BVS     %FT99
        SUB     r0,r3,r2                     ;base of lower of the two mappings
        MOVS    r1,r2                        ;size
        BEQ     %FT99
        MOV     r2,#L2PT
        ADD     r2,r2,r0,LSR #10             ;r2 -> 1st L2PT entry for screen
        LDR     r3,[r2]
        MOV     r3,r3,LSR #20
        MOV     r3,r3,LSL #20                ;r3 := physical address of base of screen (will be 1Mb aligned)
        ORR     r3,r3,#&C00                  ;access permissions (r/w,r/w)
        ORR     r3,r3,#&03E                  ;domain 1, cacheable, bufferable, section
        LDR     r2,=L1PT
        ADD     r2,r2,r0,LSR #18             ;r2 -> 1st L1PT entry for screen
01
        STR     r3,[r2],#4
        ADD     r3,r3,#&100000
        SUBS    r1,r1,#&100000
        BGT     %BT01
        ARMA_read_MMUdomain r0
        BIC     r0,r0,#&C
        ARMA_write_MMUdomain r0              ;mark domain 1 to fault
        MOV     r0,#&c0000001
        SWI     XOS_MMUControl               ;flush caches and TLBs (caches,ITLB flush redundant, but there you go)
        MOV     r0,#0
        LDR     r1,[r0,#ARMA_Cleaner_status]
        BIC     r1,r1,#ACS_SCsuspend
        ORR     r1,r1,#ACS_Scacheflag
        STR     r1,[r0,#ARMA_Cleaner_status]
99
        Pull    "r0-r8,PC"

;action: make lower screen mapping vanilla flavour by suspending screen cleaning, then setting page mapped,
;        uncacheable and domain 0
;
Screen_makevanilla ROUT
        Push    "r0-r8,LR"
        MOV     r0,pc
        ORR     r1,r0,#I_bit
        TEQP    r1,#0                        ;disable IRQs
        MOV     r1,#0
        LDR     r2,[r1,#ARMA_Cleaner_status]
        ORR     r2,r2,#ACS_SCsuspend
        BIC     r2,r2,#ACS_VSCcountdown_MASK
        BIC     r2,r2,#ACS_Scacheflag
        STR     r2,[r1,#ARMA_Cleaner_status]
        TEQP    r0,#0                        ;restore IRQs
        TST     r2,#&80000000
        BNE     %FT99                        ;assume already vanilla if SC disabled
        MOV     r0,#2
        MOV     r1,#ChangeDyn_Screen
        SWI     XOS_DynamicArea
        BVS     %FT99
        SUB     r0,r3,r2                     ;base of lower of the two mappings
        MOVS    r1,r2                        ;size
        BEQ     %FT99
        MOV     r3,#L2PT
        ADD     r4,r3,r0,LSR #10             ;L2PT of base (L2PT stuff will still be set up, though unused)
        ADD     r5,r3,r4,LSR #10
        AND     r4,r5,#3                     ;remember 1k offset into L2PT page itself, for later
        BIC     r5,r5,#&3                    ;L2PT of L2PT of base
        LDR     r6,[r5]
        MOV     r6,r6,LSR #12
        MOV     r6,r6,LSL #12                ;physical address of L2PT of base, except for offset
        ORR     r6,r6,r4,LSL #10             ;and now including offset
        ORR     r6,r6,#&11                   ;for vanilla L1PT entry - is domain 0, page
        LDR     r7,=L1PT
        ADD     r7,r7,r0,LSR #18             ;r7 -> 1st L1PT entry for screen
01
        STR     r6,[r7],#4
        ADD     r6,r6,#&400                  ;next L2PT physical address (1k per 1Mb of mapping)
        SUBS    r1,r1,#&100000
        BGT     %BT01
        MOV     r0,#&c0000001
        SWI     XOS_MMUControl               ;flush caches and TLBs (Icache,ITLB flush redundant, but there you go)
99
        Pull    "r0-r8,PC"

   ] ;ChocolateScreen
@


4.4.4.2
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d32 12
d47 2
d50 6
d60 1
d62 1
d65 1
a65 1

d69 16
d95 1
d97 3
d117 765
d883 74
a956 1
        InsertDebugRoutines
d958 1
d962 1
d966 1
d976 4
d983 1
d1004 1
d1010 3
d1017 2
d1077 3
d1090 1
d1160 21
d1191 150
d1365 1
d1394 6
d1401 1
d1405 1
d1408 26
d1470 1
d1473 5
d1498 1
d1573 81
d1678 1
a1678 1

d1680 3
d1693 3
d1697 1
d1731 1
d1733 1
d1786 1
d1790 1
d2062 1
d2064 1
d2172 1
d2174 1
d2291 1
d2293 1
d2327 6
d2337 12
d2403 1
d2405 1
d2590 1
d2592 1
d2620 1
d2667 2
d2673 1
d2677 1
d2679 1
d2726 1
d2728 2
d2734 1
d2753 1
d2759 3
d2774 1
d2776 3
d2924 4
a2927 1

d2932 1
d2934 1
d3097 1
d3126 1
d3163 1
d3165 1
d3206 1
d3209 1
d3288 1
d3290 1
d3417 1
d3419 1
d3467 1
a3467 5
    ;StrongARM - see comments below for ARM810support, and in different scheme for StrongARM
    ;            copy, further down. RISC OS 3.7 had a grotty fix here that has a hole
    ;            for pages involved in interrupts (only showed up occasionally with PC card s/w)

  [ ARM810support
d3471 4
a3474 2
    ;      ARM810's write-back cache. Here, we do a clean flush, which fixes the problem for any pages
    ;      that will not be updated by interrupts.
a3475 1
    ;      *** IT DOES NOT FIX THE PROBLEM FOR PAGES AFFECTED BY INTERRUPTS ***
d3477 8
a3484 2
    ;      There is a proper fix for StrongARM (similar problem) below. ARM810 support could do
    ;      similar, but effort of writing and testing not warranted at this time
a3485 2
 ! 0,"mjs: ARM810support WARNING! Pages_Unsafe/Pages_Safe copying code does NOT cope with"
 ! 0,"     pages that may be updated by interrupt code. Bug may cause problems in 'rare' cases."
d3617 1
a3617 2
        TEQP    pc, #SVC_mode + I_bit           ; disable IRQs round here (we don't want interrupt code to update
                                                ; the old mapping behind us while we're trying to copy it)
a3625 85
  [ StrongARM

    ;we use a different scheme on StrongARM, because:
    ;  (1) we need to ensure cache coherency of a *writeback* data cache, so cannot use a second mapping of page in
    ;      old scheme without doing cache cleaning (physical copy of page is used)
    ;  (2) speed of copy from/to uncacheable space is diabolical on StrongARM (remember, IRQs are off!)
    ;so the scheme is:
    ;   -  if  the old page is currently not mapped, or is mapped uncacheable, create a temporary cacheable mapping
    ;      (at address of Nowhere, used merely as convenient temporary place) - this ensures that we have a valid mapping
    ;      without using (uncacheable) physical copy, and that our LDMs will be fast, whatever the cacheable status of the
    ;      original mapping - there is no cache coherency issue, because the temporary mapping is only created if that
    ;      original mapping is non-existent or uncacheable
    ;   -  create a temporary cacheable,bufferable mapping of the replacement page (at address of Nowhere+PageSize, used
    ;      merely as convenient temporary place) - this ensures that our STMs are fast, whatever the status of the original
    ;      mapping (SA110 needs cacheable as well as bufferable for burst STMs) - there is no cache coherency issue because
    ;      this address will not have been read, nor be read during this scheme
    ;   -  do the copy, a cache line at a time, flushing the cache behind us for the src - there is no need to clean,
    ;      because either the mapping is never written (temp mapping), or the mapping is to be discarded and it is only
    ;      necessary for the up-to-date data to reach the replacement page
    ;   -  remove the temporary mapping(s), and flush the DTLB entries
    ;
        ARM_read_ID r2
        AND     r2, r2, #&F000
        CMP     r2, #&A000
        BNE     cda_pagecopy_notSA
        LDR     r4, [r8, #4]            ;logical address of src page
        MOV     r3, #L2PT
        ADD     r3, r3, r4, LSR #(12-2) ;L2PT addr for logical page (assumes 4k page size)
        LDR     r7, [r3]                ;L2PT entry, will be 0 if page not mapped, else bit 3 will be cacheable bit
        TST     r7, #8                  ;will be NE if we do have a valid, cacheable mapping
        BNE     cda_pagecopy_mapdest

;make a temporary cacheable,bufferable mapping of src at Nowhere
        MOV     r3, #L2PT
        LDR     r4, =DuffEntry          ;address of Nowhere
        ADD     r3, r3, r4, LSR #(12-2) ;L2PT addr
        LDR     r7, [r8, #8]            ;physical address of src page
        ORR     r7, r7, #&550
        ORR     r7, r7, #&00E           ;&55E = L2PT bits for svc access, C=1, B=1
        STR     r7, [r3]                ;update L2PT

;make a temporary cacheable,bufferable mapping of dest (replacement page) at Nowhere+PageSize
cda_pagecopy_mapdest
        MOV     r3, #L2PT
        LDR     r7, =DuffEntry
        ADD     r7, r7, r5              ;address of Nowhere+PageSize
        ADD     r3, r3, r7, LSR #(12-2) ;L2PT address for logical page at Nowhere+PageSize
        LDR     r10, [r0, lr, LSL #3]   ;log. address for replacement page
        MOV     r9, #L2PT
        ADD     r9, r9, r10, LSR #(12-2)
        LDR     r9, [r9]
        MOV     r9, r9, LSR #12
        MOV     r9, r9, LSL #12         ;physical address of replacement page (looked up from L2PT entry)
        ORR     r9, r9, #&550
        ORR     r9, r9, #&00E           ;&55E = L2PT bits for svc access, C=1, B=1
        STR     r9, [r3]                ;update L2PT

        MOV     r0, r7                  ;r0 := log. address for dest (temp mapping at Nowhere+PageSize)
        MOV     r6, r4                  ;r6 := log. address for src  (either addr of page, or of temp mapping at Nowhere)
        ADD     lr, r6, r5              ;lr := end src address
cda_pagecopy_copyloop
        LDMIA   r6,  {r2, r3, r4, r7, r9, r10, r11, r12}
        STMIA   r0!, {r2, r3, r4, r7, r9, r10, r11, r12}
        ARMA_flush_DCentry r6           ;flush behind us for reads (no need to clean)
        ADD     r6, r6, #32             ;next cache line
        TEQ     r6, lr
        BNE     cda_pagecopy_copyloop

        LDR     r6, =DuffEntry
        MOV     r4, #L2PT
        ADD     r4, r4, r6, LSR #(12-2) ;L2PT address for logical page at Nowhere (assumes page size 4k)
        MOV     r7, #0                  ;means translation fault in L2PT
        STR     r7, [r4]                ;update L2PT to remove 1st temporary mapping (if any)
        ARMA_flush_DTLBentry r6         ;must flush DTLB entry
        STR     r7, [r4,#4]             ;update L2PT to remove 2nd temporary mapping
        ADD     r6, r6, r5
        ARMA_flush_DTLBentry r6         ;must flush DTLB entry
        B       %FT73                   ;carry on with common scheme for all ARMs
cda_pagecopy_notSA

  ] ;StrongARM

;traditional scheme of copying via physical space copy of page - not adequate for StrongARM (nor
;ARM810 - see comments above under ARM810support

a3635 1
73
d3711 1
d3795 1
d3841 1
d3843 1
d3873 1
d3876 1
d3911 1
d3913 1
d3980 1
d3982 1
d4046 1
d4048 1
d4132 1
d4134 1
d4138 1
d4140 1
d4143 1
d4145 1
d4206 1
d4208 1
d4275 1
d4277 1
d4296 1
d4298 1
d4346 1
d4387 1
d4648 1
@


4.4.4.3
log
@1) Fixes and tidy ups:
   - mapping of Cur/Sys/Sound area done more elegantly, and soft CAM info
     is now consistent with it
   - cached screen cleaning on VSync performed *after* VSync events
   - comments at top of ARM600 modernised
   - Pages_Unsafe/Safe code fixed to work properly on StrongARM with
     pages that are involved in interrupts (there is no fix for ARM8,
     since that is unlikely to be needed - an ASSERT checks use of ARM8
   - OS_DynamicArea code souped up, to be much more efficient for large
     numbers of dynamic areas (see comments near top of ChangeDyn)
   - cached screen is now suspended on h/w scroll (avoids possible cache
     incoherency)
2) API changes:
   - new OS_Memory reason code (10) allows Wimp to inform kernel of
     Wimp_ClaimFreeMemory, and can control VRAM rescue (see below)
   - new OS_ReadSysInfo reason code (6) allows reading of kernel values
     (reserved for Acorn use, eg. for SoftLoad, ROMPatch)
   - new OS_DynamicArea reason codes (6 and 7) allow for more efficient
     monitoring of dynamic areas by TaskManager (reserved for Acorn use)
3) Changes for Phoebe:
   - kernel runs a VRAM rescue process, which ensures that any VRAM not
     used for the screen is reclaimed if necessary and sinks to the bottom
     of the Free Pool. This is important for Phoebe, where VRAM is slower
     than SDRAM, but does no harm on other platforms.
   - logical copy of physical RAM is removed from memory map. This frees
     up 256M of address space that will later be used for PCI on Phoebe,
     but should do no harm on other platforms (this space is marked
     private in PRMs, so 3rd parties should not use it).
@
text
@a35 1
AP_VRescue      *       2 :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_NeedsSpecificPages
d41 1
a41 2
AP_CursorChunk5 *       1 :OR: PageFlags_Unavailable                                  ;first 5 pages of 8 page chunk (SWI dispatch etc)
AP_CursorChunk3 *       1 :OR: DynAreaFlags_NotCacheable :OR: PageFlags_Unavailable   ;next  3 pages of 8 page chunk
a49 1
;system areas:
d57 1
a57 2
ChangeDyn_VRescue    * 7
ChangeDyn_MaxArea    * 7
a74 62
; mjs - performance enhancements for Ursula:
; Workspace for acceleration of operations on a DA, by reducing need to traverse DA list.
;
; - accelerates allocating non-quick DA numbers to O(n) instead of laughable O(n*n), where n is no. of DAs
; - accelerates enumeration to O(n) instead of laughable O(n*n)
; - allocation of a quick handle (DA number) is O(1)
; - access of a DA node from a quick handle is O(1)
; - access of a DA node from a non-quick handle is O(1), if it repeats the most recent non-quick handle access (else O(n))
;
; - creation of a DA still has some O(n) work (requires search for address space), but is now rather quicker
; - removal of a DA is still O(n) (requires traversal of list in order to get previous node)
; - other uses of a DA with a quick handle (eg. get info, change size) avoid any O(n) work
;
; - all system handles will be quick.
; - non-system handles will be quick, except for very large numbers of DAs, or silly modules like the Wimp who insist on
;   their own silly DA number (the latter can still benefit from LastTreacleHandle - see below)
;
; Limitations:
; - does not allow anyone to choose their own DA number that clashes with the quick handle set - should not
;   be a problem since choosing own number reserved for Acorn use
; - does not allow anyone to renumber a DA with a quick handle - again, reserved for system use
; - DA names will be truncated to a maximum of 31 characters (or as defined below)
;
                                  ;Note - OS_DynamicArea reason codes 6,7 disappear if DynArea_QuickHandles is FALSE
                                  GBLL DynArea_QuickHandles
DynArea_QuickHandles              SETL {TRUE}
;
                                  GBLL DynArea_NullNamePtrMeansHexString
DynArea_NullNamePtrMeansHexString SETL {TRUE} :LAND: DynArea_QuickHandles
;
  [ DynArea_QuickHandles
DynArea_MaxNameLength     * 31                      ;maximum length of DA name, excluding terminator (multiple of 4, -1)
DynArea_NumQHandles       * 1024                    ;maximum no. of non-system quick handles available simultaneously
;
                          ^  0,R11
DynArea_TreacleGuess      # 4                       ;guess for next non-quick handle to allocate, if needed, is TreacleGuess+1
DynArea_CreatingHandle    # 4                       ;handle proposed but not yet committed, during DynArea_Create, or -1 if none
DynArea_CreatingPtr       # 4                       ;ptr to proposed DANode during DynArea_Create (invalid if CreatingHandle = -1)
DynArea_LastTreacleHandle # 4                       ;last non-quick handle accessed by a client (usually the Wimp), or -1 if none
DynArea_LastTreaclePtr    # 4                       ;ptr to DANode for last non-quick handle accessed (invalid if LastTreacleHandle = -1)
DynArea_LastEnumHandle    # 4                       ;last handle enumerated, or -1 if none
DynArea_LastEnumPtr       # 4                       ;ptr to DANode for last handle enumerated (invalid if LastEnumHandle = -1)
DynArea_OD6Signature      # 4                       ;signature of changes to non-system DAs since last call to OS_DynamicArea 6
                                                    ;bit  0 = 1 if any DAs have been created
                                                    ;bit  1 = 1 if any DAs have been removed
                                                    ;bit  2 = 1 if any DAs have been resized (excluding grow or shrink at creation or removal)
                                                    ;bit  3 = 1 if any DAs have been renumbered
                                                    ;bits 4-30   reserved (0)
                                                    ;bit 31 = 1 if next resize is not to update signature (used during create, remove)
DynArea_OD6PrevSignature  # 4                       ;previous signature, used to distinguish single from multiple changes
DynArea_OD6Handle         # 4                       ;handle of last DA that affected signature
DynArea_SysQHandleArray   # 4*(ChangeDyn_MaxArea+1) ;for system areas 0..MaxArea, word = ptr to DANode, or 0 if not created yet
DynArea_FreeQHandles      # 4                       ;index of first free quick handle, starting at 1 (or 0 for none)
DynArea_QHandleArray      # 4*DynArea_NumQHandles   ;1 word per quick handle
                                                    ; - if free, word = index of next free quick handle (or 0 if none)
                                                    ; - if used, word = ptr to DANode (must be > DynArea_NumQHandles)
;
DynArea_ws_size           *  :INDEX:@@               ;must be multiple of 4
;
            ASSERT DynArea_QHandleArray = DynArea_FreeQHandles +4
  ]
;
a309 3
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; out: r10 -> node
  |
a310 1
  ]
d510 5
a514 5
DAReason_Create          *  0
DAReason_Remove          *  1
DAReason_GetInfo         *  2
DAReason_Enumerate       *  3
DAReason_Renumber        *  4
d516 4
a519 1
DAReason_ReturnFree      *  5   ;if ShrinkableDAs, else reason code invalid
a520 6
 [ DynArea_QuickHandles
DAReason_GetChangeInfo   *  6   ;if DynArea_Quickhandles, else reason code invalid
DAReason_EnumerateInfo   *  7   ;if DynArea_Quickhandles, else reason code invalid
 ]
DAReason_Limit           *  8   ;end of defined DA reasons

a577 9
 |
        B       DynArea_Unknown
 ]
 [ DynArea_QuickHandles
        B       DynArea_GetChangeInfo
        B       DynArea_EnumerateInfo
 |
        B       DynArea_Unknown
        B       DynArea_Unknown
d627 1
a627 13
  [ DynArea_QuickHandles
        CMP     r1, #DynArea_NewAreas
        BLO     %FT06
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BLO     %FT08           ; can't choose your own quick handle
  ]

06
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber ; see if area number is unique
  |
        BL      CheckAreaNumber  ; see if area number is unique
  ]
a629 1
08
a643 16
  [ DynArea_QuickHandles
10
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws ]
        LDR     r1, DynArea_FreeQHandles          ;get index of next available quick handle, if any free
        CMP     r1, #0
        ADDNE   r1, r1, #DynArea_NewAreas-1       ;compute quick handle from index
        BNE     %FT20
        LDR     r1, DynArea_TreacleGuess          ;last non-quick number allocated
12
        ADD     r1, r1, #1                        ; increment for next guess (collisions should be *very* rare)
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        MOVLO   r1, #DynArea_NewAreas+DynArea_NumQHandles
        BL      QCheckAreaNumber
        BCS     %BT12                             ; and try again
  |
a649 2
  ]

a688 6
  [ DynArea_QuickHandles
    ;we save work and reduce stress on system heap by claiming only one block, consisting of node followed by
    ;string space (always maximum length, but typically not overly wasteful compared to 2nd block overhead)
    ;
        MOV     r3, #DANode_NodeSize + DynArea_MaxNameLength + 1
  |
a689 1
  ]
d709 1
a709 1
; now make copy of string
d711 1
a711 36
  [ DynArea_QuickHandles

        ADD     r7, r2, #DANode_NodeSize
        STR     r7, [r2, #DANode_Title]
        Push    "r0"
        MOV     r0, #DynArea_MaxNameLength
        TEQ     r8, #0
    [ DynArea_NullNamePtrMeansHexString
        ASSERT  DynArea_MaxNameLength > 8
        BNE     %FT45
        Push    "r1, r2"
        MOV     r0, r1                          ;string is 8-digit hex of DA number
        MOV     r1, r7
        MOV     r2, #DynArea_MaxNameLength+1
        SWI     XOS_ConvertHex8
        Pull    "r1, r2"
        B       %FT55
    |
        BEQ     %FT50                           ;assume NULL ptr to mean no DA name
    ]
45
        LDRB    r6, [r8], #1
        STRB    r6, [r7], #1
        SUB     r0, r0, #1
        TEQ     r6, #0
        TEQNE   r0, #0
        BNE     %BT45
50
        MOV     r0, #0
        STRB    r0, [r7], #1
55
        Pull    "r0"

  |

        MOV     r7, r8                          ; first find out length of string
a731 2
 ] ;DynArea_QuickHandles

a749 12
  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ;so XOS_ChangeDynamicArea can pick up the node we are still creating
        STR     r1, DynArea_CreatingHandle
        STR     r2, DynArea_CreatingPtr
        ;so initial grow won't leave resize signature
        LDR     lr, DynArea_OD6Signature
        ORR     lr, lr, #&80000000             
        STR     lr, DynArea_OD6Signature
  ]

d752 1
a752 1
        Push    "r0, r1, r2"
d754 1
a754 1
        LDR     r1, [sp, #3*4]                  ; reload requested size off stack
d756 1
a756 35
        BVS     %FT90                           ; deal with error - r0,r1,r2 still stacked
        Pull    "r0, r1, r2"

  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        MOV     lr, #-1
        STR     lr, DynArea_CreatingHandle      ;invalidate this now
        CMP     r1, #ChangeDyn_MaxArea
        BHI     %FT72
        ADR     lr, DynArea_SysQHandleArray
        STR     r2, [lr, r1, LSL #2]            ;system handle - store ptr to node for quick reference
        B       %FT80
72
        LDR     lr, DynArea_OD6Signature
        STR     lr, DynArea_OD6PrevSignature
        ORR     lr, lr, #1
        STR     lr, DynArea_OD6Signature
        STR     r1, DynArea_OD6Handle
        CMP     r1, #DynArea_NewAreas
        BLO     %FT80
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BHS     %FT74
        SUB     r10, r1, #DynArea_NewAreas
        ADR     lr, DynArea_QHandleArray
        LDR     r6, [lr, r10, LSL #2]           ;pick up index of next free quick handle
        STR     r6, DynArea_FreeQHandles        ;store as index of first free quick handle
        STR     r2, [lr, r10, LSL #2]           ;store ptr to node for quick reference
        B       %FT80
74
        LDR     r10, DynArea_TreacleGuess
        ADD     r10, r10, #1
        STR     r10, DynArea_TreacleGuess       ;non-quick handle allocated, increment for next allocate
80
  ] ;DynArea_QuickHandles
d760 1
a760 2
        Push    "r0, r1, r2"
        MOV     r2, r1                          ; r2 = area number
d763 1
a763 1
        Pull    "r0, r1, r2"
d776 2
a777 2
  [ :LNOT: DynArea_QuickHandles
        LDR     r2, [r2, #DANode_Title]
d779 2
a780 2
  ]
        Pull    "r0, r1, r2"                    ; pull stacked registers, and drop thru to...
a781 1
  [ :LNOT: DynArea_QuickHandles
a788 1
  ]
d790 1
a790 1
        BL      FreeSysHeapNode                 ; free DA node itself
a791 6
  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        MOV     lr, #-1
        STR     lr, DynArea_CreatingHandle
  ]
a808 4
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT92                   ; must not allow a system area to be removed

;*MUST NOT USE QCheckAreaNumber* (need r11 = previous)
a811 11
  [ DynArea_QuickHandles
        Push    "r11"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ;so final shrink won't leave resize signature
        LDR     lr, DynArea_OD6Signature
        ORR     lr, lr, #&80000000             
        STR     lr, DynArea_OD6Signature
        Pull    "r11"
  ]

d819 6
a824 1
        BVS     %FT80                   ; handle shrink failure - r0-r2 still stacked
d826 5
a830 1
        Pull    "r0-r2"
a837 1
  [ :LNOT: DynArea_QuickHandles
a839 1
  ]
a842 35

  [ DynArea_QuickHandles
        Push    "r2, r3"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        MOV     r2,#-1
        STR     r2, DynArea_CreatingHandle                ; invalidate these, just in case
        STR     r2, DynArea_LastTreacleHandle
        STR     r2, DynArea_LastEnumHandle
        LDR     r2, DynArea_OD6Signature                  ; we know system areas cannot be removed
        STR     r2, DynArea_OD6PrevSignature
        ORR     r2, r2, #2
        STR     r2, DynArea_OD6Signature
        STR     r1, DynArea_OD6Handle
        CMP     r1, #DynArea_NewAreas
        BLO     %FT10 
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BHS     %FT10
        SUB     r2, r1, #DynArea_NewAreas-1               ; index of quick handle
        ADR     r10, DynArea_FreeQHandles                 ; so we can index array from 1
        LDR     r3, DynArea_FreeQHandles
        STR     r3, [r10, r2, LSL #2]
        STR     r2, DynArea_FreeQHandles                  ; put on front of free list
10
        Pull    "r2, r3"
  ]

; Issue service to tell TaskManager

        Push    "r0, r1, r2"
        MOV     r2, r1
        MOV     r1, #Service_DynamicAreaRemove
        BL      Issue_Service
        Pull    "r0, r1, r2"

a853 1
        Pull    "r0-r2"                 ; balance stack
a863 10
;if you think this is worth internationalising, I pity you
92
        ADR     r0, DynArea_BadRemove
        SETV
        EXIT
DynArea_BadRemove
        DCD     0
        DCB     "illegal DA remove",0
        ALIGN

a884 3
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
a885 1
  ]
a901 121
;       DynArea_GetChangeInfo
;
;       Get info on changes to *non-system* dynamic areas
;       Reserved for Acorn use (intended for TaskManager, can only serve one client)
;
;       Internal routine called by DynamicAreaSWI
;
; in:   r0 = reason code (6)
;
; out:  r1 = Number of affected area, if a single change has occurred since last call,
;          = -1, if no changes or more than one change have occurred
;       r2 = signature of changes to non-system dynamic areas since last call to
;            OS_DynamicArea 6
;            bit 0 = 1 if any non-system areas have been created
;            bit 1 = 1 if any non-system areas have been removed
;            bit 2 = 1 if any non-system areas have been resized
;            bit 3 = 1 if any non-system areas have been renumbered 
;            bits 4-31 reserved (undefined)
;
;Notes:
; (1) bit 2 of r2 excludes the initial grow of a created area, and the final
;     shrink of a removed area
; (2) if a single renumber has occurred, r1 is the old number

  [ DynArea_QuickHandles

DynArea_GetChangeInfo ROUT
        Push    "lr"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        LDR     r1, DynArea_OD6Handle
        LDR     r2, DynArea_OD6Signature
        LDR     lr, DynArea_OD6PrevSignature
        CMP     lr, #0
        MOVNE   r1, #-1
        CMP     r2, #0
        MOVEQ   r1, #-1
        MOV     lr, #0
        STR     lr, DynArea_OD6Signature
        STR     lr, DynArea_OD6PrevSignature
        CLRV
        Pull    "PC"

  ] ;DynArea_QuickHandles

;**************************************************************************
;
;       DynArea_EnumerateInfo
;
;       Enumerate *non-system* dynamic areas, returning selected info
;       Reserved for Acorn use (intended for TaskManager)
;
; in:   r0 = reason code (7)
;       r1 = -1 to start enumeration, or area number to continue from
;
; out:  r1 = number of next area found, or -1 if no more areas
;       r2 = current size of area, if area found
;       r3 = base logical address, if area found
;       r4 = area flags, if area found
;       r5 = maximum size of area, if area found
;       r6 -> title string, if area found
;
;Notes:
; (1) r2-r6 on exit are undefined if r1 = -1
;

  [ DynArea_QuickHandles

DynArea_EnumerateInfo ROUT
        Push    "lr"
        CMP     r1, #-1                         ; if starting from beginning
        LDREQ   r10, [r1, #DAList+1]            ; then load pointer to 1st node
        BEQ     %FT10                           ; and skip

        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        LDR     r10, DynArea_LastEnumHandle
        CMP     r10, r1
        LDREQ   r10, DynArea_LastEnumPtr        ; pick up where we left off
        BEQ     %FT08
        BL      QCheckAreaNumber                ; else check valid area number
        BCC     %FT14

08
        LDR     r10, [r10, #DANode_Link]        ; find next one
10
        TEQ     r10, #0                         ; if at end
        MOVEQ   r1, #-1                         ; then return -1
        BEQ     %FT12
        LDR     r1, [r10, #DANode_Number]       ; else return number
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %BT08                           ; skip if system area

        LDR     r2, [r10, #DANode_Size]         ; return rest of info
        LDR     r3, [r10, #DANode_Base]
        LDR     r4, [r10, #DANode_Flags]
        LDR     r5, [r10, #DANode_MaxSize]
        LDR     r6, [r10, #DANode_Title]

        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        STR     r1, DynArea_LastEnumHandle
        STR     r10, DynArea_LastEnumPtr        ; save a lot of messing about on next call
12
        CLRV
        Pull    "PC"

;it's a reserved call, so naff off internationalisation
14
        ADR     r0,DynArea_badei
        SETV
        Pull    "PC"
DynArea_badei
        DCD     0
        DCB     "bad DA number",0
        ALIGN

  ] ;DynArea_QuickHandles

;**************************************************************************
;
a917 9
  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        LDR     r10, DynArea_LastEnumHandle
        CMP     r10, r1
        LDREQ   r10, DynArea_LastEnumPtr        ; pick up where we left off
        BEQ     %FT08
        BL      QCheckAreaNumber                ; else check valid area number
  |
a918 1
  ]
a920 1
08
d925 1
a925 10
        BEQ     %FT12
        LDR     r1, [r10, #DANode_Number]       ; else return number

  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        STR     r1, DynArea_LastEnumHandle
        STR     r10, DynArea_LastEnumPtr        ; save a lot of messing about on next call
  ]
12
a940 17
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT92                           ; can't renumber a system area
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT92
  [ DynArea_QuickHandles
        CMP     r1, #DynArea_NewAreas
        BLO     %FT10
        CMP     r1, #DynArea_NewAreas+DynArea_NumQHandles
        BLO     %FT92                           ; can't renumber a quick handle
10
        CMP     r2, #DynArea_NewAreas
        BLO     %FT12
        CMP     r2, #DynArea_NewAreas+DynArea_NumQHandles
        BLO     %FT92                           ; can't choose your own quick handle
12
        BL      QCheckAreaNumber
  |
a941 1
  ]
a946 3
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; check area r2 doesn't already exist
  |
a947 1
  ]
a961 14
  [ DynArea_QuickHandles
        MOV     r11, #0                         ; we know system areas cannot be renumbered
        LDR     r11, [r11, #DynArea_ws]
        MOV     r10, #-1
        STR     r10, DynArea_CreatingHandle     ; invalidate these, just in case
        STR     r10, DynArea_LastTreacleHandle
        STR     r10, DynArea_LastEnumHandle
        LDR     lr, DynArea_OD6Signature
        STR     lr, DynArea_OD6PrevSignature
        ORR     lr, lr, #8
        STR     lr, DynArea_OD6Signature
        STR     r1, DynArea_OD6Handle
  ]

a970 10
;if you think this is worth internationalising, I pity you
92
        ADR     r0, DynArea_NaughtyRenum
        SETV
        EXIT
DynArea_NaughtyRenum
        DCD     0
        DCB     "illegal DA renumber",0
        ALIGN

a988 3
  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; else check area number is valid
  |
a989 1
  ]
a1025 3
  [ DynArea_QuickHandles
QCheckAreaNumber_nonQ
  ]
a1035 8
  [ DynArea_QuickHandles
        Push    "r11"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        STR     r1,  DynArea_LastTreacleHandle
        STR     r10, DynArea_LastTreaclePtr
        Pull    "r11"
  ]
a1037 42
  [ DynArea_QuickHandles

; QCheckAreaNumber - similar to CheckAreaNumber, but blisteringly quick for system or for quick
;                    numbers. However, DOES NOT return previous node in r11.
;
QCheckAreaNumber ENTRY
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        CMP     r1, #-1
        BEQ     QCheckAreaNumber_nonQ           ;just to protect against -1 as a proposed number
        LDR     lr, DynArea_LastTreacleHandle
        CMP     lr, r1
        LDREQ   r10, DynArea_LastTreaclePtr
        EXIT    EQ                              ;found node is slow one we handled last time (carry set)
        LDR     lr, DynArea_CreatingHandle
        CMP     lr, r1
        LDREQ   r10, DynArea_CreatingPtr
        EXIT    EQ                              ;found node is one we're creating (carry set)
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT10
        CMP     r1,#DynArea_NewAreas
        BLO     QCheckAreaNumber_nonQ
        SUB     lr, r1, #DynArea_NewAreas
        CMP     lr, #DynArea_NumQHandles
        BHS     QCheckAreaNumber_nonQ
;quick handle
        ADR     r10, DynArea_QHandleArray
        LDR     r10, [r10, lr, LSL #2]
        CMP     r10, #DynArea_NumQHandles
        MOVLS   r10, #0                         ;not a valid pointer
        CMP     r10, #1
        EXIT                                    ;handle free, carry clear
                                                ;or word is ptr to node, carry set
;system handle
10
        ADR     r10, DynArea_SysQHandleArray
        LDR     r10, [r10, r1, LSL #2]
        CMP     r10, #1                    
        EXIT                                    ;DA does not exist, carry clear
                                                ;or word is ptr to node, carry set
  ] ;DynArea_QuickHandles

d1118 5
a1122 5
        &       UndStackSoftCamChunk,   1024*1024       ; undefined stack / soft cam map
        &       CursorChunkAddress,     64*1024         ; 32K for cursor, 32K for "nowhere"
        &       L2PT,                   4*1024*1024     ; L2PT (and L1PT)
        &       &03000000,              16*1024*1024    ; I/O + ROM
        &       PhysSpace,              256*1024*1024   ; PhysSpace excluding DRAM (DRAM no longer mapped here)
d1156 1
a1156 3
        BCS     %FT90                                   ; if we wrapped then we failed (includes end+1=0, but this
                                                        ; should fail given shadow ROM fixed area, and we can't let
                                                        ; end+1=0 through to compare with r2
a1377 1

d1389 9
a1397 8
; We have to move all free pages (ie ones not occupied by the static pages) into the free pool.
; The free pages consist of a video chunk and a non-video chunk, each having consecutive
; physical page numbers. The static pages occupy the start of the non-video chunk. We start at
; page 0 and move up till we hit the end of the video chunk. We then separately do the non-video
; chunk, starting from the first page not used for statics. Pouring the video chunk into the
; free pool first has the benefit that video pages will not be used early, except for video -
; this avoids the potential for wasted page mappings during system boot, caused by the VRAM rescue
; process doing its stuff.
d1401 4
a1404 13
        MOV     r5, #0                          ; r5 = amount of memory in free pool so far
        MOV     r7, #0
        LDR     r7, [r7, #VideoSize]            ; r7 = size of video RAM
        MOV     r7, r7, LSR #12                 ; r7 = 1st page number in non-video chunk
        MOV     r2, #0                          ; r2 = 1st page of video chunk
10
        BL      BangCamUpdate
        ADD     r3, r3, #4096                   ; advance logical address
        ADD     r5, r5, #4096
        ADD     r2, r2, #1
        CMP     r2, r7                          ; done video chunk?
        BLO     %BT10

d1410 5
a1414 4
        ADD     r2, r7, r8, LSR #12             ; r2 = 1st free page of non-video chunk (allowing for statics)
        MOV     r7, #0
        LDR     r7, [r7, #MaxCamEntry]          ; r7 = last page of non-video chunk
20
d1418 2
a1419 3
        ADD     r2, r2, #1
        CMP     r2, r7                          ; done non-video chunk?
        BLS     %BT20
a1441 48
  [ DynArea_QuickHandles

        LDR     r3, =DynArea_ws_size
        BL      ClaimSysHeapNode                    ; should not give error - kernel boot
        MOV     r0, #0
        STR     r2, [r0, #DynArea_ws]
        MOV     r11, r2
        LDR     r3, =DynArea_ws_size
        ADD     r3, r3, r2
DynArea_QHinit_loop1
        STR     r0, [r2], #4
        CMP     r2, r3
        BLO     DynArea_QHinit_loop1

        MOV     r1, #-1
        STR     r1, DynArea_CreatingHandle
        STR     r1, DynArea_LastTreacleHandle
        STR     r1, DynArea_LastEnumHandle

        ADR     r1, DynArea_QHandleArray            ; init all Qhandles as free, free list = 1..DynArea_NumQHandles
        MOV     r2, #1
        STR     r2, DynArea_FreeQHandles
DynArea_QHinit_loop2
        ADD     r2, r2, #1
        STR     r2, [r1], #4
        CMP     r2, #DynArea_NumQHandles
        BLO     DynArea_QHinit_loop2
        MOV     r2, #0
        STR     r2, [r1]                            ; 0 = end of free list

        MOV     r1, #DynArea_NewAreas-1
        ADD     r1, r1, #DynArea_NumQHandles        ; first non-quick DA number -1
        STR     r1, DynArea_TreacleGuess

        ADR     r1, DynArea_SysQHandleArray
        MOV     r2, #SysHeapDANode
        STR     r2, [r1, #ChangeDyn_SysHeap:SHL:2]
        MOV     r2, #FreePoolDANode
        STR     r2, [r1, #ChangeDyn_FreePool:SHL:2]

  |

        MOV     r0, #0
        STR     r0, [r0, #DynArea_ws]

  ] ;DynArea_QuickHandles

        MOV     r0, #0
d1489 6
d1497 2
a1498 2
;       ChangeDynamicSWI - implement OS_ChangeDynamicArea (change the
;                          size of a dynamic area)
d1501 2
a1502 1
;       r1 = size of change (in bytes, signed integer)
d1504 2
a1505 2
; out:  r0   preserved
;       r1 = actual amount moved (in bytes, unsigned integer)
a1506 2
ChangeDynamicSWI ROUT
        Push    "r0, r2-r9, r10, lr"
d1508 1
a1513 2
        LDREQB  r10, [r10, #VRAMRescue_control] ; also check that wimp has not locked Free Pool
        TSTEQ   r10, #VRRc_wimp_lock
a1526 4

  [ DynArea_QuickHandles
        BL      QCheckAreaNumber                ; check area number is on list
  |
a1527 1
  ]
a1534 17
  [ DynArea_QuickHandles      
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        LDR     r5, DynArea_OD6Signature
        CMP     r0, #ChangeDyn_MaxArea
        BLS     daq_cda_od6done
        CMP     r0, #&FFFFFFF0                  ;don't count special DA numbers, such as ChangeDyn_AplSpace
        BHI     daq_cda_od6done
        TST     r5, #&80000000                  ;if set, disables resize signature for this call
        STREQ   r5, DynArea_OD6PrevSignature
        STREQ   r0, DynArea_OD6Handle
        ORREQ   r5, r5, #4
daq_cda_od6done
        BIC     r5, r5, #&80000000              ;clear any disable
        STR     r5, DynArea_OD6Signature
  ]

a1572 9
  [ ChocolateScreen
        MOV     lr, #ARMA_Cleaner_status
        LDR     lr, [lr]
        TST     lr, #ACS_SCdisable
        CMPEQ   r0, #ChangeDyn_Screen
        MOVEQ   lr, #&100000
        SUBEQ   lr, lr, #1
        SUBNE   lr, r5, #1
    |
a1573 1
    ]
d2203 23
d2362 7
a2368 6
    ; mjs 06 Oct 97: 
    ; This is a new scheme for page copying, that does not rely on logical copy of physical space. Also:
    ;  (1) has the advantage of speed for StrongARM (which is diabolical copying to/from uncacheable space)
    ;  (2) fixes a bug present in 3.70, 3.71 - for StrongARM, we need to ensure coherency of a *writeback*
    ;      data cache and memory, for pages that may be involved in interrupts (3.70,3.71 failed in latter case)
    ; So, the scheme for StrongARM is:
d2371 3
a2373 2
    ;      and that our LDMs will be fast on StrongARM - there is no cache coherency issue, because the temporary mapping
    ;      is only created if that original mapping is non-existent or uncacheable
d2376 2
a2377 2
    ;      mapping (StrongARM needs cacheable as well as bufferable for burst STMs) - there is no cache coherency issue
    ;      because this address will not have been read, nor be read during this scheme
a2381 1
    ; The scheme is similar for ARM 6/7. The scheme currently *does not cope with ARM8* (no ARM8 product forseeable).
a2382 2
        ASSERT  :LNOT: ARM810support

d2384 3
a2386 2
        AND     r2, r2, #&F000          ;ARM identifier nibble in r2

d2400 1
a2400 3
        CMP     r2, #&A000
        ORREQ   r7, r7, #&00E           ;StrongARM  - &55E = L2PT bits for svc access, C=1, B=1
        ORRNE   r7, r7, #&002           ;ARM 6 or 7 - &552 = L2PT bits for svc access, C=0, B=0
d2422 1
a2422 5

        CMP     r2, #&A000
        BNE     cda_pagecopy_67_copyloop

cda_pagecopy_SA_copyloop
d2428 1
a2428 1
        BNE     cda_pagecopy_SA_copyloop
d2440 3
d2444 8
a2451 2
;currently, assume not SA means ARM 6/7 (ignore ARM 8)
cda_pagecopy_67_copyloop                
d2455 1
a2455 12
        BNE     cda_pagecopy_67_copyloop

        LDR     r6, =DuffEntry
        MOV     r4, #L2PT
        ADD     r4, r4, r6, LSR #(12-2) ;L2PT address for logical page at Nowhere (assumes page size 4k)
        MOV     r7, #0                  ;means translation fault in L2PT
        STR     r7, [r4]                ;update L2PT to remove 1st temporary mapping (if any)
        ARM67_flush_TLBentry r6         ;must flush TLB entry
        STR     r7, [r4,#4]             ;update L2PT to remove 2nd temporary mapping
        ADD     r6, r6, r5
        ARM67_flush_TLBentry r6         ;must flush TLB entry

@


4.4.4.4
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a31 2
;access permissions and flags
;
a32 1
AP_SVCStack     *       1                                       ; user r/-, CB (added for Ursula)
d39 1
a39 2
AP_RAMDisc      *       2 :OR: DynAreaFlags_NotCacheable        ; user none, ~CB (this is poor performance for current StrongARMs)
AP_RAMDisc_SA   *       2                                       ; user none, CB  (for StrongARM only - added for Ursula)
d44 1
a44 4
AP_PageZero     *       0 :OR: PageFlags_Unavailable            ; user r/w, CB (sadly, at least some of this needs user access)
                                                                ; Ursula change: pages now locked, because soft CAM doesn't represent
                                                                ; protection on 1k sub-pages, so swapping pages would cock up access permissions
                                                                ; Ursula applies more protection on a 1k granularity - see L1L2PTenhancements
d1629 1
a1629 8
;mjs changes for Ursula:
; - L2PT (and L1PT) have moved, so moved in list
; - area starting at CursorChunkAddress expanded to include cache cleaners etc.
; - PhysSpace now excludes DRAM
; - Shadow ROM removed, but top 8M retained as reserved
;
        ASSERT  L2PT >= 64*1024*1024
        ASSERT  UndStackSoftCamChunk = L2PT + 4*1024*1024
d1632 3
a1634 1
        &       CursorChunkAddress,     2*1024*1024     ; cursor,Nowhere,cache cleaners and reserved
d1636 2
a1637 4
        &       L2PT,                   8*1024*1024     ; 4M for L2PT (and L1PT), 1M for UNDSTK+SoftCAM, 3M reserved
        &       PhysSpace,              256*1024*1024   ; PhysSpace excluding DRAM
        &       &FF800000,              &007FFFFF       ; Reserved (used to be Shadow ROM), length has been bodged
                                                        ; to avoid wrap problems
d1671 2
a1672 2
                                                        ; should fail given reserved fixed area at top, and we can't
                                                        ; let end+1=0 through to compare with r2)
a1882 163

  [ ChocolateSysHeap
;
; CreateChocolateBlockArray
;
; entry: r2 = No. of blocks to be created in array (N)
;        r3 = size of each block in bytes (S, must be multiple of 4)
;
; exit:
;        r2 = address of chocolate block array (parent SysHeap block address)
;        array is initialised to all blocks free
;   OR   V set, r0=error pointer, if error (from OS_Heap)
;
; - A Chocolate block array is only suitable for blocks of single fixed size.
;   These blocks may be allocated and freed in any order, but never resized.
; - Allocating and freeing blocks from a Chocolate block array is much faster
;   than OS_Heap, and the cost of operations is independent of N.
; - A Chocolate block array is a single block in the SysHeap, and looks like this
;   (excluding the internal structure of OS_Heap blocks):
;
;  - array header (3 words):
;    - word 0  =  total no. of blocks in array (N)
;    - word 1  =  size of each block container (S+4)
;    - word 2  -> first free block container in array, or 0 if none free
;  - followed immediately by N block containers, each of form:
;    - container header (1 word):
;      - word 0 :  bits  0..30 = container id (C)
;                                C = (S+4)*I, where I is array index, 0..N-1
;                  bit  31     = 1 if block is free, 0 if block is in use
;    - followed immediately by the S/4 words of the block itself
;      - if the block is in use, these words are as defined by the client
;      - if the block is free, the first word is a pointer to the next free 
;        block container (or 0 if end of free list), and the other words
;        are undefined
;
; - A Chocolate block array requires a SysHeap block of 3*4 + N*(S + 4) bytes
;
CreateChocolateBlockArray ROUT
        Push    "r0,r1,r3,r4,r5,lr"
        MOV     r5,r2                ;N
        ADD     r4,r3,#4             ;S+4
        MUL     r3,r5,r4
        ADD     r3,r3,#3*4
        BL      ClaimSysHeapNode
        STRVS   r0,[SP]
        BVS     %FT50
        STR     r5,[r2]
        STR     r4,[r2,#4]
        ADD     r1,r2,#3*4
        STR     r1,[r2,#8]
        MOV     lr,r5
        ADD     r0,r2,#3*4
        MOV     r1,#&80000000        ;free flag
10
        STR     r1,[r0]
        ADD     r3,r0,r4
        STR     r3,[r0,#4]
        ADD     r1,r1,r4
        SUBS    lr,lr,#1
        MOVNE   r0,r3
        BNE     %BT10
        MOV     r1,#0
        STR     r1,[r0,#4]           ;end of free list
50
        Pull    "r0,r1,r3,r4,r5,pc"

;
; ClaimChocolateBlock
;
; entry: r3 = address of parent ChocolateBlockArray (must be valid)
; exit:  r2 = address of allocated block
;        r3 = size of block
;  OR    V set, R0=error (no free blocks)
;
ClaimChocolateBlock ROUT
        Push    "r1,r4,lr"
        MOV     r4,pc
        ORR     r1,r4,#I_bit
        TEQP    r1,#0             ;protect critical manipulation from interrupt re-entry
        LDR     r2,[r3,#8]        ;pick up block container at front of free list
        CMP     r2,#0
        BEQ     ClaimChocolateBlock_NoneFree
        LDR     r1,[r2]
        BIC     r1,r1,#&80000000  ;clear the free flag
        STR     r1,[r2]
        LDR     r1,[r2,#4]        ;next free block container
        STR     r1,[r3,#8]        ;put it at front
        ADD     r2,r2,#4          ;address of block
        LDR     r3,[r3,#4]
        SUB     r3,r3,#4          ;size of block
        BIC     r4,r4,#V_bit      ;return with V clear
        TEQP    r4,#0             ;restore IRQ state
        Pull    "r1,r4,pc"
;
;DON'T even think about internationalisation - this exit route must be fast
ClaimChocolateBlock_NoneFree
        ADR     R0,ChocolateBlock_NFError
        ORR     r4,r4,#V_bit      ;return with V set
        TEQP    r4,#0             ;restore IRQ state
        Pull    "r1,r4,pc"

;
; FreeChocolateBlock
;
; entry: r1 = address of parent ChocolateBlockArray (must be valid)
;        r2 = address of block to free (may be invalid)
; exit:  -
;   OR   V set, R0=error (not a ChocolateBlock), r1,r2 still preserved
;
FreeChocolateBlock ROUT
        Push    "r2,r3,r4,lr"
        MOV     r4,pc
        ORR     r3,r4,#I_bit
        TEQP    r3,#0             ;protect critical manipulation from interrupt re-entry
        ADD     r3,r1,#12         ;r3 -> first block container
        SUB     r2,r2,#4          ;r2 -> container for block (if valid)
        CMP     r2,r3
        BLO     FreeChocolateBlock_NaffOff
        LDR     lr,[r1,#-4]       ;OS_Heap's size word (naughty!)
        ADD     lr,lr,r1
        CMP     r2,lr
        BHS     FreeChocolateBlock_NaffOff
        LDR     lr,[r2]           ;block container id
        TST     lr,#&80000000     ;free flag
        BNE     FreeChocolateBlock_NaffOff
        ADD     lr,lr,r3          ;lr := address of block container, from container id
        CMP     lr,r2
        BNE     FreeChocolateBlock_NaffOff
;
;we now believe caller is freeing a valid block, currently in use
;
        LDR     lr,[r2]
        ORR     lr,lr,#&80000000
        STR     lr,[r2]           ;set free flag in container id
        LDR     lr,[r1,#8]        ;current front of free list
        STR     lr,[r2,#4]        ;chain free list to block container we are freeing
        STR     r2,[r1,#8]        ;put freed block container at front
        BIC     r4,r4,#V_bit      ;return with V clear
        TEQP    r4,#0             ;restore IRQ state
        Pull    "r2,r3,r4,pc"
;
;DON'T even think about internationalisation - this exit route must be fast
FreeChocolateBlock_NaffOff
        ADR     R0,ChocolateBlock_NOError
        ORR     r4,r4,#V_bit      ;return with V set
        TEQP    r4,#0             ;restore IRQ state
        Pull    "r2,r3,r4,pc"

;
;forget internationalisation - if these errors aren't dealt with silently, 
;                              the kernel's stuffed anyway
ChocolateBlock_NFError
        DCD     0
        DCB     "Chocolate SysHeap claim failed",0
        ALIGN
ChocolateBlock_NOError
        DCD     0
        DCB     "not a Chocolate SysHeap block",0
        ALIGN

  ] ;ChocolateSysHeap

;**************************************************************************
a1950 1
        ASSERT  SysHeapPlusSVCStackSize > SVCStackSize
d1955 1
a1955 1
        MOV     r4, #SysHeapPlusSVCStackSize - (SysHeapStart-SysHeapChunkAddress)
a1966 48
  [ ChocolateSysHeap
        ASSERT  ChocolateCBBlocks = ChocolateBlockArrays +  0
        ASSERT  ChocolateSVBlocks = ChocolateBlockArrays +  4
        ASSERT  ChocolateTKBlocks = ChocolateBlockArrays +  8
        ASSERT  ChocolateMRBlocks = ChocolateBlockArrays + 12
        ASSERT  ChocolateMABlocks = ChocolateBlockArrays + 16
        ASSERT  ChocolateMSBlocks = ChocolateBlockArrays + 20
        MOV     r1,#ChocolateBlockArrays
        MOV     r2,#MaxChocolateCBBlocks
        MOV     r3,#3*4
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#0]
        MOV     r2,#MaxChocolateSVBlocks
        MOV     r3,#VecNodeSize
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#4]
        MOV     r2,#MaxChocolateTKBlocks
        MOV     r3,#TickNodeSize
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#8]
        MOV     r2,#MaxChocolateMRBlocks
        MOV     r3,#ROMModule_NodeSize
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#12]
        MOV     r2,#MaxChocolateMABlocks
        MOV     r3,#ModInfo + Incarnation_Postfix + 8
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#16]
        MOV     r2,#MaxChocolateMSBlocks
        MOV     r3,#ModSWINode_Size
        BL      CreateChocolateBlockArray       ; better not fail
        STR     r2,[r1,#20]

  ]

  [ Oscli_HashedCommands
        MOV     r3,#4*(Oscli_MHashValMask+1)
        BL      ClaimSysHeapNode                ; better not fail
        MOV     r0,#0
        STR     r0,[r0,#Oscli_CmdHashSum]
        STR     r2,[r0,#Oscli_CmdHashLists]
        MOV     r3,#Oscli_MHashValMask+1
DynArea_OHinit_loop
        STR     r0,[r2],#4
        SUBS    r3,r3,#1
        BNE     DynArea_OHinit_loop
  ]

d2037 1
a2037 1
        &       SysHeapPlusSVCStackSize-(SysHeapStart-SysHeapChunkAddress) ; size
@


4.4.4.5
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a51 1
AP_Kbuffs       *       1 :OR: DynAreaFlags_NotUserDraggable    ; user r/- (added for Ursula, use if LongCommandLines)
a56 3
  [ DA_Batman
ChangeDyn_Batcall    * -3               ; special DA number to select Batman usage of OS_ChangeDynamicArea
  ]
d67 2
a68 3
ChangeDyn_VRescue    * 7                ; VRAM rescue (Ursula)
ChangeDyn_Kbuffs     * 8                ; Kernel buffers for LongCommandLines (Ursula)
ChangeDyn_MaxArea    * 8
d109 1
a112 4
      ;various bad things happen if DynArea_QuickHandles is FALSE (eg. some new API disappears)
      ;should remove FALSE build option to simplify source code next time kernel is updated (kept for reference/testing now)
      ASSERT DynArea_QuickHandles

a127 1
DynArea_ShrinkableSubList # 4                       ;sub list of dynamic areas that are Shrinkable (0 if none)
a136 6
DynArea_OD8Clamp1         # 4                       ;clamp value on area max size for OS_DynamicArea 0 with R5 = -1
                                                    ;(default -1, set by R1 of OS_DynamicArea 8)
DynArea_OD8Clamp2         # 4                       ;clamp value on area max size for OS_DynamicArea 0 with R5 > 0 (not Sparse)
                                                    ;(default -1, set by R2 of OS_DynamicArea 8)
DynArea_OD8Clamp3         # 4                       ;clamp value on area max size for OS_DynamicArea 0 for a Sparse area
                                                    ;(default 4G-4k, set by R3 of OS_DynamicArea 8)
a597 1
DAReason_SetClamps       *  8   ;if DynArea_Quickhandles, else reason code invalid
d599 1
a599 5
 [ DA_Batman
DAReason_SparseClaim     *  9   ;if DA_Batman, else reason code invalid
DAReason_SparseRelease   * 10   ;if DA_Batman, else reason code invalid
  ]
DAReason_Limit           * 11   ;end of defined DA reasons
d606 24
a629 17
;
; rearranged slightly for Ursula - allow room for some expansion of DA flags in future without moving page flags
;
DynAreaFlags_APBits             * 15 :SHL:  0   ; currently only uses 2 bits, but may extend to allow svc/usr read-only
DynAreaFlags_NotBufferable      *  1 :SHL:  4
DynAreaFlags_NotCacheable       *  1 :SHL:  5
DynAreaFlags_DoublyMapped       *  1 :SHL:  6
DynAreaFlags_NotUserDraggable   *  1 :SHL:  7
DynAreaFlags_NeedsSpecificPages *  1 :SHL:  8   ; whether area will ever require particular physical pages
DynAreaFlags_Shrinkable         *  1 :SHL:  9   ; whether area may be shrunk when need more space in free pool
DynAreaFlags_SparseMap          *  1 :SHL: 10   ; whether area may have non-contiguous mapping of pages (Holey dynamic areas Batman!)
DynAreaFlags_PiersBinding       *  1 :SHL: 11   ; whether area is bound to client application, and so may be swapped out with it (not implemented yet)
;
; bits 12..15 nominally reserved for future DA flags expansion
;
DynAreaFlags_AccessMask * DynAreaFlags_APBits :OR: DynAreaFlags_NotBufferable :OR: DynAreaFlags_NotCacheable :OR: DynAreaFlags_DoublyMapped
;
d631 2
a632 2
;
TempUncacheableShift            * 16
d634 2
a635 2
PageFlags_Unavailable           *  1 :SHL: 20                      ; physical page may not be requested by a PreShrink handler
;
a636 2
;
PageFlags_Required              *  1 :SHL: 21                      ; physical page asked for by handler
d638 2
a663 9
        B       DynArea_SetClamps
 |
        B       DynArea_Unknown
        B       DynArea_Unknown
        B       DynArea_Unknown
 ]
 [ DA_Batman
        B       DynArea_SparseClaim
        B       DynArea_SparseRelease
d668 1
d698 1
a698 7
;               bit  8 = 1 => area may require specific physical pages
;               bit  9 = 1 => area is shrinkable (only implemented if ShrinkableDAs)
;               bit 10 = 1 => area may be sparsely mapped (only implemented if DA_Batman)
;               bit 11 = 1 => area is bound to client application (allows areas to be overlayed in address space)
;                             not implemented yet, but declared in public API for Ursula
;               bits 12..15 reserved for future DA flag expansion (should be 0)
;               bits 16..31 reserved for internal page flags (should be 0)
a773 24
  [ DynArea_QuickHandles
    ;
    ; apply clamps on max size, as set by last call to OS_DynamicArea 8
    ;
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
    [ DA_Batman
        TST     r4, #DynAreaFlags_SparseMap
        BEQ     DAC_notsparse
        LDR     r10, DynArea_OD8Clamp3   ; clamp for sparse dynamic area
        CMP     r5, r10                  ; if requested max size is > relevant clamp
        MOVHI   r5, r10                  ; then clamp it!
        MOV     r10, #0
        LDR     r11, [r10, #Page_Size]
        B       DAC_roundup
DAC_notsparse
    ]
        CMP     r5, #-1
        LDREQ   r10, DynArea_OD8Clamp1   ; clamp for max size requested of -1
        LDRNE   r10, DynArea_OD8Clamp2   ; clamp for max size requested of some specific value
        CMP     r5, r10                  ; if requested max size is > relevant clamp
        MOVHI   r5, r10                  ; then clamp it!
  ]

a779 1
DAC_roundup
d822 1
a822 1
; now store data in node
a828 11
  [ DA_Batman
        ;disallow some awkward flag options if SparseMap set (no error), and temporarily create as not sparse
        ;also disallow a DA handler
        TST     r4, #DynAreaFlags_SparseMap
        STREQ   r4, [r2, #DANode_Flags]
        BICNE   r7, r4, #DynAreaFlags_DoublyMapped + DynAreaFlags_NeedsSpecificPages + DynAreaFlags_Shrinkable + DynAreaFlags_SparseMap
        ORRNE   r7, r7, #DynAreaFlags_NotUserDraggable
        STRNE   r7, [r2, #DANode_Flags]
        MOVNE   r6, #0
        MOVNE   r7, #0
  |
a829 1
  ]
d833 2
a834 4
        MOV     r7, #0
        STR     r7, [r2, #DANode_Size]          ; initial size is zero before we grow it
        STR     r7, [r2, #DANode_SubLink]       ; initialise as not part of any sublist
        STR     r7, [r2, #DANode_SparseHWM]     ; initial high water mark if Sparse, redundant otherwise
a934 11
  [ DA_Batman
        TST     r4, #DynAreaFlags_SparseMap
        LDRNE   r11, [r2, #DANode_Flags]
        ORRNE   r11, r11, #DynAreaFlags_SparseMap ; set this in node now (after initial grow)
        STRNE   r11, [r2, #DANode_Flags]
        LDRNE   r11, [r2, #DANode_Size]
        LDRNE   lr,  [r2, #DANode_Base]
        ADDNE   r11, r11, lr
        STRNE   r11, [r2, #DANode_SparseHWM]      ; initial high water mark
  ]

a937 6

        TST     r4, #DynAreaFlags_Shrinkable
        LDRNE   lr, DynArea_ShrinkableSubList
        STRNE   lr, [r2, #DANode_SubLink]
        STRNE   r2, DynArea_ShrinkableSubList   ;link onto front of Shrinkable sublist if Shrinkable

d1028 2
a1034 18
  [ DA_Batman
        Push    "r11"
        LDR     r11,[r10,#DANode_Flags]
        TST     r11,#DynAreaFlags_SparseMap
        Pull    "r11"
        BEQ     DAR_notsparse
        Push    "r0,r2-r3"
        MOV     r0,#DAReason_SparseRelease
        LDR     r2,[r10,#DANode_Base]
        LDR     r3,[r10,#DANode_MaxSize]
        SWI     XOS_DynamicArea            ;release all pages in sparse area
        STRVS   r0,[SP]
        Pull    "r0,r2-r3"
        EXIT    VS
        B       DAR_delink
DAR_notsparse
  ]

d1050 2
a1051 3

        LDR     r2, [r10, #DANode_Size]       ; get current size
        RSB     r1, r2, #0                    ; negate it
a1056 1
DAR_delink
a1061 22
  [ DynArea_QuickHandles
        ;if it is a Shrinkable area, find on Shrinkable sublist and remove it
        Push    "r0-r2, r11"
        LDR     r0, [r10, #DANode_Flags]
        TST     r0, #DynAreaFlags_Shrinkable
        BEQ     %FT06
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ADR     r1, DynArea_ShrinkableSubList
        LDR     r2, [r1]
04
        CMP     r2, r10
        LDREQ   r2, [r2, #DANode_SubLink]
        STREQ   r2, [r1]
        BEQ     %FT06
        ADD     r1, r2, #DANode_SubLink
        LDR     r2, [r2, #DANode_SubLink]
        B       %BT04
06
        Pull    "r0-r2, r11"
  ]

d1079 1
a1079 3
        CMP     r1, #ChangeDyn_MaxArea
        BLS     %FT08                                     ; system area being removed
        LDR     r2, DynArea_OD6Signature 
a1092 5
        B       %FT10
08
        ADR     r10, DynArea_SysQHandleArray
        MOV     r2,  #0
        STR     r2,  [r10, r1, LSL #2]                    ; reset system Qhandle
a1094 1

d1127 9
a1299 254
;       DynArea_SetClamps
;
;       Set clamps on max size of dynamic areas created by subsequent
;       calls to OS_DynamicArea 0
;
;   On entry
;       R0 = 8 (reason code)
;       R1 = limit on maximum size of (non-Sparse) areas created by
;            OS_DynamicArea 0 with R5 = -1, or 0 to read only
;       R2 = limit on maximum size of (non-Sparse) areas created by
;            OS_DynamicArea 0 with R5 > 0, or 0 to read only
;       R3 = limit on maximum size of Sparse areas created by
;            OS_DynamicArea 0 with R4 bit 10 set, or 0 to read only
;
;   On exit
;       R1 = previous limit for OS_DynamicArea 0 with R5 = -1
;       R2 = previous limit for OS_DynamicArea 0 with R5 > 0
;       R3 = previous limit for OS_DynamicArea 0 with R4 bit 10 set
;
;       Specifying -1 in R1 or R2 means the respective limit
;       is the RAM limit of the machine (this is the default).
;       Specifiying larger than the RAM limit in R1 or R2 is
;       equivalent to specifiying -1.
;
  [ DynArea_QuickHandles

DynArea_SetClamps ROUT
        Push    "r9,lr"

        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]

        LDR     r10, DynArea_OD8Clamp1
        LDR     lr,  DynArea_OD8Clamp2
        LDR     r9,  DynArea_OD8Clamp3

        CMP     r1, #0
        STRNE   r1, DynArea_OD8Clamp1
        CMP     r2, #0
        STRNE   r2, DynArea_OD8Clamp2
        CMP     r3, #0
        STRNE   r3, DynArea_OD8Clamp3

        MOV     r1, r10
        MOV     r2, lr
        MOV     r3, r9

        CLRV
        Pull    "r9,PC"

  ] ;DynArea_QuickHandles

;**************************************************************************

;       DynArea_SparseClaim
;
;  Ensure region of sparse dynamic area is mapped to valid memory
;
; in:   r0 = reason code (9)
;       r1 = area number
;       r2 = base of region to claim
;       r3 = size of region to claim
;
; out:  r0-r3 preserved (error if not all of region successfully mapped)
;       r10-r12 may be corrupted
;
; action: - round base and size to page granularity
;         - scan the L2PT for each page covered
;         - find contiguous fragments of 1 or more pages that are not yet mapped-in
;         - pass each of these fragments as a psuedo DANode to OS_ChangeDynamicArea
;           via special Batcall), to 'grow' pages into each fragment
;
  [ DA_Batman

DynArea_SparseClaim ROUT
        Push    "r0-r9,lr"
        MOV     r4,#1                   ; flags operation as a claim

DynArea_SparseChange                    ; common entry point for claim and release

  [ DynArea_QuickHandles
        BL      QCheckAreaNumber        ; check area exists
  |
        BL      CheckAreaNumber         ; check area exists
  ]
        BCC     DA_naffsparse           ; area not there

        LDR     r9,[r10,#DANode_Flags]
        TST     r9,#DynAreaFlags_SparseMap
        BEQ     DA_naffsparse           ; area not sparse

        MOV     r9,#&1000               ;page size
        SUB     r9,r9,#1
        ADD     r3,r3,r2                ;base+size
        CMP     r4,#1
        BICEQ   r2,r2,r9                ;round base down to page granularity for claim
        ADDEQ   r3,r3,r9
        BICEQ   r3,r3,r9                ;round base+size up to page granularity for claim
        ADDNE   r2,r2,r9
        BICNE   r2,r2,r9                ;round base up to page granularity for release
        BICNE   r3,r3,r9                ;round base+size down to page granularity for release
        SUB     r3,r3,r2                ;rounded size

        ADD     r9,r3,r2
        LDR     r5,[r10,#DANode_Base]
        LDR     r6,[r10,#DANode_MaxSize]
        ADD     r6,r6,r5
        CMP     r2,r5
        CMPHS   r9,r5
        BLO     DA_naffsparse
        CMP     r2,r6
        CMPLS   r9,r6
        BHI     DA_naffsparse

        ADD     r5,r2,r3                   ;base+size of mapping
        LDR     r6,[r10,#DANode_SparseHWM] ;high water mark = highest claim base+size seen
        CMP     r4,#1
        BEQ     %FT08
        CMP     r5,r6
        SUBHI   r3,r6,r2                   ;for release we can save work by trimming to high water mark
        B       %FT09                      ;r3 is now trimmed size (may be <=0 for trim to nothing)
08
        CMP     r5,r6
        STRHI   r5,[r10,#DANode_SparseHWM] ;for claim remember highest base+size as high water mark
09
        SUB     SP,SP,#DANode_NodeSize  ;room for temporary DANode on stack
        MOV     r9,r10                  ;actual sparse area DANode
        MOV     r5,SP
        MOV     r6,#DANode_NodeSize
10
        LDR     r7,[r9],#4           ;copy sparse area node to temp node
        STR     r7,[r5],#4
        SUBS    r6,r6,#4
        BNE     %BT10
        ADD     r3,r2,r3             ;stop address
;
        MOV     r5,#L2PT
        ADD     r5,r5,r2,LSR #10     ;r5 -> L2PT for base (assumes 4k page)
        MOV     r8,r2                ;start address
;
;look for next fragment of region that needs to have mapping change
20
        CMP     r8,r3
        BHS     %FT50                ;done
        LDR     r6,[r5],#4           ;pick-up next L2PT entry
        CMP     r4,#0                ;if operation is a release...
        CMPEQ   r6,#0                ;...and L2PT entry is 0 (not mapped)...
        ADDEQ   r8,r8,#&1000         ;...then skip page (is ok)
        BEQ     %BT20
        CMP     r4,#0                ;if operation is a claim (not 0)...
        CMPNE   r6,#0                ;...and L2PT entry is non-0 (mapped)...
        ADDNE   r8,r8,#&1000         ;...then skip page (is ok)
        BNE     %BT20
        MOV     r1,#&1000            ;else we need to do a change (1 page so far)
30
        ADD     r9,r8,r1
        CMP     r9,r3
        BHS     %FT40
        LDR     r6,[r5],#4           ;pick-up next L2PT entry
        CMP     r4,#1                ;if operation is a release (not 1)...
        CMPNE   r6,#0                ;...and L2PT entry is non-0 (mapped)...
        ADDNE   r1,r1,#&1000         ;...then count page as needing change
        BNE     %BT30
        CMP     r4,#1                ;if operation is a claim...
        CMPEQ   r6,#0                ;...and L2PT entry is 0 (not mapped)...
        ADDEQ   r1,r1,#&1000         ;...then count page as needing change
        BEQ     %BT30
;set up pseudo DA and do Batcall to change mapping of fragment we have found
40
        MOV     r2,SP                  ;temp DANode
        STR     r8,[r2,#DANode_Base]
        ADD     r8,r8,r1
        ADD     r8,r8,#&1000           ;next address to check after fragment
        CMP     r4,#1
        MOVEQ   r9,#0                  ;start size of 0 for claim
        MOVNE   r9,r1                  ;start size of fragment size for release
        STR     r9,[r2,#DANode_Size]
        STR     r1,[r2,#DANode_MaxSize]
        MOV     r0,#ChangeDyn_Batcall
        CMP     r4,#0
        RSBEQ   r1,r1,#0               ;batshrink for release, batgrow for claim
        SWI     XOS_ChangeDynamicArea
        CMP     r4,#0
        RSBEQ   r1,r1,#0
        LDR     r9,[r10,#DANode_Size]
        ADD     r9,r9,r1
        STR     r9,[r10,#DANode_Size]
        BVC     %BT20
;
50
        ADD     SP,SP,#DANode_NodeSize   ;drop temp DANode
        BL      DA_sparse_serviceandsig
        STRVS   r0,[SP]
        Pull    "r0-r9,PC"

DA_naffsparse
        ADR     r0,DA_naffsparseinnit
        SETV
        STR     r0,[SP]
        Pull    "r0-r9,PC"
DA_naffsparseinnit
        DCD     0
        DCB     "invalid OS_DynamicArea sparse claim/release",0
        ALIGN

DA_sparse_serviceandsig ROUT
        Push    "r0,LR"
        LDR     r1,[r10,#DANode_Number]
   [ DynArea_QuickHandles
        MOV     r11,#0
        LDR     r11,[r11, #DynArea_ws]
        LDR     r5,DynArea_OD6Signature
        STR     r5,DynArea_OD6PrevSignature
        ORR     r5,r5,#4                     ;signal a resize
        STR     r5,DynArea_OD6Signature
        STR     r1,DynArea_OD6Handle
   ]
        MOV     r2,r1                    ;area number
        MOV     r0,#0                    ;nominal 'grow/shrink' of 0 for service call
        MOV     r1,#Service_MemoryMoved
        BL      Issue_Service
        Pull    "r0,PC",,^

  ] ;DA_Batman

;**************************************************************************
;
;       DynArea_SparseRelease
;
;  Allow region of sparse dynamic area to release memory to free pool
;
; in:   r0 = reason code (10)
;       r1 = area number
;       r2 = base of region to release
;       r3 = size of region to release
;
; out:  r0-r3 preserved (error if not all of region successfully released)
;       r10-r12 may be corrupted
;
;
; action: - similar to DynArea_SparseClaim, but does 'shrinks' on fragments
;           that are mapped in

  [ DA_Batman

DynArea_SparseRelease ROUT
        Push    "r0-r9,lr"
        MOV     r4,#0                   ; flags operation as a release
        B       DynArea_SparseChange    ; jump to common code       

  ] ;DA_Batman

;**************************************************************************
;
d1460 1
a1462 9
  [ DynArea_QuickHandles
        ;traverse the Shrinkable sublist
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        LDR     r11, DynArea_ShrinkableSubList
        B       %FT21
  |
        MOV     r11, #DAList
  ]
a1463 3
  [ DynArea_QuickHandles
        LDR     r11, [r11, #DANode_SubLink]     ; load next area on sublist
  |
a1464 2
  ]
21
a1467 3
  [ DynArea_QuickHandles
        TEQ     r11, r10                        ; must not be the excluded area
  |
a1470 1
  ]
d1646 1
a1646 5
  [ LongCommandLines
        &       CursorChunkAddress,     1504*1024       ; cursor,Nowhere,cache cleaners and reserved
  |
        &       CursorChunkAddress,     2048*1024       ; cursor,Nowhere,cache cleaners and reserved
  ]
a2210 5
        STR     r1, DynArea_OD8Clamp1
        STR     r1, DynArea_OD8Clamp2
        MOV     r1, #&1000
        RSB     r1, r1, #0
        STR     r1, DynArea_OD8Clamp3               ; 4G - 4k
a2246 2
        ASSERT DANode_NodeSize = 11*4 ;so that tables below just might be valid DANodes

a2256 2
        &       0                               ; no sublist
        &       0                               ; not sparse
a2267 2
        &       0                               ; no sublist
        &       0                               ; not sparse
a2278 2
        &       0                               ; no sublist
        &       0                               ; not sparse
a2298 10

  [ DA_Batman
;OR, a special call is allowed for internal use:
;
; in:   r0 = ChangeDyn_Batman (-3)
;       r1 = size of change (in bytes, signed integer)
;       r2 -> pseudo DANode for this call - base of DA will be base of fragment to map/unmap,
;             magnitude of r1 will give size of fragment, sign of r1 is +ve for map -ve for unmap
  ]

a2316 7
  [ DA_Batman
    ;check for special Batman call (which uses OS_ChangeDynamicArea to map or unmap a fragment of a sparse DA)
        CMP     r0, #ChangeDyn_Batcall
        MOVEQ   r10, r2                         ; Batman call passes a pseudo DANode in r2
        BEQ     CDA_handlechecked
  ]

a2327 1

a2334 10
  [ DA_Batman
        ;a sparse area is not allowed to do an ordinary grow or shrink
        ;
        LDR     r11, [r10, #DANode_Flags]
        TST     r11, #DynAreaFlags_SparseMap
        BNE     failure_IRQgoingClearSemaphore
  ]

CDA_handlechecked

a2765 4
  [ DA_Batman
        CMP     r0, #ChangeDyn_Batcall
        BEQ     ISMM_BatCloak           ; cloaking device (no service issue)
  ]
a2771 3
  [ DA_Batman
ISMM_BatCloak
  ]
a3751 4
  [ LongCommandLines
AreaName_Kbuffs
        =       "Kernel buffers", 0
  ]
a3821 1
  [ KernelOwnsRAMFSDA
a3906 2

  ] ;KernelOwnsRAMFSDA
@


4.4.4.6
log
@ - reestablish ownership of RAMFS dynamic area by kernel; this may be
   switched out again later, if new RAMFS takes over ownership
 - make ChangeDynamicArea allow re-entrancy slightly earlier on a shrink;
   now allows re-enter after page moves but before calling any post-shrink
   handler; this should fix problem with RAMFS and new FileCore (that now
   itself uses dynamic areas); needs testing once we pull a ROM together
 - Fix following bugs:
    - (new) kernel was keeping modules on active service chains during
      call to their finalise, now temporarily delinks them, as the API
      says it should; symptom eg. Zap 1.39 fails to quit (module Zap)
    - (longstanding) *help in a taskwindow was very dangerous (eg quit
      window, run other *help, start new window can all take out OS,
      by fundamentally cracking MessageTrans); fix: *help now does not
      keep MessageTrans descriptor on SVC stack (swapped out on pre-empt),
      now has re-entrancy guard, gives 'busy' error if reentered; minor
      infelicity is that busy message may be given on new *help after
      abandoning old one in taskwindow, but the next *help will work
    - (longstanding) *time could occasionally give a scrambled message on
      first call in a taskwindow (caused by multiple use of a general
      buffer)
@
text
@a2950 4
  [ EarlierReentrancyInDAShrink
        MOV     r4, #0                          ; indicate no page block (and ptr to semaphore)
        STR     r4, [r4, #CDASemaphore]         ; OK to reenter now (we've done the damage)
  ]
@


4.4.4.7
log
@ - Fix problem with OS_DynamicArea 8 (clamps on maximum size).
   If clamp was less than requested initial size, clamp was still being
   applied, which breaks API of OS_DynamicArea 0 by giving less than
   requested size without returning error.
   Fix is to allow requested initial size to defeat clamp, which is also
   much more useful (allows max size to float up to what client obviously
   needs).
 - Kernel now enumerates dynamic areas in alphabetical order - gives much
   neater switcher display with only small extra cost on area creation
   (getting switcher to do sort would be expensive/messy). Performance
   here still wipes the floor with old kernels.
@
text
@a151 1
DynArea_SortedList        # 4                       ;alphabetically sorted list of non-system areas, or 0 if none
a812 3
        LDR     r10, [sp]                ; requested initial size, from stack
        CMP     r5, r10
        MOVLO   r5, r10                  ; we must try to honour initial size (allowed to break clamp)
a822 3
        LDR     r10, [sp]                ; requested initial size, from stack
        CMP     r5, r10
        MOVLO   r5, r10                  ; we must try to honour initial size (allowed to break clamp)
a900 1
        STR     r7, [r2, #DANode_SortLink]      ; initially, not on alphabetically sorted list
a979 2


a1000 34
  [ DynArea_QuickHandles
;
; Now put node on alphabetically sorted list
;
        Push    "r3,r4,r5,r7,r8,r9"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ADR     r8, DynArea_SortedList - DANode_SortLink ;so that [r8, #DANode_SortLink] addresses list header)
75
        MOV     r7, r8                       ; previous
        LDR     r8, [r7, #DANode_SortLink]
        TEQ     r8, #0
        BEQ     %FT78
        ;ho hum, UK case insensitive string compare
        LDR     r3, [r2, #DANode_Title]
        LDR     r9, [r8, #DANode_Title]
76
        LDRB    r4, [r3],#1
        uk_LowerCase r4,r11
        LDRB    r5, [r9],#1
        uk_LowerCase r5,r11
        CMP     r4, r5
        BNE     %FT77
        CMP     r4, #0
        BNE     %BT76
77
        BHI     %BT75
78
        STR     r2, [r7, #DANode_SortLink]  
        STR     r8, [r2, #DANode_SortLink]
79
        Pull    "r3,r4,r5,r7,r8,r9"
  ] ;DynArea_QuickHandles

a1157 23

  [ DynArea_QuickHandles
;
; delink from sorted list
;
        Push    "r7,r8,r11"
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
        ADR     r8, DynArea_SortedList - DANode_SortLink ;so that [r8, #DANode_SortLink] addresses list header)
DAR_sdloop
        MOV     r7, r8                      ;previous
        LDR     r8, [r7, #DANode_SortLink]
        TEQ     r8, #0                      ;just in case not on list, shouldn't happen  
        BEQ     DAR_sddone
        TEQ     r8, r10
        BNE     DAR_sdloop
        LDR     r8, [r8, #DANode_SortLink]
        STR     r8, [r7, #DANode_SortLink]
DAR_sddone
        Pull    "r7,r8,r11"

  ] ;DynArea_QuickHandles

d1371 3
a1376 5

        CMP     r1, #-1                         ; if starting from beginning
        LDREQ   r10, DynArea_SortedList         ; then load pointer to 1st node on sorted list
        BEQ     %FT10                           ; and skip

d1385 1
a1385 1
        LDR     r10, [r10, #DANode_SortLink]    ; find next one
d1458 6
a1463 8
;insist on at least 1M for a clamp value (ignore anything lower)
;
        CMP     r1, #&100000
        STRHS   r1, DynArea_OD8Clamp1
        CMP     r2, #&100000
        STRHS   r2, DynArea_OD8Clamp2
        CMP     r3, #&100000
        STRHS   r3, DynArea_OD8Clamp3
a1687 4
  [ DynArea_QuickHandles
        MOV     r11, #0
        LDR     r11, [r11, #DynArea_ws]
  ]
a1688 3
  [ DynArea_QuickHandles
        LDREQ   r10, DynArea_SortedList         ; then load pointer to 1st node on sorted list
  |
a1689 1
  ]
d1693 2
a1705 3
  [ DynArea_QuickHandles
        LDR     r10, [r10, #DANode_SortLink]    ; find next one
  |
a1706 1
  ]
d2476 1
a2476 1
        LDMIA   r0, {r0-r8}                        ; copy initial data into node
a2534 1

a2628 7
        LDR     r1, =FreePoolDANode
        STR     r1, DynArea_SortedList              ; initially, FreePool at front of sorted list,
        LDR     r2, =SysHeapDANode
        STR     r2, [r1, #DANode_SortLink]          ; and SysHeap second...
        MOV     r1, #0
        STR     R1, [r2, #DANode_SortLink]          ; ...and last

d2649 1
a2649 1
;note that words of a DANode beyond 0..8 are assumed to be safely initialised as 0
d2661 2
d2674 2
d2687 2
@


4.4.4.8
log
@Made the kernel control the layout of the free space map on the RAM disc,
which avoids the rmreinit ramfs on every size change of the disc.

Also increase RAM disc max size to 128M bytes.

Change is enabled by NewRAMFS switch.
@
text
@d998 1
a998 1
        ORR     lr, lr, #&80000000
d1039 1
a1039 1
        STR     r2, [r7, #DANode_SortLink]
d1184 1
a1184 1
        ORR     lr, lr, #&80000000
d1214 1
a1214 1
        TEQ     r8, #0                      ;just in case not on list, shouldn't happen
d1271 1
a1271 1
        LDR     r2, DynArea_OD6Signature
d1277 1
a1277 1
        BLO     %FT10
d1384 1
a1384 1
;            bit 3 = 1 if any non-system areas have been renumbered
d1741 1
a1741 1
        B       DynArea_SparseChange    ; jump to common code
d2028 1
a2028 1
        CMP     r10, #1
d2406 1
a2406 1
;      - if the block is free, the first word is a pointer to the next free
d2524 1
a2524 1
;forget internationalisation - if these errors aren't dealt with silently,
d2856 1
a2856 1
  [ DynArea_QuickHandles
d3698 1
a3698 1
    ; mjs 06 Oct 97:
d3784 1
a3784 1
cda_pagecopy_67_copyloop
a4368 433
 [ NewRAMFS

; disc record structure

        ^ 0
;
SectorSize      # 1     ;log2 sector size
SecsPerTrk      # 1
Heads           # 1     ;n-1 for old adfs floppy format
Density         # 1     ;1/2/4 single double quad

;only those above & DiscsDrv & Disc Size needed for low level drivers

LinkBits        # 1
BitSize         # 1     ;log2 bytes for each bit in map, 0 for old format
RAskew          # 1     ;track to track sector skew for random access

BootOpt         # 1     ;boot option for this disc

LowSector       # 1     ; Lowest sector number on a track and flags:
                ; Bit     Meaning when set
LowSectorMask   * &3f
                ; 0-5     Lowest numbered sector on a track
;SequenceSides   bit 6
                ; 6       Tracks are numbered 0..s-1 on side 0, then s..2s-1 on side 1, etc
;DoubleStep      bit 7
                ; 7       Double step

Zones           # 1     ;# zones in map
ZoneSpare       # 2     ;# bits in zones after 0 which are not map bits
        ASSERT  (ZoneSpare :MOD: 4)=2

RootDir         # 4
DiscSize        # 4

DiscStruc       # 0     ;above entries (except BootOpt) define disc structure

DiscId          # 2
DiscName        # 10
DiscRecSig      # 0     ;above entries form signature of disc

DiscType        # 4    ; FileType of disc: FileType_Data indicates
                        ; that the disc is, as yet, unidentified.
                        ; This may occur as a result of the identification
                        ; process failing, or the identification process
                        ; not yet happening. FileType_Data discs have no
                        ; concept of a unique identifier so drive independance
                        ; when accessing them is not possible.

DiscSize2	# 4	; top 32bits of the disc size.  This combines with
			; DiscSize to give the full size of the disc.  Note
			; that we may have to move DiscStruc to below here
			; so we can compare structures properly.
ShareSize       # 1     ; sharing unit
BigFlag         # 1     ; flag - 0 for small disc, 1 for big
BigFlagBit	* 1	; bit for the big flag
Zones2		# 1	; high byte of number of zones
SharePad	# 1	; padding
DiscVersion	# 4	; version number of disc format
RootDirSize	# 4	; size of root dir
DiscRecSig2     # 0     ;above entries form signature of disc


SkeletonDiscRec		;fields marked * need filling in
	=  	10	; sector size 2^10
	=  	1	; sectors per track (this is a RAM disc, after all)
	=  	1	; heads
	=  	0	; density
	=  	0	; * LinkBits
	=  	0	; * BitSize
	=  	0	; skew
	=  	0	; lowsector
	=  	0	; * nzones
	=  	0,0	; * ZoneSpare
	DCD 	0	; * RootDir
	DCD 	0	; * DiscSize
	DCD 	0,0,0	; disc cycle id + disc name
	DCD 	0	; DiscType
	DCD 	0	; DiscSize2
	DCD 	0	; ShareSize,BigFlag,Zones2,Reserved
	DCD 	1   	; DiscVersion
	DCD 	2048 	; RootSize

	ASSERT	.-SkeletonDiscRec = DiscRecSig2

ZoneDiscRecSz   * 60    ;reserve additional bytes
Zone0Bits       * ZoneDiscRecSz*8

InitRAMDisc ROUT
	Push	"R0-R11,LR"
	ADRL	r0, RAMDisc_DismountStr
	SWI	XOS_CLI

        SWI     XOS_ReadRAMFsLimits     ;(->R0,R1)

	SUBS	r6, r1, r0
	BEQ	%FT85

	MOV	r1, #4096
	MOV	r2, #0
10
	STR	r2, [r0], #4
	SUBS	r1, r1, #4
	BNE	%BT10

	SUB	sp, sp, #DiscRecSig2

	ADRL	R0, SkeletonDiscRec	; source

	MOV	R1, SP			; dest
	MOV	R2, #DiscRecSig2	; length

20
	LDR	R3, [R0], #4
	STR	R3, [R1], #4
	SUBS	R2, R2, #4
	BNE	%BT20

	STR	R6, [SP, #DiscSize]	;store away the size

	MOV	r5, SP
	BL	InitDiscRec		; fill in the disc record fields which need calculation

	MOV	r1, #WriteTrkOp
	ORR	r1, r1, r5, LSL #6
	MOV	r2, #0
	MOV	r3, #0
	MOV	r4, #1024
	SWI	XRamFS_DiscOp

	BVS	%FT75

	MOV	r0, #&CF
	ADRL	r1, RAMDisc_RAMdisc0Name	; name ptr
	SWI	XOS_Find		; find it

	BVS	%FT75			; failed to do so

	MOV	R3, R0

	MOV	r0, sp
	ADRL	r1, RAMDisc_EmptyBBList		; no bad block list
	ADRL	r2, RAMDisc_JustDiscName	; disc name

	SWI	XFileCore_LayoutStructure

	MOV	r0, #0
	MOV	r1, r3
	SWI	XOS_Find

	ADRL	r0, RAMDisc_DismountStr
	SWI	XOS_CLI

	ADRL	r0, RAMDisc_MountStr
	SWI	XOS_CLI

75
	ADD	sp, sp, #DiscRecSig2

85
	STRVS	r0, [sp]
	Pull	"R0-R11,PC"


RAMDisc_EmptyBBList
	DCD	-1
RAMDisc_JustDiscName
	DCB	"RamDisc0",0
	ALIGN
RAMDisc_RAMdisc0Name
        DCB     "RAM::0",0
        ALIGN
RAMDisc_DismountStr
	DCB	"RAM:Dismount :0",0
RAMDisc_MountStr
	DCB	"RAM:mount :0",0
	ALIGN

; >>>>>>>>>>>
; InitDiscRec
; >>>>>>>>>>>

; this routine generates the values in the disc record to suit the
; chosen size of the RAM disc.  We need to work out the values, and
; place them in a disc record

; in:
;
;    r5 -> disc record

; out:
;
;   disc record fields filled in: zones, zonespare, LinkBits and bitsize

; here's some definitions used by this routine:

Min_LinkBits	*	13	; minimum allowed LinkBits (with 1024 byte zones)
Max_LinkBits	*	19	; maximum allowed LinkBits (unlikely!)
Min_BitSize	*	7	; minimum allowed bitsize
Max_BitSize	*	12	; max allowed bitsize
Min_ZoneSpare	*	32	; min allowed zonespare
Max_ZoneSpare	*	64	; max allowed zonespare
Min_Zones	*	1	; min allowed zones
Max_Zones	*	16	; max allowed zones

; internal register allocation:

; r5 -> disc record

; r0 = current bitsize
; r1 = current zonespare
; r2 = current zones
; r3 = current LinkBits
; r4 = map allocation bits required to cover disc
; r6 = number of bits in a zone
; r7 = number of allocation bits in the map
; r8 = ids per zone


InitDiscRec	ROUT
	Push	"R0-R11,LR"

	MOV	r0, #Min_BitSize	; init BitSize

10	; loop on BitSize
	LDR	r4, [r5, #DiscSize]
	MOV	r4, r4, LSR r0		; map bits for disc

	MOV	r1, #Min_ZoneSpare	; init ZoneSpare
20	; loop on zonespare

	LDR	lr, [r5, #SectorSize]
	MOV	r6, #8
	MOV	r6, r6, LSL lr		; bits in a zone
	SUB	r6, r6, r1		; minus sparebits

	; choose number of zones to suit

	MOV	r2, #Min_Zones		; minimum of one zone
	SUB	r7, r6, #Zone0Bits	; bits in zone 0

30	; loop for zones
	CMP	r7, r4			; do we have enough allocation bits yet?
	BHS	%FT35			; if we do, then accept this number of zones

	ADD	r7, r7, r6		; more map bits
	ADD	r2, r2, #1		; and another zone
	CMPS	r2, #Max_Zones
	BLS	%BT30			; still ok

	; here when too many zones; try a higher BitSize

	B	%FT80

35
	; now we have to choose LinkBits.  we want LinkBits to be
	; the smallest it can be for the disc.

	MOV	r3, #Min_LinkBits		; minimum value of LinkBits

40	; loop for LinkBits

	Push	"R0, R1, R2"
	MOV	r0, r6			; allocation bits in a zone
	ADD	r1, r3, #1		; LinkBits+1
	DivRem	r8, r0, r1, r2
	Pull	"R0, R1, R2"

	; check that LinkBits is enough for total possible ids
	MOV	r9, #1			; work out 1<<LinkBits
	MOV	r9, r9, LSL r3		;

	MUL	lr, r8, r2		; total ids needed
	CMPS	lr, r9			; LinkBits too small?
	BHI	%FT60			; yes!

	; we're nearly there.  now work out if the last zone
	; can be handled correctly.

	SUBS	lr, r7, r4
	BEQ	%FT50

	CMPS	lr, r3			; must be at least LinkBits+1 bits
	BLE	%FT60

	; check also that we're not too close to the start of the zone

	SUB	lr, r7, r6		; get the start of the zone

	SUB	lr, r4, lr		;
	CMPS	lr, r3
	BLE	%FT60


50	; we've found a result - fill in the disc record!

	; first, store the things we know about

	STRB	r3,[r5, #LinkBits]
	MOV	r1, r1, LSL #16
	ORR	r1, r1, r2, LSL #8

	STR	r1, [r5, #ZoneSpare-2]

	STRB	r0, [r5, #BitSize]

	LDR	lr, [r5, #DiscVersion]

	MOVS	lr, lr

	BEQ	%FT01			; do we have long filenames?

	; here when long filenames

	; the root dir's ID is the first available ID in the middle
	; zone of the map


	MOVS	r2, r2, LSR #1		; zones/2

	MULNE	lr, r2, r8		; *idsperzone
	MOVEQ	lr, #3			; if if zones/2=0, then only one zone, so the id is 3 (0,1,2 reserved)

	MOV	lr, lr, LSL #8		; construct full indirect disc address
	ORR	lr, lr, #1		; with sharing offset of 1

	B	%FT02

01
	; here when not long filenames

	; root dir is &2nn where nn is ((zones<<1)+1)

	MOV	lr, r2, LSL #1
	ADD	lr, lr, #1
	ADD	lr, lr, #&200

02

	STR	lr, [r5, #RootDir]	; root dir disc addr


	B	%FT90

; other fields in the disc record are fixed-value

60	; NEXT LinkBits
	ADD	r3, r3, #1
	CMPS	r3, #Max_LinkBits
	BLS	%BT40

70	; NEXT zonespare
	ADD	r1, r1, #1
	CMPS	r1, #Max_ZoneSpare
	BLS	%BT20


80	; NEXT BitSize
	ADD	r0, r0, #1
	CMPS	r0, #Max_BitSize	; is it too much?
	BLS	%BT10			; back around

90
	Pull	"R0-R11,PC",,^


PostGrow_RAMDisc
PostShrink_RAMDisc ENTRY "r0-r7"

; in - r3 = size change (+ve), r4 = new size, r5 = page size
; but we don't really care about any of these

; the actions we take depend on whether RAMFS is active or not

; also, we take different action if the RAM disc size is zero

	MOV	r7, r4		; keep size of disc around
	TEQS	r4, #0
	BNE	%FT05

; here if zero-size RAM disc;  kill ramfs

	MOV	r0, #ModHandReason_Delete
	ADRL	r1, ramfsname
	SWI	XOS_Module
	B	%FT90

05
        MOV     r0, #0
        LDR     r0, [r0, #Module_List]
        TEQ     r0, #0                  ; any modules yet?
        BEQ     %FT90                   ; no, then don't do anything

        MOV     r0, #ModHandReason_EnumerateROM_Modules
        MOV     r1, #0
        MOV     r2, #-1                 ; enumerate ROM modules looking for RAMFS
10
        SWI     XOS_Module
        BVS     %FT50                   ; no more modules, so it can't be unplugged
        ADRL    r5, ramfsname
20
        LDRB    r6, [r3], #1            ; get char from returned module name
        CMP     r6, #" "                ; if a terminator then we have a match
        BLS     %FT30                   ; so check for unplugged
        LowerCase r6, lr                ; else force char to lower case
        LDRB    lr, [r5], #1            ; get char from "ramfs" string
        CMP     lr, r6                  ; and if matches
        BEQ     %BT20                   ; then try next char
        B       %BT10                   ; else try next module

30
        CMP     r4, #-1                 ; is module unplugged?
        BEQ     %FT90                   ; if so, then mustn't reinit it
	CMP	r4, #0
	BNE	%FT60 			; here when we actually do owt
50
        MOV     r0, #ModHandReason_ReInit ; reinit module
        ADRL    r1, ramfsname
        SWI     XOS_Module              ; ignore any errors from this

60

  ; here we actually do the setting up of the RAM disc free space map

	BL	InitRAMDisc

90

	CLRV
	EXIT

 |

d4390 1
a4390 1
        ADRL    r5, ramfsname
d4406 1
a4406 1
        ADRL    r1, ramfsname
a4410 2

 ]
@


4.4.4.8.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@a2113 1
; - PCI space and PCI config space added (always reserved on all h/w, for simplicity)
d2118 2
a2119 5
        ASSERT  PCISpace  = PhysSpace + 256*1024*1024
        ASSERT  PCIConfig = PCISpace  + 256*1024*1024
;
FixedAreasTable                                       ; table of fixed areas (logical address, size)
        &  0,                   AplWorkMaxSize        ; application space
d2121 1
a2121 2
        &  CursorChunkAddress,  1504*1024             ; cursor,Nowhere,cache cleaners and reserved
                                                      ; (kernel buffers DA created in what was reserved space)
d2123 1
a2123 1
        &  CursorChunkAddress,  2048*1024             ; cursor,Nowhere,cache cleaners and reserved
d2125 6
a2130 8
        &  &03000000,           16*1024*1024          ; I/O + ROM
        &  L2PT,                (4+1+3)*1024*1024     ; 4M for L2PT (and L1PT), 1M for UNDSTK+SoftCAM, 3M reserved
        &  PhysSpace,           (256+256+4)*1024*1024 ; PhysSpace excluding DRAM, PCI space, PCI config space
                                                      ; (PCI config space must be 4M because of 4M granularity of
                                                      ;  AllocateBackingLevel2 routine used for dynamic areas)
        &  &FF800000,           &007FFFFF             ; Reserved (used to be Shadow ROM), length has been bodged
                                                      ; to avoid wrap problems
        &  -1,                  0                     ; termination
a2874 8
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        CMP     r0, #ChangeDyn_Screen
        MOVEQ   r12,#&100000
        SUBEQ   r12,r12,#1
        ADDEQ   r1, r1, r12
        BICEQ   r1, r1, r12
  ]
a2910 7
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        CMP     r0, #ChangeDyn_Screen
        MOVEQ   lr,#&100000
        SUBEQ   lr,lr,#1
        BICEQ   r1, r1, lr
  ]
a2947 7
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        CMP     r0, #ChangeDyn_Screen
        MOVEQ   lr,#&100000
        SUBEQ   lr,lr,#1
        BICEQ   r1, r1, lr
  ]
a3103 7
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        CMP     r0, #ChangeDyn_Screen
        MOVEQ   lr,#&100000
        SUBEQ   lr,lr,#1
        BICEQ   r1, r1, lr
  ]
d3718 1
a3719 3
;        ASSERT  :LNOT: ARM810support

  [ :LNOT: ARMSASupport_Only
a3721 1
  ]
a3735 1
  [ :LNOT: ARMSASupport_Only
a3738 3
  |
        ORR     r7, r7, #&00E           ;StrongARM  - &55E = L2PT bits for svc access, C=1, B=1
  ]
a3760 1
  [ :LNOT: ARMSASupport_Only
a3762 1
  ]
a3763 1
  [ ARMSASupport
a3780 3
  ] ;ARMSASupport
;
  [ :LNOT: ARMSASupport_Only
d3782 1
a3782 1
;
d3799 1
a3799 1
  ] ; :LNOT: ARMSASupport_Only
d3999 1
a3999 1
        BLEQ    Do_AMB_MakeUnsparse
d4021 1
a4021 1
        BL      Do_AMB_MakeUnsparse
d4026 1
a4026 1
Do_AMB_MakeUnsparse ROUT
d4418 4
a4421 4
DiscSize2       # 4     ; top 32bits of the disc size.  This combines with
                        ; DiscSize to give the full size of the disc.  Note
                        ; that we may have to move DiscStruc to below here
                        ; so we can compare structures properly.
d4424 5
a4428 5
BigFlagBit      * 1     ; bit for the big flag
Zones2          # 1     ; high byte of number of zones
SharePad        # 1     ; padding
DiscVersion     # 4     ; version number of disc format
RootDirSize     # 4     ; size of root dir
d4432 19
a4450 19
SkeletonDiscRec         ;fields marked * need filling in
        =       10      ; sector size 2^10
        =       1       ; sectors per track (this is a RAM disc, after all)
        =       1       ; heads
        =       0       ; density
        =       0       ; * LinkBits
        =       0       ; * BitSize
        =       0       ; skew
        =       0       ; lowsector
        =       0       ; * nzones
        =       0,0     ; * ZoneSpare
        DCD     0       ; * RootDir
        DCD     0       ; * DiscSize
        DCD     0,0,0   ; disc cycle id + disc name
        DCD     0       ; DiscType
        DCD     0       ; DiscSize2
        DCD     0       ; ShareSize,BigFlag,Zones2,Reserved
        DCD     1       ; DiscVersion
        DCD     2048    ; RootSize
d4452 1
a4452 1
        ASSERT  .-SkeletonDiscRec = DiscRecSig2
d4458 3
a4460 3
        Push    "R0-R11,LR"
        ADRL    r0, RAMDisc_DismountStr
        SWI     XOS_CLI
d4464 2
a4465 2
        SUBS    r6, r1, r0
        BEQ     %FT85
d4467 2
a4468 2
        MOV     r1, #4096
        MOV     r2, #0
d4470 3
a4472 3
        STR     r2, [r0], #4
        SUBS    r1, r1, #4
        BNE     %BT10
d4474 1
a4474 1
        SUB     sp, sp, #DiscRecSig2
d4476 1
a4476 1
        ADRL    R0, SkeletonDiscRec     ; source
d4478 2
a4479 2
        MOV     R1, SP                  ; dest
        MOV     R2, #DiscRecSig2        ; length
d4482 4
a4485 4
        LDR     R3, [R0], #4
        STR     R3, [R1], #4
        SUBS    R2, R2, #4
        BNE     %BT20
d4487 1
a4487 1
        STR     R6, [SP, #DiscSize]     ;store away the size
d4489 2
a4490 2
        MOV     r5, SP
        BL      InitDiscRec             ; fill in the disc record fields which need calculation
d4492 6
a4497 6
        MOV     r1, #WriteTrkOp
        ORR     r1, r1, r5, LSL #6
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #1024
        SWI     XRamFS_DiscOp
d4499 1
a4499 1
        BVS     %FT75
d4501 3
a4503 3
        MOV     r0, #&CF
        ADRL    r1, RAMDisc_RAMdisc0Name        ; name ptr
        SWI     XOS_Find                ; find it
d4505 1
a4505 1
        BVS     %FT75                   ; failed to do so
d4507 1
a4507 1
        MOV     R3, R0
d4509 3
a4511 3
        MOV     r0, sp
        ADRL    r1, RAMDisc_EmptyBBList         ; no bad block list
        ADRL    r2, RAMDisc_JustDiscName        ; disc name
d4513 1
a4513 1
        SWI     XFileCore_LayoutStructure
d4515 3
a4517 3
        MOV     r0, #0
        MOV     r1, r3
        SWI     XOS_Find
d4519 2
a4520 2
        ADRL    r0, RAMDisc_DismountStr
        SWI     XOS_CLI
d4522 2
a4523 2
        ADRL    r0, RAMDisc_MountStr
        SWI     XOS_CLI
d4526 1
a4526 1
        ADD     sp, sp, #DiscRecSig2
d4529 2
a4530 2
        STRVS   r0, [sp]
        Pull    "R0-R11,PC"
d4534 1
a4534 1
        DCD     -1
d4536 2
a4537 2
        DCB     "RamDisc0",0
        ALIGN
d4542 1
a4542 1
        DCB     "RAM:Dismount :0",0
d4544 2
a4545 2
        DCB     "RAM:mount :0",0
        ALIGN
d4565 8
a4572 8
Min_LinkBits    *       13      ; minimum allowed LinkBits (with 1024 byte zones)
Max_LinkBits    *       19      ; maximum allowed LinkBits (unlikely!)
Min_BitSize     *       7       ; minimum allowed bitsize
Max_BitSize     *       12      ; max allowed bitsize
Min_ZoneSpare   *       32      ; min allowed zonespare
Max_ZoneSpare   *       64      ; max allowed zonespare
Min_Zones       *       1       ; min allowed zones
Max_Zones       *       16      ; max allowed zones
d4588 2
a4589 2
InitDiscRec     ROUT
        Push    "R0-R11,LR"
d4591 1
a4591 1
        MOV     r0, #Min_BitSize        ; init BitSize
d4593 3
a4595 3
10      ; loop on BitSize
        LDR     r4, [r5, #DiscSize]
        MOV     r4, r4, LSR r0          ; map bits for disc
d4597 2
a4598 2
        MOV     r1, #Min_ZoneSpare      ; init ZoneSpare
20      ; loop on zonespare
d4600 4
a4603 4
        LDR     lr, [r5, #SectorSize]
        MOV     r6, #8
        MOV     r6, r6, LSL lr          ; bits in a zone
        SUB     r6, r6, r1              ; minus sparebits
d4605 1
a4605 1
        ; choose number of zones to suit
d4607 2
a4608 2
        MOV     r2, #Min_Zones          ; minimum of one zone
        SUB     r7, r6, #Zone0Bits      ; bits in zone 0
d4610 3
a4612 3
30      ; loop for zones
        CMP     r7, r4                  ; do we have enough allocation bits yet?
        BHS     %FT35                   ; if we do, then accept this number of zones
d4614 4
a4617 4
        ADD     r7, r7, r6              ; more map bits
        ADD     r2, r2, #1              ; and another zone
        CMPS    r2, #Max_Zones
        BLS     %BT30                   ; still ok
d4619 1
a4619 1
        ; here when too many zones; try a higher BitSize
d4621 1
a4621 1
        B       %FT80
d4624 2
a4625 2
        ; now we have to choose LinkBits.  we want LinkBits to be
        ; the smallest it can be for the disc.
d4627 1
a4627 1
        MOV     r3, #Min_LinkBits               ; minimum value of LinkBits
d4629 1
a4629 1
40      ; loop for LinkBits
d4631 5
a4635 5
        Push    "R0, R1, R2"
        MOV     r0, r6                  ; allocation bits in a zone
        ADD     r1, r3, #1              ; LinkBits+1
        DivRem  r8, r0, r1, r2
        Pull    "R0, R1, R2"
d4637 3
a4639 3
        ; check that LinkBits is enough for total possible ids
        MOV     r9, #1                  ; work out 1<<LinkBits
        MOV     r9, r9, LSL r3          ;
d4641 3
a4643 3
        MUL     lr, r8, r2              ; total ids needed
        CMPS    lr, r9                  ; LinkBits too small?
        BHI     %FT60                   ; yes!
d4645 2
a4646 2
        ; we're nearly there.  now work out if the last zone
        ; can be handled correctly.
d4648 2
a4649 2
        SUBS    lr, r7, r4
        BEQ     %FT50
d4651 2
a4652 2
        CMPS    lr, r3                  ; must be at least LinkBits+1 bits
        BLE     %FT60
d4654 1
a4654 1
        ; check also that we're not too close to the start of the zone
d4656 1
a4656 1
        SUB     lr, r7, r6              ; get the start of the zone
d4658 3
a4660 3
        SUB     lr, r4, lr              ;
        CMPS    lr, r3
        BLE     %FT60
d4663 1
a4663 1
50      ; we've found a result - fill in the disc record!
d4665 1
a4665 1
        ; first, store the things we know about
d4667 3
a4669 3
        STRB    r3,[r5, #LinkBits]
        MOV     r1, r1, LSL #16
        ORR     r1, r1, r2, LSL #8
d4671 1
a4671 1
        STR     r1, [r5, #ZoneSpare-2]
d4673 1
a4673 1
        STRB    r0, [r5, #BitSize]
d4675 1
a4675 1
        LDR     lr, [r5, #DiscVersion]
d4677 1
a4677 1
        MOVS    lr, lr
d4679 1
a4679 1
        BEQ     %FT01                   ; do we have long filenames?
d4681 1
a4681 1
        ; here when long filenames
d4683 2
a4684 2
        ; the root dir's ID is the first available ID in the middle
        ; zone of the map
d4687 1
a4687 1
        MOVS    r2, r2, LSR #1          ; zones/2
d4689 2
a4690 2
        MULNE   lr, r2, r8              ; *idsperzone
        MOVEQ   lr, #3                  ; if if zones/2=0, then only one zone, so the id is 3 (0,1,2 reserved)
d4692 2
a4693 2
        MOV     lr, lr, LSL #8          ; construct full indirect disc address
        ORR     lr, lr, #1              ; with sharing offset of 1
d4695 1
a4695 1
        B       %FT02
d4698 1
a4698 1
        ; here when not long filenames
d4700 1
a4700 1
        ; root dir is &2nn where nn is ((zones<<1)+1)
d4702 3
a4704 3
        MOV     lr, r2, LSL #1
        ADD     lr, lr, #1
        ADD     lr, lr, #&200
d4708 1
a4708 1
        STR     lr, [r5, #RootDir]      ; root dir disc addr
d4711 1
a4711 1
        B       %FT90
d4715 9
a4723 9
60      ; NEXT LinkBits
        ADD     r3, r3, #1
        CMPS    r3, #Max_LinkBits
        BLS     %BT40

70      ; NEXT zonespare
        ADD     r1, r1, #1
        CMPS    r1, #Max_ZoneSpare
        BLS     %BT20
d4726 4
a4729 4
80      ; NEXT BitSize
        ADD     r0, r0, #1
        CMPS    r0, #Max_BitSize        ; is it too much?
        BLS     %BT10                   ; back around
d4732 1
a4732 1
        Pull    "R0-R11,PC",,^
d4745 12
a4761 12
        MOV     r7, r4          ; keep size of disc around
        TEQS    r4, #0
        BNE     %FT05

; here if zero-size RAM disc;  kill ramfs

        MOV     r0, #ModHandReason_Delete
        ADRL    r1, ramfsname
        SWI     XOS_Module
        B       %FT90

05
d4782 2
a4783 2
        CMP     r4, #0
        BNE     %FT60                   ; here when we actually do owt
d4793 1
a4793 1
        BL      InitRAMDisc
d4797 2
a4798 2
        CLRV
        EXIT
d4800 1
a4800 2

 |   ;NewRAMFS
d4845 1
a4845 1
 ]      ;NewRAMFS
a5082 1

d5093 1
a5093 5
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        MOV     R2, #&100000
        SUB     R2, R2, #1
  ]
d5133 4
a5136 1
  [ ChocolateScreen
a5143 1
    [ ARMSASupport
a5154 11
        MOV     r2,#0
        LDR     r2,[r2,#ARMA_Cleaner_status]
        TST     r2,#ACS_HardVIDMRD
        BEQ     %FT10
        MOV     r2,#IOMD_Base
        MOV     r3,#0
        STR     r3,[r2,#IOMD2_VFLGLO]        ;flag VRAM reads from low VRAM address 0 (start of screen)
        MOV     r3,r1,LSR #(20-1)            ;address specified as multiple of 0.5M, (size will be 1M granularity)
        STR     r3,[r2,#IOMD2_VFLGHI]        ;flag VRAM reads up to VRAM high address of <size>
        LDR     r3,[r2,#IOMD2_VIDMRD]        ;dummy read to clear flag
10
d5161 1
a5161 5
        ARM_read_ID r2
        AND     r2,r2,#&F
        CMP     r2,#SA120minimumrev
        ORRLO   r3,r3,#&03E                  ;domain 1, cacheable, bufferable, section (no mini data cache)
        ORRHS   r3,r3,#&03A                  ;domain 1, mini cacheable, bufferable, section (C=1,B=0, uses mini data cache)
d5164 1
a5164 1
20
d5168 4
a5171 7
        BGT     %BT20
        MOV     r0,#0
        LDR     r1,[r0,#ARMA_Cleaner_status]
        TST     r1,#ACS_HardVIDMRD
        ARMA_read_MMUdomain r0, EQ
        BICEQ   r0,r0,#&C
        ARMA_write_MMUdomain r0, EQ          ;mark domain 1 to fault for VIDMRD emulation, if necessary
a5179 1
    ] ;ARMSASupport
a5186 3
    [ ARMSASupport
        MOV     r0,#6
        SWI     XOS_ScreenMode               ;force screen to be clean
d5193 1
a5193 1
        BIC     r2,r2,#ACS_VSCpending_MASK
d5223 2
a5225 1
    ] ;ARMSASupport
d5228 1
a5228 1
  ] ;ChocolateScreen
@


4.4.4.9
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@a2113 1
; - PCI space and PCI config space added (always reserved on all h/w, for simplicity)
d2118 2
a2119 5
        ASSERT  PCISpace  = PhysSpace + 256*1024*1024
        ASSERT  PCIConfig = PCISpace  + 256*1024*1024
;
FixedAreasTable                                       ; table of fixed areas (logical address, size)
        &  0,                   AplWorkMaxSize        ; application space
d2121 1
a2121 2
        &  CursorChunkAddress,  1504*1024             ; cursor,Nowhere,cache cleaners and reserved
                                                      ; (kernel buffers DA created in what was reserved space)
d2123 1
a2123 1
        &  CursorChunkAddress,  2048*1024             ; cursor,Nowhere,cache cleaners and reserved
d2125 6
a2130 8
        &  &03000000,           16*1024*1024          ; I/O + ROM
        &  L2PT,                (4+1+3)*1024*1024     ; 4M for L2PT (and L1PT), 1M for UNDSTK+SoftCAM, 3M reserved
        &  PhysSpace,           (256+256+4)*1024*1024 ; PhysSpace excluding DRAM, PCI space, PCI config space
                                                      ; (PCI config space must be 4M because of 4M granularity of
                                                      ;  AllocateBackingLevel2 routine used for dynamic areas)
        &  &FF800000,           &007FFFFF             ; Reserved (used to be Shadow ROM), length has been bodged
                                                      ; to avoid wrap problems
        &  -1,                  0                     ; termination
a2874 8
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        CMP     r0, #ChangeDyn_Screen
        MOVEQ   r12,#&100000
        SUBEQ   r12,r12,#1
        ADDEQ   r1, r1, r12
        BICEQ   r1, r1, r12
  ]
a2910 7
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        CMP     r0, #ChangeDyn_Screen
        MOVEQ   lr,#&100000
        SUBEQ   lr,lr,#1
        BICEQ   r1, r1, lr
  ]
a2947 7
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        CMP     r0, #ChangeDyn_Screen
        MOVEQ   lr,#&100000
        SUBEQ   lr,lr,#1
        BICEQ   r1, r1, lr
  ]
a3103 7
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        CMP     r0, #ChangeDyn_Screen
        MOVEQ   lr,#&100000
        SUBEQ   lr,lr,#1
        BICEQ   r1, r1, lr
  ]
d3718 1
a3719 3
;        ASSERT  :LNOT: ARM810support

  [ :LNOT: ARMSASupport_Only
a3721 1
  ]
a3735 1
  [ :LNOT: ARMSASupport_Only
a3738 3
  |
        ORR     r7, r7, #&00E           ;StrongARM  - &55E = L2PT bits for svc access, C=1, B=1
  ]
a3760 1
  [ :LNOT: ARMSASupport_Only
a3762 1
  ]
a3763 1
  [ ARMSASupport
a3780 3
  ] ;ARMSASupport
;
  [ :LNOT: ARMSASupport_Only
d3782 1
a3782 1
;
d3799 1
a3799 1
  ] ; :LNOT: ARMSASupport_Only
d3999 1
a3999 1
        BLEQ    Do_AMB_MakeUnsparse
d4021 1
a4021 1
        BL      Do_AMB_MakeUnsparse
d4026 1
a4026 1
Do_AMB_MakeUnsparse ROUT
d4418 4
a4421 4
DiscSize2       # 4     ; top 32bits of the disc size.  This combines with
                        ; DiscSize to give the full size of the disc.  Note
                        ; that we may have to move DiscStruc to below here
                        ; so we can compare structures properly.
d4424 5
a4428 5
BigFlagBit      * 1     ; bit for the big flag
Zones2          # 1     ; high byte of number of zones
SharePad        # 1     ; padding
DiscVersion     # 4     ; version number of disc format
RootDirSize     # 4     ; size of root dir
d4432 19
a4450 19
SkeletonDiscRec         ;fields marked * need filling in
        =       10      ; sector size 2^10
        =       1       ; sectors per track (this is a RAM disc, after all)
        =       1       ; heads
        =       0       ; density
        =       0       ; * LinkBits
        =       0       ; * BitSize
        =       0       ; skew
        =       0       ; lowsector
        =       0       ; * nzones
        =       0,0     ; * ZoneSpare
        DCD     0       ; * RootDir
        DCD     0       ; * DiscSize
        DCD     0,0,0   ; disc cycle id + disc name
        DCD     0       ; DiscType
        DCD     0       ; DiscSize2
        DCD     0       ; ShareSize,BigFlag,Zones2,Reserved
        DCD     1       ; DiscVersion
        DCD     2048    ; RootSize
d4452 1
a4452 1
        ASSERT  .-SkeletonDiscRec = DiscRecSig2
d4458 3
a4460 3
        Push    "R0-R11,LR"
        ADRL    r0, RAMDisc_DismountStr
        SWI     XOS_CLI
d4464 2
a4465 2
        SUBS    r6, r1, r0
        BEQ     %FT85
d4467 2
a4468 2
        MOV     r1, #4096
        MOV     r2, #0
d4470 3
a4472 3
        STR     r2, [r0], #4
        SUBS    r1, r1, #4
        BNE     %BT10
d4474 1
a4474 1
        SUB     sp, sp, #DiscRecSig2
d4476 1
a4476 1
        ADRL    R0, SkeletonDiscRec     ; source
d4478 2
a4479 2
        MOV     R1, SP                  ; dest
        MOV     R2, #DiscRecSig2        ; length
d4482 4
a4485 4
        LDR     R3, [R0], #4
        STR     R3, [R1], #4
        SUBS    R2, R2, #4
        BNE     %BT20
d4487 1
a4487 1
        STR     R6, [SP, #DiscSize]     ;store away the size
d4489 2
a4490 2
        MOV     r5, SP
        BL      InitDiscRec             ; fill in the disc record fields which need calculation
d4492 6
a4497 6
        MOV     r1, #WriteTrkOp
        ORR     r1, r1, r5, LSL #6
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #1024
        SWI     XRamFS_DiscOp
d4499 1
a4499 1
        BVS     %FT75
d4501 3
a4503 3
        MOV     r0, #&CF
        ADRL    r1, RAMDisc_RAMdisc0Name        ; name ptr
        SWI     XOS_Find                ; find it
d4505 1
a4505 1
        BVS     %FT75                   ; failed to do so
d4507 1
a4507 1
        MOV     R3, R0
d4509 3
a4511 3
        MOV     r0, sp
        ADRL    r1, RAMDisc_EmptyBBList         ; no bad block list
        ADRL    r2, RAMDisc_JustDiscName        ; disc name
d4513 1
a4513 1
        SWI     XFileCore_LayoutStructure
d4515 3
a4517 3
        MOV     r0, #0
        MOV     r1, r3
        SWI     XOS_Find
d4519 2
a4520 2
        ADRL    r0, RAMDisc_DismountStr
        SWI     XOS_CLI
d4522 2
a4523 2
        ADRL    r0, RAMDisc_MountStr
        SWI     XOS_CLI
d4526 1
a4526 1
        ADD     sp, sp, #DiscRecSig2
d4529 2
a4530 2
        STRVS   r0, [sp]
        Pull    "R0-R11,PC"
d4534 1
a4534 1
        DCD     -1
d4536 2
a4537 2
        DCB     "RamDisc0",0
        ALIGN
d4542 1
a4542 1
        DCB     "RAM:Dismount :0",0
d4544 2
a4545 2
        DCB     "RAM:mount :0",0
        ALIGN
d4565 8
a4572 8
Min_LinkBits    *       13      ; minimum allowed LinkBits (with 1024 byte zones)
Max_LinkBits    *       19      ; maximum allowed LinkBits (unlikely!)
Min_BitSize     *       7       ; minimum allowed bitsize
Max_BitSize     *       12      ; max allowed bitsize
Min_ZoneSpare   *       32      ; min allowed zonespare
Max_ZoneSpare   *       64      ; max allowed zonespare
Min_Zones       *       1       ; min allowed zones
Max_Zones       *       16      ; max allowed zones
d4588 2
a4589 2
InitDiscRec     ROUT
        Push    "R0-R11,LR"
d4591 1
a4591 1
        MOV     r0, #Min_BitSize        ; init BitSize
d4593 3
a4595 3
10      ; loop on BitSize
        LDR     r4, [r5, #DiscSize]
        MOV     r4, r4, LSR r0          ; map bits for disc
d4597 2
a4598 2
        MOV     r1, #Min_ZoneSpare      ; init ZoneSpare
20      ; loop on zonespare
d4600 4
a4603 4
        LDR     lr, [r5, #SectorSize]
        MOV     r6, #8
        MOV     r6, r6, LSL lr          ; bits in a zone
        SUB     r6, r6, r1              ; minus sparebits
d4605 1
a4605 1
        ; choose number of zones to suit
d4607 2
a4608 2
        MOV     r2, #Min_Zones          ; minimum of one zone
        SUB     r7, r6, #Zone0Bits      ; bits in zone 0
d4610 3
a4612 3
30      ; loop for zones
        CMP     r7, r4                  ; do we have enough allocation bits yet?
        BHS     %FT35                   ; if we do, then accept this number of zones
d4614 4
a4617 4
        ADD     r7, r7, r6              ; more map bits
        ADD     r2, r2, #1              ; and another zone
        CMPS    r2, #Max_Zones
        BLS     %BT30                   ; still ok
d4619 1
a4619 1
        ; here when too many zones; try a higher BitSize
d4621 1
a4621 1
        B       %FT80
d4624 2
a4625 2
        ; now we have to choose LinkBits.  we want LinkBits to be
        ; the smallest it can be for the disc.
d4627 1
a4627 1
        MOV     r3, #Min_LinkBits               ; minimum value of LinkBits
d4629 1
a4629 1
40      ; loop for LinkBits
d4631 5
a4635 5
        Push    "R0, R1, R2"
        MOV     r0, r6                  ; allocation bits in a zone
        ADD     r1, r3, #1              ; LinkBits+1
        DivRem  r8, r0, r1, r2
        Pull    "R0, R1, R2"
d4637 3
a4639 3
        ; check that LinkBits is enough for total possible ids
        MOV     r9, #1                  ; work out 1<<LinkBits
        MOV     r9, r9, LSL r3          ;
d4641 3
a4643 3
        MUL     lr, r8, r2              ; total ids needed
        CMPS    lr, r9                  ; LinkBits too small?
        BHI     %FT60                   ; yes!
d4645 2
a4646 2
        ; we're nearly there.  now work out if the last zone
        ; can be handled correctly.
d4648 2
a4649 2
        SUBS    lr, r7, r4
        BEQ     %FT50
d4651 2
a4652 2
        CMPS    lr, r3                  ; must be at least LinkBits+1 bits
        BLE     %FT60
d4654 1
a4654 1
        ; check also that we're not too close to the start of the zone
d4656 1
a4656 1
        SUB     lr, r7, r6              ; get the start of the zone
d4658 3
a4660 3
        SUB     lr, r4, lr              ;
        CMPS    lr, r3
        BLE     %FT60
d4663 1
a4663 1
50      ; we've found a result - fill in the disc record!
d4665 1
a4665 1
        ; first, store the things we know about
d4667 3
a4669 3
        STRB    r3,[r5, #LinkBits]
        MOV     r1, r1, LSL #16
        ORR     r1, r1, r2, LSL #8
d4671 1
a4671 1
        STR     r1, [r5, #ZoneSpare-2]
d4673 1
a4673 1
        STRB    r0, [r5, #BitSize]
d4675 1
a4675 1
        LDR     lr, [r5, #DiscVersion]
d4677 1
a4677 1
        MOVS    lr, lr
d4679 1
a4679 1
        BEQ     %FT01                   ; do we have long filenames?
d4681 1
a4681 1
        ; here when long filenames
d4683 2
a4684 2
        ; the root dir's ID is the first available ID in the middle
        ; zone of the map
d4687 1
a4687 1
        MOVS    r2, r2, LSR #1          ; zones/2
d4689 2
a4690 2
        MULNE   lr, r2, r8              ; *idsperzone
        MOVEQ   lr, #3                  ; if if zones/2=0, then only one zone, so the id is 3 (0,1,2 reserved)
d4692 2
a4693 2
        MOV     lr, lr, LSL #8          ; construct full indirect disc address
        ORR     lr, lr, #1              ; with sharing offset of 1
d4695 1
a4695 1
        B       %FT02
d4698 1
a4698 1
        ; here when not long filenames
d4700 1
a4700 1
        ; root dir is &2nn where nn is ((zones<<1)+1)
d4702 3
a4704 3
        MOV     lr, r2, LSL #1
        ADD     lr, lr, #1
        ADD     lr, lr, #&200
d4708 1
a4708 1
        STR     lr, [r5, #RootDir]      ; root dir disc addr
d4711 1
a4711 1
        B       %FT90
d4715 9
a4723 9
60      ; NEXT LinkBits
        ADD     r3, r3, #1
        CMPS    r3, #Max_LinkBits
        BLS     %BT40

70      ; NEXT zonespare
        ADD     r1, r1, #1
        CMPS    r1, #Max_ZoneSpare
        BLS     %BT20
d4726 4
a4729 4
80      ; NEXT BitSize
        ADD     r0, r0, #1
        CMPS    r0, #Max_BitSize        ; is it too much?
        BLS     %BT10                   ; back around
d4732 1
a4732 1
        Pull    "R0-R11,PC",,^
d4745 12
a4761 12
        MOV     r7, r4          ; keep size of disc around
        TEQS    r4, #0
        BNE     %FT05

; here if zero-size RAM disc;  kill ramfs

        MOV     r0, #ModHandReason_Delete
        ADRL    r1, ramfsname
        SWI     XOS_Module
        B       %FT90

05
d4782 2
a4783 2
        CMP     r4, #0
        BNE     %FT60                   ; here when we actually do owt
d4793 1
a4793 1
        BL      InitRAMDisc
d4797 2
a4798 2
        CLRV
        EXIT
d4800 1
a4800 2

 |   ;NewRAMFS
d4845 1
a4845 1
 ]      ;NewRAMFS
a5082 1

d5093 1
a5093 5
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        MOV     R2, #&100000
        SUB     R2, R2, #1
  ]
d5133 4
a5136 1
  [ ChocolateScreen
a5143 1
    [ ARMSASupport
a5154 11
        MOV     r2,#0
        LDR     r2,[r2,#ARMA_Cleaner_status]
        TST     r2,#ACS_HardVIDMRD
        BEQ     %FT10
        MOV     r2,#IOMD_Base
        MOV     r3,#0
        STR     r3,[r2,#IOMD2_VFLGLO]        ;flag VRAM reads from low VRAM address 0 (start of screen)
        MOV     r3,r1,LSR #(20-1)            ;address specified as multiple of 0.5M, (size will be 1M granularity)
        STR     r3,[r2,#IOMD2_VFLGHI]        ;flag VRAM reads up to VRAM high address of <size>
        LDR     r3,[r2,#IOMD2_VIDMRD]        ;dummy read to clear flag
10
d5161 1
a5161 5
        ARM_read_ID r2
        AND     r2,r2,#&F
        CMP     r2,#SA120minimumrev
        ORRLO   r3,r3,#&03E                  ;domain 1, cacheable, bufferable, section (no mini data cache)
        ORRHS   r3,r3,#&03A                  ;domain 1, mini cacheable, bufferable, section (C=1,B=0, uses mini data cache)
d5164 1
a5164 1
20
d5168 4
a5171 7
        BGT     %BT20
        MOV     r0,#0
        LDR     r1,[r0,#ARMA_Cleaner_status]
        TST     r1,#ACS_HardVIDMRD
        ARMA_read_MMUdomain r0, EQ
        BICEQ   r0,r0,#&C
        ARMA_write_MMUdomain r0, EQ          ;mark domain 1 to fault for VIDMRD emulation, if necessary
a5179 1
    ] ;ARMSASupport
a5186 3
    [ ARMSASupport
        MOV     r0,#6
        SWI     XOS_ScreenMode               ;force screen to be clean
d5193 1
a5193 1
        BIC     r2,r2,#ACS_VSCpending_MASK
d5223 2
a5225 1
    ] ;ARMSASupport
d5228 1
a5228 1
  ] ;ChocolateScreen
@


4.3
log
@RISC OS 3.71 kernel changes merged.
Not fully tested on all hardware permutations.
@
text
@d107 2
a108 2
 [ STB
DAHandler_TestShrink	*	4	; new reason added to find amount area could shrink by
d1714 1
a1714 1
 [ STB
d1735 2
a1736 2
 [ STB
DynAreaFlags_Shrinkable	*	1 :SHL: 9	; whether area should be shrunk when need more space in free pool
d1777 2
a1778 2
 [ STB
	B	DynArea_ReturnFree
d2178 1
a2178 1
 [ STB
d2181 1
a2181 1
;	DynArea_ReturnFree - Return total free space, including shrinkables
d2183 1
a2183 1
;	Internal routine called by DynamicAreaSWI
d2185 2
a2186 2
; in:	r0 = reason code (5)
;	r1 = area number to exclude, or -1 to include all shrinkable areas
d2188 1
a2188 1
; out:	r2 = total amount of free memory
d2192 3
a2194 3
	CMP	r1, #-1				; if no excluded area,
	MOVEQ	r10, r1				; then point r10 nowhere
	BEQ	%FT10
d2196 2
a2197 2
	BL	CheckAreaNumber			; else check area number is valid
	BCC	UnknownDyn			; [unknown area]
d2199 3
a2201 3
	MOV	r11, #DAList
	MOV	r2, #0
	LDR	r2, [r2, #FreePoolDANode + DANode_Size] ; start with current size of free pool
d2203 8
a2210 8
	LDR	r11, [r11, #DANode_Link]	; load next area
	TEQ	r11, #0				; if end of list
	EXIT	EQ				; then exit, with r2 = correct value

	LDR	lr, [r11, #DANode_Flags]	; load area flags
	TST	lr, #DynAreaFlags_Shrinkable	; must be shrinkable
	TEQNE	r11, r10			; and not excluded area
	BEQ	%BT20				; [don't try this one]
d2213 4
a2216 4
	BL	CallTestShrink
	ADD	r2, r2, r3			; add on amount if any
	Pull    r3
	B	%BT20				; then go back for more
d2683 1
a2683 1
	LTORG
d2808 4
a2811 4
 [ STB
	CMP	r1, lr
	MOVHI	r1, lr				; r1 = the most we want to move if we could
	BLHI	GenNotAllMovedError		; but if not all we still want error
d2817 1
a2817 1
 [ STB
d2819 3
a2821 3
	CMP	r2, r1
	BLCC	TryToShrinkShrinkables
	BCS	%FT15				; [we can now do it all]
d2994 1
a2994 1
 [ STB
d2998 2
a2999 2
	CMP	r1, lr				; if dest can't grow by this amount,
	BHI	%FT64				; we're definitely not doing anything
d3001 6
a3006 6
	CMP	r2, r1				; this should definitely set C=0 as required by TryToShrinkShrinkables
	Push	"lr"
	BLCC	TryToShrinkShrinkables
	Pull	"lr"
	MOVCS	r3, r1				; if succeeded set r3 to number of bytes to do
	BCS	%FT65				; and do it
d3173 1
a3173 1
 [ STB
d3176 1
a3176 1
;	TryToShrinkShrinkables - Attempt to make more space by shrinking shrinkable areas if appropriate
d3178 9
a3186 9
; in:	r1 = total amount we wish to have in src area (already limited by max_size of destination area)
;	r2 = current size of src area
;	r11 -> src area node (we don't do anything unless this is the free pool)
;	r12 -> dst area node
;	C = 0
;
; out:	r2 = new size of src area
;	C=0 => failed to move as much as we wanted
;	C=1 => succeeded in moving as much as we wanted
d3189 3
a3191 3
	LDR	lr, [r11, #DANode_Number]
	TEQ	lr, #ChangeDyn_FreePool
	EXITS	NE				; if src <> free pool, exit with flags intact
d3199 21
a3219 21
	TEQ	r10, r12			; check area <> dest
	LDRNE	lr, [r10, #DANode_Flags]	; and area is shrinkable
	TSTNE	lr, #DynAreaFlags_Shrinkable
	BEQ	%BT10				; if not, try next area

	SUBS	r1, r1, r2			; r1 = amount we still need
	LDR	lr, [r10, #DANode_Size]		; available size of this area
	CMP	lr, r1
	MOVCC	r1, lr				; min(amount we need, size of this area)
	RSB	r1, r1, #0			; make negative - it's a shrink
	MOV	r0, #0
	STR	r0, [r0, #CDASemaphore]		; momentarily pretend we're not threaded
	LDR	r0, [r10, #DANode_Number]
	SWI	XOS_ChangeDynamicArea
	MOV	r0, #1
	STR	r0, [r0, #CDASemaphore-1]	; we're threaded again
	LDR	r1, [sp, #4]			; reload original r1
	LDR	r2, [r11, #DANode_Size]		; get new size of src area
	CMP	r2, r1
	BCC	%BT10				; if still too small, loop
	EXIT					; exit CS indicating success
d3957 1
a3957 1
 [ STB
d3975 2
a3976 2
	MOV	r5, #0
	LDR	r5, [r5, #Page_Size]			; set r5 = page size
d3994 1
a3994 1
	MOV	r3, #0					; indicate no shrink possible
@


4.2
log
@Kernel merged
@
text
@d3442 9
@


4.1
log
@Initial revision
@
text
@d107 3
d1714 4
d1719 1
d1734 15
d1760 1
d1777 3
d2178 41
d2575 1
a2575 1
        SetCop  lr, CR_TLBFlush                         ; junk the TLB (probably not necessary)
a2585 2
        LTORG

d2683 2
d2808 19
d2837 1
d2993 19
d3173 49
d3427 15
d3947 42
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a106 1
DAHandler_TestShrink	*	4	; new reason added to find amount area could shrink by
d1711 1
a1711 2
DAReason_ReturnFree *   5
DAReason_Limit  *       6
a1725 1
DynAreaFlags_Shrinkable	*	1 :SHL: 9	; whether area should be shrunk when need more space in free pool
d1730 1
a1730 1
TempUncacheableShift    *       10
d1732 1
a1732 1
PageFlags_Unavailable   *       1 :SHL: 14      ; physical page may not be requested by a PreShrink handler
d1736 1
a1736 1
PageFlags_Required      *       1 :SHL: 15      ; physical page asked for by handler
a1752 1
	B	DynArea_ReturnFree
a2152 39
;	DynArea_ReturnFree - Return total free space, including shrinkables
;
;	Internal routine called by DynamicAreaSWI
;
; in:	r0 = reason code (5)
;	r1 = area number to exclude, or -1 to include all shrinkable areas
;
; out:	r2 = total amount of free memory
;

DynArea_ReturnFree ALTENTRY
	CMP	r1, #-1				; if no excluded area,
	MOVEQ	r10, r1				; then point r10 nowhere
	BEQ	%FT10

	BL	CheckAreaNumber			; else check area number is valid
	BCC	UnknownDyn			; [unknown area]
10
	MOV	r11, #DAList
	MOV	r2, #0
	LDR	r2, [r2, #FreePoolDANode + DANode_Size] ; start with current size of free pool
20
	LDR	r11, [r11, #DANode_Link]	; load next area
	TEQ	r11, #0				; if end of list
	EXIT	EQ				; then exit, with r2 = correct value

	LDR	lr, [r11, #DANode_Flags]	; load area flags
	TST	lr, #DynAreaFlags_Shrinkable	; must be shrinkable
	TEQNE	r11, r10			; and not excluded area
	BEQ	%BT20				; [don't try this one]

        Push    r3
	BL	CallTestShrink
	ADD	r2, r2, r3			; add on amount if any
	Pull    r3
	B	%BT20				; then go back for more

;**************************************************************************
;
d2518 2
a2616 2
	LTORG

d2740 3
a2742 6
	CMP	r1, lr
	MOVHI	r1, lr				; r1 = the most we want to move if we could
	BLHI	GenNotAllMovedError		; but if not all we still want error
        SUB     lr, r5, #1                      ; lr = pagesize mask
        BICS    r1, r1, lr                      ; a pagesize multiple
        BEQ     IssueServiceMemoryMoved
d2744 2
a2745 4
        LDR     r2, [r11, #DANode_Size]         ; amount src could shrink
	CMP	r2, r1
	BLCC	TryToShrinkShrinkables
	BCS	%FT15				; [we can now do it all]
d2749 1
a2749 1
        MOV     r1, r2                          ; move smaller amount
a2904 17

; growing another area from free pool
; insert code here to check for shrinking shrinkable areas

	CMP	r1, lr				; if dest can't grow by this amount,
	BHI	%FT64				; we're definitely not doing anything

	CMP	r2, r1				; this should definitely set C=0 as required by TryToShrinkShrinkables
	Push	"lr"
	BLCC	TryToShrinkShrinkables
	Pull	"lr"
	MOVCS	r3, r1				; if succeeded set r3 to number of bytes to do
	BCS	%FT65				; and do it
64

; end of inserted code

a3067 47
;	TryToShrinkShrinkables - Attempt to make more space by shrinking shrinkable areas if appropriate
;
; in:	r1 = total amount we wish to have in src area (already limited by max_size of destination area)
;	r2 = current size of src area
;	r11 -> src area node (we don't do anything unless this is the free pool)
;	r12 -> dst area node
;	C = 0
;
; out:	r2 = new size of src area
;	C=0 => failed to move as much as we wanted
;	C=1 => succeeded in moving as much as we wanted

TryToShrinkShrinkables Entry "r0,r1,r10"
	LDR	lr, [r11, #DANode_Number]
	TEQ	lr, #ChangeDyn_FreePool
	EXITS	NE				; if src <> free pool, exit with flags intact

        MOV     r10, #DAList
        ASSERT  DANode_Link = 0                 ; because DAList has only link
10
        LDR     r10, [r10, #DANode_Link]        ; and load next
        CMP     r10, #1                         ; any more nodes?
        EXIT    CC                              ; no, then no match
	TEQ	r10, r12			; check area <> dest
	LDRNE	lr, [r10, #DANode_Flags]	; and area is shrinkable
	TSTNE	lr, #DynAreaFlags_Shrinkable
	BEQ	%BT10				; if not, try next area

	SUBS	r1, r1, r2			; r1 = amount we still need
	LDR	lr, [r10, #DANode_Size]		; available size of this area
	CMP	lr, r1
	MOVCC	r1, lr				; min(amount we need, size of this area)
	RSB	r1, r1, #0			; make negative - it's a shrink
	MOV	r0, #0
	STR	r0, [r0, #CDASemaphore]		; momentarily pretend we're not threaded
	LDR	r0, [r10, #DANode_Number]
	SWI	XOS_ChangeDynamicArea
	MOV	r0, #1
	STR	r0, [r0, #CDASemaphore-1]	; we're threaded again
	LDR	r1, [sp, #4]			; reload original r1
	LDR	r2, [r11, #DANode_Size]		; get new size of src area
	CMP	r2, r1
	BCC	%BT10				; if still too small, loop
	EXIT					; exit CS indicating success

; ***********************************************************************************
;
a3774 40
        EXIT

; ***********************************************************************************
;
;       CallTestShrink - Call test-shrink routine
;
; in:   r11 -> area node
;
; out:  If handler exits VC, then r3 = no. of bytes area can shrink by
;       else r0 -> error block or 0 for generic error, and r3=0
;

CallTestShrink ENTRY "r0,r4,r5, r12"
        LDR     r0, [r11, #DANode_Handler]              ; check if no handler
        CMP     r0, #0                                  ; if none (V=0)
        EXIT    EQ                                      ; then exit

        MOV     r0, #DAHandler_TestShrink               ; r0 = reason code
        LDR     r4, [r11, #DANode_Size]                 ; r4 = current size
	MOV	r5, #0
	LDR	r5, [r5, #Page_Size]			; set r5 = page size
        ASSERT  DANode_Handler = DANode_Workspace +4
        ADD     r12, r11, #DANode_Workspace
        MOV     lr, pc
        LDMIA   r12, {r12, pc}                          ; load workspace pointer and jump to handler

; shrink amount returned by handler may not be page multiple (according to spec),
; so we'd better make it so.

        SUBVC   lr, r5, #1
        BICVC   r3, r3, lr                              ; make page multiple
        EXIT    VC
        TEQ     r0, #0                                  ; if generic error returned
        ADREQL  r0, ErrorBlock_ChDynamNotAllMoved       ; then substitute real error message
 [ International
        BLEQ    TranslateError
 ]
        STR     r0, [sp]
	MOV	r3, #0					; indicate no shrink possible
        SETV
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a106 1
DAHandler_TestShrink	*	4	; new reason added to find amount area could shrink by
d1711 1
a1711 2
DAReason_ReturnFree *   5
DAReason_Limit  *       6
a1725 1
DynAreaFlags_Shrinkable	*	1 :SHL: 9	; whether area should be shrunk when need more space in free pool
d1730 1
a1730 1
TempUncacheableShift    *       10
d1732 1
a1732 1
PageFlags_Unavailable   *       1 :SHL: 14      ; physical page may not be requested by a PreShrink handler
d1736 1
a1736 1
PageFlags_Required      *       1 :SHL: 15      ; physical page asked for by handler
a1752 1
	B	DynArea_ReturnFree
a2152 39
;	DynArea_ReturnFree - Return total free space, including shrinkables
;
;	Internal routine called by DynamicAreaSWI
;
; in:	r0 = reason code (5)
;	r1 = area number to exclude, or -1 to include all shrinkable areas
;
; out:	r2 = total amount of free memory
;

DynArea_ReturnFree ALTENTRY
	CMP	r1, #-1				; if no excluded area,
	MOVEQ	r10, r1				; then point r10 nowhere
	BEQ	%FT10

	BL	CheckAreaNumber			; else check area number is valid
	BCC	UnknownDyn			; [unknown area]
10
	MOV	r11, #DAList
	MOV	r2, #0
	LDR	r2, [r2, #FreePoolDANode + DANode_Size] ; start with current size of free pool
20
	LDR	r11, [r11, #DANode_Link]	; load next area
	TEQ	r11, #0				; if end of list
	EXIT	EQ				; then exit, with r2 = correct value

	LDR	lr, [r11, #DANode_Flags]	; load area flags
	TST	lr, #DynAreaFlags_Shrinkable	; must be shrinkable
	TEQNE	r11, r10			; and not excluded area
	BEQ	%BT20				; [don't try this one]

        Push    r3
	BL	CallTestShrink
	ADD	r2, r2, r3			; add on amount if any
	Pull    r3
	B	%BT20				; then go back for more

;**************************************************************************
;
d2518 2
a2616 2
	LTORG

d2740 3
a2742 6
	CMP	r1, lr
	MOVHI	r1, lr				; r1 = the most we want to move if we could
	BLHI	GenNotAllMovedError		; but if not all we still want error
        SUB     lr, r5, #1                      ; lr = pagesize mask
        BICS    r1, r1, lr                      ; a pagesize multiple
        BEQ     IssueServiceMemoryMoved
d2744 2
a2745 4
        LDR     r2, [r11, #DANode_Size]         ; amount src could shrink
	CMP	r2, r1
	BLCC	TryToShrinkShrinkables
	BCS	%FT15				; [we can now do it all]
d2749 1
a2749 1
        MOV     r1, r2                          ; move smaller amount
a2904 17

; growing another area from free pool
; insert code here to check for shrinking shrinkable areas

	CMP	r1, lr				; if dest can't grow by this amount,
	BHI	%FT64				; we're definitely not doing anything

	CMP	r2, r1				; this should definitely set C=0 as required by TryToShrinkShrinkables
	Push	"lr"
	BLCC	TryToShrinkShrinkables
	Pull	"lr"
	MOVCS	r3, r1				; if succeeded set r3 to number of bytes to do
	BCS	%FT65				; and do it
64

; end of inserted code

a3067 47
;	TryToShrinkShrinkables - Attempt to make more space by shrinking shrinkable areas if appropriate
;
; in:	r1 = total amount we wish to have in src area (already limited by max_size of destination area)
;	r2 = current size of src area
;	r11 -> src area node (we don't do anything unless this is the free pool)
;	r12 -> dst area node
;	C = 0
;
; out:	r2 = new size of src area
;	C=0 => failed to move as much as we wanted
;	C=1 => succeeded in moving as much as we wanted

TryToShrinkShrinkables Entry "r0,r1,r10"
	LDR	lr, [r11, #DANode_Number]
	TEQ	lr, #ChangeDyn_FreePool
	EXITS	NE				; if src <> free pool, exit with flags intact

        MOV     r10, #DAList
        ASSERT  DANode_Link = 0                 ; because DAList has only link
10
        LDR     r10, [r10, #DANode_Link]        ; and load next
        CMP     r10, #1                         ; any more nodes?
        EXIT    CC                              ; no, then no match
	TEQ	r10, r12			; check area <> dest
	LDRNE	lr, [r10, #DANode_Flags]	; and area is shrinkable
	TSTNE	lr, #DynAreaFlags_Shrinkable
	BEQ	%BT10				; if not, try next area

	SUBS	r1, r1, r2			; r1 = amount we still need
	LDR	lr, [r10, #DANode_Size]		; available size of this area
	CMP	lr, r1
	MOVCC	r1, lr				; min(amount we need, size of this area)
	RSB	r1, r1, #0			; make negative - it's a shrink
	MOV	r0, #0
	STR	r0, [r0, #CDASemaphore]		; momentarily pretend we're not threaded
	LDR	r0, [r10, #DANode_Number]
	SWI	XOS_ChangeDynamicArea
	MOV	r0, #1
	STR	r0, [r0, #CDASemaphore-1]	; we're threaded again
	LDR	r1, [sp, #4]			; reload original r1
	LDR	r2, [r11, #DANode_Size]		; get new size of src area
	CMP	r2, r1
	BCC	%BT10				; if still too small, loop
	EXIT					; exit CS indicating success

; ***********************************************************************************
;
a3774 40
        EXIT

; ***********************************************************************************
;
;       CallTestShrink - Call test-shrink routine
;
; in:   r11 -> area node
;
; out:  If handler exits VC, then r3 = no. of bytes area can shrink by
;       else r0 -> error block or 0 for generic error, and r3=0
;

CallTestShrink ENTRY "r0,r4,r5, r12"
        LDR     r0, [r11, #DANode_Handler]              ; check if no handler
        CMP     r0, #0                                  ; if none (V=0)
        EXIT    EQ                                      ; then exit

        MOV     r0, #DAHandler_TestShrink               ; r0 = reason code
        LDR     r4, [r11, #DANode_Size]                 ; r4 = current size
	MOV	r5, #0
	LDR	r5, [r5, #Page_Size]			; set r5 = page size
        ASSERT  DANode_Handler = DANode_Workspace +4
        ADD     r12, r11, #DANode_Workspace
        MOV     lr, pc
        LDMIA   r12, {r12, pc}                          ; load workspace pointer and jump to handler

; shrink amount returned by handler may not be page multiple (according to spec),
; so we'd better make it so.

        SUBVC   lr, r5, #1
        BICVC   r3, r3, lr                              ; make page multiple
        EXIT    VC
        TEQ     r0, #0                                  ; if generic error returned
        ADREQL  r0, ErrorBlock_ChDynamNotAllMoved       ; then substitute real error message
 [ International
        BLEQ    TranslateError
 ]
        STR     r0, [sp]
	MOV	r3, #0					; indicate no shrink possible
        SETV
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d2507 1
a2507 1
        ARM_flush_TLB r6                                ; junk TLB(s) (probably not needed)
a3269 15

  [ StrongARM
    ;
    ;Ahem! The data is moved to new pages by reading old pages via 'physical address' (flat copy of
    ;      physical space at virtual addr. 2G). This means data read may not be up to date wrt data in
    ;      StrongARM's write-back cache, and is a potential cache incoherency anyway (two virtual mappings
    ;      to one physical).
    ;      So, clean/flush StrongARM data cache wrt to pages first. Incidentally, since StrongARM does
    ;      not support burst read LDMs from uncacheable areas, the read is going to be a little slow anyway).
    ;
    ;
    ARM_number r0
    CMP     r0,#&A
    BLEQ    dtgps_SAcleanflush
  ]
@


4.1.3.2
log
@RISC OS 3.71 version taken
@
text
@a3285 9
  [ ARM810support
    ;
    ; ARM810 has writeback cache too
    ;
    ARM_number r0
    CMP     r0,#8
    BLEQ    dtgps_810cleanflush
  ]

@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@a3285 9
  [ ARM810support
    ;
    ; ARM810 has writeback cache too
    ;
    ARM_number r0
    CMP     r0,#8
    BLEQ    dtgps_810cleanflush
  ]

@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

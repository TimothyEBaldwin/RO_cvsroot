head	4.16;
access;
symbols
	Kernel-6_15:4.16
	Kernel-6_14:4.16
	Kernel-6_01-3:4.14
	Kernel-6_13:4.15
	Kernel-6_12:4.15
	Kernel-6_11:4.15
	Kernel-6_10:4.15
	Kernel-6_09:4.15
	Kernel-6_08-4_129_2_10:4.14.2.1
	Kernel-6_08-4_129_2_9:4.14.2.1
	Kernel-6_08:4.14
	Kernel-6_07:4.14
	Kernel-6_06:4.14
	Kernel-6_05-4_129_2_8:4.14.2.1
	Kernel-6_05:4.14
	Kernel-6_04:4.14
	Kernel-6_03:4.14
	Kernel-6_01-2:4.14
	Kernel-6_01-4_146_2_1:4.14
	Kernel-6_02:4.14
	Kernel-6_01-1:4.14
	Kernel-6_01:4.14
	Kernel-6_00:4.14
	Kernel-5_99:4.14
	Kernel-5_98:4.14
	Kernel-5_97-4_129_2_7:4.14.2.1
	Kernel-5_97:4.14
	Kernel-5_96:4.14
	Kernel-5_95:4.14
	Kernel-5_94:4.14
	Kernel-5_93:4.14
	Kernel-5_92:4.14
	Kernel-5_91:4.14
	Kernel-5_90:4.14
	Kernel-5_89-4_129_2_6:4.14.2.1
	Kernel-5_89:4.14
	Kernel-5_88-4_129_2_5:4.14.2.1
	Kernel-5_88-4_129_2_4:4.14.2.1
	Kernel-5_88:4.14
	Kernel-5_87:4.14
	Kernel-5_86-4_129_2_3:4.14.2.1
	Kernel-5_86-4_129_2_2:4.14.2.1
	Kernel-5_86-4_129_2_1:4.14
	Kernel-5_86:4.14
	SMP:4.14.0.2
	SMP_bp:4.14
	Kernel-5_85:4.14
	Kernel-5_54-1:4.14
	Kernel-5_84:4.14
	Kernel-5_83:4.14
	Kernel-5_82:4.14
	Kernel-5_81:4.14
	Kernel-5_80:4.14
	Kernel-5_79:4.14
	Kernel-5_78:4.14
	Kernel-5_77:4.14
	Kernel-5_76:4.14
	Kernel-5_75:4.14
	Kernel-5_74:4.14
	Kernel-5_73:4.14
	Kernel-5_72:4.14
	Kernel-5_71:4.14
	Kernel-5_70:4.14
	Kernel-5_69:4.14
	Kernel-5_68:4.14
	Kernel-5_67:4.14
	Kernel-5_66:4.14
	Kernel-5_65:4.14
	Kernel-5_64:4.14
	Kernel-5_63:4.14
	Kernel-5_62:4.14
	Kernel-5_61:4.14
	Kernel-5_60:4.14
	Kernel-5_59:4.14
	Kernel-5_58:4.14
	Kernel-5_57:4.14
	Kernel-5_56:4.14
	Kernel-5_55:4.14
	Kernel-5_54:4.14
	Kernel-5_53:4.14
	Kernel-5_52:4.14
	Kernel-5_51:4.14
	Kernel-5_50:4.13
	Kernel-5_49:4.13
	HAL_merge:4.10.2.27
	Kernel-5_48:4.12
	Kernel-5_35-4_79_2_327:4.10.2.27
	Kernel-5_35-4_79_2_326:4.10.2.26
	Kernel-5_35-4_79_2_325:4.10.2.26
	Kernel-5_35-4_79_2_324:4.10.2.26
	Kernel-5_35-4_79_2_323:4.10.2.26
	Kernel-5_35-4_79_2_322:4.10.2.26
	Kernel-5_35-4_79_2_321:4.10.2.26
	Kernel-5_35-4_79_2_320:4.10.2.26
	Kernel-5_35-4_79_2_319:4.10.2.26
	Kernel-5_35-4_79_2_318:4.10.2.26
	Kernel-5_35-4_79_2_317:4.10.2.26
	Kernel-5_35-4_79_2_316:4.10.2.26
	Kernel-5_35-4_79_2_315:4.10.2.26
	Kernel-5_35-4_79_2_314:4.10.2.26
	Kernel-5_35-4_79_2_313:4.10.2.26
	Kernel-5_35-4_79_2_312:4.10.2.26
	Kernel-5_35-4_79_2_311:4.10.2.26
	Kernel-5_35-4_79_2_310:4.10.2.26
	Kernel-5_35-4_79_2_309:4.10.2.26
	Kernel-5_35-4_79_2_308:4.10.2.26
	Kernel-5_35-4_79_2_307:4.10.2.26
	Kernel-5_35-4_79_2_306:4.10.2.26
	Kernel-5_35-4_79_2_305:4.10.2.26
	Kernel-5_35-4_79_2_304:4.10.2.26
	Kernel-5_35-4_79_2_303:4.10.2.26
	Kernel-5_35-4_79_2_302:4.10.2.26
	Kernel-5_35-4_79_2_301:4.10.2.26
	Kernel-5_35-4_79_2_300:4.10.2.26
	Kernel-5_35-4_79_2_299:4.10.2.26
	Kernel-5_35-4_79_2_298:4.10.2.26
	Kernel-5_35-4_79_2_297:4.10.2.26
	Kernel-5_35-4_79_2_296:4.10.2.26
	Kernel-5_35-4_79_2_295:4.10.2.26
	Kernel-5_35-4_79_2_294:4.10.2.26
	Kernel-5_35-4_79_2_293:4.10.2.26
	Kernel-5_35-4_79_2_292:4.10.2.26
	Kernel-5_35-4_79_2_291:4.10.2.26
	Kernel-5_35-4_79_2_290:4.10.2.26
	Kernel-5_35-4_79_2_289:4.10.2.26
	Kernel-5_35-4_79_2_288:4.10.2.26
	Kernel-5_35-4_79_2_287:4.10.2.26
	Kernel-5_35-4_79_2_286:4.10.2.26
	Kernel-5_35-4_79_2_285:4.10.2.26
	Kernel-5_35-4_79_2_284:4.10.2.26
	Kernel-5_35-4_79_2_283:4.10.2.26
	Kernel-5_35-4_79_2_282:4.10.2.26
	Kernel-5_35-4_79_2_281:4.10.2.26
	Kernel-5_35-4_79_2_280:4.10.2.26
	Kernel-5_35-4_79_2_279:4.10.2.26
	Kernel-5_35-4_79_2_278:4.10.2.26
	Kernel-5_35-4_79_2_277:4.10.2.26
	Kernel-5_35-4_79_2_276:4.10.2.26
	Kernel-5_35-4_79_2_275:4.10.2.26
	Kernel-5_35-4_79_2_274:4.10.2.26
	Kernel-5_35-4_79_2_273:4.10.2.26
	Kernel-5_35-4_79_2_272:4.10.2.26
	Kernel-5_35-4_79_2_271:4.10.2.26
	Kernel-5_35-4_79_2_270:4.10.2.26
	Kernel-5_35-4_79_2_269:4.10.2.26
	Kernel-5_35-4_79_2_268:4.10.2.26
	Kernel-5_35-4_79_2_267:4.10.2.26
	Kernel-5_35-4_79_2_266:4.10.2.26
	Kernel-5_35-4_79_2_265:4.10.2.26
	Kernel-5_35-4_79_2_264:4.10.2.26
	Kernel-5_35-4_79_2_263:4.10.2.26
	Kernel-5_35-4_79_2_262:4.10.2.26
	Kernel-5_35-4_79_2_261:4.10.2.26
	Kernel-5_35-4_79_2_260:4.10.2.26
	Kernel-5_35-4_79_2_259:4.10.2.26
	Kernel-5_35-4_79_2_258:4.10.2.26
	Kernel-5_35-4_79_2_257:4.10.2.26
	Kernel-5_35-4_79_2_256:4.10.2.26
	Kernel-5_35-4_79_2_255:4.10.2.26
	Kernel-5_35-4_79_2_254:4.10.2.26
	Kernel-5_35-4_79_2_253:4.10.2.26
	Kernel-5_35-4_79_2_252:4.10.2.26
	Kernel-5_35-4_79_2_251:4.10.2.26
	Kernel-5_35-4_79_2_250:4.10.2.26
	Kernel-5_35-4_79_2_249:4.10.2.26
	Kernel-5_35-4_79_2_248:4.10.2.26
	Kernel-5_35-4_79_2_247:4.10.2.26
	Kernel-5_35-4_79_2_246:4.10.2.26
	Kernel-5_35-4_79_2_245:4.10.2.26
	Kernel-5_35-4_79_2_244:4.10.2.26
	Kernel-5_35-4_79_2_243:4.10.2.26
	Kernel-5_35-4_79_2_242:4.10.2.26
	Kernel-5_35-4_79_2_241:4.10.2.26
	Kernel-5_35-4_79_2_240:4.10.2.26
	Kernel-5_35-4_79_2_239:4.10.2.26
	Kernel-5_35-4_79_2_238:4.10.2.26
	Kernel-5_35-4_79_2_237:4.10.2.26
	Kernel-5_35-4_79_2_236:4.10.2.26
	Kernel-5_35-4_79_2_235:4.10.2.26
	Kernel-5_35-4_79_2_234:4.10.2.26
	Kernel-5_35-4_79_2_233:4.10.2.26
	Kernel-5_35-4_79_2_232:4.10.2.26
	Kernel-5_35-4_79_2_231:4.10.2.26
	Kernel-5_35-4_79_2_230:4.10.2.26
	Kernel-5_35-4_79_2_229:4.10.2.26
	Kernel-5_35-4_79_2_228:4.10.2.26
	Kernel-5_35-4_79_2_227:4.10.2.26
	Kernel-5_35-4_79_2_226:4.10.2.26
	Kernel-5_35-4_79_2_225:4.10.2.26
	Kernel-5_35-4_79_2_224:4.10.2.26
	Kernel-5_35-4_79_2_223:4.10.2.26
	Kernel-5_35-4_79_2_222:4.10.2.26
	Kernel-5_35-4_79_2_221:4.10.2.26
	Kernel-5_35-4_79_2_220:4.10.2.26
	Kernel-5_35-4_79_2_219:4.10.2.26
	Kernel-5_35-4_79_2_218:4.10.2.26
	Kernel-5_35-4_79_2_217:4.10.2.25
	Kernel-5_35-4_79_2_216:4.10.2.25
	Kernel-5_35-4_79_2_215:4.10.2.25
	Kernel-5_35-4_79_2_214:4.10.2.25
	Kernel-5_35-4_79_2_213:4.10.2.25
	Kernel-5_35-4_79_2_212:4.10.2.25
	Kernel-5_35-4_79_2_211:4.10.2.25
	Kernel-5_35-4_79_2_210:4.10.2.25
	Kernel-5_35-4_79_2_209:4.10.2.25
	Kernel-5_35-4_79_2_208:4.10.2.25
	Kernel-5_35-4_79_2_207:4.10.2.25
	Kernel-5_35-4_79_2_206:4.10.2.25
	Kernel-5_35-4_79_2_205:4.10.2.25
	Kernel-5_35-4_79_2_204:4.10.2.25
	Kernel-5_35-4_79_2_203:4.10.2.25
	Kernel-5_35-4_79_2_202:4.10.2.24
	Kernel-5_35-4_79_2_201:4.10.2.24
	Kernel-5_35-4_79_2_200:4.10.2.23
	Kernel-5_35-4_79_2_199:4.10.2.23
	Kernel-5_35-4_79_2_198:4.10.2.23
	Kernel-5_35-4_79_2_197:4.10.2.23
	Kernel-5_35-4_79_2_196:4.10.2.23
	Kernel-5_35-4_79_2_195:4.10.2.23
	Kernel-5_35-4_79_2_194:4.10.2.23
	Kernel-5_35-4_79_2_193:4.10.2.23
	Kernel-5_35-4_79_2_192:4.10.2.23
	Kernel-5_35-4_79_2_191:4.10.2.23
	Kernel-5_35-4_79_2_190:4.10.2.23
	Kernel-5_35-4_79_2_189:4.10.2.23
	Kernel-5_35-4_79_2_188:4.10.2.23
	Kernel-5_35-4_79_2_187:4.10.2.23
	Kernel-5_35-4_79_2_186:4.10.2.23
	Kernel-5_35-4_79_2_185:4.10.2.23
	Kernel-5_35-4_79_2_184:4.10.2.23
	Kernel-5_35-4_79_2_183:4.10.2.22
	Kernel-5_35-4_79_2_182:4.10.2.21
	Kernel-5_35-4_79_2_181:4.10.2.20
	Kernel-5_35-4_79_2_180:4.10.2.20
	Kernel-5_35-4_79_2_179:4.10.2.20
	Kernel-5_35-4_79_2_178:4.10.2.20
	Kernel-5_35-4_79_2_177:4.10.2.20
	Kernel-5_35-4_79_2_176:4.10.2.20
	Kernel-5_35-4_79_2_175:4.10.2.20
	Kernel-5_35-4_79_2_174:4.10.2.20
	Kernel-5_35-4_79_2_173:4.10.2.20
	Kernel-5_35-4_79_2_172:4.10.2.20
	Kernel-5_35-4_79_2_171:4.10.2.20
	Kernel-5_35-4_79_2_170:4.10.2.20
	Kernel-5_35-4_79_2_169:4.10.2.20
	Kernel-5_35-4_79_2_168:4.10.2.20
	Kernel-5_35-4_79_2_167:4.10.2.20
	Kernel-5_35-4_79_2_166:4.10.2.20
	Kernel-5_35-4_79_2_165:4.10.2.20
	RPi_merge:4.10.2.19.2.4
	Kernel-5_35-4_79_2_147_2_23:4.10.2.19.2.4
	Kernel-5_35-4_79_2_147_2_22:4.10.2.19.2.4
	Kernel-5_35-4_79_2_147_2_21:4.10.2.19.2.4
	Kernel-5_35-4_79_2_147_2_20:4.10.2.19.2.4
	Kernel-5_35-4_79_2_147_2_19:4.10.2.19.2.3
	Kernel-5_35-4_79_2_147_2_18:4.10.2.19.2.3
	Kernel-5_35-4_79_2_164:4.10.2.19
	Kernel-5_35-4_79_2_163:4.10.2.19
	Kernel-5_35-4_79_2_147_2_17:4.10.2.19.2.3
	Kernel-5_35-4_79_2_147_2_16:4.10.2.19.2.3
	Kernel-5_35-4_79_2_147_2_15:4.10.2.19.2.3
	Kernel-5_35-4_79_2_162:4.10.2.19
	Kernel-5_35-4_79_2_161:4.10.2.19
	Kernel-5_35-4_79_2_147_2_14:4.10.2.19.2.3
	Kernel-5_35-4_79_2_147_2_13:4.10.2.19.2.3
	Kernel-5_35-4_79_2_160:4.10.2.19
	Kernel-5_35-4_79_2_159:4.10.2.19
	Kernel-5_35-4_79_2_158:4.10.2.19
	Kernel-5_35-4_79_2_157:4.10.2.19
	Kernel-5_35-4_79_2_156:4.10.2.19
	Kernel-5_35-4_79_2_147_2_12:4.10.2.19.2.3
	Kernel-5_35-4_79_2_147_2_11:4.10.2.19.2.3
	Kernel-5_35-4_79_2_155:4.10.2.19
	Kernel-5_35-4_79_2_147_2_10:4.10.2.19.2.3
	Kernel-5_35-4_79_2_154:4.10.2.19
	Kernel-5_35-4_79_2_153:4.10.2.19
	Kernel-5_35-4_79_2_147_2_9:4.10.2.19.2.3
	Kernel-5_35-4_79_2_152:4.10.2.19
	Kernel-5_35-4_79_2_151:4.10.2.19
	Kernel-5_35-4_79_2_147_2_8:4.10.2.19.2.3
	Kernel-5_35-4_79_2_147_2_7:4.10.2.19.2.2
	Kernel-5_35-4_79_2_150:4.10.2.19
	Kernel-5_35-4_79_2_147_2_6:4.10.2.19.2.1
	Kernel-5_35-4_79_2_147_2_5:4.10.2.19.2.1
	Kernel-5_35-4_79_2_149:4.10.2.19
	Kernel-5_35-4_79_2_147_2_4:4.10.2.19.2.1
	Kernel-5_35-4_79_2_147_2_3:4.10.2.19.2.1
	Kernel-5_35-4_79_2_148:4.10.2.19
	Kernel-5_35-4_79_2_147_2_2:4.10.2.19.2.1
	Kernel-5_35-4_79_2_147_2_1:4.10.2.19.2.1
	RPi:4.10.2.19.0.2
	RPi_bp:4.10.2.19
	Kernel-5_35-4_79_2_98_2_52_2_1:4.10.2.15.2.4.2.1
	alees_Kernel_dev:4.10.2.15.2.4.0.2
	alees_Kernel_dev_bp:4.10.2.15.2.4
	Kernel-5_35-4_79_2_147:4.10.2.19
	Kernel-5_35-4_79_2_146:4.10.2.19
	Kernel-5_35-4_79_2_145:4.10.2.19
	Kernel-5_35-4_79_2_144:4.10.2.19
	Kernel-5_35-4_79_2_143:4.10.2.19
	Kernel-5_35-4_79_2_142:4.10.2.19
	Kernel-5_35-4_79_2_141:4.10.2.19
	Kernel-5_35-4_79_2_140:4.10.2.19
	Kernel-5_35-4_79_2_139:4.10.2.19
	Kernel-5_35-4_79_2_138:4.10.2.19
	Kernel-5_35-4_79_2_137:4.10.2.18
	Kernel-5_35-4_79_2_136:4.10.2.18
	Kernel-5_35-4_79_2_135:4.10.2.18
	Kernel-5_35-4_79_2_134:4.10.2.18
	Kernel-5_35-4_79_2_133:4.10.2.18
	Kernel-5_35-4_79_2_132:4.10.2.18
	Kernel-5_35-4_79_2_131:4.10.2.18
	Kernel-5_35-4_79_2_130:4.10.2.18
	Kernel-5_35-4_79_2_129:4.10.2.18
	Kernel-5_35-4_79_2_128:4.10.2.18
	Kernel-5_35-4_79_2_127:4.10.2.18
	Kernel-5_35-4_79_2_126:4.10.2.17
	Kernel-5_35-4_79_2_125:4.10.2.17
	Kernel-5_35-4_79_2_124:4.10.2.17
	Kernel-5_35-4_79_2_123:4.10.2.16
	Cortex_merge:4.10.2.15.2.5
	Kernel-5_35-4_79_2_122:4.10.2.15
	Kernel-5_35-4_79_2_98_2_54:4.10.2.15.2.5
	Kernel-5_35-4_79_2_98_2_53:4.10.2.15.2.5
	Kernel-5_35-4_79_2_98_2_52:4.10.2.15.2.4
	Kernel-5_35-4_79_2_98_2_51:4.10.2.15.2.4
	Kernel-5_35-4_79_2_98_2_50:4.10.2.15.2.4
	Kernel-5_35-4_79_2_98_2_49:4.10.2.15.2.3
	Kernel-5_35-4_79_2_98_2_48:4.10.2.15.2.3
	Kernel-5_35-4_79_2_121:4.10.2.15
	Kernel-5_35-4_79_2_98_2_47:4.10.2.15.2.2
	Kernel-5_35-4_79_2_120:4.10.2.15
	Kernel-5_35-4_79_2_98_2_46:4.10.2.15.2.2
	Kernel-5_35-4_79_2_119:4.10.2.15
	Kernel-5_35-4_79_2_98_2_45:4.10.2.15.2.2
	Kernel-5_35-4_79_2_98_2_44:4.10.2.15.2.2
	Kernel-5_35-4_79_2_118:4.10.2.15
	Kernel-5_35-4_79_2_98_2_43:4.10.2.15.2.2
	Kernel-5_35-4_79_2_117:4.10.2.15
	Kernel-5_35-4_79_2_116:4.10.2.15
	Kernel-5_35-4_79_2_98_2_42:4.10.2.15.2.2
	Kernel-5_35-4_79_2_115:4.10.2.15
	Kernel-5_35-4_79_2_98_2_41:4.10.2.15.2.2
	Kernel-5_35-4_79_2_98_2_40:4.10.2.15.2.2
	Kernel-5_35-4_79_2_114:4.10.2.15
	Kernel-5_35-4_79_2_98_2_39:4.10.2.15.2.2
	Kernel-5_35-4_79_2_98_2_38:4.10.2.15.2.2
	Kernel-5_35-4_79_2_113:4.10.2.15
	Kernel-5_35-4_79_2_112:4.10.2.15
	Kernel-5_35-4_79_2_98_2_37:4.10.2.15.2.2
	Kernel-5_35-4_79_2_98_2_36:4.10.2.15.2.2
	Kernel-5_35-4_79_2_98_2_35:4.10.2.15.2.2
	Kernel-5_35-4_79_2_98_2_34:4.10.2.15.2.2
	Kernel-5_35-4_79_2_98_2_33:4.10.2.15.2.2
	Kernel-5_35-4_79_2_98_2_32:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_31:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_30:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_29:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_28:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_27:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_26:4.10.2.15.2.1
	Kernel-5_35-4_79_2_111:4.10.2.15
	Kernel-5_35-4_79_2_98_2_25:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_24:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_23:4.10.2.15.2.1
	Kernel-5_35-4_79_2_110:4.10.2.15
	Kernel-5_35-4_79_2_98_2_22:4.10.2.15.2.1
	Kernel-5_35-4_79_2_109:4.10.2.15
	Kernel-5_35-4_79_2_98_2_21:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_20:4.10.2.15.2.1
	Kernel-5_35-4_79_2_108:4.10.2.15
	Kernel-5_35-4_79_2_107:4.10.2.15
	Kernel-5_35-4_79_2_98_2_19:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_18:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_17:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_16:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_15:4.10.2.15.2.1
	Kernel-5_35-4_79_2_106:4.10.2.15
	Kernel-5_35-4_79_2_105:4.10.2.15
	Kernel-5_35-4_79_2_104:4.10.2.15
	Kernel-5_35-4_79_2_98_2_14:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_13:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_12:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_11:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_10:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_9:4.10.2.15.2.1
	Kernel-5_35-4_79_2_103:4.10.2.15
	Kernel-5_35-4_79_2_102:4.10.2.15
	Kernel-5_35-4_79_2_98_2_8:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_7:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_6:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_5:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_4:4.10.2.15.2.1
	Kernel-5_35-4_79_2_101:4.10.2.15
	Kernel-5_35-4_79_2_100:4.10.2.15
	Kernel-5_35-4_79_2_99:4.10.2.15
	Kernel-5_35-4_79_2_98_2_3:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_2:4.10.2.15.2.1
	Kernel-5_35-4_79_2_98_2_1:4.10.2.15.2.1
	Cortex:4.10.2.15.0.2
	Cortex_bp:4.10.2.15
	Kernel-5_35-4_79_2_98:4.10.2.15
	Kernel-5_35-4_79_2_97:4.10.2.15
	Kernel-5_35-4_79_2_96:4.10.2.15
	Kernel-5_35-4_79_2_95:4.10.2.15
	Kernel-5_35-4_79_2_94:4.10.2.15
	Kernel-5_35-4_79_2_93:4.10.2.15
	Kernel-5_35-4_79_2_92:4.10.2.15
	Kernel-5_35-4_79_2_91:4.10.2.15
	Kernel-5_35-4_79_2_90:4.10.2.15
	Kernel-5_35-4_79_2_89:4.10.2.15
	Kernel-5_35-4_79_2_88:4.10.2.15
	Kernel-5_35-4_79_2_87:4.10.2.15
	Kernel-5_35-4_79_2_86:4.10.2.15
	Kernel-5_35-4_79_2_85:4.10.2.15
	Kernel-5_35-4_79_2_84:4.10.2.15
	Kernel-5_35-4_79_2_83:4.10.2.15
	Kernel-5_35-4_79_2_82:4.10.2.15
	Kernel-5_35-4_79_2_81:4.10.2.14
	Kernel-5_35-4_79_2_80:4.10.2.13
	Kernel-5_35-4_79_2_79:4.10.2.13
	Kernel-5_35-4_79_2_78:4.10.2.13
	Kernel-5_35-4_79_2_77:4.10.2.13
	RO_5_07:4.10.2.12
	Kernel-5_35-4_79_2_76:4.10.2.12
	Kernel-5_35-4_79_2_75:4.10.2.12
	Kernel-5_35-4_79_2_74:4.10.2.12
	Kernel-5_35-4_79_2_73:4.10.2.12
	Kernel-5_35-4_79_2_72:4.10.2.12
	Kernel-5_35-4_79_2_71:4.10.2.12
	Kernel-5_35-4_79_2_70:4.10.2.11
	Kernel-5_35-4_79_2_69:4.10.2.11
	Kernel-5_35-4_79_2_68:4.10.2.10
	Kernel-5_35-4_79_2_67:4.10.2.10
	Kernel-5_35-4_79_2_66:4.10.2.10
	Kernel-5_35-4_79_2_65:4.10.2.9
	Kernel-5_35-4_79_2_64:4.10.2.9
	Kernel-5_35-4_79_2_63:4.10.2.9
	Kernel-5_35-4_79_2_62:4.10.2.9
	Kernel-5_35-4_79_2_61:4.10.2.9
	Kernel-5_35-4_79_2_59:4.10.2.9
	Kernel-5_35-4_79_2_58:4.10.2.9
	Kernel-5_35-4_79_2_57:4.10.2.9
	Kernel-5_35-4_79_2_56:4.10.2.9
	Kernel-5_35-4_79_2_55:4.10.2.8
	Kernel-5_35-4_79_2_54:4.10.2.8
	Kernel-5_35-4_79_2_53:4.10.2.8
	Kernel-5_35-4_79_2_52:4.10.2.8
	Kernel-5_35-4_79_2_51:4.10.2.8
	Kernel-5_35-4_79_2_50:4.10.2.7
	Kernel-5_35-4_79_2_49:4.10.2.7
	Kernel-5_35-4_79_2_48:4.10.2.7
	Kernel-5_47:4.11
	Kernel-5_46-4_90_2_1:4.11
	nbingham_Kernel_FastNC_dev_bp:4.11
	nbingham_Kernel_FastNC_dev:4.11.0.2
	Kernel-5_46:4.11
	Kernel-5_45:4.11
	Kernel-5_35-4_79_2_47:4.10.2.6
	Kernel-5_35-4_79_2_46:4.10.2.6
	Kernel-5_35-4_79_2_45:4.10.2.6
	Kernel-5_35-4_79_2_44:4.10.2.6
	Kernel-5_35-4_79_2_25_2_2:4.10.2.5
	Kernel-5_35-4_79_2_43:4.10.2.6
	Kernel-5_35-4_79_2_42:4.10.2.6
	Kernel-5_35-4_79_2_41:4.10.2.6
	Kernel-5_35-4_79_2_40:4.10.2.6
	Kernel-5_35-4_79_2_39:4.10.2.6
	Kernel-5_35-4_79_2_38:4.10.2.6
	Kernel-5_35-4_79_2_37:4.10.2.5
	Kernel-5_35-4_79_2_36:4.10.2.5
	Kernel-5_35-4_79_2_35:4.10.2.5
	Kernel-5_35-4_79_2_34:4.10.2.5
	Kernel-5_35-4_79_2_33:4.10.2.5
	Kernel-5_35-4_79_2_32:4.10.2.5
	Kernel-5_44:4.11
	Kernel-5_35-4_79_2_25_2_1:4.10.2.5
	Kernel-5_43:4.11
	Kernel-5_35-4_79_2_31:4.10.2.5
	Kernel-5_35-4_79_2_30:4.10.2.5
	Kernel-5_35-4_79_2_29:4.10.2.5
	Kernel-5_35-4_79_2_28:4.10.2.5
	Kernel-5_35-4_79_2_27:4.10.2.5
	Kernel-5_35-4_79_2_26:4.10.2.5
	Kernel-5_42:4.10
	Kernel-5_41:4.10
	Kernel-5_40:4.10
	Kernel-5_35-4_79_2_25:4.10.2.5
	Kernel-5_35-4_79_2_24:4.10.2.5
	Kernel-5_35-4_79_2_23:4.10.2.5
	Kernel-5_35-4_79_2_22:4.10.2.5
	Kernel-5_35-4_79_2_21:4.10.2.5
	Kernel-5_35-4_79_2_20:4.10.2.5
	Kernel-5_35-4_79_2_19:4.10.2.5
	Kernel-5_35-4_79_2_18:4.10.2.5
	Kernel-5_35-4_79_2_17:4.10.2.5
	Kernel-5_35-4_79_2_16:4.10.2.5
	Kernel-5_35-4_79_2_15:4.10.2.5
	Kernel-5_35-4_79_2_14:4.10.2.5
	Kernel-5_39:4.10
	Kernel-5_13-4_52_2_1:4.8
	Bethany:4.8.0.2
	Kernel-5_38:4.10
	Kernel-5_35-4_79_2_13:4.10.2.5
	Kernel-5_35-4_79_2_12:4.10.2.5
	Kernel-5_35-4_79_2_11:4.10.2.5
	Kernel-5_37:4.10
	Kernel-5_35-4_79_2_10:4.10.2.5
	Kernel-5_35-4_79_2_9:4.10.2.5
	Kernel-5_36:4.10
	Kernel-5_35-4_79_2_8:4.10.2.3
	Kernel-5_35-4_79_2_7:4.10.2.3
	Kernel-5_35-4_79_2_6:4.10.2.2
	Kernel-5_35-4_79_2_5:4.10.2.2
	Kernel-5_35-4_79_2_4:4.10.2.1
	Kernel-5_35-4_79_2_3:4.10.2.1
	Kernel-5_35-4_79_2_2:4.10.2.1
	dellis_autobuild_BaseSW:4.10
	Kernel-5_35-4_79_2_1:4.10.2.1
	HAL:4.10.0.2
	Kernel-5_35:4.10
	Kernel-5_34:4.10
	Kernel-5_33:4.10
	Kernel-5_32:4.10
	Kernel-5_31:4.10
	Kernel-5_30:4.10
	Kernel-5_29:4.10
	Kernel-5_28:4.10
	Kernel-5_27:4.10
	Kernel-5_26:4.10
	Kernel-5_25:4.10
	Kernel-5_24:4.10
	Kernel-5_23:4.10
	Kernel-5_22:4.9
	sbrodie_sedwards_16Mar2000:4.8
	Kernel-5_21:4.8
	Kernel-5_20:4.8
	Kernel-5_19:4.8
	Kernel-5_18:4.8
	Kernel-5_17:4.8
	Kernel-5_16:4.8
	Kernel-5_15:4.8
	Kernel-5_14:4.8
	Kernel-5_13:4.8
	Kernel-5_12:4.8
	Kernel-5_11:4.8
	Kernel-5_10:4.8
	Kernel-5_09:4.8
	Kernel-5_08:4.8
	Kernel-5_07:4.8
	Kernel-5_06:4.8
	Kernel-5_05:4.8
	Kernel-5_04:4.8
	Kernel-5_03:4.7
	Kernel-5_02:4.6
	Kernel-5_01:4.5
	Kernel-5_00:4.4
	Kernel-4_99:4.4
	Kernel-4_98:4.4
	Kernel-4_97:4.4
	Kernel-4_96:4.4
	Kernel-4_95:4.4
	Kernel-4_94:4.4
	Kernel-4_93:4.4
	Kernel-4_92:4.4
	Kernel-4_91:4.4
	Kernel-4_90:4.4
	dcotton_autobuild_BaseSW:4.11
	Kernel-4_89:4.4
	Kernel-4_88:4.4
	Kernel-4_87:4.4
	Kernel-4_86:4.4
	Kernel-4_85:4.4
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.5.2.2
	Kernel-4_84:4.4
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.5.2.2
	Ursula_RiscPC_bp:4.2.2.5
	Kernel-4_83:4.4
	Kernel-4_82:4.4
	Kernel-4_81:4.4
	Kernel-4_80:4.3
	Kernel-4_79:4.3
	Kernel-4_78:4.3
	Kernel-4_77:4.3
	Kernel-4_76:4.3
	Kernel-4_75:4.3
	Kernel-4_74:4.3
	Kernel-4_73:4.3
	Kernel-4_72:4.3
	Kernel-4_71:4.3
	Kernel-4_70:4.3
	Kernel-4_69:4.3
	Kernel-4_68:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.5.2.1
	Ursula_RiscPC:4.2.2.5.0.2
	Kernel-4_63-1_1_2_5:4.1.7.2
	Kernel-4_63-1_1_2_4:4.1.7.2
	Kernel-4_67:4.3
	Kernel-4_66:4.3
	Kernel-4_63-1_1_2_3:4.1.7.2
	Kernel-4_65:4.3
	Ursula_merge:4.2
	Kernel-4_64:4.3
	mstphens_Kernel-3_81:4.2.2.6
	Kernel-4_63-1_1_2_2:4.1.7.2
	nicke_Kernel_4_62:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.5
	UrsulaBuild_FinalSoftload:4.2.2.5
	rthornb_UrsulaBuild-12Aug1998:4.2.2.5
	aglover_UrsulaBuild-05Aug1998:4.2.2.5
	rthornb_UrsulaBuild-29Jul1998:4.2.2.5
	rthornb_UrsulaBuild-22Jul1998:4.2.2.5
	nturton_v459:4.1.7.2
	nturton_v460:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.2.2.5
	rthornb_UrsulaBuild-07Jul1998:4.2.2.5
	rthornb_UrsulaBuild-17Jun1998:4.2.2.5
	rthornb_UrsulaBuild-03Jun1998:4.2.2.5
	rthornb_UrsulaBuild-27May1998:4.2.2.5
	mstphens_Kernel-3_80:4.2.2.5
	rthornb_UrsulaBuild-21May1998:4.2.2.5
	afrost_Boca-1_2-Beta:4.1.7.2
	rthornb_UrsulaBuild_01May1998:4.2.2.5
	afrost_NC2_Generic:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.16
date	2018.11.07.22.28.10;	author jlee;	state Exp;
branches;
next	4.15;
commitid	Ub9LVqEF46x8X3ZA;

4.15
date	2018.07.07.14.06.29;	author jlee;	state Exp;
branches;
next	4.14;
commitid	VD8qInwgaJB98dJA;

4.14
date	2016.06.30.20.59.46;	author jlee;	state Exp;
branches
	4.14.2.1;
next	4.13;
commitid	skOEjp3ipLHx6xcz;

4.13
date	2016.06.30.20.28.56;	author jlee;	state Exp;
branches;
next	4.12;
commitid	lMnWzoE9eJz3Wwcz;

4.12
date	2016.06.30.20.08.09;	author jlee;	state Exp;
branches;
next	4.11;
commitid	IWoXxARWeuLDOwcz;

4.11
date	2001.05.25.13.27.33;	author srevill;	state Exp;
branches;
next	4.10;

4.10
date	2000.04.04.14.27.32;	author kbracey;	state Exp;
branches
	4.10.2.1;
next	4.9;

4.9
date	2000.03.23.16.40.44;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	99.10.26.09.49.27;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.10.25.17.17.09;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.10.25.17.10.52;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.10.25.16.48.59;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.08.03.09.59.11;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.09.30.08.42.39;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.07.14;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.23;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.14.2.1
date	2017.07.29.11.13.08;	author jlee;	state Exp;
branches;
next	;
commitid	E0o1zV5A8r2fc71A;

4.10.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.10.2.2;

4.10.2.2
date	2000.10.05.13.54.49;	author kbracey;	state Exp;
branches;
next	4.10.2.3;

4.10.2.3
date	2000.10.05.16.20.00;	author kbracey;	state Exp;
branches;
next	4.10.2.4;

4.10.2.4
date	2000.10.06.09.08.11;	author kbracey;	state Exp;
branches;
next	4.10.2.5;

4.10.2.5
date	2000.10.09.15.59.15;	author kbracey;	state Exp;
branches;
next	4.10.2.6;

4.10.2.6
date	2001.06.18.14.49.45;	author mstephen;	state Exp;
branches;
next	4.10.2.7;

4.10.2.7
date	2002.10.07.17.29.42;	author kbracey;	state Exp;
branches;
next	4.10.2.8;

4.10.2.8
date	2002.11.30.00.31.09;	author bavison;	state Exp;
branches;
next	4.10.2.9;

4.10.2.9
date	2003.02.21.20.21.54;	author bavison;	state Exp;
branches;
next	4.10.2.10;

4.10.2.10
date	2004.05.06.16.02.02;	author kbracey;	state Exp;
branches;
next	4.10.2.11;

4.10.2.11
date	2004.06.21.11.36.01;	author bavison;	state Exp;
branches;
next	4.10.2.12;

4.10.2.12
date	2004.06.25.15.07.13;	author kbracey;	state Exp;
branches;
next	4.10.2.13;

4.10.2.13
date	2004.10.06.16.55.18;	author bavison;	state Exp;
branches;
next	4.10.2.14;

4.10.2.14
date	2004.11.02.00.48.03;	author jballance;	state Exp;
branches;
next	4.10.2.15;

4.10.2.15
date	2004.11.04.15.26.22;	author jballance;	state Exp;
branches
	4.10.2.15.2.1;
next	4.10.2.16;

4.10.2.16
date	2011.11.26.21.11.16;	author jlee;	state Exp;
branches;
next	4.10.2.17;
commitid	cI3W0zbtALQG6TIv;

4.10.2.17
date	2011.11.27.11.48.10;	author rsprowson;	state Exp;
branches;
next	4.10.2.18;
commitid	OFgqaKhOb6swXXIv;

4.10.2.18
date	2011.11.27.19.18.16;	author rsprowson;	state Exp;
branches;
next	4.10.2.19;
commitid	iuIXfUOByAFYr0Jv;

4.10.2.19
date	2012.02.25.16.19.37;	author jlee;	state Exp;
branches
	4.10.2.19.2.1;
next	4.10.2.20;
commitid	ad3WnPntkzrizyUv;

4.10.2.20
date	2012.09.18.22.01.15;	author jlee;	state Exp;
branches;
next	4.10.2.21;
commitid	eFa3Y1QY0MjZP3lw;

4.10.2.21
date	2013.01.22.23.19.30;	author jlee;	state Exp;
branches;
next	4.10.2.22;
commitid	ySNxVh2X08tIdgBw;

4.10.2.22
date	2013.01.27.17.50.27;	author rsprowson;	state Exp;
branches;
next	4.10.2.23;
commitid	tDlfhdSfOxFReSBw;

4.10.2.23
date	2013.03.16.22.50.45;	author rsprowson;	state Exp;
branches;
next	4.10.2.24;
commitid	TyWRXTIjxgDcm4Iw;

4.10.2.24
date	2013.11.16.12.30.16;	author rsprowson;	state Exp;
branches;
next	4.10.2.25;
commitid	9tijEFmxNuG63vdx;

4.10.2.25
date	2013.12.15.21.34.04;	author jlee;	state Exp;
branches;
next	4.10.2.26;
commitid	KwuK29hKRyXO7hhx;

4.10.2.26
date	2014.04.14.19.22.48;	author rsprowson;	state Exp;
branches;
next	4.10.2.27;
commitid	I3FLhMw0FZGHxGwx;

4.10.2.27
date	2016.06.15.19.24.52;	author jlee;	state Exp;
branches;
next	;
commitid	QoMRsy6vZNP34Baz;

4.10.2.15.2.1
date	2009.02.01.13.25.06;	author jlee;	state Exp;
branches;
next	4.10.2.15.2.2;

4.10.2.15.2.2
date	2011.02.19.22.19.34;	author jlee;	state Exp;
branches;
next	4.10.2.15.2.3;

4.10.2.15.2.3
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	4.10.2.15.2.4;
commitid	D7rzILnwRRSXoLuv;

4.10.2.15.2.4
date	2011.09.12.18.52.31;	author bavison;	state Exp;
branches
	4.10.2.15.2.4.2.1;
next	4.10.2.15.2.5;
commitid	KJtDPjWMk0KCKezv;

4.10.2.15.2.5
date	2011.09.24.19.55.54;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.10.2.15.2.4.2.1
date	2012.05.10.03.09.53;	author bavison;	state Exp;
branches;
next	;
commitid	HTVG5Da5tRqSM74w;

4.10.2.19.2.1
date	2012.05.10.03.28.05;	author bavison;	state Exp;
branches;
next	4.10.2.19.2.2;
commitid	kuJoT3AcfB16T74w;

4.10.2.19.2.2
date	2012.05.23.00.01.16;	author jballance;	state Exp;
branches;
next	4.10.2.19.2.3;
commitid	apQ7umyAqGwlkM5w;

4.10.2.19.2.3
date	2012.05.23.21.48.58;	author bavison;	state Exp;
branches;
next	4.10.2.19.2.4;
commitid	u4A07cKhEUcXyT5w;

4.10.2.19.2.4
date	2012.09.07.23.05.52;	author jlee;	state Exp;
branches;
next	;
commitid	Ik0jMROsIiH5yEjw;

4.2.2.1
date	97.05.21.09.30.14;	author mstphens;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.09.09.13.33.29;	author mstphens;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	97.10.21.15.31.22;	author mstphens;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	97.12.08.14.34.35;	author mstphens;	state Exp;
branches;
next	4.2.2.5;

4.2.2.5
date	98.03.26.11.25.57;	author mstphens;	state Exp;
branches
	4.2.2.5.2.1;
next	4.2.2.6;

4.2.2.6
date	98.09.24.13.17.20;	author mstphens;	state Exp;
branches;
next	;

4.2.2.5.2.1
date	98.11.23.14.59.19;	author mstphens;	state Exp;
branches;
next	4.2.2.5.2.2;

4.2.2.5.2.2
date	99.08.18.13.35.58;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.23;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.52;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.36;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.50;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.12.17.34.14;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.16
log
@Attempt to tidy up substitute screen mode selection logic
Detail:
  Over the years the OS's substitute screen mode selection logic has grown to be a tangled mess, and the logic it does implement isn't always very useful. Additionally, the kernel is structured in such a way that it can be hard for modules to override it.
  This set of changes aims to fix the many of the problems, by doing the following:
  - Moving all substitute mode selection logic out of the core VDU driver code and into a Service_ModeTranslation handler. This means you now only have one place in the kernel to look instead of several, and modules can override the behaviour by claiming/blocking the service call as appropriate.
  - Moving handling of the built-in VIDC lists out of the core VDU driver code and into a Service_ModeExtension handler. This means programs can now inspect these VIDC lists by issuing the right service call (although you are essentially limited to lists which the GraphicsV driver is OK with)
  - Moving *TV interlace & offset adjustment logic into the Service_ModeExtension handler, since they're legacy things which can be handled more cleanly for MDF/EDID (and the old code was poking memory the kernel didn't own)
  - Adding a Service_EnumerateScreenModes implementation, so that if you end up in the desktop with ScreenModes non-functional, the display manager at least has something useful to show you
  - Enhancing the handling of the built-in numbered modes so that they are now available in any colour depth; the Service_ModeExtension handler (and related handlers) treat the builtin VIDC lists as a set of mode timings, not a discrete set of modes
  - Substitute mode selection logic is a complete re-write. Instead of trying a handful of numbered fallback modes, it now tries:
    - Same mode but at higher colour depths
    - Same mode but at lower colour depths
    - Alternate resolutions (half-width mode with no double-pixel if original request was for double-pixel, and default resolution for monitor type)
  - Combined with the logic to allow the builtin VIDC lists to be used at any colour depth, this means that the kernel should now be able to find substitute modes for machines which lack support for <=8bpp modes (e.g. OMAP5)
  - Additionally the mode substitution code will attempt to retain as many properties of the originally requested mode as possible (eigen values, gap mode type, etc.)
  Other improvements:
  - The kernel now actually vets the builtin VIDC lists instead of assuming that they'll work (which also means they'll have the correct ExtraBytes value, where applicable)
  - The kernel now uses GraphicsV 19 (VetMode2) to vet the mode during the mode switch process, using the result to detect where the framebuffer will be placed. This allows for GraphicsV drivers to switch between DA 2 and external framestores on a per-mode basis.
  - The kernel now supports mode selectors which specify LineLength values which are larger than necessary; this will get translated to a suitable ExtraBytes control list item (+ combined with whatever padding the driver indicates is necessary via the VetMode2 result)
  File changes:
  - hdr/KernelWS - Reserve space for a VIDC list, since the Service_ModeExtension implementation typically can't use the built-in list as-is
  - s/Arthur3 - Issue Service_ModeFileChanged when the configured monitor type is changed, so that DisplayManager + friends are aware that the set of available modes has changed
  - s/GetAll - Fiddle with GETs a bit
  - s/MemMap2 - Extra LTORG
  - s/NewIRQs - Small routine to install/uninstall false VSync routine (previously from PushModeInfo, which wasn't really the appropriate place for it)
  - s/Utility - Hook up the extra service call handlers
  - s/vdu/legacymodes - New file containing the new service call implementations, and some related code
  - s/vdu/vdudecl - Move mode workspace definition here, from vdumodes
  - s/vdu/vdudriver - Remove assorted bits of mode substitution code. Plug in new bits for calling GraphicsV 19 during mode set, and deal with ExtraBytes/LineLength during PushModeInfo
  - s/vdu/vdumodes - Move some workspace definitions to s/vdu/vdudecl. Tweak how the builtin VIDC lists are stored.
  - s/vdu/vduswis - Rip out more mode substitution code. Issue Service_ModeFileChanged when monitor type is changed by OS_ScreenMode.
Admin:
  Tested on Raspberry Pi 3, Iyonix, IGEPv5


Version 6.14. Tagged as 'Kernel-6_14'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => NewIRQs

; *****************************************************************************
;
; Main IRQ routine:
;     Push  workregs,lr
;     IRQsema -> TOS
;     stack -> IRQsema
;     call IRQ1V
;     IRQs off
;     TOS ->IRQsema
;     process callback, pulling workregs,pc at some point
;
; *****************************************************************************

        ALIGN 32

Initial_IRQ_Code ROUT
        SUB     lr, lr, #4
        Push    "r0, lr"
        MRS     lr, SPSR
        Push    "r1-r3, r11, r12, lr"
; ** For Pete's sake remember to change the heap manager if you change the above
; ** register list!!!!!!! And the [sp_irq, #4*5] below

        LDR     r12, =ZeroPage
        LDR     r0, [r12, #IRQsema]
        Push    r0
        STR     sp_irq, [r12, #IRQsema]
        MOV     lr, pc
        LDR     pc, [r12, #IRQ1V]

; IRQ1V called with r0-r3,r11,r12 trashable. r12=ZeroPage

; Stu has a theory that 1N cycle can be saved by the default IRQ1V pointing
; at a location containing a branch to our code; we then do something like
;  LDR R0, [R12, #IRQ1V]
;  CMP R0, #OurIRQ1V
;  BNE somebodysonIRQ1V
;  .... fall into default IRQ1V code

        Push     "r10"
        MOV      r10, #UnthreadV
        BL       CallVector
        Pull     "r10"

        LDR      r11, =ZeroPage
        Pull     r0
        STR      r0, [r11, #IRQsema]

        LDRB     r11, [r11, #CallBack_Flag]
        TEQ      r11, #0
        BNE      %FT10
05
        MyCLREX  r0, r1
        Pull     "r1-r3, r11, r12, lr"
        MSR      SPSR_cxsf, lr
        Pull     "r0, pc",, ^

10
        TST      r11, #CBack_Postpone
        LDREQ    lr, [sp_irq, #4*5]     ; get SPSR off stack
        TSTEQ    lr, #I32_bit :OR: &0F  ; check we came from USR26 or USR32 mode, with IRQs enabled
        BNE      %BT05

; Do a CallBack: asked for, not postponed, and we're returning into USR26/32 mode.

        ASSERT   IRQ32_mode :AND: SVC32_mode = IRQ32_mode ; so the following dodgy ops work

        Pull     "r1-r3, r11, r12"
        MRS      r0, CPSR
        ORR      r0, r0, #SVC32_mode
        MSR      CPSR_c, r0
        Push     "r10-r12"                               ; push r10-r12 onto the SVC stack
        BIC      r0, r0, #IRQ32_mode :EOR: SVC32_mode
        MSR      CPSR_c, r0
        Pull     "r10-r12"                      ; SPSR, R0, LR really
        ORR      r0, r0, #SVC32_mode
        MSR      CPSR_c, r0
        Push     r12                            ; Save the return address
        MOV      r14, r10                       ; SPSR into R14
        MOV      r0, r11                        ; restore original R0
        LDR      r10, =ZeroPage
        LDRB     r11, [r10, #CallBack_Flag]
        B        Do_CallBack_postpone_already_clear

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Default IRQ1V: despatch on interrupting device

; Now copied to RAM, together with vector entries and device tables

                  ^ 0
IRQDesp_Link      # 4
IRQDesp_R12Val    # 4
IRQDesp_CallAddr  # 4

IRQDesp_Link_Unshared * 1       ; flag in Link (for _this_ node)

       ASSERT   IRQDesp_CallAddr = IRQDesp_R12Val + 4

DefaultIRQ1Vcode ROUT

        Push    "r9,lr"
      [ ZeroPage = 0
        MOV     r9, #0
      |
        LDR     r9, %FT02
      ]
        AddressHAL r9                   ; modifies r9
        CallHAL HAL_IRQSource
        Pull    "r9"
        ADR     r2, Devices
        ADD     r1, r0, r0, LSL #1      ; multiply by 3
        ADD     r11, r2, r1, LSL #2     ; so table contains DevNo * 3
01      MOV     lr, pc
        LDMIA   r11, {r11, r12, pc}
        TST     r11, #IRQDesp_Link_Unshared
        BEQ     %BT01
        Pull    pc
      [ ZeroPage <> 0
02
        DCD     ZeroPage
      ]

; IRQ handlers are called as follows:
;   r0  =  device number
;   r12 =  what they asked for
;  [r13]=  return address to claim IRQ. r0-r3, r12, r14 corruptible.
;   r14 =  return address to pass on to next handler (unhandled shared IRQ). r1-r2, r12, r14 corruptible.

DefaultIRQ1Vcode_end

Devices * DefaultIRQ1Vcode_end + 12

NoInterrupt     * -1

DevicesEnd * Devices + MaxInterrupts * 12

        ASSERT  DevicesEnd - DefaultIRQ1Vcode <= DefIRQ1Vspace

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

InitialiseIRQ1Vtable

        Push    "v1-v3,sb,lr"
; copy IRQ handler: not done with rest of copying
; because soft break needs the info to free any claimed blocks.

        LDR     a1, =DefaultIRQ1V
        ADRL    a2, DefaultIRQ1Vcode
        ADRL    a3, DefaultIRQ1Vcode_end
CopyDefaultIRQ1V
        LDR     a4, [a2], #4
        STR     a4, [a1], #4
        CMP     a2, a3
        BNE     CopyDefaultIRQ1V

        AddressHAL
        ADD     v1, a1, #12
        ADD     a3, v1, #MaxInterrupts*12
        MOV     a2, #0
        MOV     a4, #-1
        LDR     ip, =IRQ
FillInDefaultIRQ1VDevices
        STMIA   a1!, {a2, a4, ip}
        ADD     a4, a4, #1
        CMP     a1, a3
        BNE     FillInDefaultIRQ1VDevices

; Now fill in our basic device handlers. First the timer.
        MOV     a1, #0
        CallHAL HAL_TimerDevice
        LDR     a2, =ZeroPage+OsbyteVars
        LDR     a3, =TickOne
        ADD     a1, a1, a1, LSL #1
        ADD     a1, v1, a1, LSL #2
        STMIB   a1, {a2, a3}
        
1
 [ NumberOfPodules > 0
; Now Podule bits
        MOV     a1, #IRQDesp_Link_Unshared
        LDR     a2, =ZeroPage+PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        ADR     a3, PFIQasIRQ_Despatch
        ADD     lr, v1, #PFIQasIRQ_DevNo*12
        STMIA   lr, {a1, a2, a3}
        LDR     a2, =ZeroPage+PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        ADR     a3, PIRQ_Despatch
        ADD     lr, v1, #Podule_DevNo*12
        STMIA   lr, {a1, a2, a3}
 ]

; Now IIC - if any
        LDR     v2, =ZeroPage+IICBus_Base
        MOV     v3, #0
80
        LDR     a1, [v2, #IICBus_Type]
        TST     a1, #IICFlag_HighLevel
        TSTNE   a1, #IICFlag_Background
        BEQ     %FT90
        MOV     a1, v3
        CallHAL HAL_IICDevice
; I think it's safe to call A SWI here...
        LDR     r1, =IICIRQ
        MOV     r2, v3
        SWI     XOS_ClaimDeviceVector
90
        ADD     v2, v2, #IICBus_Size
        ADD     v3, v3, #1
        CMP     v3, #IICBus_Count
        BNE     %BT80

        Pull    "v1-v3,sb,pc"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Specialist despatchers for podules

                  ^  0
PodDesp_Address   #  4     ; address of IRQ status byte
PodDesp_Mask      #  4     ; for use on above
PodDesp_R12Val    #  4
PodDesp_CallAddr  #  4     ; address to call if (?Address EOR (Mask>>8)) AND Mask <> 0
PodDesp_Link      #  4     ; next node
PodDesp_NodeSize  #  0

; In    r12 =    PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
;             or PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)     from despatcher

PFIQasIRQ_Despatch ROUT
PIRQ_Despatch ; All the same thing now

01      LDR     r12, [r12, #PodDesp_Link-PodDesp_R12Val]
        LDMIA   r12!, {r1, r2}           ; address and mask

; TMD 09-Jun-89: Don't corrupt r0 - it's needed by the default IRQ2 routine
        LDRB    r1, [r1]
        EOR     r1, r1, r2, LSR #8
        ANDS    r1, r1, r2
        BEQ     %BT01
        LDMIA   r12, {r12, pc}

Default_PIRQHandler_Node
Default_PFIQasIRQHandler_Node
        &       .+4                     ; address we know has non-zero value!
        &       -1                      ; mask
        &       0                       ; handler r12
        &       IRQ                     ; handler code
        &       0                       ; null link for naff release checking

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Claim of device vectors

; r0 = Device number
; r1 = call address
; r2 = r12 value
; r3 = interrupt location      } when podules are
; r4 = interrupt mask/polarity } supported and r0 = podule device number

CDV_Flags * &FF000000
CDV_Shared * 1:SHL:31

DeviceVector_Claim ROUT

        Push    "r0-r3, lr"

01      SWI     XOS_ReleaseDeviceVector ; Release until bored
        BVC     %BT01

        LDR     r0, [sp]
        BIC     r0, r0, #CDV_Flags
        LDR     lr, =ZeroPage
        LDR     lr, [lr, #IRQMax]
        CMP     r0, lr
        BHS     DV_Fail_NaffDevNo

 [ NumberOfPodules > 0
        ! 0,    "ClaimDeviceVector has podule IRQ/FIQs assembled in"
        CMP     r0, #Podule_DevNo
        CMPNE   r0, #PFIQasIRQ_DevNo
        BEQ     PoduleChainClaim
 ]
        MOV     r3, #12
        BL      ClaimSysHeapNode
        BVS     DV_Exit
        LDR     r11, [sp]
        BIC     r0, r11, #CDV_Flags
        ADD     r0, r0, r0, LSL #1      ; *3
        LDR     r1, =DefaultIRQ1V-DefaultIRQ1Vcode+Devices
        ADD     r1, r1, r0, LSL #2
        WritePSRc SVC_mode+I_bit, r10   ; IRQs off for update (on again on SWI exit)
        LDMIA   r1, {r0, r3, r10}
        STMIA   r2, {r0, r3, r10}       ; copy current head into node
        MOV     r10, r2
        TST     r11, #CDV_Shared
        ORREQ   r10, r10, #IRQDesp_Link_Unshared
        LDR     r11, [sp, #4*2]         ; r12 value
        LDR     r12, [sp, #4*1]         ; call address
        STMIA   r1, {r10-r12}           ; copy given info into head


DV_Exit STRVS   r0, [sp]                ; Common exit for both claim + release
        Pull    "r0-r3, lr"
        B       SLVK_TestV


DV_Fail_NaffDevNo
        ADR     r0, ErrorBlock_NaffDevNo
      [ International
        BL      TranslateError
      |
        SETV
      ]
        B       DV_Exit

        MakeErrorBlock NaffDevNo

 [ NumberOfPodules > 0
PoduleChainClaim
        MOV     r3, #PodDesp_NodeSize
        BL      ClaimSysHeapNode
        BVS     DV_Exit
        MOV     r10, r2
        LDMFD   sp, {r0-r3}
        STR     r1, [r10, #PodDesp_CallAddr]
        STR     r2, [r10, #PodDesp_R12Val]
        STR     r3, [r10, #PodDesp_Address]
        STR     r4, [r10, #PodDesp_Mask]
        CMP     r0, #Podule_DevNo
        LDREQ   r0, =ZeroPage+PIRQ_Chain
        LDRNE   r0, =ZeroPage+PFIQasIRQ_Chain
        WritePSRc SVC_mode+I_bit, r1    ; IRQs off for update
        LDR     r1, [r0]
        STR     r1, [r10, #PodDesp_Link]
        STR     r10, [r0]
        B       DV_Exit
 ]

; .............................................................................
; Release of device vectors

; r0 = Device number
; r1 = call address
; r2 = r12 value
; r0 = PFIQ|PIRQ devno -> r3 = interrupt location (LDRB always used)
;                         r4 = interrupt mask

DeviceVector_Release ROUT

        Push    "r0-r3, lr"             ; Ensure same regset as above
        BIC     r0, r0, #CDV_Flags
        LDR     lr, =ZeroPage
        LDR     lr, [lr, #IRQMax]
        CMP     r0, lr
        BHS     DV_Fail_NaffDevNo

        WritePSRc SVC_mode + I_bit, r12 ; IRQs off while holding context
 [ NumberOfPodules > 0
        ! 0,    "ReleaseDeviceVector has podule IRQ/FIQs assembled in"
        CMP     r0, #Podule_DevNo
        CMPNE   r0, #PFIQasIRQ_DevNo
        BEQ     PoduleChainRelease
 ]

        ADD     r0, r0, r0, LSL #1      ; *3
        LDR     r12, =DefaultIRQ1V-DefaultIRQ1Vcode+Devices
        ADD     r12, r12, r0, LSL #2    ; address of node
        MOV     r11, #-1                ; "fudge" predecessor node

01      LDMIB   r12, {r3, r10}
        CMP     r3, r2
        CMPEQ   r10, r1
        BEQ     %FT02                   ; found it
        MOV     r11, r12
        LDR     r12, [r12, #IRQDesp_Link]
        BICS    r12, r12, #IRQDesp_Link_Unshared
        BNE     %BT01

11      ADR     r0, ErrorBlock_BadDevVecRel
      [ International
        BL      TranslateError
      |
        SETV
      ]
        B       DV_Exit

        MakeErrorBlock BadDevVecRel


02      CMP     r11, #-1
        BEQ     %FT03
        MOV     r2, r12
        LDR     r12, [r2, #IRQDesp_Link]
        LDR     r14, [r11, #IRQDesp_Link]       ; preserve r11's "unshared" flag
        BIC     r12, r12, #IRQDesp_Link_Unshared
        AND     r14, r14, #IRQDesp_Link_Unshared
        ORR     r12, r12, r14
        STR     r12, [r11, #IRQDesp_Link] ; node delinked
        B       %FT04

03      LDR     r2, [r12, #IRQDesp_Link]; freeable = nextnode
        BIC     r2, r2, #IRQDesp_Link_Unshared
        LDMIA   r2,  {r0, r1, r3}       ; copy next node into head posn
        STMIA   r12, {r0, r1, r3}

04
        BL      FreeSysHeapNode         ; free block
        B       DV_Exit

 [ NumberOfPodules > 0
PoduleChainRelease
        CMP     r0, #Podule_DevNo
        LDREQ   r0, =ZeroPage+PIRQ_Chain-PodDesp_Link
        LDRNE   r0, =ZeroPage+PFIQasIRQ_Chain-PodDesp_Link

10      LDR     r12, [r0, #PodDesp_Link]
        CMP     r12, #0
        BEQ     %BT11
        LDR     r11, [r12, #PodDesp_Address]
        CMP     r11, r3
        LDREQ   r11, [r12, #PodDesp_Mask]
        CMPEQ   r11, r4
        LDREQ   r11, [r12, #PodDesp_CallAddr]
        CMPEQ   r11, r1
        LDREQ   r11, [r12, #PodDesp_R12Val]
        CMPEQ   r11, r2
        MOVNE   r0, r12
        BNE     %BT10

        LDR     r11, [r12, #PodDesp_Link]
        STR     r11, [r0,  #PodDesp_Link]
        MOV     r2, r12
        B       %BT04
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Default device owner for IRQ not recognised by system: pass to IRQ2V

IRQ ROUT

        Push    "r10, lr"
        MOV     r10, #IrqV
        BL      CallVector

        Pull    "r10, lr"
        Pull    "pc"                    ; new-style CDV - pull return address

; *****************************************************************************
; Default IRQ2V:
;   r0  must still have devno in it
;   r12 is 0 (from vector)

; Clear mask, clear IRQ as appropriate/possible

NOIRQ ROUT

        TEQ     r0, #0
        Pull    pc, MI
        MOV     r11, r9
        AddressHAL
        CallHAL HAL_IRQDisable
        MOV     r9, r11
        Pull    pc              ; claim vector

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; The following bits have been appropriated from source.pmf.oseven to make
; sure Tim's old code doesn't overwrite us when he gets back!

; SWI OS_GenerateEvent: call event vector if enabled

GenEvent ROUT

        Push    lr
        WritePSRc SVC_mode+I_bit, lr    ; Disable IRQs. MUST call these ones
        BL      OSEVEN                  ; in SVC mode as people expect it
        Pull    lr
        B       SLVK

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Subroutine call version

; In    r0 = event type
;       r1,r2 parameters

; Out   C=0 => event was enabled, or was >= 32 anyway
;       C=1 => event was disabled, so vector not called

OSEVEN ROUT

        Push    lr

        CMP     r0, #31                 ; Events >= 32 are ALWAYS raised. SKS
                                        ; flags are HI if so, ie. NE
      [ ZeroPage = 0
        LDRLSB  r14, [r0, #OsbyteVars + :INDEX: EventSemaphores]
      |
        LDRLS   r14, =ZeroPage+OsbyteVars+:INDEX:EventSemaphores
        LDRLSB  r14, [r0, r14]
      ]
                                        ; get semaphore for this event 0..31
        CMPLS   r14, #0                 ; non-zero => enabled
        Pull    pc, EQ                  ; if disabled, exit with C=1

        Push    "r0-r3, r10-r12" ; r3 excessive ???
        MOV     r10, #EventV            ; call event vector
        BL      CallVector
        CLC                             ; indicate event enabled
        Pull    "r0-r3, r10-r12, pc"

; ...................... default owner of EventV ..............................
; Call Event handler

; In    r12 = EvtHan_ws

DefEvent ROUT

        MOV     lr, pc                  ; link with all the bits
        LDMIA   r12, {r12, pc}          ; call EventHandler, returns to ...

        TEQ     r12, #1
        Pull    pc,NE

      [ ZeroPage = 0
        LDRB    r14, [r12, #CallBack_Flag-1] ; IRQs are still disabled
        ORR     r14, r14, #CBack_OldStyle
        STRB    r14, [r12, #CallBack_Flag-1]
      |
        LDR     r12, =ZeroPage
        LDRB    r14, [r12, #CallBack_Flag] ; IRQs are still disabled
        ORR     r14, r14, #CBack_OldStyle
        STRB    r14, [r12, #CallBack_Flag]
      ]

        Pull    pc                      ; claim EventV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Process timer zero IRQ device (100Hz clock)
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ALIGN 32

TickOne ROUT

        ; Don't push r14 - we're using new interface, and claim the vector
        Push    "r0,r9,r12"
        AddressHAL
        
        ; In some chips, Timer0 is latched in the timer block instead of,
        ; or as well as in the interrupt controller
        MOV     R0, #0 ; clear latch for Timer0
        CallHAL HAL_TimerIRQClear
        
        Pull    "r0" ; get device number back
        CallHAL HAL_IRQClear
        Pull    "r9,r12"

        LDR     R1, =ZeroPage
        LDR     R0, [R1, #MetroGnome]
        ADD     R0, R0, #1
        STR     R0, [R1, #MetroGnome]

        LDRB    R0, CentiCounter        ; Counter for VDU CTRL timing
        SUBS    R0, R0, #1
        STRCSB  R0, CentiCounter        ; decrement if not zero

        LDR     R0, IntervalTimer +0
        ADDS    R0, R0, #1              ; Increment the low 4 bytes
        STR     R0, IntervalTimer +0

        LDREQB  R0, IntervalTimer +4
        ADDEQ   R0, R0, #1              ; and carry into 5th byte if necessary
        STREQB  R0, IntervalTimer +4

        Push    "R4,R12"                ; R0-R3 already pushed

        TEQEQ   R0, #&100               ; has interval timer crossed zero ?
        MOVEQ   R0, #Event_IntervalTimer ; Event ITCZ
        BLEQ    OSEVEN

        BL      CentiSecondTick         ; Notify keyboard of a centisecond

        Pull    "R4,R12"

        LDR     R0, RealTime +0         ; Increment 5-byte real time
        ADDS    R0, R0, #1
        STR     R0, RealTime +0
        LDRCSB  R0, RealTime +4
        ADDCS   R0, R0, #1              ; Won't wrap until 2248 and then it
        STRCSB  R0, RealTime +4         ; all falls over anyway

        LDRB    R0, TimerState          ; get switch state
        TEQ     R0, #5                  ; toggles between 5 and 10

        LDREQ   R1, TimerAlpha +0       ; either load from one
        LDREQB  R2, TimerAlpha +4

        LDRNE   R1, TimerBeta +0        ; or the other
        LDRNEB  R2, TimerBeta +4

        ADREQ   R3, TimerBeta +0        ; and point to t'other
        ADRNE   R3, TimerAlpha +0

        ADDS    R1, R1, #1              ; increment
        ADC     R2, R2, #0              ; with carry

        STR     R1, [R3]                ; and store back
        STRB    R2, [R3, #4]

        EOR     R0, R0, #&0F            ; 5 <-> 10
        STRB    R0, TimerState

        Push    R10

        MOV     R10, #TickerV           ; call 100Hz vector
        BL      CallVector              ; IRQ's still disabled

        BL      ProcessTickEventChain   ; Re-enables IRQs

        Pull    "R10,PC"

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Process VSync IRQ device
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

UpdateFalseVsync ROUT
        ; claim or release falsevsync vector if vsyncs supported/not supported
        TST     r0, #GVDisplayFeature_NoVsyncIRQ ; are VSyncs not generated?
        Entry   "r0-r2"
        MOV     r0, #TickerV
        ADR     r1, FalseVsyncIRQ
        LDR     r2, =ZeroPage+OsbyteVars
        BEQ     %ft2
        SWI     XOS_Claim
        EXIT
2       SWI     XOS_Release
        EXIT

        ALIGN 32
FalseVsyncIRQ ROUT
        LDR     R1, =ZeroPage
        LDR     R0, [R1, #MetroGnome]
        TST     R0, #1
        MOVEQ   pc, lr
        Push    "lr"
        ; Fall through...

VsyncIRQ_ExtEntry ROUT
        LDRB    R0, CFStime             ; decrement 'CFS' timer !
        SUB     R0, R0, #1
        STRB    R0, CFStime

        VDWS    WsPtr                   ; Do our stuff before issuing VSYNC event
        BL      VsyncCall
        BYTEWS  WsPtr

        MOV     R0, #Event_VSync        ; VSYNC event number
        BL      OSEVEN

        LDRB    R1, FlashCount
        SUBS    R1, R1, #1
        Pull    PC, CC                  ; was zero, so frozen
        STRNEB  R1, FlashCount          ; else if now non-zero, store it back
        Pull    PC, NE                  ; not time to flash yet

        LDRB    R1, FlashState          ; Get the state and
        EORS    R1, R1, #1              ; flip to the other one (setting flags)
        STRB    R1, FlashState

        LDREQB  R2, SpacPeriod          ; get appropriate new period
        LDRNEB  R2, MarkPeriod
        STRB    R2, FlashCount          ; and put into counter

        VDWS    WsPtr
        Push    R4
        BEQ     dothesecondflash

dothefirstflash
        BL      DoFirstFlash
        Pull    "R4, PC"

dothesecondflash
        BL      DoSecondFlash
        Pull    "R4, PC"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        END
@


4.15
log
@Merge SMP branch to trunk
Detail:
  Since the current SMP changes are fairly minor, and the trunk is seeing most development, from a maintenance perspective it makes sense to merge the changes to trunk. This will also make sure they get some wider testing ready for when the next round of SMP development takes place.
  Changes:
  - Docs/SMP - New docs folder describing SMP-related changes to the HAL and interrupt handling. Some of the IRQ changes can also be taken advantage of by single-core devices, since it introduces a way to describe which interrupt sources can be routed to IRQ & FIQ
  - Makefile, hdr/DBellDevice, hdr/HALDevice - New HAL device for an inter-processor software-generated interrupt source ("doorbell")
  - hdr/HALEntries - Reuse the unused matrix keyboard & touchscreen HAL entry points for the new IRQ handling & SMP-related HAL calls
  - hdr/KernelWS - Bump up MaxInterrupts
  - hdr/OSMem, s/MemInfo - Introduce OS_Memory 19, to allow for DMA to/from cacheable memory without actually altering the cacheability of the pages (which can be even more tricky in SMP systems than it is in uniprocessor systems)
  - hdr/Options - Introduce SMP build switch. Currently this controls whether the ARMops will operate in "SMP-friendly" mode or not (when running on MP processors)
  - s/ARMops, s/MemMap2 - Introduce the ARMv7MP ARMop implementation. Simplify DCache_LineLen / ICache_LineLen handling for WB_CR7_Lx so that it's the plain value rather than log2(n)-2
  - s/ExtraSWIs - If ARMops are in SMP-friendly mode, global OS_SynchroniseCodeAreas now only syncs application space and the RMA. This is because there is no trivial MP-safe global IMB operation available. This will also make global OS_SynchroniseCodeAreas significantly slower, but the documentation has always warned against performing a global IMB for just that reason, so code that suffers performance penalties should really try and switch to a ranged IMB.
  - s/NewIRQs - Update some comments regarding IRQ handler entry/exit conditions
Admin:
  Untested


Version 6.09. Tagged as 'Kernel-6_09'
@
text
@d641 13
@


4.14
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d47 1
a47 1
; IRQ1V called with r0-r3,r11,r12 trashable. r12=0
d141 2
a142 3
; ******* IRQ device handlers entered with r0-r3,r11,r12,r14 trashable *******
;   r0  =  device number (if HAL)
;   r3  -> IOC (not in HAL world, unless IOMD HAL is helpful)
d144 2
a145 1
;   r14 =  return address to MOS IRQ exit sequence
@


4.14.2.1
log
@Initial SMP changes
Detail:
  This commit lays some of the groundwork for SMP support within the HAL, kernel, and OS.
  Makefile, hdr/HALDevice, hdr/DBellDevice - Add definitions for a doorbell HAL device, to allow CPU cores to signal each other via interrupts
  hdr/HALEntries - Repurpose HAL_Matrix and HAL_Touchscreen entry points for new SMP-related entry points. Add a couple of IRQ-related definitions.
  hdr/KernelWS - Boost MaxInterrupts to 256
  hdr/Options - Add new SMP build switch to control whether the kernel is built in SMP-friendly mode or not. SMP-friendly kernels should still run on single-core machines, but may behave slightly differently.
  s/ARMops - Make as many ARMops SMP-safe as possible, relying on hardware support for broadcasting of cache/TLB maintenance operations
  s/ExtraSWIs - Make SMP-friendly full OS_SynchroniseCodeAreas only sync application space and the RMA (full-cache IMB not really possible with SMP)
  s/NewIRQs - Update IRQ despatcher comments to (hopefully) reflect reality
  Docs/SMP/HAL, Docs/SMP/IRQ - Add documentation covering the new HAL calls and IRQ behaviour
Admin:
  Tested on Raspberry Pi 2, 3, OMAP4, iMX6


Version 5.86, 4.129.2.2. Tagged as 'Kernel-5_86-4_129_2_2'
@
text
@d47 1
a47 1
; IRQ1V called with r0-r3,r11,r12 trashable. r12=ZeroPage
d141 3
a143 2
; IRQ handlers are called as follows:
;   r0  =  device number
d145 1
a145 2
;  [r13]=  return address to claim IRQ. r0-r3, r12, r14 corruptible.
;   r14 =  return address to pass on to next handler (unhandled shared IRQ). r1-r2, r12, r14 corruptible.
@


4.13
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a98 1
      [ FixCallBacks
a99 3
      |
        B        Do_CallBack
      ]
@


4.12
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a39 6
  [ :LNOT:No26bitCode
        BIC     r0, lr, #&1F            ; clear out foreground mode bits
        ORR     r0, r0, #I32_bit + IRQ26_mode ; force IRQ_26 mode and I bit set
        MSR     CPSR_c, r0
  ]

a64 6
  [ :LNOT:No26bitCode
        MRS      r0, CPSR
        ORR      r0, r0, #&10
        MSR      CPSR_c, r0                     ; switch back to IRQ32 mode
  ]

a91 1
 [ No26bitCode :LOR: FixCallBacks
a92 4
 |
        BIC      r0, r0, #&1F
        ORR      r0, r0, #SVC26_mode
 ]
a111 2
        ASSERT    HAL ; Pre-HAL code is gone. Sorry!

a290 1
 [ HAL
a291 1
 ]
a313 1
 [ HAL
a318 5
 |
        LDR     r10, [sp, #4*2]         ; r12 value
        LDR     r11, [sp, #4*1]         ; call address
        MOV     r12, r2
 ]
a370 1
 [ HAL
a371 1
 ]
a389 1
 [ HAL
a390 3
 |
01      LDMIA   r12, {r3, r10}
 ]
a395 1
 [ HAL
a396 3
 |
        CMP     r12, #0
 ]
a413 1
 [ HAL
a417 1
 ]
a421 1
 [ HAL
a422 1
 ]
a464 1
 [ HAL
a466 3
 |
        Pull    "r10, pc"               ; return: someone will always claim it.
 ]
a469 1
 [ HAL
a471 4
 |
;   r0  must still have devno*3 in it
;   r12 is 0 (from vector)
 ]
a474 2
; NB. a cheap way of dividing by ~3 is *11,/32: accurate for 0..31 result ...

a476 1
 [ HAL
a482 44
 |
01      SUBS    r0, r0, #3
        ADDGE   r12, r12, #1
        BGT     %BT01                   ; r12 := r0 DIV 3

        CMP     R12, #8
        MOVLO   R0, #IOCIRQMSKA
        BLO     %FT03

        CMP     R12, #16
        SUBLO   R12, R12, #8
        MOVLO   R0, #IOCIRQMSKB
        BLO     %FT03

        CMP     R12, #IOMD_MouseRxFull_DevNo
        SUBLO   R12, R12, #IOMD_DMAChannel0_DevNo
        MOVLO   R0, #IOMD_DMAMSK
        BLO     %FT03

 [ MorrisSupport
        CMP     R12, #IOMD_C_Bit0_DevNo
        SUBLO   R12, R12, #IOMD_MouseRxFull_DevNo       ;reduce to bit number 0..7
        MOVLO   R0, #IOMD_IRQMSKD                       ; in IRQ D interrupt register

        SUBHS   R12, R12, #IOMD_C_Bit0_DevNo
        MOVHS   R0, #IOMD_IRQMSKC
 ]

03
        ADD     r0, r0, #IOC
        MOV     r1, #1
        MOV     r1, r1, LSL r12         ; bit to clear

        MRS     lr, CPSR
        BIC     r12, lr, #&0F
        ORR     r12, r12, #I32_bit+F32_bit+IRQ_mode
        MSR     CPSR_c, r12
        LDRB    r12, [r0]       ; FIQs off for updating IOCIRQMSKA
        BIC     r12, r12, r1
        STRB    r12, [r0]       ; relevant IRQ disabled
        MSR     CPSR_c, lr      ; absolute minimum FIQ disable period

        STRB    r1, [r0, #IOCIRQCLRA-IOCIRQMSKA] ; Clear IRQ
 ]
a563 1
 [ HAL
a575 6
 |                      
        Push    r14

        MOV     R0, #timer0_bit
        STRB    R0, [R3, #IOCIRQCLRA]   ; clear timer 0 interrupt
 ]
@


4.11
log
@  Added a couple of new sub-reason codes to OS_ReadSysInfo 6;
  Optimised the default IrqV handler.
Detail:
  * OS_ReadSysInfo 6 tells grubby programs lots of grubby info. This
    has been extended to include:

      18 - relocated base of OS SWI despatch table
      19 - relocated base of IRQ device head nodes
      20 - relocated end of IRQ device head nodes
      21 - top of the IRQ stack

    These values are known to be useful for debugging purposes.

  * The default IrqV handler gets the device number times three on
    entry in R0. It then went through a loop subtracting three and
    incrementing a counter to divide by three.

    This has been replaced by four ARM instructions which should
    give the same results (three to divide by three and one to set
    R0 to zero - as the old code did).

    If the device number is outside the range 0..31, the new code
    may produce inaccurate results, but this should not happen.
Admin:
  Not tested ;)

Version 5.43. Tagged as 'Kernel-5_43'
@
text
@d35 1
a35 1
        mrs     AL, lr, SPSR
d43 1
a43 1
        msr     AL, CPSR_c, r0
d46 1
a46 1
        MOV     r12, #0
d62 6
a67 1
        MOV      r11, #0
d72 1
a72 1
        mrs      AL, r0, CPSR
d74 1
a74 1
        msr      AL, CPSR_c, r0                 ; switch back to IRQ32 mode
d79 6
a84 3
        Pull     "r1-r3, r11, r12, lr", EQ
        msr      EQ, SPSR_cxsf, lr
        Pull     "r0, pc", EQ, ^
d86 1
d90 1
a90 3
        Pull     "r1-r3, r11, r12, lr", NE
        msr      NE, SPSR_cxsf, lr
        Pull     "r0, pc", NE, ^
d97 1
a97 1
        mrs      AL, r0, CPSR
d99 1
a99 1
        msr      AL, CPSR_c, r0
d102 1
a102 1
        msr      AL, CPSR_c, r0
d104 1
a104 1
 [ No26bitCode
d110 1
a110 1
        msr      AL, CPSR_c, r0
d114 1
a114 1
        MOV      r10, #0
d116 3
d120 1
d129 1
a129 1
       ALIGN 32
d131 4
a134 1
DefaultIRQ1Vcode ROUT
d136 1
a136 7
 [ IO_Type = "IOMD"
        MOV     r3, #IOC                ; base for IOC and IOMD
        LDRB    r0, [r3, #IOMD_DMAREQ]
        TEQ     r0, #0
        ADRNE   r1, IrqDMADevnos
        LDREQB  r0, [r3, #IOCIRQREQB]   ; if not DMA then assume IRQB until we know otherwise
        ADREQ   r1, IrqReqBDevnos
d138 1
a138 14
 [ MorrisSupport
;>>>RCM Says should we use separate Morris specific code, cos Morris doesn't support
;>>>RCM all IOMD_DMAREQ bits and non Morris machines don't have IOMD_IRQRQD.
;>>>RCM Look at use of NoInterrupt.
        ADREQ   r12, DeviceTables       ; can't reach these tables with ADR

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQD]
        ADDEQ   r1, r12, #IrqReqDDevnos-DeviceTables

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQC]
        ADDEQ   r1, r12, #IrqReqCDevnos-DeviceTables
 ]
d140 1
a140 16
        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOCIRQREQA]   ; not DMA and not IRQB so assume IRQA
        ADREQ   r1, IrqReqADevnos

        LDRB    r0, [r1, r0]            ; pick up offset in device despatcher
        ADD     r1, pc, r0, LSL #2      ; so table contains DevNo * 3
        LDMIA   r1, {r12, pc}
 |
        MOV     r3, #IOC
        LDRB    r0, [r3, #IOCIRQREQB]
        CMP     r0, #0
        LDREQB  r0, [r3, #IOCIRQREQA]

        ADREQ   r1, IrqReqADevnos
        ADRNE   r1, IrqReqBDevnos
        LDRB    r0, [r1, r0]            ; pick up offset in device despatcher
d142 21
a162 3
        ADD     r1, pc, r0, LSL #2      ; so table contains DevNo * 3
        LDMIA   r1, {r12, pc}
 ]
d165 2
a166 1
;   r3  -> IOC
d170 1
a170 87
 [ IO_Type = "IOMD"
  [ MorrisSupport
NoInterrupt * 38 ; Morris has IOMD's extra interrupts plus 16 of its own
  |
NoInterrupt * 22 ; IOMD has 6 more interrupts for DMA
  ]
 |
NoInterrupt * 16 ; internal devno; when ReqA = 0!
 ]

Devices

; Register A devices
; pbusy handler
        & 0             ; R12 value
        & IRQ           ; call address
        & 0             ; link
; ringing handler
        & 0
        & IRQ
        & 0
; printer acknowledge
        & 0
        & IRQ
        & 0
; vsync handler
        & OsbyteVars
        & VsyncIRQ
        & 0
; power on reset: this can't happen, but call IRQ2V if it does.
        & 0
        & IRQ
        & 0
; timer0
        & OsbyteVars
        & TickOne
        & 0
; timer1
        & 0
        & IRQ
        & 0
; FIQ downgrade
        & 0
        & IRQ
        & 0

; register B devices
; PFIQ downgrade
        & PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        & PFIQasIRQ_Despatch
        & 0
; sound
        & 0
        & IRQ
        & 0
; serial
        & 0
        & IRQ
        & 0
; winnie IRQ
        & 0
        & IRQ
        & 0
; Disc changed
        & 0
        & IRQ
        & 0
; podule IRQ
        & PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        & PIRQ_Despatch
        & 0
; serial TX     (Keyboard serial transmit register empty)
        & IOC
 [ Keyboard_Type = "A1A500"
        & IrqTx
 |
        & IRQ
 ]
        & 0
; serial RX     (Keyboard serial receive register full)
        & IOC
 [ Keyboard_Type = "A1A500"
        & IrqRx
 |
        & IRQ
 ]
        & 0
d172 1
a172 98
 [ IO_Type = "IOMD"
; IOMD DMA devices
; DMA channel 0
        & 0
        & IRQ
        & 0
; DMA channel 1
        & 0
        & IRQ
        & 0
; DMA channel 2
        & 0
        & IRQ
        & 0
; DMA channel 3
        & 0
        & IRQ
        & 0
; Sound DMA channel 0
        & 0
        & IRQ
        & 0
; Sound DMA channel 1
        & 0
        & IRQ
        & 0
 ]

 [ MorrisSupport
; register D devices
; Mouse port Rx full
        & IOC
        & IRQ
        & 0
; Mouse port Tx empty
        & IOC
        & IRQ
        & 0
; AtoD (Joystick)
        & 0
        & IRQ
        & 0
; Nevent1
        & 0
        & IRQ
        & 0
; Nevent2
        & 0
        & IRQ
        & 0
; The following are just place fillers in case IRQD bits 5 to 7 are ever used.
; NoInterrupt
        & 0
        & IRQ
        & 0
; NoInterrupt
        & 0
        & IRQ
        & 0
; NoInterrupt
        & 0
        & IRQ
        & 0

; register C devices
; Bit0
        & 0
        & IRQ
        & 0
; Bit1
        & 0
        & IRQ
        & 0
; Bit2
        & 0
        & IRQ
        & 0
; Bit3
        & 0
        & IRQ
        & 0
; Bit4
        & 0
        & IRQ
        & 0
; Bit5
        & 0
        & IRQ
        & 0
; Bit6
        & 0
        & IRQ
        & 0
; Bit7
        & 0
        & IRQ
        & 0
 ]
d174 1
a174 66
; Neither A or B is interrupting, which is impossible: just call IRQ2V anyway
        & 0
        & IRQ
        & 0


; Following tables encode the priority of the devices within each register
;
DeviceTables


 [ IO_Type = "IOMD"
; Prioritised IOMD DMA device numbers

IrqDMAPrio0     * 1:SHL:5
IrqDMADev0      * IOMD_DMASound1_DevNo

IrqDMAPrio1     * 1:SHL:4
IrqDMADev1      * IOMD_DMASound0_DevNo

IrqDMAPrio2     * 1:SHL:3
IrqDMADev2      * IOMD_DMAChannel3_DevNo

IrqDMAPrio3     * 1:SHL:2
IrqDMADev3      * IOMD_DMAChannel2_DevNo

IrqDMAPrio4     * 1:SHL:1
IrqDMADev4      * IOMD_DMAChannel1_DevNo

IrqDMAPrio5     * 1:SHL:0
IrqDMADev5      * IOMD_DMAChannel0_DevNo


       GBLA  DTabC
DTabC  SETA 1

IrqDMADevnos
  = NoInterrupt*3

; Top 2 bits are always 0 so table need only be 64 bytes
  WHILE DTabC <64
  [ (DTabC:AND:IrqDMAPrio5)<>0
  = IrqDMADev5*3
  |
  [ (DTabC:AND:IrqDMAPrio4)<>0
  = IrqDMADev4*3
  |
  [ (DTabC:AND:IrqDMAPrio3)<>0
  = IrqDMADev3*3
  |
  [ (DTabC:AND:IrqDMAPrio2)<>0
  = IrqDMADev2*3
  |
  [ (DTabC:AND:IrqDMAPrio1)<>0
  = IrqDMADev1*3
  |
  [ (DTabC:AND:IrqDMAPrio0)<>0
  = IrqDMADev0*3
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND
d176 1
a176 1
 ]
d178 1
d180 1
a180 111
; generic IRQA bits
IrqReqAPrio0 * por_bit
IrqReqADev0  * PowerOn_DevNo

IrqReqAPrio4 * timer1_bit
IrqReqADev4 * Timer1_DevNo

IrqReqAPrio5 * vsync_bit
IrqReqADev5 * VSync_DevNo

IrqReqAPrio6 * timer0_bit
IrqReqADev6 * Timer0_DevNo

IrqReqAPrio7 * force_bit
IrqReqADev7 * FIQDowngrade_DevNo

; Machine specific IRQB bits (devices 0-2)

 [ IO_Type = "IOC-A1" :LOR: IO_Type = "IOC-A500"
IrqReqAPrio1 * ring_bit
IrqReqADev1 * Ringing_DevNo

IrqReqAPrio2 * pbusy_bit
IrqReqADev2 * PrinterBusy_DevNo

IrqReqAPrio3 * pack_bit
IrqReqADev3 * PrinterAck_DevNo
 ]

 [ IO_Type = "IOEB"
IrqReqAPrio1 * IOEB_battery_low_bit
IrqReqADev1 * Ringing_DevNo

IrqReqAPrio2 * pbusy_bit
IrqReqADev2 * PrinterBusy_DevNo

IrqReqAPrio3 * IOEB_floppy_index_bit
IrqReqADev3 * PrinterAck_DevNo
 ]

 [ IO_Type = "IOMD"
IrqReqAPrio1 * 1:SHL:1          ; not used
IrqReqADev1 * 1

 [ ReassignedIOMDInterrupts
 ASSERT IOMDr_PrinterIRQ_DevNo = 2

IrqReqAPrio2 * IOMDr_printer_IRQ_bit
IrqReqADev2 * IOMDr_PrinterIRQ_DevNo

IrqReqAPrio3 * 1:SHL:0          ; not used
IrqReqADev3 * 0
 |
 ASSERT IOMD_PrinterIRQ_DevNo = 0
 ASSERT IOMD_FloppyIndex_DevNo = 2

IrqReqAPrio2 * IOMD_printer_IRQ_bit
IrqReqADev2 * IOMD_PrinterIRQ_DevNo

IrqReqAPrio3 * IOMD_floppy_index_bit
IrqReqADev3 * IOMD_FloppyIndex_DevNo
 ]
 ]


DTabC  SETA 1

IrqReqADevnos
  =  NoInterrupt*3
  WHILE DTabC <256
  [ (DTabC:AND:IrqReqAPrio7)<>0
  = IrqReqADev7*3
  |
  [ (DTabC:AND:IrqReqAPrio6)<>0
  = IrqReqADev6*3
  |
  [ (DTabC:AND:IrqReqAPrio5)<>0
  = IrqReqADev5*3
  |
  [ (DTabC:AND:IrqReqAPrio4)<>0
  = IrqReqADev4*3
  |
  [ (DTabC:AND:IrqReqAPrio3)<>0
  = IrqReqADev3*3
  |
  [ (DTabC:AND:IrqReqAPrio2)<>0
  = IrqReqADev2*3
  |
  [ (DTabC:AND:IrqReqAPrio1)<>0
  = IrqReqADev1*3
  |
  [ (DTabC:AND:IrqReqAPrio0)<>0
  = IrqReqADev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND


; generic IRQB bits
IrqReqBPrio2 * podule_FIQ_as_IRQ_bit
IrqReqBDev2  * PFIQasIRQ_DevNo

IrqReqBPrio3 * serial_Tx_bit
IrqReqBDev3 * SerialTx_DevNo
d182 1
a182 2
IrqReqBPrio4 * serial_Rx_bit
IrqReqBDev4 * SerialRx_DevNo
d184 67
a250 2
IrqReqBPrio5 * podule_IRQ_bit
IrqReqBDev5 * Podule_DevNo
d252 1
a252 1
; Machine specific IRQB bits
a253 236
 [ IO_Type = "IOC-A500"
IrqReqBPrio0 * 0
IrqReqBDev0 * NoInterrupt

IrqReqBPrio1 * sound_IRQ_bit
IrqReqBDev1 * Sound_DevNo

IrqReqBPrio6 * winnie_IRQ_bit :OR: winnie_DRQ_bit
IrqReqBDev6 * WinnieIRQ_DevNo

IrqReqBPrio7 * serial_bit
IrqReqBDev7 * Serial_DevNo
 ]

 [ IO_Type = "IOC-A1"
IrqReqBPrio0 * winnie_DRQ_bit
IrqReqBDev0 * DiscChanged_DevNo

IrqReqBPrio1 * sound_IRQ_bit
IrqReqBDev1 * Sound_DevNo

IrqReqBPrio6 * winnie_IRQ_bit
IrqReqBDev6 * WinnieIRQ_DevNo

IrqReqBPrio7 * serial_bit
IrqReqBDev7 * Serial_DevNo
 ]

 [ IO_Type = "IOEB"
IrqReqBPrio0 * IOEB_ide_IRQ_bit
IrqReqBDev0 * DiscChanged_DevNo

IrqReqBPrio1 * IOEB_sound_IRQ_bit
IrqReqBDev1 * Sound_DevNo

IrqReqBPrio6 * IOEB_floppy_IRQ_bit
IrqReqBDev6 * WinnieIRQ_DevNo

IrqReqBPrio7 * serial_bit
IrqReqBDev7 * Serial_DevNo
 ]

 [ IO_Type = "IOMD"
 [ ReassignedIOMDInterrupts
IrqReqBPrio0 * IOMDr_MPEGAudio_IRQ_bit
IrqReqBDev0 * IOMDr_MPEGAudio_DevNo

IrqReqBPrio1 * IOMDr_MPEGVideo_IRQ_bit
IrqReqBDev1 * IOMDr_MPEGVideo_DevNo

IrqReqBPrio6 * IOMDr_Network_IRQ_bit
IrqReqBDev6 * IOMDr_Network_DevNo

IrqReqBPrio7 * IOMDr_serial_IRQ_bit
IrqReqBDev7 * IOMDr_Serial_DevNo
 |
IrqReqBPrio0 * IOMD_floppy_IRQ_bit
IrqReqBDev0 * DiscChanged_DevNo

IrqReqBPrio1 * IOMD_HardDisc_IRQ_bit
IrqReqBDev1 * Sound_DevNo

IrqReqBPrio6 * IOMD_Network_IRQ_bit
IrqReqBDev6 * WinnieIRQ_DevNo

IrqReqBPrio7 * IOMD_serial_IRQ_bit
IrqReqBDev7 * IOMD_Serial_DevNo
 ]
 ]


DTabC  SETA 1

IrqReqBDevnos
  =  NoInterrupt*3

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqBPrio7)<>0
  = IrqReqBDev7*3
  |
  [ (DTabC:AND:IrqReqBPrio6)<>0
  = IrqReqBDev6*3
  |
  [ (DTabC:AND:IrqReqBPrio5)<>0
  = IrqReqBDev5*3
  |
  [ (DTabC:AND:IrqReqBPrio4)<>0
  = IrqReqBDev4*3
  |
  [ (DTabC:AND:IrqReqBPrio3)<>0
  = IrqReqBDev3*3
  |
  [ (DTabC:AND:IrqReqBPrio2)<>0
  = IrqReqBDev2*3
  |
  [ (DTabC:AND:IrqReqBPrio1)<>0
  = IrqReqBDev1*3
  |
  [ (DTabC:AND:IrqReqBPrio0)<>0
  = IrqReqBDev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND


 [ MorrisSupport
; Prioritised IRQD device numbers

IrqReqDPrio0     * 1:SHL:4
IrqReqDDev0      * IOMD_Event2_DevNo

IrqReqDPrio1     * 1:SHL:3
IrqReqDDev1      * IOMD_Event1_DevNo

IrqReqDPrio2     * 1:SHL:2
IrqReqDDev2      * IOMD_AtoD_DevNo

IrqReqDPrio3     * 1:SHL:1
IrqReqDDev3      * IOMD_MouseTxEmpty_DevNo

IrqReqDPrio4     * 1:SHL:0
IrqReqDDev4      * IOMD_MouseRxFull_DevNo


DTabC  SETA 1

IrqReqDDevnos
  =  NoInterrupt*3

; Top 3 bits are always 0 so table need only be 32 bytes (this will
; need to change if bits 5 to 7 are ever used).
  WHILE DTabC <32
  [ (DTabC:AND:IrqReqDPrio4)<>0
  = IrqReqDDev4*3
  |
  [ (DTabC:AND:IrqReqDPrio3)<>0
  = IrqReqDDev3*3
  |
  [ (DTabC:AND:IrqReqDPrio2)<>0
  = IrqReqDDev2*3
  |
  [ (DTabC:AND:IrqReqDPrio1)<>0
  = IrqReqDDev1*3
  |
  [ (DTabC:AND:IrqReqDPrio0)<>0
  = IrqReqDDev0*3
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

; Prioritised IRQC device numbers. We have to handle ALL interrupts
; using specific device numbers as we don't know what the IO pins
; are connected to and the NOIRQ code has to know what bit to clear
; when an unknown interrupt is triggered.

IrqReqCPrio0    * 1:SHL:0
IrqReqCDev0     * IOMD_C_Bit0_DevNo

IrqReqCPrio1    * 1:SHL:1
IrqReqCDev1     * IOMD_C_Bit1_DevNo

IrqReqCPrio2    * 1:SHL:2
IrqReqCDev2     * IOMD_C_Bit2_DevNo

IrqReqCPrio3    * 1:SHL:3
IrqReqCDev3     * IOMD_C_Bit3_DevNo

IrqReqCPrio4    * 1:SHL:4
IrqReqCDev4     * IOMD_C_Bit4_DevNo

IrqReqCPrio5    * 1:SHL:5
IrqReqCDev5     * IOMD_C_Bit5_DevNo

IrqReqCPrio6    * 1:SHL:6
IrqReqCDev6     * IOMD_C_Bit6_DevNo

IrqReqCPrio7    * 1:SHL:7
IrqReqCDev7     * IOMD_C_Bit7_DevNo


DTabC   SETA 1

IrqReqCDevnos
  =  NoInterrupt*3

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqCPrio7)<>0
  = IrqReqCDev7*3
  |
  [ (DTabC:AND:IrqReqCPrio6)<>0
  = IrqReqCDev6*3
  |
  [ (DTabC:AND:IrqReqCPrio5)<>0
  = IrqReqCDev5*3
  |
  [ (DTabC:AND:IrqReqCPrio4)<>0
  = IrqReqCDev4*3
  |
  [ (DTabC:AND:IrqReqCPrio3)<>0
  = IrqReqCDev3*3
  |
  [ (DTabC:AND:IrqReqCPrio2)<>0
  = IrqReqCDev2*3
  |
  [ (DTabC:AND:IrqReqCPrio1)<>0
  = IrqReqCDev1*3
  |
  [ (DTabC:AND:IrqReqCPrio0)<>0
  = IrqReqCDev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND
 ]


DefaultIRQ1Vcode_end

  ASSERT DefaultIRQ1Vcode_end - DefaultIRQ1Vcode <= DefIRQ1Vspace
d262 1
a262 1
PodDesp_CallAddr  #  4     ; address to call if ?Address AND Mask <> 0
a265 2
 [ True

a269 1

a271 13
 |

PFIQasIRQ_Despatch  ROUT

        LDR     r12, =PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        B       %FT01

PIRQ_Despatch ; NOROUT

        LDR     r12, =PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
 ]


d277 1
a277 1
	EOR	r1, r1, r2, LSR #8
a281 1

d296 5
a300 2
; r0 = PFIQ|PIRQ devno -> r3 = interrupt location
;                         r4 = interrupt mask
d310 7
a316 2
        CMP     r0, #NoInterrupt
        BGE     DV_Fail_NaffDevNo
d318 2
d323 1
a323 1

d327 2
a328 1
        LDR     r0, [sp]
d332 1
a332 1
        WritePSRc SVC_mode+I_bit, r10   ; IRQs off for update
d335 7
d345 1
d365 1
a365 1

d377 2
a378 2
        LDREQ   r0, =PIRQ_Chain
        LDRNE   r0, =PFIQasIRQ_Chain
d384 1
d398 7
a404 2
        CMP     r0, #NoInterrupt
        BGE     DV_Fail_NaffDevNo
d407 2
d412 1
d419 3
d423 1
d428 4
a431 1
        LDR     r12, [r12, #8]          ; get the link
d433 1
d450 8
a457 2
        LDR     r12, [r2, #8]
        STR     r12, [r11, #8]          ; node delinked
d460 4
a463 1
03      LDR     r2, [r12, #8]           ; freeable = nextnode
d471 1
a471 1

d474 2
a475 2
        LDREQ   r0, =PIRQ_Chain-PodDesp_Link
        LDRNE   r0, =PFIQasIRQ_Chain-PodDesp_Link
d495 1
a502 10
 [ False
 ASSERT VIDC_Type <> "VIDC20"
 MOV r14, #11
 MUL r14, r0, r14
 MOV r14, r14, LSR #5
 ADR r10, irq_vtable
 LDR r14, [r10, r14, LSL #2]
 MOV r10, #VIDC
 STR r14, [r10]
 ]
d506 4
a510 22

 [ False
irq_vtable
 DCD &40000000 + &444
 DCD &40000000 + &008
 DCD &40000000 + &080
 DCD &40000000 + &088

 DCD &40000000 + &800
 DCD &40000000 + &808
 DCD &40000000 + &880
 DCD &40000000 + &FA8

 DCD &40000000 + &8AF
 DCD &40000000 + &00F
 DCD &40000000 + &0F0
 DCD &40000000 + &0FF

 DCD &40000000 + &F00
 DCD &40000000 + &F0F
 DCD &40000000 + &FF0
 DCD &40000000 + &FFF
d515 4
d521 1
d529 11
a539 13
 [ False
 ASSERT VIDC_Type <> "VIDC20"
 MOV r14, #11
 MUL r14, r0, r14
 MOV r14, r14, LSR #5
 ADR r10, irq_vtable
 LDR r14, [r10, r14, LSL #2]
 MOV r10, #VIDC
 STR r14, [r10]
 ]
        ADD     R12, R0, R0, LSL #3      ; r12 := 9*R0
        ADD     R12, R12, R0, LSL #1     ; r12 := 11*R0
        MOV     R12, R12, LSR #5         ; r12 := r0/3
a542 1
        MOVHS   R0, #0
d569 1
a569 1
        mrs    ,lr, CPSR
d572 1
a572 1
        msr    ,CPSR_c, r12
d576 1
a576 1
        msr    ,CPSR_c, lr      ; absolute minimum FIQ disable period
d579 1
d611 1
d613 4
d640 1
d644 7
d661 14
d679 1
d681 1
a681 1
        MOV     R1, #0
a737 1
 [ TickIrqReenter
a741 2
 |
        BL      ProcessTickEventChain
a742 3
        MOV     R10, #TickerV           ; call 100Hz vector
        BL      CallVector
 ]
d750 7
d758 1
a758 7
VsyncIRQ ROUT

        Push    r14

        MOV     R0, #vsync_bit
        STRB    R0, [R3, #IOCIRQCLRA]   ; Clear the vsync interrupt

@


4.10
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d1063 3
a1065 3
01      SUBS    r0, r0, #3
        ADDGE   r12, r12, #1
        BGT     %BT01                   ; r12 := r0 DIV 3
d1069 1
@


4.10.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d35 1
a35 1
        MRS     lr, SPSR
d43 1
a43 1
        MSR     CPSR_c, r0
d67 1
a67 1
        MRS      r0, CPSR
d69 1
a69 1
        MSR      CPSR_c, r0                     ; switch back to IRQ32 mode
d75 1
a75 1
        MSREQ    SPSR_cxsf, lr
d82 1
a82 1
        MSRNE    SPSR_cxsf, lr
d90 1
a90 1
        MRS      r0, CPSR
d92 1
a92 1
        MSR      CPSR_c, r0
d95 1
a95 1
        MSR      CPSR_c, r0
d103 1
a103 1
        MSR      CPSR_c, r0
d1095 1
a1095 1
        MRS     lr, CPSR
d1098 1
a1098 1
        MSR     CPSR_c, r12
d1102 1
a1102 1
        MSR     CPSR_c, lr      ; absolute minimum FIQ disable period
@


4.10.2.2
log
@More HAL work. IOMD HAL fleshed out somewhat - system gets most of the way
through initialisation.

Version 5.35, 4.79.2.5. Tagged as 'Kernel-5_35-4_79_2_5'
@
text
@a121 6
 [ HAL
        MOV     r11, r9                 ; r11 trashable - r9 needs to be preserved
        AddressHAL                      ; modifies r9
        CallHAL HAL_IRQSource
        MOV     r9, r11
 |
d143 1
a143 1
 ] ; MorrisSupport
d150 3
a152 1
 | ; IO_Type
d161 1
a161 2
 ] ; IO_Type
 ] ; HAL
d164 1
d167 1
a167 2
;   r0  =  device number (even in old RISC OS!)
;   r3  -> IOC (not in HAL world, unless IOMD HAL is helpful)
a170 12
 [ HAL

DefaultIRQ1Vcode_end

Devices

NoInterrupt     * 64

        ASSERT  DefaultIRQ1Vcode_end + (NoInterrupt+1) * 12 - DefaultIRQ1Vcode <= DefIRQ1Vspace


 | ; HAL
d179 1
a179 1
 ] ; IO_Type
a363 1

d780 1
a783 53

 ] ; :LNOT: HAL


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

InitialiseIRQ1Vtable

        Push    "v1,sb,lr"
; copy IRQ handler: not done with rest of copying
; because soft break needs the info to free any claimed blocks.

        LDR     a1, =DefaultIRQ1V
        ADRL    a2, DefaultIRQ1Vcode
        ADRL    a3, DefaultIRQ1Vcode_end
CopyDefaultIRQ1V
        LDR     a4, [a2], #4
        STR     a4, [a1], #4
        CMP     a2, a3
        BNE     CopyDefaultIRQ1V

  [ HAL
        AddressHAL
        MOV     v1, a1
        ADD     a3, a1, #(NoInterrupt+1)*12
        MOV     a2, #0
        LDR     a4, =IRQ
        MOV     ip, #0
FillInDefaultIRQ1VDevices
        STMIA   a1!, {a2, a4, ip}
        CMP     a1, a3
        BNE     FillInDefaultIRQ1VDevices

; Now fill in our basic device handlers. First the timer.
        MOV     a1, #0
        CallHAL HAL_TimerDevice
        LDR     a2, =OsbyteVars
        LDR     a3, =TickOne
        ADD     a1, a1, a1, LSL #1
        ADD     a1, v1, a1, LSL #2
        STMIA   a1, {a2, a3}

; Now the VSync
        MOV     a1, #0
        CallHAL HAL_VideoFlybackDevice
        LDR     a2, =OsbyteVars
        LDR     a3, =VsyncIRQ
        ADD     a1, a1, a1, LSL #1
        ADD     a1, v1, a1, LSL #2
        STMIA   a1, {a2, a3}
  ]
        Pull    "v1,sb,pc"

@


4.10.2.3
log
@Interrupt handling tweaks.

Version 5.35, 4.79.2.7. Tagged as 'Kernel-5_35-4_79_2_7'
@
text
@a125 1
        ADD     r0, r0, r0, LSL #1      ; multiply by 3
a1327 6
    [ HAL
        MOV     r11, r9
        AddressHAL
        CallHAL HAL_IRQClear
        MOV     r9, r11
    |
a1329 1
    ]
@


4.10.2.4
log
@Wahey! This version gives you a display.

It says "Abort on data transfer".
@
text
@d123 1
a123 1
        Push    "r9"
a124 1
        MOV     r11, r14                ; r11 trashable
d126 2
a127 4
        Pull    "r9"
        ADD     r1, r0, r0, LSL #1      ; multiply by 3
        MOV     r14, r11
        ADD     r1, pc, r1, LSL #2      ; so table contains DevNo * 3
d167 1
a168 1
 ] ; HAL
d172 1
a172 1
;   r0  =  device number (if HAL)
a1245 6
 [ HAL
        MOV     r11, r9
        AddressHAL
        CallHAL HAL_IRQClear
        MOV     r9, r11
 |
a1247 1
 ]
@


4.10.2.5
log
@More L7200 HAL work
@
text
@a1136 6
 [ HAL
        MOV     r11, r9
        AddressHAL
        CallHAL HAL_IRQDisable
        MOV     r9, r11
 |
a1178 1
 ]
d1250 1
a1250 1
        Push    "r9,r12"
d1253 1
a1253 1
        Pull    "r9,r12"
d1340 1
a1340 1
        Push    "r9,r12"
d1343 1
a1343 1
        Pull    "r9,r12"
@


4.10.2.6
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d132 1
d160 10
d192 1
d198 3
d280 1
d306 1
d390 2
d447 3
d468 3
d472 19
d512 1
d570 43
d638 2
@


4.10.2.7
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a117 14
                  ^ 0
 [ HAL
IRQDesp_Link      # 4
IRQDesp_R12Val    # 4
IRQDesp_CallAddr  # 4

IRQDesp_Link_Unshared * 1       ; flag in Link (for _this_ node)
 |
IRQDesp_R12Val    # 4
IRQDesp_CallAddr  # 4
IRQDesp_Link      # 4
 ]
       ASSERT   IRQDesp_CallAddr = IRQDesp_R12Val + 4

d123 1
a123 1
        Push    "r9,lr"
d125 1
a125 1
;        MOV     r11, r14                ; r11 trashable
a127 1
        ADR     r2, Devices
d129 2
a130 9
;        MOV     r14, r11
        ADD     r11, r2, r1, LSL #2     ; so table contains DevNo * 3
 ;       ASSERT  IRQDesp_R12Val = 4
 ;       LDMIB   r1, {r12, pc}
01      MOV     lr, pc
        LDMIA   r11, {r11, r12, pc}
        TST     r11, #IRQDesp_Link_Unshared
        BEQ     %BT01
        Pull    pc
d160 1
a160 1
        ASSERT  IRQDesp_R12Val = 0
a161 1
 ] ; HAL
d173 1
a173 1
Devices * DefaultIRQ1Vcode_end + 12
d175 1
a175 2
NoInterrupt     * -1
MaxInterrupts   * 64
d177 1
a177 1
        ASSERT  Devices + MaxInterrupts * 12 - DefaultIRQ1Vcode <= DefIRQ1Vspace
d738 2
a739 2
        ADD     v1, a1, #12
        ADD     a3, v1, #MaxInterrupts*12
d741 2
a742 2
        MOV     a4, #-1
        LDR     ip, =IRQ
a744 1
        ADD     a4, a4, #1
d755 1
a755 1
        STMIB   a1, {a2, a3}
d760 5
a764 37
        CMP     a1, #-1
        LDRNE   a2, =OsbyteVars
        LDRNE   a3, =VsyncIRQ
        ADDNE   a1, a1, a1, LSL #1
        ADDNE   a1, v1, a1, LSL #2
        STMNEIB a1, {a2, a3}

 [ :LNOT:{FALSE}
; Now Podule bits
        MOV     a1, #IRQDesp_Link_Unshared
        LDR     a2, =PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        ADR     a3, PFIQasIRQ_Despatch
        ADD     lr, v1, #8*12
        STMIA   lr, {a1, a2, a3}
        ADR     a3, PIRQ_Despatch
        ADD     lr, v1, #13*12
        STMIA   lr, {a1, a2, a3}
 ]

; Now IIC - if any
        MOV     a1, #0
        CallHAL HAL_IICType
        LDR     a2, =IICType
        STR     a1, [a2]
        TST     a1, #IICFlag_HighLevel
        TSTNE   a1, #IICFlag_Background
        BEQ     %FT90
        SUB     sp, sp, #12
        MOV     a1, sp
        MOV     a2, #0
        CallHAL HAL_IICDevice
; I think it's safe to call A SWI here...
        LDMIA   sp!, {r0, r3, r4}
        LDR     r1, =IICIRQ
        MOV     r2, sb
        SWI     XOS_ClaimDeviceVector
90
d776 1
a776 1
PodDesp_CallAddr  #  4     ; address to call if (?Address EOR (Mask>>8)) AND Mask <> 0
d780 1
a780 30
 [ HAL:LAND:{FALSE}
        ROUT
; In    r1 -> top level node
;       r12 = sub chain
01      LDR     r12, [r12, #PodDesp_Link-PodDesp_R12Val]
SubInterrupt_Despatch
        LDMIA   r12!, {r2, r3}          ; address and mask
        CMP     r3, #&10000
        LDRLOB  r2, [r2]
        BHS     %FT02
        EOR     r2, r2, r3, LSR #8      ; polarity inversion
        TST     r2, r3                  ; check against mask
        BEQ     %BT01
        LDMIA   r12, {r12, pc}
02
        Push    "r0,r1,r12,lr"
        MOV     r0, r3
        MOV     r12, r3
        MOV     lr, pc
        MOV     pc, r2
        TEQ     r0, #0
        Pull    "r0,r1,r12,lr"
        BEQ     %BT01
        LDMIA   r12, {r12, pc}


NotSubInterrupt
        LDR     r1, [r1, #8]            ; call next (full) handler
        LDMIA   r1, {r12, pc}
 |
d786 1
d789 13
a810 1
 ]
d812 1
a812 1
Default_SubInterruptHandler_Node
a817 3
 [ HAL:LAND:{FALSE}
        &       NotSubInterrupt         ; handler code
 |
a818 1
 ]
a826 4
 [ HAL
; r3 = interrupt location     or r3 = 0 or (if r4 > 64K)  r3 = routine
; r4 = interrupt mask/polarity                            r4 = workspace
 |
a828 4
 ]

CDV_Flags * &FF000000
CDV_Shared * 1:SHL:31
d838 2
a839 5
 [ HAL
        BIC     r0, r0, #CDV_Flags
 ]
        CMP     r0, #MaxInterrupts
        BHS     DV_Fail_NaffDevNo
a840 4
 [ HAL:LAND:{FALSE}
;        TEQ     r3, #0
;        BNE     SubInterruptClaim
 |
a843 1
 ]
d848 1
a848 2
        LDR     r11, [sp]
        BIC     r0, r11, #CDV_Flags
d852 1
a852 1
        WritePSRc SVC_mode+I_bit, r10   ; IRQs off for update (on again on SWI exit)
a854 7
 [ HAL
        MOV     r10, r2
        TST     r11, #CDV_Shared
        ORREQ   r10, r10, #IRQDesp_Link_Unshared
        LDR     r11, [sp, #4*2]         ; r12 value
        LDR     r12, [sp, #4*1]         ; call address
 |
a857 1
 ]
a876 23
 [ HAL:LAND:{FALSE}
SubInterruptClaim
        Push    "r5"
        ADD     r0, r0, r0, LSL #1      ; *3
        LDR     r5, =DefaultIRQ1V-DefaultIRQ1Vcode+Devices
        ADD     r5, r5, r0, LSL #2
        LDR     r2, [r5, #IRQDesp_CallAddr]
        ADR     r3, SubInterrupt_Despatch
        TEQ     r2, r3
        BEQ     AlreadySubbed
        ; Need to claim the top-level interrupt.
        MOV     r3, #12
        BL      ClaimSysHeapNode
        Pull    "r5",VS
        BVS     DV_Exit
        WritePSRc SVC_mode+I_bit, r10   ; IRQs off for update (on again on SWI exit)
        LDMIA   r5, {r0, r3, r10}
        STMIA   r2, {r0, r3, r10}       ; copy current head into node
        ADR     r0, Default_SubInterruptHandler_Node
        ADR     r3, SubInterrupt_Despatch
        STR     r0, [r5, #IRQDesp_R12Val]
        STR     r3, [r5, #IRQDesp_CallAddr]
        STR     r2, [r5, #IRQDesp_Link]
a877 20
AlreadySubbed
        ; r1 -> top level interrupt entry
        MOV     r3, #PodDesp_NodeSize
        BL      ClaimSysHeapNode
        Pull    "r5",VS
        BVS     DV_Exit
        MOV     r10, r2
        ADD     r1, sp, #8
        LDMFD   r1, {r1-r3}
        STR     r1, [r10, #PodDesp_CallAddr]
        STR     r2, [r10, #PodDesp_R12Val]
        STR     r3, [r10, #PodDesp_Address]
        STR     r4, [r10, #PodDesp_Mask]
        WritePSRc SVC_mode+I_bit, r2    ; IRQs off for update
        LDR     r0, [r5, #IRQDesp_R12Val]
        STR     r0, [r10, #PodDesp_Link]
        STR     r10, [r5, #IRQDesp_R12Val]
        Pull    "r5"
        B       DV_Exit
 |
a895 1
 ]
d909 2
a910 5
 [ HAL
        BIC     r0, r0, #CDV_Flags
 ]
        CMP     r0, #MaxInterrupts
        BHS     DV_Fail_NaffDevNo
a912 1
 [ :LNOT:(HAL:LAND:{FALSE})
a915 1
 ]
a921 8
 [ HAL
;        TEQ     r3, #0
;        BNE     SubInterruptRelease
 ]

 [ HAL
01      LDMIB   r12, {r3, r10}
 |
a922 1
 ]
d927 1
a927 4
        LDR     r12, [r12, #IRQDesp_Link]
 [ HAL
        BICS    r12, r12, #IRQDesp_Link_Unshared
 |
a928 1
 ]
d945 2
a946 8
        LDR     r12, [r2, #IRQDesp_Link]
 [ HAL
        LDR     r14, [r11, #IRQDesp_Link]       ; preserve r11's "unshared" flag
        BIC     r12, r12, #IRQDesp_Link_Unshared
        AND     r14, r14, #IRQDesp_Link_Unshared
        ORR     r12, r12, r14
 ]
        STR     r12, [r11, #IRQDesp_Link] ; node delinked
d949 1
a949 1
03      LDR     r2, [r12, #IRQDesp_Link]; freeable = nextnode
a957 42
 [ HAL:LAND:{FALSE}
SubInterruptRelease
        ADR     r10, SubInterrupt_Despatch
10      LDR     r0, [r12, #IRQDesp_CallAddr]
        TEQ     r0, r10
        BEQ     %FT15

13      MOV     r11, r12
        LDR     r12, [r12, #IRQDesp_Link]
        TEQ     r12, #0
        BEQ     %BT11
        B       %BT10

15      SUB     r0, r12, #PodDesp_Link
17      LDR     r14, [r0, #PodDesp_Link]
        TEQ     r14, #0
        BEQ     %BT13

        LDR     r10, [r14, #PodDesp_Address]
        CMP     r10, r3
        LDREQ   r10, [r14, #PodDesp_Mask]
        CMPEQ   r10, r4
        LDREQ   r10, [r14, #PodDesp_CallAddr]
        CMPEQ   r10, r1
        LDREQ   r10, [r14, #PodDesp_R12Val]
        CMPEQ   r10, r2
        MOVNE   r0, r14
        BNE     %BT17

        LDR     r10, [r14, #PodDesp_Link]
        STR     r10, [r0,  #PodDesp_Link]!

        LDR     r0, [r12, #IRQDesp_R12Val]
        MOV     r2, r14
        ADR     r14, Default_SubInterruptHandler_Node
        TEQ     r0, r14                 ; last sub-interrupt gone?
        BNE     %BT04

        BL      FreeSysHeapNode         ; free sub-interrupt
        BVS     DV_Exit
        B       %BT02                   ; then go back to delink top level
 |
a980 1
 ]
a1000 3
 [ HAL
        Pull    "r10, lr, pc"           ; new-style CDV - pull return address
 |
a1001 1
 ]
a1027 4
 [ HAL
;   r0  must still have devno in it
;   r12 is 0 (from vector)
 |
a1029 1
 ]
a1047 2
        TEQ     r0, #0
        Pull    pc, MI
d1164 2
a1166 1
        ; Don't push r14 - we're using new interface, and claim the vector
a1171 2
        Push    r14

d1254 2
a1256 1
        ; Don't push r14 - we're using new interface, and claim the vector
a1261 2
        Push    r14

a1265 1
VsyncIRQ_ExtEntry
@


4.10.2.8
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d201 1
a201 1
DevicesEnd * Devices + MaxInterrupts * 12
a202 1
        ASSERT  DevicesEnd - DefaultIRQ1Vcode <= DefIRQ1Vspace
d391 1
a391 1
DevicesEnd
@


4.10.2.9
log
@  Miscellaneous stuff.
Detail:
  * Merged in the change to RISC OS 4.02 kernel that moved the GSTrans
    workspace out of scratch space.
  * Fixed a few bugs in callback postponement, and interrupt holes in
    callback dispatch. See Docs.CallbackChange for full info.
  * Fixed SystemSizeCMOS to SysHeapCMOS - wouldn't build as was.
  * Added an export of a C version of Hdr:HALDevice, based on the Hdr2H
    translation but with an additional struct definition. Required by
    SoundControl 1.00.
  * Added some additional location and ID allocations to Hdr:HALDevice.
    Required by today's HAL and SoundControl.
Admin:
  Partially tested.

Version 5.35, 4.79.2.56. Tagged as 'Kernel-5_35-4_79_2_56'
@
text
@d97 1
a97 1
 [ No26bitCode :LOR: FixCallBacks
a108 3
      [ FixCallBacks
        B        Do_CallBack_postpone_already_clear
      |
a109 1
      ]
@


4.10.2.10
log
@* HAL can choose to limit amount of screen memory to allocate
  [Not fully implemented - for now leaves at least 16MB free if only
  one RAM area; was 1MB].
* Added HAL_USBControllerInfo, HAL_MonitorLeadID and HAL_Video_Render.
* Added HAL->OS call OS_IICOpV.
* OS_MMUControl now allows independent control of I and C bits.
* Added facility to deactivate keyboard debounce (magic word "NoKd" in
  R2 in KeyV 0).
* Fixed problem with RAM amounts not a multiple of 4MB.
* Supremacy bit (in VDU 19) now sets all 8 bits of supremacy.
* Added PaletteV 14 (reads gamma tables).
* Added Supremacy transfer functions (like gamma correction, but for
  supremacy). Allows easy global supremacy effects in a mode-independent
  fashion. Controlled with PaletteV 15,16.
* Added modes 50-53 (320x240, 1,2,4,8bpp). Intended for small LCD.
* Added 13.5kHz versions of TV modes (selected by Hdr:Machine).
* Upped desktop version to 5.06.

Version 5.35, 4.79.2.66. Tagged as 'Kernel-5_35-4_79_2_66'
@
text
@a1124 3
 [ HAL
        BIC     r2, r2, #IRQDesp_Link_Unshared
 ]
@


4.10.2.11
log
@Added UnthreadV (vector &2B). Called near the end of despatch of the
outermost interrupt, in IRQ32/26 mode with IRQs disabled, just before
transient and non-transient callback checking is performed. Suitable for
implementing a CBAI replacement.

Version 5.35, 4.79.2.69. Tagged as 'Kernel-5_35-4_79_2_69'
@
text
@a65 8
        TEQ      r0, #0
        BNE      %F10
        Push     "r10"
        MOV      r10, #UnthreadV
        BL       CallVector
        Pull     "r10"
10

@


4.10.2.12
log
@* Changed some STB switches to Embedded_UI
* Added use of CDVPoduleIRQs (from Hdr:Machine)
* Fixed checksum corruption in OS_NVMemory block writes ending just below
  the checksum byte.
* Fixed R4 corruption by OS_Byte 162 with certain HALs.

Version 5.35, 4.79.2.71. Tagged as 'Kernel-5_35-4_79_2_71'
@
text
@d805 1
a805 1
 [ CDVPoduleIRQs
a920 1
  [ CDVPoduleIRQs
a922 1
  ]
a945 1
  [ CDVPoduleIRQs
a948 1
  ]
d1035 1
a1035 2
 ]
 [ CDVPoduleIRQs
d1075 1
a1075 1
 [ CDVPoduleIRQs
d1185 1
a1185 2
 ]
 [ CDVPoduleIRQs
@


4.10.2.13
log
@  Change to calling conditions of UnthreadV.
Detail:
  Previously, UnthreadV was only called when the IRQsema chain was empty, the
  link for the just-completed interrupt having just been removed. However,
  the information in the link is necessary to allow OS_Heap to be called from
  UnthreadV context, and patching up IRQsema within the UnthreadV handler
  prevents the implementation of a prioritised threading scheme. As a result,
  we must call UnthreadV every time the interrupt dispatch unthreads, and
  leave it up to the UnthreadV handler to distinguish between return to
  thread context and return from a nested interrupt handler.
Admin:
  Will require some sort of patch to enable heap-safe prioritised threading
  on RISC OS-STB 5.0.0 or RISC OS 5.07, the only two released OSes with the
  previous UnthreadV behaviour.

Version 5.35, 4.79.2.77. Tagged as 'Kernel-5_35-4_79_2_77'
@
text
@d62 6
d72 1
a72 4

        MOV      r11, #0
        Pull     r0
        STR      r0, [r11, #IRQsema]
@


4.10.2.14
log
@     several mode:
     1: default ticker based vsync generated whenever no device present to do so
     2: graphicsv handling and spec updated to use the hi 8 bits in the
        reason code (R4) to define the display number. Kernel only knows
        of display 0
Detail:
Admin:
     tested castle  castle added ip


Version 5.35, 4.79.2.81. Tagged as 'Kernel-5_35-4_79_2_81'
@
text
@d801 1
a801 8
;        BNE     %ft1
;        ; here if no vsync handler .. fudge it from tickerv
;        MOV     a1, #TickerV
;        LDR     a2, =FalseVsyncIRQ
;        LDR     a3, =OsbyteVars
;        SWI     XOS_Claim
        
1
a1494 7
FalseVsyncIRQ ROUT
        MOV     R1, #0
        LDR     R0, [R1, #MetroGnome]
        TST     R0, #1
        MOVEQ   pc, lr
        Push    "lr"
        B       VsyncIRQ_ExtEntry    
@


4.10.2.15
log
@       ensure FIQ as IRQ irq chain is correctly responded to..
Detail: Kevin work, in response to D Ellis fault find
Admin:
      Castle IP


Version 5.35, 4.79.2.82. Tagged as 'Kernel-5_35-4_79_2_82'
@
text
@d812 1
a812 1
        LDR     a2, =PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
a815 1
        LDR     a2, =PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
@


4.10.2.16
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d46 1
a46 1
        LDR     r12, =ZeroPage
d67 1
a67 1
        LDR      r11, =ZeroPage
d112 1
a112 1
        LDR      r10, =ZeroPage
d147 1
a147 6
      [ ZeroPage = 0
        MOV     r9, #0
      |
        LDR     r9, %FT02
      ]
        AddressHAL r9                   ; modifies r9
a161 4
      [ ZeroPage <> 0
02
        DCD     ZeroPage
      ]
d208 1
a208 5
  [ M_CortexA9
MaxInterrupts   * 160
  |
MaxInterrupts   * 96
  ] ; M_CortexA9
d757 1
a757 1
        Push    "v1-v3,sb,lr"
d786 1
a786 1
        LDR     a2, =ZeroPage+OsbyteVars
d796 1
a796 1
        LDRNE   a2, =ZeroPage+OsbyteVars
d812 1
a812 1
        LDR     a2, =ZeroPage+PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
d816 1
a816 1
        LDR     a2, =ZeroPage+PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
d823 4
a826 4
        LDR     v2, =ZeroPage+IICBus_Base
        MOV     v3, #0
80
        LDR     a1, [v2, #IICBus_Type]
d832 1
a832 1
        MOV     a2, v3
d837 1
a837 1
        MOV     r2, v3
a839 4
        ADD     v2, v2, #IICBus_Size
        ADD     v3, v3, #1
        CMP     v3, #IICBus_Count
        BNE     %BT80
d841 1
a841 1
        Pull    "v1-v3,sb,pc"
d1057 2
a1058 2
        LDREQ   r0, =ZeroPage+PIRQ_Chain
        LDRNE   r0, =ZeroPage+PFIQasIRQ_Chain
d1199 2
a1200 2
        LDREQ   r0, =ZeroPage+PIRQ_Chain-PodDesp_Link
        LDRNE   r0, =ZeroPage+PFIQasIRQ_Chain-PodDesp_Link
d1242 1
a1242 2
        Pull    "r10, lr"
        Pull    "pc"                    ; new-style CDV - pull return address
a1377 1
      [ ZeroPage = 0
a1378 4
      |
        LDRLS   r14, =ZeroPage+OsbyteVars+:INDEX:EventSemaphores
        LDRLSB  r14, [r0, r14]
      ]
a1401 1
      [ ZeroPage = 0
a1404 7
      |
        LDR     r12, =ZeroPage
        LDRB    r14, [r12, #CallBack_Flag] ; IRQs are still disabled
        ORR     r14, r14, #CBack_OldStyle
        STRB    r14, [r12, #CallBack_Flag]
      ]

d1428 1
a1428 1
        LDR     R1, =ZeroPage
d1504 1
a1504 1
        LDR     R1, =ZeroPage
@


4.10.2.17
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d914 1
a914 1
        EOR     r1, r1, r2, LSR #8
@


4.10.2.18
log
@Rationalise some old switches.
Export less in hdr:RISCOS.
Delete unused GetDecimalPair routine.
Move CheckYear with other RTC stuff out of PMF/osword.
Hide DebugROMInit and DebugROMErrors in release (even numbered) versions.

Version 5.35, 4.79.2.127. Tagged as 'Kernel-5_35-4_79_2_127'
@
text
@d1245 10
d1265 23
d1304 10
@


4.10.2.19
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@a889 1
      [ NoARMv5
a891 3
      |
        BLX     r2
      ]
@


4.10.2.20
log
@Merge with RPi branch
Detail:
  Merge the RPi branch with the HAL branch, ending RPi branch development
  Brief summary of changes brought in:
  * Added HAL_VideoStartupMode to allow the HAL to specify a startup mode for the OS
  * Fixed addresses being sent to GraphicsV_SetDMAAddress being wrong for external framestores (addresses were given as if internal framestore was in use)
  * Add InverseTextTransparency option for limited compile-time support for targets where framebuffer alpha channel is important
  * Fix ConfiguredLanguage for non-Tungsten builds
  * Update ARMv6 CPU detection to read cache parameters from cache type register instead of using KnownCPUTable
  * Add HALDebugHexTX/TX2/TX4 debug routines for writing out numbers via HAL
  * Use HAL_TimerIRQClear when clearing timer 0 interrupt instead of just HAL_IRQClear
  * Initialise FileLangCMOS using defines from Hdr:FSNumbers instead of magic numbers. Use SDFS on M_ARM11ZF.
  * Improved software mouse pointer support; software pointer now removed & restored in some of the same places the text cursor is
  * Improve support for external framestores; driver is now able to grow/shrink/move the framestore on mode changes if bit 5 of GraphicsV_DisplayFeatures R0 is set
  * GraphicsV_FramestoreAddress now has a default claimant which calls HAL_VideoFramestoreAddress
Admin:
  Tested on Raspberry Pi, Iyonix, OMAP3, IOMD


Version 5.35, 4.79.2.165. Tagged as 'Kernel-5_35-4_79_2_165'
@
text
@d1409 1
a1409 1
        Push    "r0,r9,r12"
a1410 7
        
        ; In some chips, Timer0 is latched in the timer block instead of,
        ; or as well as in the interrupt controller
        MOV     R0, #0 ; clear latch for Timer0
        CallHAL HAL_TimerIRQClear
        
        Pull    "r0" ; get device number back
d1413 1
a1413 1
 |                      
@


4.10.2.21
log
@Add new HAL call, HAL_IRQMax, to allow the kernel to determine the number of IRQ lines/devices at runtime
Detail:
  hdr/HALEntries - Reuse the old HAL_MonitorLeadID call number for HAL_IRQMax
  hdr/KernelWS - Rearrange CursorChunkAddress workspace a bit. Removed unused OldOscliBuffs and a couple of pre-HAL allocations, and made DefIRQ1Vspace the same size for all build configs. Add an IRQMax var to zero page workspace to cache the value returned by HAL_IRQMax.
  s/HAL - Initialise IRQMax shortly after HAL initialisation. Revise ClearPhysRAM comment to reflect which vars are preserved in the current version of the code.
  s/NewIRQs - Strip out a fair bit of pre-HAL code to make the file more readable. Update OS_ClaimDeviceVector/OS_ReleaseDeviceVector to check against IRQMax instead of the MaxInterrupts compile-time limit.
Admin:
  Tested on BB-xM, Iyonix, RiscPC, Pi
  Although the OS will now nominally adapt at runtime to how many IRQ devices there are, it's still using MaxInterrupts as an upper limit as the device claimant table has a fixed memory allocation.


Version 5.35, 4.79.2.182. Tagged as 'Kernel-5_35-4_79_2_182'
@
text
@a126 2
        ASSERT    HAL ; Pre-HAL code is gone. Sorry!

d128 1
d134 6
d141 1
a141 1
       ASSERT   IRQDesp_CallAddr = IRQDesp_R12Val + 4
d145 1
d153 1
d158 1
d160 2
d171 32
d210 2
d217 5
d227 539
d783 1
d814 6
d857 1
a857 1

d967 1
a967 3
        LDR     lr, =ZeroPage
        LDR     lr, [lr, #IRQMax]
        CMP     r0, lr
d1102 1
a1102 3
        LDR     lr, =ZeroPage
        LDR     lr, [lr, #IRQMax]
        CMP     r0, lr
@


4.10.2.22
log
@Adopt some switches from Hdr:Machine/Machine
SystemName, ROMSizeOffset, HAL32, HAL26 only used here, moved here.
Remove uses of "M_" booleans, apparently that's bad form.
Fix SWIDespatch_Size for the non thumb capable case (was ASSERTing).
Swapped UserMemStart for AppSpaceStart.
Removed last use of OldComboSupport (pre Medusa!).
Removed switch 'CDVPoduleIRQs', a correction to the machine definitions mean this can now simply be switched on NumberOfPodules (previously, IOMD couldn't chain podule interrupts).
Take out disabled sub interrupt support - it's in CVS if you want to try to get it working.
Moved ConfiguredLang to 11 for everyone, it only matters if !Boot fails, and no harm in making it common for 5.xx onwards.

Version 5.35, 4.79.2.183. Tagged as 'Kernel-5_35-4_79_2_183'
@
text
@d227 1
a227 1
 [ NumberOfPodules > 0
d277 35
d327 1
d329 1
d335 3
d339 1
d348 9
a356 2
; r3 = interrupt location      } when podules are
; r4 = interrupt mask/polarity } supported and r0 = podule device number
d377 5
a381 2
 [ NumberOfPodules > 0
        ! 0,    "ClaimDeviceVector has podule IRQ/FIQs assembled in"
d385 1
d387 1
d429 45
a473 1
 [ NumberOfPodules > 0
d515 1
a515 2
 [ NumberOfPodules > 0
        ! 0,    "ReleaseDeviceVector has podule IRQ/FIQs assembled in"
d527 5
d583 44
a626 1
 [ NumberOfPodules > 0
d921 1
d925 1
a925 1
        CallHAL HAL_IRQClear            ; Clear the vsync interrupt
d927 6
@


4.10.2.23
log
@Two magic device numbers removed
Not tagged.
@
text
@d232 1
a232 1
        ADD     lr, v1, #PFIQasIRQ_DevNo*12
d236 1
a236 1
        ADD     lr, v1, #Podule_DevNo*12
@


4.10.2.24
log
@Little kernel patches
hdr/ExportVals: the copyright header insertion got a bit confused with some of the file contents
TickEvents.s: a bad merge from Ursula branch 4.1.4.2 to trunk 4.2 left behind unmatched push/pull where TickIrqReenter had been removed
hdr/Options & NewIRQs.s: collapse remaining TickIrqReenter switches
osinit.s: when ZeroPage is in a top bit set address only the last buffer pointer would get zeroed

Tip offs from eagle eyed Tim Baldwin.

Version 5.35, 4.79.2.201. Tagged as 'Kernel-5_35-4_79_2_201'
@
text
@d749 1
d754 2
d757 3
@


4.10.2.25
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d215 10
d767 9
a775 1
        ; Fall through...
d777 1
a777 1
VsyncIRQ_ExtEntry ROUT
@


4.10.2.26
log
@Simplify HAL_IICDevice API
The only function to use the abandoned extensions to OS_ClaimDeviceVector, the 2nd & 3rd members of the structure never got used.
Change uses of HAL_IICDevice to pass in the bus, and expect the device number back.
Docs updated accordingly.

Version 5.35, 4.79.2.218. Tagged as 'Kernel-5_35-4_79_2_218'
@
text
@d238 3
a240 1
        MOV     a1, v3
d243 1
@


4.10.2.27
log
@Clear the exclusive monitor when returning to pre-empted code
Detail:
  s/Kernel - Add macro for CLREX, which uses a dummy STREX on basic ARMv6 machines. Clear the exclusive monitor after issuing transient callbacks, to cope with callbacks being triggered on exit from IRQ
  s/ArthurSWIs, s/HAL, s/NewIRQs - Clear the exclusive monitor on exit from IRQ handlers & default FIQ handler
  s/VMSAv6 - Clear the exclusive monitor on entry to the data abort pre-veneer
Admin:
  Tested on Raspberry Pi
  Non-transient callback handlers, custom abort handlers, FIQ handlers, and anything else which returns directly to interrupted user code is responsible for issuing its own CLREX if the code has done something that could have left the local monitor in the exclusive state (e.g. calling a SWI counts towards this, as there's no guarantee the monitor will be open on exit from the SWI)


Version 5.35, 4.79.2.327. Tagged as 'Kernel-5_35-4_79_2_327'
@
text
@d79 3
a81 6
        BNE      %FT10
05
        MyCLREX  r0, r1
        Pull     "r1-r3, r11, r12, lr"
        MSR      SPSR_cxsf, lr
        Pull     "r0, pc",, ^
a82 1
10
d86 3
a88 1
        BNE      %BT05
@


4.10.2.19.2.1
log
@  Merge of Raspberry Pi support code against latest kernel
Detail:
  This is a new branch from the current tip of the HAL branch, incorporating
  the changes received from Adrian Lees. The same caveats apply - this is a
  work in progress and will not work on any other platform at present.
Admin:
  Builds, but not tested.

Version 5.35, 4.79.2.147.2.1. Tagged as 'Kernel-5_35-4_79_2_147_2_1'
@
text
@a1419 11

        ! 0, "FIXME: temporary code"
;!!! HAPPY HACK
        STMFD   sp!,{r0-r12}
        ADR     r0,ret_from_vs
        Push    r0
        B       VsyncIRQ_ExtEntry
ret_from_vs
        LDMFD   sp!,{r0-r12}
;!!! HAPPY HACK

@


4.10.2.19.2.2
log
@  Added HAL_TimerIRQClear cann for system timer 0
Detail:
  (list files and functions that have changed)
Admin:
  shown running in system
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 5.35, 4.79.2.147.2.7. Tagged as 'Kernel-5_35-4_79_2_147_2_7'
@
text
@a1410 2
        MOV     r0, #0                  ; timer 0
        CallHAL HAL_TimerIRQClear
d1413 1
a1413 1
 |                      
@


4.10.2.19.2.3
log
@  Refinement to Timer clear change from a recent commit
Detail:
  An undocumented entry condition of TickOne is that r0 contains the device
  number corresponding to Timer0. This must be passed to HAL_IRQClear on
  some platforms.
Admin:
  Tested only on a Raspberry Pi. Also added enumeration of entry numbers in
  comments in Hdr:HALEntries - a handy reference when debugging from the
  command line!

Version 5.35, 4.79.2.147.2.8. Tagged as 'Kernel-5_35-4_79_2_147_2_8'
@
text
@d1409 1
a1409 1
        Push    "r0,r9,r12"
d1411 1
a1411 4
        
        ; In some chips, Timer0 is latched in the timer block instead of,
        ; or as well as in the interrupt controller
        MOV     R0, #0 ; clear latch for Timer0
a1412 2
        
        Pull    "r0" ; get device number back
@


4.10.2.19.2.4
log
@Clean up remaining kernel hacks
Detail:
  Docs/RPiNotes - Deleted, contents no longer relevant
  s/HAL, s/Kernel, s/vdu/vduswis, s/pmf/key - Cleaned up debug code
  s/NewIRQs - No need to piggy back on timer 0 IRQ to generate a fake VSync; PushModeInfo already claims/releases TickerV as appropriate if video driver doesn't provide a VSync IRQ.
  s/NewReset - Re-enable LookForHALRTC call, the stack imbalance bug was fixed before the Pi changes were merged in
  s/vdu/vducursoft - Streamline PostWrchCursor a bit by only preserving R14 around RestorePointer if the software pointer is in use
  s/vdu/vdudriver - Amend ModeChangeSub improvements to ensure old external framestore handling logic is used if driver doesn't support framestore growth/realloc
Admin:
  Tested on Raspberry Pi with high processor vectors
  Kernel now looks to be in a good state for merging back into HAL branch
  Note - Software mouse pointer support in vducursoft only checks HALVideoFeatures, so doesn't take into account the capabilities of any GraphicsV driver that may be in use.


Version 5.35, 4.79.2.147.2.20. Tagged as 'Kernel-5_35-4_79_2_147_2_20'
@
text
@d1427 11
@


4.10.2.15.2.1
log
@Initial kernel support for Cortex-A8 processors.
Detail:
  hdr/ARMops - Added Cortex_A8 processor type, new ARM architecture number
  hdr/Options - Enabled various kernel debug options
  s/ARMops - Added Cortex-A8/OMAP3530 to known CPUs list. Ignore cache type register for ARM architecture &F.
  s/NewIRQs - Increase MaxInterrupts to 96
Admin:
  Brief testing under qemu-omap3.



Version 5.35, 4.79.2.98.2.1. Tagged as 'Kernel-5_35-4_79_2_98_2_1'
@
text
@d208 1
a208 1
MaxInterrupts   * 96
@


4.10.2.15.2.2
log
@Update OS_IICOp to support multiple IIC buses
Detail:
  OS_IICOp (and in turn, RISCOS_IICOpV) now treat the top byte of R1 as containing the IIC bus number, allowing multiple buses to be used.
  hdr/KernelWS - Changed workspace a bit so that the kernel can support up to IICBus_Count buses (currently 3), each with its own IICBus_* block.
  s/HAL - Update Reset_IRQ_Handler to cope with interrupts from all IIC buses instead of just the first. Fix/update RISCOS_IICOpV description.
  s/NewIRQs - Update InitialiseIRQ1Vtable to set up interrupt handlers for all IRQ-supporting IIC buses
  s/NewReset - Get rid of the IICAbort call that was just before IICInit. IICInit now calls IICAbort itself.
  s/PMF/IIC - Bulk of the changes. Code now uses the IICBus_ structures instead of the IICStatus and IICType variables. Re-entrancy code has been updated to take into account the possiblity of multiple buses; when OS_IICOp calls are nested, the IIC transfers will be added to bus-specific queues instead of all going in the same queue. However only one queue will be processed at a time.
  s/ChangeDyn - Workspace shuffling means a couple of MOV's needed to be swapped with LDR's when getting immediate constants
Admin:
  Tested with OMAP & IOMD ROM builds.
  Both high & low-level bus types seem to work OK, along with re-entrancy, both on the same bus and on a different bus.


Version 5.35, 4.79.2.98.2.33. Tagged as 'Kernel-5_35-4_79_2_98_2_33'
@
text
@d757 1
a757 1
        Push    "v1-v3,sb,lr"
d823 4
a826 4
        MOV     v2, #IICBus_Base
        MOV     v3, #0
80
        LDR     a1, [v2, #IICBus_Type]
d832 1
a832 1
        MOV     a2, v3
d837 1
a837 1
        MOV     r2, v3
a839 4
        ADD     v2, v2, #IICBus_Size
        ADD     v3, v3, #1
        CMP     v3, #IICBus_Count
        BNE     %BT80
d841 1
a841 1
        Pull    "v1-v3,sb,pc"
@


4.10.2.15.2.3
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d46 1
a46 1
        LDR     r12, =ZeroPage
d67 1
a67 1
        LDR      r11, =ZeroPage
d112 1
a112 1
        LDR      r10, =ZeroPage
d147 1
a147 6
      [ ZeroPage = 0
        MOV     r9, #0
      |
        LDR     r9, %FT02
      ]
        AddressHAL r9                   ; modifies r9
a161 4
      [ ZeroPage <> 0
02
        DCD     ZeroPage
      ]
d786 1
a786 1
        LDR     a2, =ZeroPage+OsbyteVars
d796 1
a796 1
        LDRNE   a2, =ZeroPage+OsbyteVars
d812 1
a812 1
        LDR     a2, =ZeroPage+PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
d816 1
a816 1
        LDR     a2, =ZeroPage+PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
d823 1
a823 1
        LDR     v2, =ZeroPage+IICBus_Base
d1061 2
a1062 2
        LDREQ   r0, =ZeroPage+PIRQ_Chain
        LDRNE   r0, =ZeroPage+PFIQasIRQ_Chain
d1203 2
a1204 2
        LDREQ   r0, =ZeroPage+PIRQ_Chain-PodDesp_Link
        LDRNE   r0, =ZeroPage+PFIQasIRQ_Chain-PodDesp_Link
a1381 1
      [ ZeroPage = 0
a1382 4
      |
        LDRLS   r14, =ZeroPage+OsbyteVars+:INDEX:EventSemaphores
        LDRLSB  r14, [r0, r14]
      ]
a1405 1
      [ ZeroPage = 0
a1408 7
      |
        LDR     r12, =ZeroPage
        LDRB    r14, [r12, #CallBack_Flag] ; IRQs are still disabled
        ORR     r14, r14, #CBack_OldStyle
        STRB    r14, [r12, #CallBack_Flag]
      ]

d1432 1
a1432 1
        LDR     R1, =ZeroPage
d1508 1
a1508 1
        LDR     R1, =ZeroPage
@


4.10.2.15.2.4
log
@  Kernel updates to support Cortex-A9 CPUs
Detail:
  hdr.ARMops
    added Cortex_A9
  hdr.HALDevice
    added OMAP4 specific device IDs
  hdr.KernelWS
    changed definition of DefIRQ1Vspace for M_CortexA9
  s.ARMops
    added CortexA9 specific code for enabling L2 cache
    added CPUDesc Cortex_A9
  s.NewIRQs
    added CortexA9 specific definition of MaxInterrupts
  s.NewReset
    added M_CortexA9 options
    line 1444: corrected typo
    line 187: commented out unnecessary operation
Admin:
  Submission from Willi Theiß

Version 5.35, 4.79.2.98.2.50. Tagged as 'Kernel-5_35-4_79_2_98_2_50'
@
text
@a216 3
  [ M_CortexA9
MaxInterrupts   * 160
  |
a217 1
  ] ; M_CortexA9
@


4.10.2.15.2.4.2.1
log
@  Support for Raspberry Pi / BCM2835
Detail:
  Falls into two main areas: graphics support and ARM11 core support.
  A work in progress - in many cases the code changes need to be replaced
  with an alternative mechanism which will permit the kernel to still function
  on other platforms. Adrian marked these with "!!!" comments - I have added
  ! directives as well so that they don't get forgotten about.
Admin:
  Changes received from Adrian Lees. This revision represents the code largely
  as delivered, and is placed on its own branch (forked off from the version
  from which he worked). It is intended for reference. It doesn't build against
  current headers - this is likely to require a merge with the other changes
  to the kernel since that time.

Version 5.35, 4.79.2.98.2.52.2.1. Tagged as 'Kernel-5_35-4_79_2_98_2_52_2_1'
@
text
@a1457 11

        ! 0, "FIXME: temporary code"
;!!! HAPPY HACK
        STMFD   sp!,{r0-r12}
        ADR     r0,ret_from_vs
        Push    r0
        B       VsyncIRQ_ExtEntry
ret_from_vs
        LDMFD   sp!,{r0-r12}
;!!! HAPPY HACK

@


4.10.2.15.2.5
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d1259 1
a1259 2
        Pull    "r10, lr"
        Pull    "pc"                    ; new-style CDV - pull return address
@


4.9
log
@  Monotonic time was returned with a 1 cs error in certain circumstances.
Detail:
  Most of the centisecond timers were incremented very early in the Timer0
  interrupt routine, but MetroGnome was incremented after we had called
  TickerV. Routines on TickerV are allowed to enable interrupts, so any
  interrupt routines that use OS_ReadMonotonicTime and IRQRQA are unable to
  accurately determine if the monotonic time is one tick out-of-date or not.
  MetroGnome is now incremented with the other timers.
Admin:
  Tested with the timer code in STB-400 MPEGDriver.

Version 5.22. Tagged as 'Kernel-5_22'
@
text
@a29 1
        [ :LNOT: STB
a30 3
        ]

    [ Interruptible32bitModes
d35 1
a35 1
        mrs     AL, lr, SPSR_all
d40 1
d42 3
a44 2
        ORR     r0, r0, #I32_bit + IRQ26_mode ; force IRQ_26 mode and I_bit set
        msr     AL, CPSR_all, r0
d66 2
a67 1
        mrs      AL, r0, CPSR_all
d69 2
a70 1
        msr      AL, CPSR_all, r0               ; switch back to IRQ32 mode
d75 1
a75 1
        msr      EQ, SPSR_all, lr
d82 1
a82 1
        msr      NE, SPSR_all, lr
d85 1
a85 4
        TST      lr, #&10               ; check whether USR26 or USR32
        BNE      IRQ_callback32

; Do a CallBack: asked for, not postponed, and we're returning into USR26 mode.
d90 1
a90 1
        mrs      AL, r0, CPSR_all
d92 1
a92 1
        msr      AL, CPSR_all, r0
d95 1
a95 1
        msr      AL, CPSR_all, r0
d97 1
a97 17
        BIC      r0, r0, #&1F
        ORR      r0, r0, #SVC26_mode
        msr      AL, CPSR_all, r0
        AND      r0, r10, #&F0000000            ; plop flags into LR...
        ORR      lr, r12, r0
        AND      r0, r10, #I32_bit:OR:F32_bit
        ORR      lr, lr, r0, LSL #IF32_26Shift  ; and the I and F flags (32-bit mode)
        MOV      r0, r11                        ; restore original R0
        MOV      r10, #0
        LDRB     r11, [r10, #CallBack_Flag]
        B        Do_CallBack

; Do a CallBack32: asked for, not postponed, and we're returning into USR32 mode.
;
IRQ_callback32
        Pull     "r1-r3, r11, r12"
        mrs      AL, r0, CPSR_all
d99 1
a99 5
        msr      AL, CPSR_all, r0
        Push     "r10-r12"                               ; push r10-r12 onto the SVC stack
        BIC      r0, r0, #IRQ32_mode :EOR: SVC32_mode
        msr      AL, CPSR_all, r0
        Pull     "r10-r12"                      ; SPSR, R0, LR really
d102 4
a105 3
        msr      AL, CPSR_all, r0
        Push     "r10"                          ; push SPSR onto SVC stack (PSR for return)
        MOV      lr, r12                        ; address for return
a108 69
        B        Do_CallBack32

  | ;Interruptible32bitModes

Initial_IRQ_Code ROUT
        SUB      lr, lr, #4
        Push     "r0-r3, r11, r12, lr"
; ** For Pete's sake remember to change the heap manager if you change the above
; ** register list!!!!!!! And the [sp_irq, #4*6] below
 [ IRQSTK - 7*4 :AND: 15 <> 0
 ! 0,"IRQ STM/LDM making extra S cycle into N"
 ]

 [ CPU_Type = "ARM600"
        mrs     AL, r0, SPSR_all        ; r0 = saved PSR
        AND     r1, r0, #I32_bit + F32_bit ; r1 = caller I&F flags, in ARM6 place
        ORR     lr, lr, r1, LSL #IF32_26Shift ; put IF in place
        AND     r1, r0, #&F0000003      ; r1 = caller NZCV and mode bits
        ORR     lr, lr, r1              ; lr = 26 bit style return addr + PSR
        STR     lr, [sp_irq, #4*6]      ; store back into stack

        BIC     r0, r0, #&1F            ; clear out foreground mode bits
        ORR     r0, r0, #I32_bit + IRQ26_mode ; force IRQ_26 mode and I_bit set
        msr     AL, CPSR_all, r0
 ]

        MOV     r12, #0
        LDR     r0, [r12, #IRQsema]
        Push    r0
        STR     sp_irq, [r12, #IRQsema]
        MOV     lr, pc
        LDR     pc, [r12, #IRQ1V]

; IRQ1V called with r0-r3,r11,r12 trashable. r12=0

; Stu has a theory that 1N cycle can be saved by the default IRQ1V pointing
; at a location containing a branch to our code; we then do something like
;  LDR R0, [R12, #IRQ1V]
;  CMP R0, #OurIRQ1V
;  BNE somebodysonIRQ1V
;  .... fall into default IRQ1V code

        MOV      r11, #0
        Pull     r0
        STR      r0, [r11, #IRQsema]

        LDRB     r11, [r11, #CallBack_Flag]
        CMP      r11, #0
        Pull     "r0-r3, r11, r12, pc", EQ, ^

        TST      r11, #CBack_Postpone
        LDREQ    lr, [sp_irq, #4*6]
        TSTEQ    lr, #SVC_mode :OR: I_bit
        Pull     "r0-r3, r11, r12, pc", NE, ^

; Do a CallBack: asked for, not postponed, and we're returning into user mode.

        Pull     "r0-r3, r11, r12"
        TEQP     pc, #SVC_mode
        MOVNV    r0, r0
        Push     "r10-r12"
        TEQP     pc, #IRQ_mode
        MOVNV    r0, r0
        Pull     "r12"                  ; lr really
        TEQP     pc, #SVC_mode
        MOVNV    r0, r0
        MOV      lr, r12
        MOV      r10, #0
        LDRB     r11, [r10, #CallBack_Flag]
a110 2
  ] ;Interruptible32bitModes

a117 1
       [ :LNOT: STB
a118 1
       ]
a133 1
  [ STB
a142 5
  |
        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQD]
        ADREQ   r1, IrqReqDDevnos
  ]
a172 1
   [ STB
a173 3
   |
NoInterrupt * 27 ; Morris has IOMD's extra interrupts plus 5 of its own
   ]
a192 5
 [ DriversInKernel
        & OsbyteVars
        & PrinterIRQ
        & 0
 |
a195 1
 ]
a226 5
 [ DriversInKernel
        & OsbyteVars
        & RS423IRQ
        & 0
 |
a229 1
 ]
a308 1
 [ STB
a356 1
 ]
a708 1
 [ STB
a778 1
 ]
a820 1
 [ Fix11
a824 4
 |
        LDRB    r0, [r1]
        ANDS    r0, r0, r2
 ]
d868 1
a868 1
        TEQP    pc, #SVC_mode+I_bit     ; IRQs off for update
d907 1
a907 1
        TEQP    pc, #SVC_mode+I_bit     ; IRQs off for update
d928 1
a928 1
        TEQP    pc, #SVC_mode + I_bit   ; IRQs off while holding context
d1067 14
a1081 3
; Cope with interrupts from IRQC registers
;
  [ STB
d1083 3
a1087 8
        BHS     %FT03
  ]

; RCM 31-Jan-95 fix MED-04355, need to cope with interrupts from new Morris register
        CMP     R12, #IOMD_MouseRxFull_DevNo
        SUBHS   R12, R12, #IOMD_MouseRxFull_DevNo       ;reduce to bit number 0..7
        MOVHS   R0, #IOMD_IRQMSKD                       ; in IRQ D interrupt register
        BHS     %FT03
a1089 26
; ** TMD 14-Feb-94 - insert code here to fix MED-02859
; ** Old code did not cope with the DMA case here

 [ IO_Type = "IOMD"
        CMP     r12, #16                ; check if a DMA device
        BCC     %FT02                   ; it's not, so skip

        SUB     r12, r12, #16           ; convert to a bit number in mask
        MOV     r1, #1
        MOV     r1, r1, LSL r12         ; convert to bit mask
        LDR     r0, =IOC+IOMD_DMAMSK    ; point at mask register
        LDRB    r12, [r0]               ; load mask
        BIC     r12, r12, r1            ; knock out bit
        STRB    r12, [r0]               ; store back
        Pull    pc,,^                   ; and exit, claiming vector

02
 ]

; ** end of insertion

        CMP     r12, #8
        MOVGE   r0, #IOCIRQMSKB
        SUBGE   r12, r12, #8
        MOVLT   r0, #IOCIRQMSKA
 [ MorrisSupport
a1090 1
 ]
d1095 4
a1098 7
 [ :LNOT: NewClockChip                  ; fudge winnieDRQ on A500
        CMP     r1, #winnie_IRQ_bit
        CMPEQ   r0, #IOCIRQMSKB
        ORREQ   r1, r1, #winnie_DRQ_bit ; turn both off.
 ]
        MOV     lr, pc
        TEQP    pc, #IRQ_mode+I_bit+F_bit
d1102 1
a1102 1
        TEQP    lr, #0          ; absolute minimum FIQ disable period
d1105 1
a1105 1
        Pull    pc,,^           ; claim vector
d1116 1
a1116 1
        TEQP    pc, #SVC_mode+I_bit     ; Disable IRQs. MUST call these ones
d1158 1
a1158 1
        Pull    pc,NE,^
d1163 1
a1163 1
        Pull    pc,,^                   ; claim EventV
a1168 1
 [ :LNOT: STB
a1169 1
 ]
a1204 6
        [ :LNOT: NewClockChip
        LDRB    R1, SecondsDirty
        TEQ     R1, #0                  ; if seconds dirty
        BNE     %FT10                   ; we haven't synced yet
        ]

a1211 42
        [ :LNOT: NewClockChip
        LDRB    R0, CentiTime
        ADD     R0, R0, #1
        TEQ     R0, #100
        MOVEQ   R0, #0
        STRB    R0, CentiTime

        LDRB    R0, SecondsTime
        ADDEQ   R0, R0, #1              ; increment only if wrap from centisecs
        TEQEQ   R0, #60
        MOVEQ   R0, #0
        STRB    R0, SecondsTime

        B       NoTickThisTime          ; don't do dirty code
10
        LDRB    R0, MinTick
        MOV     R1, #IOC
        LDRB    R3, [R1, #IOCControl]   ; IOC control register
        AND     R3, R3, #rtc_minutes_bit
        TEQ     R3, R0                  ; Look for transition
        BEQ     NoTickThisTime
        TEQ     R3, #rtc_minutes_bit    ; from zero to one = minute!!!
        STRB    R3, MinTick             ; One to zero = 30 seconds
        MOV     R0, #0
        STRB    R0, SecondsDirty        ; Mark the seconds as OK now !
        STRB    R0, CentiTime ; When the minutes tick, ZERO the centiseconds!
        MOVEQ   R0, #30
        STRB    R0, SecondsTime         ; And set the seconds to 0 or 30 !

        LDR     R0, =ticksperminute     ; get offset for 1 minute (60 secs)
        MOVEQ   R0, R0, LSR #1          ; halve it if 30 second tick

        LDR     R1, RealTime +0
        ADDS    R1, R1, R0
        STR     R1, RealTime +0
        LDRCSB  R1, RealTime +4
        ADDCS   R1, R1, #1
        STRCSB  R1, RealTime +4

NoTickThisTime
        ]

a1251 1
 [ :LNOT: STB
a1252 1
 ]
@


4.8
log
@Fixed typo that stopped original interrupt allocation builds from working.

Version 5.04. Tagged as 'Kernel-5_04'
@
text
@d1330 5
@


4.7
log
@And IRQs tweaked one more time.

Version 5.03. Tagged as 'Kernel-5_03'
@
text
@d603 2
a604 2
IrqReqAPrio2 * IOMDr_printer_IRQ_bit
IrqReqADev2 * IOMDr_PrinterIRQ_DevNo
@


4.6
log
@IRQs rejigged for HdrSrc 0.52.

Version 5.02. Tagged as 'Kernel-5_02'
@
text
@d594 1
a594 1
IrqReqAPrio2 * IOMD_printer_IRQ_bit
d603 1
a603 1
IrqReqAPrio2 * IOMD_printer_IRQ_bit
d711 1
a711 1
IrqReqBPrio0 * IOMD_MPEGAudio_IRQ_bit
d714 1
a714 1
IrqReqBPrio1 * IOMD_MPEGVideo_IRQ_bit
d717 1
a717 1
IrqReqBPrio6 * IOMD_Network_IRQ_bit
d720 1
a720 1
IrqReqBPrio7 * IOMD_serial_IRQ_bit
@


4.5
log
@First attempt at a Kernel that handles ReassignedIOMDInterrupts.
If reassigned, ReadSysInfo3 returns &00x22200 in R0, to indicate that the
serial and parallel ports aren't compatible, and IDE and floppy are
unavailable.

Version 5.01. Tagged as 'Kernel-5_01'
@
text
@d591 3
d595 1
a595 1
IrqReqADev2 * IOMD_PrinterIRQ_DevNo
a596 2
 [ ReassignedIOMDInterrupts
 ASSERT IOMD_PrinterIRQ_DevNo = 2
d602 4
d712 1
a712 1
IrqReqBDev0 * IOMD_MPEGAudio_DevNo
d715 1
a715 1
IrqReqBDev1 * IOMD_MPEGVideo_DevNo
d718 1
a718 1
IrqReqBDev6 * IOMD_Network_DevNo
d721 1
a721 1
IrqReqBDev7 * IOMD_Serial_DevNo
@


4.4
log
@* Added support for 24LC64 8K EEPROM (untested).
* Integrated Ursula fast service call dispatch code.
* Added Interruptible32bitModes from Ursula.
* Stopped allowing ROM modules (other than the Kernel/UtilityModule) to write
  to the hardware vectors in 26-bit mode.

Version 4.81. Tagged as 'Kernel-4_81'
@
text
@a550 3
IrqReqAPrio2 * pbusy_bit
IrqReqADev2 * PrinterBusy_DevNo

d563 1
a563 1
; Machine specific IRQB bits
d569 3
d580 3
d589 4
a592 1
IrqReqADev1 * Ringing_DevNo
d594 7
d602 2
a603 1
IrqReqADev3 * PrinterAck_DevNo
a659 3
IrqReqBPrio7 * serial_bit
IrqReqBDev7 * Serial_DevNo

d671 3
d685 3
d699 3
d705 13
d726 4
@


4.3
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d34 101
a144 2
        BIC     pc, pc, #&FC000000      ; get back out of shadow ROM
        NOP                             ; (this instruction skipped)
d201 2
@


4.2
log
@Kernel merged
@
text
@d802 1
@


4.2.2.1
log
@Added following enhancements:

 - Chocolate screen mapping (section mapped and cached), StrongARM only
   Phoebe h/w (IOMD 2) will have register to assist this, but code currently
   relies on data abort mechanism to keep screen up to date wrt write-back
   data cache.

 - Chocolate AMBControl task switching (lazy page mapping), StrongARM only
   Improves task swapping speed. There appears to be a StrongAEM silicon
   bug rev 2 and 3) which means that LDMIB rn, {regs includind rn} cannot
   be reliably restarted after a data abort. This stuffs Chocolate AMBControl
   (awaiting response from Digital).

Both enhancements need more work to complete for Phoebe. Chocolate AMBControl
may well have to be made dormant because of silicon bug.

Note that this kernel *will* cause problems with task switching on StrongARM,
unless Chocolate task switching is disabled via !Flavour application.
@
text
@a1317 8
  [ ChocolateScreen
;screen cleaner stuff if enabled (should only be for StrongARM)
        MOV     R12,#0
        LDR     R0,[R12,#ARMA_Cleaner_status]
        TST     R0,#ACS_SCdisable:OR:ACS_SCsuspend
        BLEQ    VsyncSAScreenClean                      ; do the VSC jazz if not disabled or suspended
  ]

a1349 52

  [ ChocolateScreen
;entry: R0 = current ARMA_Cleaner_status, R12=0, R0,R1 trashable
;
VsyncSAScreenClean ROUT
        TST     R0,#ACS_VSCcountdown_MASK
        MOVEQ   PC,LR                                    ;no pending VSC if VSC countdown is 0
        SUB     R0,R0,#1:SHL:ACS_VSCcountdown_SHIFT      ;decrement VSC countdown
        TST     R0,#ACS_VSCcountdown_MASK
        STRNE   R0,[R12,#ARMA_Cleaner_status]
        MOVNE   PC,LR                                    ;nothing to do yet if VSC countdown has not reached zero
        TST     R0,#ACS_NSCsemaphore:OR:ACS_SCsemaphore
        ORRNE   R0,R0,#1:SHL:ACS_VSCcountdown_SHIFT
        STRNE   R0,[R12,#ARMA_Cleaner_status]
        MOVNE   PC,LR                                    ;if NSC or SC semaphore set, do nothing now but keep VSC countdown at 1
        Push    "R2-R4,LR"
        EOR     R0,R0,#ACS_SCflipflop                    ;next screen cleaner area
        ORR     R0,R0,#ACS_SCsemaphore
        STR     R0,[R12,#ARMA_Cleaner_status]
        AND     R14,R0,#ACS_SCflipflop                   ;extract SC flipflop bit
        LDR     R1,=ARMA_ScreenCleaners_address
        ADD     R1,R1,R14,LSR #ACS_SCflipflop_SHIFT-14   ;start address for clean (LSR -14 since 16k area size)
        ADD     R2,R1,#16*1024                           ;end address (exclusive, 16k cache size)
  [ {FALSE}
    ;this has some kind of interrupt hole (crashes with undefined instruction on FP instruction and filecore in use
    ;after running 4 movies looping in Replay 3-ish in 1024x768x16bpp for a few minutes
        MOV     R14,PC
        BIC     R14,R14,#I_bit
        TEQP    R14,#0                          ;enable interrupts, since cache clean slow-ish (semaphore protects reentrancy)
  ]
02
        LDR     R14,[R1],#32                    ;read next cleaner line into data cache (triggers 8-word line fill)
        LDR     R14,[R1],#32
        LDR     R14,[R1],#32
        LDR     R14,[R1],#32
        CMP     R1,R2
        BLO     %BT02                           ;until done
;write buffer can be allowed to drain on its own (this is not a code- or remap- critical clean)
  [ {FALSE}
        MOV     R14,PC
        ORR     R14,R14,#I_bit
        TEQP    R14,#0                          ;disable interrupts again
  ]
        ARMA_read_MMUdomain r2
        BIC     r2,r2,#&C
        ARMA_write_MMUdomain r2                 ;reset screen (domain 1) to fault
        LDR     R0,[R12,#ARMA_Cleaner_status]
        BIC     R0,R0,#ACS_SCsemaphore
        STR     R0,[R12,#ARMA_Cleaner_status]        
        Pull    "R2-R4,PC"

  ] ;ChocolateScreen
@


4.2.2.2
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d43 1
d56 1
d153 11
d182 1
d197 5
d205 1
d237 5
d245 1
d476 5
d551 8
d562 8
d573 8
d799 1
d803 4
d866 1
d868 3
d930 1
d932 3
d1286 1
d1291 6
d1381 7
d1396 5
@


4.2.2.3
log
@1) Fixes and tidy ups:
   - mapping of Cur/Sys/Sound area done more elegantly, and soft CAM info
     is now consistent with it
   - cached screen cleaning on VSync performed *after* VSync events
   - comments at top of ARM600 modernised
   - Pages_Unsafe/Safe code fixed to work properly on StrongARM with
     pages that are involved in interrupts (there is no fix for ARM8,
     since that is unlikely to be needed - an ASSERT checks use of ARM8
   - OS_DynamicArea code souped up, to be much more efficient for large
     numbers of dynamic areas (see comments near top of ChangeDyn)
   - cached screen is now suspended on h/w scroll (avoids possible cache
     incoherency)
2) API changes:
   - new OS_Memory reason code (10) allows Wimp to inform kernel of
     Wimp_ClaimFreeMemory, and can control VRAM rescue (see below)
   - new OS_ReadSysInfo reason code (6) allows reading of kernel values
     (reserved for Acorn use, eg. for SoftLoad, ROMPatch)
   - new OS_DynamicArea reason codes (6 and 7) allow for more efficient
     monitoring of dynamic areas by TaskManager (reserved for Acorn use)
3) Changes for Phoebe:
   - kernel runs a VRAM rescue process, which ensures that any VRAM not
     used for the screen is reclaimed if necessary and sinks to the bottom
     of the Free Pool. This is important for Phoebe, where VRAM is slower
     than SDRAM, but does no harm on other platforms.
   - logical copy of physical RAM is removed from memory map. This frees
     up 256M of address space that will later be used for PCI on Phoebe,
     but should do no harm on other platforms (this space is marked
     private in PRMs, so 3rd parties should not use it).
@
text
@d1243 8
a1257 11
  [ ChocolateScreen
;
;after all vsync stuff (except flashing colours), screen cleaner stuff if enabled
;(will only be enabled for StrongARM)
;
        MOV     R2,#0
        LDR     R0,[R2,#ARMA_Cleaner_status]
        TST     R0,#ACS_SCdisable:OR:ACS_SCsuspend
        BLEQ    VsyncSAScreenClean                      ; do the VSC jazz if not disabled or suspended
  ]

d1285 1
a1285 1
;entry: R0 = current ARMA_Cleaner_status, R2=0, R0,R1 trashable, ARM is StrongARM
d1292 1
a1292 1
        STRNE   R0,[R2,#ARMA_Cleaner_status]
d1296 1
a1296 1
        STRNE   R0,[R2,#ARMA_Cleaner_status]
d1298 1
d1301 2
a1302 2
        STR     R0,[R2,#ARMA_Cleaner_status]
        AND     R0,R0,#ACS_SCflipflop                    ;extract SC flipflop bit
d1304 1
a1304 1
        ADD     R1,R1,R0,LSR #ACS_SCflipflop_SHIFT-14    ;start address for clean (LSR -14 since 16k area size)
d1307 4
a1310 4
        LDR     R0,[R1],#32                              ;read next cleaner line into data cache (triggers 8-word line fill)
        LDR     R0,[R1],#32
        LDR     R0,[R1],#32
        LDR     R0,[R1],#32
d1312 1
a1312 1
        BLO     %BT02                                    ;until done
d1314 4
a1317 5
        ARMA_read_MMUdomain R0
        BIC     R0,R0,#&C
        ARMA_write_MMUdomain R0                          ;reset screen (domain 1) to fault
        MOV     R2,#0
        LDR     R0,[R2,#ARMA_Cleaner_status]
d1319 2
a1320 2
        STR     R0,[R2,#ARMA_Cleaner_status]        
        MOV     PC,LR
@


4.2.2.4
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@d43 2
d882 1
@


4.2.2.5
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a33 101
    [ Interruptible32bitModes

Initial_IRQ_Code ROUT
        SUB     lr, lr, #4
        Push    "r0, lr"
        mrs     AL, lr, SPSR_all
        Push    "r1-r3, r11, r12, lr"
; ** For Pete's sake remember to change the heap manager if you change the above
; ** register list!!!!!!! And the [sp_irq, #4*5] below

        BIC     r0, lr, #&1F            ; clear out foreground mode bits
        ORR     r0, r0, #I32_bit + IRQ26_mode ; force IRQ_26 mode and I_bit set
        msr     AL, CPSR_all, r0

        MOV     r12, #0
        LDR     r0, [r12, #IRQsema]
        Push    r0
        STR     sp_irq, [r12, #IRQsema]
        MOV     lr, pc
        LDR     pc, [r12, #IRQ1V]

; IRQ1V called with r0-r3,r11,r12 trashable. r12=0

; Stu has a theory that 1N cycle can be saved by the default IRQ1V pointing
; at a location containing a branch to our code; we then do something like
;  LDR R0, [R12, #IRQ1V]
;  CMP R0, #OurIRQ1V
;  BNE somebodysonIRQ1V
;  .... fall into default IRQ1V code

        MOV      r11, #0
        Pull     r0
        STR      r0, [r11, #IRQsema]

        mrs      AL, r0, CPSR_all
        ORR      r0, r0, #&10
        msr      AL, CPSR_all, r0               ; switch back to IRQ32 mode

        LDRB     r11, [r11, #CallBack_Flag]
        TEQ      r11, #0
        Pull     "r1-r3, r11, r12, lr", EQ
        msr      EQ, SPSR_all, lr
        Pull     "r0, pc", EQ, ^

        TST      r11, #CBack_Postpone
        LDREQ    lr, [sp_irq, #4*5]     ; get SPSR off stack
        TSTEQ    lr, #I32_bit :OR: &0F  ; check we came from USR26 or USR32 mode, with IRQs enabled
        Pull     "r1-r3, r11, r12, lr", NE
        msr      NE, SPSR_all, lr
        Pull     "r0, pc", NE, ^

        TST      lr, #&10               ; check whether USR26 or USR32
        BNE      IRQ_callback32

; Do a CallBack: asked for, not postponed, and we're returning into USR26 mode.

        ASSERT   IRQ32_mode :AND: SVC32_mode = IRQ32_mode ; so the following dodgy ops work

        Pull     "r1-r3, r11, r12"
        mrs      AL, r0, CPSR_all
        ORR      r0, r0, #SVC32_mode
        msr      AL, CPSR_all, r0
        Push     "r10-r12"                               ; push r10-r12 onto the SVC stack
        BIC      r0, r0, #IRQ32_mode :EOR: SVC32_mode
        msr      AL, CPSR_all, r0
        Pull     "r10-r12"                      ; SPSR, R0, LR really
        BIC      r0, r0, #&1F
        ORR      r0, r0, #SVC26_mode
        msr      AL, CPSR_all, r0
        AND      r0, r10, #&F0000000            ; plop flags into LR...
        ORR      lr, r12, r0
        AND      r0, r10, #I32_bit:OR:F32_bit
        ORR      lr, lr, r0, LSL #IF32_26Shift  ; and the I and F flags (32-bit mode)
        MOV      r0, r11                        ; restore original R0
        MOV      r10, #0
        LDRB     r11, [r10, #CallBack_Flag]
        B        Do_CallBack

; Do a CallBack32: asked for, not postponed, and we're returning into USR32 mode.
;
IRQ_callback32
        Pull     "r1-r3, r11, r12"
        mrs      AL, r0, CPSR_all
        ORR      r0, r0, #SVC32_mode
        msr      AL, CPSR_all, r0
        Push     "r10-r12"                               ; push r10-r12 onto the SVC stack
        BIC      r0, r0, #IRQ32_mode :EOR: SVC32_mode
        msr      AL, CPSR_all, r0
        Pull     "r10-r12"                      ; SPSR, R0, LR really
        BIC      r0, r0, #&1F
        ORR      r0, r0, #SVC26_mode
        msr      AL, CPSR_all, r0
        Push     "r10"                          ; push SPSR onto SVC stack (PSR for return)
        MOV      lr, r12                        ; address for return
        MOV      r0, r11                        ; restore original R0
        MOV      r10, #0
        LDRB     r11, [r10, #CallBack_Flag]
        B        Do_CallBack32

  | ;Interruptible32bitModes

a97 2

  ] ;Interruptible32bitModes
@


4.2.2.5.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d30 1
d32 1
a203 2
  [ IOMD1Support

d205 1
a205 1
; Default IRQ1V for IOMD1 platforms: despatch on interrupting device
d209 5
a213 1
IOMD1_DefaultIRQ1Vcode ROUT
d215 1
d219 1
a219 2
        ADRNE   r1, IOMD1_IrqDMADevnos

d221 1
a221 1
        ADREQ   r1, IOMD1_IrqReqBDevnos
d223 1
d227 11
d240 4
a243 1
        ADREQ   r1, IOMD1_IrqReqDDevnos
d246 1
a246 1
        ADREQ   r1, IOMD1_IrqReqADevnos
d251 2
a252 1

d259 12
a270 1
IOMD1_NoInterrupt * 27 ; Morris has IOMD's extra interrupts plus 5 of its own
d272 1
a272 1
IOMD1_Devices
d335 3
d339 1
d343 3
d347 1
d350 1
d376 1
d378 1
d400 50
d459 1
a459 1
IOMD1_DeviceTables
d461 2
d487 2
a488 2
IOMD1_IrqDMADevnos
  = IOMD1_NoInterrupt*3
d518 2
d542 12
d559 1
d564 2
a565 2
IOMD1_IrqReqADevnos
  =  IOMD1_NoInterrupt*3
d620 10
d638 1
d643 2
a644 2
IOMD1_IrqReqBDevnos
  =  IOMD1_NoInterrupt*3
d682 1
d703 2
a704 2
IOMD1_IrqReqDDevnos
  =  IOMD1_NoInterrupt*3
d731 5
a735 1
IOMD1_DefaultIRQ1Vcode_end
d737 2
a738 1
  ASSERT IOMD1_DefaultIRQ1Vcode_end - IOMD1_DefaultIRQ1Vcode <= DefIRQ1Vspace
d740 2
a741 1
  ] ;IOMD1Support
d743 2
a744 1
  [ IOMD2Support
d746 2
a747 2
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Default IRQ1V for IOMD2 platforms: despatch on interrupting device
d749 2
a750 1
; copied to RAM, together with vector entries and device tables
d752 2
a753 11
; Combo interrupts are all ORR'd as SMI and wired to external interrupt 10 (ei10) on IOMD2
; Hence, interrupts must be discriminated via Combo SMI status registers
;
SMI_ComboBase    *  &03010000    ;combo mapped here
SMI_selectreg    *  &3a8         ;write here to select register for access
SMI_accessreg    *  &3ac         ;access register here
SMI_enable1      *  &c           ;value to select enable1
SMI_enable2      *  &d           ;value to select enable2
SMI_status1      *  &e           ;value to select status1
SMI_status2      *  &f           ;value to select status2
SMI_INTREQbit    *  1 :SHL: 10   ;SMI at ei10, which is bit 10 of INTREQ
d755 2
a756 1
IOMD2_DefaultIRQ1Vcode ROUT
d758 2
a759 7
        MOV     r3, #IOC
;
; check for interrupting DMA device (similar to processing of INTREQ below, see comments there for description)
;
        LDR     r0, [r3, #IOMD2_DMAREQ]
        TEQ     r0, #0
        BEQ     %FT10
a760 12
        ASSERT  IOMD2_DMACheck = IOMD2_DMA_HalfMask1+4
        ORR     r0, r0, #&80000000
        ADR     r1, IOMD2_DMA_HalfMask1
        LDR     r12, [r1], #4
        TST     r0, r12
        ADDEQ   r1, r1, #IOMD2_DMA_HalfSize
05
        LDRB    r12, [r1], #1
        MOVS    r12, r0, LSL r12
        BCC     %BT05
        ADD     r1, r1, #IOMD2_DMADevice-IOMD2_DMACheck-1
        B       %FT40
d762 1
a762 64
10
;
; check for interrupting device either directly through IOMD2_INTREQ or through Combo SMI
;
        LDR     r0, [r3, #IOMD2_INTREQ]
        BIC     r0, r0, #&7E000000            ;clear pseudo bits (25..30), that may receive Combo bits
        ORR     r0, r0, #&80000000            ;set fail safe pseudo bit (31), to guarantee terminated device loop
        TST     r0, #SMI_INTREQbit            ;check for ei10 (one or more interrupts from Combo)
        BEQ     %FT20
;
; pick up Combo interrupts and munge them into pseudo bits in r0
; this is tedious, because of indexed register access, split of interrupts over two registers, and lack of
; register(s) giving pending-and-enabled status
;
        ASSERT  SMI_ComboBase < IOC
        SUB     r3, r3, #IOC-SMI_ComboBase    ;trick to get SMI_ComboBase in r3
        MOV     r12, #SMI_status1
        STR     r12, [r3, #SMI_selectreg]
        LDRB    r12, [r3, #SMI_accessreg]     ;pending IRQs, bits 2..4 are serial2,serial1,floppy
        MOV     r1,  #SMI_enable1
        STR     r1,  [r3, #SMI_selectreg]
        LDRB    r1,  [r3, #SMI_accessreg]     ;enabled IRQs
        AND     r12, r12, r1                  ;pending and enabled IRQs
        ORR     r0, r0, r12, LSL #23          ;munge SMI1 bits 2..4 into pseudo bits 25..27
        MOV     r12, #SMI_status2
        STR     r12, [r3, #SMI_selectreg]
        LDRB    r12, [r3, #SMI_accessreg]     ;pending IRQs, bits 0..2 are mouse,keyboard,IR
        MOV     r1,  #SMI_enable2
        STR     r1,  [r3, #SMI_selectreg]
        LDRB    r1,  [r3, #SMI_accessreg]     ;enabled IRQs
        AND     r12, r12, r1                  ;pending and enabled IRQs
        ORR     r0, r0, r12, LSL #28          ;munge SMI2 bits 0..2 into pseudo bits 28..30
        MOV     r3, #IOC
        
20
;
; - find highest priority interrupting device
; - serial loop may look a bit slow, but priority encoded table(s) much more unwieldy for IOMD2,
;   and not necessarily faster on a cached processor (where the small tables used here will
;   hopefully cache efficiently)
; - we do have a two-stage binary chop to speed things up a little
; - what we should have done is designed some configurable h/w priority encoding in IOMD2
;
        ASSERT  IOMD2_IRQCheck = IOMD2_IRQ_HalfMask1+3*4
        ADR     r1, IOMD2_IRQ_HalfMask1
        LDR     r12, [r1],#3*4                 ;r1 now -> IOMD2_IRQCheck
        TST     r0, r12                        ;see if any bits in upper half of priority list set
        LDREQ   r12, [r1, #-4]                 ;if not, pick up bits in 3rd quarter of priority list ...
        ADDEQ   r1, r1, #IOMD2_IRQ_HalfSize    ;... and skip to lower half of list
        LDRNE   r12, [r1, #-2*4]               ;if so, pick up bits in 1st quarter of priority list
        TST     r0, r12                        ;see if any bits in upper quarter of this half set
        ADDEQ   r1, r1, #IOMD2_IRQ_QuartSize   ;if not, skip to lower quarter
30
        LDRB    r12, [r1],#1                   ;next device
        MOVS    r12, r0, LSL r12
        BCC     %BT30                          ;carry clear if this device not interrupting
;
; - found an interrupting device in IOMD2_IRQCheck at r1-1
; - point r1 at corresponding entry in IOMD2_IRQDevice
; - possible improvement here is to order the IOMD2_Devices list in priority order, to
;   eliminate need for IOMD2_IRQDevice look-up - claim and release of devices
;   would then have to map external device numbers to internal (priority order) numbers
;
        ADD     r1, r1, #IOMD2_IRQDevice-IOMD2_IRQCheck-1
d764 2
a765 4
40
        LDRB    r0, [r1]                 ;get device number*3
        ADD     r1, pc, r0, LSL #2       ; -> entry in IOMD2_Devices
        LDMIA   r1, {r12, pc}
d767 36
a802 293
; ******* IRQ device handlers entered with r0-r3,r11,r12,r14 trashable *******
;   r3  -> IOC
;   r12 =  what they asked for
;   r14 =  return address to MOS IRQ exit sequence

IOMD2_NoInterrupt * 42

IOMD2_Devices

;  0  parallel
        & 0             ; R12 value
        & IRQ           ; call address
        & 0             ; link
;  1  unused
        & 0
        & IRQ
        & 0
;  2  floppy index
        & 0
        & IRQ
        & 0
;  3  vsync
        & OsbyteVars
        & VsyncIRQ
        & 0
;  4  unused (power on reset absent on IOMD2)
        & 0
        & IRQ
        & 0
;  5  timer0
        & OsbyteVars
        & TickOne
        & 0
;  6  timer1
        & 0
        & IRQ
        & 0
;  7  FIQ downgrade
        & 0
        & IRQ
        & 0
;  8  PFIQ downgrade
        & PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        & PFIQasIRQ_Despatch
        & 0
;  9  IDE A
        & 0
        & IRQ
        & 0
; 10  serial 1
        & 0
        & IRQ
        & 0
; 11  unused (NIC nextwork card not present on Phoebe)
        & 0
        & IRQ
        & 0
; 12  floppy
        & 0
        & IRQ
        & 0
; 13  podule IRQ
        & PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        & PIRQ_Despatch
        & 0
; 14  PS/2 keyboard
        & IOC
        & IRQ
        & 0
; 15  PS/2 mouse
        & IOC
        & IRQ
        & 0

; 16  DMA channel 0
        & 0
        & IRQ
        & 0
; 17  DMA channel 1
        & 0
        & IRQ
        & 0
; 18  DMA channel 2
        & 0
        & IRQ
        & 0
; 19  DMA channel 3
        & 0
        & IRQ
        & 0
; 20  Sound DMA channel 0
        & 0
        & IRQ
        & 0
; 21  Sound DMA channel 1 (absent on IOMD2)
        & 0
        & IRQ
        & 0

; absent devices 22 ... 26 (7500 only)
; 22
        & 0
        & IRQ
        & 0
; 23
        & 0
        & IRQ
        & 0
; 24
        & 0
        & IRQ
        & 0
; 25
        & 0
        & IRQ
        & 0
; 26
        & 0
        & IRQ
        & 0
;new IOMD2 devices
; 27  DMA channel 4
        & 0
        & IRQ
        & 0
; 28  DMA channel 5
        & 0
        & IRQ
        & 0
; 29  DMA channel 6
        & 0
        & IRQ
        & 0
; 30  DMA channel 7
        & 0
        & IRQ
        & 0
; 31  PCI
        & PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val) ;PCI shares PIRQ_Chain with Podule
        & PCIIRQ_Despatch
        & 0
; 32  PLX (PCI controller)
        & 0
        & IRQ
        & 0
; 33  IDE B
        & 0
        & IRQ
        & 0
; 34  Audio 0
        & 0
        & IRQ
        & 0
; 35  Audio 1
        & 0
        & IRQ
        & 0
; 36  Timer 2
        & 0
        & IRQ
        & 0
; 37  Timer 3
        & 0
        & IRQ
        & 0
; 38  Timer 4
        & 0
        & IRQ
        & 0
; 39  Timer 5
        & 0
        & IRQ
        & 0
; 40  Serial 2
        & 0
        & IRQ
        & 0
; 41  IR
        & 0
        & IRQ
        & 0
; terminate
; nothing is interrupting, which is impossible: just call IRQ2V anyway
        & 0
        & IRQ
        & 0
IOMD2_Devices_end

  ASSERT IOMD2_Devices_end-IOMD2_Devices = (IOMD2_NoInterrupt+1)*4*3

; DMA structures (processing bits from DMAREQ)
; these are similar to IRQ structures, see IRQ comments for description
;
IOMD2_DMA_HalfSize   *    5
;
IOMD2_DMA_HalfMask1
  DCD  (1:SHL: 0)+(1:SHL: 1)+(1:SHL: 2)+(1:SHL: 3)+(1:SHL: 4)
;
IOMD2_DMACheck
  =  32- 0    ;DMA channel 0
  =  32- 1    ;DMA channel 1
  =  32- 2    ;DMA channel 2
  =  32- 3    ;DMA channel 3
  =  32- 4    ;DMA sound channel (VIDC sound)
  =  32- 8    ;DMA channel 4
  =  32- 9    ;DMA channel 5
  =  32-10    ;DMA channel 6
  =  32-11    ;DMA channel 7
  =  32-31    ;fail safe terminator is bit 31 (always set)
;
IOMD2_DMADevice
  =  16*3    ;DMA channel 0
  =  17*3    ;DMA channel 1
  =  18*3    ;DMA channel 2
  =  19*3    ;DMA channel 3
  =  20*3    ;DMA sound channel (VIDC sound)
  =  27*3    ;DMA channel 4
  =  28*3    ;DMA channel 5
  =  29*3    ;DMA channel 6
  =  30*3    ;DMA channel 7
  =  IOMD2_NoInterrupt*3     ;failsafe terminator (max real device is IOMD2_NoInterrupt-1)
  ALIGN

;IRQ structures (processing bits from INTREQ)
;
;to speed things up a little, two-stage binary chop to give cut worst case search by factor of 4
;this is stored just before table IOMD2_IRQCheck for extra speed (including cache friendliness)
;the bits set *must* agree with IOMD2_IRQCheck table, which *must* follow immediately after
;
IOMD2_IRQ_HalfSize   *   10  ;ten devices in half mask
IOMD2_IRQ_QuartSize  *    5  ;five devices in each quarter mask
;
IOMD2_IRQ_HalfMask1          ;1st half
  DCD  (1:SHL:26)+(1:SHL:25)+(1:SHL: 1)+(1:SHL: 2)+(1:SHL: 7)+(1:SHL:29)+(1:SHL:28)+(1:SHL: 0)+(1:SHL: 3)+(1:SHL: 4)
IOMD2_IRQ_QuartMask1         ;1st quarter
  DCD  (1:SHL:26)+(1:SHL:25)+(1:SHL: 1)+(1:SHL: 2)+(1:SHL: 7)
IOMD2_IRQ_QuartMask3         ;3rd quarter
  DCD  (1:SHL:27)+(1:SHL:21)+(1:SHL:18)+(1:SHL:16)+(1:SHL: 6)
;
;table is in order of decreasing priority, entries are amount to LSL shift appropriate
;bit of r0 into PSR C flag (allows fast test with single byte table entries)
;
IOMD2_IRQCheck
  =  32-26    ;serial 1 (bit 26 of r0)
  =  32-25    ;serial 2
  =  32- 1    ;podule
  =  32- 2    ;PCI
  =  32- 7    ;PLX
  =  32-29    ;keyboard
  =  32-28    ;mouse
  =  32- 0    ;podule FIQ downgrade   (not fully compatible on IOMD2?)
  =  32- 3    ;IDE A
  =  32- 4    ;IDE B
  =  32-27    ;floppy
  =  32-21    ;FIQ downgrade          (permanent interrupt, via special use of Timer5)
  =  32-18    ;Timer2                 (currently only allow one new timer, to avoid device proliferation)
  =  32-16    ;Timer0
  =  32- 6    ;VSync
  =  32-17    ;Timer1
  =  32- 8    ;Audio 0
  =  32- 9    ;Audio 1
  =  32- 5    ;floppy index
  =  32-11    ;parallel
  =  32-31    ;fail safe terminator is bit 31 (always set)

;
;table is in same order as IOMD2_IRQCheck, maps found index to external
;device number *3 (for easier lookup of IOMD2_Devices)
;this table *must* immediately follow IOMD2_IRQCheck
;
IOMD2_IRQDevice
  =  10*3     ;serial 1 (device 10)
  =  40*3     ;serial 2
  =  13*3     ;podule
  =  31*3     ;PCI
  =  32*3     ;PLX
  =  14*3     ;keyboard
  =  15*3     ;mouse
  =   8*3     ;podule FIQ downgrade
  =   9*3     ;IDE A
  =  33*3     ;IDE B
  =  12*3     ;floppy
  =   7*3     ;FIQ downgrade
  =  36*3     ;Timer2
  =   5*3     ;Timer0
  =   3*3     ;VSync
  =   6*3     ;Timer1
  =  34*3     ;Audio 0
  =  35*3     ;Audio 1
  =   2*3     ;floppy index
  =   0*3     ;parallel
  =  IOMD2_NoInterrupt*3     ;failsafe terminator (max real device is IOMD2_NoInterrupt-1)
  ALIGN
a803 1
IOMD2_DefaultIRQ1Vcode_end
d805 1
a805 1
  ASSERT IOMD2_DefaultIRQ1Vcode_end - IOMD2_DefaultIRQ1Vcode <= DefIRQ1Vspace
d807 1
a807 1
  ] ;IOMD2Support
d810 1
a810 1
; Specialist despatchers for podules and PCI cards
d820 6
d827 1
a827 2
; PCI cards
; In    r12 =    PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)     from despatcher
d829 1
a829 1
PCIIRQ_Despatch ROUT
d831 1
a831 2
01      LDR     r12, [r12, #PodDesp_Link-PodDesp_R12Val]
        LDMIA   r12!, {r1, r2}           ; address and mask
d833 2
a834 4
        LDR     r1, [r1]                 ;note, word access for PCI (byte for podule)
        ANDS    r1, r1, r2
        BEQ     %BT01
        LDMIA   r12, {r12, pc}
d836 1
a836 3
; Podules
; In    r12 =    PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
;             or PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)     from despatcher
d838 2
a839 1
PFIQasIRQ_Despatch ROUT
a840 1
PIRQ_Despatch ; All the same thing now
a875 2
        LDR     lr, =IOMD_NoInterrupt
        LDR     lr, [lr]
d877 1
a877 1
        CMP     r0, lr
a880 1
        CMPNE   r0, #IOMD2_PCI_DevNo
d889 1
a889 8

        ASSERT  IOMD_Devices = IOMD_DefaultIRQ1Vcode+8
        LDR     lr, =IOMD_DefaultIRQ1Vcode
        LDR     r1, [lr]
        LDR     r3, [lr,#8]
        SUB     r3, r3, r1              ; offset from code start to devices table
        LDR     r1, =DefaultIRQ1V       ; code start in RAM
        ADD     r1, r1, r3
a912 2
;handles podule or PCI claim
;
a923 1
        CMPNE   r0, #IOMD2_PCI_DevNo
d944 1
a944 4

        LDR     lr, =IOMD_NoInterrupt
        LDR     lr, [lr]
        CMP     r0, lr
a948 1
        CMPNE   r0, #IOMD2_PCI_DevNo
d953 1
a953 8

        ASSERT  IOMD_Devices = IOMD_DefaultIRQ1Vcode+8
        LDR     lr, =IOMD_DefaultIRQ1Vcode
        LDR     r12, [lr]
        LDR     r11, [lr,#8]
        SUB     r11, r11, r12           ; offset from code start to devices table
        LDR     r12, =DefaultIRQ1V      ; code start in RAM
        ADD     r12, r12, r11
d987 1
a987 2
;handles podule or PCI release
;
a989 1
        CMPNE   r0, #IOMD2_PCI_DevNo
d1018 10
d1033 23
d1063 1
a1063 1
; NB. a cheap way of dividing by 3 is *171,/512: accurate for 0..511 result ...
d1067 13
a1079 28
  [ IOMD1Support
        ASSERT  IOMD1_NoInterrupt < 512
  ]
  [ IOMD2Support
        ASSERT  IOMD2_NoInterrupt < 512
  ]
        MOV     r1, #171
        MUL     r12, r0, r1
        MOV     r12, r12, LSR #9              ;r12 := devno

NOIRQ_eh
        MOV     r0, #IOC
        LDRB    r0, [r0, #IOMD_ID0]
  [ IOMD1Support
        TEQ     r0, #IOMD_Original :AND: &FF
        TEQNE   r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BEQ     NOIRQ_IOMD1
  ]
  [ IOMD2Support
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     NOIRQ_IOMD2
  ]
        B       NOIRQ_eh                      ;deliberate panic hang up        

  [ IOMD1Support

NOIRQ_IOMD1
d1081 1
d1084 6
d1096 1
d1101 1
d1115 1
d1123 1
d1125 1
d1130 5
a1144 111
  ] ;IOMD1Support

  [ IOMD2Support

NOIRQ_IOMD2
        ADR     r0, NOIRQ_IOMD2table
        LDRB    r0, [r0, r12]
        AND     r12, r0, #31         ;bit number
        MOV     r1, #1
        MOV     r1, r1, LSL r12      ;bit mask
        MOV     r12, r0, LSR #5      ;encoded register
        CMP     r12, #4 
        ADDLO   pc,pc,r12,LSL #2     ;dispatch
        Pull    pc,,^                ;4..7 means do nothing (reserved)
        B       NOIRQ_IOMD2_dma      ;0 means DMA register
        B       NOIRQ_IOMD2_int      ;1 means INT register
        B       NOIRQ_IOMD2_SMI1     ;2 means combo SMI1 register
        B       NOIRQ_IOMD2_SMI2     ;3 means combo SMI2 register
;
NOIRQ_IOMD2_dma
        MOV     r12, #IOC
        LDR     r0, [r12, #IOMD2_DMAENBL]
        BIC     r0, r0, r1
        STR     r0, [r12, #IOMD2_DMAENBL]
        Pull    pc,,^
;
NOIRQ_IOMD2_int
        MOV     r12, #IOC
        MOV     lr, pc
        TEQP    pc, #IRQ_mode+I_bit+F_bit  ;FIQs off to mess with INTENBL
        LDR     r0, [r12, #IOMD2_INTENBL]
        BIC     r0, r0, r1
        STR     r0, [r12, #IOMD2_INTENBL]
        TEQP    lr, #0
        STR     r1, [r12, #IOMD2_INTREQ]
        Pull    pc,,^
;
NOIRQ_IOMD2_SMI1
        LDR     r12,=SMI_ComboBase
        MOV     r0, #SMI_enable1
        STR     r0, [r12, #SMI_selectreg]
        LDRB    r0, [r12, #SMI_accessreg]
        BIC     r0, r0, r1
        STRB    r0, [r12, #SMI_accessreg]
        Pull    pc,,^
;
NOIRQ_IOMD2_SMI2
        LDR     r12,=SMI_ComboBase
        MOV     r0, #SMI_enable2
        STR     r0, [r12, #SMI_selectreg]
        LDRB    r0, [r12, #SMI_accessreg]
        BIC     r0, r0, r1
        STRB    r0, [r12, #SMI_accessreg]
        Pull    pc,,^
;
;indexed by device number, 1 byte per entry
;value in bits 0..4 is bit number of a register (0 to 31)
;value in bits 5..7 is encoded register:
;      0 = IOMD2 DMAENBL
;      1 = IOMD2 INTENBL (and clear in INTREQ, in case edge sensitive)
;      2 = Combo SMI enable1
;      3 = Combo SMI enable2
;      4..7 reserved (do nothing)
;
NOIRQ_IOMD2table           ;dev  name           bit   register
  = (1 :SHL: 5) + 11       ;  0  parallel        11   INTENBL
  = (7 :SHL: 5) +  0       ;  1  -
  = (1 :SHL: 5) +  5       ;  2  floppy index     5   INTENBL
  = (1 :SHL: 5) +  6       ;  3  vsync            6   INTENBL
  = (7 :SHL: 5) +  0       ;  4  -
  = (1 :SHL: 5) + 16       ;  5  Timer0          16   INTENBL
  = (1 :SHL: 5) + 17       ;  6  Timer1          17   INTENBL
  = (1 :SHL: 5) + 21       ;  7  FIQ downgrade   21   INTENBL  (uses Timer5)
  = (1 :SHL: 5) +  0       ;  8  PFIQ downgrade   0   INTENBL
  = (1 :SHL: 5) +  3       ;  9  IDE A            3   INTENBL
  = (2 :SHL: 5) +  3       ; 10  serial 1         3   SMI1
  = (7 :SHL: 5) +  0       ; 11  -
  = (2 :SHL: 5) +  4       ; 12  floppy           4   SMI1
  = (1 :SHL: 5) +  1       ; 13  PIRQ             1   INTENBL
  = (3 :SHL: 5) +  1       ; 14  keyboard         1   SMI2
  = (3 :SHL: 5) +  0       ; 15  mouse            0   SMI2
  = (0 :SHL: 5) +  0       ; 16  DMA chan 0       0   DMAENBL
  = (0 :SHL: 5) +  1       ; 17  DMA chan 1       1   DMAENBL
  = (0 :SHL: 5) +  2       ; 18  DMA chan 2       2   DMAENBL
  = (0 :SHL: 5) +  3       ; 19  DMA chan 3       3   DMAENBL
  = (0 :SHL: 5) +  4       ; 20  Sound DMA 0      4   DMAENBL
  = (7 :SHL: 5) +  0       ; 21  -
  = (7 :SHL: 5) +  0       ; 22  -
  = (7 :SHL: 5) +  0       ; 23  -
  = (7 :SHL: 5) +  0       ; 24  -
  = (7 :SHL: 5) +  0       ; 25  -
  = (7 :SHL: 5) +  0       ; 26  -
  = (0 :SHL: 5) +  8       ; 27  DMA chan 4       8   DMAENBL
  = (0 :SHL: 5) +  9       ; 28  DMA chan 5       9   DMAENBL
  = (0 :SHL: 5) + 10       ; 29  DMA chan 6      10   DMAENBL
  = (0 :SHL: 5) + 11       ; 30  DMA chan 7      11   DMAENBL
  = (1 :SHL: 5) +  2       ; 31  PCI              2   INTENBL
  = (1 :SHL: 5) +  7       ; 32  PLX              7   INTENBL
  = (1 :SHL: 5) +  4       ; 33  IDE B            4   INTENBL
  = (1 :SHL: 5) +  8       ; 34  Audio 0          8   INTENBL
  = (1 :SHL: 5) +  9       ; 35  Audio 1          9   INTENBL
  = (1 :SHL: 5) + 18       ; 36  Timer2          18   INTENBL
  = (1 :SHL: 5) + 19       ; 37  Timer3          19   INTENBL
  = (1 :SHL: 5) + 20       ; 38  Timer4          20   INTENBL
  = (1 :SHL: 5) + 21       ; 39  Timer5          21   INTENBL
  = (2 :SHL: 5) +  2       ; 40  serial 2         2   SMI1
  = (3 :SHL: 5) +  2       ; 41  IR               2   SMI2
ALIGN

  ] ;IOMD2Support

d1207 1
d1209 1
a1209 7

;IOMD2 has a problem that Timer IRQ cannot be cleared until after timer has
;counted away from 0 (up to 0.5us). This is unlikely to be a problem, because
;of the time to respond and dispatch the interrupt, but has been seen on slow
;FPGA at least. TickOne is now rearranged to delay IRQ clear as long as
;possible, and to ensure IRQ is clear. These changes should be harmless
;on IOMD1
d1215 4
a1218 3
;Counter for VDU CTRL timing
;
        LDRB    R0, CentiCounter
d1222 24
a1245 2
;Real time
;
d1253 42
a1294 2
;System clock
;
a1315 33
;Clear interrupt source (must do this before any possible IRQ re-enable)
;
        MOV     R3, #IOC
10
        MOV     R0, #timer0_bit
        STRB    R0, [R3, #IOCIRQCLRA]   ; clear timer 0 interrupt
        LDRB    R0, [R3, #IOCIRQREQA]
        TST     R0, #timer0_bit         ; wait for clear, just in case (IOMD2 workaround)
        BNE     %BT10

;Interval timer, and keyboard timing (IRQs may be re-enabled temporarily
;eg. by Event client)
;
        LDR     R0, IntervalTimer +0
        ADDS    R0, R0, #1              ; Increment the low 4 bytes
        STR     R0, IntervalTimer +0

        LDREQB  R0, IntervalTimer +4
        ADDEQ   R0, R0, #1              ; and carry into 5th byte if necessary
        STREQB  R0, IntervalTimer +4

        Push    "R4,R12"                ; R0-R3 already pushed

        TEQEQ   R0, #&100               ; has interval timer crossed zero ?
        MOVEQ   R0, #Event_IntervalTimer ; Event ITCZ
        BLEQ    OSEVEN

        BL      CentiSecondTick         ; Notify keyboard of a centisecond

        Pull    "R4,R12"

;Ticker stuff
;
a1321 1

d1328 1
d1330 1
d1350 1
a1350 1
  [ ChocolateScreen :LAND: ARMSASupport
d1387 1
a1387 1
  [ ChocolateScreen :LAND: ARMSASupport
a1390 21
;
; 1) if VSC countdown is zero but dirty screen is flagged (VIDMRD), we want to restart countdown
; 2) if VSC countdown is now zero, we do nothing (no clean pending)
; 3) if VSC countdown is now non-zero, then we want to decrement countdown
; 4) if decremented countdown would hit zero, we check for lockout by semaphore, and hold countdown at 1 if so
; 5) if countdown has hit 0 we do a screen clean, and reset everything for next time
;
;1)
        TST     R0,#ACS_HardVIDMRD                       ;check for h/w VIDMRD presence
        BEQ     %FT01
        MOV     R1,#IOMD_Base
        LDR     R1,[R1,#IOMD2_VIDMRD]                    ;this also clears h/w flag
        TST     R1,#1
        ORRNE   R0,R0,#ACS_SoftVIDMRD
        STRNE   R0,[R2,#ARMA_Cleaner_status]             ;we *must* stickily reflect transient h/w flag in SoftVIDMRD
01
        AND     R1,R0,#ACS_VSCpending_MASK
        TEQ     R1,#ACS_SoftVIDMRD                       ;EQ if countdown currently zero but SoftVIDMRD set
        ANDEQ   R1,R0,#ACS_VSClazy_MASK
        ORREQ   R0,R0,R1,LSR #(ACS_VSClazy_SHIFT-ACS_VSCcountdown_SHIFT)  ;restart countdown (VSC countdown := VSC lazy)
;2)
a1392 1
;3)
a1396 1
;4)
d1400 1
a1400 2
        MOVNE   PC,LR                                    ;if NSC or SC semaphore set, do nothing now but hold VSC countdown at 1
;5)
a1402 1
        BIC     R0,R0,#ACS_VSCpending_MASK               ;clear this since we are about to clean (appropriate) cache
a1403 3
        TST     R0,#ACS_MiniDataCache
        MOVEQ   R2,#16*1024                              ;16k data cache size
        MOVNE   R2,#1024                                 ;1k mini data cache size
d1407 1
a1407 1
        ADD     R2,R1,R2                                 ;end address (exclusive, 16k or 1k cache size)
d1416 3
a1420 4
        TST     R0,#ACS_HardVIDMRD
        ARMA_read_MMUdomain R1, EQ
        BICEQ   R1,R1,#&C
        ARMA_write_MMUdomain R1, EQ                      ;reset screen (domain 1) to fault fo VIDMRD emulation, if necessary
@


4.2.2.5.2.2
log
@Merged previously uncommitted changes made by aglover for RISC OS Ltd CD.
Removed dynamic dependencies from Makefile.
@
text
@d691 1
a691 1

a1101 1
        [ IOMD2Support
a1102 1
        ]
a1154 1
        [ IOMD2Support
a1155 1
        ]
a1183 1
        [ IOMD2Support
a1184 1
        ]
a1233 1
        [ IOMD2Support
a1234 1
        ]
d1302 1
a1302 1
        B       NOIRQ_eh                      ;deliberate panic hang up
d1366 1
a1366 1
        CMP     r12, #4
d1746 1
a1746 1
        STR     R0,[R2,#ARMA_Cleaner_status]
@


4.2.2.6
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d30 1
d32 1
a203 2
  [ IOMD1Support

d205 1
a205 1
; Default IRQ1V for IOMD1 platforms: despatch on interrupting device
d209 5
a213 1
IOMD1_DefaultIRQ1Vcode ROUT
d215 1
d219 1
a219 2
        ADRNE   r1, IOMD1_IrqDMADevnos

d221 1
a221 1
        ADREQ   r1, IOMD1_IrqReqBDevnos
d223 1
d227 11
d240 4
a243 1
        ADREQ   r1, IOMD1_IrqReqDDevnos
d246 1
a246 1
        ADREQ   r1, IOMD1_IrqReqADevnos
d251 2
a252 1

d259 12
a270 1
IOMD1_NoInterrupt * 27 ; Morris has IOMD's extra interrupts plus 5 of its own
d272 1
a272 1
IOMD1_Devices
d335 3
d339 1
d343 3
d347 1
d350 1
d376 1
d378 1
d400 50
d459 1
a459 1
IOMD1_DeviceTables
d461 2
d487 2
a488 2
IOMD1_IrqDMADevnos
  = IOMD1_NoInterrupt*3
d518 2
d542 12
d559 1
d564 2
a565 2
IOMD1_IrqReqADevnos
  =  IOMD1_NoInterrupt*3
d620 10
d638 1
d643 2
a644 2
IOMD1_IrqReqBDevnos
  =  IOMD1_NoInterrupt*3
d682 1
d703 2
a704 2
IOMD1_IrqReqDDevnos
  =  IOMD1_NoInterrupt*3
d731 5
a735 1
IOMD1_DefaultIRQ1Vcode_end
d737 2
a738 1
  ASSERT IOMD1_DefaultIRQ1Vcode_end - IOMD1_DefaultIRQ1Vcode <= DefIRQ1Vspace
d740 2
a741 1
  ] ;IOMD1Support
d743 2
a744 1
  [ IOMD2Support
d746 2
a747 2
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Default IRQ1V for IOMD2 platforms: despatch on interrupting device
d749 2
a750 1
; copied to RAM, together with vector entries and device tables
d752 2
a753 11
; Combo interrupts are all ORR'd as SMI and wired to external interrupt 10 (ei10) on IOMD2
; Hence, interrupts must be discriminated via Combo SMI status registers
;
SMI_ComboBase    *  &03010000    ;combo mapped here
SMI_selectreg    *  &3a8         ;write here to select register for access
SMI_accessreg    *  &3ac         ;access register here
SMI_enable1      *  &c           ;value to select enable1
SMI_enable2      *  &d           ;value to select enable2
SMI_status1      *  &e           ;value to select status1
SMI_status2      *  &f           ;value to select status2
SMI_INTREQbit    *  1 :SHL: 10   ;SMI at ei10, which is bit 10 of INTREQ
d755 2
a756 1
IOMD2_DefaultIRQ1Vcode ROUT
d758 2
a759 7
        MOV     r3, #IOC
;
; check for interrupting DMA device (similar to processing of INTREQ below, see comments there for description)
;
        LDR     r0, [r3, #IOMD2_DMAREQ]
        TEQ     r0, #0
        BEQ     %FT10
a760 12
        ASSERT  IOMD2_DMACheck = IOMD2_DMA_HalfMask1+4
        ORR     r0, r0, #&80000000
        ADR     r1, IOMD2_DMA_HalfMask1
        LDR     r12, [r1], #4
        TST     r0, r12
        ADDEQ   r1, r1, #IOMD2_DMA_HalfSize
05
        LDRB    r12, [r1], #1
        MOVS    r12, r0, LSL r12
        BCC     %BT05
        ADD     r1, r1, #IOMD2_DMADevice-IOMD2_DMACheck-1
        B       %FT40
d762 1
a762 64
10
;
; check for interrupting device either directly through IOMD2_INTREQ or through Combo SMI
;
        LDR     r0, [r3, #IOMD2_INTREQ]
        BIC     r0, r0, #&7E000000            ;clear pseudo bits (25..30), that may receive Combo bits
        ORR     r0, r0, #&80000000            ;set fail safe pseudo bit (31), to guarantee terminated device loop
        TST     r0, #SMI_INTREQbit            ;check for ei10 (one or more interrupts from Combo)
        BEQ     %FT20
;
; pick up Combo interrupts and munge them into pseudo bits in r0
; this is tedious, because of indexed register access, split of interrupts over two registers, and lack of
; register(s) giving pending-and-enabled status
;
        ASSERT  SMI_ComboBase < IOC
        SUB     r3, r3, #IOC-SMI_ComboBase    ;trick to get SMI_ComboBase in r3
        MOV     r12, #SMI_status1
        STR     r12, [r3, #SMI_selectreg]
        LDRB    r12, [r3, #SMI_accessreg]     ;pending IRQs, bits 2..4 are serial2,serial1,floppy
        MOV     r1,  #SMI_enable1
        STR     r1,  [r3, #SMI_selectreg]
        LDRB    r1,  [r3, #SMI_accessreg]     ;enabled IRQs
        AND     r12, r12, r1                  ;pending and enabled IRQs
        ORR     r0, r0, r12, LSL #23          ;munge SMI1 bits 2..4 into pseudo bits 25..27
        MOV     r12, #SMI_status2
        STR     r12, [r3, #SMI_selectreg]
        LDRB    r12, [r3, #SMI_accessreg]     ;pending IRQs, bits 0..2 are mouse,keyboard,IR
        MOV     r1,  #SMI_enable2
        STR     r1,  [r3, #SMI_selectreg]
        LDRB    r1,  [r3, #SMI_accessreg]     ;enabled IRQs
        AND     r12, r12, r1                  ;pending and enabled IRQs
        ORR     r0, r0, r12, LSL #28          ;munge SMI2 bits 0..2 into pseudo bits 28..30
        MOV     r3, #IOC
        
20
;
; - find highest priority interrupting device
; - serial loop may look a bit slow, but priority encoded table(s) much more unwieldy for IOMD2,
;   and not necessarily faster on a cached processor (where the small tables used here will
;   hopefully cache efficiently)
; - we do have a two-stage binary chop to speed things up a little
; - what we should have done is designed some configurable h/w priority encoding in IOMD2
;
        ASSERT  IOMD2_IRQCheck = IOMD2_IRQ_HalfMask1+3*4
        ADR     r1, IOMD2_IRQ_HalfMask1
        LDR     r12, [r1],#3*4                 ;r1 now -> IOMD2_IRQCheck
        TST     r0, r12                        ;see if any bits in upper half of priority list set
        LDREQ   r12, [r1, #-4]                 ;if not, pick up bits in 3rd quarter of priority list ...
        ADDEQ   r1, r1, #IOMD2_IRQ_HalfSize    ;... and skip to lower half of list
        LDRNE   r12, [r1, #-2*4]               ;if so, pick up bits in 1st quarter of priority list
        TST     r0, r12                        ;see if any bits in upper quarter of this half set
        ADDEQ   r1, r1, #IOMD2_IRQ_QuartSize   ;if not, skip to lower quarter
30
        LDRB    r12, [r1],#1                   ;next device
        MOVS    r12, r0, LSL r12
        BCC     %BT30                          ;carry clear if this device not interrupting
;
; - found an interrupting device in IOMD2_IRQCheck at r1-1
; - point r1 at corresponding entry in IOMD2_IRQDevice
; - possible improvement here is to order the IOMD2_Devices list in priority order, to
;   eliminate need for IOMD2_IRQDevice look-up - claim and release of devices
;   would then have to map external device numbers to internal (priority order) numbers
;
        ADD     r1, r1, #IOMD2_IRQDevice-IOMD2_IRQCheck-1
d764 2
a765 4
40
        LDRB    r0, [r1]                 ;get device number*3
        ADD     r1, pc, r0, LSL #2       ; -> entry in IOMD2_Devices
        LDMIA   r1, {r12, pc}
d767 36
a802 293
; ******* IRQ device handlers entered with r0-r3,r11,r12,r14 trashable *******
;   r3  -> IOC
;   r12 =  what they asked for
;   r14 =  return address to MOS IRQ exit sequence

IOMD2_NoInterrupt * 42

IOMD2_Devices

;  0  parallel
        & 0             ; R12 value
        & IRQ           ; call address
        & 0             ; link
;  1  unused
        & 0
        & IRQ
        & 0
;  2  floppy index
        & 0
        & IRQ
        & 0
;  3  vsync
        & OsbyteVars
        & VsyncIRQ
        & 0
;  4  unused (power on reset absent on IOMD2)
        & 0
        & IRQ
        & 0
;  5  timer0
        & OsbyteVars
        & TickOne
        & 0
;  6  timer1
        & 0
        & IRQ
        & 0
;  7  FIQ downgrade
        & 0
        & IRQ
        & 0
;  8  PFIQ downgrade
        & PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        & PFIQasIRQ_Despatch
        & 0
;  9  IDE A
        & 0
        & IRQ
        & 0
; 10  serial 1
        & 0
        & IRQ
        & 0
; 11  unused (NIC nextwork card not present on Phoebe)
        & 0
        & IRQ
        & 0
; 12  floppy
        & 0
        & IRQ
        & 0
; 13  podule IRQ
        & PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
        & PIRQ_Despatch
        & 0
; 14  PS/2 keyboard
        & IOC
        & IRQ
        & 0
; 15  PS/2 mouse
        & IOC
        & IRQ
        & 0

; 16  DMA channel 0
        & 0
        & IRQ
        & 0
; 17  DMA channel 1
        & 0
        & IRQ
        & 0
; 18  DMA channel 2
        & 0
        & IRQ
        & 0
; 19  DMA channel 3
        & 0
        & IRQ
        & 0
; 20  Sound DMA channel 0
        & 0
        & IRQ
        & 0
; 21  Sound DMA channel 1 (absent on IOMD2)
        & 0
        & IRQ
        & 0

; absent devices 22 ... 26 (7500 only)
; 22
        & 0
        & IRQ
        & 0
; 23
        & 0
        & IRQ
        & 0
; 24
        & 0
        & IRQ
        & 0
; 25
        & 0
        & IRQ
        & 0
; 26
        & 0
        & IRQ
        & 0
;new IOMD2 devices
; 27  DMA channel 4
        & 0
        & IRQ
        & 0
; 28  DMA channel 5
        & 0
        & IRQ
        & 0
; 29  DMA channel 6
        & 0
        & IRQ
        & 0
; 30  DMA channel 7
        & 0
        & IRQ
        & 0
; 31  PCI
        & PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val) ;PCI shares PIRQ_Chain with Podule
        & PCIIRQ_Despatch
        & 0
; 32  PLX (PCI controller)
        & 0
        & IRQ
        & 0
; 33  IDE B
        & 0
        & IRQ
        & 0
; 34  Audio 0
        & 0
        & IRQ
        & 0
; 35  Audio 1
        & 0
        & IRQ
        & 0
; 36  Timer 2
        & 0
        & IRQ
        & 0
; 37  Timer 3
        & 0
        & IRQ
        & 0
; 38  Timer 4
        & 0
        & IRQ
        & 0
; 39  Timer 5
        & 0
        & IRQ
        & 0
; 40  Serial 2
        & 0
        & IRQ
        & 0
; 41  IR
        & 0
        & IRQ
        & 0
; terminate
; nothing is interrupting, which is impossible: just call IRQ2V anyway
        & 0
        & IRQ
        & 0
IOMD2_Devices_end

  ASSERT IOMD2_Devices_end-IOMD2_Devices = (IOMD2_NoInterrupt+1)*4*3

; DMA structures (processing bits from DMAREQ)
; these are similar to IRQ structures, see IRQ comments for description
;
IOMD2_DMA_HalfSize   *    5
;
IOMD2_DMA_HalfMask1
  DCD  (1:SHL: 0)+(1:SHL: 1)+(1:SHL: 2)+(1:SHL: 3)+(1:SHL: 4)
;
IOMD2_DMACheck
  =  32- 0    ;DMA channel 0
  =  32- 1    ;DMA channel 1
  =  32- 2    ;DMA channel 2
  =  32- 3    ;DMA channel 3
  =  32- 4    ;DMA sound channel (VIDC sound)
  =  32- 8    ;DMA channel 4
  =  32- 9    ;DMA channel 5
  =  32-10    ;DMA channel 6
  =  32-11    ;DMA channel 7
  =  32-31    ;fail safe terminator is bit 31 (always set)
;
IOMD2_DMADevice
  =  16*3    ;DMA channel 0
  =  17*3    ;DMA channel 1
  =  18*3    ;DMA channel 2
  =  19*3    ;DMA channel 3
  =  20*3    ;DMA sound channel (VIDC sound)
  =  27*3    ;DMA channel 4
  =  28*3    ;DMA channel 5
  =  29*3    ;DMA channel 6
  =  30*3    ;DMA channel 7
  =  IOMD2_NoInterrupt*3     ;failsafe terminator (max real device is IOMD2_NoInterrupt-1)
  ALIGN

;IRQ structures (processing bits from INTREQ)
;
;to speed things up a little, two-stage binary chop to give cut worst case search by factor of 4
;this is stored just before table IOMD2_IRQCheck for extra speed (including cache friendliness)
;the bits set *must* agree with IOMD2_IRQCheck table, which *must* follow immediately after
;
IOMD2_IRQ_HalfSize   *   10  ;ten devices in half mask
IOMD2_IRQ_QuartSize  *    5  ;five devices in each quarter mask
;
IOMD2_IRQ_HalfMask1          ;1st half
  DCD  (1:SHL:26)+(1:SHL:25)+(1:SHL: 1)+(1:SHL: 2)+(1:SHL: 7)+(1:SHL:29)+(1:SHL:28)+(1:SHL: 0)+(1:SHL: 3)+(1:SHL: 4)
IOMD2_IRQ_QuartMask1         ;1st quarter
  DCD  (1:SHL:26)+(1:SHL:25)+(1:SHL: 1)+(1:SHL: 2)+(1:SHL: 7)
IOMD2_IRQ_QuartMask3         ;3rd quarter
  DCD  (1:SHL:27)+(1:SHL:21)+(1:SHL:18)+(1:SHL:16)+(1:SHL: 6)
;
;table is in order of decreasing priority, entries are amount to LSL shift appropriate
;bit of r0 into PSR C flag (allows fast test with single byte table entries)
;
IOMD2_IRQCheck
  =  32-26    ;serial 1 (bit 26 of r0)
  =  32-25    ;serial 2
  =  32- 1    ;podule
  =  32- 2    ;PCI
  =  32- 7    ;PLX
  =  32-29    ;keyboard
  =  32-28    ;mouse
  =  32- 0    ;podule FIQ downgrade   (not fully compatible on IOMD2?)
  =  32- 3    ;IDE A
  =  32- 4    ;IDE B
  =  32-27    ;floppy
  =  32-21    ;FIQ downgrade          (permanent interrupt, via special use of Timer5)
  =  32-18    ;Timer2                 (currently only allow one new timer, to avoid device proliferation)
  =  32-16    ;Timer0
  =  32- 6    ;VSync
  =  32-17    ;Timer1
  =  32- 8    ;Audio 0
  =  32- 9    ;Audio 1
  =  32- 5    ;floppy index
  =  32-11    ;parallel
  =  32-31    ;fail safe terminator is bit 31 (always set)

;
;table is in same order as IOMD2_IRQCheck, maps found index to external
;device number *3 (for easier lookup of IOMD2_Devices)
;this table *must* immediately follow IOMD2_IRQCheck
;
IOMD2_IRQDevice
  =  10*3     ;serial 1 (device 10)
  =  40*3     ;serial 2
  =  13*3     ;podule
  =  31*3     ;PCI
  =  32*3     ;PLX
  =  14*3     ;keyboard
  =  15*3     ;mouse
  =   8*3     ;podule FIQ downgrade
  =   9*3     ;IDE A
  =  33*3     ;IDE B
  =  12*3     ;floppy
  =   7*3     ;FIQ downgrade
  =  36*3     ;Timer2
  =   5*3     ;Timer0
  =   3*3     ;VSync
  =   6*3     ;Timer1
  =  34*3     ;Audio 0
  =  35*3     ;Audio 1
  =   2*3     ;floppy index
  =   0*3     ;parallel
  =  IOMD2_NoInterrupt*3     ;failsafe terminator (max real device is IOMD2_NoInterrupt-1)
  ALIGN
a803 1
IOMD2_DefaultIRQ1Vcode_end
d805 1
a805 1
  ASSERT IOMD2_DefaultIRQ1Vcode_end - IOMD2_DefaultIRQ1Vcode <= DefIRQ1Vspace
d807 1
a807 1
  ] ;IOMD2Support
d810 1
a810 1
; Specialist despatchers for podules and PCI cards
d820 6
d827 1
a827 2
; PCI cards
; In    r12 =    PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)     from despatcher
d829 1
a829 1
PCIIRQ_Despatch ROUT
d831 1
a831 2
01      LDR     r12, [r12, #PodDesp_Link-PodDesp_R12Val]
        LDMIA   r12!, {r1, r2}           ; address and mask
d833 2
a834 4
        LDR     r1, [r1]                 ;note, word access for PCI (byte for podule)
        ANDS    r1, r1, r2
        BEQ     %BT01
        LDMIA   r12, {r12, pc}
d836 1
a836 3
; Podules
; In    r12 =    PFIQasIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)
;             or PIRQ_Chain - (PodDesp_Link-PodDesp_R12Val)     from despatcher
d838 2
a839 1
PFIQasIRQ_Despatch ROUT
a840 1
PIRQ_Despatch ; All the same thing now
a875 2
        LDR     lr, =IOMD_NoInterrupt
        LDR     lr, [lr]
d877 1
a877 1
        CMP     r0, lr
a880 1
        CMPNE   r0, #IOMD2_PCI_DevNo
d889 1
a889 8

        ASSERT  IOMD_Devices = IOMD_DefaultIRQ1Vcode+8
        LDR     lr, =IOMD_DefaultIRQ1Vcode
        LDR     r1, [lr]
        LDR     r3, [lr,#8]
        SUB     r3, r3, r1              ; offset from code start to devices table
        LDR     r1, =DefaultIRQ1V       ; code start in RAM
        ADD     r1, r1, r3
a912 2
;handles podule or PCI claim
;
a923 1
        CMPNE   r0, #IOMD2_PCI_DevNo
d944 1
a944 4

        LDR     lr, =IOMD_NoInterrupt
        LDR     lr, [lr]
        CMP     r0, lr
a948 1
        CMPNE   r0, #IOMD2_PCI_DevNo
d953 1
a953 8

        ASSERT  IOMD_Devices = IOMD_DefaultIRQ1Vcode+8
        LDR     lr, =IOMD_DefaultIRQ1Vcode
        LDR     r12, [lr]
        LDR     r11, [lr,#8]
        SUB     r11, r11, r12           ; offset from code start to devices table
        LDR     r12, =DefaultIRQ1V      ; code start in RAM
        ADD     r12, r12, r11
d987 1
a987 2
;handles podule or PCI release
;
a989 1
        CMPNE   r0, #IOMD2_PCI_DevNo
d1018 10
d1033 23
d1063 1
a1063 1
; NB. a cheap way of dividing by 3 is *171,/512: accurate for 0..511 result ...
d1067 13
a1079 28
  [ IOMD1Support
        ASSERT  IOMD1_NoInterrupt < 512
  ]
  [ IOMD2Support
        ASSERT  IOMD2_NoInterrupt < 512
  ]
        MOV     r1, #171
        MUL     r12, r0, r1
        MOV     r12, r12, LSR #9              ;r12 := devno

NOIRQ_eh
        MOV     r0, #IOC
        LDRB    r0, [r0, #IOMD_ID0]
  [ IOMD1Support
        TEQ     r0, #IOMD_Original :AND: &FF
        TEQNE   r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BEQ     NOIRQ_IOMD1
  ]
  [ IOMD2Support
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     NOIRQ_IOMD2
  ]
        B       NOIRQ_eh                      ;deliberate panic hang up        

  [ IOMD1Support

NOIRQ_IOMD1
d1081 1
d1084 6
d1096 1
d1101 1
d1115 1
d1123 1
d1125 1
d1130 5
a1144 111
  ] ;IOMD1Support

  [ IOMD2Support

NOIRQ_IOMD2
        ADR     r0, NOIRQ_IOMD2table
        LDRB    r0, [r0, r12]
        AND     r12, r0, #31         ;bit number
        MOV     r1, #1
        MOV     r1, r1, LSL r12      ;bit mask
        MOV     r12, r0, LSR #5      ;encoded register
        CMP     r12, #4 
        ADDLO   pc,pc,r12,LSL #2     ;dispatch
        Pull    pc,,^                ;4..7 means do nothing (reserved)
        B       NOIRQ_IOMD2_dma      ;0 means DMA register
        B       NOIRQ_IOMD2_int      ;1 means INT register
        B       NOIRQ_IOMD2_SMI1     ;2 means combo SMI1 register
        B       NOIRQ_IOMD2_SMI2     ;3 means combo SMI2 register
;
NOIRQ_IOMD2_dma
        MOV     r12, #IOC
        LDR     r0, [r12, #IOMD2_DMAENBL]
        BIC     r0, r0, r1
        STR     r0, [r12, #IOMD2_DMAENBL]
        Pull    pc,,^
;
NOIRQ_IOMD2_int
        MOV     r12, #IOC
        MOV     lr, pc
        TEQP    pc, #IRQ_mode+I_bit+F_bit  ;FIQs off to mess with INTENBL
        LDR     r0, [r12, #IOMD2_INTENBL]
        BIC     r0, r0, r1
        STR     r0, [r12, #IOMD2_INTENBL]
        TEQP    lr, #0
        STR     r1, [r12, #IOMD2_INTREQ]
        Pull    pc,,^
;
NOIRQ_IOMD2_SMI1
        LDR     r12,=SMI_ComboBase
        MOV     r0, #SMI_enable1
        STR     r0, [r12, #SMI_selectreg]
        LDRB    r0, [r12, #SMI_accessreg]
        BIC     r0, r0, r1
        STRB    r0, [r12, #SMI_accessreg]
        Pull    pc,,^
;
NOIRQ_IOMD2_SMI2
        LDR     r12,=SMI_ComboBase
        MOV     r0, #SMI_enable2
        STR     r0, [r12, #SMI_selectreg]
        LDRB    r0, [r12, #SMI_accessreg]
        BIC     r0, r0, r1
        STRB    r0, [r12, #SMI_accessreg]
        Pull    pc,,^
;
;indexed by device number, 1 byte per entry
;value in bits 0..4 is bit number of a register (0 to 31)
;value in bits 5..7 is encoded register:
;      0 = IOMD2 DMAENBL
;      1 = IOMD2 INTENBL (and clear in INTREQ, in case edge sensitive)
;      2 = Combo SMI enable1
;      3 = Combo SMI enable2
;      4..7 reserved (do nothing)
;
NOIRQ_IOMD2table           ;dev  name           bit   register
  = (1 :SHL: 5) + 11       ;  0  parallel        11   INTENBL
  = (7 :SHL: 5) +  0       ;  1  -
  = (1 :SHL: 5) +  5       ;  2  floppy index     5   INTENBL
  = (1 :SHL: 5) +  6       ;  3  vsync            6   INTENBL
  = (7 :SHL: 5) +  0       ;  4  -
  = (1 :SHL: 5) + 16       ;  5  Timer0          16   INTENBL
  = (1 :SHL: 5) + 17       ;  6  Timer1          17   INTENBL
  = (1 :SHL: 5) + 21       ;  7  FIQ downgrade   21   INTENBL  (uses Timer5)
  = (1 :SHL: 5) +  0       ;  8  PFIQ downgrade   0   INTENBL
  = (1 :SHL: 5) +  3       ;  9  IDE A            3   INTENBL
  = (2 :SHL: 5) +  3       ; 10  serial 1         3   SMI1
  = (7 :SHL: 5) +  0       ; 11  -
  = (2 :SHL: 5) +  4       ; 12  floppy           4   SMI1
  = (1 :SHL: 5) +  1       ; 13  PIRQ             1   INTENBL
  = (3 :SHL: 5) +  1       ; 14  keyboard         1   SMI2
  = (3 :SHL: 5) +  0       ; 15  mouse            0   SMI2
  = (0 :SHL: 5) +  0       ; 16  DMA chan 0       0   DMAENBL
  = (0 :SHL: 5) +  1       ; 17  DMA chan 1       1   DMAENBL
  = (0 :SHL: 5) +  2       ; 18  DMA chan 2       2   DMAENBL
  = (0 :SHL: 5) +  3       ; 19  DMA chan 3       3   DMAENBL
  = (0 :SHL: 5) +  4       ; 20  Sound DMA 0      4   DMAENBL
  = (7 :SHL: 5) +  0       ; 21  -
  = (7 :SHL: 5) +  0       ; 22  -
  = (7 :SHL: 5) +  0       ; 23  -
  = (7 :SHL: 5) +  0       ; 24  -
  = (7 :SHL: 5) +  0       ; 25  -
  = (7 :SHL: 5) +  0       ; 26  -
  = (0 :SHL: 5) +  8       ; 27  DMA chan 4       8   DMAENBL
  = (0 :SHL: 5) +  9       ; 28  DMA chan 5       9   DMAENBL
  = (0 :SHL: 5) + 10       ; 29  DMA chan 6      10   DMAENBL
  = (0 :SHL: 5) + 11       ; 30  DMA chan 7      11   DMAENBL
  = (1 :SHL: 5) +  2       ; 31  PCI              2   INTENBL
  = (1 :SHL: 5) +  7       ; 32  PLX              7   INTENBL
  = (1 :SHL: 5) +  4       ; 33  IDE B            4   INTENBL
  = (1 :SHL: 5) +  8       ; 34  Audio 0          8   INTENBL
  = (1 :SHL: 5) +  9       ; 35  Audio 1          9   INTENBL
  = (1 :SHL: 5) + 18       ; 36  Timer2          18   INTENBL
  = (1 :SHL: 5) + 19       ; 37  Timer3          19   INTENBL
  = (1 :SHL: 5) + 20       ; 38  Timer4          20   INTENBL
  = (1 :SHL: 5) + 21       ; 39  Timer5          21   INTENBL
  = (2 :SHL: 5) +  2       ; 40  serial 2         2   SMI1
  = (3 :SHL: 5) +  2       ; 41  IR               2   SMI2
ALIGN

  ] ;IOMD2Support

d1207 1
d1209 1
a1209 7

;IOMD2 has a problem that Timer IRQ cannot be cleared until after timer has
;counted away from 0 (up to 0.5us). This is unlikely to be a problem, because
;of the time to respond and dispatch the interrupt, but has been seen on slow
;FPGA at least. TickOne is now rearranged to delay IRQ clear as long as
;possible, and to ensure IRQ is clear. These changes should be harmless
;on IOMD1
d1215 4
a1218 3
;Counter for VDU CTRL timing
;
        LDRB    R0, CentiCounter
d1222 24
a1245 2
;Real time
;
d1253 42
a1294 2
;System clock
;
a1315 33
;Clear interrupt source (must do this before any possible IRQ re-enable)
;
        MOV     R3, #IOC
10
        MOV     R0, #timer0_bit
        STRB    R0, [R3, #IOCIRQCLRA]   ; clear timer 0 interrupt
        LDRB    R0, [R3, #IOCIRQREQA]
        TST     R0, #timer0_bit         ; wait for clear, just in case (IOMD2 workaround)
        BNE     %BT10

;Interval timer, and keyboard timing (IRQs may be re-enabled temporarily
;eg. by Event client)
;
        LDR     R0, IntervalTimer +0
        ADDS    R0, R0, #1              ; Increment the low 4 bytes
        STR     R0, IntervalTimer +0

        LDREQB  R0, IntervalTimer +4
        ADDEQ   R0, R0, #1              ; and carry into 5th byte if necessary
        STREQB  R0, IntervalTimer +4

        Push    "R4,R12"                ; R0-R3 already pushed

        TEQEQ   R0, #&100               ; has interval timer crossed zero ?
        MOVEQ   R0, #Event_IntervalTimer ; Event ITCZ
        BLEQ    OSEVEN

        BL      CentiSecondTick         ; Notify keyboard of a centisecond

        Pull    "R4,R12"

;Ticker stuff
;
a1321 1

d1328 1
d1330 1
d1350 1
a1350 1
  [ ChocolateScreen :LAND: ARMSASupport
d1387 1
a1387 1
  [ ChocolateScreen :LAND: ARMSASupport
a1390 21
;
; 1) if VSC countdown is zero but dirty screen is flagged (VIDMRD), we want to restart countdown
; 2) if VSC countdown is now zero, we do nothing (no clean pending)
; 3) if VSC countdown is now non-zero, then we want to decrement countdown
; 4) if decremented countdown would hit zero, we check for lockout by semaphore, and hold countdown at 1 if so
; 5) if countdown has hit 0 we do a screen clean, and reset everything for next time
;
;1)
        TST     R0,#ACS_HardVIDMRD                       ;check for h/w VIDMRD presence
        BEQ     %FT01
        MOV     R1,#IOMD_Base
        LDR     R1,[R1,#IOMD2_VIDMRD]                    ;this also clears h/w flag
        TST     R1,#1
        ORRNE   R0,R0,#ACS_SoftVIDMRD
        STRNE   R0,[R2,#ARMA_Cleaner_status]             ;we *must* stickily reflect transient h/w flag in SoftVIDMRD
01
        AND     R1,R0,#ACS_VSCpending_MASK
        TEQ     R1,#ACS_SoftVIDMRD                       ;EQ if countdown currently zero but SoftVIDMRD set
        ANDEQ   R1,R0,#ACS_VSClazy_MASK
        ORREQ   R0,R0,R1,LSR #(ACS_VSClazy_SHIFT-ACS_VSCcountdown_SHIFT)  ;restart countdown (VSC countdown := VSC lazy)
;2)
a1392 1
;3)
a1396 1
;4)
d1400 1
a1400 2
        MOVNE   PC,LR                                    ;if NSC or SC semaphore set, do nothing now but hold VSC countdown at 1
;5)
a1402 1
        BIC     R0,R0,#ACS_VSCpending_MASK               ;clear this since we are about to clean (appropriate) cache
a1403 3
        TST     R0,#ACS_MiniDataCache
        MOVEQ   R2,#16*1024                              ;16k data cache size
        MOVNE   R2,#1024                                 ;1k mini data cache size
d1407 1
a1407 1
        ADD     R2,R1,R2                                 ;end address (exclusive, 16k or 1k cache size)
d1416 3
a1420 4
        TST     R0,#ACS_HardVIDMRD
        ARMA_read_MMUdomain R1, EQ
        BICEQ   R1,R1,#&C
        ARMA_write_MMUdomain R1, EQ                      ;reset screen (domain 1) to fault fo VIDMRD emulation, if necessary
@


4.1
log
@Initial revision
@
text
@d30 4
d110 4
d128 11
d142 1
d144 1
d173 3
d177 1
d325 49
d383 25
d412 34
d491 3
d531 1
a594 1

a635 58
 [ IO_Type = "IOMD"
; Prioritised IOMD DMA device numbers

IrqDMAPrio0     * 1:SHL:5
IrqDMADev0      * IOMD_DMASound1_DevNo

IrqDMAPrio1     * 1:SHL:4
IrqDMADev1      * IOMD_DMASound0_DevNo

IrqDMAPrio2     * 1:SHL:3
IrqDMADev2      * IOMD_DMAChannel3_DevNo

IrqDMAPrio3     * 1:SHL:2
IrqDMADev3      * IOMD_DMAChannel2_DevNo

IrqDMAPrio4     * 1:SHL:1
IrqDMADev4      * IOMD_DMAChannel1_DevNo

IrqDMAPrio5     * 1:SHL:0
IrqDMADev5      * IOMD_DMAChannel0_DevNo


DTabC SETA 1

IrqDMADevnos
  = NoInterrupt*3

; Top 2 bits are always 0 so table need only be 64 bytes
  WHILE DTabC <64
  [ (DTabC:AND:IrqDMAPrio5)<>0
  = IrqDMADev5*3
  |
  [ (DTabC:AND:IrqDMAPrio4)<>0
  = IrqDMADev4*3
  |
  [ (DTabC:AND:IrqDMAPrio3)<>0
  = IrqDMADev3*3
  |
  [ (DTabC:AND:IrqDMAPrio2)<>0
  = IrqDMADev2*3
  |
  [ (DTabC:AND:IrqDMAPrio1)<>0
  = IrqDMADev1*3
  |
  [ (DTabC:AND:IrqDMAPrio0)<>0
  = IrqDMADev0*3
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

 ]


d660 2
a661 1
; Top 3 bits are always 0 so table need only be 32 bytes
d685 71
d1050 9
d1175 4
d1302 4
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a119 2
        ADREQ   r12, DeviceTables       ; can't reach these tables with ADR

d122 1
a122 5
        ADDEQ   r1, r12, #IrqReqDDevnos-DeviceTables

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQC]
        ADDEQ   r1, r12, #IrqReqCDevnos-DeviceTables
a123 1

d152 1
a152 1
NoInterrupt * 38 ; Morris has IOMD's extra interrupts plus 16 of its own
a299 47
; The following are just place fillers in case IRQD bits 5 to 7 are ever used.
; NoInterrupt
        & 0
        & IRQ
        & 0
; NoInterrupt
        & 0
        & IRQ
        & 0
; NoInterrupt
        & 0
        & IRQ
        & 0

; register C devices
; Bit0
        & 0
        & IRQ
        & 0
; Bit1
        & 0
        & IRQ
        & 0
; Bit2
        & 0
        & IRQ
        & 0
; Bit3
        & 0
        & IRQ
        & 0
; Bit4
        & 0
        & IRQ
        & 0
; Bit5
        & 0
        & IRQ
        & 0
; Bit6
        & 0
        & IRQ
        & 0
; Bit7
        & 0
        & IRQ
        & 0
a308 25
;
DeviceTables


 [ IO_Type = "IOMD"
; Prioritised IOMD DMA device numbers

IrqDMAPrio0     * 1:SHL:5
IrqDMADev0      * IOMD_DMASound1_DevNo

IrqDMAPrio1     * 1:SHL:4
IrqDMADev1      * IOMD_DMASound0_DevNo

IrqDMAPrio2     * 1:SHL:3
IrqDMADev2      * IOMD_DMAChannel3_DevNo

IrqDMAPrio3     * 1:SHL:2
IrqDMADev3      * IOMD_DMAChannel2_DevNo

IrqDMAPrio4     * 1:SHL:1
IrqDMADev4      * IOMD_DMAChannel1_DevNo

IrqDMAPrio5     * 1:SHL:0
IrqDMADev5      * IOMD_DMAChannel0_DevNo

a312 34
IrqDMADevnos
  = NoInterrupt*3

; Top 2 bits are always 0 so table need only be 64 bytes
  WHILE DTabC <64
  [ (DTabC:AND:IrqDMAPrio5)<>0
  = IrqDMADev5*3
  |
  [ (DTabC:AND:IrqDMAPrio4)<>0
  = IrqDMADev4*3
  |
  [ (DTabC:AND:IrqDMAPrio3)<>0
  = IrqDMADev3*3
  |
  [ (DTabC:AND:IrqDMAPrio2)<>0
  = IrqDMADev2*3
  |
  [ (DTabC:AND:IrqDMAPrio1)<>0
  = IrqDMADev1*3
  |
  [ (DTabC:AND:IrqDMAPrio0)<>0
  = IrqDMADev0*3
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

 ]


a357 3

DTabC  SETA 1

a394 1

d458 1
d500 58
d582 1
a582 2
; Top 3 bits are always 0 so table need only be 32 bytes (this will
; need to change if bits 5 to 7 are ever used).
a605 71

; Prioritised IRQC device numbers. We have to handle ALL interrupts
; using specific device numbers as we don't know what the IO pins
; are connected to and the NOIRQ code has to know what bit to clear
; when an unknown interrupt is triggered.

IrqReqCPrio0    * 1:SHL:0
IrqReqCDev0     * IOMD_C_Bit0_DevNo

IrqReqCPrio1    * 1:SHL:1
IrqReqCDev1     * IOMD_C_Bit1_DevNo

IrqReqCPrio2    * 1:SHL:2
IrqReqCDev2     * IOMD_C_Bit2_DevNo

IrqReqCPrio3    * 1:SHL:3
IrqReqCDev3     * IOMD_C_Bit3_DevNo

IrqReqCPrio4    * 1:SHL:4
IrqReqCDev4     * IOMD_C_Bit4_DevNo

IrqReqCPrio5    * 1:SHL:5
IrqReqCDev5     * IOMD_C_Bit5_DevNo

IrqReqCPrio6    * 1:SHL:6
IrqReqCDev6     * IOMD_C_Bit6_DevNo

IrqReqCPrio7    * 1:SHL:7
IrqReqCDev7     * IOMD_C_Bit7_DevNo


DTabC   SETA 1

IrqReqCDevnos
  =  NoInterrupt*3

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqCPrio7)<>0
  = IrqReqCDev7*3
  |
  [ (DTabC:AND:IrqReqCPrio6)<>0
  = IrqReqCDev6*3
  |
  [ (DTabC:AND:IrqReqCPrio5)<>0
  = IrqReqCDev5*3
  |
  [ (DTabC:AND:IrqReqCPrio4)<>0
  = IrqReqCDev4*3
  |
  [ (DTabC:AND:IrqReqCPrio3)<>0
  = IrqReqCDev3*3
  |
  [ (DTabC:AND:IrqReqCPrio2)<>0
  = IrqReqCDev2*3
  |
  [ (DTabC:AND:IrqReqCPrio1)<>0
  = IrqReqCDev1*3
  |
  [ (DTabC:AND:IrqReqCPrio0)<>0
  = IrqReqCDev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

a899 7
; Cope with interrupts from IRQC registers
;
        CMP     R12, #IOMD_C_Bit0_DevNo
        SUBHS   R12, R12, #IOMD_C_Bit0_DevNo
        MOVHS   R0, #IOMD_IRQMSKC
        BHS     %FT03

@


4.1.7.2
log
@Added support for inverted podule IRQ pending bit.
@
text
@a781 1
	EOR	r1, r1, r2, LSR #8
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a119 2
        ADREQ   r12, DeviceTables       ; can't reach these tables with ADR

d122 1
a122 5
        ADDEQ   r1, r12, #IrqReqDDevnos-DeviceTables

        TEQEQ   r0, #0
        LDREQB  r0, [r3, #IOMD_IRQRQC]
        ADDEQ   r1, r12, #IrqReqCDevnos-DeviceTables
a123 1

d152 1
a152 1
NoInterrupt * 38 ; Morris has IOMD's extra interrupts plus 16 of its own
a299 47
; The following are just place fillers in case IRQD bits 5 to 7 are ever used.
; NoInterrupt
        & 0
        & IRQ
        & 0
; NoInterrupt
        & 0
        & IRQ
        & 0
; NoInterrupt
        & 0
        & IRQ
        & 0

; register C devices
; Bit0
        & 0
        & IRQ
        & 0
; Bit1
        & 0
        & IRQ
        & 0
; Bit2
        & 0
        & IRQ
        & 0
; Bit3
        & 0
        & IRQ
        & 0
; Bit4
        & 0
        & IRQ
        & 0
; Bit5
        & 0
        & IRQ
        & 0
; Bit6
        & 0
        & IRQ
        & 0
; Bit7
        & 0
        & IRQ
        & 0
a308 25
;
DeviceTables


 [ IO_Type = "IOMD"
; Prioritised IOMD DMA device numbers

IrqDMAPrio0     * 1:SHL:5
IrqDMADev0      * IOMD_DMASound1_DevNo

IrqDMAPrio1     * 1:SHL:4
IrqDMADev1      * IOMD_DMASound0_DevNo

IrqDMAPrio2     * 1:SHL:3
IrqDMADev2      * IOMD_DMAChannel3_DevNo

IrqDMAPrio3     * 1:SHL:2
IrqDMADev3      * IOMD_DMAChannel2_DevNo

IrqDMAPrio4     * 1:SHL:1
IrqDMADev4      * IOMD_DMAChannel1_DevNo

IrqDMAPrio5     * 1:SHL:0
IrqDMADev5      * IOMD_DMAChannel0_DevNo

a312 34
IrqDMADevnos
  = NoInterrupt*3

; Top 2 bits are always 0 so table need only be 64 bytes
  WHILE DTabC <64
  [ (DTabC:AND:IrqDMAPrio5)<>0
  = IrqDMADev5*3
  |
  [ (DTabC:AND:IrqDMAPrio4)<>0
  = IrqDMADev4*3
  |
  [ (DTabC:AND:IrqDMAPrio3)<>0
  = IrqDMADev3*3
  |
  [ (DTabC:AND:IrqDMAPrio2)<>0
  = IrqDMADev2*3
  |
  [ (DTabC:AND:IrqDMAPrio1)<>0
  = IrqDMADev1*3
  |
  [ (DTabC:AND:IrqDMAPrio0)<>0
  = IrqDMADev0*3
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

 ]


a357 3

DTabC  SETA 1

a394 1

d458 1
d500 58
d582 1
a582 2
; Top 3 bits are always 0 so table need only be 32 bytes (this will
; need to change if bits 5 to 7 are ever used).
a605 71

; Prioritised IRQC device numbers. We have to handle ALL interrupts
; using specific device numbers as we don't know what the IO pins
; are connected to and the NOIRQ code has to know what bit to clear
; when an unknown interrupt is triggered.

IrqReqCPrio0    * 1:SHL:0
IrqReqCDev0     * IOMD_C_Bit0_DevNo

IrqReqCPrio1    * 1:SHL:1
IrqReqCDev1     * IOMD_C_Bit1_DevNo

IrqReqCPrio2    * 1:SHL:2
IrqReqCDev2     * IOMD_C_Bit2_DevNo

IrqReqCPrio3    * 1:SHL:3
IrqReqCDev3     * IOMD_C_Bit3_DevNo

IrqReqCPrio4    * 1:SHL:4
IrqReqCDev4     * IOMD_C_Bit4_DevNo

IrqReqCPrio5    * 1:SHL:5
IrqReqCDev5     * IOMD_C_Bit5_DevNo

IrqReqCPrio6    * 1:SHL:6
IrqReqCDev6     * IOMD_C_Bit6_DevNo

IrqReqCPrio7    * 1:SHL:7
IrqReqCDev7     * IOMD_C_Bit7_DevNo


DTabC   SETA 1

IrqReqCDevnos
  =  NoInterrupt*3

  WHILE DTabC <256
  [ (DTabC:AND:IrqReqCPrio7)<>0
  = IrqReqCDev7*3
  |
  [ (DTabC:AND:IrqReqCPrio6)<>0
  = IrqReqCDev6*3
  |
  [ (DTabC:AND:IrqReqCPrio5)<>0
  = IrqReqCDev5*3
  |
  [ (DTabC:AND:IrqReqCPrio4)<>0
  = IrqReqCDev4*3
  |
  [ (DTabC:AND:IrqReqCPrio3)<>0
  = IrqReqCDev3*3
  |
  [ (DTabC:AND:IrqReqCPrio2)<>0
  = IrqReqCDev2*3
  |
  [ (DTabC:AND:IrqReqCPrio1)<>0
  = IrqReqCDev1*3
  |
  [ (DTabC:AND:IrqReqCPrio0)<>0
  = IrqReqCDev0*3
  ]
  ]
  ]
  ]
  ]
  ]
  ]
  ]
DTabC SETA DTabC+1
  WEND

a899 7
; Cope with interrupts from IRQC registers
;
        CMP     R12, #IOMD_C_Bit0_DevNo
        SUBHS   R12, R12, #IOMD_C_Bit0_DevNo
        MOVHS   R0, #IOMD_IRQMSKC
        BHS     %FT03

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a29 2
        ALIGN 32

a105 2
        ALIGN 32

a1015 2
        ALIGN 32

a1138 2

        ALIGN 32
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

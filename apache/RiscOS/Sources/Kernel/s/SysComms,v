head	4.9;
access;
symbols
	Kernel-6_14:4.9
	Kernel-6_01-3:4.9
	Kernel-6_13:4.9
	Kernel-6_12:4.9
	Kernel-6_11:4.9
	Kernel-6_10:4.9
	Kernel-6_09:4.9
	Kernel-6_08-4_129_2_10:4.9
	Kernel-6_08-4_129_2_9:4.9
	Kernel-6_08:4.9
	Kernel-6_07:4.9
	Kernel-6_06:4.9
	Kernel-6_05-4_129_2_8:4.9
	Kernel-6_05:4.9
	Kernel-6_04:4.9
	Kernel-6_03:4.9
	Kernel-6_01-2:4.9
	Kernel-6_01-4_146_2_1:4.9
	Kernel-6_02:4.9
	Kernel-6_01-1:4.9
	Kernel-6_01:4.9
	Kernel-6_00:4.9
	Kernel-5_99:4.9
	Kernel-5_98:4.9
	Kernel-5_97-4_129_2_7:4.9
	Kernel-5_97:4.9
	Kernel-5_96:4.9
	Kernel-5_95:4.9
	Kernel-5_94:4.9
	Kernel-5_93:4.9
	Kernel-5_92:4.9
	Kernel-5_91:4.9
	Kernel-5_90:4.9
	Kernel-5_89-4_129_2_6:4.9
	Kernel-5_89:4.9
	Kernel-5_88-4_129_2_5:4.9
	Kernel-5_88-4_129_2_4:4.9
	Kernel-5_88:4.9
	Kernel-5_87:4.9
	Kernel-5_86-4_129_2_3:4.9
	Kernel-5_86-4_129_2_2:4.9
	Kernel-5_86-4_129_2_1:4.9
	Kernel-5_86:4.9
	SMP:4.9.0.2
	SMP_bp:4.9
	Kernel-5_85:4.9
	Kernel-5_54-1:4.9
	Kernel-5_84:4.9
	Kernel-5_83:4.9
	Kernel-5_82:4.9
	Kernel-5_81:4.9
	Kernel-5_80:4.9
	Kernel-5_79:4.9
	Kernel-5_78:4.9
	Kernel-5_77:4.9
	Kernel-5_76:4.9
	Kernel-5_75:4.9
	Kernel-5_74:4.9
	Kernel-5_73:4.9
	Kernel-5_72:4.9
	Kernel-5_71:4.9
	Kernel-5_70:4.9
	Kernel-5_69:4.9
	Kernel-5_68:4.9
	Kernel-5_67:4.9
	Kernel-5_66:4.9
	Kernel-5_65:4.9
	Kernel-5_64:4.9
	Kernel-5_63:4.9
	Kernel-5_62:4.9
	Kernel-5_61:4.9
	Kernel-5_60:4.9
	Kernel-5_59:4.9
	Kernel-5_58:4.9
	Kernel-5_57:4.9
	Kernel-5_56:4.9
	Kernel-5_55:4.9
	Kernel-5_54:4.9
	Kernel-5_53:4.8
	Kernel-5_52:4.7
	Kernel-5_51:4.7
	Kernel-5_50:4.6
	Kernel-5_49:4.6
	HAL_merge:4.5.2.11
	Kernel-5_48:4.6
	Kernel-5_35-4_79_2_327:4.5.2.11
	Kernel-5_35-4_79_2_326:4.5.2.11
	Kernel-5_35-4_79_2_325:4.5.2.11
	Kernel-5_35-4_79_2_324:4.5.2.11
	Kernel-5_35-4_79_2_323:4.5.2.11
	Kernel-5_35-4_79_2_322:4.5.2.11
	Kernel-5_35-4_79_2_321:4.5.2.11
	Kernel-5_35-4_79_2_320:4.5.2.11
	Kernel-5_35-4_79_2_319:4.5.2.11
	Kernel-5_35-4_79_2_318:4.5.2.11
	Kernel-5_35-4_79_2_317:4.5.2.11
	Kernel-5_35-4_79_2_316:4.5.2.11
	Kernel-5_35-4_79_2_315:4.5.2.11
	Kernel-5_35-4_79_2_314:4.5.2.11
	Kernel-5_35-4_79_2_313:4.5.2.11
	Kernel-5_35-4_79_2_312:4.5.2.11
	Kernel-5_35-4_79_2_311:4.5.2.11
	Kernel-5_35-4_79_2_310:4.5.2.11
	Kernel-5_35-4_79_2_309:4.5.2.11
	Kernel-5_35-4_79_2_308:4.5.2.11
	Kernel-5_35-4_79_2_307:4.5.2.11
	Kernel-5_35-4_79_2_306:4.5.2.11
	Kernel-5_35-4_79_2_305:4.5.2.11
	Kernel-5_35-4_79_2_304:4.5.2.11
	Kernel-5_35-4_79_2_303:4.5.2.11
	Kernel-5_35-4_79_2_302:4.5.2.11
	Kernel-5_35-4_79_2_301:4.5.2.11
	Kernel-5_35-4_79_2_300:4.5.2.11
	Kernel-5_35-4_79_2_299:4.5.2.11
	Kernel-5_35-4_79_2_298:4.5.2.11
	Kernel-5_35-4_79_2_297:4.5.2.11
	Kernel-5_35-4_79_2_296:4.5.2.11
	Kernel-5_35-4_79_2_295:4.5.2.11
	Kernel-5_35-4_79_2_294:4.5.2.11
	Kernel-5_35-4_79_2_293:4.5.2.11
	Kernel-5_35-4_79_2_292:4.5.2.11
	Kernel-5_35-4_79_2_291:4.5.2.11
	Kernel-5_35-4_79_2_290:4.5.2.11
	Kernel-5_35-4_79_2_289:4.5.2.11
	Kernel-5_35-4_79_2_288:4.5.2.11
	Kernel-5_35-4_79_2_287:4.5.2.11
	Kernel-5_35-4_79_2_286:4.5.2.11
	Kernel-5_35-4_79_2_285:4.5.2.11
	Kernel-5_35-4_79_2_284:4.5.2.11
	Kernel-5_35-4_79_2_283:4.5.2.11
	Kernel-5_35-4_79_2_282:4.5.2.11
	Kernel-5_35-4_79_2_281:4.5.2.11
	Kernel-5_35-4_79_2_280:4.5.2.11
	Kernel-5_35-4_79_2_279:4.5.2.11
	Kernel-5_35-4_79_2_278:4.5.2.11
	Kernel-5_35-4_79_2_277:4.5.2.11
	Kernel-5_35-4_79_2_276:4.5.2.11
	Kernel-5_35-4_79_2_275:4.5.2.11
	Kernel-5_35-4_79_2_274:4.5.2.11
	Kernel-5_35-4_79_2_273:4.5.2.11
	Kernel-5_35-4_79_2_272:4.5.2.11
	Kernel-5_35-4_79_2_271:4.5.2.11
	Kernel-5_35-4_79_2_270:4.5.2.11
	Kernel-5_35-4_79_2_269:4.5.2.11
	Kernel-5_35-4_79_2_268:4.5.2.11
	Kernel-5_35-4_79_2_267:4.5.2.11
	Kernel-5_35-4_79_2_266:4.5.2.11
	Kernel-5_35-4_79_2_265:4.5.2.11
	Kernel-5_35-4_79_2_264:4.5.2.11
	Kernel-5_35-4_79_2_263:4.5.2.11
	Kernel-5_35-4_79_2_262:4.5.2.11
	Kernel-5_35-4_79_2_261:4.5.2.11
	Kernel-5_35-4_79_2_260:4.5.2.11
	Kernel-5_35-4_79_2_259:4.5.2.11
	Kernel-5_35-4_79_2_258:4.5.2.11
	Kernel-5_35-4_79_2_257:4.5.2.11
	Kernel-5_35-4_79_2_256:4.5.2.11
	Kernel-5_35-4_79_2_255:4.5.2.11
	Kernel-5_35-4_79_2_254:4.5.2.11
	Kernel-5_35-4_79_2_253:4.5.2.11
	Kernel-5_35-4_79_2_252:4.5.2.11
	Kernel-5_35-4_79_2_251:4.5.2.11
	Kernel-5_35-4_79_2_250:4.5.2.11
	Kernel-5_35-4_79_2_249:4.5.2.11
	Kernel-5_35-4_79_2_248:4.5.2.11
	Kernel-5_35-4_79_2_247:4.5.2.11
	Kernel-5_35-4_79_2_246:4.5.2.11
	Kernel-5_35-4_79_2_245:4.5.2.11
	Kernel-5_35-4_79_2_244:4.5.2.11
	Kernel-5_35-4_79_2_243:4.5.2.11
	Kernel-5_35-4_79_2_242:4.5.2.11
	Kernel-5_35-4_79_2_241:4.5.2.11
	Kernel-5_35-4_79_2_240:4.5.2.11
	Kernel-5_35-4_79_2_239:4.5.2.11
	Kernel-5_35-4_79_2_238:4.5.2.11
	Kernel-5_35-4_79_2_237:4.5.2.11
	Kernel-5_35-4_79_2_236:4.5.2.11
	Kernel-5_35-4_79_2_235:4.5.2.11
	Kernel-5_35-4_79_2_234:4.5.2.11
	Kernel-5_35-4_79_2_233:4.5.2.11
	Kernel-5_35-4_79_2_232:4.5.2.11
	Kernel-5_35-4_79_2_231:4.5.2.11
	Kernel-5_35-4_79_2_230:4.5.2.11
	Kernel-5_35-4_79_2_229:4.5.2.11
	Kernel-5_35-4_79_2_228:4.5.2.11
	Kernel-5_35-4_79_2_227:4.5.2.10
	Kernel-5_35-4_79_2_226:4.5.2.10
	Kernel-5_35-4_79_2_225:4.5.2.10
	Kernel-5_35-4_79_2_224:4.5.2.10
	Kernel-5_35-4_79_2_223:4.5.2.10
	Kernel-5_35-4_79_2_222:4.5.2.10
	Kernel-5_35-4_79_2_221:4.5.2.10
	Kernel-5_35-4_79_2_220:4.5.2.10
	Kernel-5_35-4_79_2_219:4.5.2.10
	Kernel-5_35-4_79_2_218:4.5.2.10
	Kernel-5_35-4_79_2_217:4.5.2.10
	Kernel-5_35-4_79_2_216:4.5.2.10
	Kernel-5_35-4_79_2_215:4.5.2.10
	Kernel-5_35-4_79_2_214:4.5.2.10
	Kernel-5_35-4_79_2_213:4.5.2.10
	Kernel-5_35-4_79_2_212:4.5.2.10
	Kernel-5_35-4_79_2_211:4.5.2.10
	Kernel-5_35-4_79_2_210:4.5.2.10
	Kernel-5_35-4_79_2_209:4.5.2.10
	Kernel-5_35-4_79_2_208:4.5.2.10
	Kernel-5_35-4_79_2_207:4.5.2.10
	Kernel-5_35-4_79_2_206:4.5.2.10
	Kernel-5_35-4_79_2_205:4.5.2.10
	Kernel-5_35-4_79_2_204:4.5.2.10
	Kernel-5_35-4_79_2_203:4.5.2.10
	Kernel-5_35-4_79_2_202:4.5.2.10
	Kernel-5_35-4_79_2_201:4.5.2.10
	Kernel-5_35-4_79_2_200:4.5.2.10
	Kernel-5_35-4_79_2_199:4.5.2.10
	Kernel-5_35-4_79_2_198:4.5.2.10
	Kernel-5_35-4_79_2_197:4.5.2.10
	Kernel-5_35-4_79_2_196:4.5.2.10
	Kernel-5_35-4_79_2_195:4.5.2.10
	Kernel-5_35-4_79_2_194:4.5.2.10
	Kernel-5_35-4_79_2_193:4.5.2.10
	Kernel-5_35-4_79_2_192:4.5.2.10
	Kernel-5_35-4_79_2_191:4.5.2.10
	Kernel-5_35-4_79_2_190:4.5.2.10
	Kernel-5_35-4_79_2_189:4.5.2.10
	Kernel-5_35-4_79_2_188:4.5.2.10
	Kernel-5_35-4_79_2_187:4.5.2.10
	Kernel-5_35-4_79_2_186:4.5.2.10
	Kernel-5_35-4_79_2_185:4.5.2.10
	Kernel-5_35-4_79_2_184:4.5.2.10
	Kernel-5_35-4_79_2_183:4.5.2.10
	Kernel-5_35-4_79_2_182:4.5.2.9
	Kernel-5_35-4_79_2_181:4.5.2.9
	Kernel-5_35-4_79_2_180:4.5.2.9
	Kernel-5_35-4_79_2_179:4.5.2.9
	Kernel-5_35-4_79_2_178:4.5.2.9
	Kernel-5_35-4_79_2_177:4.5.2.9
	Kernel-5_35-4_79_2_176:4.5.2.9
	Kernel-5_35-4_79_2_175:4.5.2.9
	Kernel-5_35-4_79_2_174:4.5.2.9
	Kernel-5_35-4_79_2_173:4.5.2.8
	Kernel-5_35-4_79_2_172:4.5.2.8
	Kernel-5_35-4_79_2_171:4.5.2.8
	Kernel-5_35-4_79_2_170:4.5.2.8
	Kernel-5_35-4_79_2_169:4.5.2.8
	Kernel-5_35-4_79_2_168:4.5.2.8
	Kernel-5_35-4_79_2_167:4.5.2.8
	Kernel-5_35-4_79_2_166:4.5.2.8
	Kernel-5_35-4_79_2_165:4.5.2.8
	RPi_merge:4.5.2.7.2.1
	Kernel-5_35-4_79_2_147_2_23:4.5.2.7.2.1
	Kernel-5_35-4_79_2_147_2_22:4.5.2.7
	Kernel-5_35-4_79_2_147_2_21:4.5.2.7
	Kernel-5_35-4_79_2_147_2_20:4.5.2.7
	Kernel-5_35-4_79_2_147_2_19:4.5.2.7
	Kernel-5_35-4_79_2_147_2_18:4.5.2.7
	Kernel-5_35-4_79_2_164:4.5.2.8
	Kernel-5_35-4_79_2_163:4.5.2.8
	Kernel-5_35-4_79_2_147_2_17:4.5.2.7
	Kernel-5_35-4_79_2_147_2_16:4.5.2.7
	Kernel-5_35-4_79_2_147_2_15:4.5.2.7
	Kernel-5_35-4_79_2_162:4.5.2.8
	Kernel-5_35-4_79_2_161:4.5.2.8
	Kernel-5_35-4_79_2_147_2_14:4.5.2.7
	Kernel-5_35-4_79_2_147_2_13:4.5.2.7
	Kernel-5_35-4_79_2_160:4.5.2.8
	Kernel-5_35-4_79_2_159:4.5.2.8
	Kernel-5_35-4_79_2_158:4.5.2.8
	Kernel-5_35-4_79_2_157:4.5.2.8
	Kernel-5_35-4_79_2_156:4.5.2.8
	Kernel-5_35-4_79_2_147_2_12:4.5.2.7
	Kernel-5_35-4_79_2_147_2_11:4.5.2.7
	Kernel-5_35-4_79_2_155:4.5.2.8
	Kernel-5_35-4_79_2_147_2_10:4.5.2.7
	Kernel-5_35-4_79_2_154:4.5.2.8
	Kernel-5_35-4_79_2_153:4.5.2.8
	Kernel-5_35-4_79_2_147_2_9:4.5.2.7
	Kernel-5_35-4_79_2_152:4.5.2.8
	Kernel-5_35-4_79_2_151:4.5.2.8
	Kernel-5_35-4_79_2_147_2_8:4.5.2.7
	Kernel-5_35-4_79_2_147_2_7:4.5.2.7
	Kernel-5_35-4_79_2_150:4.5.2.7
	Kernel-5_35-4_79_2_147_2_6:4.5.2.7
	Kernel-5_35-4_79_2_147_2_5:4.5.2.7
	Kernel-5_35-4_79_2_149:4.5.2.7
	Kernel-5_35-4_79_2_147_2_4:4.5.2.7
	Kernel-5_35-4_79_2_147_2_3:4.5.2.7
	Kernel-5_35-4_79_2_148:4.5.2.7
	Kernel-5_35-4_79_2_147_2_2:4.5.2.7
	Kernel-5_35-4_79_2_147_2_1:4.5.2.7
	RPi:4.5.2.7.0.2
	RPi_bp:4.5.2.7
	Kernel-5_35-4_79_2_98_2_52_2_1:4.5.2.5.2.1
	alees_Kernel_dev:4.5.2.5.2.1.0.2
	alees_Kernel_dev_bp:4.5.2.5.2.1
	Kernel-5_35-4_79_2_147:4.5.2.7
	Kernel-5_35-4_79_2_146:4.5.2.7
	Kernel-5_35-4_79_2_145:4.5.2.7
	Kernel-5_35-4_79_2_144:4.5.2.7
	Kernel-5_35-4_79_2_143:4.5.2.7
	Kernel-5_35-4_79_2_142:4.5.2.7
	Kernel-5_35-4_79_2_141:4.5.2.7
	Kernel-5_35-4_79_2_140:4.5.2.7
	Kernel-5_35-4_79_2_139:4.5.2.7
	Kernel-5_35-4_79_2_138:4.5.2.7
	Kernel-5_35-4_79_2_137:4.5.2.7
	Kernel-5_35-4_79_2_136:4.5.2.7
	Kernel-5_35-4_79_2_135:4.5.2.7
	Kernel-5_35-4_79_2_134:4.5.2.7
	Kernel-5_35-4_79_2_133:4.5.2.7
	Kernel-5_35-4_79_2_132:4.5.2.7
	Kernel-5_35-4_79_2_131:4.5.2.7
	Kernel-5_35-4_79_2_130:4.5.2.7
	Kernel-5_35-4_79_2_129:4.5.2.7
	Kernel-5_35-4_79_2_128:4.5.2.7
	Kernel-5_35-4_79_2_127:4.5.2.7
	Kernel-5_35-4_79_2_126:4.5.2.7
	Kernel-5_35-4_79_2_125:4.5.2.7
	Kernel-5_35-4_79_2_124:4.5.2.7
	Kernel-5_35-4_79_2_123:4.5.2.6
	Cortex_merge:4.5.2.5.2.1
	Kernel-5_35-4_79_2_122:4.5.2.5
	Kernel-5_35-4_79_2_98_2_54:4.5.2.5.2.1
	Kernel-5_35-4_79_2_98_2_53:4.5.2.5.2.1
	Kernel-5_35-4_79_2_98_2_52:4.5.2.5.2.1
	Kernel-5_35-4_79_2_98_2_51:4.5.2.5.2.1
	Kernel-5_35-4_79_2_98_2_50:4.5.2.5.2.1
	Kernel-5_35-4_79_2_98_2_49:4.5.2.5.2.1
	Kernel-5_35-4_79_2_98_2_48:4.5.2.5.2.1
	Kernel-5_35-4_79_2_121:4.5.2.5
	Kernel-5_35-4_79_2_98_2_47:4.5.2.5
	Kernel-5_35-4_79_2_120:4.5.2.5
	Kernel-5_35-4_79_2_98_2_46:4.5.2.5
	Kernel-5_35-4_79_2_119:4.5.2.5
	Kernel-5_35-4_79_2_98_2_45:4.5.2.5
	Kernel-5_35-4_79_2_98_2_44:4.5.2.5
	Kernel-5_35-4_79_2_118:4.5.2.5
	Kernel-5_35-4_79_2_98_2_43:4.5.2.5
	Kernel-5_35-4_79_2_117:4.5.2.5
	Kernel-5_35-4_79_2_116:4.5.2.5
	Kernel-5_35-4_79_2_98_2_42:4.5.2.5
	Kernel-5_35-4_79_2_115:4.5.2.5
	Kernel-5_35-4_79_2_98_2_41:4.5.2.5
	Kernel-5_35-4_79_2_98_2_40:4.5.2.5
	Kernel-5_35-4_79_2_114:4.5.2.5
	Kernel-5_35-4_79_2_98_2_39:4.5.2.5
	Kernel-5_35-4_79_2_98_2_38:4.5.2.5
	Kernel-5_35-4_79_2_113:4.5.2.5
	Kernel-5_35-4_79_2_112:4.5.2.5
	Kernel-5_35-4_79_2_98_2_37:4.5.2.5
	Kernel-5_35-4_79_2_98_2_36:4.5.2.5
	Kernel-5_35-4_79_2_98_2_35:4.5.2.5
	Kernel-5_35-4_79_2_98_2_34:4.5.2.5
	Kernel-5_35-4_79_2_98_2_33:4.5.2.5
	Kernel-5_35-4_79_2_98_2_32:4.5.2.5
	Kernel-5_35-4_79_2_98_2_31:4.5.2.5
	Kernel-5_35-4_79_2_98_2_30:4.5.2.5
	Kernel-5_35-4_79_2_98_2_29:4.5.2.5
	Kernel-5_35-4_79_2_98_2_28:4.5.2.5
	Kernel-5_35-4_79_2_98_2_27:4.5.2.5
	Kernel-5_35-4_79_2_98_2_26:4.5.2.5
	Kernel-5_35-4_79_2_111:4.5.2.5
	Kernel-5_35-4_79_2_98_2_25:4.5.2.5
	Kernel-5_35-4_79_2_98_2_24:4.5.2.5
	Kernel-5_35-4_79_2_98_2_23:4.5.2.5
	Kernel-5_35-4_79_2_110:4.5.2.5
	Kernel-5_35-4_79_2_98_2_22:4.5.2.5
	Kernel-5_35-4_79_2_109:4.5.2.5
	Kernel-5_35-4_79_2_98_2_21:4.5.2.5
	Kernel-5_35-4_79_2_98_2_20:4.5.2.5
	Kernel-5_35-4_79_2_108:4.5.2.5
	Kernel-5_35-4_79_2_107:4.5.2.5
	Kernel-5_35-4_79_2_98_2_19:4.5.2.5
	Kernel-5_35-4_79_2_98_2_18:4.5.2.5
	Kernel-5_35-4_79_2_98_2_17:4.5.2.5
	Kernel-5_35-4_79_2_98_2_16:4.5.2.5
	Kernel-5_35-4_79_2_98_2_15:4.5.2.5
	Kernel-5_35-4_79_2_106:4.5.2.5
	Kernel-5_35-4_79_2_105:4.5.2.5
	Kernel-5_35-4_79_2_104:4.5.2.5
	Kernel-5_35-4_79_2_98_2_14:4.5.2.5
	Kernel-5_35-4_79_2_98_2_13:4.5.2.5
	Kernel-5_35-4_79_2_98_2_12:4.5.2.5
	Kernel-5_35-4_79_2_98_2_11:4.5.2.5
	Kernel-5_35-4_79_2_98_2_10:4.5.2.5
	Kernel-5_35-4_79_2_98_2_9:4.5.2.5
	Kernel-5_35-4_79_2_103:4.5.2.5
	Kernel-5_35-4_79_2_102:4.5.2.5
	Kernel-5_35-4_79_2_98_2_8:4.5.2.5
	Kernel-5_35-4_79_2_98_2_7:4.5.2.5
	Kernel-5_35-4_79_2_98_2_6:4.5.2.5
	Kernel-5_35-4_79_2_98_2_5:4.5.2.5
	Kernel-5_35-4_79_2_98_2_4:4.5.2.5
	Kernel-5_35-4_79_2_101:4.5.2.5
	Kernel-5_35-4_79_2_100:4.5.2.5
	Kernel-5_35-4_79_2_99:4.5.2.5
	Kernel-5_35-4_79_2_98_2_3:4.5.2.5
	Kernel-5_35-4_79_2_98_2_2:4.5.2.5
	Kernel-5_35-4_79_2_98_2_1:4.5.2.5
	Cortex:4.5.2.5.0.2
	Cortex_bp:4.5.2.5
	Kernel-5_35-4_79_2_98:4.5.2.5
	Kernel-5_35-4_79_2_97:4.5.2.5
	Kernel-5_35-4_79_2_96:4.5.2.5
	Kernel-5_35-4_79_2_95:4.5.2.5
	Kernel-5_35-4_79_2_94:4.5.2.5
	Kernel-5_35-4_79_2_93:4.5.2.5
	Kernel-5_35-4_79_2_92:4.5.2.5
	Kernel-5_35-4_79_2_91:4.5.2.5
	Kernel-5_35-4_79_2_90:4.5.2.5
	Kernel-5_35-4_79_2_89:4.5.2.5
	Kernel-5_35-4_79_2_88:4.5.2.4
	Kernel-5_35-4_79_2_87:4.5.2.4
	Kernel-5_35-4_79_2_86:4.5.2.4
	Kernel-5_35-4_79_2_85:4.5.2.4
	Kernel-5_35-4_79_2_84:4.5.2.4
	Kernel-5_35-4_79_2_83:4.5.2.4
	Kernel-5_35-4_79_2_82:4.5.2.4
	Kernel-5_35-4_79_2_81:4.5.2.4
	Kernel-5_35-4_79_2_80:4.5.2.4
	Kernel-5_35-4_79_2_79:4.5.2.4
	Kernel-5_35-4_79_2_78:4.5.2.4
	Kernel-5_35-4_79_2_77:4.5.2.4
	RO_5_07:4.5.2.4
	Kernel-5_35-4_79_2_76:4.5.2.4
	Kernel-5_35-4_79_2_75:4.5.2.4
	Kernel-5_35-4_79_2_74:4.5.2.4
	Kernel-5_35-4_79_2_73:4.5.2.4
	Kernel-5_35-4_79_2_72:4.5.2.4
	Kernel-5_35-4_79_2_71:4.5.2.4
	Kernel-5_35-4_79_2_70:4.5.2.4
	Kernel-5_35-4_79_2_69:4.5.2.4
	Kernel-5_35-4_79_2_68:4.5.2.4
	Kernel-5_35-4_79_2_67:4.5.2.4
	Kernel-5_35-4_79_2_66:4.5.2.4
	Kernel-5_35-4_79_2_65:4.5.2.4
	Kernel-5_35-4_79_2_64:4.5.2.4
	Kernel-5_35-4_79_2_63:4.5.2.4
	Kernel-5_35-4_79_2_62:4.5.2.4
	Kernel-5_35-4_79_2_61:4.5.2.4
	Kernel-5_35-4_79_2_59:4.5.2.4
	Kernel-5_35-4_79_2_58:4.5.2.4
	Kernel-5_35-4_79_2_57:4.5.2.4
	Kernel-5_35-4_79_2_56:4.5.2.4
	Kernel-5_35-4_79_2_55:4.5.2.4
	Kernel-5_35-4_79_2_54:4.5.2.4
	Kernel-5_35-4_79_2_53:4.5.2.4
	Kernel-5_35-4_79_2_52:4.5.2.4
	Kernel-5_35-4_79_2_51:4.5.2.4
	Kernel-5_35-4_79_2_50:4.5.2.4
	Kernel-5_35-4_79_2_49:4.5.2.4
	Kernel-5_35-4_79_2_48:4.5.2.4
	Kernel-5_47:4.5
	Kernel-5_46-4_90_2_1:4.5
	nbingham_Kernel_FastNC_dev_bp:4.5
	nbingham_Kernel_FastNC_dev:4.5.0.4
	Kernel-5_46:4.5
	Kernel-5_45:4.5
	Kernel-5_35-4_79_2_47:4.5.2.3
	Kernel-5_35-4_79_2_46:4.5.2.3
	Kernel-5_35-4_79_2_45:4.5.2.3
	Kernel-5_35-4_79_2_44:4.5.2.3
	Kernel-5_35-4_79_2_25_2_2:4.5.2.1
	Kernel-5_35-4_79_2_43:4.5.2.3
	Kernel-5_35-4_79_2_42:4.5.2.3
	Kernel-5_35-4_79_2_41:4.5.2.3
	Kernel-5_35-4_79_2_40:4.5.2.2
	Kernel-5_35-4_79_2_39:4.5.2.2
	Kernel-5_35-4_79_2_38:4.5.2.2
	Kernel-5_35-4_79_2_37:4.5.2.2
	Kernel-5_35-4_79_2_36:4.5.2.1
	Kernel-5_35-4_79_2_35:4.5.2.1
	Kernel-5_35-4_79_2_34:4.5.2.1
	Kernel-5_35-4_79_2_33:4.5.2.1
	Kernel-5_35-4_79_2_32:4.5.2.1
	Kernel-5_44:4.5
	Kernel-5_35-4_79_2_25_2_1:4.5.2.1
	Kernel-5_43:4.5
	Kernel-5_35-4_79_2_31:4.5.2.1
	Kernel-5_35-4_79_2_30:4.5.2.1
	Kernel-5_35-4_79_2_29:4.5.2.1
	Kernel-5_35-4_79_2_28:4.5.2.1
	Kernel-5_35-4_79_2_27:4.5.2.1
	Kernel-5_35-4_79_2_26:4.5.2.1
	Kernel-5_42:4.5
	Kernel-5_41:4.5
	Kernel-5_40:4.5
	Kernel-5_35-4_79_2_25:4.5.2.1
	Kernel-5_35-4_79_2_24:4.5.2.1
	Kernel-5_35-4_79_2_23:4.5.2.1
	Kernel-5_35-4_79_2_22:4.5.2.1
	Kernel-5_35-4_79_2_21:4.5.2.1
	Kernel-5_35-4_79_2_20:4.5.2.1
	Kernel-5_35-4_79_2_19:4.5.2.1
	Kernel-5_35-4_79_2_18:4.5.2.1
	Kernel-5_35-4_79_2_17:4.5.2.1
	Kernel-5_35-4_79_2_16:4.5.2.1
	Kernel-5_35-4_79_2_15:4.5.2.1
	Kernel-5_35-4_79_2_14:4.5.2.1
	Kernel-5_39:4.5
	Kernel-5_13-4_52_2_1:4.3
	Bethany:4.3.0.2
	Kernel-5_38:4.5
	Kernel-5_35-4_79_2_13:4.5.2.1
	Kernel-5_35-4_79_2_12:4.5.2.1
	Kernel-5_35-4_79_2_11:4.5.2.1
	Kernel-5_37:4.5
	Kernel-5_35-4_79_2_10:4.5.2.1
	Kernel-5_35-4_79_2_9:4.5.2.1
	Kernel-5_36:4.5
	Kernel-5_35-4_79_2_8:4.5.2.1
	Kernel-5_35-4_79_2_7:4.5.2.1
	Kernel-5_35-4_79_2_6:4.5.2.1
	Kernel-5_35-4_79_2_5:4.5.2.1
	Kernel-5_35-4_79_2_4:4.5.2.1
	Kernel-5_35-4_79_2_3:4.5.2.1
	Kernel-5_35-4_79_2_2:4.5.2.1
	dellis_autobuild_BaseSW:4.5
	Kernel-5_35-4_79_2_1:4.5.2.1
	HAL:4.5.0.2
	Kernel-5_35:4.5
	Kernel-5_34:4.5
	Kernel-5_33:4.5
	Kernel-5_32:4.5
	Kernel-5_31:4.5
	Kernel-5_30:4.5
	Kernel-5_29:4.5
	Kernel-5_28:4.5
	Kernel-5_27:4.5
	Kernel-5_26:4.5
	Kernel-5_25:4.5
	Kernel-5_24:4.5
	Kernel-5_23:4.4
	Kernel-5_22:4.3
	sbrodie_sedwards_16Mar2000:4.3
	Kernel-5_21:4.3
	Kernel-5_20:4.3
	Kernel-5_19:4.3
	Kernel-5_18:4.3
	Kernel-5_17:4.3
	Kernel-5_16:4.3
	Kernel-5_15:4.3
	Kernel-5_14:4.3
	Kernel-5_13:4.3
	Kernel-5_12:4.3
	Kernel-5_11:4.3
	Kernel-5_10:4.3
	Kernel-5_09:4.3
	Kernel-5_08:4.3
	Kernel-5_07:4.3
	Kernel-5_06:4.3
	Kernel-5_05:4.3
	Kernel-5_04:4.3
	Kernel-5_03:4.3
	Kernel-5_02:4.3
	Kernel-5_01:4.3
	Kernel-5_00:4.3
	Kernel-4_99:4.3
	Kernel-4_98:4.3
	Kernel-4_97:4.3
	Kernel-4_96:4.3
	Kernel-4_95:4.3
	Kernel-4_94:4.3
	Kernel-4_93:4.3
	Kernel-4_92:4.3
	Kernel-4_91:4.3
	Kernel-4_90:4.3
	dcotton_autobuild_BaseSW:4.5
	Kernel-4_89:4.3
	Kernel-4_88:4.3
	Kernel-4_87:4.3
	Kernel-4_86:4.3
	Kernel-4_85:4.3
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.4.2.1
	Kernel-4_84:4.3
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.4.2.1
	Ursula_RiscPC_bp:4.2.2.4
	Kernel-4_83:4.2
	Kernel-4_82:4.2
	Kernel-4_81:4.2
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.4.2.1
	Ursula_RiscPC:4.2.2.4.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.2
	Ursula_merge:4.2
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.2.2.5
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.4
	UrsulaBuild_FinalSoftload:4.2.2.4
	rthornb_UrsulaBuild-12Aug1998:4.2.2.4
	aglover_UrsulaBuild-05Aug1998:4.2.2.4
	rthornb_UrsulaBuild-29Jul1998:4.2.2.4
	rthornb_UrsulaBuild-22Jul1998:4.2.2.4
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.4
	rthornb_UrsulaBuild-07Jul1998:4.2.2.4
	rthornb_UrsulaBuild-17Jun1998:4.2.2.4
	rthornb_UrsulaBuild-03Jun1998:4.2.2.4
	rthornb_UrsulaBuild-27May1998:4.2.2.4
	mstphens_Kernel-3_80:4.2.2.4
	rthornb_UrsulaBuild-21May1998:4.2.2.4
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.4
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2016.07.24.10.50.44;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	x4yCuRzf90zVXyfz;

4.8
date	2016.07.15.08.03.56;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	DxftEb9tACoGkoez;

4.7
date	2016.06.30.20.59.46;	author jlee;	state Exp;
branches;
next	4.6;
commitid	skOEjp3ipLHx6xcz;

4.6
date	2016.06.30.20.08.09;	author jlee;	state Exp;
branches;
next	4.5;
commitid	IWoXxARWeuLDOwcz;

4.5
date	2000.04.12.13.58.38;	author sbrodie;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	2000.04.04.14.27.33;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.08.19.10.52.36;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.07.19;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.25;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.5.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.5.2.2;

4.5.2.2
date	2001.06.15.09.39.58;	author mstephen;	state Exp;
branches;
next	4.5.2.3;

4.5.2.3
date	2001.06.26.09.37.11;	author mstephen;	state Exp;
branches;
next	4.5.2.4;

4.5.2.4
date	2002.10.07.17.29.43;	author kbracey;	state Exp;
branches;
next	4.5.2.5;

4.5.2.5
date	2005.09.15.15.18.28;	author bavison;	state Exp;
branches
	4.5.2.5.2.1;
next	4.5.2.6;

4.5.2.6
date	2011.11.26.21.11.17;	author jlee;	state Exp;
branches;
next	4.5.2.7;
commitid	cI3W0zbtALQG6TIv;

4.5.2.7
date	2011.11.27.11.48.11;	author rsprowson;	state Exp;
branches
	4.5.2.7.2.1;
next	4.5.2.8;
commitid	OFgqaKhOb6swXXIv;

4.5.2.8
date	2012.05.26.09.00.28;	author rsprowson;	state Exp;
branches;
next	4.5.2.9;
commitid	EMsCe1GQBPXgdd6w;

4.5.2.9
date	2012.10.28.16.51.46;	author rsprowson;	state Exp;
branches;
next	4.5.2.10;
commitid	ruXZqdTJKJ85Qaqw;

4.5.2.10
date	2013.01.27.17.50.27;	author rsprowson;	state Exp;
branches;
next	4.5.2.11;
commitid	tDlfhdSfOxFReSBw;

4.5.2.11
date	2014.06.29.06.50.23;	author rsprowson;	state Exp;
branches;
next	;
commitid	N9nM4oqvSy29WnGx;

4.5.2.5.2.1
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

4.5.2.7.2.1
date	2012.09.18.15.50.03;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.2.2.1
date	97.09.09.13.33.36;	author mstphens;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.12.08.14.34.42;	author mstphens;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	98.03.26.11.26.05;	author mstphens;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	98.04.14.11.23.58;	author mstphens;	state Exp;
branches
	4.2.2.4.2.1;
next	4.2.2.5;

4.2.2.5
date	98.09.24.13.17.24;	author mstphens;	state Exp;
branches;
next	;

4.2.2.4.2.1
date	98.11.23.14.59.23;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.25;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.01.10;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.46;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.57;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Resolve 2x header clashes
hdr/AHCIDevice:
  Remove this, since it clashes with the (differing API version number) copy exported by SATADriver. Post merging the Kernel back to the trunk the newer file datestamp has meant the wrong one gets exported during any ROM build which includes both components. Since the Kernel doesn't need AHCIDevice itself, it is left to the respective client (SATADriver or AHCIDriver in this case) to export them.
hdr/ModHand:
  Resolve the longstanding clash of Module_Title with the same named symbol that CMHG uses. There are very few assembler needing to look at the module header (Kernel, FileCore, Debugger, Podule) directly, but every C module which uses CMHG and wants one of the ModHandReason values ends up with a duplicate define.
  Obsolete Arthur era Module_LoadAddr value.
ArthurSWIs.s/MoreComms.s/NewReset.s/SWINaming.s/SysComms.s/Utility.s:
  Module_Title->Module_TitleStr.
ModHand.s:
  Module_Title->Module_TitleStr.
  Recode Module_LoadAddr using the file type from Hdr:FileTypes.
GetAlls.s:
  Drop unused NVRAM and PortMan headers. Add Hdr:FileTypes.

Version 5.54. Tagged as 'Kernel-5_54'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => SysComms , the system commands file: Load save dump etc.

TAB      *      9
FSUTtemp RN     r10

         GBLS   UtilRegs        ; Save the same set so we can common up exits
UtilRegs SETS   "r7-r10"        ; Sam will preserve r0-r6 on module star entry

AnyNoParms  *   &FF0000         ; Between 0 and 255 parameters: all flags clear


SysCommsModule ROUT

Module_BaseAddr SETA SysCommsModule

        &       0               ; No Start entry
        &       0               ; Not initialised
        &       0
        &       0
        &       0
        &       SysTitle-SysCommsModule
        &       SCHCTab-SysCommsModule
        &       0
        &       0
        &       0
        &       0
 [ International_Help <> 0
        &       MessageFileName-SysCommsModule
 |
        &       0
 ]

SysTitle
        = "$SystemName", 9
   [ :LEN: "$SystemName" < 8
        =  9
   ]
        =  "$VersionNo", 0

  [ Oscli_HashedCommands
;
;***WARNING*** if commands are added or changed, SysCoHashedCmdTab MUST be updated correspondingly
;
  ]
SCHCTab ; Alphabetically ordered so it's easier to find stuff

        Command Append,  1,  1, International_Help
        Command Build,   1,  1, International_Help
        Command Close,   0,  0, International_Help
        Command Create,  4,  1, International_Help
        Command Delete,  1,  1, International_Help
        Command Dump,    3,  1, International_Help
        Command Exec,    1,  0, International_Help
        Command FX,      5,  1, International_Help    ; 1-3 parms, but up to 2 commas may be there
        Command GO,    255,  0, International_Help
HelpText
        Command Help,  255,  0, International_Help
        Command Key,   255,  1, International_Help
        Command Load,    2,  1, International_Help ; Fudge order for compatibility (*L.)
        Command List,    3,  1, International_Help
        Command Opt,     2,  0, International_Help
        Command Print,   1,  1, International_Help
        Command Quit,    0,  0, International_Help
        Command Remove,  1,  1, International_Help
        Command Save,    6,  2, International_Help ; *SAVE Fn St + Le Ex Lo (compatibility)
        Command Shadow,  1,  0, International_Help
        Command Spool,   1,  0, International_Help
        Command SpoolOn, 1,  0, International_Help
        Command TV,      3,  0, International_Help
        Command Type,    3,  1, International_Help ; -file fred -tabexpand
        =       0

  [ Oscli_HashedCommands
;
; - Hashing table is 32 wide
; - Hashing function is:
;
;      hash = (sum of all chars of command, each upper-cased) & 0x1f
;
; - Order of commands in each hashed list is alphabetical

; Table MUST be reorganised if hashing function changed, or command set altered
;
           ALIGN
SysCoHashedCmdTab
;
;     ! 0,"SysCoHashedCmdTab at ":CC::STR:(SysCoHashedCmdTab)
;
;First, 1 word per table entry, giving offset to hashed list on each hash value
;
           DCD       SHC_hash00 - SysCommsModule
           DCD       0                            ;null list on this hash value
           DCD       SHC_hash02 - SysCommsModule
           DCD       SHC_hash03 - SysCommsModule
           DCD       0
           DCD       SHC_hash05 - SysCommsModule
           DCD       SHC_hash06 - SysCommsModule
           DCD       0
           DCD       0
           DCD       SHC_hash09 - SysCommsModule
           DCD       SHC_hash0A - SysCommsModule
           DCD       0
           DCD       0
           DCD       SHC_hash0D - SysCommsModule
           DCD       SHC_hash0E - SysCommsModule
           DCD       SHC_hash0F - SysCommsModule
           DCD       SHC_hash10 - SysCommsModule
           DCD       0
           DCD       0
           DCD       SHC_hash13 - SysCommsModule
           DCD       SHC_hash14 - SysCommsModule
           DCD       0
           DCD       SHC_hash16 - SysCommsModule
           DCD       0
           DCD       SHC_hash18 - SysCommsModule
           DCD       0
           DCD       0
           DCD       0
           DCD       SHC_hash1C - SysCommsModule
           DCD       0
           DCD       SHC_hash1E - SysCommsModule
           DCD       0
;
; Now the hashed lists
;
SHC_hash00
        Command Load,    2,  1, International_Help ; Fudge order for compatibility (*L.)
        =   0
        ALIGN
SHC_hash02
        Command Type,    3,  1, International_Help ; -file fred -tabexpand
        =   0
        ALIGN
SHC_hash03
        Command Quit,    0,  0, International_Help
        =   0
        ALIGN
SHC_hash05
        Command Exec,    1,  0, International_Help
        =   0
        ALIGN
SHC_hash06
        Command Shadow,  1,  0, International_Help
        =   0
        ALIGN
SHC_hash09
        Command Help,  255,  0, International_Help
        Command Key,   255,  1, International_Help
        =   0
        ALIGN
SHC_hash0A
        Command SpoolOn, 1,  0, International_Help
        Command TV,      3,  0, International_Help
        =   0
        ALIGN
SHC_hash0D
        Command Print,   1,  1, International_Help
        Command Spool,   1,  0, International_Help
        =   0
        ALIGN
SHC_hash0E
        Command Remove,  1,  1, International_Help
        =   0
        ALIGN
SHC_hash0F
        Command Save,    6,  2, International_Help ; *SAVE Fn St + Le Ex Lo (compatibility)
        =   0
        ALIGN
SHC_hash10
        Command Build,   1,  1, International_Help
        =   0
        ALIGN
SHC_hash13
        Command Delete,  1,  1, International_Help
        Command Opt,     2,  0, International_Help
        =   0
        ALIGN
SHC_hash14
        Command Create,  4,  1, International_Help
        =   0
        ALIGN
SHC_hash16
        Command Close,   0,  0, International_Help
        Command Dump,    3,  1, International_Help
        Command GO,    255,  0, International_Help
        =   0
        ALIGN
SHC_hash18
        Command Append,  1,  1, International_Help
        =   0
        ALIGN
SHC_hash1C
        Command List,    3,  1, International_Help
        =   0
        ALIGN
SHC_hash1E
        Command FX,      5,  1, International_Help    ; 1-3 parms, but up to 2 commas may be there
        =   0
        ALIGN

;now a small table to fudge around need for old syntax for *fx etc (ie.
;allow zero spaces between command and first, numeric, parameter)
;
SHC_fudgeulike
        Command FX,      5,  1, International_Help    ; 1-3 parms, but up to 2 commas may be there
        Command Key,   255,  1, International_Help
        Command Opt,     2,  0, International_Help
        Command TV,      3,  0, International_Help
        =   0
        ALIGN

  ] ;Oscli_HashedCommands

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Most help and syntax messages go together to save ALIGNing wastage

        GET       s.MosDict
        GET       s.TokHelpSrc

GO_Syntax   * Module_BaseAddr
Help_Syntax * Module_BaseAddr

        ALIGN                   ; Just the one, please !

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HelpBufferSize * 512

Help_Code ROUT       ; got R0 ptr to commtail, R1 no parameters
        Push    "r7, lr"

; first pass round a service call to let wally user code do things.
        MOV     r2, r1
        MOV     r1, #Service_Help
        BL      Issue_Service
        CMP     r1, #0
        Pull    "r7, pc", EQ

        CMP     r2, #0
        MOVNE   r6, r0
        addr    r6, HelpText, EQ

        MOV     r0, #117                ; Read current VDU status
        SWI     XOS_Byte                ; Won't fail
        SWI     XOS_WriteI+14           ; paged mode on.
        Pull    "r7, pc", VS            ; Wrch can fail

        Push    "r1"                    ; Save page mode state
        MOV     r0, r6
        MOV     r7, #0                  ; anyhelpdoneyet flag

DoHelpOnNextKeyWord
; now look at syscomms module.
        addr    r1, SysCommsModule
        BL      ShowHelpInModule
        BVS     %FT67

; now try looking round the modules.
        LDR      R2, =ZeroPage+Module_List
11      LDR      R2, [R2]
        CMP      R2, #0
        BEQ      tryagainstmodulename
        LDR      R1, [R2, #Module_code_pointer]
        LDR      R12, [R2, #Module_incarnation_list]
        ADD      R12, R12, #Incarnation_Workspace
        BL       ShowHelpInModule
        BVS      %FT67
        B        %BT11

tryagainstmodulename
        Push     "r0"
        MOV       r1, #0
        MOV       r2, #0
tamn_loop
        MOV       r0, #ModHandReason_GetNames
        SWI       XOS_Module
        Pull      r0, VS
        BVS       %FT02
        LDR       r0, [stack]      ; kword ptr
        Push     "r1, r2"
        LDR       r4, [r3, #Module_TitleStr]
        CMP       r4, #0
        BEQ       tamn_notit
        ADD       r4, r4, r3
        MOV       R5, #0           ; offset
tamn_chk
        LDRB      R1, [R0, R5]
        LDRB      R2, [R4, R5]
        CMP       R1, #32
        CMPLE     R2, #32
        BLE       tamn_dojacko    ; matched at terminator
        UpperCase R1, R6
        UpperCase R2, R6
        CMP       R1, R2
        ADDEQ     R5, R5, #1
        BEQ       tamn_chk
        RSBS      R2, R2, #33     ; only if not terminated
        CMPLE     R1, #"."        ; success if abbreviation
        BNE       tamn_notit
tamn_dojacko
        BL        ModuleJackanory
        STRVS     r0, [stack, #2*4]
tamn_notit
        Pull     "r1, r2"
        Pull      r0, VS
        BVS       %FT67
        CMP       r2, #0
        ADDNE     r1, r1, #1
        MOVNE     r2, #0
        B         tamn_loop

02      LDRB      R1, [R0], #1
        CMP       R1, #"."
        CMPNE     R1, #" "
        BGT       %BT02
        CMP       R1, #" "
        BLT       %FT67
66      LDRB      R1, [R0], #1
        CMP       R1, #" "
        BEQ       %BT66
        SUBGT     R0, R0, #1
        BGT       DoHelpOnNextKeyWord
67      BLVC      testnohelpdone
        Pull     "R1"
        MRS       r6, CPSR
        TST       R1, #5
        SWIEQ     XOS_WriteI+15  ; paged mode off
        MSR       CPSR_f, r6     ; restore V state
        Pull     "r7, PC"

testnohelpdone
        CMP       r7, #0
        MOVNE     pc, lr
        MOV       r7, lr
      [ International
        BL        WriteS_Translated
        =         "NoHelp:No help found.",10,13,0
        ALIGN
      |
        SWI       XOS_WriteS
        =         "No help found.",10,13,0
        ALIGN
      ]
        MOV       pc, r7

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ModuleJackanory   ROUT      ; give summary of info in module @@ r3
        Push     "r0, lr"
        CheckSpaceOnStack HelpBufferSize+256, modjack_noroom, r6
        SUB       stack, stack, #HelpBufferSize
        MOV       r2, r3
        LDR       r3, [r2, #Module_TitleStr]
        CMP       r3, #0
        ADDNE     r3, r3, r2
        ADREQL    r3, NoRIT
        BL        PrintMatch
        BVS       %FT99
        LDR       r3, [r2, #Module_HelpStr]
        CMP       r3, #0
        BEQ       nohstring
        STMDB     sp!, {r2, r3}
        LDR       r2, =ZeroPage                 ; Try our message file before Global.
        LDR       r0, [r2, #KernelMessagesBlock]
        TEQ       r0, #0
        ADDNE     r0, r2, #KernelMessagesBlock+4
        ADRL      r1, modjack_hstr
      [ ZeroPage <> 0
        MOV       r2, #0
      ]
        SWI       XMessageTrans_Lookup
        SWIVC     XMessageTrans_Dictionary
        MOVVC     r1, r0
        MOVVC     r0, r2
        SWIVC     XOS_PrettyPrint
        SWIVC     XOS_WriteI + 32
        LDMIA     sp!, {r2, r3}
        ADDVC     r0, r2, r3
        SWIVC     XOS_PrettyPrint
        BVS       %FT99
nohstring
        MOV       r3, stack                ; buffer address
        MOV       r1, #0                   ; flags for commands
        ADRL      r0, modjack_comms
        BL        OneModuleK_Lookup
        MOVVC     r1, #FS_Command_Flag
        ADRVCL    r0, modjack_filecomms
        BLVC      OneModuleK_Lookup
        MOVVC     r1, #Status_Keyword_Flag
        ADRVCL    r0, modjack_confs
        BLVC      OneModuleK_Lookup
        MOVVC     r1, #-1
        ADRVCL    r0, modjack_aob
        BLVC      OneModuleK_Lookup
99      ADD       stack, stack, #HelpBufferSize
        SWIVC     XOS_NewLine
98      STRVS     r0, [stack]
        Pull     "r0, PC"
modjack_noroom
        ADRL      r0, ErrorBlock_StackFull
      [ International
        BL        TranslateError
      |
        SETV
      ]
        B         %BT98

OneModuleK_Lookup
        STMDB   sp!, {r1-r3, lr}
        MOV     r1, r0
        LDR     r2, =ZeroPage                   ; Try our message file before Global.
        LDR     r0, [r2, #KernelMessagesBlock]
        TEQ     r0, #0
        ADDNE   r0, r2, #KernelMessagesBlock+4
      [ ZeroPage <> 0
        MOV     r2, #0
      ]
        SWI     XMessageTrans_Lookup
        MOVVC   r0, r2
        LDMIA   sp!, {r1-r3, lr}
        MOVVS   pc, lr
        B       OneModuleK

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Print match header, keyword @@ r3

PrintMatch      ROUT
      [ International
        Push   "r0-r4, lr"
        SWI     XOS_ReadEscapeState
        BLCS    AckEscape
        BVS     %FT99
        SWI     XOS_WriteI+CR
        MOVVC   r4,r3
        BL      WriteS_Translated_UseR4
        =       "HelpFound:==> Help on keyword %0",0
        ALIGN
        SWIVC   XOS_NewLine
99      STRVS   R0, [stack]
        MOV     R7, #1
        Pull   "r0-r4, PC"
      |
        Push   "r0-r2, lr"
        SWI     XOS_ReadEscapeState
        BLCS    AckEscape
        ADRVC   r0, HelpMatchString
        MOV     r2, r3
        SWIVC   XOS_PrettyPrint    ; print matched keyword
        SWIVC   XOS_NewLine
        STRVS   R0, [stack]
        MOV     R7, #1
        Pull   "r0-r2, PC"

HelpMatchString =  CR, "==> Help on keyword ",TokenEscapeChar,Token0, 0
        ALIGN
      ]

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ShowHelpInModule  ROUT    ; take module ptr in R1, give relevant help.

        Push   "R2-R6, lr"

        LDR     R2, [R1, #Module_HC_Table]
        CMP     R2, #0
        Pull   "R2-R6, PC", EQ

        ADD     R2, R1, R2        ; point at table
fujjnulltables
        LDRB    R5, [R2]
        CMP     R5, #0
        BNE     %FT21
        Pull   "R2-R6, PC"       ; finished

21      MOV     R3, #0           ; offset
22      LDRB    R4, [R0, R3]
        LDRB    R5, [R2, R3]
        CMP     R4, #32
        CMPLE   R5, #32
        BLE     %FT25           ; matched at terminator
        UpperCase R4, R6
        UpperCase R5, R6
        CMP     R4, R5
        ADDEQ   R3, R3, #1
        BEQ     %BT22
        RSBS    R5, R5, #33       ; only if not terminated
        CMPLE   R4, #"."          ; success if abbreviation
        BEQ     %FT25
        ADD     R2, R2, R3
23      LDRB    R5, [R2], #1
        CMP     R5, #32
        BGT     %BT23             ; skip to terminator
        ADD     R2, R2, #3
        BIC     R2, R2, #3        ; ALIGN
24      ADD     R2, R2, #16
        B       fujjnulltables

25      ADD     R2, R2, R3
        SUB     R3, R2, R3        ; hang on to keyword ptr
28      LDRB    R5, [R2], #1
        CMP     R5, #0
        BNE     %BT28           ; demand null terminator
        ADD     R2, R2, #3
        BIC     R2, R2, #3        ; ALIGN

        LDR     R5, [R2, #12]    ; get help offset
        CMP     R5, #0
        BEQ     %BT24          ; no help.

        BL      PrintMatch           ; r3 -> keyword
        Pull   "R2-R6, PC", VS

        LDR     R6, [R2, #4]     ; get info word
        TST     R6, #Help_Is_Code_Flag
        BNE     CallHelpKeywordCode

        Push   "R0-r3"
        TST     R6, #International_Help
        BEQ     %FT35
        SUB     sp, sp, #16
        LDR     r2, [r1, #-4]
        LDR     r0, [r1, #Module_MsgFile]
        TST     r0, #12,2
        CMPEQ   r0, #1
        CMPCS   r2, r0
        MOVLS   r0, #0
        BLS     %FT29
        ADD     r1, r1, r0
        MOV     r2, #0
        MOV     r0, sp
        SWI     XMessageTrans_OpenFile
        MOVVS   r0, #0
29      MOV     r6, r0
        LDR     r1, [sp, #16 + 1 * 4]
        ADD     r1, r5, r1
        MOV     r2, #0
        SWI     XMessageTrans_Lookup
        ADDVS   r2, r0, #4
        SWI     XMessageTrans_Dictionary
        MOVVS   r0, #0
        MOV     r1, r0
        MOV     r0, r2
        LDR     r2, [sp, #16 + 3 * 4]
        SWI     XOS_PrettyPrint         ; Error check not done yet
        SWI     XOS_NewLine
        MOV     r0, r6
        LDR     r2, [sp, #16 + 2 * 4]
        LDR     R5, [r2, #8]
        CMP     R5, #0
        BEQ     %FT30                   ; Should print default message?
        LDR     r1, [sp, #16 + 1 * 4]
        ADD     r1, r5, r1
        MOV     r2, #0
        SWI     XMessageTrans_Lookup
        ADDVS   r2, r0, #4
        SWI     XMessageTrans_Dictionary
        MOVVS   r0, #0
        MOV     r1, r0
        MOV     r0, r2
        LDR     r2, [sp, #16 + 3 * 4]
        SWI     XOS_PrettyPrint         ; No Error check!!!
        SWI     XOS_NewLine
30      MOVS    r0, r6
        SWINE   XMessageTrans_CloseFile
        ADD     sp, sp, #16
        Pull    "R0-R3"
        B       %BT24

35      ADD     R0, R5, R1
        MOV     r1, #0
        MOV     r2, r3
        SWI     XOS_PrettyPrint
        SWIVC   XOS_NewLine
        STRVS   R0, [stack]
        Pull   "R0-r3"
        Pull   "R2-R6, PC", VS
        B       %BT24

helpnostack
        ADRL    R0, ErrorBlock_StackFull
      [ International
        BL      TranslateError
      |
        SETV
      ]
        Pull   "R2-R6, pc"

CallHelpKeywordCode
        CheckSpaceOnStack HelpBufferSize+256, helpnostack, R6
        SUB     stack, stack, #HelpBufferSize
        Push   "R0-R2, R12"     ; code allowed to corrupt R1-R6, R12
        MOV     R2, R1
        ADD     R0, stack, #4*4
        MOV     R1, #HelpBufferSize
        MOV     lr, PC          ; R12 set by our caller
        ADD     PC, R5, R2
        BVS     hkc_threwawobbly
        CMP     R0, #0
        MOVNE   r1, #0
        SWINE   XOS_PrettyPrint
        SWIVC   XOS_NewLine
hkc_threwawobbly
        STRVS   R0, [stack]
        Pull   "R0-R2, R12"
        ADD     stack, stack, #HelpBufferSize
        BVC     %BT24
        Pull   "R2-R6, PC"

;**************************************************************************

GO_Code ROUT
        Push  "R7, lr"
        MOV    R4, R0
        BL     SPACES
        CMP    R5, #13
        TEQNE  R5, #";"
        MOVLS  R7, #AppSpaceStart
        BCC    GOEX
        BEQ    GOEX0
        BL     ReadHex
        MOVVS  R7, #AppSpaceStart
        BL     SPACES
GOEX0   TEQ    R5, #";"
        BLEQ   SPACES
GOEX    SUB    R1, R4, #1
        MOV    R0, #FSControl_StartApplication
        MOV    R2, R7
        ADR    R3, GOSMUDGE
        SWI    XOS_FSControl
        Pull  "R7, PC", VS

        LDR    sp_svc, =SVCSTK ; remove supervisor stuff
        WritePSRc 0, R14       ; in to user mode
        MOV    PC, R7

GOSMUDGE = "GO ", 0
         ALIGN

ReadHex Push    "R0-R2, lr"
        MOV      R0, #16
        SUB      R1, R4, #1
        SWI      XOS_ReadUnsigned
        MOV      R4, R1
        MOV      R7, R2
        Pull    "R0-R2, PC"

SPACES  LDRB R5, [R4], #1
        TEQ R5, #" "
        BEQ SPACES
        MOV PC, R14

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Close_Code Entry

        MOV    R0, #0
        MOV    R1, #0
        SWI    XOS_Find
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

FX_Code Entry

        MOV     R1, #0
        MOV     R2, #0
        Push    "R1-R2"         ; Put optional parms (default 0, 0) on stack
        MOV     R1, R0
        MOV     R0, #10
        SWI     XOS_ReadUnsigned
        Push    "R2"            ; Pulled as R0 when OSByte called
        BVS     %FT90
        BL      %FT10

TV_EntryPoint

        MOV     R0, #10
        SWI     XOS_ReadUnsigned
        BVS     %FT90
        STR     R2, [stack, #4]
        BL      %FT10
        MOV     R0, #10
        SWI     XOS_ReadUnsigned
        BVS     %FT90
        STR     R2, [stack, #8]

        BL      %FT10                ; check for EOL: goes to 05 if end
        ADR     R0, ErrorBlock_TooManyParms
      [ International
        BL      TranslateError
      |
        SETV
      ]
90      ADD     sp, sp, #12    ; Error before we'd pulled r0-r2 for osbyte
        EXIT

        MakeErrorBlock  TooManyParms

05
        Pull    "R0-R2"
        SWI     XOS_Byte
        EXIT

; Skip leading spaces and optional comma

10      LDRB    R2, [R1], #1
        CMP     R2, #" "
        BEQ     %BT10
        CMP     R2, #","
        MOVEQ   PC, lr         ; Let ReadUnsigned strip leading spaces.
        CMP     R2, #CR
        CMPNE   R2, #LF
        CMPNE   R2, #0
        BEQ     %BT05          ; Terminated command, so execute the osbyte
        SUB     R1, R1, #1     ; Back to first char
        MOV     PC, lr


TV_Code ALTENTRY ; must be same as FX_Code !

        MOV     R1, #144        ; OSBYTE number
        MOV     R2, #0
        MOV     R14, #0
        Push   "R1, R2, lr"
        MOV     R1, R0
        B       TV_EntryPoint


Shadow_Code Entry

        CMP     R1, #0
        MOV     R1, R0
        MOV     R0, #10 + (1:SHL:30)
        SWINE   XOS_ReadUnsigned
        MOVEQ   R2, #0
        EXIT    VS
        BL      CheckEOL
        BNE     ShadowNaff
        MOV     R0, #114
        MOV     R1, R2
        SWI     XOS_Byte
        EXIT

ShadowNaff
        ADRL    R0, ErrorBlock_BadNumb
      [ International
        BL      TranslateError
      |
        SETV
      ]
        EXIT

CheckEOL
        LDRB    R0, [R1], #1
        CMP     R0, #" "
        CMPNE   R0, #13
        CMPNE   R0, #10
        CMPNE   R0, #0
        MOV     PC, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Key_Code Entry

        SUB     sp, sp, #32
        MOV     R1, R0
        MOV     r6, sp
        LDR     R2, %FT02               ; Load 'Key$'
        STR     R2, [R6], #4
        MOV     R0, #10 + (1 :SHL: 29)  ; default base
        MOV     R2, #15                 ; maximum key
        SWI     XOS_ReadUnsigned
        BVS     %FT90
        CMP     R2, #10
        MOVGE   R4, #"1"
        STRGEB  R4, [R6], #1
        SUBGE   R2, R2, #10
        ADD     R2, R2, #"0"
        STRB    R2, [R6]
        MOV     R2, #0
        STRB    R2, [R6, #1]
        MOV     R0, sp
        MOV     R3, #0
        MOV     R4, #VarType_String
        SWI     XOS_SetVarVal

80      ADD     sp, sp, #32
        EXIT

90      ADR     r0, ErrorBlock_BadKey
      [ International
        BL      TranslateError
      |
        SETV    ; It needs setting here !
      ]
        B       %BT80

        MakeErrorBlock BadKey
02
        DCB     "Key$"                  ; Must be aligned
        ALIGN

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Exec, Spool and SpoolOn share a common body

Exec_Code Entry "$UtilRegs"

        MOV     r3, #&40        ; OPENIN exec
        MOV     r4, #198        ; r0b for osbyte exec
        B       %FT01


Spool_Code ALTENTRY

        MOV     r3, #&80        ; OPENOUT spool
        B       %FT00


SpoolOn_Code ALTENTRY

        MOV     r3, #&C0        ; OPENUP spoolon

00      MOV     r4, #199        ; r0b for osbyte spool/spoolon

01      MOV     r5, r0          ; Save filename^
        MOV     r6, r1          ; Save n parms

        MOV     r0, r4          ; Read old exec/spool handle
        MOV     r1, #0          ; Write 0 as handle; we may be just closing
        MOV     r2, #0          ; and keep zero if open error (cf. RUN)
        SWI     XOS_Byte        ; Won't cause error
        BL      CloseR1
        EXIT    VS

        CMP     r6, #0          ; No filename present ?
        EXIT    EQ              ; ie. just closing down exec/spool ?

        MOV     r1, r5          ; -> filename
        MOV     r0, r3          ; OPENIN exec/OPENUP spoolon/OPENOUT spool
        BL      OpenFileWithWinge
        EXIT    VS

        CMP     r3, #&C0        ; Doing SPOOLON ? VClear
        BLEQ    MoveToEOF       ; PTR#r1:= EXT#r1

        MOV     r0, r4          ; Write new exec/spool handle (r1)
        MOV     r2, #0
        SWIVC   XOS_Byte        ; May have got error in moving to EOF
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; List, Print and Type share a common body

listopt   RN    r2
lastchar  RN    r3
linecount RN    r4
charcount RN    r5

lnum      *     2_01    ; Line numbers
type      *     2_10    ; GSREAD format ?

filterprinting  * 2_10000000            ; Bits controlling printing
linenumbering   * 2_01000000
expandtabs      * 2_00100000

forcetbsrange   * 2_00001000
allowtbschar    * 2_00000100
unprintangle    * 2_00000010
unprinthex      * 2_00000001
unprintdot      * 2_00000001

Print_Code Entry "$UtilRegs"

        MOV     listopt, #0             ; No line numbers, raw ASCII
        B       %FT01


List_Code ALTENTRY

        MOV     listopt, #(filterprinting + linenumbering)
        MOV     linecount, #0
        B       %FT00


TypeArgs = "File/A,TabExpand/S",0
        ALIGN

Type_Code ALTENTRY

        MOV     listopt, #filterprinting

00      MOV     r6, r1                  ; no. params
        BL      ReadGSFormat            ; Read configured GSFormat bits
        EXIT    VS                      ; I2C could be faulty ! File not open
        ORR     listopt, listopt, r1

        CMP     r6, #1
        BEQ     %FT01
        Push   "R2, R3"
        MOV     R1, R0                  ; args given
        ADR     R0, TypeArgs
        LDR     R2, =ArgumentBuffer
        MOV     R3, #LongCLISize
        SWI     XOS_ReadArgs
        Pull   "R2, R3", VS
        EXIT    VS
        LDR     R0, [R2, #4]            ; tabflag
        CMP     R0, #0
        LDR     R0, [R2, #0]            ; filename ptr
        Pull   "R2, R3"
        ORRNE   listopt, listopt, #expandtabs

01      MOV     lastchar, #0            ; Reset NewLine indicator

        MOV     r1, r0                  ; Point to filename
        MOV     r0, #&40                ; han := OPENIN <filename>
        BL      OpenFileWithWinge
        EXIT    VS

10      SWI     XOS_ReadEscapeState     ; Won't cause error
        BCS     CloseThenAckEscape

        MOV     charcount, #0           ; No characters printed this line

        SWI     XOS_BGet                ; Get first character of line
        BVS     UtilityExitCloseR1
        BCS     UtilityExitCloseR1      ; EOF ?

        TST     listopt, #linenumbering ; Do we want to print the line number ?
        BLNE    LineNumberPrint
        BVS     UtilityExitCloseR1

; Doing ASCII (print) or GSREAD (type, list) ?

30      TST     listopt, #filterprinting
        BEQ     %FT35

; GSREAD format printing

        CMP     r0, #CR                 ; CR and LF both line terminators
        CMPNE   r0, #LF
        BEQ     %FT70

        CMP     r0, #TAB
        BNE     %FT31
        TST     listopt, #expandtabs
        BEQ     %FT31

; simple tab expansion: 8 spaces
        SWI     XOS_WriteS
        =      "        ",0
        ALIGN
        B       %FT32

31      MOV     lastchar, r0
        CMP     r0, #""""               ; Don't display quotes in GSREAD though
        CMPNE   r0, #"<"                ; Or left angle
        BEQ     %FT35
        BL      PrintCharInGSFormat

32      BVC     %FT40

35      SWIVC   XOS_WriteC
        BVS     UtilityExitCloseR1
        ADD     charcount, charcount, #1

40      SWI     XOS_ReadEscapeState     ; Won't cause error
        BCS     CloseThenAckEscape

        SWI     XOS_BGet                ; Get another character on this line
        BVS     UtilityExitCloseR1
        BCC     %BT30                   ; Loop if not EOF

50      TST     listopt, #filterprinting
        SWINE   XOS_NewLine             ; Terminate with NewLine if not *Print
        B       UtilityExitCloseR1


; Hit LF or CR in GSFormat mode, decide whether to give a NewLine or not

70      CMP     r0, lastchar            ; NewLine if same as last time eg LF,LF
        SWIEQ   XOS_NewLine
        BVS     UtilityExitCloseR1
        BEQ     %BT10                   ; Loop back and do another line

        CMP     lastchar, #CR           ; Don't give another NewLine if we've
        CMPNE   lastchar, #LF           ; had CR, LF or LF, CR
        MOVEQ   lastchar, #0            ; Reset NewLine indicator so more will
        BEQ     %BT40                   ; Loop and do more chars in this line

        MOV     lastchar, r0            ; Save char forcing this NewLine
        SWI     XOS_NewLine             ; Do NewLine then another line
        BVC     %BT10
        B       UtilityExitCloseR1

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Dump_Code Entry "$UtilRegs"

        MOV     r7, r1                  ; Remember nparms
        MOV     r8, r0                  ; Remember filename^ for below
        MOV     r1, r0                  ; -> filename

        MOV     r0, #&40                ; han := OPENIN <filename>
        BL      OpenFileWithWinge
        EXIT    VS                      ; File not yet open
        MOV     r9, r1                  ; Save handle

        MOV     r0, #OSFile_ReadWithType
        MOV     r1, r8                  ; Restore filename^
        SWI     XOS_File                ; Must exist and be a file now
        MOVVS   r1, r9                  ; Restore handle in case of error/exit
        BVS     UtilityExitCloseR1

        TEQ     r0, #object_nothing     ; It opened a moment ago, assume stream
                                        ; like file (or broken FS). Rely on EOF.
        MOVEQ   r6, #0
        MOVEQ   r4, #-1

        CMP     r4, #0                  ; Zero length ?
        BEQ     UtilityExitCloseR1      ; Nothing to do then ! VClear

        MOV     r5, r9                  ; Standard place for handle below

; Default display at load addr of file (r2) unless special

        BL      ReadGSFormat            ; Only interested in some bits
        BVS     UtilityExitCloseR1
        AND     r10, r1, #forcetbsrange + allowtbschar

        CMP     r6, #-1                 ; Unstamped file ?
        MOVNE   r2, #0                  ; Display start = 0
        MOV     r3, #0                  ; Default PTR# = 0
                                        ; Funny order 'cos of ReadOptionalLoadAndExec

        CMP     r7, #1                  ; Only filename specified ?
        BEQ     %FA10                   ; If so, use loadaddr and ptr=0

        MOV     r1, r8                  ; Get back filename^
        BL      SkipToSpace             ; Over the filename
        BL      ReadOptionalLoadAndExec ; Abuse ! r3 := start, r2 := disp start
        MOVVS   r1, r5
        BVS     UtilityExitCloseR1

        ADD     r2, r3, r2              ; Display offset = disparm/loadaddr+ptr

10      Swap    r2, r3                  ; r2 := start, r3 := disp start
        CMP     r2, r4                  ; Is ptr > ext ? VClear
        MOVHS   r1, r5
        BLHS    SetErrorOutsideFile

        MOVVC   r0, #OSArgs_SetPTR
        MOVVC   r1, r5
        SWIVC   XOS_Args                ; PTR#r1 := start offset
        MOVVC   r7, #0

        BLVC    ReadWindowWidth
        BVS     UtilityExitCloseR1

        SUB     r9, r0, #12+1           ; -ExtraFields (address and separators)
        MOV     r9, r9, LSR #2   ; Two nibbles, one space and one char per byte

        Push    r10                     ; Save format bits
        MOV     r10, #(1 :SHL: 31)      ; Move 1 bit down until not zero
12      MOVS    r10, r10, LSR #1
        MOVEQ   r9, #1                  ; Always 1 byte per line at least
        BEQ     %FT15
        TST     r10, r9                 ; Mask against r9 (byte count)
        BEQ     %BT12                   ; Not hit yet ?

        AND     r9, r9, r10, LSR #1     ; Take the bit one lower down
        ORR     r9, r9, r10             ; And the bit we matched. Yowzay !

15      MOV     r1, r5                  ; Get handle back
        Pull    r10                     ; Get format back


        SUB     sp, sp, #256            ; Need temp frame now

; Main Dump loop

30      SWI     XOS_ReadEscapeState     ; Won't cause error
        ADDCS   sp, sp, #256
        BCS     CloseThenAckEscape

; Get line of data (r9 bytes). Keep track of how many bytes were read in r4

        MOV     r2, sp                  ; Temp buffer
        MOV     r4, #0
35      SWI     XOS_BGet                ; Fall out of loop if EOF
        BVS     UtilityExitCloseR1_256
        STRCCB  r0, [r2, r4]
        ADDCC   r4, r4, #1
        CMPCC   r4, r9
        BCC     %BT35

        CMP     r4, #0                  ; No bytes to do this line ?
        BEQ     UtilityExitCloseR1_256

; Must preserve r4 till end for testing

        ANDS    r7, r7, #15             ; Print title every 16 lines of data
        BNE     %FT54


      [ International
        SWI     XOS_NewLine
        BL      WriteS_Translated
        DCB     "Address:Address  :",0
        ALIGN
      |
        SWI     XOS_WriteS              ; Print title start
        DCB     LF, CR
        DCB     "Address  :", 0
        ALIGN
      ]
        BVS     UtilityExitCloseR1_256

        MOV     r8, #0
50      ADD     r0, r3, r8              ; Print byte == LSB of
        SWI     XOS_WriteI+" "          ; display across page
        BLVC    HexR0Byte
        BVS     UtilityExitCloseR1_256
        ADD     r8, r8, #1
        CMP     r8, r9
        BNE     %BT50

        CMP     r9, #11                 ; No room to print title end ?
        BLO     %FT52                   ; VClear

        SWI     XOS_WriteS
        DCB     " : ", 0
        ALIGN
        BVS     UtilityExitCloseR1_256

        SUB     r8, r9, #10             ; Centre 'ASCII data' over data
        MOVS    r8, r8, LSR #1
51      SUBS    r8, r8,#1               ; VClear
        SWI     XOS_WriteI+" "
        BVS     UtilityExitCloseR1_256
        BPL     %BT51

      [ International
        BL      WriteS_Translated
        DCB     "ASCII:ASCII data",0
        ALIGN
      |
        SWI     XOS_WriteS
        DCB     "ASCII data", 0
        ALIGN
      ]

52      SWIVC   XOS_NewLine
        SWIVC   XOS_NewLine

54      MOVVC   r0, r3                  ; Print start of line address
        BLVC    HexR0LongWord
        SWIVC   XOS_WriteI+" "
        SWIVC   XOS_WriteI+":"
        BVS     UtilityExitCloseR1_256

; Print line of data in hex

        MOV     r5, #0
55      LDRB    r0, [r2, r5]
        SWI     XOS_WriteI+" "
        BVS     UtilityExitCloseR1_256
        CMP     r5, r4                  ; Byte valid ?
        SWICS   XOS_WriteI+" "
        BVS     UtilityExitCloseR1_256
        SWICS   XOS_WriteI+" "
        BVS     UtilityExitCloseR1_256
        BLCC    HexR0Byte               ; Alters C, so do last
        BVS     UtilityExitCloseR1_256
        ADD     r5, r5, #1
        CMP     r5, r9
        BCC     %BT55

        SWI     XOS_WriteS
        DCB     " : ", 0
        ALIGN
        BVS     UtilityExitCloseR1_256

; Print line of data in ASCII

        MOV     r5, #0
65      LDRB    r0, [r2, r5]
        TST     r10, #forcetbsrange     ; Forcing into 00..7F ?
        BICNE   r0, r0, #&80
        TST     r10, #allowtbschar
        BEQ     %FT66
        CMP     r0, #&80                ; Print tbs unmolested
        BHS     %FT67
66      CMP     r0, #" "                ; Space through twiddle are valid
        RSBGES  r14, r0, #&7E
        MOVLT   r0, #"."
67      SWI     XOS_WriteC
        BVS     UtilityExitCloseR1_256
        ADD     r5, r5, #1
        CMP     r5, r4
        BCC     %BT65

        SWI     XOS_NewLine
        BVS     UtilityExitCloseR1_256
        ADD     r7, r7, #1              ; Increment line count
        ADD     r3, r3, r9              ; Increment display address by r9 bytes
        CMP     r4, r9                  ; Loop till we couldn't fill a line
        BEQ     %BT30

; .............................................................................

UtilityExitCloseR1_256

        ADD     sp, sp, #256            ; Kill temp frame

; .............................................................................

UtilityExitCloseR1

        BL      CloseR1                 ; Accumulates V

        Pull    "$UtilRegs, pc"         ; Back to *Command handler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Append and Build share a common body

Append_Code Entry "$UtilRegs"

        MOV     r1, r0          ; -> filename
        MOV     r0, #&C0        ; OPENUP
        B       %FT01


Build_Code ALTENTRY

        MOV     r1, r0          ; -> filename
        MOV     r0, #&80        ; OPENOUT

01      BL      OpenFileWithWinge
        EXIT    VS

        SUB     sp, sp, #256

        MOV     r5, r1          ; Save handle for later
        BL      MoveToEOF       ; Can do this anyhow as ext#(openout)=0

        MOV     linecount, #0

10      BLVC    LineNumberPrint ; Escape is tested for on OS_ReadLine.Err below
        BVS     UtilityExitCloseR1_256

        MOV     r0, sp             ; Get a line from Joe Punter
        MOV     r1, #256-1         ; -1 for terminator
        MOV     r2, #" "
        MOV     r3, #&FF
        SWI     XOS_ReadLine32
        MOVVS   r1, r5
        BVS     UtilityExitCloseR1_256
        MOV     r3, #CR                 ; Terminate source string
        STRB    r3, [r0, r1]
        MOVCC   FSUTtemp, #0            ; Ended with ESCAPE ?
        MOVCS   FSUTtemp, #-1
        MOVCS   r0, #&7E                ; Ack. ESCAPE, not error
        SWICS   XOS_Byte
        BVS     UtilityExitCloseR1_256

        MOV     r2, sp                  ; r2 -> buffer to translate
        MOV     r1, r5                  ; Get handle back
18      LDRB    r0, [r2], #1            ; Put all the spaces out ourselves !
        CMP     r0, #" "                ; VClear
        SWIEQ   XOS_BPut
        BVS     UtilityExitCloseR1_256
        BEQ     %BT18

        SUB     r0, r2, #1         ; r0 -> past spaces, rest to translate
        MOV     r2, #(1 :SHL: 31)  ; No quote funnies, don't end on space, do |
        SWI     XOS_GSInit

20      SWIVC   XOS_GSRead              ; Get a char
        MOVVS   R1, R5
        BVS     UtilityExitCloseR1_256
        BCS     %FT30                   ; End of string ?
        MOV     r3, r0                  ; Save GSState
        MOV     r0, r1                  ; Char from GSRead
        MOV     r1, r5                  ; Get handle back
        SWI     XOS_BPut
        BVS     UtilityExitCloseR1_256
        MOV     r0, r3                  ; Restore GSState
        B       %BT20                   ; And loop

30      CMP     FSUTtemp, #0            ; Did we read ESCAPE ? VClear
        MOV     r1, r5                  ; In any case, we want r1 handle
        MOV     r0, #CR                 ; If not, stick a CR on eoln
        SWIEQ   XOS_BPut
        BEQ     %BT10                   ; Finished if ESCAPE was pressed
                                        ; Catch error back there too

        SWIVC   XOS_NewLine

        B       UtilityExitCloseR1_256

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OSFile routines: Load, Save, Create, Delete and Remove

Load_Code Entry "$UtilRegs"

        MOV     r7, r0                  ; -> filename
        CMP     r1, #1                  ; Just filename (1 parm) ?
        MOVEQ   r3, #&FF                ; Load at its own address if so
        BEQ     %FT90

        BL      SkipNameAndReadAddr
        EXIT    VS
        BLCS    SetErrorBadAddress      ; Must check for trailing junk
        MOVVC   r3, #0                  ; Got load address from command line

90      MOVVC   r0, #OSFile_Load
        ORRVC   r3, r3, #1<<31          ; Do OS_SynchroniseCodeAreas after load
        MOVVC   r1, r7                  ; Get filename^ back
        SWIVC   XOS_File
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Save_Error
        DCD       ErrorNumber_Syntax
      [ International
        DCB       "BadSav:Bad parameters for *Save", 0
      ]
        ALIGN

Save_Code Entry "$UtilRegs"

        BL      SkipNameAndReadAddr
        EXIT    VS

        MOV     r4, r2          ; Got start address
        BL      SkipSpaces
        MOV     r5, r0          ; Preserve state
        CMP     r0, #"+"        ; Is it a +<length> parm ?
        ADDEQ   r1, r1, #1      ; Skip '+' then
        BLEQ    SkipSpaces      ; And any trailing spaces
        BL      ReadAtMost8Hex  ; Read a word anyway
        EXIT    VS

        CMP     r5, #"+"
        MOVNE   r5, r2          ; <end addr> ?
        ADDEQ   r5, r2, r4      ; Form <end addr> := <start addr> + <length>
        MOV     r2, r4          ; r2, r3 := both r4 by default
        MOV     r3, r4
        BL      ReadOptionalLoadAndExec
        SETV    CS
        ADRVS   R0, Save_Error  ; If there's anything on the end, it's an error
      [ International
        BLVS    TranslateError
      ]
        MOVVC   r0, #OSFile_Save
        MOVVC   r1, r7          ; Get filename^ back
        SWIVC   XOS_File
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Create_Code Entry "r1, $UtilRegs"

        CMP     r1, #1                  ; Filename only -> length 0, dated
        MOVEQ   r7, r0                  ; Filename^
        MOVEQ   r2, #0                  ; Will be copied to r5 in a bit
        BLNE    SkipNameAndReadAddr
        EXIT    VS
        MOV     r5, r2                  ; Got length, put in as end address
        MOV     r4, #0                  ; So start addr shall be .. 0 !

        LDR     r14, [sp]               ; No load, exec -> datestamp FFD
        CMP     r14, #3
        MOVLO   r0, #OSFile_CreateStamp
        LDRLO   r2, =&FFFFFFFD          ; Only bottom 12 bits are of interest
        MOVHS   r0, #OSFile_Create      ; Makes it an immediate constant
        MOVHS   r2, #0                  ; Load/Exec default to 0
        MOVHS   r3, #0
        BLHS    ReadOptionalLoadAndExec

        MOVVC   r1, r7                  ; Get filename^ back
        SWIVC   XOS_File
        EXIT

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Delete and Remove share a common body

Delete_Code Entry

        MOV     r6, #0                  ; Give error if file doesn't exist
        B       %FT01                   ; Use a reg. not affected by OSFile !

Remove_Code ALTENTRY

        MOV     r6, #-1                 ; Don't winge

01      MOV     r1, r0                  ; -> filename
        MOV     r0, #OSFile_Delete
        SWI     XOS_File
        EXIT    VS

        ASSERT  object_nothing = 0
        CMP     r0, r6                  ; Are we going to winge ?
        MOVEQ   r0, #OSFile_MakeError   ; Give pretty error now, says Tutu
        MOVEQ   r2, #object_nothing
        SWIEQ   XOS_File
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Gosh, doesn't use UtilRegs !!!

Opt_Code Entry

        MOV     r3, #0                  ; Default parms are 0, 0
        MOV     r4, #0
        CMP     r1, #0                  ; No parms ? VClear
        BEQ     %FT50

        MOV     r1, r0
        MOV     r0, #10                 ; Default base 10, allow naff term ','
        SWI     XOS_ReadUnsigned        ; Read first parm
        EXIT    VS
        MOV     r3, r2

        BL      FS_SkipSpaces           ; Try getting another parm anyway
        BCC     %FT50                   ; End of the line

        TEQ     r0, #","                ; commas too !
        ADDEQ   r1, r1, #1
        BLEQ    FS_SkipSpaces
        CMP     r0, #space              ; Anything here ?
        BEQ     %FT99

        MOV     r0, #(1 :SHL: 31) + 10  ; Default base 10, no bad terms
        SWI     XOS_ReadUnsigned        ; Read second parm
        MOVVC   r4, r2

50      MOVVC   r0, #FSControl_Opt
        MOVVC   r1, r3
        MOVVC   r2, r4
        SWIVC   XOS_FSControl
        EXIT

99      ADR     r0, SyntaxError_StarOpt
      [ International
        BL      TranslateError
      |
        SETV
      ]
        EXIT


SyntaxError_StarOpt
        DCD     ErrorNumber_Syntax
        DCB     "OptErr:Syntax: *Opt [<x> [[,] <y>]]", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;              H o r r i b l e   l i t t l e   s u b r o u t i n e s
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Variegated output routines

HexR0LongWord Entry "r0"

        MOV     r0, r0, ROR #16
        BL      HexR0Word
        MOVVC   r0, r0, ROR #32-16
        BLVC    HexR0Word
        STRVS   r0, [sp]
        EXIT


HexR0Word Entry "r0"

        MOV     r0, r0, ROR #8
        BL      HexR0Byte
        MOVVC   r0, r0, ROR #32-8
        BLVC    HexR0Byte
        STRVS   r0, [sp]
        EXIT


HexR0Byte Entry "r0"

        MOV     r0, r0, ROR #4
        BL      HexR0Nibble
        MOVVC   r0, r0, ROR #32-4
        BLVC    HexR0Nibble
        STRVS   r0, [sp]
        EXIT


HexR0Nibble Entry "r0"

        AND     r0, r0, #15
        CMP     r0, #10
        ADDCC   r0, r0, #"0"
        ADDCS   r0, r0, #"A"-10
        SWI     XOS_WriteC
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SkipSpaces ROUT

10      LDRB    r0, [r1], #1
        CMP     r0, #" "        ; Leave r1 -> ~space
        BEQ     %BT10
        SUB     r1, r1, #1
        CLRV
        MOV     pc, lr          ; r0 = first ~space. Can't really fail


SkipToSpace Entry

10      LDRB    lr, [r1], #1
        CMP     lr, #&7F
        CMPNE   lr, #" "        ; Leave r1 -> space or CtrlChar
        BHI     %BT10
        SUB     r1, r1, #1
        CLRV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> string

; Out   flags from CMP r0, #space for eol detection

FS_SkipSpaces ROUT

10      LDRB    r0, [r1], #1
        CMP     r0, #space      ; Leave r1 -> ~space
        BEQ     %BT10
        SUB     r1, r1, #1
        MOV     pc, lr          ; r0 = first ~space

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = open mode
;       r1 -> filename

; Out   VC: r0 = r1 = handle
;       VS: r0 -> error (FilingSystemError or 'NotFound')

OpenFileWithWinge Entry

        ORR     r0, r0, #(open_mustopen :OR: open_nodir) ; Saves us code here
        SWI     XOS_Find
        MOVVC   r1, r0
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; PTR#handle := EXT#handle

; In    r1 = handle to use

; Out   VC: PTR moved
;       VS: r0 -> Filing System Error

MoveToEOF Entry "r0, r2"

        MOV     r0, #OSArgs_ReadEXT
        SWI     XOS_Args
        MOVVC   r0, #OSArgs_SetPTR
        SWIVC   XOS_Args
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CloseThenAckEscape

        BL      CloseR1

        BL      AckEscape
        Pull    "$UtilRegs, pc"         ; Common exit - back to MOS


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = handle to close, or 0 means don't do anything

; Out   VC: file closed, or nothing done
;       VS: r0 -> Filing System Error, or VSet on entry

CloseR1 EntryS "r0"

        CMP     r1, #0                  ; Is there a handle to close ? VClear
        MOVNE   r0, #0                  ; CLOSE#han
        SWINE   XOS_Find
        EXITS   VC                      ; Accumulate V

        STR     r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Increment then print a line number in decimal

LineNumberPrint Entry "r0-r1"

        ADD     linecount, linecount, #1 ; r0 := ++linecount
        MOV     r0, linecount
        MOV     r1, #1                  ; Print leading spaces
        BL      PrintR0Decimal
        SWIVC   XOS_WriteI+" "
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = number to print
;       r1 = 0 -> strip spaces
;            1 -> print leading spaces

; Number gets printed RJ in a field of 4 if possible, or more as necessary

PrintR0Decimal Entry "r0-r3"

        SUB     sp, sp, #32
        MOV     r3, r1                  ; Save flag
        MOV     r1, sp
        MOV     r2, #32
        SWI     XOS_BinaryToDecimal     ; No errors from this
        CMP     r3, #0                  ; If not doing spaces or >= 4 chars
        CMPNE   r2, #4                  ; in the number, son't print any

        ADRLT   r0, %FT98-1             ; Point to right amount of spaces
        ADDLT   r0, r0, r2
        SWILT   XOS_Write0

10      LDRVCB  r0, [r1], #1
        SWIVC   XOS_WriteC
        BVS     %FT99
        SUBS    r2, r2, #1
        BNE     %BT10

99      ADD     sp, sp, #32
        STRVS   r0, [sp]
        EXIT

98
        DCB     "   ", 0                ; Three spaces, null
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Read configured GS string format
;
; Out   r1 = bits read from CMOS ram

ReadGSFormat Entry "r0, r2"

        MOV     r0, #ReadCMOS
        MOV     r1, #PrintSoundCMOS
        SWI     XOS_Byte
        ANDVC   r1, r2, #2_1111         ; Mask out all but my bits
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0b = char to print using current listopt

; Out   r0 corrupt

PrintCharInGSFormat Entry "r1, listopt"

        AND     r0, r0, #&FF    ; Just in case
        TST     listopt, #forcetbsrange ; Forcing tbs into 00..7F ?
        BIC     listopt, listopt, #forcetbsrange
        BICNE   r0, r0, #&80            ; Take top bit out if so

        CMP     r0, #" "        ; Do we need to do this at all ?
        RSBGES  r14, r0, #&7E
        BLT     %FT10           ; LT if not in range &20-&7E
        CMP     r0, #"|"        ; Solidus ? VClear
        CMPNE   r0, #""""       ; Quote ?
        CMPNE   r0, #"<"        ; Left angle ?
        SWINE   XOS_WriteC      ; Nope, so let's print the char and exit
        EXIT    VS
        EXIT    NE


10      TST     listopt, #allowtbschar  ; International format bit ?
        BIC     listopt, listopt, #allowtbschar
        BEQ     %FT15
        CMP     r0, #&80
        BHS     %FT45                   ; Print tbs char and exit

15      TST     listopt, #unprintangle  ; Angle bracket format ?
        BNE     %FT50

        TST     listopt, #unprintdot    ; Doing unprintable dot format (2_01) ?
        BEQ     %FT16

        CMP     r0, #" "                ; Only space to twiddle are printable
        RSBGES  r14, r0, #&7E
        MOVLT   r0, #"."                ; All others are dot
        B       %FT45                   ; Print char and exit


; Normal BBC GSREAD format (2_00)

16      CMP     r0, #&80                ; Deal with tbs first
        BIC     r0, r0, #&80
        BLO     %FT17
        SWI     XOS_WriteI+"|"
        SWIVC   XOS_WriteI+"!"
        EXIT    VS

17      CMP     r0, #&7F                ; Delete ? -> |?. VClear
        MOVEQ   r0, #"?"
        CMPNE   r0, #""""               ; Quote ? -> |"
        CMPNE   r0, #"|"                ; Solidus ? -> ||
        SWIEQ   XOS_WriteI+"|"
        EXIT    VS
        CMP     r0, #&1F                ; CtrlChar ? -> |<char+@@>. VClear
        ADDLS   r0, r0, #"@@"
        SWILS   XOS_WriteI+"|"

45      SWI     XOS_WriteC              ; Used from above
        EXIT


50 ; Angle bracket format, either hex (2_11) or decimal (2_10)

        SWI     XOS_WriteI+"<"
        TST     listopt, #unprinthex
        BNE     %FT60
        MOV     r1, #0                  ; Strip leading spaces
        BLVC    PrintR0Decimal
        SWIVC   XOS_WriteI+">"
        EXIT


60      SWIVC   XOS_WriteI+"&"
        BLVC    HexR0Byte
        SWIVC   XOS_WriteI+">"
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> filename. Used by most MOS OSFile routines for initial decoding

; Out   r1 -> past address read
;       r2 = address read
;       r7 = initial filename^
;       VS : failed to read address, r0 -> error
;       CS : text present comes immediately after address

SkipNameAndReadAddr Entry

        MOV     r7, r0          ; Save filename^
        MOV     r1, r0          ; -> filename
        BL      SkipToSpace     ; Over the filename
        BL      SkipSpaces      ; To the address
        BL      ReadAtMost8Hex  ; Go read it Floyd !
        LDRVCB  r0, [r1]        ; Anything on the end ?
        CMPVC   r0, #" "+1      ; CtrlChar + space ok
        EXIT                    ; VC/VS from readhex or VC, CC/CS from CMP

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r2, r3 = load/exec addresses to use if none provided. r1 -> string

; Out   r2, r3 conditionally updated, r1 updated, past any trailing spaces
;       VS if failed, error ('Bad Address' or whatever) set
;       CS if something comes afterwards ...

ReadOptionalLoadAndExec Entry "r0, FSUTtemp"

        MOV     FSUTtemp, r2    ; Save initial value

        BL      SkipSpaces
        CMP     r0, #" "        ; No more parms ?
        EXIT    LO              ; VClear, r2, r3 unaffected

        BL      ReadAtMost8Hex
        BVS     %FT99
        MOV     r3, r2
        MOV     r2, FSUTtemp
        BL      SkipSpaces
        CMP     r0, #" "        ; No more parms ?
        EXIT    LO              ; VClear, r2 unaffected, r3 updated

        BL      ReadAtMost8Hex
        BLVC    SkipSpaces      ; Anything on the end ?
        CMPVC   r0, #" "
99      STRVS   r0, [sp]
        EXIT                    ; VC/VS from readhex or VC, CC/CS from CMP

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Read a hex (default) address from a string

; In    r1 -> string

; Out   VC: r1 -> first char not used in building number, r2 = number
;       VS: error ('Bad Address') set

ReadAtMost8Hex Entry "r0, r3-r4"

        MOV     R0, #16                 ; default base, don't trap bad terms
        SWI     XOS_ReadUnsigned
        STRVS   r0, [sp]
        EXIT                    ; VClear -> good hex number / VSet -> bad

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Set various errors: VSet always on exit

SetErrorBadAddress

        ADR     r0, ErrorBlock_BadAddress
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        RETURNVS

        MakeErrorBlock BadAddress


SetErrorOutsideFile

        ADR     r0, ErrorBlock_OutsideFile
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        RETURNVS

        MakeErrorBlock OutsideFile


SetErrorEscape

        ADR     r0, ErrorBlock_Escape
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        RETURNVS

        MakeErrorBlock Escape

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

AckEscape
        Push   "r1-r2, lr"
        MOV     r0, #&7E
        SWI     XOS_Byte

        BLVC    SetErrorEscape          ; Only set ESCAPE error if no override
        Pull    "r1-r2, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        END
@


4.8
log
@Improve handling of *DUMPing a stream
The checks in *DUMP tried to spot a stream (ie. a file that can be opened with OS_Find but that OS_File 5 doesn't think is there), but in doing so never set the address or offset, so the hex values shown on the left of the screen would be whatever junk was in r2 & r3.
Reorder the tests so it starts at 0 and runs until EOF.
Make use of OSFile_ReadWithType rather than trying to deduce if it's an untyped file ourselves.
Tested with
  *DUMP random:
from SystemDevs-1_33.

Version 5.53. Tagged as 'Kernel-5_53'
@
text
@d295 1
a295 1
        LDR       r4, [r3, #Module_Title]
d367 1
a367 1
        LDR       r3, [r2, #Module_Title]
@


4.7
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d1025 1
a1025 1
        MOV     r0, #OSFile_ReadInfo    ; Read file info
d1028 1
a1028 1
        MOV     r1, r9                  ; Restore handle in case of error/exit
d1031 5
d1047 2
a1048 8
        CMP     r2, #0                  ; Command file ?
        CMPEQ   r3, #-1
        BEQ     %FT04

        MOV     r14, r2, ASR #(32-12)   ; Date stamped file ?
        CMP     r14, #-1                ; &FFFtttdd
04      MOVEQ   r2, #0                  ; Display start = 0

d1050 1
a1050 1
                                        ; Funny order 'cos of ReadOptLoadAndExe
d1422 1
@


4.6
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a918 1
  [ LongCommandLines
a919 3
  |
        MOV     R3, #256
  ]
d1335 1
a1335 3
 [ StrongARM
        ORRVC   r3, r3, #1<<31
 ]
@


4.5
log
@  Bug fixes only.
Detail:
  "Podule" number now displayed again in *ROMModule output - flag
     preservation issue caused it to disappear in 5.23.
  *Eval output no longer misses its trailing space, neither do "Podule" or
    "Extn ROM" in *ROMModules output.
  Heap manager now works again in non-SVC modes.
  Exception dump now contains faked up 26-bit PC+PSR lookalike.
Admin:
  Assembled.
@
text
@d232 1
a232 1
        GET       s.TMOSHelp
d273 1
a273 1
        MOV      R2, #Module_List
d339 1
a339 1
        mrs      ,r6, CPSR
d342 1
a342 1
        msr      ,CPSR_f, r6     ; restore V state
d377 2
a378 2
        MOV       r0, #0                        ; Try our message file before Global.
        LDR       r0, [r0, #KernelMessagesBlock]
d380 1
a380 1
        ADRNE     r0, KernelMessagesBlock+4
d382 1
d384 1
d425 2
a426 2
        MOV     r0, #0                          ; Try our message file before Global.
        LDR     r0, [r0, #KernelMessagesBlock]
d428 2
a429 1
        ADRNE   r0, KernelMessagesBlock+4
d431 1
d446 1
a446 1

d453 1
a453 1
        STRVS   R0, [stack]
d597 2
a599 1
        SETV
d631 1
a631 1
        MOVLS  R7, #UserMemStart
d635 1
a635 1
        MOVVS  R7, #UserMemStart
d668 1
a668 1
Close_Code ENTRY
d677 1
a677 1
FX_Code ENTRY
d743 1
a743 1
Shadow_Code ENTRY
d745 12
a756 12
       CMP      R1, #0
       MOV      R1, R0
       MOV      R0, #10 + (1:SHL:30)
       SWINE    XOS_ReadUnsigned
       MOVEQ    R2, #0
       EXIT     VS
       BL       CheckEOL
       BNE      ShadowNaff
       MOV      R0, #114
       MOV      R1, R2
       SWI      XOS_Byte
       EXIT
d759 7
a765 7
       ADRL     R0, ErrorBlock_BadNumb
     [ International
       BL       TranslateError
     |
       SETV
     ]
       EXIT
d768 6
a773 6
       LDRB     R0, [R1], #1
       CMP      R0, #" "
       CMPNE    R0, #13
       CMPNE    R0, #10
       CMPNE    R0, #0
       MOV      PC, lr
d777 1
a777 1
Key_Code ENTRY
d822 1
a822 1
Exec_Code ENTRY "$UtilRegs"
d888 1
a888 1
Print_Code ENTRY "$UtilRegs"
d919 3
d923 1
d1018 1
a1018 1
Dump_Code ENTRY "$UtilRegs"
d1248 1
a1248 1
Append_Code ENTRY "$UtilRegs"
d1273 2
a1274 2
        MOV     r0, sp          ; Get a line from Joe Punter
        MOV     r1, #256-1      ; -1 for terminator
d1277 1
a1277 1
        SWI     XOS_ReadLine
d1326 1
a1326 1
Load_Code ENTRY "$UtilRegs"
d1340 1
a1340 1
	ORRVC	r3, r3, #1<<31
d1355 1
a1355 1
Save_Code ENTRY "$UtilRegs"
d1387 1
a1387 1
Create_Code ENTRY "r1, $UtilRegs"
d1415 1
a1415 1
Delete_Code ENTRY
d1438 1
a1438 1
Opt_Code ENTRY
d1489 1
a1489 1
HexR0LongWord ENTRY "r0"
d1499 1
a1499 1
HexR0Word ENTRY "r0"
d1509 1
a1509 1
HexR0Byte ENTRY "r0"
d1519 1
a1519 1
HexR0Nibble ENTRY "r0"
d1541 1
a1541 1
SkipToSpace ENTRY
d1571 1
a1571 1
OpenFileWithWinge ENTRY
d1586 1
a1586 1
MoveToEOF ENTRY "r0, r2"
d1624 1
a1624 1
LineNumberPrint ENTRY "r0-r1"
d1641 1
a1641 1
PrintR0Decimal ENTRY "r0-r3"
d1670 2
a1671 2
; Read configured info of Tutu's wally byte

d1674 1
a1674 1
ReadGSFormat ENTRY "r0, r2"
d1677 1
a1677 1
        MOV     r1, #TutuCMOS
d1688 1
a1688 1
PrintCharInGSFormat ENTRY "r1, listopt"
d1772 1
a1772 1
SkipNameAndReadAddr ENTRY
d1790 1
a1790 1
ReadOptionalLoadAndExec ENTRY "r0, FSUTtemp"
d1820 1
a1820 1
ReadAtMost8Hex ENTRY "r0, r3-r4"
@


4.5.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d339 1
a339 1
        MRS       r6, CPSR
d342 1
a342 1
        MSR       CPSR_f, r6     ; restore V state
d663 1
a663 1
Close_Code Entry
d672 1
a672 1
FX_Code Entry
d738 1
a738 1
Shadow_Code Entry
d772 1
a772 1
Key_Code Entry
d817 1
a817 1
Exec_Code Entry "$UtilRegs"
d883 1
a883 1
Print_Code Entry "$UtilRegs"
d1009 1
a1009 1
Dump_Code Entry "$UtilRegs"
d1239 1
a1239 1
Append_Code Entry "$UtilRegs"
d1317 1
a1317 1
Load_Code Entry "$UtilRegs"
d1346 1
a1346 1
Save_Code Entry "$UtilRegs"
d1378 1
a1378 1
Create_Code Entry "r1, $UtilRegs"
d1406 1
a1406 1
Delete_Code Entry
d1429 1
a1429 1
Opt_Code Entry
d1480 1
a1480 1
HexR0LongWord Entry "r0"
d1490 1
a1490 1
HexR0Word Entry "r0"
d1500 1
a1500 1
HexR0Byte Entry "r0"
d1510 1
a1510 1
HexR0Nibble Entry "r0"
d1532 1
a1532 1
SkipToSpace Entry
d1562 1
a1562 1
OpenFileWithWinge Entry
d1577 1
a1577 1
MoveToEOF Entry "r0, r2"
d1615 1
a1615 1
LineNumberPrint Entry "r0-r1"
d1632 1
a1632 1
PrintR0Decimal Entry "r0-r3"
d1665 1
a1665 1
ReadGSFormat Entry "r0, r2"
d1679 1
a1679 1
PrintCharInGSFormat Entry "r1, listopt"
d1763 1
a1763 1
SkipNameAndReadAddr Entry
d1781 1
a1781 1
ReadOptionalLoadAndExec Entry "r0, FSUTtemp"
d1811 1
a1811 1
ReadAtMost8Hex Entry "r0, r3-r4"
@


4.5.2.2
log
@Merge in long command line support from Ursula kernel.
Look for LongCommandLine flag, command line size currently
set at 1k.
For HAL/32bit builds, the kernel buffer space is at high
(top bit set) address, which may break some code using signed
comparisons. So *beware* that there may be some latent
bugs in old kernel code using these buffers, not yet found.
One such bug, in s.Arthur2 found and fixed.
Tested moderately on ARM9 desktop build.
Lovely to reimplement things I did two and half years ago.

Version 5.35, 4.79.2.37. Tagged as 'Kernel-5_35-4_79_2_37'
@
text
@a913 3
  [ LongCommandLines
        MOV     R3, #LongCLISize
  |
a914 1
  ]
@


4.5.2.3
log
@1) Bring IOMD HAL more up to date. Add support for new
call HAL_CleanerSpace (preparation for StrongARM kernel
support).

2) In kernel, add HAL_CleanerSpace call (preparation for
StrongARM and XScale core support). Fix bug found with
ARMv3 support during test on Risc PC.

3) Implement new API for kernel SWIs that have used top
bits of addresses as flags. The new API has an extra
flag that must be set, so kernel can distinguish and
support both APIs. The reason for all this is that
addresses are 32-bits now, people, keep up there. Briefly:

  OS_HeapSort
    bit 31 of r0 set for new API, r1 is full 32-bit address
    flags move from r1 bits 31-29 to r0 bits 30-28

  OS_ReadLine
    bit 31 of r1 set for new API, r0 is full 32-bit address
    flags move from bits 31,30 of r0 to bits 30,29 of r1

  OS_SubstituteArgs
    bit 31 of r2 set for new API, r0 is full 32-bit address
    flag moves from bit 31 of r0 to bit 30 of r2

Tested on Risc PC and briefly on Customer A 2

Ta

Version 5.35, 4.79.2.41. Tagged as 'Kernel-5_35-4_79_2_41'
@
text
@d1268 2
a1269 3
        MOV     r0, sp             ; Get a line from Joe Punter
        MOV     r1, #256-1         ; -1 for terminator
        ORR     r1, r1, #&80000000 ; yep, new API
@


4.5.2.4
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d1270 1
d1273 1
a1273 1
        SWI     XOS_ReadLine32
@


4.5.2.5
log
@  Bugfix to *Help.
Detail:
  Internationalisation of *Help code (ie probably dating back to RISC OS 3.1)
  broke the Escape condition checking. This is particularly nasty if you
  do *Help . on a machine with slow hardware scrolling!
Admin:
  Not tested.

Version 5.35, 4.79.2.89. Tagged as 'Kernel-5_35-4_79_2_89'
@
text
@d442 1
a442 1
        BVS     %FT99
d449 1
a449 1
99      STRVS   R0, [stack]
@


4.5.2.6
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d273 1
a273 1
        LDR      R2, =ZeroPage+Module_List
d377 2
a378 2
        LDR       r2, =ZeroPage                 ; Try our message file before Global.
        LDR       r0, [r2, #KernelMessagesBlock]
d380 1
a380 1
        ADDNE     r0, r2, #KernelMessagesBlock+4
a381 1
      [ ZeroPage <> 0
a382 1
      ]
d423 2
a424 2
        LDR     r2, =ZeroPage                   ; Try our message file before Global.
        LDR     r0, [r2, #KernelMessagesBlock]
d426 1
a426 2
        ADDNE   r0, r2, #KernelMessagesBlock+4
      [ ZeroPage <> 0
a427 1
      ]
@


4.5.2.7
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d1339 1
a1339 1
        ORRVC   r3, r3, #1<<31
@


4.5.2.7.2.1
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d744 12
a755 12
        CMP     R1, #0
        MOV     R1, R0
        MOV     R0, #10 + (1:SHL:30)
        SWINE   XOS_ReadUnsigned
        MOVEQ   R2, #0
        EXIT    VS
        BL      CheckEOL
        BNE     ShadowNaff
        MOV     R0, #114
        MOV     R1, R2
        SWI     XOS_Byte
        EXIT
d758 7
a764 7
        ADRL    R0, ErrorBlock_BadNumb
      [ International
        BL      TranslateError
      |
        SETV
      ]
        EXIT
d767 6
a772 6
        LDRB    R0, [R1], #1
        CMP     R0, #" "
        CMPNE   R0, #13
        CMPNE   R0, #10
        CMPNE   R0, #0
        MOV     PC, lr
d1669 2
a1670 2
; Read configured GS string format
;
d1676 1
a1676 1
        MOV     r1, #PrintSoundCMOS
@


4.5.2.8
log
@Adoption of *CONFIGURE/STATUS CACHE commands
The kernel already looks after all other aspects of the ARM CPU, so can look after the cache control command too.
 HelpStrs.s:New tokens for help and syntax
 CmdHelp.s:UK help and syntax
 Arthur3.s:Tables updates for *CONFIGURE/STATUS, lined some stuff up, default error text sync'd with Hdr:NewErrors
 MoreComms.s:Parsing and doing of *CACHE
 Utility.s:Hashing table updated for *CACHE
Other minor changes
 hdr/Options:Bring 'MosVer' into the private header
 hdr/RISCOS:aasm aliases for SP removed, MainVars and MosVer made private, added definition of the start of application space
 HeapMan.s:Use of GRAB changed to Pull
 Offset of TutuCMOS changed for more informative PrintSoundCMOS
 PMF/osbyte.s:Use OsBytes header file in place of MainVars

Version 5.35, 4.79.2.151. Tagged as 'Kernel-5_35-4_79_2_151'
@
text
@d744 12
a755 12
        CMP     R1, #0
        MOV     R1, R0
        MOV     R0, #10 + (1:SHL:30)
        SWINE   XOS_ReadUnsigned
        MOVEQ   R2, #0
        EXIT    VS
        BL      CheckEOL
        BNE     ShadowNaff
        MOV     R0, #114
        MOV     R1, R2
        SWI     XOS_Byte
        EXIT
d758 7
a764 7
        ADRL    R0, ErrorBlock_BadNumb
      [ International
        BL      TranslateError
      |
        SETV
      ]
        EXIT
d767 6
a772 6
        LDRB    R0, [R1], #1
        CMP     R0, #" "
        CMPNE   R0, #13
        CMPNE   R0, #10
        CMPNE   R0, #0
        MOV     PC, lr
d1669 2
a1670 2
; Read configured GS string format
;
d1676 1
a1676 1
        MOV     r1, #PrintSoundCMOS
@


4.5.2.9
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d597 1
a597 1
      |
a598 1
      ]
@


4.5.2.10
log
@Adopt some switches from Hdr:Machine/Machine
SystemName, ROMSizeOffset, HAL32, HAL26 only used here, moved here.
Remove uses of "M_" booleans, apparently that's bad form.
Fix SWIDespatch_Size for the non thumb capable case (was ASSERTing).
Swapped UserMemStart for AppSpaceStart.
Removed last use of OldComboSupport (pre Medusa!).
Removed switch 'CDVPoduleIRQs', a correction to the machine definitions mean this can now simply be switched on NumberOfPodules (previously, IOMD couldn't chain podule interrupts).
Take out disabled sub interrupt support - it's in CVS if you want to try to get it working.
Moved ConfiguredLang to 11 for everyone, it only matters if !Boot fails, and no harm in making it common for 5.xx onwards.

Version 5.35, 4.79.2.183. Tagged as 'Kernel-5_35-4_79_2_183'
@
text
@d631 1
a631 1
        MOVLS  R7, #AppSpaceStart
d635 1
a635 1
        MOVVS  R7, #AppSpaceStart
@


4.5.2.11
log
@Makefile recreated from fragments
Need a custom ROM stage as the Kernel is linked as a binary, and a custom exports phase as the AAsmModule makefile tops out at 3 exported headers, but otherwise the rest can be shared.
Tested in an IOMD ROM build.

Version 5.35, 4.79.2.228. Tagged as 'Kernel-5_35-4_79_2_228'
@
text
@d232 1
a232 1
        GET       s.TokHelpSrc
@


4.5.2.5.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d273 1
a273 1
        LDR      R2, =ZeroPage+Module_List
d377 2
a378 2
        LDR       r2, =ZeroPage                 ; Try our message file before Global.
        LDR       r0, [r2, #KernelMessagesBlock]
d380 1
a380 1
        ADDNE     r0, r2, #KernelMessagesBlock+4
a381 1
      [ ZeroPage <> 0
a382 1
      ]
d423 2
a424 2
        LDR     r2, =ZeroPage                   ; Try our message file before Global.
        LDR     r0, [r2, #KernelMessagesBlock]
d426 1
a426 2
        ADDNE   r0, r2, #KernelMessagesBlock+4
      [ ZeroPage <> 0
a427 1
      ]
@


4.4
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a1521 5
SkipOverNameAndSpaces
        Push    lr
        BL      SkipToSpace
        Pull    lr

d1532 1
a1532 1
SkipToSpace ENTRY "r0"
d1534 3
a1536 3
10      LDRB    r0, [r1], #1
        CMP     r0, #&7F
        CMPNE   r0, #" "        ; Leave r1 -> space or CtrlChar
d1540 1
a1540 1
        MOV     pc, lr
@


4.3
log
@ChocolateSysVars and ChocolateOscli merged from Ursula.

Version 4.84. Tagged as 'Kernel-4_84'
@
text
@d339 1
a339 1
        MOV       r6, pc
d342 1
a342 2
        TEQP      PC, r6         ; restore V state
        MOVNV     r0, r0
d347 1
a347 1
        MOVNES    pc, lr
d594 2
a595 2
        Pull   "R2-R6, lr"
        ORRS    PC, lr, #V_bit
d642 2
a643 1
        BICS   PC, R7, #ARM_CC_Mask
d1533 2
a1534 1
        BICS    pc, lr, #V_bit  ; r0 = first ~space. Can't really fail
d1544 2
a1545 1
        EXITS
d1607 1
a1607 1
CloseR1 ENTRY "r0"
d1834 1
a1834 1
        ORRS    pc, lr, #V_bit
d1847 1
a1847 1
        ORRS    pc, lr, #V_bit
d1860 1
a1860 1
        ORRS    pc, lr, #V_bit
@


4.2
log
@Kernel merged
@
text
@d54 5
d86 141
@


4.2.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d204 1
d208 5
d268 1
d270 3
d293 1
d307 15
d446 1
d448 1
d552 1
d554 3
d609 1
d611 3
d654 1
d656 3
d972 1
d977 6
d1009 1
d1013 5
d1195 1
d1197 1
d1222 1
d1224 1
d1316 1
d1318 3
d1681 1
d1685 1
d1694 1
d1698 1
d1707 1
d1711 1
@


4.2.2.2
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a53 5
  [ Oscli_HashedCommands
;
;***WARNING*** if commands are added or changed, SysCoHashedCmdTab MUST be updated correspondingly
;
  ]
a80 130

  [ Oscli_HashedCommands
;
; - Hashing table is 32 wide
; - Hashing function is: 
;
;      hash = (sum of all chars of command, each upper-cased) & 0x1f
;
; - Order of commands in each hashed list is alphabetical

; Table MUST be reorganised if hashing function changed, or command set altered
;
           ALIGN
SysCoHashedCmdTab
;
;     ! 0,"SysCoHashedCmdTab at ":CC::STR:(SysCoHashedCmdTab)
;
;First, 1 word per table entry, giving offset to hashed list on each hash value
;
           DCD       SHC_hash00 - SysCommsModule
           DCD       0                            ;null list on this hash value
           DCD       SHC_hash02 - SysCommsModule
           DCD       SHC_hash03 - SysCommsModule
           DCD       0
           DCD       SHC_hash05 - SysCommsModule
           DCD       SHC_hash06 - SysCommsModule
           DCD       0
           DCD       0
           DCD       SHC_hash09 - SysCommsModule
           DCD       SHC_hash0A - SysCommsModule
           DCD       0
           DCD       0
           DCD       SHC_hash0D - SysCommsModule
           DCD       SHC_hash0E - SysCommsModule
           DCD       SHC_hash0F - SysCommsModule
           DCD       SHC_hash10 - SysCommsModule
           DCD       0
           DCD       0
           DCD       SHC_hash13 - SysCommsModule
           DCD       SHC_hash14 - SysCommsModule
           DCD       0
           DCD       SHC_hash16 - SysCommsModule
           DCD       0
           DCD       SHC_hash18 - SysCommsModule
           DCD       0
           DCD       0
           DCD       0
           DCD       SHC_hash1C - SysCommsModule
           DCD       0
           DCD       SHC_hash1E - SysCommsModule
           DCD       0
;
; Now the hashed lists
;
SHC_hash00
        Command Load,    2,  1, International_Help ; Fudge order for compatibility (*L.)
        =   0
        ALIGN
SHC_hash02
        Command Type,    3,  1, International_Help ; -file fred -tabexpand
        =   0
        ALIGN
SHC_hash03
        Command Quit,    0,  0, International_Help
        =   0
        ALIGN
SHC_hash05
        Command Exec,    1,  0, International_Help
        =   0
        ALIGN
SHC_hash06
        Command Shadow,  1,  0, International_Help
        =   0
        ALIGN
SHC_hash09
        Command Help,  255,  0, International_Help
        Command Key,   255,  1, International_Help
        =   0
        ALIGN
SHC_hash0A
        Command SpoolOn, 1,  0, International_Help
        Command TV,      3,  0, International_Help
        =   0
        ALIGN
SHC_hash0D
        Command Print,   1,  1, International_Help
        Command Spool,   1,  0, International_Help
        =   0
        ALIGN
SHC_hash0E
        Command Remove,  1,  1, International_Help
        =   0
        ALIGN
SHC_hash0F
        Command Save,    6,  2, International_Help ; *SAVE Fn St + Le Ex Lo (compatibility)
        =   0
        ALIGN
SHC_hash10
        Command Build,   1,  1, International_Help
        =   0
        ALIGN
SHC_hash13
        Command Delete,  1,  1, International_Help
        Command Opt,     2,  0, International_Help
        =   0
        ALIGN
SHC_hash14
        Command Create,  4,  1, International_Help
        =   0
        ALIGN
SHC_hash16
        Command Close,   0,  0, International_Help
        Command Dump,    3,  1, International_Help
        Command GO,    255,  0, International_Help
        =   0
        ALIGN
SHC_hash18
        Command Append,  1,  1, International_Help
        =   0
        ALIGN
SHC_hash1C
        Command List,    3,  1, International_Help
        =   0
        ALIGN
SHC_hash1E
        Command FX,      5,  1, International_Help    ; 1-3 parms, but up to 2 commas may be there
        =   0
        ALIGN

  ] ;Oscli_HashedCommands
@


4.2.2.3
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a214 11
;now a small table to fudge around need for old syntax for *fx etc (ie.
;allow zero spaces between command and first, numeric, parameter)
;
SHC_fudgeulike
        Command FX,      5,  1, International_Help    ; 1-3 parms, but up to 2 commas may be there
        Command Key,   255,  1, International_Help
        Command Opt,     2,  0, International_Help
        Command TV,      3,  0, International_Help
        =   0
        ALIGN

a862 3
  [ LongCommandLines
        MOV     R3, #LongCLISize
  |
a863 1
  ]
@


4.2.2.4
log
@ - reestablish ownership of RAMFS dynamic area by kernel; this may be
   switched out again later, if new RAMFS takes over ownership
 - make ChangeDynamicArea allow re-entrancy slightly earlier on a shrink;
   now allows re-enter after page moves but before calling any post-shrink
   handler; this should fix problem with RAMFS and new FileCore (that now
   itself uses dynamic areas); needs testing once we pull a ROM together
 - Fix following bugs:
    - (new) kernel was keeping modules on active service chains during
      call to their finalise, now temporarily delinks them, as the API
      says it should; symptom eg. Zap 1.39 fails to quit (module Zap)
    - (longstanding) *help in a taskwindow was very dangerous (eg quit
      window, run other *help, start new window can all take out OS,
      by fundamentally cracking MessageTrans); fix: *help now does not
      keep MessageTrans descriptor on SVC stack (swapped out on pre-empt),
      now has re-entrancy guard, gives 'busy' error if reentered; minor
      infelicity is that busy message may be given on new *help after
      abandoning old one in taskwindow, but the next *help will work
    - (longstanding) *time could occasionally give a scrambled message on
      first call in a taskwindow (caused by multiple use of a general
      buffer)
@
text
@d505 1
d515 1
a515 16

        SWI     XOS_ReadEscapeState
        BCS     helpescape

        ;protect against re-entrancy (from several pre-emptive task windows)
        Push    "r2-r3"
        LDR     r2,=Help_guard
        LDR     r3,[r2]
        TST     r3,#1                  ;bit 0 flags msg descriptor in use
        Pull    "r2-r3",NE
        BNE     help_busyfail
        MOV     r3,#1
        STR     r3,[r2]
        Pull    "r2-r3"

        LDR     r0,=Help_msgdescr
d517 1
a517 1
        BVS     %FT30
d519 1
a519 1
        LDR     r1, [sp, #1 * 4]
d523 3
a525 2
        SWIVC   XMessageTrans_Dictionary
        BVS     %FT30
d528 1
a528 1
        LDR     r2, [sp, #3 * 4]
d530 1
a530 2
        SWIVC   XOS_NewLine
        BVS     %FT30
d532 1
a532 1
        LDR     r2, [sp, #2 * 4]
d536 1
a536 1
        LDR     r1, [sp, #1 * 4]
d540 3
a542 2
        SWIVC   XMessageTrans_Dictionary
        BVS     %FT30
d545 6
a550 8
        LDR     r2, [sp, #3 * 4]
        SWI     XOS_PrettyPrint
        SWIVC   XOS_NewLine
30      BL      help_closemsgfile
        LDR     r1, =Help_guard
        MOV     r2, #0
        STR     r2,[r1]
        STRVS   r0, [stack]
a551 1
        Pull    "R2-R6, PC", VS
a563 27
helpescape
        BL      AckEscape
        STRVS   r0,[stack]
        Pull    "r0-r3"
        Pull    "R2-R6, PC"

;slightly nasty to other help task to shut descriptor, but ensures we cannot be locked
;out forever (eg. premature kill of help in task window leaves descriptor open)
help_busyfail
        ASSERT  Help_msgdescr = Help_guard+4
        LDR     r1,=Help_guard
        LDR     r2,[r1]
        TST     r2,#1
        ADDNE   r0,r1,#4
        SWINE   XMessageTrans_CloseFile
        MOV     r2,#0
        STR     r2,[r1]
        ADR     r0,help_busyfail_error
        SETV 
        STR     r0,[stack]
        Pull    "r0-r3"
        Pull    "R2-R6, PC"
help_busyfail_error
        DCD     0
        DCB     "sorry, *help is (or was) busy",0
        ALIGN

a589 6

help_closemsgfile ROUT
        Push    "r0,lr"
        MOVS    r0, r6
        SWINE   XMessageTrans_CloseFile ;ignore error
        Pull    "r0,pc",,^              ;preserve any current error
@


4.2.2.4.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d1330 1
d1332 1
@


4.2.2.5
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d1330 1
d1332 1
@


4.1
log
@Initial revision
@
text
@d1184 3
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a1183 3
 [ StrongARM
	ORRVC	r3, r3, #1<<31
 ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

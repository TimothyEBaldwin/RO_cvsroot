head	4.31;
access;
symbols
	Kernel-6_14:4.31
	Kernel-6_01-3:4.28
	Kernel-6_13:4.31
	Kernel-6_12:4.31
	Kernel-6_11:4.31
	Kernel-6_10:4.30
	Kernel-6_09:4.30
	Kernel-6_08-4_129_2_10:4.23.2.4
	Kernel-6_08-4_129_2_9:4.23.2.4
	Kernel-6_08:4.30
	Kernel-6_07:4.29
	Kernel-6_06:4.28
	Kernel-6_05-4_129_2_8:4.23.2.3
	Kernel-6_05:4.28
	Kernel-6_04:4.28
	Kernel-6_03:4.28
	Kernel-6_01-2:4.28
	Kernel-6_01-4_146_2_1:4.28
	Kernel-6_02:4.28
	Kernel-6_01-1:4.28
	Kernel-6_01:4.28
	Kernel-6_00:4.28
	Kernel-5_99:4.28
	Kernel-5_98:4.28
	Kernel-5_97-4_129_2_7:4.23.2.3
	Kernel-5_97:4.28
	Kernel-5_96:4.28
	Kernel-5_95:4.28
	Kernel-5_94:4.27
	Kernel-5_93:4.27
	Kernel-5_92:4.27
	Kernel-5_91:4.27
	Kernel-5_90:4.26
	Kernel-5_89-4_129_2_6:4.23.2.2
	Kernel-5_89:4.25
	Kernel-5_88-4_129_2_5:4.23.2.1
	Kernel-5_88-4_129_2_4:4.23.2.1
	Kernel-5_88:4.24
	Kernel-5_87:4.24
	Kernel-5_86-4_129_2_3:4.23
	Kernel-5_86-4_129_2_2:4.23
	Kernel-5_86-4_129_2_1:4.23
	Kernel-5_86:4.23
	SMP:4.23.0.2
	SMP_bp:4.23
	Kernel-5_85:4.23
	Kernel-5_54-1:4.21
	Kernel-5_84:4.23
	Kernel-5_83:4.23
	Kernel-5_82:4.23
	Kernel-5_81:4.23
	Kernel-5_80:4.23
	Kernel-5_79:4.23
	Kernel-5_78:4.23
	Kernel-5_77:4.23
	Kernel-5_76:4.23
	Kernel-5_75:4.23
	Kernel-5_74:4.23
	Kernel-5_73:4.23
	Kernel-5_72:4.23
	Kernel-5_71:4.23
	Kernel-5_70:4.22
	Kernel-5_69:4.22
	Kernel-5_68:4.22
	Kernel-5_67:4.22
	Kernel-5_66:4.22
	Kernel-5_65:4.22
	Kernel-5_64:4.22
	Kernel-5_63:4.22
	Kernel-5_62:4.22
	Kernel-5_61:4.22
	Kernel-5_60:4.22
	Kernel-5_59:4.22
	Kernel-5_58:4.22
	Kernel-5_57:4.22
	Kernel-5_56:4.22
	Kernel-5_55:4.22
	Kernel-5_54:4.21
	Kernel-5_53:4.20
	Kernel-5_52:4.20
	Kernel-5_51:4.20
	Kernel-5_50:4.19
	Kernel-5_49:4.18
	HAL_merge:4.16.2.52
	Kernel-5_48:4.17
	Kernel-5_35-4_79_2_327:4.16.2.52
	Kernel-5_35-4_79_2_326:4.16.2.52
	Kernel-5_35-4_79_2_325:4.16.2.52
	Kernel-5_35-4_79_2_324:4.16.2.52
	Kernel-5_35-4_79_2_323:4.16.2.52
	Kernel-5_35-4_79_2_322:4.16.2.52
	Kernel-5_35-4_79_2_321:4.16.2.52
	Kernel-5_35-4_79_2_320:4.16.2.52
	Kernel-5_35-4_79_2_319:4.16.2.52
	Kernel-5_35-4_79_2_318:4.16.2.52
	Kernel-5_35-4_79_2_317:4.16.2.52
	Kernel-5_35-4_79_2_316:4.16.2.52
	Kernel-5_35-4_79_2_315:4.16.2.52
	Kernel-5_35-4_79_2_314:4.16.2.52
	Kernel-5_35-4_79_2_313:4.16.2.52
	Kernel-5_35-4_79_2_312:4.16.2.52
	Kernel-5_35-4_79_2_311:4.16.2.52
	Kernel-5_35-4_79_2_310:4.16.2.52
	Kernel-5_35-4_79_2_309:4.16.2.52
	Kernel-5_35-4_79_2_308:4.16.2.52
	Kernel-5_35-4_79_2_307:4.16.2.52
	Kernel-5_35-4_79_2_306:4.16.2.52
	Kernel-5_35-4_79_2_305:4.16.2.52
	Kernel-5_35-4_79_2_304:4.16.2.52
	Kernel-5_35-4_79_2_303:4.16.2.52
	Kernel-5_35-4_79_2_302:4.16.2.52
	Kernel-5_35-4_79_2_301:4.16.2.52
	Kernel-5_35-4_79_2_300:4.16.2.52
	Kernel-5_35-4_79_2_299:4.16.2.52
	Kernel-5_35-4_79_2_298:4.16.2.52
	Kernel-5_35-4_79_2_297:4.16.2.52
	Kernel-5_35-4_79_2_296:4.16.2.52
	Kernel-5_35-4_79_2_295:4.16.2.52
	Kernel-5_35-4_79_2_294:4.16.2.52
	Kernel-5_35-4_79_2_293:4.16.2.52
	Kernel-5_35-4_79_2_292:4.16.2.52
	Kernel-5_35-4_79_2_291:4.16.2.52
	Kernel-5_35-4_79_2_290:4.16.2.52
	Kernel-5_35-4_79_2_289:4.16.2.52
	Kernel-5_35-4_79_2_288:4.16.2.52
	Kernel-5_35-4_79_2_287:4.16.2.52
	Kernel-5_35-4_79_2_286:4.16.2.52
	Kernel-5_35-4_79_2_285:4.16.2.52
	Kernel-5_35-4_79_2_284:4.16.2.52
	Kernel-5_35-4_79_2_283:4.16.2.51
	Kernel-5_35-4_79_2_282:4.16.2.51
	Kernel-5_35-4_79_2_281:4.16.2.51
	Kernel-5_35-4_79_2_280:4.16.2.51
	Kernel-5_35-4_79_2_279:4.16.2.51
	Kernel-5_35-4_79_2_278:4.16.2.51
	Kernel-5_35-4_79_2_277:4.16.2.51
	Kernel-5_35-4_79_2_276:4.16.2.51
	Kernel-5_35-4_79_2_275:4.16.2.51
	Kernel-5_35-4_79_2_274:4.16.2.51
	Kernel-5_35-4_79_2_273:4.16.2.51
	Kernel-5_35-4_79_2_272:4.16.2.51
	Kernel-5_35-4_79_2_271:4.16.2.51
	Kernel-5_35-4_79_2_270:4.16.2.51
	Kernel-5_35-4_79_2_269:4.16.2.51
	Kernel-5_35-4_79_2_268:4.16.2.51
	Kernel-5_35-4_79_2_267:4.16.2.51
	Kernel-5_35-4_79_2_266:4.16.2.51
	Kernel-5_35-4_79_2_265:4.16.2.51
	Kernel-5_35-4_79_2_264:4.16.2.51
	Kernel-5_35-4_79_2_263:4.16.2.51
	Kernel-5_35-4_79_2_262:4.16.2.51
	Kernel-5_35-4_79_2_261:4.16.2.51
	Kernel-5_35-4_79_2_260:4.16.2.51
	Kernel-5_35-4_79_2_259:4.16.2.51
	Kernel-5_35-4_79_2_258:4.16.2.51
	Kernel-5_35-4_79_2_257:4.16.2.51
	Kernel-5_35-4_79_2_256:4.16.2.51
	Kernel-5_35-4_79_2_255:4.16.2.51
	Kernel-5_35-4_79_2_254:4.16.2.51
	Kernel-5_35-4_79_2_253:4.16.2.51
	Kernel-5_35-4_79_2_252:4.16.2.50
	Kernel-5_35-4_79_2_251:4.16.2.49
	Kernel-5_35-4_79_2_250:4.16.2.49
	Kernel-5_35-4_79_2_249:4.16.2.49
	Kernel-5_35-4_79_2_248:4.16.2.49
	Kernel-5_35-4_79_2_247:4.16.2.49
	Kernel-5_35-4_79_2_246:4.16.2.49
	Kernel-5_35-4_79_2_245:4.16.2.49
	Kernel-5_35-4_79_2_244:4.16.2.49
	Kernel-5_35-4_79_2_243:4.16.2.49
	Kernel-5_35-4_79_2_242:4.16.2.49
	Kernel-5_35-4_79_2_241:4.16.2.49
	Kernel-5_35-4_79_2_240:4.16.2.49
	Kernel-5_35-4_79_2_239:4.16.2.49
	Kernel-5_35-4_79_2_238:4.16.2.49
	Kernel-5_35-4_79_2_237:4.16.2.49
	Kernel-5_35-4_79_2_236:4.16.2.49
	Kernel-5_35-4_79_2_235:4.16.2.49
	Kernel-5_35-4_79_2_234:4.16.2.49
	Kernel-5_35-4_79_2_233:4.16.2.48
	Kernel-5_35-4_79_2_232:4.16.2.48
	Kernel-5_35-4_79_2_231:4.16.2.48
	Kernel-5_35-4_79_2_230:4.16.2.48
	Kernel-5_35-4_79_2_229:4.16.2.48
	Kernel-5_35-4_79_2_228:4.16.2.48
	Kernel-5_35-4_79_2_227:4.16.2.48
	Kernel-5_35-4_79_2_226:4.16.2.48
	Kernel-5_35-4_79_2_225:4.16.2.48
	Kernel-5_35-4_79_2_224:4.16.2.47
	Kernel-5_35-4_79_2_223:4.16.2.47
	Kernel-5_35-4_79_2_222:4.16.2.47
	Kernel-5_35-4_79_2_221:4.16.2.47
	Kernel-5_35-4_79_2_220:4.16.2.47
	Kernel-5_35-4_79_2_219:4.16.2.47
	Kernel-5_35-4_79_2_218:4.16.2.47
	Kernel-5_35-4_79_2_217:4.16.2.47
	Kernel-5_35-4_79_2_216:4.16.2.47
	Kernel-5_35-4_79_2_215:4.16.2.47
	Kernel-5_35-4_79_2_214:4.16.2.47
	Kernel-5_35-4_79_2_213:4.16.2.47
	Kernel-5_35-4_79_2_212:4.16.2.47
	Kernel-5_35-4_79_2_211:4.16.2.47
	Kernel-5_35-4_79_2_210:4.16.2.47
	Kernel-5_35-4_79_2_209:4.16.2.47
	Kernel-5_35-4_79_2_208:4.16.2.47
	Kernel-5_35-4_79_2_207:4.16.2.47
	Kernel-5_35-4_79_2_206:4.16.2.47
	Kernel-5_35-4_79_2_205:4.16.2.47
	Kernel-5_35-4_79_2_204:4.16.2.47
	Kernel-5_35-4_79_2_203:4.16.2.47
	Kernel-5_35-4_79_2_202:4.16.2.47
	Kernel-5_35-4_79_2_201:4.16.2.46
	Kernel-5_35-4_79_2_200:4.16.2.46
	Kernel-5_35-4_79_2_199:4.16.2.45
	Kernel-5_35-4_79_2_198:4.16.2.45
	Kernel-5_35-4_79_2_197:4.16.2.45
	Kernel-5_35-4_79_2_196:4.16.2.45
	Kernel-5_35-4_79_2_195:4.16.2.45
	Kernel-5_35-4_79_2_194:4.16.2.45
	Kernel-5_35-4_79_2_193:4.16.2.45
	Kernel-5_35-4_79_2_192:4.16.2.45
	Kernel-5_35-4_79_2_191:4.16.2.45
	Kernel-5_35-4_79_2_190:4.16.2.45
	Kernel-5_35-4_79_2_189:4.16.2.45
	Kernel-5_35-4_79_2_188:4.16.2.45
	Kernel-5_35-4_79_2_187:4.16.2.45
	Kernel-5_35-4_79_2_186:4.16.2.45
	Kernel-5_35-4_79_2_185:4.16.2.44
	Kernel-5_35-4_79_2_184:4.16.2.44
	Kernel-5_35-4_79_2_183:4.16.2.44
	Kernel-5_35-4_79_2_182:4.16.2.44
	Kernel-5_35-4_79_2_181:4.16.2.44
	Kernel-5_35-4_79_2_180:4.16.2.44
	Kernel-5_35-4_79_2_179:4.16.2.43
	Kernel-5_35-4_79_2_178:4.16.2.43
	Kernel-5_35-4_79_2_177:4.16.2.43
	Kernel-5_35-4_79_2_176:4.16.2.43
	Kernel-5_35-4_79_2_175:4.16.2.43
	Kernel-5_35-4_79_2_174:4.16.2.43
	Kernel-5_35-4_79_2_173:4.16.2.43
	Kernel-5_35-4_79_2_172:4.16.2.43
	Kernel-5_35-4_79_2_171:4.16.2.42
	Kernel-5_35-4_79_2_170:4.16.2.41
	Kernel-5_35-4_79_2_169:4.16.2.41
	Kernel-5_35-4_79_2_168:4.16.2.40
	Kernel-5_35-4_79_2_167:4.16.2.39
	Kernel-5_35-4_79_2_166:4.16.2.38
	Kernel-5_35-4_79_2_165:4.16.2.38
	RPi_merge:4.16.2.35.2.4
	Kernel-5_35-4_79_2_147_2_23:4.16.2.35.2.4
	Kernel-5_35-4_79_2_147_2_22:4.16.2.35.2.3
	Kernel-5_35-4_79_2_147_2_21:4.16.2.35.2.3
	Kernel-5_35-4_79_2_147_2_20:4.16.2.35.2.3
	Kernel-5_35-4_79_2_147_2_19:4.16.2.35.2.2
	Kernel-5_35-4_79_2_147_2_18:4.16.2.35.2.2
	Kernel-5_35-4_79_2_164:4.16.2.37
	Kernel-5_35-4_79_2_163:4.16.2.37
	Kernel-5_35-4_79_2_147_2_17:4.16.2.35.2.2
	Kernel-5_35-4_79_2_147_2_16:4.16.2.35.2.2
	Kernel-5_35-4_79_2_147_2_15:4.16.2.35.2.2
	Kernel-5_35-4_79_2_162:4.16.2.37
	Kernel-5_35-4_79_2_161:4.16.2.37
	Kernel-5_35-4_79_2_147_2_14:4.16.2.35.2.2
	Kernel-5_35-4_79_2_147_2_13:4.16.2.35.2.1
	Kernel-5_35-4_79_2_160:4.16.2.37
	Kernel-5_35-4_79_2_159:4.16.2.37
	Kernel-5_35-4_79_2_158:4.16.2.37
	Kernel-5_35-4_79_2_157:4.16.2.37
	Kernel-5_35-4_79_2_156:4.16.2.36
	Kernel-5_35-4_79_2_147_2_12:4.16.2.35.2.1
	Kernel-5_35-4_79_2_147_2_11:4.16.2.35.2.1
	Kernel-5_35-4_79_2_155:4.16.2.36
	Kernel-5_35-4_79_2_147_2_10:4.16.2.35.2.1
	Kernel-5_35-4_79_2_154:4.16.2.36
	Kernel-5_35-4_79_2_153:4.16.2.35
	Kernel-5_35-4_79_2_147_2_9:4.16.2.35.2.1
	Kernel-5_35-4_79_2_152:4.16.2.35
	Kernel-5_35-4_79_2_151:4.16.2.35
	Kernel-5_35-4_79_2_147_2_8:4.16.2.35.2.1
	Kernel-5_35-4_79_2_147_2_7:4.16.2.35.2.1
	Kernel-5_35-4_79_2_150:4.16.2.35
	Kernel-5_35-4_79_2_147_2_6:4.16.2.35.2.1
	Kernel-5_35-4_79_2_147_2_5:4.16.2.35.2.1
	Kernel-5_35-4_79_2_149:4.16.2.35
	Kernel-5_35-4_79_2_147_2_4:4.16.2.35.2.1
	Kernel-5_35-4_79_2_147_2_3:4.16.2.35.2.1
	Kernel-5_35-4_79_2_148:4.16.2.35
	Kernel-5_35-4_79_2_147_2_2:4.16.2.35.2.1
	Kernel-5_35-4_79_2_147_2_1:4.16.2.35.2.1
	RPi:4.16.2.35.0.2
	RPi_bp:4.16.2.35
	Kernel-5_35-4_79_2_98_2_52_2_1:4.16.2.28.2.11.2.1
	alees_Kernel_dev:4.16.2.28.2.11.0.2
	alees_Kernel_dev_bp:4.16.2.28.2.11
	Kernel-5_35-4_79_2_147:4.16.2.35
	Kernel-5_35-4_79_2_146:4.16.2.34
	Kernel-5_35-4_79_2_145:4.16.2.34
	Kernel-5_35-4_79_2_144:4.16.2.34
	Kernel-5_35-4_79_2_143:4.16.2.34
	Kernel-5_35-4_79_2_142:4.16.2.34
	Kernel-5_35-4_79_2_141:4.16.2.34
	Kernel-5_35-4_79_2_140:4.16.2.34
	Kernel-5_35-4_79_2_139:4.16.2.34
	Kernel-5_35-4_79_2_138:4.16.2.33
	Kernel-5_35-4_79_2_137:4.16.2.32
	Kernel-5_35-4_79_2_136:4.16.2.32
	Kernel-5_35-4_79_2_135:4.16.2.32
	Kernel-5_35-4_79_2_134:4.16.2.32
	Kernel-5_35-4_79_2_133:4.16.2.32
	Kernel-5_35-4_79_2_132:4.16.2.31
	Kernel-5_35-4_79_2_131:4.16.2.31
	Kernel-5_35-4_79_2_130:4.16.2.31
	Kernel-5_35-4_79_2_129:4.16.2.31
	Kernel-5_35-4_79_2_128:4.16.2.31
	Kernel-5_35-4_79_2_127:4.16.2.31
	Kernel-5_35-4_79_2_126:4.16.2.31
	Kernel-5_35-4_79_2_125:4.16.2.31
	Kernel-5_35-4_79_2_124:4.16.2.30
	Kernel-5_35-4_79_2_123:4.16.2.30
	Cortex_merge:4.16.2.28.2.11
	Kernel-5_35-4_79_2_122:4.16.2.29
	Kernel-5_35-4_79_2_98_2_54:4.16.2.28.2.11
	Kernel-5_35-4_79_2_98_2_53:4.16.2.28.2.11
	Kernel-5_35-4_79_2_98_2_52:4.16.2.28.2.11
	Kernel-5_35-4_79_2_98_2_51:4.16.2.28.2.11
	Kernel-5_35-4_79_2_98_2_50:4.16.2.28.2.10
	Kernel-5_35-4_79_2_98_2_49:4.16.2.28.2.9
	Kernel-5_35-4_79_2_98_2_48:4.16.2.28.2.9
	Kernel-5_35-4_79_2_121:4.16.2.29
	Kernel-5_35-4_79_2_98_2_47:4.16.2.28.2.8
	Kernel-5_35-4_79_2_120:4.16.2.29
	Kernel-5_35-4_79_2_98_2_46:4.16.2.28.2.8
	Kernel-5_35-4_79_2_119:4.16.2.29
	Kernel-5_35-4_79_2_98_2_45:4.16.2.28.2.8
	Kernel-5_35-4_79_2_98_2_44:4.16.2.28.2.8
	Kernel-5_35-4_79_2_118:4.16.2.29
	Kernel-5_35-4_79_2_98_2_43:4.16.2.28.2.8
	Kernel-5_35-4_79_2_117:4.16.2.29
	Kernel-5_35-4_79_2_116:4.16.2.29
	Kernel-5_35-4_79_2_98_2_42:4.16.2.28.2.8
	Kernel-5_35-4_79_2_115:4.16.2.29
	Kernel-5_35-4_79_2_98_2_41:4.16.2.28.2.8
	Kernel-5_35-4_79_2_98_2_40:4.16.2.28.2.7
	Kernel-5_35-4_79_2_114:4.16.2.28
	Kernel-5_35-4_79_2_98_2_39:4.16.2.28.2.7
	Kernel-5_35-4_79_2_98_2_38:4.16.2.28.2.7
	Kernel-5_35-4_79_2_113:4.16.2.28
	Kernel-5_35-4_79_2_112:4.16.2.28
	Kernel-5_35-4_79_2_98_2_37:4.16.2.28.2.7
	Kernel-5_35-4_79_2_98_2_36:4.16.2.28.2.7
	Kernel-5_35-4_79_2_98_2_35:4.16.2.28.2.7
	Kernel-5_35-4_79_2_98_2_34:4.16.2.28.2.7
	Kernel-5_35-4_79_2_98_2_33:4.16.2.28.2.7
	Kernel-5_35-4_79_2_98_2_32:4.16.2.28.2.6
	Kernel-5_35-4_79_2_98_2_31:4.16.2.28.2.5
	Kernel-5_35-4_79_2_98_2_30:4.16.2.28.2.5
	Kernel-5_35-4_79_2_98_2_29:4.16.2.28.2.5
	Kernel-5_35-4_79_2_98_2_28:4.16.2.28.2.5
	Kernel-5_35-4_79_2_98_2_27:4.16.2.28.2.5
	Kernel-5_35-4_79_2_98_2_26:4.16.2.28.2.4
	Kernel-5_35-4_79_2_111:4.16.2.28
	Kernel-5_35-4_79_2_98_2_25:4.16.2.28.2.3
	Kernel-5_35-4_79_2_98_2_24:4.16.2.28.2.3
	Kernel-5_35-4_79_2_98_2_23:4.16.2.28.2.3
	Kernel-5_35-4_79_2_110:4.16.2.28
	Kernel-5_35-4_79_2_98_2_22:4.16.2.28.2.3
	Kernel-5_35-4_79_2_109:4.16.2.28
	Kernel-5_35-4_79_2_98_2_21:4.16.2.28.2.3
	Kernel-5_35-4_79_2_98_2_20:4.16.2.28.2.3
	Kernel-5_35-4_79_2_108:4.16.2.28
	Kernel-5_35-4_79_2_107:4.16.2.28
	Kernel-5_35-4_79_2_98_2_19:4.16.2.28.2.3
	Kernel-5_35-4_79_2_98_2_18:4.16.2.28.2.3
	Kernel-5_35-4_79_2_98_2_17:4.16.2.28.2.2
	Kernel-5_35-4_79_2_98_2_16:4.16.2.28.2.2
	Kernel-5_35-4_79_2_98_2_15:4.16.2.28.2.2
	Kernel-5_35-4_79_2_106:4.16.2.28
	Kernel-5_35-4_79_2_105:4.16.2.28
	Kernel-5_35-4_79_2_104:4.16.2.28
	Kernel-5_35-4_79_2_98_2_14:4.16.2.28.2.2
	Kernel-5_35-4_79_2_98_2_13:4.16.2.28.2.2
	Kernel-5_35-4_79_2_98_2_12:4.16.2.28.2.2
	Kernel-5_35-4_79_2_98_2_11:4.16.2.28.2.2
	Kernel-5_35-4_79_2_98_2_10:4.16.2.28.2.1
	Kernel-5_35-4_79_2_98_2_9:4.16.2.28.2.1
	Kernel-5_35-4_79_2_103:4.16.2.28
	Kernel-5_35-4_79_2_102:4.16.2.28
	Kernel-5_35-4_79_2_98_2_8:4.16.2.28.2.1
	Kernel-5_35-4_79_2_98_2_7:4.16.2.28.2.1
	Kernel-5_35-4_79_2_98_2_6:4.16.2.28.2.1
	Kernel-5_35-4_79_2_98_2_5:4.16.2.28.2.1
	Kernel-5_35-4_79_2_98_2_4:4.16.2.28.2.1
	Kernel-5_35-4_79_2_101:4.16.2.28
	Kernel-5_35-4_79_2_100:4.16.2.28
	Kernel-5_35-4_79_2_99:4.16.2.28
	Kernel-5_35-4_79_2_98_2_3:4.16.2.28.2.1
	Kernel-5_35-4_79_2_98_2_2:4.16.2.28
	Kernel-5_35-4_79_2_98_2_1:4.16.2.28
	Cortex:4.16.2.28.0.2
	Cortex_bp:4.16.2.28
	Kernel-5_35-4_79_2_98:4.16.2.28
	Kernel-5_35-4_79_2_97:4.16.2.28
	Kernel-5_35-4_79_2_96:4.16.2.28
	Kernel-5_35-4_79_2_95:4.16.2.28
	Kernel-5_35-4_79_2_94:4.16.2.28
	Kernel-5_35-4_79_2_93:4.16.2.28
	Kernel-5_35-4_79_2_92:4.16.2.28
	Kernel-5_35-4_79_2_91:4.16.2.28
	Kernel-5_35-4_79_2_90:4.16.2.28
	Kernel-5_35-4_79_2_89:4.16.2.28
	Kernel-5_35-4_79_2_88:4.16.2.28
	Kernel-5_35-4_79_2_87:4.16.2.28
	Kernel-5_35-4_79_2_86:4.16.2.28
	Kernel-5_35-4_79_2_85:4.16.2.28
	Kernel-5_35-4_79_2_84:4.16.2.28
	Kernel-5_35-4_79_2_83:4.16.2.28
	Kernel-5_35-4_79_2_82:4.16.2.28
	Kernel-5_35-4_79_2_81:4.16.2.28
	Kernel-5_35-4_79_2_80:4.16.2.28
	Kernel-5_35-4_79_2_79:4.16.2.28
	Kernel-5_35-4_79_2_78:4.16.2.28
	Kernel-5_35-4_79_2_77:4.16.2.28
	RO_5_07:4.16.2.28
	Kernel-5_35-4_79_2_76:4.16.2.28
	Kernel-5_35-4_79_2_75:4.16.2.28
	Kernel-5_35-4_79_2_74:4.16.2.28
	Kernel-5_35-4_79_2_73:4.16.2.28
	Kernel-5_35-4_79_2_72:4.16.2.28
	Kernel-5_35-4_79_2_71:4.16.2.28
	Kernel-5_35-4_79_2_70:4.16.2.27
	Kernel-5_35-4_79_2_69:4.16.2.27
	Kernel-5_35-4_79_2_68:4.16.2.27
	Kernel-5_35-4_79_2_67:4.16.2.27
	Kernel-5_35-4_79_2_66:4.16.2.27
	Kernel-5_35-4_79_2_65:4.16.2.26
	Kernel-5_35-4_79_2_64:4.16.2.26
	Kernel-5_35-4_79_2_63:4.16.2.26
	Kernel-5_35-4_79_2_62:4.16.2.26
	Kernel-5_35-4_79_2_61:4.16.2.26
	Kernel-5_35-4_79_2_59:4.16.2.26
	Kernel-5_35-4_79_2_58:4.16.2.25
	Kernel-5_35-4_79_2_57:4.16.2.24
	Kernel-5_35-4_79_2_56:4.16.2.24
	Kernel-5_35-4_79_2_55:4.16.2.23
	Kernel-5_35-4_79_2_54:4.16.2.22
	Kernel-5_35-4_79_2_53:4.16.2.22
	Kernel-5_35-4_79_2_52:4.16.2.22
	Kernel-5_35-4_79_2_51:4.16.2.22
	Kernel-5_35-4_79_2_50:4.16.2.21
	Kernel-5_35-4_79_2_49:4.16.2.21
	Kernel-5_35-4_79_2_48:4.16.2.20
	Kernel-5_47:4.16
	Kernel-5_46-4_90_2_1:4.16
	nbingham_Kernel_FastNC_dev_bp:4.16
	nbingham_Kernel_FastNC_dev:4.16.0.4
	Kernel-5_46:4.16
	Kernel-5_45:4.16
	Kernel-5_35-4_79_2_47:4.16.2.19
	Kernel-5_35-4_79_2_46:4.16.2.19
	Kernel-5_35-4_79_2_45:4.16.2.19
	Kernel-5_35-4_79_2_44:4.16.2.19
	Kernel-5_35-4_79_2_25_2_2:4.16.2.15
	Kernel-5_35-4_79_2_43:4.16.2.19
	Kernel-5_35-4_79_2_42:4.16.2.19
	Kernel-5_35-4_79_2_41:4.16.2.19
	Kernel-5_35-4_79_2_40:4.16.2.19
	Kernel-5_35-4_79_2_39:4.16.2.19
	Kernel-5_35-4_79_2_38:4.16.2.19
	Kernel-5_35-4_79_2_37:4.16.2.18
	Kernel-5_35-4_79_2_36:4.16.2.17
	Kernel-5_35-4_79_2_35:4.16.2.17
	Kernel-5_35-4_79_2_34:4.16.2.17
	Kernel-5_35-4_79_2_33:4.16.2.17
	Kernel-5_35-4_79_2_32:4.16.2.16
	Kernel-5_44:4.16
	Kernel-5_35-4_79_2_25_2_1:4.16.2.15
	Kernel-5_43:4.16
	Kernel-5_35-4_79_2_31:4.16.2.16
	Kernel-5_35-4_79_2_30:4.16.2.16
	Kernel-5_35-4_79_2_29:4.16.2.15
	Kernel-5_35-4_79_2_28:4.16.2.15
	Kernel-5_35-4_79_2_27:4.16.2.15
	Kernel-5_35-4_79_2_26:4.16.2.15
	Kernel-5_42:4.16
	Kernel-5_41:4.16
	Kernel-5_40:4.16
	Kernel-5_35-4_79_2_25:4.16.2.15
	Kernel-5_35-4_79_2_24:4.16.2.15
	Kernel-5_35-4_79_2_23:4.16.2.15
	Kernel-5_35-4_79_2_22:4.16.2.15
	Kernel-5_35-4_79_2_21:4.16.2.15
	Kernel-5_35-4_79_2_20:4.16.2.15
	Kernel-5_35-4_79_2_19:4.16.2.14
	Kernel-5_35-4_79_2_18:4.16.2.12
	Kernel-5_35-4_79_2_17:4.16.2.12
	Kernel-5_35-4_79_2_16:4.16.2.12
	Kernel-5_35-4_79_2_15:4.16.2.12
	Kernel-5_35-4_79_2_14:4.16.2.12
	Kernel-5_39:4.16
	Kernel-5_13-4_52_2_1:4.12
	Bethany:4.12.0.2
	Kernel-5_38:4.16
	Kernel-5_35-4_79_2_13:4.16.2.11
	Kernel-5_35-4_79_2_12:4.16.2.10
	Kernel-5_35-4_79_2_11:4.16.2.10
	Kernel-5_37:4.16
	Kernel-5_35-4_79_2_10:4.16.2.8
	Kernel-5_35-4_79_2_9:4.16.2.7
	Kernel-5_36:4.16
	Kernel-5_35-4_79_2_8:4.16.2.4
	Kernel-5_35-4_79_2_7:4.16.2.3
	Kernel-5_35-4_79_2_6:4.16.2.3
	Kernel-5_35-4_79_2_5:4.16.2.3
	Kernel-5_35-4_79_2_4:4.16.2.2
	Kernel-5_35-4_79_2_3:4.16.2.2
	Kernel-5_35-4_79_2_2:4.16.2.2
	dellis_autobuild_BaseSW:4.16
	Kernel-5_35-4_79_2_1:4.16.2.1
	HAL:4.16.0.2
	Kernel-5_35:4.16
	Kernel-5_34:4.16
	Kernel-5_33:4.16
	Kernel-5_32:4.16
	Kernel-5_31:4.16
	Kernel-5_30:4.15
	Kernel-5_29:4.15
	Kernel-5_28:4.15
	Kernel-5_27:4.15
	Kernel-5_26:4.15
	Kernel-5_25:4.15
	Kernel-5_24:4.14
	Kernel-5_23:4.13
	Kernel-5_22:4.12
	sbrodie_sedwards_16Mar2000:4.12
	Kernel-5_21:4.12
	Kernel-5_20:4.12
	Kernel-5_19:4.12
	Kernel-5_18:4.12
	Kernel-5_17:4.12
	Kernel-5_16:4.12
	Kernel-5_15:4.12
	Kernel-5_14:4.12
	Kernel-5_13:4.12
	Kernel-5_12:4.12
	Kernel-5_11:4.12
	Kernel-5_10:4.12
	Kernel-5_09:4.12
	Kernel-5_08:4.12
	Kernel-5_07:4.12
	Kernel-5_06:4.12
	Kernel-5_05:4.12
	Kernel-5_04:4.11
	Kernel-5_03:4.11
	Kernel-5_02:4.11
	Kernel-5_01:4.11
	Kernel-5_00:4.11
	Kernel-4_99:4.11
	Kernel-4_98:4.11
	Kernel-4_97:4.10
	Kernel-4_96:4.10
	Kernel-4_95:4.10
	Kernel-4_94:4.10
	Kernel-4_93:4.10
	Kernel-4_92:4.10
	Kernel-4_91:4.10
	Kernel-4_90:4.10
	dcotton_autobuild_BaseSW:4.16
	Kernel-4_89:4.9
	Kernel-4_88:4.9
	Kernel-4_87:4.9
	Kernel-4_86:4.9
	Kernel-4_85:4.8
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.3.2.7.2.1
	Kernel-4_84:4.8
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.3.2.7.2.1
	Ursula_RiscPC_bp:4.3.2.7
	Kernel-4_83:4.8
	Kernel-4_82:4.8
	Kernel-4_81:4.8
	Kernel-4_80:4.8
	Kernel-4_79:4.8
	Kernel-4_78:4.8
	Kernel-4_77:4.8
	Kernel-4_76:4.8
	Kernel-4_75:4.8
	Kernel-4_74:4.8
	Kernel-4_73:4.8
	Kernel-4_72:4.8
	Kernel-4_71:4.8
	Kernel-4_70:4.7
	Kernel-4_69:4.7
	Kernel-4_68:4.6
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.7.2.1
	Ursula_RiscPC:4.3.2.7.0.2
	Kernel-4_63-1_1_2_5:4.1.7.6
	Kernel-4_63-1_1_2_4:4.1.7.6
	Kernel-4_67:4.6
	Kernel-4_66:4.5
	Kernel-4_63-1_1_2_3:4.1.7.6
	Kernel-4_65:4.5
	Ursula_merge:4.3
	Kernel-4_64:4.4
	mstphens_Kernel-3_81:4.3.2.8
	Kernel-4_63-1_1_2_2:4.1.7.6
	nicke_Kernel_4_62:4.1.7.5
	rthornb_UrsulaBuild-19Aug1998:4.3.2.7
	UrsulaBuild_FinalSoftload:4.3.2.7
	rthornb_UrsulaBuild-12Aug1998:4.3.2.7
	aglover_UrsulaBuild-05Aug1998:4.3.2.7
	rthornb_UrsulaBuild-29Jul1998:4.3.2.7
	rthornb_UrsulaBuild-22Jul1998:4.3.2.7
	nturton_v459:4.1.7.4
	nturton_v460:4.1.7.4
	rthornb_UrsulaBuild-15Jul1998:4.3.2.7
	rthornb_UrsulaBuild-07Jul1998:4.3.2.7
	rthornb_UrsulaBuild-17Jun1998:4.3.2.7
	rthornb_UrsulaBuild-03Jun1998:4.3.2.7
	rthornb_UrsulaBuild-27May1998:4.3.2.7
	mstphens_Kernel-3_80:4.3.2.7
	rthornb_UrsulaBuild-21May1998:4.3.2.7
	afrost_Boca-1_2-Beta:4.1.7.4
	rthornb_UrsulaBuild_01May1998:4.3.2.6
	afrost_NC2_Generic:4.1.7.4
	Spinner_B20_2:4.1.7.4
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.4
	Spinner_B17:4.1.7.4
	Spinner_B15:4.1.7.4
	Spinner_B14:4.1.7.4
	Spinner_B13:4.1.7.4
	Spinner_B12:4.1.7.4
	Spinner_B10:4.1.7.4
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.3
	ARTtmp:4.1.7.2.0.2
	Spin_merge:4.1.7.6
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.31
date	2018.07.14.19.02.24;	author jlee;	state Exp;
branches;
next	4.30;
commitid	DsDtaR4YavfJx8KA;

4.30
date	2018.06.30.08.38.53;	author rool;	state Exp;
branches;
next	4.29;
commitid	Bu55fAfHOotJxhIA;

4.29
date	2018.06.16.13.29.42;	author rool;	state Exp;
branches;
next	4.28;
commitid	k3HPMJpkVeRoBvGA;

4.28
date	2018.02.03.18.41.38;	author rsprowson;	state Exp;
branches;
next	4.27;
commitid	VwdJDuE1iBptBrpA;

4.27
date	2017.11.12.18.27.53;	author jlee;	state Exp;
branches;
next	4.26;
commitid	PqiiLEuiKbkbcMeA;

4.26
date	2017.10.07.12.11.51;	author jlee;	state Exp;
branches;
next	4.25;
commitid	afNukMjf0Y8Ug7aA;

4.25
date	2017.09.09.10.35.43;	author rool;	state Exp;
branches;
next	4.24;
commitid	SuZJGVb4fAmIDv6A;

4.24
date	2017.08.19.16.43.35;	author jlee;	state Exp;
branches;
next	4.23;
commitid	43sQ2BtQwXrLlQ3A;

4.23
date	2016.12.13.19.41.12;	author jlee;	state Exp;
branches
	4.23.2.1;
next	4.22;
commitid	XeVhUEC50BLVkRxz;

4.22
date	2016.08.02.22.10.44;	author jlee;	state Exp;
branches;
next	4.21;
commitid	CnQYuUGzojQfrMgz;

4.21
date	2016.07.24.10.50.44;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	x4yCuRzf90zVXyfz;

4.20
date	2016.06.30.20.59.46;	author jlee;	state Exp;
branches;
next	4.19;
commitid	skOEjp3ipLHx6xcz;

4.19
date	2016.06.30.20.42.05;	author jlee;	state Exp;
branches;
next	4.18;
commitid	bDF3DCxdmyMD0xcz;

4.18
date	2016.06.30.20.28.56;	author jlee;	state Exp;
branches;
next	4.17;
commitid	lMnWzoE9eJz3Wwcz;

4.17
date	2016.06.30.20.08.09;	author jlee;	state Exp;
branches;
next	4.16;
commitid	IWoXxARWeuLDOwcz;

4.16
date	2000.08.15.16.47.24;	author sbrodie;	state Exp;
branches
	4.16.2.1;
next	4.15;

4.15
date	2000.05.08.17.05.47;	author sforrest;	state Exp;
branches;
next	4.14;

4.14
date	2000.04.13.10.37.28;	author kbracey;	state Exp;
branches;
next	4.13;

4.13
date	2000.04.04.14.27.32;	author kbracey;	state Exp;
branches;
next	4.12;

4.12
date	99.10.29.16.10.03;	author kbracey;	state Exp;
branches;
next	4.11;

4.11
date	99.10.18.16.15.32;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	99.09.29.17.09.27;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	99.09.16.13.53.36;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.02.25.15.58.03;	author nturton;	state Exp;
branches;
next	4.7;

4.7
date	99.02.09.10.57.40;	author nturton;	state Exp;
branches;
next	4.6;

4.6
date	98.10.30.18.06.59;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	98.10.01.07.42.49;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.09.30.08.42.41;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.05.51.53;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.14.07.16;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.23;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.23.2.1
date	2017.08.31.18.47.03;	author jlee;	state Exp;
branches;
next	4.23.2.2;
commitid	e0d3gZHfENrcEo5A;

4.23.2.2
date	2017.09.10.11.27.22;	author jlee;	state Exp;
branches;
next	4.23.2.3;
commitid	EGooxXrB27MqTD6A;

4.23.2.3
date	2018.02.16.00.01.40;	author jlee;	state Exp;
branches;
next	4.23.2.4;
commitid	L7HYXYTsWSFlZ0rA;

4.23.2.4
date	2018.07.07.13.15.13;	author jlee;	state Exp;
branches;
next	;
commitid	xZcbvu8u7pqAQcJA;

4.16.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.16.2.2;

4.16.2.2
date	2000.10.02.08.52.20;	author kbracey;	state Exp;
branches;
next	4.16.2.3;

4.16.2.3
date	2000.10.05.13.54.49;	author kbracey;	state Exp;
branches;
next	4.16.2.4;

4.16.2.4
date	2000.10.05.16.46.36;	author dellis;	state Exp;
branches;
next	4.16.2.5;

4.16.2.5
date	2000.10.06.09.08.11;	author kbracey;	state Exp;
branches;
next	4.16.2.6;

4.16.2.6
date	2000.10.09.15.59.15;	author kbracey;	state Exp;
branches;
next	4.16.2.7;

4.16.2.7
date	2000.10.10.10.54.17;	author mstephen;	state Exp;
branches;
next	4.16.2.8;

4.16.2.8
date	2000.10.16.11.55.38;	author kbracey;	state Exp;
branches;
next	4.16.2.9;

4.16.2.9
date	2000.10.20.14.58.21;	author kbracey;	state Exp;
branches;
next	4.16.2.10;

4.16.2.10
date	2000.10.20.15.48.04;	author mstephen;	state Exp;
branches;
next	4.16.2.11;

4.16.2.11
date	2000.11.10.15.51.35;	author kbracey;	state Exp;
branches;
next	4.16.2.12;

4.16.2.12
date	2001.01.09.17.17.32;	author mstephen;	state Exp;
branches;
next	4.16.2.13;

4.16.2.13
date	2001.03.07.15.12.57;	author kbracey;	state Exp;
branches;
next	4.16.2.14;

4.16.2.14
date	2001.03.08.17.53.36;	author kbracey;	state Exp;
branches;
next	4.16.2.15;

4.16.2.15
date	2001.03.16.15.30.02;	author kbracey;	state Exp;
branches;
next	4.16.2.16;

4.16.2.16
date	2001.05.17.10.51.11;	author kbracey;	state Exp;
branches;
next	4.16.2.17;

4.16.2.17
date	2001.06.11.11.33.32;	author kbracey;	state Exp;
branches;
next	4.16.2.18;

4.16.2.18
date	2001.06.15.09.39.57;	author mstephen;	state Exp;
branches;
next	4.16.2.19;

4.16.2.19
date	2001.06.18.14.49.45;	author mstephen;	state Exp;
branches;
next	4.16.2.20;

4.16.2.20
date	2002.10.07.17.29.42;	author kbracey;	state Exp;
branches;
next	4.16.2.21;

4.16.2.21
date	2002.10.16.17.23.14;	author bavison;	state Exp;
branches;
next	4.16.2.22;

4.16.2.22
date	2002.11.30.00.31.09;	author bavison;	state Exp;
branches;
next	4.16.2.23;

4.16.2.23
date	2003.01.27.15.25.34;	author kbracey;	state Exp;
branches;
next	4.16.2.24;

4.16.2.24
date	2003.02.21.20.21.55;	author bavison;	state Exp;
branches;
next	4.16.2.25;

4.16.2.25
date	2003.03.02.23.30.46;	author kbracey;	state Exp;
branches;
next	4.16.2.26;

4.16.2.26
date	2003.03.31.09.44.11;	author kbracey;	state Exp;
branches;
next	4.16.2.27;

4.16.2.27
date	2004.05.06.16.02.03;	author kbracey;	state Exp;
branches;
next	4.16.2.28;

4.16.2.28
date	2004.06.25.15.07.13;	author kbracey;	state Exp;
branches
	4.16.2.28.2.1;
next	4.16.2.29;

4.16.2.29
date	2011.07.31.13.48.13;	author jlee;	state Exp;
branches;
next	4.16.2.30;
commitid	o0Go7NdMMK4UrGtv;

4.16.2.30
date	2011.11.26.21.11.16;	author jlee;	state Exp;
branches;
next	4.16.2.31;
commitid	cI3W0zbtALQG6TIv;

4.16.2.31
date	2011.11.27.12.34.45;	author rsprowson;	state Exp;
branches;
next	4.16.2.32;
commitid	QtdLV6zjuPNxdYIv;

4.16.2.32
date	2012.01.15.08.22.22;	author rsprowson;	state Exp;
branches;
next	4.16.2.33;
commitid	b6tNv5QPTHakffPv;

4.16.2.33
date	2012.02.25.16.19.37;	author jlee;	state Exp;
branches;
next	4.16.2.34;
commitid	ad3WnPntkzrizyUv;

4.16.2.34
date	2012.03.11.16.02.28;	author jlee;	state Exp;
branches;
next	4.16.2.35;
commitid	Su8z1Zake4xzZtWv;

4.16.2.35
date	2012.04.25.23.20.19;	author bavison;	state Exp;
branches
	4.16.2.35.2.1;
next	4.16.2.36;
commitid	RcJ6nLFcjU06Yi2w;

4.16.2.36
date	2012.06.21.07.59.24;	author rsprowson;	state Exp;
branches;
next	4.16.2.37;
commitid	IX8PhIHHo1Sy2y9w;

4.16.2.37
date	2012.07.01.21.26.41;	author rsprowson;	state Exp;
branches;
next	4.16.2.38;
commitid	K3GB4gteEYUubUaw;

4.16.2.38
date	2012.09.18.22.01.15;	author jlee;	state Exp;
branches;
next	4.16.2.39;
commitid	eFa3Y1QY0MjZP3lw;

4.16.2.39
date	2012.09.30.08.46.15;	author rsprowson;	state Exp;
branches;
next	4.16.2.40;
commitid	oaVP9UztPt2m3xmw;

4.16.2.40
date	2012.09.30.16.29.22;	author jlee;	state Exp;
branches;
next	4.16.2.41;
commitid	sRDLisRa5FxeCzmw;

4.16.2.41
date	2012.10.06.19.40.51;	author srevill;	state Exp;
branches;
next	4.16.2.42;
commitid	LJehZvPA40mYtmnw;

4.16.2.42
date	2012.10.08.13.33.31;	author srevill;	state Exp;
branches;
next	4.16.2.43;
commitid	jje13cvdo9fWnAnw;

4.16.2.43
date	2012.10.09.23.43.16;	author jlee;	state Exp;
branches;
next	4.16.2.44;
commitid	4wh5JUOT6SA9JLnw;

4.16.2.44
date	2013.01.10.21.19.09;	author rsprowson;	state Exp;
branches;
next	4.16.2.45;
commitid	F6D8WGw2f7PkWHzw;

4.16.2.45
date	2013.03.28.21.36.25;	author jlee;	state Exp;
branches;
next	4.16.2.46;
commitid	UN0GP6eB0LlNyBJw;

4.16.2.46
date	2013.10.28.22.25.52;	author rsprowson;	state Exp;
branches;
next	4.16.2.47;
commitid	ODFbeIUI1Y5lX6bx;

4.16.2.47
date	2013.11.20.20.29.58;	author rsprowson;	state Exp;
branches;
next	4.16.2.48;
commitid	X1FKtc2EAz7Jz3ex;

4.16.2.48
date	2014.05.07.20.59.16;	author jlee;	state Exp;
branches;
next	4.16.2.49;
commitid	kFTgiCW21h4ZkEzx;

4.16.2.49
date	2014.08.17.10.29.17;	author jballance;	state Exp;
branches;
next	4.16.2.50;
commitid	EvuS6ETGlsoyzHMx;

4.16.2.50
date	2015.01.11.23.10.49;	author jlee;	state Exp;
branches;
next	4.16.2.51;
commitid	a9HNIsO4R7LP3F5y;

4.16.2.51
date	2015.01.16.00.43.13;	author jlee;	state Exp;
branches;
next	4.16.2.52;
commitid	6VfHOoXB8KkCrb6y;

4.16.2.52
date	2015.08.31.19.28.38;	author jlee;	state Exp;
branches;
next	;
commitid	Ni3KL17bG70fnszy;

4.16.2.28.2.1
date	2009.03.06.23.23.43;	author jlee;	state Exp;
branches;
next	4.16.2.28.2.2;

4.16.2.28.2.2
date	2009.07.23.00.57.11;	author jlee;	state Exp;
branches;
next	4.16.2.28.2.3;

4.16.2.28.2.3
date	2009.12.05.20.17.51;	author jlee;	state Exp;
branches;
next	4.16.2.28.2.4;

4.16.2.28.2.4
date	2010.04.22.20.28.27;	author jlee;	state Exp;
branches;
next	4.16.2.28.2.5;

4.16.2.28.2.5
date	2010.06.23.22.34.27;	author jlee;	state Exp;
branches;
next	4.16.2.28.2.6;

4.16.2.28.2.6
date	2010.10.04.22.22.14;	author jlee;	state Exp;
branches;
next	4.16.2.28.2.7;

4.16.2.28.2.7
date	2011.02.19.22.19.34;	author jlee;	state Exp;
branches;
next	4.16.2.28.2.8;

4.16.2.28.2.8
date	2011.07.31.13.39.19;	author jlee;	state Exp;
branches;
next	4.16.2.28.2.9;
commitid	tnhfpNorgEFQoGtv;

4.16.2.28.2.9
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	4.16.2.28.2.10;
commitid	D7rzILnwRRSXoLuv;

4.16.2.28.2.10
date	2011.09.12.18.52.31;	author bavison;	state Exp;
branches;
next	4.16.2.28.2.11;
commitid	KJtDPjWMk0KCKezv;

4.16.2.28.2.11
date	2011.09.12.20.31.39;	author jlee;	state Exp;
branches
	4.16.2.28.2.11.2.1;
next	;
commitid	aYOriTZbxBByifzv;

4.16.2.28.2.11.2.1
date	2012.05.10.03.09.53;	author bavison;	state Exp;
branches;
next	;
commitid	HTVG5Da5tRqSM74w;

4.16.2.35.2.1
date	2012.05.10.03.28.06;	author bavison;	state Exp;
branches;
next	4.16.2.35.2.2;
commitid	kuJoT3AcfB16T74w;

4.16.2.35.2.2
date	2012.07.08.23.07.56;	author jlee;	state Exp;
branches;
next	4.16.2.35.2.3;
commitid	XImsZIoxnxlowObw;

4.16.2.35.2.3
date	2012.09.07.23.05.52;	author jlee;	state Exp;
branches;
next	4.16.2.35.2.4;
commitid	Ik0jMROsIiH5yEjw;

4.16.2.35.2.4
date	2012.09.18.15.50.03;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.3.2.1
date	97.05.21.09.30.18;	author mstphens;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	97.05.23.13.06.55;	author kbracey;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	97.09.09.13.33.30;	author mstphens;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	97.10.21.15.31.25;	author mstphens;	state Exp;
branches;
next	4.3.2.5;

4.3.2.5
date	97.12.08.14.34.39;	author mstphens;	state Exp;
branches;
next	4.3.2.6;

4.3.2.6
date	98.03.26.11.26.00;	author mstphens;	state Exp;
branches;
next	4.3.2.7;

4.3.2.7
date	98.05.19.15.52.05;	author sproven;	state Exp;
branches
	4.3.2.7.2.1;
next	4.3.2.8;

4.3.2.8
date	98.09.24.13.17.22;	author mstphens;	state Exp;
branches;
next	;

4.3.2.7.2.1
date	98.11.23.14.59.21;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.23;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.55;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.08.09.29;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.16.46.06;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.38;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.52;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.12.19.36.38;	author brice;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.03.25.20.54.51;	author scormie;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.05.12.10.44.41;	author scormie;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	98.08.12.12.12.15;	author nicke;	state Exp;
branches;
next	4.1.7.6;

4.1.7.6
date	98.09.11.16.00.22;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.31
log
@Evict ECFIndex and PalIndex from VDU workspace
Detail:
  ECFIndex and PalIndex claim to be mode variables, but it's impossible for extension modes to specify their values.
  Since they're easy to calculate from the ModeFlags and Log2BPP values, drop them from the mode workspace (+ table of builtin modes) and calculate them on the fly instead.
  File changes:
  - hdr/KernelWS - Drop ECFIndex & PalIndex from workspace
  - s/vdu/vdumodes - Adjust workspace definition, drop ECFIndex & PalIndex values from VWSTAB
  - s/vdu/vdudriver - Remove now-redundant copy loop from ModeChangeSub. Remove code from GenerateModeSelectorVars that sets up the ECFIndex & PalIndex values on the stack
  - s/vdu/vdugrafl - Adjust copy loop in SwitchOutputToSprite/Mask
  - s/vdu/vdupalette, s/vdu/vdupalxx - Add GetPalIndex routine to generate PalIndex on the fly. Drop the obsolete 16bpp palette/gamma table and shuffle the other entries to simplify GetPalIndex a bit.
  - s/vdu/vduplot - Add GetECFIndex routine to generate ECFIndex on the fly. Also, fix things so that mode 0 isn't the only rectangular-pixel mode which uses the special rectangular-pixel ECF patterns (index 0 vs. index 4). Fiddle with ExportedHLine a bit to avoid an out-of-range ADR.
  - s/NewReset - Fix UAL warning for MOV R0, AppSpaceStart. Adjust memset to not assume 512KB is the correct amount
Admin:
  Tested on Raspberry Pi 3


Version 6.11. Tagged as 'Kernel-6_11'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    => NewReset

; Reset types
SoftReset       * 0
PowerOnReset    * 1
ControlReset    * 2

; CMOS RAM resetting stuff:
CMOSLimit       * &F0

; Keyboard scan
KbdFlag_Ctrl    * 1:SHL:0
KbdFlag_Shift   * 1:SHL:1
KbdFlag_R       * 1:SHL:4
KbdFlag_T       * 1:SHL:5
KbdFlag_Delete  * 1:SHL:6
KbdFlag_Copy    * 1:SHL:7
KbdFlag_Present * 1:SHL:30
KbdFlag_Done    * 1:SHL:31

; GetConfiguredSize - convert CMOS address into amount of memory
; in:   r0 = CMOS address
; out:  r0 corrupted
;       r2 = amount in bytes

; NB this routine doesn't do screen size mangling (yet!)

GetConfiguredSize Entry "r1"
        LDR     r1, =ZeroPage
        LDR     r1, [r1, #Page_Size]
        ADRL    lr, PageShifts-1
        LDRB    r1, [lr, r1, LSR #12]   ; r1 = log2 pagesize
        MOV     r2, #127                ; mask of value

        TEQ     r0, #FontCMOS           ; if fontsize
        MOVEQ   r1, #12                 ; then in units of 4K, not pagesize
        MOVEQ   r2, #255                ; and use full byte

        BL      Read                    ; read CMOS ram
        AND     r2, r0, r2              ; value anded with mask
        MOV     r2, r2, LSL r1          ; and shifted up accordingly
        EXIT

; MassageScreenSize - called from screen DA creation and ReadSysInfo

MassageScreenSize ROUT
        Push    lr
        LDR     lr, =ZeroPage
        LDR     lr, [lr, #VideoSizeFlags]
        TST     lr, #OSAddRAM_VRAMNotForGeneralUse
        MOVNE   r0, lr, LSR #12
        MOVNE   r0, r0, LSL #12
        Pull    pc, NE

        CMP     r0, #0
        BNE     CmosScreenWillDo
      [ ZeroPage <> 0
        LDR     r0, =ZeroPage
      ]
        LDR     r0, [r0, #RAMLIMIT]
        CMP     r0, #512*1024
        MOVEQ   r0, #80*1024
        MOVNE   r0, #160*1024
CmosScreenWillDo
        CMP     r0, #20*1024            ; ensure mode 0 gettable
        ADDCC   r0, r0, r10             ; if not, then add another page
        BCC     CmosScreenWillDo
        CMP     r0, #ScreenMaxSize
        MOVHI   r0, #ScreenMaxSize
        Pull    pc

        LTORG

CONT_Break
        AddressHAL
        MOV     a1, #1
        LDR     a2, =L1PT
        CallHAL HAL_Reset

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Entry point from HALInit

Continue_after_HALInit

; OK, there is quite a bit of code poking below, to various addresses. We'll
; defer IMB consideration till the poking's done, then do a full IMB (full
; data cache clean). This avoids various little IMB's and removes chance of leaving
; some unnoticed poked code in data cache. The deferral should be safe, because none
; of the poked code will be used yet awhile (given that current IRQ hardware vector is
; not actually changed below).

; Copy default processor vector table and default preveneers.
; Code relies on preveneers being immediately after processor vector table
; but could easily be changed into 2 copy loops.
        ASSERT  ProcVecPreVeneers = ProcVec_End
        ASSERT  DefaultPreVeneers = DefaultProcVecs+ProcVec_End-ProcVec_Start

        ADRL    R0, DefaultProcVecs
        LDR     R1, =ZeroPage+ProcVec_Start
        MOV     R2, #ProcVec_End-ProcVec_Start+ProcVecPreVeneersSize
39
        LDR     R3, [R0], #4
        STR     R3, [R1], #4
        SUBS    R2, R2, #4
        BNE     %BT39

; copy handler addresses
        ADRL    R1, MOSROMVecs+4        ; don't copy to 0: key stuff is using
                                        ; it as workspace!
        LDR     R0, =ZeroPage+4
        LDR     R3, =ZeroPage+EndMOSROMVecs-MOSROMVecs

40
        LDR     R2, [R1], #4            ; N.B. IRQ handler better be same as the one in there
        STR     R2, [R0], #4
        TEQ     R0, R3
        BNE     %BT40

        ChangedProcVecs r0

 [ CacheCMOSRAM
        DebugTX "InitCMOSCache entry"
        BL      InitCMOSCache           ; initialise cache of CMOS RAM
        TEQ     R0, #0                  ; returns zero on failure
      [ ZeroPage <> 0
        LDREQ   R0, =ZeroPage
      ]
        LDREQ   R1, [R0, #HAL_StartFlags]
        ORREQ   R1, R1, #OSStartFlag_NoCMOS
        STREQ   R1, [R0, #HAL_StartFlags]
        BEQ     %FT41
        DebugTX "InitCMOSCache done"
        B       %FT42
41
        DebugTX "InitCMOSCache failed"
42
 ]

; Now copy the initialised data
        LDR     R0, =ZeroPage+IRQ1V
        ADRL    r1, StartData
        LDR     R3, =ZeroPage+(EndData-StartData+IRQ1V)
DatCopy
        LDR     R2, [R1], #4
        STR     R2, [R0], #4
        TEQ     R0, R3
        BNE     DatCopy

        ADR     r2, CONT_Break
        LDR     r0, =ZeroPage
        STR     r2, [r0, #ResetIndirection]

        MOV     r3, #0                  ; zero-initialise abort list, and other key workspace
        STR     r3, [r0, #AbortIndirection]
 [ CompatibilityPage
        STRB    r3, [r0, #CompatibilityPageEnabled]
 ]

; Now the SWI despatch + low part of SWI table
        ADRL    R3, DirtyBranch
        LDR     R0, =SWIDespatch
SVCTabCopy                              ; so copy the table
        LDR     R2, [R1], #4
        STR     R2, [R0], #4
        TEQ     R1, R3
        BNE     SVCTabCopy

; pad to 1K table here, rather than use ROM space
        ADRL    R2, NoSuchSWI
        LDR     R4, =1024+SvcTable      ; end of table
PadSVCTable
        CMP     R0, R4
        STRNE   R2, [R0], #4
        BNE     PadSVCTable

; now the dirty branch
        LDR     R1, [R1]
        STR     R1, [R0]

; conversion SWIs all go through same despatch point
        LDR     R0, =SvcTable
        ADRL    R1, despatchConvert
        STR     R1, [R0, #OS_ConvertStandardDateAndTime * 4]
        STR     R1, [R0, #OS_ConvertDateAndTime * 4]

        MOV     R2, #OS_ConvertHex1
conversionSWIfill
        STR     R1, [R0, R2, LSL #2]
        ADD     R2, R2, #1
        CMP     R2, #OS_ConvertVariform
        BLS     conversionSWIfill

; OK, that completes the poking around, some of which is code. Now let's
; do a full IMB type thing, to be safe
;
        LDR     r0, =ZeroPage
        ARMop   IMB_Full,,,r0
        DebugTX "IMB_Full done"

      [ CacheablePageTables
; If we want cacheable page tables, now is a good time to enable them
; (can't easily enable them earlier on due to the page tables being temporarily
; doubly-mapped during MMU init)
        BL      MakePageTablesCacheable
      ]

; Initialise CAO ptr to none.

        LDR     R0, =ZeroPage
        LDR     R1, =DuffEntry          ; nothing will be here!!
        STR     R1, [R0, #Curr_Active_Object]

; Get creating the essential areas

        DebugTX "InitDynamicAreas"
        BL      InitDynamicAreas

        ; RMA
        Push    "r0-r12"
        MOV     r1, #ChangeDyn_RMA      ; Area number
        MOV     r2, #4096               ; Initial size
        MOV     r3, #RMAAddress         ; Base address
        MOV     r4, #AreaFlags_RMA      ; Area flags
        MOV     r5, #RMAMaxSize         ; Maximum size
        ADRL    r6, DynAreaHandler_RMA  ; Pointer to handler
        MOV     r7, r3                  ; Workspace ptr points at area itself
        ADRL    r8, AreaName_RMA        ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
        Pull    "r0-r12"

        ; Screen
        Push    "r0-r12"
        MOV     r0, #ScreenSizeCMOS
        BL      Read

        LDR     r5, =ZeroPage
        LDR     r10, [r5, #Page_Size]   ; needed by MassageScreenSize
        MUL     r0, r10, r0             ; convert to bytes
        LDR     r5, [r5, #VideoSizeFlags] ; maximum size
        MOV     r5, r5, LSR #12
        MOV     r5, r5, LSL #12
        BL      MassageScreenSize       ; Clamps the initial size regardless of the
                                        ; contents of the ScreenSizeCMOS

        MOV     r1, #ChangeDyn_Screen   ; area number
        MOV     r2, r0                  ; initial size
        MOV     r3, #-1                 ; Base address dynamic
        LDR     r4, =AreaFlags_Screen   ; area flags
        ADRL    r6, DynAreaHandler_Screen ; handler
        VDWS    r7                      ; workspace pointer
        MOV     r8, #0
        STR     r8, [r7, #CursorFlags]  ; put zero in CursorFlags as an indication that VDU not yet inited
        STR     r2, [r7, #TotalScreenSize]
        ADRL    r8, AreaName_Screen     ; area name
        BL      DynArea_Create
        STR     r3, [r7, #ScreenEndAddr]
        Pull    "r0-r12"

        MOV     R0, #ChangeDyn_FreePool ; 512k of RAM in AplSpace should be plenty for ROM init. 
        MOV     R1, #512*1024           ; Theoretically we don't need any at all, but having some there
        RSB     R1, R1, #0              ; should make it easier to debug any ROM init failures.
        SWI     XOS_ChangeDynamicArea
        LDR     R1, =ZeroPage
        LDR     R2, [R1, #AplWorkSize]
        STR     R2, [R1, #MemLimit]

        MOV     R0, #AppSpaceStart
        MOV     R1, #0
        SUB     R2, R2, R0
        BL      memset                  ; Clear AplSpace
        
        DebugTX "InitVectors"
        BL      InitVectors             ; ready for OsByte to read mode

        LDR     R1, =ZeroPage+ModuleSWI_HashTab
        MOV     R2, #ModuleSHT_Entries
        MOV     R0, #0
clearmswis
        SUBS    R2, R2, #1
        STR     R0, [R1, R2, LSL #2]
        BGT     clearmswis

     [  International
      [ ZeroPage <> 0
        LDR     R2, =ZeroPage
      ]
        MOV     R1, #-1                                 ; We don't have a message file yet !
        STRB    R1, [R2, #ErrorSemaphore]               ; Don't translate errors.
        STR     R0, [R2, #KernelMessagesBlock]          ; No message file open.
      [ CacheCommonErrors
        STR     R0, [R2, #CachedErrorBlocks]            ; No cached errors
      ]
     ]

        ; Make the choice between PowerOn and Hard reset based purely on
        ; the state of the POR bit and NOT on whether memory was cleared.
        LDR     R0, =ZeroPage+HAL_StartFlags
        LDR     R1, [R0]
        TST     R1, #OSStartFlag_POR
        MOVNE   R0, #PowerOnReset
        MOVEQ   R0, #ControlReset
        LDR     R1, =ZeroPage+OsbyteVars + :INDEX: LastBREAK
        STRB    R0, [R1]

        DebugTX "InitIRQ1"
        BL      InitialiseIRQ1Vtable

        LDR     R3, =ZeroPage
        ADRL    R1, Default_PIRQHandler_Node
        STR     R1, [R3, #PIRQ_Chain]
        STR     R1, [R3, #PFIQasIRQ_Chain]
        ASSERT Default_PFIQasIRQHandler_Node = Default_PIRQHandler_Node

        MOV     R0, #0                  ; put in IRQ handler, word at 0
        STRB    r0, [r3, #FIQclaim_interlock]
        STRB    r0, [r3, #CallBack_Flag]
        STR     r0, [r3, #CallBack_Vector]
        STR     r0, [r3, #TickNodeChain]

; Create the Branch Through 0 Trampoline in the system heap
        MOV     R3, #Branch0_Trampoline_Size
        BL      ClaimSysHeapNode
        ADRVCL  R0, Branch0_Trampoline
        ASSERT  Branch0_Trampoline_Init = 20
        LDMVCIA R0, {R1,R3,R4,R5,R14}
        STMVCIA R2, {R1,R3,R4,R5,R14}
        LDRVC   R0, =ZeroPage
        STRVC   R2, [R0, #ProcVec_Branch0]

        LDR     R1, BranchThroughZeroInstruction2
        STR     R1, [R0]                                ; put branch through 0 code at 0

        LDR     R1, RealIRQHandler
        STR     R1, [R0, #&18]
        
        DebugTX "IMB_Full"

        ; we need to do an IMB type thing for modifying code in vector area,
        ; and for copying irq handler code
        ARMop   IMB_Full,,,r0
        ChangedProcVecs r0

        LDR     r0,=ZeroPage
        MOV     R1, #&100
        STR     R1, [R0, #RCLimit]
        MOV     R1, #0
        STR     R1, [R0, #ReturnCode]

; now put in error handler and escape handler
        BL      DEFHAN
        BL      DEFHN2
        MOV     R0, #ExceptionDumpArea
        LDR     R1, =ZeroPage+DUMPER
        SWI     XOS_ChangeEnvironment

        VDWS    WsPtr                   ; main MOS initialisation
        DebugTX "VduInit"
        BL      VduInit
        DebugTX "ExecuteInit"
        BL      ExecuteInit
        DebugTX "KeyInit"
        BL      KeyInit
        DebugTX "OscliInit"
        BL      OscliInit               ; before initialising modules

        DebugTX "Enabling IRQs"
        WritePSRc SVC_mode, R14         ; enable IRQs
        DebugTX "IRQs on"

 [ DebugTerminal
        MOV     R0, #RdchV
        ADRL    R1, DebugTerminal_Rdch
        LDR     R2, =ZeroPage
        LDR     R2, [R2, #HAL_Workspace]
        SWI     XOS_Claim
        MOV     R0, #WrchV
        ADRL    R1, DebugTerminal_Wrch
        SWI     XOS_Claim
        DebugTX "Debug terminal on"
 ]

        BL      InitialiseMode          ; select correct screen mode, in case any
                                        ; module prints anything in initialisation

        DebugTX "HAL_InitDevices"
        AddressHAL
        MOV     R0, #0
      [ ZeroPage = 0
        STR     R0, [R0, #DeviceCount]
        STR     R0, [R0, #DeviceTable]
      |
        LDR     R1, =ZeroPage
        STR     R0, [R1, #DeviceCount]
        STR     R0, [R1, #DeviceTable]
      ]
        CallHAL HAL_InitDevices         ; get HAL to register any devices it has
        BL      LookForHALCacheController
        DebugTX "InitVariables"
        BL      InitVariables
        DebugTX "AMBControl_Init"
        BL      AMBControl_Init         ; initialise AMBControl section

        AddressHAL
        CallHAL HAL_KbdScanDependencies
        MOV     r5, r0
        DebugTX "ModuleInitForKbdScan"
        BL      ModuleInitForKbdScan

; minimal post module setup for keyboard scan

        BL      KeyPostInit

; scan keyboard for interesting keypresses R/T/Delete/End + Ctrl/Shift or timeout

        LDR     r3, =ZeroPage
        LDR     r6, [r3, #HAL_StartFlags]
        TST     r6, #OSStartFlag_RAMCleared
        MOVEQ   r6, #0                  ; RAM clear from start of free pool
        MOVNE   r6, #-1                 ; RAM clear not needed

        LDR     r3, [r3, #MetroGnome]
        ADD     r3, r3, #300            ; timeout (cs)
02
        CMP     r5, #-1                 ; HAL gave no KbdScan details
        BEQ     %FT04

        TST     r4, #KbdFlag_Present
        BNE     %FT03

        LDR     r0, =ZeroPage+KeyWorkSpace 
        LDRB    r0, [r0, #:INDEX:KbId]  ; check if anyone registered with KeyV
        CMP     r0, #&20                ; same limit as GetCountry
        BCS     %FT04

        ORR     r4, r4, #KbdFlag_Present
        DebugTX "KbdFlag_Present"
03
        MOV     r0, #OsByte_INKEY
        MOV     r1, #0 :EOR: &7F        ; scan from shift upwards
        MOV     r2, #255
        SWI     XOS_Byte
        TEQ     r1, #0
        ORREQ   r4, r4, #KbdFlag_Shift
        TEQ     r1, #1
        ORREQ   r4, r4, #KbdFlag_Ctrl
        TEQ     r1, #51
        ORREQ   r4, r4, #KbdFlag_R
        TEQ     r1, #35
        ORREQ   r4, r4, #KbdFlag_T
        TEQ     r1, #89
        ORREQ   r4, r4, #KbdFlag_Delete
        TEQ     r1, #105
        ORREQ   r4, r4, #KbdFlag_Copy
04
        SWI     XOS_LeaveOS
        SWI     XOS_EnterOS             ; callbacks

        ; Prior to getting here, ClearWkspRAM cleared low OS workspace & ScratchSpace, and
        ; Init_MapInRAM_Clear has selectively cleared other early allocations. That leaves
        ; everything from InitDynamicAreas
        ;   RMA => not cleared, it's in use
        ;   Screen => not cleared, the next CLS will do that
        ; and
        ;   AplSpace (first 512k) => cleared unconditionally
        ;   Free pool => clear now if HAL didn't
        ; left to do.
        MOV     r0, r6
        BL      ClearFreePoolSection
        MOV     r6, r0
        CMP     r6, #-1
        BNE     %BT02                   ; the show's not over until the RAM clear is done

        CMP     r5, #-1
        BEQ     %FT05                   ; HAL gave no KbdScan details

        TST     r4, #KbdFlag_Shift :OR: KbdFlag_Ctrl :OR: KbdFlag_R :OR: KbdFlag_T :OR: KbdFlag_Delete
        BNE     %FT05                   ; exciting key press beats a timeout

        LDR     r0, =ZeroPage
        LDR     r0, [r0, #MetroGnome]
        CMP     r0, r3                  ; timed out?
        BCC     %BT02
05
        ORR     r4, r4, #KbdFlag_Done
        Push    "r4"                    ; save until after MOSInit

; Clear temp ws skipped earlier
        LDR     R0, =ZeroPage+InitWsStart               
        MOV     R1, #0
        MOV     R2, #InitWsEnd - InitWsStart
        BL      memset

cmos_checks
        MOV     R3, #-1                 ; do all CMOS if we do any
      [ ValidateCMOS
; Do a POR if some super-critical values are shagged or if checksum is invalid.
        BL      ValChecksum             ; Always check the checksum
        BNE     cmos_reset
      ]

; IF power-on bit set AND R/T/Del/Copy pressed THEN reset CMOS RAM

        LDR     R0, =ZeroPage+HAL_StartFlags
        LDR     R1, [R0]
        TST     R1, #OSStartFlag_NoCMOS ; If no CMOS, reset for sensible cache
        BNE     cmos_reset

        TST     R1, #OSStartFlag_POR
        BEQ     no_cmos_reset           ; not a power on reset
        DebugTX "POR detected"
        TST     R1, #OSStartFlag_NoCMOSReset
        BNE     no_cmos_reset
        TST     R1, #OSStartFlag_CMOSReset
        BNE     cmos_reset

        TST     R4, #KbdFlag_R:OR:KbdFlag_T:OR:KbdFlag_Delete:OR:KbdFlag_Copy
        LDRNE   R3, =ZeroPage
        MOVNE   R14, #1
        STRNEB  R14, [R3, #MentionCMOSReset]
        BEQ     no_cmos_reset           ; power on bit checked again there

; CMOS reset detectified.
; Wipe it, then squirt in the MOS's table of default values

        TST     R4, #KbdFlag_Copy:OR:KbdFlag_Delete
        MOVNE   R3, #-1                 ; Del or Copy does all RAM
        MOVEQ   R3, #UserCMOS           ; R or T just system
      [ ChecksumCMOS
        BL      ValChecksum             ; unless the CMOS ram's corrupt ..
        MOVNE   R3, #-1                 ; .. then blast it anyway.
      ]
cmos_reset
        DebugTX "Reset CMOS"

        MOV     R4, #0
cmrlp
        CMP     R3, #-1
        BEQ     cmrall                  ; ignore system-only wipe checks
        CMP     R4, #UserCMOS
        MOVEQ   R4, #&50                ; skip User (30-45) & 3rd party (46-59) & high podules (60-79)
        BEQ     cmrall
        CMP     R4, #PoduleCMOS
        MOVEQ   R4, #&80                ; skip low podules (112-127)
        BEQ     cmrall
        TEQ     R4, #NewADFSCMOS        ; documented in 'Troubleshooting' in
        TEQNE   R4, #CountryCMOS        ; the RISC OS 3.7 user guide as preserved
        BEQ     cmrskip
cmrall
        MOV     R1, R4
        BL      NVMemory_ResetValue     ; get the reset value
        MOVS    R1, R2                  ; when -ve, leave alone
        MOVPL   R0, R4
        BLPL    Write                   ; CMOS(R0) := R1
cmrskip
        ADD     R4, R4, #1
        CMP     R4, #CMOSLimit
        BCC     cmrlp

; IF R or Delete pressed THEN set sync 0 ELSE set sync Auto
        LDR     R4, [SP]
        TST     R4, #KbdFlag_R:OR:KbdFlag_Delete
        MOV     R0, #VduCMOS
        MOVNE   R1, #MonitorTypeAuto :OR: Sync_Auto     ; if R or Del
        MOVEQ   R1, #MonitorTypeAuto :OR: Sync_Separate ; if T or Copy
        BL      Write

      [ ChecksumCMOS
        BL      MakeChecksum            ; create a valid checksum
      ]
        B       init_other_modules

no_cmos_reset
        MOV     r0, #SystemSpeedCMOS
        BL      Read
        BIC     r1, r0, #CMOSResetBit   ; clear bit indicating CMOS reset
        MOV     r0, #SystemSpeedCMOS
        BL      Write

init_other_modules

; init that's deferrable until the CMOS is sanitised
        DebugTX "ReadDefaults"
        BYTEWS  WsPtr
        BL      ReadHardCMOSDefaults
        BL      ReadCMOSDefaults
        DebugTX "InitHostedDAs"
        BL      InitHostedDAs
        DebugTX "MouseInit"
        BL      MouseInit

; now go back and load the other modules, scan podules, accounting for frugal bits
        DebugTX "ModuleInit"
        BL      ModuleInit

        MOV     R0, #0                  ; shrink sysheap as far as will go.
        SUB     R1, R0, #4*1024*1024
        SWI     XOS_ChangeDynamicArea
        MOV     R0, #ReadCMOS
        MOV     R1, #SysHeapCMOS
        SWI     XOS_Byte
        AND     R2, R2, #2_111111       ; mask to same size as status
        LDR     R0, =ZeroPage
        LDR     R0, [R0, #Page_Size]
        MUL     R3, R0, R2              ; size spare wanted
        BL      ClaimSysHeapNode
        MOV     R0, #HeapReason_Free
        SWI     XOS_Heap

        MOV     R0, #ReadCMOS
        MOV     R1, #FileLangCMOS
        SWI     XOS_Byte
        MOV     R1, R2
        MOV     R0, #FSControl_SelectFS ; set configured filing system
        SWI     XOS_FSControl

        ; Update territory in case it changed after ModuleInitForKbdScan
        MOV     R0, #ReadCMOS
        MOV     R1, #TerritoryCMOS
        SWI     XOS_Byte
        EOR     R0, R2, #1              ; encoded so that 0 => TerritoryNum_UK
        SWI     XTerritory_Select

        ; Update RTC now all the modules are running
        SWI     XOS_ResyncTime

  [ DebugROMInit
        SWI     XOS_WriteS
        =       "Service_PostInit",0
        SWI     XOS_NewLine
  ]
        MOV     r1, #Service_PostInit   ; issue post-initialisation service
        BL      Issue_Service

  [ DebugROMInit
        SWI     XOS_WriteS
        =       "callbacks",0
        SWI     XOS_NewLine
  ]
        SWI     XOS_LeaveOS
        SWI     XOS_EnterOS             ; switch back to SVC mode (IRQs, FIQs enabled)

      [ International                   ; Open the kernel messages file.
        LDR     r0, =ZeroPage+KernelMessagesBlock+4
        ADRL    r1, MessageFileName
        MOV     r2, #0                  ; Use file directly.
        SWI     XMessageTrans_OpenFile
        MOVVC   r0, #-1
        LDRVC   lr, =ZeroPage
        STRVC   r0, [lr, #KernelMessagesBlock]  ; Message file is now open.

        ASSERT  (ZeroPage :AND: 255) = 0  ; if we've managed to open message file
        STRVCB  lr, [lr, #ErrorSemaphore] ; then allow errors to be translated
      ]

        ; OS_ReadSysInfo 9,2 now relies on the Territory module, which may
        ; enable IRQs. But the PRMs say OS_ReadSysInfo shouldn't alter the IRQ
        ; state. So call it once here just to initialise the string which it
        ; uses the Territory module to generate.
        ; This won't account for any modules using it during ModuleInit, but
        ; that should be pretty rare (or at least rare from within IRQ-sensitive
        ; code)
        ;
        ; Must also be after Service_PostInit to give TerritoryManager opportunity
        ; to load disc based territories. 
        MOV     R0, #9
        MOV     R1, #2
        SWI     XOS_ReadSysInfo

      [ UseNewFX0Error
        ; Also, *FX 0
        BL      InitNewFX0Error
      ]
      [ CompatibilityPage
        ; Enable low zero page compatibility page
        MOV     R0, #OSMemReason_Compatibility
        MOV     R1, #1
        SWI     XOS_Memory
      ]

        BL      InitialiseMode
        LDR     R0, =ZeroPage
        LDRB    R14, [R0, #MentionCMOSReset]
        TEQ     R14, #0
        BEQ     %FT12
      [ International
        SWI     XOS_WriteI+10
        BVS     %FT09
        BL      WriteS_Translated
        =       "CmosRst:CMOS RAM reset, press ESCAPE to continue",0
        ALIGN
09
      |
        SWI     XOS_WriteS
        =       10,"CMOS RAM reset, press ESCAPE to continue",0
        ALIGN
      ]
10
        SWI     XOS_ReadEscapeState
        BCC     %BT10
        MOV     R0, #OsByte_ClearEscape
        SWI     XOS_Byte                ; Clear the condition
        SWI     XOS_WriteI+12           ; Clear the screen
12
        SWI     XOS_WriteS
        =       10, "$SystemName ", 0   ; now RISC OS (no +) again
        ALIGN

        MOV     R0, #8
        ORR     R0, R0, #&500
        SWI     XOS_Memory              ; returns amount of soft ROM (pages) in r1
        MOVVS   R1, #0

        LDR     R0, =ZeroPage
        LDR     R0, [R0, #RAMLIMIT]
        MLA     R0, R1, R2, R0          ; convert pages to bytes and add in

        MOV     R0, R0, LSR #20         ; /(1024*1024) down to megabytes
        LDR     R1, =GeneralMOSBuffer
        MOV     R2, #?GeneralMOSBuffer
        SWI     XOS_ConvertInteger4
        SWI     XOS_Write0
        SWI     XOS_WriteS
        =       "MB", 10,13, 10, 0      ; title complete
        ALIGN

        BL      ARM_PrintProcessorType

        MOV     r0, #0                  ; Set DomainId to 0 every reset
      [ ZeroPage = 0
        STR     r0, [r0, #DomainId]     ; before calling anyone
      |
        LDR     r1, =ZeroPage
        STR     r0, [r1, #DomainId]     ; before calling anyone
      ]

; issue reset service call

        MOV     R1, #Service_Reset
        SWI     XOS_ServiceCall

; now set up the default FIQ owner

        MOV     R1, #Service_ClaimFIQ
        SWI     XOS_ServiceCall

        MOV     R1, #Service_ReleaseFIQ
        SWI     XOS_ServiceCall

        BL      PostInit

        SWI     XOS_WriteI+7            ; go beep! Yaay!

; Now that ROM modules have mostly finished allocating memory, move a large
; chunk of the free memory from the free pool into application space so that
; the boot sequence and configured language have something to play around with
; (particularly if booting into BASIC!)
; However be careful not to move everything, otherwise anything which locks
; application space during boot could cripple important background processes
; like USB
        LDR     r0, =ZeroPage
        LDR     r1, [r0, #AplWorkSize]
        LDR     r0, [r0, #FreePoolDANode+DANode_PMPSize]
        CMP     r0, #DynArea_PMP_BigPageCount
        MOVLO   r0, r0, LSL #12
        LDRHS   r0, =DynArea_PMP_BigByteCount
        SUB     r1, r1, #32*1024
        SUB     r1, r1, r0
        MOV     r1, r1, ASR #1          ; 50% each sounds fair
        MOV     r0, #ChangeDyn_FreePool
        SWI     XOS_ChangeDynamicArea

        MOV     r0, #OsByte_RW_LastResetType
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        CMP     r1, #PowerOnReset
        BNE     %FT70

        LDR     r1, =ZeroPage+HAL_StartFlags
        LDR     r1, [r1]
        TST     r1, #OSStartFlag_NoCMOSReset
        BNE     %FT70

; if any keypad-numeric key pressed, reconfigure monitor type

        MOV     r0, #OsByte_ScanKeyboard        ; scan keyboard
        MOV     r1, #&FF                        ; starting at (&FF + 1) AND &FF
60
        ADD     r1, r1, #1
        AND     r1, r1, #&FF
        SWI     XOS_Byte
        TEQ     r1, #&FF                        ; if no key down
        BEQ     %FT70                           ; then give up

        ADR     r2, MonitorKeypadTable
62
        LDRB    r14, [r2], #2                   ; search for key in table
        TEQ     r14, #&FF
        BEQ     %FT70                           ; give up, key not in table
        TEQ     r1, r14
        BNE     %BT62
        LDRB    r3, [r2, #-1]                   ; get corresponding CMOS bits
        MOV     r0, #ReadCMOS
        MOV     r1, #VduCMOS
        SWI     XOS_Byte
        BIC     r2, r2, #MonitorTypeBits
        ORR     r2, r2, r3
        MOV     r0, #WriteCMOS
        SWI     XOS_Byte

        TEQ     r3, #MonitorTypeAuto            ; if we're setting monitortype auto
        BNE     %FT64
        ADRL    r0, ModeCMOSTable +8            ; then configure mode auto
        LDR     r2, [r0, #-8]                   ; (load auto value)
        BL      WriteMultiField
        ADRL    r0, SyncCMOSTable +8            ; and configure sync auto
        LDR     r2, [r0, #-8]                   ; (load auto value)
        BL      WriteMultiField

64
        BL      InitialiseMode

      [ International
        SWI     XOS_WriteI+10
        BVS     %FT65
        BL      WriteS_Translated
        =       "MonType:Monitor type reconfigured",10,13,10,0
        ALIGN
65
      |
        SWI     XOS_WriteS
        =       10,"Monitor type reconfigured",10,13,10,0
        ALIGN
      ]
        B       %FT70

RealIRQHandler
        LDR     PC, .-&18+ProcVec_IRQ

BranchThroughZeroInstruction2
        LDR     PC, .+ProcVec_Branch0

        LTORG

MonitorKeypadTable      ; internal key number, CMOS bits
        =       106, MonitorType0
        =       107, MonitorType1
        =       124, MonitorType2
        =       108, MonitorType3
        =       122, MonitorType4
        =       123, MonitorType5
        =       26,  MonitorType6
        =       27,  MonitorType7
        =       42,  MonitorType8
        =       43,  MonitorType9
        =       76,  MonitorTypeAuto    ; keypad dot
        =       &FF
        ALIGN 32

      [ International
MessageFileName DCB     "Resources:$.Resources.Kernel.Messages",0
        ALIGN
      ]

70

; Deal with SHIFT pressed/SHIFT-BREAK configured:
; do appropriate FSControl if wanted

        Pull    "R4"                    ; recover KbdFlag bits 

        TST     R4, #KbdFlag_Present    ; first check kbd there
        BNE     shifty_boot

      [ International
        BL      WriteS_Translated
        =       "NoKbd:No keyboard present - autobooting", 10,13,0
        ALIGN
      |
        SWI     XOS_WriteS
        =       7, "No keyboard present - autobooting", 10,13,0
        ALIGN
      ]
        B       Hortoculture_Kicking

shifty_boot
        MOV     R0, #OsByte_RW_StartupOptions
        MOV     R1, #0
        MOV     R2, #&FF                ; read shifty state
        SWI     XOS_Byte
        TST     R4, #KbdFlag_Shift
        EORNE   R1, R1, #8              ; invert sense
        TST     R1, #8
        BNE     %FT80                   ; no boot when set

Hortoculture_Kicking
        MOV     R0, #FSControl_BootupFS
        SWI     XOS_FSControl
        BVC     %FT80

        Push    "r3,r4"
        ADD     r1, r0, #4              ; Set Boot$Error if it failed (Desktop will report it).
        ADR     r0, str_booterror
        MOV     r2, #1024               ; Big enough that terminator will be reached.
        MOV     r3, #0
        MOV     r4, #VarType_String
        SWI     XOS_SetVarVal
        SUBVS   r0, r1, #4              ; If setting Boot$Error failed then report original error as before.
        BLVS    PrintError
        SWIVS   XOS_NewLine
        Pull    "r3,r4"
80
; if keypad-* pressed, drop into * prompt

        MOV     r0, #OsByte_INKEY
        MOV     r1, #KeyScan_NumPadStar :AND: &FF
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #&FF
        TEQEQ   r2, #&FF
        BEQ     DoStartSuper            ; EQ -> start up supervisor

; Start configured language module if keypad-* wasn't pressed

        MOV     R0, #ReadCMOS
        MOV     R1, #LanguageCMOS
        SWI     XOS_Byte

        MOV     R0, #ModHandReason_GetNames
        SUB     R1, R2, #1
        MOV     R2, #0                  ; preferred incarnation
        SWI     XOS_Module
        ADRVSL  R3, UtilityMod
        LDR     R2, [R3, #Module_TitleStr]
        CMP     R2, #0
        ADDNE   R1, R3, R2
DoStartSuper
        ADREQL  R1, UtilModTitle        ; ALWAYS enter via SWI: sets CAO etc.
        MOV     R0, #ModHandReason_Enter
        ADRL    R2, crstring            ; no environment
        SWI     XOS_Module
        CMP     r0, r0                  ; set EQ if failed to enter config.lang
        B       DoStartSuper            ; -> force Super entry


str_booterror   DCB     "Boot$$Error",0
                ALIGN

        END
@


4.30
log
@Simplify initial AplSpace claim
Detail:
  As the application slot is now a normal dynamic area, there's no need to manipulate the CAM directly. Convert FudgeSomeAppSpace into a OS_ChangeDynamicArea SWI followed by memset().
  ChangeDyn.s: Offset by 32k to account for the -32k that dynamic area -1 has.
  NewReset.s: Delete FudgeSomeAppSpace and replace as above.
Admin:
  Submission from Timothy Baldwin.

Version 6.08. Tagged as 'Kernel-6_08'
@
text
@d279 2
a280 2
        LDR     R0, [R1, #AplWorkSize]
        STR     R0, [R1, #MemLimit]
d282 1
a282 1
        MOV     R0, AppSpaceStart
d284 1
a284 1
        MOV     R2, #512*1024
@


4.29
log
@Various kernel cleanups
Detail:
  NewReset.s: Remove warning about soft reset, this is not supported any longer
  MsgCode.s: Reload LR after potentially changing mode
  PMF/osinit.s: Delete vestiges of soft reset support
Admin:
  Submission from Timothy Baldwin.

Version 6.07. Tagged as 'Kernel-6_07'
@
text
@a57 46
; FudgeSomeAppSpace - move pages from free pool to application space
; r0 = number of pages to attempt to move
; r1 = where to store number of bytes moved
; r3 = base address of where to put memory
; r11 = ap + CB
FudgeSomeAppSpace
        Push    "lr"
        LDR     R10, =ZeroPage
        LDR     R10, [R10, #Page_Size]
        MUL     R0, R10, R0             ; get size in bytes
        MOV     R5, #0                  ; amount moved
        CMP     R0, #0
        BEQ     NoMoreMemory

        LDR     r4, =ZeroPage+FreePoolDANode
        LDR     r7, [r4, #DANode_PMP]
        LDR     r8, [r4, #DANode_PMPSize]
10
        CMP     r8, #0                          ; if no free memory left
        BEQ     %FT20                           ; then tidy up
        SUB     r8, r8, #1                      ; move free pool pointer backwards
        MOV     lr, #-1
        LDR     r2, [r7, r8, LSL #2]
        STR     lr, [r7, r8, LSL #2]
        BL      Call_CAM_Mapping

        ADD     r2, r3, r10                     ; end of clear
        MOV     lr, #0
        MOV     ip, lr
15
        STMIA   r3!, {ip,lr}                    ; advance "to" pointer
        STMIA   r3!, {ip,lr}
        STMIA   r3!, {ip,lr}
        STMIA   r3!, {ip,lr}
        TEQ     r2, r3
        BNE     %BT15
        
        ADD     r5, r5, r10                     ; one more page done
        SUBS    r0, r0, r10
        BNE     %BT10
20
        STR     r8, [r4, #DANode_PMPSize]
NoMoreMemory
        STR     R5, [R1]
        Pull    "PC"

d274 7
a280 13
        LDR     R0, =(512*1024):SHR:12  ; 512k of RAM in aplspace should be plenty for ROM init. 
                                        ; Theoretically we don't need any at all, but having some there
                                        ; should make it easier to debug any ROM init failures.
        MOV     R3, #AppSpaceStart      ; aplwork start
        LDR     R1, =ZeroPage+AplWorkSize ; aplwork size
        MOV     r11, #AreaFlags_AppSpace
        BL      FudgeSomeAppSpace       ; put some memory in aplspace

        LDR     R0, =ZeroPage
        LDR     R1, [R0, #AplWorkSize]
        ADD     R1, R1, #AppSpaceStart
        STR     R1, [R0, #AplWorkSize]
        STR     R1, [R0, #MemLimit]
d282 5
a291 1
      [ ZeroPage <> 0
a292 1
      ]
d479 1
a479 1
        ;   Application space (from FudgeSomeAppSpace) => cleared unconditionally 
@


4.28
log
@Recover gracefully from a completely blank set of CMOS
Newly born boards have all 0xFF's in their CMOS (EEPROM), but the new order of keyboard scan did
  Init -> Scan keyboard -> Check (or wipe) CMOS
and would therefore leave 0xFF's in a select few kernel workspace areas and OS_Byte values.
Defer the init which reads CMOS until after the check/wipe step. Only the screen area size is now done early, but MassageScreenSize clamps that properly anyway.

Arthur3.s: Relocate stranded function SetupPrinterBuffer to osinit.
PMF/key.s: Drop support for SoftReset.
PMF/osinit.s: Stuff in hardcoded defaults at early init. Retrieve the proper ones later. Take ownership of SystemSprite/RamFS/Font Manager dynamic areas (deferrable).
vdudriver.s: Use symbolic name.
NewReset.s: Defer SystemSprite/RamFS/Font Manager area creation, MouseInit, Read(Hard)CMOSDefaults until later.
hdr/Options: Delete unused IgnoreVRAM. Remove MaxRAMFS_Size now PMPs make it not useful. Shuffle ARM6Support/XScaleMiniCache/XScaleJTAGDebug to be adjacent to their definitions.

Tested by filling first 256 bytes with 0xFF and powering up. Reset now completes, OS_Byte variables look sensible.

Version 5.95. Tagged as 'Kernel-5_95'
@
text
@a133 1
    ! 0, "*** DUMMY CONT_Break, soft breaks/resets will not work yet with HAL"
@


4.27
log
@Fix initial OS_ResyncTime to occur before Service_PostInit
Detail:
  s/NewReset - In Kernel-5_89, the initial OS_ResyncTime call was erroneously moved to after Service_PostInit, which had the side-effect of causing TerritoryManager's initial evaluation of AutoDST rules to be performed using an uninitialised RTC, with varying side effects depending on the user's timezone (e.g. UK stuck in DST all year round due to lack of BST in 1970). Move the call back to its original location so that TerritoryManager and any other PostInit claimants can see the correct time.
Admin:
  Tested in Iyonix ROM
  Resolves ticket #441


Version 5.91. Tagged as 'Kernel-5_91'
@
text
@d274 1
a274 2
; let's boogie with the CMOS for a bit
; read info and move as much memory as we can
d279 1
a279 1
; RMA
d293 1
a293 1
; Screen
d304 2
a305 1
        BL      MassageScreenSize
d321 3
a323 78
; SpriteArea
        Push    "r0-r12"
        MOV     r0, #0                  ; initialise SpriteSize to zero
      [ ZeroPage = 0
        STR     r0, [r0, #SpriteSize]   ; (fixes bug MED-00811)
      |
        LDR     r1, =ZeroPage
        STR     r0, [r1, #SpriteSize]   ; (fixes bug MED-00811)
      ]

        MOV     r0, #SpriteSizeCMOS     ; find out how much spritesize configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size

        MOV     r1, #ChangeDyn_SpriteArea ; Area number
        MOV     r3, #-1                 ; Base address dynamic
        MOV     r4, #AreaFlags_Sprites  ; Area flags
        MOV     r5, #16*1024*1024       ; Maximum size (changed from -1, address space preservation)
        ADRL    r6, DynAreaHandler_Sprites ; Pointer to handler
        MOV     r7, #-1                 ; Use base address as workspace ptr
        ADRL    r8, AreaName_SpriteArea ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
        Pull    "r0-r12"

; RAMDisc
        Push    "r0-r12"

        MOV     r1, #ChangeDyn_RamFS    ; Area number
        MOV     r3, #-1                 ; Base address dynamic
        ARM_read_ID r4
        AND     r4, r4, #&F000
        CMP     r4, #&A000
        MOVEQ   r4, #AreaFlags_RAMDisc_SA ; Area flags, if StrongARM  (introduced for Ursula)
        MOVNE   r4, #AreaFlags_RAMDisc  ; Area flags
      [ PMPRAMFS
        MOV     r5, #PMPRAMFS_Size*4096
        ORR     r4, r4, #DynAreaFlags_PMP
        MOV     r2, #0
        ORR     r4, r4, #DynAreaFlags_NeedsSpecificPages
        MOV     r9, #0
      |
        MOV     r0, #RAMDiscCMOS        ; find out how much RAM disc configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size
        MOV     r5, #MaxRAMFS_Size*1024*1024      ; A trade off between nice big disc and complete waste of address space
      ]
        ADRL    r6, DynAreaHandler_RAMDisc ; Pointer to handler
        MOV     r7, #-1                 ; Use base address as workspace ptr
        ADRL    r8, AreaName_RAMDisc    ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
      [ PMPRAMFS
        ; Currently, physical memory pools must be created with 0 size, then resized afterwards
        MOV     r0, #RAMDiscCMOS        ; find out how much RAM disc configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size
        MOVS    r1, r2
        MOV     r0, #ChangeDyn_RamFS
        SWINE   XOS_ChangeDynamicArea
      ]
        Pull    "r0-r12"

; FontArea
        Push    "r0-r12"
        MOV     r0, #FontCMOS           ; find out how much font cache configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size

        MOV     r1, #ChangeDyn_FontArea ; Area number
        MOV     r3, #-1                 ; Base address dynamic
        MOV     r4, #AreaFlags_FontArea ; Area flags
        MOV     r5, #32*1024*1024       ; Maximum size changed from -1 for Ursula (limit address
                                        ; space usage on large memory machines)
        ADRL    r6, DynAreaHandler_FontArea ; Pointer to handler
        MOV     r7, #-1                 ; Use base address as workspace ptr
        ADRL    r8, AreaName_FontArea   ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
        Pull    "r0-r12"

        LDR     R0, =(512*1024):SHR:12  ; 512k of RAM in aplspace should be plenty for ROM init. Theoretically we don't need any at all, but having some there should make it easier to debug any ROM init failures.
a427 2
        DebugTX "MouseInit"
        BL      MouseInit
a527 1
        ;   SpriteArea, RAMDisc, FontArea => not cleared, clients write their own data structures
d572 1
d646 10
d681 7
@


4.26
log
@Tweak handling of zero page compatibility page
Detail:
  s/MemInfo, hdr/KernelWS - Rather than peeking L2PT to determine if the compatibility page is enabled, use a workspace var to track its state. This ensures we won't get confused if other software decides to map something of its own to &0.
  s/NewReset - Ensure the CompatibilityPageEnabled flag is initialised correctly
Admin:
  Tested in Iyonix ROM softload


Version 5.90. Tagged as 'Kernel-5_90'
@
text
@d748 3
a779 3
        ; Update RTC now all the modules are running
        SWI     XOS_ResyncTime

@


4.25
log
@Change module initialisation to be a two pass scheme
Detail:
  To make it easier to support arbitrary complexity keyboard controllers (eg. USB via DWCDriver on the Pi) have the kernel do the early keyboard recovery key press detection instead of the HAL.
  During the first pass those modules used for reading the keyboard are started, ignoring the CMOS frugal bits.
  The keyboard is then scanned for 3s, during which time the RAM is cleared (unless the HAL indicated it has already been done).
  During the second pass the remaining modules are started respecting the CMOS frugal bits. Any which were already started in the first pass are inserted into the new chain, so the keyboard is reset once and only once.

  Boot times, with a 300cs key scan time in NewReset.
  Risc PC with 160MB RAM (128+32+0).
  Times from turning on power to initial "beep", using a stopwatch.
                RISC OS 3.70 RISC OS 5.22 This OS
  ARM610        12.5         10.4         10.3
  ARM710        11.8         10.2         9.7
  StrongARM 233 11.1         9.5          8.4

  In NewReset.s:
  Remove old KbdScan code (leave Reset_IRQ_Handler for IIC only)
  If HAL_KbdScanDependencies returns a null string then present KbdDone flag and skip to full init.
  A few vestiges of soft resets removed.
  Do RAM clear when waiting for INKEY (being careful not to trash the running modules...).
  Clearing just the freepool on a 2GB Titanium cleared 7EFD6 pages (99.2%).

  In ModHand.s:
  2nd pass need to sneaky renumber the nodes (so *ROMModules is in the right order, frugal bits line up) without resetting the chain

  In HAL.s:
  Change ClearPhysRAM to ClearWkspRAM, such that it only clears the kernel workspace rather than all RAM. The bulk of the RAM is cleared during the keyboard scan by new function ClearFreePoolSection.
  Add a variant of Init_MapInRAM which clears the mapped in RAM too (as these very early claims will not be in the free pool when the RAM is cleared later).
  Remove HAL keyboard scan setup & IRQ handler.
  Fix bug in HALDebugHexTX2, the input value needs pre-shifting by 16b before continuing.

  In GetAll.s, PMF/osbyte.s:
  Use Hdr:Countries and Hdr:OsBytes for constants.

  In PMF/key.s, PMF/osinit.s:
  Relocate the key post init from PostInit to KeyPostInit.
  Changed PostInit to not tail call KeyPostInit so they can be called independently.

  In hdr/KernelWs:
  Improve comments, add InitWsStart label to refer to.

  In hdr/HALEntries:
  Add HAL_KbdScanDependencies.
  Delete KbdFlag exports.
  Took the opportunity to reorder some of the higher numbered HAL entries and re-grouping, specifically (112,120) (84,106,108,117).
Admin:
  Tested on an ARM6/ARM7/SA Risc PC, BeagleBoard xM, Iyonix, Pandaboard ES, Wandboard Quad, IPEGv5, Titanium, Pi 2 and 3.
  Requires corresponding HAL change.
  Submission for USB bounty.

Version 5.89. Tagged as 'Kernel-5_89'
@
text
@d214 1
a214 1
        MOV     r3, #0                  ; initialise abort list
d216 3
@


4.24
log
@Add a compatibility page zero for high processor vectors / zero page relocation builds
Detail:
  When HiProcVecs is enabled, there will now be a read-only page located at &0 in order to ease compatibility with buggy software which reads from null pointers
  Although most of the page is zero-filled, the start of the page contains a few words which are invalid pointers, discouraging dereferencing them, and a warning message if the memory is interpreted as a string.
  On ARMv6+ the page is also made non-executable, to deal with branch-through-zero type situations
  OS_Memory 20 has been introduced as a way of determining whether the compatibility page is present, and also to enable/disable it
  File changes:
  - hdr/Options - Add CompatibilityPage option
  - hdr/OSMem - Declare OS_Memory reason code 20
  - hdr/KernelWS - When CompatibilityPage is enabled, make sure nothing else is located at &0
  - s/NewReset - Enable compatibility page just before Service_PostInit (try and keep zero-tolerance policy for null pointer dereferencing during ROM init)
  - s/MemInfo - OS_Memory 20 implementation. Add knowledge of the compatibility page to OS_Memory 16 and 24.
Admin:
  Tested on BB-xM


Version 5.87. Tagged as 'Kernel-5_87'
@
text
@d25 9
a33 10
; Keyboard flags
                ^ 1
KbdScanActive   # 1
                # 2
KbdFlags        # 4

; On ARM600, InitIRQWs is in zero page - check it's big enough

        ASSERT  @@ <= ?InitIRQWs

d58 1
a58 1
; FudgeConfigureRMA - move pages from free pool to somewhere
d63 2
a64 2
FudgeConfigureRMA
        Push    lr
d83 12
a94 1
        ADD     r3, r3, r10                     ; advance "to" pointer
d141 3
d146 6
a151 6
;StrongARM: OK, there is quite a bit of code poking below, to various addresses. We'll
;           defer IMB consideration till the poking's done, then do a full IMB (full
;           data cache clean). This avoids various little IMB's and removes chance of leaving
;           some unnoticed poked code in data cache. The deferral should be safe, because none
;           of the poked code will be used yet awhile (given that current IRQ hardware vector is
;           not actually changed below).
a184 1
        DebugTX "InitCMOSCache done"
d192 6
a201 8

; first save IOC soft copy so can restore it

        LDRB    R2, [R0, #IOCControlSoftCopy-IRQ1V]
        Push    "R2"
        LDRB    R2, [R0, #CannotReset-IRQ1V]
        Push    "R2"

a270 128
KeyWait * 200000                 ; 1/5 sec wait (in microseconds)
us      * 1

        AddressHAL
        MOV     r6, #25                 ; Check for keyboard 25 times (5 secs max).
        LDR     r4, =ZeroPage+InitIRQWs

kbdwait
        CallHAL HAL_KbdScan
        STR     r0, [r4, #KbdFlags]

        TST     r0, #KbdFlag_Done
        BNE     kbddone

        LDR     r0, =KeyWait*us         ; Wait 1/5 second (give keys down a chance to come in).
        CallHAL HAL_CounterDelay
        SUBS    r6, r6, #1              ; else wait a maximum of 5 seconds.
        BNE     kbdwait
kbddone
        MSR     CPSR_c, #I32_bit+SVC32_mode
        CallHAL HAL_KbdScanFinish
        LDR     r1, =ZeroPage+InitIRQWs
        MOV     r0, #0
        STRB    r0, [r1, #KbdScanActive]
        MSR     CPSR_c, #SVC32_mode
        DebugTX "Keyboard scan complete"

 [ ValidateCMOS
; Do a POR if some super-critical values are shagged or if checksum is invalid.
        MOV     R3, #-1                 ; do all RAM if we do any
        BL      ValChecksum             ; Always check the checksum
        BNE     cmos_reset
 ]

; IF power-on bit set AND R/T/Del/Copy pressed THEN reset CMOS RAM
; note that memory cleared if POR, so key info has had plenty of time!

        LDR     R0, =ZeroPage+HAL_StartFlags
        LDR     R1, [R0]
        TST     R1, #OSStartFlag_NoCMOS ; If no CMOS, reset for sensible cache
        BNE     cmos_reset
        TST     R1, #OSStartFlag_POR
        BEQ     no_cmos_reset           ; not a power on reset
        DebugTX "POR detected"
        TST     R1, #OSStartFlag_NoCMOSReset
        BNE     no_cmos_reset
        TST     R1, #OSStartFlag_CMOSReset
        BNE     cmos_reset

        LDR     R0, =ZeroPage+InitIRQWs
        LDR     R7, [R0, #KbdFlags]
        TST     R7, #KbdFlag_R:OR:KbdFlag_T:OR:KbdFlag_Delete:OR:KbdFlag_Copy
        LDRNE   R3, =ZeroPage
        MOVNE   R14, #1
        STRNEB  R14, [R3, #MentionCMOSReset]
        BEQ     no_cmos_reset           ; power on bit checked again there

; CMOS reset detectified.
; Wipe it, then squirt in the MOS's table of default values

        TST     R7, #KbdFlag_Copy:OR:KbdFlag_Delete
        MOVNE   R3, #-1                 ; Del or Copy does all RAM
        MOVEQ   R3, #UserCMOS           ; R or T just system
    [ ChecksumCMOS
        BL      ValChecksum             ; unless the CMOS ram's corrupt ..
        MOVNE   R3, #-1                 ; .. then blast it anyway.
    ]
cmos_reset
        DebugTX "Reset CMOS"
        ADD     sp, sp, #4              ; junk CannotReset flag from stack

        MOV     R4, #0
cmrlp
        CMP     R3, #-1
        BEQ     cmrall                  ; ignore system-only wipe checks
        CMP     R4, #UserCMOS
        MOVEQ   R4, #&50                ; skip User (30-45) & 3rd party (46-59) & high podules (60-79)
        BEQ     cmrall
        CMP     R4, #PoduleCMOS
        MOVEQ   R4, #&80                ; skip low podules (112-127)
        BEQ     cmrall
        TEQ     R4, #NewADFSCMOS        ; documented in 'Troubleshooting' in
        TEQNE   R4, #CountryCMOS        ; the RISC OS 3.7 user guide as preserved
        BEQ     cmrskip
cmrall
        MOV     R1, R4
        BL      NVMemory_ResetValue     ; get the reset value
        MOVS    R1, R2                  ; when -ve, leave alone
        MOVPL   R0, R4
        BLPL    Write                   ; CMOS(R0) := R1
cmrskip
        ADD     R4, R4, #1
        CMP     R4, #CMOSLimit
        BCC     cmrlp

; IF R or Delete pressed THEN set sync 0 ELSE set sync Auto
        LDR     R0, =ZeroPage+InitIRQWs
        LDR     R1, [R0, #KbdFlags]
        TST     R1, #KbdFlag_R:OR:KbdFlag_Delete
        MOV     R0, #VduCMOS
        MOVNE   R1, #MonitorTypeAuto :OR: Sync_Auto     ; if R or Del
        MOVEQ   R1, #MonitorTypeAuto :OR: Sync_Separate ; if T or Copy
        BL      Write

    [ ChecksumCMOS
        BL      MakeChecksum            ; create a valid checksum
    ]
        B       hard_reset              ; CMOS reset only checked on power on, so was hard

no_cmos_reset                           ; R1 has por_bit set if power on
        Push    "r1"
        MOV     r0, #SystemSpeedCMOS
        BL      Read
        BIC     r1, r0, #CMOSResetBit   ; clear bit indicating CMOS reset
        MOV     r0, #SystemSpeedCMOS
        BL      Write
        Pull    "r1"

        Pull    r0                      ; always pull CannotReset flag

hard_reset
hard_reset_forced
        LDR     r8, =ZeroPage

        Pull    "R2"                    ; discard old IOC state

        DebugTX "InitDynamicAreas"

d274 1
d395 2
a396 2
        LDR     R0, =(1024*1024):SHR:12 ; 1MB of RAM in aplspace should be plenty for ROM init. Theoretically we don't need any at all, but having some there should make it easier to debug any ROM init failures.
        MOV     R3, #32*1024            ; aplwork start
d399 1
a399 1
        BL      FudgeConfigureRMA       ; put some memory in aplspace
d403 1
a403 1
        ADD     R1, R1, #32*1024
d408 1
a408 1
        BL      InitVectors               ; ready for OsByte to read mode
d420 1
a423 2

     [  International
d432 2
a436 8

        ; Make the choice between PowerOn and Hard reset based purely on
        ; the state of the POR bit and NOT on whether memory was cleared.
 [ {FALSE}
        LDREQ   R0, =ZeroPage+OsbyteVars + :INDEX: LastBREAK
        LDREQB  R0, [R0]
        TSTEQ   R0, #&80                ; tbs set if memory cleared
 ]
a438 4


ResetPart1Done                          ; R0 is reset type
        WritePSRc SVC_mode + I_bit, r1  ; interrupts off since kbd bash done
a441 6
        LDR     R1, =ZeroPage+InitIRQWs
        LDR     R0, [R1, #KbdFlags]
        AND     R1, R0, #KbdFlag_Shift
        AND     R0, R0, #KbdFlag_Present
        Push    "R0, R1"                ; save until after MOSInit

d449 1
a449 1
 ASSERT Default_PFIQasIRQHandler_Node = Default_PIRQHandler_Node
d455 1
d472 1
a472 6

        LDR     R2, =ZeroPage+InitIRQWs                 ; clear temp ws
        MOV     R3, #0
        MOV     R4, #0
        STMIA   R2!, {R3,R4}
        STMIA   R2!, {R3,R4}
d475 2
a476 3
   ;we need to do an IMB type thing for modifying code in vector area,
   ;and for copying irq handler code
   ;
d479 1
a480 1

a484 1
        STR     R1, [R0, #TickNodeChain]
d486 1
a486 6
; clear the keyboard workspace (tidy!)
        ADD     R0, R0, #&1C
        MOV     R2, #InitWsEnd - &1C
        BL      memset

;now put in error handler and escape handler
a523 8
        MOV     R0, #&FD                ; read last reset type
        MOV     R1, #0
        MOV     R2, #&FF
        SWI     XOS_Byte
        CMP     R1, #SoftReset          ; soft reset?
        BEQ     SkipHardResetPart2

; HardResetPart2
d541 180
d722 1
a722 2
        BL      ModuleInit              ; initialise modules
                                        ; scan podules, copy modules.
a744 24
        ; Update RTC now all the modules are running
        SWI     XOS_ResyncTime

        ; OS_ReadSysInfo 9,2 now relies on the Territory module, which may
        ; enable IRQs. But the PRMs say OS_ReadSysInfo shouldn't alter the IRQ
        ; state. So call it once here just to initialise the string which it
        ; uses the Territory module to generate.
        ; This won't account for any modules using it during ModuleInit, but
        ; that should be pretty rare (or at least rare from within IRQ-sensitive
        ; code)
        MOV     R0, #9
        MOV     R1, #2
        SWI     XOS_ReadSysInfo

  [ UseNewFX0Error
        ; Also, *FX 0
        BL      InitNewFX0Error
  ]
  [ CompatibilityPage
        ; Enable low zero page compatibility page
        MOV     R0, #OSMemReason_Compatibility
        MOV     R1, #1
        SWI     XOS_Memory
  ]
a752 3
; New code added here by TMD 01-Apr-92
; Changed to use OS_LeaveOS 16-Oct-02

a759 1
; end of added code
d761 1
a761 1
     [ International                    ; Open the kernel messages file.
d763 1
a763 1
        ADR     r1, MessageFileName
d767 1
a767 4
      [ ZeroPage = 0
        STRVC   r0, [r0, #KernelMessagesBlock+1]  ; Message file is now open.
      |
        LDR     lr, =ZeroPage
d769 3
a772 1
     ]
d774 26
a799 7
SkipHardResetPart2                      ; code executed on all types of reset
      [ International
        LDR     r0, =ZeroPage
        LDR     r1, [r0, #KernelMessagesBlock] ; if we've managed to open message file
        TEQ     r1, #0
        ASSERT  (ZeroPage :AND: 255) = 0
        STRNEB  r0, [r0, #ErrorSemaphore] ; then allow errors to be translated
d822 1
a822 1
        MOV     R0, #124
d873 1
a873 6
        MOV     r0, #&FD                ; read last reset type (again!)
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        CMP     r1, #SoftReset          ; a softie?
        SWINE   XOS_WriteI+7            ; go beep! Yaay!
a881 1
        Push    "r1"
a892 1
        Pull    "r1"
d894 4
d899 1
a899 1
        BNE     %FT75
d904 1
a904 9
        BNE     %FT75

; if any monitor key pressed, reconfigure, otherwise hang around for a bit
; till keys get a chance to come in again after being reset for the umpteenth
; time by yet another keyboard handler! SKS 07-Jun-88

        LDR     r3, =ZeroPage
        LDR     r3, [r3, #MetroGnome]
        ADD     r3, r3, #10             ; Hang about for a little while
d906 1
a906 1
KeypadStar_key  * -92
d908 1
a908 2
HorologicalDelayLoop1
        MOV     r0, #&79                        ; scan keyboard
d915 1
a915 1
        BEQ     %FT70                           ; then check if we've run out of time
d921 1
a921 1
        BEQ     %FT70
d957 4
a960 1
        B       %FT75
a987 6
        LDR     r14, =ZeroPage
        LDR     r14, [r14, #MetroGnome]
        CMP     r14, r3
        BLO     HorologicalDelayLoop1
75

d992 4
a995 1
        Pull    "R0"                    ; first check kbd there
d997 10
a1006 2
        CMP     R0, #0
        BEQ     AutoBootCosNoKbd
d1008 2
a1009 1
        MOV     R0, #&FF
d1013 4
a1016 7
        AND     R0, R1, #8              ; picka da bit
        EOR     R0, R0, #8              ; invert sense
        Pull    "R1"
        CMP     R1, #0
        MOVNE   R1, #8
        EORS    R1, R1, R0
        BEQ     %FT80
d1035 1
a1035 3
; if either * pressed, drop into * prompt, otherwise hang around for a bit
; till keys get a chance to come in again after being reset for the umpteenth
; time by yet another keyboard handler! SKS 01-Jun-88
d1037 6
a1042 7
        LDR     r3, =ZeroPage
        LDR     r3, [r3, #MetroGnome]
        ADD     r3, r3, #10             ; Hang about for a little while

HorologicalDelayLoop2
        MOV     r1, #KeypadStar_key :AND: &FF
        BL      IsKeyPressedAtReset
a1044 6
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #MetroGnome]
        CMP     r0, r3
        BLO     HorologicalDelayLoop2


a1070 35

AutoBootCosNoKbd
      [ International
        SWI     XOS_WriteI+7
        BVS     %FT81
        BL      WriteS_Translated
        =       "NoKbd:No keyboard present - autobooting", 10,13,0
        ALIGN
81
      |
        SWI     XOS_WriteS
        =       7, "No keyboard present - autobooting", 10,13,0
        ALIGN
      ]
        B       Hortoculture_Kicking


RealIRQHandler
        LDR     PC, .-&18+ProcVec_IRQ

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = INKEY -ve key code to look for

; Out   EQ: key pressed
;       NE: key not pressed

IsKeyPressedAtReset Entry "r0-r2"

        MOV     r0, #129
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #&FF
        TEQEQ   r2, #&FF
        EXIT

@


4.23
log
@Implement support for cacheable pagetables
Detail:
  Modern ARMs (ARMv6+) introduce the possibility for the page table walk hardware to make use of the data cache(s) when performing memory accesses. This can significantly reduce the cost of a TLB miss on the system, and since the accesses are cache-coherent with the CPU it allows us to make the page tables cacheable for CPU (program) accesses also, improving the performance of page table manipulation by the OS.
  Even on ARMs where the page table walk can't use the data cache, it's been measured that page table manipulation operations can still benefit from placing the page tables in write-through or bufferable memory.
  So with that in mind, this set of changes updates the OS to allow cacheable/bufferable page tables to be used by the OS + MMU, using a system-appropriate cache policy.
  File changes:
  - hdr/KernelWS - Allocate workspace for storing the page flags that are to be used by the page tables
  - hdr/OSMem - Re-specify CP_CB_AlternativeDCache as having a different behaviour on ARMv6+ (inner write-through, outer write-back)
  - hdr/Options - Add CacheablePageTables option to allow switching back to non-cacheable page tables if necessary. Add SyncPageTables var which will be set {TRUE} if either the OS or the architecture requires a DSB after writing to a faulting page table entry.
  - s/ARM600, s/VMSAv6 - Add new SetTTBR & GetPageFlagsForCacheablePageTables functions. Update VMSAv6 for wider XCBTable (now 2 bytes per element)
  - s/ARMops - Update pre-ARMv7 MMU_Changing ARMops to drain the write buffer on entry if cacheable pagetables are in use (ARMv7+ already has this behaviour due to architectural requirements). For VMSAv6 Normal memory, change the way that the OS encodes the cache policy in the page table entries so that it's more compatible with the encoding used in the TTBR.
  - s/ChangeDyn - Update page table page flag handling to use PageTable_PageFlags. Make use of new PageTableSync macro.
  - s/Exceptions, s/AMBControl/memmap - Make use of new PageTableSync macro.
  - s/HAL - Update MMU initialisation sequence to make use of PageTable_PageFlags + SetTTBR
  - s/Kernel - Add PageTableSync macro, to be used after any write to a faulting page table entry
  - s/MemInfo - Update OS_Memory 0 page flag conversion. Update OS_Memory 24 to use new symbol for page table access permissions.
  - s/MemMap2 - Use PageTableSync. Add routines to enable/disable cacheable pagetables
  - s/NewReset - Enable cacheable pagetables once we're fully clear of the MMU initialision sequence (doing earlier would be trickier due to potential double-mapping)
Admin:
  Tested on pretty much everything currently supported
  Delivers moderate performance benefits to page table ops on old systems (e.g. 10% faster), astronomical benefits on some new systems (up to 8x faster)
  Stats: https://www.riscosopen.org/forum/forums/3/topics/2728?page=2#posts-58015


Version 5.71. Tagged as 'Kernel-5_71'
@
text
@d737 6
@


4.23.2.1
log
@Merge in latest changes from main branch


Version 5.88, 4.129.2.4. Tagged as 'Kernel-5_88-4_129_2_4'
@
text
@a736 6
  [ CompatibilityPage
        ; Enable low zero page compatibility page
        MOV     R0, #OSMemReason_Compatibility
        MOV     R1, #1
        SWI     XOS_Memory
  ]
@


4.23.2.2
log
@Merge latest changes from main branch

Version 5.89, 4.129.2.6. Tagged as 'Kernel-5_89-4_129_2_6'
@
text
@d25 10
a34 9
; Keyboard scan
KbdFlag_Ctrl    * 1:SHL:0
KbdFlag_Shift   * 1:SHL:1
KbdFlag_R       * 1:SHL:4
KbdFlag_T       * 1:SHL:5
KbdFlag_Delete  * 1:SHL:6
KbdFlag_Copy    * 1:SHL:7
KbdFlag_Present * 1:SHL:30
KbdFlag_Done    * 1:SHL:31
d59 1
a59 1
; FudgeSomeAppSpace - move pages from free pool to application space
d64 2
a65 2
FudgeSomeAppSpace
        Push    "lr"
d84 1
a84 12

        ADD     r2, r3, r10                     ; end of clear
        MOV     lr, #0
        MOV     ip, lr
15
        STMIA   r3!, {ip,lr}                    ; advance "to" pointer
        STMIA   r3!, {ip,lr}
        STMIA   r3!, {ip,lr}
        STMIA   r3!, {ip,lr}
        TEQ     r2, r3
        BNE     %BT15
        
a130 3
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Entry point from HALInit

d133 6
a138 6
; OK, there is quite a bit of code poking below, to various addresses. We'll
; defer IMB consideration till the poking's done, then do a full IMB (full
; data cache clean). This avoids various little IMB's and removes chance of leaving
; some unnoticed poked code in data cache. The deferral should be safe, because none
; of the poked code will be used yet awhile (given that current IRQ hardware vector is
; not actually changed below).
d172 1
a179 6
        BEQ     %FT41
        DebugTX "InitCMOSCache done"
        B       %FT42
41
        DebugTX "InitCMOSCache failed"
42
d184 8
d261 128
a391 1
        DebugTX "InitDynamicAreas"
d512 2
a513 2
        LDR     R0, =(512*1024):SHR:12  ; 512k of RAM in aplspace should be plenty for ROM init. Theoretically we don't need any at all, but having some there should make it easier to debug any ROM init failures.
        MOV     R3, #AppSpaceStart      ; aplwork start
d516 1
a516 1
        BL      FudgeSomeAppSpace       ; put some memory in aplspace
d520 1
a520 1
        ADD     R1, R1, #AppSpaceStart
d525 1
a525 1
        BL      InitVectors             ; ready for OsByte to read mode
a536 1
     [  International
d540 2
a549 2
        ; Make the choice between PowerOn and Hard reset based purely on
        ; the state of the POR bit and NOT on whether memory was cleared.
d553 8
d563 4
d570 6
d583 1
a583 1
        ASSERT Default_PFIQasIRQHandler_Node = Default_PIRQHandler_Node
a588 1
        STR     r0, [r3, #TickNodeChain]
d605 6
a610 1
        
d613 3
a615 2
        ; we need to do an IMB type thing for modifying code in vector area,
        ; and for copying irq handler code
d618 1
a619 1
        LDR     r0,=ZeroPage
d624 1
d626 6
a631 1
; now put in error handler and escape handler
d669 8
a693 180

        AddressHAL
        CallHAL HAL_KbdScanDependencies
        MOV     r5, r0
        DebugTX "ModuleInitForKbdScan"
        BL      ModuleInitForKbdScan

; minimal post module setup for keyboard scan

        BL      KeyPostInit

; scan keyboard for interesting keypresses R/T/Delete/End + Ctrl/Shift or timeout

        LDR     r3, =ZeroPage
        LDR     r6, [r3, #HAL_StartFlags]
        TST     r6, #OSStartFlag_RAMCleared
        MOVEQ   r6, #0                  ; RAM clear from start of free pool
        MOVNE   r6, #-1                 ; RAM clear not needed

        LDR     r3, [r3, #MetroGnome]
        ADD     r3, r3, #300            ; timeout (cs)
02
        CMP     r5, #-1                 ; HAL gave no KbdScan details
        BEQ     %FT04

        TST     r4, #KbdFlag_Present
        BNE     %FT03

        LDR     r0, =ZeroPage+KeyWorkSpace 
        LDRB    r0, [r0, #:INDEX:KbId]  ; check if anyone registered with KeyV
        CMP     r0, #&20                ; same limit as GetCountry
        BCS     %FT04

        ORR     r4, r4, #KbdFlag_Present
        DebugTX "KbdFlag_Present"
03
        MOV     r0, #OsByte_INKEY
        MOV     r1, #0 :EOR: &7F        ; scan from shift upwards
        MOV     r2, #255
        SWI     XOS_Byte
        TEQ     r1, #0
        ORREQ   r4, r4, #KbdFlag_Shift
        TEQ     r1, #1
        ORREQ   r4, r4, #KbdFlag_Ctrl
        TEQ     r1, #51
        ORREQ   r4, r4, #KbdFlag_R
        TEQ     r1, #35
        ORREQ   r4, r4, #KbdFlag_T
        TEQ     r1, #89
        ORREQ   r4, r4, #KbdFlag_Delete
        TEQ     r1, #105
        ORREQ   r4, r4, #KbdFlag_Copy
04
        SWI     XOS_LeaveOS
        SWI     XOS_EnterOS             ; callbacks

        ; Prior to getting here, ClearWkspRAM cleared low OS workspace & ScratchSpace, and
        ; Init_MapInRAM_Clear has selectively cleared other early allocations. That leaves
        ; everything from InitDynamicAreas
        ;   RMA => not cleared, it's in use
        ;   Screen => not cleared, the next CLS will do that
        ;   SpriteArea, RAMDisc, FontArea => not cleared, clients write their own data structures
        ; and
        ;   Application space (from FudgeSomeAppSpace) => cleared unconditionally 
        ;   Free pool => clear now if HAL didn't
        ; left to do.
        MOV     r0, r6
        BL      ClearFreePoolSection
        MOV     r6, r0
        CMP     r6, #-1
        BNE     %BT02                   ; the show's not over until the RAM clear is done

        CMP     r5, #-1
        BEQ     %FT05                   ; HAL gave no KbdScan details

        TST     r4, #KbdFlag_Shift :OR: KbdFlag_Ctrl :OR: KbdFlag_R :OR: KbdFlag_T :OR: KbdFlag_Delete
        BNE     %FT05                   ; exciting key press beats a timeout

        LDR     r0, =ZeroPage
        LDR     r0, [r0, #MetroGnome]
        CMP     r0, r3                  ; timed out?
        BCC     %BT02
05
        ORR     r4, r4, #KbdFlag_Done
        Push    "r4"                    ; save until after MOSInit

; Clear temp ws skipped earlier
        LDR     R0, =ZeroPage+InitWsStart               
        MOV     R1, #0
        MOV     R2, #InitWsEnd - InitWsStart
        BL      memset

cmos_checks
        MOV     R3, #-1                 ; do all CMOS if we do any
      [ ValidateCMOS
; Do a POR if some super-critical values are shagged or if checksum is invalid.
        BL      ValChecksum             ; Always check the checksum
        BNE     cmos_reset
      ]

; IF power-on bit set AND R/T/Del/Copy pressed THEN reset CMOS RAM

        LDR     R0, =ZeroPage+HAL_StartFlags
        LDR     R1, [R0]
        TST     R1, #OSStartFlag_NoCMOS ; If no CMOS, reset for sensible cache
        BNE     cmos_reset
        TST     R1, #OSStartFlag_POR
        BEQ     no_cmos_reset           ; not a power on reset
        DebugTX "POR detected"
        TST     R1, #OSStartFlag_NoCMOSReset
        BNE     no_cmos_reset
        TST     R1, #OSStartFlag_CMOSReset
        BNE     cmos_reset

        TST     R4, #KbdFlag_R:OR:KbdFlag_T:OR:KbdFlag_Delete:OR:KbdFlag_Copy
        LDRNE   R3, =ZeroPage
        MOVNE   R14, #1
        STRNEB  R14, [R3, #MentionCMOSReset]
        BEQ     no_cmos_reset           ; power on bit checked again there

; CMOS reset detectified.
; Wipe it, then squirt in the MOS's table of default values

        TST     R4, #KbdFlag_Copy:OR:KbdFlag_Delete
        MOVNE   R3, #-1                 ; Del or Copy does all RAM
        MOVEQ   R3, #UserCMOS           ; R or T just system
      [ ChecksumCMOS
        BL      ValChecksum             ; unless the CMOS ram's corrupt ..
        MOVNE   R3, #-1                 ; .. then blast it anyway.
      ]
cmos_reset
        DebugTX "Reset CMOS"

        MOV     R4, #0
cmrlp
        CMP     R3, #-1
        BEQ     cmrall                  ; ignore system-only wipe checks
        CMP     R4, #UserCMOS
        MOVEQ   R4, #&50                ; skip User (30-45) & 3rd party (46-59) & high podules (60-79)
        BEQ     cmrall
        CMP     R4, #PoduleCMOS
        MOVEQ   R4, #&80                ; skip low podules (112-127)
        BEQ     cmrall
        TEQ     R4, #NewADFSCMOS        ; documented in 'Troubleshooting' in
        TEQNE   R4, #CountryCMOS        ; the RISC OS 3.7 user guide as preserved
        BEQ     cmrskip
cmrall
        MOV     R1, R4
        BL      NVMemory_ResetValue     ; get the reset value
        MOVS    R1, R2                  ; when -ve, leave alone
        MOVPL   R0, R4
        BLPL    Write                   ; CMOS(R0) := R1
cmrskip
        ADD     R4, R4, #1
        CMP     R4, #CMOSLimit
        BCC     cmrlp

; IF R or Delete pressed THEN set sync 0 ELSE set sync Auto
        LDR     R4, [SP]
        TST     R4, #KbdFlag_R:OR:KbdFlag_Delete
        MOV     R0, #VduCMOS
        MOVNE   R1, #MonitorTypeAuto :OR: Sync_Auto     ; if R or Del
        MOVEQ   R1, #MonitorTypeAuto :OR: Sync_Separate ; if T or Copy
        BL      Write

      [ ChecksumCMOS
        BL      MakeChecksum            ; create a valid checksum
      ]
        B       init_other_modules

no_cmos_reset
        MOV     r0, #SystemSpeedCMOS
        BL      Read
        BIC     r1, r0, #CMOSResetBit   ; clear bit indicating CMOS reset
        MOV     r0, #SystemSpeedCMOS
        BL      Write

init_other_modules

; now go back and load the other modules, scan podules, accounting for frugal bits
d695 2
a696 1
        BL      ModuleInit
d719 24
d751 3
d761 1
d763 1
a763 1
      [ International                   ; Open the kernel messages file.
d765 1
a765 1
        ADRL    r1, MessageFileName
d769 4
a772 1
        LDRVC   lr, =ZeroPage
a773 3

        ASSERT  (ZeroPage :AND: 255) = 0  ; if we've managed to open message file
        STRVCB  lr, [lr, #ErrorSemaphore] ; then allow errors to be translated
d775 1
d777 7
a783 26
        ; Update RTC now all the modules are running
        SWI     XOS_ResyncTime

        ; OS_ReadSysInfo 9,2 now relies on the Territory module, which may
        ; enable IRQs. But the PRMs say OS_ReadSysInfo shouldn't alter the IRQ
        ; state. So call it once here just to initialise the string which it
        ; uses the Territory module to generate.
        ; This won't account for any modules using it during ModuleInit, but
        ; that should be pretty rare (or at least rare from within IRQ-sensitive
        ; code)
        ;
        ; Must also be after Service_PostInit to give TerritoryManager opportunity
        ; to load disc based territories. 
        MOV     R0, #9
        MOV     R1, #2
        SWI     XOS_ReadSysInfo

      [ UseNewFX0Error
        ; Also, *FX 0
        BL      InitNewFX0Error
      ]
      [ CompatibilityPage
        ; Enable low zero page compatibility page
        MOV     R0, #OSMemReason_Compatibility
        MOV     R1, #1
        SWI     XOS_Memory
d806 1
a806 1
        MOV     R0, #OsByte_ClearEscape
d857 6
a862 1
        SWI     XOS_WriteI+7            ; go beep! Yaay!
d871 1
d883 1
a884 4
        MOV     r0, #OsByte_RW_LastResetType
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
d886 1
a886 1
        BNE     %FT70
d891 9
a899 1
        BNE     %FT70
d901 1
a901 1
; if any keypad-numeric key pressed, reconfigure monitor type
d903 2
a904 1
        MOV     r0, #OsByte_ScanKeyboard        ; scan keyboard
d911 1
a911 1
        BEQ     %FT70                           ; then give up
d917 1
a917 1
        BEQ     %FT70                           ; give up, key not in table
d953 1
a953 4
        B       %FT70

RealIRQHandler
        LDR     PC, .-&18+ProcVec_IRQ
d981 6
d991 1
a991 1
        Pull    "R4"                    ; recover KbdFlag bits 
d993 2
a994 2
        TST     R4, #KbdFlag_Present    ; first check kbd there
        BNE     shifty_boot
d996 1
a996 13
      [ International
        BL      WriteS_Translated
        =       "NoKbd:No keyboard present - autobooting", 10,13,0
        ALIGN
      |
        SWI     XOS_WriteS
        =       7, "No keyboard present - autobooting", 10,13,0
        ALIGN
      ]
        B       Hortoculture_Kicking

shifty_boot
        MOV     R0, #OsByte_RW_StartupOptions
d1000 7
a1006 4
        TST     R4, #KbdFlag_Shift
        EORNE   R1, R1, #8              ; invert sense
        TST     R1, #8
        BNE     %FT80                   ; no boot when set
d1025 7
a1031 1
; if keypad-* pressed, drop into * prompt
d1033 3
a1035 6
        MOV     r0, #OsByte_INKEY
        MOV     r1, #KeyScan_NumPadStar :AND: &FF
        MOV     r2, #&FF
        SWI     XOS_Byte
        TEQ     r1, #&FF
        TEQEQ   r2, #&FF
d1038 6
d1070 35
@


4.23.2.3
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d214 1
a214 1
        MOV     r3, #0                  ; zero-initialise abort list, and other key workspace
a215 3
 [ CompatibilityPage
        STRB    r3, [r0, #CompatibilityPageEnabled]
 ]
d271 2
a272 1
; Get creating the essential areas
d277 1
a277 1
        ; RMA
d291 1
a291 1
        ; Screen
d302 1
a302 2
        BL      MassageScreenSize       ; Clamps the initial size regardless of the
                                        ; contents of the ScreenSizeCMOS
d318 78
a395 3
        LDR     R0, =(512*1024):SHR:12  ; 512k of RAM in aplspace should be plenty for ROM init. 
                                        ; Theoretically we don't need any at all, but having some there
                                        ; should make it easier to debug any ROM init failures.
d500 2
d602 1
a646 1

a719 10
; init that's deferrable until the CMOS is sanitised
        DebugTX "ReadDefaults"
        BYTEWS  WsPtr
        BL      ReadHardCMOSDefaults
        BL      ReadCMOSDefaults
        DebugTX "InitHostedDAs"
        BL      InitHostedDAs
        DebugTX "MouseInit"
        BL      MouseInit

a744 10
        ; Update territory in case it changed after ModuleInitForKbdScan
        MOV     R0, #ReadCMOS
        MOV     R1, #TerritoryCMOS
        SWI     XOS_Byte
        EOR     R0, R2, #1              ; encoded so that 0 => TerritoryNum_UK
        SWI     XTerritory_Select

        ; Update RTC now all the modules are running
        SWI     XOS_ResyncTime

d774 3
@


4.23.2.4
log
@Merge latest changes from HEAD

Version 6.08, 4.129.2.9. Tagged as 'Kernel-6_08-4_129_2_9'
@
text
@d58 46
d134 1
d321 13
a333 7
        MOV     R0, #ChangeDyn_FreePool ; 512k of RAM in AplSpace should be plenty for ROM init. 
        MOV     R1, #512*1024           ; Theoretically we don't need any at all, but having some there
        RSB     R1, R1, #0              ; should make it easier to debug any ROM init failures.
        SWI     XOS_ChangeDynamicArea
        LDR     R1, =ZeroPage
        LDR     R0, [R1, #AplWorkSize]
        STR     R0, [R1, #MemLimit]
a334 5
        MOV     R0, AppSpaceStart
        MOV     R1, #0
        MOV     R2, #512*1024
        BL      memset                  ; Clear AplSpace
        
d340 1
d342 1
d529 1
a529 1
        ;   AplSpace (first 512k) => cleared unconditionally
@


4.22
log
@Add support for shareable pages and additional access privileges
Detail:
  This set of changes:
  * Refactors page table entry encoding/decoding so that it's (mostly) performed via functions in the MMU files (s.ARM600, s.VMSAv6) rather than on an ad-hoc basis as was the case previously
  * Page table entry encoding/decoding performed during ROM init is also handled via the MMU functions, which resolves some cases where the wrong cache policy was in use on ARMv6+
  * Adds basic support for shareable pages - on non-uniprocessor systems all pages will be marked as shareable (however, we are currently lacking ARMops which broadcast cache maintenance operations to other cores, so safe sharing of cacheable regions isn't possible yet)
  * Adds support for the VMSA XN flag and the "privileged ROM" access permission. These are exposed via RISC OS access privileges 4 and above, taking advantage of the fact that 4 bits have always been reserved for AP values but only 4 values were defined
  * Adds OS_Memory 17 and 18 to convert RWX-style access flags to and from RISC OS access privelege numbers; this allows us to make arbitrary changes to the mappings of AP values 4+ between different OS/hardware versions, and allows software to more easily cope with cases where the most precise AP isn't available (e.g. no XN on <=ARMv5)
  * Extends OS_Memory 24 (CheckMemoryAccess) to return executability information
  * Adds exported OSMem header containing definitions for OS_Memory and OS_DynamicArea
  File changes:
  - Makefile - export C and assembler versions of hdr/OSMem
  - Resources/UK/Messages - Add more text for OS_Memory errors
  - hdr/KernelWS - Correct comment regarding DCacheCleanAddress. Allocate workspace for MMU_PPLTrans and MMU_PPLAccess.
  - hdr/OSMem - New file containing exported OS_Memory and OS_DynamicArea constants, and public page flags
  - hdr/Options - Reduce scope of ARM6support to only cover builds which require ARMv3 support
  - s/AMBControl/Workspace - Clarify AMBNode_PPL usage
  - s/AMBControl/growp, mapslot, mapsome, memmap - Use AreaFlags_ instead of AP_
  - s/AMBControl/main, memmap - Use GetPTE instead of generating page table entry manually
  - s/ARM600 - Remove old coments relating to lack of stack. Update BangCam to use GetPTE. Update PPL tables, removing PPLTransL1 (L1 entries are now derived from L2 table on demand) and adding a separate table for ARM6. Implement the ARM600 versions of the Get*PTE ('get page table entry') and Decode*Entry functions
  - s/ARMops - Add Init_PCBTrans function to allow relevant MMU_PPLTrans/MMU_PCBTrans pointers to be set up during the pre-MMU stage of ROM init. Update ARM_Analyse to set up the pointers that are used post MMU init.
  - s/ChangeDyn - Move a bunch of flags to hdr/OSMem. Rename the AP_ dynamic area flags to AreaFlags_ to avoid name clashes and confusion with the page table AP_ values exported by Hdr:MEMM.ARM600/Hdr:MEMM.VMSAv6. Also generate the relevant flags for OS_Memory 24 so that it can refer to the fixed areas by their name instead of hardcoding the permissions.
  - s/GetAll - GET Hdr:OSMem
  - s/HAL - Change initial page table setup to use DA/page flags and GetPTE instead of building page table entries manually. Simplify AllocateL2PT by removing the requirement for the user to supply the access perimssions that will be used for the area; instead for ARM6 we just assume that cacheable memory is the norm and set L1_U for any L1 entry we create here.
  - s/Kernel - Add GetPTE macro (for easier integration of Get*PTE functions) and GenPPLAccess macro (for easy generation of OS_Memory 24 flags)
  - s/MemInfo - Fixup OS_Memory 0 to not fail on seeing non-executable pages. Implement OS_Memory 17 & 18. Tidy up some error generation. Make OS_Memory 13 use GetPTE. Extend OS_Memory 24 to return (non-) executability information, to use the named CMA_ constants generated by s/ChangeDyn, and to use the Decode*Entry functions when it's necessary to decode page table entries.
  - s/NewReset - Use AreaFlags_ instead of AP_
  - s/VMSAv6 - Remove old comments relating to lack of stack. Update BangCam to use GetPTE. Update PPL tables, removing PPLTransL1 (L1 entries are now derived from L2 table on demand) and adding a separate table for shareable pages. Implement the VMSAv6 versions of the Get*PTE and Decode*Entry functions.
Admin:
  Tested on Raspberry Pi 1, Raspberry Pi 3, Iyonix, RPCEmu (ARM6 & ARM7), comparing before and after CAM and page table dumps to check for any unexpected differences


Version 5.55. Tagged as 'Kernel-5_55'
@
text
@d248 7
@


4.21
log
@Resolve 2x header clashes
hdr/AHCIDevice:
  Remove this, since it clashes with the (differing API version number) copy exported by SATADriver. Post merging the Kernel back to the trunk the newer file datestamp has meant the wrong one gets exported during any ROM build which includes both components. Since the Kernel doesn't need AHCIDevice itself, it is left to the respective client (SATADriver or AHCIDriver in this case) to export them.
hdr/ModHand:
  Resolve the longstanding clash of Module_Title with the same named symbol that CMHG uses. There are very few assembler needing to look at the module header (Kernel, FileCore, Debugger, Podule) directly, but every C module which uses CMHG and wants one of the ModHandReason values ends up with a duplicate define.
  Obsolete Arthur era Module_LoadAddr value.
ArthurSWIs.s/MoreComms.s/NewReset.s/SWINaming.s/SysComms.s/Utility.s:
  Module_Title->Module_TitleStr.
ModHand.s:
  Module_Title->Module_TitleStr.
  Recode Module_LoadAddr using the file type from Hdr:FileTypes.
GetAlls.s:
  Drop unused NVRAM and PortMan headers. Add Hdr:FileTypes.

Version 5.54. Tagged as 'Kernel-5_54'
@
text
@d392 1
a392 1
        MOV     r4, #AP_RMA             ; Area flags
d417 1
a417 1
        LDR     r4, =AP_Screen          ; area flags
d443 1
a443 1
        MOV     r4, #AP_Sprites         ; Area flags
d460 2
a461 2
        MOVEQ   r4, #AP_RAMDisc_SA      ; Area flags, if StrongARM  (introduced for Ursula)
        MOVNE   r4, #AP_RAMDisc         ; Area flags
d495 1
a495 1
        MOV     r4, #AP_FontArea        ; Area flags
d508 1
a508 1
        MOV     r11, #AP_AppSpace
@


4.20
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d1042 1
a1042 1
        LDR     R2, [R3, #Module_Title]
@


4.19
log
@Delete STB code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a desktop build):
  * STB
  * RO371Timings
  * NormalSpeedROMS
  * AutoSpeedROMS
  * RISCPCBurstMode
  * InterlacedPointer
  * ParallelFlashUpgrade (and s/FlashROM file)
  * Embedded_UI
  Some of the deleted code might be worth revisiting in future:
  * OS_ReadSysInfo 4 support for storing the MAC in alternate CMOS locations (including 2nd copy for error checking) or fetching via Service_MachineAddress
  * Mouse handling changes, possibly aimed at hiding the mouse pointer if a mouse isn't connected
  * More strict CMOS validation in s/NewReset
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.50. Tagged as 'Kernel-5_50'
@
text
@a139 1
 [ ProcessorVectors
a153 1
 ]
a267 5
      [ EmulatorSupport
        ARM_on_emulator r0
        MOVEQ   r0, #us
        LDRNE   r0, =KeyWait*us         ; Wait 1/5 second (give keys down a chance to come in).
      |
a268 1
      ]
a297 1
      [ CheckProtectionLink
a299 1
      ]
a374 3
 [ DebugForcedReset
        MOV     r2, #0                  ; indicate normal hard reset
 ]
a376 3
 [ DebugForcedReset
        STR     r2, [r8]                ; store to logical address zero
 ]
a592 5
 [ DebugForcedReset
        LDR     R1, [R0]
        TEQ     R1, #0                                  ; if normal hard reset
        LDREQ   R1, BranchThroughZeroInstruction2       ; then get branchthruzero code
 |
a593 1
 ]
a658 1
        [ DoInitialiseMode
a660 1
        ]
a772 1
      [ DoInitialiseMode
a773 1
      ]
a874 1
 [ CheckProtectionLink
a878 2
 ]

a885 5
 [ EmulatorSupport
        ARM_on_emulator r0
        ADDEQ   r3, r3, #1
        ADDNE   r3, r3, #10             ; Hang about for a little while
 |
a886 1
 ]
a925 1
    [ DoInitialiseMode
a939 1
    ]
a942 1
 [ ProcessorVectors
a943 3
 |
        B       .+Branch0_Trampoline
 ]
a1017 5
 [ EmulatorSupport
        ARM_on_emulator r1
        ADDEQ   r3, r3, #1
        ADDNE   r3, r3, #10             ; Hang about for a little while
 |
a1018 1
 ]
a1074 1
 [ ProcessorVectors
a1075 3
 |
        B     Initial_IRQ_Code+.-&18
 ]
@


4.18
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a295 36
 [ ValidateCMOS :LAND: STB

; ScreenSizeCMOS, RAMDiscCMOS, SysHeapCMOS, RMASizeCMOS and SpriteSizeCMOS
; should be 0. Happily they are at consecutive addresses so we can loop through
; them.
        MOV     R1, #ScreenSizeCMOS
reset_loop
        MOV     R0, R1
        BL      Read
        TEQ     R0, #0
        BNE     cmos_reset
        INC     R1
        TEQ     R1, #SpriteSizeCMOS
        BHI     reset_loop

; Year should be >=1995, <=2037 (when 32 bit signed Unix time breaks)
        MOV     R0, #YearCMOS+1
        BL      Read
        MOV     R1, R0
        MOV     R0, #YearCMOS+0
        BL      Read
        MOV     R2, #100
        MLA     R0, R2, R1, R0
        LDR     R1, =1995
        SUB     R0, R0, R1
        CMP     R0, #2037 - 1995
        BHI     cmos_reset

; Bit 4 of DBTBCMOS should be 1 (Boot)
        MOV     R0, #DBTBCMOS
        BL      Read
        TST     R0, #(1:SHL:4)
        BEQ     cmos_reset
 ]


d681 1
a681 1
        [ DoInitialiseMode :LOR: :LNOT: Embedded_UI
d797 1
a797 1
      [ DoInitialiseMode :LOR: :LNOT: Embedded_UI
a799 1
    [ :LNOT: Embedded_UI
a845 3
    |
        ! 0,    "Banner & printing of processor type disabled"
    ]
d961 1
a961 1
    [ DoInitialiseMode :LOR: :LNOT: Embedded_UI
a1105 1
    [ :LNOT: Embedded_UI
a1117 1
    ]
@


4.17
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a26 1
 [ HAL
a29 17
 |
CTRL_Down_Flag  # 1
SHIFT_Down_Flag # 1
KB_There_Flag   # 1

R_Down_Flag     # 1      ; note that these 4 form one word!!
T_Down_Flag     # 1
Del_Down_Flag   # 1
Copy_Down_Flag  # 1

KeyDataPtr      # 4

Port2Present    # 1      ; note that these 4 form one word!!
Port3Present    # 1
KeyState        # 1
KeyMSB          # 1
 ]
a123 1
  [ HAL
a129 269
  ]


  [ :LNOT: HAL

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data tables: VIDC := mode 0, all palette black

VIDCTAB

; Program Control Register first, to clear power-down bit
; Now depending upon the VIDCClockSource flag, re-program the clock source.
   [ VIDCClockSource = "VCO"
     [ VCOstartfix
        & &E0000404     ; CR: FIFO load 16 words, 1 bpp, ck/2, vclk (allow for doubled VCO freq)
     |
        & &E0000400     ; CR: FIFO load 16 words, 1 bpp, ck/1, vclk
     ]
   ]
   [ VIDCClockSource = "HCLK"
        & &E0000401     ; CR: FIFO load 16 words, 1 bpp, ck/1, hclk
   ]
   [ VIDCClockSource = "RCLK"
        & &E0000406     ; CR: FIFO load 16 words, 1 bpp, ck/2, rclk
   ]

; Don't bother programming all 256 palette entries, we'll be here all night
; Since we're setting up a 1 bit-per-pixel mode, just do colours 0 and 1

        & &10000000     ; Palette address register = 0
        & &00000000     ; Colour 0 = black
        & &00000000     ; Colour 1 = black
        & &40000000     ; Border colour = black
        & &50000000     ; Pointer colour 1 = black
        & &60000000     ; Pointer colour 2 = black
        & &70000000     ; Pointer colour 3 = black

; Get a stable display up so we get stable signals

        & &800003F8     ; HCR  = 76 + 88 + 96 + 640 + 96 + 28
        & &81000044     ; HSWR = 76
        & &82000098     ; HBSR = 76 + 88
        & &830000F2     ; HDSR = 76 + 88 + 96
        & &84000372     ; HDER = 76 + 88 + 96 + 640
        & &850003D8     ; HBER = 76 + 88 + 96 + 640 + 96
        & &860000F3     ; HCSR = HDSR

        & &90000137     ; VCR  = 3 + 19 + 16 + 256 + 16 + 2
        & &91000002     ; VSWR = 3
        & &92000015     ; VBSR = 3 + 19
        & &93000025     ; VDSR = 3 + 19 + 16
        & &94000125     ; VDER = 3 + 19 + 16 + 256
        & &95000135     ; VBER = 3 + 19 + 16 + 256 + 16
        & &96000025     ; VCSR = VDSR
        & &97000025     ; VCER = VDSR

        & &B1000001     ; SCR: sound disabled (+use 24MHz clock)

        & &C00F1003     ; EREG = comp sync, DACs on, ereg output ext lut
   [ VCOstartfix
        & &D0000302     ; FSYNREG, clk = (3+1)/(2+1) * 24MHz = 32MHz  (higher frequency as part of fix)
   |
        & &D0000305     ; FSYNREG, clk = (3+1)/(5+1) * 24MHz = 16MHz
   ]
        & &F0013000     ; DCR: bus D[31:0], Hdisc       ;RCM 29/9/94: changed from &F0012000 at PSwindells request
        & &FFFFFFFF     ; That's the lot


VIDCPhys        *       &03400000       ; used to address VIDC when MMU is off


; Entered here after RESET (or BREAK)

; This code must be capable of being executed at a non-ROM address and with the MMU off,
; and running in 32-bit mode up until the call to MemSize.

CONT_Break
        MOV     r1, #1          ; parameter passed to InitMEMC, to indicate Break not Reset
        B       Continue

CONT    ROUT
        MOV     r1, #0          ; parameter passed to InitMEMC, to indicate Reset not Break
Continue

; First bang MEMC to ensure safety

        BL      InitMEMC        ; initialise MEMC CR, and turn off MMU if it's on

; VInit etc set on ze mode change: no DMA going yet so don't set owt.

        MOV     R1, #VIDCPhys   ; Must ALWAYS initialise VIDC on reset or else
        ADR     R2, VIDCTAB     ; we may get vsync interrupts that stiff us
10      LDR     R0, [R2], #4    ; permanently as VIDC is in an undefined state
        CMP     R0, #-1         ; so have mode 0 with all black palette
        STRNE   R0, [R1]
        BNE     %BT10

; Now bang IOC (disable all but keyboard interrupts)

        MOV     R1, #IOC
        MOV     R0, #&FF                ; all inputs
        STRB    R0, [R1, #IOCControl]   ; in case called by Tim

        MOV     R0, #0
        STRB    R0, [R1, #IOCIRQMSKA]   ; kein interrupts
        STRB    R0, [R1, #IOCFIQMSK]    ; disable FIQs
        STRB    R0, [R1, #IOMD_DMAMSK]  ; disable DMA interrupts, too
        STRB    R0, [R1, #IOMD_IRQMSKC] ; and the rest...
        STRB    R0, [R1, #IOMD_IRQMSKD]

  [ Keyboard_Type = "A1A500" :LOR: Keyboard_Type = "PC"
        MOV     R0, #KARTRxBit          ; used for Archi keyboard or IOMD PC keyboard
  ]
        STRB    R0, [R1, #IOCIRQMSKB]   ; allow communication with kbd, when I_bit gets cleared

; now bits to allow CMOS read/write : need timer

        LDR     R0, =20000-1    ; R0 = Timer delay (units of 0.5 microsecond)
                                ; 20000*0.5E-6 = 0.01 Seconds (100Hz ticker)
                                ; TMD 21-May-93: "-1" correction applied

        STRB    R0, [R1, #Timer0LL]     ; Set up the delay
        MOV     R0, R0, LSR #8
        STRB    R0, [R1, #Timer0LH]
        STRB    R0, [R1, #Timer0GO]     ; and start the ticks

        MOV     R0, #timer0_bit
        STRB    R0, [R1, #IOCIRQCLRA]   ; Clear pending t0 interrupt j.i.c.

  [ VCOstartfix
        ;2nd part of fix for VCO failing to start on A7000 (esp. 7500FE) - forcing PCOMP high for about 3 ms
        LDRB    R0, [R1,#IOMD_ID0]
        CMP     R0, #&E7
        LDREQB  R0, [R1,#IOMD_ID1]
        CMPEQ   R0, #&D4
        BEQ     vcofix_notMorris      ; risky to force PCOMP on Risc PC
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000342        ; VIDC20 FSYNREG, as in VIDCTAB but with force PCOMP high
        STR     R2, [R0]
        MOV     R0, #3072*2           ; time delay of about 3 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
vcofix_waitloop
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     vcofix_waitloop       ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     vcofix_waitloop       ; loop if not finished
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000302        ; VIDC20 FSYNREG, as in VIDCTAB (PCOMP low again)
        STR     R2, [R0]
vcofix_notMorris
  ]

; now size memory

        BL      MemSize                 ; out: r0 = page size, r1 = memory size, r2 = MEMC CR value, r3-r14 corrupt

MemSized
        MOV     R8, R0                  ; R8 = page size in bytes
        MOV     R13, R1                 ; R13 is now the RAM size
        MOV     R9, R2                  ; need this to set soft copy right

   [ EmulatorSupport
        ARM_on_emulator R7
        MOVEQ   R7,#&80
        ORREQ   R7,R7,#&3E00            ; r7 := &3E80 = 16000 (standard Risc PC value)
        BLNE    TimeCPU                 ; r7 := CPU speed in kHz/MEMC1a flag
   |
        BL      TimeCPU                 ; r7 := CPU speed in kHz/MEMC1a flag
   ]

; the fixed areas give us : IRQ stack (in cursor), SVC stack (in sysheap base)
; and bottom block makes most sense done here

; now keyboard initialisation: initialise baud rate, send dummy, read dummy

        MOV     R0, #InitKbdWs
        MOV     R1, #0
        STRB    R1, [R0, #CTRL_Down_Flag] ; clear CTRL down flag, R down flag
        STRB    R1, [R0, #SHIFT_Down_Flag]
        STRB    R1, [R0, #KB_There_Flag]
        STR     R1, [R0, #R_Down_Flag]  ; all CMOS reset flags
        STR     R1, [R0, #KeyDataPtr]
        STR     R1, [R0, #Port2Present] ; all KbdRes vars

        B       SetUpKbd                ; No stack yet so branch and branch back.
SetUpKbdReturn


; set up reset interrupt handler (reads, discards keys, setting flags if CTRL or R)
; NB on ARM600 we need to go into 32-bit mode, so we can safely overwrite vectors

        MRS     r0, CPSR                ; switch into IRQ32, still IRQs disabled
        BIC     r0, r0, #&1F
        ORR     r1, r0, #IRQ32_mode
        MSR     CPSR_c, r1

        LDR     sp_irq, =IRQSTK         ; set up sp_irq

        ADRL    R2, MOSROMVecs          ; pick up from table
        LDR     R2, [R2, #&18]          ; this gets overwritten while active,
        MOV     R3, #0
        STR     R2, [R3, #&18]          ; but hopefully by the same value!

        ADDR    R2, IRQ_Test_CTRL_or_R_Pressed ; (could use ADRL, but ADDR macro is nicer)
        STR     R2, [R3, #InitIRQHandler] ; instruction is now a LDR PC,InitKbdHandler

        ORR     r0, r0, #SVC32_mode     ; switch into SVC32

 [ StrongARM
   ;for StrongARM, we need to do an IMB type thing for modifying code in vector area
        ARM_read_ID r1
        AND     r1,r1,#&F000
        CMP     r1,#&A000
        BNE     vectorpoke_notSA_1
        MOV     r1,#0                   ;we clean one cache entry, 0..1F, = vector area
  [ SAcleanflushbroken
        ARMA_clean_DCentry r1
        ARMA_flush_DCentry r1
  |
        ARMA_cleanflush_DCentry r1
  ]
        ARMA_drain_WB
        ARMA_flush_IC
vectorpoke_notSA_1
 ]

        BIC     r0, r0, #I32_bit        ; and enable IRQs
        MSR     CPSR_c, r0

 ; in SVC32 from now until we've finished poking around with vectors



 [ :LNOT: AlwaysClearRAM

; IF por OR FX200 bit set THEN clear memory
        MOV     R0, #IOC
        LDRB    R1, [R0, #IOCIRQSTAA]
        ANDS    R1, R1, #por_bit
        BNE     %FT20

        LDR     R0, =OsbyteVars + :INDEX: ESCBREAK
        LDRB    R1, [R0]
        CMP     R1, #2                  ; unlike popular rumour, bit 1 ain't
        CMPNE   R1, #3                  ; a flag
        BNE     %FT30
20
 ]
        BL      ClearPhysRAM
30
        MOV     r0, #0
        STR     r9, [r0, #MEMC_CR_SoftCopy] ; set soft copy.
        STR     r7, [r0, #MemorySpeed]  ; Remember CPU speed/MEMC1a flag
        STR     r8, [r0, #Page_Size]    ; r8 is still page size from way up there
        STR     r13, [r0, #RAMLIMIT]    ; save sussed memory size in LogRam

        LDR     sp, =SVCSTK             ; set up a stack

; do as much other initialisation as possible, to give keyboard stuff time
 [ StrongARM
        BL      Processor_Type          ; Determines the processor type & stores it in page 0.
 ]


  ]    ; :LNOT: HAL
a170 9
 [ :LNOT: No26bitCode
; Now we have set up the hardware vectors we can drop back to SVC26 mode

        MRS     r0, CPSR
        BIC     r0, r0, #&1F
        ORR     r0, r0, #SVC26_mode
        MSR     CPSR_c, r0
 ]

a256 1
 [ HAL
a257 3
 |
us      * 2
 ]
a258 1
 [ HAL
a287 23
 |
    [ KeyWait <> 0
; Check for keyboard there every 1/5 sec. but give up after 2 secs.
        MOV     r2, #IOC
        MOV     r6, #10                 ; Check for keyboard 10 times (2 secs max).
        MOV     r4, #InitKbdWs
kbdwait
        LDRB    r5, [r4, #KB_There_Flag]
      [ EmulatorSupport
        ARM_on_emulator r0
        MOVEQ   r0, #us
        LDRNE   r0, =KeyWait*us         ; Wait 1/5 second (give keys down a chance to come in).
      |
        LDR     r0, =KeyWait*us         ; Wait 1/5 second (give keys down a chance to come in).
      ]
        BL      DoMicroDelay
        TEQ     r5, #0                  ; If keyboard was there 1/5 second ago then
        BNE     kbdthere                ;   continue reset
        SUBS    r6, r6, #1              ; else wait a maximum of 2 seconds.
        BNE     kbdwait
kbdthere
    ]
 ]
a334 1
 [ HAL
a347 30
 |
        MOV     R0, #IOC
        LDRB    R1, [R0, #IOCIRQSTAA]
        ANDS    R1, R1, #por_bit
        BEQ     no_cmos_reset

      [ CheckProtectionLink
        LDR     r0, =IOMD_MonitorType

        ; on Issue A's the protection bit is only weakly pulled up,
        ; so force it high, then read it back
        LDRB    r1, [r0]
        ORR     r1, r1, #IOMD_ProtectionLinkBit
        STRB    r1, [r0]

        LDRB    r1, [r0]
        TST     r1, #IOMD_ProtectionLinkBit
        BEQ     no_cmos_reset           ; if zero then CMOS is protected
      ]

    [ STB :LAND: IOMD_C_FrontPanelButton <> 0
      [ FrontPanelButtClearsCMOS
        MOV     r0, #IOMD_Base          ; if front panel button pressed then CMOS reset
        LDRB    r0, [r0, #IOMD_CLINES]
        TST     r0, #IOMD_C_FrontPanelButton
        BEQ     cmos_reset
      ]
    ]

 ]
a349 1
 [ HAL
a351 4
 |
        LDR     R7, [R0, #R_Down_Flag]  ; Picks up R/T/Del/Copy flags all in one
        CMP     R7, #0
 ]
a359 1
 [ HAL
a360 5
 |
        ASSERT  (Del_Down_Flag - R_Down_Flag) = 2
        ASSERT  (Copy_Down_Flag - Del_Down_Flag) = 1
        MOVS    R3, R7, LSR #16         ; full reset or just system?
 ]
a396 1
 [ HAL
a398 6
 |
        LDRB    R1, [R0, #R_Down_Flag]
        CMP     R1, #0
        LDREQB  R1, [R0, #Del_Down_Flag]
        CMPEQ   R1, #0
 ]
a479 16
  [ LongCommandLines :LAND: (:LNOT: HAL)
        ;sort out the Kernel buffers dynamic area
        Push    "r0-r12"
        MOV     r1, #ChangeDyn_Kbuffs   ; Area number
        MOV     r2, #KbuffsSize         ; Initial (and in fact permanent) size
        LDR     r3, =KbuffsBaseAddress  ; Base address
        MOV     r4, #AP_Kbuffs          ; Area flags
        MOV     r5, #KbuffsMaxSize      ; Maximum size
        MOV     r6, #0                  ; no handler
        MOV     r7, #0
        ADRL    r8, AreaName_Kbuffs     ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
        Pull    "r0-r12"
  ]

a594 1
  [ HAL
a597 7
  |
        MOV     R0, #IOC
        LDRB    R1, [R0, #IOCIRQSTAA]
        ANDS    R1, R1, #por_bit
        STRNEB  R1, [R0, #IOCIRQCLRA]   ; clear POR if set
  ]

a615 1
 [ HAL
a618 4
 |
        LDRB    R0, [R1, #KB_There_Flag]
        LDRB    R1, [R1, #SHIFT_Down_Flag]
 ]
a644 10
 [ :LNOT: No26bitCode

; we're poking locations 0 and &18 here, so we'd best go back to SVC32

        MRS     r2, CPSR
        BIC     r3, r2, #&1F
        ORR     r3, r3, #SVC32_mode
        MSR     CPSR_c, r3
 ]

a670 8

 [ :LNOT:No26bitCode

; now back to SVC26

        MSR     CPSR_c, r2
 ]

a729 1
 [ HAL
a742 3
 |
        BL      L1L2PTenhancements      ; little tricks on cacheability etc for performance
 ]
a807 3
  [ :LNOT: HAL :LAND: RO371Timings
        BL      finalmemoryspeed
  ]
d941 1
a941 1
 [ HAL :LAND: CheckProtectionLink
a945 7
 |
      [ CheckProtectionLink
        LDR     r1, =IOMD_MonitorType   ; check link bit again
        LDRB    r1, [r1]                ; no need to preload bus, since should
        TST     r1, #IOMD_ProtectionLinkBit ; be still there from earlier
        BEQ     %FT75                   ; zero => protected
      ]
a1047 50
 [ StrongARM :LAND: :LNOT: HAL
cputable
        DCD &6000,0,0
        DCD &6100,1,0
        DCD &7000,2,0
        DCD &7100,3,0
        DCD &8100,4,2_11101
        DCD &a100,5,2_11011 ;corrected for 3.71 (SA does not abort for vector reads in 26-bit mode)
        DCD &7500,6,0
        DCD &7501,7,0
        DCD -1

Processor_Type
        MOV     r0,#IOMD_Base
        LDRB    r1,[r0,#IOMD_ID0]
        CMP     r1,#&E7
        LDRB    r1,[r0,#IOMD_ID1]
        CMPEQ   r1,#&D4
        BEQ     PT_RiscPC               ; E7,D4 means Risc PC
        CMP     r1,#&5B
        MOVEQ   r0,#&7500               ; 5B means 7500
        BEQ     PT_lookup
        CMP     r1,#&AA
        MOVEQ   r0,#&7500
        ORREQ   r0,r0,#&0001            ; AA means 7500FE - mark as 7501
        BEQ     PT_lookup
PT_RiscPC
        ReadCop  R0,CR_ID               ; see data sheets for values
        ; ARM 600 funny
        TST     R0,#&f000
        MOVEQ   R0,R0, LSL #4
        AND     R0,R0,#&ff00
PT_lookup
        ADR     R1,cputable
66
        LDR     R2,[R1],#4
        TEQ     R2,#0
        MOVMI   R0,#0
        STRMI   R2,[R0,#ProcessorType]
        MOVMI   PC,LR
        TEQ     R2,R0
        ADDNE   R1,R1,#8
        BNE     %BT66
        LDMIA   R1,{R0,R2}
        MOV     R1,#0
        STRB    R0,[R1,#ProcessorType]
        STR     R2,[R1,#ProcessorFlags]
        MOV     PC,LR
 ]

@


4.16
log
@  Fixed minor bug in module initialisation.
  Added common error cache.
Detail:
  Fixed module header validation code which was broken in 5.22.  This
    shouldn't have caused much of a problem as it was only a bizarre
    check (SWI chunk looked valid but SWI handler was 0) that would
    have failed - but be reported as a valid set of SWI entries.
  Added common error message cache.  Several common errors (Buffer
    overflow; Number not recognised; Bad vector release; and a couple
    of others) are now cached the first time they are translated into
    a block of memory in the system heap.
Admin:
  Tested in Ursula build - cacheing only active in Ursula build - change
    HdrSrc if you want it in your products too.
  Requires HdrSrc 0.94

Version 5.31. Tagged as 'Kernel-5_31'
@
text
@d17 2
a18 3
DuffEntry *     31*1024*1024+32*1024    ; Never any memory at this address

SoftReset       * 0                     ; Reset types
d27 5
d47 1
d49 1
a49 1
; On ARM600, InitKbdWs is in zero page - check it's big enough
d51 1
a51 1
        ASSERT  @@ <= ?InitKbdWs
a53 23
;       AddCamEntries
;
; in:   r0 -> appropriate part of CAM map
;       r1 = ap (+ CB bits in new world)
;       r2 = log address
;       r7 = amount of cam map to do
;       r8 = PageSize
;
; out:  r0, r3-r12 preserved
;       r1 corrupted
;       r2 updated by relevant amount

AddCamEntries ROUT
        Push    "r0, lr"
        MOV     lr, r1                  ; access privs (PPL)
        MOV     r1, r7
01
        STMIA   r0!, {r2, lr}           ; store logaddr, PPL
        ADD     r2, r2, r8              ; increment address by 1 page
        SUBS    r1, r1, #8              ; decrement count of how much to do
        BNE     %BT01
        Pull    "r0, pc"

d61 2
a62 2
GetConfiguredSize ENTRY "r1"
        MOV     r1, #0
d77 5
a82 10
        Push   lr
        B      ConfigureRMA

ReadCMOSAndConfigure ROUT
; R0 = index into CMOS RAM of byte with size in
; R1 = place to save amount moved
; R2 = CAM entry number to start at: updated
; R3 = LogRam Address to move memory to
; r11  PPL
; Check for memory left, move as much as poss
d84 1
a84 11
        BL      Read                    ; CMOS byte -> R0

 [ :LNOT: NewStyle_FontArea
        CMP     r3, #FontCacheAddress
        MOVEQ   r0, r0, LSL #12         ; *4K
        BEQ     NotScreen
 ]

        AND     R0, R0, #127            ; mask to same bitfield as status
ConfigureRMA
        MOV     R10, #0
a86 8
        CMP     R3, #ScreenEndAdr       ; screen?
        BNE     NotScreen

; quick pokery for sensible screensize

        BL      MassageScreenSize
        SUB     R3, R3, R0              ; step back.
NotScreen
d91 3
a93 14
 [ GetPagesFromFreePool

; r0 = amount of memory to move
; r1 = address to store size in
; (r2 = page number to start at, ignored in our method)
; r3 = address of where to put memory
; r10 = page size
; r11 = ap + CB

        MOV     r6, r11                         ; r6 = ap + CB
        MOV     r4, #FreePoolDANode
        LDR     r7, [r4, #DANode_Base]
        LDR     r8, [r4, #DANode_Size]
        ADD     r7, r7, r8                      ; r7 -> end of free pool +1
d95 7
a101 8
        CMP     r8, r10                         ; if no free memory left
        BCC     %FT20                           ; then tidy up
        SUB     r7, r7, r10                     ; move free pool pointer backwards
        Push    "r0, r1"
        MOV     r0, r7
        MOV     r1, r3
        BL      MovePageAtR0ToR1WithAccessR6
        Pull    "r0, r1"
a102 1
        SUB     r8, r8, r10                     ; one less page of free memory
d107 1
a107 33
        STR     r8, [r4, #DANode_Size]
 |
        LDR     R8, [R5, #RAMLIMIT]

; now set R6 = first entry not to use
;         R7 = end of gap   "   "  "
;         R8 = last entry we can use

        MOV     r7, #0
        LDR     r6, [r7, #VideoSize]            ; find out how many pages in video area
        MOV     r6, r6, LSR #12                 ; = page number of start of skipped bit
        ASSERT  SoftCamMapSize = L2PTSize +4
        MOV     r7, #L2PTSize
        LDMIA   r7, {r7, lr}                    ; r7 = L2PTSize, lr = SoftCamMapSize
        ADD     r7, r7, lr                      ; add sizes together
        ADD     r7, r7, #StaticPagesSize + UndStackSize ; + number of bytes used for other static bits
        ADD     r7, r6, r7, LSR #12             ; r7 = page number after static bit
        MOV     r8, r8, LSR #12                 ; make r8 into highest page number+1

CAMZapLoop
        CMP     R2, R6                  ; if at gap, skip
        MOVEQ   R2, R7
        CMP     R2, R8                  ; if no more memory, give in
        BEQ     NoMoreMemory
        ADD     R5, R5, R10
        Push    "R0, R1, R6"
        BL      BangCamUpdate
        Pull    "R0, R1, R6"
        ADD     R2, R2, #1
        ADD     R3, R3, R10
        SUBS    R0, R0, R10
        BGT     CAMZapLoop
 ]
d112 1
a112 2
; MassageScreenSize - called from ReadCMOSAndConfigure (above) and also from
; ReadSysInfo
d115 8
d125 3
d138 1
a138 1
        MOV     pc, lr
d142 12
a157 1
 [ VIDC_Type = "VIDC20"
a199 7
 [ MEMC_Type = "IOMD"
  [ Simulator
        & &94000025     ; No displayed lines, so we don't get video FIFO u/flow when simulating
  | ;Simulator
        & &94000125     ; VDER = 3 + 19 + 16 + 256
  ] ;Simulator
 | ;MEMC_Type <> "IOMD"
a200 1
 ] ;MEMC_Tupe = "IOMD"
a214 45
 | ;VIDC_Type<>"VIDC20"
        & &00000000
        & &04000000
        & &08000000
        & &0C000000
        & &10000000
        & &14000000
        & &18000000
        & &1C000000
        & &20000000
        & &24000000
        & &28000000
        & &2C000000
        & &30000000
        & &34000000
        & &38000000
        & &3C000000
        & &40000000
        & &44000000     ; Cursor -> black
        & &48000000
        & &4C000000     ; Palette programmed (avoid messy screen on reset)

        & &807FC000     ; HCR  Get a stable display up so we get stable signals
        & &8408C000     ; HSWR
        & &881B0000     ; HBSR
        & &94770000     ; HBER
        & &A04E0000     ; VCR
        & &A4024000     ; VSWR
        & &A8050000     ; VBSR
        & &B44E0000     ; VBER
        & &C0000100     ; SFR  NB. TEST BIT !!! - also DFlynn requested value
        & &E00000B2     ; CR   Set 640*256, 1 bit per pixel, rate of 12MHz
                        ; change bottom byte to 22 for Linear Microvitecs (CS)
                        ;                       B2 for Monochrome/Philips (SS)
        & &8C208000     ; HDSR
        & &90708000     ; HDER
        & &98258000     ; HCSR
        & &9C400000     ; HIR
        & &AC098000     ; VDSR
        & &B0498000     ; VDER
        & &B8098000     ; VCSR
        & &BC498000     ; VCER
; don't mess with the stereo image registers: sound code will set them.
        & &FFFFFFFF     ; That's the lot
 ] ;VIDC_Type = "VIDC20"
d219 1
d309 1
d344 1
a344 1
        mrs     AL, r0, CPSR            ; switch into IRQ32, still IRQs disabled
d347 1
a347 1
        msr     AL, CPSR_c, r1
d357 1
a357 1
        STR     R2, [R3, #InitKbdHandler] ; instruction is now a LDR PC,InitKbdHandler
a376 3
    [ ARM810support
        ARM8_branchpredict_flush  ;IMB on ARM810, and harmless on other ARMs
    ]
d380 1
a380 1
        msr     AL, CPSR_c, r0
d416 5
d436 1
a436 1
        LDR     R1, =ProcVec_Start
d448 2
a449 1
        MOV     R0, #4
d454 1
a454 1
        TEQ     R0, #EndFiq-MOSROMVecs
d457 2
d462 1
a462 1
        mrs     AL, r0, CPSR
d465 1
a465 1
        msr     AL, CPSR_c, r0
a467 10

; Ensure any CMOS operation aborted

        MOV     R1,#16                          ; Two bytes in case RTC transmitting
35
        BL      Start                           ; Start/clock edge
        BL      Stop
        SUBS    R1,R1,#1
        BNE     %BT35

d469 1
d471 8
d482 1
a482 1
        MOV     R0, #IRQ1V
d492 1
d496 1
a496 1
        TEQ     R0, #(EndData-StartData+IRQ1V)
a498 1
 [ ResetIndirected
d500 1
a500 1
        MOV     r0, #0
a501 1
 ]
d503 2
a504 2
        MOV     r0, #0                  ; initialise abort list
        STR     r0, [r0, #AbortIndirection]
d527 1
a527 2
; now the time/date conversions

d529 3
a531 4
        ADRL    R1, ConvertStandardDateAndTime
        STR     R1, [R0, #OS_ConvertStandardDateAndTime*4]
        ADD     R1, R1, #ConvertDateAndTime - ConvertStandardDateAndTime ; SKS
        STR     R1, [R0, #OS_ConvertDateAndTime*4]
a532 3
; other conversion SWIs, all go through same entry point

        ADRL    R1, despatchConvert
d537 2
a538 2
        CMP     R2, #OS_ConvertFileSize+1
        BNE     conversionSWIfill
d540 6
a545 20
;StrongARM: OK, that completes the poking around, some of which is code. Now let's
;           do a full IMB type thing, to be safe (if we're running on StrongARM)
  [ StrongARM
        ARM_read_ID R0
        AND     R0,R0,#&F000
        CMP     R0,#&A000
        BNE     afterpokingaround_notSA
        MOV     R1,#0
        STRB    R1,[R1,#SyncCodeA_sema]    ;initialise semaphore to 0
        MOV     R1,#ARMA_Cleaner_flipflop
        LDR     R0,=ARMA_Cleaners_address  ;note: we are initialising ARMA_Cleaner_flipflop here
        STR     R0,[R1]
        ARMA_clean_DC R0,R1,R2
        ARMA_drain_WB
        ARMA_flush_IC
afterpokingaround_notSA
    [ ARM810support
        ARM8_branchpredict_flush  ;IMB on ARM810, and harmless on other ARMs
    ]
  ]
d549 2
a550 2
        MOV     R0, #0
        MOV     R1, #32*1024*1024       ; nothing will be here!!
d554 5
d560 31
d594 1
a594 1
        MOV     r3, #10                 ; Check for keyboard 10 times (2 secs max).
d600 2
a601 2
        MOVEQ   r0, #2
        LDRNE   r0, =KeyWait*2          ; Wait 1/5 second (give keys down a chance to come in).
d603 1
a603 1
        LDR     r0, =KeyWait*2          ; Wait 1/5 second (give keys down a chance to come in).
d608 1
a608 1
        SUBS    r3, r3, #1              ; else wait a maximum of 2 seconds.
d612 1
d614 6
a621 4
; Do a POR if some super-critical values are shagged or if checksum is invalid.
        MOV	R3, #-1                 ; do all RAM if we do any
        BL      ValChecksum             ; Always check the checksum
        BNE	cmos_reset
d626 1
a626 1
	MOV	R1, #ScreenSizeCMOS
d628 7
a634 7
	MOV	R0, R1
	BL	Read
	TEQ	R0, #0
	BNE	cmos_reset
	INC	R1
	TEQ	R1, #SpriteSizeCMOS
	BHI	reset_loop
d636 12
a647 9
 [ {FALSE}
; FontCMOS should be <= 32 (128K)
; What on earth was this about? Why would anyone require FontSize to
; be less than 128K?
	MOV	R0, #FontCMOS
	BL	Read
	CMP	R0, #32
	BHI	cmos_reset
 ]
a648 41
 [ {FALSE}
 ; Oh, just leave it be
	MOV	R0, #VduCMOS
	BL	Read
 [ IOMD_C_MonitorType = 0 :LAND: IOMD_C_PALNTSCType = 0
; Force TV if we don't have a MonitorType auto-detect bit
	TEQ	R0, #(Sync_Separate :OR: MonitorType0)
 |
; Force auto-detect of monitor stuff if we have a MonitorType auto-detect bit
	TEQ	R0, #(Sync_Auto :OR: MonitorTypeAuto)
 ]
	BNE	cmos_reset
 ]

; Year should be >=1995, <=2020
; (2020 is arbitrary, but everything breaks soon after that)
	MOV	R0, #YearCMOS+1
	BL	Read
	TEQ	R0, #19
	BNE	check20

; 20th century: year should be 95 to 99
	MOV	R0, #YearCMOS
	BL	Read
	CMP	r0,#95
	BLT	cmos_reset
	CMP	r0,#99
	BHI	cmos_reset
	B	checkboot

check20
	TEQ	R0, #20
	BNE	cmos_reset

; 21st century: year should <= 20
	MOV	R0, #YearCMOS
	BL	Read
	CMP	R0, #20
	BHI	cmos_reset

checkboot
d650 4
a653 4
	MOV	R0, #DBTBCMOS
	BL	Read
	TEQ	R0, #(1:SHL:4)
	BNE	cmos_reset
d657 1
a657 1
; IF power-on bit set in IOC AND R/T/Del/Copy pressed THEN reset CMOS RAM
d659 16
d680 1
a680 1
 [ CheckProtectionLink
d683 2
a684 3
; on Issue A's the protection bit is only weakly pulled up,
; so force it high, then read it back

d692 1
a692 1
 ]
d694 2
a695 2
 [ STB :LAND: IOMD_C_FrontPanelButton <> 0
  [ FrontPanelButtClearsCMOS
d700 3
a702 1
  ]
d705 6
a710 2
        MOV     R0, #InitKbdWs
        LDR     R7, [R0, #R_Down_Flag]
d712 4
a717 4
        [ :LNOT: STB
        ADD     sp, sp, #4              ; junk CannotReset flag from stack
        ]

d719 1
a719 9
; **************************************************************************
; Note: if this CMOS reset code ever needs changing again, it's probably
; better to rewrite it. The Compact apparently has a table of default
; CMOS values; R-p.o. just writes the table, DEL-p.o. zeroes all, then
; writes the table. With skipping of the time CMOS, and post-prodding of
; the sync, that would probably be a better algorithm.
; **************************************************************************

     SetBorder  R0, R1, 15, 0, 0        ; flash the border as warning!
d721 5
d727 1
d733 1
a733 1
 [ STB
d735 1
a736 59
 ]
        MOVNE   R0, #0                  ; even the econet station number
        MOVEQ   R0, #1
    |
        MOV     R0, #1                  ; leave the econet station number
    ]
        MOV     R1, #0                  ; zero it first
cmrlp   BL      Write                   ; CMOS(R0) := R1
        ADD     R0, R0, #1
        CMP     R0, R3
        MOVEQ   R0, #&80                ; skip user cmos
        CMP     r0, #YearCMOS
        ADDEQ   r0, r0, #2
        CMP     r3, #UserCMOS           ; system only?
        BNE     skipskipforTC
        CMP     r0, #NewADFSCMOS
        CMPNE   r0, #CountryCMOS        ; skip these if so
        ADDEQ   r0, r0, #1
skipskipforTC
        CMP     R0, #CMOSLimit
        BNE     cmrlp
    [ ChecksumCMOS
        BL      MakeChecksum            ; create a valid checksum
    ]
; now put nice values in where necessary
; first full reset defaults
        CMP     r3, #-1
        BNE     not_full_reset

 [ STB :LAND: IOMD_C_PALNTSCType <> 0
        MOV     r4, #IOMD_Base          ; configure territory, country and timezone based on PAL/NTSC bit
        LDRB    r4, [r4, #IOMD_CLINES]
        MOV     r0, #TerritoryCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #0                  ; PAL = territory UK
        MOVNE   r1, #49                 ; NTSC = territory USA
        BL      Write
        MOV     r0, #CountryCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #1                  ; PAL = country UK
        MOVNE   r1, #48                 ; NTSC = country USA
        BL      Write
        MOV     r0, #TimeZoneCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #0                  ; PAL = 0 from UTC (GMT)
        MOVNE   r1, #&E0                ; NTSC = -8 hours from UTC (USA Pacific)
        BL      Write
   [ STB :LAND: :DEF: ObsoleteNC1CMOS
        MOV     r0, #MiscellaneousNCCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #0                  ; PAL = A4 paper size
        MOVNE   r1, #1                  ; NTSC = US letter paper size
        BL      Write
   ]
 |
        MOV     r0, #CountryCMOS
        MOV     r1, #1                  ; country UK
        BL      Write
 ]
d738 23
a760 7
 [ :LNOT: STB
        MOV     r0, #NewADFSCMOS
        MOV     r1, #&41                ; floppies=1, ST506=0, IDE=1 (changed 01-Sep-93)
        BL      Write
 ]

not_full_reset
d763 5
a767 1
        MOV     R0, #InitKbdWs
d772 1
d778 4
a781 185
 [ MorrisSupport
        MOV     R8, #IOMD_Base
	LDRB	r0, [r8, #IOMD_ID0]
	LDRB	r1, [r8, #IOMD_ID1]
	ORR	r0, r0, r1, LSL #8
	LDR	r1, =IOMD_Original
	TEQ	r0, r1
	BEQ	dont_program_mousetype
;
; Morris based machines use PS2 mice/tracker balls
;
        MOV     R0, #MouseCMOS
        MOV     R1, #PointerDevice_PS2Mouse     ;type 3
        BL      Write

  [ Select16BitSound
; set print and sound CMOS (16bit sound)
        B       Config16BitSound
  ]
dont_program_mousetype
 ]

 [ Select16BitSound
        LDR     r0, =IOMD_MonitorType

; on Issue A's the protection bit is only weakly pulled up,
; so force it high, then read it back

        LDR     r1, [r0]
        ORR     r1, r1, #IOMD_SoundsystemLinkBit
        STR     r1, [r0]

        LDR     r1, [r0]
        TST     r1, #IOMD_SoundsystemLinkBit
        BEQ     Config16BitSound                ; if zero, must be Rimmer, so assume 16bit sound hardware present

; set print and sound CMOS (8bit sound)
        MOV     R0, #TutuCMOS
        MOV     R1, #2_0100  ; tbs chars valid, ctrlchars '|x'
        BL      Write
        B       ConfigSoundDone

Config16BitSound
; set print and sound CMOS (16bit sound)
        MOV     R0, #TutuCMOS
        MOV     R1, #2_10100100  ; tbs chars valid, ctrlchars '|x'
        BL      Write

ConfigSoundDone
 ]

        ADR     R8, DefaultCMOSTable
50
        LDRB    R0, [R8], #1
        CMP     R0, #&FF
        BEQ     hard_reset              ; power on bit musta bin set
        LDRB    R1, [R8], #1
        BL      Write
        B       %BT50

        LTORG

 [ ValidateCMOS :LAND: STB
DefaultCMOSTable ; list of non-zero options wanted :
; byte pairs of offset, value
; terminated by offset &FF
        =       KeyDelCMOS,             32
        =       KeyRepCMOS,             8
        =       MODETVCMOS,             &10                                     ; TV 0,1
        =       StartCMOS,	        (2:SHL:3)				; NOCAPS
        =       DBTBCMOS,	        (1:SHL:4)				; Boot
        =       YearCMOS,               00
        =       YearCMOS+1,             20
  [ IOMD_C_MonitorType = 0 :LAND: IOMD_C_PALNTSCType = 0
; TV if we don't have a MonitorType auto-detect bit
	=	VduCMOS,	        Sync_Separate :OR: MonitorType0
  |
; auto-detect if we have a MonitorType auto-detect bit
	=	VduCMOS,	        Sync_Auto :OR: MonitorTypeAuto
  ]
        =       MouseStepCMOS,          2
        =       SystemSpeedCMOS,	(1:SHL:2):OR:(1:SHL:4):OR:(0:SHL:5)
                                      ; Delete-etc reset
                                      ;              WimpMode auto
                                      ;                           Cache on
 | ;ValidateCMOS
DefaultCMOSTable ; list of non-zero options wanted :
; byte pairs of offset, value
; terminated by offset &FF
        =       KeyDelCMOS,     32
        =       FileLangCMOS,   8
        =       FontCMOS,       16      ; TMD 15-Dec-93: Changed to 64K from 32K - fixes MED-01774
        =       PigCMOS,        10
        =       KeyRepCMOS,     8
        =       RMASizeCMOS,    0
        =       SpriteSizeCMOS, 0
        =       MODETVCMOS,     &10     ; TV 0,1
        =       NetFSIDCMOS,    254
        =       NetPSIDCMOS,    235
        =       PSITCMOS,      (3:SHL:2) :OR: (1:SHL:5)
                              ; Baud 3
                              ;                print 1

        =       DBTBCMOS,      (1:SHL:4) :OR: (4:SHL:5)
                              ; Boot (changed from NoBoot 01-Sept-93)
                              ;                Data 4

        =       StartCMOS,     (4:SHL:0) :OR: (2:SHL:3) :OR: (1:SHL:6)
                              ; Drive 4 (changed from Drive 0 01-Sept-93)
                              ;                NOCAPS (changed from CAPS 02-May-91)
                              ;                               NODIR

     [ NewClockChip                     ; only on A1's!
        =       NewADFSCMOS+1,  &FF     ; step 3 for each drive
     ]

        =       NewADFSCMOS+2,  1       ; ADFSBuffers 1
        =       SoundCMOS,      &F0     ; speaker on, volume 7, channel 1

        =       LanguageCMOS,   ConfiguredLang
        =       YearCMOS,       00
        =       YearCMOS+1,     20
 [ :LNOT: Select16BitSound
        =       TutuCMOS,       2_0100  ; tbs chars valid, ctrlchars '|x'
 ]
        =       NetFilerCMOS,  (0:SHL:0) :OR: (1:SHL:1) :OR: (0:SHL:2)
                              ; FS list order by name
                              ;                Use $.Arthurlib
                              ;                               Large icons

     ;  =       Mode2CMOS,      WimpModeAutoBit :OR: CMOSResetBit ;AKA SystemSpeedCMOS - removed by RManby and SCormie 8/3/95
        =       DesktopCMOS,    2_01000000      ; verbose ON
        =       WimpFlagsCMOS,  2_01101111      ; instant effects, drags off screen
        =       ProtectionCMOS, 2_01110110      ; allow only peek and user RPC
        =       MouseStepCMOS,  2
        =       FileSwitchCMOS,(1:SHL:0) :OR: (1:SHL:1) :OR: (0:SHL:2) :OR: (0:SHL:3) :OR: (0:SHL:6)
                              ; truncate names
                              ;                Use DragASprite (changed 01-Sept-93)
                              ;                               Interactive file copying
                              ;                                              Wimp dither colours off
                              ;                                                             last shutdown ordinary

        =       DesktopFeaturesCMOS,(1:SHL:0) :OR: (8:SHL:1) :OR: (0:SHL:7)
                              ;      3D look
                              ;                     Homerton.Medium
                              ;                                    tiled window background

        [ STB
        =       SystemSpeedCMOS,(1:SHL:0):OR:(0:SHL:1):OR:(1:SHL:2):OR:(0:SHL:3):OR:(1:SHL:4):OR:(0:SHL:5):OR:(1:SHL:6):OR:(0:SHL:7)
                              ;  AUN ROMBoot Enabled
                              ;               AUN auto-station numbering off
                              ;                            Delete-etc reset
                              ;                                         power saving off
                              ;                                                      WimpMode auto
                              ;                                                                  Cache on
                              ;                                                                               Broadcast loader disabled
                              ;                                                                                            broadcast loader colours off
        |
        =       SystemSpeedCMOS,(0:SHL:0):OR:(0:SHL:1):OR:(1:SHL:2):OR:(0:SHL:3):OR:(1:SHL:4):OR:(0:SHL:5):OR:(1:SHL:6):OR:(0:SHL:7)
                              ;  AUN BootNet Disabled
                              ;               AUN auto-station numbering off
                              ;                            Delete-etc reset
                              ;                                         power saving off
                              ;                                                      WimpMode auto
                              ;                                                                  Cache on
                              ;                                                                               Broadcast loader disabled
                              ;                                                                                            broadcast loader colours off
        ]

        [ :LNOT: STB
        =       FontMaxCMOS,    64      ; 256k
        =       FontMax2CMOS,   &28     ; 36 point
        =       FontMax3CMOS,   &3C     ; 36 point
        |
        ;       yes, omitting FontMaxCMOS is deliberate!
        =       FontMax2CMOS,   &2C     ; 32 point
        =       FontMax3CMOS,   &38     ; 32 point
        ]
        =       AlarmAndTimeCMOS,2_00010000 ; !Alarm autosave on
        =       FSLockCMOS+5,   &EA     ; Checksum for no password
        =       CDROMFSCMOS,    &60     ; drives = 0, buffer size = 32K
  ]
        =       &FF
        ALIGN

a792 279
 [ SoftResets
        TST     r1, #por_bit
        BNE     hard_reset              ; it was a power-on, so it's a hard reset
        CMP     r0, #0
 [ DebugForcedReset
        MOVNE   r2, #Reset_CannotResetFlag
 ]
        BNE     hard_reset_forced

; IF control pressed OR memory implausible (Check SysHpd, CAM map sensible) THEN hard reset

        LDR     R0, =SysHeapStart
        LDR     R8, [R0, #:INDEX: hpdmagic]
        LDR     R2, =magic_heap_descriptor
        CMP     R8, R2                  ; check sysheap initialised
 [ DebugForcedReset
        MOVNE   r2, #Reset_SysHeapCorrupt
 ]
        BNE     hard_reset_forced

; also check CAM map sensible

        MOV     R5, #0
        LDR     R4, [R5, #Page_Size]    ; R4 = page size
        ADRL    R3, PageShifts-1
        LDRB    R4, [R3, R4, LSR #12]   ; R4 = log2(pagesize)
        LDR     R3, [R5, #RAMLIMIT]     ; R3 = total RAM size
        MOV     R2, R3, LSR R4          ; number of pages=total memory / pagesize
        CMP     R2, #256                ; but if fewer than 128 (eg 64 on A305) (NB if <256 then <=128)
        MOVCC   R2, #128                ; then use 128 (all MEMC1's pages need initialising,
                                        ; even if half of them are not in use)
        SUB     R2, R2, #1
        LDR     R3, =CamEntriesForVicky

        LDR     R4, [R5, #MaxCamEntry]  ; get highest CAM entry
        LDR     R5, [R5, #CamEntriesPointer] ; and pointer to CAM soft copy

        CMP     R5, R3                  ; if not the same
 [ DebugForcedReset
        MOVNE   r2, #Reset_WrongCamMapAddress
        BNE     hard_reset_forced
 ]
        CMPEQ   R4, R2                  ; or number of pages not the same
 [ DebugForcedReset
        MOVNE   r2, #Reset_WrongNumberOfPages
 ]
        BNE     hard_reset_forced       ; then do a hard reset

; now check all cam contains sensible values

        MOV     R4, #0
        LDR     R4, [R4, #Page_Size]
        SUB     R4, R4, #1
        ORR     R4, R4, #&F0000000      ; can have addresses above 64M
CamCheck
        LDR     R3, [R5, R2, LSL #2]
        BIC     r3, r3, #&F0000000      ; remove PPL
        TST     R3, R4
 [ DebugForcedReset
        MOVNE   r2, #Reset_CamMapCorrupt
 ]
        BNE     hard_reset_forced       ; wally entry: not pagesize multiple, or >= 32M
        SUBS    R2, R2, #1
        BPL     CamCheck

; leave CTRL test till last, so the keyboard's had as much time to
; wiggle the wet string as we can give it
        MOV     R0, #InitKbdWs
        LDRB    R1, [R0, #CTRL_Down_Flag]
        CMP     R1, #0
        BNE     hard_reset

soft_reset
; clear out 4K of scratchspace, to use as a reverse CAM soft copy;
; set bytes to indicate page mapped to that address. Can then recalculate
; end of memory.

; This code doesn't currently work on ARM600 versions -
; 4K of workspace isn't enough to do this with a 4K page size
; We'd probably want to do it differently anyway, using the L2PT
; But since we're removing soft resets it's not worth the effort

        ASSERT  MEMM_Type <> "ARM600"

        MOV     R5, #ScratchSpace
        MOV     R1, #4*1024
        MOV     R2, #0
clrscratch
        SUBS    R1, R1, #4
        STRPL   R2, [R5, R1]
        BPL     clrscratch

        LDR     R2, [R2, #Page_Size]
        ADRL    R8, PageShifts-1
        LDRB    R8, [R8, R2, LSR #12]

        MOV     r7, #0
        LDR     r2, [r7, #RAMLIMIT]
        MOV     r2, r2, LSR r8          ; last valid page
        SUB     r2, r2, #1

        LDR     R7, [R7, #CamEntriesPointer]
        LDR     R12, =DuffEntry

restoreCAMloop
        LDR    R3, [R7, R2, LSL #2]
        MOV    r11, r3, LSR #28
        BIC    r3, r3, #&F0000000

        MOV    R0, R3, LSR R8              ; logram page number
        LDRB   R4, [R5, R0]
        CMP    r4, #0                      ; check for doubly mapped pages
        BEQ    rclon

        ORR    r3, r12, #&30000000         ; force to invalid place if so.
        STR    r3, [R7, R2, LSL #2]
        MOV    r3, r12
        MOV    r11, #3                     ; protected
        MOV    R0, R3, LSR R8
        LDRB   R4, [R5, R0]
rclon
        CMP    r3, #16*1024*1024           ; in application space?
        MOVLT  r11, #0                     ; noprot if so
        STRLT  r3, [R7, R2, LSL #2]
        ADD    R4, R4, #1
        STRB   R4, [R5, R0]                ; sema for interesting pages
        BL     BangCam
        SUBS   R2, R2, #1
        BPL    restoreCAMloop

; now do post-scan to see if we need to do more CAM bashing to get pages back.
; any entries that aren't validateable should be remapped.

        MOV     R7, #0
        MOV     R12, #ScratchSpace
        LDR     R2, [R7, #Page_Size]
findapplend
        LDRB    R3, [R12], #1
        CMP     R3, #0
        ADDNE   R7, R7, R2
        BNE     findapplend
        MOV     R1, #0
        STR     R7, [R1, #AplWorkSize]  ; verified value
        LDR     R3, [R1, #RAMLIMIT]     ; calc last valid page:
        MOV     R3, R3, LSR R8          ; RAMLIMIT >> R8
        MOV     R11, #0                 ; no PPL
        LDR     R4, [R11, #CamEntriesPointer]
testforremap
        SUBS    R3, R3, #1
        BMI     finishedremap
        LDR     R0, [R4, R3, LSL #2]
        BIC     r0, r0, #&F0000000      ; remove PPL
        ADD     R1, R0, R2
        SWI     XOS_ValidateAddress
        BCC     testforremap

        Push    "R2-R4"
        MOV     R0, R0, LSR R8          ; curr logram page number
        LDRB    R4, [R5, R0]
        SUB     R4, R4, #1
        STRB    R4, [R5, R0]            ; dec sema
        MOV     R2, R3                  ; entry no
        MOV     R3, R7                  ; addr to set to
        BL      BangCamUpdate
        Pull    "R2-R4"
holefilled
        ADD     R7, R7, R2
        LDRB    R0, [R12], #1           ; reinspect our reverse map
        CMP     R0, #0
        BNE     holefilled
        MOV     R0, #0
        STR     R7, [R0, #AplWorkSize]
        B       testforremap

finishedremap
        MOV     R12, #NVECTORS-1
        LDR     R11, =VecPtrTab
freenextvec
        LDR     R2, [R11, R12, LSL #2]
loseveclink
        LDR     R3, [R2, #TailPtr]
        BL      FreeSysHeapNode
        MOVVC   R2, R3
        BVC     loseveclink
        CMP     R3, #0                  ; were we at the end of the chain?
 [ DebugForcedReset
        MOVNE   r2, #Reset_VectorChainCorrupt
 ]
        BNE     hard_reset_forced
        SUBS    R12, R12, #1
        BPL     freenextvec
; so that's the code for restore default vectors, basically
        BL      InitVectors
        MOV     R0, #0
        LDR     R1, [R0, #AplWorkSize]
        STR     R1, [R0, #MemLimit]

        LDR     R3, =TickNodeChain
        LDR     R2, [R3]

loseticknodes
        CMP     R2, #0
        BEQ     ticknodesallgone

        LDR     R3, [R2]
        BL      FreeSysHeapNode
 [ DebugForcedReset
        MOVVS   r2, #Reset_TickNodesCorrupt
 ]
        BVS     hard_reset_forced
        MOV     R2, R3
        B       loseticknodes

ticknodesallgone
; and now it's time to free the IRQ structures

        MOV     R12, #(NoInterrupt-1)*12+8      ; last device link offset
        LDR     R11, =DefaultIRQ1V-DefaultIRQ1Vcode+Devices
freenextdev
        LDR     R2, [R11, R12]
losedevlink
        CMP     R2, #0
        BEQ     stepdevice

        LDR     R3, [R2, #8]
        BL      FreeSysHeapNode
 [ DebugForcedReset
        MOVVS   r2, #Reset_DeviceVectorCorrupt
 ]
        BVS     hard_reset_forced
        MOV     R2, R3
        B       losedevlink
stepdevice
        SUBS    R12, R12, #12
        BPL     freenextdev

; now the PIRQ structures and CallBack_Vector
        LDR     R11, =PIRQ_Chain
        MOV     r4, #PodDesp_Link
losepirqchain
        LDR     R2, [R11]
        CMP     r2, #0                  ; for CallBack_Vector
        BEQ     doobry
losepirqlink
        LDR     R3, [R2, r4]
        BL      FreeSysHeapNode
        MOVVC   R2, R3
        BVC     losepirqlink
        CMP     R3, #0                  ; were we at the end of the chain?
 [ DebugForcedReset
        MOVNE   r2, #Reset_PoduleOrCallBackCorrupt
 ]
        BNE     hard_reset_forced
        LDR     R2, =PIRQ_Chain
        CMP     R11, R2
        LDR     R2, =PFIQasIRQ_Chain
        MOVEQ   R11, R2
        CMPNE   r11, r2
        LDREQ   r11, =CallBack_Vector
    [ PodDesp_Link <> 0
        MOVEQ   r4, #0
    ]
        BEQ     losepirqchain


doobry  Pull    "R1"                    ; IOCControl restoration
        MOV     R0, #0
        STRB    R1, [R0, #IOCControlSoftCopy]
        MOV     R0, #IOC                ; and bash the hardware
        STRB    R1, [R0, #IOCControl]

        MOV     R0, #SoftReset
        B       ResetPart1Done

 |

; if soft resets are disabled, drop thru into hard reset code

 ] ; end of code to do with soft resets
d799 1
d801 1
a801 1
        STR     r2, [r0, -r0]           ; store to logical address zero
d806 1
a806 86
; fill in relevant CamMap entries, so can soft start.

        MOV     R8, #0
        LDR     R8, [R8, #Page_Size]
        ADRL    R1, PageShifts-1
        LDRB    R1, [R1, R8, LSR #12]

        MOV     r2, #0
        LDR     r0, [r2, #VideoSize]    ; offset from start of physical pages to static part
        MOV     r0, r0, LSR r1          ; r0 := cam entry number
        MOV     r0, r0, LSL #3          ; r0 := offset into CAM map for start of static part

        MOV     R7, #32*1024*8
        MOV     R7, R7, LSR R1          ; r7 := cam entry offset for 32K

        LDR     R12, [R2, #RAMLIMIT]    ; R12 = total RAM size

                                        ; new code which allows for MEMC2's small pages
        MOV     R1, R12, LSR R1         ; R1 = number of pages
        CMP     R1, #256                ; but if fewer than 128 (eg 64 on A305) (NB if <256 then <=128)
        MOVCC   R1, #128                ; then use 128 (all MEMC1's pages need initialising,
                                        ; even if half of them are not in use)

        SUB     R3, R1, #1
        STR     R3, [R2, #MaxCamEntry]

        LDR     R1, =CamEntriesForVicky
        STR     R1, [R2, #CamEntriesPointer]


; On ARM600 we must zap all the soft CAM map before adding any entries,
; since the old contents are used in BangCamUpdate

        Push    "r0"
        ADD     r2, r1, r3, LSL #3      ; r2 -> last entry to do
        LDR     r0, =DuffEntry
        MOV     lr, #AP_Duff            ; PPL = no access
WallopDuffOnes
        STMDA   r2!, {r0, lr}           ; store address, PPL
        CMP     r2, r1
        BCS     WallopDuffOnes
        Pull    "r0"
        ADD     R0, R0, R1

        MOV     R2, #CursorChunkAddress
        LDR     r1, =AP_CursorChunk
        BL      AddCamEntries

        CMP     R12, #512*1024
        SUBEQ   R0, R0, R7              ; previous entries
        ADDNE   R0, R0, R7              ; next entries
        MOV     R2, #0
        MOV     r1, #AP_PageZero
        BL      AddCamEntries

        CMP     R12, #512*1024
        SUBEQ   R0, R0, R7              ; previous entries
        ADDNE   R0, R0, R7              ; next entries
        MOV     R2, #SysHeapChunkAddress
        MOV     r1, #AP_SysHeap :OR: PageFlags_Unavailable
        BL      AddCamEntries

        ADD     R0, R0, R7              ; next entries (ignore 512K machines)
        MOV     r7, #0
        LDR     r7, [r7, #L2PTSize]
        MOV     r7, r7, LSR #12-3       ; number of pages * 8
        LDR     R2, =L2PT
        LDR     r1, =AP_L2PT :OR: PageFlags_Unavailable
        BL      AddCamEntries

        ADD     r2, r0, #((L1PT-L2PT):SHR:(12-3)) + 4   ; point at PPL for 1st L1 page
        LDR     r1, =AP_L1PT
        STR     r1, [r2], #8            ; store 4 CAM entries for 4 x 4K = 16K of L1
        STR     r1, [r2], #8            ; mark them as unavailable for removal
        STR     r1, [r2], #8
        STR     r1, [r2], #8

        ADD     R0, R0, R7              ; add on enough pages for L2PT

        MOV     r7, #0
        LDR     r7, [r7, #SoftCamMapSize] ; number of bytes in soft cam map
        ADD     r7, r7, #UndStackSize
        MOV     r7, r7, LSR #12-3       ; number of bytes of cam map for this
        LDR     R2, =UndStackSoftCamChunk
        MOV     r1, #AP_UndStackSoftCam
        BL      AddCamEntries
d813 14
d832 1
a832 1
        MOV     r5, #0
d835 3
a837 1
        LDR     r5, [r5, #VideoSize]    ; maximum size
d842 1
a842 1
        MOV     r3, #ScreenEndAdr       ; base address (start of 2nd copy)
d851 1
d854 2
a855 1
; RMA
d857 8
a864 8
        MOV     r1, #ChangeDyn_RMA      ; Area number
        MOV     r2, #4096               ; Initial size
        MOV     r3, #RMAAddress         ; Base address
        MOV     r4, #AP_RMA             ; Area flags
        MOV     r5, #RMAMaxSize         ; Maximum size
        ADRL    r6, DynAreaHandler_RMA  ; Pointer to handler
        MOV     r7, r3                  ; Workspace ptr points at area itself
        ADRL    r8, AreaName_RMA        ; Title string - node will have to be reallocated
d868 1
d873 1
d875 4
d886 1
a886 1
        MOV     r5, #-1                 ; Maximum size
a895 2
        MOV     r0, #RAMDiscCMOS        ; find out how much RAM disc configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size
d899 16
a914 2
        MOV     r4, #AP_RAMDisc         ; Area flags
        MOV     r5, #16*1024*1024       ; Limit maximum size to 16MB until JSR fixes FileCore
d920 8
d938 2
a939 1
        MOV     r5, #-1                 ; Maximum size
d947 1
a947 3
; get here with R2 = highest CAM entry used (in old model)

        LDR     R0, =(AplWorkMaxSize-32*1024):SHR:12    ; maximum number of pages in aplspace
d949 1
a949 1
        LDR     R1, =AplWorkSize        ; aplwork size
d951 1
a951 1
        BL      FudgeConfigureRMA       ; put as much as possible in aplspace
d953 1
a953 1
        MOV     R0, #0
d959 1
d962 5
a966 2
        LDR     R1, =ModuleSWI_HashTab
        MOV     R2, #ModuleSHT_Entries-1
d968 1
d970 5
a974 2
        SUBS    R2, R2, #1
        BGE     clearmswis
d978 2
a979 2
        STRB    R1, [R0, #ErrorSemaphore]               ; Don't translate errors.
        STR     R0, [R0, #KernelMessagesBlock]          ; No message file open.
d981 1
a981 1
        STR     R0, [R0, #CachedErrorBlocks]            ; No cached errors
d985 5
d994 1
d1000 1
a1000 1
        LDREQ   R0, =OsbyteVars + :INDEX: LastBREAK
d1010 1
a1010 1
        LDR     R1, =OsbyteVars + :INDEX: LastBREAK
d1013 6
a1018 1
        MOV     R1, #InitKbdWs
d1021 1
d1024 2
a1025 2
; copy IRQ handler: not done with rest of copying
; because soft break needs the info to free any claimed blocks.
d1027 1
a1027 10
        LDR     R0, =DefaultIRQ1V
        ADRL    R1, DefaultIRQ1Vcode
        ADRL    R2, DefaultIRQ1Vcode_end
CopyDefaultIRQ1V
        LDR     R3, [R1], #4
        STR     R3, [R0], #4
        CMP     R1, R2
        BNE     CopyDefaultIRQ1V

        LDR     R0, =PIRQ_Chain
d1029 2
a1030 2
        STR     R1, [R0]
        STR     R1, [R0, #PFIQasIRQ_Chain-PIRQ_Chain]
d1034 13
a1046 3
        STRB    r0, [r0, #FIQclaim_interlock]
        STRB    r0, [r0, #CallBack_Flag]
        STR     r0, [r0, #CallBack_Vector]
d1052 1
a1052 1
        mrs     AL, r2, CPSR
d1055 1
a1055 1
        msr     AL, CPSR_c, r3
d1070 14
a1083 23
 [ StrongARM
   ;for StrongARM, we need to do an IMB type thing for modifying code in vector area, and
   ;for copying irq handler code
        ARM_read_ID r1
        AND     r1,r1,#&F000
        CMP     r1,#&A000
        BNE     furtherpoke_notSA
   ;first, we clean one cache entry, 0..1F, = vector area
        MOV     r1,#0
        ARMA_clean_DCentry r1
   ;next, we clean DefaultIRQ1V code area
        LDR     r0,=DefaultIRQ1V
        ADD     r1,r0,#(DefaultIRQ1Vcode_end - DefaultIRQ1Vcode)
        ARMA_clean_DCrange r0,r1
   ;and then we synch IC
        ARMA_drain_WB
        ARMA_flush_IC
        MOV     r0,#0    ;restore r0 as zero base
furtherpoke_notSA
    [ ARM810support
        ARM8_branchpredict_flush  ;IMB on ARM810, and harmless on other ARMs
    ]
 ]
d1089 1
a1089 1
        msr     AL, CPSR_c, r2
d1091 1
d1094 8
a1101 2
        STR     R0, [R0, #ReturnCode]
        STR     R0, [R0, #TickNodeChain]
d1107 1
a1107 1
        LDR     R1, =DUMPER
d1111 1
d1113 1
d1115 1
d1117 1
d1119 1
d1122 1
d1124 1
d1126 13
a1138 1
        [ DoInitialiseMode :LOR: :LNOT: STB
d1151 15
d1167 2
d1170 1
d1172 1
d1183 1
a1183 1
        MOV     R0, #0
d1185 1
a1185 1
        MULTIPLY R3, R0, R2             ; size spare wanted
d1197 18
d1224 1
a1224 1
; Go into user mode, issue a dummy SWI, then go back into SVC mode
d1231 1
a1231 9
        WritePSRc 0, R14                ; enter USR mode (IRQs, FIQs enabled)
        NOP                             ; wait for it to take effect
        SWI     XOS_WriteI+0            ; I hope it doesn't generate an error
                                        ; otherwise the callback will get deferred!
  [ DebugROMInit
        SWI     XOS_WriteS
        =       "EnterOS!",0
        SWI     XOS_NewLine
  ]
d1233 1
a1233 1
  [ RO371Timings
d1238 2
a1239 2
      [ International                   ; Open the kernel messages file.
        ADR     r0, KernelMessagesBlock+4
d1244 1
d1246 3
d1250 1
d1254 1
a1254 1
        MOV     r0, #0
d1257 1
d1261 1
a1261 1
    [ DoInitialiseMode :LOR: :LNOT: STB
d1263 25
a1287 1
     [ :LNOT: STB                      ; don't print stuff on STB type products
d1292 6
a1297 1
        MOV     R0, #0
d1299 3
a1301 1
        MOV     R0, R0, LSR #20         ; /(1024*1024)
d1309 4
a1312 1
     ]
d1315 3
a1317 15
 [ StrongARM
  [ STB
   ! 0,"Printing of processor type disabled"
  |
        ;Print the processor type
        MOV     r0, #0
        LDRB    r0, [r0, #ProcessorType]
        TEQ     r0, #255
        BEQ     %FT01
        ADR     r1, processor_names
      [ International
        ADD     r0, r1, r0, LSL #3
	BL	Write0_Translated
	SWI	XOS_NewLine
	SWI	XOS_NewLine
d1319 2
a1320 2
        ADD     r0, r1, r0, LSL #5
        SWI     XOS_Write0
a1321 5
   ]
 ]

01      MOV     r0, #0                  ; Set DomainId to 0 every reset
        STR     r0, [r0, #DomainId]     ; before calling anyone
a1335 6
 [ SoftResets :LAND: STB
        ! 0, "!!!! SoftReset is true => resets close all open files !!!!"
        MOV     R0, #FSControl_Shut     ; Open files get closed at reset
        SWI     XOS_FSControl
 ]

d1345 21
d1369 7
a1375 1
 [ CheckProtectionLink
d1380 1
d1388 1
a1388 1
        MOV     r3, #0
d1436 1
a1436 1
    [ DoInitialiseMode :LOR: :LNOT: STB
d1441 3
a1443 2
        BLVC    WriteS_Translated
        =       "MonType:Monitor type reconfigured.",10,13,10,0
d1445 1
d1448 1
a1448 1
        =       10,"Monitor type reconfigured.",10,13,10,0
d1458 1
a1458 1
        B       .+(RESET1-0)
d1461 2
d1478 6
a1483 42
 [ StrongARM
  [ STB
   ! 0,"Disabling Processor ID display"
  |
processor_names
   [ International
        =	"600", 0
	ALIGN	8
	=	"610", 0
	ALIGN	8
	=	"700", 0
	ALIGN	8
	=	"710", 0
	ALIGN	8
	=	"810", 0
	ALIGN	8
	=	"SA110", 0
	ALIGN	8
	=	"7500", 0
	ALIGN	8
	=	"7500FE", 0
	ALIGN	8
   |
        DCB     "ARM 600 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 610 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 700 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 710 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 810 Processor",10,13,10,0
        ALIGN 32
        DCB     "StrongARM Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 7500 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 7500FE Processor",10,13,10,0
        ALIGN 32
   ]
        ; type, internal type, features
  ]
d1490 1
a1490 7
 [ {TRUE}
   ;corrected for 3.71 (SA does not abort for vector reads in 26-bit mode)
        DCD &a100,5,2_11011
 |
   ;value for 3.70
        DCD &a100,5,2_11111
 ]
a1493 6
 ]

      [ International
MessageFileName DCB     "Resources:$.Resources.Kernel.Messages",0
        ALIGN
      ]
a1494 1
 [ StrongARM
d1521 1
a1521 1
        STRMIB  R2,[R0,#ProcessorType]
d1529 1
a1529 1
        STRB    R2,[R1,#ProcessorFlags]
d1534 1
a1534 1
        MOV     r14, #0
d1582 1
a1582 1
        MOV     r3, #0
d1597 1
a1597 1
        MOV     r0, #0
d1626 1
a1626 1
str_booterror   DCB     "Boot$Error",0
d1631 1
a1631 1
    [ :LNOT: STB
d1634 2
a1635 1
        BLVC    WriteS_Translated
d1638 1
d1661 1
a1661 1
IsKeyPressedAtReset ENTRY "r0-r2"
a1669 28
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    [ AddTubeBashers
TubeDumpR0     ROUT
        EntryS  "R1, R2"
        ADR   lr, HexTable
        TubeChar r0, r1, "MOV r1, #"" """
        MOV    R1, #7
01      MOV    R0, R0, ROR #28
        AND    R2, R0, #&F
        TubeChar R0, R1, "LDRB R1, [lr, R2]"
        SUBS   R1, R1, #1
        BPL    %BT01
        TubeChar r0, r1, "MOV r1, #"" """
        EXITS

TubeNewl
        EntryS
        TubeChar R0, R1, "MOV R1, #10"
        TubeChar R0, R1, "MOV R1, #13"
        EXITS

HexTable = "0123456789ABCDEF"

    ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@


4.16.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d17 1
a17 5
 [ HAL32
DuffEntry *     &FAFF8000               ; Never any memory at this address
 |
DuffEntry *     &01F08000               ; Never any memory at this address
 ]
d79 1
a79 1
GetConfiguredSize Entry "r1"
d266 3
d270 1
a425 1
MemSized
d460 1
a460 1
        MRS     r0, CPSR                ; switch into IRQ32, still IRQs disabled
d463 1
a463 1
        MSR     CPSR_c, r1
d499 1
a499 1
        MSR     CPSR_c, r0
d573 1
a573 1
        MRS     r0, CPSR
d576 1
a576 1
        MSR     CPSR_c, r0
a1430 1
 [ :LNOT:HAL
d1458 1
a1458 1
        LDR     R2, =CursorChunkAddress
d1472 1
a1472 1
        LDR     R2, =SysHeapChunkAddress
d1484 1
a1484 2
        ADD     r2, r0, #((L1PT-L2PT):SHR:(12-3))   ; point at PPL for 1st L1 page
        ADD     r2, r2, #4
a1499 1
 ]
a1596 6
 [ HAL32
        MOV     R0, #0
        LDR     R0, [R0, #RAMLIMIT]
        SUB     R0, R0, #32*1024
        MOV     R0, R0, LSR #12
 |
a1597 1
 ]
d1681 1
a1681 1
        MRS     r2, CPSR
d1684 1
a1684 1
        MSR     CPSR_c, r3
d1727 1
a1727 1
        MSR     CPSR_c, r2
d2242 1
a2242 1
IsKeyPressedAtReset Entry "r0-r2"
@


4.16.2.2
log
@More HAL work. IOMD HAL work in progress. Lots of my own little build
scripts. Don't touch this.

Version 5.35, 4.79.2.2. Tagged as 'Kernel-5_35-4_79_2_2'
@
text
@a144 1
        LDR     r4, =FreePoolDANode
d146 1
a535 2
Continue_after_HALInit

d580 1
d683 1
a683 1
        LDR     R1, =DuffEntry          ; nothing will be here!!
a686 5
 [ HAL
us      * 1
 |
us      * 2
 ]
a692 3
      [ HAL
        AddressHAL
      ]
d697 2
a698 2
        MOVEQ   r0, #us
        LDRNE   r0, =KeyWait*us         ; Wait 1/5 second (give keys down a chance to come in).
d700 1
a700 1
        LDR     r0, =KeyWait*us         ; Wait 1/5 second (give keys down a chance to come in).
a701 3
      [ HAL
        CallHAL HAL_CounterDelay
      |
a702 1
      ]
a790 10
 [ HAL
        MOV     R0, #InitHALFlags
        LDR     R1, [R0]
        TST     R1, #OSStartFlag_POR
        BEQ     no_cmos_reset
        TST     R1, #OSStartFlag_NoCMOSReset
        BNE     no_cmos_reset
        TST     R1, #OSStartFlag_CMOSReset
        BNE     cmos_reset
 |
d796 1
a796 1
 [ CheckProtectionLink :LAND: :LNOT: HAL
a819 2
 ] ; HAL

a837 3
 [ HAL
        ! 0, "Sort out SetBorder for CMOS reset"
 |
a838 1
 ]
d846 1
a847 1
 [ STB
a927 4
 [ HAL
        ! 0, "Sort out 16-bit sound + PS/2 mouse CMOS reset selection"
 |

d948 1
a948 1
 ] ; MorrisSupport
a977 1
 ] ; HAL
a1709 2


a1739 1

a1743 6

; clear the keyboard workspace (tidy!)
        MOV     R0, #InitKbdHandler
        MOV     R1, #0
        MOV     R2, #InitWsEnd - InitKbdHandler
        BL      memset
@


4.16.2.3
log
@More HAL work. IOMD HAL fleshed out somewhat - system gets most of the way
through initialisation.

Version 5.35, 4.79.2.5. Tagged as 'Kernel-5_35-4_79_2_5'
@
text
@d1635 6
a1640 6
; [ HAL32
;        MOV     R0, #0
;        LDR     R0, [R0, #RAMLIMIT]
;        SUB     R0, R0, #32*1024
;        MOV     R0, R0, LSR #12
; |
d1642 1
a1642 1
; ]
a1671 5
  [ HAL
        MOV     R0, #InitHALFlags
        LDR     R1, [R0]
        TST     R1, #OSStartFlag_POR
  |
a1675 1
  ]
d1699 11
a1709 1
        BL      InitialiseIRQ1Vtable
@


4.16.2.4
log
@  Added HAL NVRAM support
Detail:
  Added the HAL NVRAM entries.
  Modified i2cutils to use the HAL entries for NVRAM and behave sensibly if the HAL reports that there is no NVRAM, in which case there must be a forced reset_cmos call so that the cache gets set up sensibly.
Admin:
  Tested under the RPC emulator and appears to be working correctly, although some calls to IIC are still being made in the no nvram case.

Version 5.35, 4.79.2.8. Tagged as 'Kernel-5_35-4_79_2_8'
@
text
@a592 4
    	TEQ 	R0, #0	    	    	; returns zero on failure
    	LDREQ 	R1, [R0, #InitHALFlags]
    	ORREQ 	R1, R1, #OSStartFlag_NoCMOS
    	STREQ	R1, [R0, #InitHALFlags]
a806 2
        TST     R1, #OSStartFlag_NoCMOS	; If no CMOS, reset for sensible cache
        BEQ     cmos_reset
@


4.16.2.5
log
@Wahey! This version gives you a display.

It says "Abort on data transfer".
@
text
@a1818 1
 [ :LNOT: HAL
a1819 1
 ]
@


4.16.2.6
log
@More L7200 HAL work
@
text
@d812 1
a812 1
        BNE     cmos_reset
d1874 1
a1874 1
  [ :LNOT: HAL :LAND: RO371Timings
d2076 1
a2076 1
        =	"600:ARM 600 Processor", 0
d2078 1
a2078 1
	=	"610:ARM 610 Processor", 0
d2080 1
a2080 1
	=	"700:ARM 700 Processor", 0
d2082 1
a2082 1
	=	"710:ARM 710 Processor", 0
d2084 1
a2084 1
	=	"810:ARM 810 Processor", 0
d2086 1
a2086 1
	=	"SA110:StrongARM Processor", 0
d2088 1
a2088 1
	=	"7500:ARM 7500 Processor", 0
d2090 1
a2090 1
	=	"7500FE:ARM 7500FE Processor", 0
@


4.16.2.7
log
@set mode working with LCD
@
text
@d701 1
a701 1
        MOV     r6, #10                 ; Check for keyboard 10 times (2 secs max).
d722 1
a722 1
        SUBS    r6, r6, #1              ; else wait a maximum of 2 seconds.
@


4.16.2.8
log
@More stuff. Up to the desktop now; cache on, working keyboard. Some source
restructuring to start to make splitting it up into several object files more
feasible.
@
text
@d594 1
a594 1
    	LDREQ 	R1, [R0, #HAL_StartFlags]
d596 1
a596 1
    	STREQ	R1, [R0, #HAL_StartFlags]
a697 3
 [ HAL
        ! 0, "Sort out keyboard boot detection"
 |
d726 1
a726 1
  ]
d809 1
a809 1
        MOV     R0, #HAL_StartFlags
d825 1
a825 1
 [ CheckProtectionLink
d1679 1
a1679 1
        MOV     R0, #HAL_StartFlags
d1920 16
a1935 3
;        IMPORT  ARM_PrintProcessorType
        BL      ARM_PrintProcessorType
  ]
a1971 6
 [ HAL
        LDR     r1, =HAL_StartFlags
        LDR     r1, [r1]
        TST     r1, #OSStartFlag_NoCMOSReset
        BNE     %FT75
 |
a1977 1
 ]
d2070 42
d2118 7
a2124 1
        DCD &a100,5,2_11011 ;corrected for 3.71 (SA does not abort for vector reads in 26-bit mode)
d2128 1
a2186 1
 [ :LNOT: HAL
a2188 1
 ]
@


4.16.2.9
log
@Stuff. A bit of touchscreen, I expect, and probably some other bits too.
@
text
@a966 11
        AddressHAL
        CheckHAL HAL_TouchscreenType
        BEQ     dont_program_mousetype
        CallHAL HAL_TouchscreenType
        TST     R0, #&FF
        BEQ     dont_program_mousetype

        MOV     R0, #MouseCMOS
        MOV     R1, #6 ; To be assigned
        BL      Write

a967 1
dont_program_mousetype
@


4.16.2.10
log
@more use of ARMops in page manipulation, change register usage of ARmops
tested by kernel boot to star prompt only

Version 5.35, 4.79.2.11. Tagged as 'Kernel-5_35-4_79_2_11'
@
text
@a16 5
; DuffEntry is the address of "Nowhere"
;  - there should never be any page actually mapped to this address (L2PT entry always 0)
;  - a page that is not mapped in should always have this special address in its CAM entry,
;    ie. should only be one Nowhere
; 
d18 1
a18 1
DuffEntry *     &FAFF8000
d20 1
a20 1
DuffEntry *     &01F08000
a21 3

Nowhere * DuffEntry  ; synonym

@


4.16.2.11
log
@Check-in of the few last-minute changes for the Customer L demo. Nothing
exciting, apart from an extended touchscreen API.

Version 5.35, 4.79.2.13. Tagged as 'Kernel-5_35-4_79_2_13'
@
text
@d21 1
a21 1
;
a986 1

a987 6

; set print and sound CMOS (16bit sound)
        MOV     R0, #TutuCMOS
        MOV     R1, #2_10100100  ; tbs chars valid, ctrlchars '|x'
        BL      Write

@


4.16.2.12
log
@First attempt at ARM9 support, and general clean-up of old ARM-specific
code, now using vectored ARMops.
Not tested.

Version 5.35, 4.79.2.14. Tagged as 'Kernel-5_35-4_79_2_14'
@
text
@a229 9
  [ HAL
    ! 0, "*** DUMMY CONT_Break, soft breaks/resets will not work yet with HAL"
CONT_Break
    B    CONT_Break
  ]


  [ :LNOT: HAL

a344 1

d502 3
a543 3

  ]    ; :LNOT: HAL

d601 4
a604 4
        TEQ     R0, #0                  ; returns zero on failure
        LDREQ   R1, [R0, #HAL_StartFlags]
        ORREQ   R1, R1, #OSStartFlag_NoCMOS
        STREQ   R1, [R0, #HAL_StartFlags]
d672 20
a691 5
; OK, that completes the poking around, some of which is code. Now let's
; do a full IMB type thing, to be safe
;
        MOV     r0, #0
        ARMop   IMB_Full,,,r0
d741 1
a741 1
        MOV     R3, #-1                 ; do all RAM if we do any
d743 1
a743 1
        BNE     cmos_reset
d748 1
a748 1
        MOV     R1, #ScreenSizeCMOS
d750 7
a756 7
        MOV     R0, R1
        BL      Read
        TEQ     R0, #0
        BNE     cmos_reset
        INC     R1
        TEQ     R1, #SpriteSizeCMOS
        BHI     reset_loop
d762 4
a765 4
        MOV     R0, #FontCMOS
        BL      Read
        CMP     R0, #32
        BHI     cmos_reset
d770 2
a771 2
        MOV     R0, #VduCMOS
        BL      Read
d774 1
a774 1
        TEQ     R0, #(Sync_Separate :OR: MonitorType0)
d777 1
a777 1
        TEQ     R0, #(Sync_Auto :OR: MonitorTypeAuto)
d779 1
a779 1
        BNE     cmos_reset
d784 4
a787 4
        MOV     R0, #YearCMOS+1
        BL      Read
        TEQ     R0, #19
        BNE     check20
d790 7
a796 7
        MOV     R0, #YearCMOS
        BL      Read
        CMP     r0,#95
        BLT     cmos_reset
        CMP     r0,#99
        BHI     cmos_reset
        B       checkboot
d799 2
a800 2
        TEQ     R0, #20
        BNE     cmos_reset
d803 4
a806 4
        MOV     R0, #YearCMOS
        BL      Read
        CMP     R0, #20
        BHI     cmos_reset
d810 4
a813 4
        MOV     R0, #DBTBCMOS
        BL      Read
        TEQ     R0, #(1:SHL:4)
        BNE     cmos_reset
d822 1
a822 1
        TST     R1, #OSStartFlag_NoCMOS ; If no CMOS, reset for sensible cache
d999 6
a1004 6
        LDRB    r0, [r8, #IOMD_ID0]
        LDRB    r1, [r8, #IOMD_ID1]
        ORR     r0, r0, r1, LSL #8
        LDR     r1, =IOMD_Original
        TEQ     r0, r1
        BEQ     dont_program_mousetype
d1067 2
a1068 2
        =       StartCMOS,              (2:SHL:3)                               ; NOCAPS
        =       DBTBCMOS,               (1:SHL:4)                               ; Boot
d1073 1
a1073 1
        =       VduCMOS,                Sync_Separate :OR: MonitorType0
d1076 1
a1076 1
        =       VduCMOS,                Sync_Auto :OR: MonitorTypeAuto
d1079 1
a1079 1
        =       SystemSpeedCMOS,        (1:SHL:2):OR:(1:SHL:4):OR:(0:SHL:5)
d1776 25
a1800 7
   ;we need to do an IMB type thing for modifying code in vector area,
   ;and for copying irq handler code
   ;
        Push    "r0"
        MOV     r0, #0
        ARMop   IMB_Full,,,r0
        Pull    "r0"
d2137 1
a2137 1
        STRMI   R2,[R0,#ProcessorType]
d2145 1
a2145 1
        STR     R2,[R1,#ProcessorFlags]
@


4.16.2.13
log
@Customer L-y HAL-y IIC-y type stuff. It's great.
@
text
@a601 1
 [ {FALSE}
a607 6
 |
        BL      Start
        MOV     R0, #1
        BL      TXAck
        BL      Stop
 ]
@


4.16.2.14
log
@Added some missing IIC and USB files.
An attempt to do NVMemory by using part of the Flash that the OS is sitting
in for Customer L. Programming algorithm works, but I'm not confident that the
Kernel does the right thing yet.

Version 5.35, 4.79.2.19. Tagged as 'Kernel-5_35-4_79_2_19'
@
text
@d741 1
a741 1
 [ ValidateCMOS
@


4.16.2.15
log
@Hopefully working NVMemory on Customer L now.

Version 5.35, 4.79.2.20. Tagged as 'Kernel-5_35-4_79_2_20'
@
text
@d814 2
a815 2
        TST     R0, #(1:SHL:4)
        BEQ     cmos_reset
@


4.16.2.16
log
@* Fixed the IIC code.
* Kernel puts sensible default FIQ handler in through the HAL.
* Fix to temporary page uncaching code.

Version 5.35, 4.79.2.30. Tagged as 'Kernel-5_35-4_79_2_30'
@
text
@d588 1
a588 1
        TEQ     R0, #EndMOSROMVecs-MOSROMVecs
d1799 1
a1799 1
        MOV     R0, #&1C
d1801 1
a1801 1
        MOV     R2, #InitWsEnd - &1C
@


4.16.2.17
log
@* Allows interrupt-driven use of PointerV (as well as polled).
* Allows HAL-driven software resets.
* Sound buffers corrected to be uncacheable.

Version 5.35, 4.79.2.33. Tagged as 'Kernel-5_35-4_79_2_33'
@
text
@a232 2
        AddressHAL
        CallHAL HAL_Reset
d641 1
d645 1
a745 4

 ]

 [ ValidateCMOS :LAND: STB
@


4.16.2.18
log
@Merge in long command line support from Ursula kernel.
Look for LongCommandLine flag, command line size currently
set at 1k.
For HAL/32bit builds, the kernel buffer space is at high
(top bit set) address, which may break some code using signed
comparisons. So *beware* that there may be some latent
bugs in old kernel code using these buffers, not yet found.
One such bug, in s.Arthur2 found and fixed.
Tested moderately on ARM9 desktop build.
Lovely to reimplement things I did two and half years ago.

Version 5.35, 4.79.2.37. Tagged as 'Kernel-5_35-4_79_2_37'
@
text
@a1623 16
  [ LongCommandLines :LAND: (:LNOT: HAL)
        ;sort out the Kernel buffers dynamic area
        Push    "r0-r12"
        MOV     r1, #ChangeDyn_Kbuffs   ; Area number
        MOV     r2, #KbuffsSize         ; Initial (and in fact permanent) size
        LDR     r3, =KbuffsBaseAddress  ; Base address
        MOV     r4, #AP_Kbuffs          ; Area flags
        MOV     r5, #KbuffsMaxSize      ; Maximum size
        MOV     r6, #0                  ; no handler
        MOV     r7, #0
        ADRL    r8, AreaName_Kbuffs     ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
        Pull    "r0-r12"
  ]

d1635 1
a1635 1
        MOV     r5, #16*1024*1024       ; Maximum size (changed from -1, address space preservation)
@


4.16.2.19
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d121 6
d245 1
d288 1
d290 3
d307 45
@


4.16.2.20
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d56 1
a56 1
; On ARM600, InitIRQWs is in zero page - check it's big enough
d58 1
a58 1
        ASSERT  @@ <= ?InitIRQWs
d126 8
a207 8
        Push    lr
        MOV     lr, #0
        LDR     lr, [lr, #VRAMFlags]
        TST     lr, #2
        MOVNE   lr, #0
        LDRNE   r0, [lr, #VideoSize]
        Pull    pc, NE

d220 1
a220 1
        Pull    pc
d438 1
a438 1
        STR     R2, [R3, #InitIRQHandler] ; instruction is now a LDR PC,InitKbdHandler
a536 2
        ChangedProcVecs r0

d548 13
a560 3
        BL      IICAbort

        BL      IICInit
a562 1
        DebugTX "InitCMOSCache entry"
a563 1
        DebugTX "InitCMOSCache done"
a637 1
        DebugTX "IMB_Full done"
d812 1
a812 1
        MOV     R0, #InitIRQWs
d914 1
a914 1
        MOV     R0, #InitIRQWs
d1019 1
a1019 1
        =       YearCMOS,               02
d1068 1
a1068 1
        =       YearCMOS,       02
d1543 1
a1543 1
        MOV     r3, #-1                 ; Base address dynamic
a1551 1
        STR     r3, [r7, #ScreenEndAddr]
d1627 1
a1627 2
        MOV     r5, #32*1024*1024       ; Maximum size changed from -1 for Ursula (limit address
                                        ; space usage on large memory machines)
d1702 1
a1702 1
        MOV     R1, #InitIRQWs
a1747 1
        ChangedProcVecs r0
a1749 1

a1783 11
 [ DebugTerminal
        MOV     R0, #RdchV
        ADRL    R1, DebugTerminal_Rdch
        MOV     R2, #0
        LDR     R2, [R2, #HAL_Workspace]
        SWI     XOS_Claim
        MOV     R0, #WrchV
        ADRL    R1, DebugTerminal_Wrch
        SWI     XOS_Claim
 ]

d1883 1
a1883 10

        Push    "R0"
        MOV     R0, #8
        ORR     R0, R0, #&500
        SWI     XOS_Memory              ; returns amount of soft ROM (pages) in r1
        MOVVS   R1, #0
        Pull    "R0"
        MLA     R0, R1, R2, R0          ; convert pages to bytes and add in

        MOV     R0, R0, LSR #20         ; /(1024*1024) down to megabytes
@


4.16.2.21
log
@  Mostly device stuff.
Detail:
  * Implemented OS_Hardware 2, 3 and 4 as described in Docs.HAL.NewAPI.
  * Added new OS->HAL and HAL->OS routines to register HAL devices with the
    OS during hard resets.
  * Updated Docs.HAL.NewAPI to correct inconsistencies, fill in missing
    definitions, and allow for interrupt sharing.
  * Now uses OS_LeaveOS to trigger callbacks after ROM module init.
Admin:
  Untested. Requires new HAL.

Version 5.35, 4.79.2.49. Tagged as 'Kernel-5_35-4_79_2_49'
@
text
@d1807 1
a1807 7
 [ HAL
        AddressHAL
        MOV     R0, #0
        STR     R0, [R0, #DeviceCount]
        STR     R0, [R0, #DeviceTable]
        CallHAL HAL_InitDevices         ; get HAL to register any devices it has
 |
d1845 1
a1845 1
; Changed to use OS_LeaveOS 16-Oct-02
d1852 9
a1860 1
        SWI     XOS_LeaveOS
@


4.16.2.22
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@a227 1
        MOV     a1, #1
d229 1
d920 7
d928 1
a928 1
        MOV     R1, #PointerDevice_USB
d931 4
a1524 14
; RMA
        Push    "r0-r12"
        MOV     r1, #ChangeDyn_RMA      ; Area number
        MOV     r2, #4096               ; Initial size
        MOV     r3, #RMAAddress         ; Base address
        MOV     r4, #AP_RMA             ; Area flags
        MOV     r5, #RMAMaxSize         ; Maximum size
        ADRL    r6, DynAreaHandler_RMA  ; Pointer to handler
        MOV     r7, r3                  ; Workspace ptr points at area itself
        ADRL    r8, AreaName_RMA        ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
        Pull    "r0-r12"

d1550 14
d1606 2
a1607 10
        ARM_read_ID r4
        AND     r4, r4, #&F000
        CMP     r4, #&A000
        MOVEQ   r4, #AP_RAMDisc_SA      ; Area flags, if StrongARM  (introduced for Ursula)
        MOVNE   r4, #AP_RAMDisc         ; Area flags
      [ {FALSE}
        MOV     r5, #16*1024*1024       ; Limit maximum size to 16MB while fiddling with FileCore
      |
        MOV     r5, #128*1024*1024      ; A trade off between nice big disc and complete waste of address space
      ]
a1716 10
; Create the Branch Through 0 Trampoline in the system heap
        MOV     R3, #Branch0_Trampoline_Size
        BL      ClaimSysHeapNode
        ADRVCL  R0, Branch0_Trampoline
        ASSERT  Branch0_Trampoline_Init = 20
        LDMVCIA R0, {R1,R3,R4,R5,R14}
        STMVCIA R2, {R1,R3,R4,R5,R14}
        MOVVC   R0, #0
        STRVC   R2, [R0, #ProcVec_Branch0]

d2041 1
a2041 1
        B       .+Branch0_Trampoline
@


4.16.2.23
log
@Support for keys held down in the HAL at power on.
*Configure ANYTHINGsize was broken due to not setting R0 to ReadUnsigned
IIC ack message uninternationalised
OS_Memory was saying we only had 4M of RAM
VDU4 scrolling when output was switched to sprite was causing corruption
on use of CTRL-J and CTRL-K
Default SystemSize CMOS set to 32k

Version 5.35, 4.79.2.55. Tagged as 'Kernel-5_35-4_79_2_55'
@
text
@a39 14
 [ HAL
KbdScanActive   # 1
                # 2
KbdFlags        # 4

KbdFlag_Ctrl    * 1:SHL:0
KbdFlag_Shift   * 1:SHL:1
KbdFlag_R       * 1:SHL:4
KbdFlag_T       * 1:SHL:5
KbdFlag_Delete  * 1:SHL:6
KbdFlag_Copy    * 1:SHL:7
KbdFlag_Present * 1:SHL:30
KbdFlag_Done    * 1:SHL:31
 |
a54 1
 ]
d648 1
a648 28
        AddressHAL
        MOV     r6, #25                 ; Check for keyboard 25 times (5 secs max).
        MOV     r4, #InitIRQWs

kbdwait
        CallHAL HAL_KbdScan
        STR     r0, [r4, #KbdFlags]

        TST     r0, #KbdFlag_Done
        BNE     kbddone

      [ EmulatorSupport
        ARM_on_emulator r0
        MOVEQ   r0, #us
        LDRNE   r0, =KeyWait*us         ; Wait 1/5 second (give keys down a chance to come in).
      |
        LDR     r0, =KeyWait*us         ; Wait 1/5 second (give keys down a chance to come in).
      ]
        CallHAL HAL_CounterDelay
        SUBS    r6, r6, #1              ; else wait a maximum of 5 seconds.
        BNE     kbdwait
kbddone
        MSR     CPSR_c, #I32_bit+SVC32_mode
        CallHAL HAL_KbdScanFinish
        MOV     r1, #InitIRQWs
        MOV     r0, #0
        STRB    r0, [r1, #KbdScanActive]
        MSR     CPSR_c, #SVC32_mode
d655 3
d667 3
d671 1
d704 10
a807 4
 [ HAL
        LDR     R7, [R0, #KbdFlags]
        TST     R7, #KbdFlag_R:OR:KbdFlag_T:OR:KbdFlag_Delete:OR:KbdFlag_Copy
 |
a809 1
 ]
a909 4
 [ HAL
        LDR     R1, [R0, #KbdFlags]
        TST     R1, #KbdFlag_R:OR:KbdFlag_Delete
 |
a913 1
 ]
d1023 1
a1023 1
        =       FontCMOS,       64      ; KJB 13-Dec-02: Changed to 256K from 64K
a1027 1
        =       SystemSizeCMOS, 8
d1102 3
a1104 4
        =       FontMaxCMOS,    64      ; 4096k
        =       FontMax2CMOS,   36:EOR:12 ; 36 point
        =       FontMax3CMOS,   36:EOR:24 ; 36 point
        =       FontMax4CMOS,   16      ; 16 point
d1112 1
a1112 1
        =       CDROMFSCMOS,    &C1     ; drives = 1, buffer size = 256K
a1696 5
 [ HAL
        LDR     R0, [R1, #KbdFlags]
        AND     R1, R0, #KbdFlag_Shift
        AND     R0, R0, #KbdFlag_Present
 |
a1698 1
 ]
a1745 6
        MOV     R2, #InitIRQWs                          ; clear temp ws
        MOV     R3, #0
        MOV     R4, #0
        STMIA   R2!, {R3,R4}
        STMIA   R2!, {R3,R4}

d2134 1
d2137 1
@


4.16.2.24
log
@  Miscellaneous stuff.
Detail:
  * Merged in the change to RISC OS 4.02 kernel that moved the GSTrans
    workspace out of scratch space.
  * Fixed a few bugs in callback postponement, and interrupt holes in
    callback dispatch. See Docs.CallbackChange for full info.
  * Fixed SystemSizeCMOS to SysHeapCMOS - wouldn't build as was.
  * Added an export of a C version of Hdr:HALDevice, based on the Hdr2H
    translation but with an additional struct definition. Required by
    SoundControl 1.00.
  * Added some additional location and ID allocations to Hdr:HALDevice.
    Required by today's HAL and SoundControl.
Admin:
  Partially tested.

Version 5.35, 4.79.2.56. Tagged as 'Kernel-5_35-4_79_2_56'
@
text
@d1063 1
a1063 1
        =       SysHeapCMOS,    8
@


4.16.2.25
log
@OSDelink/RelinkApp now work on the list in opposite orders so that
the order of vector claims doesn't get toggled.
Fix for *FX5 not working due to a TST having been swapped for CMP.
Checkprotectionlink option added to HAL version so CMOS lock is
implemented.
Updated HAL docs.

Version 5.35, 4.79.2.58. Tagged as 'Kernel-5_35-4_79_2_58'
@
text
@d787 1
a787 1
; IF power-on bit set AND R/T/Del/Copy pressed THEN reset CMOS RAM
d795 1
a795 2
        BEQ     no_cmos_reset           ; not a power on reset
      [ CheckProtectionLink
a797 1
      ]
d806 1
a806 1
      [ CheckProtectionLink
d809 3
a811 2
        ; on Issue A's the protection bit is only weakly pulled up,
        ; so force it high, then read it back
d819 1
a819 1
      ]
d821 2
a822 2
    [ STB :LAND: IOMD_C_FrontPanelButton <> 0
      [ FrontPanelButtClearsCMOS
d827 2
a828 2
      ]
    ]
d830 1
a830 1
 ]
d842 1
a842 1
      [ :LNOT: STB
d844 1
a844 1
      ]
d2010 1
a2010 1
 [ HAL :LAND: CheckProtectionLink
d2016 1
a2016 1
      [ CheckProtectionLink
d2021 1
a2021 1
      ]
@


4.16.2.26
log
@Huge update to L7200 HAL for Customer M 2 demo - now runs with 5.02 Kernel
used in Tungsten.
Added "fast" flash tool for Customer L, allowing ROMs to be sent serially at
115200 baud not 9600 baud.
Fix to VDU despatch for ARMv4 and later.
Fixes to power on delete keyboard and keyboard timeout
Implemented MemoryReadPhys and MemoryAmounts with the HAL.

Version 5.35, 4.79.2.59. Tagged as 'Kernel-5_35-4_79_2_59'
@
text
@a857 1
        TST     R7, #KbdFlag_Copy:OR:KbdFlag_Delete
d859 1
a859 4
        SetBorder  R0, R1, 15, 0, 0     ; flash the border as warning!
        ASSERT  (Del_Down_Flag - R_Down_Flag) = 2
        ASSERT  (Copy_Down_Flag - Del_Down_Flag) = 1 
        MOVS    R3, R7, LSR #16         ; full reset or just system?
d862 1
@


4.16.2.27
log
@* HAL can choose to limit amount of screen memory to allocate
  [Not fully implemented - for now leaves at least 16MB free if only
  one RAM area; was 1MB].
* Added HAL_USBControllerInfo, HAL_MonitorLeadID and HAL_Video_Render.
* Added HAL->OS call OS_IICOpV.
* OS_MMUControl now allows independent control of I and C bits.
* Added facility to deactivate keyboard debounce (magic word "NoKd" in
  R2 in KeyV 0).
* Fixed problem with RAM amounts not a multiple of 4MB.
* Supremacy bit (in VDU 19) now sets all 8 bits of supremacy.
* Added PaletteV 14 (reads gamma tables).
* Added Supremacy transfer functions (like gamma correction, but for
  supremacy). Allows easy global supremacy effects in a mode-independent
  fashion. Controlled with PaletteV 15,16.
* Added modes 50-53 (320x240, 1,2,4,8bpp). Intended for small LCD.
* Added 13.5kHz versions of TV modes (selected by Hdr:Machine).
* Upped desktop version to 5.06.

Version 5.35, 4.79.2.66. Tagged as 'Kernel-5_35-4_79_2_66'
@
text
@d862 1
a862 1
        ASSERT  (Copy_Down_Flag - Del_Down_Flag) = 1
d1092 1
a1092 1
        =       YearCMOS,       04
@


4.16.2.28
log
@* Changed some STB switches to Embedded_UI
* Added use of CDVPoduleIRQs (from Hdr:Machine)
* Fixed checksum corruption in OS_NVMemory block writes ending just below
  the checksum byte.
* Fixed R4 corruption by OS_Byte 162 with certain HALs.

Version 5.35, 4.79.2.71. Tagged as 'Kernel-5_35-4_79_2_71'
@
text
@d1854 1
a1854 1
        [ DoInitialiseMode :LOR: :LNOT: Embedded_UI
d1942 1
a1942 1
    [ DoInitialiseMode :LOR: :LNOT: Embedded_UI
d1944 1
a1944 1
     [ :LNOT: Embedded_UI
d1972 1
a1972 1
  [ Embedded_UI
d2081 1
a2081 1
    [ DoInitialiseMode :LOR: :LNOT: Embedded_UI
d2272 1
a2272 1
    [ :LNOT: Embedded_UI
@


4.16.2.29
log
@Update the method the HAL kernel uses to determine the UtilityModule & ROM dates
Detail:
  Three main changes:
  * On odd-numbered (i.e. development) versions of the module, the UtilityModule will now take its date from the VersionNum file instead of using a hard-coded date
  * All build versions now look for the new "extended ROM footer" (as created by romlinker 0.04+) at the end of the ROM image and use it to determine the ROM build date for return by OS_ReadSysInfo 9,2. Failing to find the build date in the footer will cause OS_ReadSysInfo 9,2 to return 0.
  * On odd-numbered versions, OS_Byte 0 will now use the ROM build date (as found in the extended footer) to generate the error block that's returned to the user. This seems OK as the PRM describes OS_Byte 0 as returning the "creation date of the operating system". Plus it's a convenient way of getting the ROM build date into the Switcher, since the switcher uses OS_Byte 0. If the extended footer can't be found (or if the string isn't initialised yet, e.g. before Service_PostInit) the code falls back to a hard-coded string containing the date from the VersionNum file.
  File changes:
  Makefile - Updated to not create the obsolete Time+Date file (previously used for the ROM build date)
  Version - Use date from VersionNum file for development builds
  hdr/Options - New UseNewFX0Error variable/option to make it easy to check which OS_Byte 0 variant should be enabled
  hdr/KernelWS - Added new string buffers & extended ROM footer pointer to workspace
  s/Middle - Updated OS_ReadSysInfo 9 code, and added utility functions for searching the extended ROM footer for certain tags
  s/NewReset - Added a couple of calls to initialise the new string buffers just prior to Service_PostInit. This is required since OS_Byte/OS_ReadSysInfo shouldn't enable interrupts, but date conversion relies on the Territory module, which may enable interrupts.
  s/PMF/osbyte - Updated OS_Byte 0 code
Admin:
  Tested in Tungsten ROM, with and without the extended footer present.


Version 5.35, 4.79.2.115. Tagged as 'Kernel-5_35-4_79_2_115'
@
text
@a1901 16
        ; OS_ReadSysInfo 9,2 now relies on the Territory module, which may
        ; enable IRQs. But the PRMs say OS_ReadSysInfo shouldn't alter the IRQ
        ; state. So call it once here just to initialise the string which it
        ; uses the Territory module to generate.
        ; This won't account for any modules using it during ModuleInit, but
        ; that should be pretty rare (or at least rare from within IRQ-sensitive
        ; code)
        MOV     R0, #9
        MOV     R1, #2
        SWI     XOS_ReadSysInfo

  [ UseNewFX0Error
        ; Also, *FX 0
        BL      InitNewFX0Error
  ]

@


4.16.2.30
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d107 1
a107 1
        LDR     r1, =ZeroPage
d138 1
a138 1
        LDR     R10, =ZeroPage
d154 1
a154 1
        LDR     r4, =ZeroPage+FreePoolDANode
d176 1
a176 2
        LDR     R7, =ZeroPage
        LDR     R8, [R7, #RAMLIMIT]
d182 1
a183 1
;        MOV     r7, #0
d216 1
a216 1
        LDR     lr, =ZeroPage
d219 1
a219 1
        LDRNE   lr, =ZeroPage
a224 3
      [ ZeroPage <> 0
        LDR     r0, =ZeroPage
      ]
d532 1
a532 1
        LDR     R1, =ZeroPage+ProcVec_Start
d544 1
a544 2
        LDR     R0, =ZeroPage+4
        LDR     R3, =ZeroPage+EndMOSROMVecs-MOSROMVecs
d549 1
a549 1
        TEQ     R0, R3
d563 4
a573 3
      [ ZeroPage <> 0
        LDREQ   R0, =ZeroPage
      ]
d580 1
a580 1
        LDR     R0, =ZeroPage+IRQ1V
a589 1
        LDR     R3, =ZeroPage+(EndData-StartData+IRQ1V)
d593 1
a593 1
        TEQ     R0, R3
d597 1
a597 1
        LDR     r0, =ZeroPage
d600 2
a601 2
        MOV     r3, #0                  ; initialise abort list
        STR     r3, [r0, #AbortIndirection]
d645 1
a645 1
        LDR     r0, =ZeroPage
d651 1
a651 1
        LDR     R0, =ZeroPage
d665 1
a665 1
        LDR     r4, =ZeroPage+InitIRQWs
d687 1
a687 1
        LDR     r1, =ZeroPage+InitIRQWs
a690 1
        DebugTX "Keyboard scan complete"
d790 1
a790 1
        LDR     R0, =ZeroPage+HAL_StartFlags
d833 1
a833 1
        LDR     R0, =ZeroPage+InitIRQWs
d943 1
a943 1
        LDR     R0, =ZeroPage+InitIRQWs
d1061 1
a1061 5
   [ M_CortexA8 :LOR: M_CortexA9
        =       FileLangCMOS,   26      ; SCSIFS for OMAP3, etc.
   |
        =       FileLangCMOS,   8       ; ADFS
   ]
a1152 3
   [ M_CortexA8 :LOR: M_CortexA9
        =       CDROMFSCMOS,    &C0     ; drives = 0, buffer size = 256K
   |
a1153 1
   ]
d1191 1
a1191 1
        LDR     R5, =ZeroPage
d1219 1
a1219 1
        LDR     R4, =ZeroPage
d1236 1
a1236 1
        LDR     R0, =ZeroPage+InitKbdWs
d1261 1
a1261 2
        LDR     r7, =ZeroPage
        LDR     R2, [R7, #Page_Size]
d1265 1
d1302 1
a1302 1
        LDR     R1, =ZeroPage
d1304 1
a1304 2
        LDR     R2, [R1, #Page_Size]
        MOV     R7, #0
d1310 1
d1314 2
a1315 1
        LDR     R4, [R1, #CamEntriesPointer] ; no PPL
d1339 1
a1339 3
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
      ]
d1345 1
a1345 1
        LDR     R11, =ZeroPage+VecPtrTab
d1362 1
a1362 1
        LDR     R0, =ZeroPage
d1406 1
a1406 1
        LDR     R11, =ZeroPage+PIRQ_Chain
d1422 1
a1422 1
        LDR     R2, =ZeroPage+PIRQ_Chain
d1424 1
a1424 1
        LDR     R2, =ZeroPage+PFIQasIRQ_Chain
d1427 1
a1427 1
        LDREQ   r11, =ZeroPage+CallBack_Vector
d1435 1
a1435 1
        LDR     R0, =ZeroPage
a1436 1
        ASSERT  :LNOT: HAL
a1453 1
        LDR     r8, =ZeroPage
d1455 1
a1455 1
        STR     r2, [r8]                ; store to logical address zero
d1462 1
d1467 1
a1467 1
        LDR     r2, =ZeroPage
d1574 1
a1574 1
        LDR     r5, =ZeroPage
a1612 1
      [ ZeroPage = 0
a1613 4
      |
        LDR     r1, =ZeroPage
        STR     r0, [r1, #SpriteSize]   ; (fixes bug MED-00811)
      ]
d1681 1
a1681 1
        LDR     R1, =ZeroPage+AplWorkSize ; aplwork size
d1685 1
a1685 1
        LDR     R0, =ZeroPage
d1693 2
a1694 5
        LDR     R1, =ZeroPage+ModuleSWI_HashTab
        MOV     R2, #ModuleSHT_Entries
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
d1696 1
d1698 1
a1698 6
        STR     R0, [R1, R2, LSL #2]
        BGT     clearmswis

      [ ZeroPage <> 0
        LDR     R2, =ZeroPage
      ]
d1702 2
a1703 2
        STRB    R1, [R2, #ErrorSemaphore]               ; Don't translate errors.
        STR     R0, [R2, #KernelMessagesBlock]          ; No message file open.
d1705 1
a1705 1
        STR     R0, [R2, #CachedErrorBlocks]            ; No cached errors
d1710 1
a1710 1
        LDR     R0, =ZeroPage+HAL_StartFlags
d1724 1
a1724 1
        LDREQ   R0, =ZeroPage+OsbyteVars + :INDEX: LastBREAK
d1734 1
a1734 1
        LDR     R1, =ZeroPage+OsbyteVars + :INDEX: LastBREAK
d1737 1
a1737 1
        LDR     R1, =ZeroPage+InitIRQWs
d1750 1
a1750 1
        LDR     R3, =ZeroPage
d1752 2
a1753 2
        STR     R1, [R3, #PIRQ_Chain]
        STR     R1, [R3, #PFIQasIRQ_Chain]
d1757 3
a1759 3
        STRB    r0, [r3, #FIQclaim_interlock]
        STRB    r0, [r3, #CallBack_Flag]
        STR     r0, [r3, #CallBack_Vector]
d1768 1
a1768 1
        LDRVC   R0, =ZeroPage
d1793 1
a1793 1
        LDR     R2, =ZeroPage+InitIRQWs                 ; clear temp ws
d1802 2
d1806 1
a1806 1
        LDR     r0,=ZeroPage
d1818 2
a1819 3
        MOV     R1, #0
        STR     R1, [R0, #ReturnCode]
        STR     R1, [R0, #TickNodeChain]
d1822 2
a1823 1
        ADD     R0, R0, #&1C
d1831 1
a1831 1
        LDR     R1, =ZeroPage+DUMPER
a1834 1
        DebugTX "VduInit"
a1835 1
        DebugTX "ExecuteInit"
a1836 1
        DebugTX "KeyInit"
a1837 1
        DebugTX "MouseInit"
a1838 1
        DebugTX "OscliInit"
a1840 1
        DebugTX "Enabling IRQs"
a1841 1
        DebugTX "IRQs on"
d1846 1
a1846 1
        LDR     R2, =ZeroPage
a1851 1
        DebugTX "Debug terminal on"
a1867 1
        DebugTX "HAL_InitDevices"
a1869 1
      [ ZeroPage = 0
a1871 5
      |
        LDR     R1, =ZeroPage
        STR     R0, [R1, #DeviceCount]
        STR     R0, [R1, #DeviceTable]
      ]
a1872 1
        BL      LookForHALRTC ; Check if an RTC was just added. This is currently the only place where HAL RTCs are checked for; if we wanted to check anywhere else (e.g. after ROM module initialisation) then we'd have to listen for Service_Hardware so we can cope with device removal
a1875 1
        DebugTX "InitVariables"
a1876 1
        DebugTX "AMBControl_Init"
a1877 1
        DebugTX "ModuleInit"
d1888 1
a1888 1
        LDR     R0, =ZeroPage
d1941 2
a1942 2
     [ International                    ; Open the kernel messages file.
        LDR     r0, =ZeroPage+KernelMessagesBlock+4
a1946 1
      [ ZeroPage = 0
a1947 3
      |
        LDR     lr, =ZeroPage
        STRVC   r0, [lr, #KernelMessagesBlock]  ; Message file is now open.
a1948 1
     ]
d1952 1
a1952 1
        LDR     r0, =ZeroPage
a1954 1
        ASSERT  (ZeroPage :AND: 255) = 0
d1965 1
a1965 1
        LDR     R0, =ZeroPage
a1996 1
      [ ZeroPage = 0
d1998 1
a1998 5
      |
        LDR     r1, =ZeroPage
        STR     r0, [r1, #DomainId]     ; before calling anyone
      ]
      
d2031 1
a2031 1
        LDR     r1, =ZeroPage+HAL_StartFlags
d2049 1
a2049 1
        LDR     r3, =ZeroPage
d2151 1
a2151 1
 [ StrongARM :LAND: :LNOT: HAL
d2191 1
a2191 1
        LDR     r14, =ZeroPage
d2239 1
a2239 1
        LDR     r3, =ZeroPage
d2254 1
a2254 1
        LDR     r0, =ZeroPage
a2352 37
 [ HAL
LookForHALRTC
        Push "R0-R2,R8,R12,R14"
        LDR     R0, =ZeroPage
        LDR     R0, [R0, #RTCFitted]
        CMP     R0, #0
        Pull "R0-R2,R8,R12,PC",NE ; We already have an RTC
        LDR     R0, =(0:SHL:16)+HALDeviceType_SysPeri+HALDeviceSysPeri_RTC
        MOV     R1, #0
        MOV     R8, #4
01
        SWI     XOS_Hardware
        Pull "R0-R2,R8,PC",VS
        CMP     R1, #-1
        Pull "R0-R2,R8,PC",EQ
        LDR     R14, [R2, #HALDevice_Location]
        ; Currently, we only support devices located on IIC bus 0
        CMP     R14, #HALDeviceBus_Ser+HALDeviceSerBus_IIC
        BNE     %BT01
        ; Try activating
        Push "R0-R3"
        MOV     R0, R2
        MOV     LR, PC
        LDR     PC, [R2, #HALDevice_Activate]
        CMP     R0, #1
        Pull "R0-R3"
        BNE     %BT01
        DebugTX "HAL RTC detected!"
        LDR     R0, =ZeroPage
        STR     R2, [R0, #RTCFitted]
        ; Read the time from the RTC into RealTime, and fixup YearCMOS if needed
        BYTEWS  WsPtr
        BL      CheckYear
        DebugTX "Leaving LookForHALRTC"
        Pull "R0-R2,R8,R12,PC"
 ]
 
@


4.16.2.31
log
@Conversions rationalisation.
Delete pmf/convdate, moved to conversions.
Moved OS_BinaryToDecimal to conversions.
Remove OS_ConvertHex16 and friends.
Add OS_ConvertVariform skeleton.
Tidied conversions.

Version 5.35, 4.79.2.125. Tagged as 'Kernel-5_35-4_79_2_125'
@
text
@d629 2
a630 1
; conversion SWIs all go through same despatch point
d632 7
a639 3
        STR     R1, [R0, #OS_ConvertStandardDateAndTime * 4]
        STR     R1, [R0, #OS_ConvertDateAndTime * 4]
        
d644 2
a645 2
        CMP     R2, #OS_ConvertVariform
        BLS     conversionSWIfill
@


4.16.2.32
log
@Add a NOP after the mode change in MoreSWIs.s to sync with CallASWI module.
Add two more DebugTX in the reset sequence to announce power on reset and CMOS reset code paths.
In STB land the range of permitted dates is extended from 2020 (a bit close!) to 2037 when Unix time wraps.

Version 5.35, 4.79.2.133. Tagged as 'Kernel-5_35-4_79_2_133'
@
text
@d714 1
a714 1
 ]
d753 2
a754 1
; Year should be >=1995, <=2037 (when 32 bit signed Unix time breaks)
d757 18
a774 2
        MOV     R1, R0
        MOV     R0, #YearCMOS+0
d776 1
a776 5
        MOV     R2, #100
        MLA     R0, R2, R1, R0
        LDR     R1, =1995
        SUB     R0, R0, R1
        CMP     R0, #2037 - 1995
a796 1
        DebugTX "POR detected"
a875 1
        DebugTX "Reset CMOS"
@


4.16.2.33
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@d44 9
a247 1
        LDR     a2, =L1PT
@


4.16.2.34
log
@Select correct mouse type for IOMD systems
Detail:
  s/NewReset - When resetting the mouse type, for M_32 builds, check what IOMD version is fitted and select Quadrature/PS2 as appropriate
  Falls back to USB if no IOMD/unrecognised IOMD
Admin:
  Tested in IOMD softload on RiscPC


Version 5.35, 4.79.2.139. Tagged as 'Kernel-5_35-4_79_2_139'
@
text
@a940 26
     [ M_32
; M_32 used for IOMD based machines, select quadrature or PS2 as appropriate
        AddressHAL
        MOV     R0, #0
        MOV     R1, #&400
        CallHAL HAL_ControllerAddress
        CMP     R0, #0
        MOVEQ   R1, #PointerDevice_USB
        BEQ     program_mousetype
        LDRB    R1, [R0, #IOMD_ID1]
        LDRB    R0, [R0, #IOMD_ID0]
        ORR     R0, R0, R1, LSL #8
        LDR     R1, =IOMD_Original
        TEQ     R0, R1
        MOVEQ   R1, #PointerDevice_QuadMouse
        BEQ     program_mousetype
        LDR     R1, =IOMD_7500
        TEQ     R0, R1
        LDRNE   R1, =IOMD_7500FE
        TEQNE   R0, R1
        MOVEQ   R1, #PointerDevice_PS2Mouse
        MOVNE   R1, #PointerDevice_USB
program_mousetype
        MOV     R0, #MouseCMOS
        BL      Write
     |
a943 1
     ]
@


4.16.2.35
log
@  Fix stack imbalances
Detail:
  In a couple of early exits from LookForHALRTC, R12 was missing from the
  pull macros.
Admin:
  Fix received from John Ballance.

Version 5.35, 4.79.2.147. Tagged as 'Kernel-5_35-4_79_2_147'
@
text
@d2424 1
a2424 1
        Pull "R0-R2,R8,R12,PC",VS
d2426 1
a2426 1
        Pull "R0-R2,R8,R12,PC",EQ
@


4.16.2.36
log
@Fix failure to boot with exactly 16MB of RAM
With no VRAM, in Kernerl.s.HAL line 370, the less than 16M case sets aside half the RAM as available for video (more than, it uses no more than 32M) but the exactly equals 16M case set aside none.
Add some exports to hdr.HALEntries to define the subreasons to OS_Hardware.

Version 5.35, 4.79.2.154. Tagged as 'Kernel-5_35-4_79_2_154'
@
text
@d2421 1
a2421 1
        MOV     R8, #OSHW_DeviceEnumerate
@


4.16.2.37
log
@Sort out SetBorder
NewReset.s:
The one remaining use of SetBorder was to denote the user asked for and got a CMOS reset, which in the HAL case emitted a warning because setting the border is potentially complicated/slow.
To solve this, the reset is noted and replaces the normal RISC OS banner with a warning message. The behaviour and text for this comes from the BBC Master, though the escape key is used in place of break since a reset isn't actually needed.
Moved the unused cputable inside its corresponding switch.
Two occurrences of WriteS_Translated would have executed the message in the V=1 case.
KernelWS/Resources:
Flag added to workspace, translation added to messages files.
Heapman.s:
Commented out use of SetBorder removed.
Kernel.s:
SetBorder macro removed.
Middle.s:
Switched out use of SetBorder removed.
Super1.s:
Conditional WriteS_Translated would try to execute the message in the opposite condition case.


Version 5.35, 4.79.2.157. Tagged as 'Kernel-5_35-4_79_2_157'
@
text
@d731 14
a768 1

d819 1
a819 1
        LDR     R7, [R0, #R_Down_Flag]  ; Picks up R/T/Del/Copy flags all in one
a821 3
        LDRNE   R3, =ZeroPage
        MOVNE   R14, #1
        STRNEB  R14, [R3, #MentionCMOSReset]
d838 1
d841 1
d2012 1
a2012 1
      [ DoInitialiseMode :LOR: :LNOT: Embedded_UI
d2014 1
a2014 25
      ]
    [ :LNOT: Embedded_UI
        LDR     R0, =ZeroPage
        LDRB    R14, [R0, #MentionCMOSReset]
        TEQ     R14, #0
        BEQ     %FT12
      [ International
        SWI     XOS_WriteI+10
        BVS     %FT09
        BL      WriteS_Translated
        =       "CmosRst:CMOS RAM reset, press ESCAPE to continue",0
        ALIGN
09
      |
        SWI     XOS_WriteS
        =       10,"CMOS RAM reset, press ESCAPE to continue",0
        ALIGN
      ]
10
        SWI     XOS_ReadEscapeState
        BCC     %BT10
        MOV     R0, #124
        SWI     XOS_Byte                ; Clear the condition
        SWI     XOS_WriteI+12           ; Clear the screen
12
d2019 4
d2027 1
a2027 3

        LDR     R0, =ZeroPage
        LDR     R0, [R0, #RAMLIMIT]
d2038 2
d2041 5
d2047 2
a2048 3
    |
        ! 0,    "Banner & printing of processor type disabled"
    ]
d2050 1
a2050 1
        MOV     r0, #0                  ; Set DomainId to 0 every reset
d2161 2
a2162 3
        BVS     %FT65
        BL      WriteS_Translated
        =       "MonType:Monitor type reconfigured",10,13,10,0
a2163 1
65
d2166 1
a2166 1
        =       10,"Monitor type reconfigured",10,13,10,0
a2193 6
      [ International
MessageFileName DCB     "Resources:$.Resources.Kernel.Messages",0
        ALIGN
      ]

 [ StrongARM :LAND: :LNOT: HAL
d2205 6
d2350 1
a2350 2
        BVS     %FT81
        BL      WriteS_Translated
a2352 1
81
@


4.16.2.38
log
@Merge with RPi branch
Detail:
  Merge the RPi branch with the HAL branch, ending RPi branch development
  Brief summary of changes brought in:
  * Added HAL_VideoStartupMode to allow the HAL to specify a startup mode for the OS
  * Fixed addresses being sent to GraphicsV_SetDMAAddress being wrong for external framestores (addresses were given as if internal framestore was in use)
  * Add InverseTextTransparency option for limited compile-time support for targets where framebuffer alpha channel is important
  * Fix ConfiguredLanguage for non-Tungsten builds
  * Update ARMv6 CPU detection to read cache parameters from cache type register instead of using KnownCPUTable
  * Add HALDebugHexTX/TX2/TX4 debug routines for writing out numbers via HAL
  * Use HAL_TimerIRQClear when clearing timer 0 interrupt instead of just HAL_IRQClear
  * Initialise FileLangCMOS using defines from Hdr:FSNumbers instead of magic numbers. Use SDFS on M_ARM11ZF.
  * Improved software mouse pointer support; software pointer now removed & restored in some of the same places the text cursor is
  * Improve support for external framestores; driver is now able to grow/shrink/move the framestore on mode changes if bit 5 of GraphicsV_DisplayFeatures R0 is set
  * GraphicsV_FramestoreAddress now has a default claimant which calls HAL_VideoFramestoreAddress
Admin:
  Tested on Raspberry Pi, Iyonix, OMAP3, IOMD


Version 5.35, 4.79.2.165. Tagged as 'Kernel-5_35-4_79_2_165'
@
text
@d1059 1
a1059 1
        =       FileLangCMOS,   fsnumber_SCSIFS ; SCSIFS for OMAP3, etc.
d1061 1
a1061 5
    [ M_ARM11ZF
        =       FileLangCMOS,   fsnumber_SDFS   ; SDFS for Pi, etc.
    |
        =       FileLangCMOS,   fsnumber_adfs   ; ADFS
    ]
a1555 1
        DebugTX "InitDynamicAreas"
a1702 1
        DebugTX "InitVectors"
a1766 1
        DebugTX "InitIRQ1"
a1816 1
        DebugTX "IMB_Full"
@


4.16.2.39
log
@Add *CONFIGURE [No]Num for control over the num lock state
STB default = off, desktop default = on.
Collapsed single use of 'ErrorsInR0' switch.

Version 5.35, 4.79.2.167. Tagged as 'Kernel-5_35-4_79_2_167'
@
text
@d1037 1
a1037 1
        =       StartCMOS,              (1:SHL:7):OR:(2:SHL:3)                  ; NONUM, NOCAPS
d1084 4
a1087 3
        =       StartCMOS,     (4:SHL:0) :OR: (2:SHL:3) :OR: (1:SHL:6) :OR: (0:SHL:7)
                              ; ^              ^              ^              ^
                              ; ADFS DR.4      NOCAPS         NODIR (moot)   NUM
@


4.16.2.40
log
@Initialise IIC earlier in the startup sequence. Add ID for Pandora audio HAL device
Detail:
  s/HAL, s/NewReset - Moved IIC initialisation to just after timer initialisation, and crucially, before keyboard scan initialisation. This makes things a lot easier for the HAL if it wants to use IIC during the keyboard scan (previously IIC would be enabled inbetween HAL_KbdScanSetup and the first call to HAL_KbdScan)
  hdr/HALDevice - Added a device ID for the Pandora audio controller
Admin:
  Tested on Pandora


Version 5.35, 4.79.2.168. Tagged as 'Kernel-5_35-4_79_2_168'
@
text
@d560 2
@


4.16.2.41
log
@Default CMOS changes for Cortex- and Broadcom-based builds:

- LMTransport IP (was NetBEUI)
- FreewayAutoAddress now "off"
- WimpIconiseButton now "on"
- CDROMDrives now 0 for RPi (was 1)

Version 5.35, 4.79.2.169. Tagged as 'Kernel-5_35-4_79_2_169'
@
text
@d624 1
a624 1

d1156 1
a1156 4
        =       CDROMFSCMOS,    &C0                     ; drives = 0, buffer size = 256K
        =       NetworkFlags,   LanManFStransport       ; LMTransport is NetBIOS over IP
        =       WimpDragMoveLimitCMOS, (1:SHL:2)        ; WimpIconiseButton
        =       SparrowMarker,  FreewayNoAutoAddress    ; Stop Freeway assigning addresses to interfaces
d2066 1
a2066 1

d2461 1
a2461 1

@


4.16.2.42
log
@Some tweaks ahead of an RPi code freeze.

Default CMOS tweaks now apply for the RPi hardware. Was missed in
the previous commit.

You can now build the Kernel without the ROM debug output stuff
that's enabled for odd-numbered builds, by passing FREEZE_DEV_REL=TRUE
into the makefile. For example, in the Components file, you'd add:

  -options FREEZE_DEV_REL=TRUE

onto the Kernel line.

Version 5.35, 4.79.2.171. Tagged as 'Kernel-5_35-4_79_2_171'
@
text
@d1155 1
a1155 1
   [ M_CortexA8 :LOR: M_CortexA9 :LOR: M_ARM11ZF
@


4.16.2.43
log
@Use the right setting for WimpIconiseButton
Detail:
  s/NewReset - WimpIconiseButton is bit 7 of WimpDragMoveLimitCMOS, not bit 2
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.172. Tagged as 'Kernel-5_35-4_79_2_172'
@
text
@d1158 1
a1158 1
        =       WimpDragMoveLimitCMOS, (1:SHL:7)        ; WimpIconiseButton
@


4.16.2.44
log
@Add OS_NVMemory 6
Permits applications to query what value would be used in the event of a CMOS reset for a given configure value. Notably, the configure plugins will use this in favour of 'ResetCMOS'.
hdr/Options: retire the 'Select16BitSound' switch, add comment for ChecksumCMOS switch
hdr/KernelWS: DuffEntry and Nowhere moved here
Kernel.s: Unused OSMD removed, retire single use of SPIRQ in favour of r13_irq
Middle.s: Retire SPIRQ
NewReset.s: Trim out 300+ lines of CMOS reset defaults, call OS_NVMemory 6 instead
PMF/i2cutils.s: CMOS reset default code and table moved here with refactoring
Note, the previous code preserved YearCMOS during the zeroing, only to unconditionally write it later - so have removed it from the zeroing step.
Note, the locations 80-111 are now considered as system CMOS in the allocations hence are now wiped too (previously they got skipped as user CMOS during R-power-on).

Tested on OMAP3 ROM with delete-power-on and R-power-on variants, and a simple BASIC program to read locations 0-255 via OS_NVMemory.

Version 5.35, 4.79.2.180. Tagged as 'Kernel-5_35-4_79_2_180'
@
text
@d17 15
a31 2
; Reset types
SoftReset       * 0
d711 1
d742 1
d812 4
d817 7
a823 1
; Wipe it, then squirt in the MOS's table of default values
d832 1
a837 1
    ]
d839 3
d843 64
a906 1
        ADD     sp, sp, #4              ; junk CannotReset flag from stack
d908 1
a908 23
        MOV     R4, #0
cmrlp
        CMP     R3, #-1
        BEQ     cmrall                  ; ignore system-only wipe checks
        CMP     R4, #UserCMOS
        MOVEQ   R4, #&50                ; skip User (30-45) & 3rd party (46-59) & high podules (60-79)
        BEQ     cmrall
        CMP     R4, #PoduleCMOS
        MOVEQ   R4, #&80                ; skip low podules (112-127)
        BEQ     cmrall
        TEQ     R4, #NewADFSCMOS        ; documented in 'Troubleshooting' in
        TEQNE   R4, #CountryCMOS        ; the RISC OS 3.7 user guide as preserved
        BEQ     cmrskip
cmrall
        MOV     R1, R4
        BL      NVMemory_ResetValue     ; get the reset value
        MOVS    R1, R2                  ; when -ve, leave alone
        MOVPL   R0, R4
        BLPL    Write                   ; CMOS(R0) := R1
cmrskip
        ADD     R4, R4, #1
        CMP     R4, #CMOSLimit
        BCC     cmrlp
d926 137
a1062 2
    [ ChecksumCMOS
        BL      MakeChecksum            ; create a valid checksum
d1064 103
a1166 1
        B       hard_reset              ; CMOS reset only checked on power on, so was hard
d1454 5
a1458 1
 ] ; SoftResets
d1689 6
d1696 1
@


4.16.2.45
log
@Teach the kernel about different memory attributes
Detail:
  Briefly, this set of changes:
  * Adjusts PhysRamTable so that it retains the flags passed in by the HAL from OS_AddRAM (by storing them in the lower 12 bits of the size field)
  * Sorts the non-VRAM entries of PhysRamTable by speed and DMA capability, to ensure optimal memory allocation during OS startup.
  * Adjust the initial memory allocation logic to allow the cursor/sound chunk and HAL noncacheable workspace to come from DMA capable memory
  * Extends OS_Memory 12 to accept a 'must be DMA capable' flag in bit 8 of R0. This is the same as available in ROL's OS.
  * Extends OS_DynamicArea 0 to allow the creation of dynamic areas that automatically allocate from DMA capable memory. In ROL's OS this was done by setting bit 12 of R4, but we're using bits 12-14 for specifying the cache policy, so instead bit 15 is used.
  * Fixes OS_ReadSysInfo 6 to return the correct DevicesEnd value now that the IRQ/device limit is computed at runtime
  File changes:
  * hdr/OSEntries - Add definitions of the various flags passed to OS_AddRAM by the HAL. Add a new flag, NoDMA, for memory which can't be used for DMA.
  * hdr/KernelWS - Tidy PhysRamTable definition a bit by removing all the DRAM bank definitions except the first - this makes it easier to search for code which is interacting with the table. Remove VRAMFlags, it's redundant now that the flags are kept in the table. Add DMA allocation info to InitWs.
  * s/AMBControl/memmap - Updated to mask out the flags from PhysRamTable when reading RAM block sizes.
  * s/ARM600 - Strip out a lot of IOMD specific pre-HAL code.
  * s/ChangeDyn - Updated to cope with the flags stored in PhysRamTable. Implement support for DMA-capable dynamic areas. Rewrite InitDynamicAreas to insert pages into the free pool in the right order so that the fastest memory will be taken from it first.
  * s/GetAll, s/Middle - Fix OS_ReadSysInfo 6 to return the correct HAL-specific DevicesEnd value
  * s/HAL - Significant rework of initial RAM allocation code to allow the kernel workspace to come from the fastest DMA incapable RAM, while also allowing allocation of DMA capable memory for HAL NCNB workspace & kernel cursor/sound chunks. ClearPhysRAM rewritten as part of this.
  * s/MemInfo - Updated to cope with the flags stored in PhysRamTable. Add support for the new OS_Memory 12 flag. Update OS_Memory 7 to not assume PhysRamTable entries are sorted in address order, and rip out the old pre-HAL IOMD implementation.
  * s/NewReset - Remove GetPagesFromFreePool option, assume TRUE (as this has been the case for the past 10+ years). Revise a few comments and strip dead code. Update to cope with PhysRamTable flags.
  * s/VMSAv6 - Remove a couple of unused definitions
  * s/vdu/vdudriver - Update to cope with PhysRamTable flags
Admin:
  Tested in Kinetic RiscPC ROM softload, Iyonix softload, & OMAP3


Version 5.35, 4.79.2.186. Tagged as 'Kernel-5_35-4_79_2_186'
@
text
@a99 5
; FudgeConfigureRMA - move pages from free pool to somewhere
; r0 = number of pages to attempt to move
; r1 = where to store number of bytes moved
; r3 = base address of where to put memory
; r11 = ap + CB
d101 10
d112 4
d123 9
d153 33
d190 2
a191 1
; MassageScreenSize - called from screen DA creation and ReadSysInfo
d196 4
a199 4
        LDR     lr, [lr, #VideoSizeFlags]
        TST     lr, #OSAddRAM_VRAMNotForGeneralUse
        MOVNE   r0, lr, LSR #12
        MOVNE   r0, r0, LSL #12
d1169 1
a1169 1
        LDR     r0, [r2, #VideoSizeFlags] ; offset from start of physical pages to static part
d1279 1
a1279 3
        LDR     r5, [r5, #VideoSizeFlags] ; maximum size
        MOV     r5, r5, LSR #12
        MOV     r5, r5, LSL #12
d1377 2
a1875 2
        LTORG

@


4.16.2.46
log
@Fix to RTC initial read when year hasn't rolled
There's an exit case from CheckYear which skips the actual clock read, so add an explicit call to RTCToRealTime for that case (cf. OS_ResyncTime).
Remove use of ARMv2 era MULTIPLY macro, just use MUL.
Tested on IOMD with a HAL RTC.

Version 5.35, 4.79.2.200. Tagged as 'Kernel-5_35-4_79_2_200'
@
text
@d1565 1
a1565 1
        MUL     R3, R0, R2              ; size spare wanted
a2093 1
        BL      RTCToRealTime
@


4.16.2.47
log
@Migrate RTC driver out of the kernel
The kernel will use RTC_Read and RTC_Write to access the hardware clock, while maintaining the software clock as before.
Makefile: header export is now in the RTC module's sources
KernelWS: remove RTCFitted flag
NewReset: sync the time after the module init
i2cutils: deleted clock chip code
osinit: move OS_ResyncTime into PMF/realtime
realtime: mostly packages up ordinals and calls the respective SWI

Tested on IOMD softload.

Version 5.35, 4.79.2.202. Tagged as 'Kernel-5_35-4_79_2_202'
@
text
@d1544 1
a1576 3
        ; Update RTC now all the modules are running
        SWI     XOS_ResyncTime

d1592 1
d2033 66
@


4.16.2.48
log
@Be more sensible with how much RAM we put into application space on boot
Detail:
  s/NewReset - During ROM init, keep application space mostly empty instead of attempting to move all RAM into it. This prevents the page order from being reversed, ensuring that in systems with two or more memory speeds the ROM modules get to use the fast RAM instead of the slow RAM (see free pool initialisation logic in InitDynamicAreas)
  After ROM module init, rebalance memory between the free pool and application space so that they each get 50%. This will provide plenty of memory for the boot sequence and any single-tasking stuff (e.g. booting into BASIC), without starving the free pool of memory and breaking any background processes like USB.
Admin:
  Tested on BB-xM
  Fixes issue where USB devices would fail to initialise properly on some systems due to the boot sequence temporarily locking application space while the free pool is empty


Version 5.35, 4.79.2.225. Tagged as 'Kernel-5_35-4_79_2_225'
@
text
@d1327 1
a1327 1
        LDR     R0, =(1024*1024):SHR:12 ; 1MB of RAM in aplspace should be plenty for ROM init. Theoretically we don't need any at all, but having some there should make it easier to debug any ROM init failures.
d1331 1
a1331 1
        BL      FudgeConfigureRMA       ; put some memory in aplspace
a1729 18
; Now that ROM modules have mostly finished allocating memory, move a large
; chunk of the free memory from the free pool into application space so that
; the boot sequence and configured language have something to play around with
; (particularly if booting into BASIC!)
; However be careful not to move everything, otherwise anything which locks
; application space during boot could cripple important background processes
; like USB
        Push    "r1"
        LDR     r0, =ZeroPage
        LDR     r1, [r0, #AplWorkSize]
        LDR     r0, [r0, #FreePoolDANode+DANode_Size]
        SUB     r1, r1, #32*1024
        SUB     r1, r1, r0
        MOV     r1, r1, ASR #1          ; 50% each sounds fair
        MOV     r0, #ChangeDyn_FreePool
        SWI     XOS_ChangeDynamicArea
        Pull    "r1"

@


4.16.2.49
log
@  Added hdr.options line to set up max RAMFS size.
Detail:
  s.NewReset line 1304 amended to use this variable. It was
  hard codede to 128MB as a compromise between address space reservation and size.
Admin:
  Tested OK to expand to 511MB in task manager. At 512MB the taskmanager window fails.
JB

Version 5.35, 4.79.2.234. Tagged as 'Kernel-5_35-4_79_2_234'
@
text
@d1301 1
a1301 1
        MOV     r5, #MaxRAMFS_Size*1024*1024      ; A trade off between nice big disc and complete waste of address space
@


4.16.2.50
log
@Add ARMops for PL310 L2 cache controller
Detail:
  Unlike on the Cortex-A8 or Cortex-A15, the L2 cache that's used with the Cortex-A9 isn't hooked up to the standard ARMv7 CP15 cache maintenance ops. Instead, memory-mapped registers must be used to program and maintain the cache.
  Since the PL310 can't be detected automatically, this change adds support for a 'cache controller' HAL device which the HAL can use to advertise the presence of any external caches. If a cache device is registered during HAL_InitDevices the kernel will then check it against a list of known cache types and replace the appropriate ARMop routines with the alternatives for that controller.
  File changes:
  - hdr/PL310 - New header containing PL310 register listing
  - Makefile - Add export for PL310 header. Reorder exports to be alphabetical
  - hdr/HALDevice - Add cache controller device type, PL310 device
  - hdr/KernelWS - Allocate some workspace for storing a pointer to the current cache HAL device
  - s/ARMops - Add code for searching for known cache types, and implementation of PL310-specific ARMops
  - s/GetAll - Get Hdr:PL310
  - s/NewReset - Look for a cache controller after calling HAL_InitDevices
Admin:
  Tested on Pandaboard
  Fixes various assorted instability issues


Version 5.35, 4.79.2.252. Tagged as 'Kernel-5_35-4_79_2_252'
@
text
@a1543 1
        BL      LookForHALCacheController
@


4.16.2.51
log
@Escape some dollars
Detail:
  s/NewReset, s/Super1 - Escape some dollars contained in strings to avoid warnings from objasm
Admin:
  Resulting binary unchanged


Version 5.35, 4.79.2.253. Tagged as 'Kernel-5_35-4_79_2_253'
@
text
@d2009 1
a2009 1
str_booterror   DCB     "Boot$$Error",0
@


4.16.2.52
log
@Add initial support for "physical memory pools"
Detail:
  This set of changes adds support for "physical memory pools" (aka PMPs), a new type of dynamic area which allow physical pages to be claimed/allocated without mapping them in to the logical address space. PMPs have full control over which physical pages they use (similar to DAs which request specific physical pages), and also have full control over the logical mapping of their pages (which pages go where, and per-page access/cacheability control).
  Currently the OS makes use of two PMPs: one for the free pool (which now has a logical size of zero - freeing up gigabytes of logical space), and one for the RAM disc (logical size of 1MB, allowing for a physical size limited only by the amount of free memory)
  Implementing these changes has required a number of other changes to be made:
  * The CAM has been expanded from 8 bytes per entry to 16 bytes per entry, in order to allow each RAM page to store information about its PMP association
  * The system heap has been expanded to 32MB in size (from just under 4MB), in order to allow it to be used to store PMP page lists (1 word needed per page, but PMP pages may not always have physical pages assigned to them - so to allow multiple large PMPs to exist we need more than just 1 word per RAM page)
  * The &FA000000-&FBFFFFFF area of fixed kernel workspace has been shuffled around to accomodate the larger CAM, and the system heap is now located just above the RMA.
  * SoftResets code stripped out (unlikely we'll ever want to fix and re-enable it)
  * A couple of FastCDA options are now permanently on
  * Internal page flags shuffled around a bit. PageFlags_Unavailable now publicly exposed so that PMP clients can lock/unlock pages at will.
  * When OS_ChangeDynamicArea is asked to grow or shrink the free pool, it now implicitly converts it into a shrink or grow of application space (which is what would happen anyway). This simplifies the implementation; during a grow, pages (or replacement pages) are always sourced from the free pool, and during a shrink pages are always sent to the free pool.
  File changes:
  - hdr/KernelWS - Extend DANode structure. Describe CAM format. Adjust kernel workspace.
  - hdr/OSRSI6, s/Middle - Add new item to expose the CAM format
  - hdr/Options - Remove SoftResets switch. Add some PMP switches.
  - s/ARM600, s/VMSAv6 - Updated for new CAM format. Note that although the CAM stores PMP information, BangCamUpdate currently doesn't deal with updating that data - it's the caller's responsibility to do so where appropriate.
  - s/ChangeDyn - Lots of changes to implement PMP support, and to cope with the new CAM format.
  - s/HAL - Updated to cope with new CAM format, and lack of logical mapping of free pool.
  - s/MemInfo - Updated to cope with new CAM format. OS_Memory 0 updated to cope with converting PPN to PA for pages which are mapped out. OS_Memory 24 updated to decode the access permissions on a per-page basis for PMPs, and fixed its HWM usage for sparse DAs.
  - s/NewReset - Soft reset code and unused AddCamEntries function removed. Updated to cope with new CAM format, PMP free pool, PMP RAMFS
  - s/AMBControl/allocate - Update comment (RMA hasn't been used for AMBControl nodes for a long time)
  - s/AMBControl/growp, s/AMBControl/memmap, s/AMBControl/shrinkp - Update for new CAM format + PMP free pool
  - s/vdu/vdudriver - Strip out soft reset code.
Admin:
  Tested on Pandaboard
  This is just a first iteration of the PMP feature, with any luck future changes will improve functionality. This means APIs are subject to change as well.


Version 5.35, 4.79.2.284. Tagged as 'Kernel-5_35-4_79_2_284'
@
text
@d54 23
d115 4
a118 2
        LDR     r7, [r4, #DANode_PMP]
        LDR     r8, [r4, #DANode_PMPSize]
d120 8
a127 7
        CMP     r8, #0                          ; if no free memory left
        BEQ     %FT20                           ; then tidy up
        SUB     r8, r8, #1                      ; move free pool pointer backwards
        MOV     lr, #-1
        LDR     r2, [r7, r8, LSL #2]
        STR     lr, [r7, r8, LSL #2]
        BL      Call_CAM_Mapping
d129 1
d134 1
a134 1
        STR     r8, [r4, #DANode_PMPSize]
d820 277
d1110 88
d1288 2
d1298 2
a1299 6
      [ PMPRAMFS
        MOV     r5, #PMPRAMFS_Size*4096
        ORR     r4, r4, #DynAreaFlags_PMP
        MOV     r2, #0
        ORR     r4, r4, #DynAreaFlags_NeedsSpecificPages
        MOV     r9, #0
a1300 2
        MOV     r0, #RAMDiscCMOS        ; find out how much RAM disc configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size
a1307 8
      [ PMPRAMFS
        ; Currently, physical memory pools must be created with 0 size, then resized afterwards
        MOV     r0, #RAMDiscCMOS        ; find out how much RAM disc configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size
        MOVS    r1, r2
        MOV     r0, #ChangeDyn_RamFS
        SWINE   XOS_ChangeDynamicArea
      ]
d1716 6
d1741 1
a1741 4
        LDR     r0, [r0, #FreePoolDANode+DANode_PMPSize]
        CMP     r0, #DynArea_PMP_BigPageCount
        MOVLO   r0, r0, LSL #12
        LDRHS   r0, =DynArea_PMP_BigByteCount
@


4.16.2.35.2.1
log
@  Merge of Raspberry Pi support code against latest kernel
Detail:
  This is a new branch from the current tip of the HAL branch, incorporating
  the changes received from Adrian Lees. The same caveats apply - this is a
  work in progress and will not work on any other platform at present.
Admin:
  Builds, but not tested.

Version 5.35, 4.79.2.147.2.1. Tagged as 'Kernel-5_35-4_79_2_147_2_1'
@
text
@a1567 1
        DebugTX "InitDynamicAreas"
a1714 1
        DebugTX "InitVectors"
a1778 1
        DebugTX "InitIRQ1"
a1828 1
        DebugTX "IMB_Full"
d1917 1
a1917 2
        ! 0, "FIXME: we're going to need this back at some point"
;        BL      LookForHALRTC ; Check if an RTC was just added. This is currently the only place where HAL RTCs are checked for; if we wanted to check anywhere else (e.g. after ROM module initialisation) then we'd have to listen for Service_Hardware so we can cope with device removal
@


4.16.2.35.2.2
log
@Change default filesystem to SDFS in Raspberry Pi/ARM11 builds
Detail:
  s/NewReset - Change default filesystem to SDFS for ARM11 builds, as that's somewhat more appropriate than ADFS when on the Pi. Also now using filesystem numbers from Hdr:FSNumbers instead of magic numbers.
Admin:
  Builds, but untested


Version 5.35, 4.79.2.147.2.14. Tagged as 'Kernel-5_35-4_79_2_147_2_14'
@
text
@d1071 1
a1071 1
        =       FileLangCMOS,   fsnumber_SCSIFS ; SCSIFS for OMAP3, etc.
d1073 1
a1073 5
    [ M_ARM11ZF
        =       FileLangCMOS,   fsnumber_SDFS   ; SDFS for Pi, etc.
    |
        =       FileLangCMOS,   fsnumber_ADFS   ; ADFS
    ]
@


4.16.2.35.2.3
log
@Clean up remaining kernel hacks
Detail:
  Docs/RPiNotes - Deleted, contents no longer relevant
  s/HAL, s/Kernel, s/vdu/vduswis, s/pmf/key - Cleaned up debug code
  s/NewIRQs - No need to piggy back on timer 0 IRQ to generate a fake VSync; PushModeInfo already claims/releases TickerV as appropriate if video driver doesn't provide a VSync IRQ.
  s/NewReset - Re-enable LookForHALRTC call, the stack imbalance bug was fixed before the Pi changes were merged in
  s/vdu/vducursoft - Streamline PostWrchCursor a bit by only preserving R14 around RestorePointer if the software pointer is in use
  s/vdu/vdudriver - Amend ModeChangeSub improvements to ensure old external framestore handling logic is used if driver doesn't support framestore growth/realloc
Admin:
  Tested on Raspberry Pi with high processor vectors
  Kernel now looks to be in a good state for merging back into HAL branch
  Note - Software mouse pointer support in vducursoft only checks HALVideoFeatures, so doesn't take into account the capabilities of any GraphicsV driver that may be in use.


Version 5.35, 4.79.2.147.2.20. Tagged as 'Kernel-5_35-4_79_2_147_2_20'
@
text
@d1925 2
a1926 1
        BL      LookForHALRTC ; Check if an RTC was just added. This is currently the only place where HAL RTCs are checked for; if we wanted to check anywhere else (e.g. after ROM module initialisation) then we'd have to listen for Service_Hardware so we can cope with device removal
@


4.16.2.35.2.4
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d731 14
a768 1

d819 1
a819 1
        LDR     R7, [R0, #R_Down_Flag]  ; Picks up R/T/Del/Copy flags all in one
a821 3
        LDRNE   R3, =ZeroPage
        MOVNE   R14, #1
        STRNEB  R14, [R3, #MentionCMOSReset]
d838 1
d841 1
d2020 1
a2020 1
      [ DoInitialiseMode :LOR: :LNOT: Embedded_UI
d2022 1
a2022 25
      ]
    [ :LNOT: Embedded_UI
        LDR     R0, =ZeroPage
        LDRB    R14, [R0, #MentionCMOSReset]
        TEQ     R14, #0
        BEQ     %FT12
      [ International
        SWI     XOS_WriteI+10
        BVS     %FT09
        BL      WriteS_Translated
        =       "CmosRst:CMOS RAM reset, press ESCAPE to continue",0
        ALIGN
09
      |
        SWI     XOS_WriteS
        =       10,"CMOS RAM reset, press ESCAPE to continue",0
        ALIGN
      ]
10
        SWI     XOS_ReadEscapeState
        BCC     %BT10
        MOV     R0, #124
        SWI     XOS_Byte                ; Clear the condition
        SWI     XOS_WriteI+12           ; Clear the screen
12
d2027 4
d2035 1
a2035 3

        LDR     R0, =ZeroPage
        LDR     R0, [R0, #RAMLIMIT]
d2046 2
d2049 5
d2055 2
a2056 3
    |
        ! 0,    "Banner & printing of processor type disabled"
    ]
d2058 1
a2058 1
        MOV     r0, #0                  ; Set DomainId to 0 every reset
d2169 2
a2170 3
        BVS     %FT65
        BL      WriteS_Translated
        =       "MonType:Monitor type reconfigured",10,13,10,0
a2171 1
65
d2174 1
a2174 1
        =       10,"Monitor type reconfigured",10,13,10,0
a2201 6
      [ International
MessageFileName DCB     "Resources:$.Resources.Kernel.Messages",0
        ALIGN
      ]

 [ StrongARM :LAND: :LNOT: HAL
d2213 6
d2358 1
a2358 2
        BVS     %FT81
        BL      WriteS_Translated
a2360 1
81
d2429 1
a2429 1
        MOV     R8, #OSHW_DeviceEnumerate
@


4.16.2.28.2.1
log
@Add VMSAv6 MMU support, fixes to allow booting on beagleboard
Detail:
  s/ARM600 - fix to SyncCodeAreasRange to correctly read cache line length for WB_CR7_Lx caches
  s/ARMops - Cortex cache handling fixes. Enable L2 cache for Cortex.
  s/ChangeDyn - VMSAv6 support in AllocateBackingLevel2
  s/HAL - Improve RISCOS_InitARM to set/clear correct CP15 flags for ARMv6/v7. VMSAv6 support in code to generate initial page tables.
  s/NewReset - Extra DebugTX calls during OS startup. Disable pre-HAL Processor_Type for HAL builds.
  s/VMSAv6 - Main VMSAv6 MMU code - stripped down version of s/ARM600 with support for basic VMSAv6 features.
  hdr/Options - Use VMSAv6 MMU code, not ARM600. Disable ARM6support since current VMSAv6 code will conflict with it.
Admin:
  Tested basic OS functionality under qemu-omap3 and revision B6 beagleboard.


Version 5.35, 4.79.2.98.2.3. Tagged as 'Kernel-5_35-4_79_2_98_2_3'
@
text
@a684 1
        DebugTX "Keyboard scan complete"
a685 1
        DebugTX "FIQ enabled"
a690 1
        DebugTX "IRQ enabled"
a1834 1
        DebugTX "VduInit"
a1835 1
        DebugTX "ExecuteInit"
a1836 1
        DebugTX "KeyInit"
a1837 1
        DebugTX "MouseInit"
a1838 1
        DebugTX "OscliInit"
a1840 1
        DebugTX "Enabling IRQs"
a1841 1
        DebugTX "IRQs on"
a1851 1
        DebugTX "Debug terminal on"
a1867 1
        DebugTX "HAL_InitDevices"
a1875 1
        DebugTX "InitVariables"
a1876 1
        DebugTX "AMBControl_Init"
a1877 1
        DebugTX "ModuleInit"
d2135 1
a2135 1
 [ StrongARM :LAND: :LNOT: HAL
@


4.16.2.28.2.2
log
@Add HAL RTC support to Cortex branch of kernel, clean up RTCSupport code
Detail:
  HAL kernels (on the Cortex branch at least) now support HALDevice-based RTCs. If the kernels own RTC code is disabled or fails to detect an RTC, then after HAL_InitDevices is called the HALDevice list will be scanned for any HAL-resident RTC devices.
  Additionally, the RTCSupport flag (in Hdr:Machine.Machine), which was previously TRUE for all HAL kernels, can now be set to FALSE in HAL kernels to disable the kernels own IIC RTC code. This allows the unwanted legacy RTC code to be disabled for machines which are known to use HAL RTCs instead.
  hdr/RTCDevice - new header describing data structures used for HAL RTC device
  hdr/HALDevice - added RTCDevice device type, IIC serial bus type
  hdr/KernelWS - upgraded RTCFitted from a 1 byte field to 4 byte. It now stores either a null value (for no RTC), a value <2048 for an IIC RTC address, or a value >= 2048 for a RTCDevice ptr
  Makefile - added header export of hdr/RTCDevice
  s/GetAll - include hdr/RTCDevice
  s/NewReset - initialise HAL RTC after HAL_InitDevices if required
  s/PMF/i2cutils, s/PMF/osinit, s/PMF/osword - modifications to allow use of HAL RTC (and disallow use of builtin IIC RTC)
Admin:
  Tested on rev C2 beagleboard


Version 5.35, 4.79.2.98.2.11. Tagged as 'Kernel-5_35-4_79_2_98_2_11'
@
text
@a1884 1
        BL      LookForHALRTC ; Check if an RTC was just added. This is currently the only place where HAL RTCs are checked for; if we wanted to check anywhere else (e.g. after ROM module initialisation) then we'd have to listen for Service_Hardware so we can cope with device removal
a2351 36
 [ HAL
LookForHALRTC
	Push "R0-R2,R8,R14"
	MOV	R0, #0
	LDR	R0, [R0, #RTCFitted]
	CMP	R0, #0
	Pull "R0-R2,R8,PC",NE ; We already have an RTC
	LDR	R0, =(0:SHL:16)+HALDeviceType_SysPeri+HALDeviceSysPeri_RTC
	MOV	R1, #0
	MOV	R8, #4
01
	SWI	XOS_Hardware
	Pull "R0-R2,R8,PC",VS
	CMP	R1, #-1
	Pull "R0-R2,R8,PC",EQ
	LDR	R14, [R2, #HALDevice_Location]
	; Currently, we only support devices located on IIC bus 0
	CMP	R14, #HALDeviceBus_Ser+HALDeviceSerBus_IIC
	BNE	%BT01
	; Try activating
	Push "R0-R3,R12"
	MOV	R0, R2
	MOV	LR, PC
	LDR	PC, [R2, #HALDevice_Activate]
	CMP	R0, #1
	Pull "R0-R3,R12"
	BNE	%BT01
	DebugTX "HAL RTC detected!"
	MOV	R0, #0
	STR	R2, [R0, #RTCFitted]
	; Read the time from the RTC into RealTime, and fixup YearCMOS if needed
	BL	CheckYear
	DebugTX "Leaving LookForHALRTC"
	Pull "R0-R2,R8,PC"
 ]
 
@


4.16.2.28.2.3
log
@Fix HAL RTC initialisation in Cortex kernel
Detail:
  LookForHALRTC wasn't initialising R12 to point to the OS Byte workspace before calling CheckYear, and instead relying on the previous value. This resulted in the RTC initialisation breaking once HAL_InitDevices started doing things to corrupt R12.
Admin:
  Tested on rev C2 beagleboard


Version 5.35, 4.79.2.98.2.18. Tagged as 'Kernel-5_35-4_79_2_98_2_18'
@
text
@d2355 8
a2362 8
        Push "R0-R2,R8,R12,R14"
        MOV     R0, #0
        LDR     R0, [R0, #RTCFitted]
        CMP     R0, #0
        Pull "R0-R2,R8,PC",NE ; We already have an RTC
        LDR     R0, =(0:SHL:16)+HALDeviceType_SysPeri+HALDeviceSysPeri_RTC
        MOV     R1, #0
        MOV     R8, #4
d2364 23
a2386 24
        SWI     XOS_Hardware
        Pull "R0-R2,R8,PC",VS
        CMP     R1, #-1
        Pull "R0-R2,R8,PC",EQ
        LDR     R14, [R2, #HALDevice_Location]
        ; Currently, we only support devices located on IIC bus 0
        CMP     R14, #HALDeviceBus_Ser+HALDeviceSerBus_IIC
        BNE     %BT01
        ; Try activating
        Push "R0-R3"
        MOV     R0, R2
        MOV     LR, PC
        LDR     PC, [R2, #HALDevice_Activate]
        CMP     R0, #1
        Pull "R0-R3"
        BNE     %BT01
        DebugTX "HAL RTC detected!"
        MOV     R0, #0
        STR     R2, [R0, #RTCFitted]
        ; Read the time from the RTC into RealTime, and fixup YearCMOS if needed
        BYTEWS  WsPtr
        BL      CheckYear
        DebugTX "Leaving LookForHALRTC"
        Pull "R0-R2,R8,R12,PC"
@


4.16.2.28.2.4
log
@Change default filing system to SCSIFS for CortexA8 machines
Detail:
  s/NewReset - boot filing system now defaults to SCSIFS for the CortexA8 machine type. BeagleBoards, etc. should now be able to run their boot sequence if one is placed on a USB mass storage device.
Admin:
  Tested on rev C2 beagleboard.


Version 5.35, 4.79.2.98.2.26. Tagged as 'Kernel-5_35-4_79_2_98_2_26'
@
text
@d1064 1
a1064 5
   [ M_CortexA8
        =       FileLangCMOS,   26      ; SCSIFS for OMAP3, etc.
   |
        =       FileLangCMOS,   8       ; ADFS
   ]
@


4.16.2.28.2.5
log
@Update Cortex kernel to use correct instruction/memory barriers and to perform branch target predictor maintenance. Plus tweak default CMOS settings.
Detail:
  hdr/Copro15ops - Added myISB, myDSB, myDMB macros to provide barrier functionality on ARMv6+
  s/ARMops, s/HAL, s/VMSAv6, s/AMBControl/memmap - Correct barrier operations are now performed on ARMv6+ following CP15 writes. Branch predictors are now also maintained properly.
  s/NewReset - Change default CMOS settings so number of CDFS drives is 0 in Cortex builds. Fixes rogue CDFS icon on iconbar.
Admin:
  Tested on rev C2 beagleboard


Version 5.35, 4.79.2.98.2.27. Tagged as 'Kernel-5_35-4_79_2_98_2_27'
@
text
@a1159 3
   [ M_CortexA8
        =       CDROMFSCMOS,    &C0     ; drives = 0, buffer size = 256K
   |
a1160 1
   ]
@


4.16.2.28.2.6
log
@Fix some issues preventing the Cortex kernel from being used on non-Cortex machines
Detail:
  hdr/Options - ARM6support and GetKernelMEMC values are now derived from the value of MEMM_Type
  s/ARMops, s/HAL - Code to detect and handle ARMv7 CPUs is now only enabled when using VMSAv6 MMU model. Saves us from having to deal with lack of myIMB, myDSB, etc. implementations on pre-ARMv6.
  s/HAL - Removed some debug code
  s/NewReset - Fix bug spotted by Tom Walker where R12 wasn't being restored by LookForHALRTC if a non-HAL RTC had already been found
  s/AMBControl/memmap - correct the assert clause that was checking that &FFE are the correct L2PT protection bits for non-VMSAv6 machines
Admin:
  Tested this kernel on a rev C2 beagleboard & Iyonix softload. Also compiled it into an IOMD ROM, but didn't try running it.


Version 5.35, 4.79.2.98.2.32. Tagged as 'Kernel-5_35-4_79_2_98_2_32'
@
text
@d2367 1
a2367 1
        Pull "R0-R2,R8,R12,PC",NE ; We already have an RTC
@


4.16.2.28.2.7
log
@Update OS_IICOp to support multiple IIC buses
Detail:
  OS_IICOp (and in turn, RISCOS_IICOpV) now treat the top byte of R1 as containing the IIC bus number, allowing multiple buses to be used.
  hdr/KernelWS - Changed workspace a bit so that the kernel can support up to IICBus_Count buses (currently 3), each with its own IICBus_* block.
  s/HAL - Update Reset_IRQ_Handler to cope with interrupts from all IIC buses instead of just the first. Fix/update RISCOS_IICOpV description.
  s/NewIRQs - Update InitialiseIRQ1Vtable to set up interrupt handlers for all IRQ-supporting IIC buses
  s/NewReset - Get rid of the IICAbort call that was just before IICInit. IICInit now calls IICAbort itself.
  s/PMF/IIC - Bulk of the changes. Code now uses the IICBus_ structures instead of the IICStatus and IICType variables. Re-entrancy code has been updated to take into account the possiblity of multiple buses; when OS_IICOp calls are nested, the IIC transfers will be added to bus-specific queues instead of all going in the same queue. However only one queue will be processed at a time.
  s/ChangeDyn - Workspace shuffling means a couple of MOV's needed to be swapped with LDR's when getting immediate constants
Admin:
  Tested with OMAP & IOMD ROM builds.
  Both high & low-level bus types seem to work OK, along with re-entrancy, both on the same bus and on a different bus.


Version 5.35, 4.79.2.98.2.33. Tagged as 'Kernel-5_35-4_79_2_98_2_33'
@
text
@d563 4
@


4.16.2.28.2.8
log
@Update the method the Cortex kernel uses to determine the UtilityModule & ROM dates
Detail:
  Three main changes:
  * On odd-numbered (i.e. development) versions of the module, the UtilityModule will now take its date from the VersionNum file instead of using a hard-coded date.
  * All build versions now look for the new "extended ROM footer" (as created by romlinker 0.04+) at the end of the ROM image and use it to determine the ROM build date for return by OS_ReadSysInfo 9,2. Failing to find the build date in the footer will cause OS_ReadSysInfo 9,2 to return 0.
  * On odd-numbered versions, OS_Byte 0 will now use the ROM build date (as found in the extended footer) to generate the error block that's returned to the user. This seems OK as the PRM describes OS_Byte 0 as returning the "creation date of the operation system". Plus it's a convenient way of getting the ROM build date into the Switcher, since the switcher uses OS_Byte 0. If the extended footer can't be found (or if the string hasn't been initialised yet, e.g. before Service_PostInit) the code falls back to a hard-coded string containing the date from the VersionNum file.
  File changes:
  Makefile - Updated to not create the obsolete Time+Date file (previously used for the ROM build date)
  Version - Use date from VersionNum file for development builds
  hdr/Options - New UseNewFX0Error variable/option to make it easy to check which OS_Byte 0 variant should be enabled
  hdr/KernelWS - Added new string buffers & extended ROM footer pointer to workspace
  s/Middle - Updated OS_ReadSysInfo 9 code, and added utility functions for searching the extended ROM footer for certain tags
  s/NewReset - Added a couple of calls to initialise the new string buffers just prior to Service_PostInit. This is required since OS_Byte/OS_ReadSysInfo shouldn't enable interrupts, but date conversion relies on the Territory module, which may enable interrupts.
  s/PMF/osbyte - Updated OS_Byte 0 code
Admin:
  Tested in OMAP ROM, with and without the extended footer present.


Version 5.35, 4.79.2.98.2.41. Tagged as 'Kernel-5_35-4_79_2_98_2_41'
@
text
@a1921 16
        ; OS_ReadSysInfo 9,2 now relies on the Territory module, which may
        ; enable IRQs. But the PRMs say OS_ReadSysInfo shouldn't alter the IRQ
        ; state. So call it once here just to initialise the string which it
        ; uses the Territory module to generate.
        ; This won't account for any modules using it during ModuleInit, but
        ; that should be pretty rare (or at least rare from within IRQ-sensitive
        ; code)
        MOV     R0, #9
        MOV     R1, #2
        SWI     XOS_ReadSysInfo

  [ UseNewFX0Error
        ; Also, *FX 0
        BL      InitNewFX0Error
  ]

@


4.16.2.28.2.9
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d107 1
a107 1
        LDR     r1, =ZeroPage
d138 1
a138 1
        LDR     R10, =ZeroPage
d154 1
a154 1
        LDR     r4, =ZeroPage+FreePoolDANode
d176 1
a176 2
        LDR     R7, =ZeroPage
        LDR     R8, [R7, #RAMLIMIT]
d182 1
a183 1
        MOV     r7, #0
d216 1
a216 1
        LDR     lr, =ZeroPage
d219 1
a219 1
        LDRNE   lr, =ZeroPage
a224 3
      [ ZeroPage <> 0
        LDR     r0, =ZeroPage
      ]
d532 1
a532 1
        LDR     R1, =ZeroPage+ProcVec_Start
d544 1
a544 2
        LDR     R0, =ZeroPage+4
        LDR     R3, =ZeroPage+EndMOSROMVecs-MOSROMVecs
d549 1
a549 1
        TEQ     R0, R3
a569 3
      [ ZeroPage <> 0
        LDREQ   R0, =ZeroPage
      ]
d576 1
a576 1
        LDR     R0, =ZeroPage+IRQ1V
a585 1
        LDR     R3, =ZeroPage+(EndData-StartData+IRQ1V)
d589 1
a589 1
        TEQ     R0, R3
d593 1
a593 1
        LDR     r0, =ZeroPage
d596 2
a597 2
        MOV     r3, #0                  ; initialise abort list
        STR     r3, [r0, #AbortIndirection]
d641 1
a641 1
        LDR     r0, =ZeroPage
d647 1
a647 1
        LDR     R0, =ZeroPage
d661 1
a661 1
        LDR     r4, =ZeroPage+InitIRQWs
d685 1
a685 1
        LDR     r1, =ZeroPage+InitIRQWs
d789 1
a789 1
        LDR     R0, =ZeroPage+HAL_StartFlags
d832 1
a832 1
        LDR     R0, =ZeroPage+InitIRQWs
d942 1
a942 1
        LDR     R0, =ZeroPage+InitIRQWs
d1198 1
a1198 1
        LDR     R5, =ZeroPage
d1226 1
a1226 1
        LDR     R4, =ZeroPage
d1243 1
a1243 1
        LDR     R0, =ZeroPage+InitKbdWs
d1268 1
a1268 2
        LDR     r7, =ZeroPage
        LDR     R2, [R7, #Page_Size]
d1272 1
d1309 1
a1309 1
        LDR     R1, =ZeroPage
d1311 1
a1311 2
        LDR     R2, [R1, #Page_Size]
        MOV     R7, #0
d1317 1
d1321 2
a1322 1
        LDR     R4, [R1, #CamEntriesPointer] ; no PPL
d1346 1
a1346 3
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
      ]
d1352 1
a1352 1
        LDR     R11, =ZeroPage+VecPtrTab
d1369 1
a1369 1
        LDR     R0, =ZeroPage
d1413 1
a1413 1
        LDR     R11, =ZeroPage+PIRQ_Chain
d1429 1
a1429 1
        LDR     R2, =ZeroPage+PIRQ_Chain
d1431 1
a1431 1
        LDR     R2, =ZeroPage=PFIQasIRQ_Chain
d1434 1
a1434 1
        LDREQ   r11, =ZeroPage+CallBack_Vector
d1442 1
a1442 1
        LDR     R0, =ZeroPage
a1443 1
        ASSERT  :LNOT: HAL
a1460 1
        LDR     R8, =ZeroPage
d1462 1
a1462 1
        STR     r2, [r8]                ; store to logical address zero
d1469 1
d1474 1
a1474 1
        LDR     r2, =ZeroPage
d1581 1
a1581 1
        LDR     r5, =ZeroPage
a1619 1
      [ ZeroPage = 0
a1620 4
      |
        LDR     r1, =ZeroPage
        STR     r0, [r1, #SpriteSize]   ; (fixes bug MED-00811)
      ]
d1688 1
a1688 1
        LDR     R1, =ZeroPage+AplWorkSize ; aplwork size
d1692 1
a1692 1
        LDR     R0, =ZeroPage
d1700 2
a1701 5
        LDR     R1, =ZeroPage+ModuleSWI_HashTab
        MOV     R2, #ModuleSHT_Entries
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
d1703 1
d1705 1
a1705 6
        STR     R0, [R1, R2, LSL #2]
        BGT     clearmswis

      [ ZeroPage <> 0
        LDR     R2, =ZeroPage
      ]
d1709 2
a1710 2
        STRB    R1, [R2, #ErrorSemaphore]               ; Don't translate errors.
        STR     R0, [R2, #KernelMessagesBlock]          ; No message file open.
d1712 1
a1712 1
        STR     R0, [R2, #CachedErrorBlocks]            ; No cached errors
d1717 1
a1717 1
        LDR     R0, =ZeroPage+HAL_StartFlags
d1731 1
a1731 1
        LDREQ   R0, =ZeroPage+OsbyteVars + :INDEX: LastBREAK
d1741 1
a1741 1
        LDR     R1, =ZeroPage+OsbyteVars + :INDEX: LastBREAK
d1744 1
a1744 1
        LDR     R1, =ZeroPage+InitIRQWs
d1757 1
a1757 1
        LDR     R3, =ZeroPage
d1759 2
a1760 2
        STR     R1, [R3, #PIRQ_Chain]
        STR     R1, [R3, #PFIQasIRQ_Chain]
d1764 3
a1766 3
        STRB    r0, [r3, #FIQclaim_interlock]
        STRB    r0, [r3, #CallBack_Flag]
        STR     r0, [r3, #CallBack_Vector]
d1775 1
a1775 1
        LDRVC   R0, =ZeroPage
d1800 1
a1800 1
        LDR     R2, =ZeroPage+InitIRQWs                 ; clear temp ws
d1809 2
d1813 1
a1813 1
        LDR     r0,=ZeroPage
d1825 2
a1826 3
        MOV     R1, #0
        STR     R1, [R0, #ReturnCode]
        STR     R1, [R0, #TickNodeChain]
d1829 2
a1830 1
        ADD     R0, R0, #&1C
d1838 1
a1838 1
        LDR     R1, =ZeroPage+DUMPER
d1860 1
a1860 1
        LDR     R2, =ZeroPage
a1885 1
      [ ZeroPage = 0
a1887 5
      |
        LDR     R1, =ZeroPage
        STR     R0, [R1, #DeviceCount]
        STR     R0, [R1, #DeviceTable]
      ]
d1908 1
a1908 1
        LDR     R0, =ZeroPage
d1961 2
a1962 2
     [ International                    ; Open the kernel messages file.
        LDR     r0, =ZeroPage+KernelMessagesBlock+4
a1966 1
      [ ZeroPage = 0
a1967 3
      |
        LDR     lr, =ZeroPage
        STRVC   r0, [lr, #KernelMessagesBlock]  ; Message file is now open.
a1968 1
     ]
d1972 1
a1972 1
        LDR     r0, =ZeroPage
a1974 1
        ASSERT  (ZeroPage :AND: 255) = 0
d1985 1
a1985 1
        LDR     R0, =ZeroPage
a2016 1
      [ ZeroPage = 0
d2018 1
a2018 5
      |
        LDR     r1, =ZeroPage
        STR     r0, [r1, #DomainId]     ; before calling anyone
      ]
      
d2051 1
a2051 1
        LDR     r1, =ZeroPage+HAL_StartFlags
d2069 1
a2069 1
        LDR     r3, =ZeroPage
d2211 1
a2211 1
        LDR     r14, =ZeroPage
d2259 1
a2259 1
        LDR     r3, =ZeroPage
d2274 1
a2274 1
        LDR     r0, =ZeroPage
d2376 1
a2376 1
        LDR     R0, =ZeroPage
d2401 1
a2401 1
        LDR     R0, =ZeroPage
@


4.16.2.28.2.10
log
@  Kernel updates to support Cortex-A9 CPUs
Detail:
  hdr.ARMops
    added Cortex_A9
  hdr.HALDevice
    added OMAP4 specific device IDs
  hdr.KernelWS
    changed definition of DefIRQ1Vspace for M_CortexA9
  s.ARMops
    added CortexA9 specific code for enabling L2 cache
    added CPUDesc Cortex_A9
  s.NewIRQs
    added CortexA9 specific definition of MaxInterrupts
  s.NewReset
    added M_CortexA9 options
    line 1444: corrected typo
    line 187: commented out unnecessary operation
Admin:
  Submission from Willi Theiß

Version 5.35, 4.79.2.98.2.50. Tagged as 'Kernel-5_35-4_79_2_98_2_50'
@
text
@d184 1
a184 1
;        MOV     r7, #0
d1069 1
a1069 1
   [ M_CortexA8 :LOR: M_CortexA9
d1165 1
a1165 1
   [ M_CortexA8 :LOR: M_CortexA9
d1441 1
a1441 1
        LDR     R2, =ZeroPage+PFIQasIRQ_Chain
d1472 1
a1472 1
        LDR     r8, =ZeroPage
@


4.16.2.28.2.11
log
@ARMv7 fixes
Detail:
  hdr/Copro15ops:
    - Fixed incorrect encodings of ISH/ISHST variants of DMB/DSB instructions
  s/ARMops, s/HAL, hdr/KernelWS:
    - Replace the ARMv7 cache maintenance code with the example code from the ARMv7 ARM. This allows it to deal with caches with non power-of-two set/way counts, and caches with only one way.
    - Fixed Analyse_WB_CR7_Lx to use the cache level ID register to work out how many caches to query instead of just looking for a 0 result from CSSIDR.
    - Also only look for 7 cache levels, since level 8 doesn't exist according to the ARMv7 ARM.
  s/NewReset:
    - Removed some incorrect/misleading debug output
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.51. Tagged as 'Kernel-5_35-4_79_2_98_2_51'
@
text
@d690 1
d692 1
d698 1
a698 1
        DebugTX "Keyboard scan complete"
@


4.16.2.28.2.11.2.1
log
@  Support for Raspberry Pi / BCM2835
Detail:
  Falls into two main areas: graphics support and ARM11 core support.
  A work in progress - in many cases the code changes need to be replaced
  with an alternative mechanism which will permit the kernel to still function
  on other platforms. Adrian marked these with "!!!" comments - I have added
  ! directives as well so that they don't get forgotten about.
Admin:
  Changes received from Adrian Lees. This revision represents the code largely
  as delivered, and is placed on its own branch (forked off from the version
  from which he worked). It is intended for reference. It doesn't build against
  current headers - this is likely to require a merge with the other changes
  to the kernel since that time.

Version 5.35, 4.79.2.98.2.52.2.1. Tagged as 'Kernel-5_35-4_79_2_98_2_52_2_1'
@
text
@a1564 1
        DebugTX "InitDynamicAreas"
a1711 1
        DebugTX "InitVectors"
a1775 1
        DebugTX "InitIRQ1"
a1825 1
        DebugTX "IMB_Full"
d1914 1
a1914 2
        ! 0, "FIXME: we're going to need this back at some point"
;        BL      LookForHALRTC ; Check if an RTC was just added. This is currently the only place where HAL RTCs are checked for; if we wanted to check anywhere else (e.g. after ROM module initialisation) then we'd have to listen for Service_Hardware so we can cope with device removal
@


4.15
log
@
  * Kernel failed to assemble on Lazarus builds.  Single instruction change
    should cure this.

Detail:

  * Lazarus builds of the Kernel failed with the following error:

      Immediate value out of range at line 458 in file "s.NewReset"
              ADR    R2, IRQ_Test_CTRL_or_R_Pressed

    This is due to the ADR going out of range.  Changed to use ADDR
    macro instead to rectify this.

Admin:

  * Untested at time of check-in; to be verified in next Lazarus development
    build.

Version 5.25. Tagged as 'Kernel-5_25'
@
text
@d1622 3
@


4.14
log
@* Run-time emulator detection added (no need for separate images). Needs an
  RPCEm update.
* Register allocation in default ErrorV handler fixed - problems occured when
  callbacks were triggered on way out.
* OS_Byte 19 didn't manipulate interrupt disable flag correctly in 26-bit
  builds.
* Stray bit of debugging left in sprite code many years ago removed.

Version 5.23. Not tagged
@
text
@d472 1
a472 1
        ADR     R2, IRQ_Test_CTRL_or_R_Pressed
@


4.13
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d430 5
a434 3
   [ RunningOnEmul :LAND: :LNOT: STB
        MOV     R7,#&80
        ORR     R7,R7,#&3E00            ; r7 := &3E80 = 16000 (standard Risc PC value)
a684 3
    [ RunningOnEmul :LAND: :LNOT: STB
KeyWait *       1
    |
a685 1
    ]
d694 5
d700 1
d1925 4
a1928 2
 [ RunningOnEmul :LAND: :LNOT: STB
        ADD     r3,r3,#1
d2164 5
a2168 3
 [ RunningOnEmul :LAND: :LNOT: STB
        ADD     r3,r3,#1
        |
@


4.12
log
@Ensured that interrupts in C and D registers masked on reset.
Power down A to D convertors on reset.

Version 5.05. Tagged as 'Kernel-5_05'
@
text
@a43 2
 [ MEMM_Type = "ARM600"

a46 30
 |

; Else use PhysRam start

InitKbdWs       *       PhysRam
 ]

 [ MEMM_Type <> "ARM600"
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; routine to set up a 32K chunk (for fixed areas)
; Enter with R8 = PageSize, R2 = physram offset, R3 logaddr
; R8 preserved on exit

; This routine is not needed on ARM600, as MemSize sets up the L2PT for the static pages

SlapIn32K
        MOV     R12, lr
        ADRL    R1, PageShifts-1
        LDRB    R1, [R1, R8, LSR #12]
        MOV     R2, R2, LSR R1          ; DivRem  R0, R2, R8, R1
                                        ; R2 := cam entry no
        ADD     R5, R3, #32*1024
SlapInNext
        BL      BangCam
        ADD     R2, R2, #1
        ADD     R3, R3, R8
        CMP     R3, R5
        BNE     SlapInNext
        MOV     PC, R12
 ]
a61 1
 [ ExpandedCamMap
a70 12
 |
        MOV     R1, #0
        CMP     r2, #CursorChunkAddress
        ORREQ   r2, r2, #&10000000      ; appropriate PPL
01
        STR     R2, [R0, R1]
        ADD     R1, R1, #4
        ADD     R2, R2, R8
        CMP     R1, R7
        BNE     %BT01
        MOVS    pc, lr
 ]
a168 1
  [ MEMM_Type = "ARM600"
a178 20
  |
        CMP     R8, #512*1024
        MOVEQ   R6, #(512-96)*1024
        MOVEQ   R7, #512*1024
        MOVNE   R6, #(512-32)*1024
   [ MEMM_Type = "MEMC2"
        MOVNE   R7, #(512+96)*1024      ; if MEMC2, skip L2PT as well
   |
        MOVNE   R7, #(512+64)*1024
   ]
        Push    "R2"

        ADRL    R2, PageShifts-1
        LDRB    R2, [R2, R10, LSR #12]
        MOV     R6, R6, LSR R2          ; DivRem  R6, R6, R10, R2
        MOV     R7, R7, LSR R2
        MOV     R8, R8, LSR R2

        Pull    "R2"
  ]
a334 51
 [ MEMM_Type <> "ARM600"
        GBLL    ARM3_Support
 ]

 [ :DEF:ARM3_Support
ARM3            CP     15

CR0             CN      0
CR_ID           CN      0
CR_Flush        CN      1
CR_Control      CN      2
CR_Cacheable    CN      3
CR_Updateable   CN      4
CR_Disruptive   CN      5

UndefVec *      &00000004

; Default cacheable areas
;
; ROM                   Cacheable       (&03400000..&03FFFFFF)
; I/O                   Not cacheable   (&03000000..&033FFFFF)
; Phys RAM              Not cacheable   (&02000000..&02FFFFFF)
; Log RAM (screen)      Not cacheable   (&01E00000..&01FFFFFF)
; Log RAM (RAM Disc)    Not cacheable   (&01000000..&013FFFFF)
;                       (No point in caching RAM Disc)
; Log RAM (non-screen)  Cacheable       (&00000000..&01DFFFFF)
Cacheable_Default DCD     2_11111100000000000111110011111111

; Default updateable areas
;
; ROM/CAM               Not updateable  (&03800000..&03FFFFFF)
; ROM/DAG               Not updateable  (&03400000..&037FFFFF)
; I/O                   Not updateable  (&03000000..&033FFFFF)
; Phys RAM              Not updateable  (&02000000..&02FFFFFF)
; Log RAM (screen)      Not updateable  (&01E00000..&01FFFFFF)
; Log RAM               Updateable      (&00000000..&01DFFFFF)
Updateable_Default DCD    2_00000000000000000111111111111111

; Default disruptive areas
;
; CAM                   Disruptive      (&03800000..&03FFFFFF)
; DAG                   Not disruptive  (&03400000..&037FFFFF)
; I/O                   Not disruptive  (&03000000..&033FFFFF)
; Phys RAM              Not disruptive  (&02000000..&02FFFFFF)
; Log RAM               Not disruptive  (&00000000..&01FFFFFF)
Disruptive_Default *    2_11110000000000000000000000000000

UndefRet
        MOVS    pc, lr
 ]

a371 1
 [ IO_Type = "IOMD"
a374 1
 ]
a375 3
 [ Keyboard_Type = "PC" :LAND: IO_Type <> "IOMD"
        MOV     R0, #podule_IRQ_bit     ; used for PC keyboard h/w on a podule
 |
a378 1
 ]
a436 85
; first ensure nothing dangerous in MEMC

 [ MEMM_Type <> "ARM600"                ; all this stuff is done in MemSize
 [ {TRUE}                               ; new code which allows for MEMC2's small pages
        ADRL    r2, PageShifts-1
        LDRB    r2, [r2, r8, LSR #12]   ; get log2(pagesize)
        MOV     R2, R13, LSR R2         ; number of pages=total memory / pagesize
        CMP     R2, #128                ; but if fewer than 128 (eg 64 on A305)
        MOVCC   R2, #128                ; then use 128 (all MEMC1's pages need initialising,
                                        ; even if half of them are not in use)
 |
        CMP     R13, #8*1024*1024       ; if >= 8MBytes,
        MOVCS   R2, R13, LSR #15        ; then there are R13/32K pages
        MOVCC   R2, #128                ; else there are 128 pages
 ]
        SUB     R2, R2, #1              ; maximum page number

        LDR     R3, =DuffEntry          ; a non-existant piece of memory
        MOV     R11, #AP_Duff           ; go away, users
EmptyCamEntries
        BL      BangCam                 ; ensure not mapped to anything
        SUBS    R2, R2, #1              ; dangerous
        BPL     EmptyCamEntries

; Put in position all fixed areas of memory
;   32K for cursor etc     : CAM entries for 512-32 to 512K in PhysRam

; SlapIn32K needs R8 = pagesize
; This is now already set up, so no need to compute it from
; MEMC CR (which would be wrong on ARM600 anyway)

        MOV     R11, #1                 ; user write protected
        MOV     R3, #CursorChunkAddress
        MOV     R2, #(512-32)*1024
        BL      SlapIn32K

        MOV     R3, #SysHeapChunkAddress ; 32K forced in system heap area
; use phys 512+32 to 512+64K if R13<>512K,  512-96 to 512-64K if R13=512K
        CMP     R13, #512*1024
        MOVEQ   R2, #(512-96)*1024
        MOVNE   R2, #(512+32)*1024

        MOV     r11, #0
        BL      SlapIn32K

        MOV     R3, #0                  ; 32K system work area

; use phys 512 to 512+32K if R13<>512K,  512-64 to 512-32K if R13=512K

        CMP     R13, #512*1024
        MOVEQ   R2, #(512-64)*1024
        MOVNE   R2, #512*1024

        BL      SlapIn32K
 ]

 [ :DEF:ARM3_Support
        MOV     r0, #UndefVec
        LDR     r1, [r0]
        LDR     r2, UndefRet
        MOV     r5, #0
        STR     r2, [r0]
        MRC     ARM3, 0, r5, CR_ID, CR0
        STR     r1, [r0]
        AND     r5, r5, #&ff00
        TEQ     r5, #&0300
        BNE     noarm3
        LDR     r0, Cacheable_Default
        LDR     r1, Updateable_Default
        MOV     r2, #Disruptive_Default
        MCR     ARM3, 0, r0, CR_Cacheable, CR0
        MCR     ARM3, 0, r1, CR_Updateable, CR0
        MCR     ARM3, 0, r2, CR_Disruptive, CR0
        MRC     ARM3, 0, r3, CR_Cacheable, CR0
        MRC     ARM3, 0, r4, CR_Updateable, CR0
        MRC     ARM3, 0, r5, CR_Disruptive, CR0
        TEQ     r0, r3
        TEQEQ   r1, r4
        TEQEQ   r2, r5
        BNE     noarm3
        MOV     r0, #3
        MCR     ARM3, 0, r0, CR_Control, CR0
noarm3
 ]

d458 1
a458 2
 [ CPU_Type = "ARM600"
        mrs     AL, r0, CPSR_all        ; switch into IRQ32, still IRQs disabled
d461 1
a461 1
        msr     AL, CPSR_all, r1
d470 3
d497 1
a497 1
        msr     AL, CPSR_all, r0
a500 13
 |
        TEQP    pc, #IRQ_mode + I_bit   ; set up IRQ stack
        NOP
        LDR     sp_irq, =IRQSTK

        ADRL    R0, MOSROMVecs          ; pick up from table
        LDR     R0, [R0, #&18]          ; this gets overwritten while active,
        MOV     R1, #0                  ; could have been changed by keyboard initialisation
        STR     R0, [R1, #&18]          ; but hopefully by the same value!

        TEQP    pc, #SVC_mode           ; Enable interrupts, back to supervisor mode
        NOP
 ]
d568 1
a568 2
 [ CPU_Type = "ARM600"

d571 1
a571 1
        mrs     AL, r0, CPSR_all
d574 1
a574 1
        msr     AL, CPSR_all, r0
a613 1
 [ CPU_Type = "ARM600"
a615 1
 ]
d635 2
a636 7
        [ {TRUE}          ; first version is from STB, second from 3.70
        LDR     R1, [R1]  ; since R0, R1, R2 all get trashed soon stay
        STR     R1, [R0]  ; with the more efficient STB version
        |
        LDR     R2, [R1], #4
        STR     R2, [R0], #4
        ]
a924 3
  [ {TRUE} ; cope with ARM7500FE
; Change test around so if not IOMD_Original, do the code,
; rather than checking for ARM7500 (which would exclude ARM7500FE)
a930 7
  |
        LDRB    R0, [R8, #IOMD_ID0]
        CMP     R0, #&E7
        LDRB    R0, [R8, #IOMD_ID1]
        CMPEQ   r0, #&5B
        BNE     dont_program_mousetype
  ]
d994 2
a995 2
        =       YearCMOS,               97
        =       YearCMOS+1,             19
d1043 2
a1044 2
        =       YearCMOS,       97      ; changed from 95 to 97 on 02-Jan-97
        =       YearCMOS+1,     19
a1140 1
 [ {TRUE}                               ; new code which allows for MEMC2's small pages
a1150 1
 [ MEMM_Type = "ARM600"
a1151 5
 |
        LDRLS   R3, =CamEntries         ; if <= 256 pages, then should be using
                                        ;  low-down cam soft copy
        LDRHI   R3, =CamEntriesForBigMachines ; else should be using hi up one
 ]
a1154 15
 |
        MOV     R5, #0
        LDR     R3, [R5, #RAMLIMIT]     ; read amount of RAM
        LDR     R4, [R5, #MaxCamEntry]  ; and highest CAM entry
        LDR     R5, [R5, #CamEntriesPointer] ; and pointer to CAM soft copy

        CMP     R3, #8*1024*1024        ; if >= 8MBytes then there are
        MOVCS   R2, R3, LSR #15         ; RAM/32k pages
        MOVCC   R2, #128                ; else there are 128 pages
        SUB     R2, R2, #1              ; what highest cam index should be

        LDRLS   R3, =CamEntries         ; if <= 8MBytes, should be using
                                        ; low-down cam soft copy
        LDRHI   R3, =CamEntriesForBigMachines ; else should be using hi up one
 ]
a1171 1
 [ CPU_Type = "ARM600"
a1172 3
 |
        ORR     R4, R4, #&FC000000
 ]
a1416 1
 [ ExpandedCamMap
a1417 1
  [ MEMM_Type = "ARM600"
a1418 3
  |
        LDR     r0, =480*1024
  ]
a1424 9
 |
        MOV     R0, #(512-32)*1024*4
        MOV     R0, R0, LSR R1          ; r0 := cam entry number * 4

        MOV     R7, #32*1024*4
        MOV     R7, R7, LSR R1          ; r7 := cam entry offset for 32K

        MOV     R2, #0
 ]
a1435 1
 [ MEMM_Type = "ARM600"
a1436 4
 |
        LDRLS   R1, =CamEntries                 ; if <=256 pages (was if <=8MBytes) then small CAM copy
        LDRHI   R1, =CamEntriesForBigMachines   ; else use big CAM copy
 ]
a1439 2
 [ MEMM_Type = "ARM600"

a1451 1
 ]
a1471 1
 [ MEMM_Type = "ARM600"
a1495 10
 |
  [ MEMM_Type = "MEMC2"
; CCs from CMP still valid
        SUBEQ   R0, R0, R7              ; previous entries
        ADDNE   R0, R0, R7              ; next entries
        LDR     R2, =CursorChunkAddress+64*1024 ; 01F10000
        MOV     r1, #AP_CursorChunk
        BL      AddCamEntries
  ]
 ]
d1502 1
a1502 1
 [ NewStyle_Screen
a1524 9
 |
        MOV     R2, #0                  ; CAM entry number to use (irrelevant for new code)
        MOV     R0, #ScreenSizeCMOS     ; CMOS byte to read
        MOV     R3, #ScreenEndAdr       ; where to put it (screen fudged)
        LDR     R1, =VduDriverWorkSpace+TotalScreenSize
                                        ; variable to save size set
        MOV     r11, #AP_Screen         ; Unprotected
        BL      ReadCMOSAndConfigure    ; Screen must be done first to get video RAM pages
 ]
d1526 1
a1526 1
 [ NewStyle_RMA
a1538 7
 |
        MOV     R0, #1                  ; One page. Unprotected
        MOV     R3, #RMAAddress
        ADD     R1, R3, #:INDEX: hpdend ; see comment about SysHeap!
        MOV     r11, #AP_RMA
        BL      FudgeConfigureRMA
 ]
d1540 1
a1540 1
 [ NewStyle_SpriteArea
a1557 7
 |
        MOV     R0, #SpriteSizeCMOS
        MOV     R3, #SpriteSpaceAddress
        LDR     R1, =SpriteSize         ; for Richard. Unprotected
        MOV     r11, #AP_Sprites
        BL      ReadCMOSAndConfigure
 ]
d1559 1
a1559 1
 [ NewStyle_RAMDisc
a1573 7
 |
        MOV     R0, #RAMDiscCMOS
        MOV     R3, #RAMDiscAddress
        LDR     R1, =RAMDiscSize        ; for RAMFS
        MOV     r11, #AP_RAMDisc        ; protected
        BL      ReadCMOSAndConfigure
 ]
d1575 1
a1575 1
 [ NewStyle_FontArea
a1589 7
 |
        MOV     R0, #FontCMOS
        MOV     R3, #FontCacheAddress
        LDR     R1, =FontCacheSize        ; for Fontmanager
        MOV     r11, #AP_FontArea
        BL      ReadCMOSAndConfigure      ; still protected
 ]
a1592 1
 [ MEMM_Type = "ARM600"
a1598 17
  [ :LNOT: GetPagesFromFreePool         ; memory is already in free pool, so don't mess around
        MOV     r0, #0
        LDR     r0, [r0, #RAMLIMIT]
        MOV     r0, r0, LSR #12         ; only limit on free pool is ram size
        MOV     R3, #FreePoolAddress
        LDR     R1, =FreePoolDANode + DANode_Size
        MOV     r11, #AP_FreePool
        BL      FudgeConfigureRMA       ; and the rest in FreePool
  ]
 |
        MOV     R0, #4096               ; try and get maximum amount possible
        MOV     R3, #32*1024            ; aplwork start
        LDR     R1, =AplWorkSize        ; aplwork size
        MOV     r11, #AP_AppSpace
        BL      FudgeConfigureRMA       ; stuff rest on AplWork
 ]

a1604 42
 [ MEMM_Type <> "ARM600"

; Now add all the NaffEntries to CamEntries
; R2 highest CAM entry used
; NB This is not done on ARM600, as the whole soft CAM map has to be zapped before
; we start, because BangCamUpdate uses the old contents

        LDR     R3, [R0, #MaxCamEntry]  ; (R0 still zero from above)
        CMP     R2, R3
        BGT     CAMallset
        LDR     R0, [R0, #CamEntriesPointer] ; (R0 still zero from above)
 [ ExpandedCamMap
        ADD     r3, r0, r3, LSL #3      ; r3 -> last pair of words to do
        ADD     r0, r0, r2, LSL #3      ; r0 -> first pair of words to do
        LDR     r1, =DuffEntry          ; address
        MOV     r2, #AP_Duff            ; PPL
WallopDuffOnes
        STMIA   r0!, {r1, r2}           ; store address, PPL
        CMP     r0, r3
        BLS     WallopDuffOnes
 |
        LDR     R1, =DuffEntry :OR: (AP_Duff :SHL: 28)
WallopDuffOnes
        STR     R1, [R0, R2, LSL #2]
        ADD     R2, R2, #1
        CMP     R2, R3
        BLE     WallopDuffOnes
 ]
CAMallset
 ]

 [ :LNOT: NewCDA
; System heap only initialised here on older software models
; On new ones it's already been initialised by hand in InitDynamicAreas,
; so that we can create dynamic areas above here.

        MOV     R0, #HeapReason_Init    ; initialise system heap
        LDR     R1, =SysHeapStart
        MOV     R3, #32*1024 - (SysHeapStart-SysHeapChunkAddress)
        STR     R3, [R1, #:INDEX: hpdend] ; keep ValidateAddress happy
        SWI     XOS_Heap                  ; tuff if it fails
 ]
a1606 4
 [ :LNOT: GetPagesFromFreePool
        MOV     R0, #0                  ; initialise module list to empty
        STR     R0, [R0, #Module_List]
 ]
a1624 5
        ; from STB, but generally useful
	MOV	R0, #0
	MOV	R1, R1, LSR #4
	STRB	R1, [R0, #ResetType]			; Save POR state in workspace (bit 0 of ResetType)

d1638 1
a1638 1
        TEQP    PC, #SVC_mode + I_bit   ; interrupts off since kbd bash done
d1670 1
a1670 1
 [ CPU_Type = "ARM600"
d1674 1
a1674 1
        mrs     AL, r2, CPSR_all
d1677 1
a1677 1
        msr     AL, CPSR_all, r3
d1716 1
a1716 1
 [ CPU_Type = "ARM600"
d1720 1
a1720 1
        msr     AL, CPSR_all, r2
d1741 1
a1741 2
        TEQP    pc, #SVC_mode           ; enable IRQs
        NOP
d1799 1
a1799 1
        TEQP    PC, #0                  ; enter USR mode (IRQs, FIQs enabled)
a1839 1
      [ {TRUE}                          ; Give startup message in megabytes
a1847 10
      |
        MOV     R0, R0, LSR #10         ; /1024
        LDR     R1, =GeneralMOSBuffer
        MOV     R2, #?GeneralMOSBuffer
        SWI     XOS_ConvertInteger4
        SWI     XOS_Write0
        SWI     XOS_WriteS
        =       "K", 10,13, 10, 0       ; title complete
        ALIGN
      ]
d2244 1
a2244 1
        Push  "R1, R2, lr"
d2254 1
a2254 1
        Pull  "R1, R2, PC", ,^
d2257 1
d2260 1
a2260 1
        MOVS   pc, lr
@


4.11
log
@Added RCMM keyboard support for Delete-power on, Ctrl-reset etc etc.
Right arrow on a remote also acts as Delete.

Version 4.98. Tagged as 'Kernel-4_98'
@
text
@d491 2
@


4.10
log
@* Meaning of FEIOSpeedHalf was accidentally inverted.
* Wasn't allowing writes to most of EEPROM.
* Old prototype OS_SetTime SWI code removed.
* MPEGPoduleNTSCNotPALMask option support removed to simplify things a bit.
* Now can cope with a system with a PAL/NTSC link, but no monitor detect line.
* Default PAL & NTSC modes now always 12 & 46 respectively.
* Kernel now knows about monitor type 8 (NTSC) - modes 44-46 (640x200) are
  available.
* STB/NC CMOS test removed from POST pending further investigation.

Version 4.90. Tagged as 'Kernel-4_90'
@
text
@d38 2
a39 5
 [ MorrisSupport
  [ STB
Port2Present    # 4
  |
Port2Present    # 1
d41 2
a42 4
UnusedByte3     # 1
UnusedByte4     # 1
  ]
 ]
d496 1
d498 1
d655 2
a656 8
 [ MorrisSupport
  [ STB
        STR     R1, [R0, #Port2Present]
  |
        STRB    R1, [R0, #Port2Present]
        STRB    R1, [R0, #Port3Present]
  ]
 ]
@


4.9
log
@Default RCLK mode now RCLK/2 rather than RCLK/1.
Doesn't force CMOS setting of sync and monitortype on NCs/STBs.
Accepts HClockSelect parameter (number 9) in VIDC lists. Uses this to
determine whether to use HCLK or not, rather than abusing
Service_MonitorLeadTranslation.
If DontUseVCO flag is set, then VCLK will not be used - only RCLK (or HCLK if
requested).

Version 4.86. Tagged as 'Kernel-4_86'
@
text
@d973 1
a973 1
 [ IOMD_C_MonitorType = 0 :LAND: MPEGPoduleNTSCNotPALMask = 0 :LAND: IOMD_C_PALNTSCType = 0
d1240 1
a1240 1
  [ IOMD_C_MonitorType = 0 :LAND: MPEGPoduleNTSCNotPALMask = 0 :LAND: IOMD_C_PALNTSCType = 0
@


4.8
log
@Disabled references to old NC1 CMOS locations using the flag
ObsoleteNC1CMOS (like the CMOS header file).

Version 4.71. Tagged as 'Kernel-4_71'
@
text
@d308 1
a308 1
        & &E0000402     ; CR: FIFO load 16 words, 1 bpp, ck/1, rclk
d969 2
d981 1
@


4.7
log
@ROM speed not taken from the Machine header file.  POST can now exist
in a softloaded OS, since it searches for a zero word in the ROM
instead of using one within the POST when trying to communicate with
the POST adapter (the zero word must be in ROM).  Fixed to build on
non-chrontel STB/NC products.  Lots of duplicate code merged in
MemSize.  MemSize copes better with the softload case, and is less
willing to use the region the OS occupies as video memory, or
page tables.  POST is now ON (memory tests disabled).
OS_ReadSysInfo 4 now uses the NVRAM module to access the ethernet
address in NVRAM/CMOS, so that the availability/location of the
MAC address can be changed.  CMOS location 0 is now unprotected on
STB/NC products to try to stop people poking the hardware directly.
Fixed a CMOS resetting problem on STBs where the value expected in a
location was different from the value written on a CMOS reset, so the
CMOS would be reset every time...

Version 4.69. Tagged as 'Kernel-4_69'
@
text
@d1122 1
d1128 1
@


4.6
log
@OS_Byte 129 0 255 now reports &A7 for STB build (because it _is_ a
RISC OS 3.7 generation kernel).
CMOS no longer gets scrambled when reset in STB build.
UpCall_KeyboardStatus now issued when OS_Byte 202 called or when keyboard
status byte is changed by other means (such as pressing Caps Lock).

Version 4.67. Tagged as 'Kernel-4_67'
@
text
@d971 1
a971 1
 [ IOMD_C_MonitorType = 0 :LAND: MPEGPoduleNTSCNotPALMask = 0
d1235 1
a1235 1
  [ IOMD_C_MonitorType = 0
@


4.5
log
@Following changes folded in from the start of the Ursula branch:
CPU type messages internationalised.
"Unknown OS_PlatformFeatures reason code" internationalised.
RunningOnEmul flag tweaked.
MorrisIDString conditional removed.
New modules added to SWI list at the end of the chain, on grounds that
the first-registered modules are probably more important.
*ChangeDynamicArea moved into UtilityModule from TaskManager.

Version 4.65. Tagged as 'Kernel-4_65'
@
text
@d1343 1
a1344 1
  ]
@


4.4
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d2269 1
a2269 1
   ! 0,"Printing of processor type disabled - 7500/FE weren't included"
d2277 6
d2285 1
d2424 18
a2453 1
 [ MorrisIDString
d2458 1
a2458 1
 ]
a2473 1
 [ MorrisIDString
a2475 1
 ]
a2485 1
   [ MorrisIDString
a2499 1
   ]
a2504 1
   [ MorrisIDString
a2505 1
   ]
@


4.3
log
@RISC OS 3.71 kernel changes merged.
Not fully tested on all hardware permutations.
@
text
@d296 3
a298 2

   [ VCOstartfix
d300 1
a300 1
   |
d302 7
d339 1
a339 1
  |
d341 2
a342 2
  ]
 |
d344 1
a344 1
 ]
d359 1
a359 1
 |
d403 1
a403 1
 ]
d959 1
d961 2
d967 1
d1038 1
d1043 1
d1233 1
a1233 1
        =       YearCMOS,               96
d1243 4
a1246 2
	=	DesktopFeaturesCMOS,	desktopfeaturebit_3D :OR: (8:SHL:1)	; 3D, Homerton
	=       ModemTimeoutCMOS,       10                                      ; 5 minutes
d2029 4
d2036 1
@


4.3.2.1
log
@Added following enhancements:

 - Chocolate screen mapping (section mapped and cached), StrongARM only
   Phoebe h/w (IOMD 2) will have register to assist this, but code currently
   relies on data abort mechanism to keep screen up to date wrt write-back
   data cache.

 - Chocolate AMBControl task switching (lazy page mapping), StrongARM only
   Improves task swapping speed. There appears to be a StrongAEM silicon
   bug rev 2 and 3) which means that LDMIB rn, {regs includind rn} cannot
   be reliably restarted after a data abort. This stuffs Chocolate AMBControl
   (awaiting response from Digital).

Both enhancements need more work to complete for Phoebe. Chocolate AMBControl
may well have to be made dormant because of silicon bug.

Note that this kernel *will* cause problems with task switching on StrongARM,
unless Chocolate task switching is disabled via !Flavour application.
@
text
@a884 4
        MOV     R1,#ARMA_Cleaner_status
        MOV     R0,#ACS_SCdisable
        STR     R0,[R1]                         ;initialise status, SC permanently disabled (in case not StrongARM)

d889 2
a890 6

  [ ChocolateScreen
        MOV     R1,#ARMA_Cleaner_status
        MOV     R0,#ACS_SCsuspend:OR:ACS_VSClazy_DEFAULT
        STR     R0,[R1]                         ;initialise status, VSC lazy = default value, SC enabled but suspended
  ]
d892 3
a894 4
        LDR     R0,=ARMA_Cleaners_address       ;first cleaner address
        STR     R0,[R1]                         ;initialise flipflop with first cleaner address

        ARMA_clean_DC R0,R1,R2                  ;using first cleaner address
a896 1

a1793 10

  [ ChocolateScreen
        MOV     r2,#ARMA_Cleaner_status
        LDR     r2,[r2]
        TST     r2,#ACS_SCdisable       ;section (1Mb) granularity if SC not disabled
        MOVEQ   r2,#&100000
        SUBEQ   r2,r2,#1
        ADDEQ   r0,r0,r2
        BICEQ   r0,r0,r2                ;let's crank the initial size to section granularity
  ]
@


4.3.2.2
log
@Module SWI chunks added to end of linked list on grounds that first loaded
modules are probably more important, so should be checked first.
Some RISC OS 3.70 bits internationalised.
*ChangeDynamicArea moved into UtilityModule from TaskManager.
@
text
@d2268 1
a2268 1
   ! 0,"Printing of processor type disabled"
a2275 6
      [ International
        ADD     r0, r1, r0, LSL #3
	BL	Write0_Translated
	SWI	XOS_NewLine
	SWI	XOS_NewLine
      |
a2277 1
      ]
a2415 18
   [ International
        =	"600", 0
	ALIGN	8
	=	"610", 0
	ALIGN	8
	=	"700", 0
	ALIGN	8
	=	"710", 0
	ALIGN	8
	=	"810", 0
	ALIGN	8
	=	"SA110", 0
	ALIGN	8
	=	"7500", 0
	ALIGN	8
	=	"7500FE", 0
	ALIGN	8
   |
d2428 1
d2433 1
a2433 1
   ]
d2449 1
d2452 1
d2463 1
d2478 1
d2484 1
d2486 1
@


4.3.2.3
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d17 1
a17 1
DuffEntry *     31*1024*1024+32*1024    ; Never any memory at this address (Nowhere)
d49 4
a52 1
; InitKbdWs is in zero page - check it's big enough
d54 31
d99 1
d109 12
d159 5
d182 1
d212 53
d328 7
a334 1

d336 1
a336 1

d352 43
d398 51
d555 83
d665 1
d687 4
d692 1
d706 15
d758 1
d773 1
d786 2
d794 2
d806 1
d808 1
d827 1
d831 1
d833 1
d836 1
d856 1
d859 4
d944 1
a944 1
        MOV     R3, #-1                 ; do all RAM if we do any
d946 1
a946 1
        BNE     cmos_reset
d951 1
a951 1
        MOV     R1, #ScreenSizeCMOS
d953 7
a959 7
        MOV     R0, R1
        BL      Read
        TEQ     R0, #0
        BNE     cmos_reset
        INC     R1
        TEQ     R1, #SpriteSizeCMOS
        BHI     reset_loop
d962 4
a965 4
        MOV     R0, #FontCMOS
        BL      Read
        CMP     R0, #32
        BHI     cmos_reset
d967 2
a968 2
        MOV     R0, #VduCMOS
        BL      Read
d971 1
a971 1
        TEQ     R0, #(Sync_Separate :OR: MonitorType0)
d974 1
a974 1
        TEQ     R0, #(Sync_Auto :OR: MonitorTypeAuto)
d976 1
a976 1
        BNE     cmos_reset
d980 4
a983 4
        MOV     R0, #YearCMOS+1
        BL      Read
        TEQ     R0, #19
        BNE     check20
d986 7
a992 7
        MOV     R0, #YearCMOS
        BL      Read
        CMP     r0,#95
        BLT     cmos_reset
        CMP     r0,#99
        BHI     cmos_reset
        B       checkboot
d995 2
a996 2
        TEQ     R0, #20
        BNE     cmos_reset
d999 4
a1002 4
        MOV     R0, #YearCMOS
        BL      Read
        CMP     R0, #20
        BHI     cmos_reset
d1006 4
a1009 4
        MOV     R0, #DBTBCMOS
        BL      Read
        TEQ     R0, #(1:SHL:4)
        BNE     cmos_reset
d1150 2
a1151 1
; Changed test around so if not IOMD_Original, do the code,
d1153 13
a1165 7
        LDRB    r0, [r8, #IOMD_ID0]
        LDRB    r1, [r8, #IOMD_ID1]
        ORR     r0, r0, r1, LSL #8
        LDR     r1, =IOMD_Original
        TEQ     r0, r1
        BEQ     dont_program_mousetype

d1227 2
a1228 2
        =       StartCMOS,              (2:SHL:3)                               ; NOCAPS
        =       DBTBCMOS,               (1:SHL:4)                               ; Boot
d1233 1
a1233 1
        =       VduCMOS,                Sync_Separate :OR: MonitorType0
d1236 1
a1236 1
        =       VduCMOS,                Sync_Auto :OR: MonitorTypeAuto
d1239 2
a1240 2
        =       DesktopFeaturesCMOS,    desktopfeaturebit_3D :OR: (8:SHL:1)     ; 3D, Homerton
        =       ModemTimeoutCMOS,       10                                      ; 5 minutes
d1352 301
d1656 1
d1676 1
d1678 1
a1678 1

d1680 3
d1689 9
d1709 1
d1711 4
d1717 4
a1720 1
; we must zap all the soft CAM map before adding any entries,
d1732 1
a1732 1

d1753 1
d1778 10
d1794 1
d1827 9
d1837 1
d1850 7
d1858 1
d1876 7
d1884 1
d1899 7
d1907 1
d1922 7
d1932 1
d1939 17
d1962 42
d2006 4
d2017 1
d2021 1
d2029 3
a2031 3
        MOV     R0, #0
        MOV     R1, R1, LSR #4
        STRB    R1, [R0, #ResetType]                    ; Save POR state in workspace (bit 0 of ResetType)
d2073 2
d2081 1
d2119 2
d2122 1
d2124 1
a2124 1

d2218 1
d2225 1
d2228 1
d2233 1
d2244 1
a2244 1
                                        ; Give startup message in megabytes
d2253 10
d2276 1
d2278 7
a2284 3
        BL      Write0_Translated
        SWI     XOS_NewLine
        SWI     XOS_NewLine
d2304 6
d2383 1
d2388 5
d2397 1
d2399 3
a2418 1

d2423 36
a2458 16
        =       "600", 0
        ALIGN   8
        =       "610", 0
        ALIGN   8
        =       "700", 0
        ALIGN   8
        =       "710", 0
        ALIGN   8
        =       "810", 0
        ALIGN   8
        =       "SA110", 0
        ALIGN   8
        =       "7500", 0
        ALIGN   8
        =       "7500FE", 0
        ALIGN   8
a2459 2

        ; type, internal type, features
d2466 7
a2472 1
        DCD &a100,5,2_11011   ;corrected for 3.71, value for 3.70 was 2_11111
d2476 1
d2478 1
a2478 2
 ] ;StrongARM

d2481 1
d2619 1
d2624 5
d2634 1
d2636 3
@


4.3.2.4
log
@1) Fixes and tidy ups:
   - mapping of Cur/Sys/Sound area done more elegantly, and soft CAM info
     is now consistent with it
   - cached screen cleaning on VSync performed *after* VSync events
   - comments at top of ARM600 modernised
   - Pages_Unsafe/Safe code fixed to work properly on StrongARM with
     pages that are involved in interrupts (there is no fix for ARM8,
     since that is unlikely to be needed - an ASSERT checks use of ARM8
   - OS_DynamicArea code souped up, to be much more efficient for large
     numbers of dynamic areas (see comments near top of ChangeDyn)
   - cached screen is now suspended on h/w scroll (avoids possible cache
     incoherency)
2) API changes:
   - new OS_Memory reason code (10) allows Wimp to inform kernel of
     Wimp_ClaimFreeMemory, and can control VRAM rescue (see below)
   - new OS_ReadSysInfo reason code (6) allows reading of kernel values
     (reserved for Acorn use, eg. for SoftLoad, ROMPatch)
   - new OS_DynamicArea reason codes (6 and 7) allow for more efficient
     monitoring of dynamic areas by TaskManager (reserved for Acorn use)
3) Changes for Phoebe:
   - kernel runs a VRAM rescue process, which ensures that any VRAM not
     used for the screen is reclaimed if necessary and sinks to the bottom
     of the Free Pool. This is important for Phoebe, where VRAM is slower
     than SDRAM, but does no harm on other platforms.
   - logical copy of physical RAM is removed from memory map. This frees
     up 256M of address space that will later be used for PCI on Phoebe,
     but should do no harm on other platforms (this space is marked
     private in PRMs, so 3rd parties should not use it).
@
text
@a585 13
  [ RescueVRAM
        MOV     R1,#0
        LDR     R0,[R1,#VRAMSize]
        CMP     R0,#0
        MOVEQ   R0,#VRRc_disable
        MOVNE   R0,#VRRc_suspend              ;suspend for now
        STR     R0,[R1,#VRAMRescue_control]   ;word store sets all 3 fields (control,status,nextVpage)
  |
        MOV     R1,#0
        MOV     R0,#VRRc_disable
        STR     R0,[R1,#VRAMRescue_control]   ;word store sets all 3 fields (control,status,nextVpage)
  ]

a1077 3
;this now assumes 4k pages (kernel now does not support pre-Medusa anyway)
        Push    "R0,R7"
        MOV     R7, #5*8
d1079 1
a1079 1
        LDR     r1, =AP_CursorChunk5
a1080 10
        MOV     R7, #3*8
        ADD     R0, R0, #5*8
        LDR     r1, =AP_CursorChunk3
        BL      AddCamEntries
        Pull    "R0,R7"

;used to be:
;       MOV     R2, #CursorChunkAddress
;       LDR     r1, =AP_CursorChunk
;       BL      AddCamEntries
a1380 1

a1494 26
  [ RescueVRAM
        Push    "r0-r8"
        MOV      r1,#0
        LDRB     r0,[r1,#VRAMRescue_control]
        TST      r0,#VRRc_disable
        BNE      vrescue_init_done
        BIC      r0,r0,#VRRc_suspend
        STRB     r0,[r1,#VRAMRescue_control]   ;remove suspension
        MOV      r0,#0
        MOV      r1,#ChangeDyn_VRescue
        MOV      r2,#0
        MOV      r3,#-1
        LDR      r4,=AP_VRescue
        MOV      r5,#4096
        ADRL     r6,VRescue_DAhandler
        MOV      r7,#VRAMRescue_control
        ADRL     r8,VRescue_DAname
        SWI      XOS_DynamicArea               ;create the DA area for rescueing VRAM pages in use
        MOV      r0,#10-1                      ;call rescuer every 10 centiseconds
        ADR      r1,VRAM_rescuer
        MOV      r2,#VRAMRescue_control
        SWI      XOS_CallEvery
vrescue_init_done
        Pull     "r0-r8"
  ]

a1802 165

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  [ RescueVRAM

; called via CallEvery
; entry: r12 = address of VRAMRescue_control
;
VRAM_rescuer ROUT
        Push  "r0-r2,lr"
        MOV   r2,PC
        ORR   r1,r2, #SVC_mode
        TEQP  r1,#0                       ;make sure SVC mode
        NOP
        LDRB  r0,[r12]
        TST   r0,#VRRc_disable :OR: VRRc_suspend :OR: VRRc_wimp_lock
        BNE   %FT99
        LDRB  r0,[r12,#1]                 ;status byte
        TST   r0,#VRRs_CBpending
        BNE   %FT99
        ORR   r0,r0,#VRRs_CBpending
        STRB  r0,[r12,#1]                 ;set CBpending
        ADR   r0,VRAM_rescuer_callback
        MOV   r1,r12
        SWI   XOS_AddCallBack
99
        TEQP  r2,#0
        NOP
        Pull  "r0-r2,PC"

; called via AddCallBack
; entry: r12 = address of VRAMRescue_control, svc mode, interrrupts enabled
;
VRAM_rescuer_callback ROUT
        Push  "r0-r8,lr"
        MOV   r8,PC
        ORR   r0,r8, #SVC_mode + I_bit   ;interrupts off
        TEQP  r0,#0
        NOP
        LDRB  r0,[r12,#1]                ;status byte
        BIC   r0,r0,#VRRs_CBpending
        STRB  r0,[r12,#1]                ;clear CBpending
        LDRB  r0,[r12]
        TST   r0,#VRRc_disable :OR: VRRc_suspend :OR: VRRc_wimp_lock
        BNE   %FT99
        MOV   r0,#0
        LDR   r0,[r0,#CDASemaphore]      ;paranoia - make sure CDA not threaded
        TEQ   r0,#0
        BNE   %FT99
        LDR   r0,=FreePoolDANode
        LDR   r5,[r0,#DANode_Base]
        LDR   r6,[r0,#DANode_Size]
        MOV   r0,r6,LSR #12              ;pages in Free Pool (assumes 4k page size)
        VDWS  r1
        LDR   r1,[r1,#TotalScreenSize]
        MOV   r1,r1,LSR #12              ;pages (of VRAM) in Screen dynamic area
        MOV   r2,#0
        LDR   r2,[r2,#VRAMSize]
        MOV   r2,r2,LSR #12              ;pages of total VRAM
        SUB   r3,r2,r1
        CMP   r3,r0
        MOVHI r3,r0                      ;pages of VRAM that should be in Free Pool
        CMP   r3,#0
        BEQ   %FT99

        LDR   r4,[r12]
        MOV   r4,r4,LSR #16              ;nextVpage - page number of next VRAM page to check
        CMP   r4,r1                      ;r1 is lower bound on nextVpage (VRAM page numbers start at 0)
        MOVLO r4,r1
        ADD   r0,r1,r3
        SUB   r0,r0,#1                   ;r0 is upper bound on nextVpage
        CMP   r4,r0
        MOVHI r4,r1                      ;wraparound to lower bound if necessary

        MOV   r0,#0
        LDR   r0,[r0,#CamEntriesPointer]
        SUB   r1,r4,r1
        ADD   r1,r5,r1,LSL #12           ;logaddr in Free Pool of ordered place for page at bottom of Free Pool
        LDR   r2,[r0,r4,LSL #3]          ;current logaddr of page, from CAM
        TEQ   r1,r2
        BEQ   %FT98                      ;it's in the ordered place!
        ADD   r6,r6,r5
        CMP   r2,r5
        BLO   %FT10                      ;not currently in Free Pool (below base address)
        CMP   r2,r6
        BLO   %FT20                      ;currently in Free Pool (below base+size)

10
;
; not free - grow the required page into our rescue DA (this allows the ChangeDynamicArea mechanism to
; do all the hard work with respect to Pages_Unsafe/Pages_Safe etc.), then shrink our DA back to free the page
;
        Push  "r0-r1"
        STRB  r4,[r12,#2]
        MOV   r0,r4,LSR #8
        STRB  r0,[r12,#3]                ;store page wanted for DA handler, without affecting other fields of word
        MOV   r0,#ChangeDyn_VRescue
        MOV   r1,#4096                   ;4k page size
        SWI   XOS_ChangeDynamicArea      ;rescue the page
        MOV   r1,#4096
        RSB   r1,r1,#0
        SWI   XOS_ChangeDynamicArea      ;set it free
        Pull  "r0-r1"
; now try to do simple Free Pool map again
        LDR   r2,[r0,r4,LSL #3]          ;current logaddr of page, from CAM (now should be in Free Pool)
        TEQ   r1,r2
        BEQ   %FT98                      ;good grief, it's in the ordered place!
        CMP   r2,r5
        BLO   %FT98                      ;not currently in Free Pool (below base address) - shouldn't happen
        CMP   r2,r6
        BHS   %FT98                      ;not currently in Free Pool (at or above base+size) - shouldn't happen
20
;
;in Free Pool, but not in ordered place - do a simple mapping swap (Free Pool pages are dead, so simple swap ok)
;
        MOV   r3,#L2PT
        LDR   r5,[r3,r1,LSR #10]
        MOV   r5,r5,LSR #12              ;(physical address>>12) of page currently at ordered place (from L2PT)
        MOV   lr,#PhysRamTable
        MOV   r3,#0                      ;we're going to compute page number from physical address in r3
30
        LDMIA lr!,{r6,r7}                ;load next address, size
        SUB   r6,r5,r6,LSR #12           ;number of pages into this bank
        CMP   r6,r7,LSR #12              ;if too many
        ADDCS r3,r3,r7,LSR #12           ;then advance page number
        BCS   %BT30                      ;and loop
        ADD   r3,r3,r6                   ;r3 is now page number of page at physical address r5<<12

        LDR   r5,[r0,r3,LSL #3]
        STR   r5,[r0,r4,LSL #3]
        STR   r2,[r0,r3,LSL #3]          ;swap the mappings in the CAM (PPL words will be the same)
        MOV   r0,#L2PT
        LDR   r5,[r0,r1,LSR #10]
        LDR   r6,[r0,r2,LSR #10]
        STR   r5,[r0,r2,LSR #10]
        STR   r6,[r0,r1,LSR #10]         ;swap the mappings in the L2PT (no need to flush TLBs/caches - dead pages)

98
        ADD   r4,r4,#1                   ;increment nextVpage for next call
        STRB  r4,[r12,#2]
        MOV   r4,r4,LSR #8
        STRB  r4,[r12,#3]                ;store without affecting other fields of word
99
        TEQP  r8,#0
        NOP
        Pull  "r0-r8,PC"

;
VRescue_DAname
        =     "VRAM rescue",0
        ALIGN

;
; handler just needs to fill in the page we want on pregrow
;
VRescue_DAhandler
        CMP   r0,#DAHandler_PreGrow
        MOVNE PC,r14
        LDR   r0,[r12]
        MOV   r0,r0,LSR #16        ;the page number we want (via VRAMRescue_nextVpage field)
        STR   r0,[r1]
        MOV   r0,#DAHandler_PreGrow
        MOV   PC,r14

  ] ;RescueVRAM
@


4.3.2.5
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@d384 1
d386 1
a386 8
        LDR     R1, [R2, #&18]          ; this gets overwritten while active,
        STR     R1, [R3, #&18]          ; but hopefully by the same value!

        ;and we must copy the two words that forward the branch at &18
        LDR     R1, [R2, #(ResetIRQForwarding-MOSROMVecs)]
        STR     R1, [R3, #(ResetIRQForwarding-MOSROMVecs)]
        LDR     R1, [R2, #(RIFaddress-MOSROMVecs)]
        STR     R1, [R3, #(RIFaddress-MOSROMVecs)]
d1103 8
a1110 1
        ADD     R0, R0, R7              ; next entries
d1115 3
a1117 5
        ASSERT  SVCStackSize            = 32*1024
        ASSERT  SysHeapPlusSVCStackSize = 64*1024
        ADD     R0, R0, R7              ; next entries
        Push    "R0,R7"
        MOV     R7, #8*8                ; 8 pages for 32k SVC stack
d1119 1
a1119 5
        LDR     R1, =AP_SVCStack :OR: PageFlags_Unavailable
        BL      AddCamEntries
        MOV     R7, #8*8                ; 8 pages for rest of 64k chunk (initial SysHeap)
        ADD     R0, R0, #8*8
        LDR     R1, =AP_SysHeap :OR: PageFlags_Unavailable
a1120 2
        Pull    "R0,R7"
        ADD     R0, R0, #16*8           ; next entries (after 64k Sysheap/SVCSTK chunk)
d1122 1
d1222 1
a1222 5
        ARM_read_ID r4
        AND     r4, r4, #&F000
        CMP     r4, #&A000
        MOVEQ   r4, #AP_RAMDisc_SA      ; Area flags, if StrongARM  (introduced for Ursula)
        MOVNE   r4, #AP_RAMDisc         ; Area flags
a1403 3
  [ :LNOT: InternationaliseCommonSilentErrors
        BL      Init_CommonSilentError_ws
  ]
d1541 1
a1541 1
        ADRL     r1,VRAM_rescuer
a1855 35

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  [ :LNOT: InternationaliseCommonSilentErrors
;
;  - currently just creates a buffer with a message for VarCantFind - ReadVarVal
;    can copy the name as a postfix
;  - there is only one buffer, so the hope is that an error handler that chooses
;    to report the error will not do another failed var lookup
;
Init_CommonSilentError_ws ROUT
        Push    "r0-r3,lr"
        MOV     r3,#256 + 8 + (ErrBlock_VarCantFind_End-ErrBlock_VarCantFind)
        BL      ClaimSysHeapNode
        MOV     r0,#0
        STR     r2,[r0,#CommonSilentError_ws]
        MOV     r1,#8+(ErrBlock_VarCantFind_End-ErrBlock_VarCantFind)
        STR     r1,[r2],#4        ;1st word is offset to buffer for name
        MOV     r1,#256
        STR     r1,[r2],#4        ;2nd word is max length of buffer for name
        ADR     r3,ErrBlock_VarCantFind
        MOV     r0,#ErrBlock_VarCantFind_End-ErrBlock_VarCantFind
10
        LDR     r1,[r3],#4
        STR     r1,[r2],#4
        SUBS    r0,r0,#4
        BNE     %BT10
        Pull    "r0-r3,pc"

ErrBlock_VarCantFind
        DCD     &124
        DCB     "System variable not found - "   ;MUST be multiple of 4 long, no terminator
ErrBlock_VarCantFind_End
        ASSERT  ((ErrBlock_VarCantFind_End-ErrBlock_VarCantFind) :AND: 3) = 0
  ]
@


4.3.2.6
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@d961 1
a961 1
        =       YearCMOS,       98      ; changed from 97 to 98 on 08-Jan-98 (Ursula)
a1203 16
  [ LongCommandLines
        ;sort out the Kernel buffers dynamic area
        Push    "r0-r12"
        MOV     r1, #ChangeDyn_Kbuffs   ; Area number
        MOV     r2, #KbuffsSize         ; Initial (and in fact permanent) size
        LDR     r3, =KbuffsBaseAddress  ; Base address
        MOV     r4, #AP_Kbuffs          ; Area flags
        MOV     r5, #KbuffsMaxSize      ; Maximum size
        MOV     r6, #0                  ; no handler
        MOV     r7, #0
        ADRL    r8, AreaName_Kbuffs     ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
        Pull    "r0-r12"
  ]

d1214 1
a1214 2
        MOV     r5, #16*1024*1024       ; Maximum size changed from -1 for Ursula (limit address
                                        ; space usage on large memory machines)
a1221 1
  [ KernelOwnsRAMFSDA
a1239 1
  ]
d1248 1
a1248 2
        MOV     r5, #32*1024*1024       ; Maximum size changed from -1 for Ursula (limit address
                                        ; space usage on large memory machines)
@


4.3.2.7
log
@Made the kernel control the layout of the free space map on the RAM disc,
which avoids the rmreinit ramfs on every size change of the disc.

Also increase RAM disc max size to 128M bytes.

Change is enabled by NewRAMFS switch.
@
text
@d1251 1
a1251 5
 [ NewRAMFS
        MOV     r5, #128*1024*1024     	; Limit maximum size to 128MB until we produce a machine after Phoebe
 |
        MOV     r5, #16*1024*1024       ; Limit maximum size to 16MB until we realise FileCore's ok
 ]
@


4.3.2.7.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d17 1
a17 5
DuffEntry     * 31*1024*1024+32*1024    ; Never any memory at this address (Nowhere)

T0Ticker100Hz * 20000-1                 ; Timer delay for Timer0 (units of 0.5 microsecond)
                                        ; 20000*0.5E-6 = 0.01 Seconds (100Hz ticker)
                                        ; TMD 21-May-93: "-1" correction applied
d38 4
d46 2
d187 9
d197 2
a198 2
;this is set up to allow signalling of whole-screen colours during early kernel
;boot, by setting border colour
a199 1
        & &E0000402     ; CR: FIFO load 16 words, 1 bpp, ck/1, rclk
d208 20
a227 16
        & &80000310     ; HCR  = 92 + 45 + 0 + 640 + 0 + 16
        & &81000054     ; HSWR = 92
        & &82000080     ; HBSR = 92 + 45
        & &83000080     ; HDSR = 92 + 45 + 0
        & &84000300     ; HDER = 92 + 45 + 0 + 640
        & &85000300     ; HBER = 92 + 45 + 0 + 640 + 0
        & &86000080     ; HCSR = HDSR

        & &9000020B     ; VCR  = 2 + 32 + 0 + 480 + 0 + 11
        & &91000001     ; VSWR = 2
        & &92000021     ; VBSR = 2 + 32
        & &93000021     ; VDSR = 2 + 32 + 0
        & &94000020     ; VDER = VDSR -1 to disable sceeen DMA
        & &95000201     ; VBER = 2 + 32 + 0 + 480 + 0
        & &96000021     ; VCSR = VDSR
        & &97000021     ; VCER = VDSR
d231 6
a236 2
        & &C0051003     ; EREG = sep/inv sync, DACs on, ereg output ext lut
        & &D0000302     ; FSYNREG, clk = (3+1)/(2+1) * 24MHz = 32MHz  (don't try to run VCO too slow)
d239 2
a276 30
bangIOC_eh
        LDRB    r0, [r1,#IOMD_ID0]
        TEQ     r0, #IOMD_Original :AND: &FF
        TEQNE   r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BEQ     bangIOC_IOMD1
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     bangIOC_IOMD2
        B       bangIOC_eh                   ;deliberate panic hang up

;
; 2 bits per external interrupt (ei), ei0 to ei12 in bits 0,1 to 24,25
; 00 = active high, 01 = active low, 10 = +ve edge, 11 = -ve edge
;
IOMD2_IntLevelModes * &00956C15  ; correct modes for Phoebe assignment of interrupts
;
bangIOC_IOMD2
        LDR     r0, =IOMD2_IntLevelModes
        STR     r0, [r1,#IOMD2_INTLVL]
        MOV     r0, #-1
        STR     r0, [r1,#IOMD2_INTREQ]       ;clear any spurious level interrupts
        MOV     r0, #0
        STR     r0, [r1,#IOMD2_INTENBL]      ;no IRQs
        STRB    r0, [r1,#IOCFIQMSK]          ;no FIQs
        STR     r0, [r1,#IOMD2_DMAENBL]      ;no DMA interrupts

        B       bangIOC_common

bangIOC_IOMD1

d280 1
d282 1
d284 3
d288 1
d291 1
a291 1
bangIOC_common
d293 3
a295 1
; now bits to allow CMOS read/write : need timer
a296 1
        LDR     R0, =T0Ticker100Hz
a304 17
        ;now wait for about 1ms
        ; - on Phoebe, this is plenty of time for SDRAM to get its act together
        ;   after the precharge command issued during InitMEMC
        ; - on other machines it will do no harm
        ;
        MOV     R0, #1024*2           ; time delay of about 1 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
RAM_awakes
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     RAM_awakes            ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     RAM_awakes            ; loop if not finished

a306 2

vcofix_eh
d308 4
a311 9
        TEQ     R0, #IOMD_Original :AND: &FF
        TEQNE   R0, #IOMD_IOMD2    :AND: &FF
        BEQ     vcofix_notneeded
        TEQ     R0, #IOMD_7500     :AND: &FF
        TEQNE   R0, #IOMD_7500FE   :AND: &FF
        BEQ     vcofix_needed
        B       vcofix_eh                    ;deliberate panic hang up

vcofix_needed
d329 1
a329 1
vcofix_notneeded
d340 1
a340 1
   [ RunningOnEmul
d361 4
d367 2
d396 1
a401 1
  [ ARMSASupport
a405 1
  ]
d407 4
d417 1
a417 1
        BL      SoftCopyROM             ;automagically softload ROM into reserved space, if required
d419 13
d443 1
d445 1
d540 2
a541 2
        LDR     R1, [R1]
        STR     R1, [R0]
d563 1
d573 1
a573 14
  [ ARMSASupport
    [ ChocolateScreen
        ARM_read_ID R0
        AND     R0,R0,#&F                       ;revision field of id
        CMP     R0,#SA120minimumrev             ;revision number for introduction of SA-120 (has mini data cache)
        MOVLO   R0,#0
        MOVHS   R0,#ACS_MiniDataCache           ;flag presence of mini data cache
        ORR     R0,R0,#ACS_SCsuspend:OR:ACS_VSClazy_DEFAULT
      [ :LNOT: IOMD2_VIDMRDbroken
        MOV     R1,#IOMD_Base
        LDR     R1,[R1,#IOMD_ID0]
        TEQ     R1,#IOMD_IOMD2 :AND: &FF        ;we only want to distinguish IOMD's that have VIDMRD here
        ORREQ   R0,R0,#ACS_HardVIDMRD           ;flag presence of h/w VIDMRD register    
      ]
d575 1
d577 1
a577 1
    ]
a584 1
  ] ;ARMSASupport
d587 4
d611 1
a611 1
    [ RunningOnEmul
d617 1
a617 19
kbd_eh
        MOV     r2,#IOMD_Base
        LDRB    r2,[r2,#IOMD_ID0]
        TEQ     r2,#IOMD_Original :AND: &FF
        TEQNE   r2,#IOMD_7500     :AND: &FF
        TEQNE   r2,#IOMD_7500FE   :AND: &FF
        BEQ     kbdwaitandcheck
        TEQ     r2,#IOMD_IOMD2    :AND: &FF
        BEQ     kbdpretend
        B       kbd_eh                        ;deliberate panic hang up
;
;on Phoebe, we can't see keyboard in kernel, so assume it is there
kbdpretend
        MOV     r5,#&FF
        MOV     r4,#InitKbdWs
        STRB    r5,[r4,#KB_There_Flag]
        B       kbdthere

kbdwaitandcheck
d631 1
d634 3
a636 3
 [ ValidateCMOS
; reset CMOS if its checksum is invalid
        MOV     R3, #-1                 ; do a full reset of CMOS if necessary
d639 63
d707 4
d712 1
a712 14
        ;Ursula change:
        ;power on always assumed (all resets now hard, no por_bit on IOMD2 anyway)
        MOV     R1, #por_bit

protection_check_eh
        MOV     r0, #IOMD_Base
        LDRB    r0, [r0, #IOMD_ID0]
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     Phoebe_check_CMOSreset
        TEQ     r0, #IOMD_Original :AND: &FF
        TEQNE   r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BNE     protection_check_eh            ;deliberate panic hang up

d725 1
a725 1
        B       protection_check_done
d727 4
a730 18
;Phoebe has no protection link visible via MonitorType
;Phoebe replaces keyboard DELETE with front panel volume buttons to force CMOS reset
;Check for both volume buttons pressed now, doing some debounce in s/w:
;   if pressed, and protection link absent, GIO bit 2 will read 0
;   if not pressed, GIO bit 2 reads 1
;   if protection link present, h/w is such that GIO bit 2 reads 1 regardless of buttons
;
Phoebe_check_CMOSreset
        MOV     r0, #IOMD_Base
        MOV     r3, #8*1024     ;this many reads at I/O speed to give some time for debounce
PhCMOS_debounce
        LDR     r1, [r0,#0]     ;IOCR register, GIO bits in bits 0..5
        TST     r1, #4
  [ PhoebeBodge
        MOVNE   r3,#-1          ;for FPGA board, reset CMOS if monitor lead not plugged in
        BNE     cmos_reset      ;(GIO bit 2 was proposed monitor id bit on these boards)
  |
        MOVEQ   r3,#-1          ;if 0 at any time during debounce, do CMOS reset
d732 1
a732 5
  ]
        SUBS    r3,r3,#1
        BNE     PhCMOS_debounce
;
protection_check_done
d739 4
d752 2
d757 1
d760 1
a760 1

a761 1
        SetBorder  R0, R1, 15, 0, 0     ; flash the border red as CMOS reset warning
d763 1
d766 3
a768 1

d784 1
d786 1
a786 1

d792 24
d819 3
d825 2
d829 6
d836 2
a837 1
        MOV     R1, #MonitorTypeAuto :OR: Sync_Auto
d840 1
a840 1
mousetype_eh
d842 2
d845 5
a849 7
        TEQ     r0, #IOMD_Original :AND: &FF
        BEQ     dont_program_mousetype            ;Risc PC has quadrature mouse
        TEQ     r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        TEQNE   r0, #IOMD_IOMD2    :AND: &FF
        BEQ     do_program_mousetype
        B       mousetype_eh                      ;deliberate panic hang up
d851 3
a853 2
do_program_mousetype
        ;PS2 mouse
d863 1
a865 13

check_sound_eh
        MOV     r0, #IOMD_Base
        LDRB    r0, [r0, #IOMD_ID0]
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     Config16BitSound             ;Phoebe has no SoundsystemLink, does have 16bit sound
        TEQ     r0, #IOMD_Original :AND: &FF
        TEQNE   r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BEQ     check_sound_link
        B       check_sound_eh               ;deliberate panic hang up

check_sound_link
d905 22
d953 1
d955 2
d988 11
a998 4

  [ KeepCachesOff
        =       SystemSpeedCMOS,(0:SHL:0):OR:(0:SHL:1):OR:(1:SHL:2):OR:(0:SHL:3):OR:(1:SHL:4):OR:(1:SHL:5):OR:(1:SHL:6):OR:(0:SHL:7)
  |
a999 1
  ]
d1005 1
a1005 1
                              ;                                                                  Cache off/on
d1008 1
d1010 1
d1014 5
d1023 1
a1176 7
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        MOV     r2,#&100000
        SUB     r2,r2,#1
        ADD     r0,r0,r2
        BIC     r0,r0,r2 
  ]
d1252 1
a1252 1
        MOV     r5, #128*1024*1024      ; Limit maximum size to 128MB until we produce a machine after Phoebe
d1307 4
a1310 3
        ;Ursula change:
        ;power on always assumed (all resets now hard, no por_bit on IOMD2 anyway)
        MOVS    R1, #por_bit
d1312 1
d1334 1
a1334 1
; copy appropriate IRQ handler for platform's IOMD: not done with rest of copying
a1335 19
;
  ASSERT IOMD_DefaultIRQ1Vcode     = IOMD_NoInterrupt+4
  ASSERT IOMD_DefaultIRQ1Vcode_end = IOMD_NoInterrupt+8
  ASSERT IOMD_Devices              = IOMD_NoInterrupt+12
;
resetp1d_eh
        MOV     R0, #IOMD_Base
        LDRB    R1, [R0, #IOMD_ID0]
  [ IOMD1Support
        TEQ     R1, #IOMD_Original :AND: &FF
        TEQNE   R1, #IOMD_7500     :AND: &FF
        TEQNE   R1, #IOMD_7500FE   :AND: &FF
        BEQ     resetp1d_IOMD1
  ]
  [ IOMD2Support
        TEQ     R1, #IOMD_IOMD2    :AND: &FF
        BEQ     resetp1d_IOMD2
  ]
        B       resetp1d_eh        ;deliberate panic hang up
a1336 29
  [ IOMD1Support

resetp1d_IOMD1
        LDR     R0, =IOMD_NoInterrupt
        MOV     R1, #IOMD1_NoInterrupt
        STR     R1, [R0]
        ADRL    R1, IOMD1_Devices
        STR     R1, [R0,#12]
        ADRL    R1, IOMD1_DefaultIRQ1Vcode
        STR     R1, [R0,#4]
        ADRL    R2, IOMD1_DefaultIRQ1Vcode_end
        STR     R2, [R0,#8]
        LDR     R0, =DefaultIRQ1V
        B       CopyDefaultIRQ1V

  ] ; IOMD1Support

  [ IOMD2Support

resetp1d_IOMD2
        LDR     R0, =IOMD_NoInterrupt
        MOV     R1, #IOMD2_NoInterrupt
        STR     R1, [R0]
        ADRL    R1, IOMD2_Devices
        STR     R1, [R0,#12]
        ADRL    R1, IOMD2_DefaultIRQ1Vcode
        STR     R1, [R0,#4]
        ADRL    R2, IOMD2_DefaultIRQ1Vcode_end
        STR     R2, [R0,#8]
d1338 2
a1339 3

  ] ;IOMD2Support
;
d1376 1
a1382 1
  [ ARMSASupport
d1387 2
a1388 3
        LDR     r0, =DefaultIRQ1V
        LDR     r1, =DefIRQ1Vspace   ;max size of code on any IOMD variant
        ADD     r1, r1, r0
a1393 1
  ] ;ARMSASupport
d1395 4
a1402 9
;change provoked by problem on Phoebe:
;make sure soft copies of VIDINIT etc are sensible, to avoid temporary
;programming of silly values
        LDR     r1,[r0,#VideoPhysAddr]
        STR     r1,[r0,#VInitSoftCopy]
        STR     r1,[r0,#VStartSoftCopy]
        ADD     r1,r1,#1024*1024-4096
        STR     r1,[r0,#VEndSoftCopy]

d1425 1
d1428 1
a1428 22

  [ DebugROMInit
        SWI     XOS_WriteS
        =       "Ursula kernel",13,10,0
        ALIGN
  ]

  [ PhoebeBodge_Slow
    ;Temporary code
    ;If running on IOMD2, fudge T0 to give correct 100Hz timing for slower FPGA/ASIC
    ;(as opposed to final target of 64 MHz ASIC)
    ;
Fudge_100Hz * 15000-1              ; normal value is 20000(-1), this is scaled by 48/64 for 48 MHz
        MOV     r0,#IOMD_Base
        LDRB    r1,[r0,#IOMD_ID0]
        TEQ     r1,#IOMD_IOMD2 :AND: &FF
        MOVEQ   r1,#Fudge_100Hz :AND: &FF
        STREQB  r1,[r0,#Timer0LL]
        MOVEQ   r1,#Fudge_100Hz :SHR: 8
        STREQB  r1,[r0,#Timer0LH]
        STREQB  r1,[r0,#Timer0GO]
  ]
d1495 1
a1495 1

d1497 1
a1497 1

d1513 1
d1515 1
a1523 8

        Push    "r0"
        LDR     r0, =&508
        SWI     XOS_Memory              ; returns amount of soft ROM (pages) in r1
        MOVVS   r1, #0
        Pull    "r0"
        ADD     r0, r0, r1, LSR #(8)    ; convert pages to MB and add in
   
d1531 2
d1534 4
d1548 2
d1605 66
a1670 2
;Ursula change:
;monitor keys no longer checked (archaic)
a1671 2
        
; ***
d1676 13
d1691 5
d1713 1
d1727 1
d1732 1
a1732 1
;
d1736 6
a1741 2
        TEQ     r1,#IOMD_7500     :AND: &FF
        MOVEQ   r0,#&7500
d1743 1
a1743 1
        TEQ     r1,#IOMD_7500FE   :AND: &FF
d1745 1
a1745 1
        ORREQ   r0,r0,#&0001                ; 7500FE - mark as 7501
d1747 2
a1748 4
        TEQ     r1,#IOMD_Original :AND: &FF
        TEQNE   r1,#IOMD_IOMD2    :AND: &FF
        BNE     Processor_Type              ; deliberate panic hang up
        ReadCop  R0,CR_ID                   ; see data sheets for values
d1769 1
a1769 1
; ***
d1771 6
d1779 2
a1780 5
KeypadStar_key  * -92
Shift_key       *  -1

75
        Pull    "R0"               ;junk kbd there flag (we may not have been able to tell if kbd there)
d1782 1
a1782 1
;now look for keypad * (goto supervisor) and shift (toggle boot/noboot)
d1784 2
a1785 7
        MOV     r3, #0
        LDR     r3, [r3, #MetroGnome]
 [ RunningOnEmul
        ADD     r3,r3,#1
 |
        ADD     r3,r3,#50                      ; Hang about for a little while
 ]
a1786 19
        MOV     r1, #0
        STR     r1, [sp]                       ;clear shift flag (on stack)
lookforstarorshift
        MOV     r1, #KeypadStar_key :AND: &FF
        BL      IsKeyPressedAtReset
        Pull    "r1", EQ                       ;junk shift flag
        BEQ     DoStartSuper        
        MOV     r1, #Shift_key :AND: &FF
        BL      IsKeyPressedAtReset
        MOVEQ   r1, #&FF
        STREQ   r1, [sp]                       ;set shift flag (on stack) (but still wait to see *)
        MOV     r0, #0
        LDR     r0, [r0, #MetroGnome]
        CMP     r0, r3
        BLO     lookforstarorshift

dobootoption
; Deal with SHIFT pressed/SHIFT-BREAK configured:
; do appropriate FSControl if wanted
d1793 1
a1793 1
        Pull    "R1"                    ; this is the shift flag, from stack
d1799 1
d1815 23
a1838 1
80
d1864 10
@


4.3.2.8
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d17 1
a17 5
DuffEntry     * 31*1024*1024+32*1024    ; Never any memory at this address (Nowhere)

T0Ticker100Hz * 20000-1                 ; Timer delay for Timer0 (units of 0.5 microsecond)
                                        ; 20000*0.5E-6 = 0.01 Seconds (100Hz ticker)
                                        ; TMD 21-May-93: "-1" correction applied
d38 4
d46 2
d187 9
d197 2
a198 2
;this is set up to allow signalling of whole-screen colours during early kernel
;boot, by setting border colour
a199 1
        & &E0000402     ; CR: FIFO load 16 words, 1 bpp, ck/1, rclk
d208 20
a227 16
        & &80000310     ; HCR  = 92 + 45 + 0 + 640 + 0 + 16
        & &81000054     ; HSWR = 92
        & &82000080     ; HBSR = 92 + 45
        & &83000080     ; HDSR = 92 + 45 + 0
        & &84000300     ; HDER = 92 + 45 + 0 + 640
        & &85000300     ; HBER = 92 + 45 + 0 + 640 + 0
        & &86000080     ; HCSR = HDSR

        & &9000020B     ; VCR  = 2 + 32 + 0 + 480 + 0 + 11
        & &91000001     ; VSWR = 2
        & &92000021     ; VBSR = 2 + 32
        & &93000021     ; VDSR = 2 + 32 + 0
        & &94000020     ; VDER = VDSR -1 to disable sceeen DMA
        & &95000201     ; VBER = 2 + 32 + 0 + 480 + 0
        & &96000021     ; VCSR = VDSR
        & &97000021     ; VCER = VDSR
d231 6
a236 2
        & &C0051003     ; EREG = sep/inv sync, DACs on, ereg output ext lut
        & &D0000302     ; FSYNREG, clk = (3+1)/(2+1) * 24MHz = 32MHz  (don't try to run VCO too slow)
d239 2
a276 30
bangIOC_eh
        LDRB    r0, [r1,#IOMD_ID0]
        TEQ     r0, #IOMD_Original :AND: &FF
        TEQNE   r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BEQ     bangIOC_IOMD1
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     bangIOC_IOMD2
        B       bangIOC_eh                   ;deliberate panic hang up

;
; 2 bits per external interrupt (ei), ei0 to ei12 in bits 0,1 to 24,25
; 00 = active high, 01 = active low, 10 = +ve edge, 11 = -ve edge
;
IOMD2_IntLevelModes * &00956C15  ; correct modes for Phoebe assignment of interrupts
;
bangIOC_IOMD2
        LDR     r0, =IOMD2_IntLevelModes
        STR     r0, [r1,#IOMD2_INTLVL]
        MOV     r0, #-1
        STR     r0, [r1,#IOMD2_INTREQ]       ;clear any spurious level interrupts
        MOV     r0, #0
        STR     r0, [r1,#IOMD2_INTENBL]      ;no IRQs
        STRB    r0, [r1,#IOCFIQMSK]          ;no FIQs
        STR     r0, [r1,#IOMD2_DMAENBL]      ;no DMA interrupts

        B       bangIOC_common

bangIOC_IOMD1

d280 1
d282 1
d284 3
d288 1
d291 1
a291 1
bangIOC_common
d293 3
a295 1
; now bits to allow CMOS read/write : need timer
a296 1
        LDR     R0, =T0Ticker100Hz
a304 17
        ;now wait for about 1ms
        ; - on Phoebe, this is plenty of time for SDRAM to get its act together
        ;   after the precharge command issued during InitMEMC
        ; - on other machines it will do no harm
        ;
        MOV     R0, #1024*2           ; time delay of about 1 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
RAM_awakes
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     RAM_awakes            ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     RAM_awakes            ; loop if not finished

a306 2

vcofix_eh
d308 4
a311 9
        TEQ     R0, #IOMD_Original :AND: &FF
        TEQNE   R0, #IOMD_IOMD2    :AND: &FF
        BEQ     vcofix_notneeded
        TEQ     R0, #IOMD_7500     :AND: &FF
        TEQNE   R0, #IOMD_7500FE   :AND: &FF
        BEQ     vcofix_needed
        B       vcofix_eh                    ;deliberate panic hang up

vcofix_needed
d329 1
a329 1
vcofix_notneeded
d340 1
a340 1
   [ RunningOnEmul
d361 4
d367 2
d396 1
a401 1
  [ ARMSASupport
a405 1
  ]
d407 4
d417 1
a417 1
        BL      SoftCopyROM             ;automagically softload ROM into reserved space, if required
d419 13
d443 1
d445 1
d540 2
a541 2
        LDR     R1, [R1]
        STR     R1, [R0]
d563 1
d573 1
a573 14
  [ ARMSASupport
    [ ChocolateScreen
        ARM_read_ID R0
        AND     R0,R0,#&F                       ;revision field of id
        CMP     R0,#SA120minimumrev             ;revision number for introduction of SA-120 (has mini data cache)
        MOVLO   R0,#0
        MOVHS   R0,#ACS_MiniDataCache           ;flag presence of mini data cache
        ORR     R0,R0,#ACS_SCsuspend:OR:ACS_VSClazy_DEFAULT
      [ :LNOT: IOMD2_VIDMRDbroken
        MOV     R1,#IOMD_Base
        LDR     R1,[R1,#IOMD_ID0]
        TEQ     R1,#IOMD_IOMD2 :AND: &FF        ;we only want to distinguish IOMD's that have VIDMRD here
        ORREQ   R0,R0,#ACS_HardVIDMRD           ;flag presence of h/w VIDMRD register    
      ]
d575 1
d577 1
a577 1
    ]
a584 1
  ] ;ARMSASupport
d587 4
d611 1
a611 1
    [ RunningOnEmul
d617 1
a617 19
kbd_eh
        MOV     r2,#IOMD_Base
        LDRB    r2,[r2,#IOMD_ID0]
        TEQ     r2,#IOMD_Original :AND: &FF
        TEQNE   r2,#IOMD_7500     :AND: &FF
        TEQNE   r2,#IOMD_7500FE   :AND: &FF
        BEQ     kbdwaitandcheck
        TEQ     r2,#IOMD_IOMD2    :AND: &FF
        BEQ     kbdpretend
        B       kbd_eh                        ;deliberate panic hang up
;
;on Phoebe, we can't see keyboard in kernel, so assume it is there
kbdpretend
        MOV     r5,#&FF
        MOV     r4,#InitKbdWs
        STRB    r5,[r4,#KB_There_Flag]
        B       kbdthere

kbdwaitandcheck
d631 1
d634 3
a636 3
 [ ValidateCMOS
; reset CMOS if its checksum is invalid
        MOV     R3, #-1                 ; do a full reset of CMOS if necessary
d639 63
d707 4
d712 1
a712 14
        ;Ursula change:
        ;power on always assumed (all resets now hard, no por_bit on IOMD2 anyway)
        MOV     R1, #por_bit

protection_check_eh
        MOV     r0, #IOMD_Base
        LDRB    r0, [r0, #IOMD_ID0]
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     Phoebe_check_CMOSreset
        TEQ     r0, #IOMD_Original :AND: &FF
        TEQNE   r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BNE     protection_check_eh            ;deliberate panic hang up

d725 1
a725 1
        B       protection_check_done
d727 4
a730 18
;Phoebe has no protection link visible via MonitorType
;Phoebe replaces keyboard DELETE with front panel volume buttons to force CMOS reset
;Check for both volume buttons pressed now, doing some debounce in s/w:
;   if pressed, and protection link absent, GIO bit 2 will read 0
;   if not pressed, GIO bit 2 reads 1
;   if protection link present, h/w is such that GIO bit 2 reads 1 regardless of buttons
;
Phoebe_check_CMOSreset
        MOV     r0, #IOMD_Base
        MOV     r3, #8*1024     ;this many reads at I/O speed to give some time for debounce
PhCMOS_debounce
        LDR     r1, [r0,#0]     ;IOCR register, GIO bits in bits 0..5
        TST     r1, #4
  [ PhoebeBodge
        MOVNE   r3,#-1          ;for FPGA board, reset CMOS if monitor lead not plugged in
        BNE     cmos_reset      ;(GIO bit 2 was proposed monitor id bit on these boards)
  |
        MOVEQ   r3,#-1          ;if 0 at any time during debounce, do CMOS reset
d732 1
a732 5
  ]
        SUBS    r3,r3,#1
        BNE     PhCMOS_debounce
;
protection_check_done
d739 4
d752 2
d757 1
d760 1
a760 1

a761 1
        SetBorder  R0, R1, 15, 0, 0     ; flash the border red as CMOS reset warning
d763 1
d766 3
a768 1

d784 1
d786 1
a786 1

d792 24
d819 3
d825 2
d829 6
d836 2
a837 1
        MOV     R1, #MonitorTypeAuto :OR: Sync_Auto
d840 1
a840 1
mousetype_eh
d842 2
d845 5
a849 7
        TEQ     r0, #IOMD_Original :AND: &FF
        BEQ     dont_program_mousetype            ;Risc PC has quadrature mouse
        TEQ     r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        TEQNE   r0, #IOMD_IOMD2    :AND: &FF
        BEQ     do_program_mousetype
        B       mousetype_eh                      ;deliberate panic hang up
d851 3
a853 2
do_program_mousetype
        ;PS2 mouse
d863 1
a865 13

check_sound_eh
        MOV     r0, #IOMD_Base
        LDRB    r0, [r0, #IOMD_ID0]
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     Config16BitSound             ;Phoebe has no SoundsystemLink, does have 16bit sound
        TEQ     r0, #IOMD_Original :AND: &FF
        TEQNE   r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BEQ     check_sound_link
        B       check_sound_eh               ;deliberate panic hang up

check_sound_link
d905 22
d953 1
d955 2
d988 11
a998 4

  [ KeepCachesOff
        =       SystemSpeedCMOS,(0:SHL:0):OR:(0:SHL:1):OR:(1:SHL:2):OR:(0:SHL:3):OR:(1:SHL:4):OR:(1:SHL:5):OR:(1:SHL:6):OR:(0:SHL:7)
  |
a999 1
  ]
d1005 1
a1005 1
                              ;                                                                  Cache off/on
d1008 1
d1010 1
d1014 5
d1023 1
a1176 7
  [ PhoebeBodge
    ;bodge to give phoebe-style 1M granularity regardless of SCdisable (for beta ROM on ARM6/7 Risc PC)
        MOV     r2,#&100000
        SUB     r2,r2,#1
        ADD     r0,r0,r2
        BIC     r0,r0,r2 
  ]
d1252 1
a1252 1
        MOV     r5, #128*1024*1024      ; Limit maximum size to 128MB until we produce a machine after Phoebe
d1307 4
a1310 3
        ;Ursula change:
        ;power on always assumed (all resets now hard, no por_bit on IOMD2 anyway)
        MOVS    R1, #por_bit
d1312 1
d1334 1
a1334 1
; copy appropriate IRQ handler for platform's IOMD: not done with rest of copying
a1335 19
;
  ASSERT IOMD_DefaultIRQ1Vcode     = IOMD_NoInterrupt+4
  ASSERT IOMD_DefaultIRQ1Vcode_end = IOMD_NoInterrupt+8
  ASSERT IOMD_Devices              = IOMD_NoInterrupt+12
;
resetp1d_eh
        MOV     R0, #IOMD_Base
        LDRB    R1, [R0, #IOMD_ID0]
  [ IOMD1Support
        TEQ     R1, #IOMD_Original :AND: &FF
        TEQNE   R1, #IOMD_7500     :AND: &FF
        TEQNE   R1, #IOMD_7500FE   :AND: &FF
        BEQ     resetp1d_IOMD1
  ]
  [ IOMD2Support
        TEQ     R1, #IOMD_IOMD2    :AND: &FF
        BEQ     resetp1d_IOMD2
  ]
        B       resetp1d_eh        ;deliberate panic hang up
a1336 29
  [ IOMD1Support

resetp1d_IOMD1
        LDR     R0, =IOMD_NoInterrupt
        MOV     R1, #IOMD1_NoInterrupt
        STR     R1, [R0]
        ADRL    R1, IOMD1_Devices
        STR     R1, [R0,#12]
        ADRL    R1, IOMD1_DefaultIRQ1Vcode
        STR     R1, [R0,#4]
        ADRL    R2, IOMD1_DefaultIRQ1Vcode_end
        STR     R2, [R0,#8]
        LDR     R0, =DefaultIRQ1V
        B       CopyDefaultIRQ1V

  ] ; IOMD1Support

  [ IOMD2Support

resetp1d_IOMD2
        LDR     R0, =IOMD_NoInterrupt
        MOV     R1, #IOMD2_NoInterrupt
        STR     R1, [R0]
        ADRL    R1, IOMD2_Devices
        STR     R1, [R0,#12]
        ADRL    R1, IOMD2_DefaultIRQ1Vcode
        STR     R1, [R0,#4]
        ADRL    R2, IOMD2_DefaultIRQ1Vcode_end
        STR     R2, [R0,#8]
d1338 2
a1339 3

  ] ;IOMD2Support
;
d1376 1
a1382 1
  [ ARMSASupport
d1387 2
a1388 3
        LDR     r0, =DefaultIRQ1V
        LDR     r1, =DefIRQ1Vspace   ;max size of code on any IOMD variant
        ADD     r1, r1, r0
a1393 1
  ] ;ARMSASupport
d1395 4
a1402 9
;change provoked by problem on Phoebe:
;make sure soft copies of VIDINIT etc are sensible, to avoid temporary
;programming of silly values
        LDR     r1,[r0,#VideoPhysAddr]
        STR     r1,[r0,#VInitSoftCopy]
        STR     r1,[r0,#VStartSoftCopy]
        ADD     r1,r1,#1024*1024-4096
        STR     r1,[r0,#VEndSoftCopy]

d1425 1
d1428 1
a1428 22

  [ DebugROMInit
        SWI     XOS_WriteS
        =       "Ursula kernel",13,10,0
        ALIGN
  ]

  [ PhoebeBodge_Slow
    ;Temporary code
    ;If running on IOMD2, fudge T0 to give correct 100Hz timing for slower FPGA/ASIC
    ;(as opposed to final target of 64 MHz ASIC)
    ;
Fudge_100Hz * 15000-1              ; normal value is 20000(-1), this is scaled by 48/64 for 48 MHz
        MOV     r0,#IOMD_Base
        LDRB    r1,[r0,#IOMD_ID0]
        TEQ     r1,#IOMD_IOMD2 :AND: &FF
        MOVEQ   r1,#Fudge_100Hz :AND: &FF
        STREQB  r1,[r0,#Timer0LL]
        MOVEQ   r1,#Fudge_100Hz :SHR: 8
        STREQB  r1,[r0,#Timer0LH]
        STREQB  r1,[r0,#Timer0GO]
  ]
d1495 1
a1495 1

d1497 1
a1497 1

d1513 1
d1515 1
a1523 8

        Push    "r0"
        LDR     r0, =&508
        SWI     XOS_Memory              ; returns amount of soft ROM (pages) in r1
        MOVVS   r1, #0
        Pull    "r0"
        ADD     r0, r0, r1, LSR #(8)    ; convert pages to MB and add in
   
d1531 2
d1534 4
d1548 2
d1605 66
a1670 2
;Ursula change:
;monitor keys no longer checked (archaic)
a1671 2
        
; ***
d1676 13
d1691 5
d1713 1
d1727 1
d1732 1
a1732 1
;
d1736 6
a1741 2
        TEQ     r1,#IOMD_7500     :AND: &FF
        MOVEQ   r0,#&7500
d1743 1
a1743 1
        TEQ     r1,#IOMD_7500FE   :AND: &FF
d1745 1
a1745 1
        ORREQ   r0,r0,#&0001                ; 7500FE - mark as 7501
d1747 2
a1748 4
        TEQ     r1,#IOMD_Original :AND: &FF
        TEQNE   r1,#IOMD_IOMD2    :AND: &FF
        BNE     Processor_Type              ; deliberate panic hang up
        ReadCop  R0,CR_ID                   ; see data sheets for values
d1769 1
a1769 1
; ***
d1771 6
d1779 2
a1780 5
KeypadStar_key  * -92
Shift_key       *  -1

75
        Pull    "R0"               ;junk kbd there flag (we may not have been able to tell if kbd there)
d1782 1
a1782 1
;now look for keypad * (goto supervisor) and shift (toggle boot/noboot)
d1784 2
a1785 7
        MOV     r3, #0
        LDR     r3, [r3, #MetroGnome]
 [ RunningOnEmul
        ADD     r3,r3,#1
 |
        ADD     r3,r3,#50                      ; Hang about for a little while
 ]
a1786 19
        MOV     r1, #0
        STR     r1, [sp]                       ;clear shift flag (on stack)
lookforstarorshift
        MOV     r1, #KeypadStar_key :AND: &FF
        BL      IsKeyPressedAtReset
        Pull    "r1", EQ                       ;junk shift flag
        BEQ     DoStartSuper        
        MOV     r1, #Shift_key :AND: &FF
        BL      IsKeyPressedAtReset
        MOVEQ   r1, #&FF
        STREQ   r1, [sp]                       ;set shift flag (on stack) (but still wait to see *)
        MOV     r0, #0
        LDR     r0, [r0, #MetroGnome]
        CMP     r0, r3
        BLO     lookforstarorshift

dobootoption
; Deal with SHIFT pressed/SHIFT-BREAK configured:
; do appropriate FSControl if wanted
d1793 1
a1793 1
        Pull    "R1"                    ; this is the shift flag, from stack
d1799 1
d1815 23
a1838 1
80
d1864 10
@


4.2
log
@Kernel merged
@
text
@d297 3
d301 1
d344 3
d348 1
d511 27
d696 3
d898 3
d1151 1
a1151 1
        CMP     R0, #&98
d1266 1
a1266 1
        =       YearCMOS,       95      ; changed from 93 to 95 on 12-Jan-95 to fix MED-04318
d2094 3
d2193 3
a2195 1

d2408 6
d2422 5
d2428 5
d2443 16
d2464 3
@


4.1
log
@Initial revision
@
text
@d39 1
d41 6
d511 4
d516 1
d616 1
d618 4
d644 19
d709 10
d818 7
a824 2
        LDR     R1, [R1]
        STR     R1, [R0]
d844 17
d868 5
a872 2

KeyWait *       200000                  ; 1/5 sec wait (in microseconds)
d891 71
d984 7
d996 1
d998 1
d1017 4
d1048 25
d1076 3
d1082 2
d1099 10
d1114 1
d1169 22
d1252 1
d1262 11
d1274 6
d1282 1
d1287 1
d1966 6
d2034 21
d2083 1
d2086 1
d2096 1
d2098 1
d2123 5
d2134 5
d2143 5
d2169 1
d2171 1
d2197 19
a2215 1
        MOV     r0, #0                  ; Set DomainId to 0 every reset
d2231 2
d2235 1
d2263 3
d2267 1
d2307 1
d2309 1
d2320 1
d2343 31
a2373 1
        ALIGN
d2379 24
d2454 3
d2458 1
d2499 1
d2510 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a818 69
 [ ValidateCMOS
; Do a POR if some super-critical values are shagged or if checksum is invalid.
        MOV	R3, #-1                 ; do all RAM if we do any
        BL      ValChecksum             ; Always check the checksum
        BNE	cmos_reset

; ScreenSizeCMOS, RAMDiscCMOS, SysHeapCMOS, RMASizeCMOS and SpriteSizeCMOS
; should be 0. Happily they are at consecutive addresses so we can loop through
; them.
	MOV	R1, #ScreenSizeCMOS
reset_loop
	MOV	R0, R1
	BL	Read
	TEQ	R0, #0
	BNE	cmos_reset
	INC	R1
	TEQ	R1, #SpriteSizeCMOS
	BHI	reset_loop

; FontCMOS should be <= 32 (128K)
	MOV	R0, #FontCMOS
	BL	Read
	CMP	R0, #32
	BHI	cmos_reset

	MOV	R0, #VduCMOS
	BL	Read
 [ IOMD_C_MonitorType = 0
; Force TV if we don't have a MonitorType auto-detect bit
	TEQ	R0, #(Sync_Separate :OR: MonitorType0)
 |
; Force auto-detect of monitor stuff if we have a MonitorType auto-detect bit
	TEQ	R0, #(Sync_Auto :OR: MonitorTypeAuto)
 ]
	BNE	cmos_reset

; Year should be >=1995, <=2020
; (2020 is arbitrary, but everything breaks soon after that)
	MOV	R0, #YearCMOS+1
	BL	Read
	TEQ	R0, #19
	BNE	check20

; 20th century: year should be 95 to 99
	MOV	R0, #YearCMOS
	BL	Read
	CMP	r0,#95
	BLT	cmos_reset
	CMP	r0,#99
	BHI	cmos_reset
	B	checkboot

check20
	TEQ	R0, #20
	BNE	cmos_reset

; 21st century: year should <= 20
	MOV	R0, #YearCMOS
	BL	Read
	CMP	R0, #20
	BHI	cmos_reset

checkboot
; Bit 4 of DBTBCMOS should be 1 (Boot)
	MOV	R0, #DBTBCMOS
	BL	Read
	TEQ	R0, #(1:SHL:4)
	BNE	cmos_reset
 ]
a841 7
 [ IOMD_C_FrontPanelButton <> 0
        MOV     r0, #IOMD_Base          ; if front panel button pressed then CMOS reset
        LDRB    r0, [r0, #IOMD_CLINES]
        TST     r0, #IOMD_C_FrontPanelButton
        BEQ     cmos_reset
 ]

d847 1
a865 2
cmos_reset
        ADD     sp, sp, #4              ; junk CannotReset flag from stack
a868 1
        ADD     sp, sp, #4              ; junk CannotReset flag from stack
a892 25

 [ IOMD_C_PALNTSCType <> 0
        MOV     r4, #IOMD_Base          ; configure territory, country and timezone based on PAL/NTSC bit
        LDRB    r4, [r4, #IOMD_CLINES]
        MOV     r0, #TerritoryCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #0                  ; PAL = territory UK
        MOVNE   r1, #49                 ; NTSC = territory USA
        BL      Write
        MOV     r0, #CountryCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #1                  ; PAL = country UK
        MOVNE   r1, #48                 ; NTSC = country USA
        BL      Write
        MOV     r0, #TimeZoneCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #0                  ; PAL = 0 from UTC (GMT)
        MOVNE   r1, #&E0                ; NTSC = -8 hours from UTC (USA Pacific)
        BL      Write
        MOV     r0, #MiscellaneousNCCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #0                  ; PAL = A4 paper size
        MOVNE   r1, #1                  ; NTSC = US letter paper size
        BL      Write
 |
a895 3
 ]

 [ :LNOT: STB
a898 1
 ]
a913 10
  [ {TRUE} ; cope with ARM7500FE
; Change test around so if not IOMD_Original, do the code,
; rather than checking for ARM7500 (which would exclude ARM7500FE)
	LDRB	r0, [r8, #IOMD_ID0]
	LDRB	r1, [r8, #IOMD_ID1]
	ORR	r0, r0, r1, LSL #8
	LDR	r1, =IOMD_Original
	TEQ	r0, r1
	BEQ	dont_program_mousetype
  |
a918 1
  ]
d927 1
a927 1
; set print and sound CMOS (16bit sound). We set this differently on STBs
a972 22
 [ ValidateCMOS
DefaultCMOSTable ; list of non-zero options wanted :
; byte pairs of offset, value
; terminated by offset &FF
        =       KeyDelCMOS,             32
        =       KeyRepCMOS,             8
        =       MODETVCMOS,             &10                                     ; TV 0,1
        =       StartCMOS,	        (2:SHL:3)				; NOCAPS
        =       DBTBCMOS,	        (1:SHL:4)				; Boot
        =       YearCMOS,               96
        =       YearCMOS+1,             19
  [ IOMD_C_MonitorType = 0
; TV if we don't have a MonitorType auto-detect bit
	=	VduCMOS,	        Sync_Separate :OR: MonitorType0
  |
; auto-detect if we have a MonitorType auto-detect bit
	=	VduCMOS,	        Sync_Auto :OR: MonitorTypeAuto
  ]
        =       MouseStepCMOS,          2
	=	DesktopFeaturesCMOS,	desktopfeaturebit_3D :OR: (8:SHL:1)	; 3D, Homerton
	=       ModemTimeoutCMOS,       10                                      ; 5 minutes
 | ;ValidateCMOS
a1048 1
 ] ;ValidateCMOS
d1718 1
a1718 1
 [ International
d1722 1
a1722 1
 ]
d1727 1
a1727 6
        STRNEB  R1, [R0, #IOCIRQCLRA]   		; clear POR if set

	MOV	R0, #0
	MOV	R1, R1, LSR #4
	STRB	R1, [R0, #ResetType]			; Save POR state in workspace (bit 0 of ResetType)

d1817 1
a1817 1
      [ DoInitialiseMode
d1820 1
a1820 1
      ]
d1884 1
a1884 1
    [ DoInitialiseMode
a1885 1
     [ :LNOT: STB                      ; don't print stuff on STB type products
a1910 2
     ]
    ]
a1926 2
 [ SoftResets
        ! 0, "!!!! SoftReset is true => resets close all open files !!!!"
d1929 1
a1929 2
 ]
 
a1995 1
    [ DoInitialiseMode
a1996 1

a2006 1
    ]
a2126 1
     [ :LNOT: STB
a2136 1
     ]
@


4.1.7.2
log
@Changed to use build options to select video clock source.
@
text
@d289 2
a290 10
; Now depending upon the VIDCClockSource flag, re-program the clock source.
   [ VIDCClockSource = "VCO"
        & &E0000400     ; CR: FIFO load 16 words, 1 bpp, ck/1, vclk(VCO)
   ]
   [ VIDCClockSource = "HCLK"
        & &E0000401     ; CR: FIFO load 16 words, 1 bpp, ck/1, hclk
   ]
   [ VIDCClockSource = "RCLK"
        & &E0000402     ; CR: FIFO load 16 words, 1 bpp, ck/1, rclk
   ]
d320 1
a320 1
  | ;Simulator
d322 2
a323 2
  ] ;Simulator
 | ;MEMC_Type <> "IOMD"
d325 1
a325 1
 ] ;MEMC_Tupe = "IOMD"
d336 1
a336 1
 | ;VIDC_Type<>"VIDC20"
d380 1
a380 1
 ] ;VIDC_Type = "VIDC20"
d2081 1
a2081 1

@


4.1.7.3
log
@Set the last reset was CMOS reset bit again (seems to have been lost
somewhere along the way).
@
text
@d1108 1
a1108 1
        =       YearCMOS,               97
d1118 2
a1119 4
        =       SystemSpeedCMOS,	(1:SHL:2):OR:(1:SHL:4):OR:(0:SHL:5)
                                      ; Delete-etc reset
                                      ;              WimpMode auto
                                      ;                           Cache on
@


4.1.7.4
log
@Make last reset type reflect the true state of the last reset (power-on or
hard - soft resets still disabled).
@
text
@a1883 4

        ; Make the choice between PowerOn and Hard reset based purely on
        ; the state of the POR bit and NOT on whether memory was cleared.
 [ {FALSE}
a1886 1
 ]
@


4.1.7.5
log
@Switched out front panel button comos reset for Customer F
@
text
@a919 1
  [ FrontPanelButtClearsCMOS
a923 1
  ]      
@


4.1.7.6
log
@Makefile modified to use LocalRes$Path.
Kernel no longer assumes CMOS is corrupt if FontSize > 128K.
@
text
@a845 1
 [ {FALSE}
a846 2
; What on earth was this about? Why would anyone require FontSize to
; be less than 128K?
a850 1
 ]
d925 1
a925 1
  ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a818 69
 [ ValidateCMOS
; Do a POR if some super-critical values are shagged or if checksum is invalid.
        MOV	R3, #-1                 ; do all RAM if we do any
        BL      ValChecksum             ; Always check the checksum
        BNE	cmos_reset

; ScreenSizeCMOS, RAMDiscCMOS, SysHeapCMOS, RMASizeCMOS and SpriteSizeCMOS
; should be 0. Happily they are at consecutive addresses so we can loop through
; them.
	MOV	R1, #ScreenSizeCMOS
reset_loop
	MOV	R0, R1
	BL	Read
	TEQ	R0, #0
	BNE	cmos_reset
	INC	R1
	TEQ	R1, #SpriteSizeCMOS
	BHI	reset_loop

; FontCMOS should be <= 32 (128K)
	MOV	R0, #FontCMOS
	BL	Read
	CMP	R0, #32
	BHI	cmos_reset

	MOV	R0, #VduCMOS
	BL	Read
 [ IOMD_C_MonitorType = 0 :LAND: MPEGPoduleNTSCNotPALMask = 0
; Force TV if we don't have a MonitorType auto-detect bit
	TEQ	R0, #(Sync_Separate :OR: MonitorType0)
 |
; Force auto-detect of monitor stuff if we have a MonitorType auto-detect bit
	TEQ	R0, #(Sync_Auto :OR: MonitorTypeAuto)
 ]
	BNE	cmos_reset

; Year should be >=1995, <=2020
; (2020 is arbitrary, but everything breaks soon after that)
	MOV	R0, #YearCMOS+1
	BL	Read
	TEQ	R0, #19
	BNE	check20

; 20th century: year should be 95 to 99
	MOV	R0, #YearCMOS
	BL	Read
	CMP	r0,#95
	BLT	cmos_reset
	CMP	r0,#99
	BHI	cmos_reset
	B	checkboot

check20
	TEQ	R0, #20
	BNE	cmos_reset

; 21st century: year should <= 20
	MOV	R0, #YearCMOS
	BL	Read
	CMP	R0, #20
	BHI	cmos_reset

checkboot
; Bit 4 of DBTBCMOS should be 1 (Boot)
	MOV	R0, #DBTBCMOS
	BL	Read
	TEQ	R0, #(1:SHL:4)
	BNE	cmos_reset
 ]
a841 7
 [ IOMD_C_FrontPanelButton <> 0
        MOV     r0, #IOMD_Base          ; if front panel button pressed then CMOS reset
        LDRB    r0, [r0, #IOMD_CLINES]
        TST     r0, #IOMD_C_FrontPanelButton
        BEQ     cmos_reset
 ]

d847 1
a865 2
cmos_reset
        ADD     sp, sp, #4              ; junk CannotReset flag from stack
a868 1
        ADD     sp, sp, #4              ; junk CannotReset flag from stack
a892 25

 [ IOMD_C_PALNTSCType <> 0
        MOV     r4, #IOMD_Base          ; configure territory, country and timezone based on PAL/NTSC bit
        LDRB    r4, [r4, #IOMD_CLINES]
        MOV     r0, #TerritoryCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #0                  ; PAL = territory UK
        MOVNE   r1, #49                 ; NTSC = territory USA
        BL      Write
        MOV     r0, #CountryCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #1                  ; PAL = country UK
        MOVNE   r1, #48                 ; NTSC = country USA
        BL      Write
        MOV     r0, #TimeZoneCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #0                  ; PAL = 0 from UTC (GMT)
        MOVNE   r1, #&E0                ; NTSC = -8 hours from UTC (USA Pacific)
        BL      Write
        MOV     r0, #MiscellaneousNCCMOS
        TST     r4, #IOMD_C_PALNTSCType
        MOVEQ   r1, #0                  ; PAL = A4 paper size
        MOVNE   r1, #1                  ; NTSC = US letter paper size
        BL      Write
 |
a895 3
 ]

 [ :LNOT: STB
a898 1
 ]
a913 10
  [ {TRUE} ; cope with ARM7500FE
; Change test around so if not IOMD_Original, do the code,
; rather than checking for ARM7500 (which would exclude ARM7500FE)
	LDRB	r0, [r8, #IOMD_ID0]
	LDRB	r1, [r8, #IOMD_ID1]
	ORR	r0, r0, r1, LSL #8
	LDR	r1, =IOMD_Original
	TEQ	r0, r1
	BEQ	dont_program_mousetype
  |
a918 1
  ]
d927 1
a927 1
; set print and sound CMOS (16bit sound). We set this differently on STBs
a972 22
 [ ValidateCMOS
DefaultCMOSTable ; list of non-zero options wanted :
; byte pairs of offset, value
; terminated by offset &FF
        =       KeyDelCMOS,             32
        =       KeyRepCMOS,             8
        =       MODETVCMOS,             &10                                     ; TV 0,1
        =       StartCMOS,	        (2:SHL:3)				; NOCAPS
        =       DBTBCMOS,	        (1:SHL:4)				; Boot
        =       YearCMOS,               96
        =       YearCMOS+1,             19
  [ IOMD_C_MonitorType = 0
; TV if we don't have a MonitorType auto-detect bit
	=	VduCMOS,	        Sync_Separate :OR: MonitorType0
  |
; auto-detect if we have a MonitorType auto-detect bit
	=	VduCMOS,	        Sync_Auto :OR: MonitorTypeAuto
  ]
        =       MouseStepCMOS,          2
	=	DesktopFeaturesCMOS,	desktopfeaturebit_3D :OR: (8:SHL:1)	; 3D, Homerton
	=       ModemTimeoutCMOS,       10                                      ; 5 minutes
 | ;ValidateCMOS
a1048 1
 ] ;ValidateCMOS
d1718 1
a1718 1
 [ International
d1722 1
a1722 1
 ]
d1727 1
a1727 6
        STRNEB  R1, [R0, #IOCIRQCLRA]   		; clear POR if set

	MOV	R0, #0
	MOV	R1, R1, LSR #4
	STRB	R1, [R0, #ResetType]			; Save POR state in workspace (bit 0 of ResetType)

d1817 1
a1817 1
      [ DoInitialiseMode
d1820 1
a1820 1
      ]
d1884 1
a1884 1
    [ DoInitialiseMode
a1885 1
     [ :LNOT: STB                      ; don't print stuff on STB type products
a1910 2
     ]
    ]
a1926 2
 [ SoftResets
        ! 0, "!!!! SoftReset is true => resets close all open files !!!!"
a1928 1
 ]
a1995 1
    [ DoInitialiseMode
a1996 1

a2006 1
    ]
a2126 1
     [ :LNOT: STB
a2136 1
     ]
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d39 1
a39 4
Port2Present    # 1
Port3Present    # 1
UnusedByte3     # 1
UnusedByte4     # 1
a503 4
   [ RunningOnEmul
        MOV     R7,#&80
        ORR     R7,R7,#&3E00            ; r7 := &3E80 = 16000 (standard Risc PC value)
   |
a504 1
   ]
d604 1
a604 2
        STRB    R1, [R0, #Port2Present]
        STRB    R1, [R0, #Port3Present]
a626 19

 [ StrongARM
   ;for StrongARM, we need to do an IMB type thing for modifying code in vector area
        ARM_read_ID r1
        AND     r1,r1,#&F000
        CMP     r1,#&A000
        BNE     vectorpoke_notSA_1
        MOV     r1,#0                   ;we clean one cache entry, 0..1F, = vector area
  [ SAcleanflushbroken
        ARMA_clean_DCentry r1
        ARMA_flush_DCentry r1
  |
        ARMA_cleanflush_DCentry r1
  ]
        ARMA_drain_WB
        ARMA_flush_IC
vectorpoke_notSA_1
 ]

a672 10
 [ StrongARM
        BL      Processor_Type          ; Determines the processor type & stores it in page 0.
 ]

;StrongARM: OK, there is quite a bit of code poking below, to various addresses. We'll
;           defer IMB consideration till the poking's done, then do a full IMB (full
;           data cache clean). This avoids various little IMB's and removes chance of leaving
;           some unnoticed poked code in data cache. The deferral should be safe, because none
;           of the poked code will be used yet awhile (given that current IRQ hardware vector is 
;           not actually changed below).
d772 2
a773 2
        LDR     R2, [R1], #4
        STR     R2, [R0], #4
a792 17
;StrongARM: OK, that completes the poking around, some of which is code. Now let's
;           do a full IMB type thing, to be safe (if we're running on StrongARM)
  [ StrongARM
        ARM_read_ID R0
        AND     R0,R0,#&F000
        CMP     R0,#&A000
        BNE     afterpokingaround_notSA
        MOV     R1,#0
        STRB    R1,[R1,#SyncCodeA_sema]    ;initialise semaphore to 0
        MOV     R1,#ARMA_Cleaner_flipflop
        LDR     R0,=ARMA_Cleaners_address  ;note: we are initialising ARMA_Cleaner_flipflop here
        STR     R0,[R1]
        ARMA_clean_DC R0,R1,R2
        ARMA_drain_WB
        ARMA_flush_IC
afterpokingaround_notSA
  ]
d800 2
a801 5
    [ RunningOnEmul
KeyWait *       1 
    |
KeyWait * 200000                 ; 1/5 sec wait (in microseconds)
    ]
d1034 2
a1035 2
        =       SystemSpeedCMOS,(0:SHL:0):OR:(0:SHL:1):OR:(1:SHL:2):OR:(0:SHL:3):OR:(1:SHL:4):OR:(0:SHL:5):OR:(1:SHL:6):OR:(0:SHL:7)
                              ;  AUN BootNet Disabled
d1044 2
a1045 3
        =       FontMaxCMOS,    64      ; 256k
        =       FontMax2CMOS,   &28     ; 36 point
        =       FontMax3CMOS,   &3C     ; 36 point
a1789 21
 [ StrongARM
   ;for StrongARM, we need to do an IMB type thing for modifying code in vector area, and
   ;for copying irq handler code
        ARM_read_ID r1
        AND     r1,r1,#&F000
        CMP     r1,#&A000
        BNE     furtherpoke_notSA
   ;first, we clean one cache entry, 0..1F, = vector area
        MOV     r1,#0                   
        ARMA_clean_DCentry r1
   ;next, we clean DefaultIRQ1V code area
        LDR     r0,=DefaultIRQ1V
        ADD     r1,r0,#(DefaultIRQ1Vcode_end - DefaultIRQ1Vcode)
        ARMA_clean_DCrange r0,r1
   ;and then we synch IC
        ARMA_drain_WB
        ARMA_flush_IC
        MOV     r0,#0    ;restore r0 as zero base
furtherpoke_notSA
 ]

a1828 1
        BL      L1L2PTenhancements      ; little tricks on cacheability etc for performance
a1829 1
        BL      AMBControl_Init         ; initialise AMBControl section
a1853 5
  [ DebugROMInit
        SWI     XOS_WriteS
        =       "Service_PostInit",0
        SWI     XOS_NewLine
  ]
a1859 5
  [ DebugROMInit
        SWI     XOS_WriteS
        =       "callbacks",0
        SWI     XOS_NewLine
  ]
a1863 5
  [ DebugROMInit
        SWI     XOS_WriteS
        =       "EnterOS!",0
        SWI     XOS_NewLine
  ]
d1911 1
a1911 13

 [ StrongARM
        ;Print the processor type
        MOV     r0, #0
        LDRB    r0, [r0, #ProcessorType]
        TEQ     r0, #255
        BEQ     %FT01
        ADR     r1, processor_names
        ADD     r0, r1, r0, LSL #5
        SWI     XOS_Write0
 ]

01      MOV     r0, #0                  ; Set DomainId to 0 every reset
a1955 3
 [ RunningOnEmul
        ADD     r3,r3,#1
        |
a1956 1
 ]
d2029 1
a2029 28
        ALIGN 32

 [ StrongARM
processor_names
        DCB     "ARM 600 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 610 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 700 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 710 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 810 Processor",10,13,10,0
        ALIGN 32
        DCB     "StrongARM Processor",10,13,10,0
        ALIGN 32

        ; type, internal type, features
cputable
        DCD &6000,0,0
        DCD &6100,1,0
        DCD &7000,2,0
        DCD &7100,3,0
        DCD &8100,4,2_11101
        DCD &a100,5,2_11111
        DCD -1
 ]

a2034 24
 [ StrongARM
Processor_Type
        ReadCop  R0,CR_ID               ; see data sheets for values
        ; ARM 600 funny
        TST     R0,#&f000
        MOVEQ   R0,R0, LSL #4
        AND     R0,R0,#&ff00
        ADR     R1,cputable
66
        LDR     R2,[R1],#4
        TEQ     R2,#0
        MOVMI   R0,#0
        STRMIB  R2,[R0,#ProcessorType]
        MOVMI   PC,LR
        TEQ     R2,R0
        ADDNE   R1,R1,#8
        BNE     %BT66
        LDMIA   R1,{R0,R2}
        MOV     R1,#0
        STRB    R0,[R1,#ProcessorType]
        STRB    R2,[R1,#ProcessorFlags]
        MOV     PC,LR
 ]

a2085 3
 [ RunningOnEmul
        ADD     r3,r3,#1
        |
a2086 1
 ]
@


4.1.3.2
log
@RISC OS 3.71 version taken
@
text
@a292 3
   [ VCOstartfix
        & &E0000404     ; CR: FIFO load 16 words, 1 bpp, ck/2, vclk (allow for doubled VCO freq)
   |
a293 1
   ]
a335 3
   [ VCOstartfix
        & &D0000302     ; FSYNREG, clk = (3+1)/(2+1) * 24MHz = 32MHz  (higher frequency as part of fix)
   |
a336 1
   ]
a498 27
  [ VCOstartfix
        ;2nd part of fix for VCO failing to start on A7000 (esp. 7500FE) - forcing PCOMP high for about 3 ms
        LDRB    R0, [R1,#IOMD_ID0]
        CMP     R0, #&E7
        LDREQB  R0, [R1,#IOMD_ID1]
        CMPEQ   R0, #&D4
        BEQ     vcofix_notMorris      ; risky to force PCOMP on Risc PC
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000342        ; VIDC20 FSYNREG, as in VIDCTAB but with force PCOMP high
        STR     R2, [R0]
        MOV     R0, #3072*2           ; time delay of about 3 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
vcofix_waitloop
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     vcofix_waitloop       ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     vcofix_waitloop       ; loop if not finished
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000302        ; VIDC20 FSYNREG, as in VIDCTAB (PCOMP low again)
        STR     R2, [R0]
vcofix_notMorris
  ]

a652 3
    [ ARM810support
        ARM8_branchpredict_flush  ;IMB on ARM810, and harmless on other ARMs
    ]
d709 1
a709 1
;           of the poked code will be used yet awhile (given that current IRQ hardware vector is
a846 3
    [ ARM810support
        ARM8_branchpredict_flush  ;IMB on ARM810, and harmless on other ARMs
    ]
d856 1
a856 1
KeyWait *       1
d877 1
d973 1
a973 1
        CMP     R0, #&E7
d975 2
a976 2
        CMPEQ   r0, #&D4
        BEQ     dont_program_mousetype  ; IOMD (not Morris)
d1065 1
a1065 1
        =       YearCMOS,       97      ; changed from 95 to 97 on 02-Jan-97
d1857 1
a1857 1
        MOV     r1,#0
a1867 3
    [ ARM810support
        ARM8_branchpredict_flush  ;IMB on ARM810, and harmless on other ARMs
    ]
d1962 1
a1962 3
  [ RO371Timings
        BL      finalmemoryspeed
  ]
d2158 1
a2158 6
 [ MorrisIDString
        DCB     "ARM 7500 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 7500FE Processor",10,13,10,0
        ALIGN 32
 ]
a2165 5
 [ {TRUE}
   ;corrected for 3.71 (SA does not abort for vector reads in 26-bit mode)
        DCD &a100,5,2_11011
 |
   ;value for 3.70
a2166 5
 ]
 [ MorrisIDString
        DCD &7500,6,0
        DCD &7501,7,0
 ]
a2176 16
   [ MorrisIDString
        MOV     r0,#IOMD_Base
        LDRB    r1,[r0,#IOMD_ID0]
        CMP     r1,#&E7
        LDRB    r1,[r0,#IOMD_ID1]
        CMPEQ   r1,#&D4
        BEQ     PT_RiscPC               ; E7,D4 means Risc PC
        CMP     r1,#&5B
        MOVEQ   r0,#&7500               ; 5B means 7500
        BEQ     PT_lookup
        CMP     r1,#&AA
        MOVEQ   r0,#&7500
        ORREQ   r0,r0,#&0001            ; AA means 7500FE - mark as 7501
        BEQ     PT_lookup
PT_RiscPC
   ]
a2181 3
   [ MorrisIDString
PT_lookup
   ]
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@a292 3
   [ VCOstartfix
        & &E0000404     ; CR: FIFO load 16 words, 1 bpp, ck/2, vclk (allow for doubled VCO freq)
   |
a293 1
   ]
a335 3
   [ VCOstartfix
        & &D0000302     ; FSYNREG, clk = (3+1)/(2+1) * 24MHz = 32MHz  (higher frequency as part of fix)
   |
a336 1
   ]
a498 27
  [ VCOstartfix
        ;2nd part of fix for VCO failing to start on A7000 (esp. 7500FE) - forcing PCOMP high for about 3 ms
        LDRB    R0, [R1,#IOMD_ID0]
        CMP     R0, #&E7
        LDREQB  R0, [R1,#IOMD_ID1]
        CMPEQ   R0, #&D4
        BEQ     vcofix_notMorris      ; risky to force PCOMP on Risc PC
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000342        ; VIDC20 FSYNREG, as in VIDCTAB but with force PCOMP high
        STR     R2, [R0]
        MOV     R0, #3072*2           ; time delay of about 3 ms (0.5 us units)
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R2, [R1, #Timer0CL]   ; R2 := low output latch
vcofix_waitloop
        STRB    R0, [R1, #Timer0LR]   ; copy counter into output latch
        LDRB    R3, [R1, #Timer0CL]   ; R3 := low output latch
        TEQ     R3, R2                ; unchanged ?
        BEQ     vcofix_waitloop       ; then loop
        MOV     R2, R3                ; copy anyway
        SUBS    R0, R0, #1            ; decrement count
        BNE     vcofix_waitloop       ; loop if not finished
        MOV     R0, #VIDCPhys
        LDR     R2, =&D0000302        ; VIDC20 FSYNREG, as in VIDCTAB (PCOMP low again)
        STR     R2, [R0]
vcofix_notMorris
  ]

a652 3
    [ ARM810support
        ARM8_branchpredict_flush  ;IMB on ARM810, and harmless on other ARMs
    ]
d709 1
a709 1
;           of the poked code will be used yet awhile (given that current IRQ hardware vector is
a846 3
    [ ARM810support
        ARM8_branchpredict_flush  ;IMB on ARM810, and harmless on other ARMs
    ]
d856 1
a856 1
KeyWait *       1
d877 1
d973 1
a973 1
        CMP     R0, #&E7
d975 2
a976 2
        CMPEQ   r0, #&D4
        BEQ     dont_program_mousetype  ; IOMD (not Morris)
d1065 1
a1065 1
        =       YearCMOS,       97      ; changed from 95 to 97 on 02-Jan-97
d1857 1
a1857 1
        MOV     r1,#0
a1867 3
    [ ARM810support
        ARM8_branchpredict_flush  ;IMB on ARM810, and harmless on other ARMs
    ]
d1962 1
a1962 3
  [ RO371Timings
        BL      finalmemoryspeed
  ]
d2158 1
a2158 6
 [ MorrisIDString
        DCB     "ARM 7500 Processor",10,13,10,0
        ALIGN 32
        DCB     "ARM 7500FE Processor",10,13,10,0
        ALIGN 32
 ]
a2165 5
 [ {TRUE}
   ;corrected for 3.71 (SA does not abort for vector reads in 26-bit mode)
        DCD &a100,5,2_11011
 |
   ;value for 3.70
a2166 5
 ]
 [ MorrisIDString
        DCD &7500,6,0
        DCD &7501,7,0
 ]
a2176 16
   [ MorrisIDString
        MOV     r0,#IOMD_Base
        LDRB    r1,[r0,#IOMD_ID0]
        CMP     r1,#&E7
        LDRB    r1,[r0,#IOMD_ID1]
        CMPEQ   r1,#&D4
        BEQ     PT_RiscPC               ; E7,D4 means Risc PC
        CMP     r1,#&5B
        MOVEQ   r0,#&7500               ; 5B means 7500
        BEQ     PT_lookup
        CMP     r1,#&AA
        MOVEQ   r0,#&7500
        ORREQ   r0,r0,#&0001            ; AA means 7500FE - mark as 7501
        BEQ     PT_lookup
PT_RiscPC
   ]
a2181 3
   [ MorrisIDString
PT_lookup
   ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

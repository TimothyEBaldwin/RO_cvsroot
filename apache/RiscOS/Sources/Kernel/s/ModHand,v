head	4.19;
access;
symbols
	Kernel-6_15:4.19
	Kernel-6_14:4.19
	Kernel-6_01-3:4.19
	Kernel-6_13:4.19
	Kernel-6_12:4.19
	Kernel-6_11:4.19
	Kernel-6_10:4.19
	Kernel-6_09:4.19
	Kernel-6_08-4_129_2_10:4.17.2.2
	Kernel-6_08-4_129_2_9:4.17.2.2
	Kernel-6_08:4.19
	Kernel-6_07:4.19
	Kernel-6_06:4.19
	Kernel-6_05-4_129_2_8:4.17.2.2
	Kernel-6_05:4.19
	Kernel-6_04:4.19
	Kernel-6_03:4.19
	Kernel-6_01-2:4.19
	Kernel-6_01-4_146_2_1:4.19
	Kernel-6_02:4.19
	Kernel-6_01-1:4.19
	Kernel-6_01:4.19
	Kernel-6_00:4.19
	Kernel-5_99:4.19
	Kernel-5_98:4.19
	Kernel-5_97-4_129_2_7:4.17.2.2
	Kernel-5_97:4.19
	Kernel-5_96:4.19
	Kernel-5_95:4.19
	Kernel-5_94:4.19
	Kernel-5_93:4.19
	Kernel-5_92:4.18
	Kernel-5_91:4.18
	Kernel-5_90:4.18
	Kernel-5_89-4_129_2_6:4.17.2.1
	Kernel-5_89:4.18
	Kernel-5_88-4_129_2_5:4.17
	Kernel-5_88-4_129_2_4:4.17
	Kernel-5_88:4.17
	Kernel-5_87:4.17
	Kernel-5_86-4_129_2_3:4.17
	Kernel-5_86-4_129_2_2:4.17
	Kernel-5_86-4_129_2_1:4.17
	Kernel-5_86:4.17
	SMP:4.17.0.2
	SMP_bp:4.17
	Kernel-5_85:4.17
	Kernel-5_54-1:4.16
	Kernel-5_84:4.17
	Kernel-5_83:4.17
	Kernel-5_82:4.17
	Kernel-5_81:4.17
	Kernel-5_80:4.17
	Kernel-5_79:4.17
	Kernel-5_78:4.17
	Kernel-5_77:4.17
	Kernel-5_76:4.17
	Kernel-5_75:4.17
	Kernel-5_74:4.17
	Kernel-5_73:4.17
	Kernel-5_72:4.17
	Kernel-5_71:4.17
	Kernel-5_70:4.17
	Kernel-5_69:4.17
	Kernel-5_68:4.17
	Kernel-5_67:4.17
	Kernel-5_66:4.17
	Kernel-5_65:4.17
	Kernel-5_64:4.17
	Kernel-5_63:4.16
	Kernel-5_62:4.16
	Kernel-5_61:4.16
	Kernel-5_60:4.16
	Kernel-5_59:4.16
	Kernel-5_58:4.16
	Kernel-5_57:4.16
	Kernel-5_56:4.16
	Kernel-5_55:4.16
	Kernel-5_54:4.16
	Kernel-5_53:4.15
	Kernel-5_52:4.15
	Kernel-5_51:4.15
	Kernel-5_50:4.14
	Kernel-5_49:4.14
	HAL_merge:4.11.2.13
	Kernel-5_48:4.13
	Kernel-5_35-4_79_2_327:4.11.2.13
	Kernel-5_35-4_79_2_326:4.11.2.13
	Kernel-5_35-4_79_2_325:4.11.2.13
	Kernel-5_35-4_79_2_324:4.11.2.13
	Kernel-5_35-4_79_2_323:4.11.2.13
	Kernel-5_35-4_79_2_322:4.11.2.13
	Kernel-5_35-4_79_2_321:4.11.2.13
	Kernel-5_35-4_79_2_320:4.11.2.13
	Kernel-5_35-4_79_2_319:4.11.2.13
	Kernel-5_35-4_79_2_318:4.11.2.13
	Kernel-5_35-4_79_2_317:4.11.2.13
	Kernel-5_35-4_79_2_316:4.11.2.13
	Kernel-5_35-4_79_2_315:4.11.2.13
	Kernel-5_35-4_79_2_314:4.11.2.13
	Kernel-5_35-4_79_2_313:4.11.2.13
	Kernel-5_35-4_79_2_312:4.11.2.13
	Kernel-5_35-4_79_2_311:4.11.2.13
	Kernel-5_35-4_79_2_310:4.11.2.13
	Kernel-5_35-4_79_2_309:4.11.2.13
	Kernel-5_35-4_79_2_308:4.11.2.13
	Kernel-5_35-4_79_2_307:4.11.2.13
	Kernel-5_35-4_79_2_306:4.11.2.13
	Kernel-5_35-4_79_2_305:4.11.2.13
	Kernel-5_35-4_79_2_304:4.11.2.13
	Kernel-5_35-4_79_2_303:4.11.2.13
	Kernel-5_35-4_79_2_302:4.11.2.13
	Kernel-5_35-4_79_2_301:4.11.2.13
	Kernel-5_35-4_79_2_300:4.11.2.13
	Kernel-5_35-4_79_2_299:4.11.2.13
	Kernel-5_35-4_79_2_298:4.11.2.13
	Kernel-5_35-4_79_2_297:4.11.2.13
	Kernel-5_35-4_79_2_296:4.11.2.13
	Kernel-5_35-4_79_2_295:4.11.2.13
	Kernel-5_35-4_79_2_294:4.11.2.13
	Kernel-5_35-4_79_2_293:4.11.2.13
	Kernel-5_35-4_79_2_292:4.11.2.13
	Kernel-5_35-4_79_2_291:4.11.2.13
	Kernel-5_35-4_79_2_290:4.11.2.13
	Kernel-5_35-4_79_2_289:4.11.2.13
	Kernel-5_35-4_79_2_288:4.11.2.13
	Kernel-5_35-4_79_2_287:4.11.2.13
	Kernel-5_35-4_79_2_286:4.11.2.13
	Kernel-5_35-4_79_2_285:4.11.2.13
	Kernel-5_35-4_79_2_284:4.11.2.13
	Kernel-5_35-4_79_2_283:4.11.2.13
	Kernel-5_35-4_79_2_282:4.11.2.13
	Kernel-5_35-4_79_2_281:4.11.2.13
	Kernel-5_35-4_79_2_280:4.11.2.13
	Kernel-5_35-4_79_2_279:4.11.2.13
	Kernel-5_35-4_79_2_278:4.11.2.13
	Kernel-5_35-4_79_2_277:4.11.2.13
	Kernel-5_35-4_79_2_276:4.11.2.13
	Kernel-5_35-4_79_2_275:4.11.2.13
	Kernel-5_35-4_79_2_274:4.11.2.13
	Kernel-5_35-4_79_2_273:4.11.2.13
	Kernel-5_35-4_79_2_272:4.11.2.13
	Kernel-5_35-4_79_2_271:4.11.2.13
	Kernel-5_35-4_79_2_270:4.11.2.13
	Kernel-5_35-4_79_2_269:4.11.2.13
	Kernel-5_35-4_79_2_268:4.11.2.13
	Kernel-5_35-4_79_2_267:4.11.2.13
	Kernel-5_35-4_79_2_266:4.11.2.13
	Kernel-5_35-4_79_2_265:4.11.2.13
	Kernel-5_35-4_79_2_264:4.11.2.13
	Kernel-5_35-4_79_2_263:4.11.2.13
	Kernel-5_35-4_79_2_262:4.11.2.13
	Kernel-5_35-4_79_2_261:4.11.2.13
	Kernel-5_35-4_79_2_260:4.11.2.13
	Kernel-5_35-4_79_2_259:4.11.2.13
	Kernel-5_35-4_79_2_258:4.11.2.13
	Kernel-5_35-4_79_2_257:4.11.2.13
	Kernel-5_35-4_79_2_256:4.11.2.13
	Kernel-5_35-4_79_2_255:4.11.2.13
	Kernel-5_35-4_79_2_254:4.11.2.13
	Kernel-5_35-4_79_2_253:4.11.2.13
	Kernel-5_35-4_79_2_252:4.11.2.13
	Kernel-5_35-4_79_2_251:4.11.2.13
	Kernel-5_35-4_79_2_250:4.11.2.13
	Kernel-5_35-4_79_2_249:4.11.2.13
	Kernel-5_35-4_79_2_248:4.11.2.13
	Kernel-5_35-4_79_2_247:4.11.2.13
	Kernel-5_35-4_79_2_246:4.11.2.13
	Kernel-5_35-4_79_2_245:4.11.2.13
	Kernel-5_35-4_79_2_244:4.11.2.13
	Kernel-5_35-4_79_2_243:4.11.2.13
	Kernel-5_35-4_79_2_242:4.11.2.13
	Kernel-5_35-4_79_2_241:4.11.2.13
	Kernel-5_35-4_79_2_240:4.11.2.13
	Kernel-5_35-4_79_2_239:4.11.2.13
	Kernel-5_35-4_79_2_238:4.11.2.13
	Kernel-5_35-4_79_2_237:4.11.2.13
	Kernel-5_35-4_79_2_236:4.11.2.13
	Kernel-5_35-4_79_2_235:4.11.2.13
	Kernel-5_35-4_79_2_234:4.11.2.13
	Kernel-5_35-4_79_2_233:4.11.2.13
	Kernel-5_35-4_79_2_232:4.11.2.13
	Kernel-5_35-4_79_2_231:4.11.2.13
	Kernel-5_35-4_79_2_230:4.11.2.13
	Kernel-5_35-4_79_2_229:4.11.2.13
	Kernel-5_35-4_79_2_228:4.11.2.13
	Kernel-5_35-4_79_2_227:4.11.2.13
	Kernel-5_35-4_79_2_226:4.11.2.13
	Kernel-5_35-4_79_2_225:4.11.2.13
	Kernel-5_35-4_79_2_224:4.11.2.13
	Kernel-5_35-4_79_2_223:4.11.2.13
	Kernel-5_35-4_79_2_222:4.11.2.13
	Kernel-5_35-4_79_2_221:4.11.2.13
	Kernel-5_35-4_79_2_220:4.11.2.13
	Kernel-5_35-4_79_2_219:4.11.2.13
	Kernel-5_35-4_79_2_218:4.11.2.13
	Kernel-5_35-4_79_2_217:4.11.2.13
	Kernel-5_35-4_79_2_216:4.11.2.13
	Kernel-5_35-4_79_2_215:4.11.2.13
	Kernel-5_35-4_79_2_214:4.11.2.13
	Kernel-5_35-4_79_2_213:4.11.2.13
	Kernel-5_35-4_79_2_212:4.11.2.13
	Kernel-5_35-4_79_2_211:4.11.2.13
	Kernel-5_35-4_79_2_210:4.11.2.13
	Kernel-5_35-4_79_2_209:4.11.2.13
	Kernel-5_35-4_79_2_208:4.11.2.13
	Kernel-5_35-4_79_2_207:4.11.2.13
	Kernel-5_35-4_79_2_206:4.11.2.13
	Kernel-5_35-4_79_2_205:4.11.2.13
	Kernel-5_35-4_79_2_204:4.11.2.13
	Kernel-5_35-4_79_2_203:4.11.2.13
	Kernel-5_35-4_79_2_202:4.11.2.13
	Kernel-5_35-4_79_2_201:4.11.2.13
	Kernel-5_35-4_79_2_200:4.11.2.13
	Kernel-5_35-4_79_2_199:4.11.2.13
	Kernel-5_35-4_79_2_198:4.11.2.13
	Kernel-5_35-4_79_2_197:4.11.2.13
	Kernel-5_35-4_79_2_196:4.11.2.13
	Kernel-5_35-4_79_2_195:4.11.2.13
	Kernel-5_35-4_79_2_194:4.11.2.13
	Kernel-5_35-4_79_2_193:4.11.2.13
	Kernel-5_35-4_79_2_192:4.11.2.13
	Kernel-5_35-4_79_2_191:4.11.2.13
	Kernel-5_35-4_79_2_190:4.11.2.13
	Kernel-5_35-4_79_2_189:4.11.2.13
	Kernel-5_35-4_79_2_188:4.11.2.13
	Kernel-5_35-4_79_2_187:4.11.2.13
	Kernel-5_35-4_79_2_186:4.11.2.13
	Kernel-5_35-4_79_2_185:4.11.2.13
	Kernel-5_35-4_79_2_184:4.11.2.13
	Kernel-5_35-4_79_2_183:4.11.2.12
	Kernel-5_35-4_79_2_182:4.11.2.12
	Kernel-5_35-4_79_2_181:4.11.2.12
	Kernel-5_35-4_79_2_180:4.11.2.12
	Kernel-5_35-4_79_2_179:4.11.2.12
	Kernel-5_35-4_79_2_178:4.11.2.12
	Kernel-5_35-4_79_2_177:4.11.2.12
	Kernel-5_35-4_79_2_176:4.11.2.12
	Kernel-5_35-4_79_2_175:4.11.2.12
	Kernel-5_35-4_79_2_174:4.11.2.12
	Kernel-5_35-4_79_2_173:4.11.2.12
	Kernel-5_35-4_79_2_172:4.11.2.12
	Kernel-5_35-4_79_2_171:4.11.2.12
	Kernel-5_35-4_79_2_170:4.11.2.12
	Kernel-5_35-4_79_2_169:4.11.2.12
	Kernel-5_35-4_79_2_168:4.11.2.12
	Kernel-5_35-4_79_2_167:4.11.2.12
	Kernel-5_35-4_79_2_166:4.11.2.12
	Kernel-5_35-4_79_2_165:4.11.2.12
	RPi_merge:4.11.2.12
	Kernel-5_35-4_79_2_147_2_23:4.11.2.12
	Kernel-5_35-4_79_2_147_2_22:4.11.2.12
	Kernel-5_35-4_79_2_147_2_21:4.11.2.12
	Kernel-5_35-4_79_2_147_2_20:4.11.2.12
	Kernel-5_35-4_79_2_147_2_19:4.11.2.12
	Kernel-5_35-4_79_2_147_2_18:4.11.2.12
	Kernel-5_35-4_79_2_164:4.11.2.12
	Kernel-5_35-4_79_2_163:4.11.2.12
	Kernel-5_35-4_79_2_147_2_17:4.11.2.12
	Kernel-5_35-4_79_2_147_2_16:4.11.2.12
	Kernel-5_35-4_79_2_147_2_15:4.11.2.12
	Kernel-5_35-4_79_2_162:4.11.2.12
	Kernel-5_35-4_79_2_161:4.11.2.12
	Kernel-5_35-4_79_2_147_2_14:4.11.2.12
	Kernel-5_35-4_79_2_147_2_13:4.11.2.12
	Kernel-5_35-4_79_2_160:4.11.2.12
	Kernel-5_35-4_79_2_159:4.11.2.12
	Kernel-5_35-4_79_2_158:4.11.2.12
	Kernel-5_35-4_79_2_157:4.11.2.12
	Kernel-5_35-4_79_2_156:4.11.2.12
	Kernel-5_35-4_79_2_147_2_12:4.11.2.12
	Kernel-5_35-4_79_2_147_2_11:4.11.2.12
	Kernel-5_35-4_79_2_155:4.11.2.12
	Kernel-5_35-4_79_2_147_2_10:4.11.2.12
	Kernel-5_35-4_79_2_154:4.11.2.12
	Kernel-5_35-4_79_2_153:4.11.2.12
	Kernel-5_35-4_79_2_147_2_9:4.11.2.12
	Kernel-5_35-4_79_2_152:4.11.2.12
	Kernel-5_35-4_79_2_151:4.11.2.12
	Kernel-5_35-4_79_2_147_2_8:4.11.2.12
	Kernel-5_35-4_79_2_147_2_7:4.11.2.12
	Kernel-5_35-4_79_2_150:4.11.2.12
	Kernel-5_35-4_79_2_147_2_6:4.11.2.12
	Kernel-5_35-4_79_2_147_2_5:4.11.2.12
	Kernel-5_35-4_79_2_149:4.11.2.12
	Kernel-5_35-4_79_2_147_2_4:4.11.2.12
	Kernel-5_35-4_79_2_147_2_3:4.11.2.12
	Kernel-5_35-4_79_2_148:4.11.2.12
	Kernel-5_35-4_79_2_147_2_2:4.11.2.12
	Kernel-5_35-4_79_2_147_2_1:4.11.2.12
	RPi:4.11.2.12.0.2
	RPi_bp:4.11.2.12
	Kernel-5_35-4_79_2_98_2_52_2_1:4.11.2.8.2.1
	alees_Kernel_dev:4.11.2.8.2.1.0.2
	alees_Kernel_dev_bp:4.11.2.8.2.1
	Kernel-5_35-4_79_2_147:4.11.2.12
	Kernel-5_35-4_79_2_146:4.11.2.12
	Kernel-5_35-4_79_2_145:4.11.2.12
	Kernel-5_35-4_79_2_144:4.11.2.12
	Kernel-5_35-4_79_2_143:4.11.2.12
	Kernel-5_35-4_79_2_142:4.11.2.12
	Kernel-5_35-4_79_2_141:4.11.2.12
	Kernel-5_35-4_79_2_140:4.11.2.12
	Kernel-5_35-4_79_2_139:4.11.2.12
	Kernel-5_35-4_79_2_138:4.11.2.12
	Kernel-5_35-4_79_2_137:4.11.2.11
	Kernel-5_35-4_79_2_136:4.11.2.11
	Kernel-5_35-4_79_2_135:4.11.2.10
	Kernel-5_35-4_79_2_134:4.11.2.10
	Kernel-5_35-4_79_2_133:4.11.2.10
	Kernel-5_35-4_79_2_132:4.11.2.10
	Kernel-5_35-4_79_2_131:4.11.2.10
	Kernel-5_35-4_79_2_130:4.11.2.10
	Kernel-5_35-4_79_2_129:4.11.2.10
	Kernel-5_35-4_79_2_128:4.11.2.10
	Kernel-5_35-4_79_2_127:4.11.2.10
	Kernel-5_35-4_79_2_126:4.11.2.10
	Kernel-5_35-4_79_2_125:4.11.2.10
	Kernel-5_35-4_79_2_124:4.11.2.10
	Kernel-5_35-4_79_2_123:4.11.2.9
	Cortex_merge:4.11.2.8.2.1
	Kernel-5_35-4_79_2_122:4.11.2.8
	Kernel-5_35-4_79_2_98_2_54:4.11.2.8.2.1
	Kernel-5_35-4_79_2_98_2_53:4.11.2.8.2.1
	Kernel-5_35-4_79_2_98_2_52:4.11.2.8.2.1
	Kernel-5_35-4_79_2_98_2_51:4.11.2.8.2.1
	Kernel-5_35-4_79_2_98_2_50:4.11.2.8.2.1
	Kernel-5_35-4_79_2_98_2_49:4.11.2.8.2.1
	Kernel-5_35-4_79_2_98_2_48:4.11.2.8.2.1
	Kernel-5_35-4_79_2_121:4.11.2.8
	Kernel-5_35-4_79_2_98_2_47:4.11.2.8
	Kernel-5_35-4_79_2_120:4.11.2.8
	Kernel-5_35-4_79_2_98_2_46:4.11.2.8
	Kernel-5_35-4_79_2_119:4.11.2.8
	Kernel-5_35-4_79_2_98_2_45:4.11.2.8
	Kernel-5_35-4_79_2_98_2_44:4.11.2.8
	Kernel-5_35-4_79_2_118:4.11.2.8
	Kernel-5_35-4_79_2_98_2_43:4.11.2.8
	Kernel-5_35-4_79_2_117:4.11.2.8
	Kernel-5_35-4_79_2_116:4.11.2.8
	Kernel-5_35-4_79_2_98_2_42:4.11.2.8
	Kernel-5_35-4_79_2_115:4.11.2.8
	Kernel-5_35-4_79_2_98_2_41:4.11.2.8
	Kernel-5_35-4_79_2_98_2_40:4.11.2.8
	Kernel-5_35-4_79_2_114:4.11.2.8
	Kernel-5_35-4_79_2_98_2_39:4.11.2.8
	Kernel-5_35-4_79_2_98_2_38:4.11.2.8
	Kernel-5_35-4_79_2_113:4.11.2.8
	Kernel-5_35-4_79_2_112:4.11.2.8
	Kernel-5_35-4_79_2_98_2_37:4.11.2.8
	Kernel-5_35-4_79_2_98_2_36:4.11.2.8
	Kernel-5_35-4_79_2_98_2_35:4.11.2.8
	Kernel-5_35-4_79_2_98_2_34:4.11.2.8
	Kernel-5_35-4_79_2_98_2_33:4.11.2.8
	Kernel-5_35-4_79_2_98_2_32:4.11.2.8
	Kernel-5_35-4_79_2_98_2_31:4.11.2.8
	Kernel-5_35-4_79_2_98_2_30:4.11.2.8
	Kernel-5_35-4_79_2_98_2_29:4.11.2.8
	Kernel-5_35-4_79_2_98_2_28:4.11.2.8
	Kernel-5_35-4_79_2_98_2_27:4.11.2.8
	Kernel-5_35-4_79_2_98_2_26:4.11.2.8
	Kernel-5_35-4_79_2_111:4.11.2.8
	Kernel-5_35-4_79_2_98_2_25:4.11.2.8
	Kernel-5_35-4_79_2_98_2_24:4.11.2.8
	Kernel-5_35-4_79_2_98_2_23:4.11.2.8
	Kernel-5_35-4_79_2_110:4.11.2.8
	Kernel-5_35-4_79_2_98_2_22:4.11.2.8
	Kernel-5_35-4_79_2_109:4.11.2.8
	Kernel-5_35-4_79_2_98_2_21:4.11.2.8
	Kernel-5_35-4_79_2_98_2_20:4.11.2.8
	Kernel-5_35-4_79_2_108:4.11.2.8
	Kernel-5_35-4_79_2_107:4.11.2.8
	Kernel-5_35-4_79_2_98_2_19:4.11.2.8
	Kernel-5_35-4_79_2_98_2_18:4.11.2.8
	Kernel-5_35-4_79_2_98_2_17:4.11.2.8
	Kernel-5_35-4_79_2_98_2_16:4.11.2.8
	Kernel-5_35-4_79_2_98_2_15:4.11.2.8
	Kernel-5_35-4_79_2_106:4.11.2.8
	Kernel-5_35-4_79_2_105:4.11.2.8
	Kernel-5_35-4_79_2_104:4.11.2.8
	Kernel-5_35-4_79_2_98_2_14:4.11.2.8
	Kernel-5_35-4_79_2_98_2_13:4.11.2.8
	Kernel-5_35-4_79_2_98_2_12:4.11.2.8
	Kernel-5_35-4_79_2_98_2_11:4.11.2.8
	Kernel-5_35-4_79_2_98_2_10:4.11.2.8
	Kernel-5_35-4_79_2_98_2_9:4.11.2.8
	Kernel-5_35-4_79_2_103:4.11.2.8
	Kernel-5_35-4_79_2_102:4.11.2.8
	Kernel-5_35-4_79_2_98_2_8:4.11.2.8
	Kernel-5_35-4_79_2_98_2_7:4.11.2.8
	Kernel-5_35-4_79_2_98_2_6:4.11.2.8
	Kernel-5_35-4_79_2_98_2_5:4.11.2.8
	Kernel-5_35-4_79_2_98_2_4:4.11.2.8
	Kernel-5_35-4_79_2_101:4.11.2.8
	Kernel-5_35-4_79_2_100:4.11.2.8
	Kernel-5_35-4_79_2_99:4.11.2.8
	Kernel-5_35-4_79_2_98_2_3:4.11.2.8
	Kernel-5_35-4_79_2_98_2_2:4.11.2.8
	Kernel-5_35-4_79_2_98_2_1:4.11.2.8
	Cortex:4.11.2.8.0.2
	Cortex_bp:4.11.2.8
	Kernel-5_35-4_79_2_98:4.11.2.8
	Kernel-5_35-4_79_2_97:4.11.2.8
	Kernel-5_35-4_79_2_96:4.11.2.8
	Kernel-5_35-4_79_2_95:4.11.2.8
	Kernel-5_35-4_79_2_94:4.11.2.8
	Kernel-5_35-4_79_2_93:4.11.2.8
	Kernel-5_35-4_79_2_92:4.11.2.8
	Kernel-5_35-4_79_2_91:4.11.2.8
	Kernel-5_35-4_79_2_90:4.11.2.8
	Kernel-5_35-4_79_2_89:4.11.2.8
	Kernel-5_35-4_79_2_88:4.11.2.8
	Kernel-5_35-4_79_2_87:4.11.2.8
	Kernel-5_35-4_79_2_86:4.11.2.8
	Kernel-5_35-4_79_2_85:4.11.2.8
	Kernel-5_35-4_79_2_84:4.11.2.8
	Kernel-5_35-4_79_2_83:4.11.2.8
	Kernel-5_35-4_79_2_82:4.11.2.8
	Kernel-5_35-4_79_2_81:4.11.2.8
	Kernel-5_35-4_79_2_80:4.11.2.8
	Kernel-5_35-4_79_2_79:4.11.2.8
	Kernel-5_35-4_79_2_78:4.11.2.8
	Kernel-5_35-4_79_2_77:4.11.2.8
	RO_5_07:4.11.2.8
	Kernel-5_35-4_79_2_76:4.11.2.8
	Kernel-5_35-4_79_2_75:4.11.2.8
	Kernel-5_35-4_79_2_74:4.11.2.8
	Kernel-5_35-4_79_2_73:4.11.2.8
	Kernel-5_35-4_79_2_72:4.11.2.8
	Kernel-5_35-4_79_2_71:4.11.2.8
	Kernel-5_35-4_79_2_70:4.11.2.8
	Kernel-5_35-4_79_2_69:4.11.2.8
	Kernel-5_35-4_79_2_68:4.11.2.8
	Kernel-5_35-4_79_2_67:4.11.2.8
	Kernel-5_35-4_79_2_66:4.11.2.8
	Kernel-5_35-4_79_2_65:4.11.2.8
	Kernel-5_35-4_79_2_64:4.11.2.8
	Kernel-5_35-4_79_2_63:4.11.2.8
	Kernel-5_35-4_79_2_62:4.11.2.8
	Kernel-5_35-4_79_2_61:4.11.2.8
	Kernel-5_35-4_79_2_59:4.11.2.8
	Kernel-5_35-4_79_2_58:4.11.2.8
	Kernel-5_35-4_79_2_57:4.11.2.8
	Kernel-5_35-4_79_2_56:4.11.2.8
	Kernel-5_35-4_79_2_55:4.11.2.8
	Kernel-5_35-4_79_2_54:4.11.2.8
	Kernel-5_35-4_79_2_53:4.11.2.7
	Kernel-5_35-4_79_2_52:4.11.2.6
	Kernel-5_35-4_79_2_51:4.11.2.5
	Kernel-5_35-4_79_2_50:4.11.2.4
	Kernel-5_35-4_79_2_49:4.11.2.4
	Kernel-5_35-4_79_2_48:4.11.2.4
	Kernel-5_47:4.12
	Kernel-5_46-4_90_2_1:4.12
	nbingham_Kernel_FastNC_dev_bp:4.12
	nbingham_Kernel_FastNC_dev:4.12.0.2
	Kernel-5_46:4.12
	Kernel-5_45:4.12
	Kernel-5_35-4_79_2_47:4.11.2.3
	Kernel-5_35-4_79_2_46:4.11.2.3
	Kernel-5_35-4_79_2_45:4.11.2.3
	Kernel-5_35-4_79_2_44:4.11.2.3
	Kernel-5_35-4_79_2_25_2_2:4.11.2.2
	Kernel-5_35-4_79_2_43:4.11.2.3
	Kernel-5_35-4_79_2_42:4.11.2.3
	Kernel-5_35-4_79_2_41:4.11.2.3
	Kernel-5_35-4_79_2_40:4.11.2.3
	Kernel-5_35-4_79_2_39:4.11.2.3
	Kernel-5_35-4_79_2_38:4.11.2.3
	Kernel-5_35-4_79_2_37:4.11.2.2
	Kernel-5_35-4_79_2_36:4.11.2.2
	Kernel-5_35-4_79_2_35:4.11.2.2
	Kernel-5_35-4_79_2_34:4.11.2.2
	Kernel-5_35-4_79_2_33:4.11.2.2
	Kernel-5_35-4_79_2_32:4.11.2.2
	Kernel-5_44:4.12
	Kernel-5_35-4_79_2_25_2_1:4.11.2.2
	Kernel-5_43:4.12
	Kernel-5_35-4_79_2_31:4.11.2.2
	Kernel-5_35-4_79_2_30:4.11.2.2
	Kernel-5_35-4_79_2_29:4.11.2.2
	Kernel-5_35-4_79_2_28:4.11.2.2
	Kernel-5_35-4_79_2_27:4.11.2.2
	Kernel-5_35-4_79_2_26:4.11.2.2
	Kernel-5_42:4.12
	Kernel-5_41:4.12
	Kernel-5_40:4.12
	Kernel-5_35-4_79_2_25:4.11.2.2
	Kernel-5_35-4_79_2_24:4.11.2.2
	Kernel-5_35-4_79_2_23:4.11.2.2
	Kernel-5_35-4_79_2_22:4.11.2.2
	Kernel-5_35-4_79_2_21:4.11.2.2
	Kernel-5_35-4_79_2_20:4.11.2.2
	Kernel-5_35-4_79_2_19:4.11.2.2
	Kernel-5_35-4_79_2_18:4.11.2.2
	Kernel-5_35-4_79_2_17:4.11.2.2
	Kernel-5_35-4_79_2_16:4.11.2.2
	Kernel-5_35-4_79_2_15:4.11.2.2
	Kernel-5_35-4_79_2_14:4.11.2.2
	Kernel-5_39:4.12
	Kernel-5_13-4_52_2_1:4.9
	Bethany:4.9.0.2
	Kernel-5_38:4.12
	Kernel-5_35-4_79_2_13:4.11.2.2
	Kernel-5_35-4_79_2_12:4.11.2.2
	Kernel-5_35-4_79_2_11:4.11.2.2
	Kernel-5_37:4.11
	Kernel-5_35-4_79_2_10:4.11.2.2
	Kernel-5_35-4_79_2_9:4.11.2.1
	Kernel-5_36:4.11
	Kernel-5_35-4_79_2_8:4.11.2.1
	Kernel-5_35-4_79_2_7:4.11.2.1
	Kernel-5_35-4_79_2_6:4.11.2.1
	Kernel-5_35-4_79_2_5:4.11.2.1
	Kernel-5_35-4_79_2_4:4.11.2.1
	Kernel-5_35-4_79_2_3:4.11.2.1
	Kernel-5_35-4_79_2_2:4.11.2.1
	dellis_autobuild_BaseSW:4.11
	Kernel-5_35-4_79_2_1:4.11.2.1
	HAL:4.11.0.2
	Kernel-5_35:4.11
	Kernel-5_34:4.11
	Kernel-5_33:4.11
	Kernel-5_32:4.11
	Kernel-5_31:4.11
	Kernel-5_30:4.10
	Kernel-5_29:4.10
	Kernel-5_28:4.10
	Kernel-5_27:4.10
	Kernel-5_26:4.10
	Kernel-5_25:4.10
	Kernel-5_24:4.10
	Kernel-5_23:4.10
	Kernel-5_22:4.9
	sbrodie_sedwards_16Mar2000:4.9
	Kernel-5_21:4.9
	Kernel-5_20:4.9
	Kernel-5_19:4.9
	Kernel-5_18:4.9
	Kernel-5_17:4.9
	Kernel-5_16:4.9
	Kernel-5_15:4.9
	Kernel-5_14:4.9
	Kernel-5_13:4.9
	Kernel-5_12:4.9
	Kernel-5_11:4.9
	Kernel-5_10:4.9
	Kernel-5_09:4.9
	Kernel-5_08:4.9
	Kernel-5_07:4.9
	Kernel-5_06:4.9
	Kernel-5_05:4.9
	Kernel-5_04:4.9
	Kernel-5_03:4.9
	Kernel-5_02:4.9
	Kernel-5_01:4.9
	Kernel-5_00:4.9
	Kernel-4_99:4.9
	Kernel-4_98:4.9
	Kernel-4_97:4.9
	Kernel-4_96:4.9
	Kernel-4_95:4.9
	Kernel-4_94:4.9
	Kernel-4_93:4.9
	Kernel-4_92:4.9
	Kernel-4_91:4.9
	Kernel-4_90:4.9
	dcotton_autobuild_BaseSW:4.12
	Kernel-4_89:4.9
	Kernel-4_88:4.9
	Kernel-4_87:4.9
	Kernel-4_86:4.9
	Kernel-4_85:4.9
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.5.2.1
	Kernel-4_84:4.9
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.5.2.1
	Ursula_RiscPC_bp:4.2.2.5
	Kernel-4_83:4.8
	Kernel-4_82:4.7
	Kernel-4_81:4.7
	Kernel-4_80:4.5
	Kernel-4_79:4.4
	Kernel-4_78:4.3
	Kernel-4_77:4.3
	Kernel-4_76:4.3
	Kernel-4_75:4.3
	Kernel-4_74:4.3
	Kernel-4_73:4.3
	Kernel-4_72:4.3
	Kernel-4_71:4.3
	Kernel-4_70:4.3
	Kernel-4_69:4.3
	Kernel-4_68:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.5.2.1
	Ursula_RiscPC:4.2.2.5.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.3
	Kernel-4_66:4.3
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.3
	Ursula_merge:4.2.2.1
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.2.2.6
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.5
	UrsulaBuild_FinalSoftload:4.2.2.5
	rthornb_UrsulaBuild-12Aug1998:4.2.2.5
	aglover_UrsulaBuild-05Aug1998:4.2.2.5
	rthornb_UrsulaBuild-29Jul1998:4.2.2.5
	rthornb_UrsulaBuild-22Jul1998:4.2.2.5
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.5
	rthornb_UrsulaBuild-07Jul1998:4.2.2.5
	rthornb_UrsulaBuild-17Jun1998:4.2.2.5
	rthornb_UrsulaBuild-03Jun1998:4.2.2.5
	rthornb_UrsulaBuild-27May1998:4.2.2.5
	mstphens_Kernel-3_80:4.2.2.5
	rthornb_UrsulaBuild-21May1998:4.2.2.5
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.5
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.19
date	2017.12.08.18.40.50;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	NwON3hpAUNRMq7iA;

4.18
date	2017.09.09.10.35.42;	author rool;	state Exp;
branches;
next	4.17;
commitid	SuZJGVb4fAmIDv6A;

4.17
date	2016.11.25.20.51.41;	author rsprowson;	state Exp;
branches
	4.17.2.1;
next	4.16;
commitid	cFxyc5hHhs91jyvz;

4.16
date	2016.07.24.10.50.43;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	x4yCuRzf90zVXyfz;

4.15
date	2016.06.30.20.59.46;	author jlee;	state Exp;
branches;
next	4.14;
commitid	skOEjp3ipLHx6xcz;

4.14
date	2016.06.30.20.28.56;	author jlee;	state Exp;
branches;
next	4.13;
commitid	lMnWzoE9eJz3Wwcz;

4.13
date	2016.06.30.20.08.08;	author jlee;	state Exp;
branches;
next	4.12;
commitid	IWoXxARWeuLDOwcz;

4.12
date	2000.11.21.15.19.54;	author sbrodie;	state Exp;
branches;
next	4.11;

4.11
date	2000.08.15.16.47.24;	author sbrodie;	state Exp;
branches
	4.11.2.1;
next	4.10;

4.10
date	2000.04.04.14.27.31;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	99.08.19.10.52.32;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.08.17.11.16.22;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.08.03.17.05.09;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.08.03.09.59.06;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.05.12.15.14.51;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.05.07.12.30.42;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.10.01.07.42.44;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.07.12;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.21;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.17.2.1
date	2017.09.10.11.27.22;	author jlee;	state Exp;
branches;
next	4.17.2.2;
commitid	EGooxXrB27MqTD6A;

4.17.2.2
date	2018.02.16.00.01.40;	author jlee;	state Exp;
branches;
next	;
commitid	L7HYXYTsWSFlZ0rA;

4.11.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.11.2.2;

4.11.2.2
date	2000.10.16.11.55.38;	author kbracey;	state Exp;
branches;
next	4.11.2.3;

4.11.2.3
date	2001.06.18.14.49.45;	author mstephen;	state Exp;
branches;
next	4.11.2.4;

4.11.2.4
date	2002.10.07.17.29.41;	author kbracey;	state Exp;
branches;
next	4.11.2.5;

4.11.2.5
date	2002.11.30.00.31.08;	author bavison;	state Exp;
branches;
next	4.11.2.6;

4.11.2.6
date	2002.12.13.17.38.12;	author bavison;	state Exp;
branches;
next	4.11.2.7;

4.11.2.7
date	2002.12.18.22.18.32;	author bavison;	state Exp;
branches;
next	4.11.2.8;

4.11.2.8
date	2003.01.22.14.50.27;	author bavison;	state Exp;
branches
	4.11.2.8.2.1;
next	4.11.2.9;

4.11.2.9
date	2011.11.26.21.11.16;	author jlee;	state Exp;
branches;
next	4.11.2.10;
commitid	cI3W0zbtALQG6TIv;

4.11.2.10
date	2011.11.27.11.48.09;	author rsprowson;	state Exp;
branches;
next	4.11.2.11;
commitid	OFgqaKhOb6swXXIv;

4.11.2.11
date	2012.02.18.17.41.06;	author rsprowson;	state Exp;
branches;
next	4.11.2.12;
commitid	xM2EAuruYMDffFTv;

4.11.2.12
date	2012.02.25.16.19.37;	author jlee;	state Exp;
branches;
next	4.11.2.13;
commitid	ad3WnPntkzrizyUv;

4.11.2.13
date	2013.03.24.10.16.24;	author rsprowson;	state Exp;
branches;
next	;
commitid	UvakvUQoRMnwV1Jw;

4.11.2.8.2.1
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

4.2.2.1
date	97.05.23.13.06.53;	author kbracey;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.09.09.13.33.22;	author mstphens;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	97.12.08.14.34.32;	author mstphens;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	98.03.26.11.25.53;	author mstphens;	state Exp;
branches;
next	4.2.2.5;

4.2.2.5
date	98.04.14.11.23.55;	author mstphens;	state Exp;
branches
	4.2.2.5.2.1;
next	4.2.2.6;

4.2.2.6
date	98.09.24.13.17.17;	author mstphens;	state Exp;
branches;
next	;

4.2.2.5.2.1
date	98.11.23.14.59.16;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.21;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.38;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.22;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.43;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.19
log
@Unplug/RMInsert with podule module fix
During the first pass keyboard scan the ROM module nodes are built off the anchor ROMModuleChain.
During the second pass the whole set of ROM module nodes are temporarily constructed anchored on the stack, then switched over.
This caused a problem when a duplicate name module was encountered on a podule (eg. MbufManager in a NIC) because FindROMModule searches from the ROMModuleChain anchor, didn't find a match, so created a new node rather than linking it to the NewerVersion/OlderVersion linked list on the existing node.
Then *Unplug and *RMInsert would say "Module is not in ROM" if the optional podule specifier was given, because the search stopped at the first node with the right name.

Swap round the second pass so it anchors directly on ROMModuleChain, and keeps the first pass anchor on the stack (needed only occasionally to copy over details of modules already initialised).

Tested on a Risc PC with NIC, can now selectively unplug MbufManager again.

Version 5.93. Tagged as 'Kernel-5_93'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => ModHand - the Relocatable Module Handler

ExtraRMANeeded * 24*1024 ; Amount you get extra on top of what you configured


;mjs changes for Ursula  (ChocolateOSMod) - reduce stress on SysHeap
;
                     GBLL ModHand_IntrinsicBI
ModHand_IntrinsicBI  SETL {TRUE} :LAND: ChocolateOSMod  ;base module incarnation 'node' is in module node

                        GBLL ModHand_InitDieServices
ModHand_InitDieServices SETL {TRUE} :LAND: ModHand_IntrinsicBI

; The module handler needs to know the structure of the HPD, and nodes.
; See RMTidy in particular.

;**************************************************************
;
; Module chain structure: ModuleList points at a (singly-linked) list of
; nodes with following fields:

                        ^  0
Module_chain_Link       #  4    ; the link to the next module info block
Module_code_pointer     #  4    ; pointer to the module.
Module_Hardware         #  4    ; hardware base for podules; 0 for soft loaders
Module_incarnation_list #  4    ; pointer to list of incarnation specifiers
Module_ROMModuleNode    #  4    ; pointer to ROM module node if in ROM (main, podule, extn), else zero

ModInfo                 *  @@

; The incarnation list is a list of sub-nodes, one for each incarnation.

                        ^  0
Incarnation_Link        #  4   ; link to next incarnation
Incarnation_Workspace   #  4   ; 4 private bytes for this life
Incarnation_Postfix     #  0   ; postfix string starts here

; Incarnations are distinguished by their postfix, which is separated
; from the module name by a special character:

Postfix_Separator       *  "%"

;**************************************************************

; Handler initialisation.
; registers preserved

; ROM module descriptor format

                        ^       0
ROMModule_Link          #       4               ; pointer to next node
ROMModule_Name          #       4               ; pointer to module name (either directly in ROM, or in an RMA block)
ROMModule_BaseAddress   #       4               ; start of module, if directly accessible
ROMModule_Version       #       4               ; BCD version number, decimal point between bits 15,16 eg "1.23" => &00012300
ROMModule_PoduleNumber  #       4               ; podule number (0..8 = normal podule, -1 = main ROM, -2..-n = extension ROM)
ROMModule_ChunkNumber   #       4               ; chunk number if in podule or extension ROM, unused (?) if in main ROM
ROMModule_OlderVersion  #       4               ; pointer to node holding the next older version of this module, 0 if none
ROMModule_NewerVersion  #       4               ; pointer to node holding the next newer version of this module, 0 if none
ROMModule_CMOSAddrMask  #       4               ; CMOS address of frugal bit (bits 0..15) and bit mask (16..23)
                                                ; and 'initialised' flag in bit 24 (bits 25..31 = 0)
ROMModule_Initialised   *       ROMModule_CMOSAddrMask + 3
ROMModule_Size          #       4               ; size of module
ROMModule_NodeSize      #       0

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

UnplugCMOSTable                         ; in reverse order
        =       Unplug17CMOS
        =       Unplug16CMOS, Unplug15CMOS
        =       Unplug14CMOS, Unplug13CMOS
        =       Unplug12CMOS, Unplug11CMOS
        =       Unplug10CMOS, Unplug9CMOS
        =       Unplug8CMOS, Unplug7CMOS
        =       FrugalCMOS+1, FrugalCMOS+0
        =       MosROMFrugalCMOS+3, MosROMFrugalCMOS+2
        =       MosROMFrugalCMOS+1
UnplugCMOSTableEnd                      ; used for backwards indexing
        =       MosROMFrugalCMOS+0
        =       0
        ALIGN

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ModuleInitForKbdScan - Start subset of ROM modules for keyboard scan
;
; in:   r0 -> comma seperated list of ROM module names
;
; out:  All registers preserved
;

ModuleInitForKbdScan Entry "r0-r12"

        MOV     r0, #HeapReason_Init                    ; first initialise the heap
        MOV     r1, #RMAAddress
        LDR     r3, [r1, #:INDEX: hpdend]               ; saved for us during init.
        SWI     XOS_Heap

        ASSERT  ROMModule_Link = 0

        ADRL    r6, SysModules_Info+4

        LDR     r9, =ZeroPage+ROMModuleChain            ; pointer to 'previous' node
        MOV     r8, #0                                  ; initial head ptr is zero
        STR     r8, [r9]                                ; set up null list

        LDR     r0, [sp, #0*4]
        CMP     r0, #-1                                 ; no list?
        BNE     %FT10

; just init the podule manager - this must be the second module (ie the 1st after UtilityModule)

        LDR     r1, [r6, #-4]
        ADD     r1, r6, r1
        LDR     r14, [r1, #-4]
        TEQ     r14, #0
        MOVNE   r0, #ModHandReason_AddArea
        SWINE   XOS_Module
        EXIT

; now for each module in the main ROM needed for KbdScan, create a node for it
10
        MOV     r3, #-1                                 ; podule -1 is main ROM
        MOV     r10, #0                                 ; chunk number 0 to start
20
        LDR     r7, [r6, #-4]                           ; get size of this module
        TEQ     r7, #0                                  ; if zero
        BEQ     %FT50                                   ; then no more main rom modules

        LDR     r4, [r6, #Module_TitleStr]              ; r4 = offset to module name
        ADD     r4, r6, r4                              ; r4 -> module name
        LDR     r5, [r6, #Module_HelpStr]               ; r5 = help offset
        TEQ     r5, #0                                  ; if no help string
        ADDEQ   r5, r6, #Module_HelpStr                 ; then use help offset as string (null string)
        ADDNE   r5, r6, r5                              ; otherwise point to help string

        CMP     r10, #FirstUnpluggableModule            
        BCC     %FT30                                   ; unconditional since not unpluggable anyway

        LDR     r11, [sp, #0*4]
        BL      CompareTitleWithCSV
        BNE     %FT40                                   ; if your name's not on the list you can't come in
30
        ADR     r11, UnplugCMOSTable
        SUBS    r14, r10, #FirstUnpluggableModule       ; subtract number of first module that has an unplug bit
        MOVCS   r1, r14, LSR #3                         ; get byte number
        ANDCS   r14, r14, #7                            ; get bit number
        ADDCS   r14, r14, #16                           ; bit mask stored in bits 16 onwards
        RSBCSS  r1, r1, #(UnplugCMOSTableEnd-UnplugCMOSTable) ; invert table offset, and check in range
        LDRCSB  r11, [r11, r1]                          ; load table value if in range
        MOVCS   r12, #1
        ORRCS   r11, r11, r12, LSL r14                  ; merge with bit mask
        MOVCC   r11, #0                                 ; otherwise zero

        BL      AddROMModuleNode
        BVS     %FT50                                   ; if failed then can't add any more ROMs!
40
        MOV     r9, r2                                  ; this node is now previous one
        ADD     r6, r6, r7                              ; go on to next module
        ADD     r10, r10, #1                            ; chunk number +=1
        B       %BT20

; now start them
50
        LDR     r12, =ZeroPage+ROMModuleChain
        LDR     r12, [r12]
60
        TEQ     r12, #0                                 ; if no more modules
        BEQ     %FT90                                   ; then skip

        MOV     r11, r12                                ; start with current one
        BL      InitialiseROMModuleAtInit

        LDR     r12, [r12, #ROMModule_Link]
        B       %BT60
90
      [ DebugROMInit
        SWI     XOS_WriteS
        =       "mod init (kbdscan) done",0
        SWI     XOS_NewLine
      ]
        MOV     r1, #RMASizeCMOS
        MOV     r0, #ReadCMOS
        SWI     XOS_Byte
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #Page_Size]
        MUL     r3, r0, r2
        ADD     r3, r3, #ExtraRMANeeded
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        EXIT

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ModuleInit - Start the remaining ROM modules, checking podules and extension ROMs
;
; out:  All registers preserved
;

ModuleInit   Entry "r0-r12"

; now for each module in the main ROM, create a node for it

        ASSERT  ROMModule_Link = 0

        ADRL    r6, SysModules_Info+4

        LDR     r9, =ZeroPage+ROMModuleChain            ; pointer to 'previous' node
        LDR     r12, [r9]
        Push    "r12"                                   ; keep keyboard scan chain anchor
        MOV     r8, #0                                  ; initial head ptr is zero
        STR     r8, [r9]                                ; set up null list

        MOV     r3, #-1                                 ; podule -1 is main ROM
        MOV     r10, #0                                 ; chunk number 0 to start
10
        LDR     r7, [r6, #-4]                           ; get size of this module
        TEQ     r7, #0                                  ; if zero
        BEQ     %FT20                                   ; then no more main rom modules

        LDR     r4, [r6, #Module_TitleStr]              ; r4 = offset to module name
        ADD     r4, r6, r4                              ; r4 -> module name
        LDR     r5, [r6, #Module_HelpStr]               ; r5 = help offset
        TEQ     r5, #0                                  ; if no help string
        ADDEQ   r5, r6, #Module_HelpStr                 ; then use help offset as string (null string)
        ADDNE   r5, r6, r5                              ; otherwise point to help string

        ADR     r11, UnplugCMOSTable
        SUBS    r14, r10, #FirstUnpluggableModule       ; subtract number of first module that has an unplug bit
        MOVCS   r1, r14, LSR #3                         ; get byte number
        ANDCS   r14, r14, #7                            ; get bit number
        ADDCS   r14, r14, #16                           ; bit mask stored in bits 16 onwards
        RSBCSS  r1, r1, #(UnplugCMOSTableEnd-UnplugCMOSTable) ; invert table offset, and check in range
        LDRCSB  r11, [r11, r1]                          ; load table value if in range
        MOVCS   r12, #1
        ORRCS   r11, r11, r12, LSL r14                  ; merge with bit mask
        MOVCC   r11, #0                                 ; otherwise zero

        BL      AddROMModuleNode
        BVS     %FT50                                   ; if failed then can't add any more ROMs!

        LDR     r12, [sp, #0*4]                         ; keyboard scan chain may have seen this module
12
        TEQ     r12, #0
        BEQ     %FT18

        LDR     r5, [r12, #ROMModule_BaseAddress]
        LDR     r14, [r2, #ROMModule_BaseAddress]
        TEQ     r5, r14                                 ; for main ROM an address compare is sufficient
        BNE     %FT16

        MOV     r14, #1
        STRB    r14, [r2, #ROMModule_Initialised]       ; remember it's already done
        LDR     r11, =ZeroPage+Module_List
14
        LDR     r11, [r11, #Module_chain_Link]
        TEQ     r11, #0
        BEQ     %FT16

        LDR     r14, [r11, #Module_ROMModuleNode]
        TEQ     r12, r14
        STREQ   r2, [r11, #Module_ROMModuleNode]        ; point at newly created node
        BNE     %BT14
16
        LDR     r12, [r12, #ROMModule_Link]
        B       %BT12
18
        MOV     r9, r2                                  ; this node is now previous one
        ADD     r6, r6, r7                              ; go on to next module
        ADD     r10, r10, #1                            ; chunk number +=1
        B       %BT10

; now do podule ROMs

20
        MOV     r3, #0                                  ; start at podule 0
21
        MOV     r10, #0                                 ; for each podule start at chunk 0
        CMP     r3, #-1
        MOVGT   r12, #0                                 ; if real podule then start at CMOS bit number 0 for this podule
                                                        ; else carry on from where we're at
22
        MOV     r0, r10
        SWI     XPodule_EnumerateChunksWithInfo
        BVS     %FT40                                   ; bad podule or some such
        CMP     r0, #0                                  ; no more chunks?
        BEQ     %FT45                                   ; then step to next podule
        CMP     r2, #OSType_Module
        MOVNE   r10, r0
        BNE     %BT22

; now claim a block to copy module title into

        MOV     r7, r1                                  ; pass size in r7
        Push    "r0, r3, r4"
        MOV     r3, #0
23
        LDRB    r14, [r4, r3]                           ; find length of title string
        ADD     r3, r3, #1                              ; increment length (include zero at end)
        TEQ     r14, #0
        BNE     %BT23

        BL      ClaimSysHeapNode
        Pull    "r0, r3, r14"                           ; restore chunk no., podule no., old ptr to title
        BVS     %FT50                                   ; if error then no more ROMs (doesn't matter that error ptr is naff)

        MOV     r4, r2                                  ; save pointer to block
24
        LDRB    r1, [r14], #1                           ; now copy string into block
        STRB    r1, [r2], #1
        TEQ     r1, #0
        BNE     %BT24
        MOV     r14, #(1 :SHL: 16)                      ; bit mask ready to shift
        CMP     r3, #-1
        BLT     %FT30

; doing podule ROM

        ASSERT  ?PoduleFrugalCMOS = 8                   ; ensure we're using the correct Hdr:CMOS
        CMP     r12, #7                                 ; if bit number <= 7
        CMPLS   r3, #8                                  ; then if podule number <= 8
        ADDCC   r11, r3, #PoduleFrugalCMOS              ;      then use one of the 8 PoduleFrugalCMOS bytes
        MOVEQ   r11, #NetworkFrugalCMOS                 ;      elif podule number = 8 then use network card CMOS
        MOVHI   r11, #0                                 ; otherwise no CMOS
        ORRLS   r11, r11, r14, LSL r12                  ; OR in bit mask
        B       %FT36

; doing extension ROM
30
        CMP     r12, #16                                ; 2 bytes of CMOS for extension ROMs
        MOVCC   r1, #ExtnUnplug1CMOS                    ; form CMOS address in r1
        ADDCC   r1, r1, r12, LSR #3
        ANDCC   r11, r12, #7                            ; get bit mask
        ORRCC   r11, r1, r14, LSL r11                   ; and OR in
35
        MOVCS   r11, #0                                 ; if out of range then no CMOS
36
        ADD     r12, r12, #1                            ; increment bit
        BL      AddROMModuleNode
        BVS     %FT50

        MOV     r10, r0                                 ; go onto next chunk
        MOV     r9, r2                                  ; this node is now previous one
        B       %BT22

40
        CMP     r3, #0                                  ; are we doing extension ROMs
        BMI     %FT50                                   ; if so, then stop if we get an error
45
        TEQ     r3, #0                                  ; if doing extension ROMs
        SUBMI   r3, r3, #1                              ; then go backwards
        BMI     %BT21
        ADD     r3, r3, #1                              ; go onto next podule
        CMP     r3, #16                                 ; more podules than you could ever fit
        MOVEQ   r3, #-2                                 ; if got to end, try extension ROMs
        MOVEQ   r12, #0                                 ; start by using bit 0 of CMOS
        B       %BT21

50

; free the keyboard scan chain as it's redundant now

        Pull    "r9"                                    ; recover keyboard scan chain anchor
51
        TEQ     r9, #0
        BEQ     %FT58

        MOV     r2, r9
        LDR     r9, [r9, #ROMModule_Link]
  [ ChocolateSysHeap
        ASSERT  ChocolateMRBlocks = ChocolateBlockArrays + 12
        LDR     r1,=ZeroPage+ChocolateBlockArrays
        LDR     r1,[r1,#12]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
        BL      FreeSysHeapNode
  ]
        B       %BT51
58

; now go down ROM module chain, initialising things

60
        LDR     r12, =ZeroPage+ROMModuleChain
        LDR     r12, [r12]
62
        TEQ     r12, #0                                 ; if no more modules
        BEQ     %FT90                                   ; then skip

        LDR     r3, [r12, #ROMModule_CMOSAddrMask]      ; get CMOS for LOCATION version
        ANDS    r2, r3, #&FF
        MOVNE   r1, r2
        MOVNE   r0, #ReadCMOS                           ; if there is a CMOS address
        SWINE   XOS_Byte                                ; then read it
        TST     r2, r3, LSR #16                         ; test bit
        BNE     %FT80                                   ; [LOCATION unplugged, so don't initialise here]

        MOV     r11, r12                                ; start with current one

; now find the newest version that isn't unplugged

; first find the newest version

63
        LDR     r14, [r11, #ROMModule_NewerVersion]
        TEQ     r14, #0                                 ; if there is a newer version
        MOVNE   r11, r14                                ; then link to it
        BNE     %BT63                                   ; and loop

; now work backwards until we find a version that isn't unplugged - there must be one, since LOCATION version is not unplugged

65
        TEQ     r11, r12                                ; back to LOCATION version?
        BEQ     %FT67                                   ; [yes, so use that version]
        LDR     r3, [r11, #ROMModule_CMOSAddrMask]      ; get CMOS for CODE version
        ANDS    r2, r3, #&FF
        MOVNE   r1, r2
        MOVNE   r0, #ReadCMOS                           ; if there is a CMOS address
        SWINE   XOS_Byte                                ; then read it
        TST     r2, r3, LSR #16                         ; test bit
        LDRNE   r11, [r11, #ROMModule_OlderVersion]     ; CODE is unplugged, so try next older version
        BNE     %BT65

67
        LDR     r7, [r12, #ROMModule_PoduleNumber]      ; get podule number (for LOCATION version)
        CMP     r7, #-1                                 ; is it the main ROM
        BNE     %FT69

        LDRB    r10, [r12, #ROMModule_Initialised]      ; already initialised?
        TEQ     r10, #0
        BNE     %FT80
69
        CMP     r7, #-1                                 ; is it an extension ROM
        BGE     %FT70                                   ; if not then initialise newer one

; it's an extension ROM, so only initialise if it's the newest, and hasn't yet been initialised

        TEQ     r11, r12
        LDREQB  r10, [r11, #ROMModule_Initialised]      ; only initialise if this is zero and r11=r12
        TEQEQ   r10, #0
        BNE     %FT80                                   ; don't initialise

; not an extension ROM, so initialise the newest version (r11) of this module

70
        BL      InitialiseROMModuleAtInit
80
        LDR     r12, [r12, #ROMModule_Link]
        B       %BT62

90
      [ DebugROMInit
        SWI     XOS_WriteS
        =       "mod init done",0
        SWI     XOS_NewLine
      ]
        EXIT

;******************************************************************************************************
;
;       InitialiseROMModule - Initialise a ROM module
;
; in:   r11 -> ROM module node for CODE version
;       r12 -> ROM module node for LOCATION version
;
; out:  All registers preserved
;

InitialiseROMModule Entry "r0-r12"
        MOV     r14, #1
        STRB    r14, [r11, #ROMModule_Initialised]      ; indicate it's been initialised
        LDR     r2, [r11, #ROMModule_ChunkNumber]
        LDR     r3, [r11, #ROMModule_PoduleNumber]
        LDR     r4, [r11, #ROMModule_Name]
        LDR     r6, [r11, #ROMModule_BaseAddress]
        LDR     r7, [r12, #ROMModule_PoduleNumber]
        ADRL    r1, crstring
        ADR     lr, %FT20
10
        Push    "r0-r7,r9,lr"
        LDR     r1, [r11, #ROMModule_Size]
        MOV     r5, r11                                 ; r5 -> ROM module node
        B       APMInitEntry
20
        STRVS   r0, [sp]                                ; if error, preserve r0
        EXIT

InitialiseROMModuleAtInit Entry "r0-r1"
      [ DebugROMInit                                    ; print names in ROM module init for debugging
        SWI     XOS_WriteS
        =       "init mod ",0
        ALIGN
        LDR     r0, [r11, #ROMModule_Name]
        SWI     XOS_Write0
      ]
        BL      InitialiseROMModule
      [ DebugROMInit
        BVC     %FT10
        SWI     XOS_WriteS
        =       " => error: ",0
        ALIGN
        ADDVC   r0, r0, #4
        SWIVC   XOS_Write0
10
        WritePSRc SVC_mode+I_bit,r14                    ; this bit of gymnastics ensures that requested
        LDR     r0, =ZeroPage                           ; callbacks don't fire when doing the page scroll check
        LDRB    r1, [r0, #CallBack_Flag]                ; in the VDU driver because of the new line. Otherwise,
        BIC     r14, r1, #CBack_VectorReq               ; callbacks scheduled during ROM init are ordered
        STRB    r14, [r0, #CallBack_Flag]               ; differently for DebugROMInit {TRUE} than {FALSE}

        SWI     XOS_NewLine                             ; enables interrupts itself

        WritePSRc SVC_mode+I_bit,r14
        TST     r1, #CBack_VectorReq
        LDRNEB  r1, [r0, #CallBack_Flag]
        ORRNE   r1, r1, #CBack_VectorReq                ; re-insert that request
        STRNEB  r1, [r0, #CallBack_Flag]
        WritePSRc SVC_mode,r14
      ]
        EXIT

;******************************************************************************************************
;
;       AddROMModuleNode - Create a ROM module node and link it with the chain
;
; in:   R3 = podule number
;       R4 -> module name
;       R5 -> module help string
;       R6 -> module base if directly executable, otherwise zero
;       R7 = module size
;       R8 = 0
;       R9 -> previous node
;       R10 = chunk number
;       R11 = CMOS address (in bits 0..15) and bit mask (in bits 16..23) for unplugging (0 if none)
;
; out:  R2 -> node created
;       All other registers preserved, except if error (when R0 -> error)
;

AddROMModuleNode Entry "r0,r1,r3-r12"
  [ ChocolateSysHeap
        ASSERT  ChocolateMRBlocks = ChocolateBlockArrays + 12
        LDR     r3,=ZeroPage+ChocolateBlockArrays
        LDR     r3,[r3,#12]
        BL      ClaimChocolateBlock
        MOVVS   r3, #ROMModule_NodeSize
        BLVS    ClaimSysHeapNode
  |
        MOV     r3, #ROMModule_NodeSize                 ; claim a rom module node
        BL      ClaimSysHeapNode                        ; r0,r1 corrupted, r2 -> block
  ]
        STRVS   r0, [stack]
        EXIT    VS

        STR     r8, [r2, #ROMModule_Link]               ; set link for this node to 0
        STR     r7, [r2, #ROMModule_Size]               ; store size in node
        STR     r4, [r2, #ROMModule_Name]               ; store pointer to title string
        STR     r6, [r2, #ROMModule_BaseAddress]        ; store base address
        MOV     r0, r5
        BL      GetVerNoFromHelpString                  ; read version number in BCD into r1
        STR     r1, [r2, #ROMModule_Version]            ; store version number
        LDR     r3, [stack, #2*4]                       ; reload podule number
        STR     r3, [r2, #ROMModule_PoduleNumber]       ; store podule number
        STR     r10, [r2, #ROMModule_ChunkNumber]       ; store chunk number
        STR     r11, [r2, #ROMModule_CMOSAddrMask]      ; store CMOS address and mask

; now check if module is a copy of one already on the list

        MOV     r10, #0                                 ; next oldest node
        MOV     r11, #0                                 ; next newest node
        CMP     r3, #-1                                 ; if in main ROM, no need to look for duplicates
        BEQ     %FT40

        MOV     r1, r4                                  ; make r1 -> additional module's name
        MOV     r4, #0                                  ; zero terminator for Module_StrCmp
        MOV     r12, #0                                 ; search from start of chain
        BL      FindROMModule
        TEQ     r12, #0                                 ; did we find it?
        BEQ     %FT40                                   ; no, then module is unique

        TEQ     r6, #0                                  ; set r6 to 1 if extra is directly executable, otherwise 0
        MOVNE   r6, #1
        CMP     r3, #-1                                 ; set r3 to 1 if extra is an extension ROM, otherwise 0
        MOVGE   r3, #0
        MOVLT   r3, #1
        LDR     r1, [r2, #ROMModule_Version]            ; reload version number of extra node
        BL      CompareVersions                         ; compare r2 version with r12 version
        BCC     %FT30                                   ; extra one is older than this one, so search down older chain

; extra one is newer than this one, so search down newer chain

20
        MOV     r10, r12                                ; old = this
        LDR     r12, [r12, #ROMModule_NewerVersion]     ; this = newer(this)
        MOVS    r11, r12                                ; new = this
        BEQ     %FT40                                   ; if no newer then that's it!
        BL      CompareVersions
        BCS     %BT20

; extra one is older than this one, so search down older chain

30
        MOV     r11, r12                                ; new = this
        LDR     r12, [r12, #ROMModule_OlderVersion]     ; this = older(this)
        MOVS    r10, r12                                ; old = this
        BEQ     %FT40
        BL      CompareVersions
        BCC     %BT30

40
        STR     r10, [r2, #ROMModule_OlderVersion]      ; older(extra)=old
        STR     r11, [r2, #ROMModule_NewerVersion]      ; newer(extra)=new
        TEQ     r10, #0                                 ; if old <> 0
        STRNE   r2, [r10, #ROMModule_NewerVersion]      ; then newer(old)=extra
        TEQ     r11, #0                                 ; if new <> 0
        STRNE   r2, [r11, #ROMModule_OlderVersion]      ; then older(new)=extra

        STR     r2, [r9]                                ; point previous node at this one
        CLRV
        EXIT

;******************************************************************************************************
;
;       CompareVersions - Test two for newness against another (existing) node
;
; in:   R1 = version as BCD
;       R3 = base address
;       R6 = podule number
;       R12 -> node
;
; out:  CC of compare
;       All other registers preserved
;

CompareVersions Entry
        LDR     r14, [r12, #ROMModule_Version]          ; r14 = version(this)
        CMP     r1, r14
        EXIT    NE                                      ; exit with this condition codes, unless equal
        LDR     r14, [r12, #ROMModule_BaseAddress]
        TEQ     r14, #0                                 ; set r14 to 1 if this one is directly executable, otherwise 0
        MOVNE   r14, #1
        CMP     r6, r14
        EXIT    NE                                      ; directly executables are "newer"
        LDR     r14, [r12, #ROMModule_PoduleNumber]
        CMP     r14, #-1                                ; set r14 to 1 if ext. ROM, otherwise 0
        MOVGE   r14, #0
        MOVLT   r14, #1
        CMP     r3, r14                                 ; extension ROMs are "newer" than anything else
        EXIT                                            ; if equal in all other respects, the later one is "newer"

;******************************************************************************************************
;
;       CompareTitleWithCSV - Test two for newness against another (existing) node
;
; in:   R11 = comma separated string of titles
;       R4 -> title string of a module
;
; out:  EQ if title is in the list
;       All other registers preserved
;

CompareTitleWithCSV Entry "r0, r6, r11"
10
        MOV     r6, r4                                  ; char in title string
20
        LDRB    r0, [r11], #1
        LDRB    r14, [r6], #1
        TEQ     r0, #0                                  ; (terminator OR
        TEQNE   r0, #","                                ;                separator)
        TEQEQ   r14, #0                                 ;                           AND terminator
        EXIT    EQ

        TEQ     r0, r14
        BEQ     %BT20
30
        TEQ     r0, #0
        BNE     %FT40                                   ; no more values

        MOVS    r0, #1
        EXIT    NE
40
        TEQ     r0, #","                                
        BEQ     %BT10                                   ; try next value

        LDRB    r0, [r11], #1
        B       %BT30

;******************************************************************************************************
;
;       FindROMModule - Find a named module in the ROM module list
;
; in:   R1 -> name to match
;       R4 = potential additional termintor for R1 string
;       R12 -> node before 1st node to be checked (0 => search from start)
;
; out:  R12 -> found node, or 0 if no match
;       If match, then R1 -> terminator of R1 string, otherwise preserved
;       All other registers preserved
;

FindROMModule Entry
        TEQ     r12, #0                                 ; if zero passed in on entry
        LDREQ   r12, =ZeroPage+ROMModuleChain           ; then search from start of chain
10
        LDR     r12, [r12, #ROMModule_Link]             ; go to next module
        TEQ     r12, #0                                 ; any more modules?
        EXIT    EQ                                      ; no, then exit
        Push    "r1, r3"
        LDR     r3, [r12, #ROMModule_Name]              ; point to name of module on chain
        BL      Module_StrCmp                           ; compare names
        STREQ   r1, [sp]                                ; if match, then patch stacked r1
        Pull    "r1, r3"
        BNE     %BT10                                   ; if different then try next one
        EXIT

; start of module handler SWI

     GBLA  mhrc
mhrc SETA 0

     MACRO
$l   ModuleDispatchEntry $entry
$l   B      Module_$entry
     ASSERT ModHandReason_$entry = mhrc
mhrc SETA   mhrc + 1
     MEND

ModuleHandler ROUT

     CMP      r0, #(NaffSWI - (.+12))/4     ; Range check
     ADDLO    pc, pc, r0, LSL #2            ; dispatch
     B        NaffSWI

     ModuleDispatchEntry Run
     ModuleDispatchEntry Load
     ModuleDispatchEntry Enter
     ModuleDispatchEntry ReInit
     ModuleDispatchEntry Delete
     ModuleDispatchEntry RMADesc
     ModuleDispatchEntry Claim
     ModuleDispatchEntry Free
     ModuleDispatchEntry Tidy
     ModuleDispatchEntry Clear
     ModuleDispatchEntry AddArea
     ModuleDispatchEntry CopyArea
     ModuleDispatchEntry GetNames
     ModuleDispatchEntry ExtendBlock
     ModuleDispatchEntry NewIncarnation
     ModuleDispatchEntry RenameIncarnation
     ModuleDispatchEntry MakePreferred
     ModuleDispatchEntry AddPoduleModule
     ModuleDispatchEntry LookupName
     ModuleDispatchEntry EnumerateROM_Modules
     ModuleDispatchEntry EnumerateROM_ModulesWithInfo
     ModuleDispatchEntry FindEndOfROM_ModuleChain

NaffSWI                                     ; Set V and return
        ADR     R0, ErrorBlock_BadModuleReason
      [ International
BumDealInModule_Translate
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
BumDealInModule
        B       SLVK_SetV

     MakeErrorBlock BadModuleReason

;*************************************************************

Module_Run      ROUT
       WritePSRc SVC_mode, R12              ; interrupts on
       Push    "R9, lr"
       BL       Load_Module
       BVS      LoadFailed
  ;     BL       EnvStringSkipName - done in load
EnterIt
 ; R9 now ptr to node, R10 ptr to command string to set up.
 ; Enters preferred incarnation.

       LDR      R12, [R9, #Module_incarnation_list]
       ADD      R12, R12, #Incarnation_Workspace

       LDR      R9, [R9, #Module_code_pointer]
       LDR      R11, [R9, #Module_Start]
       TEQ      R11, #0
       Pull    "R9, lr", EQ
       ExitSWIHandler EQ

       Push    "R1-R3"
       MOV      R1, R10
       MOV      R0, #FSControl_StartApplication
       MOV      R2, R9
       LDR      R3, [R9, #Module_TitleStr]  ; prefix with module title
       ADD      R3, R3, R9

       SWI      XOS_FSControl
       BVS      CantGoIntoModule

       LDR      stack, =SVCSTK
       MOV      R0, R10
       WritePSRc 0, R14
       MOV      r0, r0                      ; NOP because we've changed mode

       TST      R11, #ARM_CC_Mask           ; check for B startit, etc.
       MOVNE    R11, #0
       ADD      PC, R9, R11

CantGoIntoModule
       Pull    "R1-R3"
LoadFailed
       Pull    "R9, lr"
       B        BumDealInModule

;*************************************************************

Module_Load     ROUT
        WritePSRc SVC_mode, R12             ; interrupts on
        Push    "R9, lr"
        BL      Load_Module
        Pull    "R9, lr"
        B       SLVK_TestV

;*************************************************************

Module_Enter    ROUT
       Push    "R9, lr"                     ; ready for EnterIt
       Push    "R0-R4"
       BL       lookup_commoned

       STRVS    R0, [stack]
       Pull    "R0-R4, R9, lr", VS
       BVS      BumDealInModule

       BLNE     PreferIncarnation
       Pull    "R0-R4"
       MOV      R10, R2                     ; envstring pointer
       B        EnterIt

;*************************************************************

Module_ReInit   ROUT
       Push    "R0-R4, R9, lr"

       BL       lookup_commoned
       BVS      %FT01

       ADDEQ    R3, R9, #Module_incarnation_list
       LDREQ    R12, [R9, #Module_incarnation_list]

 ;    R12 -> incarnation node, R3  -> previous incarnation

       MOV      R10, #1                     ; fatal die
       BL       CallDie
       BVS      %FT03
     [ ModHand_InitDieServices
       BL       IssueServicePostFinal
     ]

       SUB      R10, R1, #1
       BL       EnvStringSkipName

       BL       CallInit
       BLVS     LoseModuleSpace_if_its_the_only_incarnation
       STRVC    R12, [R3, #Incarnation_Link]
     [ ModHand_InitDieServices
       BLVC     IssueServicePostInit
     ]
03     STRVS    R0, [stack]
       Pull    "R0-R4, R9, lr"
        B       SLVK_TestV


01     LDR      R11, [R0]
       LDR      R2, =ErrorNumber_RMNotFound
       CMP      R11, R2
       BEQ      %FT02
05
       SETV
       B        %BT03

02     MOV      R0, #0
       BL       AddModuleIfInROM
       B        %BT03

;*************************************************************

Module_Delete   ROUT
       Push    "R0-R4, R9, lr"
       BL       lookup_commoned
       BVS      %FT01

       ADDEQ    R3, R9, #Module_incarnation_list
       LDREQ    R12, [R9, #Module_incarnation_list]

 ;    R12 -> incarnation node, R3  -> previous incarnation

       BL       KillIncarnation
01     STRVS    R0, [stack]
       Pull    "R0-R4, R9, lr"
       B        SLVK_TestV

;*************************************************************

Module_Free      ROUT
Module_RMADesc
         Push   "R0, R1, lr"

         SUB     R0, R0, #(ModHandReason_RMADesc-HeapReason_Desc)
 ASSERT HeapReason_Desc-HeapReason_Free=ModHandReason_RMADesc-ModHandReason_Free
         MOV     R1, #RMAAddress
         SWI     XOS_Heap
         STRVS   R0, [stack]
         Pull   "R0, R1, lr"
         B       SLVK_TestV

;*************************************************************

Module_Claim  ROUT
         Push   "R0, R1, lr"
         BL      RMAClaim_Chunk
         STRVS   R0, [stack]
         Pull   "R0, R1, lr"
         B       SLVK_TestV

;*************************************************************
; Garbage collect the RMA. We know there's always one module,
; and some RMA space.

Module_Tidy
         ; on Medusa we do nothing, because we would always fail
         ; due to FSLock being Captain Scarlet
         B       SLVK

;****************************************************************************

Module_Clear Entry "r0-r3"
        WritePSRc SVC_mode, r3                          ; interrupts on
        MOV     r3, #0                                  ; position in chain

; now find entry in chain to kill : one with successor = R3

MHC_GetEndOne
        LDR     r2, =ZeroPage+Module_List               ; prevnode for killing
        LDR     r0, [r2, #Module_chain_Link]
        CMP     r0, r3
        PullEnv EQ
        ExitSWIHandler EQ
MHC_StepOn
        LDR     r1, [r0, #Module_chain_Link]
        CMP     r1, r3
        MOVNE   r2, r0
        MOVNE   r0, r1
        BNE     MHC_StepOn

        LDR     r11, [r0, #Module_ROMModuleNode]        ; don't kill if it's a ROM module (note that this would also
        CMP     r11, #1                                 ; account for squeezed ROM modules, so the invincible bit in the
        LDRCC   r11, [r0, #Module_code_pointer]         ; die entry is not strictly necessary any more, but never mind!)
        LDRCC   r11, [r11, #Module_Die]                 ; Check for invincible module
        CMPCC   r11, #&80000000                         ; (die entry has top bit set)
        MOVCS   r3, r0                                  ; step if not about to delete
                                                        ; - don't assassinate ROM modules.
        BLCC    KillAndFree
        BVC     MHC_GetEndOne

        LDR     r3, [r2, #Module_chain_Link]
        STR     r0, [stack]
        LDR     r0, [stack, #4*4]
        ORR     r0, r0, #V_bit
        STR     r0, [stack, #4*4]
        B       MHC_GetEndOne

;*************************************************************
; AddArea:
; Entry;  R1 -> module in memory to add, leaving it in place.
; Return: registers preserved, V set if problem
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module_AddArea   ROUT
         Push   "R9, lr"
         WritePSRc SVC_mode, R10             ; interrupts on
         ADRL    R10, crstring               ; null environment
         BL      ModuleIn_CheckForDuplicate  ; altentry to Load_Module
         Pull   "R9, lr"
        B       SLVK_TestV

;*************************************************************
; CopyArea
;    R1 -> area of memory to add to the module list,
;          copying into the RMA
;    R2 =  size of the area.

Module_CopyArea  ROUT
         Push   "R0-R5, R9, lr"
         WritePSRc SVC_mode, lr

  ; R1 address, R2 size
         BL      CheckHeader
         BVS     AreaFail

         MOV     R10, R1

         LDR     R1, [R10, #Module_TitleStr]
         ADD     R1, R1, R10
         BL      LookUp_Module               ; check for duplicate
         BLNE    KillAndFree
         STRVS   R0, [stack]
         Pull   "R0-R5, R9, lr", VS
         BVS     SLVK_TestV

; R10 points at area
         LDR     R3, [stack, #4*2]           ; get size back
         BL      RMAClaim_Chunk
         ADRVSL  R0, ErrorBlock_MHNoRoom
       [ International
         BLVS    TranslateError
       ]
         BVS     AreaFail

         MOV     R9, R2                      ; new module pointer

; copy R3 bytes from R10 to R2
01       LDR     R1, [R10], #4
         STR     R1, [R2], #4
         SUBS    R3, R3, #4
         BHI     %BT01                       ; was BPL, which is wrong!

         ADRL    R10, crstring               ; no environment string
         MOV     R11, #0                     ; not podular
         BL      LinkAndInit

AreaFail
         STRVS   R0, [stack]
         Pull   "R0-R5, R9, lr"
        B       SLVK_TestV

;*************************************************************
; Enumerate modules
; Entry:  R0 Reason code
;         R1 module number
;         R2 incarnation number
; Exit:   R1, R2 updated to refer to next existing module
;         R3 -> module code
;         R4    private word contents
;         R5 -> postfix string

Module_GetNames  ROUT
         WritePSRc SVC_mode, R11             ; interrupts on
         MOV     R11, R1
         MOV     R12, R2
         LDR     R10, =ZeroPage+Module_List
01       LDR     R10, [R10, #Module_chain_Link]
         CMP     R10, #0
         BEQ     %FT10                       ; no more modules
         SUBS    R11, R11, #1
         BPL     %BT01
         LDR     R3, [R10, #Module_code_pointer]
         ADD     R10, R10, #Module_incarnation_list
02       LDR     R10, [R10, #Incarnation_Link]
         CMP     R10, #0
         BEQ     %FT11                       ; no more incarnations
         SUBS    R12, R12, #1
         BPL     %BT02
         LDR     R4, [R10, #Incarnation_Workspace]
         ADD     R5, R10, #Incarnation_Postfix
         LDR     R10, [R10, #Incarnation_Link]
20       CMP     R10, #0
         ADDNE   R2, R2, #1
         MOVEQ   R2, #0
         ADDEQ   R1, R1, #1
         ExitSWIHandler

10       ADR     R0, ErrorBlock_NoMoreModules
       [ International
         B       BumDealInModule_Translate
       |
         B       BumDealInModule
       ]
         MakeErrorBlock NoMoreModules

11       CMP     r2, #0
         LDREQ   r4, =&DEADDEAD
         MOVEQ   r10, #0
         BEQ     %BT20         ; fudge for modules that go bang in init/die
         ADR     R0, ErrorBlock_NoMoreIncarnations
       [ International
         B       BumDealInModule_Translate
       |
         B       BumDealInModule
       ]
         MakeErrorBlock NoMoreIncarnations
         LTORG

;*************************************************************

Module_ExtendBlock ROUT
         Push   "R0, r1, R3, lr"

         ADD     R3, R3, #31
         BIC     R3, R3, #31

         MOV     R0, #HeapReason_ExtendBlock
         BL      DoRMAHeapOpWithExtension

         STRVS   R0, [stack]
         Pull   "R0, r1, R3, lr"
         B       SLVK_TestV

;*************************************************************
; New Incarnation
;    R1 -> module%newpostfix

Module_NewIncarnation ROUT
         Push   "R0-R4, R9, lr"
         WritePSRc SVC_mode, lr
         BL      LookUp_Module
         BEQ     CheckTheROM
         CMP     R12, #0
         BEQ     Incarnation_needed
         CMP     R12, #-1
         BNE     Incarnation_exists
         MOV     R9, R0                      ; node pointer
         MOV     R0, R1                      ; postfix
         MOV     R10, R1
         BL      EnvStringSkipName           ; envstring ptr in R10
         BL      Add_Incarnation
       [ ModHand_InitDieServices
         BLVC    IssueServicePostInit
       ]
01       STRVS   R0, [stack]
         Pull   "R0-R4, R9, lr"
         B      SLVK_TestV

CheckTheROM
         MOV     R0, #Postfix_Separator      ; passed string must have postfix
         LDR     R1, [stack, #1*4]
         BL      AddModuleIfInROM
         B       %BT01

Incarnation_needed
         Pull   "R0-R4, R9, lr"
         ADR     R0, ErrorBlock_PostfixNeeded
       [ International
         B       BumDealInModule_Translate
       |
         B       BumDealInModule
       ]
         MakeErrorBlock PostfixNeeded

Incarnation_exists
         Pull   "R0-R4, R9, lr"
         ADR     R0, ErrorBlock_IncarnationExists
       [ International
         B       BumDealInModule_Translate
       |
         B       BumDealInModule
       ]
         MakeErrorBlock IncarnationExists

;*************************************************************
; Rename Incarnation
; R1 -> current module title
; R2 -> new postfix.

Module_RenameIncarnation ROUT
         Push   "R0-R4, R9, lr"
         BL      lookup_commoned
         BVS     %FT01

; R12 -> incarnation node    (0 for not specified)
; R3  -> previous incarnation

         MOV     R11, R12
         MOV     R0, R9                      ; check incarnation
         LDR     R1, [stack, #4*2]           ; not already there
         Push    R3                          ; preserve pointer to
         BL      FindIncarnation
         Pull    R3                          ; previous incarnation
         BNE     %FT03                       ; already exists
         MOV     R12, R11

         CMP     R12, #0
         ADDEQ   R3, R9, #Module_incarnation_list
         LDREQ   R12, [R9, #Module_incarnation_list]
         MOV     R11, R3

         ADD     R1, R12, #Incarnation_Postfix
         BL      %FT10                       ; old postfix length -> R0
         MOV     R10, R0
         LDR     R1, [stack, #4*2]           ; new postfix
         BL      %FT10                       ; new length - > R0
         SUB     R3, R0, R10

         MOV     R2, R12                     ; incarnation node
         MOV     R0, #HeapReason_ExtendBlock
         BL      DoSysHeapOpWithExtension
         BVS     %FT01

         STR     R2, [R11, #Incarnation_Link] ; relink
         ADD     R2, R2, #Incarnation_Postfix
         LDR     R1, [stack, #4*2]
02       LDRB    R0, [R1], #1
         CMP     R0, #" "
         MOVLE   R0, #0
         STRB    R0, [R2], #1
         BGT     %BT02
01       STRVS   R0, [stack]
         Pull   "R0-R4, R9, lr"
         B      SLVK_TestV

03       ADR     R0, ErrorBlock_IncarnationExists
       [ International
         Push   "LR"
         BL     TranslateError
         Pull   "LR"
       |
         SETV
       ]
         B       %BT01

10       MOV     R0, #0
11       LDRB    R3, [R1, R0]
         CMP     R3, #" "
         ADDGT   R0, R0, #1
         BGT     %BT11
         MOV     PC, lr

;*************************************************************
; MakePreferred
;   R1 -> name

Module_MakePreferred ROUT
        Push    "R0-R4, R9, lr"
        BL      lookup_commoned
        BVS     %FT01
        BLNE    PreferIncarnation       ; only prefer it if found!
01
        STRVS   R0, [sp, #0]
        Pull    "R0-R4, R9, lr"
        B       SLVK_TestV

;*************************************************************
; AddPoduleModule
;
; in:   R1 -> envstring
;       R2 = chunk number
;       R3 = podule number
;
; out:  All registers preserved

Module_AddPoduleModule Entry
        WritePSRc SVC_mode, lr                  ; interrupts on
        BL      APMEntry
        PullEnv
        B       SLVK_TestV

APMEntry Entry "r0-r7,r9"
        MOV     r0, r2
        SWI     XPodule_EnumerateChunksWithInfo ; out: r1=size, r2=type, r4->name, r5->help string, r6=module address if in ROM
        BVS     %FT99
        CMP     r2, #OSType_Module
        BNE     %FT98

        MOV     r7, r3
        MOV     r5, #0                          ; indicate not a ROM module (although strictly speaking, it is!)
APMInitEntry
        Push    "r1"                            ; size
        MOV     r1, r4
        BL      LookUp_Module                   ; check for duplicate
        BLNE    KillAndFree
        Pull    "r3"                            ; get size back
        BVS     %FT99

        MOVS    r1, r6                          ; if module address non-zero, then it's a directly executable ext. ROM
        BNE     %FT10                           ; and don't claim a block, or read the chunk

        BL      RMAClaim_Chunk
        BVS     %FT99
        LDR     r0, [stack, #4*2]
        LDR     r3, [stack, #4*3]
        SWI     XPodule_ReadChunk
        MOV     r1, r2                          ; r1 = address of module
10
        LDR     r2, [r1, #-4]                   ; r2 = size
        BLVC    CheckHeader
        BVS     %FT97                           ; free space too (doesn't matter that it fails for extension ROM)

        MOV     r9, r1
        LDR     r10, [stack, #4]                ; envptr

        MOVS    r3, r7                          ; if not a podule (r7 < 0)
        MOVMI   r11, #0                         ; then use hardware address zero
        BMI     %FT20
        Push    "r1"                            ; else compute hardware address from 'fake' podule number
        SWI     XPodule_HardwareAddresses       ; get raw hardware address for podule r3 into r0 (r1 = combined)
        Pull    "r1"
        BVS     %FT97
        MOV     r11, r0                         ; move into r11
20
        BL      LinkAndInit
        STRVC   r5, [r9, #Module_ROMModuleNode] ; store zero or pointer to ROM module node (if no error in init)
99
        STRVS   r0, [stack]
        EXIT

98
        ADR     r0, ErrorBlock_ChunkNotRM
      [ International
        BL      TranslateError
      ]
96
        SETV
        B       %BT99
        MakeErrorBlock ChunkNotRM

97
        MOV     r2, r1                          ; free claimed RMA space
        MOV     r1, #RMAAddress
        Push    "r0"
        MOV     r0, #HeapReason_Free
        SWI     XOS_Heap
        Pull   "r0"
        B       %BT96

        LTORG

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; LookupName
;    Take module name, return info on it suitable for use with Enumeration
;      (e.g. to get all incarnations of it)
;  In :   R1 -> name
;  Out:   R1 module number          \  of THIS module; first enumerate
;         R2 incarnation number     /  call will give back this module
;         R3 -> module code
;         R4    private word contents
;         R5 -> postfix string

Module_LookupName ROUT
         Push   "R0-R4, R9, lr"
         BL      lookup_commoned
         BVC     %FT01
         STR     R0, [stack]
         Pull   "R0-R4, R9, lr"
         B      SLVK_SetV

01       MOV     R1, #0               ; module number
         LDR     R0, =ZeroPage+Module_List

; R9  -> module chain node
; R12 -> incarnation node    (0 for not specified, -1 for not found)

         LDREQ   R12, [R9, #Module_incarnation_list]  ; preferred inc.

02       LDR     R0, [R0]
         CMP     R0, R9
         ADDNE   R1, R1, #1
         BNE     %BT02
         ADD     R0, R0, #Module_incarnation_list
         MOV     R2, #0
03       LDR     R0, [R0]
         CMP     R0, R12
         ADDNE   R2, R2, #1
         BNE     %BT03
         LDR     R3, [R9, #Module_code_pointer]
         LDR     R4, [R12, #Incarnation_Workspace]
         ADD     R5, R12, #Incarnation_Postfix
         LDR     r0, [sp], #5*4            ; Load r0, skip r1-r4
         Pull   "R9, lr"
         ExitSWIHandler

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; EnumerateROM_Modules and EnumerateROM_ModulesWithInfo
;
;  In :   R1 = module number
;         R2 = -1    => ROM
;            = other => Podule R2
;
;  Out:   R1 = incremented: next call will return next module
;         R2 = preserved
;         R3 -> name
;         R4 = -1 => unplugged
;            =  0 => inserted but not currently in the module chain
;            =  1 => active
;            =  2 => running
;         R5 =  chunk number of podule RM
;         If R0 = ModHandReason_EnumerateROM_ModulesWithInfo then
;          R6 = BCD version number of module (decimal point between top and bottom half-words)

Module_EnumerateROM_Modules ROUT
Module_EnumerateROM_ModulesWithInfo ROUT
        LDR     r12, =ZeroPage+ROMModuleChain
        MOV     r10, r1                                 ; module count
10
        LDR     r12, [r12, #ROMModule_Link]             ; follow link to next module
        TEQ     r12, #0                                 ; if no more modules
        ADREQL  r0, ErrorBlock_NoMoreModules
      [ International
        Push    "lr",EQ
        BLEQ    TranslateError
        Pull    "lr",EQ
      ]
        BEQ     SLVK_SetV                               ; then report error
        LDR     r11, [r12, #ROMModule_PoduleNumber]
        CMP     r2, #-1                                 ; if searching for podule -1, then this one must be ">="
        BEQ     %FT30
        BGT     %FT20                                   ; searching from normal podules onwards

; searching from extension ROMs onwards

        CMP     r11, r2                                 ; so if r11 > r2 then not there yet
        BGT     %BT10

; searching from normal podules onwards

20
        CMP     r11, #-1                                ; if found one is extension ROM
        BLT     %FT30                                   ; then will be OK
        CMP     r11, r2                                 ; else is only OK if r11 >= r2
        BLT     %BT10
30
        CMP     r11, r2                                 ; check for equality
        MOVNE   r1, #0                                  ; if not correct podule then this is the one to return
        BNE     %FT50

        SUBS    r10, r10, #1                            ; decrement module count
        BCS     %BT10                                   ; not there yet, so go back
50
        Push    "r0-r2, lr"
        LDR     r10, [r12, #ROMModule_CMOSAddrMask]     ; get CMOS address and mask
        ANDS    r2, r10, #&FF                           ; extract address
        MOVNE   r1, r2                                  ; if there is a CMOS address
        MOVNE   r0, #ReadCMOS
        SWINE   XOS_Byte                                ; then read it
        TST     r2, r10, LSR #16                        ; test bit
        Pull    "r0-r2"
        Push    "r8, r9"
        MOVNE   r4, #-1                                 ; indicate unplugged
        BNE     %FT90

; not unplugged, so check for module in module list

        LDR     r4, =ZeroPage+Module_List
60
        LDR     r4, [r4, #Module_chain_Link]
        TEQ     r4, #0                                  ; module not active
        BEQ     %FT90
        LDR     r11, [r4, #Module_ROMModuleNode]        ; get active module's pointer to ROM module node
        TEQ     r11, r12                                ; if it matches
        BNE     %BT60
        LDR     r10, [r4, #Module_code_pointer]         ; get pointer to code
        LDR     r11, =ZeroPage
        LDR     r11, [r11, #Curr_Active_Object]
        LDR     r4, [r10, #-4]                          ; node size of code
        ADD     r4, r4, r10
        CMP     r11, r10
        CMPCS   r4, r11
        MOVHI   r4, #2                                  ; indicate running
        MOVLS   r4, #1                                  ; indicate just active
90
        LDR     r2, [r12, #ROMModule_PoduleNumber]      ; reload podule number
        CMP     r2, #-1                                 ; if not main ROM
        LDRNE   r5, [r12, #ROMModule_ChunkNumber]       ; then load chunk number
        LDR     r3, [r12, #ROMModule_Name]              ; load pointer to name
        ADD     r1, r1, #1                              ; move module number onto next one
        TEQ     r0, #ModHandReason_EnumerateROM_ModulesWithInfo
        LDREQ   r6, [r12, #ROMModule_Version]
        Pull    "r8, r9, lr"                            ; restore registers
        ExitSWIHandler                                  ; and exit

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; FindEndOfROM_ModuleChain
;
;  In :   R1 = -1    => ROM
;            = other => reserved
;
;  Out:   R1 = preserved
;         R2 -> first word after ROM module chain

Module_FindEndOfROM_ModuleChain ROUT
        CMP     r1, #-1                                 ; Only works for the system ROM at present
        ADRNEL  r0, ErrorBlock_BadParameters
      [ International
        Push    "lr",NE
        BLNE    TranslateError
        Pull    "lr",NE
      ]
        BNE     SLVK_SetV

        ADRL    r2, SysModules_Info + 4                 ; Step through until the end of the module chain
10      LDR     r11, [r2, #-4]
        TEQ     r11, #0
        ADDNE   r2, r2, r11
        BNE     %BT10

        ExitSWIHandler                                  ; and exit

;*************************************************************
; Support routines.
;
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Load_Module
;     takes filename pointer in R1, and loads and initialises the given file.
;     Returns R9 as a pointer to the node claimed
;     and  V/current error set if fails

Load_Module ROUT

        Push   "R0-R5, lr"

        MOV     r0, #OSFile_ReadInfo
        SWI     XOS_File
        BVS     modfailxit              ; return FileSwitch error
        CMP     r0, #object_file
        BNE     HeNotFile

        MOV     R2, R2, ASR #8          ; low byte ignored by me.
        CMP     R2, #&FFFFF000 :OR: FileType_Module
        BNE     NotAModule

; it's a module, so try and claim.
        MOV     R10, R1                 ; keep string pointer
        MOV     R3, R4                  ; size of vector needed
        BL      RMAClaim_Chunk
        BVS     modfailxit

02      MOV     R9, R2                  ; keep a copy of node ptr.
        MOV     R1, R10
        MOV     R3, #0                  ; load to R2 posn
        MOV     R0, #OSFile_Load
        SWI     XOS_File
        BVS     modfailxit              ; return FileSwitch error

50      MOV     R11, #0                 ; not loaded from hardware.

; R9 address, R9!-4 size
        MOV     R1, R9
        LDR     R2, [R9, #-4]
        BL      CheckHeader
        BVS     Duplicate_Immortal      ; actually means naff header field

; now we've got it, see if any other modules have the same name.

        LDR     R1, [R9, #Module_TitleStr]
        ADD     R1, R1, R9
        BL      LookUp_Module
        BEQ     %FT01                   ; no module at all
        CMP     R12, #0
        BNE     nopostfixwanted         ; postfix given: bad name
        BL      KillAndFree
        BVS     Duplicate_Immortal

; now claim a link
; R9 module pointer, R10 environment

01      BL      EnvStringSkipName
        BL      LinkAndInit             ; takes R2 prevnode from lookup

        STRVS   R0, [stack]
        Pull   "R0-R5, pc"

Duplicate_Immortal                      ; free space claimed for loading
        STR     R0, [stack]
        MOV     R2, R9
        MOV     R0, #HeapReason_Free
        MOV     R1, #RMAAddress
        SWI     XOS_Heap
        SETV
        Pull   "R0-R5, PC"

        MakeErrorBlock MHNoRoom

nopostfixwanted
        ADR     R0, ErrorBlock_ModulePostfix
      [ International
        BL      TranslateError
      ]
        B       modfailxit

        MakeErrorBlock ModulePostfix

        MakeErrorBlock NotMod

NotAModule
        ADR     R0, ErrorBlock_NotMod
      [ International
        BL      TranslateError
      ]
modfailxit
        STR     R0, [stack]
        SETV
        Pull   "R0-R5, PC"

HeNotFile
        MOV     r2, r0
        MOV     r0, #OSFile_MakeError
        SWI     XOS_File
        B       modfailxit

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ModuleIn_CheckForDuplicate
; Altentry to Load_Module for AddArea: module already in, initialise it.

ModuleIn_CheckForDuplicate
         Push   "R0-R5, lr"
         MOV     R9, R1           ; move module ptr to handy place
         B       %BT50

;*************************************************************
; AddModuleIfInROM
; in: R1 -> name
;     R0 = Postfix_Separator => called from AddNewIncarnation when module is not active
;                               find newest version in ROM, and initialise it in its own location (even if unplugged)
;                               then rename the base incarnation of it to specified postfix
;
;        = 0                 => called from ReInit when module is not active
;                               plug in all versions of module, and initialise newest one in its own location
;
; out: R5-R8 preserved
;      Other registers may be corrupted
;

AddModuleIfInROM Entry "r5-r8"
        MOV     r4, r0
        MOV     r12, #0                                 ; search entire ROM set
        MOV     r7, r1                                  ; save pointer to beginning of name
        BL      FindROMModule
        TEQ     r12, #0
        BNE     %FT10
        BL      MakeNotFoundError                       ; in:  r1 -> module name 'foo'
                                                        ; out: r0 -> "Module 'foo' not found" error, V=1
        EXIT

10
        MOV     r6, r1                                  ; save pointer to terminator of module name
15
        LDR     r14, [r12, #ROMModule_OlderVersion]     ; find oldest version
        TEQ     r14, #0
        MOVNE   r12, r14
        BNE     %BT15

20
        TEQ     r4, #0                                  ; if doing AddIncarnation rather than ReInit
        BNE     %FT30                                   ; then don't plug module in
        MOV     r5, #&FF                                ; set up byte mask (and indicate found)
        LDR     r1, [r12, #ROMModule_CMOSAddrMask]
        AND     r3, r5, r1, LSR #16                     ; get bit mask
        ANDS    r1, r1, r5
        BEQ     %FT30                                   ; if no CMOS, then look for another module
        MOV     r0, #ReadCMOS
        SWI     XOS_Byte
        EXIT    VS
        TST     r2, r3                                  ; test if module unplugged
        BEQ     %FT30                                   ; if not, then don't write to CMOS (so RMReInit works when FSLock enabled)
        BIC     r2, r2, r3                              ; otherwise clear bit
        MOV     r0, #WriteCMOS
        SWI     XOS_Byte
        EXIT    VS
30
        LDR     r14, [r12, #ROMModule_NewerVersion]
        TEQ     r14, #0
        MOVNE   r12, r14
        BNE     %BT20

        TEQ     r4, #0                                  ; if AddIncarnation then check that name terminator is "%"
        LDRNEB  r14, [r6], #1                           ; load next character (and skip it)
        TEQNE   r14, #Postfix_Separator
        BEQ     %FT40
        ADRL    r0, ErrorBlock_PostfixNeeded
      [ International
        BL      TranslateError
      |
        SETV
      ]
        EXIT

40
        MOV     r11, r12
        BL      InitialiseROMModule                     ; in both cases initialise newest version
                                                        ; (in AddIncarnation case it may still be unplugged)
        EXIT    VS

        TEQ     r4, #0                                  ; if ReInit then we've finished (V=0 from above)
        EXIT    EQ

        SUB     r8, r6, r7                              ; length of module name including '%'
        ADD     r8, r8, #4+1+3                          ; allow for 'Base<0>' and round up to whole number of words
        BIC     r8, r8, #3
        SUB     stack, stack, r8

        MOV     r0, stack
50
        LDRB    r14, [r7], #1                           ; copy name, including '%'
        STRB    r14, [r0], #1
        TEQ     r7, r6
        BNE     %BT50

        ADR     r1, base_postfix
60
        LDRB    r14, [r1], #1                           ; copy 'Base<0>'
        STRB    r14, [r0], #1
        TEQ     r14, #0
        BNE     %BT60

        MOV     r0, #ModHandReason_RenameIncarnation
        MOV     r1, stack                               ; pointer to '<module>%Base<0>'
        MOV     r2, r6                                  ; pointer to 'newinc'
        SWI     XOS_Module
        ADD     stack, stack, r8                        ; junk name
        EXIT

;*************************************************************
; LinkAndInit :
;     module pointer in R9
;     module list position in R2 : added at end if posn not found
;     environment string pointer in R10
;    "hardware" in R11
;     returns module node pointer in R9

LinkAndInit Entry "r2, r3"


  [ ChocolateSysHeap
        ASSERT  ChocolateMABlocks = ChocolateBlockArrays + 16
        LDR     r3,=ZeroPage+ChocolateBlockArrays
        LDR     r3,[r3,#16]
        BL      ClaimChocolateBlock
    [ ModHand_IntrinsicBI
        MOVVS   r3, #ModInfo + Incarnation_Postfix + 8   ;enough for 'Base',0
    |
        MOVVS   r3, #ModInfo
    ]
        BLVS    ClaimSysHeapNode
  |
    [ ModHand_IntrinsicBI
        MOV     r3, #ModInfo + Incarnation_Postfix + 8   ;enough for 'Base',0
    |
        MOV     r3, #ModInfo
    ]
        BL      ClaimSysHeapNode
  ]
        EXIT    VS

        STR     r9, [r2, #Module_code_pointer]
        STR     r11, [r2, #Module_Hardware]
        MOV     r9, r2                                  ; keep node pointer

        MOV     r0, #0
        STR     r0, [r2, #Module_ROMModuleNode]         ; assume not a ROM module
        STR     r0, [r2, #Module_incarnation_list]      ; terminate list
        ADR     r0, base_postfix
  [ ModHand_IntrinsicBI
        BL      Add_intrinsic_Incarnation               ; add Base incarnation
  |
        BL      Add_Incarnation                         ; add Base incarnation
  ]
        BVS     %FT01

        Pull    "r2"
        LDR     r0, =ZeroPage+Module_List
05
        LDR     r1, [r0, #Module_chain_Link]
        CMP     r1, #0
        CMPNE   r0, r2
        MOVNE   r0, r1
        BNE     %BT05

; add module to chain end - give ROM modules priority.

        STR     r1, [r9, #Module_chain_Link]
        STR     r9, [r0, #Module_chain_Link]
      [ ModHand_InitDieServices
        BL      IssueServicePostInit
      ]
        Pull    "r3, pc"                                ; V clear from EQ compare with 0

01
        Push    "r0"
        LDR     r2, [r9, #Module_code_pointer]
        MOV     r1, #RMAAddress
        MOV     r0, #HeapReason_Free
        SWI     XOS_Heap
        MOV     r2, r9                                  ; node pointer
  [ ChocolateSysHeap
        ASSERT  ChocolateMABlocks = ChocolateBlockArrays + 16
        LDR     r1,=ZeroPage+ChocolateBlockArrays
        LDR     r1,[r1,#16]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
        BL      FreeSysHeapNode
  ]
        SETV
        Pull    "r0, r2, r3, pc"

base_postfix
        =       "Base",0                                ; postfix used for 1st incarnation
        ALIGN

        LTORG

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  [ ModHand_IntrinsicBI
Add_intrinsic_Incarnation  ROUT
         Push   "R0-R3, lr"
         ADD    r2, r9, #ModInfo              ;base incarnation at end of node
         MOV    r3, #Incarnation_Postfix + 5
         B      Add_Incarnation_AltEntry
  ]

; Add_Incarnation
;       takes postfix pointer in R0 (terminated by <= space
;       module node pointer in R9
;       envstring in R10
;   Adds an incarnation node, reinitialises the module

Add_Incarnation  ROUT
         Push   "R0-R3, lr"

         MOV     R3, #Incarnation_Postfix      ; node size needed
01       LDRB    R1, [R0], #1
         ADD     R3, R3, #1
         CMP     R1, #" "
         BGT     %BT01
         BL      ClaimSysHeapNode
         STRVS   R0, [stack]
         Pull   "R0-R3, PC", VS

         LDR     R0, [stack]
Add_Incarnation_AltEntry
         ADD     R3, R2, #Incarnation_Postfix
02       LDRB    R1, [R0], #1
         CMP     R1, #" "
         STRGTB  R1, [R3], #1
         BGT     %BT02
         MOV     R1, #0
         STRB    R1, [R3]

         MOV     R3, #0
         STR     R3, [R2, #Incarnation_Workspace] ; zero private word
         MOV     R12, R2
         BL      CallInit
;         BLVS    FreeIncarnation done by CallInit
         STRVS   R0, [stack]

         LDRVC   R3, [R9, #Module_incarnation_list]
         STRVC   R3, [R2, #Incarnation_Link]
         STRVC   R2, [R9, #Module_incarnation_list]
         Pull   "R0-R3, PC"

;*************************************************************
CallInit         ROUT
;    take R9  -> module node
;         R12 -> incarnation node
;         R10 -> envstring
;    set R11 appropriately
;    initialise module with R10 given

        Push   "R0-R6, R11, R12, lr"

 [ SqueezeMods
        BL      CheckForSqueezedModule                  ; unsqueeze module if squeezed
        BVS     %FT02
 ]

  ; if ChocolateService, we must not add to service chains yet, because we have
  ; to make sure module's init entry is called before service entry (command
  ; and SWI hashing don't have these worries - they won't be used yet)

 [ Oscli_HashedCommands
  ; see if we need to update command hash nodes
        BL      AddCmdHashEntries
        BVS     %FT02
 ]

  ; see if we need to set up a module swi node

        BL      CheckForSWIEntries
        LDR     R12, [stack, #4*(6+2)]
        BNE     %FT03

  ; the module really does have a SWI chunk. Add node to hashtable.
  ; KJB - after v3.71 add new modules at end, on grounds that first-registered
  ; modules are probably more important. Exception is when a second module wants
  ; an already used SWI chunk - it should get priority.

        MOV     R4, R0
        MOV     R11, R1
  [ ChocolateSysHeap
        ASSERT  ChocolateMSBlocks = ChocolateBlockArrays + 20
        LDR     r3,=ZeroPage+ChocolateBlockArrays
        LDR     r3,[r3,#20]
        BL      ClaimChocolateBlock
        MOVVS   R3, #ModSWINode_Size
        BLVS    ClaimSysHeapNode
  |
        MOV     R3, #ModSWINode_Size
        BL      ClaimSysHeapNode
  ]
        BVS     %FT02
        STR     R9,  [R2, #ModSWINode_MListNode]
        STR     R4,  [R2, #ModSWINode_CallAddress]
        STR     R11, [R2, #ModSWINode_Number]
        ModSWIHashval R3,R11
        LDR     R4, [R3]
        B       %FT09
   ; top of loop: R4 = node under consideration, R3 = pointer to this node from previous
08      LDR     R14, [R4, #ModSWINode_Number]
        TEQ     R11, R14                        ; if numbers match, jump to end. This also sets
        BEQ     %FT10                           ;     the new node's link to this node
        ADD     R3, R4, #ModSWINode_Link        ; update R3 to this node's link
        LDR     R4, [R3]                        ; and move R4 to next node
09      TEQ     R4, #0
        BNE     %BT08                           ; if no next node, exit loop and tack on new one
10      STR     R4, [R2, #ModSWINode_Link]
        STR     R2, [R3]

03  ; now prepared to look at module

        LDR     R3, [R9, #Module_code_pointer]

        LDR     R4, [R9, #Module_ROMModuleNode]
        CMP     R4, #0
        BNE     %FT04                           ;It's a ROM module, so it already knows it's code
        Push    "r0-r2"
        LDR     r4, [r3, #-4]                   ;Read the length of the module from the RMA.
        MOV     r0, r3                          ;start address
        MOV     r2, r4                          ;length
        MOV     r1, #&B9                        ;Service_ModulePreInit ; a chance to patch things
        SWI     XOS_ServiceCall
        MOV     r0, #1                          ;It's a ranged synchronisation
        MOV     r1, r3                          ;Start address
        ADD     r2, r3, r4                      ;End address
        SWI     XOS_SynchroniseCodeAreas
        Pull    "r0-r2"
04

        LDR     R4, [R3, #Module_Init]
        CMP     R4, #0
  [ ChocolateService
        BEQ     %FT05
  |
        Pull   "R0-R6, R11, R12, PC", EQ      ; V clear
  ]

        ADD     R12, R12, #Incarnation_Workspace
        MOV     R11, #0
        ADD     R5, R9, #Module_incarnation_list - Incarnation_Link
01      LDR     R5, [R5, #Incarnation_Link]
        CMP     R5, #0                        ; count incarnations
        ADDNE   R11, R11, #1
        BNE     %BT01
        CMP     R11, #0
        LDREQ   R11, [R9, #Module_Hardware]

  ; R11, R12 now set: initialise

        MOV     lr, PC                        ; pseudo BL
        ADD     PC, R3, R4                    ; call 'im

  [ ChocolateService
    ;now safe to try to add to service chains (init entry has been called)
    ;note that AddToServiceChains may cause error (ran out of room)
05
        LDRVC   R12, [stack, #4*(6+2)]
        BLVC    AddToServiceChains
  ]
        Pull   "R0-R6, R11, R12, PC", VC

02      LDR     R12, [stack, #4*(6+2)]
        BL      FreeIncarnation
  [ Oscli_HashedCommands
        BL      FreeCmdHashEntries
  ]
  [ ChocolateService
        BL      RemoveFromServiceChains
  ]
        BL      FreeSWIEntry
        STR     R0, [stack]
        Pull   "R0-R6, R11, R12, PC"           ; V set return

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Enter with module pointer in R1
;              "    size    in R2

CheckHeader ROUT
        Push   "R3, lr"
        LDR     R3, [R1, #Module_HC_Table]
        BL      %FT11
        LDR     R3, [R1, #Module_HelpStr]
        BL      %FT11
        LDR     R3, [R1, #Module_TitleStr]
        BL      %FT11
        LDR     R3, [R1, #Module_Service]
        BL      %FT10
        LDR     R3, [R1, #Module_Die]
        BIC     R3, R3, #&80000000              ; ignore top-bit (means cannot be RMCleared)
        BL      %FT10
        LDR     R3, [R1, #Module_Init]
        TST     R3, #&80000000
        BLEQ    %FT10                           ; only check init offset if an unsqueezed module
; Need to go through extra checks to see that (a) we have a module
; flags table, and (b) it says that we're 32-bit
        LDR     R3, [R1, #Module_SWIChunk]
        TST     R3, #&FF000000
        TSTEQ   R3, #Module_SWIChunkSize-1
        BNE     %FT88
        LDR     R3, [R1, #Module_SWIEntry]
        BL      %FT20
        LDR     R3, [R1, #Module_NameTable]
        BL      %FT21
        LDR     R3, [R1, #Module_NameCode]
        BL      %FT20
        LDR     R3, [R1, #Module_MsgFile]
        BL      %FT20
        LDR     R3, [R1, #Module_FlagTable]
        BL      %FT20
        LDR     R3, [R1, R3]
        TST     R3, #ModuleFlag_32bit
        BEQ     %FT88
        CLRV
        Pull   "R3, PC"

10      TST     R3, #3
        BNE     %FT99
11      CMP     R3, R2
        MOVLO   PC, lr
99
        ADR     R0, ErrorBlock_BadRMHeaderField
      [ International
        BL      TranslateError
      |
        SETV
      ]
        Pull   "R3, PC"

20      TST     R3, #3
        BNE     %FT88
21      CMP     R3, R2
        MOVLO   PC, lr
88
        ADR     R0, ErrorBlock_RMNot32bit
      [ International
        MOV     R3, R4
        LDR     R4, [R1, #Module_TitleStr]
        ADD     R4, R1, R4
        BL      TranslateError_UseR4
        MOV     R4, R3
      |
        SETV
      ]
        Pull   "R3, PC"
        MakeErrorBlock RMNot32bit

        MakeErrorBlock BadRMHeaderField

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Enter with module node pointer in R9
; Sets R12 to module code pointer, R0 SWI code offset, R1 to SWI number
; Only returns SWIs extant if no incarnations of module yet

CheckForSWIEntries ROUT
         LDR     R12, [R9, #Module_incarnation_list]
         CMP     R12, #0
         LDREQ   R12, [R9, #Module_code_pointer]
         LDREQ   R1, [R12, #Module_SWIChunk]
         BICEQ   R1, R1, #Auto_Error_SWI_bit
         TSTEQ   R1, #Module_SWIChunkSize-1
         TSTEQ   R1, #&FF000000
         MOVNE   PC, lr                         ; naff chunk number.
         CMP     R1, #0
         LDRNE   R0, [R12, #Module_SWIEntry]
         CMPNE   R0, #0
         BEQ     %FT02
         TST     R0, #3
         MOVNE   PC, lr
         Push   "R5"
         LDR     R5, [R12, #-4]
         CMP     R5, R0
         Pull   "R5"
01       BLS     %FT02
         ADD     R0, R0, R12
         CMP     R0, R0
         MOV     PC, lr                         ; EQ for success
02       CMP     PC, #0
         MOV     PC, lr                         ; NE return

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Takes R9 pointer to module node; frees any module SWI hashtab node

FreeSWIEntry ROUT
         Push   "R0-R5, R12, lr"
         MRS     R5, CPSR
         BL      CheckForSWIEntries
         BEQ     %FT05
         MSR     CPSR_f, R5
         Pull   "R0-R5, R12, PC"
05
         MOV     R3, R1                ; copy of SWIno
         ModSWIHashval R1
         LDR     R2, [R1], #-ModSWINode_Link

  ; R1 predecessor, R2 currnode, R0 call address, R3 SWIno
  ; look down chain until find right call address and number
01       CMP     R2, #0
         BNE     %FT03
         MSR     CPSR_f, R5
         Pull   "R0-R5, R12, PC"
03
         LDR     R4, [R2, #ModSWINode_CallAddress]
         CMP     R4, R0
         LDREQ   R4, [R2, #ModSWINode_Number]
         CMPEQ   R4, R3
         MOVNE   R1, R2
         LDRNE   R2, [R2, #ModSWINode_Link]
         BNE     %BT01
         LDR     R4, [R2, #ModSWINode_Link]
         STR     R4, [R1,#ModSWINode_Link]
  [ ChocolateSysHeap
         ASSERT  ChocolateMSBlocks = ChocolateBlockArrays + 20
         LDR     r1,=ZeroPage+ChocolateBlockArrays
         LDR     r1,[r1,#20]
         BL      FreeChocolateBlock
         BLVS    FreeSysHeapNode
  |
         BL      FreeSysHeapNode
  ]
         MSR     CPSR_f, R5
         Pull   "R0-R5, R12, PC"

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  [ Oscli_HashedCommands

         ASSERT  Oscli_MHashValMask = &ff

;entry: R11 -> module cmd table, R4-> 8-word (256-bit) sieve workspace
;exit:  sieve updated, R0-R3,R5,R6 trashed
;
CmdHashSieve ROUT
         MOV     R0,R4
         MOV     R1,#0
         MOV     R2,#8
10
         STR     R1,[R0],#4                        ;zero the sieve
         SUBS    R2,R2,#1
         BNE     %BT10
         ;commands with either of these flags set in information word won't be of interest:
         MOV     R5,#FS_Command_Flag :OR: Status_Keyword_Flag
         MOV     R0,R11
18
         MOV     R6,#0                             ;hash value accumulator
         LDRB    R1,[R0],#1
         CMP     R1,#0
         BEQ     %FT40                             ;no more entries
20
         UpperCase R1,R2
         ADD     R6,R6,R1                          ;hash value is sum of upper cased char values
         LDRB    R1,[R0],#1
         CMP     R1,#0
         BNE     %BT20
         ADD     R0,R0,#3
         BIC     R0,R0,#3                          ;align to word boundary
         LDR     R1,[R0,#4]                        ;pick up information word
         TST     R1,R5
         BNE     %FT30                             ;not interested in this type of command
         AND     R6,R6,#&FF                        ;hash value (256-wide)
         AND     R2,R6,#&1F
         MOV     R3,#1
         MOV     R3,R3,LSL R2                      ;position in sieve word
         MOV     R6,R6,LSR #5                      ;sieve word index
         LDR     R1,[R4,R6,LSL #2]
         ORR     R1,R1,R3                          ;set bit in sieve for this hash value
         STR     R1,[R4,R6,LSL #2]
30
         ADD     R0,R0,#4*4                        ;next command entry (skip 4 word fields)
         B       %BT18
40
         MOV     PC,LR

;
;entry: R0 -> Oscli_CmdHashLists array
;       R6 =  hash index
;exit:  node created/expanded if necessary to allow room for at least 1 more hash ptr
;       R1 -> node (may have moved, or been created)
;       OR V set, error returned if no room
;
; - a cmd hash node is:
;           1 word  = max count (according to current size of node)
;           1 word  = current count (N)
;           N words = the entries themselves (entries are module node pointers)
;
CheckRoomForNewCmdHash ROUT
         Push    "R0,R2,R3,LR"
         LDR     R1,[R0,R6,LSL #2]     ;pick up list for this hash value
         CMP     R1,#0
         BNE     %FT10
         Push    "R0,R1"
         MOV     R3,#(5+2)*4           ;enough for 5 entries, plus the two count words
         BL      ClaimSysHeapNode
         STRVS   R0,[SP]
         Pull    "R0,R1"
         BVS     %FT90
         MOV     R1,R2
         MOV     R3,#5
         STR     R3,[R1,#0]            ;set the max count word
         MOV     R3,#0
         STR     R3,[R1,#4]            ;zero the current count word
         STR     R1,[R0,R6,LSL #2]     ;store pointer to node in array
         B       %FT90
10
         LDR     R3,[R1,#0]            ;pick up the max count
         LDR     R2,[R1,#4]            ;pick up thr current count
         ADD     R2,R2,#1              ;need one more entry
         CMP     R2,R3
         BLS     %FT90
         Push    "R0"
         MOV     R0,#HeapReason_ExtendBlock
         MOV     R2,R1
         MOV     R3,#4*4               ;enough for 4 more entries
         BL      DoSysHeapOpWithExtension
         STRVS   R0,[SP]
         Pull    "R0"
         BVS     %FT90
         MOV     R1,R2
         STR     R1,[R0,R6,LSL #2]     ;store pointer to node in array (may have moved)
         LDR     R3,[R1,#0]
         ADD     R3,R3,#4
         STR     R3,[R1,#0]            ;bump max count by 4
90
         STRVS   R0,[SP]
         Pull    "R0,R2,R3,PC"
;
;
;entry: R9 -> module node
;exit:  module entered into command hash table(s) where appropriate
;       OR V set, error returned if no room
;
AddCmdHashEntries ROUT
         Push    "R0-R6,R11,R12,LR"
         LDR     R12,[R9,#Module_incarnation_list]
         CMP     R12,#0
         BNE     %FT90                             ;only do stuff if no incarnations yet
         LDR     R12,[R9,#Module_code_pointer]
         LDR     R11,=UtilityMod
         CMP     R12,R11
         BEQ     %FT90                             ;ignore UtilityModule (Oscli deals directly with it)
         LDR     R11,[R12,#Module_HC_Table]
         CMP     R11,#0
         BEQ     %FT90                             ;no commands
         ADD     R11,R12,R11                       ;R11 -> command table
         SUB     SP,SP,#8*4                        ;256-bit workspace for 256-wide hashing sieve
         MOV     R4,SP
         BL      CmdHashSieve
         ;now our sieve has a bit set for each hash value that this module occupies for commands
         LDR     R0,=ZeroPage
         LDR     R0,[R0,#Oscli_CmdHashLists]
         MOV     R6,#0
42
         AND     R2,R6,#&1F
         MOV     R3,#1
         MOV     R3,R3,LSL R2                      ;position in sieve word
         MOV     R5,R6,LSR #5                      ;sieve word index
         LDR     R1,[R4,R5,LSL #2]
         TST     R1,R3
         BEQ     %FT50                             ;module does not occupy this hash value
         BL      CheckRoomForNewCmdHash            ;returns R1 -> cmd hash node
         BVS     %FT88
         LDR     R2,[R1,#4]                        ;current no. of entries on list
         ADD     R2,R2,#1
         STR     R2,[R1,#4]
         ADD     R1,R1,#4
         STR     R9,[R1,R2,LSL #2]                 ;store ptr to module node at end of list
50
         ADD     R6,R6,#1                          ;next hash value
         CMP     R6,#256
         BLO     %BT42
88
         ADD     SP,SP,#8*4                        ;drop sieve workspace
90
         STRVS   R0,[SP]
         Pull    "R0-R6,R11,R12,PC"
;
;
;entry: R9 -> module node
;exit:  module removed from cmd hash table(s) as necessary
;
FreeCmdHashEntries ROUT
         Push    "R0-R7,R11,R12,LR"
         MRS     R7,CPSR
         LDR     R12,[R9,#Module_incarnation_list]
         CMP     R12,#0
         BNE     %FT90                             ;only do stuff if no incarnations
         LDR     R12,[R9,#Module_code_pointer]
         LDR     R11,=UtilityMod
         CMP     R12,R11
         BEQ     %FT90                             ;ignore UtilityModule (Oscli deals directly with it)
         LDR     R11,[R12,#Module_HC_Table]
         CMP     R11,#0
         BEQ     %FT90                             ;no commands
         ADD     R11,R12,R11                       ;R11 -> command table
         SUB     SP,SP,#8*4                        ;256-bit workspace for 256-wide hashing sieve
         MOV     R4,SP
         BL      CmdHashSieve
         ;now our sieve has a bit set for each hash value that this module occupies for commands
         LDR     R0,=ZeroPage
         LDR     R0,[R0,#Oscli_CmdHashLists]
         MOV     R6,#0
42
         AND     R2,R6,#&1F
         MOV     R3,#1
         MOV     R3,R3,LSL R2                      ;position in sieve word
         MOV     R5,R6,LSR #5                      ;sieve word index
         LDR     R1,[R4,R5,LSL #2]
         TST     R1,R3
         BEQ     %FT50                             ;module does not occupy this hash value
         LDR     R1,[R0,R6,LSL #2]                 ;pick up list for this hash value
         LDR     R2,[R1,#4]                        ;current no. of entries on list
         SUB     R2,R2,#1
         STR     R2,[R1,#4]
         ADD     R1,R1,#8                          ;scrunch list to remove module (R9)
         MOV     R3,R1
         CMP     R2,#0
         BEQ     %FT50
         ADD     R2,R2,#1
40
         LDR     R5,[R1],#4
         CMP     R5,R9
         STRNE   R5,[R3],#4
         SUBS    R2,R2,#1
         BNE     %BT40
50
         ADD     R6,R6,#1                          ;next hash value
         CMP     R6,#256
         BLO     %BT42
         ADD     SP,SP,#8*4                        ;drop sieve workspace
90
         MSR     CPSR_f,R7
         Pull    "R0-R7,R11,R12,PC"                ;MUST preserve flags
;
  ] ;Oscli_HashedCommands

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  [ ChocolateService

     LTORG

; must maintain service call chains, all attached to the 3 moorings in
; kernel workspace:
;
;   - Serv_SysChains holds a fixed array of chain anchors for the 'system'
;     service calls, in the range 1..ServMinUsrNumber
;   - Serv_UsrChains holds an array of hashed list headers, each header
;     holds an array of chains (open ended service number handling for
;     service numbers >= ServMinUsrNumber)
;   - Serv_AwkwardChain is a simple anchor for a single chain of non-compliant
;     modules (either old format, or new format without table) that do not
;     say what service calls they are interested in
;
;  The order of modules on the chains is just a convenient as-seen order, so
;  there will be subtle changes in the order of modules receiving service calls
;  compared to their order in the active module list. This only affects cases
;  where a service call may be claimed. Essentially, the new kernel does not
;  guarantee who gets a chance to claim first, but this was never defined
;  anyway.

;
;a service call chain is a block looking like this:
;  word 0 = current capacity (max entries*entry_size before block must grow)
;  word 1 = current size (current number of entries*entry_size)
;  - followed by an array of the current entries in the chain (cache friendly stuff)
;  - each entry is 3 words and looks like this:
;  word 0 = address of client service handler code
;  word 1 = workspace value for client service handler code
;  word 2 = R1 value for client (will be index for branch table), or 0 meaning pass service number
;
                         ^  0
ServChain_Capacity       #  4
ServChain_Size           #  4
ServChain_Entries        #  0
ServChain_HdrSIZEOF      #  0
;
                         ^  0
ServEntry_Code           #  4
ServEntry_WSpace         #  4
ServEntry_R1             #  4
ServEntry_SIZEOF         #  0
;

;Usr service numbers are those >= ServMinUsrNumber (see below)
;A Usr service array of chains is a block looking like this:
;  word 0 = current capacity max entries*entry_size before block must grow)
;  word 1 = current size (current number of entries*entry_size)
;  - followed by an array of the current entries in the array of chains
;  - each entry is 2 words and looks like this:
;  word 0 = service call number for chain
;  word 1 = anchor for chain (or 0 if no chain allocated)
;
                         ^  0
ServUChArray_Capacity    #  4
ServUChArray_Size        #  4
ServUChArray_Entries     #  0
ServUChArray_HdrSIZEOF   #  0
;
                         ^  0
ServUChEntry_ServiceNo   #  4
ServUChEntry_ChainAnchor #  4
ServUChEntry_SIZEOF      #  0


ServMinUsrNumber         * 256       ;'System' services in range 1..255, 'User' services >= 256
ServUsrHashSize          * 16        ; power of 2

ServMagicInstruction     * &E1A00000 ; (MOV R0,R0) indicates new module format with service table
ServIndexInR1            * 1         ; bit 0 of table flags word, if set, means pass index in R1
                                     ; to handler, rather than service number
                                     ; index corresponds directly to the position of the service
                                     ; number in the table, and starts at 1 (0 is reserved for service claim)

ServInitChainCapacity  * 4         ;no. of entries to start at for a chain block
ServBumpChainCapacity  * 4         ;no. of entries to grow by for a chain block


;hashing function for Usr service numbers is (number + (number>>8)) AND (hashsize-1)
;
        MACRO
        ServHashFunction $result,$service_number
        ADD    $result,$service_number,$service_number,LSR #8
        AND    $result,$result,#ServUsrHashSize-1
        MEND

;
;entry: [R1] -> chain block ([R1] = 0 if no block created yet)
;       R5 = Code for entry, R6 = WSpace for entry, R7 = R1 value for entry
;exit:  [R1] -> chain block (may have been created, or moved if had to grow)
;       V clear if done, V set and error if ran out of room
;
AddServChainEntry  ROUT
         Push    "R0-R4,LR"
         LDR     R2,[R1]            ;get pointer to chain block from anchor
         CMP     R2,#0
         BNE     %FT10
         MOV     R3,#ServChain_HdrSIZEOF + ServInitChainCapacity*ServEntry_SIZEOF
         Push    "R1"
         BL      ClaimSysHeapNode   ;need to create block
         Pull    "R1"
         BVS     %FT90
         STR     R2,[R1]
         MOV     R0,#ServInitChainCapacity*ServEntry_SIZEOF
         STR     R0,[R2,#ServChain_Capacity]
         MOV     R0,#0
         STR     R0,[R2,#ServChain_Size]
10
         LDR     R0,[R2,#ServChain_Size]
         LDR     R3,[R2,#ServChain_Capacity]
         CMP     R0,R3
         BLO     %FT20
         Push    "R0,R1"
         MOV     R3,#ServBumpChainCapacity*ServEntry_SIZEOF
         MOV     R0, #HeapReason_ExtendBlock
         BL      DoSysHeapOpWithExtension   ;need to grow block
         STRVS   R0,[SP]
         Pull    "R0,R1"
         BVS     %FT90
         STR     R2,[R1]
         LDR     R3,[R2,#ServChain_Capacity]
         ADD     R3,R3,#ServBumpChainCapacity*ServEntry_SIZEOF
         STR     R3,[R2,#ServChain_Capacity]
20
         ADD     R3,R2,#ServChain_HdrSIZEOF
         ADD     R3,R3,R0
         STR     R5,[R3,#ServEntry_Code]
         STR     R6,[R3,#ServEntry_WSpace]
         STR     R7,[R3,#ServEntry_R1]
         LDR     R3,[R2,#ServChain_Size]
         ADD     R3,R3,#ServEntry_SIZEOF
         STR     R3,[R2,#ServChain_Size]
90
         STRVS   R0,[SP]
         Pull    "R0-R4,PC"

;
;entry: R2 -> chain block, R5 = Code for entry to remove, R6 = WSpace for entry to remove
;exit:  registers preserved, entry removed and chain scrunched if entry was found
;
RemoveServChainEntry ROUT
         Push    "R0-R4,LR"
         CMP     R2,#0
         BEQ     %FT90
         LDR     R1,[R2,#ServChain_Size]
         CMP     R1,#0
         BEQ     %FT90
         ADD     R3,R2,#ServChain_HdrSIZEOF      ;start of chain
         ADD     R1,R1,R3                        ;end of chain
10
         LDR     R4,[R3,#ServEntry_Code]
         LDR     R0,[R3,#ServEntry_WSpace]
         TEQ     R4,R5
         TEQEQ   R0,R6
         BEQ     %FT20
         ADD     R3,R3,#ServEntry_SIZEOF
         CMP     R3,R1
         BLO     %BT10
         B       %FT90
20
         ADD     R3,R3,#ServEntry_SIZEOF        ;found, scrunch up rest of chain
         CMP     R3,R1
         BHS     %FT30
         LDR     R4,[R3,#ServEntry_Code]
         STR     R4,[R3,#ServEntry_Code - ServEntry_SIZEOF]
         LDR     R4,[R3,#ServEntry_WSpace]
         STR     R4,[R3,#ServEntry_WSpace - ServEntry_SIZEOF]
         LDR     R4,[R3,#ServEntry_R1]
         STR     R4,[R3,#ServEntry_R1 - ServEntry_SIZEOF]
         B       %BT20
30
         LDR     R1,[R2,#ServChain_Size]
         SUB     R1,R1,#ServEntry_SIZEOF
         STR     R1,[R2,#ServChain_Size]
90
         Pull    "R0-R4,PC"

;
;entry: R9 -> module node, R4 -> start of module, R5 -> service handler specified by module header
;exit:  R0 is -> table, or 0 if no table
;
FindServTable ROUT
        Push   "R1-R2,LR"
        MOV    R0,#0
        LDR    R1,[R5]
        LDR    R2,=ServMagicInstruction
        TEQ    R1,R2                    ;check for new format
        BNE    %FT90                    ;nope
        LDR    R0,[R5,#-4]              ;yes, so previous word is anchor (offset) for table
        CMP    R0,#0                    ;if anchor is 0, new format but no table specified
        ADDNE  R0,R0,R4                 ;else get address by adding module start to offset
90
        Pull   "R1-R2,PC"

;
;entry: R2 -> array of chains, R3 = service number, R5,R6,R7 = Code,WSpace,R1 for chain entry
;exit:  R0=1 if success,service number added to array if necessary, entry added to appropriate chain,
;       R0=0 if fail, because service number not yet in array, and array is full (grow not attempted)
;       or V set, error returned if no room (for chain extension)
;
AddServUsr_Hashed ROUT
        Push   "R1-R4,LR"
        ADD    R1,R2,#ServUChArray_HdrSIZEOF    ;chain start
        LDR    R0,[R2,#ServUChArray_Size]
        ADD    R0,R0,R1                         ;chain end
10
        CMP    R1,R0
        BHS    %FT20
        LDR    R4,[R1,#ServUChEntry_ServiceNo]
        TEQ    R4,R3
        ADDNE  R1,R1,#ServUChEntry_SIZEOF
        BNE    %BT10
;found entry for this service number in array
        ADD    R1,R1,#ServUChEntry_ChainAnchor  ;R1 is address of anchor for chain
        BL     AddServChainEntry
        MOVVC  R0,#1
        B      %FT90                            ;succeeded (or OS error because no room)
;
20
;entry for this service number not found, add it if array has room
        LDR    R0,[R2,#ServUChArray_Capacity]
        LDR    R4,[R2,#ServUChArray_Size]
        CMP    R4,R0
        MOVHS  R0,#0
        BHS    %FT90                             ;failed (array needs extension)
        STR    R3,[R1,#ServUChEntry_ServiceNo]   ;add entry at end of current list
        MOV    R4,#0
        STR    R4,[R1,#ServUChEntry_ChainAnchor] ;no chain yet
        LDR    R4,[R2,#ServUChArray_Size]
        ADD    R4,R4,#ServUChEntry_SIZEOF
        STR    R4,[R2,#ServUChArray_Size]
        ADD    R1,R1,#ServUChEntry_ChainAnchor   ;R1 is address of anchor for chain
        BL     AddServChainEntry
        MOVVC  R0,#1
90
        Pull   "R1-R4,PC"

;
;entry: R2 -> hash header array, R3 = service number, R5,R6,R7 = Code,WSpace,R1 for chain entry
;exit:  service number added to array on appropriate hash list if necessary, entry added to appropriate chain,
;       or V set, error returned if no room (for either chain or chain array extension)
;
AddServUsr ROUT
        Push   "R0-R4,LR"
        ServHashFunction R4,R3          ;result in R4
        ADD    R1,R2,R4,LSL #2          ;R1 -> entry for this service number in hash header array
        LDR    R2,[R1]                  ;pick up anchor for array of chains
        CMP    R2,#0
        BNE    %FT10
;must create array of chains
        Push   "R1,R3"
        MOV    R3,#ServUChArray_HdrSIZEOF + 4*ServUChEntry_SIZEOF  ;initially room for 4 entries
        BL     ClaimSysHeapNode
        Pull   "R1,R3"
        BVS    %FT90
        STR    R2,[R1]
        MOV    R0,#4*ServUChEntry_SIZEOF
        STR    R0,[R2,#ServUChArray_Capacity]
        MOV    R0,#0
        STR    R0,[R2,#ServUChArray_Size]
10
        BL     AddServUsr_Hashed
        BVS    %FT90
        CMP    R0,#1
        BEQ    %FT90                          ;add succeeded, done
;add failed, so we need to grow the array of chains
        Push   "R1,R3"
        MOV    R3,#4*ServUChEntry_SIZEOF      ;bump up capacity by 4 entries
        MOV    R0, #HeapReason_ExtendBlock
        BL     DoSysHeapOpWithExtension
        Pull   "R1,R3"
        BVS    %FT90
        STR    R2,[R1]
        LDR    R0,[R2,#ServUChArray_Capacity]
        ADD    R0,R0,#4*ServUChEntry_SIZEOF
        STR    R0,[R2,#ServUChArray_Capacity]
;now we can do the add and it cannot fail
        BL     AddServUsr_Hashed
90
        STRVS  R0,[SP]
        Pull   "R0-R4,PC"

;
;entry: R3 = service number, R5,R6,R7 = Code,WSpace,R1 for chain entry
;exit:  registers preserved, entry added to appropriate chain,
;       or V set, error returned if no room
;
AddServSysOrUsr ROUT
        Push   "R0-R4,LR"
        CMP    R3,#ServMinUsrNumber
        BHS    %FT50
        LDR    R1,=ZeroPage+Serv_SysChains
        LDR    R2,[R1]
        CMP    R2,#0
        BNE    %FT30
;need to create array of service chain anchors, for service codes 0 to ServMinUserNumber-1
;(0 is not used, because reserved for service cliamed, but done for convenience)
        Push   "R1,R3"
        MOV    R3,#ServMinUsrNumber*4
        BL     ClaimSysHeapNode
        Pull   "R1,R3"
        BVS    %FT90
        STR    R2,[R1]
        MOV    R0,#0
        MOV    LR,#ServMinUsrNumber
        MOV    R4,R2
10
        STR    R0,[R4],#4             ;zero the anchors (no chains yet)
        SUBS   LR,LR,#1
        BNE    %BT10
30
        ADD    R1,R2,R3,LSL #2        ;address of anchor for this Sys service number
        BL     AddServChainEntry      ;add to chain
        B      %FT90
;
50
        LDR    R1,=ZeroPage+Serv_UsrChains
        LDR    R2,[R1]
        CMP    R2,#0
        BNE    %FT70
;need to create array of hash headers for Usr chain arrays
        Push   "R1,R3"
        MOV    R3,#ServUsrHashSize*4
        BL     ClaimSysHeapNode
        Pull   "R1,R3"
        BVS    %FT90
        STR    R2,[R1]
        MOV    R0,#0
        MOV    LR,#ServUsrHashSize
        MOV    R4,R2
60
        STR    R0,[R4],#4             ;zero the hash headers
        SUBS   LR,LR,#1
        BNE    %BT60
70
        BL     AddServUsr
90
        STRVS  R0,[SP]
        Pull   "R0-R4,PC"

;
;entry: R9 -> module node, R12 -> incarnation node
;exit:  module incarnation added onto service call chains as necessary
;       OR V set, error returned if no room
;
; IRQs are disabled during update to make sure service distribution does not happen
; under interrupt, with possibly incomplete chains still under construction. A little
; worrying that this may mean interrupts are sometimes off for a while, but there you go.
;
AddToServiceChains ROUT
        Push   "R0-R8,LR"
        MRS    R8,CPSR
        ORR    R4,R8,#I32_bit
        MSR    CPSR_c,R4                     ;IRQs off for update of chain structures
        LDR    R4,[R9,#Module_code_pointer]  ;start of module
        LDR    R5,[R4,#Module_Service]
        CMP    R5,#0
        BEQ    %FT90
        ADD    R5,R5,R4
        ADD    R6,R12,#Incarnation_Workspace
        BL     FindServTable
        CMP    R0,#0
        BEQ    %FT50
        LDR    R1,[R0],#4            ;flags word from table
        LDR    R5,[R0],#4            ;handler code offset from table
        ADD    R5,R5,R4              ;handler code address
        MOV    R2,#0
10
        ADD    R2,R2,#1              ;next index in table (start at 1)
        LDR    R3,[R0],#4            ;next service call number from table
        CMP    R3,#0                 ;table terminated by 0
        BEQ    %FT90
        TST    R1,#ServIndexInR1
        MOVNE  R7,R2                 ;we must pass index to handler
        MOVEQ  R7,#0                 ;we must pass service number
        BL     AddServSysOrUsr
        BVS    %FT90
        B      %BT10
;
50      ;awkward customer, with no service table
        MOV    R7,#0                 ;must pass service number to handler (there is no index)
        LDR    R1,=ZeroPage+Serv_AwkwardChain
        BL     AddServChainEntry
90
        STRVS  R0,[SP]
        MSR    CPSR_c,R8             ;restore IRQ state (26-bit code used to corrupt V!)
        Pull   "R0-R8,PC"

;
;entry: R9 -> module node, R12 -> incarnation node
;exit:  module incarnation removed from service call chains as necessary
;       flags preserved
;
; IRQs are disabled during update to make sure service distribution does not happen
; under interrupt, with possibly incomplete chains still under construction. A little
; worrying that this may mean interrupts are sometimes off for a while, but there you go.
;
RemoveFromServiceChains ROUT
        Push   "R0-R8,R10,LR"
        MRS    R10,CPSR
        ORR    R4,R10,#I32_bit
        MSR    CPSR_c,R4                     ;IRQs off for update of chain structures
        LDR    R4,[R9,#Module_code_pointer]
        LDR    R5,[R4,#Module_Service]
        CMP    R5,#0
        BEQ    %FT90
        ADD    R5,R5,R4
        ADD    R6,R12,#Incarnation_Workspace
        BL     FindServTable
        CMP    R0,#0
        BEQ    %FT50
        LDR    R1,[R0],#4            ;flags word from table
        LDR    R5,[R0],#4            ;handler code offset from table
        ADD    R5,R5,R4              ;handler code address
10
        LDR    R3,[R0],#4            ;next service call number from table
        CMP    R3,#0                 ;table terminated by 0
        BEQ    %FT90
        CMP    R3,#ServMinUsrNumber
        BHS    %FT20
        LDR    R1,=ZeroPage+Serv_SysChains
        LDR    R1,[R1]
        CMP    R1,#0
        BEQ    %BT10
        ADD    R1,R1,R3,LSL #2
        LDR    R2,[R1]               ;pick up anchor for Sys chain
        BL     RemoveServChainEntry
        B      %BT10
;
20
        ServHashFunction R4,R3       ;result in R4
        LDR    R1,=ZeroPage+Serv_UsrChains
        LDR    R1,[R1]
        CMP    R1,#0
        BEQ    %BT10
        LDR    R1,[R1,R4,LSL #2]     ;pick up anchor for array of chains
        CMP    R1,#0
        BEQ    %BT10
        LDR    R8,[R1,#ServUChArray_Size]
        ADD    R4,R1,#ServUChArray_HdrSIZEOF  ;chain start
        ADD    R8,R8,R4                       ;chain end
30
        CMP    R4,R8
        BHS    %BT10
        LDR    LR,[R4,#ServUChEntry_ServiceNo]
        TEQ    LR,R3
        ADDNE  R4,R4,#ServUChEntry_SIZEOF
        BNE    %BT30
        LDR    R2,[R4,#ServUChEntry_ChainAnchor]
        BL     RemoveServChainEntry
        B      %BT10
;
50
        LDR    R1,=ZeroPage+Serv_AwkwardChain
        CMP    R1,#0
        BEQ    %FT90
        LDR    R2,[R1]
        BL     RemoveServChainEntry
90
        MSR    CPSR_cf,R10                ;restore IRQ state
        Pull   "R0-R8,R10,PC"             ;MUST preserve flags

  ] ;ChocolateService

        LTORG

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

FreeIncarnation  ROUT
  ; copy error, free any workspace, incarnation link.
  ;   R12 incarnation pointer, R9 module node pointer
         Push   "R0-R2,R5,lr"
         MRS     R5, CPSR
         BL      Module_CopyError
         STR     R0, [stack]
         LDR     R2, [R12, #Incarnation_Workspace]
         CMP     R2, #0
         MOV     R0, #HeapReason_Free
         MOV     R1, #RMAAddress
         SWINE   XOS_Heap
  [ ModHand_IntrinsicBI
         SUB     R2, R12, R9
         CMP     R2, #ModInfo
         BEQ     FreeIncarnation_Exit   ;if equal, this is the intrinsic incarnation 'node'
  ]
         MOV     R2, R12
         BL      FreeSysHeapNode
FreeIncarnation_Exit
         MSR     CPSR_f, R5
         Pull   "R0-R2,R5,PC"

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; KillAndFree:
;      R0 -> module
;      R2 -> prevmodule
;  Kills all incarnations, frees all space.

KillAndFree      ROUT
         Push   "R2, R3, R9, R12, lr"
         MOV     R9, R0
         ADDS    R3, R9, #Module_incarnation_list  ; ensure V clear
01       LDR     R12, [R9, #Module_incarnation_list]
         BL      KillIncarnation
         Pull   "R2, R3, R9, R12, PC", VS
         CMP     R9, #0
         BNE     %BT01                      ; more incarnations yet
         Pull   "R2, R3, R9, R12, PC"

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; KillIncarnation
;     R9  module ptr
;     R12 incarnation ptr
;     R3  previous incarnation
;     R2  previous module
; Exit: R9 zeroed if module completely gone
;
KillIncarnation  ROUT
         Push   "R0-R2, R6, R10, lr"
         MRS     R6, CPSR
         MOV     R10, #1                     ; fatal die
         CMP     r12, #0                     ; fudge for 0 incarnations:
         BLNE    CallDie                     ; tidy up anyway
         STRVS   R0, [stack]
         Pull   "R0-R2, R6, R10, PC", VS
       [ ModHand_InitDieServices
         BL      IssueServicePostFinal
       ]
  [ ModHand_IntrinsicBI
         SUB     R2, R12, R9
         CMP     R2, #ModInfo
         BEQ     %FT01         ;if equal, this is the intrinsic incarnation 'node'
  ]
         MOV     R2, R12
         BL      FreeSysHeapNode                ; free incarnation node
01       LDR     R0, [R9, #Module_incarnation_list]
         CMP     R0, #0                      ; last incarnation?
         LDREQ   R2, [stack, #2*4]
         BLEQ    DelinkAndFreeModule
         MOVEQ   R9, #0
         MSR     CPSR_f, R6
         Pull   "R0-R2, R6, R10, PC"

LoseModuleSpace_if_its_the_only_incarnation
         Push   "R0-R2, R6, R10, lr"
         MRS     R6, CPSR
         B       %BT01

;*************************************************************
; CallDie
;    take R9  -> module node
;         R12 -> incarnation node
;         R3  -> previous incarnation
;         R10 =  fatality
; check against CAO
; delink incarnation, issue die, deal with workspace.

CallDie ROUT
         Push   "R0-R7, R11, R12, lr"
         MRS     R7, CPSR

         LDR     R11, =ZeroPage
         LDR     R11, [R11, #Curr_Active_Object]

 ; check killability

         LDR     R0,  [R9, #Module_code_pointer]
         BL      %FT10                        ; is_CAO?
         BLO     %FT04                        ; code block is CAO

 ; check if workspace block could be CAO: may have handler in there

         LDR     R0, [R12, #Incarnation_Workspace]
         BL      %FT20                        ; check block before getting size
         BVS     ModuleIsntCAO                ; not heap block - we don't
         BL      %FT10                        ; know what's going on.
         BHS     ModuleIsntCAO                ; not CAO

04       CMP     R10, #0                      ; fatal?
         BNE     CantKill
         LDR     R0, [R12, #Incarnation_Workspace]
         BL      %FT20
         BVS     ModuleIsntCAO                ; soft die of non-heap module OK
CantKill
         ADR     R0, ErrorBlock_CantKill
       [ International
         BL      TranslateError
       ]
01       STR     R0, [stack]
         LDR     R3, [stack, #4*3]
         LDR     R12, [stack, #4*(7+2)]
         STR     R12, [R3, #Incarnation_Link] ; relink
         ORR     R7, R7, #V_bit
         MSR     CPSR_f, R7
         Pull   "R0-R7, R11, R12, PC"
         MakeErrorBlock CantKill

ModuleIsntCAO
         MOV     R11, #0                     ; set R11 to incarnation number.
         LDR     R0, [R9, #Module_incarnation_list]
03       CMP     R0, R12
         ADDNE   R11, R11, #1
         LDRNE   R0, [R0, #Incarnation_Link]
         BNE     %BT03

  [ ChocolateService
         ;remove from service chains now, as part of delink
         BL      RemoveFromServiceChains
  ]
         LDR     R0, [R12, #Incarnation_Link]
         STR     R0, [R3, #Incarnation_Link] ; delink
         ADD     R12, R12, #Incarnation_Workspace
         LDR     R1, [R9, #Module_code_pointer]
         LDR     R0, [R1, #Module_Die]
         BIC     R0, R0, #&80000000          ; knock out invincibility bit
         CMP     R0, #0                      ; WARNING: don't try to combine these 2 instructions in a BICS - it wouldn't clear V
         MOV     lr, PC
         ADDNE   PC, R1, R0                  ; call.
  [ ChocolateService
         BVC     HaveKilled
         ;add back to service chains as part of relink (cant error through lack of memory, since we had room before delink)
         LDR     R12, [stack, #4*(7+2)]
         BL      AddToServiceChains
         B       %BT01
HaveKilled
  |
         BVS     %BT01
  ]
  [ Oscli_HashedCommands
         BL      FreeCmdHashEntries
  ]
         BL      FreeSWIEntry

         CMP     R10, #0                     ; soft die?
         BEQ     %FT02

         LDR     R12, [stack, #4*(7+2)]
         LDR     R2, [R12, #Incarnation_Workspace]
         CMP     R2, #0
         MOVNE   R1, #RMAAddress
         MOVNE   R0, #HeapReason_Free
         SWINE   XOS_Heap
         MOV     R0, #0
         STR     R0, [R12, #Incarnation_Workspace]   ; orgone
02
         BIC     R7, R7, #V_bit
         MSR     CPSR_f, R7
         Pull   "R0-R7, R11, R12, PC"

; check if block @@ R0 contains address R11
10       LDR     R1, [R0, #-4]
         ADD     R1, R1, R0
         CMP     R0, R11
         CMPLS   R11, R1
         MOV     PC, lr                      ; return LO for Yes

; check block @@ R0 is a valid RMA heap block
20
         Push   "R0-R3, lr"
         MOV     R2, R0
         MOV     R0, #HeapReason_ExtendBlock
         MOV     R1, #RMAAddress
         MOV     R3, #0
         SWI     XOS_Heap
         Pull   "R0-R3, PC"                 ; V set if not.

;*************************************************************
; DelinkAndFreeModule
;       R9 -> Module
;       R2 -> prevmodule

DelinkAndFreeModule ROUT
        Push    "R0-R2,R5,lr"
        MRS     R5, CPSR

;   loop here to find predecessor; make death re-entrant
        LDR     R0, =ZeroPage+Module_List
01
        LDR     R1, [R0, #Module_chain_Link]
        CMP     R1, R9
        MOVNE   R0, R1
        BNE     %BT01

        LDR     R1, [R9, #Module_chain_Link]
        STR     R1, [R0, #Module_chain_Link] ; delinked

        LDR     R2, [R9, #Module_code_pointer]
        MOV     R1, #RMAAddress
        MOV     R0, #HeapReason_Free
        SWI     XOS_Heap

        MOV     R2, R9
  [ ChocolateSysHeap
        ASSERT  ChocolateMABlocks = ChocolateBlockArrays + 16
        LDR     r1,=ZeroPage+ChocolateBlockArrays
        LDR     r1,[r1,#16]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
        BL      FreeSysHeapNode
  ]

        MSR     CPSR_f, R5
        Pull   "R0-R2,R5,PC"

;*************************************************************************
;  common lookup for reinit, enter, die
;
; Exits with EQ if incarnation not specified, NE if incarnation specified
; and found.

lookup_commoned ROUT
       Push    "lr"
       WritePSRc SVC_mode, lr               ; we will exit with IRQs enabled
       BL       LookUp_Module               ; node ptr in R0
       BEQ      %FT01                       ; not found
       CMP      R12, #-1
       BEQ      %FT02                       ; incarnation not found
       CMP      R12, #0
       MOV      R9, R0
       Pull    "PC"
01
       ADR      R0, ErrorBlock_RMNotFound
       Push    "r1-r6"
       LDR      r3, =ZeroPage
       LDR      r3, [r3, #IRQsema]
       CMP      r3, #0
       BNE      %FT03
     [ International
       MOV      R4, R1
       BL       TranslateError_UseR4
       Push     "r0"
     |
       BL       GetOscliBuffer
       Push     r5
       LDR      r2, [r0], #4
       STR      r2, [r5], #4
       BL       rmecopystr
copynfrmname
       LDRB     r2, [r1], #1
       CMP      r2, #32
       STRGTB   r2, [r5], #1
       BGT      copynfrmname

       BL       rmecopystr
       STRB     r2, [r5]                   ; terminate
     ]
       Pull    "r0-r6"


03
       SETV
       Pull    "PC"
       MakeErrorBlock  RMNotFound
02
       ADR      R0, ErrorBlock_IncarnationNotFound
     [ International
       BL      TranslateError
     ]
       B        %BT03
       MakeErrorBlock  IncarnationNotFound

MakeNotFoundError                         ; r1 -> module name
       Push     lr
       B        %BT01

;*************************************************************
; Lookup_Module
; Entry:  R1  -> module name
; Exit:   R0  -> module chain node   (0 for not found)
;         R1  -> postfix of name
;         R12 -> incarnation node    (0 for not specified, -1 for not found)
;         R2  -> previous module      for potential delinking
;         R3  -> previous incarnation  "      "         "
;         NE for found/EQ for not


LookUp_Module ROUT
         Push   "R4, R5, lr"

         WritePSRc SVC_mode, R2              ; interrupts on
         LDR     R2, =ZeroPage+Module_List
01       LDR     R0, [R2, #Module_chain_Link]
         CMP     R0, #0
         Pull   "R4, R5, PC", EQ             ; return if not found
         LDR     R4, [R0, #Module_code_pointer]
         LDR     R3, [R4, #Module_TitleStr]
         ADD     R3, R3, R4                  ; got ptr to title
         MOV     R4, #Postfix_Separator      ; allowed terminator for StrCmp
         BL      Module_StrCmp               ; compare with abbreviation.
         MOVNE   R2, R0
         BNE     %BT01                       ; loop if not found
         LDRB    R4, [R1], #1                ; get terminator
         CMP     R4, #Postfix_Separator
         BEQ     %FT02

   ; now a quick fudge to spot recursive ModHand calls during module death.
         LDR     R12, [R0, #Module_incarnation_list]
         CMP     R12, #0
         MOVEQ   R12, #-1                    ; no incarnations!
         MOVNE   R12, #0                     ; no postfix/incarnation specified
         CMP     PC, #0
         Pull   "R4, R5, PC"                 ; back with NE

02       LDRB    R4, [R1]
         CMP     R4, #" "
         BGT     %FT03
         CMP     R1, R1                      ; force EQ
         Pull   "R4, R5, PC"                 ; not found: naff postfix
03
         Push   "R1"                         ; updated value to return
         BL      FindIncarnation
         MOVEQ   R12, #-1                    ; failed to find postfix.
         CMP     PC, #0                      ; force NE
         Pull   "R1, R4, R5, PC"             ; back with NE

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; FindIncarnation
;    R0 is node pointer, need to loop to find incarnation ($R1)
;    Return EQ if not found,
;           NE => R12 -> incarnation, R3 -> previnc

FindIncarnation  ROUT
         Push   "lr"
         ADD     R3, R0, #Module_incarnation_list  ; previnc
03       LDR     R12, [R3, #Incarnation_Link]
         CMP     R12, #0
         Pull   "PC", EQ                     ; failed to find postfix.
         Push   "R3,R4"
         ADD     R3, R12, #Incarnation_Postfix
         MOV     R4, #0                      ; no special terminator
         BL      Module_StrCmp
         Pull   "R3,R4"
         MOVNE   R3, R12
         BNE     %BT03
         CMP     PC, #0                      ; force NE
         Pull   "PC"

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Module_StrCmp
;
; Do a string comparison, given pointers in R1, R3.
; Ignore case, allow $R1 to be an abbreviation of $R3
; Strings are terminated by ctrl-char, or ASC(R4) for $R1
;
; out:  EQ => match found, R1 -> terminator of R1 string
;       NE => match not found, R1 preserved
;       R3 corrupted in all cases
;

Module_StrCmp Entry "r1,r2,r5-r7"
        MOV     r2, #0
01
        LDRB    r7, [r1], #1
        LDRB    r5, [r3], #1
        CMP     r7, r4
        CMPNE   r7, #32
        CMPLE   r5, #32
        BLE     %FT02
        UpperCase r7, r6
        UpperCase r5, r6
        CMP     r7, r5
        ADDEQ   r2, r2, #1
        BEQ     %BT01
        CMP     r2, #0
        TOGPSR  Z_bit, r2                       ; invert EQ/NE
        CMPEQ   r7, #"."                        ; success if abbreviation
        EXIT    NE
        CMP     r5, #" "                        ; reject abbreviation
        EXIT    LT                              ; after full match
        ADD     r1, r1, #1
02
        SUB     r1, r1, #1
        CMP     r2, #0                          ; reject 0-length match
        TOGPSR  Z_bit, r2                       ; invert EQ/NE
        STREQ   r1, [stack]                     ; r1 -> terminator
        EXIT                                    ; return with success

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

EnvStringSkipName ROUT
         Push   "R0"
01       LDRB    R0, [R10], #1
         CMP     R0, #" "
         BGT     %BT01
02       LDREQB  R0, [R10], #1
         CMP     R0, #" "
         BEQ     %BT02
         SUB     R10, R10, #1
         Pull   "R0"
         MOV     PC, lr

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; PreferIncarnation
;    R9  -> module node
;    R12 -> incarnation node
;    R3  -> previous incarnation
PreferIncarnation
         Push   "R0"
         LDR     R0,  [R12, #Incarnation_Link]
         STR     R0,  [R3,  #Incarnation_Link]
         LDR     R0,  [R9,  #Module_incarnation_list]
         STR     R0,  [R12, #Incarnation_Link]
         STR     R12, [R9,  #Module_incarnation_list]
         Pull   "R0"
         MOV     PC, R14

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module_CopyError ROUT
; grab an oscli buffer for the error,
; rather than having a permanent module buffer
       Push     "R0, R2, R5, R6, lr"
       BL        GetOscliBuffer

       STR       R5, [stack]
       LDR       R2, [R0], #4
       STR       R2, [R5], #4
01     LDRB      R2, [R0], #1
       STRB      R2, [R5], #1
       CMP       R2, #0
       BNE       %BT01
       Pull     "R0, R2, R5, R6, PC"

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;  Claim chunk from RMA : increase RMA if can,
;  force size to multiple of 32 -4 to keep alignment OK

RMAClaim_Chunk   ROUT
         MOV     R0, #HeapReason_Get
         Push   "R0, R3, lr"

         ADD     R3, R3, #31+4               ; now force size to 32*n-4
         BIC     R3, R3, #31                 ; so heap manager always has
         SUB     R3, R3, #4                  ;  8-word aligned blocks

         B       IntoRMAHeapOp

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DoRMAHeapOpWithExtension
         Push   "R0, R3, lr"

IntoRMAHeapOp
         MOV     R1, #RMAAddress
         SWI     XOS_Heap
         Pull   "R0, R3, PC", VC

         LDR     r14, [r0]                   ; look at error number
         TEQ     r14, #ErrorNumber_HeapFail_Alloc
         STRNE   r0, [stack]
         Pull   "r0, r3, PC", NE            ; can only retry if ran out of room

         Push    r3                         ; in case extension
         LDR     r1, [stack, #4]
         CMP     r1, #HeapReason_ExtendBlock
         BNE     notRMAextendblock
         Push   "r5, r6"
         LDR     r1, [r2, #-4]               ; pick up block size
         ADD     r5, r1, r2                  ; block end +4
         SUB     r5, r5, #4                  ; TMD 02-Aug-93: block size includes size field (optimisation was never taken)
         MOV     r6, #RMAAddress
         LDR     r6, [r6, #:INDEX:hpdbase]
         ADD     r6, r6, #RMAAddress         ; free space
         CMP     r5, r6                      ; does block butt against end?
         ADDNE   r3, r3, r1                  ; max poss size needed
         Pull   "r5, r6"

  ; note that this doesn't cope well with a block at the end preceded by a
  ; free block, but tough.

notRMAextendblock
         MOV     r1, #RMAAddress
         LDR     R0, [R1, #:INDEX: hpdbase]
         LDR     R1, [R1, #:INDEX: hpdend]
         SUB     R1, R1, R0                  ; bytes free
         SUB     R1, R3, R1                  ; bytes needed

         Pull    r3
         ADD     R1, R1, #8                  ; safety factor

         MOV     R0, #1                      ; try and expand RMA.
         SWI     XOS_ChangeDynamicArea
         Pull   "R0"                         ; heap reason code back
         MOV     R1, #RMAAddress
         SWIVC   XOS_Heap
01
         ADRVSL  R0, ErrorBlock_MHNoRoom
       [ International
         Push   "LR",VS
         BLVS    TranslateError
         Pull   "LR",VS
       ]
         Pull   "r3, PC"

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data

crstring =       13
         ALIGN

;*****************************************************************************
; *Unplug code.

Unplug_Code Entry "r7-r9"
        CMP     r1, #0
        BNE     ZapTheModule

; If name not given, list unplugged modules

;       MOV     r1, #0                          ; start with module 0 (r1 is already zero indicating no parameters to command!)
        MOV     r2, #-1                         ; start with main ROMs
        MOV     r7, #0                          ; flag indicating whether we've had any unplugged modules already
10
        MOV     r0, #ModHandReason_EnumerateROM_ModulesWithInfo
        SWI     XOS_Module
        BVS     %FT30                           ; no more, so finish off
        CMP     r4, #-1                         ; is it unplugged?
        BNE     %BT10                           ; no, then go for another one

        MOV     r8, r1                          ; save module and podule numbers
        MOV     r9, r2
        TEQ     r7, #0                          ; if already printed header message
        BNE     %FT20                           ; then skip
      [ International
        BL      WriteS_Translated
        =       "Unp:Unplugged modules are:", 10, 13, 0
        ALIGN
      |
        ADR     r0, AreUnpluggedMessage
        SWI     XOS_Write0
      ]
        EXIT    VS
        MOV     r7, #1
20
        MOV     r0, r3
        SWI     XOS_Write0
        EXIT    VS
        CMP     r2, #-1
        BEQ     %FT25                           ; if a main ROM, then no blurb after name (and V=0)
      [ International
        MOV     r4, r2
      |
        ADRGT   r4, podbra                      ; is a podule module
        ADRLT   r4, extnbra                     ; is an extn rom module
      ]
        MVNLT   r2, r2                          ; so invert number
        SUB     r0, r0, r3                      ; length of module name
        RSB     r0, r0, #24                     ; number of spaces to pad out to column 24 (may be -ve)
21
        SWI     XOS_WriteI + " "                ; always print at least one space
        EXIT    VS
        SUBS    r0, r0, #1
        BGT     %BT21
      [ :LNOT: International
        MOV     r0, r4
        SWI     XOS_Write0
        EXIT    VS
      ]
        SUB     sp, sp, #3*4                    ; make buffer on stack
        MOV     r0, r2
        MOV     r1, sp
        MOV     r2, #3*4
        SWI     XOS_ConvertCardinal4
      [ International
        CMP     r4,#-1
        MOV     r4,r0                           ; r4 -> number
        BLT     %FT23
        BL      WriteS_Translated_UseR4
        =       "Podule:(Podule %0)",0
        ALIGN
        B       %FT24
23
        BL      WriteS_Translated_UseR4
        =       "Extn:(Extn ROM  %0)",0
        ALIGN
24
        ADD     sp, sp, #3*4                    ; restore stack
      |
        SWIVC   XOS_Write0
        ADD     sp, sp, #3*4                    ; restore stack
        SWIVC   XOS_WriteI + ")"
      ]
25
        SWIVC   XOS_NewLine
        MOVVC   r1, r8                          ; restore module and podule number
        MOVVC   r2, r9
        BVC     %BT10
        EXIT

30
        CMP     r7, #0                          ; NB will clear V in any case
      [ International
        BNE     %FT31
        BL      WriteS_Translated
        =       "NoUnp:No modules are unplugged", 10, 13, 0
        ALIGN
31
        EXIT
      |
        ADREQ   r0, NoUnpluggedMessage
        SWIEQ   XOS_Write0
        EXIT                                    ; exit with V=0 unless error in Write0

AreUnpluggedMessage
        =       "Unplugged modules are:", 10, 13, 0
NoUnpluggedMessage
        =       "No modules are unplugged", 10, 13, 0
podbra
        =       "("
rommposp
        =       "Podule ", 0
extnbra
        =       "("
rommposer
        =       "Extn ROM ", 0
        ALIGN
      ]

ZapTheModule
        MOV     r9, #0                          ; indicate unplug, not insert
UnplugInsertEntry
        MOV     r12, #0                         ; search from start of chain
        MOV     r7, r0                          ; name pointer
        MOV     r4, #0                          ; no extra terminator
        MOV     r5, #0                          ; indicate no versions found yet

        MOV     r6, #0                          ; indicate no version found that was initialised
        MOV     r1, r7
        BL      SkipToSpace                     ; leaves r1 pointing to 1st space or control char
        BL      SkipSpaces                      ; leaves r1 -> 1st non-space, r0 = 1st non-space char
        CMP     r0, #&7F
        CMPNE   r0, #" "                        ; if a ctrl char, then
        MOVLS   r8, #&80000000                  ; indicate to unplug all versions
        BLS     %FT40
        CMP     r0, #"-"
        ADDEQ   r1, r1, #1
        MOVEQ   r8, #-1
        MOVNE   r8, #1
        MOV     r0, #1 :SHL: 31                 ; check terminator is control char or space
        SWI     XOS_ReadUnsigned
        EXIT    VS
        MUL     r8, r2, r8                      ; apply sign
40
        MOV     r1, r7
        BL      FindROMModule
        TEQ     r12, #0
        BEQ     %FT60                           ; no versions of this module found, so report error

42
        LDR     r14, [r12, #ROMModule_OlderVersion]     ; find oldest version of this module
        TEQ     r14, #0
        MOVNE   r12, r14
        BNE     %BT42

45
        TEQ     r8, #&80000000                  ; if not doing any old podule
        LDRNE   r14, [r12, #ROMModule_PoduleNumber]
        TEQNE   r14, r8                         ; and podule number doesn't match
        BNE     %FT50                           ; then skip this one

        LDRB    r14, [r12, #ROMModule_Initialised] ; if this version of CODE was initialised then keep pointer to it
        TEQ     r14, #0
        MOVNE   r6, r12                         ; save pointer to it
        MOV     r5, #&FF                        ; set up byte mask (and indicate found)
        LDR     r1, [r12, #ROMModule_CMOSAddrMask]
        AND     r3, r5, r1, LSR #16             ; get bit mask
        ANDS    r1, r1, r5
        BEQ     %FT50                           ; if no CMOS, then look for another module
        MOV     r0, #ReadCMOS
        SWI     XOS_Byte
        EXIT    VS
        TEQ     r9, #0
        ORREQ   r2, r2, r3                      ; set unplug bit
        BICNE   r2, r2, r3                      ; or clear it as appropriate
        MOV     r0, #WriteCMOS
        SWI     XOS_Byte
        EXIT    VS
50
        LDR     r14, [r12, #ROMModule_NewerVersion] ; go to next newer version
        TEQ     r14, #0
        MOVNE   r12, r14
        BNE     %BT45

60
        TEQ     r5, #0                          ; if we've seen any versions, then don't report error
        BNE     %FT70
        ADR     r0, ErrorBlock_RMNotFoundInROM
      [ International
        BL      TranslateError
      |
        SETV
      ]
        EXIT

70
        CMP     r9, #1                          ; if doing unplug not insert
        CMPNE   r6, #0                          ; and we found a match on an initialised version (else V=0)
 [ 1 = 1
;RCM's fix for MED-04173
        EXIT    EQ

; see if module is active, by checking for module in module list
        LDR     r0, =ZeroPage+Module_List
60
        LDR     r0, [r0, #Module_chain_Link]
        TEQ     r0, #0                          ; module not active
        BEQ     %FT90
        LDR     r1, [r0, #Module_ROMModuleNode] ; get active module's pointer to ROM module node
        TEQ     r1, r12                         ; if it matches
        BNE     %BT60

        MOV     r0, #ModHandReason_Delete       ; then tell him he's dead
        LDR     r1, [r6, #ROMModule_Name]
        SWI     XOS_Module
90
 |
        MOVNE   r0, #ModHandReason_Delete       ; then tell him he's dead
        LDRNE   r1, [r6, #ROMModule_Name]
        SWINE   XOS_Module
 ]
        EXIT

RMInsert_Code ALTENTRY
        MOV     r9, #1                          ; indicate insert, not unplug
        B       UnplugInsertEntry

        MakeErrorBlock RMNotFoundInROM

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ ModHand_InitDieServices
; IssueServicePostInit
; On entry
;  R9  -> module chain node
;  R12 -> incarnation node
; On exit
;  R0-R3 corrupted
;  flags preserved

IssueServicePostInit
        Push    "R4-R5, lr"
        MRS     R5, CPSR

        ASSERT  ModHand_IntrinsicBI     ; can't be bothered to support old world

        LDR     R2, [R9, #Module_code_pointer]
        LDR     R0, [R2, #Module_HelpStr]
        ADD     R0, R2, R0
        BL      GetVerNoFromHelpString
        MOV     R0, R2
        LDR     R2, [R0, #Module_TitleStr]
        ADD     R2, R0, R2
        MOV     R4, R1
        MOV     R1, #Service_ModulePostInit
        SUB     R3, R12, R9
        SUBS    R3, R3, #ModInfo        ; R3 = 0 if intrinsic base incarnation
        ADDNE   R3, R12, #Incarnation_Postfix
        SWI     XOS_ServiceCall

        MSR     CPSR_f, R5
        Pull    "R4-R5, pc"

; IssueServicePostFinal
; On entry
;  R9  -> module chain node
;  R12 -> incarnation node (incarnation workspace is already freed)
; On exit
;  R0 corrupted
;  flags corrupted

IssueServicePostFinal
        Push    "R1-R4, lr"

        ASSERT  ModHand_IntrinsicBI     ; can't be bothered to support old world

        LDR     R2, [R9, #Module_code_pointer]
        LDR     R0, [R2, #Module_HelpStr]
        ADD     R0, R2, R0
        BL      GetVerNoFromHelpString
        MOV     R0, R2
        LDR     R2, [R0, #Module_TitleStr]
        ADD     R2, R0, R2
        MOV     R4, R1
        MOV     R1, #Service_ModulePostFinal
        SUB     R3, R12, R9
        SUBS    R3, R3, #ModInfo        ; R3 = 0 if intrinsic base incarnation
        ADDNE   R3, R12, #Incarnation_Postfix
        SWI     XOS_ServiceCall

        Pull    "R1-R4, pc"
 ]

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        END
@


4.18
log
@Change module initialisation to be a two pass scheme
Detail:
  To make it easier to support arbitrary complexity keyboard controllers (eg. USB via DWCDriver on the Pi) have the kernel do the early keyboard recovery key press detection instead of the HAL.
  During the first pass those modules used for reading the keyboard are started, ignoring the CMOS frugal bits.
  The keyboard is then scanned for 3s, during which time the RAM is cleared (unless the HAL indicated it has already been done).
  During the second pass the remaining modules are started respecting the CMOS frugal bits. Any which were already started in the first pass are inserted into the new chain, so the keyboard is reset once and only once.

  Boot times, with a 300cs key scan time in NewReset.
  Risc PC with 160MB RAM (128+32+0).
  Times from turning on power to initial "beep", using a stopwatch.
                RISC OS 3.70 RISC OS 5.22 This OS
  ARM610        12.5         10.4         10.3
  ARM710        11.8         10.2         9.7
  StrongARM 233 11.1         9.5          8.4

  In NewReset.s:
  Remove old KbdScan code (leave Reset_IRQ_Handler for IIC only)
  If HAL_KbdScanDependencies returns a null string then present KbdDone flag and skip to full init.
  A few vestiges of soft resets removed.
  Do RAM clear when waiting for INKEY (being careful not to trash the running modules...).
  Clearing just the freepool on a 2GB Titanium cleared 7EFD6 pages (99.2%).

  In ModHand.s:
  2nd pass need to sneaky renumber the nodes (so *ROMModules is in the right order, frugal bits line up) without resetting the chain

  In HAL.s:
  Change ClearPhysRAM to ClearWkspRAM, such that it only clears the kernel workspace rather than all RAM. The bulk of the RAM is cleared during the keyboard scan by new function ClearFreePoolSection.
  Add a variant of Init_MapInRAM which clears the mapped in RAM too (as these very early claims will not be in the free pool when the RAM is cleared later).
  Remove HAL keyboard scan setup & IRQ handler.
  Fix bug in HALDebugHexTX2, the input value needs pre-shifting by 16b before continuing.

  In GetAll.s, PMF/osbyte.s:
  Use Hdr:Countries and Hdr:OsBytes for constants.

  In PMF/key.s, PMF/osinit.s:
  Relocate the key post init from PostInit to KeyPostInit.
  Changed PostInit to not tail call KeyPostInit so they can be called independently.

  In hdr/KernelWs:
  Improve comments, add InitWsStart label to refer to.

  In hdr/HALEntries:
  Add HAL_KbdScanDependencies.
  Delete KbdFlag exports.
  Took the opportunity to reorder some of the higher numbered HAL entries and re-grouping, specifically (112,120) (84,106,108,117).
Admin:
  Tested on an ARM6/ARM7/SA Risc PC, BeagleBoard xM, Iyonix, Pandaboard ES, Wandboard Quad, IPEGv5, Titanium, Pi 2 and 3.
  Requires corresponding HAL change.
  Submission for USB bounty.

Version 5.89. Tagged as 'Kernel-5_89'
@
text
@d223 3
a225 2
        SUB     sp, sp, #4                              ; anchor new list on stack for now
        MOV     r9, sp                                  ; pointer to 'previous' node
d228 1
d257 1
a257 2
        LDR     r12, =ZeroPage+ROMModuleChain
        LDR     r12, [r12]                              ; keyboard scan chain may have seen this module
a327 1

d376 1
a376 1
; during keyboard scan some ROM (only) modules were already started, switch chains
d378 1
a378 4
        LDR     r12, =ZeroPage+ROMModuleChain
        Pull    "r2"
        LDR     r9, [r12]                               ; old anchor
        STR     r2, [r12]
d383 1
a383 1
        MOV     r2, r9                                  ; now free the keyboard scan chain
@


4.17
log
@Issue Service_ModulePostInit when really post init
Previously, the service call was sent when the module was in the service call chain/command table hash/SWI table hash, but not actually in the list of modules - so any recipient trying to look something up with OS_Module would get denial that the module existed.
Move the service call issue step to *after* it's linked into the module list.

Version 5.64. Tagged as 'Kernel-5_64'
@
text
@d97 7
d105 1
a105 1
ModuleInit   Entry "r0-r12"                             ; call here on system startup
d112 1
a112 1
; first initialise the podule manager - this must be the second module (ie the 1st after UtilityModule)
d115 11
d132 84
d221 4
a224 1
        LDR     r9, =ZeroPage+ROMModuleChain            ; pointer to 'previous' node
d255 27
a341 1
        B       %FT35
d374 26
d402 1
a402 1
50
d405 1
a405 1
55
d423 1
a423 1
60
d427 1
a427 1
        BNE     %BT60                                   ; and loop
d433 1
a433 1
        BEQ     %FT68                                   ; [yes, so use that version]
d443 1
a443 1
68
d445 7
d465 1
a465 31
 [ DebugROMInit                                         ; print names in ROM module init for debugging
        SWI     XOS_WriteS
        =       "init mod ",0
        ALIGN
        LDR     r0, [r11, #ROMModule_Name]
        SWI     XOS_Write0
 ]
        BL      InitialiseROMModule
 [ DebugROMInit
        BVC     %FT79
        SWI     XOS_WriteS
        =       " => error: ",0
        ALIGN
        ADDVC   r0, r0, #4
        SWIVC   XOS_Write0
79
        WritePSRc SVC_mode+I_bit,r14                    ; this bit of gymnastis ensures that requested
        LDR     r0, =ZeroPage                           ; callbacks don't fire when doing the page scroll check
        LDRB    r1, [r0, #CallBack_Flag]                ; in the VDU driver because of the new line. Otherwise,
        BIC     r14, r1, #CBack_VectorReq               ; callbacks scheduled during ROM init are ordered
        STRB    r14, [r0, #CallBack_Flag]               ; differently for DebugROMInit {TRUE} than {FALSE}

        SWI     XOS_NewLine                             ; enables interrupts itself

        WritePSRc SVC_mode+I_bit,r14
        TST     r1, #CBack_VectorReq
        LDRNEB  r1, [r0, #CallBack_Flag]
        ORRNE   r1, r1, #CBack_VectorReq                ; re-insert that request
        STRNEB  r1, [r0, #CallBack_Flag]
        WritePSRc SVC_mode,r14
 ]
d468 1
a468 1
        B       %BT55
d471 1
a471 1
 [ DebugROMInit
d475 1
a475 12
 ]
        MOV     r1, #RMASizeCMOS
        MOV     r0, #ReadCMOS
        SWI     XOS_Byte
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #Page_Size]
        MUL     r3, r0, r2
        ADD     r3, r3, #ExtraRMANeeded
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
d507 34
d641 13
d672 37
d1781 1
a1781 1
        LDR     r1, [r0]
@


4.17.2.1
log
@Merge latest changes from main branch

Version 5.89, 4.129.2.6. Tagged as 'Kernel-5_89-4_129_2_6'
@
text
@a96 7
;
;       ModuleInitForKbdScan - Start subset of ROM modules for keyboard scan
;
; in:   r0 -> comma seperated list of ROM module names
;
; out:  All registers preserved
;
d98 1
a98 1
ModuleInitForKbdScan Entry "r0-r12"
d105 1
a105 1
        ASSERT  ROMModule_Link = 0
a107 11

        LDR     r9, =ZeroPage+ROMModuleChain            ; pointer to 'previous' node
        MOV     r8, #0                                  ; initial head ptr is zero
        STR     r8, [r9]                                ; set up null list

        LDR     r0, [sp, #0*4]
        CMP     r0, #-1                                 ; no list?
        BNE     %FT10

; just init the podule manager - this must be the second module (ie the 1st after UtilityModule)

a113 84
        EXIT

; now for each module in the main ROM needed for KbdScan, create a node for it
10
        MOV     r3, #-1                                 ; podule -1 is main ROM
        MOV     r10, #0                                 ; chunk number 0 to start
20
        LDR     r7, [r6, #-4]                           ; get size of this module
        TEQ     r7, #0                                  ; if zero
        BEQ     %FT50                                   ; then no more main rom modules

        LDR     r4, [r6, #Module_TitleStr]              ; r4 = offset to module name
        ADD     r4, r6, r4                              ; r4 -> module name
        LDR     r5, [r6, #Module_HelpStr]               ; r5 = help offset
        TEQ     r5, #0                                  ; if no help string
        ADDEQ   r5, r6, #Module_HelpStr                 ; then use help offset as string (null string)
        ADDNE   r5, r6, r5                              ; otherwise point to help string

        CMP     r10, #FirstUnpluggableModule            
        BCC     %FT30                                   ; unconditional since not unpluggable anyway

        LDR     r11, [sp, #0*4]
        BL      CompareTitleWithCSV
        BNE     %FT40                                   ; if your name's not on the list you can't come in
30
        ADR     r11, UnplugCMOSTable
        SUBS    r14, r10, #FirstUnpluggableModule       ; subtract number of first module that has an unplug bit
        MOVCS   r1, r14, LSR #3                         ; get byte number
        ANDCS   r14, r14, #7                            ; get bit number
        ADDCS   r14, r14, #16                           ; bit mask stored in bits 16 onwards
        RSBCSS  r1, r1, #(UnplugCMOSTableEnd-UnplugCMOSTable) ; invert table offset, and check in range
        LDRCSB  r11, [r11, r1]                          ; load table value if in range
        MOVCS   r12, #1
        ORRCS   r11, r11, r12, LSL r14                  ; merge with bit mask
        MOVCC   r11, #0                                 ; otherwise zero

        BL      AddROMModuleNode
        BVS     %FT50                                   ; if failed then can't add any more ROMs!
40
        MOV     r9, r2                                  ; this node is now previous one
        ADD     r6, r6, r7                              ; go on to next module
        ADD     r10, r10, #1                            ; chunk number +=1
        B       %BT20

; now start them
50
        LDR     r12, =ZeroPage+ROMModuleChain
        LDR     r12, [r12]
60
        TEQ     r12, #0                                 ; if no more modules
        BEQ     %FT90                                   ; then skip

        MOV     r11, r12                                ; start with current one
        BL      InitialiseROMModuleAtInit

        LDR     r12, [r12, #ROMModule_Link]
        B       %BT60
90
      [ DebugROMInit
        SWI     XOS_WriteS
        =       "mod init (kbdscan) done",0
        SWI     XOS_NewLine
      ]
        MOV     r1, #RMASizeCMOS
        MOV     r0, #ReadCMOS
        SWI     XOS_Byte
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #Page_Size]
        MUL     r3, r0, r2
        ADD     r3, r3, #ExtraRMANeeded
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        EXIT

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ModuleInit - Start the remaining ROM modules, checking podules and extension ROMs
;
; out:  All registers preserved
;

ModuleInit   Entry "r0-r12"
d119 1
a119 4
        ADRL    r6, SysModules_Info+4

        SUB     sp, sp, #4                              ; anchor new list on stack for now
        MOV     r9, sp                                  ; pointer to 'previous' node
a149 27
        LDR     r12, =ZeroPage+ROMModuleChain
        LDR     r12, [r12]                              ; keyboard scan chain may have seen this module
12
        TEQ     r12, #0
        BEQ     %FT18

        LDR     r5, [r12, #ROMModule_BaseAddress]
        LDR     r14, [r2, #ROMModule_BaseAddress]
        TEQ     r5, r14                                 ; for main ROM an address compare is sufficient
        BNE     %FT16

        MOV     r14, #1
        STRB    r14, [r2, #ROMModule_Initialised]       ; remember it's already done
        LDR     r11, =ZeroPage+Module_List
14
        LDR     r11, [r11, #Module_chain_Link]
        TEQ     r11, #0
        BEQ     %FT16

        LDR     r14, [r11, #Module_ROMModuleNode]
        TEQ     r12, r14
        STREQ   r2, [r11, #Module_ROMModuleNode]        ; point at newly created node
        BNE     %BT14
16
        LDR     r12, [r12, #ROMModule_Link]
        B       %BT12
18
d210 1
a242 26
50

; during keyboard scan some ROM (only) modules were already started, switch chains

        LDR     r12, =ZeroPage+ROMModuleChain
        Pull    "r2"
        LDR     r9, [r12]                               ; old anchor
        STR     r2, [r12]
51
        TEQ     r9, #0
        BEQ     %FT58

        MOV     r2, r9                                  ; now free the keyboard scan chain
        LDR     r9, [r9, #ROMModule_Link]
  [ ChocolateSysHeap
        ASSERT  ChocolateMRBlocks = ChocolateBlockArrays + 12
        LDR     r1,=ZeroPage+ChocolateBlockArrays
        LDR     r1,[r1,#12]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
        BL      FreeSysHeapNode
  ]
        B       %BT51
58

d245 1
a245 1
60
d248 1
a248 1
62
d266 1
a266 1
63
d270 1
a270 1
        BNE     %BT63                                   ; and loop
d276 1
a276 1
        BEQ     %FT67                                   ; [yes, so use that version]
d286 1
a286 1
67
a287 7
        CMP     r7, #-1                                 ; is it the main ROM
        BNE     %FT69

        LDRB    r10, [r12, #ROMModule_Initialised]      ; already initialised?
        TEQ     r10, #0
        BNE     %FT80
69
d301 31
a331 1
        BL      InitialiseROMModuleAtInit
d334 1
a334 1
        B       %BT62
d337 1
a337 1
      [ DebugROMInit
d341 12
a352 1
      ]
a383 34
InitialiseROMModuleAtInit Entry "r0-r1"
      [ DebugROMInit                                    ; print names in ROM module init for debugging
        SWI     XOS_WriteS
        =       "init mod ",0
        ALIGN
        LDR     r0, [r11, #ROMModule_Name]
        SWI     XOS_Write0
      ]
        BL      InitialiseROMModule
      [ DebugROMInit
        BVC     %FT10
        SWI     XOS_WriteS
        =       " => error: ",0
        ALIGN
        ADDVC   r0, r0, #4
        SWIVC   XOS_Write0
10
        WritePSRc SVC_mode+I_bit,r14                    ; this bit of gymnastics ensures that requested
        LDR     r0, =ZeroPage                           ; callbacks don't fire when doing the page scroll check
        LDRB    r1, [r0, #CallBack_Flag]                ; in the VDU driver because of the new line. Otherwise,
        BIC     r14, r1, #CBack_VectorReq               ; callbacks scheduled during ROM init are ordered
        STRB    r14, [r0, #CallBack_Flag]               ; differently for DebugROMInit {TRUE} than {FALSE}

        SWI     XOS_NewLine                             ; enables interrupts itself

        WritePSRc SVC_mode+I_bit,r14
        TST     r1, #CBack_VectorReq
        LDRNEB  r1, [r0, #CallBack_Flag]
        ORRNE   r1, r1, #CBack_VectorReq                ; re-insert that request
        STRNEB  r1, [r0, #CallBack_Flag]
        WritePSRc SVC_mode,r14
      ]
        EXIT

a483 13
;******************************************************************************************************
;
;       CompareVersions - Test two for newness against another (existing) node
;
; in:   R1 = version as BCD
;       R3 = base address
;       R6 = podule number
;       R12 -> node
;
; out:  CC of compare
;       All other registers preserved
;

a501 37
;       CompareTitleWithCSV - Test two for newness against another (existing) node
;
; in:   R11 = comma separated string of titles
;       R4 -> title string of a module
;
; out:  EQ if title is in the list
;       All other registers preserved
;

CompareTitleWithCSV Entry "r0, r6, r11"
10
        MOV     r6, r4                                  ; char in title string
20
        LDRB    r0, [r11], #1
        LDRB    r14, [r6], #1
        TEQ     r0, #0                                  ; (terminator OR
        TEQNE   r0, #","                                ;                separator)
        TEQEQ   r14, #0                                 ;                           AND terminator
        EXIT    EQ

        TEQ     r0, r14
        BEQ     %BT20
30
        TEQ     r0, #0
        BNE     %FT40                                   ; no more values

        MOVS    r0, #1
        EXIT    NE
40
        TEQ     r0, #","                                
        BEQ     %BT10                                   ; try next value

        LDRB    r0, [r11], #1
        B       %BT30

;******************************************************************************************************
;
d1574 1
a1574 1
        LDR     r1, [r0, #Module_chain_Link]
@


4.17.2.2
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d223 2
a224 3
        LDR     r9, =ZeroPage+ROMModuleChain            ; pointer to 'previous' node
        LDR     r12, [r9]
        Push    "r12"                                   ; keep keyboard scan chain anchor
a226 1

d255 2
a256 1
        LDR     r12, [sp, #0*4]                         ; keyboard scan chain may have seen this module
d327 1
d376 1
a376 1
; free the keyboard scan chain as it's redundant now
d378 4
a381 1
        Pull    "r9"                                    ; recover keyboard scan chain anchor
d386 1
a386 1
        MOV     r2, r9
@


4.16
log
@Resolve 2x header clashes
hdr/AHCIDevice:
  Remove this, since it clashes with the (differing API version number) copy exported by SATADriver. Post merging the Kernel back to the trunk the newer file datestamp has meant the wrong one gets exported during any ROM build which includes both components. Since the Kernel doesn't need AHCIDevice itself, it is left to the respective client (SATADriver or AHCIDriver in this case) to export them.
hdr/ModHand:
  Resolve the longstanding clash of Module_Title with the same named symbol that CMHG uses. There are very few assembler needing to look at the module header (Kernel, FileCore, Debugger, Podule) directly, but every C module which uses CMHG and wants one of the ModHandReason values ends up with a duplicate define.
  Obsolete Arthur era Module_LoadAddr value.
ArthurSWIs.s/MoreComms.s/NewReset.s/SWINaming.s/SysComms.s/Utility.s:
  Module_Title->Module_TitleStr.
ModHand.s:
  Module_Title->Module_TitleStr.
  Recode Module_LoadAddr using the file type from Hdr:FileTypes.
GetAlls.s:
  Drop unused NVRAM and PortMan headers. Add Hdr:FileTypes.

Version 5.54. Tagged as 'Kernel-5_54'
@
text
@a27 2
; Test version, incorporating multiple incarnation attempt

d69 1
a69 1
ROMModule_PoduleNumber  #       4               ; podule number (0..7 = normal podule, -1 = main ROM, -2..-n = extension ROM)
d940 3
d1584 3
a1661 3
       [ ModHand_InitDieServices
         BLVC    IssueServicePostInit
       ]
@


4.15
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d131 1
a131 1
        LDR     r4, [r6, #Module_Title]                 ; r4 = offset to module name
d609 1
a609 1
       LDR      R3, [R9, #Module_Title]     ; prefix with module title
d818 1
a818 1
         LDR     R1, [R10, #Module_Title]
d1328 2
a1329 2
        BIC     R2, R2, #&FF            ; low byte ignored by me.
        CMP     R2, #Module_LoadAddr
d1355 1
a1355 1
        LDR     R1, [R9, #Module_Title]
d1804 1
a1804 1
        LDR     R3, [R1, #Module_Title]
d1857 1
a1857 1
        LDR     R4, [R1, #Module_Title]
d2944 1
a2944 1
         LDR     R3, [R4, #Module_Title]
d3410 1
a3410 1
        LDR     R2, [R0, #Module_Title]
d3440 1
a3440 1
        LDR     R2, [R0, #Module_Title]
@


4.14
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a744 2
 [ RMTidyDoesNowt                               ; on Medusa we do nothing, because we would always fail
                                                ; due to FSLock being Captain Scarlet
d746 2
a748 345
 |
Module_Tidy      ROUT
         Push   "R0-R6, R9, lr"

         WritePSRc SVC_mode, r0

         LDR     r0, =ZeroPage
         LDR     r0, [r0, #Curr_Active_Object]
         MOV     r1, #RMAAddress
         LDR     r2, [r1, #:INDEX:hpdend]
         SUBS    r0, r0, r1
         CMPHI   r2, r0
         ADRHIL  r0, ErrorBlock_CantKill
       [ International
         BLHI    TranslateError
       |
         SETV    HI
       ]

         BLVC    Genocide                   ; warn all of impending calamity
         BVS     ExitRMTidy

; now for the great adventure. R2 is old contents of ModuleList
; First build a list of block addresses, together with address of pointer to
; block, in ascending order.

         LDR     R2, =ScratchSpace
         STR     R9, [R2], #4               ; save original module list
         MOV     R3, R2

; in loop, R0 is block address, R1 is pointer to pointer to block
; R2 is ptr to list start
; R3 is list limit

01      ADD      R1, R9, #Module_code_pointer
        LDR      R0, [R1]
        BL       %FT10                      ; insert pair

        LDR      R1, [R9, #Module_incarnation_list]
02      ADD      R1, R1, #Incarnation_Workspace
        LDR      R0, [R1]
        CMP      R0, #0
        BLNE     %FT10                      ; insert workspace block if there
        LDR      R1, [R1, #-Incarnation_Workspace]
        CMP      R1, #0
        BNE      %BT02

        LDR      R9, [R9, #Module_chain_Link] ; next module
        CMP      R9, #0
        BNE      %BT01

; Now iterate over claimed blocks, to discard non-heap pointers.

        MOV      R5, R2                     ; currblock ptr

; if hpdfree <> hpdsize then
;    doblock (hpdsize, hpdfree=Nil -> hpdbase, hpdfree)

        MOV      R12, #RMAAddress
        LDR      R4, [R12, #:INDEX: hpdfree]
        CMP      R4, #Nil
        ADDNE    R4, R4, #:INDEX: hpdfree   ; convert to heapstart offset

        CMP      R4, #hpdsize
        BEQ      %FT04
        MOV      R0, #hpdsize
        CMP      R4, #Nil
        LDREQ    R1, [R12, #:INDEX: hpdbase]
        MOVNE    R1, R4
        BL       ScanAllocBlock
        CMP      R4, #Nil
        BEQ      BlocksScanned

;  while hpdfree <> Nil
;     doblock (hpdfree+fresize, step(hpdfree)=Nil -> hpdbase, hpdfree)

04      ADD      R4, R4, R12
        LDR      R1, [R4, #frelink]
        LDR      R0, [R4, #fresize]
        SUB      R4, R4, R12

        ADD      R0, R0, R4
        CMP      R1, #Nil
        ADDNE    R4, R4, R1
        MOVNE    R1, R4
        LDREQ    R1, [R12, #:INDEX: hpdbase]
        BL       ScanAllocBlock
        BNE      %BT04

BlocksScanned
        MOV      R3, R5                     ; new list end

; copy blocks, relocate ptrs
; R2, R3 list limits
; R12 heap start

        ADD      R0, R12, #hpdsize          ; get addr for first block
StripBlocks
        CMP      R2, R3
        BEQ      %FT09                      ; nowt to copy
        LDR      R1, [R2], #8
        CMP      R1, #0
        BEQ      StripBlocks
        LDR      R4, [R1]                   ; block size
        CMP      R1, R0
        ADDEQ    R0, R4, R0
        BEQ      StripBlocks

; R1 address of first block, R0 address to copy to - gopher it!
; R4 size
        LDR      R5, [R2, #-4]              ; pointer to
        ADD      R0, R0, #4
        STR      R0, [R5]                   ; relocate ptr
        SUB      R0, R0, #4

CopyBlock
        LDR      R5, [R1], #4
        STR      R5, [R0], #4
        SUBS     R4, R4, #4
        BGT      CopyBlock
        B        StripBlocks

09
; Update Hpd
        SUB      R0, R0, R12                ; convert to offset
        STR      R0, [R12, #:INDEX: hpdbase]

        MOV      R0, #Nil
        STR      R0, [R12, #:INDEX: hpdfree] ; no free list.

 ; for restarting, we need
 ; R1 -> prevmod to R9
 ; R9 -> the whinger, R12 -> incarnation list, R2 stop point
 ; R4 -> dead module list
 ; R3 -> previnc

        LDR      R9, =ZeroPage+Module_List  ; "module" that's linked at end
        LDR      R4, =ScratchSpace
        LDR      R4, [R4]                   ; dead list
        MOV      R2, #0                     ; persuade it to step module
        MOV      R12, #0                    ; immediately.
        BL       RestartModuleStructure
        BVS      ExitRMTidy

        MOV      R0, #1
        MOV      R1, #-16*1024*1024
        SWI      XOS_ChangeDynamicArea
        CLRV

ExitRMTidy
        STRVS    R0, [stack]
        Pull    "R0-R6, R9, lr"
        B       SLVK_TestV

;-------------------------------------------------------------------------
; RMTidy support routines

; Insertion routine. (R0, 1) is pair to insert, R2 list start, R3 list end.
; Uses R10, 11, 4

10      MOV      R11, R2           ; take curr posn ptr

        SUB      R0, R0, #4        ; genuine internal heap pointer value
11      CMP      R11, R3           ; list ended?
        BEQ      %FT13
        LDR      R4, [R11], #8
        CMP      R4, R0            ; or right posn?
        BLO      %BT11

        SUB      R11, R11, #8      ; where we will store new entry to
        SUB      R4, R3, #4        ; R4 is OS_Word to move from.
12      LDR      R10, [R4], #-4    ; now copy between R11 and R3 up 8.
        STR      R10, [R4, #12]
        CMP      R4, R11
        BHS      %BT12

13      ADD      R3, R3, #8        ; update list end
        STMIA    R11, {R0, R1}     ; new entry in
        ADD      R0, R0, #4        ; and back to link.
        MOV      PC, lr

;-------------------------------------------------------------------
ScanAllocBlock    ROUT
 ; R0 block start
 ; R1 block end
 ; R12 heap start
 ; R3  list end
 ; R5  current list entry

 ; poke out list entries that aren't proper heap pointers

        Push     "R0, R1, R7, R8, lr"
        mrs      ,lr, CPSR
        MOV       R8, #0
        ADD       R0, R0, R12     ; convert to addressi
        ADD       R1, R1, R12

01      CMP       R5, R3
        BHS       %FT02
        LDR       R7, [R5], #8

        CMP       R7, R0          ; while entry at R5 LO R0 pokeout
        STRLO     R8, [R5, #-8]
        BLO       %BT01

        SUBHI     R5, R5, #8

        LDR       R7, [R0]
        ADD       R0, R0, R7      ; next block
        CMP       R0, R1          ; step block until end
        BLO       %BT01
02
        msr      ,CPSR_f, lr
        Pull     "R0, R1, R7, R8, PC"

        LTORG

;-----------------------------------------------------------------------------

Genocide ROUT ; non-fatally kill de lot of em, stiff the module chain
              ; corrupts R1-R5, R9, R10, R12
              ; returns R9 = original module chain

         Push   "lr"
         MOV     R4, #0                     ; chain so far

FindChainEnd
         LDR     R1, =ZeroPage+Module_List  ; prevnode
         LDR     R9, [R1, #Module_chain_Link] ; currnode
         CMP     R9, #0
         BNE     %FT01
         MOV     R9, R4
         Pull   "PC"

01       LDR     R11, [R9, #Module_chain_Link] ; lastnode?
         CMP     R11, #0
         MOVNE   R1, R9                     ; step chain
         MOVNE   R9, R11
         BNE     %BT01

         LDR     R2, [R9, #Module_incarnation_list] ; keep chain head
         ADD     R3, R9, #Module_incarnation_list
02       LDR     R12, [R3, #Incarnation_Link]       ; currinc
         CMP     R12, #0
         BNE     %FT03
         STR     R12, [R1, #Module_chain_Link]      ; remove from chain
         STR     R2, [R9, #Module_incarnation_list] ; replace incarnations
         STR     R4, [R9, #Module_chain_Link]       ; make into dead head
         MOV     R4, R9
         B       FindChainEnd

03       MOV     R10, #0                    ; not fatal indicator
 [ {FALSE} ; debug RMTidy
        Push    "r0"
        LDR     r0, [r9, #Module_code_pointer]
        LDR     r14, [r0, #Module_Title]
        ADD     r0, r0, r14
        SWI     XOS_WriteS
        =       "RMTidy: killing '", 0
        ALIGN
        SWI     XOS_Write0
        SWI     XOS_WriteS
        =       "'", 10, 13, 0
        ALIGN
        Pull    "r0"
 ]
         BL      CallDie
         BVC     %BT02

; Copy the error in case overwritten

        MOV     R5,R0                           ; Error block
        LDR     R0,=GeneralMOSBuffer                ; R0-> stashed error
        LDR     LR,[R5],#4
        STR     LR,[R0],#4                      ; Copy error number
05      LDRB    LR,[R5],#1
        STRB    LR,[R0],#1
        CMP     LR,#' '                         ; End of string?
        BGE     %BT05                           ; No then more
        LDR     R0,=GeneralMOSBuffer            ; R0-> stashed error
        SETV

         MOV     R5, R12
         MOV     R12, R2
         MOV     R2, R5     ; r12 now incarnation to start, R2 stop point
         BL      RestartModuleStructure
                ; somebody winged, so try and restore consistency before error.
         Pull   "PC"

;------------------------------------------------------------------------------

RestartModuleStructure ROUT

 ; R1 -> prevmod to R9
 ; R9 -> the whinger, R12 -> incarnation list, R2 stop point
 ; R4 -> dead module list
 ; R3 -> previnc

         Push   "R0, R8, lr"
         MRS     R8, CPSR

11       CMP     R2, R12
         BNE     %FT12                      ; more incarnations to do

         CMP     R4, #0
         BNE     %FT13

         MSR     CPSR_f, R8
         Pull   "R0, R8, PC"

13       MOV     R1, R9
14       MOV     R9, R4
         LDR     R4, [R4, #Module_chain_Link]
         MOV     R2,#0                      ; indicate reinit all incarnations
         LDR     R12, [R9, #Module_incarnation_list]
         STR     R2,  [R9, #Module_incarnation_list]
         ADD     R3, R9, #Module_incarnation_list ; previnc ptr

         STR     R2, [R9, #Module_chain_Link]     ; relink next
         STR     R9, [R1, #Module_chain_Link]
         B       %BT11                            ; start incarnations

12       LDR     R11, [R12, #Incarnation_Link]    ; get next in case problems
         ADRL    R10, crstring                    ; no environment
         BL      CallInit                         ; frees node if error
         BVC     %FT15

         STR     R0, [stack]
         ORR     R8, R8, #V_bit
         Push   "R2"
         MOV     R2, R1                     ; prevnode
         BL      LoseModuleSpace_if_its_the_only_incarnation
         Pull   "R2"

         CMP     R9, #0                     ; did we just discard that module?
         BEQ     %BT14                      ; yup - next one

15       LDRVC   R0,  [R3, #Incarnation_Link]
         STRVC   R0,  [R12,#Incarnation_Link]
         STRVC   R12, [R3, #Incarnation_Link]
         MOVVC   R3, R12

         MOV     R12, R11
         B       %BT11                      ; next incarnation
 ] ; endif <RMTidyDoesNowt>
a1733 1
 [ StrongARM
a1748 1
 ]
@


4.13
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a375 1
      [ No26bitCode
a376 4
      |
        MOV     lr, pc                                  ; ADRS lr, %FT10
        ADD     lr, lr, #%FT20-%FT10                    ; ADRS lr, %FT20
      ]
a2160 1
 [ No26bitCode
a2179 1
 ]
a2195 1
 [ No26bitCode
a2212 1
 ]
@


4.12
log
@  32-bit kernels will refuse to initialise non 32-bit modules.
Detail:
  The kernel will examine all modules that it is requested to initialise
    and will refuse to initialise any module without a module flags word
    entry in its module header or with bit 0 the first flags word being
    clear (bit 0 being ModuleFlag_32bit)
  Error message added to all the messages files.
  New error block added to message counting block.  The Non-32-bit module
    message is not a cached error message, though.
Admin:
  Tested in 32-bit Lazarus build.

Version 5.38. Tagged as 'Kernel-5_38'
@
text
@d25 2
d71 1
a71 1
ROMModule_PoduleNumber  #       4               ; podule number (0..3 = normal podule, -1 = main ROM, -2..-n = extension ROM)
d100 1
a100 1
ModuleInit   ENTRY "r0-r12"                             ; call here on system startup
d121 1
a121 1
        LDR     r9, =ROMModuleChain                     ; pointer to 'previous' node
a203 2
 [ IO_Type = "IOMD"

a211 7
 |
        ASSERT  ?PoduleFrugalCMOS >= 4
        CMP     r3, #4                                  ; if podule number < 4
        CMPCC   r12, #8                                 ; and bit number < 8
        ADDCC   r11, r3, #PoduleFrugalCMOS              ; then compute CMOS address
        ORRCC   r11, r11, r14, LSL r12                  ; and OR in bit mask
 ]
d248 1
a248 1
        LDR     r12, =ROMModuleChain
d303 1
a303 1
 [ DebugROMInit
a304 1
;;;        =       "About to initialise module ",0
d306 1
a308 1
        SWI     XOS_NewLine
d311 2
a312 2
 [ DebugROMErrors                                       ; print errors in ROM module init for debugging
        BVC     %FT80
d314 1
a314 2
;;;        =       "Error in ROM module init: ",0
        =       " error: ",0
d318 15
a332 1
        SWIVC   XOS_NewLine
d347 1
a347 1
        MOV     r0, #0
d367 1
a367 1
InitialiseROMModule ENTRY "r0-r12"
d376 3
d381 1
d409 1
a409 1
AddROMModuleNode ENTRY "r0,r1,r3-r12"
d412 1
a412 1
        MOV     r3,#ChocolateBlockArrays
d491 1
a491 1
CompareVersions ENTRY
d520 1
a520 1
FindROMModule ENTRY
d522 1
a522 1
        LDREQ   r12, =ROMModuleChain                    ; then search from start of chain
d655 1
a655 1
       BLGT     PreferIncarnation
d676 3
d686 3
d721 1
a721 1
        B       SLVK_TestV
d735 1
a735 1
        B       SLVK_TestV
d744 1
a744 1
        B       SLVK_TestV
d752 2
a753 1
Module_Tidy *   SLVK
d760 1
a760 1
         MOV     r0, #0
d765 2
a766 2
         CMPGT   r2, r0
         ADRGTL  r0, ErrorBlock_CantKill
d768 1
a768 1
         BLGT    TranslateError
d770 1
a770 1
         SETV    GT
d890 1
a890 1
        MOV      R9, #Module_List           ; "module" that's linked at end
d952 1
a952 1
        BGE       %FT02
d955 3
a957 3
        CMP       R7, R0          ; while entry at R5 LT R0 pokeout
        STRLT     R8, [R5, #-8]
        BLT       %BT01
d959 1
a959 1
        SUBGT     R5, R5, #8
d964 1
a964 1
        BLT       %BT01
d981 1
a981 1
         MOV     R1, #Module_List             ; prevnode
d1053 1
a1053 1
         mrs    ,R8, CPSR
d1061 1
a1061 1
         msr    ,CPSR_f, R8
d1102 1
a1102 1
Module_Clear ENTRY "r0-r3"
d1109 1
a1109 1
        MOV     r2, #Module_List                        ; prevnode for killing
d1216 1
a1216 1
         MOV     R10, #Module_List
d1264 2
a1265 2
         ADD     R3, R3, #15
         BIC     R3, R3, #15
d1285 2
a1286 1
         BGT     Incarnation_exists
d1298 1
d1398 1
a1398 1
        BLGT    PreferIncarnation       ; only prefer it if found!
d1413 1
a1413 1
Module_AddPoduleModule ENTRY
d1419 1
a1419 1
APMEntry ENTRY "r0-r7,r9"
d1509 1
a1509 1
         MOV     R0, #Module_List
d1553 1
a1553 1
        LDR     r12, =ROMModuleChain
d1604 1
a1604 1
        MOV     r4, #Module_List
d1613 1
a1613 1
        MOV     r11, #0
d1784 1
a1784 1
AddModuleIfInROM ENTRY "r5-r8"
d1881 1
a1881 1
LinkAndInit ENTRY "r2, r3"
d1886 1
a1886 1
        MOV     r3,#ChocolateBlockArrays
d1921 1
a1921 1
        ADR     r0, Module_List
d1944 1
a1944 1
        MOV     r1,#ChocolateBlockArrays
d2008 3
d2053 1
a2053 1
        MOV     r3,#ChocolateBlockArrays
d2067 2
a2068 2
	LDR	R4, [R3]
  	B	%FT09
d2070 8
a2077 8
08	LDR	R14, [R4, #ModSWINode_Number]
	TEQ	R11, R14			; if numbers match, jump to end. This also sets
	BEQ	%FT10				;     the new node's link to this node
	ADD	R3, R4, #ModSWINode_Link	; update R3 to this node's link
	LDR	R4, [R3] 			; and move R4 to next node
09	TEQ	R4, #0
	BNE	%BT08				; if no next node, exit loop and tack on new one
10	STR	R4, [R2, #ModSWINode_Link]
d2151 1
a2151 2
        Push   "R0, R3, lr"
        ADR     R0, ErrorBlock_BadRMHeaderField
d2166 3
a2168 2
      [ No26bitCode                             ; insist that modules declare themselves 32-bit safe
        ADR     R0, ErrorBlock_RMNot32bit
d2170 17
a2186 16
        BIC     R3, R3, #Auto_Error_SWI_bit
        TST     R3, #Module_SWIChunkSize-1
        TSTEQ   R3, #&FF000000
        BNE     %FT99                           ; naff SWI chunk number
        TEQ     R3, #0
        LDRNE   R3, [R1, #Module_SWIEntry]      ; check for SWI entry point like CheckForSWIEntries
        BLNE    %FT10
        LDR     R3, [R1, #Module_MsgFile]       ; Other places appear to require this to be word-aligned
        BL      %FT10
        CMP     R3, R2
        LDRLO   R3, [R1, #Module_FlagTable]
        BL      %FT10
        LDR     R3, [R1, R3]                    ; Retrieve first word of module flags
        TST     R3, #ModuleFlag_32bit           ; NE if 32-bit compatible
        BEQ     %FT99
      ]
d2188 1
a2188 1
        Pull   "R0, R3, PC"
d2195 1
a2195 1
        LDMIB   SP!, {R3, LR}                   ; NOTE: sp still points at stacked LR!
d2201 22
a2222 1
        Pull    "PC"
a2223 1
        MakeErrorBlock RMNot32bit
d2261 1
a2261 1
         mrs    ,R5, CPSR
d2264 1
a2264 1
         msr    ,CPSR_f, R5
d2275 1
a2275 1
         msr    ,CPSR_f, R5
d2289 1
a2289 1
         MOV     r1,#ChocolateBlockArrays
d2296 1
a2296 1
         msr    ,CPSR_f, R5
d2424 1
a2424 1
         MOV     R0,#0
d2458 1
a2458 1
         mrs    ,R7,CPSR
d2474 1
a2474 1
         MOV     R0,#0
d2506 1
a2506 1
         msr    ,CPSR_f,R7
d2806 1
a2806 1
        LDR    R1,=Serv_SysChains
d2831 1
a2831 1
        LDR    R1,=Serv_UsrChains
d2866 1
a2866 1
        mrs   ,R8,CPSR
d2868 1
a2868 1
        msr   ,CPSR_c,R4                     ;IRQs off for update of chain structures
d2896 1
a2896 1
        LDR    R1,=Serv_AwkwardChain
d2900 1
a2900 1
        msr   ,CPSR_c,R8             ;restore IRQ state (26-bit code used to corrupt V!)
d2914 1
a2914 1
        mrs   ,R10,CPSR
d2916 1
a2916 1
        msr   ,CPSR_c,R4                     ;IRQs off for update of chain structures
d2935 1
a2935 1
        LDR    R1,=Serv_SysChains
d2946 1
a2946 1
        LDR    R1,=Serv_UsrChains
d2968 1
a2968 1
        LDR    R1,=Serv_AwkwardChain
d2974 1
a2974 1
        msr   ,CPSR_cf,R10                ;restore IRQ state
d2987 1
a2987 1
         mrs    ,R5, CPSR
d3003 1
a3003 1
         msr    ,CPSR_f, R5
d3033 1
a3033 1
         mrs    ,R6, CPSR
d3039 3
d3054 1
a3054 1
         msr    ,CPSR_f, R6
d3059 1
a3059 1
         mrs    ,R6, CPSR
d3073 1
a3073 1
         mrs    ,R7, CPSR
d3075 1
a3075 1
         MOV     R11, #0
d3082 1
a3082 1
         BLT     %FT04                        ; code block is CAO
d3090 1
a3090 1
         BGE     ModuleIsntCAO                ; not CAO
d3107 1
a3107 1
         msr    ,CPSR_f, R7
d3160 1
a3160 1
         msr    ,CPSR_f, R7
d3168 1
a3168 1
         MOV     PC, lr                      ; return LT for Yes
d3187 1
a3187 1
        mrs    ,R5, CPSR
d3190 1
a3190 1
        MOV     R0, #Module_List
d3208 1
a3208 1
        MOV     r1,#ChocolateBlockArrays
d3216 1
a3216 1
        msr    ,CPSR_f, R5
d3221 3
d3230 2
a3232 1
       BLT      %FT02                       ; incarnation not found
d3238 1
a3238 1
       MOV      r3, #0
d3295 1
a3295 1
         LDR     R2, =Module_List
d3365 1
a3365 1
Module_StrCmp ENTRY "r1,r2,r5-r7"
d3441 1
a3441 1
;  force size to multiple of 16 -4 to keep alignment OK
d3447 3
a3449 3
         ADD     R3, R3, #15+4               ; now force size to 16*n-4
         BIC     R3, R3, #15                 ; so heap manager always has
         SUB     R3, R3, #4                  ;  4-word aligned blocks
d3519 1
a3519 1
Unplug_Code ENTRY "r7-r9"
d3718 1
a3718 1
        MOV     r0, #Module_List
d3746 64
@


4.11
log
@  Fixed minor bug in module initialisation.
  Added common error cache.
Detail:
  Fixed module header validation code which was broken in 5.22.  This
    shouldn't have caused much of a problem as it was only a bizarre
    check (SWI chunk looked valid but SWI handler was 0) that would
    have failed - but be reported as a valid set of SWI entries.
  Added common error message cache.  Several common errors (Buffer
    overflow; Number not recognised; Bad vector release; and a couple
    of others) are now cached the first time they are translated into
    a block of memory in the system heap.
Admin:
  Tested in Ursula build - cacheing only active in Ursula build - change
    HdrSrc if you want it in your products too.
  Requires HdrSrc 0.94

Version 5.31. Tagged as 'Kernel-5_31'
@
text
@d2130 2
a2131 1
        Push   "R3, lr"
d2146 19
d2166 1
a2166 1
        Pull   "R3, PC"
d2173 1
a2173 2
        Pull   "R3, lr"
        ADR     R0, ErrorBlock_BadRMHeaderField
a2174 1
        Push    "lr"
a2175 1
        Pull    "lr"
d2179 1
a2179 1
        MOV     PC, lr
d2181 1
@


4.11.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d98 1
a98 1
ModuleInit   Entry "r0-r12"                             ; call here on system startup
d362 1
a362 1
InitialiseROMModule Entry "r0-r12"
d400 1
a400 1
AddROMModuleNode Entry "r0,r1,r3-r12"
d482 1
a482 1
CompareVersions Entry
d511 1
a511 1
FindROMModule Entry
d706 1
a706 1
       B        SLVK_TestV
d720 1
a720 1
         B       SLVK_TestV
d729 1
a729 1
         B       SLVK_TestV
d737 1
a737 2
Module_Tidy
         B       SLVK
d1037 1
a1037 1
         MRS     R8, CPSR
d1045 1
a1045 1
         MSR     CPSR_f, R8
d1086 1
a1086 1
Module_Clear Entry "r0-r3"
a1280 1
         LDR     R1, [stack, #1*4]
d1395 1
a1395 1
Module_AddPoduleModule Entry
d1401 1
a1401 1
APMEntry Entry "r0-r7,r9"
d1766 1
a1766 1
AddModuleIfInROM Entry "r5-r8"
d1863 1
a1863 1
LinkAndInit Entry "r2, r3"
d2201 1
a2201 1
         MRS     R5, CPSR
d2204 1
a2204 1
         MSR     CPSR_f, R5
d2215 1
a2215 1
         MSR     CPSR_f, R5
d2236 1
a2236 1
         MSR     CPSR_f, R5
d2398 1
a2398 1
         MRS     R7,CPSR
d2446 1
a2446 1
         MSR     CPSR_f,R7
d2806 1
a2806 1
        MRS    R8,CPSR
d2808 1
a2808 1
        MSR    CPSR_c,R4                     ;IRQs off for update of chain structures
d2840 1
a2840 1
        MSR    CPSR_c,R8             ;restore IRQ state (26-bit code used to corrupt V!)
d2854 1
a2854 1
        MRS    R10,CPSR
d2856 1
a2856 1
        MSR    CPSR_c,R4                     ;IRQs off for update of chain structures
d2914 1
a2914 1
        MSR    CPSR_cf,R10                ;restore IRQ state
d2927 1
a2927 1
         MRS     R5, CPSR
d2943 1
a2943 1
         MSR     CPSR_f, R5
d2973 1
a2973 1
         MRS     R6, CPSR
d2991 1
a2991 1
         MSR     CPSR_f, R6
d2996 1
a2996 1
         MRS     R6, CPSR
d3010 1
a3010 1
         MRS     R7, CPSR
d3044 1
a3044 1
         MSR     CPSR_f, R7
d3097 1
a3097 1
         MSR     CPSR_f, R7
d3124 1
a3124 1
        MRS     R5, CPSR
d3153 1
a3153 1
        MSR     CPSR_f, R5
d3298 1
a3298 1
Module_StrCmp Entry "r1,r2,r5-r7"
d3452 1
a3452 1
Unplug_Code Entry "r7-r9"
@


4.11.2.2
log
@More stuff. Up to the desktop now; cache on, working keyboard. Some source
restructuring to start to make splitting it up into several object files more
feasible.
@
text
@d3021 1
a3021 1
         BLO     %FT04                        ; code block is CAO
d3029 1
a3029 1
         BHS     ModuleIsntCAO                ; not CAO
d3107 1
a3107 1
         MOV     PC, lr                      ; return LO for Yes
@


4.11.2.3
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d202 2
d212 7
@


4.11.2.4
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d1240 2
a1241 2
         ADD     R3, R3, #31
         BIC     R3, R3, #31
a2137 21
 [ No26bitCode
; Need to go through extra checks to see that (a) we have a module
; flags table, and (b) it says that we're 32-bit
        LDR     R3, [R1, #Module_SWIChunk]
        TST     R3, #&FF000000
        TSTEQ   R3, #Module_SWIChunkSize-1
        BNE     %FT88
        LDR     R3, [R1, #Module_SWIEntry]
        BL      %FT20
        LDR     R3, [R1, #Module_NameTable]
        BL      %FT21
        LDR     R3, [R1, #Module_NameCode]
        BL      %FT20
        LDR     R3, [R1, #Module_MsgFile]
        BL      %FT20
        LDR     R3, [R1, #Module_FlagTable]
        BL      %FT20
        LDR     R3, [R1, R3]
        TST     R3, #ModuleFlag_32bit
        BEQ     %FT88
 ]
d2146 1
d2149 1
d2151 1
d2155 1
a2155 18
        Pull   "R3, PC"

 [ No26bitCode
20      TST     R3, #3
        BNE     %FT88
21      CMP     R3, R2
        MOVLO   PC, lr
88
        ADR     R0, ErrorBlock_RMNot32bit
      [ International
        BL      TranslateError
      |
        SETV
      ]
        Pull   "R3, PC"
        MakeErrorBlock RMNot32bit
 ]

d3367 1
a3367 1
;  force size to multiple of 32 -4 to keep alignment OK
d3373 3
a3375 3
         ADD     R3, R3, #31+4               ; now force size to 32*n-4
         BIC     R3, R3, #31                 ; so heap manager always has
         SUB     R3, R3, #4                  ;  8-word aligned blocks
@


4.11.2.5
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d637 1
a637 1
       BLNE     PreferIncarnation
d741 2
a742 2
         CMPHI   r2, r0
         ADRHIL  r0, ErrorBlock_CantKill
d744 1
a744 1
         BLHI    TranslateError
d746 1
a746 1
         SETV    HI
d928 1
a928 1
        BHS       %FT02
d931 3
a933 3
        CMP       R7, R0          ; while entry at R5 LO R0 pokeout
        STRLO     R8, [R5, #-8]
        BLO       %BT01
d935 1
a935 1
        SUBHI     R5, R5, #8
d940 1
a940 1
        BLO       %BT01
d1261 1
a1261 2
         CMP     R12, #-1
         BNE     Incarnation_exists
d1373 1
a1373 1
        BLNE    PreferIncarnation       ; only prefer it if found!
d2183 1
a2183 5
        MOV     R3, R4
        LDR     R4, [R1, #Module_Title]
        ADD     R4, R1, R4
        BL      TranslateError_UseR4
        MOV     R4, R3
a3185 3
;
; Exits with EQ if incarnation not specified, NE if incarnation specified
; and found.
a3191 2
       CMP      R12, #-1
       BEQ      %FT02                       ; incarnation not found
d3193 1
@


4.11.2.6
log
@  HAL device support, and a couple of new service calls.
Detail:
  * Rejigged documented meaning of device "Location" field so that we can
    fit full PCI locations in.
  * Defined lots of device "Type" values in Hdr:HALDevice.
  * Removed obsolete DMA-related HAL entries in Hdr:HALEntries (no longer
    required by DMAManager 0_15-4_4_2_6, no longer provided by Tungsten HAL
    0.07).
  * OS_Hardware 2 and 3 actually work now.
  * Changed OS_Hardware 4 to take a maximum major version number to match.
  * HAL workspace is now USR mode readable.
  * Service calls issued after module initialisation/finalisation (see
    Docs.ModPostServ).
Admin:
  OS_Hardware tested, service calls not tested.

Version 5.35, 4.79.2.52. Tagged as 'Kernel-5_35-4_79_2_52'
@
text
@a24 2
                        GBLL ModHand_InitDieServices
ModHand_InitDieServices SETL {TRUE} :LAND: ModHand_IntrinsicBI
a657 3
     [ ModHand_InitDieServices
       BL       IssueServicePostFinal
     ]
a664 3
     [ ModHand_InitDieServices
       BLVC     IssueServicePostInit
     ]
a1983 3
       [ ModHand_InitDieServices
         BLVC    IssueServicePostInit
       ]
a3011 3
       [ ModHand_InitDieServices
         BL      IssueServicePostFinal
       ]
a3712 64

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ ModHand_InitDieServices
; IssueServicePostInit
; On entry
;  R9  -> module chain node
;  R12 -> incarnation node
; On exit
;  R0-R3 corrupted
;  flags preserved

IssueServicePostInit
        Push    "R4-R5, lr"
        MRS     R5, CPSR

        ASSERT  ModHand_IntrinsicBI     ; can't be bothered to support old world

        LDR     R2, [R9, #Module_code_pointer]
        LDR     R0, [R2, #Module_HelpStr]
        ADD     R0, R2, R0
        BL      GetVerNoFromHelpString
        MOV     R0, R2
        LDR     R2, [R0, #Module_Title]
        ADD     R2, R0, R2
        MOV     R4, R1
        MOV     R1, #Service_ModulePostInit
        SUB     R3, R12, R9
        SUBS    R3, R3, #ModInfo        ; R3 = 0 if intrinsic base incarnation
        ADDNE   R3, R12, #Incarnation_Postfix
        SWI     XOS_ServiceCall

        MSR     CPSR_f, R5
        Pull    "R4-R5, pc"

; IssueServicePostFinal
; On entry
;  R9  -> module chain node
;  R12 -> incarnation node (incarnation workspace is already freed)
; On exit
;  R0 corrupted
;  flags corrupted

IssueServicePostFinal
        Push    "R1-R4, lr"

        ASSERT  ModHand_IntrinsicBI     ; can't be bothered to support old world

        LDR     R2, [R9, #Module_code_pointer]
        LDR     R0, [R2, #Module_HelpStr]
        ADD     R0, R2, R0
        BL      GetVerNoFromHelpString
        MOV     R0, R2
        LDR     R2, [R0, #Module_Title]
        ADD     R2, R0, R2
        MOV     R4, R1
        MOV     R1, #Service_ModulePostFinal
        SUB     R3, R12, R9
        SUBS    R3, R3, #ModInfo        ; R3 = 0 if intrinsic base incarnation
        ADDNE   R3, R12, #Incarnation_Postfix
        SWI     XOS_ServiceCall

        Pull    "R1-R4, pc"
 ]
@


4.11.2.7
log
@Added 256-colour version of the (high-resolution only) teletext code,
and support for teletext when hardware scroll is disabled. Both are required
for Tungsten.
Turned off the module init/final service calls, since we still don't have an
allocation for them.
Upped the OS version number to 5.01.

Version 5.35, 4.79.2.53. Tagged as 'Kernel-5_35-4_79_2_53'
@
text
@d26 1
a26 1
ModHand_InitDieServices SETL {FALSE} :LAND: ModHand_IntrinsicBI
@


4.11.2.8
log
@Added some symbols to the export hdr.DMADevice to define the HAL device ID
codes within each Type.
Also enabled the Service_ModulePostInit/Final service calls now that the
service call allocations have been confirmed.

Version 5.35, 4.79.2.54. Tagged as 'Kernel-5_35-4_79_2_54'
@
text
@d26 1
a26 1
ModHand_InitDieServices SETL {TRUE} :LAND: ModHand_IntrinsicBI
@


4.11.2.9
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d121 1
a121 1
        LDR     r9, =ZeroPage+ROMModuleChain            ; pointer to 'previous' node
d248 1
a248 1
        LDR     r12, =ZeroPage+ROMModuleChain
d335 1
a335 1
        LDR     r0, =ZeroPage
d396 1
a396 1
        LDR     r3,=ZeroPage+ChocolateBlockArrays
d506 1
a506 1
        LDREQ   r12, =ZeroPage+ROMModuleChain           ; then search from start of chain
d744 1
a744 1
         LDR     r0, =ZeroPage
d874 1
a874 1
        LDR      R9, =ZeroPage+Module_List  ; "module" that's linked at end
d965 1
a965 1
         LDR     R1, =ZeroPage+Module_List  ; prevnode
d1093 1
a1093 1
        LDR     r2, =ZeroPage+Module_List               ; prevnode for killing
d1200 1
a1200 1
         LDR     R10, =ZeroPage+Module_List
d1493 1
a1493 1
         LDR     R0, =ZeroPage+Module_List
d1537 1
a1537 1
        LDR     r12, =ZeroPage+ROMModuleChain
d1588 1
a1588 1
        LDR     r4, =ZeroPage+Module_List
d1597 1
a1597 1
        LDR     r11, =ZeroPage
d1870 1
a1870 1
        LDR     r3,=ZeroPage+ChocolateBlockArrays
d1905 1
a1905 1
        LDR     r0, =ZeroPage+Module_List
d1928 1
a1928 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d2037 1
a2037 1
        LDR     r3,=ZeroPage+ChocolateBlockArrays
d2273 1
a2273 1
         LDR     r1,=ZeroPage+ChocolateBlockArrays
d2408 1
a2408 1
         LDR     R0,=ZeroPage
d2458 1
a2458 1
         LDR     R0,=ZeroPage
d2790 1
a2790 1
        LDR    R1,=ZeroPage+Serv_SysChains
d2815 1
a2815 1
        LDR    R1,=ZeroPage+Serv_UsrChains
d2880 1
a2880 1
        LDR    R1,=ZeroPage+Serv_AwkwardChain
d2919 1
a2919 1
        LDR    R1,=ZeroPage+Serv_SysChains
d2930 1
a2930 1
        LDR    R1,=ZeroPage+Serv_UsrChains
d2952 1
a2952 1
        LDR    R1,=ZeroPage+Serv_AwkwardChain
d3059 1
a3059 1
         LDR     R11, =ZeroPage
d3174 1
a3174 1
        LDR     R0, =ZeroPage+Module_List
d3192 1
a3192 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d3222 1
a3222 1
       LDR      r3, =ZeroPage
d3279 1
a3279 1
         LDR     R2, =ZeroPage+Module_List
d3702 1
a3702 1
        LDR     r0, =ZeroPage+Module_List
@


4.11.2.10
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d2051 2
a2052 2
        LDR     R4, [R3]
        B       %FT09
d2054 8
a2061 8
08      LDR     R14, [R4, #ModSWINode_Number]
        TEQ     R11, R14                        ; if numbers match, jump to end. This also sets
        BEQ     %FT10                           ;     the new node's link to this node
        ADD     R3, R4, #ModSWINode_Link        ; update R3 to this node's link
        LDR     R4, [R3]                        ; and move R4 to next node
09      TEQ     R4, #0
        BNE     %BT08                           ; if no next node, exit loop and tack on new one
10      STR     R4, [R2, #ModSWINode_Link]
@


4.11.2.11
log
@Process some callbacks during module initialisation.
When in DebugROMInit=TRUE mode each call to XOS_NewLine also checks and
processes pending callbacks (in VduLF). This makes the USB enumeration
come out in a different order because they're all collected at the end.
As an intermediate step, collect callbacks for DebugROMInit=FALSE too.
Note: developers should not rely on this behaviour, this will be phased
out before the next stable release.

Version 5.35, 4.79.2.136. Tagged as 'Kernel-5_35-4_79_2_136'
@
text
@d71 1
a71 1
ROMModule_PoduleNumber  #       4               ; podule number (0..7 = normal podule, -1 = main ROM, -2..-n = extension ROM)
d305 1
d309 1
a309 7
        SWI     XOS_NewLine                             ; VDU driver processes callbacks on LF
 |
        ! 0,    "Temporarily doing callbacks like the VDU driver would" 
        LDR     R0, =ZeroPage
        LDRB    R14, [R0, #CallBack_Flag]
        TST     R14, #CBack_VectorReq
        BLNE    process_callback_chain                  ; Process callbacks here too then
d315 1
@


4.11.2.12
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@a367 3
      [ No26bitCode
        ADR     lr, %FT20
      |
a369 1
      ]
@


4.11.2.13
log
@Retire single use of DebugROMErrors
hdr/Options: Switch removed
s/Modhand: Switch removed, now considered equivalent to DebugROMInit. DebugROMInit changed so that the callback ordering is as expected, batched up until "callbacks" is hit after Service_PostInit.
PMF/osbyte: Redundant RISC OS 2.01 code deleted

Version 5.35, 4.79.2.184. Tagged as 'Kernel-5_35-4_79_2_184'
@
text
@d303 1
a303 1
 [ DebugROMInit                                         ; print names in ROM module init for debugging
a305 1
        ALIGN
d308 7
d317 2
a318 2
 [ DebugROMInit
        BVC     %FT79
d320 1
a320 1
        =       " => error: ",0
d324 1
a324 15
79
        WritePSRc SVC_mode+I_bit,r14                    ; this bit of gymnastis ensures that requested
        LDR     r0, =ZeroPage                           ; callbacks don't fire when doing the page scroll check
        LDRB    r1, [r0, #CallBack_Flag]                ; in the VDU driver because of the new line. Otherwise,
        BIC     r14, r1, #CBack_VectorReq               ; callbacks scheduled during ROM init are ordered
        STRB    r14, [r0, #CallBack_Flag]               ; differently for DebugROMInit {TRUE} than {FALSE}

        SWI     XOS_NewLine                             ; enables interrupts itself

        WritePSRc SVC_mode+I_bit,r14
        TST     r1, #CBack_VectorReq
        LDRNEB  r1, [r0, #CallBack_Flag]
        ORRNE   r1, r1, #CBack_VectorReq                ; re-insert that request
        STRNEB  r1, [r0, #CallBack_Flag]
        WritePSRc SVC_mode,r14
@


4.11.2.8.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d121 1
a121 1
        LDR     r9, =ZeroPage+ROMModuleChain            ; pointer to 'previous' node
d248 1
a248 1
        LDR     r12, =ZeroPage+ROMModuleChain
d335 1
a335 1
        LDR     r0, =ZeroPage
d396 1
a396 1
        LDR     r3,=ZeroPage+ChocolateBlockArrays
d506 1
a506 1
        LDREQ   r12, =ZeroPage+ROMModuleChain           ; then search from start of chain
d744 1
a744 1
         LDR     r0, =ZeroPage
d874 1
a874 1
        LDR      R9, =ZeroPage+Module_List  ; "module" that's linked at end
d965 1
a965 1
         LDR     R1, =ZeroPage+Module_List  ; prevnode
d1093 1
a1093 1
        LDR     r2, =ZeroPage+Module_List               ; prevnode for killing
d1200 1
a1200 1
         LDR     R10, =ZeroPage+Module_List
d1493 1
a1493 1
         LDR     R0, =ZeroPage+Module_List
d1537 1
a1537 1
        LDR     r12, =ZeroPage+ROMModuleChain
d1588 1
a1588 1
        LDR     r4, =ZeroPage+Module_List
d1597 1
a1597 1
        LDR     r11, =ZeroPage
d1870 1
a1870 1
        LDR     r3,=ZeroPage+ChocolateBlockArrays
d1905 1
a1905 1
        LDR     r0, =ZeroPage+Module_List
d1928 1
a1928 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d2037 1
a2037 1
        LDR     r3,=ZeroPage+ChocolateBlockArrays
d2273 1
a2273 1
         LDR     r1,=ZeroPage+ChocolateBlockArrays
d2408 1
a2408 1
         LDR     R0,=ZeroPage
d2458 1
a2458 1
         LDR     R0,=ZeroPage
d2790 1
a2790 1
        LDR    R1,=ZeroPage+Serv_SysChains
d2815 1
a2815 1
        LDR    R1,=ZeroPage+Serv_UsrChains
d2880 1
a2880 1
        LDR    R1,=ZeroPage+Serv_AwkwardChain
d2919 1
a2919 1
        LDR    R1,=ZeroPage+Serv_SysChains
d2930 1
a2930 1
        LDR    R1,=ZeroPage+Serv_UsrChains
d2952 1
a2952 1
        LDR    R1,=ZeroPage+Serv_AwkwardChain
d3059 1
a3059 1
         LDR     R11, =ZeroPage
d3174 1
a3174 1
        LDR     R0, =ZeroPage+Module_List
d3192 1
a3192 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d3222 1
a3222 1
       LDR      r3, =ZeroPage
d3279 1
a3279 1
         LDR     R2, =ZeroPage+Module_List
d3702 1
a3702 1
        LDR     r0, =ZeroPage+Module_List
@


4.10
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d2182 1
a2182 1
         MOVEQ   PC, lr
@


4.9
log
@ChocolateSysVars and ChocolateOscli merged from Ursula.

Version 4.84. Tagged as 'Kernel-4_84'
@
text
@d583 1
a583 1
       TEQP     PC, #SVC_mode               ; interrupts on
d613 1
a613 1
       TEQP     pc, #0
d629 1
a629 1
        TEQP    PC, #SVC_mode               ; interrupts on
d742 1
a742 1
         TEQP    PC, #SVC_mode
d929 2
a930 1
        Push     "R0, R1, R7, R8"
d950 2
a951 2
        Pull     "R0, R1, R7, R8"
        MOVS      PC, lr
d1036 2
a1037 1
         Push   "R0, lr"
d1043 1
a1043 1
         Pull   "R0, PC", EQ, ^
d1045 4
a1048 1
         MOV     R1, R9
d1066 1
a1066 3
         LDR     R0, [stack, #4]
         ORR     R0, R0, #V_bit
         STR     R0, [stack, #4]
d1087 1
a1087 1
        TEQP    pc, #SVC_mode                           ; interrupts on
d1130 1
a1130 1
         TEQP    PC, #SVC_mode               ; interrupts on
d1144 1
a1144 1
         TEQP    PC, #SVC_mode
d1197 1
a1197 1
         TEQP    PC, #SVC_mode               ; interrupts on
d1264 1
a1264 1
         TEQP    PC, #SVC_mode
a1319 1
 [ Fix12
a1322 3
 |
         BL      FindIncarnation
 ]
a1381 1
 [ Fix13
a1382 1
 ]
d1396 1
a1396 1
        TEQP    pc, #SVC_mode                   ; interrupts on
d1711 2
a1712 2
        Pull   "R0-R5, lr"
        ORRS    PC, lr, #V_bit
d1734 2
a1735 2
        Pull   "R0-R5, lr"
        ORRS    PC, lr, #V_bit
d1933 2
a1934 2
        Pull    "r0, r2, r3, lr"
        ORRS    pc, lr, #V_bit
d1940 2
d2111 1
a2111 2
        Pull   "R0-R6, R11, R12, lr", VC
        BICVCS  PC, lr, #V_bit
d2145 2
a2146 2
        Pull   "R3, lr"
        BICS    PC, lr, #V_bit
d2159 2
d2162 1
a2162 1
        ORRS    PC, lr, #V_bit
d2182 1
a2182 1
         BEQ     %FT01
d2189 1
a2189 1
01       BICLSS  PC, lr, #Z_bit                 ; NE return
d2191 4
a2194 1
         ORRS    PC, lr, #Z_bit                 ; EQ for success
d2200 2
a2201 1
         Push   "R0-R4, R12, lr"
d2203 4
a2206 1
         Pull   "R0-R4, R12, PC", NE, ^
d2214 4
a2217 1
         Pull   "R0-R4, R12, PC", EQ, ^
d2236 2
a2237 1
         Pull   "R0-R4, R12, PC",,^
d2397 2
a2398 1
         Push    "R0-R6,R11,R12,LR"
d2446 2
a2447 1
         Pull    "R0-R6,R11,R12,PC",,^             ;MUST preserve flags
d2806 3
a2808 3
        MOV    r8,pc
        ORR    r4,r8,#I_bit
        TEQP   r4,#0                         ;IRQs off for update of chain structures
d2840 1
a2840 1
        TEQP   r8,#0          ;restore IRQ state
d2854 3
a2856 3
        MOV    r10,pc
        ORR    r4,r10,#I_bit
        TEQP   r4,#0                         ;IRQs off for update of chain structures
d2914 2
a2915 2
        TEQP   r10,#0                     ;restore IRQ state
        Pull   "R0-R8,R10,PC",,^          ;MUST preserve flags
d2919 2
d2926 2
a2927 1
         Push   "R0-R2, lr"
d2943 2
a2944 1
         Pull   "R0-R2, PC",,^
d2972 2
a2973 1
         Push   "R0-R2, R10, lr"
d2978 1
a2978 1
         Pull   "R0-R2, R10, PC", VS
d2991 2
a2992 1
         Pull   "R0-R2, R10, PC",,^
d2995 2
a2996 1
         Push   "R0-R2, R10, lr"
d3009 2
a3010 1
         Push   "R0-R6, R11, R12, lr"
d3041 1
a3041 1
         LDR     R12, [stack, #4*(6+2)]
d3043 3
a3045 2
         Pull   "R0-R6, R11, R12, lr"
         ORRS    PC, lr, #V_bit
d3066 1
a3066 1
         CMP     R0, #0                      ; WARNING: don't try to combine these 2 instructions in a BICS, V is used below
d3072 1
a3072 1
         LDR     R12, [stack, #4*(6+2)]
d3087 1
a3087 1
         LDR     R12, [stack, #4*(6+2)]
d3096 3
a3098 2
         Pull   "R0-R6, R11, R12, lr"
         BICS    PC, lr, #V_bit
d3123 2
a3124 1
        Push    "R0-R2, lr"
d3153 2
a3154 1
        Pull   "R0-R2, PC",,^
a3159 2
       BIC      lr, lr, #I_bit
       TEQP     PC, #SVC_mode
d3161 1
d3198 2
a3199 2
       Pull    "lr"
       ORRS     PC, lr, #V_bit
d3226 2
a3227 1
         TEQP    PC, #SVC_mode               ; interrupts on
d3253 4
a3256 2
         Pull   "R4, R5, lr", LE
         ORRLES  PC, lr, #Z_bit              ; not found: naff postfix
a3274 1
 [ Fix9
a3279 6
 |
         Push   "R3"
         ADD     R3, R12, #Incarnation_Postfix
         BL      Module_StrCmp
         Pull   "R3"
 ]
d3313 1
a3313 2
        MOV     r2, #Z_bit
        TEQP    r2, pc                          ; invert EQ/NE
d3322 1
a3322 2
        MOV     r2, #Z_bit
        TEQP    r2, pc                          ; invert EQ/NE
@


4.8
log
@Ursula ChocolateSysHeap and 128-entry SWI hash table incorporated.

Version 4.83. Tagged as 'Kernel-4_83'
@
text
@d2012 6
d2117 3
d2230 210
d3056 3
@


4.7
log
@Fixed CVS synchronisation cock-up in previous check-in. Retagged.
@
text
@d401 8
d411 1
d1867 14
d1887 1
d1927 7
d1935 1
d2025 8
d2035 1
d2208 7
d2216 1
d2897 7
d2905 1
@


4.6
log
@* Added support for 24LC64 8K EEPROM (untested).
* Integrated Ursula fast service call dispatch code.
* Added Interruptible32bitModes from Ursula.
* Stopped allowing ROM modules (other than the Kernel/UtilityModule) to write
  to the hardware vectors in 26-bit mode.

Version 4.81. Tagged as 'Kernel-4_81'
@
text
@d1623 1
a1623 1
        Pull    "lr",EQ
@


4.5
log
@Fixed typo in OS_Module 21 code. You wouldn't think you could screw up a
mere 12 lines of ARM code would you?

Version 4.80. Tagged as 'Kernel-4_80'
@
text
@d20 6
d1623 1
a1623 1
        Pull    "lr",NE
d1858 3
d1862 1
d1874 3
d1878 1
d1912 9
d1940 1
d1976 4
d2037 3
d2041 1
d2058 7
d2070 3
d2172 468
d2642 1
a2642 1
  ;   R12 incarnation pointer
d2651 5
d2658 1
d2693 5
a2697 1

d2766 4
d2779 8
d2788 1
@


4.4
log
@Added OS_Module 21 (find end of ROM module chain).

Version 4.79. Tagged as 'Kernel-4_79'
@
text
@d1617 1
a1617 1
        Pull    "lr",EQ
@


4.3
log
@Following changes folded in from the start of the Ursula branch:
CPU type messages internationalised.
"Unknown OS_PlatformFeatures reason code" internationalised.
RunningOnEmul flag tweaked.
MorrisIDString conditional removed.
New modules added to SWI list at the end of the chain, on grounds that
the first-registered modules are probably more important.
*ChangeDynamicArea moved into UtilityModule from TaskManager.

Version 4.65. Tagged as 'Kernel-4_65'
@
text
@d550 1
d1600 27
@


4.2
log
@Kernel merged
@
text
@d1931 3
d1943 13
a1955 4
        ModSWIHashvalOffset R11
        LDR     R6, [R11, #ModuleSWI_HashTab]!  ;  link into table.
        STR     R6, [R2, #ModSWINode_Link]
        STR     R2, [R11]
@


4.2.2.1
log
@Module SWI chunks added to end of linked list on grounds that first loaded
modules are probably more important, so should be checked first.
Some RISC OS 3.70 bits internationalised.
*ChangeDynamicArea moved into UtilityModule from TaskManager.
@
text
@a1930 3
  ; KJB - after v3.71 add new modules at end, on grounds that first-registered
  ; modules are probably more important. Exception is when a second module wants
  ; an already used SWI chunk - it should get priority.
d1940 4
a1943 13
        ModSWIHashval R3,R11
	LDR	R4, [R3]
  	B	%FT09
   ; top of loop: R4 = node under consideration, R3 = pointer to this node from previous
08	LDR	R14, [R4, #ModSWINode_Number]
	TEQ	R11, R14			; if numbers match, jump to end. This also sets
	BEQ	%FT10				;     the new node's link to this node
	ADD	R3, R4, #ModSWINode_Link	; update R3 to this node's link
	LDR	R4, [R3] 			; and move R4 to next node
09	TEQ	R4, #0
	BNE	%BT08				; if no next node, exit loop and tack on new one
10	STR	R4, [R2, #ModSWINode_Link]
        STR     R2, [R3]
@


4.2.2.2
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d207 5
d553 1
d558 1
d735 1
d737 3
d973 14
d1145 1
d1147 1
d1204 1
d1206 3
d1216 1
d1218 3
d1268 1
d1270 3
d1278 1
d1280 3
d1301 1
d1305 3
d1341 1
d1345 3
d1367 1
d1369 1
d1439 1
d1441 1
d1528 1
d1532 1
d1678 1
d1680 1
d1689 1
d1691 1
d1773 1
d1775 3
d2037 1
d2041 1
d2199 1
d2201 1
d2311 1
d2315 15
d2339 1
d2341 1
d2408 1
d2414 6
d2578 1
d2582 1
d2614 1
d2618 4
d2630 1
d2632 4
d2644 5
d2654 1
d2668 5
d2682 1
d2689 19
d2778 1
d2780 3
d2788 1
a2788 1

d2806 5
@


4.2.2.3
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a19 6
;mjs changes for Ursula  (ChocolateOSMod) - reduce stress on SysHeap
;
                     GBLL ModHand_IntrinsicBI
ModHand_IntrinsicBI  SETL {TRUE} :LAND: ChocolateOSMod  ;base module incarnation 'node' is in module node


a389 8
  [ ChocolateSysHeap
        ASSERT  ChocolateMRBlocks = ChocolateBlockArrays + 12
        MOV     r3,#ChocolateBlockArrays
        LDR     r3,[r3,#12]
        BL      ClaimChocolateBlock
        MOVVS   r3, #ROMModule_NodeSize
        BLVS    ClaimSysHeapNode
  |
a391 1
  ]
a1758 17


  [ ChocolateSysHeap
        ASSERT  ChocolateMABlocks = ChocolateBlockArrays + 16
        MOV     r3,#ChocolateBlockArrays
        LDR     r3,[r3,#16]
        BL      ClaimChocolateBlock
    [ ModHand_IntrinsicBI
        MOVVS   r3, #ModInfo + Incarnation_Postfix + 8   ;enough for 'Base',0
    |
        MOVVS   r3, #ModInfo
    ]
        BLVS    ClaimSysHeapNode
  |
    [ ModHand_IntrinsicBI
        MOV     r3, #ModInfo + Incarnation_Postfix + 8   ;enough for 'Base',0
    |
a1759 1
    ]
a1760 1
  ]
a1770 3
  [ ModHand_IntrinsicBI
        BL      Add_intrinsic_Incarnation               ; add Base incarnation
  | 
a1771 1
  ]
a1773 1

a1795 7
  [ ChocolateSysHeap
        ASSERT  ChocolateMABlocks = ChocolateBlockArrays + 16
        MOV     r1,#ChocolateBlockArrays
        LDR     r1,[r1,#16]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
a1796 1
  ]
a1804 9

  [ ModHand_IntrinsicBI
Add_intrinsic_Incarnation  ROUT
         Push   "R0-R3, lr"
         ADD    r2, r9, #ModInfo              ;base incarnation at end of node
         MOV    r3, #Incarnation_Postfix + 5
         B      Add_Incarnation_AltEntry
  ]

a1823 1
Add_Incarnation_AltEntry
a1858 6
 [ Oscli_HashedCommands
  ; see if we need to update command hash nodes
        BL      AddCmdHashEntries
        BVS     %FT02
 ]

a1871 8
  [ ChocolateSysHeap
        ASSERT  ChocolateMSBlocks = ChocolateBlockArrays + 20
        MOV     r3,#ChocolateBlockArrays
        LDR     r3,[r3,#20]
        BL      ClaimChocolateBlock
        MOVVS   R3, #ModSWINode_Size
        BLVS    ClaimSysHeapNode
  |
a1873 1
  ]
d1879 2
a1880 2
        LDR     R4, [R3]
        B       %FT09
d1882 8
a1889 8
08      LDR     R14, [R4, #ModSWINode_Number]
        TEQ     R11, R14                        ; if numbers match, jump to end. This also sets
        BEQ     %FT10                           ;     the new node's link to this node
        ADD     R3, R4, #ModSWINode_Link        ; update R3 to this node's link
        LDR     R4, [R3]                        ; and move R4 to next node
09      TEQ     R4, #0
        BNE     %BT08                           ; if no next node, exit loop and tack on new one
10      STR     R4, [R2, #ModSWINode_Link]
a1937 3
  [ Oscli_HashedCommands
        BL      FreeCmdHashEntries
  ]
a2029 7
  [ ChocolateSysHeap
         ASSERT  ChocolateMSBlocks = ChocolateBlockArrays + 20
         MOV     r1,#ChocolateBlockArrays
         LDR     r1,[r1,#20]
         BL      FreeChocolateBlock
         BLVS    FreeSysHeapNode
  |
a2030 1
  ]
a2034 209
  [ Oscli_HashedCommands

         ASSERT  Oscli_MHashValMask = &ff

;entry: R11 -> module cmd table, R4-> 8-word (256-bit) sieve workspace
;exit:  sieve updated, R0-R3,R5,R6 trashed
;
CmdHashSieve ROUT
         MOV     R0,R4
         MOV     R1,#0
         MOV     R2,#8
10
         STR     R1,[R0],#4                        ;zero the sieve
         SUBS    R2,R2,#1
         BNE     %BT10
         ;commands with either of these flags set in information word won't be of interest:
         MOV     R5,#FS_Command_Flag :OR: Status_Keyword_Flag
         MOV     R0,R11
18
         MOV     R6,#0                             ;hash value accumulator
         LDRB    R1,[R0],#1
         CMP     R1,#0
         BEQ     %FT40                             ;no more entries
20
         UpperCase R1,R2
         ADD     R6,R6,R1                          ;hash value is sum of upper cased char values
         LDRB    R1,[R0],#1
         CMP     R1,#0
         BNE     %BT20
         ADD     R0,R0,#3
         BIC     R0,R0,#3                          ;align to word boundary
         LDR     R1,[R0,#4]                        ;pick up information word
         TST     R1,R5
         BNE     %FT30                             ;not interested in this type of command
         AND     R6,R6,#&FF                        ;hash value (256-wide)
         AND     R2,R6,#&1F
         MOV     R3,#1
         MOV     R3,R3,LSL R2                      ;position in sieve word
         MOV     R6,R6,LSR #5                      ;sieve word index
         LDR     R1,[R4,R6,LSL #2]
         ORR     R1,R1,R3                          ;set bit in sieve for this hash value
         STR     R1,[R4,R6,LSL #2]
30
         ADD     R0,R0,#4*4                        ;next command entry (skip 4 word fields)
         B       %BT18
40
         MOV     PC,LR

;
;entry: R0 -> Oscli_CmdHashLists array
;       R6 =  hash index
;exit:  node created/expanded if necessary to allow room for at least 1 more hash ptr
;       R1 -> node (may have moved, or been created)
;       OR V set, error returned if no room
;
; - a cmd hash node is:
;           1 word  = max count (according to current size of node)
;           1 word  = current count (N)
;           N words = the entries themselves (entries are module node pointers)
;
CheckRoomForNewCmdHash ROUT
         Push    "R0,R2,R3,LR"
         LDR     R1,[R0,R6,LSL #2]     ;pick up list for this hash value
         CMP     R1,#0
         BNE     %FT10
         Push    "R0,R1"
         MOV     R3,#(5+2)*4           ;enough for 5 entries, plus the two count words
         BL      ClaimSysHeapNode
         STRVS   R0,[SP]
         Pull    "R0,R1"
         BVS     %FT90
         MOV     R1,R2
         MOV     R3,#5
         STR     R3,[R1,#0]            ;set the max count word
         MOV     R3,#0
         STR     R3,[R1,#4]            ;zero the current count word
         STR     R1,[R0,R6,LSL #2]     ;store pointer to node in array
         B       %FT90
10
         LDR     R3,[R1,#0]            ;pick up the max count
         LDR     R2,[R1,#4]            ;pick up thr current count
         ADD     R2,R2,#1              ;need one more entry
         CMP     R2,R3
         BLS     %FT90
         Push    "R0"
         MOV     R0,#HeapReason_ExtendBlock
         MOV     R2,R1
         MOV     R3,#4*4               ;enough for 4 more entries
         BL      DoSysHeapOpWithExtension
         STRVS   R0,[SP]
         Pull    "R0"
         BVS     %FT90
         MOV     R1,R2
         STR     R1,[R0,R6,LSL #2]     ;store pointer to node in array (may have moved)
         LDR     R3,[R1,#0]
         ADD     R3,R3,#4
         STR     R3,[R1,#0]            ;bump max count by 4
90
         STRVS   R0,[SP]
         Pull    "R0,R2,R3,PC"
;
;
;entry: R9 -> module node
;exit:  module entered into command hash table(s) where appropriate
;       OR V set, error returned if no room
;
AddCmdHashEntries ROUT
         Push    "R0-R6,R11,R12,LR"
         LDR     R12,[R9,#Module_incarnation_list]
         CMP     R12,#0
         BNE     %FT90                             ;only do stuff if no incarnations yet
         LDR     R12,[R9,#Module_code_pointer]
         LDR     R11,=UtilityMod
         CMP     R12,R11
         BEQ     %FT90                             ;ignore UtilityModule (Oscli deals directly with it)
         LDR     R11,[R12,#Module_HC_Table]
         CMP     R11,#0
         BEQ     %FT90                             ;no commands
         ADD     R11,R12,R11                       ;R11 -> command table
         SUB     SP,SP,#8*4                        ;256-bit workspace for 256-wide hashing sieve
         MOV     R4,SP
         BL      CmdHashSieve
         ;now our sieve has a bit set for each hash value that this module occupies for commands
         MOV     R0,#0
         LDR     R0,[R0,#Oscli_CmdHashLists]
         MOV     R6,#0
42
         AND     R2,R6,#&1F
         MOV     R3,#1
         MOV     R3,R3,LSL R2                      ;position in sieve word
         MOV     R5,R6,LSR #5                      ;sieve word index
         LDR     R1,[R4,R5,LSL #2]
         TST     R1,R3
         BEQ     %FT50                             ;module does not occupy this hash value
         BL      CheckRoomForNewCmdHash            ;returns R1 -> cmd hash node
         BVS     %FT90
         LDR     R2,[R1,#4]                        ;current no. of entries on list
         ADD     R2,R2,#1
         STR     R2,[R1,#4]
         ADD     R1,R1,#4
         STR     R9,[R1,R2,LSL #2]                 ;store ptr to module node at end of list
50
         ADD     R6,R6,#1                          ;next hash value
         CMP     R6,#256
         BLO     %BT42
         ADD     SP,SP,#8*4                        ;drop sieve workspace
90
         STRVS   R0,[SP]
         Pull    "R0-R6,R11,R12,PC"
;
;
;entry: R9 -> module node
;exit:  module removed from cmd hash table(s) as necessary
;
FreeCmdHashEntries ROUT
         Push    "R0-R6,R11,R12,LR"
         LDR     R12,[R9,#Module_incarnation_list]
         CMP     R12,#0
         BNE     %FT90                             ;only do stuff if no incarnations
         LDR     R12,[R9,#Module_code_pointer]
         LDR     R11,=UtilityMod
         CMP     R12,R11
         BEQ     %FT90                             ;ignore UtilityModule (Oscli deals directly with it)
         LDR     R11,[R12,#Module_HC_Table]
         CMP     R11,#0
         BEQ     %FT90                             ;no commands
         ADD     R11,R12,R11                       ;R11 -> command table
         SUB     SP,SP,#8*4                        ;256-bit workspace for 256-wide hashing sieve
         MOV     R4,SP
         BL      CmdHashSieve
         ;now our sieve has a bit set for each hash value that this module occupies for commands
         MOV     R0,#0
         LDR     R0,[R0,#Oscli_CmdHashLists]
         MOV     R6,#0
42
         AND     R2,R6,#&1F
         MOV     R3,#1
         MOV     R3,R3,LSL R2                      ;position in sieve word
         MOV     R5,R6,LSR #5                      ;sieve word index
         LDR     R1,[R4,R5,LSL #2]
         TST     R1,R3
         BEQ     %FT50                             ;module does not occupy this hash value
         LDR     R1,[R0,R6,LSL #2]                 ;pick up list for this hash value
         LDR     R2,[R1,#4]                        ;current no. of entries on list
         SUB     R2,R2,#1
         STR     R2,[R1,#4]
         ADD     R1,R1,#8                          ;scrunch list to remove module (R9)
         MOV     R3,R1
         CMP     R2,#0
         BEQ     %FT50
         ADD     R2,R2,#1
40
         LDR     R5,[R1],#4
         CMP     R5,R9
         STRNE   R5,[R3],#4
         SUBS    R2,R2,#1
         BNE     %BT40
50
         ADD     R6,R6,#1                          ;next hash value
         CMP     R6,#256
         BLO     %BT42
         ADD     SP,SP,#8*4                        ;drop sieve workspace
90
         Pull    "R0-R6,R11,R12,PC",,^             ;MUST preserve flags
;
  ] ;Oscli_HashedCommands

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

d2037 1
a2037 1
  ;   R12 incarnation pointer, R9 module node pointer
a2045 5
  [ ModHand_IntrinsicBI
         SUB     R2, R12, R9
         CMP     R2, #ModInfo
         BEQ     FreeIncarnation_Exit   ;if equal, this is the intrinsic incarnation 'node'
  ]
a2047 1
FreeIncarnation_Exit
d2082 1
a2082 5
  [ ModHand_IntrinsicBI
         SUB     R2, R12, R9
         CMP     R2, #ModInfo
         BEQ     %FT01         ;if equal, this is the intrinsic incarnation 'node'
  ]
a2158 3
  [ Oscli_HashedCommands
         BL      FreeCmdHashEntries
  ]
a2217 7
  [ ChocolateSysHeap
        ASSERT  ChocolateMABlocks = ChocolateBlockArrays + 16
        MOV     r1,#ChocolateBlockArrays
        LDR     r1,[r1,#16]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
a2218 1
  ]
@


4.2.2.4
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a1915 4
  ; if ChocolateService, we must not add to service chains yet, because we have
  ; to make sure module's init entry is called before service entry (command
  ; and SWI hashing don't have these worries - they won't be used yet)

a1987 3
  [ ChocolateService
        BEQ     %FT05
  |
a1988 1
  ]
a2004 7
  [ ChocolateService
    ;now safe to try to add to service chains (init entry has been called)
    ;note that AddToServiceChains may cause error (ran out of room)
05
        LDRVC   R12, [stack, #4*(6+2)]
        BLVC    AddToServiceChains 
  ]
a2012 3
  [ ChocolateService
        BL      RemoveFromServiceChains
  ]
d2253 1
a2253 1
         BVS     %FT88
a2262 1
88
a2326 468
  [ ChocolateService

     LTORG

; must maintain service call chains, all attached to the 3 moorings in
; kernel workspace:
;
;   - Serv_SysChains holds a fixed array of chain anchors for the 'system'
;     service calls, in the range 1..ServMinUsrNumber
;   - Serv_UsrChains holds an array of hashed list headers, each header
;     holds an array of chains (open ended service number handling for
;     service numbers >= ServMinUsrNumber)
;   - Serv_AwkwardChain is a simple anchor for a single chain of non-compliant
;     modules (either old format, or new format without table) that do not
;     say what service calls they are interested in
;
;  The order of modules on the chains is just a convenient as-seen order, so
;  there will be subtle changes in the order of modules receiving service calls
;  compared to their order in the active module list. This only affects cases
;  where a service call may be claimed. Essentially, the new kernel does not
;  guarantee who gets a chance to claim first, but this was never defined
;  anyway.

;
;a service call chain is a block looking like this:
;  word 0 = current capacity (max entries*entry_size before block must grow)
;  word 1 = current size (current number of entries*entry_size)
;  - followed by an array of the current entries in the chain (cache friendly stuff)
;  - each entry is 3 words and looks like this:
;  word 0 = address of client service handler code
;  word 1 = workspace value for client service handler code
;  word 2 = R1 value for client (will be index for branch table), or 0 meaning pass service number
;
                         ^  0
ServChain_Capacity       #  4
ServChain_Size           #  4
ServChain_Entries        #  0
ServChain_HdrSIZEOF      #  0
;
                         ^  0
ServEntry_Code           #  4
ServEntry_WSpace         #  4
ServEntry_R1             #  4
ServEntry_SIZEOF         #  0
;

;Usr service numbers are those >= ServMinUsrNumber (see below)
;A Usr service array of chains is a block looking like this:
;  word 0 = current capacity max entries*entry_size before block must grow)
;  word 1 = current size (current number of entries*entry_size)
;  - followed by an array of the current entries in the array of chains
;  - each entry is 2 words and looks like this:
;  word 0 = service call number for chain
;  word 1 = anchor for chain (or 0 if no chain allocated)
;
                         ^  0
ServUChArray_Capacity    #  4
ServUChArray_Size        #  4
ServUChArray_Entries     #  0
ServUChArray_HdrSIZEOF   #  0
;
                         ^  0
ServUChEntry_ServiceNo   #  4
ServUChEntry_ChainAnchor #  4
ServUChEntry_SIZEOF      #  0


ServMinUsrNumber         * 256       ;'System' services in range 1..255, 'User' services >= 256
ServUsrHashSize          * 16        ; power of 2

ServMagicInstruction     * &E1A00000 ; (MOV R0,R0) indicates new module format with service table
ServIndexInR1            * 1         ; bit 0 of table flags word, if set, means pass index in R1
                                     ; to handler, rather than service number
                                     ; index corresponds directly to the position of the service
                                     ; number in the table, and starts at 1 (0 is reserved for service claim)

ServInitChainCapacity  * 4         ;no. of entries to start at for a chain block
ServBumpChainCapacity  * 4         ;no. of entries to grow by for a chain block


;hashing function for Usr service numbers is (number + (number>>8)) AND (hashsize-1)
;
        MACRO
        ServHashFunction $result,$service_number
        ADD    $result,$service_number,$service_number,LSR #8
        AND    $result,$result,#ServUsrHashSize-1
        MEND

;
;entry: [R1] -> chain block ([R1] = 0 if no block created yet)
;       R5 = Code for entry, R6 = WSpace for entry, R7 = R1 value for entry
;exit:  [R1] -> chain block (may have been created, or moved if had to grow)
;       V clear if done, V set and error if ran out of room
;
AddServChainEntry  ROUT
         Push    "R0-R4,LR"
         LDR     R2,[R1]            ;get pointer to chain block from anchor
         CMP     R2,#0
         BNE     %FT10
         MOV     R3,#ServChain_HdrSIZEOF + ServInitChainCapacity*ServEntry_SIZEOF
         Push    "R1"
         BL      ClaimSysHeapNode   ;need to create block
         Pull    "R1"
         BVS     %FT90
         STR     R2,[R1]
         MOV     R0,#ServInitChainCapacity*ServEntry_SIZEOF
         STR     R0,[R2,#ServChain_Capacity]
         MOV     R0,#0
         STR     R0,[R2,#ServChain_Size]
10
         LDR     R0,[R2,#ServChain_Size]
         LDR     R3,[R2,#ServChain_Capacity]
         CMP     R0,R3
         BLO     %FT20
         Push    "R0,R1"
         MOV     R3,#ServBumpChainCapacity*ServEntry_SIZEOF
         MOV     R0, #HeapReason_ExtendBlock
         BL      DoSysHeapOpWithExtension   ;need to grow block
         STRVS   R0,[SP]
         Pull    "R0,R1"
         BVS     %FT90
         STR     R2,[R1]
         LDR     R3,[R2,#ServChain_Capacity]
         ADD     R3,R3,#ServBumpChainCapacity*ServEntry_SIZEOF
         STR     R3,[R2,#ServChain_Capacity]
20
         ADD     R3,R2,#ServChain_HdrSIZEOF
         ADD     R3,R3,R0
         STR     R5,[R3,#ServEntry_Code]
         STR     R6,[R3,#ServEntry_WSpace]
         STR     R7,[R3,#ServEntry_R1]
         LDR     R3,[R2,#ServChain_Size]
         ADD     R3,R3,#ServEntry_SIZEOF
         STR     R3,[R2,#ServChain_Size]
90
         STRVS   R0,[SP]
         Pull    "R0-R4,PC"

;
;entry: R2 -> chain block, R5 = Code for entry to remove, R6 = WSpace for entry to remove
;exit:  registers preserved, entry removed and chain scrunched if entry was found
;
RemoveServChainEntry ROUT
         Push    "R0-R4,LR"
         CMP     R2,#0
         BEQ     %FT90
         LDR     R1,[R2,#ServChain_Size]
         CMP     R1,#0
         BEQ     %FT90
         ADD     R3,R2,#ServChain_HdrSIZEOF      ;start of chain
         ADD     R1,R1,R3                        ;end of chain
10
         LDR     R4,[R3,#ServEntry_Code]
         LDR     R0,[R3,#ServEntry_WSpace]
         TEQ     R4,R5
         TEQEQ   R0,R6
         BEQ     %FT20
         ADD     R3,R3,#ServEntry_SIZEOF
         CMP     R3,R1
         BLO     %BT10
         B       %FT90
20
         ADD     R3,R3,#ServEntry_SIZEOF        ;found, scrunch up rest of chain
         CMP     R3,R1
         BHS     %FT30
         LDR     R4,[R3,#ServEntry_Code]
         STR     R4,[R3,#ServEntry_Code - ServEntry_SIZEOF]
         LDR     R4,[R3,#ServEntry_WSpace]
         STR     R4,[R3,#ServEntry_WSpace - ServEntry_SIZEOF]
         LDR     R4,[R3,#ServEntry_R1]
         STR     R4,[R3,#ServEntry_R1 - ServEntry_SIZEOF]
         B       %BT20
30
         LDR     R1,[R2,#ServChain_Size]
         SUB     R1,R1,#ServEntry_SIZEOF
         STR     R1,[R2,#ServChain_Size]
90
         Pull    "R0-R4,PC"

;
;entry: R9 -> module node, R4 -> start of module, R5 -> service handler specified by module header
;exit:  R0 is -> table, or 0 if no table
;
FindServTable ROUT
        Push   "R1-R2,LR"
        MOV    R0,#0
        LDR    R1,[R5]
        LDR    R2,=ServMagicInstruction
        TEQ    R1,R2                    ;check for new format
        BNE    %FT90                    ;nope
        LDR    R0,[R5,#-4]              ;yes, so previous word is anchor (offset) for table
        CMP    R0,#0                    ;if anchor is 0, new format but no table specified
        ADDNE  R0,R0,R4                 ;else get address by adding module start to offset
90
        Pull   "R1-R2,PC"

;
;entry: R2 -> array of chains, R3 = service number, R5,R6,R7 = Code,WSpace,R1 for chain entry
;exit:  R0=1 if success,service number added to array if necessary, entry added to appropriate chain,
;       R0=0 if fail, because service number not yet in array, and array is full (grow not attempted)
;       or V set, error returned if no room (for chain extension)
;
AddServUsr_Hashed ROUT
        Push   "R1-R4,LR"
        ADD    R1,R2,#ServUChArray_HdrSIZEOF    ;chain start
        LDR    R0,[R2,#ServUChArray_Size]
        ADD    R0,R0,R1                         ;chain end
10
        CMP    R1,R0
        BHS    %FT20
        LDR    R4,[R1,#ServUChEntry_ServiceNo]
        TEQ    R4,R3
        ADDNE  R1,R1,#ServUChEntry_SIZEOF
        BNE    %BT10
;found entry for this service number in array
        ADD    R1,R1,#ServUChEntry_ChainAnchor  ;R1 is address of anchor for chain
        BL     AddServChainEntry
        MOVVC  R0,#1
        B      %FT90                            ;succeeded (or OS error because no room)
;
20
;entry for this service number not found, add it if array has room
        LDR    R0,[R2,#ServUChArray_Capacity]
        LDR    R4,[R2,#ServUChArray_Size]
        CMP    R4,R0
        MOVHS  R0,#0
        BHS    %FT90                             ;failed (array needs extension)
        STR    R3,[R1,#ServUChEntry_ServiceNo]   ;add entry at end of current list
        MOV    R4,#0
        STR    R4,[R1,#ServUChEntry_ChainAnchor] ;no chain yet
        LDR    R4,[R2,#ServUChArray_Size]
        ADD    R4,R4,#ServUChEntry_SIZEOF
        STR    R4,[R2,#ServUChArray_Size]
        ADD    R1,R1,#ServUChEntry_ChainAnchor   ;R1 is address of anchor for chain
        BL     AddServChainEntry
        MOVVC  R0,#1
90
        Pull   "R1-R4,PC"

;
;entry: R2 -> hash header array, R3 = service number, R5,R6,R7 = Code,WSpace,R1 for chain entry
;exit:  service number added to array on appropriate hash list if necessary, entry added to appropriate chain,
;       or V set, error returned if no room (for either chain or chain array extension)
;
AddServUsr ROUT
        Push   "R0-R4,LR"
        ServHashFunction R4,R3          ;result in R4
        ADD    R1,R2,R4,LSL #2          ;R1 -> entry for this service number in hash header array
        LDR    R2,[R1]                  ;pick up anchor for array of chains
        CMP    R2,#0
        BNE    %FT10
;must create array of chains
        Push   "R1,R3"
        MOV    R3,#ServUChArray_HdrSIZEOF + 4*ServUChEntry_SIZEOF  ;initially room for 4 entries
        BL     ClaimSysHeapNode
        Pull   "R1,R3"
        BVS    %FT90
        STR    R2,[R1]
        MOV    R0,#4*ServUChEntry_SIZEOF
        STR    R0,[R2,#ServUChArray_Capacity]
        MOV    R0,#0
        STR    R0,[R2,#ServUChArray_Size]
10
        BL     AddServUsr_Hashed
        BVS    %FT90
        CMP    R0,#1
        BEQ    %FT90                          ;add succeeded, done
;add failed, so we need to grow the array of chains
        Push   "R1,R3"
        MOV    R3,#4*ServUChEntry_SIZEOF      ;bump up capacity by 4 entries
        MOV    R0, #HeapReason_ExtendBlock
        BL     DoSysHeapOpWithExtension
        Pull   "R1,R3"
        BVS    %FT90
        STR    R2,[R1]
        LDR    R0,[R2,#ServUChArray_Capacity]
        ADD    R0,R0,#4*ServUChEntry_SIZEOF
        STR    R0,[R2,#ServUChArray_Capacity]
;now we can do the add and it cannot fail
        BL     AddServUsr_Hashed
90
        STRVS  R0,[SP]
        Pull   "R0-R4,PC"

;
;entry: R3 = service number, R5,R6,R7 = Code,WSpace,R1 for chain entry
;exit:  registers preserved, entry added to appropriate chain,
;       or V set, error returned if no room
;
AddServSysOrUsr ROUT
        Push   "R0-R4,LR"
        CMP    R3,#ServMinUsrNumber
        BHS    %FT50
        LDR    R1,=Serv_SysChains
        LDR    R2,[R1]
        CMP    R2,#0
        BNE    %FT30
;need to create array of service chain anchors, for service codes 0 to ServMinUserNumber-1
;(0 is not used, because reserved for service cliamed, but done for convenience)
        Push   "R1,R3"
        MOV    R3,#ServMinUsrNumber*4
        BL     ClaimSysHeapNode
        Pull   "R1,R3"
        BVS    %FT90
        STR    R2,[R1]
        MOV    R0,#0
        MOV    LR,#ServMinUsrNumber
        MOV    R4,R2
10
        STR    R0,[R4],#4             ;zero the anchors (no chains yet)
        SUBS   LR,LR,#1
        BNE    %BT10
30
        ADD    R1,R2,R3,LSL #2        ;address of anchor for this Sys service number
        BL     AddServChainEntry      ;add to chain
        B      %FT90
;
50
        LDR    R1,=Serv_UsrChains
        LDR    R2,[R1]
        CMP    R2,#0
        BNE    %FT70
;need to create array of hash headers for Usr chain arrays
        Push   "R1,R3"
        MOV    R3,#ServUsrHashSize*4
        BL     ClaimSysHeapNode
        Pull   "R1,R3"
        BVS    %FT90
        STR    R2,[R1]
        MOV    R0,#0
        MOV    LR,#ServUsrHashSize
        MOV    R4,R2
60
        STR    R0,[R4],#4             ;zero the hash headers
        SUBS   LR,LR,#1
        BNE    %BT60
70
        BL     AddServUsr
90
        STRVS  R0,[SP]
        Pull   "R0-R4,PC"

;
;entry: R9 -> module node, R12 -> incarnation node
;exit:  module incarnation added onto service call chains as necessary
;       OR V set, error returned if no room
;
; IRQs are disabled during update to make sure service distribution does not happen
; under interrupt, with possibly incomplete chains still under construction. A little
; worrying that this may mean interrupts are sometimes off for a while, but there you go.
;
AddToServiceChains ROUT
        Push   "R0-R8,LR"
        MOV    r8,pc
        ORR    r4,r8,#I_bit
        TEQP   r4,#0                         ;IRQs off for update of chain structures
        LDR    R4,[R9,#Module_code_pointer]  ;start of module
        LDR    R5,[R4,#Module_Service]
        CMP    R5,#0
        BEQ    %FT90
        ADD    R5,R5,R4
        ADD    R6,R12,#Incarnation_Workspace
        BL     FindServTable
        CMP    R0,#0
        BEQ    %FT50
        LDR    R1,[R0],#4            ;flags word from table
        LDR    R5,[R0],#4            ;handler code offset from table
        ADD    R5,R5,R4              ;handler code address
        MOV    R2,#0
10
        ADD    R2,R2,#1              ;next index in table (start at 1)
        LDR    R3,[R0],#4            ;next service call number from table
        CMP    R3,#0                 ;table terminated by 0
        BEQ    %FT90
        TST    R1,#ServIndexInR1
        MOVNE  R7,R2                 ;we must pass index to handler
        MOVEQ  R7,#0                 ;we must pass service number        
        BL     AddServSysOrUsr
        BVS    %FT90
        B      %BT10
;
50      ;awkward customer, with no service table
        MOV    R7,#0                 ;must pass service number to handler (there is no index)
        LDR    R1,=Serv_AwkwardChain
        BL     AddServChainEntry
90
        STRVS  R0,[SP]
        TEQP   r8,#0          ;restore IRQ state
        Pull   "R0-R8,PC"

;
;entry: R9 -> module node, R12 -> incarnation node
;exit:  module incarnation removed from service call chains as necessary
;       flags preserved
;
; IRQs are disabled during update to make sure service distribution does not happen
; under interrupt, with possibly incomplete chains still under construction. A little
; worrying that this may mean interrupts are sometimes off for a while, but there you go.
;
RemoveFromServiceChains ROUT
        Push   "R0-R8,R10,LR"
        MOV    r10,pc
        ORR    r4,r10,#I_bit
        TEQP   r4,#0                         ;IRQs off for update of chain structures
        LDR    R4,[R9,#Module_code_pointer]
        LDR    R5,[R4,#Module_Service]
        CMP    R5,#0
        BEQ    %FT90
        ADD    R5,R5,R4
        ADD    R6,R12,#Incarnation_Workspace
        BL     FindServTable
        CMP    R0,#0
        BEQ    %FT50
        LDR    R1,[R0],#4            ;flags word from table
        LDR    R5,[R0],#4            ;handler code offset from table
        ADD    R5,R5,R4              ;handler code address
10
        LDR    R3,[R0],#4            ;next service call number from table
        CMP    R3,#0                 ;table terminated by 0
        BEQ    %FT90
        CMP    R3,#ServMinUsrNumber
        BHS    %FT20
        LDR    R1,=Serv_SysChains
        LDR    R1,[R1]
        CMP    R1,#0
        BEQ    %BT10
        ADD    R1,R1,R3,LSL #2
        LDR    R2,[R1]               ;pick up anchor for Sys chain
        BL     RemoveServChainEntry
        B      %BT10
;
20
        ServHashFunction R4,R3       ;result in R4
        LDR    R1,=Serv_UsrChains
        LDR    R1,[R1]
        CMP    R1,#0
        BEQ    %BT10
        LDR    R1,[R1,R4,LSL #2]     ;pick up anchor for array of chains
        CMP    R1,#0
        BEQ    %BT10
        LDR    R8,[R1,#ServUChArray_Size]
        ADD    R4,R1,#ServUChArray_HdrSIZEOF  ;chain start
        ADD    R8,R8,R4                       ;chain end
30
        CMP    R4,R8
        BHS    %BT10
        LDR    LR,[R4,#ServUChEntry_ServiceNo]
        TEQ    LR,R3
        ADDNE  R4,R4,#ServUChEntry_SIZEOF
        BNE    %BT30
        LDR    R2,[R4,#ServUChEntry_ChainAnchor]
        BL     RemoveServChainEntry    
        B      %BT10
;
50
        LDR    R1,=Serv_AwkwardChain
        CMP    R1,#0
        BEQ    %FT90
        LDR    R2,[R1]
        BL     RemoveServChainEntry    
90
        TEQP   r10,#0                     ;restore IRQ state
        Pull   "R0-R8,R10,PC",,^          ;MUST preserve flags

  ] ;ChocolateService

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

a2462 5
  ]
  [ ChocolateService
         LDR     R12, [stack, #4*(6+2)]
         BL      RemoveFromServiceChains
         ADD     R12, R12, #Incarnation_Workspace
@


4.2.2.5
log
@ - reestablish ownership of RAMFS dynamic area by kernel; this may be
   switched out again later, if new RAMFS takes over ownership
 - make ChangeDynamicArea allow re-entrancy slightly earlier on a shrink;
   now allows re-enter after page moves but before calling any post-shrink
   handler; this should fix problem with RAMFS and new FileCore (that now
   itself uses dynamic areas); needs testing once we pull a ROM together
 - Fix following bugs:
    - (new) kernel was keeping modules on active service chains during
      call to their finalise, now temporarily delinks them, as the API
      says it should; symptom eg. Zap 1.39 fails to quit (module Zap)
    - (longstanding) *help in a taskwindow was very dangerous (eg quit
      window, run other *help, start new window can all take out OS,
      by fundamentally cracking MessageTrans); fix: *help now does not
      keep MessageTrans descriptor on SVC stack (swapped out on pre-empt),
      now has re-entrancy guard, gives 'busy' error if reentered; minor
      infelicity is that busy message may be given on new *help after
      abandoning old one in taskwindow, but the next *help will work
    - (longstanding) *time could occasionally give a scrambled message on
      first call in a taskwindow (caused by multiple use of a general
      buffer)
@
text
@a2937 4
  [ ChocolateService
         ;remove from service chains now, as part of delink
         BL      RemoveFromServiceChains
  ]    
a2946 8
  [ ChocolateService
         BVC     HaveKilled
         ;add back to service chains as part of relink (cant error through lack of memory, since we had room before delink)
         LDR     R12, [stack, #4*(6+2)]
         BL      AddToServiceChains
         B       %BT01
HaveKilled
  |
a2947 1
  ]
d2950 5
@


4.2.2.5.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d202 2
d212 3
a214 2

        B       %FT35  ;huh???
d1972 1
d1988 1
@


4.2.2.6
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d202 2
d212 3
a214 2

        B       %FT35  ;huh???
d1972 1
d1988 1
@


4.1
log
@Initial revision
@
text
@d306 2
a307 1
        =       "About to initialise module "
d316 2
a317 1
        =       "Error in ROM module init: ",0
d328 5
d399 1
a399 1
        
d810 1
a810 1
       
d848 1
a848 1
   
d872 1
a872 1
        STRVS    R0, [stack] 
d886 1
a886 1
        BEQ      %FT13           
d1026 1
a1026 1
        
d1343 1
a1343 1
         BL     TranslateError 
d1632 1
a1633 1
        MOV     R3, #0                  ; load to R2 posn
d1949 18
d2031 1
a2031 1
        MakeErrorBlock BadRMHeaderField  
d2229 1
a2229 1
02  
d2277 1
a2277 1
        Pull   "R0-R2, PC",,^ 
d2694 1
a2694 1
        ALIGN     
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d306 1
a306 2
;;;        =       "About to initialise module ",0
        =       "init mod ",0
d315 1
a315 2
;;;        =       "Error in ROM module init: ",0
        =       " error: ",0
a325 5
 [ DebugROMInit
        SWI     XOS_WriteS
        =       "mod init done",0
        SWI     XOS_NewLine
 ]
d392 1
a392 1

d803 1
a803 1

d841 1
a841 1

d865 1
a865 1
        STRVS    R0, [stack]
d879 1
a879 1
        BEQ      %FT13
d1019 1
a1019 1

d1336 1
a1336 1
         BL     TranslateError
d1625 1
a1626 1
        MOV     R0, #OSFile_Load
a1941 18
 [ StrongARM
        LDR     R4, [R9, #Module_ROMModuleNode]
        CMP     R4, #0
        BNE     %FT04                           ;It's a ROM module, so it already knows it's code
        Push    "r0-r2"
        LDR     r4, [r3, #-4]                   ;Read the length of the module from the RMA.
        MOV     r0, r3                          ;start address
        MOV     r2, r4                          ;length
        MOV     r1, #&B9                        ;Service_ModulePreInit ; a chance to patch things
        SWI     XOS_ServiceCall
        MOV     r0, #1                          ;It's a ranged synchronisation
        MOV     r1, r3                          ;Start address
        ADD     r2, r3, r4                      ;End address
        SWI     XOS_SynchroniseCodeAreas
        Pull    "r0-r2"
04
 ]

d2006 1
a2006 1
        MakeErrorBlock BadRMHeaderField
d2204 1
a2204 1
02
d2252 1
a2252 1
        Pull   "R0-R2, PC",,^
d2669 1
a2669 1
        ALIGN
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

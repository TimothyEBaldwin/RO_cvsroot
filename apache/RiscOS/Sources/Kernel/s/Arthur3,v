head	4.8;
access;
symbols
	Kernel-6_14:4.8
	Kernel-6_01-3:4.7
	Kernel-6_13:4.7
	Kernel-6_12:4.7
	Kernel-6_11:4.7
	Kernel-6_10:4.7
	Kernel-6_09:4.7
	Kernel-6_08-4_129_2_10:4.6.2.1
	Kernel-6_08-4_129_2_9:4.6.2.1
	Kernel-6_08:4.7
	Kernel-6_07:4.7
	Kernel-6_06:4.7
	Kernel-6_05-4_129_2_8:4.6.2.1
	Kernel-6_05:4.7
	Kernel-6_04:4.7
	Kernel-6_03:4.7
	Kernel-6_01-2:4.7
	Kernel-6_01-4_146_2_1:4.7
	Kernel-6_02:4.7
	Kernel-6_01-1:4.7
	Kernel-6_01:4.7
	Kernel-6_00:4.7
	Kernel-5_99:4.7
	Kernel-5_98:4.7
	Kernel-5_97-4_129_2_7:4.6.2.1
	Kernel-5_97:4.7
	Kernel-5_96:4.7
	Kernel-5_95:4.7
	Kernel-5_94:4.6
	Kernel-5_93:4.6
	Kernel-5_92:4.6
	Kernel-5_91:4.6
	Kernel-5_90:4.6
	Kernel-5_89-4_129_2_6:4.6
	Kernel-5_89:4.6
	Kernel-5_88-4_129_2_5:4.6
	Kernel-5_88-4_129_2_4:4.6
	Kernel-5_88:4.6
	Kernel-5_87:4.6
	Kernel-5_86-4_129_2_3:4.6
	Kernel-5_86-4_129_2_2:4.6
	Kernel-5_86-4_129_2_1:4.6
	Kernel-5_86:4.6
	SMP:4.6.0.2
	SMP_bp:4.6
	Kernel-5_85:4.6
	Kernel-5_54-1:4.6
	Kernel-5_84:4.6
	Kernel-5_83:4.6
	Kernel-5_82:4.6
	Kernel-5_81:4.6
	Kernel-5_80:4.6
	Kernel-5_79:4.5
	Kernel-5_78:4.5
	Kernel-5_77:4.5
	Kernel-5_76:4.5
	Kernel-5_75:4.5
	Kernel-5_74:4.5
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.5
	Kernel-5_64:4.5
	Kernel-5_63:4.5
	Kernel-5_62:4.5
	Kernel-5_61:4.5
	Kernel-5_60:4.5
	Kernel-5_59:4.5
	Kernel-5_58:4.5
	Kernel-5_57:4.5
	Kernel-5_56:4.5
	Kernel-5_55:4.5
	Kernel-5_54:4.5
	Kernel-5_53:4.5
	Kernel-5_52:4.5
	Kernel-5_51:4.5
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.3.2.11
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.3.2.11
	Kernel-5_35-4_79_2_326:4.3.2.11
	Kernel-5_35-4_79_2_325:4.3.2.11
	Kernel-5_35-4_79_2_324:4.3.2.11
	Kernel-5_35-4_79_2_323:4.3.2.11
	Kernel-5_35-4_79_2_322:4.3.2.11
	Kernel-5_35-4_79_2_321:4.3.2.11
	Kernel-5_35-4_79_2_320:4.3.2.11
	Kernel-5_35-4_79_2_319:4.3.2.11
	Kernel-5_35-4_79_2_318:4.3.2.11
	Kernel-5_35-4_79_2_317:4.3.2.11
	Kernel-5_35-4_79_2_316:4.3.2.11
	Kernel-5_35-4_79_2_315:4.3.2.11
	Kernel-5_35-4_79_2_314:4.3.2.11
	Kernel-5_35-4_79_2_313:4.3.2.11
	Kernel-5_35-4_79_2_312:4.3.2.11
	Kernel-5_35-4_79_2_311:4.3.2.11
	Kernel-5_35-4_79_2_310:4.3.2.11
	Kernel-5_35-4_79_2_309:4.3.2.11
	Kernel-5_35-4_79_2_308:4.3.2.11
	Kernel-5_35-4_79_2_307:4.3.2.11
	Kernel-5_35-4_79_2_306:4.3.2.11
	Kernel-5_35-4_79_2_305:4.3.2.11
	Kernel-5_35-4_79_2_304:4.3.2.11
	Kernel-5_35-4_79_2_303:4.3.2.11
	Kernel-5_35-4_79_2_302:4.3.2.11
	Kernel-5_35-4_79_2_301:4.3.2.11
	Kernel-5_35-4_79_2_300:4.3.2.11
	Kernel-5_35-4_79_2_299:4.3.2.11
	Kernel-5_35-4_79_2_298:4.3.2.11
	Kernel-5_35-4_79_2_297:4.3.2.11
	Kernel-5_35-4_79_2_296:4.3.2.11
	Kernel-5_35-4_79_2_295:4.3.2.11
	Kernel-5_35-4_79_2_294:4.3.2.11
	Kernel-5_35-4_79_2_293:4.3.2.11
	Kernel-5_35-4_79_2_292:4.3.2.11
	Kernel-5_35-4_79_2_291:4.3.2.11
	Kernel-5_35-4_79_2_290:4.3.2.11
	Kernel-5_35-4_79_2_289:4.3.2.11
	Kernel-5_35-4_79_2_288:4.3.2.11
	Kernel-5_35-4_79_2_287:4.3.2.11
	Kernel-5_35-4_79_2_286:4.3.2.11
	Kernel-5_35-4_79_2_285:4.3.2.11
	Kernel-5_35-4_79_2_284:4.3.2.11
	Kernel-5_35-4_79_2_283:4.3.2.11
	Kernel-5_35-4_79_2_282:4.3.2.11
	Kernel-5_35-4_79_2_281:4.3.2.11
	Kernel-5_35-4_79_2_280:4.3.2.11
	Kernel-5_35-4_79_2_279:4.3.2.11
	Kernel-5_35-4_79_2_278:4.3.2.11
	Kernel-5_35-4_79_2_277:4.3.2.11
	Kernel-5_35-4_79_2_276:4.3.2.11
	Kernel-5_35-4_79_2_275:4.3.2.11
	Kernel-5_35-4_79_2_274:4.3.2.11
	Kernel-5_35-4_79_2_273:4.3.2.11
	Kernel-5_35-4_79_2_272:4.3.2.11
	Kernel-5_35-4_79_2_271:4.3.2.11
	Kernel-5_35-4_79_2_270:4.3.2.11
	Kernel-5_35-4_79_2_269:4.3.2.11
	Kernel-5_35-4_79_2_268:4.3.2.11
	Kernel-5_35-4_79_2_267:4.3.2.11
	Kernel-5_35-4_79_2_266:4.3.2.11
	Kernel-5_35-4_79_2_265:4.3.2.11
	Kernel-5_35-4_79_2_264:4.3.2.11
	Kernel-5_35-4_79_2_263:4.3.2.11
	Kernel-5_35-4_79_2_262:4.3.2.11
	Kernel-5_35-4_79_2_261:4.3.2.11
	Kernel-5_35-4_79_2_260:4.3.2.11
	Kernel-5_35-4_79_2_259:4.3.2.11
	Kernel-5_35-4_79_2_258:4.3.2.11
	Kernel-5_35-4_79_2_257:4.3.2.11
	Kernel-5_35-4_79_2_256:4.3.2.11
	Kernel-5_35-4_79_2_255:4.3.2.11
	Kernel-5_35-4_79_2_254:4.3.2.11
	Kernel-5_35-4_79_2_253:4.3.2.11
	Kernel-5_35-4_79_2_252:4.3.2.11
	Kernel-5_35-4_79_2_251:4.3.2.11
	Kernel-5_35-4_79_2_250:4.3.2.11
	Kernel-5_35-4_79_2_249:4.3.2.11
	Kernel-5_35-4_79_2_248:4.3.2.11
	Kernel-5_35-4_79_2_247:4.3.2.11
	Kernel-5_35-4_79_2_246:4.3.2.11
	Kernel-5_35-4_79_2_245:4.3.2.11
	Kernel-5_35-4_79_2_244:4.3.2.11
	Kernel-5_35-4_79_2_243:4.3.2.11
	Kernel-5_35-4_79_2_242:4.3.2.11
	Kernel-5_35-4_79_2_241:4.3.2.11
	Kernel-5_35-4_79_2_240:4.3.2.11
	Kernel-5_35-4_79_2_239:4.3.2.11
	Kernel-5_35-4_79_2_238:4.3.2.11
	Kernel-5_35-4_79_2_237:4.3.2.11
	Kernel-5_35-4_79_2_236:4.3.2.11
	Kernel-5_35-4_79_2_235:4.3.2.11
	Kernel-5_35-4_79_2_234:4.3.2.11
	Kernel-5_35-4_79_2_233:4.3.2.11
	Kernel-5_35-4_79_2_232:4.3.2.11
	Kernel-5_35-4_79_2_231:4.3.2.11
	Kernel-5_35-4_79_2_230:4.3.2.11
	Kernel-5_35-4_79_2_229:4.3.2.11
	Kernel-5_35-4_79_2_228:4.3.2.11
	Kernel-5_35-4_79_2_227:4.3.2.11
	Kernel-5_35-4_79_2_226:4.3.2.11
	Kernel-5_35-4_79_2_225:4.3.2.11
	Kernel-5_35-4_79_2_224:4.3.2.11
	Kernel-5_35-4_79_2_223:4.3.2.11
	Kernel-5_35-4_79_2_222:4.3.2.11
	Kernel-5_35-4_79_2_221:4.3.2.11
	Kernel-5_35-4_79_2_220:4.3.2.11
	Kernel-5_35-4_79_2_219:4.3.2.11
	Kernel-5_35-4_79_2_218:4.3.2.11
	Kernel-5_35-4_79_2_217:4.3.2.11
	Kernel-5_35-4_79_2_216:4.3.2.11
	Kernel-5_35-4_79_2_215:4.3.2.11
	Kernel-5_35-4_79_2_214:4.3.2.11
	Kernel-5_35-4_79_2_213:4.3.2.11
	Kernel-5_35-4_79_2_212:4.3.2.11
	Kernel-5_35-4_79_2_211:4.3.2.11
	Kernel-5_35-4_79_2_210:4.3.2.11
	Kernel-5_35-4_79_2_209:4.3.2.11
	Kernel-5_35-4_79_2_208:4.3.2.11
	Kernel-5_35-4_79_2_207:4.3.2.11
	Kernel-5_35-4_79_2_206:4.3.2.11
	Kernel-5_35-4_79_2_205:4.3.2.11
	Kernel-5_35-4_79_2_204:4.3.2.11
	Kernel-5_35-4_79_2_203:4.3.2.11
	Kernel-5_35-4_79_2_202:4.3.2.11
	Kernel-5_35-4_79_2_201:4.3.2.11
	Kernel-5_35-4_79_2_200:4.3.2.11
	Kernel-5_35-4_79_2_199:4.3.2.11
	Kernel-5_35-4_79_2_198:4.3.2.11
	Kernel-5_35-4_79_2_197:4.3.2.11
	Kernel-5_35-4_79_2_196:4.3.2.11
	Kernel-5_35-4_79_2_195:4.3.2.11
	Kernel-5_35-4_79_2_194:4.3.2.11
	Kernel-5_35-4_79_2_193:4.3.2.11
	Kernel-5_35-4_79_2_192:4.3.2.11
	Kernel-5_35-4_79_2_191:4.3.2.11
	Kernel-5_35-4_79_2_190:4.3.2.11
	Kernel-5_35-4_79_2_189:4.3.2.11
	Kernel-5_35-4_79_2_188:4.3.2.11
	Kernel-5_35-4_79_2_187:4.3.2.11
	Kernel-5_35-4_79_2_186:4.3.2.11
	Kernel-5_35-4_79_2_185:4.3.2.11
	Kernel-5_35-4_79_2_184:4.3.2.11
	Kernel-5_35-4_79_2_183:4.3.2.11
	Kernel-5_35-4_79_2_182:4.3.2.11
	Kernel-5_35-4_79_2_181:4.3.2.11
	Kernel-5_35-4_79_2_180:4.3.2.11
	Kernel-5_35-4_79_2_179:4.3.2.11
	Kernel-5_35-4_79_2_178:4.3.2.11
	Kernel-5_35-4_79_2_177:4.3.2.11
	Kernel-5_35-4_79_2_176:4.3.2.11
	Kernel-5_35-4_79_2_175:4.3.2.11
	Kernel-5_35-4_79_2_174:4.3.2.11
	Kernel-5_35-4_79_2_173:4.3.2.10
	Kernel-5_35-4_79_2_172:4.3.2.10
	Kernel-5_35-4_79_2_171:4.3.2.10
	Kernel-5_35-4_79_2_170:4.3.2.10
	Kernel-5_35-4_79_2_169:4.3.2.10
	Kernel-5_35-4_79_2_168:4.3.2.10
	Kernel-5_35-4_79_2_167:4.3.2.10
	Kernel-5_35-4_79_2_166:4.3.2.9
	Kernel-5_35-4_79_2_165:4.3.2.9
	RPi_merge:4.3.2.8.2.1
	Kernel-5_35-4_79_2_147_2_23:4.3.2.8.2.1
	Kernel-5_35-4_79_2_147_2_22:4.3.2.8
	Kernel-5_35-4_79_2_147_2_21:4.3.2.8
	Kernel-5_35-4_79_2_147_2_20:4.3.2.8
	Kernel-5_35-4_79_2_147_2_19:4.3.2.8
	Kernel-5_35-4_79_2_147_2_18:4.3.2.8
	Kernel-5_35-4_79_2_164:4.3.2.9
	Kernel-5_35-4_79_2_163:4.3.2.9
	Kernel-5_35-4_79_2_147_2_17:4.3.2.8
	Kernel-5_35-4_79_2_147_2_16:4.3.2.8
	Kernel-5_35-4_79_2_147_2_15:4.3.2.8
	Kernel-5_35-4_79_2_162:4.3.2.9
	Kernel-5_35-4_79_2_161:4.3.2.9
	Kernel-5_35-4_79_2_147_2_14:4.3.2.8
	Kernel-5_35-4_79_2_147_2_13:4.3.2.8
	Kernel-5_35-4_79_2_160:4.3.2.9
	Kernel-5_35-4_79_2_159:4.3.2.9
	Kernel-5_35-4_79_2_158:4.3.2.9
	Kernel-5_35-4_79_2_157:4.3.2.9
	Kernel-5_35-4_79_2_156:4.3.2.9
	Kernel-5_35-4_79_2_147_2_12:4.3.2.8
	Kernel-5_35-4_79_2_147_2_11:4.3.2.8
	Kernel-5_35-4_79_2_155:4.3.2.9
	Kernel-5_35-4_79_2_147_2_10:4.3.2.8
	Kernel-5_35-4_79_2_154:4.3.2.9
	Kernel-5_35-4_79_2_153:4.3.2.9
	Kernel-5_35-4_79_2_147_2_9:4.3.2.8
	Kernel-5_35-4_79_2_152:4.3.2.9
	Kernel-5_35-4_79_2_151:4.3.2.9
	Kernel-5_35-4_79_2_147_2_8:4.3.2.8
	Kernel-5_35-4_79_2_147_2_7:4.3.2.8
	Kernel-5_35-4_79_2_150:4.3.2.8
	Kernel-5_35-4_79_2_147_2_6:4.3.2.8
	Kernel-5_35-4_79_2_147_2_5:4.3.2.8
	Kernel-5_35-4_79_2_149:4.3.2.8
	Kernel-5_35-4_79_2_147_2_4:4.3.2.8
	Kernel-5_35-4_79_2_147_2_3:4.3.2.8
	Kernel-5_35-4_79_2_148:4.3.2.8
	Kernel-5_35-4_79_2_147_2_2:4.3.2.8
	Kernel-5_35-4_79_2_147_2_1:4.3.2.8
	RPi:4.3.2.8.0.2
	RPi_bp:4.3.2.8
	Kernel-5_35-4_79_2_98_2_52_2_1:4.3.2.5.2.1
	alees_Kernel_dev:4.3.2.5.2.1.0.2
	alees_Kernel_dev_bp:4.3.2.5.2.1
	Kernel-5_35-4_79_2_147:4.3.2.8
	Kernel-5_35-4_79_2_146:4.3.2.8
	Kernel-5_35-4_79_2_145:4.3.2.8
	Kernel-5_35-4_79_2_144:4.3.2.8
	Kernel-5_35-4_79_2_143:4.3.2.8
	Kernel-5_35-4_79_2_142:4.3.2.7
	Kernel-5_35-4_79_2_141:4.3.2.7
	Kernel-5_35-4_79_2_140:4.3.2.7
	Kernel-5_35-4_79_2_139:4.3.2.7
	Kernel-5_35-4_79_2_138:4.3.2.7
	Kernel-5_35-4_79_2_137:4.3.2.7
	Kernel-5_35-4_79_2_136:4.3.2.7
	Kernel-5_35-4_79_2_135:4.3.2.7
	Kernel-5_35-4_79_2_134:4.3.2.7
	Kernel-5_35-4_79_2_133:4.3.2.7
	Kernel-5_35-4_79_2_132:4.3.2.7
	Kernel-5_35-4_79_2_131:4.3.2.7
	Kernel-5_35-4_79_2_130:4.3.2.7
	Kernel-5_35-4_79_2_129:4.3.2.7
	Kernel-5_35-4_79_2_128:4.3.2.7
	Kernel-5_35-4_79_2_127:4.3.2.6
	Kernel-5_35-4_79_2_126:4.3.2.6
	Kernel-5_35-4_79_2_125:4.3.2.6
	Kernel-5_35-4_79_2_124:4.3.2.6
	Kernel-5_35-4_79_2_123:4.3.2.6
	Cortex_merge:4.3.2.5.2.2
	Kernel-5_35-4_79_2_122:4.3.2.5
	Kernel-5_35-4_79_2_98_2_54:4.3.2.5.2.2
	Kernel-5_35-4_79_2_98_2_53:4.3.2.5.2.2
	Kernel-5_35-4_79_2_98_2_52:4.3.2.5.2.1
	Kernel-5_35-4_79_2_98_2_51:4.3.2.5.2.1
	Kernel-5_35-4_79_2_98_2_50:4.3.2.5.2.1
	Kernel-5_35-4_79_2_98_2_49:4.3.2.5.2.1
	Kernel-5_35-4_79_2_98_2_48:4.3.2.5.2.1
	Kernel-5_35-4_79_2_121:4.3.2.5
	Kernel-5_35-4_79_2_98_2_47:4.3.2.5
	Kernel-5_35-4_79_2_120:4.3.2.5
	Kernel-5_35-4_79_2_98_2_46:4.3.2.5
	Kernel-5_35-4_79_2_119:4.3.2.5
	Kernel-5_35-4_79_2_98_2_45:4.3.2.5
	Kernel-5_35-4_79_2_98_2_44:4.3.2.5
	Kernel-5_35-4_79_2_118:4.3.2.5
	Kernel-5_35-4_79_2_98_2_43:4.3.2.5
	Kernel-5_35-4_79_2_117:4.3.2.5
	Kernel-5_35-4_79_2_116:4.3.2.5
	Kernel-5_35-4_79_2_98_2_42:4.3.2.5
	Kernel-5_35-4_79_2_115:4.3.2.5
	Kernel-5_35-4_79_2_98_2_41:4.3.2.5
	Kernel-5_35-4_79_2_98_2_40:4.3.2.5
	Kernel-5_35-4_79_2_114:4.3.2.5
	Kernel-5_35-4_79_2_98_2_39:4.3.2.5
	Kernel-5_35-4_79_2_98_2_38:4.3.2.5
	Kernel-5_35-4_79_2_113:4.3.2.5
	Kernel-5_35-4_79_2_112:4.3.2.5
	Kernel-5_35-4_79_2_98_2_37:4.3.2.5
	Kernel-5_35-4_79_2_98_2_36:4.3.2.5
	Kernel-5_35-4_79_2_98_2_35:4.3.2.5
	Kernel-5_35-4_79_2_98_2_34:4.3.2.5
	Kernel-5_35-4_79_2_98_2_33:4.3.2.5
	Kernel-5_35-4_79_2_98_2_32:4.3.2.5
	Kernel-5_35-4_79_2_98_2_31:4.3.2.5
	Kernel-5_35-4_79_2_98_2_30:4.3.2.5
	Kernel-5_35-4_79_2_98_2_29:4.3.2.5
	Kernel-5_35-4_79_2_98_2_28:4.3.2.5
	Kernel-5_35-4_79_2_98_2_27:4.3.2.5
	Kernel-5_35-4_79_2_98_2_26:4.3.2.5
	Kernel-5_35-4_79_2_111:4.3.2.5
	Kernel-5_35-4_79_2_98_2_25:4.3.2.5
	Kernel-5_35-4_79_2_98_2_24:4.3.2.5
	Kernel-5_35-4_79_2_98_2_23:4.3.2.5
	Kernel-5_35-4_79_2_110:4.3.2.5
	Kernel-5_35-4_79_2_98_2_22:4.3.2.5
	Kernel-5_35-4_79_2_109:4.3.2.5
	Kernel-5_35-4_79_2_98_2_21:4.3.2.5
	Kernel-5_35-4_79_2_98_2_20:4.3.2.5
	Kernel-5_35-4_79_2_108:4.3.2.5
	Kernel-5_35-4_79_2_107:4.3.2.5
	Kernel-5_35-4_79_2_98_2_19:4.3.2.5
	Kernel-5_35-4_79_2_98_2_18:4.3.2.5
	Kernel-5_35-4_79_2_98_2_17:4.3.2.5
	Kernel-5_35-4_79_2_98_2_16:4.3.2.5
	Kernel-5_35-4_79_2_98_2_15:4.3.2.5
	Kernel-5_35-4_79_2_106:4.3.2.5
	Kernel-5_35-4_79_2_105:4.3.2.5
	Kernel-5_35-4_79_2_104:4.3.2.5
	Kernel-5_35-4_79_2_98_2_14:4.3.2.5
	Kernel-5_35-4_79_2_98_2_13:4.3.2.5
	Kernel-5_35-4_79_2_98_2_12:4.3.2.5
	Kernel-5_35-4_79_2_98_2_11:4.3.2.5
	Kernel-5_35-4_79_2_98_2_10:4.3.2.5
	Kernel-5_35-4_79_2_98_2_9:4.3.2.5
	Kernel-5_35-4_79_2_103:4.3.2.5
	Kernel-5_35-4_79_2_102:4.3.2.5
	Kernel-5_35-4_79_2_98_2_8:4.3.2.5
	Kernel-5_35-4_79_2_98_2_7:4.3.2.5
	Kernel-5_35-4_79_2_98_2_6:4.3.2.5
	Kernel-5_35-4_79_2_98_2_5:4.3.2.5
	Kernel-5_35-4_79_2_98_2_4:4.3.2.5
	Kernel-5_35-4_79_2_101:4.3.2.5
	Kernel-5_35-4_79_2_100:4.3.2.5
	Kernel-5_35-4_79_2_99:4.3.2.5
	Kernel-5_35-4_79_2_98_2_3:4.3.2.5
	Kernel-5_35-4_79_2_98_2_2:4.3.2.5
	Kernel-5_35-4_79_2_98_2_1:4.3.2.5
	Cortex:4.3.2.5.0.2
	Cortex_bp:4.3.2.5
	Kernel-5_35-4_79_2_98:4.3.2.5
	Kernel-5_35-4_79_2_97:4.3.2.5
	Kernel-5_35-4_79_2_96:4.3.2.5
	Kernel-5_35-4_79_2_95:4.3.2.5
	Kernel-5_35-4_79_2_94:4.3.2.5
	Kernel-5_35-4_79_2_93:4.3.2.5
	Kernel-5_35-4_79_2_92:4.3.2.5
	Kernel-5_35-4_79_2_91:4.3.2.5
	Kernel-5_35-4_79_2_90:4.3.2.5
	Kernel-5_35-4_79_2_89:4.3.2.5
	Kernel-5_35-4_79_2_88:4.3.2.5
	Kernel-5_35-4_79_2_87:4.3.2.5
	Kernel-5_35-4_79_2_86:4.3.2.5
	Kernel-5_35-4_79_2_85:4.3.2.5
	Kernel-5_35-4_79_2_84:4.3.2.5
	Kernel-5_35-4_79_2_83:4.3.2.5
	Kernel-5_35-4_79_2_82:4.3.2.5
	Kernel-5_35-4_79_2_81:4.3.2.5
	Kernel-5_35-4_79_2_80:4.3.2.5
	Kernel-5_35-4_79_2_79:4.3.2.5
	Kernel-5_35-4_79_2_78:4.3.2.5
	Kernel-5_35-4_79_2_77:4.3.2.5
	RO_5_07:4.3.2.5
	Kernel-5_35-4_79_2_76:4.3.2.5
	Kernel-5_35-4_79_2_75:4.3.2.5
	Kernel-5_35-4_79_2_74:4.3.2.5
	Kernel-5_35-4_79_2_73:4.3.2.5
	Kernel-5_35-4_79_2_72:4.3.2.5
	Kernel-5_35-4_79_2_71:4.3.2.5
	Kernel-5_35-4_79_2_70:4.3.2.5
	Kernel-5_35-4_79_2_69:4.3.2.5
	Kernel-5_35-4_79_2_68:4.3.2.5
	Kernel-5_35-4_79_2_67:4.3.2.5
	Kernel-5_35-4_79_2_66:4.3.2.5
	Kernel-5_35-4_79_2_65:4.3.2.5
	Kernel-5_35-4_79_2_64:4.3.2.5
	Kernel-5_35-4_79_2_63:4.3.2.5
	Kernel-5_35-4_79_2_62:4.3.2.5
	Kernel-5_35-4_79_2_61:4.3.2.5
	Kernel-5_35-4_79_2_59:4.3.2.5
	Kernel-5_35-4_79_2_58:4.3.2.5
	Kernel-5_35-4_79_2_57:4.3.2.5
	Kernel-5_35-4_79_2_56:4.3.2.5
	Kernel-5_35-4_79_2_55:4.3.2.5
	Kernel-5_35-4_79_2_54:4.3.2.4
	Kernel-5_35-4_79_2_53:4.3.2.4
	Kernel-5_35-4_79_2_52:4.3.2.4
	Kernel-5_35-4_79_2_51:4.3.2.4
	Kernel-5_35-4_79_2_50:4.3.2.3
	Kernel-5_35-4_79_2_49:4.3.2.3
	Kernel-5_35-4_79_2_48:4.3.2.3
	Kernel-5_47:4.3
	Kernel-5_46-4_90_2_1:4.3
	nbingham_Kernel_FastNC_dev_bp:4.3
	nbingham_Kernel_FastNC_dev:4.3.0.4
	Kernel-5_46:4.3
	Kernel-5_45:4.3
	Kernel-5_35-4_79_2_47:4.3.2.3
	Kernel-5_35-4_79_2_46:4.3.2.3
	Kernel-5_35-4_79_2_45:4.3.2.3
	Kernel-5_35-4_79_2_44:4.3.2.3
	Kernel-5_35-4_79_2_25_2_2:4.3.2.2
	Kernel-5_35-4_79_2_43:4.3.2.3
	Kernel-5_35-4_79_2_42:4.3.2.3
	Kernel-5_35-4_79_2_41:4.3.2.3
	Kernel-5_35-4_79_2_40:4.3.2.3
	Kernel-5_35-4_79_2_39:4.3.2.3
	Kernel-5_35-4_79_2_38:4.3.2.3
	Kernel-5_35-4_79_2_37:4.3.2.3
	Kernel-5_35-4_79_2_36:4.3.2.2
	Kernel-5_35-4_79_2_35:4.3.2.2
	Kernel-5_35-4_79_2_34:4.3.2.2
	Kernel-5_35-4_79_2_33:4.3.2.2
	Kernel-5_35-4_79_2_32:4.3.2.2
	Kernel-5_44:4.3
	Kernel-5_35-4_79_2_25_2_1:4.3.2.2
	Kernel-5_43:4.3
	Kernel-5_35-4_79_2_31:4.3.2.2
	Kernel-5_35-4_79_2_30:4.3.2.2
	Kernel-5_35-4_79_2_29:4.3.2.2
	Kernel-5_35-4_79_2_28:4.3.2.2
	Kernel-5_35-4_79_2_27:4.3.2.2
	Kernel-5_35-4_79_2_26:4.3.2.2
	Kernel-5_42:4.3
	Kernel-5_41:4.3
	Kernel-5_40:4.3
	Kernel-5_35-4_79_2_25:4.3.2.2
	Kernel-5_35-4_79_2_24:4.3.2.2
	Kernel-5_35-4_79_2_23:4.3.2.2
	Kernel-5_35-4_79_2_22:4.3.2.2
	Kernel-5_35-4_79_2_21:4.3.2.2
	Kernel-5_35-4_79_2_20:4.3.2.2
	Kernel-5_35-4_79_2_19:4.3.2.2
	Kernel-5_35-4_79_2_18:4.3.2.2
	Kernel-5_35-4_79_2_17:4.3.2.2
	Kernel-5_35-4_79_2_16:4.3.2.2
	Kernel-5_35-4_79_2_15:4.3.2.2
	Kernel-5_35-4_79_2_14:4.3.2.2
	Kernel-5_39:4.3
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.3
	Kernel-5_35-4_79_2_13:4.3.2.1
	Kernel-5_35-4_79_2_12:4.3.2.1
	Kernel-5_35-4_79_2_11:4.3.2.1
	Kernel-5_37:4.3
	Kernel-5_35-4_79_2_10:4.3.2.1
	Kernel-5_35-4_79_2_9:4.3.2.1
	Kernel-5_36:4.3
	Kernel-5_35-4_79_2_8:4.3.2.1
	Kernel-5_35-4_79_2_7:4.3.2.1
	Kernel-5_35-4_79_2_6:4.3.2.1
	Kernel-5_35-4_79_2_5:4.3.2.1
	Kernel-5_35-4_79_2_4:4.3.2.1
	Kernel-5_35-4_79_2_3:4.3.2.1
	Kernel-5_35-4_79_2_2:4.3.2.1
	dellis_autobuild_BaseSW:4.3
	Kernel-5_35-4_79_2_1:4.3.2.1
	HAL:4.3.0.2
	Kernel-5_35:4.3
	Kernel-5_34:4.3
	Kernel-5_33:4.3
	Kernel-5_32:4.3
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.3
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.2
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.2
	Ursula_RiscPC_bp:4.1.4.2
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.2
	Ursula_RiscPC:4.1.4.2.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.2
	UrsulaBuild_FinalSoftload:4.1.4.2
	rthornb_UrsulaBuild-12Aug1998:4.1.4.2
	aglover_UrsulaBuild-05Aug1998:4.1.4.2
	rthornb_UrsulaBuild-29Jul1998:4.1.4.2
	rthornb_UrsulaBuild-22Jul1998:4.1.4.2
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.2
	rthornb_UrsulaBuild-07Jul1998:4.1.4.2
	rthornb_UrsulaBuild-17Jun1998:4.1.4.2
	rthornb_UrsulaBuild-03Jun1998:4.1.4.2
	rthornb_UrsulaBuild-27May1998:4.1.4.2
	mstphens_Kernel-3_80:4.1.4.2
	rthornb_UrsulaBuild-21May1998:4.1.4.2
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2018.11.07.22.28.10;	author jlee;	state Exp;
branches;
next	4.7;
commitid	Ub9LVqEF46x8X3ZA;

4.7
date	2018.02.03.18.41.38;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	VwdJDuE1iBptBrpA;

4.6
date	2017.03.05.15.46.05;	author rool;	state Exp;
branches
	4.6.2.1;
next	4.5;
commitid	dJn0Mnw2lDlTonIz;

4.5
date	2016.06.30.20.59.45;	author jlee;	state Exp;
branches;
next	4.4;
commitid	skOEjp3ipLHx6xcz;

4.4
date	2016.06.30.20.08.07;	author jlee;	state Exp;
branches;
next	4.3;
commitid	IWoXxARWeuLDOwcz;

4.3
date	2000.08.18.09.31.45;	author sbrodie;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	2000.04.04.14.27.27;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.12;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2018.02.16.00.01.40;	author jlee;	state Exp;
branches;
next	;
commitid	L7HYXYTsWSFlZ0rA;

4.3.2.1
date	2000.09.15.12.38.00;	author kbracey;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2001.01.09.17.17.32;	author mstephen;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	2001.06.15.09.39.57;	author mstephen;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	2002.11.30.00.31.06;	author bavison;	state Exp;
branches;
next	4.3.2.5;

4.3.2.5
date	2003.01.27.15.25.32;	author kbracey;	state Exp;
branches
	4.3.2.5.2.1;
next	4.3.2.6;

4.3.2.6
date	2011.11.26.21.11.14;	author jlee;	state Exp;
branches;
next	4.3.2.7;
commitid	cI3W0zbtALQG6TIv;

4.3.2.7
date	2011.12.10.19.03.46;	author jlee;	state Exp;
branches;
next	4.3.2.8;
commitid	tEbdTPC2UwO3XFKv;

4.3.2.8
date	2012.03.24.14.16.46;	author bavison;	state Exp;
branches
	4.3.2.8.2.1;
next	4.3.2.9;
commitid	0gbd3sVMDrnpZ8Yv;

4.3.2.9
date	2012.05.26.09.00.25;	author rsprowson;	state Exp;
branches;
next	4.3.2.10;
commitid	EMsCe1GQBPXgdd6w;

4.3.2.10
date	2012.09.30.08.46.15;	author rsprowson;	state Exp;
branches;
next	4.3.2.11;
commitid	oaVP9UztPt2m3xmw;

4.3.2.11
date	2012.10.28.16.51.45;	author rsprowson;	state Exp;
branches;
next	;
commitid	ruXZqdTJKJ85Qaqw;

4.3.2.5.2.1
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	4.3.2.5.2.2;
commitid	D7rzILnwRRSXoLuv;

4.3.2.5.2.2
date	2011.09.24.19.55.53;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.3.2.8.2.1
date	2012.09.18.15.50.01;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.1.1.1
date	96.11.05.09.41.12;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.59.41;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.32.58;	author mstphens;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.03.26.11.25.25;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.10.43;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.21;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Attempt to tidy up substitute screen mode selection logic
Detail:
  Over the years the OS's substitute screen mode selection logic has grown to be a tangled mess, and the logic it does implement isn't always very useful. Additionally, the kernel is structured in such a way that it can be hard for modules to override it.
  This set of changes aims to fix the many of the problems, by doing the following:
  - Moving all substitute mode selection logic out of the core VDU driver code and into a Service_ModeTranslation handler. This means you now only have one place in the kernel to look instead of several, and modules can override the behaviour by claiming/blocking the service call as appropriate.
  - Moving handling of the built-in VIDC lists out of the core VDU driver code and into a Service_ModeExtension handler. This means programs can now inspect these VIDC lists by issuing the right service call (although you are essentially limited to lists which the GraphicsV driver is OK with)
  - Moving *TV interlace & offset adjustment logic into the Service_ModeExtension handler, since they're legacy things which can be handled more cleanly for MDF/EDID (and the old code was poking memory the kernel didn't own)
  - Adding a Service_EnumerateScreenModes implementation, so that if you end up in the desktop with ScreenModes non-functional, the display manager at least has something useful to show you
  - Enhancing the handling of the built-in numbered modes so that they are now available in any colour depth; the Service_ModeExtension handler (and related handlers) treat the builtin VIDC lists as a set of mode timings, not a discrete set of modes
  - Substitute mode selection logic is a complete re-write. Instead of trying a handful of numbered fallback modes, it now tries:
    - Same mode but at higher colour depths
    - Same mode but at lower colour depths
    - Alternate resolutions (half-width mode with no double-pixel if original request was for double-pixel, and default resolution for monitor type)
  - Combined with the logic to allow the builtin VIDC lists to be used at any colour depth, this means that the kernel should now be able to find substitute modes for machines which lack support for <=8bpp modes (e.g. OMAP5)
  - Additionally the mode substitution code will attempt to retain as many properties of the originally requested mode as possible (eigen values, gap mode type, etc.)
  Other improvements:
  - The kernel now actually vets the builtin VIDC lists instead of assuming that they'll work (which also means they'll have the correct ExtraBytes value, where applicable)
  - The kernel now uses GraphicsV 19 (VetMode2) to vet the mode during the mode switch process, using the result to detect where the framebuffer will be placed. This allows for GraphicsV drivers to switch between DA 2 and external framestores on a per-mode basis.
  - The kernel now supports mode selectors which specify LineLength values which are larger than necessary; this will get translated to a suitable ExtraBytes control list item (+ combined with whatever padding the driver indicates is necessary via the VetMode2 result)
  File changes:
  - hdr/KernelWS - Reserve space for a VIDC list, since the Service_ModeExtension implementation typically can't use the built-in list as-is
  - s/Arthur3 - Issue Service_ModeFileChanged when the configured monitor type is changed, so that DisplayManager + friends are aware that the set of available modes has changed
  - s/GetAll - Fiddle with GETs a bit
  - s/MemMap2 - Extra LTORG
  - s/NewIRQs - Small routine to install/uninstall false VSync routine (previously from PushModeInfo, which wasn't really the appropriate place for it)
  - s/Utility - Hook up the extra service call handlers
  - s/vdu/legacymodes - New file containing the new service call implementations, and some related code
  - s/vdu/vdudecl - Move mode workspace definition here, from vdumodes
  - s/vdu/vdudriver - Remove assorted bits of mode substitution code. Plug in new bits for calling GraphicsV 19 during mode set, and deal with ExtraBytes/LineLength during PushModeInfo
  - s/vdu/vdumodes - Move some workspace definitions to s/vdu/vdudecl. Tweak how the builtin VIDC lists are stored.
  - s/vdu/vduswis - Rip out more mode substitution code. Issue Service_ModeFileChanged when monitor type is changed by OS_ScreenMode.
Admin:
  Tested on Raspberry Pi 3, Iyonix, IGEPv5


Version 6.14. Tagged as 'Kernel-6_14'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => Arthur3

; the IF command

IF_Code    ROUT
        Push    "R2, lr"
        LDR     R2, =GeneralMOSBuffer
01
        LDRB    R1, [R0], #1
        STRB    R1, [R2], #1
        CMP     R1, #10
        CMPNE   R1, #13
        CMPNE   R1, #0
        BEQ     NoTHEN
        CMP     R1, #" "
        BNE     %BT01
        LDRB    R1, [R0]
        CMP     R1, #"t"
        CMPNE   R1, #"T"
        BNE     %BT01
        LDRB    R1, [R0, #1]
        CMP     R1, #"h"
        CMPNE   R1, #"H"
        BNE     %BT01
        LDRB    R1, [R0, #2]
        CMP     R1, #"e"
        CMPNE   R1, #"E"
        BNE     %BT01
        LDRB    R1, [R0, #3]
        CMP     R1, #"n"
        CMPNE   R1, #"N"
        BNE     %BT01
        LDRB    R1, [R0, #4]
        CMP     R1, #" "
        CMPNE   R1, #13
        CMPNE   R1, #10
        CMPNE   R1, #0
        BNE     %BT01
        MOV     R1, #13
        STRB    R1, [R2, #-1]
        ADD     R0, R0, #4              ; skip THEN
        Push    "R0"
        LDR     R0, =GeneralMOSBuffer
        MOV     R2, #-1    ; integers only mate
        SWI     XOS_EvaluateExpression
        BVS     WantInteger
        Pull    "R1"
        CMP     R2, #0
        BEQ     %FT02                   ; false
        LDR     R2, =GeneralMOSBuffer
03
        LDRB    R0, [R1], #1
        STRB    R0, [R2], #1
        CMP     R0, #10
        CMPNE   R0, #13
        CMPNE   R0, #0
        BEQ     %FT04
        CMP     R0, #" "
        BLEQ    %FT05
        BNE     %BT03
04
        MOV     R0, #13
        STRB    R0, [R2, #-1]
        LDR     R0, =GeneralMOSBuffer
07
        SWI     XOS_CLI
06
        Pull    "R2, PC"

05
        LDRB    R0, [R1]
        CMP     R0, #"e"
        CMPNE   R0, #"E"
        MOVNE   PC, lr
        LDRB    R0, [R1, #1]
        CMP     R0, #"l"
        CMPNE   R0, #"L"
        MOVNE   PC, lr
        LDRB    R0, [R1, #2]
        CMP     R0, #"s"
        CMPNE   R0, #"S"
        MOVNE   PC, lr
        LDRB    R0, [R1, #3]
        CMP     R0, #"e"
        CMPNE   R0, #"E"
        MOVNE   PC, lr
        LDRB    R0, [R1, #4]
        CMP     R0, #" "
        CMPNE   R1, #13
        CMPNE   R1, #10
        CMPNE   R1, #0
        MOV     PC, lr

02
        LDRB    R0, [R1], #1
        CMP     R0, #10
        CMPNE   R0, #13
        CMPNE   R0, #0
        BEQ     %BT06
        CMP     R0, #" "
        BLEQ    %BT05
        BNE     %BT02
        ADD     R0, R1, #4
        B       %BT07

NoTHEN  ROUT
        ADR     R0, %FT01
      [ International
        BL      TranslateError
      ]
IfError
        SETV
        Pull    "R2, pc"
01
        &       ErrorNumber_Syntax
        =       "NoThen:There is no THEN", 0
        ALIGN

WantInteger ROUT
        CMP     R1, #0
        Pull    "R1"
        BNE     %FT10
        SETV
        Pull    "R2, pc"               ; integer returned, so leave expranal error there
10
        ADR     R0, %FT01
      [ International
        BL      TranslateError
      ]
        B       IfError
01
        &       ErrorNumber_Syntax
        =       "IsString:Expression is a string", 0
        ALIGN

;************************************************************************
; the expression analysis SWI

; truth values
Expr_True  *  -1
Expr_False *   0

; Type symbols

type_Integer  * 0
type_String   * 1
type_Operator * 2

; operators :
; single char syms have their ascii value
op_Bra     * "("   ; 40
op_Ket     * ")"   ; 41
op_Times   * "*"   ; 42
op_Plus    * "+"   ; 43
op_Minus   * "-"   ; 45
op_Divide  * "/"   ; 47
op_LT      * "<"   ; 60
op_EQ      * "="   ; 61
op_GT      * ">"   ; 62

; now fill in some gaps

op_NE      * 44    ; <>
op_STR     * 46    ; STR
op_GE      * 48    ; >=
op_LE      * 49    ; <=
op_RShift  * 50    ; >>
op_LShift  * 51    ; <<
op_AND     * 52    ; AND
op_OR      * 53    ; OR
op_EOR     * 54    ; EOR
op_NOT     * 55    ; NOT
op_Right   * 56    ; RIGHT
op_Left    * 57    ; LEFT
op_MOD     * 58    ; MOD
op_Bottom  * 59
op_VAL     * 63    ; VAL
op_LRShift * 64    ; >>>
op_LEN     * 65    ; LEN

; TMD 12-Sep-89 - add separate tokens for monadic versions of + and -

op_UnaryPlus * 66  ; unary plus
op_UnaryMinus * 67 ; unary minus

; so 40-67 inclusive is filled.

        MACRO
$label  ePush   $reglist
        LCLS    temps
        LCLL    onereg
temps   SETS    "$reglist"
onereg  SETL    {TRUE}
        WHILE   onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL    {FALSE}
        ]
temps   SETS    temps :RIGHT: (:LEN: temps - 1)
        WEND
      [ onereg
$label  STR     $reglist, [R11, #-4]!
      |
$label  STMFD   R11!, {$reglist}
      ]
        CMP     R11, R10
        BLE     StackOFloErr
        MEND

        MACRO
$label  ePull   $reglist, $writeback, $cc
        LCLS    temps
        LCLL    onereg
temps   SETS    "$reglist"
onereg  SETL    {TRUE}
        WHILE   onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL    {FALSE}
        ]
temps   SETS    temps :RIGHT: (:LEN: temps - 1)
        WEND
    [ onereg
      [ "$writeback" = ""
        LDR$cc     $reglist, [R11], #4
      |
        LDR$cc     $reglist, [R11]
      ]
    |
      [ "$writeback" = ""
        LDM$cc.FD  R11!, {$reglist}
      |
        LDM$cc.FD  R11, {$reglist}
      ]
    ]
        MEND

;*************************************************************************
; SWI EvalExp.
; In  : R0 -> string
;       R1 -> buffer
;       R2 maxchars
; Out : R0 unchanged.
;       IF R1 = 0, R2 is an integer
;       IF R1<>0, buffer has a string, length in R2.
;       V set if bad expression, buffer overflow
;*************************************************************************

ExprBuffOFlo ROUT
        ADRL    R0, ErrorBlock_BuffOverflow
      [ International
        BL      TranslateError
      ]
        STR     R0, [stack]
        Pull    "R0-R4, lr"
        B       SLVK_SetV

ReadExpression ROUT
        Push    "R0-R4, lr"
        CLRPSR  I_bit, R12    ; interrupts on, ta.
        LDR     R12, =ExprWSpace
        STR     R13, ExprSVCstack
        LDR     R1, =ExprBuff
        MOV     R2, #LongCLISize
        ORR     R2, R2, #(1 :SHL: 30) :OR: (1 :SHL: 31)
        SWI     XOS_GSTrans   ; No | transformation, no " or space termination.
                              ; so can never go wrong!
        BCS     ExprBuffOFlo
        MOV     R0, #13
        STRB    R0, [R1, R2]

        LDR     R11, =ExprStackStart
        LDR     R10, =ExprStackLimit
        MOV     R0, #0
        STRB    R0, exprBracDif
        MOV     R0, #type_Operator
        MOV     R2, #op_Bottom
        STRB    R2, tos_op
        STMFD   R11!, {R0, R2}  ; push "bottom"

; All set : now chug round items.

01
        BL      GetFactor
        CMP     R0, #type_Operator
        BNE     %BT01

        CMP     R2, #op_Ket
        BNE     %FT02
        LDRB    R3, exprBracDif
 [ {TRUE}                       ; TMD 11-Sep-89 - save an instruction
        SUBS    R3, R3, #1
        BCC     BadBraErr
 |
        CMP     R3, #0
        BEQ     BadBraErr
        SUB     R3, R3, #1
 ]
        STRB    R3, exprBracDif

03
        LDRB    R3, tos_op
        CMP     R3, #op_Bra
        BEQ     %FT55
        BL      compile_top_op
        B       %BT03
55
        ePull   "R0, R2"
        CMP     R0, #type_Operator
        BEQ     MissingOpErr
        CMP     R0, #type_String
        BLEQ    Pull_String
        Push    "R0, R2"
        ePull   "R0, R2"
        CMP     R0, #type_Operator
        BNE     MissingOrErr    ; discard "("
        ePull   "R0, R2", No
        CMP     R0, #type_Operator
        BNE     MissingOrErr
        STRB    R2, tos_op      ; reset tosop
        Pull    "R0, R2"
        CMP     R0, #type_String
        BLEQ    Push_String
        ePush   "R0, R2"        ; move temp result down.
        B       %BT01

02
        CMP     R2, #op_Bra
        LDREQB  R3, exprBracDif
        ADDEQ   R3, R3, #1
        STREQB  R3, exprBracDif ; bracdif +:= 1

; TMD 12-Sep-89 - now check for unary plus or minus

        CMP     R2, #op_Plus                    ; if EQ then CS
        TEQNE   R2, #(op_Minus :SHL: 2),2       ; if EQ then CC
        ePull   "R0, R4", No, EQ                ; if +/- and top item is op
        TEQEQ   R0, #type_Operator, 0           ; then it's unary plus/minus
        BNE     %FT10                           ; else normal

        MOVCS   R2, #op_UnaryPlus               ; CS => unary plus
        MOVCC   R2, #op_UnaryMinus              ; CC => unary minus
10

;  WHILE lp (tos.op) > rp (itemtype) DO compile.top.op ()

        ADR     R4, rightprectab-op_Bra
        LDRB    R4, [R4, R2]
04
        ADR     R0, leftprectab-op_Bra
        LDRB    R3, tos_op
        LDRB    R0, [R0, R3]
        CMP     R0, R4
        BLE     %FT75
        BL      compile_top_op
        B       %BT04
75
        MOV     R0, #type_Operator
        ePush   "R0, R2"        ;  push (operator)
        STRB    R2, tos_op
        CMP     R2, #op_Bottom
        BNE     %BT01

; check proper expr, return it.
; should have bum/result/bum on stack.

        ePull   "R0, R2"        ; this one's forced to be bottom
        ePull   "R0, R2"
        CMP     R0, #type_Operator
        BEQ     MissingOpErr
        CMP     R0, #type_String
        BLEQ    Pull_String
        Push    "R0, R2"
        ePull   "R0, R2"
        CMP     R0, #type_Operator ; if an op's there, it has to be bottom
        Pull    "R1, R2"
        BNE     MissingOpErr

        Pull    "R0, R3, R4"    ; original R1, R2 -> R3, R4
        CMP     R1, #type_Integer
        Pull    "R3, R4, lr", EQ
        ExitSWIHandler EQ
        CMP     R4, R2
        BGE     ExprBuffOK
        MOV     R2, R4          ; no chars to move.
        ADRL    R0, BufferOFloError
        LDR     lr, [stack, #4*2]
        ORR     lr, lr, #V_bit
        STR     lr, [stack, #4*2]
ExprBuffOK
        MOV     R1, R3
        LDR     R4, =exprSTRACC ; get ptr to it.
        Push    "R2"
06
        SUBS    R2, R2, #1
        LDRPLB  R3, [R4, R2]
        STRPLB  R3, [R1, R2]
        BPL     %BT06
        Pull    "R2-R4, lr"
        ExitSWIHandler

leftprectab
;    Bra  Ket  Time Plus NE   Minu STR  Divi GE   LE   RShi LShift
   = 2,   1,   8,   7,   6,   7,   9,   8,   6,   6,   6,   6
;    AND  OR   EOR  NOT  Righ Left MOD  Bott LT   EQ   GT   VAL LRSh
   = 5,   4,   4,   9,   9,   9,   8,   1,   6,   6,   6,   9,  6
;    LEN  Un+  Un-
   = 9,   9,   9

rightprectab
;    Bra  Ket  Time Plus NE   Minu STR  Divi GE   LE   RShi LShift
   = 11,  0,   7,   6,   5,   6,   10,  7,   5,   5,   5,   5
;    AND  OR   EOR  NOT  Righ Left MOD  Bott LT   EQ   GT   VAL LRSh
   = 4,   3,   3,   10,  10,  10,  7,   1,   5,   5,   5,   10, 5
;    LEN  Un+  Un-
   = 10,  10,  10

    ALIGN

;*****************************************************************************

compile_top_op ROUT
; corrupts the flags
        Push    "R2-R4, lr"
        ePull   "R0, R2"
        CMP     R0, #type_Operator
        BEQ     MissingOpErr            ; everybody needs a rhs op
        CMP     R0, #type_String
        BLEQ    Pull_String
        ePull   "R3, R4"                ; must be tosop
        CMP     R3, #type_Operator
        BNE     MissingOrErr

        SUB     R4, R4, #op_Bra
        ADR     R3, Operator_Dispatch
        LDR     R4, [R3, R4, LSL #2]
        ADD     PC, R3, R4

DispatchReturn
        ePull   "R3, R4", No            ; pull with no writeback
        CMP     R3, #type_Operator
        BNE     MissingOrErr
        STRB    R4, tos_op
        CMP     R0, #type_String
        BLEQ    Push_String
        ePush   "R0, R2"                ; temp val -> stack

        Pull    "R2-R4, PC"

; the routines in this table are entered with one operand popped,
; any other op on stack ready to pop.
; Return with temp val set up (R0, R2 and maybe exprSTRACC)
; Can use R0, R2-R4 as reqd

Operator_Dispatch
        &       Bra_Code - Operator_Dispatch
        &       0  ;  Ket_Code - Operator_Dispatch - can't happen
        &       Times_Code - Operator_Dispatch
        &       Plus_Code - Operator_Dispatch
        &       NE_Code - Operator_Dispatch
        &       Minus_Code - Operator_Dispatch
        &       STR_Code - Operator_Dispatch
        &       Divide_Code - Operator_Dispatch
        &       GE_Code - Operator_Dispatch
        &       LE_Code - Operator_Dispatch
        &       RShift_Code - Operator_Dispatch
        &       LShift_Code - Operator_Dispatch
        &       AND_Code - Operator_Dispatch
        &       OR_Code - Operator_Dispatch
        &       EOR_Code - Operator_Dispatch
        &       NOT_Code - Operator_Dispatch
        &       Right_Code - Operator_Dispatch
        &       Left_Code - Operator_Dispatch
        &       MOD_Code - Operator_Dispatch
        &       0   ; Bottom_Code - Operator_Dispatch - can't happen
        &       LT_Code - Operator_Dispatch
        &       EQ_Code - Operator_Dispatch
        &       GT_Code - Operator_Dispatch
        &       VAL_Code - Operator_Dispatch
        &       LRShift_Code- Operator_Dispatch
        &       LEN_Code- Operator_Dispatch
        &       UnPlus_Code- Operator_Dispatch
        &       UnMinus_Code- Operator_Dispatch

;**************************************************************************
; dispatch  routines

;--------------------------------------------------------------------------
; monadic operators

VAL_Code    ROUT  ; VAL string (VAL integer is NOP)
UnPlus_Code ROUT  ; + integer (same code as VAL)
        CMP     R0, #type_String
        BLEQ    StringToInteger
        B       DispatchReturn

STR_Code ROUT  ; STR integer (STR string is NOP)
        CMP     R0, #type_Integer
        BLEQ    IntegerToString
        B       DispatchReturn

LEN_Code ROUT  ; LEN string
        CMP     R0, #type_Integer
        BLEQ    IntegerToString
        MOV     R0, #type_Integer   ; and R2 is length!
        B       DispatchReturn

NOT_Code     ROUT  ; NOT integer
        CMP     R0, #type_String
        BLEQ    StringToInteger
        MVN     R2, R2
        B       DispatchReturn

UnMinus_Code ROUT ; - integer
        CMP     R0, #type_String
        BLEQ    StringToInteger
        RSB     R2, R2, #0
        B       DispatchReturn

;--------------------------------------------------------------------------
; diadic plus

Plus_Code       ROUT  ; integer+integer ; string+string
        ePull   "R3, R4"
;       CMP     R3, #type_Operator      ; can't be operator as unary plus
;       BEQ     %FT01                   ; is separately dispatched now
        CMP     R0, #type_String
        BEQ     %FT02
        CMP     R3, #type_String
        BLEQ    PullStringToInteger     ; in R4
        ADD     R2, R2, R4
        B       DispatchReturn

02
        CMP     R3, #type_String
        BEQ     %FT03
        BL      StringToInteger
        ADD     R2, R2, R4
        B       DispatchReturn

03
        ADD     R0, R2, R4
        CMP     R0, #LongCLISize
        BGE     StrOFloErr
        LDR     R3, =exprSTRACC
        Push    "R0"                    ; new length
        ADD     R0, R3, R0
        ADD     R3, R3, R2
  ; copy R2 bytes from --(R3) to --(R0)
04
        SUBS    R2, R2, #1
        LDRGEB  R4, [R3, #-1]!
        STRGEB  R4, [R0, #-1]!
        BGE     %BT04
; R0-exprSTRACC is no of chars in stacked string
        LDR     R3, =exprSTRACC
        SUB     R0, R0, R3
05
        SUBS    R0, R0, #1
        LDRGEB  R2, [R11], #1
        STRGEB  R2, [R3], #1
        BGE     %BT05
        ADD     R11, R11, #3
        BIC     R11, R11, #3            ; realign stack
        Pull    "R2"
        MOV     R0, #type_String
        B       DispatchReturn

Minus_Code    ROUT  ; integer-integer
;       ePull   "R3, R4", No            ; can't be unary minus - this is
;       CMP     R3, #type_Operator      ; separately dispatched now
;       BEQ     %FT01
        BL      TwoIntegers
        SUB     R2, R4, R2
        B       DispatchReturn

;---------------------------------------------------------------------------
; integer pair only : maths

Times_Code   ROUT  ; integer*integer
        BL      TwoIntegers
        MOV     R3, R2
        MUL     R2, R4, R3              ; get R3*R4->R2
        B       DispatchReturn

MOD_Code     ROUT  ; integer MOD integer
        Push    "R5"
        MOV     R5, #&80000000
        B       DivModCommon

Divide_Code  ROUT  ; integer/integer
        Push    "R5"
        MOV     R5, #0
DivModCommon
        BL      TwoIntegers             ; want R4/R2
        CMP     R2, #0
        Pull    "R5", EQ
        BEQ     DivZeroErr
        RSBMI   R2, R2, #0
        EORMIS  R5, R5, #1
        EORMI   R5, R5, #1              ; oops-wanted MOD, ignore this sign
        CMP     R4, #0
        EORMI   R5, R5, #1
        RSBMI   R4, R4, #0
        DivRem  R3, R4, R2, R0          ; R3 := R4 DIV R2; R4 := R4 REM R2
        MOVS    R5, R5, LSL #1          ; CS if MOD, NE if -ve
        MOVCS   R2, R4
        MOVCC   R2, R3
        RSBNE   R2, R2, #0
        MOV     R0, #type_Integer
        Pull    "R5"
        B       DispatchReturn

;---------------------------------------------------------------------------
; integer pair only : logical

AND_Code ROUT                   ; integer AND integer
        BL      TwoIntegers
        AND     R2, R2, R4
        B       DispatchReturn

OR_Code ROUT                    ; integer OR integer
        BL      TwoIntegers
        ORR     R2, R2, R4
        B       DispatchReturn

EOR_Code ROUT                   ; integer EOR integer
        BL      TwoIntegers
        EOR     R2, R2, R4
        B       DispatchReturn

;----------------------------------------------------------------------------
; mixed operands

Right_Code ROUT                 ; string RIGHT integer
        CMP     R0, #type_Integer
        BLNE    StringToInteger
        MOV     R4, R2
        ePull   "R0, R2"
        CMP     R0, #type_String
        BNE     %FT01
        BL      Pull_String
02   ; string in stracc, R2 chars available, R4 chars wanted.
        CMP     R2, R4
        BLO     DispatchReturn  ; ignore if R4 -ve or bigger than available
        LDR     R0, =exprSTRACC
        ADD     R3, R0, R2
        SUB     R3, R3, R4      ; mov from R3 to R0, R4 bytes
03
        LDRB    R2, [R3], #1
        SUBS    R4, R4, #1
        STRGEB  R2, [R0], #1
        BGE     %BT03
        LDR     R2, =exprSTRACC
        SUB     R2, R0, R2  ; get length back.
        MOV     R0, #type_String
        B       DispatchReturn

01
        CMP     R0, #type_Operator
        BEQ     MissingOpErr
        BL      IntegerToString
        B       %BT02

Left_Code ROUT                  ; string LEFT integer
        CMP     R0, #type_Integer
        BLNE    StringToInteger
        MOV     R4, R2
        ePull   "R0, R2"
        CMP     R0, #type_String
        BNE     %FT01
        BL      Pull_String
02
        CMP     R4, R2
        MOVLO   R2, R4          ; only use new length if +ve and < current length
        B       DispatchReturn

01
        CMP     R0, #type_Operator
        BEQ     MissingOpErr
        BL      IntegerToString
        B       %BT02

;-----------------------------------------------------------------------
; relational operators

EQ_Code ROUT                    ; integer = integer ; string = string
        BL      Comparison
        MOVEQ   R2, #Expr_True
        MOVNE   R2, #Expr_False
        B       DispatchReturn

NE_Code ROUT                    ; integer<>integer ; string<>string
        BL      Comparison
        MOVNE   R2, #Expr_True
        MOVEQ   R2, #Expr_False
        B       DispatchReturn

GT_Code ROUT                    ; integer > integer ; string>string
        BL      Comparison
        MOVGT   R2, #Expr_True
        MOVLE   R2, #Expr_False
        B       DispatchReturn

LT_Code ROUT                    ; integer < integer ; string<string
        BL      Comparison
        MOVLT   R2, #Expr_True
        MOVGE   R2, #Expr_False
        B       DispatchReturn

GE_Code ROUT                    ; integer >= integer ; string>=string
        BL      Comparison
        MOVGE   R2, #Expr_True
        MOVLT   R2, #Expr_False
        B       DispatchReturn

LE_Code ROUT                    ; integer <= integer ; string<=string
        BL      Comparison
        MOVLE   R2, #Expr_True
        MOVGT   R2, #Expr_False
        B       DispatchReturn

;--------------------------------------------------------------------------
; shift operators

RShift_Code ROUT                ; integer >> integer
        BL      TwoIntegers
        CMP     R2, #0
        RSBLT   R2, R2, #0
        BLT     NegRShift
NegLShift
        CMP     R2, #32
        MOVGE   R2, R4, ASR #31 ; sign extend all through
        MOVLT   R2, R4, ASR R2
        B       DispatchReturn

LRShift_Code ROUT               ; integer >>> integer
        BL      TwoIntegers
        CMP     R2, #0
        RSBLT   R2, R2, #0
        BLT     NegRShift
        CMP     R2, #32
        MOVGE   R2, #0
        MOVLT   R2, R4, LSR R2
        B       DispatchReturn

LShift_Code ROUT                ; integer << integer
        BL      TwoIntegers
        CMP     R2, #0
        RSBLT   R2, R2, #0
        BLT     NegLShift
NegRShift
        CMP     R2, #32
        MOVGE   R2, #0
        MOVLT   R2, R4, LSL R2
        B       DispatchReturn

;---------------------------------------------------------------------------
; Support routines :

TwoIntegers   ROUT
        Push    "lr"
        CMP     R0, #type_String
        BLEQ    StringToInteger
        ePull   "R3, R4"
        CMP     R3, #type_Operator
        BEQ     MissingOpErr
        CMP     R3, #type_String
        BLEQ    PullStringToInteger
        Pull    "PC"

Comparison    ROUT
        Push    "lr"
        ePull   "R3, R4"
        CMP     R3, #type_Operator
        BEQ     MissingOpErr
        CMP     R0, #type_String
        BEQ     %FT01
        CMP     R3, #type_String
        BLEQ    PullStringToInteger
        CMP     R4, R2
        Pull    "PC"

01
        CMP     R3, #type_String
        BEQ     %FT02
        BL      StringToInteger
        CMP     R4, R2
        Pull    "PC"

02
        MOV     R3, R11
        ADD     R11, R11, R4
        ADD     R11, R11, #3
        BIC     R11, R11, #3
;    $R3, length R4 against $exprSTRACC, length R2
        Push    "R1, R2, R4, R5"
        CMP     R2, R4
        MOVGT   R2, R4                  ; minm length -> R2
        LDR     R0, =exprSTRACC
03
        SUBS    R2, R2, #1
        BLT     %FT04
        LDRB    R1, [R0], #1
        LDRB    R5, [R3], #1
        CMP     R5, R1
        BEQ     %BT03
        MOV     R0, #type_Integer
        Pull    "R1, R2, R4, R5, PC"

04
        Pull    "R1, R2, R4, R5"
        CMP     R4, R2
        MOV     R0, #type_Integer
        Pull    "PC"

StringToInteger ROUT
        Push    "R1, R3, R4, lr"
        LDR     R1, =exprSTRACC
        ADD     R3, R1, R2              ; end pointer to check all string used.
        MOV     R0, #13
        STRB    R0, [R1, R2]            ; force terminator in
01
        LDRB    R0, [R1], #1
        CMP     R0, #" "
        BEQ     %BT01
        MOV     R4, #0
        CMP     R0, #"-"
        MOVEQ   R4, #-1
        CMPNE   R0, #"+"
        SUBNE   R1, R1, #1
        MOV     R0, #10
        SWI     XOS_ReadUnsigned
02
        LDRB    R0, [R1], #1
        CMP     R0, #" "
        BEQ     %BT02
        SUB     R1, R1, #1
        CMP     R1, R3
        BNE     BadIntegerErr
        MOV     R0, #type_Integer
        CMP     R4, #0
        RSBNE   R2, R2, #0
        Pull    "R1, R3, R4, PC"

IntegerToString ROUT
        Push    "R1, lr"
        MOV     R0, R2
        LDR     R1, =exprSTRACC
        MOV     R2, #LongCLISize
        SUB     R2, R2, #1
        SWI     XOS_BinaryToDecimal
        MOV     R0, #type_String
        Pull    "R1, PC"

PullStringToInteger ROUT        ; corrupts exprSTRACC
        Push    "R0, R2, lr"
        MOV     R2, R4
        BL      Pull_String
        BL      StringToInteger
        MOV     R4, R2
        MOV     R3, #type_Integer
        Pull    "R0, R2, PC"

;******************************************************************************

GetFactor ROUT
; return type in R0
; if operator, R2 has op_xxx
; if integer/string, it has been pushed
; R1 updated, R2 corrupted.

10
        LDRB    R0, [R1], #1
        CMP     R0, #" "
        BEQ     %BT10

        CMP     R0, #13
        BNE     %FT11
        MOV     R2, #op_Bottom
        MOV     R0, #type_Operator
        MOV     PC, lr

31
        CMP     R0, #"@@"-1      ; chars >= "@@" are OK
        BGT     %FT32
        CMP     R0, #" "        ; chars <= " " always terminate
        MOVLE   PC, lr
        Push    "R2, R3"
        ADR     R2, terminatename_map-"!"
        LDRB    R3, [R2, R0]    ; termination map for " " < char < "@@"
        CMP     R3, #0
        Pull    "R2, R3"
        MOVEQ   PC, lr
32
        STRB    R0, [R3], #1
        MOV     PC, lr          ; return with GT for OK, LE for naff

terminatename_map       ; 1 means character allowed
        ;  !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?
        =  1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1
        ALIGN

11
        CMP     R0, #"&"        ; hex number?
        CMPNE   R0, #"0"
        RSBGTS  R2, R0, #"9"
        BGE     %FT03           ; got to get a number.

        CMP     R0, #""""
        BEQ     %FT04           ; string.

  ; look for operator
        Push    "R3"
        ADR     R2, operator_table
20
        LDRB    R3, [R2], #1
        CMP     R3, #0          ; end of table?
        BEQ     %FT30
        CMP     R0, R3
        BEQ     %FT21
22
        LDRB    R3, [R2], #1
        CMP     R3, #0
        BNE     %BT22
        ADD     R2, R2, #1      ;   skip op_xxx
        B       %BT20
21
        Push    "R1"
24
        LDRB    R3, [R2], #1
        CMP     R3, #0
        BEQ     %FT23
        LDRB    R0, [R1], #1
        CMP     R0, R3
        BEQ     %BT24
        Pull    "R1"
        LDRB    R0, [R1, #-1]
        B       %BT22
23
        Pull    "R3"            ; junk R1
        Pull    "R3"
        LDRB    R2, [R2]
        MOV     R0, #type_Operator
        MOV     PC, lr          ; got an operator.

30
        LDR     R3, =exprSTRACC
 ; assume variable name : try and read it.
        Push    "lr"
        BL      %BT31           ; check R0 for allowed in name, insert.
        BLE     NaffItemErr
33
        LDRB    R0, [R1], #1
        BL      %BT31
        BGT     %BT33
        SUB     R1, R1, #1
        MOV     R0, #13
        STRB    R0, [R3], #1
 ; potential name in exprSTRACC
        Push    "R1, R4"
        LDR     R0, =exprSTRACC
        MOV     R2, #-1         ; just test for existence first
        MOV     R3, #0
        MOV     R4, #0          ; no expansion
        SWI     XOS_ReadVarVal
        CMP     R2, #0
        BEQ     NaffItemErr
        LDR     R1, =exprSTRACC ; overwrite name with value
        MOV     R0, R1          ; overwritten by VSet return
        MOV     R2, #LongCLISize
        SUB     R2, R2, #1
        MOV     R3, #0
        CMP     R4, #VarType_Macro
        MOVEQ   R4, #VarType_Expanded
        SWI     XOS_ReadVarVal
        BVS     StrOFloErr
        CMP     R4, #VarType_Number
        LDREQ   R2, [R1]
        MOVEQ   R0, #type_Integer
        BLNE    Push_String
        MOVNE   R0, #type_String
        ePush   "R0, R2"
        Pull    "R1, R4, lr"
        Pull    "R3"
        MOV     PC, lr

operator_table
        =       "("    , 0, op_Bra
        =       ")"    , 0, op_Ket
        =       "+"    , 0, op_Plus
        =       "-"    , 0, op_Minus
        =       "*"    , 0, op_Times
        =       "/"    , 0, op_Divide
        =       "="    , 0, op_EQ
        =       "<>"   , 0, op_NE
        =       "<="   , 0, op_LE
        =       "<<"   , 0, op_LShift
        =       "<"    , 0, op_LT
        =       ">="   , 0, op_GE
        =       ">>>"  , 0, op_LRShift
        =       ">>"   , 0, op_RShift
        =       ">"    , 0, op_GT
        =       "AND"  , 0, op_AND
        =       "OR"   , 0, op_OR
        =       "EOR"  , 0, op_EOR
        =       "NOT"  , 0, op_NOT
        =       "RIGHT", 0, op_Right
        =       "LEFT" , 0, op_Left
        =       "MOD"  , 0, op_MOD
        =       "STR"  , 0, op_STR
        =       "VAL"  , 0, op_VAL
        =       "LEN"  , 0, op_LEN
        =       0
        ALIGN

03
        SUB     R1, R1, #1      ; point at string start
        Push    "lr"
        MOV     R0, #10
        SWI     XOS_ReadUnsigned
        LDRVS   R13, ExprSVCstack
        BVS     BumNumber2      ; already messagetransed, so don't do it again MED-01583
        MOV     R0, #type_Integer
        ePush   "R0, R2"
        Pull    "PC"

ExprErrCommon
BumNumber
        LDR     R13, ExprSVCstack
      [ International
        BL      TranslateError
      ]
BumNumber2
        STR     R0, [stack]
        Pull    "R0-R4, lr"
        MOV     R1, #0          ; haven't put anything in buffer
        B       SLVK_SetV
BadStringErr
        ADRL    R0, ErrorBlock_BadString
        B       ExprErrCommon
Bra_Code
BadBraErr
        ADR     R0, ErrorBlock_BadBra
        B       ExprErrCommon
        MakeErrorBlock BadBra
StackOFloErr
        ADR     R0, ErrorBlock_StkOFlo
        B       ExprErrCommon
        MakeErrorBlock StkOFlo
MissingOpErr
        ADR     R0, ErrorBlock_MissOpn
        B       ExprErrCommon
        MakeErrorBlock MissOpn
MissingOrErr
        ADR     R0, ErrorBlock_MissOpr
        B       ExprErrCommon
        MakeErrorBlock MissOpr
BadIntegerErr
        ADR     R0, ErrorBlock_BadInt
        B       ExprErrCommon
        MakeErrorBlock BadInt
StrOFloErr
        ADR     R0, ErrorBlock_StrOFlo
        B       ExprErrCommon
        MakeErrorBlock StrOFlo
NaffItemErr
        ADR     R0, ErrorBlock_NaffItm
        B       ExprErrCommon
        MakeErrorBlock NaffItm
DivZeroErr
        ADR     R0, ErrorBlock_DivZero
        B       ExprErrCommon
        MakeErrorBlock DivZero

04
        LDR     R2, =exprSTRACC
05
        LDRB    R0, [R1], #1
        CMP     R0, #13
        CMPNE   R0, #10
        CMPNE   R0, #0
        BEQ     BadStringErr
        CMP     R0, #""""
        BEQ     %FT06
07
        STRB    R0, [R2], #1    ; can't overflow - comes from buffer
        B       %BT05

06
        LDRB    R0, [R1], #1
        CMP     R0, #""""
        BEQ     %BT07
        SUB     R1, R1, #1
        LDR     R0, =exprSTRACC
        SUB     R2, R2, R0      ; length to R2
        Push    "lr"
        BL      Push_String
        ePush   "R0, R2"
        Pull    "PC"

Push_String  ROUT
        Push    "R2, R3"
        SUBS    R2, R2, #1
        BMI     %FT02
        BIC     R2, R2, #3
        LDR     R0, =exprSTRACC
01
        LDR     R3, [R0, R2]
        ePush   "R3"
        SUBS    R2, R2, #4
        BGE     %BT01
02
        Pull    "R2, R3"
        MOV     R0, #type_String
        MOV     PC, lr

Pull_String ROUT
        CMP     R2, #0
        MOVEQ   PC, lr
        Push    "R0, R2, R3"
        LDR     R0, =exprSTRACC
01
        ePull   "R3"
        STR     R3, [R0], #4
        SUBS    R2, R2, #4
        BGT     %BT01
        Pull    "R0, R2, R3"
        MOV     PC, lr

        LTORG

;*****************************************************************************

; Configure and Status

; The configuration table : some types and macros first.

ConType_NoParm  * 1
ConType_Field   * 2
ConType_Special * 3
ConType_Size    * 4

; Type Special has another table :
; code to set it
; code to show it
; string to print for Configure listing.
; Keep table position as offset from table entry

        MACRO
        Config_Special   $name
        =       ConType_Special, "$name", 0
        ALIGN
        &       Config_$name._table - .
        MEND

; Table offset :
Config_Special_SetCode  * 0
Config_Special_ShowCode * 4
Config_Special_String   * 8

; Type NoParm  : *con. name
; put $value into bits $bitoff to $bitoff+$fwidth in byte $byteoff

        MACRO
        Config_NoParm   $name, $bitoff, $fwidth, $bytoff, $value
        =       ConType_NoParm, "$name", 0
        ALIGN
        =       $bitoff, $fwidth, $bytoff, $value
        MEND

; Type Field   : *con. name number
; read value & put into bits $bitoff to $bitoff+$fwidth in byte $byteoff

        MACRO
        Config_Field   $name, $bitoff, $fwidth, $bytoff
        =       ConType_Field, "$name", 0
        ALIGN
        =       $bitoff, $fwidth, $bytoff, 0
        MEND

; Type Size   : *con. name number|nK
; read value & put into bits $bitoff to $bitoff+$fwidth in byte $byteoff

        MACRO
$l      Config_Size   $name, $bitoff, $fwidth, $bytoff
        =       ConType_Size, "$name", 0
        ALIGN
$l      =       $bitoff, $fwidth, $bytoff, 0
        MEND

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; now the table

Config_Table
        Config_Special  Baud
AlternateBoot
        Config_NoParm   Boot,           4, 0, DBTBCMOS, 1
AlternateNoBoot
        Config_NoParm   NoBoot,         4, 0, DBTBCMOS, 0
        Config_Special  Cache
AlternateCaps
        Config_NoParm   Caps,           3, 2, StartCMOS, 4
AlternateNoCaps
        Config_NoParm   NoCaps,         3, 2, StartCMOS, 2
ExpandShCaps
        Config_NoParm   ShCaps,         3, 2, StartCMOS, 1
EndListCapsFrig
AlternateNum
        Config_NoParm   Num,            7, 0, StartCMOS, 0
AlternateNoNum
        Config_NoParm   NoNum,          7, 0, StartCMOS, 1
        Config_Field    Data,           5, 2, DBTBCMOS
        Config_Field    Delay,          0, 7, KeyDelCMOS
        Config_Field    DumpFormat,     0, 4, PrintSoundCMOS
        Config_Size     FontSize,       0, 7, FontCMOS
FontSizeFrig
        Config_Special  Ignore
        Config_Field    Language,       0, 7, LanguageCMOS
AlternateLoud
        Config_NoParm   Loud,           1, 0, DBTBCMOS, 1
        Config_Special  Mode
        Config_Special  MonitorType
        Config_Special  MouseStep
        Config_Special  MouseType
        Config_Field    Print,          5, 2, PSITCMOS
        Config_Size     PrinterBufferSize, 0, 7, PrinterBufferCMOS
PrinterBufferFrig
AlternateQuiet
        Config_NoParm   Quiet,          1, 0, DBTBCMOS, 0
        Config_Size     RamFSSize,      0, 6, RAMDiscCMOS
        Config_Field    Repeat,         0, 7, KeyRepCMOS
        Config_Size     RMASize,        0, 6, RMASizeCMOS
        Config_Size     ScreenSize,     0, 6, ScreenSizeCMOS
ScreenSizeFrig
AlternateScroll
        Config_NoParm   Scroll,         3, 0, DBTBCMOS, 0
AlternateNoScroll
        Config_NoParm   NoScroll,       3, 0, DBTBCMOS, 1
        Config_Size     SpriteSize,     0, 6, SpriteSizeCMOS
        Config_Special  Sync
        Config_Size     SystemSize,     0, 5, SysHeapCMOS
        Config_Special  TV
        Config_Special  WimpMode
        =       0

ShCapsString = "ShiftCaps", 0

        ALIGN

ExpandFrig * 8    ; see code that shows NoParm options.
ExpandTab
        &       ExpandShCaps    - ExpandFrig-.
        &       ShCapsString    - .-1
        &       0

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        MACRO
        Config_Special_Table $name, $text
Config_$name._table
        B       Config_$name._setcode
        B       Config_$name._showcode
        =       "$text", 0
        ALIGN
        MEND

        ALIGN
        Config_Special_Table Baud, "<D>"
        Config_Special_Table Cache, "On|Off"
        Config_Special_Table TV, "[<D> [[,] <D>]]"
        Config_Special_Table Mode, "<D> | Auto"
        Config_Special_Table Ignore, "[<D>]"
        Config_Special_Table MouseStep, "<D>"
        Config_Special_Table MouseType, "<D>"
        Config_Special_Table MonitorType, "<D> | EDID | Auto"
        Config_Special_Table Sync, "<D> | Auto"
        Config_Special_Table WimpMode, "<D> | Auto"

;*****************************************************************************
; Lookup : R0 -> option
;   Exit : R2 -> table entry, EQ for not found
;          R0 stepped on

FindOption Entry "r1, r3-r5"
        ADRL    r2, Config_Table+1
04
        MOV     r1, #0                         ; offset
01
        LDRB    r3, [r0, r1]
        LDRB    r4, [r2, r1]
        CMP     r3, #32
        CMPLE   r4, #32
        BLE     %FT02
        UpperCase r3, r5
        UpperCase r4, r5
        CMP     r3, r4
        ADDEQ   r1, r1, #1
        BEQ     %BT01
        CMP     r3, #"."
        TOGPSR  Z_bit, r3                       ; invert EQ/NE
        CMPNE   r1, #0
        ADDNE   r1, r1, #1                      ; skip .
        BNE     %FT02
03
        LDRB    r1, [r2], #1
        CMP     r1, #0
        BNE     %BT03
        ADD     r2, r2, #7                      ; skip infoword
        BIC     r2, r2, #3
        LDRB    r1, [r2], #1
        CMP     r1, #0
        BNE     %BT04
        EXIT                                    ; failure exit

02
        ADD     r0, r0, r1                      ; point at char after option
        SUBS    r2, r2, #1
        EXIT                                    ; return with success

;****************************************************************************
;
; Configure
; IF noparms OR parm=. THEN list options : issue service call : finish listing
;                      ELSE lookup parm1 : doit
;    IF notfound THEN issue service

Configure_Help ROUT
        Push    "r0, lr"
        ADR     r0, %FT01
        MOV     r1, #Status_Keyword_Flag
        B       KeyHelpCommon
01
        DCB     "HUTMCON", 0
        ALIGN

Configure_Code  ROUT
        Push    "lr"
        CMP     r1, #0          ; noparms?
        MOVEQ   r3, #0
        BEQ     ListAll         ; go listem.
        BL      FindOption
        BEQ     %FT01
        LDRB    r4, [r2], #1
03
        LDRB    r1, [r2], #1
        CMP     r1, #0
        BNE     %BT03
        ADD     r2, r2, #3
        BIC     r2, r2, #3
        LDR     r1, [r2]
        CMP     r4, #ConType_Size
        BEQ     ReadSizeParm

        CMP     r4, #ConType_Field
        ASSERT  ConType_Special > ConType_Field
; if special dispatch it
        ADDGT   r1, r1, r2                              ; point at node
        ADDGT   pc, r1, #Config_Special_SetCode         ; call it
; if noparm get value
        MOVLT   r2, r1, LSR #24
        BLEQ    ReadNumParm
        BVS     BadConParm
BaudEntry
        BL      ConfigCheckEOL
        Pull    "pc", VS
IgnoreEntry
        MOV     r0, r1                  ; info word
        BL      ReadByte                ; current byte into R1

        MOV     r3, r0, LSR #8
        AND     r3, r3, #&FF            ; get fwidth
        MOV     r4, #2
        MOV     r4, r4, LSL r3
        SUB     r4, r4, #1              ; get mask/maximum value
        CMP     r2, r4
        BHI     ConParmTooBig

        AND     r3, r0, #&FF            ; get bitoff
        BIC     r1, r1, r4, LSL r3      ; clear bits in correct position
        ORR     r2, r1, r2, LSL r3      ; OR in new bits

        MOV     r1, r0, LSR #16         ; get bytoff
        AND     r1, r1, #&FF
        MOV     r0, #WriteCMOS
        SWI     XOS_Byte                ; and set it. Assume this clears V!

        Pull    "pc" 

BadConParm
        MOV     r0, #1
        B       ConfigGenErr
BadConParmError
        &       ErrorNumber_Syntax
        =       "NotNumeric:Numeric parameter needed", 0
        ALIGN

ConParmTooBig
        MOV     r0, #2
        B       ConfigGenErr
ConParmTooBigError
        &       ErrorNumber_Syntax
        =       "ConParmTooBig:Configure parameter too big", 0
        ALIGN
01
        LDR     r12, =ZeroPage+Module_List
conoptloop
        LDR     r12, [r12]
        CMP     r12, #0
        BEQ     conoptservice
        LDR     r1, [r12, #Module_code_pointer]
        LDR     r2, [r1, #Module_HC_Table]
        CMP     r2, #0
        BEQ     conoptloop
        MOV     r4, #Status_Keyword_Flag
        BL      FindItem
        BCC     conoptloop              ; next module
        ADD     r0, r0, r3              ; point at commtail
        LDR     r12, [r12, #Module_incarnation_list]    ; preferred life
        ADDS    r12, r12, #Incarnation_Workspace        ; clear V
        Push    "r1-r6"

StKey_SkipSpaces
        LDRB    r4, [r0], #1
        CMP     r4, #" "
        BEQ     StKey_SkipSpaces
        SUB     r0, r0, #1

        MOV     lr, pc
        ADD     pc, r1, r5            ; call im
        Pull    "r1-r6"
        Pull    "pc", VC
ConfigGenErr
        CMP     r0, #3
        BHI     ExitConfig
        ADREQL  r0, Config2manyparms
        CMP     r0, #2
        ADREQ   r0, ConParmTooBigError
        CMP     r0, #1
        ADRLO   r0, BadConOptError
        ADREQ   r0, BadConParmError
      [ International
        BL      TranslateError
      ]
ExitConfig
        SETV
        Pull    "pc"

conoptservice
        MOV     r1, #Service_UKConfig
        BL      Issue_Service
        CMP     r1, #0
        BNE     BadConOpt
        CMP     r0, #0
        BGE     ConfigGenErr
        Pull    "pc"                    ; TBS means OK: note CMP has cleared V

BadConOpt
        MOV     r0, #0
        B       ConfigGenErr
BadConOptError
        &       ErrorNumber_Syntax
        =       "BadConOpt:Configure option not recognised", 0
        ALIGN

ReadNumParm Entry "r1"
10
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     %BT10
        SUB     r1, r0, #1
        MOV     r0, #10                 ; set base
        SWI     XOS_ReadUnsigned
        EXIT    VS
        MOV     r0, r1
        LDRB    r1, [r0]
        CMP     r1, #" "
        SETV    GT
        EXIT

; read a number or Auto
; returns R2 = number or -1 for Auto
;         R0 -> terminator

ReadNumAuto Entry "r1,r3,r4"
10
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     %BT10
        SUB     r1, r0, #1
        ADR     r3, AutoString          ; string to match against
        MOV     r4, #0                  ; no other terminators for $R1
        BL      Module_StrCmp           ; out: EQ => match, r1 -> terminator
                                        ;      NE => no match, r1 preserved
                                        ;      r3 corrupted in both cases
        MOVEQ   r2, #-1
        BEQ     %FT20
        MOV     r0, #10                 ; set base
        SWI     XOS_ReadUnsigned
        EXIT    VS
20
        MOV     r0, r1
        LDRB    r1, [r0]
        CMP     r1, #" "
        SETV    GT
        EXIT

AutoString
        =       "Auto", 0
dotstring
        =       ".", 0
        ALIGN

ReadSizeParm ROUT
        Push    "r1, r8"
        MOV     r8, r2
02
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     %BT02
        SUB     r1, r0, #1
        MOV     r0, #10                 ; set base
        SWI     XOS_ReadUnsigned
        Pull    "r1, r8", VS
        BVS     BadConParm
        MOV     r0, r1
        LDRB    r1, [r0]
        CMP     r1, #" "
        BLE     %FT01
        CMP     r1, #"k"
        CMPNE   r1, #"K"
        Pull    "r1, r8", NE
        BNE     BadConParm
        ADRL    r14, PrinterBufferFrig-4
        TEQ     r8, r14                 ; if printer buffer size
        TEQEQ   r2, #1                  ; and 1K
        MOVEQ   r2, #0                  ; then use zero (default)
        ADRL    r14, FontSizeFrig-4     ; point at info word for fontsize
        TEQ     r8, r14                 ; if fontsize
        MOVEQ   r8, #4*1024             ; then use 4K (lucky it's a pagesize!)
        LDRNE   r8, =ZeroPage           ; else use pagesize units
        LDRNE   r8, [r8, #Page_Size]
        ADRL    r14, PageShifts-1
        LDRB    r14, [r14, r8, LSR #12]
        SUB     r14, r14, #10           ; *1024
        MOV     r8, r8, LSR #10         ; /1024
        SUB     r8, r8, #1
        ADD     r2, r2, r8
        BIC     r2, r2, r8              ; round up to nearest pagesize
        MOV     r2, r2, LSR r14         ; divide parm by pagesize
        ADD     r0, r0, #1              ; point past "K" for EOL checking
01
        Pull    "r1, r8"
        B       BaudEntry

;*****************************************************************************
; Status
; list all options matched : allow . and <terminator> to match all
; issue service

Status_Code     ROUT
        Push    "lr"
        CMP     r1, #0          ; noparms?
        MOVEQ   r3, #1
        BEQ     ListAll         ; go listemall
        CMP     r1, #1
        BNE     %FT01
        BL      FindOption
        BEQ     %FT01
        MOV     r3, #2
        BL      ListOneConfig
        Pull    "pc"

01
        LDR     r6, =ZeroPage+Module_List
statoptloop
        LDR     r6, [r6]
        CMP     r6, #0
        BEQ     statoptservice
        LDR     r1, [r6, #Module_code_pointer]
        LDR     r2, [r1, #Module_HC_Table]
        CMP     r2, #0
        BEQ     statoptloop
        MOV     r4, #Status_Keyword_Flag
        BL      FindItem
        BCC     statoptloop             ; next module
        MOV     r0, #1
        LDR     r12, [r6, #Module_incarnation_list]
        ADD     r12, r12, #Incarnation_Workspace
        Push    "r0-r6"
        MOV     lr, pc
        ADD     pc, r1, r5              ; call im
        STRVS   r0, [sp]
        Pull    "r0-r6, pc"

statoptservice
        MOV     r1, #Service_UKStatus
        BL      Issue_Service
        CMP     r1, #0
        Pull    "pc", EQ
        ADR     r0, %FT03
      [ International
        BL      TranslateError
      |
        SETV
      ]
        Pull    "pc"
03
        &       ErrorNumber_Syntax
        =       "BadStat:Bad status option", 0
        ALIGN

;*****************************************************************************

; routine to list everything : on entry R3 = 0 means entered from configure
;                                          = 1   "     "      "   status
;                                       lr stacked for return

ListAll ROUT
        MOV     r0, #117                ; Read current VDU status
        SWI     XOS_Byte                ; Won't fail
        Push    "r1"

      [ International
        SWI     XOS_WriteI+14
        BL      WriteS_Translated
        =       "Config:Configuration",0
        ALIGN
        SWIVC   XOS_WriteI+" "
      |
        SWI     XOS_WriteS
        =       14, "Configuration ", 0 ; paged mode on.
        ALIGN
      ]
        Pull    "r1, pc", VS            ; Wrch can fail
        CMP     r3, #0
        ADREQ   r0, %FT06
        ADRNE   r0, %FT08
      [ International
        BL      Write0_Translated
      |
        SWI     XOS_Write0
      ]
        SWIVC   XOS_NewLine
        SWIVC   XOS_NewLine
        Pull    "r1, pc", VS

        ADRL    r2, Config_Table
02
        ADRL    r4, AlternateCaps
        CMP     r4, r2
        CMPEQ   r3, #1
        BEQ     FrigCapsList
        LDRB    r4, [r2]
        CMP     r4, #0
        BLNE    ListOneConfig
        Pull    "r1, pc", VS
        BNE     %BT02

10
        ADRL    r0, dotstring           ; match all
        Push    "r3, r7"
        LDR     r7, =ZeroPage+Module_List
listallmloop
        LDR     r7, [r7]
        CMP     r7, #0
        BEQ     listallservice
        LDR     r1, [r7, #Module_code_pointer]
        LDR     r2, [r1, #Module_HC_Table]
        CMP     r2, #0
        BEQ     listallmloop
listalltryfind
        MOV     r4, #Status_Keyword_Flag
        BL      FindItem
        BCC     listallmloop            ; next module
        LDR     r0, [stack]             ; pick up r3
        LDR     r12, [r7, #Module_incarnation_list]
        ADD     r12, r12, #Incarnation_Workspace
        Push    "r0-r6"
        MOV     lr, pc
        ADD     pc, r1, r5              ; call im
        Pull    "r0-r6"
        ADD     r2, r2, #16             ; step to next field
        ADRL    r0, dotstring
        B       listalltryfind

      [ International
06
        =       "Options:options:",0
08
        =       "Status:status:",0
      |
06
        =       "options:",0
08
        =       "status:",0
      ]
        ALIGN

listallservice
        Pull    "r3, r7"
        CMP     r3, #0
        MOVEQ   r1, #Service_UKConfig
        MOVNE   r1, #Service_UKStatus
        MOV     r0, #0                  ; indicate list wanted
        BL      Issue_Service
        CMP     r3, #0
      [ International
        BEQ     %FT20
        BL      GSWriteS_Translated
        =       "STail:|J|MUse *Configure to set the options.|J|M",0
        ALIGN
        B       %FT30
20
        BL      GSWriteS_Translated
        =       "CTail1:|J|MWhere:|J|MD is a decimal number, a hexadecimal number preceded by &,|J|M"
        =       "or the base followed by underscore, followed|J|M",0
        ALIGN
        BL      GSWriteS_Translated
        =       "CTail2:by digits in the given base.|J|MItems within [ ] are optional.|J|M"
        =       "Use *Status to display the current settings.|J|M",0
        ALIGN
30
      |
        ADRNE   r0, statuslastline
        ADREQ   r0, configlastline
        SWI     XOS_Write0
      ]
        Pull    "r1"
        Pull    "pc", VS                ; return error if set
        TST     r1, #5
        SWIEQ   XOS_WriteI+15  ; paged mode off
        Pull    "pc"

      [ :LNOT: International
statuslastline
        =       10,13, "Use *Configure to set the options.", 10,13,0
configlastline
        =       10,13, "Where:", 10,13
        =       "D is a decimal number, " ;, 10,13
        =       "a hexadecimal number preceded by &, ", 10,13
        =       "or the base followed by underscore, followed", 10,13
        =       "by digits in the given base.", 10,13
        =       "Items within [ ] are optional.", 10,13
        =       "Use *Status to display the current settings.", 10,13, 0
        ALIGN
      ]

FrigCapsList
        MOV     r3, #2
        BL      ListOneConfig
        Pull    "r1, pc", VS
        MOV     r3, #1
        ADRL    r2, EndListCapsFrig
        B       %BT02

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; routine to list one item :
; R3 = 0 means entered from configure
;    = 1   "     "      "   status
;    = 2   "     "      "   status <item>
; R2 points at the item, stepped to next on exit
; Preserves flags

ListOneConfig   ROUT
        EntryS
        LDRB    r4, [r2]
        CMP     r4, #ConType_Field
        CMPNE   r4, #ConType_Size
        CMPNE   r3, #0
        BNE     %FT20

        ADD     r0, r2, #1
        SWI     XOS_Write0
        BVS     ExitShow
        SUB     r1, r0, r2      ; get length
        ADD     r2, r0, #3      ; skip terminator
        BIC     r2, r2, #3      ; and align

        CMP     r4, #ConType_NoParm
        BEQ     %FT07
04
        SWI     XOS_WriteI+" "
        BVS     ExitShow
        ADD     r1, r1, #1
        CMP     r1, #12
        BLS     %BT04

        CMP     r3, #0
        BNE     %FT30

        CMP     r4, #ConType_Size
        ADREQ   r0, %FT42
        BEQ     %FT43

        CMP     r4, #ConType_Field
        ASSERT  ConType_Special > ConType_Field
        ADREQ   r0, %FT05
        LDRGT   r0, [r2]
        ADDGT   r0, r0, r2                      ; point at node
        ADDGT   r0, r0, #Config_Special_String  ; point at string
43
        SWI     XOS_Write0
07
        ADD     r2, r2, #4
ExitShow
        SWIVC   XOS_NewLine
11
        EXITV
05
        =       "<D>", 0
42
        =       "<D>[K]", 0

; status bits :

        ALIGN
20
        ADD     r0, r2, #1              ; got to do *status on a NoParm or Special
21
        LDRB    r1, [r0], #1
        CMP     r1, #0                  ; step past name
        BNE     %BT21
        ADD     r0, r0, #3
        BIC     r0, r0, #3              ; align
        LDR     r1, [r0]                ; get info word.
        CMP     r4, #ConType_Special
        ADDEQ   r1, r1, r0              ; point at node
        ADDEQ   pc, r1, #Config_Special_ShowCode

; if CRbytevalue = infowordvalue then print something

        MOV     r4, r0                  ; hang on to it
        MOV     r0, r1
        BL      GetValue
        MOV     r1, r1, LSR #24         ; value.
        CMP     r0, r1
        BNE     %FT10                   ; check for *Status <Item>

; first see if expansion needed

        ADRL    r0, ExpandTab
22
        LDR     r1, [r0], #8
        CMP     r1, #0
        BEQ     %FT23
        ADD     r1, r1, r0              ; get real address
        CMP     r1, r2
        BNE     %BT22
        LDR     r2, [r0, #-4]!
14
        ADD     r2, r2, r0              ; new string
23
        ADD     r2, r2, #1

; now write chars with space between lowercase then upper

        MOV     r1, #1                  ; indicate uppercase last
24
        LDRB    r0, [r2], #1
        CMP     r0, #0
        BEQ     %FT25
        CMP     r0, #"Z"                ; uppercase if LE
        CMPLE   r1, #0
        SWILE   XOS_WriteI+" "
        BVS     ExitShow
        CMP     r0, #"Z"
        MOVLE   r1, #1
        MOVGT   r1, #0
        SWI     XOS_WriteC
        BVC     %BT24

25
        ADDVC   r2, r4, #4
        B       ExitShow

30
        LDR     r0, [r2], #4            ; got to do *status for Field
        CMP     r4, #ConType_Size
        MOV     r4, r2
        BL      GetValue
        BEQ     %FT31
        BL      PrintR0
        B       ExitShow
31
        Push    "r8, r9"
        ADRL    r8, FontSizeFrig
        CMP     r4, r8
        LDRNE   r8, =ZeroPage
        LDRNE   r8, [r8, #Page_Size]
        MOVEQ   r8, #4*1024
        ADRL    r9, PageShifts-1
        LDRB    r9, [r9, r8, LSR #12]
        SUB     r9, r9, #10
        MOVS    r0, r0, LSL r9          ; size in K
        BNE     %FT35
        ADRL    r8, PrinterBufferFrig   ; if zero and PrinterBufferSize, then 1K
        TEQ     r8, r2
        MOVEQ   r0, #1
        BEQ     %FT35
        ADRL    r8, ScreenSizeFrig      ; if zero and it's ScreenSize, then call OS_ReadSysInfo to find appropriate amount
        TEQ     r8, r2
        BNE     %FT35
        SWI     XOS_ReadSysInfo         ; proper screen size (r0=0) on entry
        MOV     r0, r0, LSR #10
35
        Pull    "r8, r9"
        BL      PrintR0
        SWIVC   XOS_WriteI+"K"
        B       ExitShow

10
        CMP     r3, #2
        ADDNE   r2, r4, #4
        BNE     %BT11

; R0 is the value set : can corrupt R3 as this is the do-one entry

        MOV     r3, r0
        ADRL    r0, AlternateTab        ; look for option really set
12
        LDR     r1, [r0], #8            ; better find a match!
        ADD     r1, r1, r0              ; get real address
        CMP     r1, r2
        BNE     %BT12
        LDR     r2, [r0, #-4]!
        ADD     r2, r2, r0              ; translation table
        LDR     r0, [r2, r3, LSL #2]
        B       %BT14                   ; go print it

AlternateTab
        &       AlternateBoot - ExpandFrig-.
        &       %FT91 -.
        &       AlternateNoBoot - ExpandFrig-.
        &       %FT91 -.
        &       AlternateCaps - ExpandFrig-.
        &       %FT92 -.
        &       AlternateNoCaps - ExpandFrig-.
        &       %FT92 -.
        &       ExpandShCaps - ExpandFrig-.
        &       %FT92 -.
        &       AlternateNum - ExpandFrig-.
        &       %FT93 -.
        &       AlternateNoNum - ExpandFrig-.
        &       %FT93 -.
        &       AlternateLoud - ExpandFrig-.
        &       %FT95 -.
        &       AlternateQuiet - ExpandFrig-.
        &       %FT95 -.
        &       AlternateScroll - ExpandFrig-.
        &       %FT96 -.
        &       AlternateNoScroll - ExpandFrig-.
        &       %FT96 -.

91
        &       AlternateNoBoot -%BT91
        &       AlternateBoot   -%BT91
92
        &       ShCapsString    -%BT92-1
        &       ShCapsString    -%BT92-1
        &       AlternateNoCaps -%BT92
        &       AlternateNoCaps -%BT92
        &       AlternateCaps   -%BT92
        &       AlternateCaps   -%BT92
        &       AlternateCaps   -%BT92
        &       AlternateCaps   -%BT92
93
        &       AlternateNum   -%BT93
        &       AlternateNoNum -%BT93
95
        &       AlternateQuiet -%BT95
        &       AlternateLoud  -%BT95
96
        &       AlternateScroll   -%BT96
        &       AlternateNoScroll -%BT96

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; read byte from CMOS RAM : info word in R0, byte -> R1

ReadByte Entry  "r0, r2"
        MOV     r1, r0, LSR #16         ; get bytoff
        AND     r1, r1, #&FF
        MOV     r0, #ReadCMOS
        SWI     XOS_Byte
        MOV     r1, r2
        EXIT

; take infoword in R0, return value in R0

GetValue EntryS "r1"
        BL      ReadByte                ; now extract the value
        AND     r14, r0, #&FF           ; get bitoff
        MOV     r1, r1, LSR r14         ; throw away low bits
        MOV     r0, r0, LSR #8
        AND     r0, r0, #&FF            ; get fwidth
        RSB     r0, r0, #31             ; number of positions to shift up to remove unwanted bits
        MOV     r1, r1, LSL r0          ; shift up...
        MOV     r0, r1, LSR r0          ; ...then down again
        EXITS

PrintR0 Entry   "r1, r2"
        CMP     r0, #-1
        BNE     %FT10
        ADRL    r0, AutoString
        SWI     XOS_Write0
        EXIT
10
        SUB     sp, sp, #32
        MOV     r1, sp
        MOV     r2, #32
        SWI     XOS_ConvertInteger4
        SWIVC   XOS_Write0
        ADD     sp, sp, #32
        EXIT

NoString =      "No ", 0
        ALIGN

ConfigCheckEOL  ROUT
        LDRB    r3, [r0], #1
        CMP     r3, #" "
        BEQ     ConfigCheckEOL
        CMP     r3, #13
        CMPNE   r3, #10
        CMPNE   r3, #0
        MOVEQ   pc, lr
        ADR     R0, Config2manyparms
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      |
        SETV
      ]
        MOV     pc, lr

Config2manyparms
        &       ErrorNumber_Syntax
        =       "Config2manyparms:Too many parameters"

;*************************************************************************

IgnoreBitoff *  1

Config_TV_setcode ROUT
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     Config_TV_setcode
        SUB     r1, r0, #1
        MOV     r0, #10                 ; set base
        SWI     XOS_ReadUnsigned
        BVS     %FT01
        CMP     r2, #3
        SUBGT   r0, r2, #252
        CMPGT   r0, #3
        BHI     BadConOpt
        CMP     r2, #3
        ANDGT   r2, r2, #7              ; top bit set in field means 252-255
        Push    "r2"
        MOV     r0, #0
03
        LDRB    r2, [r1], #1
        CMP     r2, #" "
        BEQ     %BT03
        CMP     r2, #","
        CMPEQ   r0, #0
        MOVEQ   r0, #","
        BEQ     %BT03
        SUB     r1, r1, #1
        Push    "r0"
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        Pull    "r0"
        BVC     %FT04
        CMP     r0, #0
        Pull    "r0", NE
        BNE     BadConOpt
04
        CMP     r2, #1
        Pull    "r0"
        BHI     ConParmTooBig
        ORR     r2, r2, r0, LSL #1
01
        MOV     r0, r1
        LDR     r1, %FT02
        B       BaudEntry
02
        =       4, 3, MODETVCMOS, 0

Config_TV_showcode
        MOV     r4, r0
        SWI     XOS_WriteS
        =       "TV         ", 0
        ALIGN
        MOVVC   r0, #ReadCMOS
        MOVVC   r1, #MODETVCMOS
        SWIVC   XOS_Byte
        MOVVC   r2, r2, LSL #24
        MOVVC   r0, r2, ASR #29         ; get signed TV shift
        ANDVC   r0, r0, #&FF
        BLVC    PrintR0
        SWIVC   XOS_WriteI+","
        MOVVC   r0, r2, LSR #28
        ANDVC   r0, r0, #1              ; interlace bit
        BLVC    PrintR0
        ADD     r2, r4, #4
        B       ExitShow

Config_Ignore_setcode ROUT
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     Config_Ignore_setcode
        SUB     r1, r0, #1
        MOV     r0, #10                 ; set base
        SWI     XOS_ReadUnsigned
        MOV     r0, r1
        Push    "r2"
        ADR     lr, %FT03
        Push    lr                      ; return reg for BaudEntry
        MOVVS   r2, #1
        MOVVC   r2, #0                  ; if number had clear noignore
        LDR     r1, %FT01
        B       BaudEntry               ; pseudo-BL
03
        Pull    "r2"                    ; set to 0 if noignore, but we don't care!
        LDR     r1, %FT02
        B       IgnoreEntry
01
        =       IgnoreBitoff, 0, PSITCMOS, 0
02
        =       0, 7, PigCMOS, 0

Config_Ignore_showcode
        MOV     r4, r0
        MOV     r0, #ReadCMOS
        MOV     r1, #PSITCMOS
        SWI     XOS_Byte
        TST     r2, # 1 :SHL: IgnoreBitoff
        ADRNE   r0, NoString
        SWINE   XOS_Write0
        BVS     ExitShow
        SWI     XOS_WriteS
        =       "Ignore", 0
        ALIGN
        BVS     ExitShow
        ADDNE   r2, r4, #4
        BNE     ExitShow
        MOV     r1, #PigCMOS
        SWI     XOS_Byte
        SWI     XOS_WriteS
        =       "     ", 0
        ALIGN
        MOV     r1, #PigCMOS
        SWIVC   XOS_Byte
        MOVVC   r0, r2
        BLVC    PrintR0
        ADD     r2, r4, #4
        B       ExitShow

Config_Mode_setcode  ROUT
Config_WimpMode_setcode ROUT
        ADR     r1, ModeCMOSTable
ConfigMultiField ROUT
        BL      ReadNumAuto
        BVS     BadConParm
        CMP     r2, #-1
        LDR     r14, [r1], #4                   ; get auto number
        MOVEQ   r2, r14                         ; if auto number then replace by auto value
        LDR     r14, [r1], #4                   ; get maximum value
        CMPNE   r2, r14                         ; if not auto then check maximum value
        BHI     ConParmTooBig
        BL      ConfigCheckEOL
        BVS     ExitConfig
        MOV     r0, r1
        BL      WriteMultiField
        Pull    "pc"                            ; was already stacked by *Configure

ModeCMOSTable
        &       256                             ; Auto value
        &       255                             ; maximum valid number
;               address, mask from bit 0, shift to 1st bit in value, shift to 1st bit in CMOS
 [ {TRUE} ; mode = wimpmode
        =       WimpModeCMOS,   &FF, 0, 0       ; normal bits here
        =       Mode2CMOS,      &01, 8, 4       ; mode auto bit
        ASSERT  WimpModeAutoBit = 16
 |
        =       MODETVCMOS,     &0F, 0, 0       ; bits 0 to 3 here
        =       VduCMOS,        &01, 4, 1       ; bit 4 here
        =       Mode2CMOS,      &0F, 5, 0       ; bits 5 to 7, and auto bit here
 ]
        =       0
        ALIGN

; Write a number of CMOS RAM bit fields from a value

; in:   r0 -> table
;       r2 -> value to split
;
; out:  -

WriteMultiField Entry "r0-r5"
        MOV     r3, r0                  ; pointer to where we're at in table
        MOV     r4, r2                  ; value
10
        LDRB    r1, [r3], #1
        TEQ     r1, #0
        EXIT    EQ
        MOV     r0, #ReadCMOS
        SWI     XOS_Byte
        LDRB    r0, [r3], #1            ; r0 = mask
        LDRB    r5, [r3], #1            ; r5 = shift to 1st bit in value
        LDRB    r14, [r3], #1           ; r14 = shift to 1st bit in CMOS
        BIC     r2, r2, r0, LSL r14     ; knock out previous bits
        AND     r5, r0, r4, LSR r5      ; get new bits, at bottom of byte
        ORR     r2, r2, r5, LSL r14     ; form new CMOS value
        MOV     r0, #WriteCMOS
        SWI     XOS_Byte
        B       %BT10

; Read a value formed by merging a number of CMOS RAM bit fields

; in:   r0 -> table
; out:  r0 = value

ReadMultiField Entry "r1-r6"
        LDR     r6, [r0, #4]            ; get maximum value allowed
        ADD     r3, r0, #2*4            ; pointer to where we're at in table (skip auto, max)
        MOV     r4, #0                  ; cumulative value
10
        LDRB    r1, [r3], #1
        TEQ     r1, #0
        BEQ     %FT20
        MOV     r0, #ReadCMOS
        SWI     XOS_Byte
        LDRB    r0, [r3], #1            ; r0 = mask
        LDRB    r5, [r3], #1            ; r5 = shift to 1st bit in value
        LDRB    r14, [r3], #1           ; r14 = shift to 1st bit in CMOS
        AND     r2, r0, r2, LSR r14     ; get relevant bits in bottom of byte
        ORR     r4, r4, r2, LSL r5      ; merge new bits with value
        B       %BT10
20
        CMP     r4, r6                  ; if within range
        MOVLS   r0, r4                  ; then return that value
        MOVHI   r0, #-1                 ; else return -1 indicating Auto
        EXIT

Config_Mode_showcode ROUT
        MOV     r4, r0
        ADR     r0, ModeSpacedString
ModeWimpModeShowCode
        SWI     XOS_Write0
        BVS     %FT10
        BL      Read_Configd_Mode
        BL      PrintR0
10
        ADD     r2, r4, #4
        B       ExitShow

ModeSpacedString
        =       "Mode       ", 0
WimpModeSpacedString
        =       "WimpMode   ", 0
        ALIGN

Config_WimpMode_showcode ROUT
        MOV     r4, r0
        ADR     r0, WimpModeSpacedString
        B       ModeWimpModeShowCode

Read_Configd_Mode Entry
        ADR     r0, ModeCMOSTable
        BL      ReadMultiField
        EXIT

Config_Baud_setcode  ROUT
        BL      ReadNumParm
        BVS     BadConParm
        CMP     r2, #8
        BGT     ConParmTooBig
        SUBS    r2, r2, #1
        MOVMI   r2, #6
        LDR     r1, %FT01               ; set up info word
        B       BaudEntry
01
        =       2, 2, PSITCMOS, 0

Config_Baud_showcode
        MOV     r4, r0
        SWI     XOS_WriteS
        =       "Baud       ", 0
        ALIGN
        LDRVC   r0, %BT01               ; get infoword
        BLVC    GetValue
        ADDVC   r0, r0, #1
        BLVC    PrintR0
        ADD     r2, r4, #4
        B       ExitShow

Config_Cache_setcode ROUT
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     Config_Cache_setcode
        SUB     r0, r0, #1
        BL      Cache_Opt_Parse
        MOVS    r1, r1
        BMI     BadConOpt
        MOVNE   r4, #&20                ; CMOS flag for 'Off'
        MOVEQ   r4, #0                  ; CMOS flag for 'On'
        MOVVC   r0, #ReadCMOS
        MOVVC   r1, #SystemSpeedCMOS
        SWIVC   XOS_Byte
        BICVC   r2, r2, #&20
        ORRVC   r2, r2, r4
        MOVVC   r0, #WriteCMOS
        SWIVC   XOS_Byte
        Pull    "pc"
        
Config_Cache_showcode
        MOV     r4, r0
        SWI     XOS_WriteS
        =       "Cache      ", 0
        ALIGN
        MOVVC   r0, #ReadCMOS
        MOVVC   r1, #SystemSpeedCMOS
        SWIVC   XOS_Byte
        BVS     %FT11
        TST     r2, #&20                ; clear = enable
        ADREQ   r0, %FT12
        ADRNE   r0, %FT13
        SWI     XOS_Write0
11      ADD     r2, r4, #4
        B       ExitShow
12
        =       "On", 0
13
        =       "Off", 0
        ALIGN        

Config_MouseStep_setcode ROUT
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     Config_MouseStep_setcode
        CMP     r2, #"-"
        Push    "r2"
        SUBNE   r1, r0, #1
        MOV     r0, #10                 ; set base
        SWI     XOS_ReadUnsigned
        Pull    "r0"
        BVS     BadConParm
        CMP     r0, #"-"
        RSBEQ   r2, r2, #0
        CMP     r2, #0
        BEQ     BadConOpt
        CMP     r2, #-128
        BLT     BadConOpt
        CMP     r2, #127
        BGT     ConParmTooBig
        MOV     r0, r1
        LDR     r1, %FT02
        B       BaudEntry
02
        =       0, 7, MouseStepCMOS, 0

Config_MouseStep_showcode ROUT
        MOV     r4, r0
        SWI     XOS_WriteS
        =       "MouseStep  ", 0
        ALIGN
        MOVVC   r0, #ReadCMOS
        MOVVC   r1, #MouseStepCMOS
        SWIVC   XOS_Byte
        BVS     %FT01
        MOVS    r2, r2, LSL #24
        MOVNE   r0, r2, ASR #24  ; get sign extended byte
        MOVEQ   r0, #1
        BL      PrintR0
01      ADD     r2, r4, #4
        B       ExitShow

Config_MouseType_setcode ROUT
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     Config_MouseType_setcode
        SUB     r1, r0, #1
        MOV     r0, #10          ; set base
        SWI     XOS_ReadUnsigned
        BVS     BadConParm
        CMP     r2, #&100
        BCS     ConParmTooBig
        MOV     r4, r1
        MOV     r0, #1
        MOV     r1, r2
        SWI     XOS_Pointer
        MOV     r0, r4
        LDR     r1, %FT01
        B       BaudEntry
01
        =       0, 7, MouseCMOS, 0

Config_MouseType_showcode
        MOV     r4, r0
        SWI     XOS_WriteS
        =       "MouseType  ", 0
        ALIGN
        LDRVC   r0, %BT01
        BLVC    GetValue
        BLVC    PrintR0
        ADD     r2, r4, #4
        B       ExitShow

Config_MonitorType_setcode
10
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     %BT10
        SUB     r1, r0, #1
        ADR     r3, MonitorTypeNameEDID ; string to match against
        MOV     r4, #0                  ; no other terminators for $R1
        BL      Module_StrCmp           ; out: EQ => match, r1 -> terminator
                                        ;      NE => no match, r1 preserved
                                        ;      r3 corrupted in both cases
        LDREQB  r3, [r1]
        MOVNE   r0, r1
        ADR     r1, MonitorTypeCMOSTable
        BNE     %FT20
        CMP     r3, #" "
        BGT     BadConParm
        MOV     r2, #MonitorTypeEDID :SHR: MonitorTypeShift
        MOV     r4, r2
        B       %FT30
20
        BL      ReadNumAuto
        BVS     BadConParm
        MOV     r4, r2                          ; save value to store in current monitortype
        CMP     r2, #-1
        LDR     r14, [r1], #4                   ; get auto number
        MOVEQ   r2, r14                         ; if auto number then replace by auto value
        LDR     r14, [r1], #4                   ; get maximum value
        CMPNE   r2, r14                         ; if not auto then check maximum value
        BHI     ConParmTooBig
        BL      ConfigCheckEOL
        BVS     ExitConfig
30
        LDR     r0, =ZeroPage+VduDriverWorkSpace+CurrentMonitorType
        STR     r4, [r0]                        ; update current value

        MOV     r0, r1
        BL      WriteMultiField
        ; Let the display manager know that the available modes have changed
        MOV     r1, #Service_ModeFileChanged
        BL      Issue_Service
        Pull    "pc"                            ; was already stacked by *Configure

        LTORG

MonitorTypeCMOSTable
        DCD     MonitorTypeAuto :SHR: MonitorTypeShift          ; value for Auto
        DCD     MonitorTypeEDID :SHR: MonitorTypeShift          ; maximum valid number
;               address, mask from bit 0, shift to 1st bit in value, shift to 1st bit in CMOS
        =       VduCMOS,        MonitorTypeBits :SHR: MonitorTypeShift, 0, MonitorTypeShift
        =       0

MonitorTypeNameEDID
        DCB     "EDID", 0
        ALIGN

Config_MonitorType_showcode ROUT
        MOV     r4, r0
        SWI     XOS_WriteS
        =       "MonitorType ", 0
        ALIGN
        BVS     %FT20
        BL      Read_Configd_MonitorType
        TEQ     r0, #MonitorTypeEDID :SHR: MonitorTypeShift
        BNE     %FT10
        ADR     r0, MonitorTypeNameEDID
        SWI     XOS_Write0
        B       %FT20
10
        BL      PrintR0
20
        ADD     r2, r4, #4
        B       ExitShow

Read_Configd_MonitorType Entry
        ADR     r0, MonitorTypeCMOSTable
        BL      ReadMultiField
        EXIT

Config_Sync_setcode
        ADR     r1, SyncCMOSTable
        B       ConfigMultiField

SyncCMOSTable
        &       3       ; Auto value
        &       1       ; maximum valid number
;               address, mask from bit 0, shift to 1st bit in value, shift to 1st bit in CMOS
        =       VduCMOS, 1, 0, 0
        =       VduCMOS, 1, 1, 7
        =       0
        ALIGN

Config_Sync_showcode ROUT
        MOV     r4, r0
        SWI     XOS_WriteS
        =       "Sync       ", 0
        ALIGN
        BVS     %FT10
        BL      Read_Configd_Sync
        BL      PrintR0
10
        ADD     r2, r4, #4
        B       ExitShow

Read_Configd_Sync Entry
        ADR     r0, SyncCMOSTable
        BL      ReadMultiField
        EXIT

        END
@


4.7
log
@Recover gracefully from a completely blank set of CMOS
Newly born boards have all 0xFF's in their CMOS (EEPROM), but the new order of keyboard scan did
  Init -> Scan keyboard -> Check (or wipe) CMOS
and would therefore leave 0xFF's in a select few kernel workspace areas and OS_Byte values.
Defer the init which reads CMOS until after the check/wipe step. Only the screen area size is now done early, but MassageScreenSize clamps that properly anyway.

Arthur3.s: Relocate stranded function SetupPrinterBuffer to osinit.
PMF/key.s: Drop support for SoftReset.
PMF/osinit.s: Stuff in hardcoded defaults at early init. Retrieve the proper ones later. Take ownership of SystemSprite/RamFS/Font Manager dynamic areas (deferrable).
vdudriver.s: Use symbolic name.
NewReset.s: Defer SystemSprite/RamFS/Font Manager area creation, MouseInit, Read(Hard)CMOSDefaults until later.
hdr/Options: Delete unused IgnoreVRAM. Remove MaxRAMFS_Size now PMPs make it not useful. Shuffle ARM6Support/XScaleMiniCache/XScaleJTAGDebug to be adjacent to their definitions.

Tested by filling first 256 bytes with 0xFF and powering up. Reset now completes, OS_Byte variables look sensible.

Version 5.95. Tagged as 'Kernel-5_95'
@
text
@d2463 3
@


4.6
log
@Extend MonitorType configure keyword
Detail:
  Accept a monitortype of 'EDID' (as distinct from 'Auto', which uses the ID pins) to force the kernel, via ScrModes, to use the native screen mode prior to executing the boot sequence.
  Required for discless boot, this also helps if the boot sequence fails, the desktop will be entered in the monitor's native resolution, or a fallback if GraphicsV rejects that.
  The allocation of the EDID monitor type has been carefully selected to degrade to 'Auto' when used with an older OS. That way the configuration in CMOS is safe to use with softloads on top of older physical ROMs.
  When OS_ScreenMode is queried return the 'Auto' type, ie. at an API level there's no distinction.
Admin:
  Requires HdrSrc-2_67.
  Submission for the EDID bounty.

Version 5.80. Tagged as 'Kernel-5_80'
@
text
@a2530 19
SetUpPrinterBuffer Entry "r1-r3"
        MOV     r0, #PrinterBufferCMOS
        BL      Read
        LDR     r2, =ZeroPage
        LDR     r2, [r2, #Page_Size]
        MULS    r3, r2, r0
        BEQ     %FT10                           ; if zero, then use default area & size

        BL      ClaimSysHeapNode                ; else claim space from system heap
        BVC     %FT20                           ; if no error then OK, else use default
10
        LDR     r2, =PrintBuff                  ; use default buffer
        MOV     r3, #PrintBuffSize
20
        LDR     r0, =ZeroPage
        STR     r2, [r0, #PrinterBufferAddr]
        STR     r3, [r0, #PrinterBufferSize]
        EXIT

@


4.6.2.1
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d2531 19
@


4.5
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d1288 1
a1288 1
        Config_Special_Table MonitorType, "<D> | Auto"
d2426 12
d2439 7
d2457 1
a2457 1

d2468 2
a2469 2
        &       MonitorTypeAuto :SHR: MonitorTypeShift          ; Auto value
        &       MonitorTypeF :SHR: MonitorTypeShift             ; maximum valid number
d2473 3
d2483 1
a2483 1
        BVS     %FT10
d2485 6
d2492 1
a2492 1
10
@


4.4
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a274 1
  [ LongCommandLines
a276 4
  |
        ADR     R1, ExprBuff
        MOV     R2, #256
  ]
a554 1
  [ LongCommandLines
a556 4
  |
        CMP     R0, #255
        BGT     StrOFloErr
  ]
a861 1
  [ LongCommandLines
a863 3
  |
        MOV     R2, #255
  ]
a982 1
  [ LongCommandLines
a984 3
  |
        MOV     R2, #255
  ]
a1236 1
 [ AssemblePointerV
a1237 1
 ]
a1286 1
 [ AssemblePointerV
a1287 1
 ]
a2425 1
 [ ModeSelectors
a2444 4
 |
        ADR     r1, MonitorTypeCMOSTable
        B       ConfigMultiField
 ]
@


4.3
log
@  Improved the error cacheing.
  Removed DriversInKernel conditional.
Detail:
  If the territory changes or the resource file changes, the kernel
    will now decache all the cached error blocks so that next time
    they are required, they will be looked up again.
  The error cacheing is now a kernel build option and is always set
    to on.
  Removed one of the 5 error messages to be cached - it never seems
    to happen.  The remaining 4 are more frequent.
Admin:
  Tested in Ursula build.
  Cannot be used with HdrSrc 0.94.  HdrSrc 0.95 and later is required
    (or HdrSrc 0.93 and earlier subject to other kernel requirements)
  Requires MessageTrans 0.42 or later for correct operation when a
    replacement messages file is loaded.

Version 5.32. Tagged as 'Kernel-5_32'
@
text
@d203 18
a220 4
$label  ePush  $reglist
$label  STMFD  R11!, {$reglist}
        CMP    R11, R10
        BLE    StackOFloErr
d224 18
a241 1
$label  ePull  $reglist, $writeback, $cc
d247 1
d275 4
d281 1
d560 4
d566 1
d872 4
d877 1
d997 4
d1002 1
d1231 1
d1239 4
d1245 1
a1245 5
ExpandDir
        Config_NoParm   Dir,            6, 0, StartCMOS, 0
ExpandNoDir
        Config_NoParm   NoDir,          6, 0, StartCMOS, 1
        Config_Field    DumpFormat,     0, 4, TutuCMOS
d1263 1
a1263 1
        Config_Size     RamFsSize,      0, 6, RAMDiscCMOS
a1278 2
NoDirString =  "No"
DirString   =  "Directory", 0
a1284 4
        &       ExpandDir       - ExpandFrig-.
        &       DirString       - .-1           ; another printing fudge!
        &       ExpandNoDir     - ExpandFrig-.
        &       NoDirString     - .-1
d1302 1
d1319 1
a1319 1
FindOption ENTRY "r1, r3-r5"
d1422 1
a1422 1
        Pull    "pc"
d1440 1
a1440 1
        MOV     r12, #Module_List
d1497 1
a1497 1
        =       "BadConOpt:Bad configure option", 0
d1500 1
a1500 1
ReadNumParm ENTRY "r1"
d1506 1
d1519 1
a1519 1
ReadNumAuto ENTRY "r1,r3,r4"
d1532 1
d1544 2
d1556 1
d1566 1
a1566 1
        Pull   "r1, r8", NE
d1575 1
a1575 1
        MOVNE   r8, #0                  ; else use pagesize units
d1609 1
a1609 1
        MOV     r6, #Module_List
d1638 2
a1640 1
        SETV
d1697 1
a1697 1
        MOV     r7, #Module_List
d1852 1
d1924 1
a1924 1
        MOVNE   r8, #0
d1964 1
a1964 1
        B       %BT14                   ; go printit
d1977 1
a1977 1
        &       ExpandDir - ExpandFrig-.
d1979 1
a1979 1
        &       ExpandNoDir - ExpandFrig-.
d2003 2
a2004 2
        &       DirString   -%BT93-1
        &       NoDirString -%BT93-1
d2016 1
a2016 1
ReadByte ENTRY  "r0, r2"
d2037 1
a2037 1
PrintR0 ENTRY   "r1, r2"
d2075 1
a2075 1
        =      "Config2manyparms:Too many parameters"
d2086 1
d2150 1
d2237 1
a2237 1
WriteMultiField ENTRY "r0-r5"
d2261 1
a2261 1
ReadMultiField ENTRY "r1-r6"
d2306 1
a2306 1
Read_Configd_Mode ENTRY
d2335 40
d2382 1
d2421 1
d2462 1
a2462 1
        LDR     r0, =VduDriverWorkSpace+CurrentMonitorType
d2473 2
d2495 1
a2495 1
Read_Configd_MonitorType ENTRY
d2525 1
a2525 1
Read_Configd_Sync ENTRY
d2530 1
a2530 1
SetUpPrinterBuffer ENTRY "r1-r3"
d2533 1
a2533 1
        MOV     r2, #0
d2544 1
a2544 1
        MOV     r0, #0
@


4.3.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d1271 1
a1271 1
FindOption Entry "r1, r3-r5"
d1452 1
a1452 1
ReadNumParm Entry "r1"
d1470 1
a1470 1
ReadNumAuto Entry "r1,r3,r4"
a1797 1
        ALIGN
d1961 1
a1961 1
ReadByte Entry  "r0, r2"
d1982 1
a1982 1
PrintR0 Entry   "r1, r2"
d2180 1
a2180 1
WriteMultiField Entry "r0-r5"
d2204 1
a2204 1
ReadMultiField Entry "r1-r6"
d2249 1
a2249 1
Read_Configd_Mode Entry
d2394 1
a2394 1
Read_Configd_MonitorType Entry
d2424 1
a2424 1
Read_Configd_Sync Entry
d2429 1
a2429 1
SetUpPrinterBuffer Entry "r1-r3"
@


4.3.2.2
log
@First attempt at ARM9 support, and general clean-up of old ARM-specific
code, now using vectored ARMops.
Not tested.

Version 5.35, 4.79.2.14. Tagged as 'Kernel-5_35-4_79_2_14'
@
text
@a2374 2
        LTORG

@


4.3.2.3
log
@Merge in long command line support from Ursula kernel.
Look for LongCommandLine flag, command line size currently
set at 1k.
For HAL/32bit builds, the kernel buffer space is at high
(top bit set) address, which may break some code using signed
comparisons. So *beware* that there may be some latent
bugs in old kernel code using these buffers, not yet found.
One such bug, in s.Arthur2 found and fixed.
Tested moderately on ARM9 desktop build.
Lovely to reimplement things I did two and half years ago.

Version 5.35, 4.79.2.37. Tagged as 'Kernel-5_35-4_79_2_37'
@
text
@a242 4
  [ LongCommandLines
        LDR     R1, =ExprBuff
        MOV     R2, #LongCLISize
  |
a244 1
  ]
a522 4
  [ LongCommandLines
        CMP     R0, #LongCLISize
        BGE     StrOFloErr
  |
a524 1
  ]
a829 4
  [ LongCommandLines
        MOV     R2, #LongCLISize
        SUB     R2, R2, #1
  |
a830 1
  ]
a949 4
  [ LongCommandLines
        MOV     R2, #LongCLISize
        SUB     R2, R2, #1
  |
a950 1
  ]
@


4.3.2.4
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d1230 1
a1230 1
        Config_Size     RamFSSize,      0, 6, RAMDiscCMOS
@


4.3.2.5
log
@Support for keys held down in the HAL at power on.
*Configure ANYTHINGsize was broken due to not setting R0 to ReadUnsigned
IIC ack message uninternationalised
OS_Memory was saying we only had 4M of RAM
VDU4 scrolling when output was switched to sprite was causing corruption
on use of CTRL-J and CTRL-K
Default SystemSize CMOS set to 32k

Version 5.35, 4.79.2.55. Tagged as 'Kernel-5_35-4_79_2_55'
@
text
@a1477 1
        MOV     r0, #10                 ; set base
a1502 1
        MOV     r0, #10                 ; set base
a1523 1
        MOV     r0, #10                 ; set base
a2051 1
        MOV     r0, #10                 ; set base
a2114 1
        MOV     r0, #10                 ; set base
a2305 1
        MOV     r0, #10                 ; set base
a2343 1
        MOV     r0, #10          ; set base
@


4.3.2.6
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@a203 13
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   {TRUE}
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
      [ onereg
$label  STR    $reglist, [R11, #-4]!
      |
a204 1
      ]
a210 17
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   {TRUE}
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
    [ onereg
      [ "$writeback" = ""
        LDR$cc     $reglist, [R11], #4
      |
        LDR$cc     $reglist, [R11]
      ]
    |
a215 1
    ]
d1412 1
a1412 1
        LDR     r12, =ZeroPage+Module_List
d1545 1
a1545 1
        LDRNE   r8, =ZeroPage           ; else use pagesize units
d1579 1
a1579 1
        LDR     r6, =ZeroPage+Module_List
d1666 1
a1666 1
        LDR     r7, =ZeroPage+Module_List
d1893 1
a1893 1
        LDRNE   r8, =ZeroPage
d2391 1
a2391 1
        LDR     r0, =ZeroPage+VduDriverWorkSpace+CurrentMonitorType
d2462 1
a2462 1
        LDR     r2, =ZeroPage
d2473 1
a2473 1
        LDR     r0, =ZeroPage
@


4.3.2.7
log
@Improve heap manager. Add heap testbed. Add dummy implementation of some OS_ScreenMode reason codes.
Detail:
  s/HeapMan, hdr/KernelWS - Heap manager improvements:
    - Errors generated by interrupted heap operations that are forced to complete by a OS_Heap call from the background are now cached in kernel workspace until the foreground task is resumed. This prevents them from being potentially overwritten by MessageTrans running out of background error buffers.
    - Added new OS_Heap reason code, #7 - Get area aligned. This allows areas of memory to be allocated at specific (power-of-2) alignments, and optionally without crossing a given (power-of-2) boundary. Alignment & boundary calculations are performed using logical addresses.
    - Removed the limitation that all free and allocated blocks must be a multiple of 8 bytes in length. This change was required in order to allow OS_Heap 7 to function correctly. Now the only requirements are that blocks must be multiples of 4 bytes in length, at 4 byte alignment, with a minimum length of 8 bytes. 4 extra padding bytes may still be added to the end of allocations in order to avoid creating 4-byte free blocks.
  s/HeapMan, TestSrc/HeapTest/Makefile, TestSrc/HeapTest/c/testbed, TestSrc/HeapTest/s/asm - Added heap testbed program. Can either use the OS_Heap SWI or directly include a copy of the Kernel's heap manager sources.
  s/vdudecl, s/vduswis - Added dummy implementations of OS_ScreenMode 4, 5 and 6. This prevents the Wimp generating lots of "Unknown OS_ScreenMode reason code" errors when redrawing the screen.
  s/Arthur3, s/Oscli - Moved dotstring closer to where it's used to avoid "ADRL out of range" errors in Tungsten build
Admin:
  Tested in OMAP3 ROM & Tungsten ROM softload.
  Heap testbed successfully performed over 400 million heap ops, so there shouldn't be any serious bugs in the new code (touch wood)


Version 5.35, 4.79.2.128. Tagged as 'Kernel-5_35-4_79_2_128'
@
text
@a1547 2
dotstring
        =       ".", 0
@


4.3.2.8
log
@  Retired *Configure options, and a new header export
Detail:
  * As noted in recent commits to ADFS, the *Configure options Dir and NoDir
    haven't done anything since RISC OS 2, so ADFS has stopped reading the
    CMOS bit. Unusually, these options are implemented by the kernel, so this
    is the accompanying change to remove the *Configure options. This frees
    up a bit of CMOS for future re-use.
  * Now exports a C version of Hdr:ModHand.
Admin:
  Builds OK, but not tested in a ROM build yet (should be fairly safe though)

Version 5.35, 4.79.2.143. Tagged as 'Kernel-5_35-4_79_2_143'
@
text
@d1240 4
a1243 4
;ExpandDir
;        Config_NoParm   Dir,            6, 0, StartCMOS, 0
;ExpandNoDir
;        Config_NoParm   NoDir,          6, 0, StartCMOS, 1
d1278 2
a1279 2
;NoDirString =  "No"
;DirString   =  "Directory", 0
d1286 4
a1289 4
;        &       ExpandDir       - ExpandFrig-.
;        &       DirString       - .-1           ; another printing fudge!
;        &       ExpandNoDir     - ExpandFrig-.
;        &       NoDirString     - .-1
d1980 4
a1983 4
;        &       ExpandDir - ExpandFrig-.
;        &       %FT93 -.
;        &       ExpandNoDir - ExpandFrig-.
;        &       %FT93 -.
d2005 3
a2007 3
;93
;        &       DirString   -%BT93-1
;        &       NoDirString -%BT93-1
@


4.3.2.8.2.1
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d203 6
a208 6
$label  ePush   $reglist
        LCLS    temps
        LCLL    onereg
temps   SETS    "$reglist"
onereg  SETL    {TRUE}
        WHILE   onereg :LAND: :LEN: temps > 0
d210 1
a210 1
onereg  SETL    {FALSE}
d212 1
a212 1
temps   SETS    temps :RIGHT: (:LEN: temps - 1)
d215 1
a215 1
$label  STR     $reglist, [R11, #-4]!
d217 1
a217 1
$label  STMFD   R11!, {$reglist}
d219 2
a220 2
        CMP     R11, R10
        BLE     StackOFloErr
d224 6
a229 6
$label  ePull   $reglist, $writeback, $cc
        LCLS    temps
        LCLL    onereg
temps   SETS    "$reglist"
onereg  SETL    {TRUE}
        WHILE   onereg :LAND: :LEN: temps > 0
d231 1
a231 1
onereg  SETL    {FALSE}
d233 1
a233 1
temps   SETS    temps :RIGHT: (:LEN: temps - 1)
a1230 1
        Config_Special  Cache
d1240 5
a1244 1
        Config_Field    DumpFormat,     0, 4, PrintSoundCMOS
d1278 2
d1286 4
a1306 1
        Config_Special_Table Cache, "On|Off"
d1426 1
a1426 1
        Pull    "pc" 
d1501 1
a1501 1
        =       "BadConOpt:Configure option not recognised", 0
d1570 1
a1570 1
        Pull    "r1, r8", NE
d1980 4
d2005 3
d2078 1
a2078 1
        =       "Config2manyparms:Too many parameters"
a2337 40
Config_Cache_setcode ROUT
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     Config_Cache_setcode
        SUB     r0, r0, #1
        BL      Cache_Opt_Parse
        MOVS    r1, r1
        BMI     BadConOpt
        MOVNE   r4, #&20                ; CMOS flag for 'Off'
        MOVEQ   r4, #0                  ; CMOS flag for 'On'
        MOVVC   r0, #ReadCMOS
        MOVVC   r1, #SystemSpeedCMOS
        SWIVC   XOS_Byte
        BICVC   r2, r2, #&20
        ORRVC   r2, r2, r4
        MOVVC   r0, #WriteCMOS
        SWIVC   XOS_Byte
        Pull    "pc"
        
Config_Cache_showcode
        MOV     r4, r0
        SWI     XOS_WriteS
        =       "Cache      ", 0
        ALIGN
        MOVVC   r0, #ReadCMOS
        MOVVC   r1, #SystemSpeedCMOS
        SWIVC   XOS_Byte
        BVS     %FT11
        TST     r2, #&20                ; clear = enable
        ADREQ   r0, %FT12
        ADRNE   r0, %FT13
        SWI     XOS_Write0
11      ADD     r2, r4, #4
        B       ExitShow
12
        =       "On", 0
13
        =       "Off", 0
        ALIGN        

@


4.3.2.9
log
@Adoption of *CONFIGURE/STATUS CACHE commands
The kernel already looks after all other aspects of the ARM CPU, so can look after the cache control command too.
 HelpStrs.s:New tokens for help and syntax
 CmdHelp.s:UK help and syntax
 Arthur3.s:Tables updates for *CONFIGURE/STATUS, lined some stuff up, default error text sync'd with Hdr:NewErrors
 MoreComms.s:Parsing and doing of *CACHE
 Utility.s:Hashing table updated for *CACHE
Other minor changes
 hdr/Options:Bring 'MosVer' into the private header
 hdr/RISCOS:aasm aliases for SP removed, MainVars and MosVer made private, added definition of the start of application space
 HeapMan.s:Use of GRAB changed to Pull
 Offset of TutuCMOS changed for more informative PrintSoundCMOS
 PMF/osbyte.s:Use OsBytes header file in place of MainVars

Version 5.35, 4.79.2.151. Tagged as 'Kernel-5_35-4_79_2_151'
@
text
@d203 6
a208 6
$label  ePush   $reglist
        LCLS    temps
        LCLL    onereg
temps   SETS    "$reglist"
onereg  SETL    {TRUE}
        WHILE   onereg :LAND: :LEN: temps > 0
d210 1
a210 1
onereg  SETL    {FALSE}
d212 1
a212 1
temps   SETS    temps :RIGHT: (:LEN: temps - 1)
d215 1
a215 1
$label  STR     $reglist, [R11, #-4]!
d217 1
a217 1
$label  STMFD   R11!, {$reglist}
d219 2
a220 2
        CMP     R11, R10
        BLE     StackOFloErr
d224 6
a229 6
$label  ePull   $reglist, $writeback, $cc
        LCLS    temps
        LCLL    onereg
temps   SETS    "$reglist"
onereg  SETL    {TRUE}
        WHILE   onereg :LAND: :LEN: temps > 0
d231 1
a231 1
onereg  SETL    {FALSE}
d233 1
a233 1
temps   SETS    temps :RIGHT: (:LEN: temps - 1)
a1230 1
        Config_Special  Cache
d1240 5
a1244 1
        Config_Field    DumpFormat,     0, 4, PrintSoundCMOS
d1278 2
d1286 4
a1306 1
        Config_Special_Table Cache, "On|Off"
d1426 1
a1426 1
        Pull    "pc" 
d1501 1
a1501 1
        =       "BadConOpt:Configure option not recognised", 0
d1570 1
a1570 1
        Pull    "r1, r8", NE
d1980 4
d2005 3
d2078 1
a2078 1
        =       "Config2manyparms:Too many parameters"
a2337 40
Config_Cache_setcode ROUT
        LDRB    r2, [r0], #1
        CMP     r2, #" "
        BEQ     Config_Cache_setcode
        SUB     r0, r0, #1
        BL      Cache_Opt_Parse
        MOVS    r1, r1
        BMI     BadConOpt
        MOVNE   r4, #&20                ; CMOS flag for 'Off'
        MOVEQ   r4, #0                  ; CMOS flag for 'On'
        MOVVC   r0, #ReadCMOS
        MOVVC   r1, #SystemSpeedCMOS
        SWIVC   XOS_Byte
        BICVC   r2, r2, #&20
        ORRVC   r2, r2, r4
        MOVVC   r0, #WriteCMOS
        SWIVC   XOS_Byte
        Pull    "pc"
        
Config_Cache_showcode
        MOV     r4, r0
        SWI     XOS_WriteS
        =       "Cache      ", 0
        ALIGN
        MOVVC   r0, #ReadCMOS
        MOVVC   r1, #SystemSpeedCMOS
        SWIVC   XOS_Byte
        BVS     %FT11
        TST     r2, #&20                ; clear = enable
        ADREQ   r0, %FT12
        ADRNE   r0, %FT13
        SWI     XOS_Write0
11      ADD     r2, r4, #4
        B       ExitShow
12
        =       "On", 0
13
        =       "Off", 0
        ALIGN        

@


4.3.2.10
log
@Add *CONFIGURE [No]Num for control over the num lock state
STB default = off, desktop default = on.
Collapsed single use of 'ErrorsInR0' switch.

Version 5.35, 4.79.2.167. Tagged as 'Kernel-5_35-4_79_2_167'
@
text
@a1238 4
AlternateNum
        Config_NoParm   Num,            7, 0, StartCMOS, 0
AlternateNoNum
        Config_NoParm   NoNum,          7, 0, StartCMOS, 1
d1959 1
a1959 1
        B       %BT14                   ; go print it
a1971 4
        &       AlternateNum - ExpandFrig-.
        &       %FT93 -.
        &       AlternateNoNum - ExpandFrig-.
        &       %FT93 -.
a1992 3
93
        &       AlternateNum   -%BT93
        &       AlternateNoNum -%BT93
@


4.3.2.11
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d1638 1
a1638 1
      |
a1639 1
      ]
@


4.3.2.5.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d1412 1
a1412 1
        LDR     r12, =ZeroPage+Module_List
d1545 1
a1545 1
        LDRNE   r8, =ZeroPage           ; else use pagesize units
d1579 1
a1579 1
        LDR     r6, =ZeroPage+Module_List
d1666 1
a1666 1
        LDR     r7, =ZeroPage+Module_List
d1893 1
a1893 1
        LDRNE   r8, =ZeroPage
d2391 1
a2391 1
        LDR     r0, =ZeroPage+VduDriverWorkSpace+CurrentMonitorType
d2462 1
a2462 1
        LDR     r2, =ZeroPage
d2473 1
a2473 1
        LDR     r0, =ZeroPage
@


4.3.2.5.2.2
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@a203 13
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   {TRUE}
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
      [ onereg
$label  STR    $reglist, [R11, #-4]!
      |
a204 1
      ]
a210 17
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   {TRUE}
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
    [ onereg
      [ "$writeback" = ""
        LDR$cc     $reglist, [R11], #4
      |
        LDR$cc     $reglist, [R11]
      ]
    |
a215 1
    ]
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a1205 1
 [ :LNOT: DriversInKernel
a1207 1
 ]
a1514 1
 [ :LNOT: DriversInKernel
a1518 1
 ]
a1876 1
 [ :LNOT: DriversInKernel
a1880 1
 ]
a2428 1
 [ :LNOT: DriversInKernel
a2446 1
 ]
@


4.1
log
@Initial revision
@
text
@d126 2
a127 2
        Pull    "R2, lr"
        ORRS    PC, lr, #V_bit
d136 4
a139 2
        Pull    "R2, lr", EQ            ; integer returned, so leave expranal error there
        ORREQS  PC, lr, #V_bit
d240 1
a240 1
        TEQP    PC, #SVC_mode   ; interrupts on, ta.
d284 4
a287 3
        BLNE    compile_top_op
        BNE     %BT03

d334 4
a337 3
        BLGT    compile_top_op
        BGT     %BT04

d403 1
a403 1
; preserves the flags
d428 1
a428 1
        GRABS   "R2-R4, PC"
d563 1
a563 1
        MULTIPLY R2, R3, R4             ; get R3*R4->R2
d1289 1
a1289 2
        MOV     r3, #Z_bit
        TEQP    r3, pc                          ; invert EQ/NE
d1434 2
a1435 2
        Pull    "lr"
        ORRS    pc, lr, #V_bit
d1590 2
a1591 2
        Pull    "lr"
        ORRS    pc, lr, #V_bit
d1751 1
a1751 1
        Push    "lr"
d1794 1
a1794 3
        Pull    "lr"
        BICVCS  pc, lr, #V_bit
        ORRS    pc, lr, #V_bit
d1889 3
a1891 2
        SWIEQ   XOS_ReadSysInfo         ; proper screen size (r0=0) on entry
        MOVEQ   r0, r0, LSR #10
d1977 1
a1977 1
GetValue ENTRY  "r1"
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d122 1
d124 1
d139 1
d141 1
d229 1
d231 1
d269 1
d272 5
a276 1

d1005 1
d1007 1
d1202 1
d1205 1
d1427 1
d1429 1
d1514 1
d1519 1
d1584 1
d1586 1
d1605 1
d1611 5
d1620 1
d1622 3
d1668 1
d1673 6
d1689 1
d1705 5
d1716 13
d1880 1
d1885 1
d2013 1
d2017 3
d2165 1
a2165 1

d2169 5
a2173 1

d2353 1
d2373 4
d2433 1
d2452 1
@


4.1.4.2
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a234 4
  [ LongCommandLines
        LDR     R1, =ExprBuff
        MOV     R2, #LongCLISize
  |
a236 1
  ]
a507 4
  [ LongCommandLines
        CMP     R0, #LongCLISize
        BGE     StrOFloErr
  |
a509 1
  ]
a814 4
  [ LongCommandLines
        MOV     R2, #LongCLISize
        SUB     R2, R2, #1
  |
a815 1
  ]
a934 4
  [ LongCommandLines
        MOV     R2, #LongCLISize
        SUB     R2, R2, #1
  |
a935 1
  ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

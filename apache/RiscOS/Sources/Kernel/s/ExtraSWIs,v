head	4.6;
access;
symbols
	Kernel-6_14:4.6
	Kernel-6_01-3:4.5
	Kernel-6_13:4.6
	Kernel-6_12:4.6
	Kernel-6_11:4.6
	Kernel-6_10:4.6
	Kernel-6_09:4.6
	Kernel-6_08-4_129_2_10:4.5.2.2
	Kernel-6_08-4_129_2_9:4.5.2.2
	Kernel-6_08:4.5
	Kernel-6_07:4.5
	Kernel-6_06:4.5
	Kernel-6_05-4_129_2_8:4.5.2.2
	Kernel-6_05:4.5
	Kernel-6_04:4.5
	Kernel-6_03:4.5
	Kernel-6_01-2:4.5
	Kernel-6_01-4_146_2_1:4.5
	Kernel-6_02:4.5
	Kernel-6_01-1:4.5
	Kernel-6_01:4.5
	Kernel-6_00:4.5
	Kernel-5_99:4.5
	Kernel-5_98:4.5
	Kernel-5_97-4_129_2_7:4.5.2.2
	Kernel-5_97:4.5
	Kernel-5_96:4.5
	Kernel-5_95:4.5
	Kernel-5_94:4.5
	Kernel-5_93:4.5
	Kernel-5_92:4.5
	Kernel-5_91:4.5
	Kernel-5_90:4.5
	Kernel-5_89-4_129_2_6:4.5.2.2
	Kernel-5_89:4.5
	Kernel-5_88-4_129_2_5:4.5.2.2
	Kernel-5_88-4_129_2_4:4.5.2.1
	Kernel-5_88:4.5
	Kernel-5_87:4.5
	Kernel-5_86-4_129_2_3:4.5.2.1
	Kernel-5_86-4_129_2_2:4.5.2.1
	Kernel-5_86-4_129_2_1:4.5
	Kernel-5_86:4.5
	SMP:4.5.0.2
	SMP_bp:4.5
	Kernel-5_85:4.5
	Kernel-5_54-1:4.4
	Kernel-5_84:4.5
	Kernel-5_83:4.5
	Kernel-5_82:4.5
	Kernel-5_81:4.5
	Kernel-5_80:4.5
	Kernel-5_79:4.5
	Kernel-5_78:4.5
	Kernel-5_77:4.5
	Kernel-5_76:4.5
	Kernel-5_75:4.5
	Kernel-5_74:4.5
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.4
	Kernel-5_64:4.4
	Kernel-5_63:4.4
	Kernel-5_62:4.4
	Kernel-5_61:4.4
	Kernel-5_60:4.4
	Kernel-5_59:4.4
	Kernel-5_58:4.4
	Kernel-5_57:4.4
	Kernel-5_56:4.4
	Kernel-5_55:4.4
	Kernel-5_54:4.4
	Kernel-5_53:4.4
	Kernel-5_52:4.4
	Kernel-5_51:4.3
	Kernel-5_50:4.2
	Kernel-5_49:4.2
	HAL_merge:4.1.8.2
	Kernel-5_48:4.2
	Kernel-5_35-4_79_2_327:4.1.8.2
	Kernel-5_35-4_79_2_326:4.1.8.2
	Kernel-5_35-4_79_2_325:4.1.8.2
	Kernel-5_35-4_79_2_324:4.1.8.2
	Kernel-5_35-4_79_2_323:4.1.8.2
	Kernel-5_35-4_79_2_322:4.1.8.2
	Kernel-5_35-4_79_2_321:4.1.8.2
	Kernel-5_35-4_79_2_320:4.1.8.2
	Kernel-5_35-4_79_2_319:4.1.8.2
	Kernel-5_35-4_79_2_318:4.1.8.2
	Kernel-5_35-4_79_2_317:4.1.8.2
	Kernel-5_35-4_79_2_316:4.1.8.2
	Kernel-5_35-4_79_2_315:4.1.8.2
	Kernel-5_35-4_79_2_314:4.1.8.2
	Kernel-5_35-4_79_2_313:4.1.8.2
	Kernel-5_35-4_79_2_312:4.1.8.2
	Kernel-5_35-4_79_2_311:4.1.8.2
	Kernel-5_35-4_79_2_310:4.1.8.2
	Kernel-5_35-4_79_2_309:4.1.8.2
	Kernel-5_35-4_79_2_308:4.1.8.2
	Kernel-5_35-4_79_2_307:4.1.8.2
	Kernel-5_35-4_79_2_306:4.1.8.2
	Kernel-5_35-4_79_2_305:4.1.8.2
	Kernel-5_35-4_79_2_304:4.1.8.2
	Kernel-5_35-4_79_2_303:4.1.8.2
	Kernel-5_35-4_79_2_302:4.1.8.2
	Kernel-5_35-4_79_2_301:4.1.8.2
	Kernel-5_35-4_79_2_300:4.1.8.2
	Kernel-5_35-4_79_2_299:4.1.8.2
	Kernel-5_35-4_79_2_298:4.1.8.2
	Kernel-5_35-4_79_2_297:4.1.8.2
	Kernel-5_35-4_79_2_296:4.1.8.2
	Kernel-5_35-4_79_2_295:4.1.8.2
	Kernel-5_35-4_79_2_294:4.1.8.2
	Kernel-5_35-4_79_2_293:4.1.8.2
	Kernel-5_35-4_79_2_292:4.1.8.2
	Kernel-5_35-4_79_2_291:4.1.8.2
	Kernel-5_35-4_79_2_290:4.1.8.2
	Kernel-5_35-4_79_2_289:4.1.8.2
	Kernel-5_35-4_79_2_288:4.1.8.2
	Kernel-5_35-4_79_2_287:4.1.8.2
	Kernel-5_35-4_79_2_286:4.1.8.2
	Kernel-5_35-4_79_2_285:4.1.8.2
	Kernel-5_35-4_79_2_284:4.1.8.2
	Kernel-5_35-4_79_2_283:4.1.8.2
	Kernel-5_35-4_79_2_282:4.1.8.2
	Kernel-5_35-4_79_2_281:4.1.8.2
	Kernel-5_35-4_79_2_280:4.1.8.2
	Kernel-5_35-4_79_2_279:4.1.8.2
	Kernel-5_35-4_79_2_278:4.1.8.2
	Kernel-5_35-4_79_2_277:4.1.8.2
	Kernel-5_35-4_79_2_276:4.1.8.2
	Kernel-5_35-4_79_2_275:4.1.8.2
	Kernel-5_35-4_79_2_274:4.1.8.2
	Kernel-5_35-4_79_2_273:4.1.8.2
	Kernel-5_35-4_79_2_272:4.1.8.2
	Kernel-5_35-4_79_2_271:4.1.8.2
	Kernel-5_35-4_79_2_270:4.1.8.2
	Kernel-5_35-4_79_2_269:4.1.8.2
	Kernel-5_35-4_79_2_268:4.1.8.2
	Kernel-5_35-4_79_2_267:4.1.8.2
	Kernel-5_35-4_79_2_266:4.1.8.2
	Kernel-5_35-4_79_2_265:4.1.8.2
	Kernel-5_35-4_79_2_264:4.1.8.2
	Kernel-5_35-4_79_2_263:4.1.8.2
	Kernel-5_35-4_79_2_262:4.1.8.2
	Kernel-5_35-4_79_2_261:4.1.8.2
	Kernel-5_35-4_79_2_260:4.1.8.2
	Kernel-5_35-4_79_2_259:4.1.8.2
	Kernel-5_35-4_79_2_258:4.1.8.2
	Kernel-5_35-4_79_2_257:4.1.8.2
	Kernel-5_35-4_79_2_256:4.1.8.2
	Kernel-5_35-4_79_2_255:4.1.8.2
	Kernel-5_35-4_79_2_254:4.1.8.2
	Kernel-5_35-4_79_2_253:4.1.8.2
	Kernel-5_35-4_79_2_252:4.1.8.2
	Kernel-5_35-4_79_2_251:4.1.8.2
	Kernel-5_35-4_79_2_250:4.1.8.2
	Kernel-5_35-4_79_2_249:4.1.8.2
	Kernel-5_35-4_79_2_248:4.1.8.2
	Kernel-5_35-4_79_2_247:4.1.8.2
	Kernel-5_35-4_79_2_246:4.1.8.2
	Kernel-5_35-4_79_2_245:4.1.8.2
	Kernel-5_35-4_79_2_244:4.1.8.2
	Kernel-5_35-4_79_2_243:4.1.8.2
	Kernel-5_35-4_79_2_242:4.1.8.2
	Kernel-5_35-4_79_2_241:4.1.8.2
	Kernel-5_35-4_79_2_240:4.1.8.2
	Kernel-5_35-4_79_2_239:4.1.8.2
	Kernel-5_35-4_79_2_238:4.1.8.2
	Kernel-5_35-4_79_2_237:4.1.8.2
	Kernel-5_35-4_79_2_236:4.1.8.2
	Kernel-5_35-4_79_2_235:4.1.8.2
	Kernel-5_35-4_79_2_234:4.1.8.2
	Kernel-5_35-4_79_2_233:4.1.8.2
	Kernel-5_35-4_79_2_232:4.1.8.2
	Kernel-5_35-4_79_2_231:4.1.8.2
	Kernel-5_35-4_79_2_230:4.1.8.2
	Kernel-5_35-4_79_2_229:4.1.8.2
	Kernel-5_35-4_79_2_228:4.1.8.2
	Kernel-5_35-4_79_2_227:4.1.8.2
	Kernel-5_35-4_79_2_226:4.1.8.2
	Kernel-5_35-4_79_2_225:4.1.8.2
	Kernel-5_35-4_79_2_224:4.1.8.2
	Kernel-5_35-4_79_2_223:4.1.8.2
	Kernel-5_35-4_79_2_222:4.1.8.2
	Kernel-5_35-4_79_2_221:4.1.8.2
	Kernel-5_35-4_79_2_220:4.1.8.2
	Kernel-5_35-4_79_2_219:4.1.8.2
	Kernel-5_35-4_79_2_218:4.1.8.2
	Kernel-5_35-4_79_2_217:4.1.8.2
	Kernel-5_35-4_79_2_216:4.1.8.2
	Kernel-5_35-4_79_2_215:4.1.8.2
	Kernel-5_35-4_79_2_214:4.1.8.2
	Kernel-5_35-4_79_2_213:4.1.8.2
	Kernel-5_35-4_79_2_212:4.1.8.2
	Kernel-5_35-4_79_2_211:4.1.8.2
	Kernel-5_35-4_79_2_210:4.1.8.2
	Kernel-5_35-4_79_2_209:4.1.8.2
	Kernel-5_35-4_79_2_208:4.1.8.2
	Kernel-5_35-4_79_2_207:4.1.8.2
	Kernel-5_35-4_79_2_206:4.1.8.2
	Kernel-5_35-4_79_2_205:4.1.8.2
	Kernel-5_35-4_79_2_204:4.1.8.2
	Kernel-5_35-4_79_2_203:4.1.8.2
	Kernel-5_35-4_79_2_202:4.1.8.2
	Kernel-5_35-4_79_2_201:4.1.8.2
	Kernel-5_35-4_79_2_200:4.1.8.2
	Kernel-5_35-4_79_2_199:4.1.8.2
	Kernel-5_35-4_79_2_198:4.1.8.2
	Kernel-5_35-4_79_2_197:4.1.8.2
	Kernel-5_35-4_79_2_196:4.1.8.2
	Kernel-5_35-4_79_2_195:4.1.8.2
	Kernel-5_35-4_79_2_194:4.1.8.2
	Kernel-5_35-4_79_2_193:4.1.8.2
	Kernel-5_35-4_79_2_192:4.1.8.2
	Kernel-5_35-4_79_2_191:4.1.8.2
	Kernel-5_35-4_79_2_190:4.1.8.2
	Kernel-5_35-4_79_2_189:4.1.8.2
	Kernel-5_35-4_79_2_188:4.1.8.2
	Kernel-5_35-4_79_2_187:4.1.8.2
	Kernel-5_35-4_79_2_186:4.1.8.2
	Kernel-5_35-4_79_2_185:4.1.8.2
	Kernel-5_35-4_79_2_184:4.1.8.2
	Kernel-5_35-4_79_2_183:4.1.8.2
	Kernel-5_35-4_79_2_182:4.1.8.2
	Kernel-5_35-4_79_2_181:4.1.8.2
	Kernel-5_35-4_79_2_180:4.1.8.2
	Kernel-5_35-4_79_2_179:4.1.8.2
	Kernel-5_35-4_79_2_178:4.1.8.2
	Kernel-5_35-4_79_2_177:4.1.8.2
	Kernel-5_35-4_79_2_176:4.1.8.2
	Kernel-5_35-4_79_2_175:4.1.8.2
	Kernel-5_35-4_79_2_174:4.1.8.2
	Kernel-5_35-4_79_2_173:4.1.8.2
	Kernel-5_35-4_79_2_172:4.1.8.2
	Kernel-5_35-4_79_2_171:4.1.8.2
	Kernel-5_35-4_79_2_170:4.1.8.2
	Kernel-5_35-4_79_2_169:4.1.8.2
	Kernel-5_35-4_79_2_168:4.1.8.2
	Kernel-5_35-4_79_2_167:4.1.8.2
	Kernel-5_35-4_79_2_166:4.1.8.2
	Kernel-5_35-4_79_2_165:4.1.8.2
	RPi_merge:4.1.8.2
	Kernel-5_35-4_79_2_147_2_23:4.1.8.2
	Kernel-5_35-4_79_2_147_2_22:4.1.8.2
	Kernel-5_35-4_79_2_147_2_21:4.1.8.2
	Kernel-5_35-4_79_2_147_2_20:4.1.8.2
	Kernel-5_35-4_79_2_147_2_19:4.1.8.2
	Kernel-5_35-4_79_2_147_2_18:4.1.8.2
	Kernel-5_35-4_79_2_164:4.1.8.2
	Kernel-5_35-4_79_2_163:4.1.8.2
	Kernel-5_35-4_79_2_147_2_17:4.1.8.2
	Kernel-5_35-4_79_2_147_2_16:4.1.8.2
	Kernel-5_35-4_79_2_147_2_15:4.1.8.2
	Kernel-5_35-4_79_2_162:4.1.8.2
	Kernel-5_35-4_79_2_161:4.1.8.2
	Kernel-5_35-4_79_2_147_2_14:4.1.8.2
	Kernel-5_35-4_79_2_147_2_13:4.1.8.2
	Kernel-5_35-4_79_2_160:4.1.8.2
	Kernel-5_35-4_79_2_159:4.1.8.2
	Kernel-5_35-4_79_2_158:4.1.8.2
	Kernel-5_35-4_79_2_157:4.1.8.2
	Kernel-5_35-4_79_2_156:4.1.8.2
	Kernel-5_35-4_79_2_147_2_12:4.1.8.2
	Kernel-5_35-4_79_2_147_2_11:4.1.8.2
	Kernel-5_35-4_79_2_155:4.1.8.2
	Kernel-5_35-4_79_2_147_2_10:4.1.8.2
	Kernel-5_35-4_79_2_154:4.1.8.2
	Kernel-5_35-4_79_2_153:4.1.8.2
	Kernel-5_35-4_79_2_147_2_9:4.1.8.2
	Kernel-5_35-4_79_2_152:4.1.8.2
	Kernel-5_35-4_79_2_151:4.1.8.2
	Kernel-5_35-4_79_2_147_2_8:4.1.8.2
	Kernel-5_35-4_79_2_147_2_7:4.1.8.2
	Kernel-5_35-4_79_2_150:4.1.8.2
	Kernel-5_35-4_79_2_147_2_6:4.1.8.2
	Kernel-5_35-4_79_2_147_2_5:4.1.8.2
	Kernel-5_35-4_79_2_149:4.1.8.2
	Kernel-5_35-4_79_2_147_2_4:4.1.8.2
	Kernel-5_35-4_79_2_147_2_3:4.1.8.2
	Kernel-5_35-4_79_2_148:4.1.8.2
	Kernel-5_35-4_79_2_147_2_2:4.1.8.2
	Kernel-5_35-4_79_2_147_2_1:4.1.8.2
	RPi:4.1.8.2.0.2
	RPi_bp:4.1.8.2
	Kernel-5_35-4_79_2_98_2_52_2_1:4.1.8.1.2.1
	alees_Kernel_dev:4.1.8.1.2.1.0.2
	alees_Kernel_dev_bp:4.1.8.1.2.1
	Kernel-5_35-4_79_2_147:4.1.8.2
	Kernel-5_35-4_79_2_146:4.1.8.2
	Kernel-5_35-4_79_2_145:4.1.8.2
	Kernel-5_35-4_79_2_144:4.1.8.2
	Kernel-5_35-4_79_2_143:4.1.8.2
	Kernel-5_35-4_79_2_142:4.1.8.2
	Kernel-5_35-4_79_2_141:4.1.8.2
	Kernel-5_35-4_79_2_140:4.1.8.2
	Kernel-5_35-4_79_2_139:4.1.8.2
	Kernel-5_35-4_79_2_138:4.1.8.2
	Kernel-5_35-4_79_2_137:4.1.8.2
	Kernel-5_35-4_79_2_136:4.1.8.2
	Kernel-5_35-4_79_2_135:4.1.8.2
	Kernel-5_35-4_79_2_134:4.1.8.2
	Kernel-5_35-4_79_2_133:4.1.8.2
	Kernel-5_35-4_79_2_132:4.1.8.2
	Kernel-5_35-4_79_2_131:4.1.8.2
	Kernel-5_35-4_79_2_130:4.1.8.2
	Kernel-5_35-4_79_2_129:4.1.8.2
	Kernel-5_35-4_79_2_128:4.1.8.2
	Kernel-5_35-4_79_2_127:4.1.8.2
	Kernel-5_35-4_79_2_126:4.1.8.2
	Kernel-5_35-4_79_2_125:4.1.8.2
	Kernel-5_35-4_79_2_124:4.1.8.2
	Kernel-5_35-4_79_2_123:4.1.8.2
	Cortex_merge:4.1.8.1.2.1
	Kernel-5_35-4_79_2_122:4.1.8.1
	Kernel-5_35-4_79_2_98_2_54:4.1.8.1.2.1
	Kernel-5_35-4_79_2_98_2_53:4.1.8.1.2.1
	Kernel-5_35-4_79_2_98_2_52:4.1.8.1.2.1
	Kernel-5_35-4_79_2_98_2_51:4.1.8.1.2.1
	Kernel-5_35-4_79_2_98_2_50:4.1.8.1.2.1
	Kernel-5_35-4_79_2_98_2_49:4.1.8.1.2.1
	Kernel-5_35-4_79_2_98_2_48:4.1.8.1.2.1
	Kernel-5_35-4_79_2_121:4.1.8.1
	Kernel-5_35-4_79_2_98_2_47:4.1.8.1
	Kernel-5_35-4_79_2_120:4.1.8.1
	Kernel-5_35-4_79_2_98_2_46:4.1.8.1
	Kernel-5_35-4_79_2_119:4.1.8.1
	Kernel-5_35-4_79_2_98_2_45:4.1.8.1
	Kernel-5_35-4_79_2_98_2_44:4.1.8.1
	Kernel-5_35-4_79_2_118:4.1.8.1
	Kernel-5_35-4_79_2_98_2_43:4.1.8.1
	Kernel-5_35-4_79_2_117:4.1.8.1
	Kernel-5_35-4_79_2_116:4.1.8.1
	Kernel-5_35-4_79_2_98_2_42:4.1.8.1
	Kernel-5_35-4_79_2_115:4.1.8.1
	Kernel-5_35-4_79_2_98_2_41:4.1.8.1
	Kernel-5_35-4_79_2_98_2_40:4.1.8.1
	Kernel-5_35-4_79_2_114:4.1.8.1
	Kernel-5_35-4_79_2_98_2_39:4.1.8.1
	Kernel-5_35-4_79_2_98_2_38:4.1.8.1
	Kernel-5_35-4_79_2_113:4.1.8.1
	Kernel-5_35-4_79_2_112:4.1.8.1
	Kernel-5_35-4_79_2_98_2_37:4.1.8.1
	Kernel-5_35-4_79_2_98_2_36:4.1.8.1
	Kernel-5_35-4_79_2_98_2_35:4.1.8.1
	Kernel-5_35-4_79_2_98_2_34:4.1.8.1
	Kernel-5_35-4_79_2_98_2_33:4.1.8.1
	Kernel-5_35-4_79_2_98_2_32:4.1.8.1
	Kernel-5_35-4_79_2_98_2_31:4.1.8.1
	Kernel-5_35-4_79_2_98_2_30:4.1.8.1
	Kernel-5_35-4_79_2_98_2_29:4.1.8.1
	Kernel-5_35-4_79_2_98_2_28:4.1.8.1
	Kernel-5_35-4_79_2_98_2_27:4.1.8.1
	Kernel-5_35-4_79_2_98_2_26:4.1.8.1
	Kernel-5_35-4_79_2_111:4.1.8.1
	Kernel-5_35-4_79_2_98_2_25:4.1.8.1
	Kernel-5_35-4_79_2_98_2_24:4.1.8.1
	Kernel-5_35-4_79_2_98_2_23:4.1.8.1
	Kernel-5_35-4_79_2_110:4.1.8.1
	Kernel-5_35-4_79_2_98_2_22:4.1.8.1
	Kernel-5_35-4_79_2_109:4.1.8.1
	Kernel-5_35-4_79_2_98_2_21:4.1.8.1
	Kernel-5_35-4_79_2_98_2_20:4.1.8.1
	Kernel-5_35-4_79_2_108:4.1.8.1
	Kernel-5_35-4_79_2_107:4.1.8.1
	Kernel-5_35-4_79_2_98_2_19:4.1.8.1
	Kernel-5_35-4_79_2_98_2_18:4.1.8.1
	Kernel-5_35-4_79_2_98_2_17:4.1.8.1
	Kernel-5_35-4_79_2_98_2_16:4.1.8.1
	Kernel-5_35-4_79_2_98_2_15:4.1.8.1
	Kernel-5_35-4_79_2_106:4.1.8.1
	Kernel-5_35-4_79_2_105:4.1.8.1
	Kernel-5_35-4_79_2_104:4.1.8.1
	Kernel-5_35-4_79_2_98_2_14:4.1.8.1
	Kernel-5_35-4_79_2_98_2_13:4.1.8.1
	Kernel-5_35-4_79_2_98_2_12:4.1.8.1
	Kernel-5_35-4_79_2_98_2_11:4.1.8.1
	Kernel-5_35-4_79_2_98_2_10:4.1.8.1
	Kernel-5_35-4_79_2_98_2_9:4.1.8.1
	Kernel-5_35-4_79_2_103:4.1.8.1
	Kernel-5_35-4_79_2_102:4.1.8.1
	Kernel-5_35-4_79_2_98_2_8:4.1.8.1
	Kernel-5_35-4_79_2_98_2_7:4.1.8.1
	Kernel-5_35-4_79_2_98_2_6:4.1.8.1
	Kernel-5_35-4_79_2_98_2_5:4.1.8.1
	Kernel-5_35-4_79_2_98_2_4:4.1.8.1
	Kernel-5_35-4_79_2_101:4.1.8.1
	Kernel-5_35-4_79_2_100:4.1.8.1
	Kernel-5_35-4_79_2_99:4.1.8.1
	Kernel-5_35-4_79_2_98_2_3:4.1.8.1
	Kernel-5_35-4_79_2_98_2_2:4.1.8.1
	Kernel-5_35-4_79_2_98_2_1:4.1.8.1
	Cortex:4.1.8.1.0.2
	Cortex_bp:4.1.8.1
	Kernel-5_35-4_79_2_98:4.1.8.1
	Kernel-5_35-4_79_2_97:4.1.8.1
	Kernel-5_35-4_79_2_96:4.1.8.1
	Kernel-5_35-4_79_2_95:4.1.8.1
	Kernel-5_35-4_79_2_94:4.1.8.1
	Kernel-5_35-4_79_2_93:4.1.8.1
	Kernel-5_35-4_79_2_92:4.1.8.1
	Kernel-5_35-4_79_2_91:4.1.8.1
	Kernel-5_35-4_79_2_90:4.1.8.1
	Kernel-5_35-4_79_2_89:4.1.8.1
	Kernel-5_35-4_79_2_88:4.1.8.1
	Kernel-5_35-4_79_2_87:4.1.8.1
	Kernel-5_35-4_79_2_86:4.1.8.1
	Kernel-5_35-4_79_2_85:4.1.8.1
	Kernel-5_35-4_79_2_84:4.1.8.1
	Kernel-5_35-4_79_2_83:4.1.8.1
	Kernel-5_35-4_79_2_82:4.1.8.1
	Kernel-5_35-4_79_2_81:4.1.8.1
	Kernel-5_35-4_79_2_80:4.1.8.1
	Kernel-5_35-4_79_2_79:4.1.8.1
	Kernel-5_35-4_79_2_78:4.1.8.1
	Kernel-5_35-4_79_2_77:4.1.8.1
	RO_5_07:4.1.8.1
	Kernel-5_35-4_79_2_76:4.1.8.1
	Kernel-5_35-4_79_2_75:4.1.8.1
	Kernel-5_35-4_79_2_74:4.1.8.1
	Kernel-5_35-4_79_2_73:4.1.8.1
	Kernel-5_35-4_79_2_72:4.1.8.1
	Kernel-5_35-4_79_2_71:4.1.8.1
	Kernel-5_35-4_79_2_70:4.1.8.1
	Kernel-5_35-4_79_2_69:4.1.8.1
	Kernel-5_35-4_79_2_68:4.1.8.1
	Kernel-5_35-4_79_2_67:4.1.8.1
	Kernel-5_35-4_79_2_66:4.1.8.1
	Kernel-5_35-4_79_2_65:4.1.8.1
	Kernel-5_35-4_79_2_64:4.1.8.1
	Kernel-5_35-4_79_2_63:4.1.8.1
	Kernel-5_35-4_79_2_62:4.1.8.1
	Kernel-5_35-4_79_2_61:4.1.8.1
	Kernel-5_35-4_79_2_59:4.1.8.1
	Kernel-5_35-4_79_2_58:4.1.8.1
	Kernel-5_35-4_79_2_57:4.1.8.1
	Kernel-5_35-4_79_2_56:4.1.8.1
	Kernel-5_35-4_79_2_55:4.1.8.1
	Kernel-5_35-4_79_2_54:4.1.8.1
	Kernel-5_35-4_79_2_53:4.1.8.1
	Kernel-5_35-4_79_2_52:4.1.8.1
	Kernel-5_35-4_79_2_51:4.1.8.1
	Kernel-5_35-4_79_2_50:4.1.8.1
	Kernel-5_35-4_79_2_49:4.1.8.1
	Kernel-5_35-4_79_2_48:4.1.8.1
	Kernel-5_47:4.1
	Kernel-5_46-4_90_2_1:4.1
	nbingham_Kernel_FastNC_dev_bp:4.1
	nbingham_Kernel_FastNC_dev:4.1.0.12
	Kernel-5_46:4.1
	Kernel-5_45:4.1
	Kernel-5_35-4_79_2_47:4.1.8.1
	Kernel-5_35-4_79_2_46:4.1.8.1
	Kernel-5_35-4_79_2_45:4.1.8.1
	Kernel-5_35-4_79_2_44:4.1.8.1
	Kernel-5_35-4_79_2_25_2_2:4.1.8.1
	Kernel-5_35-4_79_2_43:4.1.8.1
	Kernel-5_35-4_79_2_42:4.1.8.1
	Kernel-5_35-4_79_2_41:4.1.8.1
	Kernel-5_35-4_79_2_40:4.1.8.1
	Kernel-5_35-4_79_2_39:4.1.8.1
	Kernel-5_35-4_79_2_38:4.1.8.1
	Kernel-5_35-4_79_2_37:4.1.8.1
	Kernel-5_35-4_79_2_36:4.1.8.1
	Kernel-5_35-4_79_2_35:4.1.8.1
	Kernel-5_35-4_79_2_34:4.1.8.1
	Kernel-5_35-4_79_2_33:4.1.8.1
	Kernel-5_35-4_79_2_32:4.1.8.1
	Kernel-5_44:4.1
	Kernel-5_35-4_79_2_25_2_1:4.1.8.1
	Kernel-5_43:4.1
	Kernel-5_35-4_79_2_31:4.1.8.1
	Kernel-5_35-4_79_2_30:4.1.8.1
	Kernel-5_35-4_79_2_29:4.1.8.1
	Kernel-5_35-4_79_2_28:4.1.8.1
	Kernel-5_35-4_79_2_27:4.1.8.1
	Kernel-5_35-4_79_2_26:4.1.8.1
	Kernel-5_42:4.1
	Kernel-5_41:4.1
	Kernel-5_40:4.1
	Kernel-5_35-4_79_2_25:4.1.8.1
	Kernel-5_35-4_79_2_24:4.1.8.1
	Kernel-5_35-4_79_2_23:4.1.8.1
	Kernel-5_35-4_79_2_22:4.1.8.1
	Kernel-5_35-4_79_2_21:4.1.8.1
	Kernel-5_35-4_79_2_20:4.1.8.1
	Kernel-5_35-4_79_2_19:4.1.8.1
	Kernel-5_35-4_79_2_18:4.1.8.1
	Kernel-5_35-4_79_2_17:4.1.8.1
	Kernel-5_35-4_79_2_16:4.1.8.1
	Kernel-5_35-4_79_2_15:4.1.8.1
	Kernel-5_35-4_79_2_14:4.1.8.1
	Kernel-5_39:4.1
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.10
	Kernel-5_38:4.1
	Kernel-5_35-4_79_2_13:4.1.8.1
	Kernel-5_35-4_79_2_12:4.1.8.1
	Kernel-5_35-4_79_2_11:4.1.8.1
	Kernel-5_37:4.1
	Kernel-5_35-4_79_2_10:4.1.8.1
	Kernel-5_35-4_79_2_9:4.1.8.1
	Kernel-5_36:4.1
	Kernel-5_35-4_79_2_8:4.1.8.1
	Kernel-5_35-4_79_2_7:4.1.8.1
	Kernel-5_35-4_79_2_6:4.1.8.1
	Kernel-5_35-4_79_2_5:4.1.8.1
	Kernel-5_35-4_79_2_4:4.1.8.1
	Kernel-5_35-4_79_2_3:4.1.8.1
	Kernel-5_35-4_79_2_2:4.1.8.1
	dellis_autobuild_BaseSW:4.1
	Kernel-5_35-4_79_2_1:4.1.8.1
	HAL:4.1.0.8
	Kernel-5_35:4.1
	Kernel-5_34:4.1
	Kernel-5_33:4.1
	Kernel-5_32:4.1
	Kernel-5_31:4.1
	Kernel-5_30:4.1
	Kernel-5_29:4.1
	Kernel-5_28:4.1
	Kernel-5_27:4.1
	Kernel-5_26:4.1
	Kernel-5_25:4.1
	Kernel-5_24:4.1
	Kernel-5_23:4.1
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.1
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.2
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.2
	Ursula_RiscPC_bp:4.1.4.2
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.2
	Ursula_RiscPC:4.1.4.2.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.2
	UrsulaBuild_FinalSoftload:4.1.4.2
	rthornb_UrsulaBuild-12Aug1998:4.1.4.2
	aglover_UrsulaBuild-05Aug1998:4.1.4.2
	rthornb_UrsulaBuild-29Jul1998:4.1.4.2
	rthornb_UrsulaBuild-22Jul1998:4.1.4.2
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.2
	rthornb_UrsulaBuild-07Jul1998:4.1.4.2
	rthornb_UrsulaBuild-17Jun1998:4.1.4.2
	rthornb_UrsulaBuild-03Jun1998:4.1.4.2
	rthornb_UrsulaBuild-27May1998:4.1.4.2
	mstphens_Kernel-3_80:4.1.4.2
	rthornb_UrsulaBuild-21May1998:4.1.4.2
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2018.07.07.14.06.29;	author jlee;	state Exp;
branches;
next	4.5;
commitid	VD8qInwgaJB98dJA;

4.5
date	2016.12.13.16.42.50;	author jlee;	state Exp;
branches
	4.5.2.1;
next	4.4;
commitid	aGog9bB8f4QKlQxz;

4.4
date	2016.06.30.21.14.27;	author jlee;	state Exp;
branches;
next	4.3;
commitid	juXQJ5NfO6DKbxcz;

4.3
date	2016.06.30.20.59.46;	author jlee;	state Exp;
branches;
next	4.2;
commitid	skOEjp3ipLHx6xcz;

4.2
date	2016.06.30.20.08.08;	author jlee;	state Exp;
branches;
next	4.1;
commitid	IWoXxARWeuLDOwcz;

4.1
date	96.11.05.09.41.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1
	4.1.8.1;
next	;

4.5.2.1
date	2017.07.29.11.13.08;	author jlee;	state Exp;
branches;
next	4.5.2.2;
commitid	E0o1zV5A8r2fc71A;

4.5.2.2
date	2017.09.03.21.36.58;	author jlee;	state Exp;
branches;
next	;
commitid	T1suKXljbc8yuN5A;

4.1.1.1
date	96.11.05.09.41.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.59.59;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.33.07;	author mstphens;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.12.08.14.34.21;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.10.54;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.29;	author nturton;	state Exp;
branches;
next	;

4.1.8.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches
	4.1.8.1.2.1;
next	4.1.8.2;

4.1.8.2
date	2011.11.26.21.11.15;	author jlee;	state Exp;
branches;
next	;
commitid	cI3W0zbtALQG6TIv;

4.1.8.1.2.1
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;


desc
@@


4.6
log
@Merge SMP branch to trunk
Detail:
  Since the current SMP changes are fairly minor, and the trunk is seeing most development, from a maintenance perspective it makes sense to merge the changes to trunk. This will also make sure they get some wider testing ready for when the next round of SMP development takes place.
  Changes:
  - Docs/SMP - New docs folder describing SMP-related changes to the HAL and interrupt handling. Some of the IRQ changes can also be taken advantage of by single-core devices, since it introduces a way to describe which interrupt sources can be routed to IRQ & FIQ
  - Makefile, hdr/DBellDevice, hdr/HALDevice - New HAL device for an inter-processor software-generated interrupt source ("doorbell")
  - hdr/HALEntries - Reuse the unused matrix keyboard & touchscreen HAL entry points for the new IRQ handling & SMP-related HAL calls
  - hdr/KernelWS - Bump up MaxInterrupts
  - hdr/OSMem, s/MemInfo - Introduce OS_Memory 19, to allow for DMA to/from cacheable memory without actually altering the cacheability of the pages (which can be even more tricky in SMP systems than it is in uniprocessor systems)
  - hdr/Options - Introduce SMP build switch. Currently this controls whether the ARMops will operate in "SMP-friendly" mode or not (when running on MP processors)
  - s/ARMops, s/MemMap2 - Introduce the ARMv7MP ARMop implementation. Simplify DCache_LineLen / ICache_LineLen handling for WB_CR7_Lx so that it's the plain value rather than log2(n)-2
  - s/ExtraSWIs - If ARMops are in SMP-friendly mode, global OS_SynchroniseCodeAreas now only syncs application space and the RMA. This is because there is no trivial MP-safe global IMB operation available. This will also make global OS_SynchroniseCodeAreas significantly slower, but the documentation has always warned against performing a global IMB for just that reason, so code that suffers performance penalties should really try and switch to a ranged IMB.
  - s/NewIRQs - Update some comments regarding IRQ handler entry/exit conditions
Admin:
  Untested


Version 6.09. Tagged as 'Kernel-6_09'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > ExtraSWIs

;----------------------------------------------------------------------------------------
; ClaimProcVecSWI
;
;       In:     r0 = vector and flags
;                       bit     meaning
;                       0-7     vector number
;                               0 = 'Branch through 0' vector
;                               1 = Undefined instruction
;                               2 = SWI
;                               3 = Prefetch abort
;                               4 = Data abort
;                               5 = Address exception (only on ARM 2 & 3)
;                               6 = IRQ
;                               7+ = reserved for future use
;                       8       0 = release
;                               1 = claim
;                       9-31    reserved (set to 0)
;               r1 = replacement value
;               r2 = value which should currently be on vector (only needed for release)
;
;       Out:    r1 = value which has been replaced (only returned on claim)
;
;       Allows a module to attach itself to one of the processor vectors.
;
ClaimProcVecSWI ROUT
        Entry   "r3-r5"

        AND     r3, r0, #&FF            ; Get vector number.
        CMP     r3, #(ProcVec_End-ProcVec_Start):SHR:2
        ADRCSL  r0, ErrorBlock_BadClaimNum
        BCS     %FT30

        MOV     r4, r1                  ; r4 = replacement value
        LDR     r5, =ZeroPage+ProcVec_Start
        PHPSEI                          ; Disable IRQs while we mess around with vectors.

        TST     r0, #1:SHL:8
        LDRNE   r1, [r5, r3, LSL #2]!   ; If claiming then return current value (r5->vector to replace).
        BNE     %FT10

        LDR     r3, [r5, r3, LSL #2]!   ; Releasing so get current value (r5->vector to replace).
        TEQ     r2, r3                  ; Make sure it's what the caller thinks it is.
        ADRNEL  r0, ErrorBlock_NaffRelease
        BNE     %FT20
10
        STR     r4, [r5]                ; Store replacement value.
        PLP                             ; Restore IRQs.
        PullEnv
        ExitSWIHandler

20
        PLP                             ; Restore IRQs and return error.
30
  [ International
        BL      TranslateError
  ]
        PullEnv
        B       SLVK_SetV


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_UpdateMEMC: Read/write MEMC1 control register

SSETMEMC ROUT

        AND     r10, r0, r1
        LDR     r12, =ZeroPage
        WritePSRc SVC_mode+I_bit+F_bit, r0
        LDR     r0, [r12, #MEMC_CR_SoftCopy] ; return old value
        BIC     r11, r0, r1
        ORR     r11, r11, R10
        BIC     r11, r11, #&FF000000
        BIC     r11, r11, #&00F00000
        ORR     r11, r11, #MEMCADR
        STR     r11, [r12, #MEMC_CR_SoftCopy]

; mjs Oct 2000 kernel/HAL split
;
; The kernel itself should now never call this SWI, but grudgingly has
; to maintain at least bit 10 of soft copy
;
; Here, we only mimic action of bit 10 to control video/cursor DMA (eg. for ADFS)
; The whole OS_UpdateMEMC thing would ideally be withdrawn as archaic, but
; unfortunately has not even been deprecated up to now

; for reference, the bits of the MEMC1 control register are:
;
; bits 0,1 => unused
; bits 2,3 => page size, irrelevant since always 4K
; bits 4,5 => low ROM access time (mostly irrelevant but set it up anyway)
; bits 6,7 => hi  ROM access time (definitely irrelevant but set it up anyway)
; bits 8,9 => DRAM refresh control
; bit 10   => Video/cursor DMA enable
; bit 11   => Sound DMA enable
; bit 12   => OS mode

        Push  "r0,r1,r4, r14"
        TST   r11, #(1 :SHL: 10)
        MOVEQ r0, #1             ; blank (video DMA disable)
        MOVNE r0, #0             ; unblank (video DMA enable)
        MOV   r1, #0             ; no funny business with DPMS
        ADD   r4, r12, #VduDriverWorkSpace
        LDR   r4, [r4, #CurrentGraphicsVDriver]
        MOV   r4, r4, LSL #24
        ORR   r4, r4, #GraphicsV_SetBlank
        BL    CallGraphicsV
        Pull  "r0,r1,r4, r14"

        WritePSRc SVC_mode+I_bit, r11
        ExitSWIHandler


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       SWI OS_MMUControl
;
; in:   r0 = 0 (reason code 0, for modify control register)
;       r1 = EOR mask
;       r2 = AND mask
;
;       new control = ((old control AND r2) EOR r1)
;
; out:  r1 = old value
;       r2 = new value
;
; in:   r0 bits 1 to 28 = 0, bit 0 = 1  (reason code 1, for flush request)
;          r0 bit 31 set if cache(s) to be flushed
;          r0 bit 30 set if TLB(s) to be flushed
;          r0 bit 29 set if flush of entry only (else whole flush)
;          r0 bit 28 set if write buffer to be flushed (implied by bit 31)
;       r1 = entry specifier, if r0 bit 29 set
;       (currently, flushing by entry is ignored, and just does full flush)
;
; in:   r0 bits 0-7 = 2: reason code 2, read ARMop
;          r0 bits 15-8 = ARMop index
;
; out:  r0 = ARMop function ptr
;

MMUControlSWI   Entry
        BL      MMUControlSub
        PullEnv
        ORRVS   lr, lr, #V_bit
        ExitSWIHandler

MMUControlSub
        Push    lr
        AND     lr,r0,#&FF
        CMP     lr, #MMUCReason_Unknown
        ADDCC   pc, pc, lr, LSL #2
        B       MMUControl_Unknown
        B       MMUControl_ModifyControl ; -> See $MEMM_Type file
        B       MMUControl_Flush
        B       MMUControl_GetARMop

MMUControl_Unknown
        ADRL    r0, ErrorBlock_HeapBadReason
 [ International
        BL      TranslateError
 |
        SETV
 ]
        Pull    "pc"

MMUControl_Flush
        MOVS    r10, r0
        LDR     r12, =ZeroPage
        ARMop   Cache_CleanInvalidateAll,MI,,r12
        TST     r10,#&40000000
        ARMop   TLB_InvalidateAll,NE,,r12
        TST     r10,#&10000000
        ARMop   DSB_ReadWrite,NE,,r12
        ADDS    r0,r10,#0
        Pull    "pc"

MMUControl_GetARMop
        AND     r0, r0, #&FF00
        CMP     r0, #(ARMopPtrTable_End-ARMopPtrTable):SHL:6
        BHS     MMUControl_Unknown
        ADRL    lr, ARMopPtrTable
        LDR     r0, [lr, r0, LSR #6]
        LDR     r0, [r0]
        Pull    "pc"

;
; ---------------- XOS_SynchroniseCodeAreas implementation ---------------
;

;this SWI effectively implements IMB and IMBrange (Instruction Memory Barrier)
;for newer ARMs

;entry:
;   R0 = flags
;        bit 0 set ->  R1,R2 specify virtual address range to synchronise
;                      R1 = start address (word aligned, inclusive)
;                      R2 = end address (word aligned, inclusive)
;        bit 0 clear   synchronise entire virtual space
;        bits 1..31    reserved
;
;exit:
;   R0-R2 preserved
;
SyncCodeAreasSWI ROUT
        Push    "lr"
        BL      SyncCodeAreas
        Pull    "lr"                    ; no error return possible
        B       SLVK

SyncCodeAreas
        TST     R0,#1                   ; range variant of SWI?
        BEQ     SyncCodeAreasFull

SyncCodeAreasRange
        Push    "r0-r2, lr"
        MOV     r0, r1
        ADD     r1, r2, #4                 ;exclusive end address
        LDR     r2, =ZeroPage
        LDRB    lr, [r2, #DCache_LineLen]
        SUB     lr, lr, #1
        ADD     r1, r1, lr                 ;rounding up end address
        MVN     lr, lr
        AND     r0, r0, lr                 ;cache line aligned
        AND     r1, r1, lr                 ;cache line aligned
        ARMop   IMB_Range,,,r2
        Pull    "r0-r2, pc"

SyncCodeAreasFull
      [ SMP
        Entry   "r0-r2"
        LDR     r2, =ZeroPage
        ARMop   Cache_RangeThreshold,,,r2
        CMP     r0, #-1
        BNE     %FT90
        ; ARMops are in SMP-friendly mode, which means we have no (SMP-friendly) global IMB available
        ; Just clean application space and the RMA?
        LDR     r1, [r2, #AplWorkSize]
        MOV     r0, #32*1024
        ARMop   IMB_Range,,,r2
        MOV     r0, #ChangeDyn_RMA
        SWI     XOS_ReadDynamicArea
        ADD     r1, r1, r0
        ARMop   IMB_Range,,,r2
        EXIT        
90
        ARMop   IMB_Full,,,r2
        EXIT
      |
        Entry   "r0"
        LDR     r0, =ZeroPage
        ARMop   IMB_Full,,,r0
        EXIT
      ]

        LTORG

        END
@


4.5
log
@Reimplement AMBControl ontop of the PMP system
Detail:
  With this set of changes, each AMB node is now the owner of a fake DANode which is linked to a PMP.
  From a user's perspective the behaviour of AMBControl is the same as before, but rewriting it to use PMPs internally offers the following (potential) benefits:
  * Reduction in the amount of code which messes with the CAM & page tables, simplifying future work/maintenance. Some of the AMB ops (grow, shrink) now just call through to OS_ChangeDynamicArea. However all of the old AMB routines were well-optimised, so to avoid a big performance hit for common operations not all of them have been removed (e.g. mapslot / mapsome). Maybe one day these optimal routines will be made available for use by regular PMP DAs.
  * Removal of the slow Service_MemoryMoved / Service_PagesSafe handlers that had to do page list fixup after the core kernel had reclaimed/moved pages. Since everything is a PMP, the kernel will now deal with this on behalf of AMB.
  * Removal of a couple of other slow code paths (e.g. Do_AMB_MakeUnsparse calls from OS_ChangeDynamicArea)
  * Potential for more flexible mapping of application space in future, e.g. sparse allocation of memory to the wimp slot
  * Simpler transition to an ASID-based task swapping scheme on ARMv6+?
  Other changes of note:
  * AMB_LazyMapIn switch has been fixed up to work correctly (i.e. turning it off now disables lazy task swapping and all associated code instead of producing a build error)
  * The DANode for the current app should be accessed via the GetAppSpaceDANode macro. This will either return the current AMB DANode, or AppSpaceDANode (if e.g. pre-Wimp). However be aware that AppSpaceDANode retains the legacy behaviour of having a base + size relative to &0, while the AMB DANodes (identifiable via the PMP flag) are sane and have their base + size relative to &8000.
  * Mostly-useless DebugAborts switch removed
  * AMBPhysBin (page number -> phys addr lookup table) removed. Didn't seem to give any tangible performance benefit, and was imposing hidden restrictions on memory usage (all phys RAM fragments in PhysRamTable must be multiple of 512k). And if it really was a good optimisation, surely it should have been applied to all areas of the kernel, not just AMB!
  Other potential future improvements:
  * Turn the fake DANodes into real dynamic areas, reducing the amount of special code needed in some places, but allow the DAs to be hidden from OS_DynamicArea 3 so that apps/users won't get too confused
  * Add a generic abort trapping system to PMPs/DAs (lazy task swapping abort handler is still a special case)
  File changes:
  - s/ARM600, s/VMSAv6, s/ExtraSWIs - Remove DebugAborts
  - s/ArthurSWIs - Remove AMB service call handler dispatch
  - s/ChangeDyn - AMB_LazyMapIn switch fixes. Add alternate internal entry points for some PMP ops to allow the DANode to be specified (used by AMB)
  - s/Exceptions - Remove DebugAborts, AMB_LazyMapIn switch fixes
  - s/Kernel - Define GetAppSpaceDANode macro, AMB_LazyMapIn switch fix
  - s/MemInfo - AMB_LazyMapIn switch fixes
  - s/AMBControl/AMB - Update GETs
  - s/AMBControl/Memory - Remove block size quantisation, AMB_BlockResize (page list blocks are now allocated by PMP code)
  - s/AMBControl/Options - Remove PhysBin definitions, AMBMIRegWords (moved to Workspace file), AMB_LimpidFreePool switch. Add AMB_Debug switch.
  - s/AMBControl/Workspace - Update AMBNode to contain an embedded DANode. Move AMBMIRegWords here from Options file.
  - s/AMBControl/allocate - Fake DA node initialisation
  - s/AMBControl/deallocate - Add debug output
  - s/AMBControl/growp, growshrink, mapslot, mapsome, shrinkp - Rewrite to use PMP ops where possible, add debug output
  - s/AMBControl/main - Remove PhysBin initialisation. Update the enumerate/mjs_info call.
  - s/AMBControl/memmap - Low-level memory mapping routines updated or rewritten as appropriate.
  - s/AMBControl/readinfo - Update to cope with DANode
  - s/AMBControl/service - Remove old service call handlers
  - s/AMBControl/handler - DA handler for responding to PMP calls from OS_ChangeDynamicArea; just calls through to growpages/shrinkpages as appropriate.
Admin:
  Tested on pretty much everything currently supported


Version 5.66. Tagged as 'Kernel-5_66'
@
text
@a233 2
        LDRB    lr, [r2, #Cache_Type]
        CMP     lr, #CT_ctype_WB_CR7_Lx ; DCache_LineLen lin or log?
a234 3
        MOVEQ   r2, #4
        MOVEQ   lr, r2, LSL lr
        LDREQ   r2, =ZeroPage
d244 21
a264 1
        Push    "r0, lr"
d267 2
a268 1
        Pull    "r0, pc"
@


4.5.2.1
log
@Initial SMP changes
Detail:
  This commit lays some of the groundwork for SMP support within the HAL, kernel, and OS.
  Makefile, hdr/HALDevice, hdr/DBellDevice - Add definitions for a doorbell HAL device, to allow CPU cores to signal each other via interrupts
  hdr/HALEntries - Repurpose HAL_Matrix and HAL_Touchscreen entry points for new SMP-related entry points. Add a couple of IRQ-related definitions.
  hdr/KernelWS - Boost MaxInterrupts to 256
  hdr/Options - Add new SMP build switch to control whether the kernel is built in SMP-friendly mode or not. SMP-friendly kernels should still run on single-core machines, but may behave slightly differently.
  s/ARMops - Make as many ARMops SMP-safe as possible, relying on hardware support for broadcasting of cache/TLB maintenance operations
  s/ExtraSWIs - Make SMP-friendly full OS_SynchroniseCodeAreas only sync application space and the RMA (full-cache IMB not really possible with SMP)
  s/NewIRQs - Update IRQ despatcher comments to (hopefully) reflect reality
  Docs/SMP/HAL, Docs/SMP/IRQ - Add documentation covering the new HAL calls and IRQ behaviour
Admin:
  Tested on Raspberry Pi 2, 3, OMAP4, iMX6


Version 5.86, 4.129.2.2. Tagged as 'Kernel-5_86-4_129_2_2'
@
text
@d249 1
a249 25
      [ SMP
        Entry   "r0-r2"
        LDR     r2, =ZeroPage
        ARMop   Cache_RangeThreshold,,,r2
        CMP     r0, #-1
        BNE     %FT90
        ; ARMops are in SMP-friendly mode
        ; Just clean application space and the RMA?
        GetAppSpaceDANode r1, r2
        LDR     r0, [r1, #DANode_Flags]
        TST     r0, #DynAreaFlags_PMP
        LDR     r1, [r1, #DANode_Size]
        ADDNE   r1, r1, #32*1024
        MOV     r0, #32*1024
        ARMop   IMB_Range,,,r2
        MOV     r0, #ChangeDyn_RMA
        SWI     XOS_ReadDynamicArea
        ADD     r1, r1, r0
        ARMop   IMB_Range,,,r2
        EXIT        
90
        ARMop   IMB_Full,,,r2
        EXIT
      |
        Entry   "r0"
d252 1
a252 2
        EXIT
      ]
@


4.5.2.2
log
@Fix global OS_SynchroniseCodeAreas. ARMop tweaks.
Detail:
  s/ExtraSWIs - Fix global OS_SynchroniseCodeAreas using the wrong appspace size; would have resulted in appspace only being partially synced if some pages were mapped out due to lazy swapping
  s/ARMops, s/ExtraSWIs, s/MemMap2 - Simplify code by making DCache_LineLen / ICache_LineLen store the actual line length values on ARMv7+ instead of the log2 values. Optimise SMP I-cache invalidation by allowing it to do a global invalidate. Ensure all ARMv7+ range checks use LO instead of NE, to avoid any problems with mismatched I/D line lengths (can't be sure the op range was rounded to the larger of the two)
Admin:
  Tested on iMX6


Version 5.88, 4.129.2.5. Tagged as 'Kernel-5_88-4_129_2_5'
@
text
@d234 2
d237 3
d255 1
a255 1
        ; ARMops are in SMP-friendly mode, which means we have no (SMP-friendly) global IMB available
d257 5
a261 1
        LDR     r1, [r2, #AplWorkSize]
@


4.4
log
@Tidy things up a bit
Detail:
  hdr/Options - Reduce the scope of SASTMhatbroken and InterruptDelay switches so that they're only enabled when we're building for ARMv4 targets
  s/ARM600, s/VMSAv6, s/ExtraSWIs, s/Exceptions - Move duplicate code out of s/ARM600 & s/VMSAv6 and into shared locations. OS_UpdateMEMC, the bulk of OS_MMUControl, and OS_SynchroniseCodeAreas are now located in s/ExtraSWIs. Meanwhile the data & prefetch abort veneers have been moved to the new file s/Exceptions. s/ARM600 and s/VMSAv6 are now almost purely to do with the different page table formats.
  s/GetAll - GET s/Exceptions
Admin:
  Tested on Raspberry Pi


Version 5.52. Tagged as 'Kernel-5_52'
@
text
@a255 4
 [ DebugAborts
        InsertDebugRoutines
 ]

@


4.3
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d77 183
@


4.2
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a16 2
 [ ProcessorVectors

a75 2
 ]

@


4.1
log
@Initial revision
@
text
@d44 1
a44 1
        ENTRY   "r3-r5"
d52 1
a52 1
        LDR     r5, =ProcVec_Start
@


4.1.8.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d44 1
a44 1
        Entry   "r3-r5"
@


4.1.8.2
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d52 1
a52 1
        LDR     r5, =ZeroPage+ProcVec_Start
@


4.1.8.1.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d52 1
a52 1
        LDR     r5, =ZeroPage+ProcVec_Start
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d17 2
d72 1
d74 1
d77 2
@


4.1.4.2
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a69 1
  [ InternationaliseCommonSilentErrors
a70 1
  ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

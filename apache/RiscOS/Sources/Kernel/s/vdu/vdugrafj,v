head	4.5;
access;
symbols
	Kernel-6_14:4.5
	Kernel-6_01-3:4.5
	Kernel-6_13:4.5
	Kernel-6_12:4.5
	Kernel-6_11:4.5
	Kernel-6_10:4.5
	Kernel-6_09:4.5
	Kernel-6_08-4_129_2_10:4.5
	Kernel-6_08-4_129_2_9:4.5
	Kernel-6_08:4.5
	Kernel-6_07:4.5
	Kernel-6_06:4.5
	Kernel-6_05-4_129_2_8:4.5
	Kernel-6_05:4.5
	Kernel-6_04:4.5
	Kernel-6_03:4.5
	Kernel-6_01-2:4.5
	Kernel-6_01-4_146_2_1:4.5
	Kernel-6_02:4.5
	Kernel-6_01-1:4.5
	Kernel-6_01:4.5
	Kernel-6_00:4.5
	Kernel-5_99:4.5
	Kernel-5_98:4.5
	Kernel-5_97-4_129_2_7:4.5
	Kernel-5_97:4.5
	Kernel-5_96:4.5
	Kernel-5_95:4.5
	Kernel-5_94:4.5
	Kernel-5_93:4.5
	Kernel-5_92:4.5
	Kernel-5_91:4.5
	Kernel-5_90:4.5
	Kernel-5_89-4_129_2_6:4.5
	Kernel-5_89:4.5
	Kernel-5_88-4_129_2_5:4.5
	Kernel-5_88-4_129_2_4:4.5
	Kernel-5_88:4.5
	Kernel-5_87:4.5
	Kernel-5_86-4_129_2_3:4.5
	Kernel-5_86-4_129_2_2:4.5
	Kernel-5_86-4_129_2_1:4.5
	Kernel-5_86:4.5
	SMP:4.5.0.2
	SMP_bp:4.5
	Kernel-5_85:4.5
	Kernel-5_54-1:4.5
	Kernel-5_84:4.5
	Kernel-5_83:4.5
	Kernel-5_82:4.5
	Kernel-5_81:4.5
	Kernel-5_80:4.5
	Kernel-5_79:4.5
	Kernel-5_78:4.5
	Kernel-5_77:4.5
	Kernel-5_76:4.5
	Kernel-5_75:4.5
	Kernel-5_74:4.5
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.5
	Kernel-5_64:4.5
	Kernel-5_63:4.5
	Kernel-5_62:4.5
	Kernel-5_61:4.5
	Kernel-5_60:4.5
	Kernel-5_59:4.5
	Kernel-5_58:4.5
	Kernel-5_57:4.5
	Kernel-5_56:4.5
	Kernel-5_55:4.5
	Kernel-5_54:4.5
	Kernel-5_53:4.5
	Kernel-5_52:4.5
	Kernel-5_51:4.5
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.2.2.6
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.6
	Kernel-5_35-4_79_2_326:4.2.2.6
	Kernel-5_35-4_79_2_325:4.2.2.6
	Kernel-5_35-4_79_2_324:4.2.2.6
	Kernel-5_35-4_79_2_323:4.2.2.6
	Kernel-5_35-4_79_2_322:4.2.2.6
	Kernel-5_35-4_79_2_321:4.2.2.6
	Kernel-5_35-4_79_2_320:4.2.2.6
	Kernel-5_35-4_79_2_319:4.2.2.6
	Kernel-5_35-4_79_2_318:4.2.2.6
	Kernel-5_35-4_79_2_317:4.2.2.6
	Kernel-5_35-4_79_2_316:4.2.2.6
	Kernel-5_35-4_79_2_315:4.2.2.6
	Kernel-5_35-4_79_2_314:4.2.2.6
	Kernel-5_35-4_79_2_313:4.2.2.6
	Kernel-5_35-4_79_2_312:4.2.2.6
	Kernel-5_35-4_79_2_311:4.2.2.6
	Kernel-5_35-4_79_2_310:4.2.2.6
	Kernel-5_35-4_79_2_309:4.2.2.6
	Kernel-5_35-4_79_2_308:4.2.2.6
	Kernel-5_35-4_79_2_307:4.2.2.6
	Kernel-5_35-4_79_2_306:4.2.2.6
	Kernel-5_35-4_79_2_305:4.2.2.6
	Kernel-5_35-4_79_2_304:4.2.2.6
	Kernel-5_35-4_79_2_303:4.2.2.6
	Kernel-5_35-4_79_2_302:4.2.2.6
	Kernel-5_35-4_79_2_301:4.2.2.6
	Kernel-5_35-4_79_2_300:4.2.2.6
	Kernel-5_35-4_79_2_299:4.2.2.6
	Kernel-5_35-4_79_2_298:4.2.2.6
	Kernel-5_35-4_79_2_297:4.2.2.6
	Kernel-5_35-4_79_2_296:4.2.2.6
	Kernel-5_35-4_79_2_295:4.2.2.6
	Kernel-5_35-4_79_2_294:4.2.2.6
	Kernel-5_35-4_79_2_293:4.2.2.5
	Kernel-5_35-4_79_2_292:4.2.2.5
	Kernel-5_35-4_79_2_291:4.2.2.5
	Kernel-5_35-4_79_2_290:4.2.2.5
	Kernel-5_35-4_79_2_289:4.2.2.5
	Kernel-5_35-4_79_2_288:4.2.2.5
	Kernel-5_35-4_79_2_287:4.2.2.5
	Kernel-5_35-4_79_2_286:4.2.2.5
	Kernel-5_35-4_79_2_285:4.2.2.5
	Kernel-5_35-4_79_2_284:4.2.2.5
	Kernel-5_35-4_79_2_283:4.2.2.5
	Kernel-5_35-4_79_2_282:4.2.2.5
	Kernel-5_35-4_79_2_281:4.2.2.5
	Kernel-5_35-4_79_2_280:4.2.2.5
	Kernel-5_35-4_79_2_279:4.2.2.5
	Kernel-5_35-4_79_2_278:4.2.2.5
	Kernel-5_35-4_79_2_277:4.2.2.5
	Kernel-5_35-4_79_2_276:4.2.2.5
	Kernel-5_35-4_79_2_275:4.2.2.5
	Kernel-5_35-4_79_2_274:4.2.2.5
	Kernel-5_35-4_79_2_273:4.2.2.5
	Kernel-5_35-4_79_2_272:4.2.2.5
	Kernel-5_35-4_79_2_271:4.2.2.5
	Kernel-5_35-4_79_2_270:4.2.2.5
	Kernel-5_35-4_79_2_269:4.2.2.5
	Kernel-5_35-4_79_2_268:4.2.2.5
	Kernel-5_35-4_79_2_267:4.2.2.5
	Kernel-5_35-4_79_2_266:4.2.2.5
	Kernel-5_35-4_79_2_265:4.2.2.5
	Kernel-5_35-4_79_2_264:4.2.2.5
	Kernel-5_35-4_79_2_263:4.2.2.5
	Kernel-5_35-4_79_2_262:4.2.2.5
	Kernel-5_35-4_79_2_261:4.2.2.5
	Kernel-5_35-4_79_2_260:4.2.2.5
	Kernel-5_35-4_79_2_259:4.2.2.5
	Kernel-5_35-4_79_2_258:4.2.2.5
	Kernel-5_35-4_79_2_257:4.2.2.5
	Kernel-5_35-4_79_2_256:4.2.2.5
	Kernel-5_35-4_79_2_255:4.2.2.5
	Kernel-5_35-4_79_2_254:4.2.2.5
	Kernel-5_35-4_79_2_253:4.2.2.5
	Kernel-5_35-4_79_2_252:4.2.2.5
	Kernel-5_35-4_79_2_251:4.2.2.5
	Kernel-5_35-4_79_2_250:4.2.2.5
	Kernel-5_35-4_79_2_249:4.2.2.5
	Kernel-5_35-4_79_2_248:4.2.2.5
	Kernel-5_35-4_79_2_247:4.2.2.5
	Kernel-5_35-4_79_2_246:4.2.2.5
	Kernel-5_35-4_79_2_245:4.2.2.5
	Kernel-5_35-4_79_2_244:4.2.2.5
	Kernel-5_35-4_79_2_243:4.2.2.5
	Kernel-5_35-4_79_2_242:4.2.2.5
	Kernel-5_35-4_79_2_241:4.2.2.5
	Kernel-5_35-4_79_2_240:4.2.2.5
	Kernel-5_35-4_79_2_239:4.2.2.5
	Kernel-5_35-4_79_2_238:4.2.2.5
	Kernel-5_35-4_79_2_237:4.2.2.4
	Kernel-5_35-4_79_2_236:4.2.2.4
	Kernel-5_35-4_79_2_235:4.2.2.4
	Kernel-5_35-4_79_2_234:4.2.2.4
	Kernel-5_35-4_79_2_233:4.2.2.4
	Kernel-5_35-4_79_2_232:4.2.2.4
	Kernel-5_35-4_79_2_231:4.2.2.4
	Kernel-5_35-4_79_2_230:4.2.2.4
	Kernel-5_35-4_79_2_229:4.2.2.4
	Kernel-5_35-4_79_2_228:4.2.2.4
	Kernel-5_35-4_79_2_227:4.2.2.4
	Kernel-5_35-4_79_2_226:4.2.2.4
	Kernel-5_35-4_79_2_225:4.2.2.4
	Kernel-5_35-4_79_2_224:4.2.2.4
	Kernel-5_35-4_79_2_223:4.2.2.4
	Kernel-5_35-4_79_2_222:4.2.2.4
	Kernel-5_35-4_79_2_221:4.2.2.4
	Kernel-5_35-4_79_2_220:4.2.2.4
	Kernel-5_35-4_79_2_219:4.2.2.4
	Kernel-5_35-4_79_2_218:4.2.2.4
	Kernel-5_35-4_79_2_217:4.2.2.4
	Kernel-5_35-4_79_2_216:4.2.2.4
	Kernel-5_35-4_79_2_215:4.2.2.4
	Kernel-5_35-4_79_2_214:4.2.2.4
	Kernel-5_35-4_79_2_213:4.2.2.4
	Kernel-5_35-4_79_2_212:4.2.2.4
	Kernel-5_35-4_79_2_211:4.2.2.4
	Kernel-5_35-4_79_2_210:4.2.2.4
	Kernel-5_35-4_79_2_209:4.2.2.4
	Kernel-5_35-4_79_2_208:4.2.2.4
	Kernel-5_35-4_79_2_207:4.2.2.4
	Kernel-5_35-4_79_2_206:4.2.2.4
	Kernel-5_35-4_79_2_205:4.2.2.4
	Kernel-5_35-4_79_2_204:4.2.2.4
	Kernel-5_35-4_79_2_203:4.2.2.4
	Kernel-5_35-4_79_2_202:4.2.2.4
	Kernel-5_35-4_79_2_201:4.2.2.4
	Kernel-5_35-4_79_2_200:4.2.2.4
	Kernel-5_35-4_79_2_199:4.2.2.4
	Kernel-5_35-4_79_2_198:4.2.2.4
	Kernel-5_35-4_79_2_197:4.2.2.4
	Kernel-5_35-4_79_2_196:4.2.2.4
	Kernel-5_35-4_79_2_195:4.2.2.4
	Kernel-5_35-4_79_2_194:4.2.2.4
	Kernel-5_35-4_79_2_193:4.2.2.3
	Kernel-5_35-4_79_2_192:4.2.2.3
	Kernel-5_35-4_79_2_191:4.2.2.3
	Kernel-5_35-4_79_2_190:4.2.2.3
	Kernel-5_35-4_79_2_189:4.2.2.3
	Kernel-5_35-4_79_2_188:4.2.2.3
	Kernel-5_35-4_79_2_187:4.2.2.3
	Kernel-5_35-4_79_2_186:4.2.2.3
	Kernel-5_35-4_79_2_185:4.2.2.3
	Kernel-5_35-4_79_2_184:4.2.2.3
	Kernel-5_35-4_79_2_183:4.2.2.3
	Kernel-5_35-4_79_2_182:4.2.2.3
	Kernel-5_35-4_79_2_181:4.2.2.3
	Kernel-5_35-4_79_2_180:4.2.2.3
	Kernel-5_35-4_79_2_179:4.2.2.3
	Kernel-5_35-4_79_2_178:4.2.2.3
	Kernel-5_35-4_79_2_177:4.2.2.3
	Kernel-5_35-4_79_2_176:4.2.2.3
	Kernel-5_35-4_79_2_175:4.2.2.3
	Kernel-5_35-4_79_2_174:4.2.2.3
	Kernel-5_35-4_79_2_173:4.2.2.2
	Kernel-5_35-4_79_2_172:4.2.2.2
	Kernel-5_35-4_79_2_171:4.2.2.2
	Kernel-5_35-4_79_2_170:4.2.2.2
	Kernel-5_35-4_79_2_169:4.2.2.2
	Kernel-5_35-4_79_2_168:4.2.2.2
	Kernel-5_35-4_79_2_167:4.2.2.2
	Kernel-5_35-4_79_2_166:4.2.2.2
	Kernel-5_35-4_79_2_165:4.2.2.2
	RPi_merge:4.2.2.2
	Kernel-5_35-4_79_2_147_2_23:4.2.2.2
	Kernel-5_35-4_79_2_147_2_22:4.2.2.2
	Kernel-5_35-4_79_2_147_2_21:4.2.2.2
	Kernel-5_35-4_79_2_147_2_20:4.2.2.2
	Kernel-5_35-4_79_2_147_2_19:4.2.2.2
	Kernel-5_35-4_79_2_147_2_18:4.2.2.2
	Kernel-5_35-4_79_2_164:4.2.2.2
	Kernel-5_35-4_79_2_163:4.2.2.2
	Kernel-5_35-4_79_2_147_2_17:4.2.2.2
	Kernel-5_35-4_79_2_147_2_16:4.2.2.2
	Kernel-5_35-4_79_2_147_2_15:4.2.2.2
	Kernel-5_35-4_79_2_162:4.2.2.2
	Kernel-5_35-4_79_2_161:4.2.2.2
	Kernel-5_35-4_79_2_147_2_14:4.2.2.2
	Kernel-5_35-4_79_2_147_2_13:4.2.2.2
	Kernel-5_35-4_79_2_160:4.2.2.2
	Kernel-5_35-4_79_2_159:4.2.2.2
	Kernel-5_35-4_79_2_158:4.2.2.2
	Kernel-5_35-4_79_2_157:4.2.2.2
	Kernel-5_35-4_79_2_156:4.2.2.2
	Kernel-5_35-4_79_2_147_2_12:4.2.2.2
	Kernel-5_35-4_79_2_147_2_11:4.2.2.2
	Kernel-5_35-4_79_2_155:4.2.2.2
	Kernel-5_35-4_79_2_147_2_10:4.2.2.2
	Kernel-5_35-4_79_2_154:4.2.2.2
	Kernel-5_35-4_79_2_153:4.2.2.2
	Kernel-5_35-4_79_2_147_2_9:4.2.2.2
	Kernel-5_35-4_79_2_152:4.2.2.2
	Kernel-5_35-4_79_2_151:4.2.2.2
	Kernel-5_35-4_79_2_147_2_8:4.2.2.2
	Kernel-5_35-4_79_2_147_2_7:4.2.2.2
	Kernel-5_35-4_79_2_150:4.2.2.2
	Kernel-5_35-4_79_2_147_2_6:4.2.2.2
	Kernel-5_35-4_79_2_147_2_5:4.2.2.2
	Kernel-5_35-4_79_2_149:4.2.2.2
	Kernel-5_35-4_79_2_147_2_4:4.2.2.2
	Kernel-5_35-4_79_2_147_2_3:4.2.2.2
	Kernel-5_35-4_79_2_148:4.2.2.2
	Kernel-5_35-4_79_2_147_2_2:4.2.2.2
	Kernel-5_35-4_79_2_147_2_1:4.2.2.2
	RPi:4.2.2.2.0.2
	RPi_bp:4.2.2.2
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2.2.1.2.1
	alees_Kernel_dev:4.2.2.1.2.1.0.2
	alees_Kernel_dev_bp:4.2.2.1.2.1
	Kernel-5_35-4_79_2_147:4.2.2.2
	Kernel-5_35-4_79_2_146:4.2.2.2
	Kernel-5_35-4_79_2_145:4.2.2.2
	Kernel-5_35-4_79_2_144:4.2.2.2
	Kernel-5_35-4_79_2_143:4.2.2.2
	Kernel-5_35-4_79_2_142:4.2.2.2
	Kernel-5_35-4_79_2_141:4.2.2.2
	Kernel-5_35-4_79_2_140:4.2.2.2
	Kernel-5_35-4_79_2_139:4.2.2.2
	Kernel-5_35-4_79_2_138:4.2.2.2
	Kernel-5_35-4_79_2_137:4.2.2.2
	Kernel-5_35-4_79_2_136:4.2.2.2
	Kernel-5_35-4_79_2_135:4.2.2.2
	Kernel-5_35-4_79_2_134:4.2.2.2
	Kernel-5_35-4_79_2_133:4.2.2.2
	Kernel-5_35-4_79_2_132:4.2.2.2
	Kernel-5_35-4_79_2_131:4.2.2.2
	Kernel-5_35-4_79_2_130:4.2.2.2
	Kernel-5_35-4_79_2_129:4.2.2.2
	Kernel-5_35-4_79_2_128:4.2.2.2
	Kernel-5_35-4_79_2_127:4.2.2.2
	Kernel-5_35-4_79_2_126:4.2.2.2
	Kernel-5_35-4_79_2_125:4.2.2.2
	Kernel-5_35-4_79_2_124:4.2.2.2
	Kernel-5_35-4_79_2_123:4.2.2.2
	Cortex_merge:4.2.2.1.2.1
	Kernel-5_35-4_79_2_122:4.2.2.1
	Kernel-5_35-4_79_2_98_2_54:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_53:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_52:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_51:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_50:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_49:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_48:4.2.2.1.2.1
	Kernel-5_35-4_79_2_121:4.2.2.1
	Kernel-5_35-4_79_2_98_2_47:4.2.2.1.2.1
	Kernel-5_35-4_79_2_120:4.2.2.1
	Kernel-5_35-4_79_2_98_2_46:4.2.2.1.2.1
	Kernel-5_35-4_79_2_119:4.2.2.1
	Kernel-5_35-4_79_2_98_2_45:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_44:4.2.2.1.2.1
	Kernel-5_35-4_79_2_118:4.2.2.1
	Kernel-5_35-4_79_2_98_2_43:4.2.2.1.2.1
	Kernel-5_35-4_79_2_117:4.2.2.1
	Kernel-5_35-4_79_2_116:4.2.2.1
	Kernel-5_35-4_79_2_98_2_42:4.2.2.1.2.1
	Kernel-5_35-4_79_2_115:4.2.2.1
	Kernel-5_35-4_79_2_98_2_41:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_40:4.2.2.1.2.1
	Kernel-5_35-4_79_2_114:4.2.2.1
	Kernel-5_35-4_79_2_98_2_39:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_38:4.2.2.1.2.1
	Kernel-5_35-4_79_2_113:4.2.2.1
	Kernel-5_35-4_79_2_112:4.2.2.1
	Kernel-5_35-4_79_2_98_2_37:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_36:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_35:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_34:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_33:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_32:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_31:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_30:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_29:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_28:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_27:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_26:4.2.2.1.2.1
	Kernel-5_35-4_79_2_111:4.2.2.1
	Kernel-5_35-4_79_2_98_2_25:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_24:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_23:4.2.2.1.2.1
	Kernel-5_35-4_79_2_110:4.2.2.1
	Kernel-5_35-4_79_2_98_2_22:4.2.2.1.2.1
	Kernel-5_35-4_79_2_109:4.2.2.1
	Kernel-5_35-4_79_2_98_2_21:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_20:4.2.2.1.2.1
	Kernel-5_35-4_79_2_108:4.2.2.1
	Kernel-5_35-4_79_2_107:4.2.2.1
	Kernel-5_35-4_79_2_98_2_19:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_18:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_17:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_16:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_15:4.2.2.1.2.1
	Kernel-5_35-4_79_2_106:4.2.2.1
	Kernel-5_35-4_79_2_105:4.2.2.1
	Kernel-5_35-4_79_2_104:4.2.2.1
	Kernel-5_35-4_79_2_98_2_14:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_13:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_12:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_11:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_10:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_9:4.2.2.1.2.1
	Kernel-5_35-4_79_2_103:4.2.2.1
	Kernel-5_35-4_79_2_102:4.2.2.1
	Kernel-5_35-4_79_2_98_2_8:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_7:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_6:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_5:4.2.2.1.2.1
	Kernel-5_35-4_79_2_98_2_4:4.2.2.1
	Kernel-5_35-4_79_2_101:4.2.2.1
	Kernel-5_35-4_79_2_100:4.2.2.1
	Kernel-5_35-4_79_2_99:4.2.2.1
	Kernel-5_35-4_79_2_98_2_3:4.2.2.1
	Kernel-5_35-4_79_2_98_2_2:4.2.2.1
	Kernel-5_35-4_79_2_98_2_1:4.2.2.1
	Cortex:4.2.2.1.0.2
	Cortex_bp:4.2.2.1
	Kernel-5_35-4_79_2_98:4.2.2.1
	Kernel-5_35-4_79_2_97:4.2.2.1
	Kernel-5_35-4_79_2_96:4.2.2.1
	Kernel-5_35-4_79_2_95:4.2.2.1
	Kernel-5_35-4_79_2_94:4.2.2.1
	Kernel-5_35-4_79_2_93:4.2.2.1
	Kernel-5_35-4_79_2_92:4.2.2.1
	Kernel-5_35-4_79_2_91:4.2.2.1
	Kernel-5_35-4_79_2_90:4.2.2.1
	Kernel-5_35-4_79_2_89:4.2.2.1
	Kernel-5_35-4_79_2_88:4.2.2.1
	Kernel-5_35-4_79_2_87:4.2.2.1
	Kernel-5_35-4_79_2_86:4.2.2.1
	Kernel-5_35-4_79_2_85:4.2.2.1
	Kernel-5_35-4_79_2_84:4.2.2.1
	Kernel-5_35-4_79_2_83:4.2.2.1
	Kernel-5_35-4_79_2_82:4.2.2.1
	Kernel-5_35-4_79_2_81:4.2.2.1
	Kernel-5_35-4_79_2_80:4.2.2.1
	Kernel-5_35-4_79_2_79:4.2.2.1
	Kernel-5_35-4_79_2_78:4.2.2.1
	Kernel-5_35-4_79_2_77:4.2.2.1
	RO_5_07:4.2.2.1
	Kernel-5_35-4_79_2_76:4.2.2.1
	Kernel-5_35-4_79_2_75:4.2.2.1
	Kernel-5_35-4_79_2_74:4.2.2.1
	Kernel-5_35-4_79_2_73:4.2.2.1
	Kernel-5_35-4_79_2_72:4.2.2.1
	Kernel-5_35-4_79_2_71:4.2.2.1
	Kernel-5_35-4_79_2_70:4.2.2.1
	Kernel-5_35-4_79_2_69:4.2.2.1
	Kernel-5_35-4_79_2_68:4.2.2.1
	Kernel-5_35-4_79_2_67:4.2.2.1
	Kernel-5_35-4_79_2_66:4.2.2.1
	Kernel-5_35-4_79_2_65:4.2.2.1
	Kernel-5_35-4_79_2_64:4.2.2.1
	Kernel-5_35-4_79_2_63:4.2.2.1
	Kernel-5_35-4_79_2_62:4.2.2.1
	Kernel-5_35-4_79_2_61:4.2.2.1
	Kernel-5_35-4_79_2_59:4.2.2.1
	Kernel-5_35-4_79_2_58:4.2.2.1
	Kernel-5_35-4_79_2_57:4.2.2.1
	Kernel-5_35-4_79_2_56:4.2.2.1
	Kernel-5_35-4_79_2_55:4.2.2.1
	Kernel-5_35-4_79_2_54:4.2.2.1
	Kernel-5_35-4_79_2_53:4.2.2.1
	Kernel-5_35-4_79_2_52:4.2.2.1
	Kernel-5_35-4_79_2_51:4.2.2.1
	Kernel-5_35-4_79_2_50:4.2.2.1
	Kernel-5_35-4_79_2_49:4.2.2.1
	Kernel-5_35-4_79_2_48:4.2.2.1
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.4
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2.2.1
	Kernel-5_35-4_79_2_46:4.2.2.1
	Kernel-5_35-4_79_2_45:4.2.2.1
	Kernel-5_35-4_79_2_44:4.2.2.1
	Kernel-5_35-4_79_2_25_2_2:4.2.2.1
	Kernel-5_35-4_79_2_43:4.2.2.1
	Kernel-5_35-4_79_2_42:4.2.2.1
	Kernel-5_35-4_79_2_41:4.2.2.1
	Kernel-5_35-4_79_2_40:4.2.2.1
	Kernel-5_35-4_79_2_39:4.2.2.1
	Kernel-5_35-4_79_2_38:4.2.2.1
	Kernel-5_35-4_79_2_37:4.2.2.1
	Kernel-5_35-4_79_2_36:4.2.2.1
	Kernel-5_35-4_79_2_35:4.2.2.1
	Kernel-5_35-4_79_2_34:4.2.2.1
	Kernel-5_35-4_79_2_33:4.2.2.1
	Kernel-5_35-4_79_2_32:4.2.2.1
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2.2.1
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2.2.1
	Kernel-5_35-4_79_2_30:4.2.2.1
	Kernel-5_35-4_79_2_29:4.2.2.1
	Kernel-5_35-4_79_2_28:4.2.2.1
	Kernel-5_35-4_79_2_27:4.2.2.1
	Kernel-5_35-4_79_2_26:4.2.2.1
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2.2.1
	Kernel-5_35-4_79_2_24:4.2.2.1
	Kernel-5_35-4_79_2_23:4.2.2.1
	Kernel-5_35-4_79_2_22:4.2.2.1
	Kernel-5_35-4_79_2_21:4.2.2.1
	Kernel-5_35-4_79_2_20:4.2.2.1
	Kernel-5_35-4_79_2_19:4.2.2.1
	Kernel-5_35-4_79_2_18:4.2.2.1
	Kernel-5_35-4_79_2_17:4.2.2.1
	Kernel-5_35-4_79_2_16:4.2.2.1
	Kernel-5_35-4_79_2_15:4.2.2.1
	Kernel-5_35-4_79_2_14:4.2.2.1
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2.2.1
	Kernel-5_35-4_79_2_12:4.2.2.1
	Kernel-5_35-4_79_2_11:4.2.2.1
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2.2.1
	Kernel-5_35-4_79_2_9:4.2.2.1
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2.2.1
	Kernel-5_35-4_79_2_7:4.2.2.1
	Kernel-5_35-4_79_2_6:4.2.2.1
	Kernel-5_35-4_79_2_5:4.2.2.1
	Kernel-5_35-4_79_2_4:4.2.2.1
	Kernel-5_35-4_79_2_3:4.2.2.1
	Kernel-5_35-4_79_2_2:4.2.2.1
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2.2.1
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches;
next	4.4;
commitid	skOEjp3ipLHx6xcz;

4.4
date	2016.06.30.20.29.05;	author jlee;	state Exp;
branches;
next	4.3;
commitid	lMnWzoE9eJz3Wwcz;

4.3
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.04.04.14.27.41;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.39;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.09.15.12.38.02;	author kbracey;	state Exp;
branches
	4.2.2.1.2.1;
next	4.2.2.2;

4.2.2.2
date	2011.11.26.21.11.28;	author jlee;	state Exp;
branches;
next	4.2.2.3;
commitid	cI3W0zbtALQG6TIv;

4.2.2.3
date	2012.10.28.16.51.52;	author rsprowson;	state Exp;
branches;
next	4.2.2.4;
commitid	ruXZqdTJKJ85Qaqw;

4.2.2.4
date	2013.08.06.22.43.10;	author jlee;	state Exp;
branches;
next	4.2.2.5;
commitid	TOIaeUf2Q4rBIr0x;

4.2.2.5
date	2014.09.18.21.52.55;	author jlee;	state Exp;
branches;
next	4.2.2.6;
commitid	6ckSnTJtm4MjkSQx;

4.2.2.6
date	2015.10.12.21.33.35;	author jlee;	state Exp;
branches;
next	;
commitid	GP0OA8o3gtfsIREy;

4.2.2.1.2.1
date	2009.05.10.18.49.18;	author jlee;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.39;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.22;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.44;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.18;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.47;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduGrafJ
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - Sprite stuff
;
; Author R C Manby
; Date   10.11.86
;

; *****************************************************************************
;
;       GetSpriteUserCoords - Pick up area of screen as sprite using
;                             given external coordinates
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite name
;       R3 = 0 => exclude palette data
;            1 => include palette data
;       R4,R5 = (X,Y) EXTERNAL coordinates of one corner of box
;       R6,R7 = (X,Y) EXTERNAL coordinates of opposite corner of box
;

GetSpriteUserCoords ROUT
        Push    "R1-R3, R14"
        ADD     R8, WsPtr, #GCsX
        LDMIA   R8, {R9,R10}            ; preserve GCsX,GCsY around EIG

        MOV     R0, R4
        MOV     R1, R5
        MOV     R2, #4                  ; indicate absolute coord
        BL      EIG
        MOV     R4, R0
        MOV     R5, R1

        MOV     R0, R6
        MOV     R1, R7
        BL      EIG
        MOV     R6, R0
        MOV     R7, R1

        STMIA   R8, {R9,R10}            ; restore GcsX,GCsY
        Pull    "R1-R3, R14"
        B       GetSpr05

; *****************************************************************************
;
;       GetSprite - Pick up area of screen bounded by OldCs and GCsI as sprite
;
;       External routine + GetSpr05 called by GetSpriteUserCoords
;        (also external)
;
; in:   R1 -> sprite area
;       R2 -> sprite name
;       R3 = 0 => exclude palette data
;            1 => include palette data
;       OldCsX,OldCsY = (X,Y) INTERNAL coordinates of one corner of box
;       GCsIX, GCsIY  = (X,Y) INTERNAL coordinates of opposite corner of box
;

GetSprite ROUT
        ADD     R4, WsPtr, #OldCsX      ; pickup area given by OldCs
        LDMIA   R4, {R4-R7}             ; and GCsIX
GetSpr05
        Push    R14
      [ {TRUE}
        GraphicsMode R0
        BNE     %FT70
      |
        LDR     R0, [WsPtr, #NPix]
        TEQ     R0, #0
        BEQ     %FT70                   ; quit with error if not graphics mode
      ]

        KillSpChoosePtr

        SortT   R4, R6, R8              ; R4 ,R5, R6 ,R7 N.B. BotL &
        SortT   R5, R7, R8              ; sL ,sB, sR ,sT      TopR

        LDR     R8, [WsPtr, #YWindLimit]
        SUB     R8, R8, R7              ; use inverted sT as index
        AND     R8, R8, #7              ; into EcfPatternTable
        STR     R8, [WsPtr, #SGetEcfIndx]

        LDR     R0, [WsPtr, #ModeNo]
        STR     R0, [WsPtr, #SGetMode]  ; needs setting up before CreateHeader

        Push    R2
        BL      SpriteCtrlBlk
        BVC     %FT90           ; sprite already exists, so be clever
        Pull    R2              ; restore name pointer

                                ;      R1     ,R2     ,R3       ,R4,R5,R6,R7
        BL      CreateHeader    ; In : AreaPtr,NamePtr,Palette  ,sl,sb,sr,st
                                ; Out:                 ImageSize,lx,ty,
        BVS     %FT80           ; Error, (no room/not a graphics mode)

        BL      GetSpriteData

; R1 -> sprite area, R2 -> sprite
; now add the sprite to the sprite area

        LDR     R3, [R2, #spNext]       ; total size of new sprite
        LDMIA   R1, {R4-R7}             ; saEnd,saNumber,saFirst,saFree
        ADD     R5, R5, #1
        ADD     R7, R7, R3
        STMIA   R1, {R4-R7}

; have we made a new format sprite ? if so no left hand wastage is allowed.

        LDR     R3, [R2, #spMode]
        CMP     R3, #256

        BLCS    RemoveLeftHandWastage

        BL      SelectSprite
        SWI     XOS_RestoreCursors
        Pull    R14
        RETURNVC

70
        ADRL    R0, SpriteErr_NotGraphics
      [ International
        BL      TranslateError
      ]
75
        STR     R0, [WsPtr, #RetnReg0]
80                                      ; return point after an error
        Pull    R14
        RETURNVS

; come here if sprite already exists
; we want to extend or reduce existing sprite as necessary

90
        ADD     R13, R13, #4            ; throw away stacked name ptr
        LDR     R14, [WsPtr, #VduSprite]
        TEQ     R14, R2                 ; if same as vdu output sprite
        ADREQL  R0, SpriteErr_SpriteIsCurrentDest
      [ International
        BLEQ    TranslateError
      ]
        BEQ     %BT75                   ; then error

        ADR     R14, %FT95
        Push    "R1, R14"
        ADD     R8, WsPtr, #NameBuf
        LDMIA   R8, {R9-R11}            ; load 3 words of name
        ADD     R8, WsPtr, #SGetName
        STMIA   R8, {R9-R11}            ; and store in SGetName

        Push    "R1, R2, R3"            ; save sprite area, sprite, palflag
        BL      PreCreateHeader
        Pull    "R1, R2"                ; restore sprite area ptr + sprite ptr
        BVS     %FT93
                                        ; R4 = total size of sprite
        Push    R4                      ; save new size of sprite
        LDR     R0, [R2, #spNext]
        SUBS    R3, R4, R0              ; compare required size with existing
        MOV     R3, R3, ASR #2          ; no. of words to extend/reduce by
        BEQ     %FT94                   ; [is exactly right already]
        BHI     %FT92                   ; need to extend sprite

; need to reduce sprite

        RSB     R3, R3, #0              ; no. of words to reduce by
        LDR     R4, [R2, #spImage]
        SUB     R4, R0, R4              ; offset from Image to Next
        SUB     R4, R4, R3, LSL #2      ; dest. start as offset from spImage
        BL      RemoveWords
        RSB     R3, R3, #0              ; put R3 back to no. of words to extend
        B       %FT94

; need to extend sprite

92
        BL      ExtendSpriteByR3
93
        ADDVS   R13, R13, #4*4          ; junk size, palflag,
                                        ; sprite area, fake return address
        BVS     %BT80                   ; no room to extend sprite
94
        Pull    R4                      ; restore new size of sprite
        B       PostCreateHeader

; come back to here after PostCreateHeader exits
; R1 -> sprite area, R2 -> sprite, R3 = no. of words to extend by

95
; Enable interrupts here for 32bit machines
        WritePSRc SVC_mode, R14
        BL      GetSpriteData
        BL      SelectSprite

; have we made a new format sprite ? if so no left hand wastage is allowed.

        LDR     R3, [R2, #spMode]
        CMP     R3, #256
        BLCS    RemoveLeftHandWastage

        SWI     XOS_RestoreCursors
        Pull    R14
        RETURNVC

; *****************************************************************************

GetSpriteData ROUT
        Push    "R1-R3, R14"
        SWI     XOS_RemoveCursors
        MOV     R0, R4
        MOV     R1, R5
        BL      ScreenAddr
        MOV     R0, R2                          ; screen addr of TopL of area
        LDMIA   R13, {R4,R5}                    ; R4->sprite area, R5->sprite
        LDR     R1, [WsPtr, #SGetImage]
        ADD     R1, R1, R5                      ; memory address
        LDR     R2, [WsPtr, #SGetWidth]
        ADD     R2, R2, #1                      ; sprite width (words)
        LDR     R3, [WsPtr, #SGetHeight]        ; height
        ADD     R3, R3, #1

        LDR     R8, [WsPtr, #SGetTopMargin]     ; gap above window (rows)
        LDR     R9, [WsPtr, #SGetBotMargin]     ;     below        (rows)
        LDR     R10, [WsPtr, #SGetLWrdMargin]   ;     left of      (words)
        LDR     R11, [WsPtr, #SGetRWrdMargin]   ;     right of     (words)

        SUB     R2, R2, R10
        SUBS    R2, R2, R11             ; number words in window per scanline
        BLEQ    PaintSprite             ; Left or Right of window
        BEQ     %FT60

        SUB     R3, R3, R8
        SUBS    R3, R3, R9              ; number of rows in window
        BLEQ    PaintSprite             ; above or below window
        BEQ     %FT60

        LDR     R14, [WsPtr, #LineLength] ; offset from RHend of row to LHend
        SUB     R14, R14, R2, LSL #2    ; of next row
        STR     R14, [WsPtr, #SGetRowOfst]

        LDR     R11, [WsPtr, #SGetLBitMargin]
        MOV     R5, #&FFFFFFFF
        MOV     R5, R5, LSL R11         ; LmarginMask

        LDR     R11, [WsPtr, #SGetRBitMargin]
        MOV     R6, #&FFFFFFFE
        MVN     R6, R6, LSL R11         ; RmarginMask

        SUBS    R2, R2, #1
        STR     R2, [WsPtr, #SGetColWCnt] ; if only one word in window per row
        ANDEQ   R5, R5, R6              ; then combine L&R masks
        MOVEQ   R6, R5
        STR     R5, [WsPtr, #SGetLBitMargin]
        STR     R6, [WsPtr, #SGetRBitMargin]

        LDR     R5, [WsPtr, #SGetTopMargin]     ; paint TopMargin (if any)
        CMP     R5, #0
        BLNE    PaintBlock

; R0    ,R1    ,R2     ,R3    ,R4      ..       R11
; ScrAdr,MemAdr,ColWCnt,RowCnt,{8 words from screen},

10
        LDR     R4, [WsPtr, #SGetLWrdMargin] ; paint 1 row of LHmargin (if any)
        CMP     R4, #0
        BLNE    PaintRow        ; on exit R6 holds word of BgEcf, if not called
                                ; R6 is corrupt, but it doesn't matter
        LDR     R2, [WsPtr, #SGetColWCnt] ; on screen word count ( >0 in words)
        LDR     R5, [WsPtr, #SGetLBitMargin]
        LDR     R4, [R0], #4    ; get first on screen word
        AND     R4, R4, R5
        BIC     R6, R6, R5      ; Write BgEcf (or nonsense) to out of window
        ORR     R4, R4, R6      ; pixels
        STR     R4, [R1], #4
        SUBS    R2, R2, #1
        BLT     %FT50           ; if all plotted

        SUBS    R2, R2, #8      ; try for 8 words
20
        LDMCSIA R0!, {R4-R11}   ; copy 8 words from screen to memory
        STMCSIA R1!, {R4-R11}
        SUBCSS  R2, R2, #8
        BCS     %BT20
30
        ADDS    R2, R2, #8
        LDR     R6, [WsPtr,#SGetEcfIndx]
        ADD     R6, WsPtr, R6, LSL #2
        LDR     R6, [R6, #BgEcf]        ; BgEcf for this scanline
        LDR     R5, [WsPtr,#SGetRBitMargin]
        BIC     R6, R6, R5
40
        LDR     R4, [R0], #4
        ANDEQ   R4, R4, R5
        ORREQ   R4, R4, R6
        STR     R4, [R1], #4
        SUBS    R2, R2, #1
        BCS     %BT40
50
        LDR     R4, [WsPtr, #SGetRWrdMargin]
        CMP     R4, #0
        BLNE    PaintRow

        LDR     R2, [WsPtr, #SGetColWCnt]
        LDR     R4, [WsPtr, #SGetRowOfst]
        LDR     R5, [WsPtr,#SGetEcfIndx]
        ADD     R0, R0, R4                      ; offset ScrAdr to next row
        ADD     R5, R5, #1
        AND     R5, R5, #7
        STR     R5, [WsPtr, #SGetEcfIndx]       ; update EcfIndx to next row
        SUBS    R3, R3, #1
        BGT     %BT10                           ; do next screen line

        LDR     R5, [WsPtr, #SGetBotMargin]     ; paint bottom margin (if any)
        CMP     R5, #0
        BLNE    PaintBlock
60
        Pull    "R1-R3, PC"


; *****************************************************************************
;
;       PaintSprite - Paint the whole of the sprite in background colour
;
;       Internal routine, called by GetSprite when all area is outside window
;
; in:   R1 -> first byte in sprite
;

PaintSprite ROUT
        LDR     R5, [WsPtr, #SGetHeight]
        ADD     R5, R5, #1              ; R5 = number of rows in sprite

; and drop thru to ...

; *****************************************************************************
;
;       PaintBlock - Paint a number of rows of the sprite in background colour
;
;       Internal routine, called by GetSprite to do area above and below window
;        and dropped thru to by PaintSprite
;
; in:   R1 -> start of first row to paint
;       R5 = number of rows to do
;
; out:  Flags preserved

PaintBlock ROUT
        MRS     R4, CPSR
        Push    "R4,R14"
        LDR     R4, [WsPtr, #SGetWidth]
        ADD     R4, R4, #1
10
        BL      PaintRow
        LDR     R6, [WsPtr, #SGetEcfIndx]
        ADD     R6, R6, #1
        AND     R6, R6, #7
        STR     R6, [WsPtr, #SGetEcfIndx]
        SUBS    R5, R5, #1
        BNE     %BT10

        Pull    "R4,R14"
        MSR     CPSR_f, R4
        MOV     PC,R14

; *****************************************************************************
;
;       PaintRow - Paint part of a row in sprite with background colour
;
;       Internal routine, called by GetSprite to do areas left+right of window
;        and by PaintBlock
;
; in:   R1 -> first word to paint
;       R4 = number of words to paint
;
; out:  R4 preserved
;

PaintRow ROUT
        Push    R4
        LDR     R6, [WsPtr, #SGetEcfIndx]
        ADD     R6, WsPtr, R6, LSL #2
        LDR     R6, [R6, #BgEcf]        ; BgEcf for this scanline
10
        STR     R6, [R1], #4
        SUBS    R4, R4, #1
        BNE     %BT10
        Pull    R4
        MOV     PC, R14

; *****************************************************************************
;
;       CreateSprite - Create a sprite with given attributes
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite name
;       R3 = 0/1 => exclude/include palette data
;       R4 = width in pixels
;       R5 = height in pixels
;       R6 = mode number of sprite
;

CreateSprite ROUT
        Push    R14
        KillSpChoosePtr
        BL      DeleteSpriteByName      ; delete any existing sprite
        STR     R6, [WsPtr, #SGetMode]  ; needs setting up before CreateHeader
        SUB     R6, R4, #1              ; width in pixels-1
        SUB     R7, R5, #1              ; height-1
        MOV     R4, #0
        MOV     R5, #0
                                        ;      R3     ,R4,R5,R6,R7
        BL      CreateHeader            ; In : Palette,sl,sb,sr,st
                                        ; Out: ImageSize
        Pull    PC, VS                  ; if error, then bomb out

        MOV     R4, #0                  ; clear R3 words at offset 0 in sprite
        BL      ClearWords              ; ie clear image to 0

 ; Now add the sprite to the sprite area

        LDR     R3, [R2, #spNext]       ; total size of new sprite
        LDMIA   R1, {R4-R7}             ; saEnd,saNumber,saFirst,saFree
        ADD     R5, R5, #1
        ADD     R7, R7, R3
        STMIA   R1, {R4-R7}

        Pull    R14
        RETURNVC

; *****************************************************************************
;
;       CreateHeader - Create a header and info for a sprite
;
;       Internal routine, called by GetSprite, CreateSprite, ScreenSave
;
; in:   R1 -> sprite area
;       R2 -> sprite name
;       R3 = 0/1 => exclude/include palette data
;       R4,R5 = (X,Y) INTERNAL coordinate of bottom left
;       R6,R7 = (X,Y) INTERNAL coordinate of top right
;
; out:  R1 preserved
;       R2 -> new sprite
;       R3 = size of image in words
;       R4,R5 = (X,Y) INTERNAL coordinate of top left of on screen area
;       R0, R6-R11 corrupted
;

CreateHeader ROUT
        Push    "R1, R14"
        Push    R3

        BL      GetName                 ; name returned in R9-R11
        ADD     R8, WsPtr, #SGetName
        STMIA   R8, {R9-R11}            ; save the name away

        BL      PreCreateHeader

        Pull    "R0, R1, PC", VS

; now the updating the sprite area bit

        LDR     R1, [R13, #1*4]         ; reload sprite area ptr off stack
        LDR     R2, [R1, #saFree]
        LDR     R5, [R1, #saEnd]
        SUB     R5, R5, R2
        CMP     R5, R4
        BCC     %FT10

        ADD     R2, R2, R1              ; address of new sprite

PostCreateHeader
        ADD     R5, WsPtr, #SGetName
        LDMIA   R5, {R5-R11}

; R4 spNext, R5-R7 spName(0..2),
; R8 spWidth, R9 spHeight, R10 spLBit, R11 spRBit

        STMIA   R2, {R4-R11}            ; write control block for sprite
        LDR     R11, [WsPtr, #SGetImage]
        STR     R11, [R2, #spImage]
        STR     R11, [R2, #spTrans]     ; spImage=spTrans ie no mask

        LDR     R11, [WsPtr, #SGetMode]

        STR     R11, [R2, #spMode]
        ANDS    LR, R11, #15<<27        ; do we have an old or new sprite ?
        BEQ     %FT09
        TEQ     LR, #SpriteType_RISCOS5<<27 ; RISC OS 5 type?
      [ NoARMT2
        ANDEQ   LR, R11, #127<<20
        MOVEQ   LR, LR, LSR #20
      |
        UBFXEQ  LR, R11, #20, #7
      ]
        MOVNE   LR, LR, LSR #27       

09
        ADD     R4, WsPtr, #SGetTopLeft
        LDMIA   R4, {R4, R5}            ; (R4,R5) = TopLeft of 'on screen' area
        Pull    R11                     ; R11 = 0/1 for (ex/in)clude palette

;amg 25th May 1994. We now allow palettes on new format sprites in 8bpp and below

        CMP     LR,#SpriteType_New16bpp
        BCS     %FT11                   ; check for new 16/32 bpp

        TEQ     R11,#0                  ; was a palette wanted in the first place?
        BLNE    WritePaletteToSprite    ; do it if so

;        ;only allow palette data to be written if EQ and R11<>0
;
;        BNE     %FT11
;
;        TEQ     R11, #0
;        BLNE    WritePaletteToSprite

11
        Pull    "R1, R14"
        RETURNVC

10
        ADRL    R0, SpriteErr_NoRoom
      [ International
        BL      TranslateError
      ]
        STR     R0, [WsPtr, #RetnReg0]
        Pull    "R0, R1, R14"           ; junk palflag, sprite area ptr
        RETURNVS

; *****************************************************************************
;
;       SanitizeSGetMode - Convert SGetMode into a new format sprite word if necessary
;
;       If SGetMode is either   a) a mode selector pointer, or
;                               b) a mode number which has more than 8bpp
;       then SGetMode is replaced by a suitable sprite mode word
;
; amg: 15/10/93: changed to be more keen to generate old format mode numbers. It is
;                now also called from createsprite, so it will pass through a new
;                sprite mode word unchanged. Mode numbers will be unchanged. Mode
;                selectors will be changed to a mode number if one of suitable
;                eigs and depth exists --- size of screen is *not* taken into
;                account here.


; in:   WsPtr -> VDU workspace
;
; out:  If OK, then
;         V=0
;         All registers preserved
;       else
;         V=1
;         r0 -> error
;         RetnReg0 -> error
;       endif
;

SanitizeSGetMode Entry "r0-r4,r11"
        LDR     r11, [WsPtr, #SGetMode]

        CMP     r11, #&100
        BCC     %FT20                   ; [not a mode selector or new format sprite word]

        TST     r11, #1                 ; is it already a new format sprite word?
        EXIT    NE
10
        MOV     r0, r11                 ; r0 -> mode selector
        BL      ValidateModeSelector
        STRVS   r0, [sp]
        STRVS   r0, [WsPtr, #RetnReg0]
        EXIT    VS

15
; convert to new format sprite word

        MOV     r4, r11                 ; preserve the mode for later

        ;amg: add check for log2bpp=log2bpc

        MOV     r0, r4
        MOV     r1, #VduExt_Log2BPC
        SWI     XOS_ReadModeVariable
        MOV     R3,R2

        MOV     r0, r4
        MOV     r1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable

        CMP     R3, R2
        BNE     %FT90

        MOV     r0, r4
        MOV     r1, #VduExt_ModeFlags
        SWI     XOS_ReadModeVariable
        MOV     r3, r2

        MOV     r0, r4
        MOV     r1, #VduExt_NColour
        SWI     XOS_ReadModeVariable

; work out the sprite type. Note: Only dealing with RGB colour space here!
        ADDS    r2, r2, #1
        MOVEQ   r11, #SpriteType_New32bpp
        BEQ     %FT16
        CMP     r2, #1<<24
        MOVEQ   r11, #SpriteType_New24bpp
        BEQ     %FT16
        CMP     r2, #1<<12
        MOVEQ   r11, #SpriteType_New4K
        BEQ     %FT16
        CMP     r2, #1<<1
        MOVEQ   r11, #SpriteType_New1bpp
        BEQ     %FT16
        CMP     r2, #1<<2
        MOVEQ   r11, #SpriteType_New2bpp
        BEQ     %FT16
        CMP     r2, #1<<4
        MOVEQ   r11, #SpriteType_New4bpp
        BEQ     %FT16
        CMP     r2, #1<<8
        CMPNE   r2, #1<<6
        MOVEQ   r11, #SpriteType_New8bpp
        BEQ     %FT16
        CMP     r2, #1<<16
        BNE     %FT90
        ; Could be 565 or 1555
        TST     r3, #ModeFlag_64k
        MOVEQ   r11, #SpriteType_New16bpp
        MOVNE   r11, #SpriteType_New64K
16
; work out whether we need a RISC OS 5 mode word or not
        ANDS    r3, r3, #ModeFlag_DataFormat_Mask ; Any relevant modeflags set?
        TSTEQ   r11, #&F0                         ; Type too big for 4 bits?
        BEQ     %FT17

        ; RISC OS 5 style sprite mode word
        ORR     r11, r3, r11, LSL #20   ; sprite type plus mode flags
        ORR     r11, r11, #1 + (SpriteType_RISCOS5<<27)

        MOV     r1, #VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        ORR     r11, r11, r2, LSL #4    ; put xdpi into position

        MOV     r1, #VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        ORR     r11, r11, r2, LSL #6    ; put ydpi into position

        STR     r11, [WsPtr, #SGetMode] ; store new value
        EXIT

17
        ; "New"-style sprite mode word
        MOV     r11, r11, LSL #27
        ORR     r11, r11, #1
        
        MOV     r1, #VduExt_XEigFactor
        SWI     XOS_ReadModeVariable

        MOV     lr, #180
        MOV     lr, lr, LSR r2          ; cope with 45, 90, 180 dpi

        ORR     r11, r11, lr, LSL #1    ; put into xdpi position

        MOV     r1, #VduExt_YEigFactor
        SWI     XOS_ReadModeVariable

        MOV     lr, #180
        MOV     lr, lr, LSR r2
        ORR     r11, r11, lr, LSL #14   ; put into ydpi position

        STR     r11, [WsPtr, #SGetMode] ; store new value

        ;now check if we can force it back to a mode number

        ;if the bpp is > 8 the answer is no
        AND     r2, r11, #15<<27
        CMP     r2, #SpriteType_New16bpp
        EXIT    CS

        BIC     r0, r11, #&F8000000     ; take off the type information
        ADR     r1, substitute_list
        ADD     r2, r1, #12             ; end of list
27
        LDR     r3, [r1], #4
        TEQ     r3, r0
        BEQ     %FT28
        TEQ     r1, r2
        EXIT    EQ                      ; can't do anything with it
        BNE     %BT27
28
        ADD     r1, r1, #8              ; point at modes word, allowing for post inc
        ADD     r1, r1, r11, LSR #27    ; add in the sprite's type
        SUB     r1, r1, #1              ; and reduce it by one
        LDRB    r1, [r1]                ; fetch the right mode number

        ;if we got 255, we can't save the day
        CMP     r1,#255
        STRNE   r1, [WsPtr, #SGetMode]  ; and store it

        EXIT

substitute_list
        DCD     &001680B5               ;90 X 90 DPI, X/Y EIG 1 1
        DCD     &000B40B5               ;90 X 45 DPI, X/Y EIG 1 2
        DCD     &000B405B               ;45 X 45 DPI, X/Y EIG 2 2

        ;amg: used to use mode 4 for 2 colour eig 2 x 2 - now doesn't because of
        ;confusion about double pixels

        DCD     &1C1B1A19               ;modes  25, 26, 27, 28 for 90 x 90
        DCD     &0F0C0800               ;modes   0,  8, 12, 15 for 90 x 45
        DCD     &0D0901FF               ;modes n/a,  1,  9, 13 for 45 x 45
20
        MOV     r0, r11                 ; check if bpp for mode is > 8
        MOV     r1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        CMP     r2, #4
        BCS     %BT15                   ; if so then convert to new format sprite as well
        EXIT

90
        ADRL    R0, ErrorBlock_BadMODE
      [ International
        BL      TranslateError
      ]
        STR     r0, [sp]
        STR     r0, [WsPtr, #RetnReg0]
        SETV
        EXIT
        


; *****************************************************************************

PreCreateHeader ROUT
        Push    R14
        BL      SanitizeSGetMode        ; convert SGetMode to new format sprite if nec.
        Pull    PC, VS                  ; duff mode selector

        ;amg 25th May 1994
        ;We now allow palettes on new format sprites of 8bpp and below

;        ;force to no palette space if a new format sprite
;        LDR     LR, [WsPtr, #SGetMode]  ; get the mode
;        MOVS    LR, LR, LSR #27         ; set NE if new
;        MOVNE   R3, #0                  ; turn off palette

        LDR     LR, [WsPtr, #SGetMode]  ; get the sprite mode word
        BIC     LR, LR, #&80000000      ; ignore alpha mask flag
        CMP     LR, #SpriteType_RISCOS5<<27
        MOVLO   LR, LR, LSR #7          ; shift sprite type to its RISC OS 5 location
        ANDHS   LR, LR, #127<<20        ; or get RISC OS 5 type as-is
        CMP     LR, #SpriteType_New16bpp<<20 ; check for true colour
        MOVHS   R3, #0                  ; turn off the palette request

        TEQ     R3, #0                  ; convert R3 into mask to (ex/in)clude
        MOVNE   R3, #&FF                ; space for palette data

; amg need more palette space in case it's going to be a full palette
        ORRNE   R3, R3, #&300

        Push    "R6, R7"                ; preserve R6,R7 over the call
        ADD     R2, WsPtr, #SGetNext
        BL      SetupSprModeData

;      R6    ,R7    ,R8    ,R9   ,R10 ,R11
; Out: RdNCol,WrNCol,BytePC,XShft,NPix,Log2BPC

; amg 26th October 1993 - kill another bit of Arthur compatibility in favour
; of full palette 8bpp sprites
;        AND     R6, R6, #63     ; make 64 palette entries like MOS 1.2

        LDR     R7,[WsPtr,#ModeFlags]
        TST     R7, #ModeFlag_FullPalette
        ANDEQ   R6, R6, #63

        ADD     R6, R6, #1      ; number of palette entries in this mode
        AND     R3, R3, R6      ; if (palette not wanted) OR (256 colour mode)
                                ; then R3=0 else R3=number of palette entries
                                ; N.B. in 256 colour modes we end up ignoring
                                ;      the palette
        Pull    "R6,R7"
        Pull    PC, VS          ; error, not a graphics mode

        MOV     R3, R3, LSL #3  ; two words per palette entry
        ADD     R3, R3, #SpriteCBsize
        STR     R3, [WsPtr, #SGetImage] ; R0-R3 now free for use
                                        ; R4 ,R5, R6 ,R7
                                        ; sL ,sB, sR ,sT
        SUB     R0, R7, R5              ; height-1
        STR     R0, [WsPtr, #SGetHeight]
        ADD     R0, R0, #1              ; actual height in rows

        LDR     R1, [WsPtr, #GWTRow]    ; if SpriteTopRow > GWTopRow
        SUBS    R2, R7, R1
        MOVGT   R7, R1                  ; then clip for ScreenAddr's benefit
        MOVLE   R2, #0
        Least   R2, R2, R0
        STR     R2, [WsPtr, #SGetTopMargin] ; number of blank rows at top

        LDR     R1, [WsPtr, #GWBRow]
        SUBS    R2, R1, R5
        MOVLT   R2, #0
        Least   R2, R2, R0
        STR     R2, [WsPtr, #SGetBotMargin] ; number of blank rows at bottom

        WordOffset R0,R4, R9,R10,R11    ; offset to sL
        WordOffset R1,R6, R9,R10,R11    ;       to sR
        SUB     R2, R1, R0              ; width-1
        STR     R2, [WsPtr, #SGetWidth]
        ADD     R2, R2, #1              ; actual width in words

        BitLOffset R3,R4, R9,R10,R11    ; LBit
        STR     R3, [WsPtr, #SGetLBit]
        BitROffset R3,R6, R9,R10,R11    ; RBit
        STR     R3, [WsPtr, #SGetRBit]

        LDR     R8, [WsPtr, #GWLCol]
        Greatest R4,R4,R8
        WordOffset R3,R4, R9,R10,R11    ; offset to clipL
        SUB     R3, R3, R0
        Least   R3,R3,R2
        STR     R3, [WsPtr, #SGetLWrdMargin]    ; no. of blank words at left
        BitLOffset R3,R4, R9,R10,R11
        STR     R3, [WsPtr, #SGetLBitMargin]    ; no. of blank words at right

        LDR     R8, [WsPtr, #GWRCol]
        Least   R6, R6, R8
        WordOffset R3,R6, R9,R10,R11    ; offset to clipR
        SUB     R3, R1, R3
        Least   R3, R3, R2
        STR     R3, [WsPtr, #SGetRWrdMargin]
        BitROffset R3,R6, R9,R10,R11
        STR     R3, [WsPtr, #SGetRBitMargin]

        ADD     R0, WsPtr, #SGetTopLeft
        STMIA   R0, {R4, R7}            ; store top & left of 'on screen' area
        LDR     R0, [WsPtr, #SGetWidth]
        LDR     R1, [WsPtr, #SGetHeight]
        ADD     R0, R0, #1              ; width in words
        ADD     R1, R1, #1              ; height in words

        MUL     R3, R1, R0              ; image size in words
        LDR     R4, [WsPtr, #SGetImage]
        ADD     R4, R4, R3, LSL #2      ; total size in bytes

        Pull    R14
        RETURNVC

; *****************************************************************************
;
;       Decide mask size
;
;       Internal routine called from CreateMask
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 =  size of image data (bytes)
;
; out:  R3 = size of mask data (words)

DecideMaskSize ROUT
        Entry   "R5,R8"

        LDR     LR, [R2, #spMode]       ; get the sprite mode
        MOVS    LR, LR, LSR #27         ; isolate the type

        MOVEQ   R3,R3,LSR #2            ; if T=0 then return the same size as
        EXIT    EQ                      ; the image (but returns in words not
                                        ; bytes)

        LDR     R5, [R2, #spWidth]
        BL      GetMaskspWidth          ; get mask width information
        LDR     LR, [R2, #spHeight]     ; number of rows (minus 1)
        ADD     R5, R5, #1              ; width in words
        ADD     LR, LR, #1              ; height in rows
        MUL     R3, LR, R5              ; number of words for the mask

        EXIT

; *****************************************************************************
;
;       CreateMask - Add mask to sprite or set existing mask to 'solid'
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;

CreateMask ROUT
        Push    R14
        KillSpChoosePtr
        LDR     R4, [R2, #spNext]
        LDR     R5, [R2, #spImage]      ; NB Image=Trans if NO mask
        LDR     R6, [R2, #spTrans]
        SUB     R3, R4, R6

        BL      DecideMaskSize          ; returns R3=size of mask (words)

        TEQ     R5, R6
        BNE     %FT10                   ; mask exists

        MOV     R6, R4
        BL      ExtendSprite
        ADRVSL  R0, SpriteErr_NotEnoughRoom ; only error is NoRoomToInsert
      [ International
        BLVS    TranslateError
      ]
        STRVS   R0, [WsPtr, #RetnReg0]  ; correct this to 'Not enough room'
        Pull    PC, VS

        STR     R6, [R2, #spTrans]      ; new spTrans := old spNext
10                                      ; R3 mask size (words), R6 spTrans
        ADD     R6, R6, R2
        MOV     R4, #&FFFFFFFF
20
        STR     R4, [R6], #4
        SUBS    R3, R3, #1
        BNE     %BT20

        Pull    R14
        RETURNVC

; *****************************************************************************
;
;       RemoveMask - Remove mask from sprite
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;

RemoveMask ROUT
        Push    R14
        KillSpChoosePtr
        LDR     R4, [R2, #spNext]
        LDR     R5, [R2, #spImage]      ; NB spTrans = spImage, if NO mask
        LDR     R6, [R2, #spTrans]
        TEQ     R5, R6
        BEQ     %FT10                   ; no mask so ignore

        SUB     R3, R4, R6

        BL      DecideMaskSize          ; returns R3=size in words

        SUB     R4, R6, R5
        BL      RemoveWords
        LDR     R5, [R2, #spImage]      ; spTrans := spImage, ie NO mask
        STR     R5, [R2, #spTrans]
10
        Pull    R14
        RETURNVC

; *****************************************************************************
;
;       WritePaletteToSprite - Write palette information into sprite CB
;
;       Internal routine, called by CreateHeader
;
; in:   R2 -> sprite
;
; out:  All registers preserved
;

WritePaletteToSprite ROUT
        Push    "R0-R4, R14"
        LDR     R0, [WsPtr, #SprReadNColour]    ; highest palette entry

; amg 26th October 1993 - this bit of Arthur compatibility bites the
; dust to make screensaving full palette sprites work properly
;        AND     R0, R0, #63             ; make 63 if 255 like MOS 1.20
        LDR     R4, [WsPtr,#ModeFlags]
        TST     R4, #ModeFlag_FullPalette
        ANDEQ   R0, R0, #63

        ADD     R4, R2, R0, LSL #3
        ADD     R4, R4, #spPalette      ; ptr to last pal pos in spPalette
10
        MOV     R1, #16                 ; read 'normal' colour
        SWI     XOS_ReadPalette
        STMIA   R4, {R2,R3}
        SUB     R4, R4, #8
        SUBS    R0, R0, #1
        BCS     %BT10
        Pull    "R0-R4,PC"

; *****************************************************************************
;
;       WritePaletteFromSprite - Write palette from information in sprite CB
;
;       Internal routine, called by ScreenLoad
;
; in:   R2 -> sprite
;
; out:  All registers preserved
;

WritePaletteFromSprite ROUT
        Push    "R0-R6, R14"
        LDR     R0, [WsPtr, #ModeNo]
        LDR     R1, [R2, #spMode]

        ;logic for this routine
        ;
        ;[WsPtr, #ModeNo] is the current mode/ptr to mode selector
        ;R2 points at sprite data
        ;[WsPtr, #SloadModeSel] is space for building a mode selector for the sprite
        ;
        ; 1. construct a mode selector for the sprite (even if the sprite uses
        ;    a numbered mode, we prefer to use a mode selector because the
        ;    sprite width/height might not match that of the mode - old, deleted
        ;    comments from '93 suggest that ScreenSave 'is about to be changed'
        ;    to save out mode numbers even if a numbered mode isn't in use)
        ; 2. compare the mode selector (width, height, eigen values, pixel
        ;    format) against the current mode
        ; 3. if any of the values differ, try using the mode selector we
        ;    generated to change mode
        ; 4. if using the mode selector failed, and the sprite specified a
        ;    numbered mode, try changing to that mode directly
        ; 5. give up if all mode changes failed
        ; 6. if we changed mode, remember to re-remove cursors
        ; 7. proceed to write palette

        ; Step 1: mode selector construction
        MOV     R5, R1                  ;keep the mode number/sprite mode word safe
        MOV     R4, R2                  ;save the sprite pointer

        MOV     R3, #1
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_Flags]

        MOV     R0, R5        
        MOV     R1, #VduExt_XEigFactor
        STR     R1, [WsPtr, #SloadModeSel+ModeSelector_ModeVars]
        SWI     XOS_ReadModeVariable
        STRCC   R2, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+4]

        MOVCC   R1, #VduExt_YEigFactor
        STRCC   R1, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+8]
        SWICC   XOS_ReadModeVariable
        STRCC   R2, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+12]

        MOVCC   R1, #VduExt_ModeFlags
        STRCC   R1, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+16]
        SWICC   XOS_ReadModeVariable
        STRCC   R2, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+20] ; n.b. may be tweaked below for 8bpp modes

        MOVCC   R1, #VduExt_NColour
        STRCC   R1, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+24]
        SWICC   XOS_ReadModeVariable
        STRCC   R2, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+28]

        MOVCC   R1, #VduExt_Log2BPP
        SWICC   XOS_ReadModeVariable
        STRCC   R2, [WsPtr, #SloadModeSel+ModeSelector_PixelDepth]
        BCS     %FT90                   ;bad mode

        MOV     R3, #-1
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_FrameRate]
        ASSERT  ?SloadModeSel >= ModeSelector_ModeVars+32+4
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+32] ;list terminator

        ; calculate sprite width/height
        ; (R2 = Log2BPP from above)

        LDR     R0, [R4, #spWidth]      ;number of words
        MOV     R0, R0, LSL #5          ;convert to a number of bits
        LDR     LR, [R4, #spRBit]       ;last bit used
        ADD     LR, LR, #1              ;convert to number of bits
        ADD     R0, R0, LR              ;combine
        MOV     R0, R0, LSR R2          ;and convert to pixels
        STR     R0, [WsPtr, #SloadModeSel+ModeSelector_XRes]

        LDR     R3, [R4, #spHeight]
        ADD     R1, R3, #1
        STR     R1, [WsPtr, #SloadModeSel+ModeSelector_YRes]

        ; If it's an 8bpp mode, use the palette size to determine the FullPalette mode flag
        CMP     R2, #3
        BNE     %FT20

        ADD     LR, R4, #spImage        ;point to image/mask start
        LDMIA   LR, {R6,LR}             ;fetch them
        CMP     R6, LR                  ;which is bigger ?
        MOVGT   R6, LR                  ;use the least
        SUB     R6, R6, #spPalette      ;and the palette size is...
        CMP     R6, #&800               ;full entry 256 colour
        MOVEQ   R6, #ModeFlag_FullPalette
        MOVNE   R6, #0
        STR     R6, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+20]

20
        ; Step 2: Compare mode selector to current mode

        ; X, Y, Log2BPP checked first since we have those in registers
        LDR     R1, [WsPtr, #XWindLimit]
        ADD     R1, R1, #1
        CMP     R1, R0
        LDREQ   R1, [WsPtr, #YWindLimit]
        CMPEQ   R1, R3
        LDREQ   R1, [WsPtr, #Log2BPP]
        CMPEQ   R1, R2

        ; Check the other mode variables
        LDREQ   R1, [WsPtr, #XEigFactor]
        LDREQ   R0, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+4]
        CMPEQ   R1, R0
        LDREQ   R1, [WsPtr, #YEigFactor]
        LDREQ   R0, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+12]
        CMPEQ   R1, R0
        LDREQ   R1, [WsPtr, #NColour]
        LDREQ   R0, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+28]
        CMPEQ   R1, R0
        BNE     %FT30

        ; Check ModeFlags last because there are several flags we need to ignore
        LDR     LR, =ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_DataFormat_Mask
        CMP     R2, #7
        ORRHI   LR, LR, #ModeFlag_ChromaSubsampleMode ; Only include if actually a YCbCr mode (aliases GreyscalePalette and would cause false-positives otherwise)
        LDR     R1, [WsPtr, #ModeFlags]
        LDR     R0, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+20]
        EOR     R1, R1, R0
        ANDS    R1, R1, LR
        BEQ     %FT70

30
        ; Step 3: Change mode using mode selector
        MOV     R0,#ScreenModeReason_SelectMode
        ADD     R1,WsPtr,#SloadModeSel
        SWI     XOS_ScreenMode
        BVC     %FT60

        ; Step 4: Change mode using mode number if selector failed
        LDR     R1, [R4, #spMode]
        BICS    R14, R1, #&FF           ; EQ if sprite mode is a number (< 256), (V still set afterwards)
        MOVEQ   R0, #ScreenModeReason_SelectMode
        SWIEQ   XOS_ScreenMode          ; if called, will set V appropriately

        ; Step 5: Give up if all mode changes failed
        STRVS   R0, [WsPtr, #RetnReg0] 
        Pull    "R0-R6,PC", VS

60
        ; Step 6: Remember to re-remove cursors
        SWI     XOS_RemoveCursors

70
        ; Step 7: Actually write the palette
        LDR     R3, [R4, #spImage]
        CMP     R3, #spPalette          ; will clear V if EQ
        Pull    "R0-R6, PC", EQ         ; no palette data

        LDR     R0, [WsPtr, #NColour]
        ADD     R3, R4, #spPalette+8
        ADD     R3, R3, R0, LSL #3
75
        LDMDB   R3!, {R1,R2}

        BL      SendPalettePair         ; Note: Writes error directly to RetnReg0
        Pull    "R0-R6, PC", VS
        SUBS    R0, R0, #1              ; (V will be cleared by this)
        BCS     %BT75
        Pull    "R0-R6, PC"

90
        ADRL    R0,SpriteErr_InvalidSpriteMode
      [ International
        BL      TranslateError
      |
        SETV
      ]
        STR     R0, [WsPtr, #RetnReg0]
        Pull    "R0-R6,PC"

; *****************************************************************************
;
;       SendPalettePair - Program palette with flash pair
;
;       Internal routine, called by WritePaletteFromSprite
;
; in:   R0 = logical colour
;       R1 = first flash colour
;       R2 = second flash colour
;
; out:  R1 corrupted
;

SendPalettePair ROUT
        Push    "R0-R3, R14"
        TEQ     R1, R2                  ; are colours the same ?
        BNE     %FT10                   ; if not then do in two halves

        MOV     R3, #16
        BL      SendPaletteEntry        ; then send with 16
        Pull    "R0-R3, PC"
10
        MOV     R3, #17                 ; else send 1st flash with 17
        BL      SendPaletteEntry
        MOVVC   R1, R2
        MOVVC   R3, #18                 ; then 2nd flash with 18
        BLVC    SendPaletteEntry
        Pull    "R0-R3, PC"

; *****************************************************************************
;
;       SendPaletteEntry - Program one palette entry
;
;       Internal routine, called by SendPalettePair
;
; in:   R0 = logical colour
;       R1 = physical colour BGRx
;       R3 = PP field to use
;
; out:  All registers preserved
;

SendPaletteEntry ROUT
        Push    "R0,R1, R14"
        BIC     R1, R1, #&7F            ; clear all bits except sup. bit
        ORR     R1, R1, R3              ; or in new bits
        MOV     R0, R0, LSL #24         ; move log. col. up to top 8 bits
        Push    "R0, R1"                ; create an OSWORD block at R13+3

        MOV     R0, #12
        ADD     R1, R13, #3             ; R1 -> block
        SWI     XOS_Word
        STRVS   R0, [WsPtr, #RetnReg0]
        ADD     R13, R13, #8
        Pull    "R0,R1, PC"

        END
@


4.4
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a587 1
 [ ModeSelectors
a591 1
 ]
@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a161 1
 [ No26bitCode
a162 3
 |
        ADR     R14, %FT95+SVC_mode ; Enable interrupts on return from PostCreateHeader
 ]
a206 1
 [ No26bitCode
a208 1
 ]
a364 1
 [ No26bitCode
a366 3
 |
        Push    R14
 ]
a377 1
 [ No26bitCode
a380 3
 |
        Pull    PC,,^                 ; we must preserve the flags
 ]
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d162 5
a166 1
        ADR     R14, %FT95 + SVC_mode
d211 4
d372 1
a372 1
        mrs    ,R4, CPSR
d390 1
a390 1
        msr    ,CPSR_f, R4
a518 70
 [ {FALSE}      ; TMD 08-Jun-93: SGetMode sanitation done in PreCreateHeader now
; Previously we simply copied the current SGetMode straight into spmode.
; With the advent of mode descriptors and the new sprite mode word this
; has to get a bit more intelligent. New logic is:
; i) is the value > 256 (unsigned) ? Y - mode descriptor - have to make
;    a new sprite mode word, N - proceed to next...
; ii) is this higher than 8bpp ? Y - have to use a new sprite mode word
;    N - use the mode number

; Note: Once all the mode descriptor work is complete the second test
; may be removed, since no 16/32bpp modes will have mode numbers
; associated with them. However, until then it stays.

        !       0,"vdugrafj: remove marked section when mode descriptors"
        !       0,"          work, and no 16/32bpp modes have old mode numbers."

        CMP     R11, #256
        BCC     %FT20                    ;branch if under 256

30      ; this mode is not available in RISC OS 3, so give it a new format
        ; sprite mode word instead

        Push    "R0-R3"

        MOV     R0,R11
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable

        MOV     R11,#1                   ;bit 0 is always set

        ADD     LR, R2, #1               ;turn it into the sprite type
        ORR     R11, R11, LR, LSL #27    ;and put it into position

        MOV     R1, #VduExt_XEigFactor
        SWI     XOS_ReadModeVariable

        MOV     R4, #180
        MOV     LR, R4, LSR R2           ;convert to a dpi (180 >> eig)
        ORR     R11, R11, LR, LSL #1     ;and put it into position

        MOV     R1, #VduExt_YEigFactor
        SWI     XOS_ReadModeVariable

        MOV     LR, R4, LSR R2           ;convert to a dpi (180 >> eig)
        ORR     R11, R11, LR, LSL #14    ;and put it into position

        Pull    "R0-R3"

        B       %FT40

20      ;**************************************************************************
        ;The test and branch below should be removed once mode descriptors are done
        ;**************************************************************************

        ; ,---------------- BEGIN REMOVE SECTION ##################################
        ; v                                                                       #
        Push    "R0-R3"                  ;                                        #
        MOV     R0,R11                   ;                                        #
        MOV     R1,#VduExt_Log2BPP       ;                                        #
        SWI     XOS_ReadModeVariable     ;                                        #
        CMP     R2, #4                   ;                                        #
        Pull    "R0-R3"                  ;                                        #
        BCS     %BT30                    ;over 3 ?, put in a new sprite mode word #
        ; ^                                                                       #
        ; '---------------- END REMOVE SECTION ####################################

        ; it is an old fashioned mode number, so use that to allow RO 3.00/3.10
        ; to understand this sprite
40
 ]
d520 10
a529 1
        MOVS    LR, R11, LSR #27         ; do we have an old or new sprite ? EQ=old
d531 1
d592 1
a592 1
SanitizeSGetMode ENTRY "r0-r4,r11"
d614 72
a685 1
        MOV     r11,#1                  ; bit 0 is always set
d687 5
a706 17
        ;amg: add check for log2bpp=log2bpc

        MOV     r0, r4
        MOV     r1, #VduExt_Log2BPC
        SWI     XOS_ReadModeVariable
        MOV     R3,R2

        MOV     r0, r4
        MOV     r1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable

        CMP     R3, R2
        BNE     %FT20

        ADD     lr, r2, #1              ; turn it into the sprite type
        ORR     r11, r11, lr, LSL #27   ; and put it into position

d712 2
a713 1
        CMP     r2, #4
d757 12
d784 7
a790 4
        LDR     LR, [WsPtr, #SGetMode]   ; get the sprite mode word
        MOV     LR, LR, LSR #27          ; isolate the sprite type
        CMP     LR, #SpriteType_New16bpp ; check for 16/32bpp
        MOVCS   R3, #0                   ; turn off the palette request
d810 1
a810 1
        TST     R7, #Flag_FullPalette
d899 1
a899 1
        Push "R0-R2,R4-R5,R14"
d905 1
a905 1
        Pull    "R0-R2,R4-R5,R15",EQ    ; the image (but returns in words not
d908 5
a912 22
        ADRL    R5, NSM_bpptable-4
        LDR     R4, [R5, LR, LSL #2]    ; get the log2bpp value

        LDR     R5, [R2, #spWidth]      ; number of words-1 per row

        LDR     LR, [R2, #spRBit]       ; fetch the last bit used
        ADD     LR, LR, #1              ; turn into a number of bits rather than bit number
        MOV     LR, LR, LSR R4          ; turn into a number of pixels

        RSB     R4, R4, #5
        MOV     R5, R5, LSL R4          ; number of pixels on the row for the full words

        ADD     R5, R5, LR

        ANDS    LR, R5, #&1F            ; is it a whole number of words
        MOVNE   LR, #1                  ; if not start at 1 not 0
        ADD     LR, LR, R5, LSR #5      ; add the number of whole words

                                        ; now have number of words per mask row

        LDR     R5, [R2, #spHeight]     ; number of rows (minus 1)
        ADD     R5, R5, #1
d915 1
a915 1
        Pull "R0-R2,R4-R5,R15"
d1011 1
a1011 1
        TST     R4, #Flag_FullPalette
a1040 2
        [ {TRUE} :LAND: ModeSelectors

d1045 1
a1045 1
        ;[WsPtr, #SloadModeSel] is 36 bytes for building a mode selector for the sprite
d1047 14
a1060 32
        ;sprite mode < 256 ?
        ;yes: equal to current mode ?
        ;     yes: already in correct mode. done.
        ;     no:  change to mode sprite wants, done.
        ;no:  build a mode selector for the sprite
        ;     check pixel depth, xres, yres, xdpi and ydpi
        ;     all identical ?
        ;     yes: already in suitable mode. done.
        ;     no:  change mode. done.
        ;if we do a mode change, remember to re-remove cursors

        ;amg 15 Oct '93 Screensave is about to be changed to use a representative
        ;mode number of the eigs and depth (only), so screenload no longer believes
        ;the screen mode number in the file.

        ;amg 21 Dec '93 Slight modification - if the screen mode change failed, and
        ;we have an old screen mode number, use that as a last gasp

;        CMP     R1, #256
;        BCS     %FT30                   ;branch if a new format sprite mode word

;        CMP     R1, R0                  ;are we in the right (old style) mode ?
;        BEQ     %FT10

;        MOV     R0,#ScreenModeReason_SelectMode
;        SWI     XOS_ScreenMode
;        STRVS   R0, [WsPtr, #RetnReg0]  ;exit on error
;        Pull    "R0-R6,PC", VS
;        B       %FT40                   ;otherwise get on with it

30      ; new format sprite mode word
        ; build the mode selector at SLoadModeSel
d1062 1
d1064 1
a1064 13

        ;do the absolutes first
        MOV     R3, #-1
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_FrameRate]
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+16] ;list terminator after two pairs
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+32] ;list terminator after four pairs
        MOV     R3, #128
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+20]  ;modeflags value, if needed
        MOV     R3, #VduExt_NColour
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+24]
        MOV     R3, #255
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+28]

a1067 10
        MOV     R3, #VduExt_XEigFactor
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars]    ; modevar 1 = xeig
        MOV     R3, #VduExt_YEigFactor
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+8]  ; modevar 2 = Yeig

        ;now the things from the sprite
;        MOV     R3, R1, LSR #27         ;sprite type
;        ADRL    R4, NSM_bpptable-4      ;readmodevar's table
;        LDR     R3, [R4, R3, LSL #2]    ;word index
;        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_PixelDepth]
d1069 1
a1069 48
        ;change to calling read mode variable to cope with mode number or sprite mode word
        MOV     R4, R2                  ;save the sprite pointer
        MOV     R0, R5                  ;sprite mode word/mode number
        MOV     R1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        STR     R2, [WsPtr, #SloadModeSel+ModeSelector_PixelDepth]
        MOV     R3, R2

        ;if log2bpp=3, and size of palette data indicates full palette, we need to force
        ;a suitable mode
        CMP     R3, #3
        BNE     %FT40

        ADD     LR, R4, #spImage        ;point to image/mask start
        LDMIA   LR,{R2,LR}              ;fetch them
        CMP     R2,LR                   ;which is bigger ?
        MOVGT   R2,LR                   ;use the least
        SUB     R2,R2,#spPalette        ;and the palette size is...

        CMP     R2,#&800                ;full entry 256 colour

        ;change the mode selector so it includes a modeflags word
        ;(following two words already set up)

        MOVEQ   R2, #0
        ;amg 28/4/94 bugfix - following inst wasn't conditional
        STREQ   R2, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+16]

40
        MOV     R2, R4                  ;restore the sprite pointer

        LDR     R4, [R2, #spWidth]      ;number of words
        MOV     R4, R4, LSL #5          ;convert to a number of bits
        LDR     LR, [R2, #spRBit]       ;last bit used
        ADD     LR, LR, #1              ;convert to number of bits
        ADD     R4, R4, LR              ;combine
        MOV     R4, R4, LSR R3          ;and convert to pixels
        STR     R4, [WsPtr, #SloadModeSel+ModeSelector_XRes]

        LDR     R3, [R2, #spHeight]
        ADD     R3, R3, #1
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_YRes]
        MOV     R6, R2                  ;save the sprite pointer for later

        ;that leaves the x and y eig factors, which are derived
        ;from the dpi

        MOV     R0, R5                  ;R0 = sprite mode word
d1071 1
d1074 1
d1076 1
a1078 1
        BCS     %FT90                   ;we canna take it captain....
d1080 4
a1083 1
        ;do the comparison which involve the mode selectors first
d1085 4
a1088 2
        ;depth
        LDR     LR, [WsPtr, #ModeNo]
d1090 4
a1093 4
        LDR     R3, [LR, #ModeSelector_PixelDepth]
        LDR     R4, [WsPtr, #SloadModeSel+ModeSelector_PixelDepth]
        TEQ     R3, R4
        BNE     %FT80                   ;need to change mode to new mode selr
d1095 4
a1098 4
        LDR     R3, [LR, #ModeSelector_XRes]
        LDR     R4, [WsPtr, #SloadModeSel+ModeSelector_XRes]
        TEQ     R3, R4
        BNE     %FT80                   ;need to change mode to new mode selr
d1100 2
a1101 4
        LDR     R3, [LR, #ModeSelector_YRes]
        LDR     R4, [WsPtr, #SloadModeSel+ModeSelector_YRes]
        TEQ     R3, R4
        BNE     %FT80                   ;need to change mode to new mode selr
d1103 25
a1127 5
        ;now the eigs
        LDR     R3, [WsPtr, #XEigFactor]
        LDR     R4, [WsPtr, #SloadModeSel+ModeSelector_Flags+4]
        TEQ     R3, R4
        BNE     %FT80                   ;need to change mode to new mode selr
d1129 2
a1130 3
        LDR     R3, [WsPtr, #YEigFactor]
        LDR     R4, [WsPtr, #SloadModeSel+ModeSelector_Flags+12]
        TEQ     R3, R4
d1132 30
a1161 1
        BEQ     %FT10                   ;this mode is suitable
d1163 2
a1164 1
80
d1168 1
d1170 2
a1171 9

        [ {TRUE}
        ;ensure we preserve the error pointer in situations where we can't try to
        ;fall back to the mode number in the sprite header

        ;if it errored try again if there's a mode number available
        BVC     %FT40

        LDR     R1, [R6, #spMode]
a1174 3
        |
        ;if it errored try again if there's a mode number available
        BVC     %FT40
d1176 2
a1177 7
        MOV     R0, #ScreenModeReason_SelectMode
        LDR     R1, [R6, #spMode]
        BICS    R14, R1, #&FF           ; EQ if sprite mode is a number (< 256), (V still set afterwards)
        SWIEQ   XOS_ScreenMode          ; if called, will set V appropriately
        ]

        STRVS   R0, [WsPtr, #RetnReg0]  ;exit on error
a1178 10
        B       %FT40                   ;otherwise get on with it
90
        ADRL    R0,SpriteErr_InvalidSpriteMode
        [ International
        BL      TranslateError
        ]
        STR     R0, [WsPtr, #RetnReg0]
        SETV
        Pull    "R0-R6,PC"
        |
d1180 3
a1182 6
        ;as originally done this code tended to compare mode specifiers against new
        ;sprite mode words, and worse still tried to select a mode from a new sprite
        ;mode word. the rewrite above takes a more logical approach

        CMP     R0, R1                  ; if already in correct mode
        BEQ     %FT10                   ; then skip
d1184 3
a1186 17
 [ ModeSelectors
        MOV     r0, #ScreenModeReason_SelectMode
        SWI     XOS_ScreenMode
 |
        MOV     R0, #22
        SWI     XOS_WriteC
        MOVVC   R0, R1
        SWIVC   XOS_WriteC
 ]
        STRVS   R0, [WsPtr, #RetnReg0]
        Pull    "R0-R6,PC", VS
        ]
40
        SWI     XOS_RemoveCursors       ; remove cursors again
10
        MOV     R2, R6
        LDR     R3, [R2, #spImage]
d1190 5
a1194 1
        LDR     R4, [WsPtr, #NColour]
d1196 1
a1196 7
        ADD     R3, R2, #spPalette
        ADD     R3, R3, R4, LSL #3
20
        LDMIA   R3, {R1,R2}
        MOV     R0, R4

        BL      SendPalettePair
d1198 3
d1202 9
a1210 4
        SUB     R3, R3, #8
        SUBS    R4, R4, #1              ; (V will be cleared by this)
        BCS     %BT20
        Pull    "R0-R6, PC"
@


4.2.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d364 1
a364 1
        MRS     R4, CPSR
d382 1
a382 1
        MSR     CPSR_f, R4
d644 1
a644 1
SanitizeSGetMode Entry "r0-r4,r11"
@


4.2.2.2
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d162 1
a162 5
 [ No26bitCode
        ADR     R14, %FT95
 |
        ADR     R14, %FT95+SVC_mode ; Enable interrupts on return from PostCreateHeader
 ]
a206 4
 [ No26bitCode
; Enable interrupts here for 32bit machines
        WritePSRc SVC_mode, R14
 ]
@


4.2.2.3
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d1232 1
a1232 1
      [ International
d1234 2
a1235 1
      |
a1236 2
      ]
        STR     R0, [WsPtr, #RetnReg0]
@


4.2.2.4
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d519 70
d590 1
a590 10
        ANDS    LR, R11, #15<<27        ; do we have an old or new sprite ?
        BEQ     %FT09
        TEQ     LR, #SpriteType_RISCOS5<<27 ; RISC OS 5 type?
      [ NoARMT2
        ANDEQ   LR, R11, #127<<20
        MOVEQ   LR, LR, LSR #20
      |
        UBFXEQ  LR, R11, #20, #7
      ]
        MOVNE   LR, LR, LSR #27       
a591 1
09
d674 1
a674 61
        ;amg: add check for log2bpp=log2bpc

        MOV     r0, r4
        MOV     r1, #VduExt_Log2BPC
        SWI     XOS_ReadModeVariable
        MOV     R3,R2

        MOV     r0, r4
        MOV     r1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable

        CMP     R3, R2
        BNE     %FT90

        MOV     r0, r4
        MOV     r1, #VduExt_ModeFlags
        SWI     XOS_ReadModeVariable
        MOV     r3, r2

        MOV     r0, r4
        MOV     r1, #VduExt_NColour
        SWI     XOS_ReadModeVariable

; work out the sprite type. Note: Only dealing with RGB colour space here!
        ADDS    r2, r2, #1
        MOVEQ   r11, #SpriteType_New32bpp
        BEQ     %FT16
        CMP     r2, #1<<24
        MOVEQ   r11, #SpriteType_New24bpp
        BEQ     %FT16
        CMP     r2, #1<<12
        MOVEQ   r11, #SpriteType_New4K
        BEQ     %FT16
        CMP     r2, #1<<1
        MOVEQ   r11, #SpriteType_New1bpp
        BEQ     %FT16
        CMP     r2, #1<<2
        MOVEQ   r11, #SpriteType_New2bpp
        BEQ     %FT16
        CMP     r2, #1<<4
        MOVEQ   r11, #SpriteType_New4bpp
        BEQ     %FT16
        CMP     r2, #1<<8
        CMPNE   r2, #1<<6
        MOVEQ   r11, #SpriteType_New8bpp
        BEQ     %FT16
        CMP     r2, #1<<16
        BNE     %FT90
        ; Could be 565 or 1555
        TST     r3, #ModeFlag_64k
        MOVEQ   r11, #SpriteType_New16bpp
        MOVNE   r11, #SpriteType_New64K
16
; work out whether we need a RISC OS 5 mode word or not
        ANDS    r3, r3, #ModeFlag_DataFormat_Mask ; Any relevant modeflags set?
        TSTEQ   r11, #&F0                         ; Type too big for 4 bits?
        BEQ     %FT17

        ; RISC OS 5 style sprite mode word
        ORR     r11, r3, r11, LSL #20   ; sprite type plus mode flags
        ORR     r11, r11, #1 + (SpriteType_RISCOS5<<27)
a677 16
        ORR     r11, r11, r2, LSL #4    ; put xdpi into position

        MOV     r1, #VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        ORR     r11, r11, r2, LSL #6    ; put ydpi into position

        STR     r11, [WsPtr, #SGetMode] ; store new value
        EXIT

17
        ; "New"-style sprite mode word
        MOV     r11, r11, LSL #27
        ORR     r11, r11, #1
        
        MOV     r1, #VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
d691 17
d713 1
a713 2
        AND     r2, r11, #15<<27
        CMP     r2, #SpriteType_New16bpp
a756 12
90
        ADRL    R0, ErrorBlock_BadMODE
      [ International
        BL      TranslateError
      ]
        STR     r0, [sp]
        STR     r0, [WsPtr, #RetnReg0]
        SETV
        EXIT
        


d795 1
a795 1
        TST     R7, #ModeFlag_FullPalette
d884 1
a884 1
        Entry   "R5,R8"
d890 1
a890 1
        EXIT    EQ                      ; the image (but returns in words not
d893 22
a914 5
        LDR     R5, [R2, #spWidth]
        BL      GetMaskspWidth          ; get mask width information
        LDR     LR, [R2, #spHeight]     ; number of rows (minus 1)
        ADD     R5, R5, #1              ; width in words
        ADD     LR, LR, #1              ; height in rows
d917 1
a917 1
        EXIT
d1013 1
a1013 1
        TST     R4, #ModeFlag_FullPalette
@


4.2.2.5
log
@Fix PreCreateHeader to allow palettes for <=256 colour RISC OS 5 sprites. LoadCoordPair tweaks.
Detail:
  s/vdu/vdudecl - Add a couple more optimisations to LoadCoordPair - use SXTH where possible, and use LDRSH if data is halfword aligned (not currently the case, but may be in future)
  s/vdu/vdugrafj - Fix PreCreateHeader to allow <=256 colour RISC OS 5 sprites to have palettes
Admin:
  Tested on Pandaboard


Version 5.35, 4.79.2.238. Tagged as 'Kernel-5_35-4_79_2_238'
@
text
@d784 4
a787 7
        LDR     LR, [WsPtr, #SGetMode]  ; get the sprite mode word
        BIC     LR, LR, #&80000000      ; ignore alpha mask flag
        CMP     LR, #SpriteType_RISCOS5<<27
        MOVLO   LR, LR, LSR #7          ; shift sprite type to its RISC OS 5 location
        ANDHS   LR, LR, #127<<20        ; or get RISC OS 5 type as-is
        CMP     LR, #SpriteType_New16bpp<<20 ; check for true colour
        MOVHS   R3, #0                  ; turn off the palette request
@


4.2.2.6
log
@Fix bad pointer dereference and other issues with *ScreenLoad
Detail:
  s/vdu/vdugrafj - Rewrite WritePaletteFromSprite to fix some issues with the logic which decides whether to change screen mode:
  - ModeNo was always being treated as if it was a mode selector block, causing bad pointer dereferences if it was actually a numbered mode. Prior to zero page protection the code would have eventually stumbled its way through to the mode change code.
  - For checking the pixel format, only the Log2BPP was being compared, resulting in code deciding that (e.g.) modes with differing RGB order were the same
  - However the eigen value checking was also broken (checking wrong part of generated mode selector block), causing the mode change logic to always be taken
  s/vdu/vdugrafdec - Increase size of SloadModeSel so it's actually large enough to hold the generated mode selector - old code would have run off the end a bit (thankfully, it was the last thing in that particular workspace block)
Admin:
  Tested on BB-xM, *ScreenLoad'ing sprites from various modes
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/4/topics/3649


Version 5.35, 4.79.2.294. Tagged as 'Kernel-5_35-4_79_2_294'
@
text
@d1041 2
d1047 1
a1047 1
        ;[WsPtr, #SloadModeSel] is space for building a mode selector for the sprite
d1049 32
a1080 14
        ; 1. construct a mode selector for the sprite (even if the sprite uses
        ;    a numbered mode, we prefer to use a mode selector because the
        ;    sprite width/height might not match that of the mode - old, deleted
        ;    comments from '93 suggest that ScreenSave 'is about to be changed'
        ;    to save out mode numbers even if a numbered mode isn't in use)
        ; 2. compare the mode selector (width, height, eigen values, pixel
        ;    format) against the current mode
        ; 3. if any of the values differ, try using the mode selector we
        ;    generated to change mode
        ; 4. if using the mode selector failed, and the sprite specified a
        ;    numbered mode, try changing to that mode directly
        ; 5. give up if all mode changes failed
        ; 6. if we changed mode, remember to re-remove cursors
        ; 7. proceed to write palette
a1081 1
        ; Step 1: mode selector construction
d1083 13
a1095 1
        MOV     R4, R2                  ;save the sprite pointer
d1099 54
d1154 4
a1157 1
        MOV     R0, R5        
a1158 1
        STR     R1, [WsPtr, #SloadModeSel+ModeSelector_ModeVars]
a1160 1

a1161 1
        STRCC   R1, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+8]
d1164 1
d1166 1
a1166 4
        MOVCC   R1, #VduExt_ModeFlags
        STRCC   R1, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+16]
        SWICC   XOS_ReadModeVariable
        STRCC   R2, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+20] ; n.b. may be tweaked below for 8bpp modes
d1168 2
a1169 4
        MOVCC   R1, #VduExt_NColour
        STRCC   R1, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+24]
        SWICC   XOS_ReadModeVariable
        STRCC   R2, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+28]
d1171 4
a1174 9
        MOVCC   R1, #VduExt_Log2BPP
        SWICC   XOS_ReadModeVariable
        STRCC   R2, [WsPtr, #SloadModeSel+ModeSelector_PixelDepth]
        BCS     %FT90                   ;bad mode

        MOV     R3, #-1
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_FrameRate]
        ASSERT  ?SloadModeSel >= ModeSelector_ModeVars+32+4
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+32] ;list terminator
d1176 4
a1179 2
        ; calculate sprite width/height
        ; (R2 = Log2BPP from above)
d1181 4
a1184 15
        LDR     R0, [R4, #spWidth]      ;number of words
        MOV     R0, R0, LSL #5          ;convert to a number of bits
        LDR     LR, [R4, #spRBit]       ;last bit used
        ADD     LR, LR, #1              ;convert to number of bits
        ADD     R0, R0, LR              ;combine
        MOV     R0, R0, LSR R2          ;and convert to pixels
        STR     R0, [WsPtr, #SloadModeSel+ModeSelector_XRes]

        LDR     R3, [R4, #spHeight]
        ADD     R1, R3, #1
        STR     R1, [WsPtr, #SloadModeSel+ModeSelector_YRes]

        ; If it's an 8bpp mode, use the palette size to determine the FullPalette mode flag
        CMP     R2, #3
        BNE     %FT20
d1186 5
a1190 9
        ADD     LR, R4, #spImage        ;point to image/mask start
        LDMIA   LR, {R6,LR}             ;fetch them
        CMP     R6, LR                  ;which is bigger ?
        MOVGT   R6, LR                  ;use the least
        SUB     R6, R6, #spPalette      ;and the palette size is...
        CMP     R6, #&800               ;full entry 256 colour
        MOVEQ   R6, #ModeFlag_FullPalette
        MOVNE   R6, #0
        STR     R6, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+20]
d1192 3
a1194 2
20
        ; Step 2: Compare mode selector to current mode
d1196 1
a1196 30
        ; X, Y, Log2BPP checked first since we have those in registers
        LDR     R1, [WsPtr, #XWindLimit]
        ADD     R1, R1, #1
        CMP     R1, R0
        LDREQ   R1, [WsPtr, #YWindLimit]
        CMPEQ   R1, R3
        LDREQ   R1, [WsPtr, #Log2BPP]
        CMPEQ   R1, R2

        ; Check the other mode variables
        LDREQ   R1, [WsPtr, #XEigFactor]
        LDREQ   R0, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+4]
        CMPEQ   R1, R0
        LDREQ   R1, [WsPtr, #YEigFactor]
        LDREQ   R0, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+12]
        CMPEQ   R1, R0
        LDREQ   R1, [WsPtr, #NColour]
        LDREQ   R0, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+28]
        CMPEQ   R1, R0
        BNE     %FT30

        ; Check ModeFlags last because there are several flags we need to ignore
        LDR     LR, =ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_DataFormat_Mask
        CMP     R2, #7
        ORRHI   LR, LR, #ModeFlag_ChromaSubsampleMode ; Only include if actually a YCbCr mode (aliases GreyscalePalette and would cause false-positives otherwise)
        LDR     R1, [WsPtr, #ModeFlags]
        LDR     R0, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+20]
        EOR     R1, R1, R0
        ANDS    R1, R1, LR
        BEQ     %FT70
d1198 1
a1198 2
30
        ; Step 3: Change mode using mode selector
a1201 1
        BVC     %FT60
d1203 9
a1211 2
        ; Step 4: Change mode using mode number if selector failed
        LDR     R1, [R4, #spMode]
d1215 3
d1219 7
a1225 2
        ; Step 5: Give up if all mode changes failed
        STRVS   R0, [WsPtr, #RetnReg0] 
d1227 1
a1227 23

60
        ; Step 6: Remember to re-remove cursors
        SWI     XOS_RemoveCursors

70
        ; Step 7: Actually write the palette
        LDR     R3, [R4, #spImage]
        CMP     R3, #spPalette          ; will clear V if EQ
        Pull    "R0-R6, PC", EQ         ; no palette data

        LDR     R0, [WsPtr, #NColour]
        ADD     R3, R4, #spPalette+8
        ADD     R3, R3, R0, LSL #3
75
        LDMDB   R3!, {R1,R2}

        BL      SendPalettePair         ; Note: Writes error directly to RetnReg0
        Pull    "R0-R6, PC", VS
        SUBS    R0, R0, #1              ; (V will be cleared by this)
        BCS     %BT75
        Pull    "R0-R6, PC"

d1237 44
@


4.2.2.1.2.1
log
@Assorted kernel fixes for ARMv6/ARMv7
Detail:
  s/ARMops - Fix IMB_Range_WB_CR7_Lx to clean the correct number of cache lines
  s/HAL - Change CP15 control register flags so unaligned loads are enabled on ARMv6 (to simplify support for ARMv7 where unaligned loads are always enabled, and to match the behaviour expected by the example code in Hdr:CPU.Arch)
  s/AMBControl/memmap - Make AMB_LazyFixUp use the correct L2PT protection flags depending on ARM600/VMSAv6 MMU model. Also guard against problems caused by future L2PT flag changes.
  s/vdu/vdugrafj - Fix previously undiscovered 32bit incompatability in GetSprite (OS_SpriteOp 14/16)
Admin:
  Tested on rev C2 beagleboard


Version 5.35, 4.79.2.98.2.5. Tagged as 'Kernel-5_35-4_79_2_98_2_5'
@
text
@d162 1
a162 5
 [ No26bitCode
        ADR     R14, %FT95
 |
        ADR     R14, %FT95+SVC_mode ; Enable interrupts on return from PostCreateHeader
 ]
a206 4
 [ No26bitCode
; Enable interrupts here for 32bit machines
        WritePSRc SVC_mode, R14
 ]
@


4.1
log
@Initial revision
@
text
@d130 1
a130 1
        
d136 1
a136 1
        BICS    PC, R14, #V_bit
d147 1
a147 1
        ORRS    PC, R14, #V_bit
d218 1
a218 1
        BICS    PC, R14, #V_bit
d252 1
a252 1
        LDR     R14, [WsPtr, #LineLength] ; offset from RHend of row to LHend 
d269 1
a269 1
        STR     R6, [WsPtr, #SGetRBitMargin] 
d275 1
a275 1
; R0    ,R1    ,R2     ,R3    ,R4      ..       R11 
d363 4
d368 1
d380 7
a386 2
        Pull    R14
        MOVS    PC, R14                 ; we must preserve the flags
d411 1
a411 1
        MOVS    PC, R14
d453 1
a453 1
        BICS    PC, R14, #V_bit
d508 1
a508 1
                                                             
d535 1
a535 1
        MOV     R0,R11  
d551 1
a551 1
        MOV     R1, #VduExt_YEigFactor  
d565 1
a565 1
        ; ,---------------- BEGIN REMOVE SECTION ##################################  
d586 2
a587 2
        Pull    R11                     ; R11 = 0/1 for (ex/in)clude palette      
           
d597 1
a597 1
;                       
d599 1
a599 1
;           
d605 1
a605 1
        BICS    PC, R14, #V_bit
d614 1
a614 1
        ORRS    PC, R14, #V_bit
d663 1
a663 1
                       
d676 1
a676 1
        MOV     r1, #VduExt_YEigFactor  
d682 1
a682 1
                                   
d687 1
a687 1
        SWI     XOS_ReadModeVariable  
d693 1
a693 1
        
d700 1
a700 1
        STR     r11, [WsPtr, #SGetMode] ; store new value      
d711 1
a711 1
27        
d723 1
a723 1
        
d728 2
a729 2
        EXIT       
        
d734 1
a734 1
                                                
d737 1
a737 1
        
d755 1
a755 1
                                             
d758 1
a758 1
                                             
d861 1
a861 1
        BICS    PC, R14, #V_bit
d873 1
a873 1
; out:  R3 = size of mask data (words)  
d880 1
a880 1
        
d884 1
a884 1
       
d927 1
a927 1
        SUB     R3, R4, R6 
d953 1
a953 1
        BICS    PC, R14, #V_bit
d984 1
a984 1
        BICS    PC, R14, #V_bit
d1034 1
a1034 1
        
d1036 1
a1036 1
        
d1048 1
a1048 1
        ;     check pixel depth, xres, yres, xdpi and ydpi 
d1056 2
a1057 2
        ;the screen mode number in the file. 
        
d1063 1
a1063 1
        
d1066 2
a1067 2
             
;        MOV     R0,#ScreenModeReason_SelectMode 
d1072 2
a1073 2
        
30      ; new format sprite mode word   
d1075 1
a1075 1
                 
d1077 1
a1077 1
        
d1082 1
a1082 1
        STR     R3, [WsPtr, #SloadModeSel+ModeSelector_ModeVars+32] ;list terminator after four pairs                                                          
d1089 2
a1090 2
        
        
d1097 1
a1097 1
        
d1110 2
a1111 2
        MOV     R3, R2     
        
d1115 2
a1116 2
        BNE     %FT40   
        
d1122 1
a1122 1
        
d1124 1
a1124 1
                              
d1134 1
a1134 1
                     
d1142 1
a1142 1
        
d1147 1
a1147 1
        
d1150 1
a1150 1
        
d1159 1
a1159 1
        
d1161 1
a1161 1
                                    
d1164 1
a1164 1
        
d1169 1
a1169 1
        
d1174 1
a1174 1
        
d1179 1
a1179 1
                  
d1185 1
a1185 1
        
d1191 3
a1193 3
        
80              
        MOV     R0,#ScreenModeReason_SelectMode 
d1195 1
a1195 1
        SWI     XOS_ScreenMode        
d1207 1
a1207 1
        MOVEQ   R0, #ScreenModeReason_SelectMode 
d1213 1
a1213 1
        MOV     R0, #ScreenModeReason_SelectMode 
d1218 1
a1218 1
        
d1222 1
a1222 1
90                             
d1231 1
a1231 1
        
d1235 1
a1235 1
        
d1238 1
a1238 1
                                  
d1250 2
a1251 2
        ]            
40        
d1253 1
a1253 1
10                    
d1260 1
a1260 1
        
d1268 1
a1268 1
        Pull    "R0-R6, PC", VS   
d1322 2
a1323 2
        Push    "R0, R1"                ; create an OSWORD block at R13+3    
                             
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d83 1
d86 5
d140 1
d142 1
d157 1
d159 1
d501 70
d599 1
d601 1
d644 1
d649 1
d927 1
d929 1
d1025 1
d1188 1
d1199 9
d1214 1
d1216 1
d1220 21
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

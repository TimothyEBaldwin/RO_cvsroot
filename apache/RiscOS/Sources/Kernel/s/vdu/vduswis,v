head	4.13;
access;
symbols
	Kernel-6_14:4.13
	Kernel-6_01-3:4.12
	Kernel-6_13:4.12
	Kernel-6_12:4.12
	Kernel-6_11:4.12
	Kernel-6_10:4.12
	Kernel-6_09:4.12
	Kernel-6_08-4_129_2_10:4.12
	Kernel-6_08-4_129_2_9:4.12
	Kernel-6_08:4.12
	Kernel-6_07:4.12
	Kernel-6_06:4.12
	Kernel-6_05-4_129_2_8:4.12
	Kernel-6_05:4.12
	Kernel-6_04:4.12
	Kernel-6_03:4.12
	Kernel-6_01-2:4.12
	Kernel-6_01-4_146_2_1:4.12
	Kernel-6_02:4.12
	Kernel-6_01-1:4.12
	Kernel-6_01:4.12
	Kernel-6_00:4.12
	Kernel-5_99:4.12
	Kernel-5_98:4.12
	Kernel-5_97-4_129_2_7:4.12
	Kernel-5_97:4.12
	Kernel-5_96:4.12
	Kernel-5_95:4.12
	Kernel-5_94:4.12
	Kernel-5_93:4.12
	Kernel-5_92:4.12
	Kernel-5_91:4.12
	Kernel-5_90:4.12
	Kernel-5_89-4_129_2_6:4.12
	Kernel-5_89:4.12
	Kernel-5_88-4_129_2_5:4.12
	Kernel-5_88-4_129_2_4:4.12
	Kernel-5_88:4.12
	Kernel-5_87:4.12
	Kernel-5_86-4_129_2_3:4.12
	Kernel-5_86-4_129_2_2:4.12
	Kernel-5_86-4_129_2_1:4.12
	Kernel-5_86:4.12
	SMP:4.12.0.2
	SMP_bp:4.12
	Kernel-5_85:4.12
	Kernel-5_54-1:4.9
	Kernel-5_84:4.12
	Kernel-5_83:4.12
	Kernel-5_82:4.11
	Kernel-5_81:4.11
	Kernel-5_80:4.11
	Kernel-5_79:4.11
	Kernel-5_78:4.11
	Kernel-5_77:4.11
	Kernel-5_76:4.11
	Kernel-5_75:4.11
	Kernel-5_74:4.11
	Kernel-5_73:4.9
	Kernel-5_72:4.9
	Kernel-5_71:4.9
	Kernel-5_70:4.9
	Kernel-5_69:4.9
	Kernel-5_68:4.9
	Kernel-5_67:4.9
	Kernel-5_66:4.9
	Kernel-5_65:4.9
	Kernel-5_64:4.9
	Kernel-5_63:4.9
	Kernel-5_62:4.9
	Kernel-5_61:4.9
	Kernel-5_60:4.9
	Kernel-5_59:4.9
	Kernel-5_58:4.9
	Kernel-5_57:4.9
	Kernel-5_56:4.9
	Kernel-5_55:4.9
	Kernel-5_54:4.9
	Kernel-5_53:4.9
	Kernel-5_52:4.9
	Kernel-5_51:4.9
	Kernel-5_50:4.8
	Kernel-5_49:4.8
	HAL_merge:4.6.2.23
	Kernel-5_48:4.7
	Kernel-5_35-4_79_2_327:4.6.2.23
	Kernel-5_35-4_79_2_326:4.6.2.23
	Kernel-5_35-4_79_2_325:4.6.2.23
	Kernel-5_35-4_79_2_324:4.6.2.23
	Kernel-5_35-4_79_2_323:4.6.2.23
	Kernel-5_35-4_79_2_322:4.6.2.23
	Kernel-5_35-4_79_2_321:4.6.2.23
	Kernel-5_35-4_79_2_320:4.6.2.23
	Kernel-5_35-4_79_2_319:4.6.2.23
	Kernel-5_35-4_79_2_318:4.6.2.23
	Kernel-5_35-4_79_2_317:4.6.2.22
	Kernel-5_35-4_79_2_316:4.6.2.22
	Kernel-5_35-4_79_2_315:4.6.2.22
	Kernel-5_35-4_79_2_314:4.6.2.22
	Kernel-5_35-4_79_2_313:4.6.2.22
	Kernel-5_35-4_79_2_312:4.6.2.22
	Kernel-5_35-4_79_2_311:4.6.2.22
	Kernel-5_35-4_79_2_310:4.6.2.22
	Kernel-5_35-4_79_2_309:4.6.2.22
	Kernel-5_35-4_79_2_308:4.6.2.22
	Kernel-5_35-4_79_2_307:4.6.2.22
	Kernel-5_35-4_79_2_306:4.6.2.22
	Kernel-5_35-4_79_2_305:4.6.2.22
	Kernel-5_35-4_79_2_304:4.6.2.22
	Kernel-5_35-4_79_2_303:4.6.2.22
	Kernel-5_35-4_79_2_302:4.6.2.22
	Kernel-5_35-4_79_2_301:4.6.2.21
	Kernel-5_35-4_79_2_300:4.6.2.21
	Kernel-5_35-4_79_2_299:4.6.2.21
	Kernel-5_35-4_79_2_298:4.6.2.21
	Kernel-5_35-4_79_2_297:4.6.2.21
	Kernel-5_35-4_79_2_296:4.6.2.21
	Kernel-5_35-4_79_2_295:4.6.2.21
	Kernel-5_35-4_79_2_294:4.6.2.21
	Kernel-5_35-4_79_2_293:4.6.2.21
	Kernel-5_35-4_79_2_292:4.6.2.21
	Kernel-5_35-4_79_2_291:4.6.2.21
	Kernel-5_35-4_79_2_290:4.6.2.21
	Kernel-5_35-4_79_2_289:4.6.2.21
	Kernel-5_35-4_79_2_288:4.6.2.21
	Kernel-5_35-4_79_2_287:4.6.2.21
	Kernel-5_35-4_79_2_286:4.6.2.21
	Kernel-5_35-4_79_2_285:4.6.2.21
	Kernel-5_35-4_79_2_284:4.6.2.21
	Kernel-5_35-4_79_2_283:4.6.2.21
	Kernel-5_35-4_79_2_282:4.6.2.21
	Kernel-5_35-4_79_2_281:4.6.2.21
	Kernel-5_35-4_79_2_280:4.6.2.21
	Kernel-5_35-4_79_2_279:4.6.2.21
	Kernel-5_35-4_79_2_278:4.6.2.21
	Kernel-5_35-4_79_2_277:4.6.2.21
	Kernel-5_35-4_79_2_276:4.6.2.21
	Kernel-5_35-4_79_2_275:4.6.2.21
	Kernel-5_35-4_79_2_274:4.6.2.21
	Kernel-5_35-4_79_2_273:4.6.2.21
	Kernel-5_35-4_79_2_272:4.6.2.21
	Kernel-5_35-4_79_2_271:4.6.2.21
	Kernel-5_35-4_79_2_270:4.6.2.21
	Kernel-5_35-4_79_2_269:4.6.2.21
	Kernel-5_35-4_79_2_268:4.6.2.21
	Kernel-5_35-4_79_2_267:4.6.2.21
	Kernel-5_35-4_79_2_266:4.6.2.21
	Kernel-5_35-4_79_2_265:4.6.2.21
	Kernel-5_35-4_79_2_264:4.6.2.21
	Kernel-5_35-4_79_2_263:4.6.2.21
	Kernel-5_35-4_79_2_262:4.6.2.21
	Kernel-5_35-4_79_2_261:4.6.2.21
	Kernel-5_35-4_79_2_260:4.6.2.21
	Kernel-5_35-4_79_2_259:4.6.2.21
	Kernel-5_35-4_79_2_258:4.6.2.21
	Kernel-5_35-4_79_2_257:4.6.2.21
	Kernel-5_35-4_79_2_256:4.6.2.21
	Kernel-5_35-4_79_2_255:4.6.2.21
	Kernel-5_35-4_79_2_254:4.6.2.21
	Kernel-5_35-4_79_2_253:4.6.2.21
	Kernel-5_35-4_79_2_252:4.6.2.21
	Kernel-5_35-4_79_2_251:4.6.2.21
	Kernel-5_35-4_79_2_250:4.6.2.21
	Kernel-5_35-4_79_2_249:4.6.2.21
	Kernel-5_35-4_79_2_248:4.6.2.21
	Kernel-5_35-4_79_2_247:4.6.2.21
	Kernel-5_35-4_79_2_246:4.6.2.21
	Kernel-5_35-4_79_2_245:4.6.2.21
	Kernel-5_35-4_79_2_244:4.6.2.21
	Kernel-5_35-4_79_2_243:4.6.2.21
	Kernel-5_35-4_79_2_242:4.6.2.21
	Kernel-5_35-4_79_2_241:4.6.2.21
	Kernel-5_35-4_79_2_240:4.6.2.21
	Kernel-5_35-4_79_2_239:4.6.2.21
	Kernel-5_35-4_79_2_238:4.6.2.21
	Kernel-5_35-4_79_2_237:4.6.2.21
	Kernel-5_35-4_79_2_236:4.6.2.21
	Kernel-5_35-4_79_2_235:4.6.2.21
	Kernel-5_35-4_79_2_234:4.6.2.21
	Kernel-5_35-4_79_2_233:4.6.2.21
	Kernel-5_35-4_79_2_232:4.6.2.21
	Kernel-5_35-4_79_2_231:4.6.2.21
	Kernel-5_35-4_79_2_230:4.6.2.21
	Kernel-5_35-4_79_2_229:4.6.2.21
	Kernel-5_35-4_79_2_228:4.6.2.21
	Kernel-5_35-4_79_2_227:4.6.2.21
	Kernel-5_35-4_79_2_226:4.6.2.21
	Kernel-5_35-4_79_2_225:4.6.2.21
	Kernel-5_35-4_79_2_224:4.6.2.21
	Kernel-5_35-4_79_2_223:4.6.2.21
	Kernel-5_35-4_79_2_222:4.6.2.21
	Kernel-5_35-4_79_2_221:4.6.2.21
	Kernel-5_35-4_79_2_220:4.6.2.21
	Kernel-5_35-4_79_2_219:4.6.2.20
	Kernel-5_35-4_79_2_218:4.6.2.20
	Kernel-5_35-4_79_2_217:4.6.2.20
	Kernel-5_35-4_79_2_216:4.6.2.20
	Kernel-5_35-4_79_2_215:4.6.2.19
	Kernel-5_35-4_79_2_214:4.6.2.19
	Kernel-5_35-4_79_2_213:4.6.2.19
	Kernel-5_35-4_79_2_212:4.6.2.19
	Kernel-5_35-4_79_2_211:4.6.2.19
	Kernel-5_35-4_79_2_210:4.6.2.19
	Kernel-5_35-4_79_2_209:4.6.2.18
	Kernel-5_35-4_79_2_208:4.6.2.18
	Kernel-5_35-4_79_2_207:4.6.2.18
	Kernel-5_35-4_79_2_206:4.6.2.18
	Kernel-5_35-4_79_2_205:4.6.2.17
	Kernel-5_35-4_79_2_204:4.6.2.17
	Kernel-5_35-4_79_2_203:4.6.2.17
	Kernel-5_35-4_79_2_202:4.6.2.16
	Kernel-5_35-4_79_2_201:4.6.2.16
	Kernel-5_35-4_79_2_200:4.6.2.16
	Kernel-5_35-4_79_2_199:4.6.2.16
	Kernel-5_35-4_79_2_198:4.6.2.16
	Kernel-5_35-4_79_2_197:4.6.2.16
	Kernel-5_35-4_79_2_196:4.6.2.15
	Kernel-5_35-4_79_2_195:4.6.2.15
	Kernel-5_35-4_79_2_194:4.6.2.14
	Kernel-5_35-4_79_2_193:4.6.2.13
	Kernel-5_35-4_79_2_192:4.6.2.13
	Kernel-5_35-4_79_2_191:4.6.2.13
	Kernel-5_35-4_79_2_190:4.6.2.13
	Kernel-5_35-4_79_2_189:4.6.2.13
	Kernel-5_35-4_79_2_188:4.6.2.13
	Kernel-5_35-4_79_2_187:4.6.2.13
	Kernel-5_35-4_79_2_186:4.6.2.13
	Kernel-5_35-4_79_2_185:4.6.2.13
	Kernel-5_35-4_79_2_184:4.6.2.13
	Kernel-5_35-4_79_2_183:4.6.2.13
	Kernel-5_35-4_79_2_182:4.6.2.13
	Kernel-5_35-4_79_2_181:4.6.2.13
	Kernel-5_35-4_79_2_180:4.6.2.13
	Kernel-5_35-4_79_2_179:4.6.2.13
	Kernel-5_35-4_79_2_178:4.6.2.13
	Kernel-5_35-4_79_2_177:4.6.2.13
	Kernel-5_35-4_79_2_176:4.6.2.13
	Kernel-5_35-4_79_2_175:4.6.2.12
	Kernel-5_35-4_79_2_174:4.6.2.12
	Kernel-5_35-4_79_2_173:4.6.2.11
	Kernel-5_35-4_79_2_172:4.6.2.11
	Kernel-5_35-4_79_2_171:4.6.2.11
	Kernel-5_35-4_79_2_170:4.6.2.11
	Kernel-5_35-4_79_2_169:4.6.2.11
	Kernel-5_35-4_79_2_168:4.6.2.11
	Kernel-5_35-4_79_2_167:4.6.2.11
	Kernel-5_35-4_79_2_166:4.6.2.11
	Kernel-5_35-4_79_2_165:4.6.2.11
	RPi_merge:4.6.2.9.2.4
	Kernel-5_35-4_79_2_147_2_23:4.6.2.9.2.4
	Kernel-5_35-4_79_2_147_2_22:4.6.2.9.2.3
	Kernel-5_35-4_79_2_147_2_21:4.6.2.9.2.3
	Kernel-5_35-4_79_2_147_2_20:4.6.2.9.2.3
	Kernel-5_35-4_79_2_147_2_19:4.6.2.9.2.2
	Kernel-5_35-4_79_2_147_2_18:4.6.2.9.2.2
	Kernel-5_35-4_79_2_164:4.6.2.11
	Kernel-5_35-4_79_2_163:4.6.2.11
	Kernel-5_35-4_79_2_147_2_17:4.6.2.9.2.1
	Kernel-5_35-4_79_2_147_2_16:4.6.2.9.2.1
	Kernel-5_35-4_79_2_147_2_15:4.6.2.9.2.1
	Kernel-5_35-4_79_2_162:4.6.2.11
	Kernel-5_35-4_79_2_161:4.6.2.11
	Kernel-5_35-4_79_2_147_2_14:4.6.2.9.2.1
	Kernel-5_35-4_79_2_147_2_13:4.6.2.9.2.1
	Kernel-5_35-4_79_2_160:4.6.2.11
	Kernel-5_35-4_79_2_159:4.6.2.11
	Kernel-5_35-4_79_2_158:4.6.2.10
	Kernel-5_35-4_79_2_157:4.6.2.10
	Kernel-5_35-4_79_2_156:4.6.2.10
	Kernel-5_35-4_79_2_147_2_12:4.6.2.9.2.1
	Kernel-5_35-4_79_2_147_2_11:4.6.2.9.2.1
	Kernel-5_35-4_79_2_155:4.6.2.10
	Kernel-5_35-4_79_2_147_2_10:4.6.2.9.2.1
	Kernel-5_35-4_79_2_154:4.6.2.10
	Kernel-5_35-4_79_2_153:4.6.2.10
	Kernel-5_35-4_79_2_147_2_9:4.6.2.9.2.1
	Kernel-5_35-4_79_2_152:4.6.2.10
	Kernel-5_35-4_79_2_151:4.6.2.10
	Kernel-5_35-4_79_2_147_2_8:4.6.2.9.2.1
	Kernel-5_35-4_79_2_147_2_7:4.6.2.9.2.1
	Kernel-5_35-4_79_2_150:4.6.2.10
	Kernel-5_35-4_79_2_147_2_6:4.6.2.9.2.1
	Kernel-5_35-4_79_2_147_2_5:4.6.2.9.2.1
	Kernel-5_35-4_79_2_149:4.6.2.9
	Kernel-5_35-4_79_2_147_2_4:4.6.2.9.2.1
	Kernel-5_35-4_79_2_147_2_3:4.6.2.9.2.1
	Kernel-5_35-4_79_2_148:4.6.2.9
	Kernel-5_35-4_79_2_147_2_2:4.6.2.9.2.1
	Kernel-5_35-4_79_2_147_2_1:4.6.2.9.2.1
	RPi:4.6.2.9.0.2
	RPi_bp:4.6.2.9
	Kernel-5_35-4_79_2_98_2_52_2_1:4.6.2.7.2.2.2.1
	alees_Kernel_dev:4.6.2.7.2.2.0.2
	alees_Kernel_dev_bp:4.6.2.7.2.2
	Kernel-5_35-4_79_2_147:4.6.2.9
	Kernel-5_35-4_79_2_146:4.6.2.9
	Kernel-5_35-4_79_2_145:4.6.2.9
	Kernel-5_35-4_79_2_144:4.6.2.9
	Kernel-5_35-4_79_2_143:4.6.2.9
	Kernel-5_35-4_79_2_142:4.6.2.9
	Kernel-5_35-4_79_2_141:4.6.2.9
	Kernel-5_35-4_79_2_140:4.6.2.9
	Kernel-5_35-4_79_2_139:4.6.2.9
	Kernel-5_35-4_79_2_138:4.6.2.9
	Kernel-5_35-4_79_2_137:4.6.2.9
	Kernel-5_35-4_79_2_136:4.6.2.9
	Kernel-5_35-4_79_2_135:4.6.2.9
	Kernel-5_35-4_79_2_134:4.6.2.9
	Kernel-5_35-4_79_2_133:4.6.2.9
	Kernel-5_35-4_79_2_132:4.6.2.9
	Kernel-5_35-4_79_2_131:4.6.2.9
	Kernel-5_35-4_79_2_130:4.6.2.9
	Kernel-5_35-4_79_2_129:4.6.2.9
	Kernel-5_35-4_79_2_128:4.6.2.9
	Kernel-5_35-4_79_2_127:4.6.2.8
	Kernel-5_35-4_79_2_126:4.6.2.8
	Kernel-5_35-4_79_2_125:4.6.2.8
	Kernel-5_35-4_79_2_124:4.6.2.8
	Kernel-5_35-4_79_2_123:4.6.2.8
	Cortex_merge:4.6.2.7.2.2
	Kernel-5_35-4_79_2_122:4.6.2.7
	Kernel-5_35-4_79_2_98_2_54:4.6.2.7.2.2
	Kernel-5_35-4_79_2_98_2_53:4.6.2.7.2.2
	Kernel-5_35-4_79_2_98_2_52:4.6.2.7.2.2
	Kernel-5_35-4_79_2_98_2_51:4.6.2.7.2.2
	Kernel-5_35-4_79_2_98_2_50:4.6.2.7.2.2
	Kernel-5_35-4_79_2_98_2_49:4.6.2.7.2.2
	Kernel-5_35-4_79_2_98_2_48:4.6.2.7.2.2
	Kernel-5_35-4_79_2_121:4.6.2.7
	Kernel-5_35-4_79_2_98_2_47:4.6.2.7.2.1
	Kernel-5_35-4_79_2_120:4.6.2.7
	Kernel-5_35-4_79_2_98_2_46:4.6.2.7.2.1
	Kernel-5_35-4_79_2_119:4.6.2.7
	Kernel-5_35-4_79_2_98_2_45:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_44:4.6.2.7.2.1
	Kernel-5_35-4_79_2_118:4.6.2.7
	Kernel-5_35-4_79_2_98_2_43:4.6.2.7.2.1
	Kernel-5_35-4_79_2_117:4.6.2.7
	Kernel-5_35-4_79_2_116:4.6.2.7
	Kernel-5_35-4_79_2_98_2_42:4.6.2.7.2.1
	Kernel-5_35-4_79_2_115:4.6.2.7
	Kernel-5_35-4_79_2_98_2_41:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_40:4.6.2.7.2.1
	Kernel-5_35-4_79_2_114:4.6.2.7
	Kernel-5_35-4_79_2_98_2_39:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_38:4.6.2.7.2.1
	Kernel-5_35-4_79_2_113:4.6.2.7
	Kernel-5_35-4_79_2_112:4.6.2.7
	Kernel-5_35-4_79_2_98_2_37:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_36:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_35:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_34:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_33:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_32:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_31:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_30:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_29:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_28:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_27:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_26:4.6.2.7.2.1
	Kernel-5_35-4_79_2_111:4.6.2.7
	Kernel-5_35-4_79_2_98_2_25:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_24:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_23:4.6.2.7.2.1
	Kernel-5_35-4_79_2_110:4.6.2.7
	Kernel-5_35-4_79_2_98_2_22:4.6.2.7.2.1
	Kernel-5_35-4_79_2_109:4.6.2.7
	Kernel-5_35-4_79_2_98_2_21:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_20:4.6.2.7.2.1
	Kernel-5_35-4_79_2_108:4.6.2.7
	Kernel-5_35-4_79_2_107:4.6.2.7
	Kernel-5_35-4_79_2_98_2_19:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_18:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_17:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_16:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_15:4.6.2.7.2.1
	Kernel-5_35-4_79_2_106:4.6.2.7
	Kernel-5_35-4_79_2_105:4.6.2.7
	Kernel-5_35-4_79_2_104:4.6.2.7
	Kernel-5_35-4_79_2_98_2_14:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_13:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_12:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_11:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_10:4.6.2.7.2.1
	Kernel-5_35-4_79_2_98_2_9:4.6.2.7.2.1
	Kernel-5_35-4_79_2_103:4.6.2.7
	Kernel-5_35-4_79_2_102:4.6.2.7
	Kernel-5_35-4_79_2_98_2_8:4.6.2.7
	Kernel-5_35-4_79_2_98_2_7:4.6.2.7
	Kernel-5_35-4_79_2_98_2_6:4.6.2.7
	Kernel-5_35-4_79_2_98_2_5:4.6.2.7
	Kernel-5_35-4_79_2_98_2_4:4.6.2.7
	Kernel-5_35-4_79_2_101:4.6.2.7
	Kernel-5_35-4_79_2_100:4.6.2.7
	Kernel-5_35-4_79_2_99:4.6.2.7
	Kernel-5_35-4_79_2_98_2_3:4.6.2.7
	Kernel-5_35-4_79_2_98_2_2:4.6.2.7
	Kernel-5_35-4_79_2_98_2_1:4.6.2.7
	Cortex:4.6.2.7.0.2
	Cortex_bp:4.6.2.7
	Kernel-5_35-4_79_2_98:4.6.2.7
	Kernel-5_35-4_79_2_97:4.6.2.7
	Kernel-5_35-4_79_2_96:4.6.2.7
	Kernel-5_35-4_79_2_95:4.6.2.7
	Kernel-5_35-4_79_2_94:4.6.2.7
	Kernel-5_35-4_79_2_93:4.6.2.7
	Kernel-5_35-4_79_2_92:4.6.2.7
	Kernel-5_35-4_79_2_91:4.6.2.7
	Kernel-5_35-4_79_2_90:4.6.2.7
	Kernel-5_35-4_79_2_89:4.6.2.7
	Kernel-5_35-4_79_2_88:4.6.2.7
	Kernel-5_35-4_79_2_87:4.6.2.7
	Kernel-5_35-4_79_2_86:4.6.2.7
	Kernel-5_35-4_79_2_85:4.6.2.7
	Kernel-5_35-4_79_2_84:4.6.2.7
	Kernel-5_35-4_79_2_83:4.6.2.7
	Kernel-5_35-4_79_2_82:4.6.2.7
	Kernel-5_35-4_79_2_81:4.6.2.7
	Kernel-5_35-4_79_2_80:4.6.2.7
	Kernel-5_35-4_79_2_79:4.6.2.7
	Kernel-5_35-4_79_2_78:4.6.2.7
	Kernel-5_35-4_79_2_77:4.6.2.7
	RO_5_07:4.6.2.7
	Kernel-5_35-4_79_2_76:4.6.2.7
	Kernel-5_35-4_79_2_75:4.6.2.7
	Kernel-5_35-4_79_2_74:4.6.2.7
	Kernel-5_35-4_79_2_73:4.6.2.7
	Kernel-5_35-4_79_2_72:4.6.2.7
	Kernel-5_35-4_79_2_71:4.6.2.7
	Kernel-5_35-4_79_2_70:4.6.2.7
	Kernel-5_35-4_79_2_69:4.6.2.7
	Kernel-5_35-4_79_2_68:4.6.2.7
	Kernel-5_35-4_79_2_67:4.6.2.6
	Kernel-5_35-4_79_2_66:4.6.2.6
	Kernel-5_35-4_79_2_65:4.6.2.6
	Kernel-5_35-4_79_2_64:4.6.2.6
	Kernel-5_35-4_79_2_63:4.6.2.6
	Kernel-5_35-4_79_2_62:4.6.2.6
	Kernel-5_35-4_79_2_61:4.6.2.6
	Kernel-5_35-4_79_2_59:4.6.2.6
	Kernel-5_35-4_79_2_58:4.6.2.6
	Kernel-5_35-4_79_2_57:4.6.2.6
	Kernel-5_35-4_79_2_56:4.6.2.6
	Kernel-5_35-4_79_2_55:4.6.2.6
	Kernel-5_35-4_79_2_54:4.6.2.6
	Kernel-5_35-4_79_2_53:4.6.2.6
	Kernel-5_35-4_79_2_52:4.6.2.6
	Kernel-5_35-4_79_2_51:4.6.2.6
	Kernel-5_35-4_79_2_50:4.6.2.5
	Kernel-5_35-4_79_2_49:4.6.2.5
	Kernel-5_35-4_79_2_48:4.6.2.5
	Kernel-5_47:4.6
	Kernel-5_46-4_90_2_1:4.6
	nbingham_Kernel_FastNC_dev_bp:4.6
	nbingham_Kernel_FastNC_dev:4.6.0.4
	Kernel-5_46:4.6
	Kernel-5_45:4.6
	Kernel-5_35-4_79_2_47:4.6.2.4
	Kernel-5_35-4_79_2_46:4.6.2.4
	Kernel-5_35-4_79_2_45:4.6.2.4
	Kernel-5_35-4_79_2_44:4.6.2.4
	Kernel-5_35-4_79_2_25_2_2:4.6.2.4
	Kernel-5_35-4_79_2_43:4.6.2.4
	Kernel-5_35-4_79_2_42:4.6.2.4
	Kernel-5_35-4_79_2_41:4.6.2.4
	Kernel-5_35-4_79_2_40:4.6.2.4
	Kernel-5_35-4_79_2_39:4.6.2.4
	Kernel-5_35-4_79_2_38:4.6.2.4
	Kernel-5_35-4_79_2_37:4.6.2.4
	Kernel-5_35-4_79_2_36:4.6.2.4
	Kernel-5_35-4_79_2_35:4.6.2.4
	Kernel-5_35-4_79_2_34:4.6.2.4
	Kernel-5_35-4_79_2_33:4.6.2.4
	Kernel-5_35-4_79_2_32:4.6.2.4
	Kernel-5_44:4.6
	Kernel-5_35-4_79_2_25_2_1:4.6.2.4
	Kernel-5_43:4.6
	Kernel-5_35-4_79_2_31:4.6.2.4
	Kernel-5_35-4_79_2_30:4.6.2.4
	Kernel-5_35-4_79_2_29:4.6.2.4
	Kernel-5_35-4_79_2_28:4.6.2.4
	Kernel-5_35-4_79_2_27:4.6.2.4
	Kernel-5_35-4_79_2_26:4.6.2.4
	Kernel-5_42:4.6
	Kernel-5_41:4.6
	Kernel-5_40:4.6
	Kernel-5_35-4_79_2_25:4.6.2.4
	Kernel-5_35-4_79_2_24:4.6.2.4
	Kernel-5_35-4_79_2_23:4.6.2.4
	Kernel-5_35-4_79_2_22:4.6.2.4
	Kernel-5_35-4_79_2_21:4.6.2.4
	Kernel-5_35-4_79_2_20:4.6.2.4
	Kernel-5_35-4_79_2_19:4.6.2.4
	Kernel-5_35-4_79_2_18:4.6.2.3
	Kernel-5_35-4_79_2_17:4.6.2.3
	Kernel-5_35-4_79_2_16:4.6.2.3
	Kernel-5_35-4_79_2_15:4.6.2.3
	Kernel-5_35-4_79_2_14:4.6.2.2
	Kernel-5_39:4.6
	Kernel-5_13-4_52_2_1:4.4
	Bethany:4.4.0.2
	Kernel-5_38:4.6
	Kernel-5_35-4_79_2_13:4.6.2.2
	Kernel-5_35-4_79_2_12:4.6.2.2
	Kernel-5_35-4_79_2_11:4.6.2.2
	Kernel-5_37:4.6
	Kernel-5_35-4_79_2_10:4.6.2.2
	Kernel-5_35-4_79_2_9:4.6.2.2
	Kernel-5_36:4.6
	Kernel-5_35-4_79_2_8:4.6.2.2
	Kernel-5_35-4_79_2_7:4.6.2.2
	Kernel-5_35-4_79_2_6:4.6.2.2
	Kernel-5_35-4_79_2_5:4.6.2.2
	Kernel-5_35-4_79_2_4:4.6.2.2
	Kernel-5_35-4_79_2_3:4.6.2.2
	Kernel-5_35-4_79_2_2:4.6.2.1
	dellis_autobuild_BaseSW:4.6
	Kernel-5_35-4_79_2_1:4.6.2.1
	HAL:4.6.0.2
	Kernel-5_35:4.6
	Kernel-5_34:4.6
	Kernel-5_33:4.6
	Kernel-5_32:4.6
	Kernel-5_31:4.6
	Kernel-5_30:4.6
	Kernel-5_29:4.6
	Kernel-5_28:4.6
	Kernel-5_27:4.6
	Kernel-5_26:4.6
	Kernel-5_25:4.6
	Kernel-5_24:4.5
	Kernel-5_23:4.5
	Kernel-5_22:4.4
	sbrodie_sedwards_16Mar2000:4.4
	Kernel-5_21:4.4
	Kernel-5_20:4.4
	Kernel-5_19:4.4
	Kernel-5_18:4.4
	Kernel-5_17:4.4
	Kernel-5_16:4.4
	Kernel-5_15:4.4
	Kernel-5_14:4.4
	Kernel-5_13:4.4
	Kernel-5_12:4.4
	Kernel-5_11:4.4
	Kernel-5_10:4.4
	Kernel-5_09:4.4
	Kernel-5_08:4.4
	Kernel-5_07:4.4
	Kernel-5_06:4.4
	Kernel-5_05:4.4
	Kernel-5_04:4.4
	Kernel-5_03:4.4
	Kernel-5_02:4.4
	Kernel-5_01:4.4
	Kernel-5_00:4.4
	Kernel-4_99:4.4
	Kernel-4_98:4.4
	Kernel-4_97:4.4
	Kernel-4_96:4.4
	Kernel-4_95:4.4
	Kernel-4_94:4.4
	Kernel-4_93:4.4
	Kernel-4_92:4.4
	Kernel-4_91:4.4
	Kernel-4_90:4.4
	dcotton_autobuild_BaseSW:4.6
	Kernel-4_89:4.3
	Kernel-4_88:4.3
	Kernel-4_87:4.3
	Kernel-4_86:4.3
	Kernel-4_85:4.3
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.3.2.1
	Kernel-4_84:4.3
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.3.2.1
	Ursula_RiscPC_bp:4.2.2.3
	Kernel-4_83:4.3
	Kernel-4_82:4.3
	Kernel-4_81:4.3
	Kernel-4_80:4.3
	Kernel-4_79:4.3
	Kernel-4_78:4.3
	Kernel-4_77:4.3
	Kernel-4_76:4.3
	Kernel-4_75:4.3
	Kernel-4_74:4.3
	Kernel-4_73:4.3
	Kernel-4_72:4.3
	Kernel-4_71:4.3
	Kernel-4_70:4.3
	Kernel-4_69:4.3
	Kernel-4_68:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.3.2.1
	Ursula_RiscPC:4.2.2.3.0.2
	Kernel-4_63-1_1_2_5:4.1.7.2
	Kernel-4_63-1_1_2_4:4.1.7.2
	Kernel-4_67:4.3
	Kernel-4_66:4.3
	Kernel-4_63-1_1_2_3:4.1.7.2
	Kernel-4_65:4.3
	Ursula_merge:4.2
	Kernel-4_64:4.3
	mstphens_Kernel-3_81:4.2.2.4
	Kernel-4_63-1_1_2_2:4.1.7.2
	nicke_Kernel_4_62:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.3
	UrsulaBuild_FinalSoftload:4.2.2.3
	rthornb_UrsulaBuild-12Aug1998:4.2.2.3
	aglover_UrsulaBuild-05Aug1998:4.2.2.3
	rthornb_UrsulaBuild-29Jul1998:4.2.2.3
	rthornb_UrsulaBuild-22Jul1998:4.2.2.3
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.3
	rthornb_UrsulaBuild-07Jul1998:4.2.2.3
	rthornb_UrsulaBuild-17Jun1998:4.2.2.3
	rthornb_UrsulaBuild-03Jun1998:4.2.2.3
	rthornb_UrsulaBuild-27May1998:4.2.2.3
	mstphens_Kernel-3_80:4.2.2.3
	rthornb_UrsulaBuild-21May1998:4.2.2.3
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.3
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2018.11.07.22.28.13;	author jlee;	state Exp;
branches;
next	4.12;
commitid	Ub9LVqEF46x8X3ZA;

4.12
date	2017.06.13.21.03.46;	author jlee;	state Exp;
branches;
next	4.11;
commitid	AnFxxd2I6mszWfVz;

4.11
date	2016.12.15.18.33.33;	author jlee;	state Exp;
branches;
next	4.10;
commitid	ATZJJqFZmHhMT6yz;

4.10
date	2016.12.15.15.27.03;	author jlee;	state Exp;
branches;
next	4.9;
commitid	SNoEvPlWCrTKR5yz;

4.9
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches;
next	4.8;
commitid	skOEjp3ipLHx6xcz;

4.8
date	2016.06.30.20.29.06;	author jlee;	state Exp;
branches;
next	4.7;
commitid	lMnWzoE9eJz3Wwcz;

4.7
date	2016.06.30.20.08.20;	author jlee;	state Exp;
branches;
next	4.6;
commitid	IWoXxARWeuLDOwcz;

4.6
date	2000.04.17.14.22.53;	author kbracey;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2000.04.04.14.27.43;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.09.29.17.09.34;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.09.30.08.42.58;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.07.42;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.42;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2000.09.15.12.38.02;	author kbracey;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2000.10.03.12.06.00;	author mstephen;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2001.01.12.13.52.13;	author mstephen;	state Exp;
branches;
next	4.6.2.4;

4.6.2.4
date	2001.03.07.15.13.00;	author kbracey;	state Exp;
branches;
next	4.6.2.5;

4.6.2.5
date	2002.10.07.17.29.46;	author kbracey;	state Exp;
branches;
next	4.6.2.6;

4.6.2.6
date	2002.11.30.00.31.14;	author bavison;	state Exp;
branches;
next	4.6.2.7;

4.6.2.7
date	2004.06.18.14.38.55;	author bavison;	state Exp;
branches
	4.6.2.7.2.1;
next	4.6.2.8;

4.6.2.8
date	2011.11.26.21.11.29;	author jlee;	state Exp;
branches;
next	4.6.2.9;
commitid	cI3W0zbtALQG6TIv;

4.6.2.9
date	2011.12.10.19.03.49;	author jlee;	state Exp;
branches
	4.6.2.9.2.1;
next	4.6.2.10;
commitid	tEbdTPC2UwO3XFKv;

4.6.2.10
date	2012.05.21.19.31.44;	author rsprowson;	state Exp;
branches;
next	4.6.2.11;
commitid	oEtPURiKNEPMRC5w;

4.6.2.11
date	2012.07.04.17.50.58;	author rsprowson;	state Exp;
branches;
next	4.6.2.12;
commitid	BwjRc3GMlaDwTgbw;

4.6.2.12
date	2012.10.28.16.51.52;	author rsprowson;	state Exp;
branches;
next	4.6.2.13;
commitid	ruXZqdTJKJ85Qaqw;

4.6.2.13
date	2012.11.17.14.45.37;	author rsprowson;	state Exp;
branches;
next	4.6.2.14;
commitid	AATwE9nsGuEZuJsw;

4.6.2.14
date	2013.08.06.22.43.11;	author jlee;	state Exp;
branches;
next	4.6.2.15;
commitid	TOIaeUf2Q4rBIr0x;

4.6.2.15
date	2013.08.07.21.21.24;	author jlee;	state Exp;
branches;
next	4.6.2.16;
commitid	ZCsSS95hs01Dez0x;

4.6.2.16
date	2013.10.06.18.02.42;	author jlee;	state Exp;
branches;
next	4.6.2.17;
commitid	6Bp9Hz2X0M7Ucg8x;

4.6.2.17
date	2013.12.15.21.34.14;	author jlee;	state Exp;
branches;
next	4.6.2.18;
commitid	KwuK29hKRyXO7hhx;

4.6.2.18
date	2013.12.19.00.09.00;	author jlee;	state Exp;
branches;
next	4.6.2.19;
commitid	sFhm1gbZFIB4TFhx;

4.6.2.19
date	2014.03.09.15.57.03;	author jlee;	state Exp;
branches;
next	4.6.2.20;
commitid	FnXbK143NQLRy2sx;

4.6.2.20
date	2014.04.06.19.23.29;	author jlee;	state Exp;
branches;
next	4.6.2.21;
commitid	EtypGk33aKVRNEvx;

4.6.2.21
date	2014.04.18.14.10.56;	author jlee;	state Exp;
branches;
next	4.6.2.22;
commitid	4EaaKIpUowBKGaxx;

4.6.2.22
date	2016.01.06.22.14.38;	author jlee;	state Exp;
branches;
next	4.6.2.23;
commitid	nCWrOk75Tem9bVPy;

4.6.2.23
date	2016.05.08.17.11.14;	author jlee;	state Exp;
branches;
next	;
commitid	H8vGguuJRqFVxH5z;

4.6.2.7.2.1
date	2009.06.15.23.56.11;	author bavison;	state Exp;
branches;
next	4.6.2.7.2.2;

4.6.2.7.2.2
date	2011.08.08.23.28.38;	author jlee;	state Exp;
branches
	4.6.2.7.2.2.2.1;
next	;
commitid	D7rzILnwRRSXoLuv;

4.6.2.7.2.2.2.1
date	2012.05.10.03.10.02;	author bavison;	state Exp;
branches;
next	;
commitid	HTVG5Da5tRqSM74w;

4.6.2.9.2.1
date	2012.05.10.03.28.13;	author bavison;	state Exp;
branches;
next	4.6.2.9.2.2;
commitid	kuJoT3AcfB16T74w;

4.6.2.9.2.2
date	2012.09.02.19.56.55;	author jlee;	state Exp;
branches;
next	4.6.2.9.2.3;
commitid	q3Bny0G3EqBdFZiw;

4.6.2.9.2.3
date	2012.09.07.23.05.59;	author jlee;	state Exp;
branches;
next	4.6.2.9.2.4;
commitid	Ik0jMROsIiH5yEjw;

4.6.2.9.2.4
date	2012.09.18.15.50.12;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.2.2.1
date	97.05.21.09.30.46;	author mstphens;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.09.09.13.34.54;	author mstphens;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	97.10.21.15.31.40;	author mstphens;	state Exp;
branches
	4.2.2.3.2.1;
next	4.2.2.4;

4.2.2.4
date	98.09.24.13.17.57;	author mstphens;	state Exp;
branches;
next	;

4.2.2.3.2.1
date	98.11.23.14.59.48;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.42;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.04.00;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.38;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.05.00;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	98.07.21.17.57.52;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Attempt to tidy up substitute screen mode selection logic
Detail:
  Over the years the OS's substitute screen mode selection logic has grown to be a tangled mess, and the logic it does implement isn't always very useful. Additionally, the kernel is structured in such a way that it can be hard for modules to override it.
  This set of changes aims to fix the many of the problems, by doing the following:
  - Moving all substitute mode selection logic out of the core VDU driver code and into a Service_ModeTranslation handler. This means you now only have one place in the kernel to look instead of several, and modules can override the behaviour by claiming/blocking the service call as appropriate.
  - Moving handling of the built-in VIDC lists out of the core VDU driver code and into a Service_ModeExtension handler. This means programs can now inspect these VIDC lists by issuing the right service call (although you are essentially limited to lists which the GraphicsV driver is OK with)
  - Moving *TV interlace & offset adjustment logic into the Service_ModeExtension handler, since they're legacy things which can be handled more cleanly for MDF/EDID (and the old code was poking memory the kernel didn't own)
  - Adding a Service_EnumerateScreenModes implementation, so that if you end up in the desktop with ScreenModes non-functional, the display manager at least has something useful to show you
  - Enhancing the handling of the built-in numbered modes so that they are now available in any colour depth; the Service_ModeExtension handler (and related handlers) treat the builtin VIDC lists as a set of mode timings, not a discrete set of modes
  - Substitute mode selection logic is a complete re-write. Instead of trying a handful of numbered fallback modes, it now tries:
    - Same mode but at higher colour depths
    - Same mode but at lower colour depths
    - Alternate resolutions (half-width mode with no double-pixel if original request was for double-pixel, and default resolution for monitor type)
  - Combined with the logic to allow the builtin VIDC lists to be used at any colour depth, this means that the kernel should now be able to find substitute modes for machines which lack support for <=8bpp modes (e.g. OMAP5)
  - Additionally the mode substitution code will attempt to retain as many properties of the originally requested mode as possible (eigen values, gap mode type, etc.)
  Other improvements:
  - The kernel now actually vets the builtin VIDC lists instead of assuming that they'll work (which also means they'll have the correct ExtraBytes value, where applicable)
  - The kernel now uses GraphicsV 19 (VetMode2) to vet the mode during the mode switch process, using the result to detect where the framebuffer will be placed. This allows for GraphicsV drivers to switch between DA 2 and external framestores on a per-mode basis.
  - The kernel now supports mode selectors which specify LineLength values which are larger than necessary; this will get translated to a suitable ExtraBytes control list item (+ combined with whatever padding the driver indicates is necessary via the VetMode2 result)
  File changes:
  - hdr/KernelWS - Reserve space for a VIDC list, since the Service_ModeExtension implementation typically can't use the built-in list as-is
  - s/Arthur3 - Issue Service_ModeFileChanged when the configured monitor type is changed, so that DisplayManager + friends are aware that the set of available modes has changed
  - s/GetAll - Fiddle with GETs a bit
  - s/MemMap2 - Extra LTORG
  - s/NewIRQs - Small routine to install/uninstall false VSync routine (previously from PushModeInfo, which wasn't really the appropriate place for it)
  - s/Utility - Hook up the extra service call handlers
  - s/vdu/legacymodes - New file containing the new service call implementations, and some related code
  - s/vdu/vdudecl - Move mode workspace definition here, from vdumodes
  - s/vdu/vdudriver - Remove assorted bits of mode substitution code. Plug in new bits for calling GraphicsV 19 during mode set, and deal with ExtraBytes/LineLength during PushModeInfo
  - s/vdu/vdumodes - Move some workspace definitions to s/vdu/vdudecl. Tweak how the builtin VIDC lists are stored.
  - s/vdu/vduswis - Rip out more mode substitution code. Issue Service_ModeFileChanged when monitor type is changed by OS_ScreenMode.
Admin:
  Tested on Raspberry Pi 3, Iyonix, IGEPv5


Version 6.14. Tagged as 'Kernel-6_14'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduSWIs

        MACRO
        BranchNotJustUs $label, $vector, $tmp1, $tmp2
        LDR     R11, =ZeroPage
         [ $tmp1=R11
         LDR     R12, [R11, #VecPtrTab+$vector*4]! ; load vector node
         |
         LDR     R12, [R11, #VecPtrTab+$vector*4]  ; load vector, leave R11=0
         ]
        CMP     R12, #&FC000000                    ; fudge
        BCC     $label
        MEND

        MACRO
        BranchNotJustUsWrch $label
        BranchNotJustUs $label, WrchV, R11, R14
        MEND

        MACRO
        SWIEntry $swiname
        &       OS_$swiname
        &       SWI$swiname-(.+4)
        MEND


; *****************************************************************************
;
;       SWIRVV - SWI ReadVduVariables handler
;
; in:   R0 -> input block
;       R1 -> output block
;
; out:  All registers preserved
;
;       The input block consists of a string of words, terminated by -1
;       Each word indicates which VDU variable to read.
;       The (word) values of these variables are put in sequence into the
;       output block (no terminator is put in this block). Invalid variables
;       are returned as zero.

SWIRVV  ROUT
SWIReadVduVariables                     ; alternative symbol used for init'ing
        TST     R0, #3                  ; input block not aligned
        TSTEQ   R1, #3                  ; or output block not aligned
        ExitSWIHandler NE               ; then exit
        Push    R9
        VDWS    WsPtr
        MOV     R10, #0                 ; offset into both blocks
10
        LDR     R11, [R0, R10]
        CMP     R11, #-1                ; end of block ?
        Pull    R9, EQ
        ExitSWIHandler EQ

        CMP     R11, #&100              ; is it fudged "code" variable
        BCS     %FT30                   ; yes, then use special code

        CMP     R11, #(SWIRVVTabModeEnd-SWIRVVTab) ; a mode variable
        ADRCC   R9, SWIRVVTab           ; if so then point to them
        BCC     %FT20
        SUB     R11, R11, #&80          ; base for non-mode variables
        CMP     R11, #(SWIRVVTabEnd-SWIRVVTabModeEnd)
        ADRCCL  R9, SWIRVVTabModeEnd
        BCC     %FT20
        SUB     R11, R11, #&40          ; base for GraphicsV variables
        CMP     R11, #(SWIRVVTabGraphicsVEnd-SWIRVVTabEnd)
        ADRCCL  R9, SWIRVVTabEnd
20
        LDRCCB  R11, [R9, R11]          ; yes, then load offset
        LDRCC   R11, [WsPtr, R11, LSL #2] ; and then load variable
        MOVCS   R11, #0                 ; no, then put zero in it
25
        STR     R11, [R1, R10]
        ADD     R10, R10, #4
        B       %BT10

; Special code to read window width for Bruce et al.

30
        SUB     R11, R11, #&100
        CMP     R11, #2                 ; 0 => WindowWidth, 1 => WindowHeight
        BCS     %BT20                   ; not one of those, so illegal

        Push    "R0-R7"
        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #Vdu5Bit
        ADDEQ   R4, WsPtr, #TWLCol      ; if VDU 4 mode, use text window
        ADDNE   R4, WsPtr, #GWLCol      ; else use graphics window
        LDMIA   R4, {R0-R3}
        SUB     R0, R2, R0              ; R0 = horizontal width -1
        SUB     R1, R1, R3              ; R1 = vertical height -1

        BEQ     %FT32

        ADD     R2, WsPtr, #GCharSizes  ; R2=GCharSizeX; R3=GCharSizeY
        LDMIA   R2, {R2-R5}             ; R4=GCharSpaceX; R5=GCharSpaceY

        TST     R6, #2                  ; if going from right to left
        SUBNE   R2, R2, #1              ; then width reduction = sizex-1
        MOVEQ   R2, #0                  ; else 0

        TST     R6, #4                  ; if going from bottom to top
        RSBNE   R3, R3, #1              ; then -height reduction = 1-sizey
        MOVEQ   R3, #0                  ; else 0

        SUB     R7, R0, R2              ; R7 = width-1-(width reduction)
        DivRem  R0, R7, R4, R2, norem   ; R0 = (width-(1 or sizex))DIV spacex

        SUB     R7, R3, R1              ; R7 = height-(1-height reduction)
        DivRem  R1, R7, R5, R3, norem   ; R1 = (height-(1 or sizey))DIV spacey
32
        TST     R6, #8                  ; are X and Y reversed ?
        EORNE   R0, R0, R1              ; yes, then swap
        EORNE   R1, R0, R1
        EORNE   R0, R0, R1

        TST     R6, #Vdu5Bit
        BNE     %FT35
        TST     R6, #1                  ; is it "81 column mode ?" and VDU 4
        ADDNE   R0, R0, #1              ; yes, then extra column
35
        TEQ     R11, #0                 ; reading width ?
        MOVEQ   R11, R0                 ; yes, then use X
        MOVNE   R11, R1                 ; no, use Y

        Pull    "R0-R7"                 ; restore registers
        B       %BT25                   ; and store result away


SWIRVVTab

; Note these first variables should be the same as in SWI ReadModeVariable

        RVVT    ModeFlags
        RVVT    ScrRCol
        RVVT    ScrBRow
        RVVT    NColour
        RVVT    XEigFactor
        RVVT    YEigFactor
        RVVT    LineLength
        RVVT    ScreenSize
        RVVT    YShftFactor
        RVVT    Log2BPP
        RVVT    Log2BPC
        RVVT    XWindLimit
        RVVT    YWindLimit
SWIRVVTabModeEnd

        RVVT    GWLCol
        RVVT    GWBRow
        RVVT    GWRCol
        RVVT    GWTRow
        RVVT    TWLCol
        RVVT    TWBRow
        RVVT    TWRCol
        RVVT    TWTRow
        RVVT    OrgX
        RVVT    OrgY
        RVVT    GCsX
        RVVT    GCsY
        RVVT    OlderCsX
        RVVT    OlderCsY
        RVVT    OldCsX
        RVVT    OldCsY
        RVVT    GCsIX
        RVVT    GCsIY
        RVVT    NewPtX
        RVVT    NewPtY
        RVVT    ScreenStart
        RVVT    DisplayStart
        RVVT    TotalScreenSize
        RVVT    GPLFMD
        RVVT    GPLBMD
        RVVT    GFCOL
        RVVT    GBCOL
        RVVT    TForeCol
        RVVT    TBackCol
        RVVT    GFTint
        RVVT    GBTint
        RVVT    TFTint
        RVVT    TBTint
        RVVT    MaxMode
        RVVT    GCharSizeX
        RVVT    GCharSizeY
        RVVT    GCharSpaceX
        RVVT    GCharSpaceY
        RVVT    HLineAddr
        RVVT    TCharSizeX
        RVVT    TCharSizeY
        RVVT    TCharSpaceX
        RVVT    TCharSpaceY
        RVVT    GcolOraEorAddr
        RVVT    VIDCClockSpeed
        RVVT    PixelRate
        RVVT    BorderL
        RVVT    BorderB
        RVVT    BorderR
        RVVT    BorderT
SWIRVVTabEnd

        RVVT    CurrentGraphicsVDriver
SWIRVVTabGraphicsVEnd        

        ALIGN

        [ {FALSE}

; *****************************************************************************
;
;       SWISetVduVariables - SWI OS_SetVduVariables handler
;
; in:   R0 -> block of variable numbers (word aligned)
;       R1 -> block of variable values (word aligned)
;
; out:  All registers preserved
;
;       The block pointed to by R0 consists of a string of words, terminated
;       by -1. Each word indicates which variable to write. The corresponding
;       value in the R1 block is written to this variable. Invalid variables
;       are ignored.
;

SWISetVduVariables ROUT
        TST     R0, #3                  ; index block not aligned
        TSTEQ   R1, #3                  ; or value block not aligned
        ExitSWIHandler NE               ; then exit
        Push    R9
        VDWS    WsPtr
        MOV     R10, #0                 ; offset into both blocks
10
        LDR     R11, [R0, R10]
        CMP     R11, #-1                ; end of block ?
        Pull    R9, EQ
        ExitSWIHandler EQ

        TEQ     R11, #VduExt_XEigFactor
        TEQNE   R11, #VduExt_YEigFactor
        BNE     %FT25

        CMP     R11, #(SWIRVVTabModeEnd-SWIRVVTab) ; a mode variable
        ADRCC   R9, SWIRVVTab           ; if so then point to them
        SUBCS   R11, R11, #&80          ; base for non-mode variables
        ADRCS   R9, SWIRVVTabModeEnd
20
        LDRB    R11, [R9, R11]          ; yes, then load offset
        LDR     R9, [R1, R10]           ; load value
        STR     R9, [WsPtr, R11, LSL #2] ; store in variable
        Push    "R0-R5,R14"
        BL      IEG                     ; update ext. cursor
                                        ; on exit, R2=XEigFactor, R3=YEigFactor
        SUBS    R0, R2, R3              ; XEigFactor-YEigFactor
        MOVLT   R0, #2                  ; X<Y => 2 (vert rect)
        MOVGT   R0, #1                  ; X>Y => 1 (horz rect) else 0 (square)
        STR     R0, [WsPtr, #AspectRatio]

; mouse bounding box, mouse position ???

        Pull    "R0-R5,R14"
25
        ADD     R10, R10, #4
        B       %BT10

        ]

; *****************************************************************************
;
;       SWIReadModeVar - Handler for SWI OS_ReadModeVariable
;
; in:   R0 = screen mode you want the information for, -1 => current mode
;       R1 = number of variable to read
;
; out:  R2 = value of variable
;

; Note: the algorithms used to derive the variables for mode selectors
; are duplicated in source.vdudriver, in GenerateModeSelectorVars

SWIReadModeVar ROUT
SWIReadModeVariable                     ; alternative symbol used for init'ing
        Push    "R0,R1,R14"

        CMP     R1, #(RMVTabEnd-RMVTab) ; valid variable number ?
        BCS     BadReadModeVar          ; no, then exit

        ; AMG - note that the new sprite mode word code assumes that this
        ;       test has been done!

        VDWS    WsPtr

; AMG - add readmodevariable returns for new format sprite mode words. Much of
;       this is munging the word passed in. A new sprite mode word can be
;       distinguished from a pointer to a mode selector structure because
;       b0 will be set in the new sprite mode word. 11/3/93

; TMD - serious optimisation introduced 17-Feb-93
; TMD - additional optimisation for current mode added 16-Mar-93

; AMG - Fix bug MED-00414 ... need to support eig=0 modes here 26-Oct-93

        CMP     r0, #-1                 ; if explicitly asking for current mode
        BEQ     RMVForCurrentMode       ; then use optimised code

        CMP     r0, #&100
        BCC     %FT11                   ; an old style mode number, branch past
                                        ; the new code below
        TST     r0, #&01
        BNE     NewSpriteModeWord       ; b0 set, so it is a NewSpriteModeWord
                                        ; rather than a pointer to a mode selector

; it's a mode selector, so check if valid first

        BL      ValidateModeSelector
        BVS     BadReadModeVar

; check if variable is in workspace list

        ADD     r10, r0, #ModeSelector_ModeVars         ; point at list
        BL      CheckWorkspaceList                      ; check list
        BCC     GoodReadModeVar                         ; [it was in list, so exit]

; not in list, so deduce from other parms
; (we know the variable number is in range)

        LDR     pc, [pc, r1, LSL #2]
        NOP
        &       RMVMS_ModeFlags
        &       RMVMS_ScrRCol
        &       RMVMS_ScrBRow
        &       RMVMS_NColour
        &       RMVMS_XEigFactor
        &       RMVMS_YEigFactor
        &       RMVMS_LineLength
        &       RMVMS_ScreenSize
        &       RMVMS_YShftFactor
        &       RMVMS_Log2BPP
        &       RMVMS_Log2BPC
        &       RMVMS_XWindLimit
        &       RMVMS_YWindLimit

RMVMS_ModeFlags
RMVMS_YShftFactor
        MOV     r2, #0                                  ; default modeflags, yshftfactor = 0
        B       GoodReadModeVar

RMVMS_ScrRCol
        LDR     r2, [r0, #ModeSelector_XRes]            ; default scrcol = (xres>>3)-1
        MOV     r2, r2, LSR #3
        SUB     r2, r2, #1
        B       GoodReadModeVar

RMVMS_ScrBRow
        LDR     r2, [r0, #ModeSelector_YRes]            ; default scrbrow = (yres>>3)-1
        MOV     r2, r2, LSR #3
        SUB     r2, r2, #1
        B       GoodReadModeVar

RMVMS_NColour
        LDR     r2, [r0, #ModeSelector_PixelDepth]
        CMP     r2, #6                                  ; if pixel depth is sensible
        ADRCCL  r11, NColourTable                       ; then lookup in table
        LDRCC   r2, [r11, r2, LSL #2]
        MOVCS   r2, #1                                  ; else return 1
        B       GoodReadModeVar

RMVMS_XEigFactor
        MOV     r2, #1                                  ; default xeig = 1
        B       GoodReadModeVar

RMVMS_YEigFactor
        LDR     r2, [r0, #ModeSelector_XRes]
        LDR     r11, [r0, #ModeSelector_YRes]
        CMP     r11, r2, LSR #1                         ; if yres < xres/2
        MOVCC   r2, #2                                  ; then yeig = 2
        MOVCS   r2, #1                                  ; else yeig = 1
        B       GoodReadModeVar

RMVMS_LineLength
        LDR     r2, [r0, #ModeSelector_XRes]
RMVMS_ShiftByPixDepthMinus3
        LDR     r11, [r0, #ModeSelector_PixelDepth]
        CMP     r11, #6                                 ; if out of range
        MOVCS   r11, #0                                 ; use log2bpp=0
        MOV     r2, r2, LSL r11
        MOV     r2, r2, LSR #3                          ; ll = (xres << pixdepth) >> 3
        B       GoodReadModeVar

RMVMS_ScreenSize
        LDR     r2, [r0, #ModeSelector_XRes]
        LDR     r11, [r0, #ModeSelector_YRes]
        MUL     r2, r11, r2                             ; xres * yres
        B       RMVMS_ShiftByPixDepthMinus3

RMVMS_Log2BPP
RMVMS_Log2BPC
        LDR     r2, [r0, #ModeSelector_PixelDepth]
        CMP     r2, #6                                  ; range check
        MOVCS   r2, #0
        B       GoodReadModeVar

RMVMS_XWindLimit
        LDR     r2, [r0, #ModeSelector_XRes]            ; default xwindlimit = xres-1
        SUB     r2, r2, #1
        B       GoodReadModeVar

RMVMS_YWindLimit
        LDR     r2, [r0, #ModeSelector_YRes]            ; default ywindlimit = yres-1
        SUB     r2, r2, #1
        B       GoodReadModeVar

11
        BIC     r11, r0, #&80           ; clear shadow bit

        BranchIfKnownMode r11, %FA50

; not known mode, so look

        Push    "r2-r4"
        MOV     r2, r11
        BL      OfferModeExtensionAnyMonitor
        MOVEQ   r11, r4                 ; if service responded to, save pointer to workspace list
        Pull    "r2-r4"
        BNE     BadReadModeVar          ; exit if mode not known about

; now search down list checking for variable number

        ADD     r10, r11, #8            ; skip list type and base mode
        BL      CheckWorkspaceList      ; look up variable in list
        BCC     GoodReadModeVar         ; if there then exit

; not in workspace list provided, so use base mode to look up in MOS's table

        LDR     r11, [r11, #4]          ; load workspace list base mode
        BranchIfKnownMode r11, %FA50

; panic - base mode unrecognised
; existing code simply loads off end of table! - instead of that, return value zero
; alternatively we could return carry set, but that might cause backward compatibility problems (maybe)

        MOV     r2, #0
        B       GoodReadModeVar

50
        ADR     r10, RMVTab
        LDRB    r10, [r10, r1]          ; R10 = offset in each mode table * 2
                                        ; if bit 0 set, then word value
        ADRL    r14, Vwstab
        LDR     r11, [r14, r11, LSL #2] ; get offset to table for this mode
        ADD     r11, r11, r14           ; convert to pointer
        MOVS    r10, r10, LSR #1        ; put byte/word flag into carry
        LDRCCB  r2, [r11, r10]          ; load either a byte
        LDRCS   r2, [r11, r10]          ; or a word out of table

; and drop thru to GoodModeVar

GoodReadModeVar
        Pull    "R0,R1,R14"
        BIC     R14, R14, #C_bit        ; indicate successful read
        ExitSWIHandler

BadReadModeVar
        Pull    "R0,R1,R14"
        ORR     R14, R14, #C_bit        ; indicate bad read
        ExitSWIHandler

; CheckWorkspaceList - Check a mode variable (index, value) list for a match
; in:   r1 = variable number
;       r10 -> list
;
; out:  If match found, then
;         r2 = value
;         C=0
;       else
;         C=1
;       endif
;       r10 corrupted in both cases

CheckWorkspaceList Entry
10
        LDR     r14, [r10], #8          ; load next index (and skip index+value)
        CMP     r14, #-1                ; if end of list
        EXIT    EQ                      ; then not in workspace list, so exit (C=1 from CMP)
        TEQ     r14, r1
        BNE     %BT10

        LDR     r2, [r10, #-4]          ; load value of variable
        CLC                             ; clear carry
        EXIT

RMVForCurrentMode
        ADR     r10, MVToVVTable
        LDR     r10, [r10, r1, LSL #2]
        LDR     r2, [WsPtr, r10]
        B       GoodReadModeVar

MVToVVTable
        &       ModeFlags
        &       ScrRCol
        &       ScrBRow
        &       NColour
        &       XEigFactor
        &       YEigFactor
        &       LineLength
        &       ScreenSize
        &       YShftFactor
        &       Log2BPP
        &       Log2BPC
        &       XWindLimit
        &       YWindLimit

; Note these should be the same as the first few in SWI ReadVduVariables

RMVTab
        RMVT    ModeFlags, W    ; was B
        RMVT    ScrRCol, W      ; was B
        RMVT    ScrBRow, W      ; was B
        RMVT    NColour, W
        RMVT    XEigFactor, W   ; was B
        RMVT    YEigFactor, W   ; was B
        RMVT    LineLength, W
        RMVT    ScreenSize, W
        RMVT    YShftFactor, W  ; was B
        RMVT    Log2BPP, W      ; was B
        RMVT    Log2BPC, W      ; was B
        RMVT    XWindLimit, W
        RMVT    YWindLimit, W
RMVTabEnd
        ALIGN

; *****************************************************************************
;
;       NewSpriteModeWord, called from ReadModeVariable
;
; in:   R0 = new sprite mode word
;       R1 = number of variable to read
;       (R0,R1,R14 stacked & corruptible)
;
; out:  R2 = value of variable
;
; Return parameters as follows:

; (Unknown types will return an error. Invalid mode variable numbers will already
;  have been weeded out at the entry to ReadModeVariable)

;        0 ModeFlags          Error
;        1 ScrRCol            Error
;        2 ScrBRow            Error
;        3 NColour            derived from bpp passed in (255 for 8bpp)
;        4 XEigFactor         returns 0,1,2 for 180,90,45 dpi, error otherwise
;        5 YEigFactor         as XEigFactor
;        6 LineLength         Error
;        7 ScreenSize         Error
;        8 YShftFactor        Error
;        9 Log2BPP            returns 0,1,2,3,4,5 for T=1-6, error otherwise
;       10 Log2BPC            as Log2BPP
;       11 XWindLimit         Error
;       12 YWindLimit         Error

NewSpriteModeWord ROUT

; validate the sprite type. Types 1-6 only at present. Type 0 is a
; mode number, but if it comes this way, it's bad, since mode >= 256

        MOV     r14, r0, LSR #27        ; shift type word into b4-b0
        ANDS    r14, r14, #&F           ; discard wide mask bit
        BEQ     BadReadModeVar          ; zero is bad cos mode >= 256
        ;if it's a RISC OS 5 sprite mode word, deal with it elsewhere
        CMP     r14, #SpriteType_RISCOS5
        BEQ     RISCOS5SpriteModeWord
        ;if it's an unknown one, apply a substitute
        CMP     r14, #SpriteType_RO5MAX
        MOVCS   r14, #SpriteType_Substitute

; it's a valid type, now branch by the mode variable number
15
        ADR     r2, NewSpriteModeWordRoutines
        ADD     pc, r2, r1, LSL #2      ; and despatch it

NewSpriteModeWordRoutines
        B       NSM_modeflags  ;        0 ModeFlags             (zero)
        B       BadReadModeVar ;        1 ScrRCol               Error
        B       BadReadModeVar ;        2 ScrBRow               Error
        B       NSM_ncol       ;        3 NColour
        B       NSM_xeig       ;        4 XEigFactor
        B       NSM_yeig       ;        5 YEigFactor
        B       BadReadModeVar ;        6 LineLength            Error
        B       BadReadModeVar ;        7 ScreenSize            Error
        B       NSM_yshftfactor ;       8 YShftFactor           (zero)
        B       NSM_bpp        ;        9 Log2BPP
        B       NSM_bpp        ;       10 Log2BPC               as Log2BPP
        B       BadReadModeVar ;       11 XWindLimit            Error
        B       BadReadModeVar ;       12 YWindLimit            Error

; entry conditions here
; r14 - sprite type in b0-b6 for a word offset
; r0  - mode word
; r1  - mode variable (no longer needed at this point)

NSM_ncol ; r14 is already the type bits shifted down to b0-b6, ie a word offset
        ADRL    r2, NColourTable -4     ; results table (adjust for T=0 never occurring here)
        LDR     r2, [r2, r14, LSL #2]   ; pull the correct value
        CMP     r2, #63
        MOVEQ   r2, #255                ; make sure we return 255 not 63
        B       GoodReadModeVar         ; and return happily

NSM_bpp
        ADR     r2, NSM_bpptable-4      ; (adjusted for T=0 never occurring here)
        LDR     r2, [r2, r14, LSL #2]
        B       GoodReadModeVar

NSM_bpptable
        &       0, 1, 2, 3, 4, 5
        &       5, 5, 5 ; CMYK, 24bpp, JPEG (not supported)
        &       4 ; 64K sprite
        &       5, 5, 5, 5, 5 ; types 11-15 (reserved)
        &       4 ; 4K sprite
        &       5, 5 ; YCbCr 422 & 420 (not supported)

NSM_yeig
      [ NoARMT2
        MOV     r0, r0, LSR #14         ; move ydpi into b0-b12
      |
        UBFX    r0, r0, #14, #13        ; move ydpi into b0-b12
      ]
        B       %FT20

NSM_xeig
      [ NoARMT2
        MOV     r0, r0, LSR #1          ; move xdpi into b0-b12
20
        LDR     r14, =&00001FFF         ; mask for dpi bits
        AND     r0, r0, r14
      |
        UBFX    r0, r0, #1, #13         ; move xdpi into b0-b12
20
      ]

        CMP     r0, #180
        MOVEQ   r2, #0
        BEQ     GoodReadModeVar

        CMP     r0, #22
        CMPNE   r0, #23
        MOVEQ   r2, #3
        BEQ     GoodReadModeVar

        TEQ     r0, #(45 :SHL: 2), 2    ; check if 45   (EQ,CC if so)
        CMPNE   r0, #90                 ; or 90         (EQ,CS if so)
        BNE     BadReadModeVar
        MOVCC   r2, #2                  ; 45 => xeig=2
        MOVCS   r2, #1                  ; 90 => xeig=1
        B       GoodReadModeVar

NSM_modeflags
        CMP     r14, #SpriteType_New64K
        MOVEQ   r2, #ModeFlag_64k
        MOVNE   r2, #0
        B       GoodReadModeVar
        
NSM_yshftfactor
        MOV     r2, #0
        B       GoodReadModeVar

RISCOS5SpriteModeWord
        TST     r0, #&F0000                     ; validate RO 5 sprite mode word
        TSTEQ   r0, #&0000E
        MOVNE   r14, #SpriteType_Substitute     ; and try substitute if bad
        BNE     %BT15
        ; From this point on, assume it really is a RISC OS 5 sprite mode word, and throw errors for anything we don't recognise
        MOV     r14, r0, LSR #20
        ANDS    r14, r14, #127
        BEQ     BadReadModeVar                  ; type 0 isn't valid
        CMP     r14, #SpriteType_RO5MAX
        BGE     BadReadModeVar
        
        ADR     r2, RO5SpriteModeWordRoutines
        ADD     pc, r2, r1, LSL #2      ; and despatch it

RO5SpriteModeWordRoutines
        B       RO5SM_modeflags ;       0 ModeFlags             (zero)
        B       BadReadModeVar ;        1 ScrRCol               Error
        B       BadReadModeVar ;        2 ScrBRow               Error
        B       NSM_ncol       ;        3 NColour
        B       RO5SM_xeig     ;        4 XEigFactor
        B       RO5SM_yeig     ;        5 YEigFactor
        B       BadReadModeVar ;        6 LineLength            Error
        B       BadReadModeVar ;        7 ScreenSize            Error
        B       NSM_yshftfactor ;       8 YShftFactor           (zero)
        B       NSM_bpp        ;        9 Log2BPP
        B       NSM_bpp        ;       10 Log2BPC               as Log2BPP
        B       BadReadModeVar ;       11 XWindLimit            Error
        B       BadReadModeVar ;       12 YWindLimit            Error

RO5SM_modeflags
        AND     r2, r0, #&FF00
        ; Validate ModeFlags. We only support RGB colourspace, so the only valid
        ; bits are the RGB and alpha flags
        TST     r2, #&FF00-(ModeFlag_DataFormatSub_RGB+ModeFlag_DataFormatSub_Alpha)
        BNE     BadReadModeVar
        ; Add in the 64K flag if necessary
        CMP     r14, #SpriteType_New64K
        ORREQ   r2, r2, #ModeFlag_64k
        B       GoodReadModeVar

RO5SM_xeig
      [ NoARMT2
        MOV     r2, r0, LSR #4
        AND     r2, r2, #3
      |
        UBFX    r2, r0, #4, #2
      ]
        B       GoodReadModeVar

RO5SM_yeig
      [ NoARMT2
        MOV     r2, r0, LSR #6
        AND     r2, r2, #3
      |
        UBFX    r2, r0, #6, #2
      ]
        B       GoodReadModeVar
        


; *****************************************************************************
;
;       SWICheckModeValid - The 'Can I get into this mode?' call
;
; in:   r0 = mode you want to get into (may be pointer to mode selector)
; out:  C=0 => yes you can, r0 preserved
;       C=1 => no you can't ...
;         r0 = -1 => ... because the mode doesn't exist
;           r1 = substitute mode
;           r1 = -2 => not enough memory for even the substitute mode !
;         r0 = -2 => ... because not enough memory
;

SWICheckModeValid ROUT
        VDWS    WsPtr
        Push    "r1,r9,lr"
        BL      FindOKMode              ; out: r1 = substitute mode
        BVS     %FT90

        CMP     r1, #&100               ; if it's a mode number
        BICCC   r10, r1, #&80           ; then knock off shadow bit
        MOVCS   r10, r1                 ; else don't
        MOV     r11, r10
        BL      PushModeInfo
        BVS     %FT90

        LDR     r11, [r13, #wkScreenSize] ; get screen size for this mode
        ADD     r13, r13, #PushedInfoSize ; junk stacked mode table + VIDC info

        MOV     r10, r1, LSR #7         ; 'shadow' bit (NB will be 0 or 1)
        CMP     r10, #2                 ; except if its a mode selector
        MOVCS   r10, #0                 ; in which case no shadow
        LDROSB  r9, Shadow
        TEQ     r0, r1                  ; if substitute different from original
        MOV     r0, r1                  ; (always set r0 to be substitute mode)
        MOVNE   r14, #-1                ; then indicate original is silly
        MOVEQ   r14, #0                 ; else indicate sensible
        TEQEQ   r9, #0                  ; and if shadow 0
        MOVEQ   r10, #1                 ; then force shadow mode

        LDR     r9, [WsPtr, #GraphicsVFeatures]
        TST     r9, #GVDisplayFeature_VariableFramestore
        MOVNE   r9, #-1                 ; treat as unlimited memory if variable
                                        ; framestore (driver should have
                                        ; rejected the VetMode call from
                                        ; FindOKMode if it doesn't have enough)

        LDREQ   r9, [WsPtr, #TotalScreenSize] ; maximum allowed amount
        CMP     r9, r11, LSL r10        ; compare with this (*2 if shadow)
                                        ; C=0 => No room
        TEQ     r14, #0                 ; NZ => silly, CC => no room

        MOV     r1, #-2                 ; for if silly mode and bad space
        Pull    r1, EQ                  ; if not silly, restore old R1
        ADDNE   r13, r13, #4            ; else junk stacked R1
        MOVHI   r1, r0                  ; silly mode, ok space, R1=subst. mode

        MOVCC   r0, #-2                 ; if no room, indicate it
        MOVNE   r0, #-1                 ; but silly overrides this

        Pull    "r9, r14"
        CMP     r0, #-2                 ; C=1 => bad exit
        BICCC   r14, r14, #C_bit
        ORRCS   r14, r14, #C_bit
        ExitSWIHandler

; exit point in case of error from FindOKMode or PushModeInfo

90
        Pull    "r1, r9, r14"
        MOV     r0, #-1                 ; indicate no such mode
        MOV     r1, #-2                 ; and no substitute mode
        ORR     r14, r14, #C_bit
        ExitSWIHandler

; *****************************************************************************
;
;       FindOKMode - Convert mode number into an appropriate one for
;                    this monitor type
;
; in:   r0 = original mode specifier
;
; out:  If no error, then
;         r0 preserved
;         r1 = appropriate mode specifier
;         V = 0
;       else
;         r0 -> error
;         r1 corrupted
;         V = 1
;       endif
;       All other registers preserved
;

FindOKMode ROUT
        Push    "r0,r2-r4,r10,r11,lr"
        BL      ReadMonitorType
        CMP     r0, #&100               ; if it's a mode number
        BICCC   r2, r0, #&80            ; then knock off shadow bit
        MOVCS   r2, r0                  ; else don't
        BL      OfferModeExtension
        BNE     %FT05

; service claimed

; mjs Kernel/HAL split
; call GraphicsV vetting routine to possibly disallow mode
;
        Push "r0-r4, r12"
        MOV   r0,r3
        MOV   r1,r4

        ;now any vet the driver might want to do
        LDR   r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV   r4, r4, LSL #24
        ORR   r4, r4, #GraphicsV_VetMode
        BL    CallGraphicsV
        TEQ   r4, #0
        MOVNE r0, #0
04
        CMP   r0,#0
        Pull "r0-r4,r12"
        BNE   %FT05         ; driver says "Oi, Kernel, No!"

; service claimed and happy driver so return with this mode

        MOV     r1, r0
        CLRV
        Pull    "r0,r2-r4,r10,r11,pc"

05

; not claimed, so r2 (=mode without shadow) and r3 (=monitortype) are preserved

        Pull    "r0"
        CMP     r0, #&100               ; if a mode selector and not responded to
        BCS     %FT30                   ; then return error

        MOV     r1, #Service_ModeTranslation
        IssueService
        TEQ     r1, #0
        BNE     %FT30
        MOV     r1, r2                  ; if claimed, then use module's mode
        CLRV
        Pull    "r2-r4,r10,r11, pc"

30
        ADRL    r0, ErrorBlock_ModeNotAvailable ; then return error
 [ International
        BL      TranslateError
 |
        SETV                            ; error exit
 ]
        Pull    "r2-r4,r10,r11, pc"

        LTORG

; *****************************************************************************
;
;       ReadMonitorType - Read monitor type
;
; out:  R3 = monitor type
;       All other registers preserved
;

ReadMonitorType Entry "r0-r2"
        MOV     r0, #1
        SWI     XOS_ReadSysInfo         ; out: r0 = mode, r1 = monitortype, r2 = sync
        MOV  r3, r1                  ; move into r3
        EXIT

; *****************************************************************************
;
;       SWIClaimScreenMemory - Claim unused screen memory (for ADFS etc.)
;
; in:   R0 = 0 => release, 1 => claim
;       R1 = length you require
;
; out:  (for claim)
;       C=0 => success
;         R1 = actual length
;         R2 = address
;
;       C=1 => failure
;         R1 = length you could have
;

SWIClaimScreenMemory ROUT
        MRS     R11, CPSR               ; disable IRQs, so can be called from
        ORR     R11, R11, #I32_bit      ; an IRQ routine
        MSR     CPSR_c, R11

        VDWS    WsPtr
        TEQ     R0, #0                  ; 0 => release
        STREQB  R0, [WsPtr, #ScreenMemoryClaimed] ; indicate free again
        ExitSWIHandler EQ

; is claim

        LDRB    R10, [WsPtr, #ScreenMemoryClaimed]
        TEQ     R10, #0                 ; already claimed (NZ)
        MOVNE   R1, #0                  ; indicate you could have zero bytes
        BNE     %FT10                   ; failure exit

        LDRB    R10, [WsPtr, #ExternalFramestore]
        TEQ     R10, #0
        BNE     %FT15

        LDR     R10, [WsPtr, #TotalScreenSize]
        LDR     R11, [WsPtr, #ScreenSize]
        SUB     R10, R10, R11           ; amount available
        CMP     R1, R10                 ; is this enough
        MOV     R1, R10                 ; tell him how much he could have
        BHI     %FT10                   ; if not enough, then exit

        MOV     R10, #1                 ; indicate now claimed
        STRB    R10, [WsPtr, #ScreenMemoryClaimed]

        LDR     R2, [WsPtr, #DisplayStart]
        ADD     R2, R2, R11             ; R2 -> start of usable area

        BIC     R14, R14, #C_bit
        ExitSWIHandler

10
        ORR     R14, R14, #C_bit
        ExitSWIHandler

; using external framestore - they can have the whole screen memory DA
15
        Push    "R0,R1,R14"
        MOV     R0, #2
        SWI     XOS_ReadDynamicArea     ; R0 -> start, R1 = len
        MOVVC   R10, R0
        MOVVC   R11, R1
        MOVVS   R11, #0
        Pull    "R0,R1,R14"
        CMP     R1, R11                 ; is this enough
        MOV     R1, R11                 ; tell him how much he could have
        BHI     %BT10                   ; if not enough, then exit

        MOV     R11, #1                 ; indicate now claimed
        STRB    R11, [WsPtr, #ScreenMemoryClaimed]

        MOV     R2, R10

        BIC     R14, R14, #C_bit
        ExitSWIHandler

; *****************************************************************************
;
;       SWIPlot - PLOT R0,R1,R2
;
; in:   R0 = plot code
;       R1 = X coordinate
;       R2 = Y coordinate
;
; out:  -
;

SWIPlot ROUT
        CMP     R0, #256                ; is plot code >= 256 ?
        ExitSWIHandler CS               ; yes, then do nothing
                                        ; (for future expansion)
        BranchNotJustUs %F10, WrchV, R12, R12

        LDRB    R12, [R11, #OsbyteVars + :INDEX: WrchDest]
        LDRB    R10, [R11, #OsbyteVars + :INDEX: SpoolFileH]
        ORRS    R10, R10, R12
        LDREQB  R10, [R11, #OsbyteVars + :INDEX: VDUqueueItems]
        TEQEQ   R10, #0

        VDWS    WsPtr
        LDREQ   R10, [WsPtr, #CursorFlags]
        TSTEQ   R10, #VduDisabled       ; if VDU disabled, go thru normal stuff
        LDREQ   R10, [WsPtr, #ModeFlags] ; if non-graphic, then send
        TSTEQ   R10, #ModeFlag_NonGraphic ; thru normal chans
        BNE     %FT10

        Push    "R0-R9,R14"
        BL      PreWrchCursor
        WritePSRc SVC_mode, R14         ; interrupts on
        LDMFD   R13, {R0-R2}
        MOV     R3, R0                  ; save plot code
        MOV     R0, R1, LSL #16
        MOV     R0, R0, ASR #16         ; R0 := sign extended X coord
        MOV     R1, R2, LSL #16
        MOV     R1, R1, ASR #16         ; R1 := sign extended Y coord
        MOV     R2, R3
        MOV     R9, #1                  ; indicate entry from SWI Plot
        BL      EntryFromSWIPlot
        BL      PostWrchCursor
        Pull    "R0-R9,R14"
        ExitSWIHandler

SWIPlotBadExit
        STR     R0, [R13]               ; save error block pointer in saved R0
        BL      PostWrchCursor
        Pull    "R0-R9,R14"
        ORR     R14, R14, #V_bit
        ExitSWIHandler

10
        Push    "R0,R14"
        SWI     XOS_WriteI+25           ; send 25
        SWIVC   XOS_WriteC              ; send plot code
        ANDVC   R0, R1, #&FF
        SWIVC   XOS_WriteC              ; send X (lo)
        MOVVC   R0, R1, LSR #8
        SWIVC   XOS_WriteC              ; send X (hi)
        ANDVC   R0, R2, #&FF
        SWIVC   XOS_WriteC              ; send Y (lo)
        MOVVC   R0, R2, LSR #8
        SWIVC   XOS_WriteC              ; send Y (hi)

        Pull    "R0,R14", VC            ; if no error, pull stacked R0 and R14
        ExitSWIHandler VC

        ADD     R13, R13, #4            ; if error, junk stacked R0
        Pull    "R14"
        ORR     R14, R14, #V_bit        ; and set V bit in link
        ExitSWIHandler

; *****************************************************************************
;
;       SWIRemoveCursors - Remove input and output cursors for screen bashing
;
; out:  All registers preserved (R10-R12 preserved by Sam)
;

SWIRemoveCursors
        Push    "R0-R4,R6,R8-R9,R14"
        VDWS    WsPtr
        BL      PreWrchCursor
        Pull    "R0-R4,R6,R8-R9,R14"
        ExitSWIHandler

; *****************************************************************************
;
;       SWIRestoreCursors - Restore input and output cursors after screen bash
;
; out:  All registers preserved (R10-R12 preserved by Sam)
;

SWIRestoreCursors
        Push    "R0-R4,R6,R8-R9,R14"
        VDWS    WsPtr
        BL      PostWrchCursor
        Pull    "R0-R4,R6,R8-R9,R14"
        ExitSWIHandler

; *****************************************************************************
;
;       SWIWriteN - Write R1 bytes from address R0 to wrch
;
; in:   R0 -> string
;       R1 -> number of chars to print
;
; out:  -
;

SWIWriteN ROUT
        Push    "R0,R1,R14"
        WritePSRc SVC_mode, R14             ; enable interrupts

        BranchNotJustUsWrch %F70

; R11 now points to either vector node or 1st address on chain, as appropriate
; R12 holds current value of this location, to be checked each time

        MOV     R10, R0
10
        SUBS    R1, R1, #1
        BCC     %FT90                   ; count has expired (V=0)
        LDRB    R0, [R10], #1
        Push    PC                      ; need to get to %FT20 - push PC+12 (old ARM) or PC+8 (StrongARM)
        B       PMFWrchDirect
        MOV     R0,R0                   ; NOP for PC+8 case

20
        BVS     %FT90
        LDR     R0, [R11]
        TEQ     R0, R12                 ; vector still the same ?
        BEQ     %BT10                   ; yes, then loop
        B       %FT75                   ; no, do rest with wrch

70
        ADDS    R10, R0, #0             ; R10 := R0 and V := 0
75
        ADD     R11, R10, R1
        TEQ     R10, R11
80
        LDRNEB  R0, [R10], #1
        SWINE   XOS_WriteC
        MOVVS   R10, R11
        TEQ     R10, R11
        BNE     %BT80
90
        Pull    "R0,R1,R14", VC         ; if no error, pull stacked R0,R1 & R14
        ExitSWIHandler VC

        ADD     R13, R13, #4            ; if error, junk stacked R0
        Pull    "R1,R14"
        ORR     R14, R14, #V_bit        ; and set V bit in link
        ExitSWIHandler


; *****************************************************************************
;
;       SWIWrite0 - Write a zero-terminated string pointed to by R0
;
; in:   R0 -> string
;
; out:  R0 -> char after the zero
;

SWIWrite0 ROUT
        Push    "R14"
        WritePSRc SVC_mode, R10                 ; enable interrupts

        MOV     R10, R0                         ; R10 -> string

        BranchNotJustUsWrch %F70

; R11 now points to either vector node or 1st address on chain, as appropriate
; R12 holds current value of this location, to be checked each time

10
        LDRB    R0, [R10], #1
        CMP     R0, #0
        BEQ     %FT80                   ; no more characters
        Push    PC, NE                  ; need to get to %FT20 - push PC+12 (old ARM) or PC+8 (StrongARM)
        BNE     PMFWrchDirect
        MOV     R0,R0                   ;NOP for PC+8

20
        BVS     %FT80
        LDR     R0, [R11]
        TEQ     R0, R12                 ; vector still the same ?
        BEQ     %BT10                   ; yes, then loop
                                        ; no, then drop thru
                                        ; and do rest with Wrch
70
        LDRB    R0, [R10], #1
        CMP     R0, #0                  ; (V:=0)
        SWINE   XOS_WriteC
        BGT     %BT70                   ; branch if no error and not terminated
80
        MOVVC   R0, R10                 ; if no error, R0 -> char after zero

        Pull    "R14"
        ORRVS   R14, R14, #V_bit
        ExitSWIHandler

; *****************************************************************************
;
;       SWIWriteS - Write a zero-terminated in-line string
;
; in:   R14 -> first char of string (but has PSR bits in it)
;
; out:  -
;

SWIWriteS ROUT
        Push    "R0, R14"
        WritePSRc SVC_mode, R10                 ; enable interrupts

; return address is on the stack, above our R0, R14, and SWI number
        LDR     R10, [R13, #12]

        BranchNotJustUsWrch %F70

; R11 now points to either vector node or 1st address on chain, as appropriate
; R12 holds current value of this location, to be checked each time

10
        LDRB    R0, [R10], #1
        CMP     R0, #0
        BEQ     %FT80                   ; no more characters
        Push    PC, NE                  ; need to get to %FT20 - push PC+12 (old ARM) or PC+8 (StrongARM)
        BNE     PMFWrchDirect
        MOV     R0,R0                   ;NOP for PC+8
20
        BVS     %FT80
        LDR     R0, [R11]
        TEQ     R0, R12                 ; vector still the same ?
        BEQ     %BT10                   ; yes, then loop
                                        ; no, then drop thru
                                        ; and do rest with Wrch
70
        LDRB    R0, [R10], #1
        CMP     R0, #0                  ; (V:=0)
        SWINE   XOS_WriteC
        BGT     %BT70                   ; branch if no error and not terminated
80
        BVS     %FT90
        Pull    "R0, R14"
85
        TST     R14, #T32_bit
        ADDNE   R10, R10, #1            ; if Thumb
        BICNE   R10, R10, #1            ; round up to next halfword boundary
        ADDEQ   R10, R10, #3            ; else
        BICEQ   R10, R10, #3            ; round up to next word boundary
        STR     R10, [R13, #4]          ; Poke new address into stack
        ExitSWIHandler

90
        Pull    "R11, R14"              ; junk the stacked R0
        ORR     R14, R14, #V_bit
95
        LDRB    R11, [R10], #1          ; skip to the zero terminator
        TEQ     R11, #0
        BNE     %BT95
        B       %BT85

; *****************************************************************************
;
;       RemovePages - Called by MOS when ChangeDynamicArea reduces the
;                     amount of screen memory
;
; in:   R0 = - number of bytes being removed
;       R4 = current size
;
; out:  All registers preserved
;

RemovePages ROUT
        Push    "R0-R8,R12,R14"
        BL      InsertRemovePagesCommon
        BNE     RemovePages_ExternalFramestore
        LDR     R14, [WsPtr, #ScreenEndAddr]
        ADD     R2, R0, R14             ; end of remaining screen memory

; display starts in pages that remain

        SUB     R5, R3, R0              ; new DisplayStart

05
        CMP     R5, R14                 ; if off end of 1st copy
        SUBCS   R5, R5, R4              ; then repeatedly subtract off new size
        BCS     %BT05                   ; until in range

        Push    "R0-R2"
        MOV     R0, R5                  ; put new display start in r0
        BL      SetVinit                ; this updates DisplayStart
        Pull    "R0-R2"

        ADD     R3, R3, R4              ; end of area to copy +1
        CMP     R3, R2
        BLS     %FT20                   ; nothing to copy

        SUB     R4, R3, R0              ; destination end
10
        LDMDB   R3!, {R5-R8}            ; load 4 words (minimum amount)
        STMDB   R4!, {R5-R8}            ; store 4 words
        TEQ     R3, R2
        BNE     %BT10

20
InsertRemovePagesExit
        LDR     R14, [WsPtr, #ScreenEndAddr]
        LDR     R4, [WsPtr, #DisplayScreenStart]
        SUB     R0, R4, R0
        LDR     R3, [WsPtr, #TotalScreenSize]
25
        CMP     R0, R14                 ; ensure displayscreenstart in range too
        SUBCS   R0, R0, R3
        BCS     %BT25
        BL      NewScreenStart
30
        BL      SetVendDefault

        Pull    "R0-R8,R12,PC"

; in:   R0 = - number of bytes being removed
;       R4 = current size
RemovePages_ExternalFramestore

 [ {FALSE}
; Should do the copy, but need access to address
        ADD     R3, R3, R4              ; end of area to copy +1
        CMP     R3, R2
        BLS     %FT20                   ; nothing to copy

        SUB     R4, R3, R0              ; destination end
10
        LDMDB   R3!, {R5-R8}            ; load 4 words (minimum amount)
        STMDB   R4!, {R5-R8}            ; store 4 words
        TEQ     R3, R2
        BNE     %BT10

20
 ]
InsertRemovePages_ExternalFramestoreExit
        Pull    "R0-R8,R12,PC"

; *****************************************************************************
;
;       InsertPages - Called by MOS when ChangeDynamicArea increases the
;                     amount of screen memory
;
; in:   R0 = number of bytes being added
;       R4 = new size
;

InsertPages ROUT
        Push    "R0-R8,R12,R14"
        BL      InsertRemovePagesCommon
        BNE     InsertPages_ExternalFramestore
        SUB     R5, R3, R0              ; new DisplayStart
        STR     R5, [WsPtr, #DisplayStart]
        ADD     R2, R3, R1              ; end of block to copy

        LDR     R3, [WsPtr, #ScreenEndAddr]
        SUB     R4, R3, R0
10
        TEQ     R3, R2
        LDMNEIA R3!, {R5-R8}
        STMNEIA R4!, {R5-R8}
        BNE     %BT10
        B       InsertRemovePagesExit

InsertPages_ExternalFramestore
; Should do copy here
        B       InsertRemovePages_ExternalFramestoreExit

; *****************************************************************************

InsertRemovePagesCommon ROUT
        VDWS    WsPtr
        LDRB    R1, [WsPtr, #ExternalFramestore]
        TEQ     R1, #0
        MOVNE   PC, R14

        LDR     R1, [WsPtr, #TotalScreenSize]   ; old size

        LDR     R4, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
        STRB    R4, [R4, #OsbyteVars + :INDEX:MemDriver]  ; indicate default
        STRB    R4, [R4, #OsbyteVars + :INDEX:MemDisplay] ; for both of these

        LDR     R4, [WsPtr, #VduStatus] ; not shadowing any more
        BIC     R4, R4, #Shadowing
        STR     R4, [WsPtr, #VduStatus]

        ADD     R4, R1, R0              ; length of remaining screen memory
        STR     R4, [WsPtr, #TotalScreenSize] ; new size
        LDR     R3, [WsPtr, #ScreenEndAddr]
        RSB     R5, R4, R3              ; start of remaining screen memory
        STR     R5, [WsPtr, #DriverBankAddr]
        STR     R5, [WsPtr, #DisplayBankAddr]

        LDR     R3, [WsPtr, #DisplayStart]
        MOV     PC, R14

; *****************************************************************************
;
;       SWIChangedBox - Entry point for SWI OS_ChangedBox
;
; in:   R0 = 0 => disable clip box calculations
;            1 => enable clip box calculations
;            2 => reset clip box to null
;            -1 => do nothing
;
; out:  R0 = old enable state (0 => disabled, 1 => enabled)
;       R1 -> clipbox info, consisting of 5 words
;        [R1, #0] = disable/enable flag (in bit 0)
;        [R1, #4] = internal X-coord of left edge of box
;        [R1, #8] = internal Y-coord of bottom edge of box
;        [R1, #12] = internal X-coord of right edge of box
;        [R1, #16] = internal Y-coord of top edge of box
;

SWIChangedBox ROUT
        VDWS    WsPtr
        MOV     R1, WsPtr
        LDR     R10, [R1, #ClipBoxEnable]! ; R10 = old state, R1 -> state
        CMP     R0, #2                  ; known reason ?
        BHI     %FT10                   ; no, then just read state
        BEQ     %FT20                   ; reset rectangle to null

        STR     R0, [R1]                ; then store R0 in ClipBoxEnable
        WritePSRc SVC_mode + I_bit, R11 ; disable IRQs to update CursorFlags
        TST     R0, #1
        LDR     R0, [WsPtr, #CursorFlags]
        BICEQ   R0, R0, #ClipBoxEnableBit
        ORRNE   R0, R0, #ClipBoxEnableBit
        STR     R0, [WsPtr, #CursorFlags]
10
        MOV     R0, R10                 ; R0 = old state
        ExitSWIHandler

20
        Push    "R4-R7"
        ADR     R0, NullRectangle
        LDMIA   R0, {R4-R7}
        STMIB   R1, {R4-R7}             ; store over coordinates
        Pull    "R4-R7"
        B       %BT10

NullRectangle
        &       &7FFFFFFF, &7FFFFFFF, &80000000, &80000000

; *****************************************************************************
;
;       SetClipBoxToFullScreen - Called by FF
;
; in:   WsPtr -> VduDriverWorkSpace
;
; out:  R0-R4 corrupted
;       PSR preserved
;

        ASSERT  YWindLimit = XWindLimit +4

SetClipBoxToFullScreen ROUT
        ADD     R4, WsPtr, #XWindLimit
        LDMIA   R4, {R2, R3}
        MOV     R0, #0
        MOV     R1, #0
        ADD     R4, WsPtr, #ClipBoxCoords
        STMIA   R4, {R0-R3}
        MOV     PC, R14

; *****************************************************************************
;
;       MergeClipBox - Merge a given rectangle into clip box
;
; in:   R0..R3 = Left, bottom, right, top of rectangle to merge
;       WsPtr -> VduDriverWorkSpace
;
; out:  All registers preserved
;

MergeClipBox ROUT
        Push    "R4-R8, R14"
        ADD     R8, WsPtr, #ClipBoxCoords
        LDMIA   R8, {R4-R7}
        BL      MergeClipBoxes
        STMIA   R8, {R4-R7}
        Pull    "R4-R8, PC"

MergeClipBoxes ROUT
        CMP     R0, R4
        MOVLT   R4, R0
        CMP     R1, R5
        MOVLT   R5, R1
        CMP     R2, R6
        MOVGT   R6, R2
        CMP     R3, R7
        MOVGT   R7, R3
        MOV     PC, R14

; *****************************************************************************
;
;       DoPlotClipBox - Compute clip box for a PLOT command
;
; in:   R2 = plot code
;
; out:  R0-R2 preserved
;

DoPlotClipBox ROUT
        TST     R2, #3                  ; (R2 AND 3)=0 => move operation
        ADRNE   R11, ClipBoxPlotTable
        LDRNEB  R11, [R11, R2, LSR #3]  ; get 'type' of this plot
        TEQNE   R11, #0                 ; 0 => don't change clip window
        MOVEQ   PC, R14
        Push    "R0-R2, R14"
        CMP     R11, #3                 ; if 1..3
        BLS     ClipLastR11Points       ; then use last R11 points
        CMP     R11, #ClipIndex_Ellipse
        BCC     ClipFullWindow          ; flood fill => merge graphics window
        BEQ     ClipEllipse
        CMP     R11, #ClipIndex_LineFill
        BCC     ClipParallelogram
        BEQ     ClipLineFill
        Pull    "R0-R2, PC"

ClipIndex_FloodFill     * 4
ClipIndex_Ellipse       * 5
ClipIndex_Parallelogram * 6
ClipIndex_LineFill      * 7

ClipBoxPlotTable
        =       2,2,2,2,2,2,2,2         ; 00..38 line drawing
        =       1                       ; 40 point plot
        =       ClipIndex_LineFill      ; 48 line fill
        =       3                       ; 50 triangle
        =       ClipIndex_LineFill      ; 58 line fill
        =       2                       ; 60 rectangle fill
        =       ClipIndex_LineFill      ; 68 line fill
        =       ClipIndex_Parallelogram ; 70 parallelogram
        =       ClipIndex_LineFill      ; 78 line fill
        =       ClipIndex_FloodFill     ; 80 flood fill
        =       ClipIndex_FloodFill     ; 88 flood fill
        =       0,0,0,0,0               ; 90..B0 circle things
                                        ; (done in GenCircleParm)
        =       0                       ; B8 block copy/move (done in code)
        =       ClipIndex_Ellipse       ; C0 ellipse outline
        =       ClipIndex_Ellipse       ; C8 ellipse fill
        =       0, 0, 0                 ; D0..E0 do nothing
        =       0                       ; E8 sprite plot (done in SWI SpriteOp)
        =       0, 0                    ; F0,F8 do nothing
        ALIGN

ClipLastR11Points ROUT
        ADD     R10, WsPtr, #NewPtX
        BL      MergeR11PointsFromR10
        Pull    "R0-R2, PC"

MergeR11PointsFromR10 ROUT
        Push    R14
        LDMIA   R10, {R4,R5}            ; get last point
        MOV     R6, R4                  ; right=left
        MOV     R7, R5                  ; top=bottom
        SUBS    R11, R11, #1
        BEQ     %FT10
05
        LDMDB   R10!, {R0,R1}           ; get another point (X,Y)
        MOV     R2, R0
        MOV     R3, R1
        BL      MergeClipBoxes
        SUBS    R11, R11, #1            ; one less point to do
        BNE     %BT05
10

; now clip this to graphics window

        ADD     R10, WsPtr, #GWLCol
        LDMIA   R10, {R0-R3}
        CMP     R4, R0
        MOVGE   R0, R4
        CMP     R5, R1
        MOVGE   R1, R5
        CMP     R6, R2
        MOVLE   R2, R6
        CMP     R7, R3
        MOVLE   R3, R7
        CMP     R2, R0
        CMPGE   R3, R1
        BLGE    MergeClipBox            ; if R>=L and T>=B then merge
        Pull    PC


ClipLineFill ROUT
        ADD     R10, WsPtr, #GWLCol
        LDMIA   R10, {R0-R3}
        ADD     R10, WsPtr, #NewPtX
        LDMIA   R10, {R4-R5}
        CMP     R4, R0                  ; if point is inside window
        CMPGE   R2, R4
        CMPGE   R5, R1
        CMPGE   R3, R5
        MOVGE   R1, R5                  ; then top=bottom=Y
        MOVGE   R3, R5                  ; and left=GWLCol, right=GWRCol
        BLGE    MergeClipBox
        Pull    "R0-R2, PC"

ClipParallelogram ROUT
        ADD     R10, WsPtr, #OldCsX
        LDMIA   R10, {R0-R5}            ; load up last 3 points
ClipParallelRegs
        ADD     R6, R0, R4              ; 4th point = 1st + 3rd - 2nd
        SUB     R6, R6, R2
        ADD     R7, R1, R5
        SUB     R7, R7, R3
        Push    "R0-R7"                 ; stack all four points
        ADD     R10, R13, #6*4          ; point R10 at last point
        MOV     R11, #4                 ; 4 points to merge
        BL      MergeR11PointsFromR10
        ADD     R13, R13, #8*4          ; junk stacked points
        Pull    "R0-R2, PC"

ClipEllipse ROUT
        ADD     R10, WsPtr, #OldCsX
        LDMIA   R10, {R0-R5}            ; last 3 points (AX,AY,BX,BY,CX,CY)
        SUB     R6, R2, R0              ; R6 = BX-AX
        ADD     R0, R0, R2              ; R0 = AX+BX
        SUB     R0, R0, R4              ; R0 = AX+BX-CX
        ADD     R2, R4, R6              ; R2 = CX+BX-AX
        SUB     R4, R4, R6              ; R4 = CX-(BX-AX) = CX+AX-BX
        RSB     R1, R5, R1, LSL #1      ; R1 = 2*AY-CY
        MOV     R3, R5                  ; R3 = CY
        B       ClipParallelRegs

ClipFullWindow ROUT
        ADD     R10, WsPtr, #GWLCol     ; merge graphics window with
        LDMIA   R10, {R0-R3}            ; clip rectangle (which can be larger)
        BL      MergeClipBox
        Pull    "R0-R2, PC"

; *****************************************************************************
;
;       ClipBlockCopyMove - Calculate clip box for block copy/move
;
; in:   R0-R7 = SrcL, SrcB, SrcR, SrcT, DestL, DestB, DestR, DestT
;       R8 = 0 => move, 2 => copy
;
; out:  R0-R7 preserved
;       R8-R11 undefined
;

ClipBlockCopyMove ROUT
        Push    "R0-R7, R14"
        ADD     R10, R13, #6*4          ; R10 -> last point (DestR,DestT)
        RSB     R11, R8, #4             ; R11 = 4 if move, 2 if copy
                                        ; (number of points to merge)
        BL      MergeR11PointsFromR10
        Pull    "R0-R7, PC"

; *****************************************************************************
;
;       ClipCircle - Add circle bounding box to clip box
;
; in:   R0 = radius of circle in square pixels
;       R5, R6 = CentreX, CentreY
;       R7 = AspectRatio (0 => square, 1 => flat rect, 2 => tall rect)
;
; out:  R0-R7 preserved
;       R8-R11 undefined
;

ClipCircle ROUT
        Push    "R0-R7,R14"
        CMP     R7, #1
        MOVEQ   R8, R0, LSR #1          ; if flat then dX = rad/2
        MOVNE   R8, R0                  ; else dX = rad
        MOVHI   R9, R0, LSR #1          ; if tall then dY = rad/2
        MOVLS   R9, R0                  ; else dY = rad
        SUB     R0, R5, R8              ; left
        SUB     R1, R6, R9              ; bottom
        ADD     R2, R5, R8              ; right
        ADD     R3, R6, R9              ; top
        Push    "R0-R3"
        ADD     R10, R13, #2*4          ; point R10 at last point
        MOV     R11, #2                 ; 2 points to merge
        BL      MergeR11PointsFromR10
        ADD     R13, R13, #4*4          ; junk stacked points
        Pull    "R0-R7,PC"

; *****************************************************************************
;
;       ClipCursorCell - Add current cursor cell to clip box
;
; in:   -
;
; out:  All registers preserved
;

ClipCursorCell ROUT
        ASSERT  CursorY = CursorX +4
        Push    "R0-R3, R14"
        ADD     R0, WsPtr, #CursorX
        LDMIA   R0, {R0, R1}
        MOV     R2, R0                  ; RCol = LCol
        MOV     R3, R1                  ; TRow = BRow
        BL      ClipTextArea
        Pull    "R0-R3, PC"

; *****************************************************************************
;
;       ClipTextArea - Add a text area to the clip box
;
; in:   R0 = LCol of area
;       R1 = BRow of area
;       R2 = RCol of area
;       R3 = TRow of area
;
; out:  All registers preserved
;

ClipTextArea ROUT
        Push    "R0-R3, R14"
        MOV     R0, R0, LSL #3                  ; left = LCol*8
        MOV     R2, R2, LSL #3
        ADD     R2, R2, #7                      ; right = RCol*8 + 7
        LDR     R14, [WsPtr, #RowMult]
        MUL     R3, R14, R3                     ; TRow * RowMult
        MLA     R1, R14, R1, R14                ; (BRow+1) * RowMult
        LDR     R14, [WsPtr, #YWindLimit]
        SUB     R3, R14, R3             ; top = YWindLimit-TRow*RowMult
        SUB     R1, R14, R1
        ADD     R1, R1, #1              ; bot = YWindLimit-(BRow+1)*Mult+1
        BL      MergeClipBox
        Pull    "R0-R3, PC"

; *****************************************************************************
;
;       ClipScroll - Add clip box when scrolling
;
; in:   R0 = 0 => add text window
;       R0 <> 0 => set to full screen
;
; out:  All registers preserved
;

ClipScroll ROUT
        Push    "R0-R4, R14"
        CMP     R0, #1                  ; if scrolling screen
        BLCS    SetClipBoxToFullScreen  ; set to full screen

        ADDCC   R4, WsPtr, #TWLCol      ; else add text window
        LDMCCIA R4, {R0-R3}
        BLCC    ClipTextArea

        Pull    "R0-R4, PC"

; *****************************************************************************
;
;       ClipSpritePlot - Compute and merge sprite plot bounding box
;
; in:   R0 = unclipped X-coord (internal)
;       R1 = clipped topY (internal)
;       R2 = width of sprite in words
;       R3 = height of sprite -1
;       R4 = GWLCol
;       R5 = height reduction
;       R6 = GWRCol
;       R8 -> sprite
;
; out:  All registers preserved
;

ClipSpritePlot ROUT
        Push    "R0-R11, R14"
        ADD     R9, R8, #spLBit
        LDMIA   R9, {R9, R10}           ; R9 = spLBit; R10 = spRBit
        ADD     R2, R9, R2, LSL #5      ; R2 = width*32+spLBit
        RSB     R10, R10, #32           ; R10 = 32-spRBit
        SUB     R2, R2, R10             ; R2 = width in bits-1
        LDR     R9, [WsPtr, #Log2BPC]
        ADD     R2, R0, R2, LSR R9      ; R2 = unclipped rightX
        CMP     R0, R4
        MOVLT   R0, R4                  ; R0 = clipped leftX
        CMP     R2, R6
        MOVGT   R2, R6                  ; R2 = clipped rightX
        SUB     R3, R3, R5              ; R3 = no. of lines on screen -1
        SUB     R1, R1, R3              ; R1 = clipped botY
        ADD     R3, R1, R3              ; R3 = clipped topY

        CMP     R2, R0                  ; if right>=left
        CMPGE   R3, R1                  ; and top>=bot
        BLGE    MergeClipBox            ; then add rectangle
        Pull    "R0-R11, PC"


; *****************************************************************************
;
;       ScreenModeSWI - Entry point for SWI OS_ScreenMode
;
; in:   r0 = reason code
;       Other registers depend on reason code
;
; out:  Depends on reason code
;

ScreenModeSWI Entry
        BL      ScreenModeSub
        PullEnv
        ORRVS   lr, lr, #V_bit
        ExitSWIHandler

        MACRO
        SMEntry $name
        ASSERT  . - ScreenModeSub_Table = ScreenModeReason_$name * 4
        B       ScreenMode_$name
        MEND

        MACRO
        SMEntry2 $name
        ASSERT  . - ScreenModeSub_Table2 = (ScreenModeReason_$name - ScreenModeReason_RegisterDriver) * 4
        B       ScreenMode_$name
        MEND

ScreenModeSub
        CMP     r0, #ScreenModeReason_Limit1
        ADDCC   pc, pc, r0, LSL #2
        B       %FT10
ScreenModeSub_Table
        SMEntry SelectMode
        SMEntry ReturnMode
        SMEntry EnumerateModes
        SMEntry SelectMonitorType
        SMEntry ConfigureAcceleration
        SMEntry CleanCache
        SMEntry ForceCleanCache
        SMEntry CountScreenBanks
        SMEntry SelectDisplayBank
        SMEntry SelectVDUBank
        SMEntry CopyBank
        SMEntry SelectDevice
        SMEntry ROL_DeviceDetails
        SMEntry ModeStringToSpecifier
        SMEntry ModeSpecifierToString
        SMEntry SelectModeByString

10
        SUB     r10, r0, #ScreenModeReason_RegisterDriver
        CMP     r10, #ScreenModeReason_Limit2-ScreenModeReason_RegisterDriver
        ADDCC   pc, pc, r10, LSL #2
        B       ScreenMode_Unknown
ScreenModeSub_Table2
        SMEntry2 RegisterDriver
        SMEntry2 StartDriver
        SMEntry2 StopDriver
        SMEntry2 DeregisterDriver
        SMEntry2 EnumerateDrivers

; unknown OS_ScreenMode reason code

ScreenMode_CountScreenBanks
ScreenMode_SelectDisplayBank
ScreenMode_SelectVDUBank
ScreenMode_CopyBank
ScreenMode_ROL_DeviceDetails
ScreenMode_Unknown
        ADR     r0, ErrorBlock_ScreenModeBadReason
ScreenMode_TranslateAndReturnError
      [ International
        Push    lr
        BL      TranslateError
        Pull    lr
      ]
ScreenMode_ReturnError
        SETV
        MOV     pc, lr

        MakeErrorBlock ScreenModeBadReason
        MakeErrorBlock BadGDriver
        MakeErrorBlock TooManyGDrivers

;**************************************************************************
;
;       ScreenMode_SelectMode - Select a screen mode
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (0)
;       r1 = mode specifier
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_SelectMode Entry "r0-r9"
        WritePSRc SVC_mode, WsPtr       ; enable IRQs
        VDWS    WsPtr
        BL      PreWrchCursor           ; remove cursor
        LDR     r2, [sp, #1*4]          ; reload mode specifier
        BL      ModeChangeSub           ; perform mode change
        BVS     %FT90
        BL      PostWrchCursor          ; if no error, then restore cursor
        CLRV                            ; indicate no error
        EXIT                            ; and exit

90
        STR     r0, [sp]                ; overwrite stacked r0 with error ptr
        BL      PostWrchCursor          ; restore cursor
        SETV                            ; indicate error
        EXIT                            ; and exit

;**************************************************************************
;
;       ScreenMode_ReturnMode - Return current screen mode specifier
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (1)
;
; out:  r1 = mode specifier
;       r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_ReturnMode ROUT
        VDWS    WsPtr
        LDR     r1, [WsPtr, #ModeNo]
        CLRV
        MOV     pc, lr

;**************************************************************************
;
;       ScreenMode_EnumerateModes - Enumerate screen modes
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (2)
;       r2 = enumeration index (0 to start from beginning)
;       r6 -> block to return data into, or 0 to just count entries
;       r7 = size of block if r6<>0, or zero if r6=0
;
; out:  r1 = 0 if service claimed, otherwise r1<>0
;       r2 = updated enumeration index
;       r6 = updated block pointer
;       r7 = size of remaining free area in block
;       r10-r12 may be corrupted
;       All other registers are preserved
;

ScreenMode_EnumerateModes Entry "r3-r5"
        MOV     r1, #Service_EnumerateScreenModes
        BL      ReadMonitorType
        GetBandwidthAndSize     r4, r5
        BL      Issue_Service
        EXIT

;**************************************************************************
;
;       ScreenMode_SelectMonitorType - Select current monitor type
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (3)
;       r1 = monitor type to set, or -1 to restore from configured value
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_SelectMonitorType Entry "r0-r1"
        VDWS    WsPtr
        CMP     r1, #-1                                 ; if not restoring configured value
        BNE     %FT10                                   ; then skip
        BL      Read_Configd_MonitorType                ; else read CMOS value (returns in r0)
        MOV     r1, r0
10
        STR     r1, [WsPtr, #CurrentMonitorType]        ; update current value
        ; Let the display manager know that the available modes have changed
        MOV     r1, #Service_ModeFileChanged
        BL      Issue_Service
        EXIT

;**************************************************************************
;
;       ScreenMode_ConfigureAcceleration - Configure screen memory cacheability
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (4)
;       r1 = flags:
;              bit 0 : set to suspend cached screen until mode change
;              bit 1 : set to suspend screen cleaning
;              bit 2 : set to disable hardware acceleration
;              other : reserved, must be 0
;            or -1 to read current value
;       r2 = number of VSyncs between automatic screen cleaning (1-3), or -1
;       to read current value
;
; out:  r1 = new flag state
;       r2 = new number of VSyncs between automatic screen cleaning
;       r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_ConfigureAcceleration
        ; Screen caching isn't supported yet. Just return dummy values.
        MOV     r1,#1
        MOV     r2,#1
        MOV     pc,lr

;**************************************************************************
;
;       ScreenMode_CleanCache - Clean screen memory from cache, if cache enabled
;       ScreenMode_ForceCleanCache - Force clean of screen memory from cache
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (5 or 6)
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_CleanCache
ScreenMode_ForceCleanCache
        ; Screen caching isn't supported yet. Just do nothing.
        MOV      pc,lr


;**************************************************************************
;
;       ScreenMode_SelectDevice
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (11)
;       r1 = new device/driver number, or -1 to read current
;
; out:  r1 = previous (or current, if reading) driver number
;       r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_SelectDevice ROUT
        Entry   "r0,r2-r5"
        VDWS    WsPtr
        LDR     r5, [WsPtr, #CurrentGraphicsVDriver]
        CMP     r1, #-1
        MOVEQ   r1, r5
        CMP     r1, r5
        EXIT    EQ
        ; Validate this selection
        CMP     r1, #GraphicsVInvalid
        BEQ     %FT01
        CMP     r1, #MaxGraphicsVDrivers
        BHS     %FT20
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        LDR     r11, [r10, r1, LSL #2]
        CMP     r11, #0
        LDRNE   r0, [r11, #GVDriver_StateFlags]
        TSTNE   r0, #GVDriverState_Started
        BEQ     %FT20
01
        CMP     r5, #GraphicsVInvalid
        BEQ     %FT10
        ! 0, "GVTODO - API to disable a driver"
10
        ; Issue pre-changing service call because we're about to change the VDU
        ; vars
        MOV     r0, #DisplayChanged_PreChanging
        MOV     r2, r1
        MOV     r1, #Service_DisplayChanged
        MOV     r3, #DisplayChangedSub_ModeChanged
        IssueService
        ; Update current driver VDU var
        STR     r2, [WsPtr, #CurrentGraphicsVDriver]
        ; Issue service call to indicate change is coming
        MOV     r0, #DisplayChanged_Changing
        IssueService
        ; Call InitialiseMode to select a mode to use for this new driver
        CMP     r2, #GraphicsVInvalid
        BLNE    InitialiseMode
        BVS     %FT15
        ; Success!
        MOV     r0, #DisplayChanged_Changed
        IssueService
        MOV     r1, r5
        EXIT
15
        ; Something went wrong trying to activate the new driver
        ; Try and restore the old one
        STR     r0, [sp] ; Return the error to the caller
        STR     r5, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r0, #DisplayChanged_Changing
        MOV     r2, r5
        IssueService
        CMP     r5, #GraphicsVInvalid
        BLNE    InitialiseMode
        ; TODO - Try harder if this 2nd call fails (e.g. try all drivers in turn)
        MOV     r0, #DisplayChanged_Changed
        IssueService
        MOV     r1, r5
        SETV
        EXIT
20
        PullEnv
        ADR     r0, ErrorBlock_BadGDriver
        B       ScreenMode_TranslateAndReturnError


;**************************************************************************
;
;       ScreenMode_ModeStringToSpecifier
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (13)
;       r1 = pointer to mode string
;       r2 = pointer to mode specifier to fill in
;       r3 = size of mode specifier
;
; out:  r0 = error, or preserved
;       r10-r12 may be corrupted
;       All other registers preserved
;

; Flags in R8
strtospec_got_xres * 1 ; X encountered
strtospec_got_yres * 2 ; Y encountered
strtospec_got_colours * 4 ; C, G, or T encountered
strtospec_got_layout * 8 ; L encountered
strtospec_is_ttx * 16 ; we're selecting a teletext mode
strtospec_got_ttx_rcol * 32 ; TX encountered
strtospec_got_ttx_brow * 64 ; TY encountered

ScreenMode_ModeStringToSpecifier ROUT
        Entry   "r1-r9"
        MOV     r10, r2
        ADD     r9, r2, #ModeSelector_ModeVars
        SUBS    r3, r3, #ModeSelector_ModeVars+4 ; Must at least be big enough for base block and list terminator
        BLT     strtospec_overflow
        MOV     r0, #ModeSelectorFlags_ValidFormat
        STR     r0, [r2, #ModeSelector_Flags]
        ; Find first parameter
strtospec_findfirst
        LDRB    r0, [r1], #1
        CMP     r0, #32
        BLO     strtospec_badstring
        CMP     r0, #","
        BEQ     strtospec_findfirst
        ; Is it a mode number?
        SUB     r4, r0, #"0"
        CMP     r4, #9
        BHI     strtospec_nonumber
        ; Must have space for at least four mode variables
        ; NColour, ModeFlags, XEigFactor, YEigFactor
        SUBS    r3, r3, #4*8
        BLT     strtospec_overflow
        SUB     r1, r1, #1
        MOV     r0, #10 :OR: (1:SHL:30) ; base 10, 0-255
        SWI     XOS_ReadUnsigned
        EXIT    VS
        ; Read the mode variables and use them to initialise the selector
        MOV     r8, r1
        MOV     r0, r2
        MOV     r1, #VduExt_XWindLimit
        SWI     XOS_ReadModeVariable
        ADDVC   r4, r2, #1
        MOVVC   r1, #VduExt_YWindLimit
        SWIVC   XOS_ReadModeVariable
        ADDVC   r5, r2, #1
        MOVVC   r1, #VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable
        MOVVC   r6, r2
        MOVVC   r7, #-1
        ASSERT  ModeSelector_XRes = 4
        ASSERT  ModeSelector_YRes = 8
        ASSERT  ModeSelector_PixelDepth = 12
        ASSERT  ModeSelector_FrameRate = 16
        STMVCIB r10, {r4-r7}
        MOVVC   r1, #VduExt_NColour
        SWIVC   XOS_ReadModeVariable
        STMVCIA r9!, {r1,r2}
        MOVVC   r1, #VduExt_ModeFlags
        SWIVC   XOS_ReadModeVariable
        LDRVC   lr, =ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_ChromaSubsampleMode :OR: ModeFlag_DataFormat_Mask
        ANDVC   r2, r2, lr ; Only keep the pixel format flags?
        STMVCIA r9!, {r1,r2}
        MOVVC   r1, #VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        STMVCIA r9!, {r1,r2}
        MOVVC   r1, #VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        EXIT    VS
        STMIA   r9!, {r1,r2}
        MOV     r1, r8
        MOV     r8, #0
        ; Fall through...
strtospec_scanloop
        ; Process the rest of the string
        LDRB    r0, [r1], #1
        CMP     r0, #32
        BLO     strtospec_done
        CMPNE   r0, #","
        BEQ     strtospec_scanloop
strtospec_check
        ASCII_UpperCase r0, lr
        CMP     R0,#"E"
        BEQ     strtospec_get_eig_factors
        CMP     R0,#"X"
        BEQ     strtospec_get_xres
        CMP     R0,#"Y"
        BEQ     strtospec_get_yres
        CMP     R0,#"C"
        BEQ     strtospec_get_colours
        CMP     R0,#"G"
        BEQ     strtospec_get_greys
        CMP     R0,#"F"
        BEQ     strtospec_get_frame
        CMP     R0,#"L"
        BEQ     strtospec_get_layout
        CMP     R0,#"T"
        BEQ     strtospec_get_ttx_colours
        ; Fall through...
strtospec_badstring
        PullEnv
        ADRL    r0, ErrorBlock_BadParameters ; Match the *wimpmode error
        B       ScreenMode_TranslateAndReturnError
strtospec_overflow
        PullEnv
        ADRL    r0, ErrorBlock_BuffOverflow
        B       ScreenMode_TranslateAndReturnError

strtospec_nonumber
        MOV     r4, #-1 ; xres
        MOV     r5, #-1 ; yres
        MOV     r6, #-1 ; bpp
        MOV     r7, #-1 ; framerate
        ASSERT  ModeSelector_XRes = 4
        ASSERT  ModeSelector_YRes = 8
        ASSERT  ModeSelector_PixelDepth = 12
        ASSERT  ModeSelector_FrameRate = 16
        STMIB   r10, {r4-r7}
        MOV     r8, #0 ; flags of which base parameters we've found, to detect duplicates
        B       strtospec_check

strtospec_get_eig_factors
        LDRB    R0,[R1],#1
        ASCII_UpperCase R0,R14
        CMP     R0,#"X"                  ; only EX EY allowed
        MOVEQ   R0,#VduExt_XEigFactor
        CMP     R0,#"Y"
        MOVEQ   R0,#VduExt_YEigFactor
        CMPNE   R0,#VduExt_XEigFactor
        BNE     strtospec_badstring
        Push    "R0"
        MOV     R0,#&2000000a           ; base 10
        MOV     R2,#3                   ; only allow 0-3 (note OS can cope with 4)
        SWI     XOS_ReadUnsigned
        ADDVS   sp,sp,#4
        BVS     strtospec_badstring
        Pull    "R0"
        ADR     lr, strtospec_scanloop
        ; Fall through...

strtospec_setvar ROUT
        ; Set mode variable R0 to value R2
        ; corrupts r4,r5
        ADD     r4,r10,#ModeSelector_ModeVars
05
        TEQ     r4,r9
        BEQ     %FT10
        LDR     r5,[r4],#8
        CMP     r5,r0
        BNE     %BT05
        STR     r2,[r4,#-4]
        MOV     pc,lr
10
        SUBS    r3,r3,#8
        BLT     strtospec_overflow
        STMIA   r9!,{r0,r2}
        MOV     pc,lr

strtospec_get_xres
        TST     r8, #strtospec_got_xres
        BNE     strtospec_badstring                  ; only one x allowed
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        STR     r2, [r10, #ModeSelector_XRes]
        ORR     r8, r8, #strtospec_got_xres
        B       strtospec_scanloop

strtospec_get_yres
        TST     r8, #strtospec_got_yres
        BNE     strtospec_badstring                  ; only one y allowed
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        STR     r2, [r10, #ModeSelector_YRes]
        ORR     r8, r8, #strtospec_got_yres
        B       strtospec_scanloop

strtospec_get_frame
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        STR     r2, [r10, #ModeSelector_FrameRate]
        B       strtospec_scanloop

strtospec_get_ttx_colours
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        MOV     R2,#strtospec_got_ttx_rcol
        MOV     R4,#VduExt_ScrRCol
        CMP     R0,#"X"
        MOVNE   R2,#strtospec_got_ttx_brow
        MOVNE   R4,#VduExt_ScrBRow
        CMPNE   R0,#"Y"
        BEQ     strtospec_get_ttx_size
        ; Set the "is teletext" flag
        ORR     R8,R8,#strtospec_is_ttx
        ; Fall through...
strtospec_get_colours ROUT
        TST     r8, #strtospec_got_colours
        BNE     strtospec_badstring                  ; only one C or G allowed
; only 2,4,16,64,256,4K,32T,32K,64T,64K,16M are valid
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring

        CMP     R2,#2
        ADREQ   R0,pixelformat_2col
        BEQ     strtospec_setpixelformat

        CMP     R2,#4
        BNE     %FT05
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"K"
        CMPNE   R0,#"T"
        ADREQ   R0,pixelformat_4k
        ADRNE   R0,pixelformat_4col
        ADDEQ   R1,R1,#1
        B       strtospec_setpixelformat

05
        CMP     R2,#16
        BNE     %FT10
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"M"
        ADREQ   R0,pixelformat_32bpp
        ADRNE   R0,pixelformat_16col
        ADDEQ   R1,R1,#1
        B       strtospec_setpixelformat

10
        CMP     R2,#64
        BNE     %FT15
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"K"
        CMPNE   R0,#"T"
        ADREQ   R0,pixelformat_64k
        ADRNE   R0,pixelformat_64col
        ADDEQ   R1,R1,#1
        B       strtospec_setpixelformat

15
        CMP     R2,#256
        ADREQ   R0,pixelformat_256col
        BEQ     strtospec_setpixelformat

        CMP     R2,#32
        BNE     strtospec_badstring
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"K"
        CMPNE   R0,#"T"
        BNE     strtospec_badstring
        ADR     R0,pixelformat_32k
        ADD     R1,R1,#1

strtospec_setpixelformat ROUT
        ORR     r8, r8, #strtospec_got_colours
        ASSERT  GVPixelFormat_NColour = 0
        ASSERT  GVPixelFormat_ModeFlags = 4
        ASSERT  GVPixelFormat_Log2BPP = 8
        LDMIA   r0, {r2,r6-r7}
        MOV     r0, #VduExt_NColour
        BL      strtospec_setvar
        STR     r7, [r10, #ModeSelector_PixelDepth]
        ; Merge new ModeFlags into any existing ones
        ADD     r4, r10, #ModeSelector_ModeVars
        TST     r8, #strtospec_is_ttx
        ; ROL spec says these should both be set for teletext
        ORRNE   r6, r6, #ModeFlag_Teletext+ModeFlag_GapMode
05
        TEQ     r4, r9
        BEQ     %FT10
        LDR     r5, [r4], #8
        CMP     r5, #VduExt_ModeFlags
        BNE     %BT05
        LDR     r2, [r4,#-4]
        BIC     r2, r2, #ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_GreyscalePalette
        ORR     r2, r2, r6
        ; Make sure it's RGB family
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TST     r2, #ModeFlag_DataFormatFamily_Mask
        BICNE   r2, r2, #ModeFlag_DataFormat_Mask ; Clear family & sub-family
        STR     r2, [r4,#-4]
        B       strtospec_scanloop
10
        SUBS    r3,r3,#8
        BLT     strtospec_overflow
        MOV     r0, #VduExt_ModeFlags
        STMIA   r9!,{r0,r6}
        B       strtospec_scanloop                

strtospec_get_greys
        TST     R8,#strtospec_got_colours
        BNE     strtospec_badstring                  ; only one C or G allowed
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        ; 2, 4, 16, 256, 16M allowed
        CMP     R2,#2
        ADREQ   R0,pixelformat_2grey
        BEQ     strtospec_setpixelformat
        CMP     R2,#4
        ADREQ   R0,pixelformat_4grey
        BEQ     strtospec_setpixelformat
        CMP     R2,#256
        ADREQ   R0,pixelformat_256grey
        BEQ     strtospec_setpixelformat
        CMP     R2,#16
        BNE     strtospec_badstring
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"M"
        ADREQ   R0,pixelformat_24bpp
        ADRNE   R0,pixelformat_16grey
        ADDEQ   R1,R1,#1
        B       strtospec_setpixelformat

strtospec_get_layout ROUT
        TST     R8,#strtospec_got_layout
        BNE     strtospec_badstring                  ; only one L allowed
        MOV     R7,#0
        LDRB    R0,[R1],#1
        ASCII_UpperCase R0,R14
        CMP     R0,#"A"
        ORREQ   R7,R7,#ModeFlag_DataFormatSub_Alpha
        CMPNE   R0,#"T"
        BNE     strtospec_badstring
        LDRB    R0,[R1],#1
        ASCII_UpperCase R0,R14
        CMP     R0,#32
        BLT     strtospec_badstring
        LDRB    R2,[R1],#1
        CMP     R2,#"G"
        CMPNE   R2,#"g"
        BNE     strtospec_badstring
        LDRB    R2,[R1],#1
        ASCII_UpperCase R2,R14
        EOR     R2,R0,R2
        CMP     R2,#"R" :EOR: "B"
        BNE     strtospec_badstring
        CMP     R0,#"R"
        ORREQ   R7,R7,#ModeFlag_DataFormatSub_RGB
        CMPNE   R0,#"B"
        BNE     strtospec_badstring
        ; Merge new ModeFlags into any existing ones
        ADD     r4, r10, #ModeSelector_ModeVars
        ORR     r8, r8, #strtospec_got_layout
05
        TEQ     r4, r9
        BEQ     %FT10
        LDR     r5, [r4], #8
        CMP     r5, #VduExt_ModeFlags
        BNE     %BT05
        LDR     r2, [r4,#-4]
        ; Must be RGB family
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TST     r2, #ModeFlag_DataFormatFamily_Mask
        BNE     strtospec_badstring
        BIC     r2, r2, #ModeFlag_DataFormatSub_Mask
        ORR     r2, r2, r7
        STR     r2, [r4,#-4]
        B       strtospec_scanloop
10
        SUBS    r3,r3,#8
        BLT     strtospec_overflow
        MOV     r0, #VduExt_ModeFlags
        STMIA   r9!,{r0,r7}
        B       strtospec_scanloop                

; R2 = R8 flag bit
; R4 = mode variable number
strtospec_get_ttx_size
        TST     r8, r2
        BNE     strtospec_badstring
        ADD     r1, r1, #1
        ORR     r8, r8, r2
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        SUBS    r2, r2, #1
        BLO     strtospec_badstring
        MOV     r0, r4
        ADR     lr, strtospec_scanloop
        B       strtospec_setvar

strtospec_done
        ; Did we find everything necessary?
        ASSERT  ModeSelector_XRes = 4
        ASSERT  ModeSelector_YRes = 8
        ASSERT  ModeSelector_PixelDepth = 12
        LDMIB   r10,{r0-r2}
        CMP     r0,#-1
        CMPNE   r1,#-1
        CMPNE   r2,#-1
        BEQ     strtospec_badstring
        ; TX and TY are only valid if T is also used
        EOR     r0, r8, #strtospec_is_ttx
        TST     r8, #strtospec_got_ttx_rcol+strtospec_got_ttx_brow
        TSTNE   r0, #strtospec_is_ttx
        BNE     strtospec_badstring
        ; Terminate the control list and exit
        MOV     r0, #-1
        STR     r0,[r9]
        MOV     r0, #ScreenModeReason_ModeStringToSpecifier
        EXIT
        
        ASSERT  GVPixelFormat_NColour = 0
        ASSERT  GVPixelFormat_ModeFlags = 4
        ASSERT  GVPixelFormat_Log2BPP = 8
        ASSERT  GVPixelFormat_Size = 12
pixelformat_list
pixelformat_2col    DCD 1,0,0
                    DCB "C2",0,0
pixelformat_4col    DCD 3,0,1
                    DCB "C4",0,0
pixelformat_16col   DCD 15,0,2
                    DCB "C16",0
pixelformat_64col   DCD 63,0,3
                    DCB "C64",0
pixelformat_256col  DCD 255,ModeFlag_FullPalette,3
                    DCB "C256"
pixelformat_4k      DCD 4095,0,4
                    DCB "C4K",0
pixelformat_32k     DCD 65535,0,4
                    DCB "C32K"
pixelformat_64k     DCD 65535,ModeFlag_64k,4
                    DCB "C64K"
pixelformat_32bpp   DCD -1,0,5
                    DCB "C16M"
pixelformat_2grey   DCD 1,ModeFlag_GreyscalePalette,0
                    DCB "G2",0,0
pixelformat_4grey   DCD 3,ModeFlag_GreyscalePalette,1
                    DCB "G4",0,0
pixelformat_16grey  DCD 15,ModeFlag_GreyscalePalette,2
                    DCB "G16",0
pixelformat_256grey DCD 255,ModeFlag_FullPalette+ModeFlag_GreyscalePalette,3
                    DCB "G256"
pixelformat_24bpp   DCD 16777215,0,6
                    DCB "G16M"
pixelformat_end

spectostr_ex  DCB "E"
spectostr_x   DCB "X",0
spectostr_y   DCB "Y",0
        ALIGN

;**************************************************************************
;
;       ScreenMode_ModeSpecifierToString
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (14)
;       r1 = pointer to mode specifier
;       r2 = pointer to mode string to fill in
;       r3 = size of mode string
;
; out:  r3 = -ve size of buffer required, if not big enough
;            0 if string was filled in
;       r10-r12 may be corrupted
;       All other registers preserved
;
;       Write values in the following order for consistency with other code:
;
;       X... Y... (C...|G...|T...) [L...] [EX...] [EY...] [F...] [TX...] [TY...]
;
ScreenMode_ModeSpecifierToString ROUT
        Entry   "r1-r9",8
        CMP     r1,#256
        BLO     %FT90 ; No mode numbers, please!
        LDR     r0,[r1,#ModeSelector_Flags]
        AND     r0,r0,#ModeSelectorFlags_FormatMask
        CMP     r0,#ModeSelectorFlags_ValidFormat
        BNE     %FT90
        MOV     r4,#0 ; Current string length
        ADR     r0,spectostr_x
        LDR     r5,[r1,#ModeSelector_XRes]
        BL      spectostr_write
        ADR     r0,spectostr_y
        LDR     r5,[r1,#ModeSelector_YRes]
        BL      spectostr_write
        ; Process the variable list to get the other parameters
        LDR     r8,[r1,#ModeSelector_PixelDepth] ; Get Log2BPP
        CMP     r8,#3
        MOVEQ   r7,#ModeFlag_FullPalette       ; Default ModeFlags
        MOVNE   r7,#0                          ;
        MOV     r5,#1
        MOV     r6,r5,LSL r8
        MOV     r6,r5,LSL r6
        SUB     r6,r6,#1                       ; Default NColour
        ADD     r1, r1, #ModeSelector_ModeVars
        MOV     r9, #-1                        ; XEig
        MOV     r10, #-1                       ; YEig
10
        LDR     r0, [r1], #8
        CMP     r0, #VduExt_ModeFlags
        LDREQ   r7, [r1,#-4]
        CMP     r0, #VduExt_NColour
        LDREQ   r6, [r1,#-4]
        CMP     r0, #VduExt_XEigFactor
        LDREQ   r9, [r1,#-4]
        CMP     r0, #VduExt_YEigFactor
        LDREQ   r10, [r1,#-4]
        CMP     r0, #-1
        BNE     %BT10
        ; Give up now if this is non RGB
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TST     r7, #ModeFlag_DataFormatFamily_Mask
        BNE     %FT90
        ; Stash the original flags for the teletext check
        Push    "r7"
        ; Mask out the uninteresting bits
        LDR     r0,=ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_ChromaSubsampleMode :OR: ModeFlag_DataFormat_Mask
        AND     r7,r7,r0
        ; Determine the colour format
        ADR     r0,pixelformat_list
20
        LDMIA   r0!,{r5,r11,lr}
        CMP     r5,r6
        AND     r5,r7,#ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_GreyscalePalette
        CMPEQ   r5,r11
        CMPEQ   r8,lr
        LDR     r5,[r0],#4
        BEQ     %FT30
        ADR     r5,pixelformat_end
        CMP     r0,r5
        BNE     %BT20
        ADD     sp,sp,#4 ; junk r7
        B       %FT90
30
        ; Munge string to say 'T' if it's teletext
        ; This will also remove the grey-ness from greyscale teletext... but
        ; we don't support those at the moment anyway (could perhaps use 'TG'?)
        Pull    "r7"
        TST     r7, #ModeFlag_Teletext
        BICNE   r5,r5,#&FF
        ORRNE   r5,r5,#'T'
        MOV     r6,#0
        STMIA   sp,{r5,r6} ; Push string onto stack to get it null terminated
        MOV     r0,sp
        BL      spectostr_writestr
        ; Write L... if necessary
        ANDS    r14,r7,#ModeFlag_DataFormatSub_Mask
        BEQ     %FT40
        ASSERT  ModeFlag_DataFormatSub_Mask = &C:SHL:12
        SUB     r14,r14,#1:SHL:14
        ADR     r0,spectostr_l
        ADD     r0,r0,r14,LSR #14-3
        BL      spectostr_writestr
40
        ; Write eigen values
        CMP     r9,#-1
        ADR     r0,spectostr_ex
        MOV     r5,r9
        BLNE    spectostr_write
        CMP     r10,#-1
        ADR     r0,spectostr_ey
        MOV     r5,r10
        BLNE    spectostr_write
        ; Write the framerate
        FRAMLDR r1
        LDR     r5,[r1,#ModeSelector_FrameRate]
        ADR     r0,spectostr_f
        CMP     r5,#-1
        BLNE    spectostr_write
        ; Write text resolution if teletext mode
        TST     r7,#ModeFlag_Teletext
        BEQ     %FT60
        ADD     r1,r1,#ModeSelector_ModeVars
50
        LDR     r14,[r1],#8
        CMP     r14,#-1
        BEQ     %FT60
        ADR     r0,spectostr_tx
        CMP     r14,#VduExt_ScrRCol
        ADRNE   r0,spectostr_ty
        CMPNE   r14,#VduExt_ScrBRow
        BNE     %BT50
        LDR     r5,[r1,#-4]
        ADD     r5,r5,#1
        ADR     lr,%BT50
        B       spectostr_write
60
        ; Finish
        CMP     r4,r3
        MOV     r0,#0
        STRLTB  r0,[r2,r4] ; Terminate string if space available
        ADD     r4,r4,#1
        SUBGE   r0,r0,r4
        FRAMSTR r0,,r3 ; Set to 0 or -(total length)
        MOV     r0,#ScreenModeReason_ModeSpecifierToString
        CLRV
        EXIT

spectostr_ey  DCB "EY",0
spectostr_f   DCB "F",0
spectostr_tx  DCB "TX",0
spectostr_ty  DCB "TY",0
        ALIGN

90
        PullEnv
        ADRL    r0, ErrorBlock_BadParameters
        B       ScreenMode_TranslateAndReturnError

spectostr_write ROUT
        ; Write string R0 followed by number R5
        ; R0 corrupted
        Push    "lr"
        BL      spectostr_writestr
        Push    "r1-r5"
        ADD     r0,sp,#4*4
        MOV     r2,#-1
        MOV     r3,#4
        MOV     r4,#ConvertToCardinal
        SWI     XOS_ConvertVariform
        MVN     r2,r2 ; Get length, excluding terminator
        LDMIB   sp,{r1,r3-r4} ; get stacked r2, r3-r4
        ADD     r1,r1,r4 ; Position to write to
        ADD     r4,r4,r2 ; Increment written length
        STR     r4,[sp,#12]
        CMP     r4,r3 ; Is there space?
        ADD     r0,sp,#4*4
        MOV     r3,#4
        MOV     r4,#ConvertToCardinal
        SWILE   XOS_ConvertVariform
        Pull    "r1-r5,pc"

spectostr_writestr ROUT
        ; Write string R0
        ; R0 corrupted
        Push    "lr"
        ; Do we need a leading space?
        CMP     r4,#0
        MOVNE   lr,#32
        BNE     %FT10
05
        LDRB    lr,[r0],#1
        CMP     lr,#0
        Pull    "pc",EQ
10
        CMP     r4,r3
        STRLTB  lr,[r2,r4]
        ADD     r4,r4,#1
        B       %BT05

spectostr_l
        DCB     "LTRGB",0,0,0
        DCB     "LABGR",0,0,0
        DCB     "LARGB",0,0,0


;**************************************************************************
;
;       ScreenMode_SelectModeByString
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (15)
;       r1 = pointer to mode string
;
; out:  r0 = error, or preserved
;       r10-r12 may be corrupted
;       All other registers preserved
;
ScreenMode_SelectModeByString ROUT
        Entry   "r1-r3", ModeSelector_MaxSize
        MOV     r0, #ScreenModeReason_ModeStringToSpecifier
        MOV     r2, sp
        MOV     r3, #ModeSelector_MaxSize
        SWI     XOS_ScreenMode
        MOVVC   r0, #ScreenModeReason_SelectMode
        MOVVC   r1, r2
        SWIVC   XOS_ScreenMode
        MOVVC   r0, #ScreenModeReason_SelectModeByString
        EXIT

;**************************************************************************
;
;       ScreenMode_RegisterDriver
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (64)
;       r1 = flags (reserved, sbz)
;       r2 = driver name string (static, null-terminated)
;
; out:  r0 = driver number
;       r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_RegisterDriver ROUT
        TEQ     r1, #0
        ADRNEL  r0, ErrorBlock_BadParameters
        BNE     ScreenMode_TranslateAndReturnError
        Entry   "r1-r4"
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        MOV     r4, #0
05
        LDR     r11, [r10], #4
        CMP     r11, #0
        BEQ     %FT10
        ADD     r4, r4, #1
        CMP     r4, #MaxGraphicsVDrivers
        BNE     %BT05
        ADRL    r0, ErrorBlock_TooManyGDrivers
        PullEnv
        B       ScreenMode_TranslateAndReturnError
10
        MOV     r3, #GVDriver_Size
        BL      ClaimSysHeapNode
        EXIT    VS
        LDMIA   sp, {r1,r3}
        ASSERT  GVDriver_RegisterFlags = 0
        ASSERT  GVDriver_Name = 4
        ASSERT  GVDriver_StateFlags = 8
        MOV     r11, #0
        STMIA   r2, {r1,r3,r11}
        STR     r2, [r10, #-4]
        MOV     r0, r4
        EXIT

;**************************************************************************
;
;       ScreenMode_StartDriver
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (65)
;       r1 = driver number
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_StartDriver ROUT
        Entry   "r0-r3"
        VDWS    WsPtr
        ; Validate driver number
        CMP     r1, #MaxGraphicsVDrivers
        BHS     %FT10
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        LDR     r11, [r10, r1, LSL #2]
        CMP     r11, #0
        LDRNE   r0, [r11, #GVDriver_StateFlags]
        EORNE   r0, r0, #GVDriverState_Started
        TSTNE   r0, #GVDriverState_Started
        BEQ     %FT10
        ; Mark as started
        STR     r0, [r11, #GVDriver_StateFlags]
        ; Issue a service call to indicate new driver is ready to go
        ; For simplicity ROL's Service_DisplayStatus is used. However the
        ; display descriptor is empty as we don't (currently) use them.
        MOV     r0, #DisplayStatus_Registered
        MOV     r2, r1
        MOV     r1, #Service_DisplayStatus
        ADR     r3, dummy_display_descriptor
        IssueService
        ; If we don't have a driver yet, use this one
        LDR     r0, [WsPtr, #CurrentGraphicsVDriver]
        CMP     r0, #GraphicsVInvalid
        MOVEQ   r0, #ScreenModeReason_SelectDevice
        MOVEQ   r1, r2
        SWIEQ   XOS_ScreenMode
        ; Swallow any error - just because the driver can't be used as the default driver it doesn't mean that it failed to start
        CLRV
        EXIT
10
        PullEnv
        ADRL    r0, ErrorBlock_BadGDriver
        B       ScreenMode_TranslateAndReturnError        

dummy_display_descriptor
        DCD     0


;**************************************************************************
;
;       ScreenMode_StopDriver
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (66)
;       r1 = driver number
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_StopDriver ROUT
        Entry   "r0-r3"
        VDWS    WsPtr
        ; Validate driver number
        CMP     r1, #MaxGraphicsVDrivers
        BHS     %FT10
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        LDR     r11, [r10, r1, LSL #2]
        CMP     r11, #0
        LDRNE   r0, [r11, #GVDriver_StateFlags]
        TSTNE   r0, #GVDriverState_Started
        BEQ     %FT10
        ; Deactivate driver if it's currently in use
        LDR     r0, [WsPtr, #CurrentGraphicsVDriver]
        CMP     r0, r1
        MOVEQ   r0, #ScreenModeReason_SelectDevice
        MOVEQ   r1, #GraphicsVInvalid
        SWIEQ   XOS_ScreenMode
        ; Give up if the driver failed to stop (shouldn't really happen, as it'll be the driver making the call to StopDriver)
        STRVS   r0, [sp]
        EXIT    VS
        ; Issue Service_DisplayStatus to indicate driver stopping
        MOV     r0, #DisplayStatus_Deregistered
        MOV     r2, r1
        MOV     r1, #Service_DisplayStatus
        MOV     r3, #0
        IssueService
        ; Mark as stopped
        LDR     r0, [r11, #GVDriver_StateFlags]
        BIC     r0, r0, #GVDriverState_Started
        STR     r0, [r11, #GVDriver_StateFlags]
        EXIT
10
        PullEnv
        ADRL    r0, ErrorBlock_BadGDriver
        B       ScreenMode_TranslateAndReturnError        
        

;**************************************************************************
;
;       ScreenMode_DeregisterDriver
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (67)
;       r1 = driver number
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_DeregisterDriver ROUT
        Entry   "r0-r2"
        ; Validate driver number
        CMP     r1, #MaxGraphicsVDrivers
        BHS     %FT10
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        LDR     r2, [r10, r1, LSL #2]!
        CMP     r2, #0
        LDRNE   r1, [r2, #GVDriver_StateFlags]
        EORNE   r1, r1, #GVDriverState_Started
        TSTNE   r1, #GVDriverState_Started
        BEQ     %FT10
        ; Mark as free
        MOV     r1, #0
        STR     r1, [r10]
        ; Free the heap block
        BL      FreeSysHeapNode
        CLRV    ; Ignore heap errors, the driver is still freed
        EXIT
10
        PullEnv
        ADRL    r0, ErrorBlock_BadGDriver
        B       ScreenMode_TranslateAndReturnError        


;**************************************************************************
;
;       ScreenMode_EnumerateDrivers
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (68)
;       r1 = driver number to return details of
;            or GraphicsVInvalid to return id of first driver
;       r2 = flags (reserved, sbz)
;
; out:  r1 = next driver number
;            or GraphicsVInvalid if reached end of list
;       r2 = driver flags on registration
;       r3 = driver name string
;       r4 = driver state
;            0 = unallocated/invalid driver (r2, r3 invalid)
;            1 = allocated
;            2 = started
;       r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_EnumerateDrivers ROUT
        ; Validate flags
        TEQ     r2, #0
        ADRNEL  r0, ErrorBlock_BadParameters
        BNE     ScreenMode_TranslateAndReturnError
        Entry   "r5-r6"
        ; Return information on requested driver
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        CMP     r1, #MaxGraphicsVDrivers
        LDRLO   r11, [r10, r1, LSL #2]
        MOVHS   r11, #0
        CMP     r11, #0
        ASSERT  GVDriver_RegisterFlags = 0
        ASSERT  GVDriver_Name = 4
        ASSERT  GVDriver_StateFlags = 8
        LDMNEIA r11, {r2-r4}
        ASSERT  GVDriverState_Started = 1
        ANDNE   r4, r4, #1
        ADDNE   r4, r4, #1
        MOVEQ   r2, #0
        MOVEQ   r3, #0
        MOVEQ   r4, #0
        ; Work out next driver number
        CMP     r1, #GraphicsVInvalid
        MOVEQ   r1, #0
        BEQ     %FT20
10
        CMP     r1, #MaxGraphicsVDrivers-1
        MOVHS   r1, #GraphicsVInvalid
        BHS     %FT90
        ADD     r1, r1, #1
20
        LDR     r11, [r10, r1, LSL #2]
        CMP     r11, #0
        BEQ     %BT10
90
        EXIT        
        

        END
@


4.12
log
@Tweak OS_ReadModeVariable optimisations
Detail:
  s/vdu/vduswis - Don't use RMVForCurrentMode when R0 = ModeNo, only use it if R0 is -1. This ensures that results for explicitly-specified modes will always represent the base properties of the mode and won't be influenced by any unusual properties of the current mode, e.g. LineLength/ScreenSize alterations caused by driver-specific framebuffer padding.
Admin:
  Tested on Raspberry Pi 3


Version 5.83. Tagged as 'Kernel-5_83'
@
text
@a850 19
      [ {FALSE} ; There are so many pixel formats now that it's better to let the driver do one check itself rather than doing one here and then one in the driver
        ;we'll do the vet on whether h/w supports the pixel depth ourselves
        LDR   r2,[r0,#VIDCList3_PixelDepth]
        MOV   r3,#1
        MOV   r3,r3,LSL r2                 ; bits per pixel

        Push  "r0-r2"
        LDR   r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV   r4, r4, LSL #24
        ORR   r4, r4, #GraphicsV_DisplayFeatures
        BL    CallGraphicsV
        TEQ   r4,#0
        TSTEQ r3,r1
        Pull  "r0-r2"

        MOVEQ r0,#1
        BEQ   %FT04                        ; not supported
      ]

d863 1
a863 1
; service claimed and happy HAL so return with this mode
a876 99
        MOV     r10, r2                 ; mode without shadow bits
        MOV     r1, r0                  ; start from existing mode

        CMP     r3, #NumMonitorTypes    ; monitor type must be in range
        BCS     %FT10                   ; if not then must issue service
        CMPCC   r10, #NumModes          ; and mode must be in range
        MOVCC   r11, #NumModes
        MLACC   r11, r3, r11, r10       ; then form monitortype*numberofmodes + modenumber
        ADRCCL  r14, BigVIDCTable       ; point to big table
        LDRCC   r11, [r14, r11, LSL #2] ; and load offset
        CMPCC   r11, #-1                ; CS if mode number or monitor type out of range, or if not known in table
        BCC     %FT20                   ; else it's known about, so OK

; known monitor type, but unknown mode, so find substitute

        ADR     r14, SubstModeTable
        LDR     r11, [r14, r3, LSL #2]
        TEQ     r11, #0                 ; if r0=0, monitor type is actually unknown - issue service call
        BEQ     %FT10
        ADD     r1, r11, r14
05
        BL      FindSubstitute
        Pull    "r2-r4,r10,r11, pc"     ; exit VC or VS

; unknown monitor type, so offer service

10

; if monitor type 7 (file), and requesting mode 7, try some alternative teletext modes before asking for external help
        TEQ     r3, #7
        TEQEQ   r10, #7
        BNE     %FT19
        Push    "r0,r3"
        ; Build up a temporary mode selector (however, needs to be in a static buffer to allow return via OS_CheckModeValid)
        ADD     r10, WsPtr, #TempModeSelector
        ADR     r0, AltTTXModeProto
        MOV     r2, #AltTTXMode_Size
11
        SUBS    r2, r2, #4
        LDR     r3, [r0, r2]
        STR     r3, [r10, r2]
        BNE     %BT11
        ; For each resolution, try all the pixel formats supported by the driver
        ADR     r11, AltTTXModes
12
        LDMIA   r11!, {r3, r4}
        CMP     r3, #-1
        BEQ     %FT18
        ASSERT  ModeSelector_XRes = 4
        ASSERT  ModeSelector_YRes = 8
        ASSERT  ModeSelector_PixelDepth = 12
        MOV     r14, #2 ; Start at 4BPP and work up
        STMIB   r10, {r3, r4, r14}
13
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_PixelFormats
        BL      CallGraphicsV
        CMP     r4, #0
        BNE     %FT18
        ; Look for pixel formats that match the current Log2BPP
        CMP     r1, #0
        BEQ     %FT18
14
        ASSERT  GVPixelFormat_NColour = 0
        ASSERT  GVPixelFormat_ModeFlags = 4
        ASSERT  GVPixelFormat_Log2BPP = 8
        ASSERT  GVPixelFormat_Size = 12
        LDMIA   r0!, {r2-r4}
        LDR     r14, [r10, #ModeSelector_PixelDepth]
        CMP     r4, r14
        BNE     %FT17
        STR     r2, [r10, #AltTTXMode_NColour]
        ORR     r3, r3, #ModeFlag_Teletext+ModeFlag_GapMode
        STR     r3, [r10, #AltTTXMode_Flags]
        Push    "r0"
        BL      PushModeInfo
        ADDVC   r13, r13, #PushedInfoSize
        Pull    "r0"
        MOVVC   r1, r10
        Pull    "r0,r3",VC
        BVC     %FT20
17
        SUBS    r1, r1, #1
        BNE     %BT14
        ; Try next BPP
        LDR     r14, [r10, #ModeSelector_PixelDepth]
        ADD     r14, r14, #1
        CMP     r14, #6
        STRLO   r14, [r10, #ModeSelector_PixelDepth]
        BLO     %BT13
        ; Try next resolution
        B       %BT12
18
        Pull    "r0,r3"
        MOV     r10, #7

19
        MOV     r2, r10
d880 2
a881 13
        MOVEQ   r1, r2                  ; if claimed, then use module's mode
        BEQ     %FT20

; unknown monitor type
; if monitor type 7 (file), use substitution table for VGA (reasonable assumption)

        TEQ     r3, #7
        ADREQ   r1, SubstType3
        BEQ     %BT05

        MOV     r1, #0                  ; else panic and use mode 0

20
a893 59
SubstModeTable
        &       SubstType01-SubstModeTable
        &       SubstType01-SubstModeTable
        &       SubstType2-SubstModeTable
        &       SubstType3-SubstModeTable
        &       SubstType4-SubstModeTable
        &       0
        &       0
        &       0
        &       SubstType8-SubstModeTable

SubstType01
        =        0,  8, 12, 15
SubstType2
        =       23, 23, 23, 23
SubstType3
        =       25, 26, 27, 28
SubstType4
        =       29, 30, 31, 32
SubstType8
        =       44, 45, 46, 46

; Alternate teletext modes
; Primary use case for this list of alternatives is when EDID is in use, so we only list modes which might typically show up in EDID.
AltTTXModes
      [ :LNOT: HiResTTX
        DCD     640, 350
        DCD     640, 400
        DCD     720, 400
        DCD     640, 480
        DCD     720, 480
      |
        ; For HiResTTX it makes sense to include the native teletext resolution, so that we can try the other colour depths that are available (failure to get native mode 7 might have only been due to unsupported colour depth)
        DCD     640, 500
      ]
        DCD     720, 576
        DCD     800, 600
        DCD     1280, 720
        DCD     -1

AltTTXModeProto
        DCD     1
        DCD     0 ; width
        DCD     0 ; height
        DCD     2 ; Log2BPP
        DCD     -1
        DCD     VduExt_ModeFlags
AltTTXMode_Flags * . - AltTTXModeProto
        DCD     0
        DCD     VduExt_ScrRCol
        DCD     39
        DCD     VduExt_ScrBRow
        DCD     24
        DCD     VduExt_NColour
AltTTXMode_NColour * . - AltTTXModeProto
        DCD     15
        DCD     -1
AltTTXMode_Size * . - AltTTXModeProto

a897 43
;       FindSubstitute - Find substitute mode with right no. of bpp
;
; in:   r1 -> table of 4 bytes; subst. modes for 1, 2, 4, 8 bpp respectively
;       r10 = mode specifier to be tested (shadow bit clear)
;
; out:  If no error, then
;         r0 preserved
;         r1 = substitute mode
;         V=0
;       else
;         r0 -> error
;         r1 preserved
;       endif
;       r11 corrupted, all other registers preserved
;

FindSubstitute Entry
        MOV     r11, #0
        BL      PushModeInfoAnyMonitor
        EXIT    VS                              ; if error, then exit now
        LDR     r11, [r13, #wkLog2BPP]
        ADD     r13, r13, #PushedInfoSize
        CMP     r11, #4
        MOVCS   r11, #0
        Push    "r0-r4"
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV                   ; see if h/w supports this BPP
        TEQ     r4, #0
        MOVEQ   r2, r1
        MOVNE   r2, #2_111111
        MOV     r3, #1
        MOV     r3, r3, LSL r11
        TST     r2, r3
        MOVEQ   r11, #3                         ; if not, use 8 BPP (assumed best chance for a mode number)
        Pull    "r0-r4"
        LDRB    r1, [r1, r11]
        CLRV
        EXIT

; *****************************************************************************
;
d1959 1
a1959 1
ScreenMode_SelectMonitorType Entry "r0"
d1967 3
@


4.11
log
@Teletext fixes
Detail:
  s/vdu/vdudriver, s/vdu/vdumodes - Re-introduce TTX256 so that 8bpp teletext will be used if no MDF is loaded
  s/vdu/vdudriver - If the video driver didn't support the native mode 7 colour depth, ModePromoTable was swapping it for another mode number, preventing the AltTTX code in FindOKMode from operating. So, skip the ModePromoTable check for mode 7.
  s/vdu/vduswis - Minor correction to alternate teletext mode search; 1<<5 = 32bpp, so stop search at log2bpp of 6
Admin:
  Tested on Raspberry Pi


Version 5.74. Retagged as 'Kernel-5_74'
@
text
@a314 2
        LDR     r11, [WsPtr, #ModeNo]   ; get current mode

a425 3
        CMP     r0, r11                 ; if implicitly asking for current mode (and mode <> mode selector)
        BEQ     RMVForCurrentMode       ; then use optimised code

@


4.10
log
@Add support for custom teletext modes
Detail:
  This set of changes:
  * Adds support for the T, TX and TY mode string elements (as per RISCOS Ltd)
  * Adds support for entering arbitrary-resolution teletext modes by using mode selector blocks with the Teletext mode flag set
  * ScrRCol and ScrBRow mode variables can be provided in the mode selector in order to restrict the number of text rows/columns in teletext modes (as per RISCOS Ltd)
  * If the rows / columns are restricted in this manner then the text window will be centered on the screen, to try and avoid things looking too ugly (no variable text scaling implemented)
  * For HiResTTX, all colour depths >= 4bpp are now supported by teletext. This essentially makes the TTX256 switch obsolete.
  * If the "native" mode 7 is unavailable then the kernel will try a series of fallback resolutions & colour depths in an effort to find a combination that works
  Known bugs/issues:
  * Teletext column count has a max limit of 255 due to TTXDoubleCounts being a byte array
  * If there's a border around the text window, the border will not be refreshed when changing transparency modes using a VDU 23,18,0 sequence
  * ScreenLoad looks like it can overflow the LargeCommon buffer (no buffer size check) - needs fixing before LargeCommon can be safely shrunk below (Old)TTXMapSize
  File changes:
  - hdr/KernelWS - Make CharWidth non-conditional. Adjust handling of teletext workspace; it's now allocated from the system heap to allow it to cope with arbitrary screen sizes
  - s/vdu/vdu23 - Make CharWidth non-conditional
  - s/vdu/vducursoft - Make CursorTeletext cope with arbitrary colour depths, make CharWidth non-conditional, remove hard-coded teletext values
  - s/vdu/vdudriver - Deal with teletext workspace allocation during ModeChangeSub. Deal with selecting teletext modes (and validating colour depth) in GenerateModeSelectorVars.
  - s/vdu/vdugrafl - Make CharWidth non-conditional. Calculate offset required for text window centering.
  - s/vdu/vdumodes - Remove TTX256
  - s/vdu/vduswis - Try other teletext modes if native mode 7 not available. Extend OS_ScreenMode reason codes to cope with teletext mode strings.
  - s/vdu/vduttx - Update to use dynamic workspace. Replace various hardcoded values with variable lookups. Update character plotting + colour/palette selection to work with true-colour modes if HiResTTX.
  - s/vdu/vduwrch - Move some useful code into a subroutine. Update FastCLS to cope with true-colour teletext. Update AddressR0R1 to cope with text window centering offset. Make CharWidth non-conditional.
Admin:
  Tested on Raspberry Pi, BB-xM
  VDU 23,18,0 in 256-colour teletext now works correctly (previously 64-colour mode was in use, causing palette update to be ruined by VIDC1-mangling)


Version 5.74. Tagged as 'Kernel-5_74'
@
text
@d989 1
a989 1
        CMP     r14, #7
@


4.9
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d928 71
d1050 37
d2348 10
d2444 2
a2445 1
        ; TODO - Add support for T, TX, TY teletext parameters
d2507 1
a2507 1
        TST     r8, #1
d2513 1
a2513 1
        ORR     r8, r8, #1
d2517 1
a2517 1
        TST     r8, #2
d2523 1
a2523 1
        ORR     r8, r8, #2
d2533 13
d2547 1
a2547 1
        TST     r8, #4
d2608 1
a2608 1
        ORR     r8, r8, #4
d2618 3
d2644 1
a2644 1
        TST     R8,#4
d2670 1
a2670 1
        TST     R8,#8
d2698 1
a2698 1
        ORR     r8, r8, #8
d2721 16
d2747 5
d2816 1
a2816 1
;       X... Y... (C...|G...) [L...] [EX...] [EY...] [F...]
d2857 1
a2857 2
        ; Give up now if this is a teletext mode, or non RGB
        TST     r7, #ModeFlag_Teletext
d2859 1
a2859 1
        TSTEQ   r7, #ModeFlag_DataFormatFamily_Mask
d2861 2
d2879 1
d2882 7
d2894 1
a2894 1
        ANDS    r7,r7,#ModeFlag_DataFormatSub_Mask
d2897 1
a2897 1
        SUB     r7,r7,#1:SHL:14
d2899 1
a2899 1
        ADD     r0,r0,r7,LSR #14-3
d2911 1
a2911 1
        ; Finally the framerate
d2917 18
d2948 2
@


4.8
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a381 28
; TMD 09-Dec-93
; New algorithms for xeig, yeig from Roger:
;       xeig = 1: yeig = 1
;       if yres<xres/2 OR yres<400 then yeig = 2
;       if (xres<<xeig)<(yres<<yeig) then xeig = 2

 [ RogerEXEY
RMVMS_XEigFactor
        LDR     r2, [r0, #ModeSelector_XRes]
        LDR     r11, [r0, #ModeSelector_YRes]
        CMP     r11, r2, LSR #1                         ; if yres < xres/2
        CMPCS   r11, #400                               ; or yres < 400
        MOVCC   r11, r11, LSL #2                        ; then yeig = 2
        MOVCS   r11, r11, LSL #1                        ; else yeig = 1
        CMP     r11, r2, LSL #1                         ; if (xres<<1) < (yres<<yeig)
        MOVHI   r2, #2                                  ; then xeig = 2
        MOVLS   r2, #1                                  ; else xeig = 1
        B       GoodReadModeVar

RMVMS_YEigFactor
        LDR     r2, [r0, #ModeSelector_XRes]
        LDR     r11, [r0, #ModeSelector_YRes]
        CMP     r11, r2, LSR #1                         ; if yres < xres/2
        CMPCS   r11, #400                               ; or yres < 400
        MOVCC   r2, #2                                  ; then yeig = 2
        MOVCS   r2, #1                                  ; else yeig = 1
        B       GoodReadModeVar
 |
a392 1
 ]
a1240 1
  [ StrongARM
a1242 1
        [ AssemblingArthur
a1243 3
        |
        LDR     PC, =(MOSDriver + MOSPMFWrch)
        ]
a1244 9
  |
        Push    PC                      ; push address of %FT20
        LDRB    R0, [R10], #1
        [ AssemblingArthur
        B       PMFWrchDirect
        |
        LDR     PC, =(MOSDriver + MOSPMFWrch)
        ]
  ]
a1296 1
  [ StrongARM
a1298 1
        [ AssemblingArthur
a1299 3
        |
        LDRNE   PC, =(MOSDriver + MOSPMFWrch)
        ]
a1300 9
  |
        Push    PC, NE                  ; push address of %FT20
        [ AssemblingArthur
        BNE     PMFWrchDirect
        |
        LDRNE   PC, =(MOSDriver + MOSPMFWrch)
        ]
        B       %FT80                   ; no more characters
  ]
a1344 1
  [ StrongARM
a1348 5
  |
        Push    PC, NE                  ; push address of %FT20
        BNE     PMFWrchDirect
        B       %FT80                   ; no more characters
  ]
a1381 2
        [ AssemblingArthur

a1521 2
        ]

@


4.7
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a1175 1
 [ No26bitCode
a1177 16
 |
        ADR     R14, %FT05 + SVC_mode   ; R14 will have I_bit clear

; TMD 16-May-89: Next instruction used to be B PreWrchCursor2, a secondary
; entry point that didn't disable IRQs as they were assumed to be already
; off. However this caused a bug in RISC OS 2.00, since SWIs are now entered
; with the IRQ state of the caller, so this has now been changed back to
; use the primary entry point (PreWrchCursor) which does disable them.

        B       PreWrchCursor           ; this exits by MOVS PC, R14 so it
                                        ; clears the I_bit for us
; PreWrchCursor  also exits with R6 = CursorFlags, needed for the
; EntryFromSWIPlot routine to do clip window calculations if necessary

05
 ]
a1427 1
  [ No26bitCode
a1432 4
  |
        ADD     R10, R10, #3
        BIC     R10, R10, #3            ; round up to next word boundary
  ]
@


4.6
log
@Had one of those weekend brainstorms - managed to speed up SWI despatcher
_and_ add Thumb support to it.
Fixed OS_BreakPt - was confused by PC/PSR split.

Version 5.24. Not tagged
@
text
@a16 3
        GBLL    FixRemovePages
FixRemovePages  SETL {TRUE}

d19 1
a19 1
        MOV     R11, #0
d25 1
a25 1
        CMP     R12, #&03800000
d79 4
d122 1
a122 1
        DivRem  R0, R7, R4, R2          ; R0 = (width-(1 or sizex))DIV spacex
d125 1
a125 1
        DivRem  R1, R7, R5, R3          ; R1 = (height-(1 or sizey))DIV spacey
a208 1
 [ STB
d210 4
a213 1
 ]
d216 3
a326 2
  [ ModeSelectors

a454 5
  |

; else drop thru into ...

  ]
d526 1
a526 1
CheckWorkspaceList ENTRY
d584 1
a584 1
;       (R0,R1,R14 stacked)
d612 2
a613 1
        MOVS    r14, r0, LSR #27        ; shift type word into b4-b0
d615 3
d619 1
a619 1
        CMP     r14, #SpriteType_MAX
d623 1
a623 1

a659 2
         ; note, yes - I know this could be type-1, but at some point some new type
         ; will break the relationship so it's a table from day 1 to cope with this
d661 5
a665 3

NSM_eig_mask
        &       &00001FFF
d668 1
d670 4
a673 1
        B       %FT10
d676 1
d678 1
a678 1
10
d681 4
d703 5
d709 42
a750 1
        MOV     r2, #0                  ; both these return zero
d753 20
a791 1
 [ ModeSelectors
a794 3
 |
        BIC     r10, r1, #&80           ; only use substitute mode (11/8/88)
 ]
a802 1
 [ ModeSelectors
a804 1
 ]
d813 8
a820 1
        LDR     r9, [WsPtr, #TotalScreenSize] ; maximum allowed amount
a869 1
 [ ModeSelectors
a872 3
 |
        BIC     r2, r0, #&80
 ]
d876 41
a916 1
; service claimed, so return with this number
a926 1
 [ ModeSelectors
a928 1
 ]
d981 2
a983 1
        SETV                            ; error exit
d1008 2
d1028 1
a1028 1
FindSubstitute ENTRY
d1036 13
d1061 1
a1061 1
ReadMonitorType ENTRY "r0-r2"
d1064 1
a1064 16
        MOV     r3, r1                  ; move into r3
        EXIT

; *****************************************************************************
;
;       ReadSyncType - Read sync type
;
; out:  R4 = sync type (0 or 1)
;       Z set/clear on R4
;       All other registers preserved
;

ReadSyncType ENTRY "r0-r2"
        MOV     r0, #1
        SWI     XOS_ReadSysInfo         ; out: r0 = mode, r1 = monitortype, r2 = sync
        MOVS    r4, r2                  ; move into r4
d1084 1
a1084 1
        mrs    ,R11, CPSR               ; disable IRQs, so can be called from
d1086 1
a1086 1
        msr    ,CPSR_c, R11
d1100 4
d1124 21
d1172 1
a1172 1
        TSTEQ   R10, #Flag_NonGraphic   ; thru normal chans
d1475 1
d1483 3
a1485 5
        ADD     R2, R0, #ScreenEndAdr   ; end of remaining screen memory
 [ :LNOT: FixRemovePages
        CMP     R3, R2
        BCS     %FT50                   ; display starts in disappearing pages
 ]
a1490 1
 [ FixRemovePages
d1492 1
a1492 1
        CMP     R5, #ScreenEndAdr       ; if off end of 1st copy
a1500 3
 |
        STR     R5, [WsPtr, #DisplayStart]
 ]
d1514 1
a1516 1
 [ FixRemovePages
d1519 1
a1519 1
        CMP     R0, #ScreenEndAdr       ; ensure displayscreenstart in range too
a1521 1
 ]
d1528 9
a1536 1
 [ :LNOT: FixRemovePages
d1538 6
a1543 1
; display starts in disappearing pages
d1545 1
a1545 10
50
        ADD     R4, R3, R0              ; destination start
        MOV     R0, R3
        BL      SetVinit                ; set vinit and DisplayStart
60
        LDMIA   R3!, {R5-R8}
        STMIA   R4!, {R5-R8}
        TEQ     R3, #ScreenEndAdr
        BNE     %BT60
        B       %BT30
d1547 2
d1556 1
d1562 1
d1567 1
a1567 1
        MOV     R3, #ScreenEndAdr
d1576 4
d1584 4
d1590 2
a1591 1
        MOV     R4, #0
d1601 2
a1602 1
        RSB     R5, R4, #ScreenEndAdr   ; start of remaining screen memory
a2001 1
 [ ModeSelectors
d2013 1
a2013 1
ScreenModeSWI ENTRY
d2019 11
a2029 5
        ASSERT  ScreenModeReason_SelectMode = 0
        ASSERT  ScreenModeReason_ReturnMode = 1
        ASSERT  ScreenModeReason_EnumerateModes = 2
        ASSERT  ScreenModeReason_SelectMonitorType = 3
        ASSERT  ScreenModeReason_Limit = 4
d2032 1
a2032 1
        CMP     r0, #ScreenModeReason_Limit
d2034 23
d2058 6
a2063 4
        B       ScreenMode_SelectMode
        B       ScreenMode_ReturnMode
        B       ScreenMode_EnumerateModes
        B       ScreenMode_SelectMonitorType
d2067 5
d2084 3
a2086 6
; Temporary error blocks, so we don't have to claim Hdr:NewErrors every 5 mins.

ErrorBlock_ScreenModeBadReason
        &       0
        =       "Zonk:Unknown OS_ScreenMode reason code", 0
        ALIGN
d2101 1
a2101 1
ScreenMode_SelectMode ENTRY "r0-r9"
d2156 1
a2156 1
ScreenMode_EnumerateModes ENTRY "r3-r5"
d2176 1
a2176 1
ScreenMode_SelectMonitorType ENTRY "r0"
d2186 846
a3031 1
 ]
d3033 3
a3035 3
; Should not cause any problems on any machine.  STB flag just to be safe though.
 [ STB :LAND: {TRUE}
; *****************************************************************************
d3037 1
a3037 1
;       VIDCDividerSWI - Entry point for SWI OS_VIDCDivider
d3039 2
a3040 1
; in:   r0 = Value for divider - 1
d3042 2
a3043 1
; out:  r0 = Preserved or error if V set
d3046 50
a3095 10
VIDCDividerSWI	ENTRY "r0-r1,WsPtr"
	CMP	r0, #8					; Check the value is in range.
	BCC	%FT10					; Continue if so.
	PullEnv						; Else return an error.
	ADR	r0, ErrorBlock_BadVIDCDivider		; Get address of error.
 [ International
        BL      TranslateError				; Translate the error.
 ]
	ORR	lr, lr, #V_bit				; Return with V bit set.
	ExitSWIHandler
d3097 19
d3117 27
a3143 10
	VDWS	WsPtr					; Get the VDU work space.
	LDR	r1, [WsPtr, #VIDCControlCopy]		; Get the old control register value.
	BIC	r1, r1, #7:SHL:CR_PixelDivShift		; Mask out the old divider.
	ORR	r1, r1, r0, LSL #CR_PixelDivShift	; ORR in the new...
	STR	r1, [WsPtr, #VIDCControlCopy]		; Write back to work space.
	MOV	r0, #VIDC
	STR	r1, [r0, #0]				; Write to VIDC also.
	PullEnv						; Done.
	ExitSWIHandler
 ]
d3145 38
a3182 3
ErrorBlock_BadVIDCDivider
	&	0
	=	"BadVIDCDiv:Bad VIDC divider value.", 0
@


4.6.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d527 1
a527 1
CheckWorkspaceList Entry
d912 1
a912 1
FindSubstitute Entry
d932 1
a932 1
ReadMonitorType Entry "r0-r2"
d947 1
a947 1
ReadSyncType Entry "r0-r2"
d970 1
a970 1
        MRS     R11, CPSR               ; disable IRQs, so can be called from
d972 1
a972 1
        MSR     CPSR_c, R11
d1863 1
a1863 1
ScreenModeSWI Entry
d1918 1
a1918 1
ScreenMode_SelectMode Entry "r0-r9"
d1973 1
a1973 1
ScreenMode_EnumerateModes Entry "r3-r5"
d1993 1
a1993 1
ScreenMode_SelectMonitorType Entry "r0"
d2016 1
a2016 1
VIDCDividerSWI	Entry "r0-r1,WsPtr"
@


4.6.2.2
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@d207 1
a207 2
;mjs - no longer a sensible concept in HALised world:
;        RVVT    VIDCClockSpeed
d321 2
d451 5
d714 1
d718 3
d729 1
d732 1
d791 1
d795 3
d801 1
a801 23
; service claimed
; mjs Kernel/HAL split
; call HAL vetting routine to possibly adjust parameters (or if desperate, to disallow mode) 

;;;mjsHAL - is the mode workspace suitably generic to be passed to HAL?

        ; int HAL_VetMode(void *VIDClist, void *workspace)
        ;
        ; VIDClist  -> generic video controller list (VIDC list type 3)
        ; workspace -> mode workspace (if mode number), or 0
        ; returns 0 if OK (may be minor adjusts to VIDClist and/or workspace values)
        ;         non-zero if not OK
        ;
        Push "r0-r3, r9, r12"
        MOV   r0,r3
        MOV   r1,r4
        mjsAddressHAL
        mjsCallHAL    HAL_Video_VetMode
        CMP   r0,#0
        Pull "r0-r3,r9,r12"
        BNE   %FT05         ; HAL says "Oi, Kernel, No!"

; service claimed and happy HAL so return with this mode
d812 1
d815 1
d935 16
a950 1
        MOV  r3, r1                  ; move into r3
d1851 1
d2003 2
a2004 2
;;;mjsHAL - VIDCDividerSWI is horrible VIDC specific API, compiled out
;;;
d2006 1
a2006 1
 [ STB :LAND: {FALSE}
d2016 5
a2020 5
VIDCDividerSWI  Entry "r0-r1,WsPtr"
        CMP     r0, #8                                  ; Check the value is in range.
        BCC     %FT10                                   ; Continue if so.
        PullEnv                                         ; Else return an error.
        ADR     r0, ErrorBlock_BadVIDCDivider           ; Get address of error.
d2022 1
a2022 1
        BL      TranslateError                          ; Translate the error.
d2024 2
a2025 2
        ORR     lr, lr, #V_bit                          ; Return with V bit set.
        ExitSWIHandler
d2028 10
a2037 9
        VDWS    WsPtr                                   ; Get the VDU work space.
        LDR     r1, [WsPtr, #VIDCControlSoftCopy]       ; Get the old control register value.
        BIC     r1, r1, #7:SHL:CR_PixelDivShift         ; Mask out the old divider.
        ORR     r1, r1, r0, LSL #CR_PixelDivShift       ; ORR in the new...
        STR     r1, [WsPtr, #VIDCControlSoftCopy]       ; Write back to work space.
        MOV     r0, #VIDC
        STR     r1, [r0, #0]                            ; Write to VIDC also.
        PullEnv                                         ; Done.
        ExitSWIHandler
d2040 2
a2041 4
        &       0
        =       "BadVIDCDiv:Bad VIDC divider value.", 0

 ]
@


4.6.2.3
log
@kernel now attempts to substitute video mode numbers in face of
h/w with limited bits-per-pixel support (not tested yet)
HAL_API document added - early draft only, of interest to those
writing or modifying HALs for new h/w
ARMop_API document added - early draft only, of interest only
to those modifying kernel to support new ARM cores
*** polite comments on HAL_API welcome ***

Version 5.35, 4.79.2.15. Tagged as 'Kernel-5_35-4_79_2_15'
@
text
@d786 4
d791 7
a797 3
; mjs Kernel/HAL split
; call HAL vetting routine to possibly disallow mode
;
a800 9
        ;we'll do the vet on whether h/w supports the pixel depth ourselves
        LDR   r2,[r0,#VIDCList3_PixelDepth]
        MOV   r3,#1
        MOV   r3,r3,LSL r2                 ; bits per pixel
        LDR   r2,[WsPtr,#HWPixelFormats]
        TST   r3,r2
        MOVEQ r0,#1
        BEQ   %FT04                        ; not supported
        ;now any vet the HAL might want to do
a802 1
04
a923 7
        Push    "r2, r3"
        LDR     r2, [WsPtr, #HWPixelFormats]    ; see if h/w supports this BPP
        MOV     r3, #1
        MOV     r3, r3, LSL r11
        TST     r2, r3
        MOVEQ   r11, #3                         ; if not, use 8 BPP (assumed best chance for a mode number)
        Pull    "r2, r3"
@


4.6.2.4
log
@Customer L-y HAL-y IIC-y type stuff. It's great.
@
text
@d207 3
a209 1
        RVVT    VIDCClockSpeed
d211 1
@


4.6.2.5
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d17 3
a793 8
 [ UseGraphicsV
        Push  "r0-r2,r4"
        MOV   r4,#GraphicsV_DisplayFeatures
        BL    CallGraphicsV
        TEQ   r4,#0
        TSTEQ r3,r1
        Pull  "r0-r2,r4"
 |
a795 1
 ]
a798 8
 [ UseGraphicsV
        Push  "r4"
        MOV   r4, #GraphicsV_VetMode
        BL    CallGraphicsV
        TEQ   r4, #0
        MOVNE r0, #0
        Pull  "r4"
 |
a800 1
 ]
a922 8
 [ UseGraphicsV
        Push    "r0-r4"
        MOV     r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        TEQ     r4, #0
        MOVEQ   r2, r1
        MOVNE   r2, #2_111111
 |
a924 1
 ]
a928 3
 [ UseGraphicsV
        Pull    "r0-r4"
 |
a929 1
 ]
a980 4
        LDRB    R10, [WsPtr, #ExternalFramestore]
        TEQ     R10, #0
        BNE     %FT15

a1000 21
; using external framestore - they can have the whole screen memory DA
15
        Push    "R0,R1,R14"
        MOV     R0, #2
        SWI     XOS_ReadDynamicArea     ; R0 -> start, R1 = len
        MOVVC   R10, R0
        MOVVC   R11, R1
        MOVVS   R11, #0
        Pull    "R0,R1,R14"
        CMP     R1, R11                 ; is this enough
        MOV     R1, R11                 ; tell him how much he could have
        BHI     %BT10                   ; if not enough, then exit

        MOV     R11, #1                 ; indicate now claimed
        STRB    R11, [WsPtr, #ScreenMemoryClaimed]

        MOV     R2, R10

        BIC     R14, R14, #C_bit
        ExitSWIHandler

a1330 1
;       R4 = current size
d1338 5
a1342 3
        BNE     RemovePages_ExternalFramestore
        LDR     R14, [WsPtr, #ScreenEndAddr]
        ADD     R2, R0, R14             ; end of remaining screen memory
d1348 1
d1350 1
a1350 1
        CMP     R5, R14                 ; if off end of 1st copy
d1359 3
a1374 1
        LDR     R14, [WsPtr, #ScreenEndAddr]
d1377 1
d1380 1
a1380 1
        CMP     R0, R14                 ; ensure displayscreenstart in range too
d1383 1
d1390 1
a1390 3
; in:   R0 = - number of bytes being removed
;       R4 = current size
RemovePages_ExternalFramestore
d1392 1
a1392 5
 [ {FALSE}
; Should do the copy, but need access to address
        ADD     R3, R3, R4              ; end of area to copy +1
        CMP     R3, R2
        BLS     %FT20                   ; nothing to copy
d1394 10
a1403 8
        SUB     R4, R3, R0              ; destination end
10
        LDMDB   R3!, {R5-R8}            ; load 4 words (minimum amount)
        STMDB   R4!, {R5-R8}            ; store 4 words
        TEQ     R3, R2
        BNE     %BT10

20
a1404 2
InsertRemovePages_ExternalFramestoreExit
        Pull    "R0-R8,R12,PC"
a1411 1
;       R4 = new size
a1416 1
        BNE     InsertPages_ExternalFramestore
d1421 1
a1421 1
        LDR     R3, [WsPtr, #ScreenEndAddr]
a1429 4
InsertPages_ExternalFramestore
; Should do copy here
        B       InsertRemovePages_ExternalFramestoreExit

a1433 4
        LDR     R1, [WsPtr, #ExternalFramestore]
        TEQ     R1, #0
        MOVNE   PC, R14

d1446 1
a1446 2
        LDR     R3, [WsPtr, #ScreenEndAddr]
        RSB     R5, R4, R3              ; start of remaining screen memory
@


4.6.2.6
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d25 1
a25 1
        CMP     R12, #&FC000000                    ; fudge
@


4.6.2.7
log
@  Added four new VDU variables.
Detail:
  174: left border size
  175: bottom border size
  176: right border size
  177: top border size
Admin:
  Not tested.

Version 5.35, 4.79.2.68. Tagged as 'Kernel-5_35-4_79_2_68'
@
text
@a205 4
        RVVT    BorderL
        RVVT    BorderB
        RVVT    BorderR
        RVVT    BorderT
@


4.6.2.8
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d19 1
a19 1
        LDR     R11, =ZeroPage
d1497 1
a1497 1
        LDRB    R1, [WsPtr, #ExternalFramestore]
d1503 1
a1503 2
        LDR     R4, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
@


4.6.2.9
log
@Improve heap manager. Add heap testbed. Add dummy implementation of some OS_ScreenMode reason codes.
Detail:
  s/HeapMan, hdr/KernelWS - Heap manager improvements:
    - Errors generated by interrupted heap operations that are forced to complete by a OS_Heap call from the background are now cached in kernel workspace until the foreground task is resumed. This prevents them from being potentially overwritten by MessageTrans running out of background error buffers.
    - Added new OS_Heap reason code, #7 - Get area aligned. This allows areas of memory to be allocated at specific (power-of-2) alignments, and optionally without crossing a given (power-of-2) boundary. Alignment & boundary calculations are performed using logical addresses.
    - Removed the limitation that all free and allocated blocks must be a multiple of 8 bytes in length. This change was required in order to allow OS_Heap 7 to function correctly. Now the only requirements are that blocks must be multiples of 4 bytes in length, at 4 byte alignment, with a minimum length of 8 bytes. 4 extra padding bytes may still be added to the end of allocations in order to avoid creating 4-byte free blocks.
  s/HeapMan, TestSrc/HeapTest/Makefile, TestSrc/HeapTest/c/testbed, TestSrc/HeapTest/s/asm - Added heap testbed program. Can either use the OS_Heap SWI or directly include a copy of the Kernel's heap manager sources.
  s/vdudecl, s/vduswis - Added dummy implementations of OS_ScreenMode 4, 5 and 6. This prevents the Wimp generating lots of "Unknown OS_ScreenMode reason code" errors when redrawing the screen.
  s/Arthur3, s/Oscli - Moved dotstring closer to where it's used to avoid "ADRL out of range" errors in Tungsten build
Admin:
  Tested in OMAP3 ROM & Tungsten ROM softload.
  Heap testbed successfully performed over 400 million heap ops, so there shouldn't be any serious bugs in the new code (touch wood)


Version 5.35, 4.79.2.128. Tagged as 'Kernel-5_35-4_79_2_128'
@
text
@d1936 1
a1936 4
        ASSERT  ScreenModeReason_ConfigureAcceleration = 4
        ASSERT  ScreenModeReason_CleanCache = 5
        ASSERT  ScreenModeReason_ForceCleanCache = 6
        ASSERT  ScreenModeReason_Limit = 7
a1945 3
        B       ScreenMode_ConfigureAcceleration
        B       ScreenMode_CleanCache
        B       ScreenMode_ForceCleanCache
a2065 46
;**************************************************************************
;
;       ScreenMode_ConfigureAcceleration - Configure screen memory cacheability
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (4)
;       r1 = flags:
;              bit 0 : set to suspend cached screen until mode change
;              bit 1 : set to suspend screen cleaning
;              bit 2 : set to disable hardware acceleration
;              other : reserved, must be 0
;            or -1 to read current value
;       r2 = number of VSyncs between automatic screen cleaning (1-3), or -1
;       to read current value
;
; out:  r1 = new flag state
;       r2 = new number of VSyncs between automatic screen cleaning
;       r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_ConfigureAcceleration
        ; Screen caching isn't supported yet. Just return dummy values.
        MOV     r1,#1
        MOV     r2,#1
        MOV     pc,lr

;**************************************************************************
;
;       ScreenMode_CleanCache - Clean screen memory from cache, if cache enabled
;       ScreenMode_ForceCleanCache - Force clean of screen memory from cache
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (5 or 6)
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_CleanCache
ScreenMode_ForceCleanCache
        ; Screen caching isn't supported yet. Just do nothing.
        MOV      pc,lr

@


4.6.2.10
log
@Make Mike's macros permanent.
While the HAL and kernel were being split some temporary macros were used for the bits being worked on, after 12 years of use they're probably safe to adopt.
mjsCallHAL -> CallHAL; mjsAddressHAL -> AddressHAL; mjsHAL -> HAL.
OS_VIDCDividerSWI code now always does NoSuchSWI (had been switched out previously).
File vduhint.s no longer assembled (was empty).


Version 5.35, 4.79.2.150. Tagged as 'Kernel-5_35-4_79_2_150'
@
text
@d817 2
a818 2
        AddressHAL
        CallHAL HAL_Video_VetMode
d2118 41
@


4.6.2.11
log
@Make GraphicsV_IICOp more consistent
No accepts  r0 = b31-24 set 0
                 b23-16 fully qualified IIC address
                 b15-0  starting offset
            r1 = buffer pointer
            r2 = number of bytes to tranfer
            r4 = b31-24 display number
                 b23-16 head
                 b15-0  reason code (=14)
Now returns r0 = result codes as per HAL_IICTransfer()
            r1 = buffer pointer incremented by number of bytes transferred
            r2 = number of bytes *not* transferred
            r4 = 0
Removed '_' after Video in entry numbers to be consistent with other HAL entry naming, and HAL_VideoFlybackDevice.
Added IICStatus return numbers to Hdr:HALEntries.
Stop calling HAL_MonitorLeadID as only IOMD implemented it - just guess VGA until the graphics driver says otherwise.

Version 5.35, 4.79.2.159. Tagged as 'Kernel-5_35-4_79_2_159'
@
text
@d818 1
a818 1
        CallHAL HAL_VideoVetMode
@


4.6.2.12
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d890 1
a890 1
 |
a891 1
 ]
@


4.6.2.13
log
@ScreenModeBadReason changed to non zero error number
Temporary assignment changed to one from Hdr:NewErrors.

Version 5.35, 4.79.2.176. Tagged as 'Kernel-5_35-4_79_2_176'
@
text
@d1968 6
a1973 1
        MakeErrorBlock ScreenModeBadReason
@


4.6.2.14
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d577 1
a577 1
;       (R0,R1,R14 stacked & corruptible)
d605 1
a605 2
        MOV     r14, r0, LSR #27        ; shift type word into b4-b0
        ANDS    r14, r14, #&F           ; discard wide mask bit
a606 3
        ;if it's a RISC OS 5 sprite mode word, deal with it elsewhere
        CMP     r14, #SpriteType_RISCOS5
        BEQ     RISCOS5SpriteModeWord
d608 1
a608 1
        CMP     r14, #SpriteType_RO5MAX
d612 1
a612 1
15
d649 2
d652 3
a654 5
        &       5, 5, 5 ; CMYK, 24bpp, JPEG (not supported)
        &       4 ; 64K sprite
        &       5, 5, 5, 5, 5 ; types 11-15 (reserved)
        &       4 ; 4K sprite
        &       5, 5 ; YCbCr 422 & 420 (not supported)
a656 1
      [ NoARMT2
d658 1
a658 4
      |
        UBFX    r0, r0, #14, #13        ; move ydpi into b0-b12
      ]
        B       %FT20
a660 1
      [ NoARMT2
d662 1
a662 1
20
a664 4
      |
        UBFX    r0, r0, #1, #13         ; move xdpi into b0-b12
20
      ]
a682 5
        CMP     r14, #SpriteType_New64K
        MOVEQ   r2, #ModeFlag_64k
        MOVNE   r2, #0
        B       GoodReadModeVar
        
d684 1
a684 51
        MOV     r2, #0
        B       GoodReadModeVar

RISCOS5SpriteModeWord
        TST     r0, #&F0000                     ; validate RO 5 sprite mode word
        TSTEQ   r0, #&0000E
        MOVNE   r14, #SpriteType_Substitute     ; and try substitute if bad
        BNE     %BT15
        ; From this point on, assume it really is a RISC OS 5 sprite mode word, and throw errors for anything we don't recognise
        MOV     r14, r0, LSR #20
        ANDS    r14, r14, #127
        BEQ     BadReadModeVar                  ; type 0 isn't valid
        CMP     r14, #SpriteType_RO5MAX
        BGE     BadReadModeVar
        
        ADR     r2, RO5SpriteModeWordRoutines
        ADD     pc, r2, r1, LSL #2      ; and despatch it

RO5SpriteModeWordRoutines
        B       RO5SM_modeflags ;       0 ModeFlags             (zero)
        B       BadReadModeVar ;        1 ScrRCol               Error
        B       BadReadModeVar ;        2 ScrBRow               Error
        B       NSM_ncol       ;        3 NColour
        B       RO5SM_xeig     ;        4 XEigFactor
        B       RO5SM_yeig     ;        5 YEigFactor
        B       BadReadModeVar ;        6 LineLength            Error
        B       BadReadModeVar ;        7 ScreenSize            Error
        B       NSM_yshftfactor ;       8 YShftFactor           (zero)
        B       NSM_bpp        ;        9 Log2BPP
        B       NSM_bpp        ;       10 Log2BPC               as Log2BPP
        B       BadReadModeVar ;       11 XWindLimit            Error
        B       BadReadModeVar ;       12 YWindLimit            Error

RO5SM_modeflags
        AND     r2, r0, #&FF00
        ; Validate ModeFlags. We only support RGB colourspace, so the only valid
        ; bits are the RGB and alpha flags
        TST     r2, #&FF00-(ModeFlag_DataFormatSub_RGB+ModeFlag_DataFormatSub_Alpha)
        BNE     BadReadModeVar
        ; Add in the 64K flag if necessary
        CMP     r14, #SpriteType_New64K
        ORREQ   r2, r2, #ModeFlag_64k
        B       GoodReadModeVar

RO5SM_xeig
      [ NoARMT2
        MOV     r2, r0, LSR #4
        AND     r2, r2, #3
      |
        UBFX    r2, r0, #4, #2
      ]
a686 11
RO5SM_yeig
      [ NoARMT2
        MOV     r2, r0, LSR #6
        AND     r2, r2, #3
      |
        UBFX    r2, r0, #6, #2
      ]
        B       GoodReadModeVar



d1086 1
a1086 1
        TSTEQ   R10, #ModeFlag_NonGraphic ; thru normal chans
d1933 8
a1940 5
        MACRO
        SMEntry $name
        ASSERT  . - ScreenModeSub_Table = ScreenModeReason_$name * 4
        B       ScreenMode_$name
        MEND
d1943 1
a1943 1
        CMP     r0, #ScreenModeReason_Limit1
d1946 7
a1952 17
ScreenModeSub_Table
        SMEntry SelectMode
        SMEntry ReturnMode
        SMEntry EnumerateModes
        SMEntry SelectMonitorType
        SMEntry ConfigureAcceleration
        SMEntry CleanCache
        SMEntry ForceCleanCache
        SMEntry CountScreenBanks
        SMEntry SelectDisplayBank
        SMEntry SelectVDUBank
        SMEntry CopyBank
        SMEntry SelectDevice
        SMEntry ROL_DeviceDetails
        SMEntry ModeStringToSpecifier
        SMEntry ModeSpecifierToString
        SMEntry SelectModeByString
a1955 6
ScreenMode_CountScreenBanks
ScreenMode_SelectDisplayBank
ScreenMode_SelectVDUBank
ScreenMode_CopyBank
ScreenMode_SelectDevice
ScreenMode_ROL_DeviceDetails
a2113 607
;**************************************************************************
;
;       ScreenMode_ModeStringToSpecifier
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (13)
;       r1 = pointer to mode string
;       r2 = pointer to mode specifier to fill in
;       r3 = size of mode specifier
;
; out:  r0 = error, or preserved
;       r10-r12 may be corrupted
;       All other registers preserved
;
ScreenMode_ModeStringToSpecifier ROUT
        Entry   "r1-r9"
        MOV     r10, r2
        ADD     r9, r2, #ModeSelector_ModeVars
        SUBS    r3, r3, #ModeSelector_ModeVars+4 ; Must at least be big enough for base block and list terminator
        BLT     strtospec_overflow
        MOV     r0, #ModeSelectorFlags_ValidFormat
        STR     r0, [r2, #ModeSelector_Flags]
        ; Find first parameter
strtospec_findfirst
        LDRB    r0, [r1], #1
        CMP     r0, #32
        BLO     strtospec_badstring
        CMP     r0, #","
        BEQ     strtospec_findfirst
        ; Is it a mode number?
        SUB     r4, r0, #"0"
        CMP     r4, #9
        BHI     strtospec_nonumber
        ; Must have space for at least four mode variables
        ; NColour, ModeFlags, XEigFactor, YEigFactor
        SUBS    r3, r3, #4*8
        BLT     strtospec_overflow
        SUB     r1, r1, #1
        MOV     r0, #10 :OR: (1:SHL:30) ; base 10, 0-255
        SWI     XOS_ReadUnsigned
        EXIT    VS
        ; Read the mode variables and use them to initialise the selector
        MOV     r8, r1
        MOV     r0, r2
        MOV     r1, #VduExt_XWindLimit
        SWI     XOS_ReadModeVariable
        ADDVC   r4, r2, #1
        MOVVC   r1, #VduExt_YWindLimit
        SWIVC   XOS_ReadModeVariable
        ADDVC   r5, r2, #1
        MOVVC   r1, #VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable
        MOVVC   r6, r2
        MOVVC   r7, #-1
        ASSERT  ModeSelector_XRes = 4
        ASSERT  ModeSelector_YRes = 8
        ASSERT  ModeSelector_PixelDepth = 12
        ASSERT  ModeSelector_FrameRate = 16
        STMVCIB r10, {r4-r7}
        MOVVC   r1, #VduExt_NColour
        SWIVC   XOS_ReadModeVariable
        STMVCIA r9!, {r1,r2}
        MOVVC   r1, #VduExt_ModeFlags
        SWIVC   XOS_ReadModeVariable
        LDRVC   lr, =ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_ChromaSubsampleMode :OR: ModeFlag_DataFormat_Mask
        ANDVC   r2, r2, lr ; Only keep the pixel format flags?
        STMVCIA r9!, {r1,r2}
        MOVVC   r1, #VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        STMVCIA r9!, {r1,r2}
        MOVVC   r1, #VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        EXIT    VS
        STMIA   r9!, {r1,r2}
        MOV     r1, r8
        MOV     r8, #0
        ; Fall through...
strtospec_scanloop
        ; Process the rest of the string
        LDRB    r0, [r1], #1
        CMP     r0, #32
        BLO     strtospec_done
        CMPNE   r0, #","
        BEQ     strtospec_scanloop
strtospec_check
        ASCII_UpperCase r0, lr
        CMP     R0,#"E"
        BEQ     strtospec_get_eig_factors
        CMP     R0,#"X"
        BEQ     strtospec_get_xres
        CMP     R0,#"Y"
        BEQ     strtospec_get_yres
        CMP     R0,#"C"
        BEQ     strtospec_get_colours
        CMP     R0,#"G"
        BEQ     strtospec_get_greys
        CMP     R0,#"F"
        BEQ     strtospec_get_frame
        CMP     R0,#"L"
        BEQ     strtospec_get_layout
        ; TODO - Add support for T, TX, TY teletext parameters
        ; Fall through...
strtospec_badstring
        PullEnv
        ADRL    r0, ErrorBlock_BadParameters ; Match the *wimpmode error
        B       ScreenMode_TranslateAndReturnError
strtospec_overflow
        PullEnv
        ADRL    r0, ErrorBlock_BuffOverflow
        B       ScreenMode_TranslateAndReturnError

strtospec_nonumber
        MOV     r4, #-1 ; xres
        MOV     r5, #-1 ; yres
        MOV     r6, #-1 ; bpp
        MOV     r7, #-1 ; framerate
        ASSERT  ModeSelector_XRes = 4
        ASSERT  ModeSelector_YRes = 8
        ASSERT  ModeSelector_PixelDepth = 12
        ASSERT  ModeSelector_FrameRate = 16
        STMIB   r10, {r4-r7}
        MOV     r8, #0 ; flags of which base parameters we've found, to detect duplicates
        B       strtospec_check

strtospec_get_eig_factors
        LDRB    R0,[R1],#1
        ASCII_UpperCase R0,R14
        CMP     R0,#"X"                  ; only EX EY allowed
        MOVEQ   R0,#VduExt_XEigFactor
        CMP     R0,#"Y"
        MOVEQ   R0,#VduExt_YEigFactor
        CMPNE   R0,#VduExt_XEigFactor
        BNE     strtospec_badstring
        Push    "R0"
        MOV     R0,#&2000000a           ; base 10
        MOV     R2,#3                   ; only allow 0-3 (note OS can cope with 4)
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        Pull    "R0"
        ADR     lr, strtospec_scanloop
        ; Fall through...

strtospec_setvar ROUT
        ; Set mode variable R0 to value R2
        ; corrupts r4,r5
        ADD     r4,r10,#ModeSelector_ModeVars
05
        TEQ     r4,r9
        BEQ     %FT10
        LDR     r5,[r4],#8
        CMP     r5,r0
        BNE     %BT05
        STR     r2,[r4,#-4]
        MOV     pc,lr
10
        SUBS    r3,r3,#8
        BLT     strtospec_overflow
        STMIA   r9!,{r0,r2}
        MOV     pc,lr

strtospec_get_xres
        TST     r8, #1
        BNE     strtospec_badstring                  ; only one x allowed
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        STR     r2, [r10, #ModeSelector_XRes]
        ORR     r8, r8, #1
        B       strtospec_scanloop

strtospec_get_yres
        TST     r8, #2
        BNE     strtospec_badstring                  ; only one y allowed
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        STR     r2, [r10, #ModeSelector_YRes]
        ORR     r8, r8, #2
        B       strtospec_scanloop

strtospec_get_frame
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        STR     r2, [r10, #ModeSelector_FrameRate]
        B       strtospec_scanloop

strtospec_get_colours ROUT
        TST     r8, #4
        BNE     strtospec_badstring                  ; only one C or G allowed
; only 2,4,16,64,256,4K,32T,32K,64T,64K,16M are valid
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring

        CMP     R2,#2
        ADREQ   R0,pixelformat_2col
        BEQ     strtospec_setpixelformat

        CMP     R2,#4
        BNE     %FT05
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"K"
        CMPNE   R0,#"T"
        ADREQ   R0,pixelformat_4k
        ADRNE   R0,pixelformat_4col
        ADDEQ   R1,R1,#1
        B       strtospec_setpixelformat

05
        CMP     R2,#16
        BNE     %FT10
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"M"
        ADREQ   R0,pixelformat_32bpp
        ADRNE   R0,pixelformat_16col
        ADDEQ   R1,R1,#1
        B       strtospec_setpixelformat

10
        CMP     R2,#64
        BNE     %FT15
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"K"
        CMPNE   R0,#"T"
        ADREQ   R0,pixelformat_64k
        ADRNE   R0,pixelformat_64col
        ADDEQ   R1,R1,#1
        B       strtospec_setpixelformat

15
        CMP     R2,#256
        ADREQ   R0,pixelformat_256col
        BEQ     strtospec_setpixelformat

        CMP     R2,#32
        BNE     strtospec_badstring
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"K"
        CMPNE   R0,#"T"
        BNE     strtospec_badstring
        ADR     R0,pixelformat_32k
        ADD     R1,R1,#1

strtospec_setpixelformat ROUT
        ORR     r8, r8, #4
        LDMIA   r0, {r2,r6-r7}
        MOV     r0, #VduExt_NColour
        BL      strtospec_setvar
        STR     r7, [r10, #ModeSelector_PixelDepth]
        ; Merge new ModeFlags into any existing ones
        ADD     r4, r10, #ModeSelector_ModeVars
05
        TEQ     r4, r9
        BEQ     %FT10
        LDR     r5, [r4], #8
        CMP     r5, #VduExt_ModeFlags
        BNE     %BT05
        LDR     r2, [r4,#-4]
        BIC     r2, r2, #ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_GreyscalePalette
        ORR     r2, r2, r6
        ; Make sure it's RGB family
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TST     r2, #ModeFlag_DataFormatFamily_Mask
        BICNE   r2, r2, #ModeFlag_DataFormat_Mask ; Clear family & sub-family
        STR     r2, [r4,#-4]
        B       strtospec_scanloop
10
        SUBS    r3,r3,#8
        BLT     strtospec_overflow
        MOV     r0, #VduExt_ModeFlags
        STMIA   r9!,{r0,r6}
        B       strtospec_scanloop                

strtospec_get_greys
        TST     R8,#4
        BNE     strtospec_badstring                  ; only one C or G allowed
        MOV     r0, #10
        SWI     XOS_ReadUnsigned
        BVS     strtospec_badstring
        ; 4, 16, 256, 16M allowed
        CMP     R2,#4
        ADREQ   R0,pixelformat_4grey
        BEQ     strtospec_setpixelformat
        CMP     R2,#256
        ADREQ   R0,pixelformat_256grey
        BEQ     strtospec_setpixelformat
        CMP     R2,#16
        BNE     strtospec_badstring
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R0,#"M"
        ADREQ   R0,pixelformat_24bpp
        ADRNE   R0,pixelformat_16grey
        ADDEQ   R1,R1,#1
        B       strtospec_setpixelformat

strtospec_get_layout ROUT
        TST     R8,#8
        BNE     strtospec_badstring                  ; only one L allowed
        MOV     R7,#0
        LDRB    R0,[R1],#1
        ASCII_UpperCase R0,R14
        CMP     R0,#"A"
        ORREQ   R7,R7,#ModeFlag_DataFormatSub_Alpha
        CMPNE   R0,#"T"
        BNE     strtospec_badstring
        LDRB    R0,[R1],#1
        ASCII_UpperCase R0,R14
        CMP     R0,#32
        BLT     strtospec_badstring
        LDRB    R2,[R1],#1
        CMP     R2,#"G"
        CMPNE   R2,#"g"
        BNE     strtospec_badstring
        LDRB    R2,[R1],#1
        ASCII_UpperCase R2,R14
        EOR     R2,R0,R2
        CMP     R2,#"R" :EOR: "B"
        BNE     strtospec_badstring
        CMP     R0,#"R"
        ORREQ   R7,R7,#ModeFlag_DataFormatSub_RGB
        CMPNE   R0,#"B"
        BNE     strtospec_badstring
        ; Merge new ModeFlags into any existing ones
        ADD     r4, r10, #ModeSelector_ModeVars
        ORR     r8, r8, #8
05
        TEQ     r4, r9
        BEQ     %FT10
        LDR     r5, [r4], #8
        CMP     r5, #VduExt_ModeFlags
        BNE     %BT05
        LDR     r2, [r4,#-4]
        ; Must be RGB family
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TST     r2, #ModeFlag_DataFormatFamily_Mask
        BNE     strtospec_badstring
        BIC     r2, r2, #ModeFlag_DataFormatSub_Mask
        ORR     r2, r2, r7
        STR     r2, [r4,#-4]
        B       strtospec_scanloop
10
        SUBS    r3,r3,#8
        BLT     strtospec_overflow
        MOV     r0, #VduExt_ModeFlags
        STMIA   r9!,{r0,r7}
        B       strtospec_scanloop                

strtospec_done
        ; Did we find everything necessary?
        ASSERT  ModeSelector_XRes = 4
        ASSERT  ModeSelector_YRes = 8
        ASSERT  ModeSelector_PixelDepth = 12
        LDMIB   r10,{r0-r2}
        CMP     r0,#-1
        CMPNE   r1,#-1
        CMPNE   r2,#-1
        BEQ     strtospec_badstring
        ; Terminate the control list and exit
        MOV     r0, #-1
        STR     r0,[r9]
        MOV     r0, #ScreenModeReason_ModeStringToSpecifier
        EXIT
        
        ; Format is NColour, ModeFlags, Log2BPP, 4 char name string
pixelformat_list
pixelformat_2col    DCD 1,0,0
                    DCB "C2",0,0
pixelformat_4col    DCD 3,0,1
                    DCB "C4",0,0
pixelformat_16col   DCD 15,0,2
                    DCB "C16",0
pixelformat_64col   DCD 63,0,3
                    DCB "C64",0
pixelformat_256col  DCD 255,ModeFlag_FullPalette,3
                    DCB "C256"
pixelformat_4k      DCD 4095,0,4
                    DCB "C4K",0
pixelformat_32k     DCD 65535,0,4
                    DCB "C32K"
pixelformat_64k     DCD 65535,ModeFlag_64k,4
                    DCB "C64K"
pixelformat_32bpp   DCD -1,0,5
                    DCB "C16M"
pixelformat_4grey   DCD 3,ModeFlag_GreyscalePalette,1
                    DCB "G4",0,0
pixelformat_16grey  DCD 15,ModeFlag_GreyscalePalette,2
                    DCB "G16",0
pixelformat_256grey DCD 255,ModeFlag_FullPalette+ModeFlag_GreyscalePalette,3
                    DCB "G256"
pixelformat_24bpp   DCD 16777215,0,6
                    DCB "G16M"
pixelformat_end

spectostr_ex  DCB "E"
spectostr_x   DCB "X",0
spectostr_y   DCB "Y",0
        ALIGN

;**************************************************************************
;
;       ScreenMode_ModeSpecifierToString
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (14)
;       r1 = pointer to mode specifier
;       r2 = pointer to mode string to fill in
;       r3 = size of mode string
;
; out:  r3 = -ve size of buffer required, if not big enough
;            0 if string was filled in
;       r10-r12 may be corrupted
;       All other registers preserved
;
;       Write values in the following order for consistency with other code:
;
;       X... Y... (C...|G...) [L...] [EX...] [EY...] [F...]
;
ScreenMode_ModeSpecifierToString ROUT
        Entry   "r1-r9",8
        CMP     r1,#256
        BLO     %FT90 ; No mode numbers, please!
        LDR     r0,[r1,#ModeSelector_Flags]
        AND     r0,r0,#ModeSelectorFlags_FormatMask
        CMP     r0,#ModeSelectorFlags_ValidFormat
        BNE     %FT90
        MOV     r4,#0 ; Current string length
        ADR     r0,spectostr_x
        LDR     r5,[r1,#ModeSelector_XRes]
        BL      spectostr_write
        ADR     r0,spectostr_y
        LDR     r5,[r1,#ModeSelector_YRes]
        BL      spectostr_write
        ; Process the variable list to get the other parameters
        LDR     r8,[r1,#ModeSelector_PixelDepth] ; Get Log2BPP
        CMP     r8,#3
        MOVEQ   r7,#ModeFlag_FullPalette       ; Default ModeFlags
        MOVNE   r7,#0                          ;
        MOV     r5,#1
        MOV     r6,r5,LSL r8
        MOV     r6,r5,LSL r6
        SUB     r6,r6,#1                       ; Default NColour
        ADD     r1, r1, #ModeSelector_ModeVars
        MOV     r9, #-1                        ; XEig
        MOV     r10, #-1                       ; YEig
10
        LDR     r0, [r1], #8
        CMP     r0, #VduExt_ModeFlags
        LDREQ   r7, [r1,#-4]
        CMP     r0, #VduExt_NColour
        LDREQ   r6, [r1,#-4]
        CMP     r0, #VduExt_XEigFactor
        LDREQ   r9, [r1,#-4]
        CMP     r0, #VduExt_YEigFactor
        LDREQ   r10, [r1,#-4]
        CMP     r0, #-1
        BNE     %BT10
        ; Give up now if this is a teletext mode, or non RGB
        TST     r7, #ModeFlag_Teletext
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TSTEQ   r7, #ModeFlag_DataFormatFamily_Mask
        BNE     %FT90
        ; Mask out the uninteresting bits
        LDR     r0,=ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_ChromaSubsampleMode :OR: ModeFlag_DataFormat_Mask
        AND     r7,r7,r0
        ; Determine the colour format
        ADR     r0,pixelformat_list
20
        LDMIA   r0!,{r5,r11,lr}
        CMP     r5,r6
        AND     r5,r7,#ModeFlag_FullPalette :OR: ModeFlag_64k :OR: ModeFlag_GreyscalePalette
        CMPEQ   r5,r11
        CMPEQ   r8,lr
        LDR     r5,[r0],#4
        BEQ     %FT30
        ADR     r5,pixelformat_end
        CMP     r0,r5
        BNE     %BT20
        B       %FT90
30
        MOV     r6,#0
        STMIA   sp,{r5,r6} ; Push string onto stack to get it null terminated
        MOV     r0,sp
        BL      spectostr_writestr
        ; Write L... if necessary
        ANDS    r7,r7,#ModeFlag_DataFormatSub_Mask
        BEQ     %FT40
        ASSERT  ModeFlag_DataFormatSub_Mask = &C:SHL:12
        SUB     r7,r7,#1:SHL:14
        ADR     r0,spectostr_l
        ADD     r0,r0,r7,LSR #14-3
        BL      spectostr_writestr
40
        ; Write eigen values
        CMP     r10,#-1
        ADR     r0,spectostr_ex
        MOV     r5,r9
        BLNE    spectostr_write
        CMP     r10,#-1
        ADR     r0,spectostr_ey
        MOV     r5,r10
        BLNE    spectostr_write
        ; Finally the framerate
        FRAMLDR r1
        LDR     r5,[r1,#ModeSelector_FrameRate]
        ADR     r0,spectostr_f
        CMP     r5,#-1
        BLNE    spectostr_write
        ; Finish
        CMP     r4,r3
        MOV     r0,#0
        STRLTB  r0,[r2,r4] ; Terminate string if space available
        ADD     r4,r4,#1
        SUBGE   r0,r0,r4
        FRAMSTR r0,,r3 ; Set to 0 or -(total length)
        MOV     r0,#ScreenModeReason_ModeSpecifierToString
        CLRV
        EXIT

spectostr_ey  DCB "EY",0
spectostr_f   DCB "F",0
        ALIGN

90
        PullEnv
        ADRL    r0, ErrorBlock_BadParameters
        B       ScreenMode_TranslateAndReturnError

spectostr_write ROUT
        ; Write string R0 followed by number R5
        ; R0 corrupted
        Push    "lr"
        BL      spectostr_writestr
        Push    "r1-r5"
        ADD     r0,sp,#4*4
        MOV     r2,#-1
        MOV     r3,#4
        MOV     r4,#ConvertToCardinal
        SWI     XOS_ConvertVariform
        MVN     r2,r2 ; Get length, excluding terminator
        LDMIB   sp,{r1,r3-r4} ; get stacked r2, r3-r4
        ADD     r1,r1,r4 ; Position to write to
        ADD     r4,r4,r2 ; Increment written length
        STR     r4,[sp,#12]
        CMP     r4,r3 ; Is there space?
        ADD     r0,sp,#4*4
        MOV     r3,#4
        MOV     r4,#ConvertToCardinal
        SWILE   XOS_ConvertVariform
        Pull    "r1-r5,pc"

spectostr_writestr ROUT
        ; Write string R0
        ; R0 corrupted
        Push    "lr"
        ; Do we need a leading space?
        CMP     r4,#0
        MOVNE   lr,#32
        BNE     %FT10
05
        LDRB    lr,[r0],#1
        CMP     lr,#0
        Pull    "pc",EQ
10
        CMP     r4,r3
        STRLTB  lr,[r2,r4]
        ADD     r4,r4,#1
        B       %BT05

spectostr_l
        DCB     "LTRGB",0,0,0
        DCB     "LABGR",0,0,0
        DCB     "LARGB",0,0,0


;**************************************************************************
;
;       ScreenMode_SelectModeByString
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (15)
;       r1 = pointer to mode string
;
; out:  r0 = error, or preserved
;       r10-r12 may be corrupted
;       All other registers preserved
;
ScreenMode_SelectModeByString ROUT
        Entry   "r1-r3", ModeSelector_MaxSize
        MOV     r0, #ScreenModeReason_ModeStringToSpecifier
        MOV     r2, sp
        MOV     r3, #ModeSelector_MaxSize
        SWI     XOS_ScreenMode
        MOVVC   r0, #ScreenModeReason_SelectMode
        MOVVC   r1, r2
        SWIVC   XOS_ScreenMode
        MOVVC   r0, #ScreenModeReason_SelectModeByString
        EXIT

@


4.6.2.15
log
@Fix errors building for pre-ARMv7
Detail:
  s/vdu/vduswis - Add an extra LTORG that's within range of LDR r14,=&1FFF instruction
Admin:
  Tested in Iyonix softload
  Fixes build errors for Tungsten ROM, should fix IOMD + BCM2835 too.


Version 5.35, 4.79.2.195. Tagged as 'Kernel-5_35-4_79_2_195'
@
text
@a973 2
        LTORG

@


4.6.2.16
log
@Fix plotting of RISC OS 5 type sprites and masks. Fix hang when attempting to report "alpha mask not supported" error. Fix reading/writing of alpha mask pixels.
Detail:
  s/vdu/vdugrafg - Fixed PutSprite and PlotMask to correctly deal with RISC OS 5 type sprite mode words. Fix infinite loops in PutSpriWideMaskErr casued by R14 getting trashed.
  s/vdu/vdugrafh - Fixed SpriteMaskAddr malfunctioning when trying to calculate addresses in alpha masks. Minor ReadPixelMask & WritePixelMask optimisations.
  s/vdu/vduswis - Fixed OS_ScreenMode 13 & 14 to count "G2" as a valid colour specifier.
Admin:
  Tested on BB-xM
  Should hopefully fix the random hangs reported on the forums when trying to use sprites with alpha masks


Version 5.35, 4.79.2.197. Tagged as 'Kernel-5_35-4_79_2_197'
@
text
@d2493 1
a2493 4
        ; 2, 4, 16, 256, 16M allowed
        CMP     R2,#2
        ADREQ   R0,pixelformat_2grey
        BEQ     strtospec_setpixelformat
a2597 2
pixelformat_2grey   DCD 1,ModeFlag_GreyscalePalette,0
                    DCB "G2",0,0
@


4.6.2.17
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@a78 4
        BCC     %FT20
        SUB     R11, R11, #&40          ; base for GraphicsV variables
        CMP     R11, #(SWIRVVTabGraphicsVEnd-SWIRVVTabEnd)
        ADRCCL  R9, SWIRVVTabEnd
a211 3
        RVVT    CurrentGraphicsVDriver
SWIRVVTabGraphicsVEnd        

d763 1
a763 1
        
d865 1
a865 1
; call GraphicsV vetting routine to possibly disallow mode
d867 1
a867 1
        Push "r0-r4, r12"
a869 2

      [ {FALSE} ; There are so many pixel formats now that it's better to let the driver do one check itself rather than doing one here and then one in the driver
d874 3
a876 5

        Push  "r0-r2"
        LDR   r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV   r4, r4, LSL #24
        ORR   r4, r4, #GraphicsV_DisplayFeatures
d880 5
a884 2
        Pull  "r0-r2"

d887 4
a890 6
      ]

        ;now any vet the driver might want to do
        LDR   r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV   r4, r4, LSL #24
        ORR   r4, r4, #GraphicsV_VetMode
d894 5
d901 2
a902 2
        Pull "r0-r4,r12"
        BNE   %FT05         ; driver says "Oi, Kernel, No!"
d974 2
a997 2
        LTORG

d1024 1
d1026 2
a1027 4
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV                   ; see if h/w supports this BPP
d1031 4
d1039 1
d1041 3
a2019 6
        MACRO
        SMEntry2 $name
        ASSERT  . - ScreenModeSub_Table2 = (ScreenModeReason_$name - ScreenModeReason_RegisterDriver) * 4
        B       ScreenMode_$name
        MEND

d2023 1
a2023 1
        B       %FT10
a2041 12
10
        SUB     r10, r0, #ScreenModeReason_RegisterDriver
        CMP     r10, #ScreenModeReason_Limit2-ScreenModeReason_RegisterDriver
        ADDCC   pc, pc, r10, LSL #2
        B       ScreenMode_Unknown
ScreenModeSub_Table2
        SMEntry2 RegisterDriver
        SMEntry2 StartDriver
        SMEntry2 StopDriver
        SMEntry2 DeregisterDriver
        SMEntry2 EnumerateDrivers        

d2048 1
a2062 2
        MakeErrorBlock BadGDriver
        MakeErrorBlock TooManyGDrivers
a2207 60

;**************************************************************************
;
;       ScreenMode_SelectDevice
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (11)
;       r1 = new device/driver number, or -1 to read current
;
; out:  r1 = previous (or current, if reading) driver number
;       r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_SelectDevice ROUT
        Entry   "r0,r2-r5"
        VDWS    WsPtr
        LDR     r5, [WsPtr, #CurrentGraphicsVDriver]
        CMP     r1, #-1
        MOVEQ   r1, r5
        CMP     r1, r5
        EXIT    EQ
        ; Validate this selection
        CMP     r1, #GraphicsVInvalid
        BEQ     %FT01
        CMP     r1, #MaxGraphicsVDrivers
        BHS     %FT20
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        LDR     r11, [r10, r1, LSL #2]
        CMP     r11, #0
        LDRNE   r0, [r11, #GVDriver_StateFlags]
        TSTNE   r0, #GVDriverState_Started
        BEQ     %FT20
01
        CMP     r5, #GraphicsVInvalid
        BEQ     %FT10
        ! 0, "GVTODO - API to disable a driver"
10
        CMP     r1, #GraphicsVInvalid
        STR     r1, [WsPtr, #CurrentGraphicsVDriver]
        ; Call InitialiseMode to select a mode to use for this new driver
        BLNE    InitialiseMode
        MOV     r1, r5
        EXIT    VC
        ; Something went wrong trying to activate the new driver
        ; Try and restore the old one
        STR     r0, [sp] ; Return the error to the caller
        STR     r1, [WsPtr, #CurrentGraphicsVDriver]
        CMP     r1, #GraphicsVInvalid
        BLNE    InitialiseMode
        ; TODO - Try harder if this 2nd call fails (e.g. try all drivers in turn)
        SETV
        EXIT
20
        PullEnv
        ADR     r0, ErrorBlock_BadGDriver
        BEQ     ScreenMode_TranslateAndReturnError


a2458 3
        ASSERT  GVPixelFormat_NColour = 0
        ASSERT  GVPixelFormat_ModeFlags = 4
        ASSERT  GVPixelFormat_Log2BPP = 8
d2581 1
a2581 4
        ASSERT  GVPixelFormat_NColour = 0
        ASSERT  GVPixelFormat_ModeFlags = 4
        ASSERT  GVPixelFormat_Log2BPP = 8
        ASSERT  GVPixelFormat_Size = 12
a2819 235
;**************************************************************************
;
;       ScreenMode_RegisterDriver
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (64)
;       r1 = flags (reserved, sbz)
;       r2 = driver name string (static, null-terminated)
;
; out:  r0 = driver number
;       r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_RegisterDriver ROUT
        TEQ     r1, #0
        ADRNEL  r0, ErrorBlock_BadParameters
        BNE     ScreenMode_TranslateAndReturnError
        Entry   "r1-r4"
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        MOV     r4, #0
05
        LDR     r11, [r10], #4
        CMP     r11, #0
        BEQ     %FT10
        ADD     r4, r4, #1
        CMP     r4, #MaxGraphicsVDrivers
        BNE     %BT05
        ADRL    r0, ErrorBlock_TooManyGDrivers
        PullEnv
        B       ScreenMode_TranslateAndReturnError
10
        MOV     r3, #GVDriver_Size
        BL      ClaimSysHeapNode
        EXIT    VS
        LDMIA   sp, {r1,r3}
        ASSERT  GVDriver_RegisterFlags = 0
        ASSERT  GVDriver_Name = 4
        ASSERT  GVDriver_StateFlags = 8
        MOV     r11, #0
        STMIA   r2, {r1,r3,r11}
        STR     r2, [r10, #-4]
        MOV     r0, r4
        EXIT

;**************************************************************************
;
;       ScreenMode_StartDriver
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (65)
;       r1 = driver number
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_StartDriver ROUT
        Entry   "r0-r1"
        VDWS    WsPtr
        ; Validate driver number
        CMP     r1, #MaxGraphicsVDrivers
        BHS     %FT10
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        LDR     r11, [r10, r1, LSL #2]
        CMP     r11, #0
        LDRNE   r0, [r11, #GVDriver_StateFlags]
        EORNE   r0, r0, #GVDriverState_Started
        TSTNE   r0, #GVDriverState_Started
        BEQ     %FT10
        ; Mark as started
        STR     r0, [r11, #GVDriver_StateFlags]
        ! 0, "GVTODO - Issue service call" ; Service_DisplayStatus doesn't make much sense here, since we aren't using ROL's format of display descriptor
        ; If we don't have a driver yet, use this one
        LDR     r0, [WsPtr, #CurrentGraphicsVDriver]
        CMP     r0, #GraphicsVInvalid
        MOVEQ   r0, #ScreenModeReason_SelectDevice
        SWIEQ   XOS_ScreenMode
        ; Swallow any error - just because the driver can't be used as the default driver it doesn't mean that it failed to start
        CLRV
        EXIT
10
        PullEnv
        ADRL    r0, ErrorBlock_BadGDriver
        B       ScreenMode_TranslateAndReturnError        


;**************************************************************************
;
;       ScreenMode_StopDriver
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (66)
;       r1 = driver number
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_StopDriver ROUT
        Entry   "r0-r1"
        VDWS    WsPtr
        ; Validate driver number
        CMP     r1, #MaxGraphicsVDrivers
        BHS     %FT10
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        LDR     r11, [r10, r1, LSL #2]
        CMP     r11, #0
        LDRNE   r0, [r11, #GVDriver_StateFlags]
        TSTNE   r0, #GVDriverState_Started
        BEQ     %FT10
        ; Deactivate driver if it's currently in use
        LDR     r0, [WsPtr, #CurrentGraphicsVDriver]
        CMP     r0, r1
        MOVEQ   r0, #ScreenModeReason_SelectDevice
        MOVEQ   r1, #GraphicsVInvalid
        SWIEQ   XOS_ScreenMode
        ; Give up if the driver failed to stop (shouldn't really happen, as it'll be the driver making the call to StopDriver)
        STRVS   r0, [sp]
        EXIT    VS
        ! 0, "GVTODO - Issue service call" ; Service_DisplayStatus doesn't make much sense here, since we aren't using ROL's format of display descriptor
        ; Mark as stopped
        LDR     r0, [r11, #GVDriver_StateFlags]
        BIC     r0, r0, #GVDriverState_Started
        STR     r0, [r11, #GVDriver_StateFlags]
        EXIT
10
        PullEnv
        ADRL    r0, ErrorBlock_BadGDriver
        B       ScreenMode_TranslateAndReturnError        
        

;**************************************************************************
;
;       ScreenMode_DeregisterDriver
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (67)
;       r1 = driver number
;
; out:  r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_DeregisterDriver ROUT
        Entry   "r0-r2"
        ; Validate driver number
        CMP     r1, #MaxGraphicsVDrivers
        BHS     %FT10
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        LDR     r2, [r10, r1, LSL #2]!
        CMP     r2, #0
        LDRNE   r1, [r2, #GVDriver_StateFlags]
        EORNE   r1, r1, #GVDriverState_Started
        TSTNE   r1, #GVDriverState_Started
        BEQ     %FT10
        ; Mark as free
        MOV     r1, #0
        STR     r1, [r10]
        ; Free the heap block
        BL      FreeSysHeapNode
        CLRV    ; Ignore heap errors, the driver is still freed
        EXIT
10
        PullEnv
        ADRL    r0, ErrorBlock_BadGDriver
        B       ScreenMode_TranslateAndReturnError        


;**************************************************************************
;
;       ScreenMode_EnumerateDrivers
;
;       Internal routine called by ScreenModeSWI
;
; in:   r0 = reason code (68)
;       r1 = driver number to return details of
;            or GraphicsVInvalid to return id of first driver
;       r2 = flags (reserved, sbz)
;
; out:  r1 = next driver number
;            or GraphicsVInvalid if reached end of list
;       r2 = driver flags on registration
;       r3 = driver name string
;       r4 = driver state
;            0 = unallocated/invalid driver (r2, r3 invalid)
;            1 = allocated
;            2 = started
;       r10-r12 may be corrupted
;       All other registers preserved
;

ScreenMode_EnumerateDrivers ROUT
        ; Validate flags
        TEQ     r2, #0
        ADRNEL  r0, ErrorBlock_BadParameters
        BNE     ScreenMode_TranslateAndReturnError
        Entry   "r5-r6"
        ; Return information on requested driver
        LDR     r10, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
        CMP     r1, #MaxGraphicsVDrivers
        LDRLO   r11, [r10, r1, LSL #2]
        MOVHS   r11, #0
        CMP     r11, #0
        ASSERT  GVDriver_RegisterFlags = 0
        ASSERT  GVDriver_Name = 4
        ASSERT  GVDriver_StateFlags = 8
        LDMNEIA r11, {r2-r4}
        ASSERT  GVDriverState_Started = 1
        ANDNE   r4, r4, #1
        ADDNE   r4, r4, #1
        MOVEQ   r2, #0
        MOVEQ   r3, #0
        MOVEQ   r4, #0
        ; Work out next driver number
        CMP     r1, #GraphicsVInvalid
        MOVEQ   r1, #0
        BEQ     %FT20
10
        CMP     r1, #MaxGraphicsVDrivers-1
        MOVHS   r1, #GraphicsVInvalid
        BHS     %FT90
        ADD     r1, r1, #1
20
        LDR     r11, [r10, r1, LSL #2]
        CMP     r11, #0
        BEQ     %BT10
90
        EXIT        
        

@


4.6.2.18
log
@Miscellaneous fixes
Detail:
  s/MemInfo - Fix OS_Memory 0 physical-to-logical conversion returning bad addresses for most cases due to R5 being modified by physical_to_ppn (bug introduced in revision 4.4.2.20)
  s/vdu/vdudriver - Fix some VDU driver variables not being initialised correctly when switching GraphicsV driver
  s/vdu/vdugrafv - Fix handling of VSync events from GraphicsV drivers other than driver zero
  s/vdu/vduswis - Fix abort when OS_ScreenMode 11 is passed a bad driver number
Admin:
  Tested on Raspberry Pi
  There still seems to be a bug lurking somewhere when switching to a GraphicsV driver that uses DA2; the system will crash horribly unless DA2 is already a suitable size for the initial mode change


Version 5.35, 4.79.2.206. Tagged as 'Kernel-5_35-4_79_2_206'
@
text
@d2282 1
a2282 1
        B       ScreenMode_TranslateAndReturnError
@


4.6.2.19
log
@ModeFlag_GreyscalePalette handling improvements. Issue service calls on certain GraphicsV events. Sprite tweaks and fixes.
Detail:
  hdr/VduExt - Add reason codes used by Service_DisplayChanged & Service_DisplayStatus
  s/vdu/vdugrafg - Remove dependency on SpriteReason_BadReasonCode; just use the size of our lookup table instead. Alter SpriteOp lookup table so that unimplemented ops return an error instead of doing nothing. Fix PutSprite incorrectly using the slow GCOL action plotter if a request was made to plot a sprite using its mask but the sprite has none.
  s/vdu/vdugrafl - Update screen redirection handling to set ModeFlag_GreyscalePalette if switching output to a sprite with a greyscale palette or a RISC OS Select alpha mask. Restore the flag to its correct value when restoring screen output.
  s/vdu/vdupalxx - Update ModeFlag_GreyscalePalette in realtime as the palette is changed
  s/vdu/vduswis - Issue Service_DisplayChanged during OS_ScreenMode 11. Issue Service_DisplayStatus during OS_ScreenMode 65 & 66.
Admin:
  Tested on Iyonix, BB-xM


Version 5.35, 4.79.2.210. Tagged as 'Kernel-5_35-4_79_2_210'
@
text
@d2264 1
a2265 6
        ; Issue service call to indicate change is coming
        MOV     r0, #DisplayChanged_Changing
        MOV     r2, r1
        MOV     r1, #Service_DisplayChanged
        MOV     r3, #0
        IssueService
a2266 1
        CMP     r2, #GraphicsVInvalid
a2267 4
        BVS     %FT15
        ; Success!
        MOV     r0, #DisplayChanged_Changed
        IssueService
d2269 1
a2269 2
        EXIT
15
d2273 2
a2274 5
        STR     r5, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r0, #DisplayChanged_Changing
        MOV     r2, r5
        IssueService
        CMP     r5, #GraphicsVInvalid
a2276 3
        MOV     r0, #DisplayChanged_Changed
        IssueService
        MOV     r1, r5
d2963 1
a2963 1
        Entry   "r0-r3"
d2977 1
a2977 8
        ; Issue a service call to indicate new driver is ready to go
        ; For simplicity ROL's Service_DisplayStatus is used. However the
        ; display descriptor is empty as we don't (currently) use them.
        MOV     r0, #DisplayStatus_Registered
        MOV     r2, r1
        MOV     r1, #Service_DisplayStatus
        ADR     r3, dummy_display_descriptor
        IssueService
a2981 1
        MOVEQ   r1, r2
a2990 3
dummy_display_descriptor
        DCD     0

d3006 1
a3006 1
        Entry   "r0-r3"
d3026 1
a3026 6
        ; Issue Service_DisplayStatus to indicate driver stopping
        MOV     r0, #DisplayStatus_Deregistered
        MOV     r2, r1
        MOV     r1, #Service_DisplayStatus
        MOV     r3, #0
        IssueService
@


4.6.2.20
log
@Improve Service_DisplayStatus, Service_DisplayChanged functionality
Detail:
  hdr/VduExt - Define new Service_DisplayChanged reason code for us to issue before anything actually happens. Define new Service_DisplayStatus reason codes for drivers to issue when they change their configuration/capabilities in some way.
  s/Utility - Listen out for Service_DisplayStatus
  s/vdu/vdudriver - When DisplayStatus_Changing/DisplayStatus_Changed is received for the current driver, translate into the appropriate DisplayChanged reason codes so that software which only cares about the current driver doesn't have two sets of service calls to listen out for
  s/vdu/vduswis - When switching driver in OS_ScreenMode 11, issue the new Service_DisplayChanged PreChanging reason code before we update the current GraphicsV driver VDU variable
Admin:
  Tested in Iyonix ROM softload


Version 5.35, 4.79.2.216. Tagged as 'Kernel-5_35-4_79_2_216'
@
text
@d2056 1
a2056 1
        SMEntry2 EnumerateDrivers
d2264 3
a2266 3
        ; Issue pre-changing service call because we're about to change the VDU
        ; vars
        MOV     r0, #DisplayChanged_PreChanging
d2269 1
a2269 6
        MOV     r3, #DisplayChangedSub_ModeChanged
        IssueService
        ; Update current driver VDU var
        STR     r2, [WsPtr, #CurrentGraphicsVDriver]
        ; Issue service call to indicate change is coming
        MOV     r0, #DisplayChanged_Changing
@


4.6.2.21
log
@Change handling of GraphicsV_StartupMode. Fix OS_CheckModeValid for variable framestore case.
Detail:
  s/PMF/osinit, s/vdu/vdudriver - Move GraphicsV_StartupMode call from InitialiseMode to TranslateMonitorLeadType. This means (a) it'll only be used if the CMOS mode is set to 'auto' and (b) the returned mode can more easily be read by other modules via OS_ReadSysInfo 1.
  s/vdu/vduswis - Make OS_CheckModeValid act as if we have practically unlimited screen memory if using a GraphcisV driver with variable external framestore. In this case it's the driver should have already OK'd the memory requirements from within the VetMode call issued by FindOKMode - although the check won't be fully valid if we're checking for a shadow mode as the driver currently isn't told how many screen banks are required.
Admin:
  Tested on Raspberry Pi
  OS_CheckModeValid fix ensures valid modes which require large amounts of VRAM are reported correctly when we're currently in a low-memory mode


Version 5.35, 4.79.2.220. Tagged as 'Kernel-5_35-4_79_2_220'
@
text
@d813 1
a813 8
        LDR     r9, [WsPtr, #GraphicsVFeatures]
        TST     r9, #GVDisplayFeature_VariableFramestore
        MOVNE   r9, #-1                 ; treat as unlimited memory if variable
                                        ; framestore (driver should have
                                        ; rejected the VetMode call from
                                        ; FindOKMode if it doesn't have enough)

        LDREQ   r9, [WsPtr, #TotalScreenSize] ; maximum allowed amount
@


4.6.2.22
log
@Fix a couple of mode specifier/string conversion issues
Detail:
  s/vdu/vduswis - Fix conversion of mode specifier to mode string so that the X eigen value is only reported in the mode string if it was included in the mode specifier; previously was erroneously basing the decision on whether the Y eigen was specified, resulting in e.g. "EX4294967295" if only the Y eigen was included
  - Fix a stack imbalance causing the conversion of mode string to mode specifier crashing (typically with branch through zero) if an invalid eigen value is specified in the string (e.g. EX-1 as above)
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.302. Tagged as 'Kernel-5_35-4_79_2_302'
@
text
@a2451 1
        ADDVS   sp,sp,#4
d2826 1
a2826 1
        CMP     r9,#-1
@


4.6.2.23
log
@Avoid unnecesssary remainder calculations
Detail:
  s/HeapSort, s/vdu/vdugrafc, s/vdu/vduswis - Avoid unnecessary remainder calculations in DivRem macro
  s/PMF/i2cutils, s/PMF/osword - Make use of DivRem's ability to accept a constant as the divisor
Admin:
  Tested on Cortex-A15


Version 5.35, 4.79.2.318. Tagged as 'Kernel-5_35-4_79_2_318'
@
text
@d122 1
a122 1
        DivRem  R0, R7, R4, R2, norem   ; R0 = (width-(1 or sizex))DIV spacex
d125 1
a125 1
        DivRem  R1, R7, R5, R3, norem   ; R1 = (height-(1 or sizey))DIV spacey
@


4.6.2.9.2.1
log
@  Merge of Raspberry Pi support code against latest kernel
Detail:
  This is a new branch from the current tip of the HAL branch, incorporating
  the changes received from Adrian Lees. The same caveats apply - this is a
  work in progress and will not work on any other platform at present.
Admin:
  Builds, but not tested.

Version 5.35, 4.79.2.147.2.1. Tagged as 'Kernel-5_35-4_79_2_147_2_1'
@
text
@a700 1
  DebugTX "CheckModeValid"
a774 5
        ! 0, "FIXME: temporary code"
;!!!
  ADDS R1,R0,#0
  MOV pc,lr

@


4.6.2.9.2.2
log
@Preperation for working Raspberry Pi video driver
Detail:
  hdr/HALEntries - Add new HAL_Video_StartupMode HAL entry to allow the HAL to specify a startup mode
  s/HAL, s/Kernel - Tweaked debug routines
  s/vdu/vdudriver - Make use of HAL_Video_StartupMode in InitialiseMode to decide what initial mode should be. Clean up some hacks & debug. Improve handling of external framestores; if bit 5 of GraphicsV_DisplayFeatures r0 is set, the kernel will now allow the display driver to grow/shrink/move its framestore in response to mode changes.
  s/vdu/vdugrafv - Adjust default GV_FramestoreAddress implementation to only claim vector if HAL returns a framestore
  s/vdu/vduswis - Re-enable FindOKMode
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.18. Tagged as 'Kernel-5_35-4_79_2_147_2_18'
@
text
@d776 5
@


4.6.2.9.2.3
log
@Clean up remaining kernel hacks
Detail:
  Docs/RPiNotes - Deleted, contents no longer relevant
  s/HAL, s/Kernel, s/vdu/vduswis, s/pmf/key - Cleaned up debug code
  s/NewIRQs - No need to piggy back on timer 0 IRQ to generate a fake VSync; PushModeInfo already claims/releases TickerV as appropriate if video driver doesn't provide a VSync IRQ.
  s/NewReset - Re-enable LookForHALRTC call, the stack imbalance bug was fixed before the Pi changes were merged in
  s/vdu/vducursoft - Streamline PostWrchCursor a bit by only preserving R14 around RestorePointer if the software pointer is in use
  s/vdu/vdudriver - Amend ModeChangeSub improvements to ensure old external framestore handling logic is used if driver doesn't support framestore growth/realloc
Admin:
  Tested on Raspberry Pi with high processor vectors
  Kernel now looks to be in a good state for merging back into HAL branch
  Note - Software mouse pointer support in vducursoft only checks HALVideoFeatures, so doesn't take into account the capabilities of any GraphicsV driver that may be in use.


Version 5.35, 4.79.2.147.2.20. Tagged as 'Kernel-5_35-4_79_2_147_2_20'
@
text
@d701 1
@


4.6.2.9.2.4
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d817 2
a818 2
        AddressHAL
        CallHAL HAL_VideoVetMode
d2118 41
@


4.6.2.7.2.1
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  s.PMF.i2cutils line 454: this LDR of byte values was harmless (bits 8
    upwards are discarded later) but slower than an LDRB on ARMv6 or later.
  s.PMF.i2cutils line 556: should have loaded RTCFitted using LDRB. Looks
    like effect would have been to reduce utilisation of CMOS cache.
  s.vdu.vduswis line 1500: mistakenly accessing ExternalFramestore using LDR.
    I don't think the intention was to prevent the screen DA being resized
    while screen memory was claimed, but that was the effect.
  s.vdu.vduwrch line 3106: this LDR of a 1-byte variable was harmless (only
    used for testing bit 4) but slower than an LDRB on ARMv6 or later.
  CPU version is no longer specified in the makefile - it's better to inherit
  it from the build environment now that we actually set it appropriately.
Admin:
  Built and briefly tested.

Version 5.35, 4.79.2.98.2.9. Tagged as 'Kernel-5_35-4_79_2_98_2_9'
@
text
@d1497 1
a1497 1
        LDRB    R1, [WsPtr, #ExternalFramestore]
@


4.6.2.7.2.2
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d19 1
a19 1
        LDR     R11, =ZeroPage
d1503 1
a1503 2
        LDR     R4, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
@


4.6.2.7.2.2.2.1
log
@  Support for Raspberry Pi / BCM2835
Detail:
  Falls into two main areas: graphics support and ARM11 core support.
  A work in progress - in many cases the code changes need to be replaced
  with an alternative mechanism which will permit the kernel to still function
  on other platforms. Adrian marked these with "!!!" comments - I have added
  ! directives as well so that they don't get forgotten about.
Admin:
  Changes received from Adrian Lees. This revision represents the code largely
  as delivered, and is placed on its own branch (forked off from the version
  from which he worked). It is intended for reference. It doesn't build against
  current headers - this is likely to require a merge with the other changes
  to the kernel since that time.

Version 5.35, 4.79.2.98.2.52.2.1. Tagged as 'Kernel-5_35-4_79_2_98_2_52_2_1'
@
text
@a700 1
  DebugTX "CheckModeValid"
a774 5
        ! 0, "FIXME: temporary code"
;!!!
  ADDS R1,R0,#0
  MOV pc,lr

@


4.5
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d1306 7
d1315 1
@


4.4
log
@* Meaning of FEIOSpeedHalf was accidentally inverted.
* Wasn't allowing writes to most of EEPROM.
* Old prototype OS_SetTime SWI code removed.
* MPEGPoduleNTSCNotPALMask option support removed to simplify things a bit.
* Now can cope with a system with a PAL/NTSC link, but no monitor detect line.
* Default PAL & NTSC modes now always 12 & 46 respectively.
* Kernel now knows about monitor type 8 (NTSC) - modes 44-46 (640x200) are
  available.
* STB/NC CMOS test removed from POST pending further investigation.

Version 4.90. Tagged as 'Kernel-4_90'
@
text
@a22 1
        [ AssemblingArthur
a29 19
        |
         [ Module
         LDR     $tmp1, [R11, #VecPtrTab+$vector*4]  ; load vector node
         LDR     R12, [$tmp1]                    ; get first address on chain
         EOR     $tmp2, R12, #&01000000
         CMP     $tmp2, #&00020000
         BCS     $label
         |
         LDR     $tmp1, [R11, #VecPtrTab+$vector*4]  ; load vector node
         LDR     R12, [$tmp1]                    ; get first address on chain
         [ $vector=SpriteV
         EOR     $tmp2, R12, #&01600000
         |
         RSB     $tmp2, R12, #&01E00000
         ]
         CMP     $tmp2, #&10000
         BCS     $label
         ]
        ]
a42 28
        [ :LNOT: AssemblingArthur
SetUpSWIs ROUT
        LDR     R1, =SvcTable
        ADR     R2, SWITable
10
        LDMIA   R2!, {R3, R4}           ; R3 = SWI number; R4 = address offset
        CMP     R3, #-1                 ; end of table ?
        ADDNE   R4, R4, R2              ; no, then R4 = address
        STRNE   R4, [R1, R3, LSL #2]
        BNE     %BT10
        MOV     PC, R14

SWITable
        SWIEntry        ReadVduVariables
        SWIEntry        ReadPalette
        SWIEntry        ReadModeVariable
        SWIEntry        RemoveCursors
        SWIEntry        RestoreCursors
        SWIEntry        CheckModeValid
        SWIEntry        ClaimScreenMemory
        SWIEntry        Plot
        SWIEntry        WriteN
        SWIEntry        Write0
        SWIEntry        WriteS
        SWIEntry        SetECFOrigin
        SWIEntry        ChangedBox
        &       -1
        ]
d970 3
a972 3
        MOV     R11, PC                 ; disable IRQs, so can be called from
        TST     R11, #I_bit             ; an IRQ routine
        TEQEQP  R11, #I_bit
d1037 4
d1055 1
d1137 1
a1137 1
        TEQP    PC, #SVC_mode               ; enable interrupts
d1206 1
a1206 1
        TEQP    PC, #SVC_mode                   ; enable interrupts
d1267 1
a1267 1
        TEQP    PC, #SVC_mode                   ; enable interrupts
d1269 2
a1270 1
        BIC     R10, R14, #ARM_CC_Mask          ; R10 -> string
a1282 1
        [ AssemblingArthur
a1283 3
        |
        LDRNE   PC, =(MOSDriver + MOSPMFWrch)
        ]
a1286 1
        [ AssemblingArthur
a1287 3
        |
        LDRNE   PC, =(MOSDriver + MOSPMFWrch)
        ]
d1308 1
a1308 2
        AND     R14, R14, #ARM_CC_Mask  ; R14 = user PSR
        ORR     R14, R14, R10
d1385 1
a1385 1
        Pull    "R0-R8,R12,PC",,^
d1479 1
a1479 1
        TEQP    PC, #SVC_mode + I_bit   ; disable IRQs to update CursorFlags
d1911 1
a1911 1
        TEQP    pc, #SVC_mode           ; enable IRQs
@


4.3
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d882 2
d926 4
d939 2
@


4.2
log
@Kernel merged
@
text
@d256 3
d2039 39
@


4.2.2.1
log
@Added following enhancements:

 - Chocolate screen mapping (section mapped and cached), StrongARM only
   Phoebe h/w (IOMD 2) will have register to assist this, but code currently
   relies on data abort mechanism to keep screen up to date wrt write-back
   data cache.

 - Chocolate AMBControl task switching (lazy page mapping), StrongARM only
   Improves task swapping speed. There appears to be a StrongAEM silicon
   bug rev 2 and 3) which means that LDMIB rn, {regs includind rn} cannot
   be reliably restarted after a data abort. This stuffs Chocolate AMBControl
   (awaiting response from Digital).

Both enhancements need more work to complete for Phoebe. Chocolate AMBControl
may well have to be made dormant because of silicon bug.

Note that this kernel *will* cause problems with task switching on StrongARM,
unless Chocolate task switching is disabled via !Flavour application.
@
text
@a1904 6
  [ ChocolateScreen
        ASSERT  ScreenModeReason_ChocolateControl = 4
        ASSERT  ScreenModeReason_ChocolateUpdate = 5
        ASSERT  ScreenModeReason_ChocolateForceUpdate = 6
        ASSERT  ScreenModeReason_Limit = 7
  |
a1905 1
  ]
a1914 5
  [ ChocolateScreen
        B       ScreenMode_ChocolateControl
        B       ScreenMode_ChocolateUpdate
        B       ScreenMode_ChocolateForceUpdate
  ]
d2035 1
a2035 169
;**************************************************************************
;
  [ ChocolateScreen

; ScreenMode_ChocolateControl - control chocolate flavour screen (cached and
;                               section mapped when enabled - only allowed for
;                               StrongARM (vsync cleaner assumes StrongARM)
;   r0 = reason code (4)
;   r1 = cached screen control flags
;          bit  0     set to suspend cached screen for this mode
;          bit  1     set to suspend all screen cleaning (foreground and VSync)
;          bits 2..30 reserved for future expansion (must be 0)
;          bit  31    must be 0 when setting flags
;        or r1 = -1 to read current flags
;   r2 = sets VSync cache cleaner laziness (to be used when not suspended)
;        1 means VSync cleans on the 1st vsync after 'screen needs clean' is triggered and not reset by foreground
;        2 means VSync cleans on 2nd vsync
;        3 means VSync cleans on 3rd vsync
;        or r2 = -1 to read current vsync control value
;        other values reserved (undefined behaviour)
; exit: r1 = current value of cached screen control flags (either for r1=-1 on entry,
;            or value actually invoked given any restrictions for current platform)
;       r2 = current value for VSync cleaner control (similar considerations to r1 exit)
;
ScreenMode_ChocolateControl ROUT
        Push    "r3-r5,LR"
        MOV     LR,#0
        LDR     r4,[LR,#ARMA_Cleaner_status] ;r4 = ARMA_Cleaner status word throughout
        TST     r4,#ACS_SCdisable            ;set means permanent chocolate disable (not a StrongARM)
        BNE     %FT50
        CMP     r1,#0
        BLT     %FT20
        TST     r1,#1
        BEQ     %FT10
;deal with suspending cached screen
        ORR     r1,r1,#2                     ;all screen cleaning will be suspended, of necessity
        TST     r4,#ACS_Scacheflag
        BEQ     %FT20                        ;cached screen already suspended
        BL      Screen_makevanilla           ;uncaches screen, suspends vsync cleaner
        MOV     LR,#0
        LDR     r4,[LR,#ARMA_Cleaner_status] ;pick up new status after makevanilla
        B       %FT20
10
;deal with restoring cached screen
        TST     r4,#ACS_Scacheflag
        BNE     %FT12                        ;screen already cached
        BL      Screen_makechocolate         ;caches screen, restarts vsync cleaner
        MOV     LR,#0
        LDR     r4,[LR,#ARMA_Cleaner_status] ;pick up new status after makechocolate
12
;deal with suspending or resuming all screen cleaning
        MOV     r3,PC
        ORR     r4,r3,#I_bit
        TEQP    r4,#0                        ;disable IRQs to update ARMA_Cleaner_Status
        LDR     r4,[LR,#ARMA_Cleaner_status]
        TST     r1,#2
        ORRNE   r4,r4,#ACS_SCsuspend
        BICEQ   r4,r4,#ACS_SCsuspend
        STR     r4,[LR,#ARMA_Cleaner_status]
        ARMA_read_MMUdomain r5,EQ
        BICEQ   r5,r5,#&C
        ARMA_write_MMUdomain r5,EQ           ;mark domain 1 to fault if we are resuming screen cleaning
        TEQP    r3,#0                        ;restore IRQ status
20
;deal with VSync screen cleaner laziness setting
        CMP     r2,#0
        BLT     %FT50
        CMP     r2,#1
        MOVLO   r2,#1
        CMP     r2,#3
        MOVHI   r2,#3
        MOV     r3,PC
        ORR     r4,r3,#I_bit
        TEQP    r4,#0                        ;disable IRQs to update ARMA_Cleaner_Status
        LDR     r4,[LR,#ARMA_Cleaner_status]
        BIC     r4,r4,#ACS_VSClazy_MASK
        ORR     r4,r4,r2,LSL #ACS_VSClazy_SHIFT
        STR     r4,[LR,#ARMA_Cleaner_status]
        TEQP    r3,#0                        ;restore IRQ status
50
;read current status
        MOV     r1,#0
        TST     r4,#ACS_SCdisable
        ORRNE   r1,r1,#3
        TST     r4,#ACS_Scacheflag
        ORREQ   r1,r1,#1
        TST     r4,#ACS_SCsuspend
        ORRNE   r1,r1,#2
        AND     r2,r4,#ACS_VSClazy_MASK
        MOV     r2,r2,LSR #ACS_VSClazy_SHIFT
        Pull    "r3-r5,PC"

; ScreenMode_ChocolateUpdate
;
; r0 = 5 (reason code)
;
; ensure cache is up to date wrt the screen immediately, if necessary and not suspended
;
;
ScreenMode_ChocolateUpdate
        Push    "r1-r4,LR"
        MOV     r1,#0
        B       int_ScreenMode_ChocolateUpdate

; ScreenMode_ChocolateForceUpdate
;
; r0 = 6 (reason code)
;
; force cache to be up to date wrt the screen immediately, if necessary, regardless of SC suspend
;
;
ScreenMode_ChocolateForceUpdate
        Push    "r1-r4,LR"
        MOV     r1,#1
;
;internal entry: r1=1 to force update even if suspended, else r1=0
;
int_ScreenMode_ChocolateUpdate ROUT
        MOV     LR,#0
        MOV     r3,PC
        ORR     r4,r3,#I_bit
        TEQP    r4,#0                                   ;disable IRQs in case we update ARMA_Cleaner_status
        LDR     r4,[LR,#ARMA_Cleaner_status]
        TST     r4,#ACS_SCdisable                       ;only update if SC not disabled (may be forced when suspended)
        BNE     %FT50
        TST     r4,#ACS_Scacheflag                      ;do not update if screen currently uncached
        BEQ     %FT50
        TST     r4,#ACS_SCsuspend
        TSTNE   r1,#1
        BNE     %FT06                                   ;update if SC suspended but forced
        TST     r4,#ACS_SCsuspend
        BNE     %FT50                                   ;no update if SC suspended and not forced
        TST     r4,#ACS_VSCcountdown_MASK               ;also no update if SC not suspended but no VSC is pending
        BEQ     %FT50
06
        EOR     r4,r4,#ACS_SCflipflop                   ;next screen cleaner area
        ORR     r4,r4,#ACS_SCsemaphore
        STR     r4,[LR,#ARMA_Cleaner_status]            ;update status
        AND     r2,r4,#ACS_SCflipflop                   ;extract SC flipflop bit
        LDR     r1,=ARMA_ScreenCleaners_address
        ADD     r1,r1,r2,LSR #(ACS_SCflipflop_SHIFT-14) ;start address for clean (LSR -14 since 16k area size)
        ADD     r2,r1,#16*1024                          ;end address (exclusive, 16k cache size)
        TEQP    r3,#0                                   ;restore IRQs during clean
10
        LDR     r4,[r1],#32                             ;read next cleaner line into data cache (triggers 8-word line fill)
        LDR     r4,[r1],#32
        LDR     r4,[r1],#32
        LDR     r4,[r1],#32
        CMP     r1,r2
        BLO     %BT10                                   ;until done
;write buffer can be allowed to drain on its own (this is not a code- or remap- critical clean)
        MOV     r3,PC
        ORR     r4,r3,#I_bit
        TEQP    r4,#0                           ;disable IRQs to mess with ARMA_Cleaner status and MMUdomain
        ARMA_read_MMUdomain r4
        BIC     r4,r4,#&C
        ARMA_write_MMUdomain r4                 ;reset screen (domain 1) to fault
        LDR     r4,[LR,#ARMA_Cleaner_status]
        BIC     r4,r4,#ACS_SCsemaphore:OR:ACS_VSCcountdown_MASK
        STR     r4,[LR,#ARMA_Cleaner_status]
50
        TEQP    r3,#0                           ;restore IRQ status
        Pull    "r1-r4,PC"

 ] ;ChocolateScreen


 ] ;ModeSelectors

@


4.2.2.2
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d23 1
d31 19
d63 28
d260 58
d366 1
d429 22
d462 1
d496 5
d759 1
d763 3
d774 1
d777 1
d836 1
d840 3
d857 1
d860 1
d909 1
d911 1
d1183 1
d1185 3
d1192 1
d1194 3
d1253 1
d1255 3
d1261 1
d1263 3
d1314 1
d1316 3
d1322 1
d1324 3
d1360 1
d1490 1
d1883 1
d1933 1
d1937 1
d2214 1
@


4.2.2.3
log
@1) Fixes and tidy ups:
   - mapping of Cur/Sys/Sound area done more elegantly, and soft CAM info
     is now consistent with it
   - cached screen cleaning on VSync performed *after* VSync events
   - comments at top of ARM600 modernised
   - Pages_Unsafe/Safe code fixed to work properly on StrongARM with
     pages that are involved in interrupts (there is no fix for ARM8,
     since that is unlikely to be needed - an ASSERT checks use of ARM8
   - OS_DynamicArea code souped up, to be much more efficient for large
     numbers of dynamic areas (see comments near top of ChangeDyn)
   - cached screen is now suspended on h/w scroll (avoids possible cache
     incoherency)
2) API changes:
   - new OS_Memory reason code (10) allows Wimp to inform kernel of
     Wimp_ClaimFreeMemory, and can control VRAM rescue (see below)
   - new OS_ReadSysInfo reason code (6) allows reading of kernel values
     (reserved for Acorn use, eg. for SoftLoad, ROMPatch)
   - new OS_DynamicArea reason codes (6 and 7) allow for more efficient
     monitoring of dynamic areas by TaskManager (reserved for Acorn use)
3) Changes for Phoebe:
   - kernel runs a VRAM rescue process, which ensures that any VRAM not
     used for the screen is reclaimed if necessary and sinks to the bottom
     of the Free Pool. This is important for Phoebe, where VRAM is slower
     than SDRAM, but does no harm on other platforms.
   - logical copy of physical RAM is removed from memory map. This frees
     up 256M of address space that will later be used for PCI on Phoebe,
     but should do no harm on other platforms (this space is marked
     private in PRMs, so 3rd parties should not use it).
@
text
@a1892 3
; this routine is also used by HardScrollUp and HardScrollDown to suspend cached screen (avoids
; possible cache coherency issue with use of 2nd screen mapping)
;
@


4.2.2.3.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d1031 1
d1036 5
d1093 1
d1098 5
d1146 1
d1151 5
a1930 1
        TSTEQ   r4,#ACS_HardVIDMRD
d1933 1
a1933 1
        ARMA_write_MMUdomain r5,EQ           ;mark domain 1 to fault if we are resuming screen cleaning, and we need VIDMRD emulation
d2004 1
a2004 9
        TST     r4,#ACS_HardVIDMRD                      ;check for h/w VIDMRD presence
        BEQ     %FT04
        MOV     r2,#IOMD_Base
        LDR     r2,[r2,#IOMD2_VIDMRD]                   ;this also clears flag
        TST     r2,#1
        ORRNE   r4,r4,#ACS_SoftVIDMRD
        STRNE   r4,[LR,#ARMA_Cleaner_status]            ;we *must* stickily reflect transient h/w flag in SoftVIDMRD
04
        TST     r4,#ACS_VSCpending_MASK                 ;also no update if SC not suspended but no VSC is pending
a2006 1
        BIC     r4,r4,#ACS_VSCpending_MASK              ;force this clear since we're about to clean (appropriate) cache
d2013 1
a2013 3
        TST     r4,#ACS_MiniDataCache
        ADDEQ   r2,r1,#16*1024                          ;end address (exclusive, 16k cache size)
        ADDNE   r2,r1,#1024                             ;end address (exclusive, 1k mini cache size)
d2026 3
d2030 1
a2030 5
        TST     r4,#ACS_HardVIDMRD
        ARMA_read_MMUdomain r1, EQ
        BICEQ   r1,r1,#&C
        ARMA_write_MMUdomain r1, EQ             ;reset screen (domain 1) to fault for VIDMRD emulation, if necessary
        BIC     r4,r4,#ACS_SCsemaphore
d2036 1
a2036 1
  ] ;ChocolateScreen
@


4.2.2.4
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d1031 1
d1036 5
d1093 1
d1098 5
d1146 1
d1151 5
a1930 1
        TSTEQ   r4,#ACS_HardVIDMRD
d1933 1
a1933 1
        ARMA_write_MMUdomain r5,EQ           ;mark domain 1 to fault if we are resuming screen cleaning, and we need VIDMRD emulation
d2004 1
a2004 9
        TST     r4,#ACS_HardVIDMRD                      ;check for h/w VIDMRD presence
        BEQ     %FT04
        MOV     r2,#IOMD_Base
        LDR     r2,[r2,#IOMD2_VIDMRD]                   ;this also clears flag
        TST     r2,#1
        ORRNE   r4,r4,#ACS_SoftVIDMRD
        STRNE   r4,[LR,#ARMA_Cleaner_status]            ;we *must* stickily reflect transient h/w flag in SoftVIDMRD
04
        TST     r4,#ACS_VSCpending_MASK                 ;also no update if SC not suspended but no VSC is pending
a2006 1
        BIC     r4,r4,#ACS_VSCpending_MASK              ;force this clear since we're about to clean (appropriate) cache
d2013 1
a2013 3
        TST     r4,#ACS_MiniDataCache
        ADDEQ   r2,r1,#16*1024                          ;end address (exclusive, 16k cache size)
        ADDNE   r2,r1,#1024                             ;end address (exclusive, 1k mini cache size)
d2026 3
d2030 1
a2030 5
        TST     r4,#ACS_HardVIDMRD
        ARMA_read_MMUdomain r1, EQ
        BICEQ   r1,r1,#&C
        ARMA_write_MMUdomain r1, EQ             ;reset screen (domain 1) to fault for VIDMRD emulation, if necessary
        BIC     r4,r4,#ACS_SCsemaphore
d2036 1
a2036 1
  ] ;ChocolateScreen
@


4.1
log
@Initial revision
@
text
@d501 1
a501 1
                     
d633 3
a635 3
;          
; Return parameters as follows:                                      
                                   
d653 1
a653 1
NewSpriteModeWord ROUT 
d663 1
a663 1
                             
d683 1
a683 1
              
d698 1
a698 1
        LDR     r2, [r2, r14, LSL #2] 
d708 1
a708 1
                           
d717 2
a718 2
        AND     r0, r0, r14    
        
d727 1
a727 1
            
d1180 10
d1197 2
d1250 10
d1267 2
d1311 10
d1328 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Added SWI OS_VIDCDivider, and vdu variable PixelRate for better video mode
support.  Fixed to build for Risc PC.
@
text
@a255 3
 [ STB
        RVVT    PixelRate
 ]
a2000 39

; Should not cause any problems on any machine.  STB flag just to be safe though.
 [ STB :LAND: {TRUE}
; *****************************************************************************
;
;       VIDCDividerSWI - Entry point for SWI OS_VIDCDivider
;
; in:   r0 = Value for divider - 1
;
; out:  r0 = Preserved or error if V set
;

VIDCDividerSWI	ENTRY "r0-r1,WsPtr"
	CMP	r0, #8					; Check the value is in range.
	BCC	%FT10					; Continue if so.
	PullEnv						; Else return an error.
	ADR	r0, ErrorBlock_BadVIDCDivider		; Get address of error.
 [ International
        BL      TranslateError				; Translate the error.
 ]
	ORR	lr, lr, #V_bit				; Return with V bit set.
	ExitSWIHandler

10
	VDWS	WsPtr					; Get the VDU work space.
	LDR	r1, [WsPtr, #VIDCControlCopy]		; Get the old control register value.
	BIC	r1, r1, #7:SHL:CR_PixelDivShift		; Mask out the old divider.
	ORR	r1, r1, r0, LSL #CR_PixelDivShift	; ORR in the new...
	STR	r1, [WsPtr, #VIDCControlCopy]		; Write back to work space.
	MOV	r0, #VIDC
	STR	r1, [r0, #0]				; Write to VIDC also.
	PullEnv						; Done.
	ExitSWIHandler
 ]

ErrorBlock_BadVIDCDivider
	&	0
	=	"BadVIDCDiv:Bad VIDC divider value.", 0

@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d501 1
a501 1

d633 3
a635 3
;
; Return parameters as follows:

d653 1
a653 1
NewSpriteModeWord ROUT
d663 1
a663 1

d683 1
a683 1

d698 1
a698 1
        LDR     r2, [r2, r14, LSL #2]
d708 1
a708 1

d717 2
a718 2
        AND     r0, r0, r14

d727 1
a727 1

a1179 10
  [ StrongARM
        LDRB    R0, [R10], #1
        Push    PC                      ; need to get to %FT20 - push PC+12 (old ARM) or PC+8 (StrongARM)
        [ AssemblingArthur
        B       PMFWrchDirect
        |
        LDR     PC, =(MOSDriver + MOSPMFWrch)
        ]
        MOV     R0,R0                   ; NOP for PC+8 case
  |
a1186 2
  ]

a1237 10
  [ StrongARM
        BEQ     %FT80                   ; no more characters
        Push    PC, NE                  ; need to get to %FT20 - push PC+12 (old ARM) or PC+8 (StrongARM)
        [ AssemblingArthur
        BNE     PMFWrchDirect
        |
        LDRNE   PC, =(MOSDriver + MOSPMFWrch)
        ]
        MOV     R0,R0                   ;NOP for PC+8
  |
a1244 2
  ]

a1286 10
  [ StrongARM
        BEQ     %FT80                   ; no more characters
        Push    PC, NE                  ; need to get to %FT20 - push PC+12 (old ARM) or PC+8 (StrongARM)
        [ AssemblingArthur
        BNE     PMFWrchDirect
        |
        LDRNE   PC, =(MOSDriver + MOSPMFWrch)
        ]
        MOV     R0,R0                   ;NOP for PC+8
  |
a1293 1
  ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@
